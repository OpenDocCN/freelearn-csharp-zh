- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controlling Flow, Converting Types, and Handling Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is all about writing code that performs simple operations on variables,
    makes decisions, performs pattern matching, and repeats statements or blocks.
    You will also learn how to work with arrays to store multiple values, how to convert
    variable or expression values from one type to another, how to handle exceptions,
    and how to check for overflows in number variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Operating on variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding selection statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding iteration statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing multiple values in an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting and converting between types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for overflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating on variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Operators** apply simple operations such as addition and multiplication to
    **operands** such as variables and literal values. Operators return a new value
    that is the result of the operation and can be assigned to a variable, and they
    can also affect the operands.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding binary operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most operators are **binary**, meaning that they work on two operands, as shown
    in the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Examples of binary operators include adding and multiplying, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Understanding unary operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some operators are **unary**, meaning they work on a single operand and can
    be applied before or after the operand, as shown in the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Examples of unary operators include incrementors and retrieving a type or its
    size in bytes, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Understanding ternary operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **ternary** operator works on three operands, as shown in the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of a ternary operator is the conditional operator `?:`, which acts
    like a simplified `if` statement. The first operand is a Boolean expression, the
    second operand is a value to return if it is `true`, and the third operand is
    a value to return if it is `false`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: More experienced C# developers adopt ternary operators as much as possible because
    they are concise and can result in cleaner code once you are used to reading them.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring unary operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two common unary operators are used to increment, `++`, and decrement, `--`,
    a number. Let us write some example code to show how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve completed the previous chapters, then you will already have a `cs13net9`
    folder. If not, then you’ll need to create it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a new solution and project, as defined
    in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console App** / `console`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `Operators`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter03`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not use top-level statements**: Cleared'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable native AOT publish**: Cleared'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `Operators.csproj`, add a new `<ItemGroup>` section to statically import
    `System.Console` for all C# files using the `implicit usings` .NET SDK feature,
    as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, delete the existing statements and then declare two integer
    variables named `a` and `b`; set `a` to `3`, increment `a` while assigning the
    result to `b`, and then output their values, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: I recommend wrapping the statements for each section in
    `#region` and `#endregion` (as shown in the preceding code) so that you can easily
    collapse the sections. But I will not show this in future code tasks to save space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before running the console app, ask yourself a question: what do you think
    the value of `b` will be when output? Once you’ve thought about that, run the
    code and compare your prediction against the actual result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The variable `b` has the value `3` because the `++` operator executes *after*
    the assignment; this is known as a **postfix operator**. If you need to increment
    *before* the assignment, then use the **prefix operator**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy and paste the statements, and then modify them to rename the variables
    and use the prefix operator, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rerun the code and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Due to the confusion between the prefix and postfix for
    the increment and decrement operators when combined with an assignment, the Swift
    programming language designers decided to drop support for this operator in version
    3\. My recommendation for usage in C# is to never combine the use of the `++`
    and `--` operators with an assignment operator, `=`. Perform the operations as
    separate statements.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring binary arithmetic operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Increment and decrement are unary arithmetic operators. Other arithmetic operators
    are usually binary and allow you to perform arithmetic operations on two numbers,
    as the following shows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to declare and assign values to two integer variables named
    `e` and `f`, and then apply the five common binary arithmetic operators to the
    two numbers, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To understand the divide `/` and modulo `%` operators when applied to integers,
    you need to think back to primary school. Imagine you have eleven sweets and three
    friends.
  prefs: []
  type: TYPE_NORMAL
- en: How can you divide the sweets between your friends? You can give three sweets
    to each of your friends, and there will be two left over. Those two sweets are
    the **modulus**, also known as the **remainder** after dividing. If you had twelve
    sweets, then each friend would get four of them, and there would be none left
    over, so the remainder would be zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to declare and assign a value to a `double` variable named `g`
    to show the difference between whole-number and real-number divisions, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the first operand is a floating-point number, such as `g` with the value
    `11.0`, then the divide operator returns a floating-point value, such as `3.6666666666665`,
    rather than a whole number.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have already been using the most common assignment operator, `=`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make your code more concise, you can combine the assignment operator with
    other operators like arithmetic operators, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Null-coalescing operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Related operators to the assignment operators are the null-coalescing operators.
    Sometimes, you want to either assign a variable to a result or, if the variable
    is `null`, assign an alternative value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this using the null-coalescing operators, `??` or `??=`, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Exploring logical operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Logical operators operate on Boolean values, so they return either `true` or
    `false`. Let’s explore binary logical operators that operate on two Boolean values,
    traditionally named `p` and `q` in mathematics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to declare two Boolean variables, `p` and `q`,
    with values of `true` and `false`, and then output truth tables showing the results
    of applying AND, OR, and XOR (exclusive OR) logical operators, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember that `,-5` means left-align within a five-width column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the AND `&` logical operator, both operands must be `true` for the result
    to be `true`. For the OR `|` logical operator, either operand can be `true` for
    the result to be `true`. For the XOR `^` logical operator, either operand can
    be `true` (but not both!) for the result to be `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring conditional logical operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conditional logical operators are like logical operators, but you use two symbols
    instead of one, for example, `&&` instead of `&`, or `||` instead of `|`.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 4*, *Writing, Debugging, and Testing Functions*, you will learn
    about functions in more detail, but I need to introduce functions now to explain
    conditional logical operators, also known as short-circuiting Boolean operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function executes statements and then returns a value. That value could be
    a Boolean value like `true` that is used in a Boolean operation. Let’s make use
    of conditional logical operators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, write statements to declare a function that
    writes a message to the console and returns `true`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Local functions can be anywhere within the statements in `Program.cs` that use
    the top-level program feature but it is good practice to put them at the bottom
    of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the previous `WriteLine` statements, perform an AND `&` operation on
    the `p` and `q` variables, and the result of calling the function, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, view the result, and note that the function was called twice,
    once for `p` and once for `q`, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy and paste the three statements and then change the `&` operators into
    `&&` operators, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, view the result, and note that the function does run when combined
    with the `p` variable. It does not run when combined with the `q` variable because
    the `q` variable is `false` so the result will be `false` anyway, so it does not
    need to execute the function, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Now you can see why the conditional logical operators are
    described as being short-circuiting. They can make your apps more efficient, but
    they can also introduce subtle bugs in cases where you assume that the function
    will always be called. It is safest to avoid them when used in combination with
    functions that cause side effects.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exploring bitwise and binary shift operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bitwise operators compare the bits in the binary representation of a number.
    Each bit, either the `0` (zero) or `1` (one) value, is compared individually to
    the bit in the same column.
  prefs: []
  type: TYPE_NORMAL
- en: Binary shift operators can perform some common arithmetic calculations much
    faster than traditional operators, for example, any multiplication by a factor
    of 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore bitwise and binary shift operators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to declare two integer variables named `x`
    and `y` with values `10` and `6`, and then output the results of applying AND,
    OR, and XOR bitwise operators, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember that `,7` means right-align in a seven-width column and `:B8` means
    format in binary with eight digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For `x & y`, only the 2-bit column is set. For `x | y`, the 8-, 4-, and 2-bit
    columns are set. For `x ^ y`, the 8- and 4-bit columns are set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to output the results of applying the left-shift
    operator to move the bits of the variable `x` by three columns, multiplying `x`
    by 8, and right-shifting the bits of the variable `y` by one column, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `80` result is because the bits in it were shifted three columns to the
    left, so the 1 bits moved into the 64- and 16-bit columns, and 64 + 16 = 80\.
    This is the equivalent of multiplying by 8, but CPUs can perform a bit-shift faster.
    The `3` result is because the 1 bits in `y` were shifted one column into the 2-
    and 1-bit columns.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Remember that when operating on integer values, the `&`
    and `|` symbols are bitwise operators, and when operating on Boolean values like
    `true` and `false`, the `&` and `|` symbols are logical operators.'
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`nameof` and `sizeof` are convenient operators when working with types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nameof` returns the short name (without the namespace) of a variable, type,
    or member as a `string` value, which is useful when outputting exception messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sizeof` returns the size in bytes of simple types, which is useful for determining
    the efficiency of data storage. Technically, the `sizeof` operator requires an
    unsafe code block, but the sizes of value types with a C# alias, like `int` and
    `double`, are hardcoded as constants by the compiler so they do not need an unsafe
    block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many other operators; for example, the dot between a variable and
    its members is called the **member access operator** and the round brackets at
    the end of a function or method name are called the **invocation operator**, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Understanding selection statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every application needs to be able to select from choices and branch along different
    code paths. The two selection statements in C# are `if` and `switch`. You can
    use `if` for all your code, but `switch` can simplify your code in some common
    scenarios, such as when there is a single variable that can have multiple values
    that each require different processing.
  prefs: []
  type: TYPE_NORMAL
- en: Branching with the if statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `if` statement determines which branch to follow by evaluating a Boolean
    expression. If the expression is `true`, then the block executes. The `else` block
    is optional, and it executes if the `if` expression is `false`. The `if` statement
    can be nested.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if` statement can be combined with other `if` statements as `else if`
    branches, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Each `if` statement’s Boolean expression is independent of the others and, unlike
    `switch` statements, does not need to reference a single value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write some code to explore selection statements like `if`:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `SelectionStatements` to the `Chapter03` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember to statically import `System.Console` in your project file. If you
    are using Visual Studio, then configure the startup project to be the current
    selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements and then add statements to
    check if a password is at least eight characters long, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Why you should always use braces with if statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As there is only a single statement inside each block, the preceding code could
    be written without the curly braces, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This style of `if` statement should be avoided because it can introduce serious
    bugs. An infamous example is the #gotofail bug in Apple’s iPhone iOS operating
    system. For 18 months after Apple’s iOS 6 was released, in September 2012, it
    had a bug due to an `if` statement without braces in its **Secure Sockets Layer**
    (**SSL**) encryption code. This meant that any user running Safari, the device’s
    web browser, who tried to connect to secure websites, such as their bank, was
    not properly secure because an important check was being accidentally skipped.'
  prefs: []
  type: TYPE_NORMAL
- en: Just because you can leave out the curly braces, doesn’t mean you should. Your
    code is not “more efficient” without them; instead, it is harder to read, less
    maintainable, and, potentially, more dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching with the if statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A feature introduced with C# 7 and later is pattern matching. The `if` statement
    can use the `is` keyword in combination with declaring a local variable to make
    your code safer. It is important to note that a single expression, for example,
    `o is int i`, does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Checks the type of the data in a variable named `o`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the type check is `true`, then it assigns the value to the variable named
    `i`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**More Information**: You can learn more about the `is` operator at the following
    link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/is](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/is).
    You will use this technique in later chapters, so keep this in mind.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements so that if the value stored in the variable named `o` is an
    `int`, then the value is assigned to the local variable named `i`, which can then
    be used inside the `if` statement. This is safer than using the variable named
    `o` because we know for sure that `i` is an `int` variable and not something else,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Delete the double-quote characters around the `"3"` value so that the value
    stored in the variable named `o` is an `int` type instead of a `string` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rerun the code to view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Branching with the switch statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `switch` statement is different from the `if` statement because `switch`
    compares a single expression against a list of multiple possible `case` statements.
    Every `case` statement is related to the single expression. Every `case` section
    must end with one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `break` keyword (like `case 1` in the following code).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `goto` `case` keywords (like `case 2` in the following code).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They should have no statements (like `case 3` in the following code).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `goto` keyword that references a named label (like `case 5` in the following
    code).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `return` keyword to leave the current function (not shown in the code).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s write some code to explore the `switch` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following code for a `switch` statement. You should note that the
    penultimate statement is a label that can be jumped to, and the first statement
    generates a random number between 1 and 6 (the number 7 in the code is an exclusive
    upper bound). The `switch` statement branches are based on the value of this random
    number, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: You can use the `goto` keyword to jump to another case or
    a label. The `goto` keyword is frowned upon by most programmers but can be a good
    solution to code logic in some scenarios. However, you should use it sparingly,
    if at all. To see how often Microsoft uses `goto` in the .NET base class libraries,
    use the following link: [https://github.com/search?q=%22goto%20%22+repo%3Adotnet%2Fruntime+language%3AC%23&type=code&ref=advsearch](https://github.com/search?q=%22goto%20%22+repo%3Adotnet%2Fruntime+language%3AC%23&type=code&ref=advsearch).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code multiple times to see what happens in various cases of random
    numbers, as shown in the following example output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: The `Random` class that we used to generate a random number
    has a `Next` method that allows you to specify an inclusive lower bound and an
    exclusive upper bound and will generate a pseudo-random number. Instead of creating
    a new instance of `Random` that is not thread-safe, since .NET 6, you can use
    a `Shared` instance that is thread-safe so it can be used concurrently from any
    thread.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s take a small diversion from the `switch` keyword to review how to
    add a new item to a project using Visual Studio because, in the next code task,
    you need to add a new class file to your project and I haven’t shown you how to
    do that yet.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new item to a project using Visual Studio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Visual Studio version 17.6 or later has an optional simplified dialog box for
    adding a new item to a project. After navigating to **Project** | **Add New Item…**,
    or right-clicking on a project in **Solution Explorer** and selecting **Add**
    | **New Item…**, you will see the traditional dialog box, as shown in *Figure
    3.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Add New Item dialog box in normal view'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click the **Show Compact View** button, then it switches to a simplified
    dialog box, as shown in *Figure 3.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Add New Item dialog box in compact view'
  prefs: []
  type: TYPE_NORMAL
- en: To revert to the normal dialog box, click the **Show All Templates** button.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching with the switch statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like the `if` statement, the `switch` statement supports pattern matching in
    C# 7 and later. The `case` values no longer need to be literal values; they can
    be patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In C# 7 and later, your code can more concisely branch, based on the subtype
    of a class, and you can declare and assign a local variable to safely use it.
    Additionally, `case` statements can include a `when` keyword to perform more specific
    pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of pattern matching with the `switch` statement using
    a custom class hierarchy of animals with different properties:'
  prefs: []
  type: TYPE_NORMAL
- en: You will learn more details about defining classes in *Chapter 5*, *Building
    Your Own Types with Object-Oriented Programming*. For now, you should be able
    to get the idea from reading the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `SelectionStatements` project, add a new class file named `Animals.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, navigate to **Project** | **Add New Item…** or press *Ctrl*
    + *Shift* + *A*, type the name, and then click **Add**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In VS Code, click the **New File…** button and type the name.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In Rider, right-click on the project and select **Add** | **Class/Interface…**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `Animals.cs`, delete any existing statements, and then define three classes,
    a base class, `Animal`, and two inherited classes, `Cat` and `Spider`, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since this section is about pattern matching and not the most common way to
    define a class with fields, it is not important how the data types are declared.
    The `Name` property has been declared nullable and the other two properties are
    not. You could make the `Name` not-nullable and make the other two nullable and
    the pattern-matching example is unaffected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to declare an array of nullable animals, and
    then show a message based on what type and attributes each animal has, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice:** Always put the `default` at the end of a `switch` statement.
    I wrote the preceding `switch` statement with the `default` in the middle of the
    set of branches deliberately to show that the compiler will accept this, and will
    always move it to the end of the set of branches for you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `case` statement shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`case Cat fourLeggedCat when fourLeggedCat.Legs == 4:`'
  prefs: []
  type: TYPE_NORMAL
- en: 'can also be written using the more concise property pattern-matching syntax,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`case Cat { Legs: 4 } fourLeggedCat:`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note that the array named `animals` is declared to contain
    the `Animal?` type, so it could be any subtype of `Animal`, such as `Cat` or `Spider`,
    or a `null` value. In this code, we create four instances of `Animal` of different
    types with different properties, and one `null` one, so the result will be five
    messages that describe each of the animals, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Simplifying switch statements with switch expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In C# 8 or later, you can simplify `switch` statements using **switch expressions**.
  prefs: []
  type: TYPE_NORMAL
- en: Most `switch` statements are very simple, yet they require a lot of typing.
    `switch` expressions are designed to simplify the code you need to type while
    still expressing the same intent in scenarios where all cases return a value to
    set a single variable. `switch` expressions use a lambda, `=>`, to indicate a
    return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement the previous code that used a `switch` statement using a `switch`
    expression so that you can compare the two styles:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, at the bottom and inside the `foreach` loop, add statements
    to set the message based on what type and attributes the animal has, using a `switch`
    expression, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The main differences are the removal of the `case` and `break` keywords. The
    underscore character `_` is used to represent the default return value. It is
    known as a **discard** and you can read more about it at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/discards).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, and note that the result is the same as before, as shown in the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Understanding iteration statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Iteration statements repeat a block of statements either while a condition is
    `true` (`while` and `for` statements) or for each item in a collection (`foreach`
    statement). The choice of which statement to use is based on a combination of
    ease of understanding to solve the logic problem and personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: Looping with the while statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `while` statement evaluates a Boolean expression and continues to loop
    while it is true. Let’s explore iteration statements:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `IterationStatements` to the `Chapter03` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements, and then add statements to
    define a `while` statement that loops while an integer variable has a value less
    than 10, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the results, which should be the numbers 0 to 9, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Looping with the do statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `do` statement is like `while`, except the Boolean expression is checked
    at the bottom of the block instead of the top, which means that the block always
    executes at least once, as the following shows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to define a `do` loop, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and note that you are prompted to enter your password repeatedly
    until you enter it correctly, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As an optional challenge, add statements so that the user can only make three
    attempts before an error message is displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, you might want to comment out the code for this section so you
    do not have to keep entering a password every time you run the console app!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Looping with the for statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `for` statement is like `while`, except that it is more succinct. It combines:'
  prefs: []
  type: TYPE_NORMAL
- en: An optional **initializer expression**, which executes once at the start of
    the loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional **conditional expression**, which executes on every iteration at
    the start of the loop to check whether the looping should continue. If the expression
    returns `true` or it is missing, the loop will execute again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional **iterator expression**, which executes on every loop at the bottom
    of the statement. This is often used to increment a counter variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `for` statement is commonly used with an integer counter. Let’s explore
    some code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type a `for` statement to output the numbers 1 to 10, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code to view the result, which should be the numbers 1 to 10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add another `for` statement to output the numbers 0 to 10, incrementing by
    3, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code to view the result, which should be the numbers 0, 3, 6, and 9.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, experiment with changing the initializer expression, conditional
    expression, or iterator expression to see their effects. Only change one thing
    at a time so that you can clearly see the effect produced.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Looping with the foreach statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `foreach` statement is a bit different from the previous three iteration
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: It is used to perform a block of statements on each item in a sequence, for
    example, an array or collection. Each item is usually read-only, and if the sequence
    structure is modified during iteration, for example, by adding or removing an
    item, then an exception will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to create an array of string variables and then output the
    length of each one, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Understanding how foreach works internally
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A developer who defines a type that represents multiple items, like an array
    or collection, should make sure that a programmer can use the `foreach` statement
    to enumerate through the type’s items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, the `foreach` statement will work on any type that follows these
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The type must have a method named `GetEnumerator` that returns an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The returned object must have a property named `Current` and a method named
    `MoveNext`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MoveNext` method must change the value of `Current` and return `true` if
    there are more items to enumerate through or return `false` if there are no more
    items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are interfaces named `IEnumerable` and `IEnumerable<T>` that formally
    define these rules, but technically, the compiler does not require the type to
    implement these interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler turns the `foreach` statement in the preceding example into something
    like the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Due to the use of an iterator and its read-only `Current` property, the variable
    declared in a `foreach` statement cannot be used to modify the value of the current
    item.
  prefs: []
  type: TYPE_NORMAL
- en: Storing multiple values in an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you need to store multiple values of the same type, you can declare an
    **array**. For example, you may do this when you need to store four names in a
    `string` array.
  prefs: []
  type: TYPE_NORMAL
- en: Working with single-dimensional arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code that you will write next will allocate memory for an array for storing
    four `string` values. It will then store `string` values at index positions 0
    to 3 (arrays usually have a lower bound of zero, so the index of the last item
    is one less than the length of the array).
  prefs: []
  type: TYPE_NORMAL
- en: 'We could visualize the array like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 | 1 | 2 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Kate | Jack | Rebecca | Tom |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.1: Visualization of an array of four string values'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Do not assume that all arrays count from zero. The most
    common type of array in .NET is **szArray**, a single-dimensional zero-indexed
    array, and these use the normal `[]` syntax. But .NET also has **mdArray**, a
    multi-dimensional array, and these do not have to have a lower bound of zero.
    These are rarely used, but you should know they exist.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it will loop through each item in the array using a `for` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at how to use an array:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `Arrays` to the `Chapter03` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements and then type statements to
    declare and use an array of `string` values, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Arrays are always of a fixed size at the time of memory allocation, so you need
    to decide how many items you want to store before instantiating them.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative to defining the array in three steps as above is to use array
    initializer syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the `for` loop, add a statement to declare, allocate memory, and instantiate
    the values of a similar array, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Change the `for` loop to use `names2`, run the console app, and note that the
    results are the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Working with multi-dimensional arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of a single-dimension array for storing a row of string values (or any
    other data type), what if we want to store a grid of values? Or a cube? Or even
    higher dimensions?
  prefs: []
  type: TYPE_NORMAL
- en: 'We could visualize a two-dimensional array, aka a grid, of `string` values
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | 0 | 1 | 2 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Alpha | Beta | Gamma | Delta |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Anne | Ben | Charlie | Doug |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Aardvark | Bear | Cat | Dog |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.2: Visualization of a two-dimensional array'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at how to use multi-dimensional arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, add statements to declare and instantiate a
    two-dimensional array of `string` values, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can discover the lower and upper bounds of this array using helpful methods,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then use these values in nested `for` statements to loop through the
    `string` values, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You must supply a value for every row and every column when it is instantiated,
    or you will get compile errors. If you need to indicate a missing `string` value,
    then use `string.Empty`. Or if you declare the array to be nullable `string` values
    by using `string?[]`, then you can also use `null` for a missing value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you cannot use the array initialization syntax, perhaps because you are
    loading values from a file or database, then you can separate the declaration
    of the array dimension and the allocation of memory from the assignment of values,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: When declaring the size of the dimensions, you specify the length, not the upper
    bound. The expression `new string[3,4]` means the array can have 3 items in its
    first dimension (0) with an upper bound of 2, and the array can have 4 items in
    its second dimension (1) with an upper bound of 3.
  prefs: []
  type: TYPE_NORMAL
- en: Working with jagged arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need a multi-dimensional array but the number of items stored in each
    dimension is different, then you can define an array of arrays, aka a jagged array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could visualize a jagged array as shown in *Figure 3.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_03_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Visualization of a jagged array'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at how to use a jagged array:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, add statements to declare and instantiate an
    array of arrays of `string` values, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can discover the lower and upper bounds of the array of arrays, and then
    each array with it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then use these values in nested `for` statements to loop through the
    `string` values, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: List pattern matching with arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, you saw how an individual object supports pattern matching
    against its type and properties. Pattern matching also works with arrays and collections.
  prefs: []
  type: TYPE_NORMAL
- en: Introduced with C# 11, list pattern matching works with any type that has a
    public `Length` or `Count` property and has an indexer using an `int` or `System.Index`
    parameter. You will learn about indexers in *Chapter 5*, *Building Your Own Types
    with Object-Oriented Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: When you define multiple list patterns in the same `switch` expression, you
    must order them so that the more specific one comes first, or the compiler will
    complain because a more general pattern will match the more specific pattern too,
    and make the more specific one unreachable.
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 3.3* shows examples of list pattern matching, assuming a list of `int`
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Example** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `[]` | Matches an empty array or collection. |'
  prefs: []
  type: TYPE_TB
- en: '| `[..]` | Matches an array or collection with any number of items, including
    zero, so `[..]` must come after `[]` if you need to switch on both. |'
  prefs: []
  type: TYPE_TB
- en: '| `[_]` | Matches a list with any single item. |'
  prefs: []
  type: TYPE_TB
- en: '| `[int item1]` or`[var item1]` | Matches a list with any single item and can
    use the value in the return expression by referring to `item1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `[7, 2]` | Matches exactly a list of two items with those values in that
    order. |'
  prefs: []
  type: TYPE_TB
- en: '| `[_, _]` | Matches a list with any two items. |'
  prefs: []
  type: TYPE_TB
- en: '| `[var item1, var item2]` | Matches a list with any two items and can use
    the values in the return expression by referring to `item1` and `item2`. |'
  prefs: []
  type: TYPE_TB
- en: '| `[_, _, _]` | Matches a list with any three items. |'
  prefs: []
  type: TYPE_TB
- en: '| `[var item1, ..]` | Matches a list with one or more items. Can refer to the
    value of the first item in its return expression by referring to `item1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `[var firstItem, .., var lastItem]` | Matches a list with two or more items.
    Can refer to the value of the first and last item in its return expression by
    referring to `firstItem` and `lastItem`. |'
  prefs: []
  type: TYPE_TB
- en: '| `[.., var lastItem]` | Matches a list with one or more items. Can refer to
    the value of the last item in its return expression by referring to `lastItem`.
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.3: Examples of list pattern matching'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see some examples in code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, add statements to define some arrays of `int`
    values, and then pass them to a method that returns descriptive text depending
    on the pattern that matches best, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In C# 6, Microsoft added support for expression-bodied function members. The
    `CheckSwitch` function above uses this syntax. In C#, lambdas are the use of the
    `=>` character to indicate a return value from a function. I will properly introduce
    this in *Chapter 4, Writing, Debugging, and Testing Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can learn more about list pattern matching at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns#list-patterns](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns#list-patterns).'
  prefs: []
  type: TYPE_NORMAL
- en: Trailing commas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The trailing comma after the last item in the `switch` expression is optional
    and the compiler will not complain about it.
  prefs: []
  type: TYPE_NORMAL
- en: Most languages, including C#, allow the code style of trailing commas. When
    multiple items are separated by commas (for example, when declaring an anonymous
    object, an array, collection initializers, enums, and switch expressions), C#
    allows you to have the trailing comma after the last item. This makes it easy
    to rearrange the order of the items without having to keep adding and removing
    commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read a discussion about allowing trailing commas for `switch` expressions
    back in 2018 at the following link: [https://github.com/dotnet/csharplang/issues/2098](https://github.com/dotnet/csharplang/issues/2098).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even JSON serializers have an option to allow this because it is so common
    to use, as discussed at the following link: [https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.allowtrailingcommas](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.allowtrailingcommas).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding inline arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inline arrays were introduced with C# 12; they are an advanced feature used
    by the .NET runtime team to improve performance. You are unlikely to use them
    yourself unless you are a public library author, but you will automatically benefit
    from others’ use of them.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: You can learn more about inline arrays at the following
    link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/inline-arrays](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-12.0/inline-arrays).'
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use slightly different syntax to declare different types of arrays, as shown
    in *Table 3.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type of array** | **Declaration syntax** |'
  prefs: []
  type: TYPE_TB
- en: '| One dimension | `datatype[]`, for example, `string[]` |'
  prefs: []
  type: TYPE_TB
- en: '| Two dimensions | `string[,]` |'
  prefs: []
  type: TYPE_TB
- en: '| Three dimensions | `string[,,]` |'
  prefs: []
  type: TYPE_TB
- en: '| Ten dimensions | `string[,,,,,,,,,]` |'
  prefs: []
  type: TYPE_TB
- en: '| Array of arrays, aka two-dimensional jagged array | `string[][]` |'
  prefs: []
  type: TYPE_TB
- en: '| Array of arrays of arrays, aka three-dimensional jagged array | `string[][][]`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.4: Summary of array declaration syntax'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are useful for temporarily storing multiple items, but collections are
    a more flexible option when adding and removing items dynamically. You don’t need
    to worry about collections right now, as we will cover them in *Chapter 8*, *Working
    with Common .NET Types*.
  prefs: []
  type: TYPE_NORMAL
- en: You can convert any sequence of items into an array using the `ToArray` extension
    method, which we will cover in *Chapter 11*, *Querying and Manipulating Data Using
    LINQ*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: If you do not need to dynamically add and remove items,
    then you should use an array instead of a collection like `List<T>` because arrays
    are more efficient in memory use and the items are stored contiguously, which
    can improve performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Casting and converting between types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will often need to convert values of variables between different types.
    For example, data input is often entered as text in the console, so it is initially
    stored in a variable of the `string` type, but it then needs to be converted into
    a date/time, number, or some other data type, depending on how it should be stored
    and processed.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you will need to convert between number types, like between an integer
    and a floating point, before performing calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Converting is also known as **casting**, and it has two varieties: **implicit**
    and **explicit**. Implicit casting happens automatically, and it is safe, meaning
    that you will not lose any information.'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit casting must be performed manually because it may lose information,
    for example, the precision of a number. By explicitly casting, you are telling
    the C# compiler that you understand and accept the risk.
  prefs: []
  type: TYPE_NORMAL
- en: Casting numbers implicitly and explicitly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implicitly casting an `int` variable into a `double` variable is safe because
    no information can be lost, as the following shows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `CastingConverting` to the `Chapter03` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements, then type statements to declare
    and assign an `int` variable and a `double` variable, and then implicitly cast
    the integer’s value when assigning it to the `double` variable, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Type statements to declare and assign a `double` variable and an `int` variable,
    and then implicitly cast the `double` value when assigning it to the `int` variable,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the error message, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This error message will also appear in the Visual Studio **Error List**, VS
    Code **PROBLEMS** window, or Rider **Problems** window.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot implicitly cast a `double` variable into an `int` variable because
    it is potentially unsafe and could lose data, like the value after the decimal
    point. You must explicitly cast a `double` variable into an `int` variable using
    a pair of round brackets around the type you want to cast the `double` type into.
    The pair of round brackets is the **cast operator**. Even then, you must be aware
    that the part after the decimal point will be trimmed off without warning because
    you have chosen to perform an explicit cast and therefore understand the consequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the assignment statement for the `d` variable to explicitly cast the
    variable `c` into an `int`, and add a comment to explain what will happen, as
    shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code to view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We must perform a similar operation when converting values between larger integers
    and smaller integers. Again, be aware that you might lose information because
    any value too big will have its bits copied and then be interpreted in ways that
    you might not expect!
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter statements to declare and assign a `long` (64-bit) integer variable to
    an `int` (32-bit) integer variable, both using a small value that will work and
    a too-large value that will not, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code to view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the value of `e` to 5 billion, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code to view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Five billion cannot fit into a 32-bit integer, so it overflows (wraps around)
    to about 705 million. It is all to do with the binary representation of integer
    numbers. You will see more examples of integer overflow and how to handle it later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How negative numbers are represented in binary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might have wondered why `f` had the value `-1` in the previous code. Negative,
    aka signed, numbers use the first bit to represent negativity. If the bit is `0`
    (zero), then it is a positive number. If the bit is `1` (one), then it is a negative
    number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write some code to illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter statements to output the maximum value for an `int` in decimal and binary
    number formats, then output the values `8` to `-8`, decrementing by one, and finally,
    output the minimum value for an `int`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `,12` and `,34` mean right-align within those column widths. `:B32`
    means format as binary padded with leading zeros to a width of 32.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code to view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that all the positive binary number representations start with `0` and
    all the negative binary number representations start with `1`. The decimal value
    `-1` is represented by all ones in binary. That is why when you have an integer
    too large to fit in a 32-bit integer, it becomes `-1`. But it’s not always the
    case that the result of this type of casting is `-1`. When casting from a wider
    integer data type to a narrower integer data type, the most significant extra
    bits get truncated. For example, if you’re casting from a 32-bit integer to a
    16-bit integer, the 16 **most significant bits (MSBs)** of the 32-bit integer
    will be truncated. The **least significant bits (LSBs)** represent the result
    of the casting. For instance, if you’re casting to a 16-bit integer, the 16 least
    significant bits of the original value will represent the result after casting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter statements to show an example of a `long` integer that, when cast to
    an `int`, gets truncated to a non-minus-one value, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code to view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**More Information**: If you are interested in learning more about how signed
    numbers can be represented in computer systems, then you can read the following
    article: [https://en.wikipedia.org/wiki/Signed_number_representations](https://en.wikipedia.org/wiki/Signed_number_representations).'
  prefs: []
  type: TYPE_NORMAL
- en: Converting with the System.Convert type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can only cast between similar types, for example, between whole numbers
    like `byte`, `int`, and `long`, or between a class and its subclasses. You cannot
    cast a `long` to a `string` or a `byte` to a `DateTime`.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to using the cast operator is to use the `System.Convert` type.
    The `System.Convert` type can convert to and from all the C# number types, as
    well as Booleans, strings, and date and time values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write some code to see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, statically import the `System.Convert` class, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, add an entry to `CastingConverting.csproj`, as shown in the
    following markup: `<Using Include="System.Convert" Static="true" />`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, type statements to declare and assign a value
    to a `double` variable, convert it into an integer, and then write both values
    to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: An important difference between casting and converting is that converting rounds
    the `double` value `9.8` up to `10` instead of trimming the part after the decimal
    point. Another is that casting can allow overflows while converting will throw
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Rounding numbers and the default rounding rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have now seen that the cast operator trims the decimal part of a real number
    and that the `System.Convert` method rounds up or down. However, what is the rule
    for rounding?
  prefs: []
  type: TYPE_NORMAL
- en: In British primary schools for children aged 5 to 11, pupils are taught to round
    *up* if the decimal part is .5 or higher and round *down* if the decimal part
    is less. Of course, these terms only make sense because, at that age, the pupils
    are only dealing with positive numbers. With negative numbers, these terms become
    confusing and should be avoided. This is why the .NET API uses the `enum` values
    `AwayFromZero`, `ToZero`, `ToEven`, `ToPositiveInfinity`, and `ToNegativeInfinity`
    for improved clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore if C# follows the same primary school rule:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to declare and assign an array of `double` values, convert
    each of them into an integer, and then write the result to the console, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have shown that the rule for rounding in C# is subtly different from the
    primary school rule:'
  prefs: []
  type: TYPE_NORMAL
- en: It always rounds *toward zero* if the decimal part is less than the midpoint
    .5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It always rounds *away from zero* if the decimal part is more than the midpoint
    .5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will round *away from zero* if the decimal part is the midpoint .5 and the
    non-decimal part is *odd*, but it will round *toward zero* if the non-decimal
    part is *even*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This rule is known as **Banker’s rounding**, and it is preferred because it
    reduces bias by alternating when it rounds toward or away from zero. Sadly, other
    languages such as JavaScript use the primary school rule.
  prefs: []
  type: TYPE_NORMAL
- en: Taking control of rounding rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can take control of the rounding rules by using the `Round` method of the
    `Math` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to round each of the `double` values using the “away from zero”
    rounding rule, also known as rounding “up,” and then write the result to the console,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can use a `foreach` statement to enumerate all the items in a multi-dimensional
    array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: For every programming language that you use, check its rounding
    rules. They may not work the way you expect! You can read more about `Math.Round`
    at the following link: [https://learn.microsoft.com/en-us/dotnet/api/system.math.round](https://learn.microsoft.com/en-us/dotnet/api/system.math.round).'
  prefs: []
  type: TYPE_NORMAL
- en: Converting from any type to a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common conversion is from any type into a `string` variable for outputting
    as human-readable text, so all types have a method named `ToString` that they
    inherit from the `System.Object` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `ToString` method converts the current value of any variable into a textual
    representation. Some types can’t be sensibly represented as text, so they return
    their namespace and type name instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s convert some types into a `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to declare some variables, convert them to their `string` representation,
    and write them to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Passing any object to the `WriteLine` method implicitly converts it into a `string`,
    so it is not necessary to explicitly call `ToString`. We are doing so here just
    to emphasize what is happening. Explicitly calling `ToString` does avoid a boxing
    operation, so if you are developing games with Unity, then that can help you avoid
    memory garbage collection issues.
  prefs: []
  type: TYPE_NORMAL
- en: Converting from a binary object to a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you have a binary object like an image or video that you want to either
    store or transmit, you sometimes do not want to send the raw bits because you
    do not know how those bits could be misinterpreted, for example, by the network
    protocol transmitting them or another operating system that is reading the stored
    binary object.
  prefs: []
  type: TYPE_NORMAL
- en: The safest thing to do is to convert the binary object into a `string` of safe
    characters. Programmers call this **Base64** encoding. Base64 is an encoding scheme
    that converts arbitrary bytes into text using a specific set of 64 characters.
    It’s widely used for data transfer and has long been supported through various
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Convert` type has a pair of methods, `ToBase64String` and `FromBase64String`,
    that perform this conversion for you. Let’s see them in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to create an array of bytes randomly populated with byte values,
    write each byte nicely formatted to the console, and then write the same bytes
    converted into Base64 to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, an `int` value would output assuming decimal notation, that is,
    Base10\. You can use format codes such as `:X2` to format the value using hexadecimal
    notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Base64 for URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Base64 is useful, but some of the characters it uses, like `+` and `/`, are
    problematic for certain uses, such as query strings in URLs, where these characters
    have special meanings.
  prefs: []
  type: TYPE_NORMAL
- en: To address this issue, the Base64Url scheme was created. It is similar to Base64
    but uses a slightly different set of characters, making it suitable for contexts
    like URLs.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: You can learn more about the Base64Url scheme at the
    following link: [https://base64.guru/standards/base64url](https://base64.guru/standards/base64url).'
  prefs: []
  type: TYPE_NORMAL
- en: '.NET 9 introduces the new `Base64Url` class, which offers a range of optimized
    methods for encoding and decoding data using the `Base64Url` scheme. For example,
    you can convert some arbitrary bytes into Base64Url, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Parsing from strings to numbers or dates and times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second most common conversion is from strings to numbers or date and time
    values.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite of `ToString` is `Parse`. Only a few types have a `Parse` method,
    including all the number types and `DateTime`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see `Parse` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, import the namespace for working with cultures,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom of `Program.cs`, add statements to parse an integer and a date
    and time value from strings, and then write the result to the console, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, a date and time value outputs with the short date and time format.
    You can use format codes such as `D` to output only the date part using the long
    date format.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Use the standard date and time format specifiers, as shown
    at the following link: [https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#table-of-format-specifiers](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#table-of-format-specifiers).'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Parse exceptions by using the TryParse method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One problem with the `Parse` method is that it gives errors if the `string`
    cannot be converted:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type a statement to attempt to parse a string containing letters into an integer
    variable, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As well as the preceding exception message, you will see a stack trace. I have
    not included stack traces in this book because they take up too much space.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid errors, you can use the `TryParse` method instead. `TryParse` attempts
    to convert the input `string` and returns `true` if it can convert it and `false`
    if it cannot. Exceptions are a relatively expensive operation so they should be
    avoided when possible.
  prefs: []
  type: TYPE_NORMAL
- en: The `out` keyword is required to allow the `TryParse` method to set the `count`
    variable when the conversion works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see `TryParse` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `int` `count` declaration with statements to use the `TryParse`
    method and ask the user to input a count for the number of eggs, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, enter `12`, and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, enter `twelve`, and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can also use methods of the `System.Convert` type to convert `string` values
    into other types; however, like the `Parse` method, it gives an error if it cannot
    convert.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Try method naming convention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '.NET uses a standard signature for all methods that follow the `Try` naming
    convention. For any method named `Something` that returns a value of a specific
    type, its matching `TrySomething` method must return a `bool` to indicate success
    or failure and use an `out` parameter in place of the return value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Handling exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve seen several scenarios where errors have occurred when converting types.
    Some languages return error codes when something goes wrong. .NET uses exceptions
    that are richer and designed only for failure reporting. When this happens, we
    say *a runtime exception has been thrown*.
  prefs: []
  type: TYPE_NORMAL
- en: Other systems might use return values that could have multiple uses. For example,
    if the return value is a positive number, it might represent the count of rows
    in a table, or if the return value is a negative number, it might represent some
    error code.
  prefs: []
  type: TYPE_NORMAL
- en: Some third-party libraries make it easier to define “result” types that can
    indicate errors as well as successes. Many .NET developers prefer to use them
    instead of throwing exceptions. You can learn more about this in an optional online
    section at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When an exception is thrown, the thread is suspended, and if the calling code
    has defined a `try-catch` statement, then it is given a chance to handle the exception.
    If the current method does not handle it, then its calling method is given a chance,
    and so on up the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen, the default behavior of a console app is to output a message
    about the exception, including a stack trace, and then stop running the code.
    The application is terminated. This is better than allowing the code to continue
    executing in a potentially corrupt state. Your code should only catch and handle
    exceptions that it understands and can properly fix.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Avoid writing code that will throw an exception whenever
    possible, perhaps by performing `if` statement checks. Sometimes you can’t, and
    sometimes it is best to allow the exception to be caught by a higher-level component
    that is calling your code. You will learn how to do this in *Chapter 4*, *Writing,
    Debugging, and Testing Functions*.'
  prefs: []
  type: TYPE_NORMAL
- en: In .NET 9, exception handling uses a new implementation based on the NativeAOT
    exception handling model. This improves exception handling performance by 2 to
    4 times in the .NET team’s benchmarks.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping error-prone code in a try block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you know that a statement can cause an error, you should wrap that statement
    in a `try` block. For example, parsing from text to a number can cause an error.
    Any statements in the `catch` block will be executed only if an exception is thrown
    by a statement in the `try` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don’t have to do anything inside the `catch` block. Let’s see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `HandlingExceptions` to the `Chapter03` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete any existing statements, and then type statements to
    prompt the user to enter their age and then write their age to the console, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following compiler message: `Warning CS8604 Possible null
    reference argument for parameter ''s'' in ''int int.Parse(string s)''`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, in .NET 6 or later projects, Microsoft enables nullable reference
    types, so you will see many more compiler warnings like this. In production code,
    you should add code to check for `null` and handle that possibility appropriately,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: In this book, I will not give instructions to add these `null` checks every
    time because the code samples are not designed to be production-quality, and having
    `null` checks everywhere will clutter the code and use up valuable pages.
  prefs: []
  type: TYPE_NORMAL
- en: You will probably see hundreds more examples of potentially `null` variables
    throughout the code samples in this book. Those warnings are safe to ignore for
    the book code examples. You only need to pay attention to similar warnings when
    you write your own production code. You will see more about null handling in *Chapter
    6*,*Implementing Interfaces and Inheriting Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, it is impossible for `input` to be `null` because the user must
    press *Enter* for `ReadLine` to return, and if they have not typed any characters
    at that point, then the `ReadLine` method will return an empty `string`. Let’s
    tell the compiler that it does not need to show us this warning:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable the compiler warning, change `input` to `input!`, as shown highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: An exclamation mark, `!`, after an expression is called the **null-forgiving
    operator** and it disables the compiler warning. The **null-forgiving operator**
    has no effect at runtime. If the expression could evaluate to `null` at runtime,
    perhaps because we assigned it in another way, then an exception would be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: This code includes two messages to indicate *before* parsing and *after* parsing
    to make the flow through the code clearer. These will be especially useful as
    the example code grows more complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, enter `49`, and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, enter `Kermit`, and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the code was executed, the error exception was caught, the default message
    and stack trace were not output, and the console app continued running. This is
    better than the default behavior, but it might be useful to see the type of error
    that occurred.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: You should never use an empty `catch` statement like this
    in production code because it “swallows” exceptions and hides potential problems.
    You should at least log the exception if you cannot or do not want to handle it
    properly, or rethrow it so that higher-level code can decide instead. You will
    learn about logging in *Chapter 4*,*Writing, Debugging, and Testing Functions*.'
  prefs: []
  type: TYPE_NORMAL
- en: Catching all exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get information about any type of exception that might occur, you can declare
    a variable of type `System.Exception` to the `catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an exception variable declaration to the `catch` block and use it to write
    information about the exception to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, enter `Kermit` again, and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Catching specific exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know which specific type of exception occurred, we can improve
    our code by catching just that type of exception and customizing the message that
    we display to the user. You can think of this as a form of testing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Leave the existing `catch` block and, above it, add a new `catch` block for
    the format exception type, as shown in the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, enter `Kermit` again, and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The reason we want to leave the more general `catch` below is that there might
    be other types of exceptions that can occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, enter `9876543210`, and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s add another `catch` block for this type of exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Leave the existing `catch` blocks, and add a new `catch` block for the overflow
    exception type, as shown in the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, enter `9876543210`, and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The order in which you catch exceptions is important. The correct order is related
    to the inheritance hierarchy of the exception types. You will learn about inheritance
    in *Chapter 5*,*Building Your Own Types with Object-Oriented Programming*. However,
    don’t worry too much about this—the compiler will give you build errors if you
    get exceptions in the wrong order anyway.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Avoid over-catching exceptions. They should often be allowed
    to propagate up the call stack to be handled at a level where more information
    is known about the circumstances that could change the logic of how they should
    be handled. You will learn about this in *Chapter 4*,*Writing, Debugging, and
    Testing Functions*.'
  prefs: []
  type: TYPE_NORMAL
- en: Catching with filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also add filters to a `catch` statement using the `when` keyword, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: The `Contains` method on the `string` type has overloads
    for both a `string` value that is passed using double-quotes and a `char` value
    that is passed using single-quotes. When you want to check for one character,
    like a dollar, it is more efficient to use the `char` overload as in the preceding
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: Checking for overflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we saw that when casting between number types, it was possible to lose
    information, for example, when casting from a `long` variable to an `int` variable.
    If the value stored in a type is too big, it will overflow.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing overflow exceptions with the checked statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `checked` statement tells .NET to throw an exception when an overflow happens
    instead of allowing it to happen silently, which is done by default for performance
    reasons.
  prefs: []
  type: TYPE_NORMAL
- en: We will set the initial value of an `int` variable to its maximum value minus
    one. Then, we will increment it several times, outputting its value each time.
    Once it gets above its maximum value, it overflows to its minimum value and continues
    incrementing from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, type statements to declare and assign an integer to one less
    than its maximum possible value, and then increment it and write its value to
    the console three times, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result that shows the value overflowing silently
    and wrapping around to large negative values, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s get the compiler to warn us about the overflow by wrapping the statements
    using a `checked` statement block, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result that shows the overflow being checked and
    causing an exception to be thrown, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just like any other exception, we should wrap these statements in a `try` statement
    block and display a nicer error message for the user, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Disabling compiler overflow checks with the unchecked statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous section was about the default overflow behavior at *runtime* and
    how to use the `checked` statement to change that behavior. This section is about
    *compile-time* overflow behavior and how to use the `unchecked` statement to change
    that behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'A related keyword is `unchecked`. This keyword switches off overflow checks
    performed by the compiler within a block of code. Let’s see how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following statement at the end of the previous statements. The compiler
    will not compile this statement because it knows it will overflow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Hover your mouse pointer over the error, and note that a compile-time check
    is shown as an error message, as shown in *Figure 3.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_03_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: A compile-time check for integer overflow'
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable compile-time checks, wrap the statement in an `unchecked` block,
    write the value of `y` to the console, decrement it, and repeat, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Of course, it would be rare that you would want to explicitly switch off a check
    like this because it allows an overflow to occur. But perhaps you can think of
    a scenario where you might want that behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with deeper research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.1 – Online material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Online material can be extra content written by me for this book, or it can
    be references to content created by Microsoft or third parties.
  prefs: []
  type: TYPE_NORMAL
- en: Returning result types versus throwing exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In .NET programming, handling errors often revolves around two primary mechanisms:
    exceptions and result types. Learn more about result types by reading the following
    online section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch03-result-types.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch03-result-types.md)'
  prefs: []
  type: TYPE_NORMAL
- en: C# 101 notebooks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the links to notebooks and videos at the following link to see interactive
    examples of C# using Polyglot Notebooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/dotnet/csharp-notebooks#c-101](https://github.com/dotnet/csharp-notebooks#c-101)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.2 – Practice exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Practice exercises go deeper into the topics for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Loops and overflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What will happen if this code executes?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Create a console app in `Chapter03` named `Exercise_LoopsAndOverflow` and enter
    the preceding code. Run the console app and view the output. What happens?
  prefs: []
  type: TYPE_NORMAL
- en: What code could you add (don’t change any of the preceding code) to warn us
    about the problem?
  prefs: []
  type: TYPE_NORMAL
- en: Practice loops and operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: FizzBuzz is a group game for children to teach them about division. Players
    take turns to count incrementally, replacing any number divisible by 3 with the
    word *fizz*, any number divisible by 5 with the word *buzz*, and any number divisible
    by both with *fizzbuzz*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a console app in `Chapter03` named `Exercise_FizzBuzz` that outputs
    a simulated FizzBuzz game that counts up to 100\. The output should look something
    like *Figure 3.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B22322_03_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: A simulated FizzBuzz game output'
  prefs: []
  type: TYPE_NORMAL
- en: Practice exception handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a console app in `Chapter03` named `Exercise_Exceptions` that asks the
    user for two numbers in the range 0–255 and then divides the first number by the
    second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Write exception handlers to catch any thrown errors, as shown in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 3.3 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you divide an `int` variable by `0`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens when you divide a `double` variable by `0`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens when you overflow an `int` variable, that is, set it to a value
    beyond its range?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `x = y++;` and `x = ++y;`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `break`, `continue`, and `return` when used inside
    a loop statement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three parts of a `for` statement and which of them are required?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `=` and `==` operators?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does the following statement compile?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What does the underscore (`_`) represent in a `switch` expression?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What interface must an object “implement” to be enumerated over by using the
    `foreach` statement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test your knowledge of operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What are the values of `x` and `y` after the following statements execute?
    Create a console app in `Chapter03` named `Ch03Ex03Operators` to test your assumptions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Increment and addition operators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Binary shift operators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Bitwise operators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Exercise 3.4 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn about the topics covered in this
    chapter in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-3---controlling-flow-converting-types-and-handling-exceptions](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-3---controlling-flow-converting-types-and-handling-exceptions)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use operators to perform simple tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use branch and loop statements to implement logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with single- and multi-dimensional arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert between types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catch exceptions and handle integer overflow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are now ready to learn how to reuse blocks of code by defining functions,
    how to pass values into them and get values back, and how to track down bugs in
    your code and squash them using debugging and testing tools!
  prefs: []
  type: TYPE_NORMAL
