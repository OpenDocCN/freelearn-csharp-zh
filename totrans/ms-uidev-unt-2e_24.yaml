- en: '19'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with IMGUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last UI system I will cover is **IMGUI** or **Immediate Mode Graphical User
    Interface**. The primary usage for IMGUI is to create tools that assist developers
    during development and debugging. While IMGUI can technically make runtime UI,
    it is strongly discouraged by Unity. So, for example, you can use it to make Editor
    extensions or debug menus that will run in your game’s view, and can be accessed
    when you play your game outside of the Editor. However, keep in mind these debug
    in-game menus are meant to be developer-facing, not player-facing. IMGUI is most
    commonly used for developing Editor UI extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Since this book’s primary focus is on runtime, player-facing UI, I won’t delve
    too deep into this system; however, I’ll cover the very basics of making developer-facing
    with IMGUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I will discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A general overview of how to use IMGUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most commonly used IMGUI Controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use IMGUI for Inspector UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to show debug frame rate text UI in your game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to put a button on an Inspector component and import data to a ScriptableObject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to note that IMGUI is not a recommended system by Unity. When
    it comes to runtime UI, they recommend uGUI (which is what the majority of this
    book is about), and when it comes to Editor UI, they recommend UI Toolkit (which
    was covered in [*Chapter 18*](B18327_18.xhtml#_idTextAnchor481)). So, learning
    IMGUI is not necessarily a required skill for anyone developing in Unity. It is
    especially not a required skill for non-programmers. However, it does give programmers
    a very quick way to build out UI to assist them in development, so the skills
    are not useless.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review some basic information about IMGUI.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the relevant codes and asset files of this chapter here: [https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2019](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2019)'
  prefs: []
  type: TYPE_NORMAL
- en: IMGUI overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I stated earlier, IMGUI gives programmers a quick way to build out UI that
    can assist them in their development. This is because IMGUI is built exclusively
    via code. It is not connected to GameObjects, and all objects are rendered via
    calls to an `OnGUI()` or `OnInspectorGUI()` method. The `OnGUI()` method is called
    every frame, similar to the `Update()` method.
  prefs: []
  type: TYPE_NORMAL
- en: If you want your IMGUI to appear within your scene, you write all your UI building
    code in an `OnGUI()` method within a `MonoBehaviour` inheriting script. Because
    IMGUI items are created via code, any UI you create with it on a `MonoBehaviour`
    script will not render until the game is run.
  prefs: []
  type: TYPE_NORMAL
- en: If you want your UI to appear in an Editor window, you will write all your UI
    building code in an `OnGUI()` method within an `EditorWindow` inheriting script.
    If you want your UI to appear in the Inspector, you write all your UI building
    code in an `OnInspectorGUI()` method within an `Editor` inheriting script.
  prefs: []
  type: TYPE_NORMAL
- en: 'All IMGUI items are created by calling their unique method within an `OnGUI()`
    or `OnInspectorGUI()` method. Each of their unique methods can be positioned and
    sized using rectangular position. When positioning an object with rectangular
    position, you first create a new Rectangle using the `Rect()` method. The `Rect()`
    method takes four parameters: `x` position, `y` position, `width`, and `height`.
    So, for example, you can create a new rectangle with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This would create a rectangle at screen coordinate `(10, 10)` with a width and
    height of `50`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, screen coordinates put position `(0,0)` in the top-left corner of
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `Vector2`s to specify the parameters. For example, you could
    do something like this to achieve the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to create IMGUI items, let’s review the types of items
    that you can draw using `OnGUI()`.
  prefs: []
  type: TYPE_NORMAL
- en: IMGUI Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The items drawn using IMGUI are called **Controls**. While the term “Controls”
    may imply the item is interactable, not all Controls are interactable. There are
    multiple Controls available with the IMGUI system, but you can accomplish most
    of your IMGUI goals with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Label`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Button`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RepeatButton`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextField`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextArea`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Toggle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a comprehensive list of all IMGUI controls here: [https://docs.unity3d.com/2023.3/Documentation/Manual/gui-Controls.xhtml](https://docs.unity3d.com/2023.3/Documentation/Manual/gui-Controls.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Label`, you call the `GUI.Label()`method. The `GUI.Label()` method has multiple
    overloads, but the primary ones you will use are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Where the first is used to define a text label, and the second is used to define
    an image label.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code will display a text label and an image label
    in a scene, when it is attached to a GameObject and the `labelTexture` variable
    is assigned in the Inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The labels will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.1: Using IMGUI Labels](img/B18327_19_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19.1: Using IMGUI Labels'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Button`, you call the `GUI.Button()` method. The `GUI.Button()` method has
    multiple overloads, but the primary ones you will use are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Where the first will be used to define a text button, and the second will be
    used to define an image button.
  prefs: []
  type: TYPE_NORMAL
- en: To execute code when a button is clicked, you create the button within an `if`
    statement within the `OnGUI()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code will display a text button and an image button
    in a scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Both buttons will write a message in the console each time they are clicked.
    The code must be attached to a GameObject and the `buttonTexture` variable must
    be assigned in the Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: 'The buttons created by the preceding code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.2: Using IMGUI Buttons](img/B18327_19_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19.2: Using IMGUI Buttons'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create a button that calls a method as it is clicked and held,
    you can use a `Button`. You can replace all instances of `GUI.Button` in the preceding
    code with `GUI.RepeatButton` and achieve a similar result, except the button will
    execute the method as long as the button is held.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TextField` is used when you want only a single line of editable text,
    whereas `TextArea` is used when you want multiple lines. To create a `TextField`
    or `TextArea`, you call the `GUI.TextField()` and `GUI.TextArea()` methods, respectively.
    The `GUI.TextField()` method has multiple overloads, but the primary ones you
    will use are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first method creates a `TextField`, and the second creates a `TextArea`.
    In both cases, the `string` parameter is the text that will be displayed before
    the user begins editing the text. Note that the method returns a `string` type.
    You can get the value of what is entered by the user by assigning the constructed
    object to a `string` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code will display a `TextField` and `TextArea` you
    can interact with in your scene when it is attached to a GameObject:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The items rendered in the scene appear as follows before the user starts editing
    the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.3: Using the IMGUI TextField and TextArea Controls](img/B18327_19_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19.3: Using the IMGUI TextField and TextArea Controls'
  prefs: []
  type: TYPE_NORMAL
- en: '`Toggle`, you call the `GUI.Toggle()` method. The `GUI.Toggle()` method has
    multiple overloads, but the primary ones you will use are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that the method returns a `bool` type. You can get the value of the toggle
    by assigning the created object to a `bool` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code will create a toggle whose value is assigned
    to a Boolean variable whenever the toggle is clicked. This example, like the other
    examples, would need to be attached to a GameObject in your scene to render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The toggle will initially render in the scene as follows until the user interacts
    with it, in which case the toggle will turn on and off with each click.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.4: Using the IMGUI Toggle Control](img/B18327_19_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19.4: Using the IMGUI Toggle Control'
  prefs: []
  type: TYPE_NORMAL
- en: All the examples I have shown were in the scene. However, if you want to display
    your UI in an Editor window, your code will work similarly. You simply put your
    code in an `EditorWindow` inheriting script. (See the example covered in [*Chapter
    18*](B18327_18.xhtml#_idTextAnchor481).) However, it is slightly different if
    you want to create IMGUI in your Inspector. Let’s look at that now.
  prefs: []
  type: TYPE_NORMAL
- en: IMGUI in the Inspector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using IMGUI to enhance your components works very similarly to the way it does
    with in-game IMGUI and `EditorWindow` IMGUI. However, there are some small changes.
    First, you write scripts that inherit from `Editor`. Second, you use the `OnInspectorGUI()`
    method, not the `OnGUI()` method. Third, if you want the Inspector to also contain
    all its usual data, you need to call the `DrawDefaultInspector()` method within
    your `OnInspectorGUI()` method. Lastly, if you want the IMGUI button to appear
    in line with the various default Inspector elements, you use the `GUILayout` base
    class, rather than the `GUI` base class. So, for example, you wouldn’t create
    a button with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, you’d create it with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Buttons created with `GUILayout` do not require a rectangular position and will
    automatically be positioned within the UI.
  prefs: []
  type: TYPE_NORMAL
- en: I will cover an example of this in the *Examples* section.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have enough basic background information to begin developing developer-facing
    UI with IMGUI. Let’s look at some basic examples to get you started on using the
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the examples in this chapter, I will cover two types of IMGUI usages: one
    for an in-game debug menu and another for an Inspector UI. All the examples covered
    up to this point have all been in-game debug menu UI.'
  prefs: []
  type: TYPE_NORMAL
- en: Using IMGUI to show framerate in-game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s create a very simple script that will show the frame rate of our game
    in the scene. It will change color if the framerate drops below a certain value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the framerate in your game, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene called `Chapter19-Examples.unity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the new scene, create a new GameObject called `DebugMenu`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new script called `DebugFrameRate.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the `DebugFrameRate.cs` script to your `DebugMenu` GameObject as a component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the new script and add the following variable declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `fps` variable is used to get an estimate of our game’s frame rate, while
    the `fpsThreshold` variable is assigned in the Inspector and used to determine
    the threshold for when our fps will display as red in the scene.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an IMGUI `Label` that will display the fps with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s calculate the fps. We can get an estimate of the fps with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Play your game, and you should see the fps displayed in the scene. If you open
    the **Stats** window, you should see that the values are relatively close.![Figure
    19.5: The frame rate displaying in-game](img/B18327_19_05.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 19.5: The frame rate displaying in-game'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It’s slightly difficult to see what the value is without pausing the game. So,
    let’s make it change color when it drops below a certain value. This will make
    it easier to see when there is a framerate we find worrisome. We’ll use the `fpsThreshold`
    value for this. Your game running in your Editor may run at a different framerate
    than mine, so please use a value that makes sense for your system to be able to
    see the code execute. I’m going to use `1000`. Enter the value for your `fpsThreshould`
    in the Inspector.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s make it change color when it goes below that threshold. Add the
    following `if`/`else` statement to the top of your `OnGUI()` method, before the
    label is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And that’s all you need to have a framerate estimate display in your game.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a framerate for your game is a great example of something you might
    want to make with an in-game debug UI. This will let you easily see the general
    performance of your game, even when you run it outside of the Editor. You could
    extend this to only appear when you perform specific tasks or only update every
    second. The possibilities are endless.
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of other reasons you may want to use an in-game debug menu. For
    example, you might want buttons that call functions that help you skip to sections
    of your game. Or maybe you want a button that clears your saved data. The important
    thing to remember about making in-game UI with IMGUI is this should all be to
    help you, the developer, but should not be used to display information to your
    player.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at an example of something you can do in your Editor to assist
    your development.
  prefs: []
  type: TYPE_NORMAL
- en: Using IMGUI to make an Inspector button that imports data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often in game development, you will have data stored in some external source
    and need to import it into a usable format within your game’s code. For example,
    you may have a writer on your team who creates all dialogue in an Excel sheet,
    which you then need to figure out how to import into your game. This example will
    show a basic example that uses an Inspector button to read text from a file and
    distribute it to the appropriate place within your game, specifically a ScriptableObject.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.6: A custom Inspector with an import button](img/B18327_19_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19.6: A custom Inspector with an import button'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t really discussed ScriptableObjects in this text. A ScriptableObject
    is essentially a data container within Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a button that imports data into your ScriptableObject, complete the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# script called `DialogueData.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder in your `Assets` folder called `Data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the code files, find the text file called `SampleDialogue.txt`. Import
    it into your `Data` folder. Alternatively, you can create a text file with at
    least three lines of text and place it into this folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your `DialogueData.cs` script and change it so that it inherits from `Monobehavior`
    to `ScriptableObject`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following two lines of code to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ll use the `textPath` variable to define where the text file being imported
    is within our project and the `importedDialogue` variable to hold all the imported
    dialogue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following line above the class definition, to create a menu that makes
    `DialogueData` ScriptableObjects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, return to your Editor and create a new ScriptableObject by right-clicking
    within your `Data` folder and selecting **Create** | **DialogueData**.![Figure
    19.7: Creating the DialogueData ScriptableObject](img/B18327_19_07.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 19.7: Creating the DialogueData ScriptableObject'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This will create a new ScriptableObject called `New SO` with the following
    Inspector:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 19.8: The ScriptableObject’s Inspector](img/B18327_19_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 19.8: The ScriptableObject’s Inspector'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let’s customize the Inspector with an import button. Create a new script
    called `DialogueDataCustomEditor.cs` and save it in your `Editor` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the script and make it inherit from `Editor` instead of `Monobehavior`,
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure to add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, to let the script know that it is a custom Inspector for the `DialogueData`
    class, add the following above the class definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to your script to display a button in the Inspector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you return to your `New SO`, you’ll see that the Inspector only contains
    a button now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 19.9: The button in the Inspector](img/B18327_19_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19.9: The button in the Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: 'It no longer displays all of the data that we want to show in the Inspector.
    So, add the following, above your button code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It should now draw the button on top of the default Inspector information,
    which is not what we want.![Figure 19.10: The button in the Inspector over the
    default information](img/B18327_19_10.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 19.10: The button in the Inspector over the default information'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit the button code to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will cause the button to display at the bottom of the component, utilizing
    the layout of the Unity GUI instead of being explicitly positioned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 19.11: The button using the GUILayout base class](img/B18327_19_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 19.11: The button using the GUILayout base class'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we just need to import the dialogue. Add the following variable declaration
    to your code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will use this variable to correctly parse the data in the text file, making
    sure each new line is a new line of dialogue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we need to add code that will first get the data from the file and then
    send it to the ScriptableObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, update your `OnInspectorGUI()` method to call the `ReadString()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to add the location of the `SampleDialogue.txt` file to our ScriptableObject.
    Right-click on `SampleDialogue.txt` and select **Copy Path**. Paste it into the
    **Text** **Path** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 19.12: The textPath variable assigned in the Inspector](img/B18327_19_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19.12: The textPath variable assigned in the Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: We should be good to go. Click on the **Import Dialogue** button and the dialogue
    will now import. Your Inspector should appear like *Figure 19**.6*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And that’s it for using IMGUI to create a button within the Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how to use the IMGUI system to build UI for both
    developers, in-game debug displays as well as Editor extensions. While IMGUI is
    not necessarily a recommended UI system, it is extremely helpful for creating
    super-quick tools to assist developers during the development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will look at the other input system provided by Unity:
    the New Input System.'
  prefs: []
  type: TYPE_NORMAL
