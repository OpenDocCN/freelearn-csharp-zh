["```cs\nProperties \n{\n  _MainTex(\"Texture\", 2D) = \"white\" \n}\n```", "```cs\n#pragma surface surf SimpleLambert  \n```", "```cs\nvoid surf(Input IN, inout SurfaceOutput o) { \n  o.Albedo = tex2D(_MainTex, IN.uv_MainTex).rgb; \n} \n```", "```cs\n// Allows us to use the SimpleLambert lighting mode\nhalf4 LightingSimpleLambert (SurfaceOutput s, half3 lightDir, \n                             half atten) \n{ \n  // First calculate the dot product of the light direction and the \n  // surface's normal\n  half NdotL = dot(s.Normal, lightDir); \n\n  // Next, set what color should be returned\n  half4 color; \n\n  color.rgb = s.Albedo * _LightColor0.rgb * (NdotL * atten); \n  color.a = s.Alpha; \n\n  // Return the calculated color\n  return color; \n} \n```", "```cs\n_RampTex (\"Ramp\", 2D) = \"white\" {} \n```", "```cs\nsampler2D _RampTex; \n```", "```cs\n#pragma surface surf Toon \n```", "```cs\nfixed4 LightingToon (SurfaceOutput s, fixed3 lightDir, \n            fixed atten) \n{ \n  // First calculate the dot product of the light direction and the \n  // surface's normal\n  half NdotL = dot(s.Normal, lightDir); \n\n  // Remap NdotL to the value on the ramp map\n  NdotL = tex2D(_RampTex, fixed2(NdotL, 0.5)); \n\n  // Next, set what color should be returned\n  half4 color; \n\n  color.rgb = s.Albedo * _LightColor0.rgb * (NdotL * atten ); \n  color.a = s.Alpha; \n\n  // Return the calculated color\n  return color; \n} \n```", "```cs\nhalf4 LightingCustomLambert (SurfaceOutput s, half3 lightDir, \n                half3 viewDir, half atten) \n{ \n  half NdotL = dot (s.Normal, lightDir); \n\n  // Snap instead\n  half cel = floor(NdotL * _CelShadingLevels) / \n             (_CelShadingLevels - 0.5); \n\n  // Next, set what color should be returned\n  half4 color; \n\n  color.rgb = s.Albedo * _LightColor0.rgb * (cel * atten ); \n  color.a = s.Alpha; \n\n  // Return the calculated color\n  return color; \n} \n```", "```cs\nProperties \n{ \n  _MainTint (\"Diffuse Tint\", Color) = (1,1,1,1) \n  _MainTex (\"Base (RGB)\", 2D) = \"white\" {} \n  _SpecularColor (\"Specular Color\", Color) = (1,1,1,1) \n  _SpecPower (\"Specular Power\", Range(0,30)) = 1 \n} \n```", "```cs\nfloat4 _SpecularColor; \nsampler2D _MainTex; \nfloat4 _MainTint; \nfloat _SpecPower; \n```", "```cs\nfixed4 LightingPhong (SurfaceOutput s, fixed3 lightDir, \n                      half3 viewDir, fixed atten) \n{ \n  // Reflection \n  float NdotL = dot(s.Normal, lightDir); \n  float3 reflectionVector = normalize(2.0 * s.Normal * \n     NdotL - lightDir); \n\n  // Specular \n  float spec = pow(max(0, dot(reflectionVector, viewDir)), \n     _SpecPower); \n  float3 finalSpec = _SpecularColor.rgb * spec; \n\n  // Final effect \n  fixed4 c; \n  c.rgb = (s.Albedo * _LightColor0.rgb * max(0,NdotL) * \n     atten) + (_LightColor0.rgb * finalSpec); \n  c.a = s.Alpha; \n  return c; \n} \n```", "```cs\nCGPROGRAM \n#pragma surface surf Phong \n```", "```cs\nvoid surf (Input IN, inout SurfaceOutput o) \n{\n half4 c = tex2D (_MainTex, IN.uv_MainTex) * _MainTint;\n o.Albedo = c.rgb;\n o.Alpha = c.a;\n}\n```", "```cs\nCPROGRAM \n#pragma surface surf Phong \nfixed4 LightingPhong (SurfaceOutput s, fixed3 lightDir, half3 viewDir, fixed atten) \n{ \n  // ... \n} \n```", "```cs\nfloat3 reflectionVector = normalize(2.0 * s.Normal * NdotL - \n                                    lightDir);\n```", "```cs\nProperties \n{ \n  _MainTint (\"Diffuse Tint\", Color) = (1,1,1,1) \n  _MainTex (\"Base (RGB)\", 2D) = \"white\" {} \n  _SpecularColor (\"Specular Color\", Color) = (1,1,1,1) \n  _SpecPower (\"Specular Power\", Range(0.1,60)) = 3 \n} \n```", "```cs\nsampler2D _MainTex; \nfloat4 _MainTint; \nfloat4 _SpecularColor; \nfloat _SpecPower; \n```", "```cs\nfixed4 LightingCustomBlinnPhong (SurfaceOutput s, \n                  fixed3 lightDir, \n                  half3 viewDir, \n                  fixed atten) \n{ \n  float NdotL = max(0,dot(s.Normal, lightDir)); \n\n  float3 halfVector = normalize(lightDir + viewDir); \n  float NdotH = max(0, dot(s.Normal, halfVector)); \n  float spec = pow(NdotH, _SpecPower) * _SpecularColor; \n\n  float4 color; \n  color.rgb = (s.Albedo * _LightColor0.rgb * NdotL) + \n        (_LightColor0.rgb * _SpecularColor.rgb * spec) * atten; \n  color.a = s.Alpha; \n  return color; \n} \n```", "```cs\nvoid surf (Input IN, inout SurfaceOutput o) \n{\n half4 c = tex2D (_MainTex, IN.uv_MainTex) * _MainTint;\n o.Albedo = c.rgb;\n o.Alpha = c.a;\n}\n```", "```cs\nCPROGRAM \n#pragma surface surf CustomBlinnPhong \n```", "```cs\nfloat3 halfVector = normalize(lightDir + viewDir); \n```", "```cs\nProperties \n{ \n  _MainTint (\"Diffuse Tint\", Color) = (1,1,1,1) \n  _MainTex (\"Base (RGB)\", 2D) = \"white\" {} \n  _SpecularColor (\"Specular Color\", Color) = (1,1,1,1) \n  _Specular (\"Specular Amount\", Range(0,1)) = 0.5 \n  _SpecPower (\"Specular Power\", Range(0,1)) = 0.5 \n  _AnisoDir (\"Anisotropic Direction\", 2D) = \"\" {} \n  _AnisoOffset (\"Anisotropic Offset\", Range(-1,1)) = -0.2 \n} \n```", "```cs\nsampler2D _MainTex; \nsampler2D _AnisoDir; \nfloat4 _MainTint; \nfloat4 _SpecularColor; \nfloat _AnisoOffset; \nfloat _Specular; \nfloat _SpecPower; \n```", "```cs\nfixed4 LightingAnisotropic(SurfaceAnisoOutput s, fixed3 \n   lightDir, half3 viewDir, fixed atten) \n{ \n  fixed3 halfVector = normalize(normalize(lightDir) + \n     normalize(viewDir)); \n  float NdotL = saturate(dot(s.Normal, lightDir)); \n\n  fixed HdotA = dot(normalize(s.Normal + s.AnisoDirection), \n     halfVector);  float aniso = max(0, sin(radians((HdotA + _AnisoOffset) * \n     180)));  float spec = saturate(pow(aniso, s.Gloss * 128) * \n     s.Specular); \n\n  fixed4 c; \n  c.rgb = ((s.Albedo * _LightColor0.rgb * NdotL) + \n     (_LightColor0.rgb * _SpecularColor.rgb * spec)) * \n     atten; \n  c.a = s.Alpha; \n  return c; \n} \n```", "```cs\nCGPROGRAM \n#pragma surface surf Anisotropic \n```", "```cs\nstruct Input  \n{ \n  float2 uv_MainTex; \n  float2 uv_AnisoDir; \n}; \n```", "```cs\nstruct SurfaceAnisoOutput \n{ \n  fixed3 Albedo; \n  fixed3 Normal; \n  fixed3 Emission; \n  fixed3 AnisoDirection; \n  half Specular; \n  fixed Gloss; \n  fixed Alpha; \n}; \n```", "```cs\nvoid surf(Input IN, inout SurfaceAnisoOutput o) \n{ \n  half4 c = tex2D(_MainTex, IN.uv_MainTex) * _MainTint; \n  float3 anisoTex = UnpackNormal(tex2D(_AnisoDir, \n     IN.uv_AnisoDir)); \n\n  o.AnisoDirection = anisoTex; \n  o.Specular = _Specular; \n  o.Gloss = _SpecPower; \n  o.Albedo = c.rgb; \n  o.Alpha = c.a; \n} \n```", "```cs\nstruct SurfaceAnisoOutput \n{ \n  fixed3 Albedo; \n  fixed3 Normal; \n  fixed3 Emission; \n  fixed3 AnisoDirection; \n  half Specular; \n  fixed Gloss; \n  fixed Alpha; \n}; \n```", "```cs\nfixed3 halfVector = normalize(normalize(lightDir) + \n                    normalize(viewDir)); \nfloat NdotL = saturate(dot(s.Normal, lightDir)); \n```", "```cs\nfixed HdotA = dot(normalize(s.Normal + s.AnisoDirection), \n                  halfVector); \nfloat aniso = max(0, sin(radians((HdotA + _AnisoOffset) * 180))); \n```", "```cs\nfloat spec = saturate(pow(aniso, s.Gloss * 128) * s.Specular); \n```"]