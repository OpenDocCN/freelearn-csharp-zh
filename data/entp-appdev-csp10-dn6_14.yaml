- en: '*Chapter 11*: Creating an ASP.NET Core 6 Web Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：创建ASP.NET Core 6网络应用程序'
- en: Up until now, we have built all the core components of the application, such
    as the data access layer and service layer, and all these components are primarily
    server-side components, also known as **backend components**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了应用程序的所有核心组件，如数据访问层和服务层，所有这些组件主要是服务器端组件，也称为**后端组件**。
- en: In this chapter, we will build the presentation layer/**user interface** (**UI**)
    for our e-commerce application, which is also known as the **client-side component**.
    The UI is the face of the application; having a good presentation layer not only
    helps with keeping users engaged in the application but also encourages users
    to come back to the application. This is especially the case with enterprise applications,
    where a good presentation layer helps users to navigate through the application
    easily and helps them in performing various day-to-day activities that are dependent
    on the application with ease.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建我们的电子商务应用程序的呈现层/用户界面（**UI**），也称为**客户端组件**。UI是应用程序的界面；一个好的呈现层不仅有助于保持用户对应用程序的参与度，而且鼓励用户返回应用程序。这在企业应用程序中尤为重要，一个好的呈现层有助于用户轻松地浏览应用程序，并帮助他们轻松地执行依赖于应用程序的日常活动。
- en: 'We will focus on understanding ASP.NET Core MVC and developing a web application
    using ASP.NET Core MVC. Primarily, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于理解ASP.NET Core MVC，并使用ASP.NET Core MVC开发一个网络应用程序。主要涵盖以下主题：
- en: Introduction to frontend web development
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端网页开发简介
- en: Integrating APIs with the service layer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将API与服务层集成
- en: Creating the controller and actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建控制器和操作
- en: Creating a UI using ASP.NET Core MVC
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ASP.NET Core MVC创建用户界面
- en: Understanding Blazor
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Blazor
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you need a basic knowledge of C#, .NET Core, HTML, and CSS.
    The code examples for the chapter can be found here: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter11/RazorSample](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter11/RazorSample).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要具备基本的C#、.NET Core、HTML和CSS知识。本章的代码示例可以在这里找到：[https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter11/RazorSample](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter11/RazorSample).
- en: 'You can find more code examples here: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到更多代码示例：[https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application).
- en: Introduction to frontend web development
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端网页开发简介
- en: The presentation layer is all about code that a browser can render and display
    to the user. Whenever a page gets loaded in a browser, it creates a hierarchy
    of various elements, such as textboxes and labels, that are present on the page.
    This hierarchy is known as the **Document Object Model** (**DOM**).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 呈现层主要是指浏览器可以渲染并显示给用户的代码。每当一个页面在浏览器中加载时，它会创建一个包含各种元素（如文本框和标签）的层次结构，这些元素都存在于页面上。这个层次结构被称为**文档对象模型**（**DOM**）。
- en: 'A good frontend is all about the ability to manipulate the DOM as needed, and
    there are many technologies/libraries that support manipulating the DOM and loading
    data dynamically using the de facto language of the web, JavaScript. Be it jQuery
    (which simplifies the use of JavaScript), full-blown client-side frameworks such
    as Angular, React, or Vue (which support complete client-side rendering), or ASP.NET
    Core frameworks such as ASP.NET Core MVC, Razor Pages, or Blazor, it all boils
    down to handling the three major building blocks of the web: HTML, CSS, and JavaScript.
    Let''s look into these three building blocks:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的前端主要在于能够根据需要操作DOM，并且有许多技术/库支持使用网络事实上的语言JavaScript动态地操作DOM和加载数据。无论是简化JavaScript使用的jQuery，还是支持完整客户端渲染的完整客户端框架，如Angular、React或Vue，或者是ASP.NET
    Core框架，如ASP.NET Core MVC、Razor Pages或Blazor，它们都归结为处理网络的三个主要构建块：HTML、CSS和JavaScript。让我们来看看这三个构建块：
- en: '**Hypertext Markup Language** (**HTML**): HTML, as the full form states, is
    a markup language that browsers can understand and display the contents. It primarily
    consists of a series of tags, which are known as **HTML elements**, and allows
    developers to define the structure of the page. For example, if you want to create
    a form that needs to allow the user to enter their first name and last name, it
    can be defined by using input HTML elements.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超文本标记语言**（**HTML**）：正如全称所述，HTML 是一种浏览器可以理解和显示内容的标记语言。它主要包含一系列称为 **HTML 元素**
    的标签，允许开发者定义页面的结构。例如，如果你想创建一个需要允许用户输入他们的名字和姓氏的表单，可以使用输入 HTML 元素来定义它。'
- en: '**Cascading Style Sheets** (**CSS**): The presentation layer is all about presenting
    data in a way that makes a web application more appealing to users and ensures
    that the application is usable, irrespective of the device/resolution that a user
    tries to load the application in. This is where CSS plays a critical role in defining
    how the content is displayed on the browser. It controls various things, such
    as the styling of the pages, the theme of the application, and the color palette,
    and, more importantly, makes them responsive so that users have the same experience
    using the application, be it loaded on a mobile or a desktop.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层叠样式表**（**CSS**）：表示层全部关于以吸引用户的方式展示数据，并确保无论用户尝试在哪种设备/分辨率上加载应用程序，应用程序都是可用的。这正是
    CSS 在定义浏览器上内容显示方面发挥关键作用的地方。它控制各种事情，如页面的样式、应用程序的主题和调色板，更重要的是，它使它们具有响应性，这样用户在使用应用程序时，无论是在移动设备还是桌面设备上，都能获得相同的体验。'
- en: The good thing about modern web development is we don't need to write everything
    from scratch and many libraries are available that can be picked and used as they
    are, in the application. We will be using one such library for an e-commerce application,
    which is explained in the *Creating a UI using ASP.NET Core MVC* section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络开发的优点是我们不需要从头开始编写一切，许多库都可以直接选择并用于应用程序中。我们将在 *使用 ASP.NET Core MVC 创建 UI*
    部分中使用这样一个库，其解释如下。
- en: '**JavaScript**: JavaScript is a scripting language that helps in performing
    various advanced dynamic operations, for example, validating input text entered
    in a form or things such as enabling/disabling HTML elements conditionally or
    retrieving data from an API. JavaScript gives more power to web pages and adds
    many programming features that a developer can use to perform advanced operations
    on the client side. Just like HTML and CSS, all browsers can understand JavaScript,
    which forms an important part of the presentation layer. All these components
    can be linked to each other, as shown in the following diagram:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript**: JavaScript 是一种脚本语言，有助于执行各种高级动态操作，例如，验证在表单中输入的文本或类似启用/禁用 HTML
    元素条件性或从 API 获取数据等操作。JavaScript 为网页提供了更多功能，并添加了许多开发者可以用来在客户端执行高级操作的编程特性。就像 HTML
    和 CSS 一样，所有浏览器都能理解 JavaScript，它构成了表示层的一个重要部分。所有这些组件都可以相互链接，如下面的图所示：'
- en: '![Figure 11.1 – HTML, CSS, and JavaScript'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1 – HTML、CSS 和 JavaScript'
- en: '](img/Figure_11.1_B18507.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.1_B18507.jpg)'
- en: Figure 11.1 – HTML, CSS, and JavaScript
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – HTML、CSS 和 JavaScript
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: HTML, CSS, and JavaScript all go hand in hand and play an important role in
    developing client-side/frontend applications and would require dedicated books
    to explain fully. Some related links can be found in the *Further reading* section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: HTML、CSS 和 JavaScript 互相依存，在开发客户端/前端应用程序中发挥着重要作用，需要专门的书籍来全面解释。一些相关链接可以在 *进一步阅读*
    部分找到。
- en: Now that we understand the importance of HTML, CSS, and JavaScript, we need
    to know how we can use them to build the presentation layer of a web application
    so that it can support multiple browsers and devices with different resolutions
    and is able to manage the state (HTTP being stateless).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 HTML、CSS 和 JavaScript 的重要性，我们需要知道如何使用它们来构建网页应用程序的表示层，以便它能够支持具有不同分辨率的多个浏览器，并且能够管理状态（HTTP
    是无状态的）。
- en: One technique could be to create all the HTML pages and host them on a web server;
    however, while this works well with static sites and also involves building everything
    from the ground up, if we want the content to be more dynamic and want a rich
    UI, we need to use technologies that can generate the HTML pages dynamically and
    provide seamless support to interact with the backend. Let's look, in the next
    section, at various technologies that can be used to generate dynamic HTML.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一种技术可能是创建所有 HTML 页面并在 Web 服务器上托管它们；然而，虽然这对于静态站点工作得很好，并且也涉及从头开始构建一切，但如果我们希望内容更加动态并且想要丰富的
    UI，我们需要使用能够动态生成 HTML 页面并提供与后端无缝交互支持的技术。让我们在下一节中看看可以用来生成动态 HTML 的各种技术。
- en: Razor syntax
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Razor 语法
- en: Before we start understanding the various possible frameworks provided by ASP.NET
    Core, let's first understand what the Razor syntax is. It is a markup syntax to
    embed server-side components into HTML. We can use the Razor syntax to bind any
    dynamic data for display or send it back to the server from a view/page for further
    processing. The Razor syntax is primarily written in Razor files/Razor view pages,
    which are nothing more than files used by C# to generate dynamic HTML. They go
    with the `.cshtml` extension and support the Razor syntax. The Razor syntax is
    processed by an engine called the **view engine**, and the default view engine
    is known as the **Razor engine**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始理解 ASP.NET Core 提供的各种可能框架之前，让我们首先了解什么是 Razor 语法。它是一种标记语法，用于将服务器端组件嵌入到 HTML
    中。我们可以使用 Razor 语法绑定任何动态数据以进行显示，或者将其从视图/页面发送回服务器以进行进一步处理。Razor 语法主要编写在 Razor 文件/Razor
    视图页面上，这些文件不过是 C# 用来生成动态 HTML 的文件。它们带有 `.cshtml` 扩展名并支持 Razor 语法。Razor 语法由一个名为
    **视图引擎** 的引擎处理，默认视图引擎被称为 **Razor 引擎**。
- en: 'To embed the Razor syntax, we typically use `@`, which tells the Razor engine
    to parse and generate HTML out of the engine. `@` can be followed by any C# built-in
    methods to generate HTML. For example, `<b>@DateTime.Now</b>` can be used to display
    the current date and time in a Razor view/page. Apart from this, just like C#,
    the Razor syntax also supports code blocks and controls structures and variables,
    among other things. Some sample Razor syntax going through the Razor engine is
    shown in the following figure:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要嵌入 Razor 语法，我们通常使用 `@`，这告诉 Razor 引擎解析并生成 HTML。`@` 后可以跟任何 C# 内置方法来生成 HTML。例如，`<b>@DateTime.Now</b>`
    可以用于在 Razor 视图/页面上显示当前日期和时间。除此之外，就像 C# 一样，Razor 语法也支持代码块、控制结构和变量等。以下图展示了通过 Razor
    引擎的一些示例 Razor 语法：
- en: '![Figure 11.2 – Razor syntax'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.2 – Razor 语法'
- en: '](img/Figure_11.2_B18507.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.2_B18507.jpg)'
- en: Figure 11.2 – Razor syntax
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – Razor 语法
- en: 'The Razor syntax also supports defining HTML controls; for example, to define
    a textbox, we can use the following Razor syntax:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Razor 语法还支持定义 HTML 控件；例如，要定义一个文本框，我们可以使用以下 Razor 语法：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code is known as an `input` tag helper and the Razor syntax takes
    care of what is known as **directive** tag helpers to bind data to an HTML control
    and generate rich, dynamic HTML. Let''s discuss this briefly:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码被称为 `input` 标记助手，Razor 语法负责处理称为 **指令** 标记助手的绑定数据到 HTML 控件并生成丰富、动态的 HTML。让我们简要讨论一下：
- en: '**Directives**: Under the hood, each Razor view/page is parsed by the Razor
    engine, and a C# class is used to generate dynamic HTML and then send it back
    to the browser. Directives can be used to control the behavior of this class,
    which further controls the dynamic HTML that is generated.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指令**：在底层，每个 Razor 视图/页面都由 Razor 引擎解析，并使用一个 C# 类来生成动态 HTML，然后将其发送回浏览器。指令可以用来控制这个类的行为，进而控制生成的动态
    HTML。'
- en: For example, the `@using` directive can be used to include any namespaces in
    the Razor view/page, or the `@code` directive can be used to include any C# members.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`@using` 指令可以用于在 Razor 视图/页面上包含任何命名空间，或者 `@code` 指令可以用于包含任何 C# 成员。
- en: One of the most used directives is `@model`, which allows you to bind a model
    to a view, which helps in validating the type of view as well as helps with IntelliSense.
    This process of binding views to a specific class/model is known as **strongly
    typing** views. We will be strongly typing all our views in our e-commerce application,
    which we will see in the *Creating a UI using ASP.NET Core MVC* section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的指令之一是 `@model`，它允许你将模型绑定到视图，这有助于验证视图的类型以及帮助 Intellisense。将视图绑定到特定类/模型的过程称为
    **强类型** 视图。在我们的电子商务应用程序中，我们将对所有视图进行强类型处理，这将在 *使用 ASP.NET Core MVC 创建 UI* 部分中看到。
- en: '**Tag helpers**: If you used ASP.NET MVC before ASP.NET Core, you would have
    come across HTML helpers, which are classes that help to bind data and generate
    HTML controls.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签助手**：如果你在 ASP.NET Core 之前使用过 ASP.NET MVC，你可能会遇到 HTML 助手，这些是帮助绑定数据和生成 HTML
    控件的类。'
- en: 'However, with ASP.NET Core, we have tag helpers, which help us to bind data
    to an HTML control. The benefit of tag helpers over HTML helpers is that tag helpers
    use the same syntax as HTML with additional attributes assigned to the standard
    HTML controls that can be generated from dynamic data. For example, to generate
    an HTML textbox control, typically, we write the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 ASP.NET Core 中，我们有标签助手，它们帮助我们将数据绑定到 HTML 控件。与 HTML 助手相比，标签助手的优点是它们使用与 HTML
    相同的语法，并为标准 HTML 控件分配了额外的属性，这些属性可以由动态数据生成。例如，要生成一个 HTML 文本框控件，通常我们会编写以下代码：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using tag helpers, this would be rewritten as shown in the following code,
    where `@Name` is the property of the model that the view is strongly typed to:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标签助手，这将被重写为以下代码，其中 `@Name` 是视图强类型关联的模型属性：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So, as you can see, it''s all about writing HTML but taking advantage of Razor
    markup to generate dynamic HTML. ASP.NET Core comes with many built-in tag helpers,
    and more details about them can be found here: [https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/built-in/?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/built-in/?view=aspnetcore-6.0).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如你所看到的，这完全是关于编写 HTML，但利用 Razor 标记来生成动态 HTML。ASP.NET Core 内置了许多标签助手，更多关于它们的信息可以在以下链接中找到：[https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/built-in/?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/built-in/?view=aspnetcore-6.0)。
- en: It is not required to know about/remember every tag helper, and we will use
    this reference documentation as and when we develop our application UI.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要了解/记住每个标签助手，我们将在开发应用程序 UI 时使用此参考文档。
- en: Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Since Razor syntax is markup, it''s not necessary to know all the syntax. The
    following link can be used as a reference for Razor syntax: [https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-6.0).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Razor 语法是标记，因此不需要了解所有语法。以下链接可以用作 Razor 语法的参考：[https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-6.0)。
- en: With this, let's look into the various options in ASP.NET Core as well as other
    common frameworks to develop the presentation layer.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们来看看 ASP.NET Core 以及其他常见框架中用于开发表示层的各种选项。
- en: Exploring Razor Pages
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Razor Pages
- en: 'Razor Pages is the default way to implement a web application using ASP.NET
    Core. Razor Pages relies on the concept of having a Razor file that can serve
    requests directly and an optional C# file associated with that Razor file for
    any additional processing. A typical Razor application can be created with the
    following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Razor Pages 是使用 ASP.NET Core 实现网络应用程序的默认方式。Razor Pages 依赖于拥有一个可以直接处理请求的 Razor
    文件的概念，以及与该 Razor 文件相关联的可选 C# 文件，用于任何额外的处理。可以使用以下命令创建一个典型的 Razor 应用程序：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the project has Razor pages and their corresponding C# files.
    On opening any Razor view, we see a directive called `@page`, which helps in browsing
    the page. So, for example, `/index` will be routed to `index.cshtml`. It's important
    that all Razor pages have the `@page` directive at the top of the page and are
    placed in the `Pages` folder, as the ASP.NET Core runtime looks for all the Razor
    pages in this folder.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，项目包含 Razor 页面及其对应的 C# 文件。在打开任何 Razor 视图时，我们会看到一个名为 `@page` 的指令，它有助于浏览页面。例如，`/index`
    将被路由到 `index.cshtml`。重要的是，所有 Razor 页面都必须在页面顶部包含 `@page` 指令，并且放置在 `Pages` 文件夹中，因为
    ASP.NET Core 运行时会在此文件夹中查找所有 Razor 页面。
- en: 'A Razor page can be further associated with a C# class, also known as a `PageModel`
    class, by using another directive called `@model`. The following is the code for
    the `index.cshtml` page:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用另一个名为 `@model` 的指令将 Razor 页面进一步关联到一个 C# 类，也称为 `PageModel` 类。以下是 `index.cshtml`
    页面的代码：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `PageModel` class is nothing more than a C# class that can have specific
    methods for `GET` and `POST` calls so that data on the Razor page can be dynamically
    fetched, say, from an API. This class needs to be inherited by `Microsoft.AspNetCore.Mvc.RazorPages.PageModel`
    and is a standard C# class. `PageModel` for `index.cshtml`, which is part of `index.cshtml.cs`,
    is shown in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`PageModel` 类不过是一个可以具有特定 `GET` 和 `POST` 调用方法的 C# 类，以便从 API 等动态获取 Razor 页面上的数据。这个类需要继承自
    `Microsoft.AspNetCore.Mvc.RazorPages.PageModel`，并且是一个标准的 C# 类。`index.cshtml` 的
    `PageModel`，它是 `index.cshtml.cs` 的一部分，如下代码所示：'
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, you can see that we are populating additional data that was used on the
    Razor page via the `OnGet` method, which is also known as a `PageModel` handler
    and can be used for the initialization of the Razor page. Like `OnGet`, we can
    add an `OnPost` handler that can be used to submit data back from the Razor page
    to `PageModel` and further the process.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们正在通过 `OnGet` 方法填充在 Razor 页面上使用的数据，这同样也被称为 `PageModel` 处理器，可以用于初始化
    Razor 页面。像 `OnGet` 一样，我们可以添加一个 `OnPost` 处理器，它可以用于将数据从 Razor 页面提交回 `PageModel`
    并进一步处理。
- en: 'The `OnPost` method will automatically bind all the properties in the `PageModel`
    class if they meet the following two conditions:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `OnPost` 方法满足以下两个条件，它将自动绑定 `PageModel` 类中的所有属性：
- en: The property is annotated with the `BindProperty` attribute.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性被注解为 `BindProperty` 属性。
- en: The Razor page has an HTML control with the same name as the property.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Razor 页面有一个与属性同名的 HTML 控件。
- en: 'So, for example, if we wanted to bind the value of the `select` control in
    the preceding code, we need to first add a property to the `PageModel` class,
    as shown in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要绑定前面代码中 `select` 控件的值，我们需要首先在 `PageModel` 类中添加一个属性，如下代码所示：
- en: '[PRE39]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, use the property name for the `select` control, as shown here, and Razor
    Pages will automatically bind the selected value to this property:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 `select` 控件的属性名，如这里所示，Razor Pages 将自动将选中的值绑定到这个属性：
- en: '[PRE41]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can use an asynchronous naming convention for the `OnGet` and `OnPost` methods
    so that they can be named as `OnGetAsync/OnPostAsync` if we are using asynchronous
    programming.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用异步命名约定为 `OnGet` 和 `OnPost` 方法命名，如果我们在使用异步编程，它们可以命名为 `OnGetAsync/OnPostAsync`。
- en: Razor Pages also supports calling methods based on the verb. The pattern for
    the method name should follow the `OnPost[handler]/OnPost[handler]Async` convention,
    where `[handler]` is the value set on the `asp-page-handler` attribute of any
    tag helper.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Razor Pages 还支持根据动词调用方法。方法名的模式应遵循 `OnPost[handler]/OnPost[handler]Async` 规范，其中
    `[handler]` 是设置在任何标签助手 `asp-page-handler` 属性上的值。
- en: 'For example, the following code will call the `OnPostDelete/OnPostDeleteAsync`
    method from the corresponding `PageModel` class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码将调用对应 `PageModel` 类中的 `OnPostDelete/OnPostDeleteAsync` 方法：
- en: '[PRE42]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For the services configuration part, Razor Pages can be configured using the
    `AddRazorPages` method in the `Program` class by adding the service to the ASP.NET
    Core `MapRazorPages` middleware needs to be injected for the Razor pages endpoint
    in the `Program` class, as shown in the following code. This is done so that all
    the Razor pages can be requested using the name of the page:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务配置部分，Razor Pages 可以通过在 `Program` 类中使用 `AddRazorPages` 方法来配置，通过将服务添加到 ASP.NET
    Core 的 `MapRazorPages` 中间件，并在 `Program` 类中注入，如下代码所示。这样做是为了使所有 Razor 页面都可以使用页面名称进行请求：
- en: '[PRE43]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This completes a simple Razor page application setup; we saw another sample
    in [*Chapter 9*](B18507_09_Epub.xhtml#_idTextAnchor860), *Working with Data in
    .NET 6*, that used Razor Pages to retrieve data from a database using **Entity
    Framework Core** (**EF Core**).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了简单的 Razor 页面应用程序设置；我们在 [*第 9 章*](B18507_09_Epub.xhtml#_idTextAnchor860)，*在
    .NET 6 中使用数据*，中看到了另一个示例，它使用了 Razor Pages 从数据库中检索数据，使用了 **Entity Framework Core**
    （**EF Core**）。
- en: Razor Pages is the easiest form of developing web applications in ASP.NET Core;
    however, for a more structured form of developing web applications that can handle
    complex features, we can go with ASP.NET Core MVC. Let's explore developing web
    apps using ASP.NET Core MVC in the next section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Razor Pages 是在 ASP.NET Core 中开发 Web 应用程序的最简单形式；然而，对于一种更结构化的开发 Web 应用程序的形式，可以处理复杂功能，我们可以选择
    ASP.NET Core MVC。让我们在下一节中探索使用 ASP.NET Core MVC 开发 Web 应用程序。
- en: Exploring the ASP.NET Core MVC website
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 ASP.NET Core MVC 网站
- en: As the name suggests, ASP.NET Core MVC is based on the MVC pattern discussed
    in [*Chapter 10*](B18507_10_Epub.xhtml#_idTextAnchor1040), *Creating an ASP.NET
    Core 6 Web API*, and is a framework in ASP.NET Core to build web applications.
    We saw in [*Chapter 10*](B18507_10_Epub.xhtml#_idTextAnchor1040), *Creating an
    ASP.NET Core 6 Web API*, that the ASP.NET Core Web API also uses the MVC pattern;
    however, ASP.NET Core MVC also supports views to display data. The underlying
    design pattern is the same, where we have a model to hold data, a controller to
    transfer the data, and views to render and display the data.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，ASP.NET Core MVC 基于第 10 章*创建 ASP.NET Core 6 Web API*中讨论的 MVC 模式，是 ASP.NET
    Core 中用于构建 Web 应用程序的框架。我们在第 10 章*创建 ASP.NET Core 6 Web API*中看到，ASP.NET Core Web
    API 也使用 MVC 模式；然而，ASP.NET Core MVC 还支持用于显示数据的视图。底层设计模式是相同的，其中我们有一个模型来存储数据，一个控制器来传输数据，以及视图来渲染和显示数据。
- en: ASP.NET Core MVC supports all the features that were discussed in [*Chapter
    10*](B18507_10_Epub.xhtml#_idTextAnchor1040), *Creating an ASP.NET Core 6 Web
    API*, such as routing, DI, model binding, and model validation, and uses the same
    bootstrapping technique of using the `Program` class. Like the Web API, .NET 6
    application services and middlewares are configured in the `Program` class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC 支持在第 10 章*创建 ASP.NET Core 6 Web API*中讨论的所有功能，例如路由、依赖注入、模型绑定和模型验证，并使用与
    Web API 相同的启动技术，即使用 `Program` 类。就像 Web API 一样，.NET 6 应用程序服务和中间件在 `Program` 类中进行配置。
- en: 'One of the key differences with MVC is the additional loading of views for
    which, instead of `AddControllers`, we need to use `AddControllersWithViews` in
    the `Program` class. An example is shown in the following figure:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与 MVC 的一个主要区别是还需要加载视图，因此，我们不是在 `Program` 类中使用 `AddControllers`，而是需要使用 `AddControllersWithViews`。以下图示了一个示例：
- en: '![Figure 11.3 – MVC request life cycle'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.3 – MVC 请求生命周期'
- en: '](img/Figure_11.3_B18507.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.3_B18507.jpg](img/Figure_11.3_B18507.jpg)'
- en: Figure 11.3 – MVC request life cycle
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 11.3 – MVC 请求生命周期
- en: '`AddControllersWithViews` primarily takes care of loading the views and handling
    the data sent by the controller, but most importantly, it takes care of configuring
    the Razor engine service that is used to process the Razor syntax in views and
    generate dynamic HTML.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddControllersWithViews` 主要负责加载视图和处理控制器发送的数据，但最重要的是，它负责配置用于在视图中处理 Razor 语法并生成动态
    HTML 的 Razor 引擎服务。'
- en: 'Controller actions in ASP.NET Core MVC need to be routed based on the action
    name passed in the URL, so on the routing part, instead of calling `MapController`,
    we configure `MapControllerRoute` and pass a pattern to it. So, the default routing
    configuration in the `UseEndpoints` middleware looks as in the following code
    snippet:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core MVC 中，控制器操作需要根据 URL 中传递的动作名称进行路由，因此在路由部分，我们不是调用 `MapController`，而是配置
    `MapControllerRoute` 并向其传递一个模式。因此，`UseEndpoints` 中间件中的默认路由配置看起来如下代码片段所示：
- en: '[PRE44]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, in the pattern, we are telling the middleware that the first part of the
    URL should be a `controller` name, followed by the action name and an optional
    `id` parameter. If nothing is passed in the URL, the default route is the `Index`
    action method of `ProductsController`. So, primarily, this is the convention-based
    routing we discussed in [*Chapter 10*](B18507_10_Epub.xhtml#_idTextAnchor1040),
    *Creating an ASP.NET Core 6 Web API*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模式中，我们正在告诉中间件，URL 的第一部分应该是 `controller` 名称，后面跟着动作名称和可选的 `id` 参数。如果 URL 中没有传递任何内容，则默认路由是
    `ProductsController` 的 `Index` 动作方法。因此，这主要是我们在第 10 章*创建 ASP.NET Core 6 Web API*中讨论的基于约定的路由。
- en: Just like Razor Pages, views in ASP.NET Core MVC applications support the Razor
    syntax and allow strongly typed views; that is, a view can be bound to a model
    for type checking, and model properties can be associated with HTML controls with
    compile-time IntelliSense support.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Razor Pages 一样，ASP.NET Core MVC 应用程序中的视图支持 Razor 语法，并允许强类型视图；也就是说，一个视图可以绑定到一个模型进行类型检查，并且模型属性可以与具有编译时智能感知支持的
    HTML 控件相关联。
- en: Since ASP.NET Core MVC gives more structure to the application, we will be using
    ASP.NET Core MVC for our presentation layer development, and it is discussed in
    detail while implementing the presentation layer in subsequent sections.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ASP.NET Core MVC 为应用程序提供了更多的结构，因此我们将使用 ASP.NET Core MVC 进行我们的表示层开发，这将在后续章节中详细讨论。
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is always a common question on which technology to choose for frontend
    development. The following link has some recommendations around this topic: [https://docs.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/choose-between-traditional-web-and-single-page-apps](https://docs.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/choose-between-traditional-web-and-single-page-apps).
    All the pros and cons should be evaluated before choosing the frontend technology
    as there are no one-size-fits-all requirements.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有一个关于选择前端开发技术的常见问题。以下链接提供了一些关于这个主题的建议：[https://docs.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/choose-between-traditional-web-and-single-page-apps](https://docs.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/choose-between-traditional-web-and-single-page-apps)。在选择前端技术之前，应该评估所有优点和缺点，因为没有一种适合所有情况的要求。
- en: With this foundation, let's move on to the next section, where we will start
    integrating the backend APIs developed up until now with our presentation layer.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基础上，让我们继续到下一节，我们将开始将到目前为止开发的后端 API 与我们的表示层集成。
- en: Integrating APIs with the service layer
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 API 与服务层集成
- en: In this section, we will be developing the `Packt.Ecommerce.Web` ASP.NET Core
    MVC application, which is created by adding the `ASP.NET Core web application(Model-View-Controller)`
    template. As we have already developed various APIs needed for the presentation
    layer, we will first build a wrapper class that will be used to communicate with
    these APIs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发 `Packt.Ecommerce.Web` ASP.NET Core MVC 应用程序，该应用程序是通过添加 `ASP.NET Core
    web application(Model-View-Controller)` 模板创建的。由于我们已经为表示层开发了各种所需的 API，因此我们首先将构建一个用于与这些
    API 通信的包装类。
- en: 'This is a single wrapper class that will be used to communicate with various
    APIs, so let''s create the contract for this class. For simplicity, we will limit
    the requirements to the most important workflow in our e-commerce application,
    and that will be as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于与各种 API 通信的单个包装类，因此让我们为这个类创建一个合约。为了简单起见，我们将要求限制到我们电子商务应用中最重要的工作流程，如下所示：
- en: The landing page retrieves all products in the system and allows users to search/filter
    the products.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录页面检索系统中的所有产品，并允许用户搜索/过滤产品。
- en: View the details of the products, add them to the cart, and be able to add more
    products to the cart.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看产品的详细信息，将它们添加到购物车中，并能够添加更多产品到购物车。
- en: Complete the order and see the invoice.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成订单并查看发票。
- en: 'To follow a more structured approach, we will segregate various classes and
    interfaces into separate folders. Let''s see how in the following steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了采用更结构化的方法，我们将将各种类和接口分离到不同的文件夹中。让我们在以下步骤中看看如何操作：
- en: 'To start with, let''s add a `Contracts` folder to the `Packt.Ecommerce.Web`
    project and add an interface with the name `IECommerceService`. This interface
    will have the following methods:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们向 `Packt.Ecommerce.Web` 项目添加一个名为 `Contracts` 的文件夹，并添加一个名为 `IECommerceService`
    的接口。这个接口将包含以下方法：
- en: '[PRE50]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, let's add a folder called `Services` and add a class called `EcommerceService`.
    This class will inherit `IECommerceService` and implement all the methods.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个名为 `Services` 的文件夹，并添加一个名为 `EcommerceService` 的类。这个类将继承 `IECommerceService`
    并实现所有方法。
- en: As we need to call various APIs, we need to make use of the `Packt.Ecommerce.Common.Options.ApplicationSettings`
    using the `options` pattern.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们需要调用各种 API，我们需要使用 `Packt.Ecommerce.Common.Options.ApplicationSettings` 通过
    `options` 模式来使用它。
- en: 'The `Program` class will have the following services configured for our MVC
    application:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program` 类将为我们的 MVC 应用程序配置以下服务：'
- en: '`AddControllersWithViews`: This will inject the necessary services for ASP.NET
    Core MVC to use controllers and views.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddControllersWithViews`: 这将为 ASP.NET Core MVC 注入使用控制器和视图所需的服务。'
- en: '`ApplicationSettings`: This will configure the `ApplicationSettings` class
    using the `IOptions` pattern with the following code:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationSettings`: 这将使用以下代码使用 `IOptions` 模式配置 `ApplicationSettings` 类：'
- en: '[PRE51]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`AddHttpClient`: This will inject `System.Net.Http.IHttpClientFactory` and
    related classes that will allow us to create an `HttpClient` object. Additionally,
    we will configure the retry policy and circuit break policy, as discussed in [*Chapter
    10*](B18507_10_Epub.xhtml#_idTextAnchor1040), *Creating an ASP.NET Core 6 Web
    API*.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddHttpClient`: 这将注入 `System.Net.Http.IHttpClientFactory` 和相关类，这将允许我们创建一个
    `HttpClient` 对象。此外，我们将配置重试策略和断路器策略，如在第 [*第10章*](B18507_10_Epub.xhtml#_idTextAnchor1040)
    中所述，*创建 ASP.NET Core 6 Web API*。'
- en: Mapping `EcommerceService` to `IECommerceService` using the .NET Core DI container.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 .NET Core DI 容器将 `EcommerceService` 映射到 `IECommerceService`。
- en: 'Configure the app insights using the following code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码配置应用洞察：
- en: '[PRE52]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Moving on to the middleware, we will be injecting the following middleware
    using the `Program` class, apart from the default routing middleware:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，关于中间件，我们将使用`Program`类注入以下中间件，除了默认的路由中间件之外：
- en: '`UseStatusCodePagesWithReExecute`: This middleware is used to redirect to a
    custom page other than for the `500` error code. We will add a method in `ProductController`
    in the next section that will be executed and loads the relevant view based on
    the error code. This middleware takes a string as an input parameter, which is
    nothing more than the route that should be executed in the case of an error, and
    to pass an error code, it allows a placeholder of `{0}`. So, the middleware configuration
    would look as follows:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UseStatusCodePagesWithReExecute`: 这个中间件用于将请求重定向到除`500`错误代码外的自定义页面。在下一节中，我们将在`ProductController`中添加一个方法，该方法将被执行并基于错误代码加载相关视图。这个中间件接受一个字符串作为输入参数，这实际上是在出现错误时应执行的路由，并且为了传递错误代码，它允许使用占位符`{0}`。因此，中间件配置看起来如下所示：'
- en: '[PRE53]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Error handling**: As for the presentation layer, unlike with the API, we
    need to redirect users to a custom page that, in the case of runtime failures,
    has relevant information, such as a user-friendly failure message and a relevant
    logging ID that can be used to retrieve the actual failure at a later stage. However,
    in the case of a development environment, we can show the complete error along
    with the stack. So, we will configure two middlewares as shown in the following
    code:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：至于表示层，与API不同，我们需要将用户重定向到自定义页面，在运行时失败的情况下，该页面包含相关信息，例如用户友好的错误消息和可以用于稍后检索实际失败的相关的日志ID。然而，在开发环境中，我们可以显示完整的错误以及堆栈。因此，我们将配置两个中间件，如下面的代码所示：'
- en: '[PRE54]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, we can see that for the development environment, we are using the `UseDeveloperExceptionPage`
    middleware, which will load the full exception stack trace, whereas, for non-development
    environments, we are using the `UseExceptionHandler` middleware, which takes the
    path of the error action method that needs to be executed. Additionally, here,
    we don't need our custom error handling middleware, as the ASP.NET Core middleware
    takes care of logging detailed errors to the logging provider, which is Application
    Insights in our case.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，对于开发环境，我们使用的是`UseDeveloperExceptionPage`中间件，它将加载完整的异常堆栈跟踪，而对于非开发环境，我们使用的是`UseExceptionHandler`中间件，它接受需要执行的错误操作方法的路径。此外，在这里，我们不需要我们的自定义错误处理中间件，因为ASP.NET
    Core中间件负责将详细的错误记录到日志提供程序，在我们的例子中是应用洞察。
- en: '`UseStaticFiles`: To allow various static files, such as CSS, JavaScript, images,
    and any other static files, we don''t need to go through the entire request pipeline,
    and that is where this middleware comes into play, which allows serving static
    files and supports short-circuiting the rest of the pipeline for static files.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UseStaticFiles`: 为了允许各种静态文件，如CSS、JavaScript、图像以及任何其他静态文件，我们不需要通过整个请求管道，这就是这个中间件发挥作用的地方，它允许服务静态文件并支持为静态文件短路其余的管道。'
- en: 'Coming back to the `EcommerceService` class, let''s first define the local
    variables and the constructor of this class, which will inject the `HTTPClient`
    factory and `ApplicationSettings` using the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`EcommerceService`类，让我们首先定义这个类的局部变量和构造函数，它将使用以下代码注入`HTTPClient`工厂和`ApplicationSettings`：
- en: '[PRE55]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, to implement methods as per our `IECommerceService` interface, we will
    use the following steps for the Get APIs:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了按照我们的`IECommerceService`接口实现方法，我们将使用以下步骤来处理Get API：
- en: '![Figure 11.4 – Get call to API'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.4 – API的Get调用'
- en: '](img/Figure_11.4_B18507.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.4_B18507.jpg)'
- en: Figure 11.4 – Get call to API
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – API的Get调用
- en: 'Based on the steps in the preceding figure, the implementation of `GetProductsAsync`,
    which is primarily used to retrieve products for the landing page and apply any
    filters while doing a product search, will look as shown in the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面图中的步骤，`GetProductsAsync`的实现，主要用于检索用于着陆页的产品并在进行产品搜索时应用任何过滤器，将如下所示：
- en: '[PRE64]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'For the `POST`/`PUT` APIs, we will have similar steps with slight modifications,
    as shown in the following figure:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`POST`/`PUT` API，我们将有类似的步骤，但略有修改，如下面的图所示：
- en: '![Figure 11.5 – Post call to API'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.5 – API调用后的情况'
- en: '](img/Figure_11.5_B18507.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.5_B18507.jpg)'
- en: Figure 11.5 – Post call to API
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – API的Post调用
- en: 'Based on this, the strategy implementation of `CreateOrUpdateOrder`, which
    is primarily used to create the shopping cart, will look as shown in the following
    code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，`CreateOrUpdateOrder`的策略实现，主要用于创建购物车，其代码如下所示：
- en: '[PRE86]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Similarly, we will implement `GetProductByIdAsync`, `GetOrderByIdAsync`, `GetInvoiceByIdAsync`,
    and `SubmitOrder` using one of the preceding strategies and using the relevant
    API endpoints.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将使用前面提到的一种策略和相关的API端点来实现`GetProductByIdAsync`、`GetOrderByIdAsync`、`GetInvoiceByIdAsync`和`SubmitOrder`。
- en: Now, let's create the controllers and action methods that will talk to `EcommerceService`
    and load the relevant views.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建将与`EcommerceService`通信并加载相关视图的控制器和操作方法。
- en: Creating the controller and actions
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建控制器和操作
- en: We have already seen that routing takes care of mapping the request URI to an
    action method in a controller, so let's further understand how the action methods
    then load the respective views. As you will have noticed, all the views in the
    ASP.NET Core MVC project are part of the `Views` folder, and when the action method
    execution is completed, it simply looks for `Views/<ControllerName>/<Action>.cshtml`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，路由负责将请求URI映射到控制器中的操作方法，因此让我们进一步了解操作方法是如何加载相应视图的。正如您所注意到的，ASP.NET Core
    MVC项目中的所有视图都是`Views`文件夹的一部分，当操作方法执行完成后，它只需简单地查找`Views/<ControllerName>/<Action>.cshtml`。
- en: For example, an action method mapping to the `Products/Index` route will load
    the `Views/Products/Index.cshtml` view. This is handled by calling the `Microsoft.AspNetCore.Mvc.Controller.View`
    method at the end of every action method.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将操作方法映射到`Products/Index`路由将加载`Views/Products/Index.cshtml`视图。这是通过在每个操作方法结束时调用`Microsoft.AspNetCore.Mvc.Controller.View`方法来处理的。
- en: 'There are additional overloads and helper methods that can override this behavior
    and route to a different view as needed. Before we talk about these helper methods,
    just like the Web API, each action method in the MVC controller can also return
    `IActionResult`, which means we can make use of helper methods to redirect to
    a view. In ASP.NET Core MVC, every controller is inherited by a base class, `Microsoft.AspNetCore.Mvc.Controller`,
    which comes with a few helper methods, and loading a view via an action method
    is handled by the following helper methods in the `Microsoft.AspNetCore.Mvc.Controller`
    class:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以覆盖此行为并按需路由到不同视图的额外重载和辅助方法外，我们将在讨论这些辅助方法之前，就像Web API一样，MVC控制器中的每个操作方法也可以返回`IActionResult`，这意味着我们可以利用辅助方法来重定向到视图。在ASP.NET
    Core MVC中，每个控制器都继承自基类`Microsoft.AspNetCore.Mvc.Controller`，该类包含一些辅助方法，并通过以下`Microsoft.AspNetCore.Mvc.Controller`类中的辅助方法来处理通过操作方法加载视图：
- en: '`View`: This method has multiple overloads and primarily loads the view from
    the folder under `Views` based on the controller name. For example, calling this
    method in `ProductsController` can load any `.cshtml` file from the `Views/Products`
    folder. Additionally, it can take the name of the view, which can be loaded if
    required, and supports passing an object that can be retrieved in views by strongly
    typing the view.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`View`：此方法具有多种重载，主要根据控制器名称从`Views`文件夹下的文件夹加载视图。例如，在`ProductsController`中调用此方法可以加载`Views/Products`文件夹中的任何`.cshtml`文件。此外，它还可以接受视图名称，如果需要，可以加载，并支持通过强类型化视图来传递可以由视图检索的对象。'
- en: '`RedirectToAction`: Although the `View` method handles most scenarios, there
    would be scenarios where we need to call another action method within the same
    controller or another controller, which is where `RedirectToAction` helps. This
    method comes with various overloads and allows us to specify the name of the action
    method, controller method, and object that the action method can receive as route
    values.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RedirectToAction`：尽管`View`方法处理了大多数场景，但仍然会有需要在同一控制器或另一个控制器中调用另一个操作方法的场景，这就是`RedirectToAction`发挥作用的地方。此方法具有多种重载，允许我们指定操作方法、控制器方法以及操作方法可以接收作为路由值的对象。'
- en: In short, to load the views and pass data from controllers, we will be passing
    respective models to the `View` method and, as required, we will use `RedirectToAction`
    whenever there is a need to call another action method.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，为了加载视图并从控制器传递数据，我们将通过`View`方法传递相应的模型，并在需要时使用`RedirectToAction`来调用另一个操作方法。
- en: 'Now, the question is how to handle data retrieval (`GET` calls) versus data
    submission (`POST` calls), and in ASP.NET Core MVC, all the action methods support
    annotating with HTTP verbs using the `HttpGet` and `HttpPost` attributes. The
    following are a few rules that can be used to annotate methods:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题是如何处理数据检索（`GET`调用）与数据提交（`POST`调用），在ASP.NET Core MVC中，所有动作方法都支持使用`HttpGet`和`HttpPost`属性来标记HTTP动词。以下是一些可以用来标记方法的规则：
- en: If we want to retrieve data, then the action method is annotated using `HttpGet`.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要检索数据，则动作方法应使用`HttpGet`进行标记。
- en: If we want to submit data to an action method, it should be annotated using
    `HttpPost` with the relevant object as the input parameter to that action method.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要向动作方法提交数据，则应使用`HttpPost`进行标记，并将相关对象作为动作方法的输入参数。
- en: Typically, methods that need to send data from a controller to a view should
    be annotated with `[HttpGet]`, and methods that need to receive data from a view
    for further submission to the database should be annotated using `[HttpPost]`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，需要从控制器向视图发送数据的函数应使用`[HttpGet]`进行标记，而需要从视图接收数据以进一步提交到数据库的函数应使用`[HttpPost]`进行标记。
- en: Now, let's move on to adding the required controllers and implementing them.
    When we add `Packt.Ecommerce.Web`, it creates a `Controllers` folder with `HomeController`
    created by default, which we need to delete. Then we need to add the three controllers
    by right-clicking on the `Controllers` folder, then selecting `ProductsController`,
    `CartController`, and `OrdersController`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续添加所需的控制器并实现它们。当我们添加`Packt.Ecommerce.Web`时，它将创建一个包含默认创建的`HomeController`的`Controllers`文件夹，我们需要将其删除。然后，我们需要通过右键单击`Controllers`文件夹，然后选择`ProductsController`、`CartController`和`OrdersController`来添加三个控制器。
- en: 'All these controllers will have the following two common properties, one for
    logging and one for calling methods of `EcommerceService`. They are further initialized
    using constructor injection as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些控制器都将具有以下两个共同属性，一个用于日志记录，另一个用于调用`EcommerceService`的方法。它们将通过构造函数注入进一步初始化，如下所示：
- en: '[PRE105]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Let''s now discuss what is defined in each of these controllers:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在讨论每个控制器中定义的内容：
- en: '`ProductsController`: This controller will contain the `public async Task<IActionResult>
    Index(string searchString, string category)` action method to load the default
    view for listing all the products, which further supports filtering. There will
    be another method, `public async Task<IActionResult> Details(string productId,
    string productName)`, that takes the ID and name of the product and loads the
    details of the specified product. As both these methods are used for retrieving,
    they will be annotated using `[HttpGet]`. Additionally, this controller will have
    the `Error` method, as discussed earlier. Since it can receive an error code as
    an input parameter from the `UseStatusCodePagesWithReExecute` middleware, we will
    have simple logic to load the views accordingly:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductsController`：此控制器将包含一个`public async Task<IActionResult> Index(string
    searchString, string category)`动作方法，用于加载列出所有产品的默认视图，并进一步支持过滤。将会有另一个方法，`public
    async Task<IActionResult> Details(string productId, string productName)`，它接受产品的ID和名称，并加载指定产品的详细信息。由于这两个方法都用于检索，因此它们将使用`[HttpGet]`进行标记。此外，此控制器将具有之前讨论过的`Error`方法。由于它可以从`UseStatusCodePagesWithReExecute`中间件接收错误代码作为输入参数，因此我们将有简单的逻辑来相应地加载视图：'
- en: '[PRE107]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '`CartController`: This controller contains the `public async Task<IActionResult>
    Index(ProductListViewModel product)` action method to add a product to the cart,
    where we will create an order with the order status set to `''Cart''`, as this
    needs to receive data and further pass it to the API, which will be annotated
    with `[HttpPost]`. For simplicity, this is left anonymous but can be restricted
    for the logged-in users. Once the order is created, this method will make use
    of the `RedirectToAction` helper method and redirects to the `public async Task<IActionResult>
    Index(string orderId)` action method within this controller, which further loads
    the cart with all the products and the checkout form. This method can also be
    used to directly navigate to the shopping cart.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CartController`：此控制器包含一个`public async Task<IActionResult> Index(ProductListViewModel
    product)`动作方法，用于将产品添加到购物车中。我们将创建一个订单，并将订单状态设置为`''Cart''`，因为这需要接收数据并将其进一步传递到API，该API将被标记为`[HttpPost]`。为了简化，这里将其留为匿名，但可以限制对已登录用户的访问。一旦创建订单，此方法将使用`RedirectToAction`辅助方法，并将重定向到控制器内的`public
    async Task<IActionResult> Index(string orderId)`动作方法，该方法进一步加载包含所有产品的购物车和结账表单。此方法也可以直接导航到购物车。'
- en: '`OrdersController`: This is the last controller in the flow, which contains
    the `public async Task<IActionResult> Create(OrderDetailsViewModel order)` action
    method to submit the order after filling in the payment details. This method updates
    the status of the order to `Submitted`, then creates an invoice for the order,
    and finally, redirects to another action method, `public async Task<IActionResult>
    Index(string invoiceId)`, which loads the final invoice of the order and completes
    the transaction.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrdersController`: 这是流程中的最后一个控制器，其中包含一个`public async Task<IActionResult> Create(OrderDetailsViewModel
    order)`动作方法，用于在填写支付详情后提交订单。此方法将订单状态更新为`Submitted`，然后为订单创建发票，最后重定向到另一个动作方法`public
    async Task<IActionResult> Index(string invoiceId)`，该方法加载订单的最终发票并完成交易。'
- en: 'The following diagram represents the flow between various methods across controllers
    to complete the shopping workflow:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表示了控制器之间完成购物流程的方法之间的流程：
- en: '![Figure 11.6 – Flow between controller action methods'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.6 – 控制器动作方法之间的流程'
- en: '](img/Figure_11.6_B18507.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.6_B18507.jpg)'
- en: Figure 11.6 – Flow between controller action methods
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 控制器动作方法之间的流程
- en: With this knowledge, let's design the views in the next section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些知识，让我们在下一节中设计视图。
- en: Creating a UI using ASP.NET Core MVC
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ASP.NET Core MVC创建UI
- en: Up until now, we have defined a service to communicate with backend APIs and
    further defined controllers that will pass the data to views using models. Now,
    let's build various views that will render the data and present it to users.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了一个服务来与后端API通信，并进一步定义了将使用模型将数据传递给视图的控制器。现在，让我们构建各种视图，这些视图将渲染数据并向用户展示。
- en: 'To begin with, let''s see the various components that are involved in rendering
    the views:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看参与渲染视图的各种组件：
- en: 'The `Views` folder: All views are part of this folder, with each controller-specific
    view segregated by a subfolder, and finally, each action method is represented
    by a `.cshtml` file.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Views`文件夹：所有视图都是这个文件夹的一部分，每个控制器特定的视图都由一个子文件夹分隔，最后，每个动作方法都由一个`.cshtml`文件表示。'
- en: To add a view, we can right-click on the action method and click **Add View**,
    which will automatically create a folder (if it isn't already present) with the
    name of the controller and add the view. Additionally, while doing this, we can
    specify the model that the view would be bound to.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个视图，我们可以在动作方法上右键单击并选择**添加视图**，这将自动创建一个（如果尚未存在）以控制器命名的文件夹，并添加视图。此外，在执行此操作时，我们可以指定视图将绑定到的模型。
- en: 'The `Layout` page: This is a common requirement in a web application where
    we have a common section across the application, such as a header with a menu
    or left navigation. To have a modular structure for our pages and to avoid any
    repetition, ASP.Net Core MVC comes with a layout page that is typically named
    `_Layout.cshtml` and is part of the `Views/Shared` folder. This page can be used
    as a parent page for all the views in our MVC project. A typical layout page looks
    like the one shown in the following code:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Layout`页面：在Web应用程序中，我们通常有一个跨应用共用的部分，例如带有菜单或左侧导航的页眉。为了使我们的页面具有模块化结构并避免重复，ASP.Net
    Core MVC提供了一个名为`_Layout.cshtml`的布局页面，它是`Views/Shared`文件夹的一部分。这个页面可以用作我们MVC项目中所有视图的父页面。一个典型的布局页面如下所示：'
- en: '[PRE108]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Here, you can see that it allows us to define the skeleton layout of the application,
    and then finally, there is a Razor method called `@RenderBody()`, which actually
    loads the child view. To specify a layout page in any view, we can use the following
    syntax, which adds `_Layout.cshtml` as a parent page to the view:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到它允许我们定义应用程序的骨架布局，然后最后，有一个名为`@RenderBody()`的Razor方法，它实际上加载了子视图。要指定任何视图中的布局页面，我们可以使用以下语法，它将`_Layout.cshtml`添加为视图的父页面：
- en: '[PRE109]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'However, there is no need to repeat this code in all the views, and that''s
    where `_ViewStart.cshtml` comes in handy. Let''s see how it helps in reusing some
    of the code across views:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有必要在所有视图中重复此代码，这正是`_ViewStart.cshtml`发挥作用的地方。让我们看看它是如何帮助我们在视图之间重用一些代码的：
- en: '`_ViewStart.cshtml`: This is a generic view that is located directly under
    the `Views` folder and is used by the Razor engine to execute any code that needs
    to be executed before the code in the view. So, typically, this is used to define
    the layout page and so, the preceding code can be added to this file so that it
    gets applied across the application.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_ViewStart.cshtml`：这是一个通用的视图，位于 `Views` 文件夹下，并由 Razor 引擎执行需要在视图代码之前执行的任何代码。因此，通常情况下，它用于定义布局页面，所以前面的代码可以添加到这个文件中，以便它在整个应用程序中应用。'
- en: '`_ViewImports.cshtml`: This is another page that can be used to import any
    common directives or namespaces across the application. Just like `_ViewStart`,
    this is also located directly under the root folder; however, both `_ViewStart`
    and `_ViewImport` can be in one (or more than one) folder and they are executed
    hierarchically starting from the one in the root views folder to the lower-level
    one in any subfolders. To enable client-side telemetry using Application Insights,
    we inject `JavaScriptSnippet` as shown in the following code. We learned about
    injecting dependent services into views in [*Chapter 5*](B18507_05_Epub.xhtml#_idTextAnchor445),
    *Dependency Injection in .NET 6*. In the following code, `JavaScriptSnippet` is
    injected into the view:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_ViewImports.cshtml`：这是另一个可以用于在应用程序中导入任何公共指令或命名空间的页面。就像 `_ViewStart` 一样，它也位于根文件夹下；然而，`_ViewStart`
    和 `_ViewImport` 可以在一个（或多个）文件夹中，并且它们是按照从根视图文件夹中的开始，到任何子文件夹中的低级别文件夹的顺序执行的。要启用使用
    Application Insights 的客户端遥测，我们按照以下代码注入 `JavaScriptSnippet`。我们在 [*第 5 章*](B18507_05_Epub.xhtml#_idTextAnchor445)
    中学习了如何将依赖服务注入到视图中，*在 .NET 6 中的依赖注入*。在以下代码中，`JavaScriptSnippet` 被注入到视图中：'
- en: '[PRE110]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '`wwwroot`: This is the root folder of the application, and all the static resources,
    such as JavaScript, CSS, and any image files, are placed here. This can further
    hold any HTML plugins that we want to use in our application. As we have already
    configured the `UseStaticFiles` middleware in our application, content from the
    folder can be directly served without any processing. The default template of
    ASP.NET Core MVC comes with a segregation of folders based on their type; for
    example, all JavaScript files are placed inside a `js` folder, CSS files are placed
    in a `css` folder, and so on. We will stick to that folder structure for our application.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wwwroot`：这是应用程序的根文件夹，所有静态资源，如 JavaScript、CSS 以及任何图像文件，都放置在这里。这里还可以存放我们希望在应用程序中使用的任何
    HTML 插件。由于我们已经在应用程序中配置了 `UseStaticFiles` 中间件，因此文件夹中的内容可以直接提供服务，无需任何处理。ASP.NET
    Core MVC 的默认模板根据类型对文件夹进行了隔离；例如，所有 JavaScript 文件都放置在 `js` 文件夹中，CSS 文件放置在 `css`
    文件夹中，等等。我们将坚持使用这种文件夹结构来构建我们的应用程序。'
- en: Note
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The process of automatically generating views by right-clicking on the action
    method and using built-in templates is known as **scaffolding** and can be used
    if are you new to the Razor syntax. However, creating a view using scaffolding
    or manually placing it inside the respective folder and strongly typing it results
    in the same behavior.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过右键单击操作方法并使用内置模板自动生成视图的过程称为 **scaffolding**，如果您对 Razor 语法不熟悉，可以使用它。然而，使用 scaffolding
    或手动将其放置在相应的文件夹中并强类型化，会产生相同的行为。
- en: Setting up AdminLTE, the layout page, and views
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 AdminLTE、布局页面和视图
- en: An important thing for getting the same look and feel across an application
    is to choose the right styling framework. Doing that not only gives a consistent
    layout but also simplifies the responsive design, which helps in rendering the
    pages correctly in various resolutions. The ASP.NET Core MVC project template
    that we are using for `Packt.Ecommerce.Web` comes out of the box with Bootstrap
    as its styling framework. We will further extend this to a theme known as `AdminLTE`,
    which comes with some interesting layouts and dashboards that can be plugged into
    our presentation layer.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要在整个应用程序中保持相同的视觉效果和感觉，一个重要的事情是选择正确的样式框架。这样做不仅提供了统一的布局，还简化了响应式设计，有助于在不同分辨率下正确渲染页面。我们为
    `Packt.Ecommerce.Web` 使用的 ASP.NET Core MVC 项目模板默认包含 Bootstrap 作为其样式框架。我们将进一步扩展到名为
    `AdminLTE` 的主题，它包含一些有趣的布局和仪表板，可以插入到我们的表示层中。
- en: 'Let''s perform the following steps to integrate `AdminLTE` into our application:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤以将 `AdminLTE` 集成到我们的应用程序中：
- en: 'Download the most recent version of `AdminLTE` from here: [https://github.com/ColorlibHQ/AdminLTE/releases](https://github.com/ColorlibHQ/AdminLTE/releases).'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里下载 `AdminLTE` 的最新版本：[https://github.com/ColorlibHQ/AdminLTE/releases](https://github.com/ColorlibHQ/AdminLTE/releases)。
- en: Extract the ZIP file downloaded in the previous step and navigate to `AdminLTE-3.0.5\dist\css`.
    Copy `adminlte.min.css` and paste it inside the `wwwroot/css` folder of `Packt.Ecommerce.Web`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取之前下载的ZIP文件，并导航到`AdminLTE-3.0.5\dist\css`。复制`adminlte.min.css`，并将其粘贴到`Packt.Ecommerce.Web`的`wwwroot/css`文件夹内。
- en: Navigate to `AdminLTE-3.0.5\dist\js`. Copy `adminlte.min.js` and paste it inside
    the `wwwroot/js` folder of `Packt.Ecommerce.Web`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`AdminLTE-3.0.5\dist\js`。复制`adminlte.min.js`，并将其粘贴到`Packt.Ecommerce.Web`的`wwwroot/js`文件夹内。
- en: Navigate to `AdminLTE-3.0.5\dist\img`. Copy the required images and paste them
    inside the `wwwroot/img` folder of `Packt.Ecommerce.Web`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`AdminLTE-3.0.5\dist\img`。复制所需的图片，并将它们粘贴到`Packt.Ecommerce.Web`的`wwwroot/img`文件夹内。
- en: Copy the `AdminLTE-3.0.5\plugins` folder and paste it inside the `wwwroot` folder
    of `Packt.Ecommerce.Web`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`AdminLTE-3.0.5\plugins`文件夹，并将其粘贴到`Packt.Ecommerce.Web`的`wwwroot`文件夹内。
- en: More information about `AdminLTE` can be found at [https://adminlte.io/docs/2.4/installation](https://adminlte.io/docs/2.4/installation).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`AdminLTE`的信息可以在[https://adminlte.io/docs/2.4/installation](https://adminlte.io/docs/2.4/installation)找到。
- en: 'Now, navigate to the `Views/_Layout.cshtml` page and remove all the existing
    code and replace it with the code from `Packt.Ecommerce.Web\Views\Shared\_Layout.cshtml`.
    On a high level, the layout is divided into the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，导航到`Views/_Layout.cshtml`页面，删除所有现有代码，并用`Packt.Ecommerce.Web\Views\Shared_Layout.cshtml`中的代码替换它。从高层次上讲，布局分为以下几部分：
- en: A header with navigation to the home page on the left side
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在左侧页眉中的导航到主页
- en: A search box in the header and a dropdown with search categories in the center
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页眉中添加一个搜索框，并在中间添加一个带有搜索类别的下拉菜单
- en: The shopping cart in the header on the right side
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在右侧页眉中的购物车
- en: A breadcrumb trail to display the navigation
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于显示导航的面包屑路径
- en: A section to render the child view using `@RenderBody()`
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于使用`@RenderBody()`渲染子视图的部分
- en: 'A couple of other key things that are needed to complete the integration of
    the `AdminLTE` template are as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 完成集成`AdminLTE`模板所需的一些其他关键事项如下：
- en: 'Add the following styles defined in the `<head>` tag:'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`<head>`标签中添加以下样式定义：
- en: '[PRE111]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Add the following JavaScript files just before the end of the `<body>` tag:'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`<body>`标签的末尾之前添加以下JavaScript文件：
- en: '[PRE112]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'With this, we have the `AdminLTE` theme integrated into our application. To
    render the JavaScript required to enable the client telemetry using Application
    Insights, add the following code inside the `head` tag of `_Layout.cshtml`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经将`AdminLTE`主题集成到我们的应用程序中。要使用Application Insights启用客户端遥测所需的JavaScript，请在`_Layout.cshtml`的`head`标签内添加以下代码：
- en: '[PRE113]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The previous code injects the JavaScript required to send telemetry data from
    views along with the instrumentation key. Unlike the server side or the client
    side, the instrumentation key is exposed. Anyone can see the instrumentation key
    from the browser developer tools. But, this is how client-side telemetry is set
    up. At this point, the risk of this is that unwanted data can be pushed by a malicious
    user or attacker as the instrumentation key has write-only access. If you wish
    to make the client-side telemetry more secure, you can expose a secure REST API
    from your service and log the telemetry events from there. You will learn more
    about Application Insights features in [*Chapter 14*](B18507_14_Epub.xhtml#_idTextAnchor1674),
    *Health and Diagnostics*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码注入了发送遥测数据所需的JavaScript，以及仪表化密钥。与服务器端或客户端不同，仪表化密钥是公开的。任何人都可以从浏览器开发者工具中看到仪表化密钥。但是，这就是客户端遥测的设置方式。此时，这种风险是恶意用户或攻击者可以通过仪表化密钥的只写访问权限推送不希望的数据。如果您希望使客户端遥测更安全，您可以从您的服务中公开一个安全的REST
    API，并从那里记录遥测事件。您将在[*第14章*](B18507_14_Epub.xhtml#_idTextAnchor1674)中了解更多关于Application
    Insights功能的信息，*健康和诊断*。
- en: Now, the application layout is ready. Let's now move on to defining various
    views in the application.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用程序布局已准备就绪。让我们现在继续定义应用程序中的各种视图。
- en: Creating the Products/Index view
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Products/Index视图
- en: This view will be used to list all the products available on our e-commerce
    application and is strongly typed with the `IEnumerable<Packt.Ecommerce.DTO.Models.ProductListViewModel>`
    model. It uses the `Index` action method of `ProductsController` to retrieve data.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图将用于列出我们电子商务应用程序上所有可用的产品，并且使用`IEnumerable<Packt.Ecommerce.DTO.Models.ProductListViewModel>`模型进行强类型化。它使用`ProductsController`的`Index`操作方法检索数据。
- en: 'In this view, we will use a simple Razor `@foreach (var item in Model)` loop
    and for each product, we will display an image of the product, its name, and its
    price. A sample of this view looks as shown in the following screenshot:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在此视图中，我们将使用简单的 Razor `@foreach (var item in Model)` 循环，并为每个产品显示产品的图片、名称和价格。以下截图展示了此视图的一个示例：
- en: '![Figure 11.7 – Products view'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.7 – 产品视图'
- en: '](img/Figure_11.7_B18507.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.7_B18507.jpg)'
- en: Figure 11.7 – Products view
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 – 产品视图
- en: Here, you can see that there is a search bar and a category dropdown coming
    from the layout page. Clicking on the product image will navigate to the `Products/Details`
    view. To support this navigation, we will make use of `AnchorTagHelper` and pass
    the product ID and name to the `Details` action method of `ProductsController`
    to further load the details of the product in the `Products/Details` view.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到有一个搜索栏和一个来自布局页面的分类下拉菜单。点击产品图片将导航到 `Products/Details` 视图。为了支持此导航，我们将使用
    `AnchorTagHelper` 并将产品ID和名称传递给 `ProductsController` 的 `Details` 动作方法，以便进一步在 `Products/Details`
    视图中加载产品的详细信息。
- en: Creating the Products/Details view
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Products/Details 视图
- en: 'This view will load the details of the product based on the product ID and
    the name passed from the `Products/Index` view. We will be using a sample page
    from `AdminLTE` as shown here: [https://adminlte.io/themes/dev/AdminLTE/pages/examples/e_commerce.html](https://adminlte.io/themes/dev/AdminLTE/pages/examples/e_commerce.html).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图将根据从 `Products/Index` 视图传递的产品ID和名称加载产品的详细信息。我们将使用以下示例页面：[https://adminlte.io/themes/dev/AdminLTE/pages/examples/e_commerce.html](https://adminlte.io/themes/dev/AdminLTE/pages/examples/e_commerce.html)。
- en: 'This page will be strongly typed with `Packt.Ecommerce.DTO.Models.ProductDetailsViewModel`
    and will display all the details of the product. A sample of this page is shown
    in the following screenshot:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面将使用 `Packt.Ecommerce.DTO.Models.ProductDetailsViewModel` 进行强类型定义，并显示产品的所有详细信息。以下截图展示了此页面的一个示例：
- en: '![Figure 11.8 – Product details view'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.8 – 产品详情视图'
- en: '](img/Figure_11.8_B18507.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.8_B18507.jpg)'
- en: Figure 11.8 – Product details view
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – 产品详情视图
- en: As you can see, there is an `'Cart'`, this will call the `Index` action method
    of `CartController` to create the cart.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有一个 `'Cart'`，这将调用 `CartController` 的 `Index` 动作方法以创建购物车。
- en: 'To pass data back to the action method, we will take the help of `FormTagHelper`,
    which allows us to wrap the page in an HTML form and specify the action and controller
    that the page can be submitted to using the following code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据传递回动作方法，我们将借助 `FormTagHelper`，它允许我们将页面包裹在一个HTML表单中，并使用以下代码指定页面可以提交到的动作和控制器：
- en: '[PRE114]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: With this code, once the `Submit` type, the page gets submitted to the `Index`
    action method of `CartController` to further save it to the database. However,
    we still need to pass the product details back to the `Index` action method and,
    for that, we will take the help of `InputTagHelper` and create hidden fields for
    all the values that need to be passed back to the action method.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，一旦提交为 `Submit` 类型，页面就会提交到 `CartController` 的 `Index` 动作方法，以便进一步将其保存到数据库。然而，我们仍然需要将产品详情传递回
    `Index` 动作方法，为此，我们将借助 `InputTagHelper` 并为所有需要传递回动作方法的值创建隐藏字段。
- en: 'The most important thing here is that the name of the hidden variable should
    match the name of the property in the model, so we will be adding the following
    code inside the form to pass the product values back to the controller:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的是隐藏变量的名称应与模型中属性的名称匹配，因此我们将在表单内添加以下代码，以将产品值传递回控制器：
- en: '[PRE115]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: ASP.NET Core MVC's model binding system reads these values and creates the product
    object needed for the `Index` method of `CartController`, which further calls
    the backend system to create the order.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC 的模型绑定系统读取这些值，并为 `CartController` 的 `Index` 方法创建所需的产品对象，然后进一步调用后端系统以创建订单。
- en: Creating the Cart/Index view
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建购物车/索引视图
- en: This view will load the cart details and will have a checkout form to fill in
    all the details and complete the order. Here, we can navigate back to the home
    page to add more products or complete the order.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图将加载购物车详情，并将有一个填写所有详细信息并完成订单的结账表单。在此，我们可以导航回主页以添加更多产品或完成订单。
- en: This view is strongly typed with `Packt.Ecommerce.DTO.Models.OrderDetailsViewModel`
    and loads data using the `Index` action method of `OrdersController`. Here, we
    are using the Bootstrap checkout form example from [https://getbootstrap.com/docs/4.5/examples/checkout/](https://getbootstrap.com/docs/4.5/examples/checkout/).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图使用 `Packt.Ecommerce.DTO.Models.OrderDetailsViewModel` 进行强类型化，并使用 `OrdersController`
    的 `Index` 动作方法加载数据。在这里，我们使用了来自 [https://getbootstrap.com/docs/4.5/examples/checkout/](https://getbootstrap.com/docs/4.5/examples/checkout/)
    的 Bootstrap 结账表单示例。
- en: 'This form makes use of model validations and HTML attributes to perform validation
    on the required fields, and we are taking the help of ASP.NET Core MVC tag helpers
    and a few HTML helpers to render the form. A sample property with model validations
    would be as shown in the following code:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单利用模型验证和 HTML 属性对必填字段进行验证，我们借助 ASP.NET Core MVC 标签辅助器和一些 HTML 辅助器来渲染表单。以下代码展示了具有模型验证的示例属性：
- en: '[PRE119]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: This model is used in [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/data/Packt.Ecommerce.DTO.Models/OrderDetailsViewModel.cs](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/data/Packt.Ecommerce.DTO.Models/OrderDetailsViewModel.cs)
    and triggers necessary validations while placing an order.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型用于 [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/data/Packt.Ecommerce.DTO.Models/OrderDetailsViewModel.cs](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/data/Packt.Ecommerce.DTO.Models/OrderDetailsViewModel.cs)
    并在下单时触发必要的验证。
- en: 'As this form also needs to be submitted, the entire form is wrapped in `FormTagHelper`,
    as shown in the following code:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此表单也需要提交，整个表单被包裹在 `FormTagHelper` 中，如下面的代码所示：
- en: '[PRE128]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'To show these validations on the UI, add the following scripts to `_layout.cshtml`
    just after all the other scripts we added earlier:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 UI 上显示这些验证，请将以下脚本添加到 `_layout.cshtml` 中，在添加了所有其他脚本之后：
- en: '[PRE129]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'To display an error message, we can make use of a validation message tag helper,
    as shown in the following code snippet. On the server side, this can be further
    evaluated using `ModelState.IsValid`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示错误消息，我们可以使用验证消息标签辅助器，如下面的代码片段所示。在服务器端，这可以通过 `ModelState.IsValid` 进一步评估：
- en: '[PRE131]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'A sample of this page would be as shown in the following screenshot:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面的示例截图如下：
- en: '![Figure 11.9 – Cart and checkout page'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.9 – 购物车和结账页面'
- en: '](img/Figure_11.9_B18507.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.9_B18507.jpg)'
- en: Figure 11.9 – Cart and checkout page
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – 购物车和结账页面
- en: We will use `InputTagHelper` as hidden fields and textboxes to pass any additional
    information back to the action method. The good thing about textboxes is if the
    `id` attribute of the textbox matches the property name, that data is automatically
    passed back to the action method and ASP.NET Core MVC's model binding system will
    take care of mapping it to the required object, which, in this case, is of the
    `Packt.Ecommerce.DTO.Models.OrderDetailsViewModel` type, which finally submits
    the order, generates invoices, and redirects to the `Orders/Index` action method.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `InputTagHelper` 作为隐藏字段和文本框，以将任何附加信息传递回动作方法。文本框的好处是，如果文本框的 `id` 属性与属性名称匹配，那么数据将自动传递回动作方法，ASP.NET
    Core MVC 的模型绑定系统将负责将其映射到所需的对象，在这种情况下，是 `Packt.Ecommerce.DTO.Models.OrderDetailsViewModel`
    类型的对象，最终提交订单、生成发票并重定向到 `Orders/Index` 动作方法。
- en: Note
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding screenshot, although we have a checkout form that includes
    payment information in production applications, we would be integrating with a
    third-party payment gateway and, usually, this entire form sits on t[he payment
    gateway side of the application for various security reas](https://razorpay.com/docs/payment-gateway/server-integration/dot-net/)ons.
    [https://stripe.com/docs/api](https://stripe.com/docs/api) and [https://razorpay.com/docs/payment-gateway/server-integration/dot-net/](https://razorpay.com/docs/payment-gateway/server-integration/dot-net/)
    are a couple of such third-party providers that help in payment gateway integration.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，尽管在生产应用中我们有一个包含支付信息的结账表单，但我们将与第三方支付网关集成，通常，整个表单都位于应用程序的支付网关侧，出于各种安全原因。[https://razorpay.com/docs/payment-gateway/server-integration/dot-net/](https://razorpay.com/docs/payment-gateway/server-integration/dot-net/)
    和 [https://stripe.com/docs/api](https://stripe.com/docs/api) 是这类第三方提供商的几个例子，它们有助于支付网关集成。
- en: Creating the Orders/Index view
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Orders/Index 视图
- en: 'Finally, we will have the view to see the invoice of the order, which is a
    simple read-only view that displays invoice information sent from the `Index`
    action method of `OrdersController`. A sample of this page is shown in the following
    screenshot:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将有一个查看订单发票的视图，这是一个简单的只读视图，显示从 `OrdersController` 的 `Index` 动作方法发送的发票信息。以下截图显示了此页面的一个示例：
- en: '![Figure 11.10 – Final invoice'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.10 – 最终发票'
- en: '](img/Figure_11.10_B18507.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.10_B18507.jpg)'
- en: Figure 11.10 – Final invoice
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 – 最终发票
- en: This completes the integration of various views and, as you have seen, we have
    limited the views to the most important flow in the e-commerce application. However,
    you can further add more features using the same principles.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了各种视图的集成，如您所见，我们已经将视图限制在电子商务应用程序中最重要的流程中。然而，您可以使用相同的原理进一步添加更多功能。
- en: Understanding Blazor
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Blazor
- en: Blazor is a new framework available from .NET Core 3.1 onward to develop the
    frontend layer of the application. It's one of the alternatives to MVC and Razor
    Pages and the application model is very much close to SPA; however, instead of
    JavaScript, we can write the logic in C# and Razor syntax.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 是从 .NET Core 3.1 开始可用的新框架，用于开发应用程序的前端层。它是 MVC 和 Razor Pages 的替代方案之一，并且应用程序模型非常接近
    SPA；然而，我们可以用 C# 和 Razor 语法编写逻辑，而不是 JavaScript。
- en: 'All the code that is written in Blazor is placed in something called a `.Razor`
    and is used to represent the application; be it the entire web page or a small
    dialog popup, everything is created as a component in Blazor applications. A typical
    Razor component looks like the one in the following code snippet:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 Blazor 编写代码都放在一个名为 `.Razor` 的地方，用于表示应用程序；无论是整个网页还是一个小对话框弹出窗口，所有内容都在 Blazor
    应用程序中作为一个组件创建。一个典型的 Razor 组件如下代码片段所示：
- en: '[PRE133]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: In this code, we are creating a page that increments a counter on the click
    of a button, and the logic for the click event is handled in the C# code, which
    updates the value in HTML. This page can be accessed using the `/counter` relative
    URL.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们创建了一个页面，该页面在按钮点击时增加计数器，点击事件的逻辑由 C# 代码处理，该代码更新 HTML 中的值。此页面可以通过 `/counter`
    相对 URL 访问。
- en: 'The major difference between Blazor and other MVC/Razor Pages is that unlike
    the request-response model, where every request is sent to the server and HTML
    is sent back to the browser, Blazor packages all the components (just like SPA)
    and loads them on the client-side. When the application is requested for the first
    time, any subsequent calls to the server are to retrieve/submit any API data or
    to update the DOM. Blazor supports the following two hosting models:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 与其他 MVC/Razor Pages 之间的主要区别在于，与请求-响应模型不同，其中每个请求都发送到服务器，并将 HTML 发送回浏览器，Blazor
    将所有组件打包（就像 SPA 一样）并在客户端加载。当应用程序首次请求时，任何后续对服务器的调用都是为了检索/提交任何 API 数据或更新 DOM。Blazor
    支持以下两种托管模型：
- en: '**Blazor WebAssembly** (**WASM**): WASM is low-level instructions that can
    be run on modern browsers, which further helps to run code written in high-level
    languages such as C# on a browser without any additional plugins. The Blazor WASM
    hosting model makes use of the open web standards given by WASM and runs the C#
    code of any Blazor WASM application in a sandbox environment on a browser. At
    a high level, all the Blazor components are compiled into .NET assemblies and
    are downloaded to the browser, and WASM loads the .NET Core runtime and loads
    all the assemblies. It further uses JavaScript interop to refresh the DOM; the
    only calls to the server would be any backend APIs. The architecture is shown
    in the following figure:'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blazor WebAssembly**（**WASM**）：WASM 是可以在现代浏览器上运行的低级指令，这有助于在浏览器上运行用高级语言（如
    C#）编写的代码，而无需任何附加插件。Blazor WASM 托管模型利用 WASM 提供的开放网络标准，在浏览器上的沙盒环境中运行任何 Blazor WASM
    应用程序的 C# 代码。在较高层次上，所有 Blazor 组件都编译成 .NET 程序集，并下载到浏览器，WASM 加载 .NET Core 运行时和所有程序集。它进一步使用
    JavaScript 互操作来刷新 DOM；唯一的服务器调用将是任何后端 API。架构如下所示：'
- en: '![Figure 11.11 – Blazor WASM hosting'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.11 – Blazor WASM 托管'
- en: '](img/Figure_11.11_B18507.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.11_B18507.jpg)'
- en: Figure 11.11 – Blazor WASM hosting
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 – Blazor WASM 托管
- en: '`blazor.server.js` and uses SignalR to receive all the DOM updates, and this
    further means that every user interaction will have a server call (although very
    light). The architecture is shown in the following figure:'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blazor.server.js` 并使用 SignalR 接收所有 DOM 更新，这意味着每个用户交互都会有一个服务器调用（尽管非常轻量）。架构如下所示：'
- en: '![Figure 11.12 – Blazor Server hosting'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.12 – Blazor Server 托管'
- en: '](img/Figure_11.12_B18507.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.12_B18507.jpg)'
- en: Figure 11.12 – Blazor Server hosting
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – Blazor Server 托管
- en: '.NET 6 comes with full tooling support for both hosting models, with their
    own project templates, and has its pros and cons, which are further explained
    here: [https://docs.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-6.0).'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6 为两种托管模型提供完整的工具支持，包括它们自己的项目模板，并且各有优缺点，这些将在以下内容中进一步解释：[https://docs.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-6.0)。
- en: 'Let''s now create a frontend application as per the following steps using a
    Blazor Server application, which allows us to add/modify product details for our
    e-commerce application:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照以下步骤使用 Blazor Server 应用程序创建一个前端应用程序，这允许我们为我们的电子商务应用程序添加/修改产品详情：
- en: Add a new Blazor Server application called `Packt.Ecommerce.Blazorweb` to the
    enterprise solution and add the `Products.razor`, `AddProduct.Razor`, and `EditProduct.razor`
    Razor components to the `Pages` folder.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为 `Packt.Ecommerce.Blazorweb` 的新 Blazor Server 应用程序添加到企业解决方案中，并将 `Products.razor`、`AddProduct.Razor`
    和 `EditProduct.razor` Razor 组件添加到 `Pages` 文件夹。
- en: This project contains the `Program` class, which is exactly like any other ASP.NET
    Core application with a few additional Blazor services. `_Host.cshtml` is the
    root of the application and an initial call to the application is received by
    this page and is responded to with HTML. This page further references the `blazor.server.js`
    script file for the SignalR connection. Another important component is the `App.Razor`
    component, which takes care of routing based on the URL. In Blazor, any component
    that needs to be mapped to a specific URL will have the `@page` directive at the
    beginning of the component, which specifies the relative URL of the application.
    `App.Razor` intercepts the URLs and routes them to the specified component. All
    Razor components are part of a `Pages` folder, and the `Data` folder comes with
    a sample model and a service that is used in the `FetchData.razor` component.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此项目包含 `Program` 类，它与其他任何 ASP.NET Core 应用程序完全相同，只是增加了一些额外的 Blazor 服务。`_Host.cshtml`
    是应用程序的根，应用程序的初始调用由该页面接收，并以 HTML 进行响应。此页面进一步引用 `blazor.server.js` 脚本文件以建立 SignalR
    连接。另一个重要组件是 `App.Razor` 组件，它负责基于 URL 的路由。在 Blazor 中，任何需要映射到特定 URL 的组件都将在其开头包含
    `@page` 指令，该指令指定应用程序的相对 URL。`App.Razor` 拦截 URL 并将它们路由到指定的组件。所有 Razor 组件都是 `Pages`
    文件夹的一部分，而 `Data` 文件夹包含用于 `FetchData.razor` 组件的示例模型和服务。
- en: 'Let''s add the following code to `NavMenu.razor` to add the `Products` navigation
    to the left menu. At this stage, if you run the application, you should be able
    to see the left menu with the `Products` navigation; however, it will not navigate
    to any page:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `NavMenu.razor` 中添加以下代码以将 `Products` 导航添加到左侧菜单。在这个阶段，如果你运行应用程序，你应该能够看到带有
    `Products` 导航的左侧菜单；然而，它不会导航到任何页面：
- en: '[PRE142]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'As we are going to retrieve data from the API, we need to inject `HTTPClient`
    into our `Program` class, just as how it''s done in ASP.NET Core applications.
    So, add the following code to the `Program` class:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将从 API 获取数据，我们需要将 `HTTPClient` 注入到我们的 `Program` 类中，就像在 ASP.NET Core 应用程序中所做的那样。因此，将以下代码添加到
    `Program` 类中：
- en: '[PRE143]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Add the following setting of `ApplicationSettings:ProductsApiEndpoint` to `appsettings.json`:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `ApplicationSettings:ProductsApiEndpoint` 设置添加到 `appsettings.json`：
- en: '[PRE144]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Since we are going to bind the `products` data, let''s add `Packt.Ecommerce.DTO.Models`
    as a project reference to `Packt.Ecommerce.Blazorweb`. In the `Pages` folder,
    add the following code to the `Products.razor` page inside the `@code` block in
    which we are creating a `HttpClient` object using `IHttpClientFactory`, which
    will be injected in the next step, and retrieving the `products` data in the `OnInitializedAsync`
    method:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将要绑定 `products` 数据，所以让我们将 `Packt.Ecommerce.DTO.Models` 添加为 `Packt.Ecommerce.Blazorweb`
    项目的引用。在 `Pages` 文件夹中，将以下代码添加到 `Products.razor` 页面的 `@code` 块内，我们在其中使用 `IHttpClientFactory`
    创建一个 `HttpClient` 对象，该对象将在下一步注入，并在 `OnInitializedAsync` 方法中检索 `products` 数据：
- en: '[PRE145]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Next, add the following code at the beginning of the `Products.Razor` page
    (outside the `@code` block). Here, we set the relative route for this component
    via the `@page` directive to `/products`. Next, we inject `IHttpClientFactory`
    and the other required namespaces, then add the HTML part that renders the list
    of products. As you can see, it''s a mixture of HTML and Razor syntax:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Products.Razor`页面的开头添加以下代码（在`@code`块外部）。在这里，我们通过`@page`指令设置此组件的相对路由为`/products`。接下来，我们注入`IHttpClientFactory`和其他所需的命名空间，然后添加渲染产品列表的HTML部分。如您所见，它是HTML和Razor语法的混合体：
- en: '[PRE146]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'At this point, if you run the application, you should see the output shown
    in the following screenshot:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果您运行应用程序，应该会看到以下截图所示的输出：
- en: '![Figure 11.13 – Product list Blazor UI'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.13 – 产品列表Blazor UI'
- en: '](img/Figure_11.13_B18507.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.13_B18507.jpg)'
- en: Figure 11.13 – Product list Blazor UI
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13 – 产品列表Blazor UI
- en: Next, let's create the `Add/Edit` pages in which we will make use of Blazor
    forms. Some of the important tooling/components that are available for forms are
    the following.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建`Add/Edit`页面，我们将使用Blazor表单。表单中可用的一些重要工具/组件如下。
- en: 'A Blazor form is created using an out-of-the-box template in Blazor known as
    `EditForm`, and it can be bound directly to any C# object using a model property.
    A typical `EditForm` looks as in the following code snippet. Here, we are defining
    to call the `OnSubmit` method when the form is submitted. Let''s add this to `AddProduct.razor`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor表单是使用Blazor中称为`EditForm`的内置模板创建的，并且可以直接使用模型属性绑定到任何C#对象。一个典型的`EditForm`如下面的代码片段所示。在这里，我们定义在表单提交时调用`OnSubmit`方法。让我们将其添加到`AddProduct.razor`中：
- en: '[PRE147]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Here, `product` is the object of the model that we want to use, which in our
    case is `Packt.Ecommerce.DTO.Models.ProductDetailsViewModel`. To bind data to
    any control, we can use a mix of HTML and Razor syntax, as shown in the following
    code. Here, we are binding the `Name` property of the product object to a textbox
    and, similarly, the `Category` property to the dropdown. Once you enter any value
    in the textbox or select a value in the dropdown, it is automatically available
    in these properties to pass it back to any backend API or database. Let''s add
    all the required properties to the HTML element in a similar manner:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`product`是我们想要使用的模型对象，在我们的案例中是`Packt.Ecommerce.DTO.Models.ProductDetailsViewModel`。要将数据绑定到任何控件，我们可以使用HTML和Razor语法的组合，如下面的代码所示。在这里，我们将产品对象的`Name`属性绑定到文本框，同样，将`Category`属性绑定到下拉列表。一旦你在文本框中输入任何值或在下拉列表中选择一个值，它就会自动出现在这些属性中，以便将其传递回任何后端API或数据库。让我们以类似的方式将所有必需的属性添加到HTML元素中：
- en: '[PRE148]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Blazor forms support data validation using data annotations, so any model that
    we want to bind to the UI can have data annotations, and Blazor applies those
    validations out of the box to the controls that the property is bound to. To apply
    validations, we add the `DataAnnotationsValidator` component and can use the `ValidationSummary`
    component to show a summary of all the validation failures. You can find more
    details at [https://docs.microsoft.com/en-us/aspnet/core/blazor/forms-validation?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/blazor/forms-validation?view=aspnetcore-6.0).
    We can further use the `ValidationMessage` component at the control level, as
    shown in the following code snippet:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor表单支持使用数据注解进行数据验证，因此任何我们想要绑定到UI的模型都可以有数据注解，Blazor会自动将这些验证应用到绑定的控件上。要应用验证，我们添加`DataAnnotationsValidator`组件，并可以使用`ValidationSummary`组件来显示所有验证失败的摘要。更多详细信息请参阅[https://docs.microsoft.com/en-us/aspnet/core/blazor/forms-validation?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/blazor/forms-validation?view=aspnetcore-6.0)。我们还可以在控件级别使用`ValidationMessage`组件，如下面的代码片段所示：
- en: '[PRE149]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: In the `code` component, add an object of `ProductDetailsViewModel` and name
    it as the product, that is, as defined in the `Model` attribute of `EditForm`,
    and further implement the `OnSubmit` method.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`code`组件中，添加一个`ProductDetailsViewModel`对象，并将其命名为product，即如`EditForm`的`Model`属性中定义的那样，并进一步实现`OnSubmit`方法。
- en: 'The entire code for `AddProduct.Razor` and `EditProduct.Razor` can be found
    in the GitHub repository, and once we run the application, we can see the following
    page:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddProduct.Razor`和`EditProduct.Razor`的完整代码可以在GitHub仓库中找到，一旦运行应用程序，我们就可以看到以下页面：'
- en: '![Figure 11.14 – The Add Product Blazor UI'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.14 – 添加产品Blazor UI'
- en: '](img/Figure_11.14_B18507.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.14_B18507.jpg)'
- en: Figure 11.14 – The Add Product Blazor UI
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14 – 添加产品Blazor UI
- en: This is a basic sample for building the frontend using Blazor that performs
    list, create, and update operations. However, there are many concepts in Blazor
    that can be further explored at [https://docs.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-6.0).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 Blazor 构建前端的基本示例，它执行列表、创建和更新操作。然而，Blazor 中还有许多概念可以进一步探索，请参阅[https://docs.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-6.0)。
- en: Summary
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we understood various aspects of the presentation layer and
    UI design. Along with this, we also learned various skills in developing the presentation
    layer using ASP.NET Core MVC and Razor Pages, and then, finally, we implemented
    the presentation layer for our enterprise application using ASP.NET Core MVC and
    Blazor.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了表示层和 UI 设计的各个方面。此外，我们还学习了使用 ASP.NET Core MVC 和 Razor Pages 开发表示层的各种技能，最后，我们使用
    ASP.NET Core MVC 和 Blazor 为我们的企业应用程序实现了表示层。
- en: With these skills, you should be able to build the presentation layer using
    ASP.NET Core MVC, Razor Pages, and Blazor, and integrate it with the backend API.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些技能，你应该能够使用 ASP.NET Core MVC、Razor Pages 和 Blazor 构建表示层，并将其与后端 API 集成。
- en: In the next chapter, we will see how to integrate authentication in our system
    across various layers of the application.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何将身份验证集成到我们系统的各个应用层中。
- en: Questions
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which one of the following is a recommended page to define the left-side navigation
    that needs to appear throughout the web application?
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个是推荐用于定义在整个 Web 应用程序中需要出现的左侧导航的页面？
- en: a. `_ViewStart.cshtml`
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: a. `_ViewStart.cshtml`
- en: b. `_ViewImports.cshtml`
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: b. `_ViewImports.cshtml`
- en: c. `_Layout.cshtml`
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: c. `_Layout.cshtml`
- en: d. `Error.cshtml`
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: d. `Error.cshtml`
- en: '**Answer: c**'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：c**'
- en: Which of the following pages can be used to configure the `Layout` page for
    the entire application?
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个页面可以用来配置整个应用程序的 `Layout` 页面？
- en: a. `_ViewStart.cshtml`
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: a. `_ViewStart.cshtml`
- en: b. `_ViewImports.cshtml`
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: b. `_ViewImports.cshtml`
- en: c. `_Layout.cshtml`
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: c. `_Layout.cshtml`
- en: d. `Error.cshtml`
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: d. `Error.cshtml`
- en: '**Answer: a**'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：a**'
- en: Which of the following special characters is used to write Razor syntax in a
    `.cshtml` page?
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个特殊字符用于在 `.cshtml` 页面中编写 Razor 语法？
- en: a. `@`
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: a. `@`
- en: b. `#`
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: b. `#`
- en: c. `<% %>`
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: c. `<% %>`
- en: d. None of the above
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: d. 以上皆非
- en: '**Answer: a**'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：a**'
- en: Which method will be called on a button click in the following tag helper code
    in a Razor page application?
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下 Razor 页面应用程序的标签助手代码中，哪个方法会在按钮点击时被调用？
- en: '[PRE150]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: a. `OnGet()`
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: a. `OnGet()`
- en: b. `onDelete()`
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: b. `onDelete()`
- en: c. `OnPostDelete()`
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: c. `OnPostDelete()`
- en: d. `OnDeleteAsync()`
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: d. `OnDeleteAsync()`
- en: '**Answer: c**'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：c**'
- en: Further reading
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.packtpub.com/web-development/html5-and-css3-building-responsive-websites](https://www.packtpub.com/web-development/html5-and-css3-building-responsive-websites)'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/web-development/html5-and-css3-building-responsive-websites](https://www.packtpub.com/web-development/html5-and-css3-building-responsive-websites)'
- en: '[https://www.packtpub.com/product/bootstrap-for-asp-net-mvc-second-edition/9781785889479](https://www.packtpub.com/product/bootstrap-for-asp-net-mvc-second-edition/9781785889479)'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/product/bootstrap-for-asp-net-mvc-second-edition/9781785889479](https://www.packtpub.com/product/bootstrap-for-asp-net-mvc-second-edition/9781785889479)'
- en: '[https://developer.mozilla.org/en-US/docs/WebAssembly](https://developer.mozilla.org/en-US/docs/WebAssembly)'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/WebAssembly](https://developer.mozilla.org/en-US/docs/WebAssembly)'
- en: '[https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-6.0)'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-6.0)'
- en: '[https://docs.microsoft.com/en-us/aspnet/core/mvc/views/partial?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/partial?view=aspnetcore-6.0)'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/mvc/views/partial?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/partial?view=aspnetcore-6.0)'
- en: '[https://developer.mozilla.org/en-US/docs/Learn/Accessibility](https://developer.mozilla.org/en-US/docs/Learn/Accessibility)'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Learn/Accessibility](https://developer.mozilla.org/en-US/docs/Learn/Accessibility)'
