- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: ASP.NET Core Fundamentals (Part 2)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 基础知识（第二部分）
- en: 'In [*Chapter 3*](B18971_03.xhtml#_idTextAnchor130), we learned about three
    important components in ASP.NET Core: routing, configuration, and environment.
    Next, let’s continue to explore the other components in ASP.NET Core.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 3 章*](B18971_03.xhtml#_idTextAnchor130) 中，我们学习了 ASP.NET Core 中的三个重要组件：路由、配置和环境。接下来，让我们继续探索
    ASP.NET Core 中的其他组件。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Logging
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录日志
- en: Middleware
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件
- en: ASP.NET Core provides a flexible logging API that works with many logging providers.
    We can send and store the logs in various destinations, such as the console, text
    files, Azure Application Insights, and so on. When the application has issues,
    logs can help us find out what is going on. Logging belongs to a bigger topic
    called *observability*, which is a set of practices that help us understand the
    state of the application. In this chapter, we will learn how to use the logging
    API in ASP.NET Core.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 提供了一个灵活的日志记录 API，它可以与许多日志提供者一起工作。我们可以将日志发送和存储在多种目的地，例如控制台、文本文件、Azure
    应用洞察等。当应用程序出现问题时，日志可以帮助我们找出发生了什么。记录日志属于一个更大的主题，称为 *可观察性*，它是一组帮助我们了解应用程序状态的实践。在本章中，我们将学习如何在
    ASP.NET Core 中使用日志记录 API。
- en: Middleware is a component that can be plugged into the request pipeline to handle
    requests and responses. It is one of the most important improvements in ASP.NET
    Core compared to the traditional ASP.NET framework. The request pipeline is a
    chain of middleware components, and each of these components can do something
    with the request or response, or pass it to the next middleware component in the
    pipeline. In this chapter, we will learn how to use built-in middleware components
    and how to develop custom middleware components.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是一个可以插入到请求管道中以处理请求和响应的组件。与传统的 ASP.NET 框架相比，这是 ASP.NET Core 中最重要的改进之一。请求管道是一系列中间件组件的链，这些组件中的每一个都可以对请求或响应进行一些操作，或者将其传递给管道中的下一个中间件组件。在本章中，我们将学习如何使用内置的中间件组件以及如何开发自定义中间件组件。
- en: By the end of this chapter, you will be able to use the logging API to log messages,
    set up log levels, and configure log providers. Additionally, you will be able
    to develop custom middleware components to process requests and responses.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用日志记录 API 记录消息、设置日志级别以及配置日志提供者。此外，你将能够开发自定义中间件组件以处理请求和响应。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter4](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter4).
    You can use VS 2022 or VS Code to open the solutions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可以在 [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter4](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter4)
    找到。你可以使用 VS 2022 或 VS Code 打开解决方案。
- en: Logging
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录日志
- en: Logging is an important part of any application. A well-designed logging system
    can capture data that helps you diagnose problems and monitor the application
    in production. Logging gives you insight into how, when, where, and why significant
    system events occurred so that you know how the application is performing and
    how users are interacting with it. Logging may help you to identify security weaknesses
    or potential attacks. Logging can also help you audit users activities.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 记录日志是任何应用程序的重要组成部分。一个设计良好的日志系统可以捕获帮助您诊断问题和监控生产中应用程序的数据。记录日志可以为您提供有关重要系统事件何时、何地以及为何发生的洞察，以便您了解应用程序的性能以及用户如何与之交互。记录日志可能有助于您识别安全漏洞或潜在的攻击。记录日志还可以帮助您审计用户活动。
- en: 'Logging should not impact the performance of the application. It should be
    fast and efficient. It should not affect any logic of the application. When you
    add logging to an application, you should consider the following points:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 记录日志不应影响应用程序的性能。它应该是快速且高效的。它不应影响应用程序的任何逻辑。当您向应用程序添加记录时，您应考虑以下要点：
- en: What information should be logged?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该记录哪些信息？
- en: What format should log messages be in?
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志消息应该是什么格式？
- en: Where should log messages be sent?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志消息应该发送到何处？
- en: How long should log messages be kept?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志消息应该保留多长时间？
- en: How to make sure log messages won’t impact the performance of the application?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保日志消息不会影响应用程序的性能？
- en: In this section, we will discuss how to use the logging system in ASP.NET Core.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何使用 ASP.NET Core 中的日志记录系统。
- en: 'Let''s create a new project to learn how to use the logging API. Create a new
    ASP.NET Core web API project named `LoggingDemo` using the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的项目来学习如何使用记录 API。使用以下命令创建一个名为 `LoggingDemo` 的新 ASP.NET Core Web API
    项目：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can also download the source code named `LoggingDemo` from the `samples/chapter4`
    folder in the chapter’s GitHub repository.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从该章节的 GitHub 存储库中 `samples/chapter4` 文件夹下载名为 `LoggingDemo` 的源代码。
- en: Using built-in logging providers
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内置记录提供程序
- en: 'ASP.NET Core supports a logging API that works with various logging providers,
    including built-in logging providers and third-party logging providers. The default
    ASP.NET Core web API template has the following logging providers registered:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 支持与各种记录提供程序一起工作的记录 API，包括内置记录提供程序和第三方记录提供程序。默认的 ASP.NET Core Web
    API 模板已注册以下记录提供程序：
- en: Console logging provider
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制台记录提供程序
- en: Debug logging provider
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试记录提供程序
- en: '`EventSource` logging provider'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventSource` 记录提供程序'
- en: '`EventLog` logging provider (Windows only)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventLog` 记录提供程序（仅限 Windows）'
- en: 'To clearly see how these logging providers work, let’s remove all the pre-registered
    logging providers and then add the console logging provider. Open the `Program.cs`
    file and add the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地看到这些记录提供程序是如何工作的，让我们先移除所有预先注册的记录提供程序，然后添加控制台记录提供程序。打开 `Program.cs` 文件并添加以下代码：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, only the console logging provider is enabled. Let''s use the console logging
    provider to output log messages. Open the `WeatherForecastController.cs` file;
    you can see the `ILogger<WeatherForecastController>` interface is injected into
    the constructor already:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只有控制台记录提供程序被启用。让我们使用控制台记录提供程序来输出日志消息。打开 `WeatherForecastController.cs` 文件；您可以看到
    `ILogger<WeatherForecastController>` 接口已经注入到构造函数中：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Open the `WeatherForecastController.cs` file in the project. Add the following
    code to the `Get()` method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中打开 `WeatherForecastController.cs` 文件。将以下代码添加到 `Get()` 方法中：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the application using the `dotnet run` command. Request the `/WeatherForecast`
    endpoint using the browser. You can see the log message in the console:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dotnet run` 命令运行应用程序。使用浏览器请求 `/WeatherForecast` 端点。您可以在控制台中看到日志消息：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you run the application in VS 2022 and run the application using the *F5*
    key, you can see a log message in the console window, but you cannot see it in
    the **Output** window of VS 2022:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 VS 2022 中运行应用程序并使用 *F5* 键运行应用程序，您可以在控制台窗口中看到日志消息，但您无法在 VS 2022 的 **输出**
    窗口中看到：
- en: '![Figure 4.1 – The Output window for debug messages in VS 2022](img/B18971_04_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – VS 2022 中调试消息的输出窗口](img/B18971_04_01.jpg)'
- en: Figure 4.1 – The Output window for debug messages in VS 2022
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – VS 2022 中调试消息的输出窗口
- en: 'To send logging messages to the `Debug` logging provider. Open the `Program.cs`
    file and add the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要将日志消息发送到 `Debug` 记录提供程序，打开 `Program.cs` 文件并添加以下代码：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Press *F5* to run the application in VS 2022 again. Now, you can see the log
    message in the **Output** window:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 按 *F5* 再次在 VS 2022 中运行应用程序。现在，您可以在 **输出** 窗口中看到日志消息：
- en: '![Figure 4.2 – Debug logging messages in VS 2022](img/B18971_04_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – VS 2022 中的调试日志消息](img/B18971_04_02.jpg)'
- en: Figure 4.2 – Debug logging messages in VS 2022
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – VS 2022 中的调试日志消息
- en: So, if want to add more other logging providers, we can call the extension methods
    of the `ILoggingBuilder` interface. Some third-party logging providers also provide
    the extension methods of the `ILoggingBuilder` interface.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想添加更多的其他记录提供程序，我们可以调用 `ILoggingBuilder` 接口的扩展方法。一些第三方记录提供程序也提供了 `ILoggingBuilder`
    接口的扩展方法。
- en: 'For example, if we need to write the log messages to the Windows event log,
    we can add the `EventLog` logging provider. Add the following code to the `Program.cs`
    file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们需要将日志消息写入 Windows 事件日志，我们可以添加 `EventLog` 记录提供程序。将以下代码添加到 `Program.cs`
    文件中：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Test the application and we should be able to see the log messages in the Windows
    event log.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应用程序，我们应该能够在 Windows 事件日志中看到日志消息。
- en: Wait – why can’t we see it in the event log?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 等等——为什么我们看不到它在事件日志中？
- en: 'This is a specific scenario for the `EventLog` logging provider. Because it
    is a Windows-only logging provider, it does not inherit the default logging provider
    settings. We need to specify the logging level in the `appsettings.json` file.
    Open the `appsettings.Development.json` file and update the `Logging` section:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个针对 `EventLog` 记录提供程序的特定场景。因为它是一个仅适用于 Windows 的记录提供程序，所以它不会继承默认的记录提供程序设置。我们需要在
    `appsettings.json` 文件中指定记录级别。打开 `appsettings.Development.json` 文件并更新 `Logging`
    部分：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We need to add an `EventLog` section to specify the logging level for the `EventLog`
    logging provider. If it is not specified, the default logging level is `Warning`,
    which is higher than `Information`. This would result in us not being able to
    see `Information` logging messages. Run the application again, and now we can
    see the log messages in the event log:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个 `EventLog` 部分来指定 `EventLog` 日志提供程序的日志级别。如果没有指定，默认日志级别是 `Warning`，这比
    `Information` 高。这将导致我们无法看到 `Information` 日志消息。再次运行应用程序，现在我们可以在事件日志中看到日志消息：
- en: '![Figure 4.3 – Event log on Windows](img/B18971_04_03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – Windows 事件日志](img/B18971_04_03.jpg)'
- en: Figure 4.3 – Event log on Windows
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – Windows 事件日志
- en: We just introduced a new term – **logging level**. What is it?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚介绍了一个新术语——**日志级别**。它是什么？
- en: Logging levels
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志级别
- en: 'In the preceding example, we used a `Log` method that accepts a `LogLevel`
    parameter. The `LogLevel` parameter indicates the severity of the log message.
    The `LogLevel` parameter can be one of the following values:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了一个接受 `LogLevel` 参数的 `Log` 方法。`LogLevel` 参数表示日志消息的严重性。`LogLevel`
    参数可以是以下值之一：
- en: '| **Level** | **Value** | **Description** |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **级别** | **值** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Trace` | `0` | Used for the most detailed messages. These messages may contain
    sensitive application data. These messages are disabled by default and should
    never be enabled in a production environment. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `Trace` | `0` | 用于最详细的日志消息。这些消息可能包含敏感的应用程序数据。默认情况下，这些消息是禁用的，不应在生产环境中启用。 |'
- en: '| `Debug` | `1` | Used for debugging information and development. Use with
    caution in production because of the high volume. Normally, these logs should
    not have a long-term value. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `Debug` | `1` | 用于调试信息和开发。在生产环境中使用时请谨慎，因为日志量很大。通常，这些日志不应具有长期价值。 |'
- en: '| `Information` | `2` | Used for tracking the general flow of the application.
    These logs should have a long-term value. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `Information` | `2` | 用于跟踪应用程序的一般流程。这些日志应具有长期价值。 |'
- en: '| `Warning` | `3` | Used to indicate potential problems or unexpected events.
    These issues typically do not cause the application to fail. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `Warning` | `3` | 用于指示潜在问题或意外事件。这些问题通常不会导致应用程序失败。 |'
- en: '| `Error` | `4` | Used to indicate failures in the current operation or request
    and not an application-wide failure. These errors and exceptions cannot be handled.
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `Error` | `4` | 用于指示当前操作或请求中的失败，而不是应用程序级别的失败。这些错误和异常无法处理。 |'
- en: '| `Critical` | `5` | Used to indicate critical failures that require immediate
    attention; for example, data loss scenarios. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `Critical` | `5` | 用于指示需要立即注意的严重故障；例如，数据丢失场景。 |'
- en: '| `None` | `6` | Used to specify a logging category that should not write messages.
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `None` | `6` | 用于指定不应写入消息的日志类别。 |'
- en: Table 4.1 – Logging levels
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 – 日志级别
- en: 'To simplify the method call, the `ILogger<TCategoryName>` interface provides
    the following extension methods to log messages for different logging levels:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化方法调用，`ILogger<TCategoryName>` 接口提供了以下扩展方法来记录不同日志级别的消息：
- en: '`LogTrace()`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LogTrace()`'
- en: '`LogDebug()`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LogDebug()`'
- en: '`LogInformation()`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LogInformation()`'
- en: '`LogWarning()`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LogWarning()`'
- en: '`LogError()`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LogError()`'
- en: '`LogCritical()`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LogCritical()`'
- en: 'You can use the `LogInformation()` method to replace the `Log()` method in
    the preceding example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `LogInformation()` 方法替换前面的示例中的 `Log()` 方法：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You will see the same log message in the console window.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在控制台窗口中看到相同的日志消息。
- en: 'Let’s add a `LogTrace()` method in the `WeatherForecastController.cs` file,
    which will send a `Trace` log:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `WeatherForecastController.cs` 文件中添加一个 `LogTrace()` 方法，它将发送一个 `Trace` 日志：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the application using `dotnet run` and request the `WeatherForecast` endpoint
    again. You will not see the trace message in the console window. Why? Because
    the trace message is disabled by default. Open the `appsettings.json` file; we
    can find the following configuration:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dotnet run` 运行应用程序，并再次请求 `WeatherForecast` 端点。你将在控制台窗口中看不到跟踪消息。为什么？因为跟踪消息默认是禁用的。打开
    `appsettings.json` 文件；我们可以找到以下配置：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Based on the configuration, the default logging level is `Information`. Look
    back at the logging level table we introduced before. The `Trace` logging level
    is 0, which is less than the `Information` logging level. So, the `Trace` logging
    level will not output by default. To enable the `Trace` logging level, we need
    to change the `Default` logging level to `Trace`. But there is another question
    – should we enable `Trace` logging for all environments?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 根据配置，默认日志级别是 `Information`。回顾一下我们之前介绍的日志级别表。`Trace` 日志级别是 0，小于 `Information`
    日志级别。因此，默认情况下不会输出 `Trace` 日志级别。要启用 `Trace` 日志级别，我们需要将 `Default` 日志级别更改为 `Trace`。但还有一个问题——我们是否应该为所有环境启用
    `Trace` 日志？
- en: 'The answer is *it depends*. The `Trace` logging level is used for the most
    detailed messages, which means it may contain sensitive application data. We can
    enable `Trace` logging in the development environment, but we may not want to
    enable it in the production environment. To achieve this, we can use the `appsettings.Development.json`
    file to override the `appsettings.json` file. That is what we learned in [*Chapter
    3*](B18971_03.xhtml#_idTextAnchor130). Open the `appsettings.Development.json`
    file and update the following configuration to enable the `Trace` log:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 *视情况而定*。`Trace` 日志级别用于最详细的消息，这意味着它可能包含敏感的应用程序数据。我们可以在开发环境中启用 `Trace` 日志，但在生产环境中可能不想启用它。为了实现这一点，我们可以使用
    `appsettings.Development.json` 文件来覆盖 `appsettings.json` 文件。这就是我们在 [*第 3 章*](B18971_03.xhtml#_idTextAnchor130)
    中学到的。打开 `appsettings.Development.json` 文件并更新以下配置以启用 `Trace` 日志：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, run the application again. You should be able to see a trace message in
    the console window for the development environment.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行应用程序。你应该能够在开发环境的控制台窗口中看到跟踪消息。
- en: Important note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To specify the logging level for the production environment, we can add an `appsettings.Production.json`
    file, and then override the settings for the `Logging` section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定生产环境的日志级别，我们可以添加一个 `appsettings.Production.json` 文件，然后覆盖 `Logging` 部分的设置。
- en: Keep in mind that the logging levels such as `Trace`, `Debug`, and `Information`
    will produce a lot of log messages. If we need to enable them in the production
    environment for troubleshooting, we need to be careful. Think about where we want
    to store logging messages.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`Trace`、`Debug` 和 `Information` 等日志级别会产生大量的日志消息。如果我们需要在生产环境中启用它们进行故障排除，我们需要小心。考虑一下我们希望将日志消息存储在哪里。
- en: 'You may notice that in the `appsettings.json` file, there is a `Microsoft.AspNetCore`
    logging section. It is used to control the logging level for the ASP.NET Core
    framework. ASP.NET Core uses the category name to differentiate logging messages
    produced from the framework and the application. Check the code where we inject
    the `ILogger` service into the controller:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到在 `appsettings.json` 文件中有一个 `Microsoft.AspNetCore` 日志部分。它用于控制 ASP.NET
    Core 框架的日志级别。ASP.NET Core 使用类别名称来区分框架和应用产生的日志消息。检查我们向控制器注入 `ILogger` 服务的代码：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `ILogger<TCategoryName>` interface is defined in the `Microsoft.Extensions.Logging`
    namespace. The `TCategoryName` type parameter is used to categorize log messages.
    You can use any string values for the category name, but using the class name
    as the logging category name is a common practice.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`ILogger<TCategoryName>` 接口定义在 `Microsoft.Extensions.Logging` 命名空间中。`TCategoryName`
    类型参数用于对日志消息进行分类。您可以使用任何字符串值作为类别名称，但使用类名作为日志类别名称是一种常见做法。'
- en: Logging parameters
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志参数
- en: 'These `Log{LOG LEVEL}()` methods have some overloads, such as the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `Log{LOG LEVEL}()` 方法有一些重载，例如以下所示：
- en: '`Log{LOG LEVEL}(string? message, params` `object?[] args)`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log{LOG LEVEL}(string? message, params object?[] args)`'
- en: '`Log{LOG LEVEL}(EventId eventId, string? message, params` `object?[] args)`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log{LOG LEVEL}(EventId eventId, string? message, params object?[] args)`'
- en: '`Log{LOG LEVEL}(Exception exception, string message, params` `object[] args)`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log{LOG LEVEL}(Exception exception, string message, params object[] args)`'
- en: '`Log{LOG LEVEL}(EventId eventId, Exception? exception, string? message, params`
    `object?[] args)`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log{LOG LEVEL}(EventId eventId, Exception? exception, string? message, params
    object?[] args)`'
- en: 'The parameters of these methods are set out here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的参数在此列出：
- en: The `eventId` parameter is used to identify the log message
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eventId` 参数用于标识日志消息'
- en: The `message` parameter is used as a format string
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message` 参数用作格式化字符串'
- en: The `args` parameter is used to pass arguments for the format string
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args` 参数用于传递格式化字符串的参数'
- en: The `exception` parameter is used to pass the exception object
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exception` 参数用于传递异常对象'
- en: 'For example, we can define an `EventIds` class to identify log messages, like
    so:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义一个`EventIds`类来识别日志消息，如下所示：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we can use the `eventId` parameter to identify log messages:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`eventId`参数来识别日志消息：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Some logging providers can use the `eventId` parameter to filter log messages.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一些日志提供者可以使用`eventId`参数来过滤日志消息。
- en: 'We have introduced how to use the `message` parameter. You can use a plain
    string as the message, or you can use a format string and use the `args` parameter
    to pass arguments for the format string. Here is an example that uses the `message`
    and `args` parameters:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何使用`message`参数。你可以使用一个普通字符串作为消息，或者你可以使用格式化字符串并使用`args`参数为格式化字符串传递参数。以下是一个使用`message`和`args`参数的示例：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If an exception occurs, you can use the `LogError()` method with the `exception`
    parameter to log the exception:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生异常，你可以使用带有`exception`参数的`LogError()`方法来记录异常：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When using the `LogError()` method to log an exception, it is important to pass
    the exception object to the `exception` parameter. This is essential in order
    to preserve stack trace information; simply logging the exception message is not
    sufficient.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`LogError()`方法记录异常时，将异常对象传递给`exception`参数非常重要。这是保留堆栈跟踪信息所必需的；仅仅记录异常消息是不够的。
- en: Using third-party logging providers
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用第三方日志提供者
- en: The logging system in ASP.NET Core is designed to be extensible. The default
    logging providers, including the console logging provider and the `Debug` logging
    provider, can output logging messages in the console window or debug window, which
    is convenient for development. But in the production environment, we may want
    to send log messages to a file, a database, or a remote logging service. We can
    use third-party logging providers to achieve this.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 的日志系统设计为可扩展。默认日志提供者，包括控制台日志提供者和`Debug`日志提供者，可以在控制台窗口或调试窗口中输出日志消息，这对于开发来说很方便。但在生产环境中，我们可能希望将日志消息发送到文件、数据库或远程日志服务。我们可以使用第三方日志提供者来实现这一点。
- en: 'There are many third-party logging frameworks or libraries that work with ASP.NET
    Core, such as the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多第三方日志框架或库与 ASP.NET Core 一起工作，例如以下这些：
- en: '| **Logging provider** | **Website** | **GitHub repo** |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **日志提供者** | **网站** | **GitHub 仓库** |'
- en: '| --- | --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Serilog` | [https://serilog.net/](https://serilog.net/) | [https://github.com/serilog/serilog-aspnetcore](https://github.com/serilog/serilog-aspnetcore)
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `Serilog` | [https://serilog.net/](https://serilog.net/) | [https://github.com/serilog/serilog-aspnetcore](https://github.com/serilog/serilog-aspnetcore)
    |'
- en: '| `NLog` | [https://nlog-project.org/](https://nlog-project.org/) | [https://github.com/NLog/NLog.Extensions.Logging](https://github.com/NLog/NLog.Extensions.Logging)
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `NLog` | [https://nlog-project.org/](https://nlog-project.org/) | [https://github.com/NLog/NLog.Extensions.Logging](https://github.com/NLog/NLog.Extensions.Logging)
    |'
- en: '| `log4net` | [https://logging.apache.org/log4net/](https://logging.apache.org/log4net/)
    | [https://github.com/huorswords/Microsoft.Extensions.Logging.Log4Net.AspNetCore](https://github.com/huorswords/Microsoft.Extensions.Logging.Log4Net.AspNetCore)
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `log4net` | [https://logging.apache.org/log4net/](https://logging.apache.org/log4net/)
    | [https://github.com/huorswords/Microsoft.Extensions.Logging.Log4Net.AspNetCore](https://github.com/huorswords/Microsoft.Extensions.Logging.Log4Net.AspNetCore)
    |'
- en: Table 4.2 – Third-party logging providers
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2 – 第三方日志提供者
- en: 'Some other platforms provide rich features for collecting and analyzing the
    log messages, such as the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他平台提供了丰富的功能来收集和分析日志消息，例如以下这些：
- en: '**Exceptionless** ([https://exceptionless.com/](https://exceptionless.com/))'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Exceptionless** ([https://exceptionless.com/](https://exceptionless.com/))'
- en: '**ELK** **Stack** ([https://www.elastic.co/elastic-stack/](https://www.elastic.co/elastic-stack/))'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ELK Stack** ([https://www.elastic.co/elastic-stack/](https://www.elastic.co/elastic-stack/))'
- en: '**Sumo** **Logic** ([https://www.sumologic.com/](https://www.sumologic.com/))'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sumo Logic** ([https://www.sumologic.com/](https://www.sumologic.com/))'
- en: '**Seq** ([https://datalust.co/seq](https://datalust.co/seq))'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Seq** ([https://datalust.co/seq](https://datalust.co/seq))'
- en: '**Sentry** ([https://sentry.io](https://sentry.io))'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sentry** ([https://sentry.io](https://sentry.io))'
- en: These platforms can provide a dashboard to view log messages. Technically, they
    are not just logging providers but also platforms for observability that contain
    logging, tracing, metrics, and so on.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些平台可以提供一个仪表板来查看日志消息。技术上，它们不仅仅是日志提供者，还包含日志、跟踪、指标等在内的可观察性平台。
- en: Let’s start with a simple example. How can we print logging messages to a file?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始。我们如何将日志消息打印到文件中？
- en: 'We can use **Serilog** to write the log messages to a file. Serilog is a popular
    logging framework that works with .NET. It provides a standard logging API and
    a rich set of sinks that write log events to storage in various formats. These
    sinks target a variety of destinations, such as the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**Serilog**将日志消息写入文件。Serilog是一个流行的日志框架，与.NET一起工作。它提供了一个标准的日志API和一组丰富的sinks，可以将日志事件以各种格式写入存储。这些sinks针对各种目的地，例如以下内容：
- en: File
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件
- en: Azure Application Insights
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Application Insights
- en: Azure Blob Storage
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Blob Storage
- en: Azure Cosmos DB
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Cosmos DB
- en: Amazon CloudWatch
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon CloudWatch
- en: Amazon DynamoDB
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon DynamoDB
- en: Amazon Kinesis
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon Kinesis
- en: Exceptionless
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Exceptionless
- en: Elasticsearch
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elasticsearch
- en: Sumo Logic
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sumo Logic
- en: Email
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮件
- en: PostgreSQL
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: RabbitMQ
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ
- en: 'Serilog provides a `Serilog.AspNetCore` NuGet package that integrates with
    ASP.NET Core. It has a set of extension methods to configure the logging system.
    To use it, install the `Serilog.AspNetCore` NuGet package by running this command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Serilog提供了一个`Serilog.AspNetCore` NuGet包，它与ASP.NET Core集成。它有一组扩展方法来配置日志系统。要使用它，通过运行以下命令安装`Serilog.AspNetCore`
    NuGet包：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, let’s use the `Serilog.Sinks.File` sink to write log messages to a file.
    Install the `Serilog.Sinks.File` NuGet package with this command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用`Serilog.Sinks.File` sink将日志消息写入文件。使用以下命令安装`Serilog.Sinks.File` NuGet包：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, update the `Program.cs` file to configure the logging system:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更新`Program.cs`文件以配置日志系统：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we first clear the default logging providers. Then, we
    create a `Serilog.ILogger` instance and add it to the logging system. The `WriteTo.File`
    method is used to configure the `Serilog.Sinks.File` sink. It will write log messages
    to a file named `log.txt` in the `logs` folder. The `rollingInterval` parameter
    is used to specify the rolling interval. In the current example, we set it up
    as daily. The `retainedFileCountLimit` parameter is used to specify the maximum
    number of log files to keep. In this case, we have kept the number of files to
    90\. Then, we call the `CreateLogger` method to create a `Serilog.ILogger` instance.
    Finally, we call the `AddSerilog()` method to add the `Serilog.ILogger` instance
    to the logging system.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先清除默认的日志提供程序。然后，我们创建一个`Serilog.ILogger`实例并将其添加到日志系统中。`WriteTo.File`方法用于配置`Serilog.Sinks.File`
    sink。它将日志消息写入`logs`文件夹中的`log.txt`文件。`rollingInterval`参数用于指定滚动间隔。在当前示例中，我们将其设置为每日。`retainedFileCountLimit`参数用于指定要保留的最大日志文件数。在这种情况下，我们保留了90个文件。然后，我们调用`CreateLogger`方法创建一个`Serilog.ILogger`实例。最后，我们调用`AddSerilog()`方法将`Serilog.ILogger`实例添加到日志系统中。
- en: There’s no need to change the code that uses the `ILogger` service. The `ILogger`
    service is still injected into the controller. The only difference is that log
    messages will be written to a file instead of the console window.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要更改使用`ILogger`服务的代码。`ILogger`服务仍然注入到控制器中。唯一的区别是日志消息将写入文件而不是控制台窗口。
- en: Run the application again and request the `/WeatherForecast` endpoint. You should
    be able to see log messages in the `logs/log.txt` file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序并请求`/WeatherForecast`端点。你应该能在`logs/log.txt`文件中看到日志消息。
- en: Important note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you write logging messages to a file, please make sure that there is enough
    disk space and that proper retention policies are set. Otherwise, the disk space
    may get exhausted. Also, it is recommended to use some professional logging systems
    for monitoring in the production environment. For example, if your application
    is deployed in Azure, you can easily integrate it with Azure Application Insights.
    Storing logging messages in a text file is not easy to manage and analyze.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将日志消息写入文件，请确保有足够的磁盘空间，并且设置了适当的保留策略。否则，磁盘空间可能会耗尽。此外，建议在生产环境中使用一些专业的日志系统进行监控。例如，如果你的应用程序部署在Azure上，你可以轻松地将其与Azure
    Application Insights集成。将日志消息存储在文本文件中不易于管理和分析。
- en: If the amount of logging messages is huge, consider sending them to a message
    queue, such as RabbitMQ, and then have a separate process to consume the messages
    and write them to a database. Keep in mind that the logging system should not
    be a bottleneck for the application. Do not use asynchronous methods for logging
    because logging should be fast, and frequently switching between threads may cause
    performance issues.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果日志消息的数量很大，考虑将它们发送到消息队列，例如RabbitMQ，然后有一个单独的过程来消费消息并将它们写入数据库。请记住，日志系统不应成为应用程序的瓶颈。不要使用异步方法进行日志记录，因为日志记录应该是快速的，频繁地在线程之间切换可能会引起性能问题。
- en: 'In the `LoggingDemo` project, we have already configured the logging system
    to write log messages to a file. You can check the `Program.cs` file to see how
    it works. Serilog provides a rich set of sinks, and it supports various configurations
    as well. You can find more provided sinks here: [https://github.com/serilog/serilog/wiki/Provided-Sinks](https://github.com/serilog/serilog/wiki/Provided-Sinks).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LoggingDemo`项目中，我们已经配置了日志系统，将日志消息写入文件。您可以通过查看`Program.cs`文件来了解它是如何工作的。Serilog
    提供了一组丰富的接收器，并支持各种配置。您可以在以下位置找到更多提供的接收器：[https://github.com/serilog/serilog/wiki/Provided-Sinks](https://github.com/serilog/serilog/wiki/Provided-Sinks)。
- en: Structured logging
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化日志
- en: 'In the *Logging parameters* section, we showed how we can use the `args` parameter
    to format a message string. You may wonder if we can use string concatenation
    to achieve the same outcome; for example, like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`日志参数`部分，我们展示了如何使用`args`参数来格式化消息字符串。您可能会想知道我们是否可以使用字符串连接来实现相同的结果；例如，像这样：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The answer is yes and no. If you do not care about the values of the parameters,
    it does seem to work. However, a modern way to handle logs is to use **structured
    logging** instead of a plain string message. Structured logging is a way to log
    messages in a structured format. Parameters such as the day of the week are identified
    and structured so that a system can process them, which means we can perform special
    operations on them, such as filtering, searching, and so on. Let’s dive into the
    details.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是是和否。如果您不关心参数的值，它似乎可以工作。然而，处理日志的现代方法是使用**结构化日志**而不是纯字符串消息。结构化日志是一种以结构化格式记录消息的方式。例如，星期几这样的参数被识别并结构化，以便系统可以处理它们，这意味着我们可以对它们执行特殊操作，例如过滤、搜索等。让我们深入了解细节。
- en: 'Serilog efficiently supports structured logging when you use `args` parameters
    instead of string concatenation. Let’s update the `Program.cs` file to send logs
    to the console window in a structured format:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`args`参数而不是字符串连接时，Serilog有效地支持结构化日志。让我们更新`Program.cs`文件，以结构化格式将日志发送到控制台窗口：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Serilog supports multiple sinks in the same logging pipeline. In the preceding
    code, we add the console sink after the file sink. The console sink is automatically
    installed with the `Serilog.AspNetCore` NuGet package, so you do not need to manually
    install it. `JsonFormatter` is used to format log messages in JSON format. You
    can also specify the `formatter` type for the file sink.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Serilog 支持在同一个日志管道中使用多个接收器。在前面代码中，我们在文件接收器之后添加了控制台接收器。控制台接收器是自动与`Serilog.AspNetCore`
    NuGet 包一起安装的，因此您不需要手动安装它。`JsonFormatter`用于以 JSON 格式格式化日志消息。您也可以为文件接收器指定`formatter`类型。
- en: 'In the `LoggingController` file, add a new action method to compare the structured
    logs and string concatenation logs:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LoggingController`文件中，添加一个新的动作方法来比较结构化日志和字符串连接日志：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run the application again and request the `api/Logging/structured-logging` endpoint.
    You should be able to see log messages in the console window in JSON format.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序并请求`api/Logging/structured-logging`端点。您应该能够在控制台窗口中看到以 JSON 格式显示的日志消息。
- en: 'Log messages with structured logging look like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用结构化日志的日志消息看起来像这样：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Log messages with string concatenation look like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串连接的日志消息看起来像这样：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that the structured logging has `Week` and `Time` properties, while the
    string concatenation does not. Structured logging is more flexible and easier
    to process. Therefore, structured logging is recommended instead of string concatenation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，结构化日志具有`周`和`时间`属性，而字符串连接则没有。结构化日志更加灵活且易于处理。因此，建议使用结构化日志而不是字符串连接。
- en: 'A great tool to analyze structured logging messages is Seq ([https://datalust.co/seq](https://datalust.co/seq)).
    Seq is a powerful log management tool that creates the visibility you need to
    quickly identify and diagnose problems in your applications. It is a commercial
    product, but it provides a free trial. You can download it here: [https://datalust.co/download](https://datalust.co/download).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 分析结构化日志消息的一个优秀工具是 Seq ([https://datalust.co/seq](https://datalust.co/seq))。Seq
    是一个强大的日志管理工具，它创建了你需要的可见性，以便快速识别和诊断应用程序中的问题。这是一个商业产品，但它提供免费试用。您可以从这里下载：[https://datalust.co/download](https://datalust.co/download)。
- en: 'Install it on your local machine. When you see the following window, please
    take note of the `5341`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的本地机器上安装它。当您看到以下窗口时，请注意`5341`：
- en: '![Figure 4.4 – Installing Seq](img/B18971_04_04.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 安装 Seq](img/B18971_04_04.jpg)'
- en: Figure 4.4 – Installing Seq
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 安装 Seq
- en: 'Next, we need to configure Serilog to send log messages to Seq. Serilog has
    a sink for Seq, so we can easily install it using the following command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置 Serilog 以将日志消息发送到 Seq。Serilog 有一个用于 Seq 的接收器，因此我们可以使用以下命令轻松安装它：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the `Program.cs` file, update the logging configuration to send log messages
    to Seq:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，更新日志配置以将日志消息发送到 Seq：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the application again and request the `api/Logging/structured-logging`
    endpoint. You should be able to see log messages in Seq:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序并请求 `api/Logging/structured-logging` 端点。您应该在 Seq 中看到日志消息：
- en: '![Figure 4.5 – Structured logging in Seq](img/B18971_04_05.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – Seq 中的结构化日志](img/B18971_04_05.jpg)'
- en: Figure 4.5 – Structured logging in Seq
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – Seq 中的结构化日志
- en: 'We can search the `Week` property to filter log messages, as shown in the following
    figure:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过搜索 `Week` 属性来过滤日志消息，如图下所示：
- en: '![Figure 4.6 – Filtering structured logs in Seq](img/B18971_04_06.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – Seq 中的结构化日志过滤](img/B18971_04_06.jpg)'
- en: Figure 4.6 – Filtering structured logs in Seq
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 在 Seq 中过滤结构化日志
- en: 'Now, we understand why structured logging is more powerful than string concatenation
    when you send logs. Serilog provides many powerful features for logging, such
    as enrichers. You can find more information about Serilog on its official website:
    [https://serilog.net/](https://serilog.net/).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们理解了为什么在发送日志时，结构化日志比字符串连接更强大。Serilog 为日志记录提供了许多强大的功能，例如 enrichers。您可以在 Serilog
    的官方网站上找到更多信息：[https://serilog.net/](https://serilog.net/)。
- en: Important note
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Seq is a good choice for local development. However, you may need to purchase
    a license for your critical applications and services for better support, or you
    may want to use another logging system. Please carefully consider your requirements
    before you choose a logging system. Don’t forget that we can use configurations
    to switch between different logging systems for different environments.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Seq 是本地开发的良好选择。然而，您可能需要为您的关键应用程序和服务购买许可证以获得更好的支持，或者您可能希望使用另一个日志系统。在选择日志系统之前，请仔细考虑您的需求。别忘了我们可以使用配置在不同环境中切换不同的日志系统。
- en: What should/shouldn’t we log?
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们应该/不应该记录什么？
- en: 'Logging is a powerful tool to help us diagnose problems, monitor an application,
    audit a system, and so on. But logging is not free. It consumes resources and
    may slow down applications. Depending on the purpose of logging, we may need to
    log different information. Generally, there are some scenarios that we should
    log:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是一个强大的工具，可以帮助我们诊断问题、监控应用程序、审计系统等。但日志记录并非免费。它消耗资源并可能减慢应用程序的运行速度。根据日志记录的目的，我们可能需要记录不同的信息。通常，有一些场景是我们应该记录的：
- en: Input/output validation errors, such as invalid input parameters or invalid
    response data
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入/输出验证错误，例如无效的输入参数或无效的响应数据
- en: Authentication and authorization failures
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证和授权失败
- en: Application errors, exceptions, and warnings, such as database connection errors,
    network errors, and so on
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序错误、异常和警告，例如数据库连接错误、网络错误等
- en: Application startup and shutdown
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序启动和关闭
- en: High-risk operations, such as deleting a record from the database, changing
    a user’s password, transferring money, and so on
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高风险操作，例如从数据库中删除记录、更改用户密码、转账等
- en: Legal compliance, such as auditing, terms of service, personal data consent,
    and so on
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 法律合规性，例如审计、服务条款、个人数据同意等
- en: Critical business events, such as a new order being placed, a new user being
    registered, and so on
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的业务事件，例如下订单、新用户注册等
- en: Any suspicious activities, such as brute-force attacks, account lockouts, and
    so on
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何可疑活动，例如暴力攻击、账户锁定等
- en: 'What information should we log? If the information in the log message is not
    sufficient to diagnose the problem, it would be useless. Generally, we should
    log the following information:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该记录什么信息？如果日志消息中的信息不足以诊断问题，那么它将是无用的。通常，我们应该记录以下信息：
- en: '**When**: What time did the event happen?'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**何时**：事件发生的时间是什么时候？'
- en: '**Where**: What is the application name and version? What is the hostname or
    IP address? What is the module or component name?'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哪里**：应用程序名称和版本是什么？主机名或 IP 地址是什么？模块或组件名称是什么？'
- en: '**Who**: Which user or client is involved in the event? What is the username,
    request ID, or client ID?'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**谁**：哪些用户或客户端参与了事件？用户名、请求 ID 或客户端 ID 是什么？'
- en: '**What**: What is the event? What severity level does the event have? What
    is the error message or stack trace? Any other descriptive information?'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容**：事件是什么？事件的严重级别是多少？错误消息或堆栈跟踪是什么？其他描述性信息？'
- en: We may need to include more information based on the requirements. For example,
    for web API applications, we also need to log the request path, HTTP method, headers,
    status code, and so on. For database applications, we may need to log the SQL
    statement, parameters, and so on.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需求，我们可能需要包含更多信息。例如，对于 Web API 应用程序，我们还需要记录请求路径、HTTP 方法、头部、状态码等。对于数据库应用程序，我们可能需要记录
    SQL 语句、参数等。
- en: 'There is some information that we should not log:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有些信息我们不应该记录：
- en: Application source code
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序源代码
- en: Sensitive application information, such as application secrets, passwords, encryption
    keys, database connection strings, and so on
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏感的应用程序信息，例如应用程序密钥、密码、加密密钥、数据库连接字符串等
- en: Sensitive user information, such as **personally identifiable information**
    (**PII**); for example, health status, government identification, and so on
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏感的用户信息，例如**个人可识别信息**（**PII**）；例如，健康状况、政府身份证明等
- en: Bank account information, credit card information, and so on
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 银行账户信息、信用卡信息等
- en: Information that users do not consent to share
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户不同意分享的信息
- en: Any other information that may violate the law or regulations
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能违反法律或法规的任何其他信息
- en: 'We have explained the basics of logging in ASP.NET Core. Next, we will learn
    another important component of ASP.NET Core: middleware.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解释了 ASP.NET Core 中的日志记录基础知识。接下来，我们将学习 ASP.NET Core 的另一个重要组件：中间件。
- en: Middleware
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件
- en: In this section, we will introduce middleware, which is one of the most important
    improvements in ASP.NET Core.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍中间件，它是 ASP.NET Core 中最重要的改进之一。
- en: 'To follow this section, you can run the following command to create a new ASP.NET
    Core web API project:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本节，您可以运行以下命令来创建一个新的 ASP.NET Core Web API 项目：
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can download the example project named `MiddlewareDemo` from the chapter’s
    GitHub repository.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从本章的 GitHub 仓库下载名为 `MiddlewareDemo` 的示例项目。
- en: What is middleware?
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是中间件？
- en: ASP.NET Core is a middleware-based framework. An ASP.NET Core application is
    built upon a set of middleware components. Middleware is a software component
    that is responsible for handling requests and responses. Multiple middleware components
    form a pipeline to process requests and generate responses. In this pipeline,
    each middleware component can perform a specific task, such as authentication,
    authorization, logging, and so on. Then, it passes the request to the next middleware
    component in the pipeline. It is a huge improvement over the traditional ASP.NET
    framework, which is based on the HTTP module and HTTP handler. In this way, the
    ASP.NET Core framework is more flexible and extensible. You can add or remove
    middleware components as needed. You can also write your own middleware components.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 是一个基于中间件的框架。ASP.NET Core 应用程序建立在一系列中间件组件之上。中间件是一个负责处理请求和响应的软件组件。多个中间件组件形成一个管道来处理请求并生成响应。在这个管道中，每个中间件组件都可以执行特定的任务，例如身份验证、授权、日志记录等。然后，它将请求传递给管道中的下一个中间件组件。这比基于
    HTTP 模块和 HTTP 处理器的传统 ASP.NET 框架有了巨大的改进。这样，ASP.NET Core 框架就更加灵活和可扩展。您可以根据需要添加或删除中间件组件。您还可以编写自己的中间件组件。
- en: 'The following diagram shows a middleware pipeline:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了中间件管道：
- en: '![Figure 4.7 – Middleware pipeline](img/B18971_04_07.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 中间件管道](img/B18971_04_07.jpg)'
- en: Figure 4.7 – Middleware pipeline
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 中间件管道
- en: A middleware component can perform tasks before and after the next middleware
    component in the pipeline. It can also choose whether to pass the request to the
    next middleware component or stop processing the request and generate a response
    directly.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件组件可以在管道中的下一个中间件组件之前和之后执行任务。它还可以选择是否将请求传递给下一个中间件组件，或者停止处理请求并直接生成响应。
- en: Creating simple middleware
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建简单的中间件
- en: 'Let''s see an example. Open the `MiddlewareDemo` project in VS Code. Add the
    following code to the `Program.cs` file:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。在 VS Code 中打开 `MiddlewareDemo` 项目。将以下代码添加到 `Program.cs` 文件中：
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Important note
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In the preceding code, `builder.Build()` returns a `WebApplication` instance.
    It is the host for the web API project, which is responsible for app startup and
    lifetime management. It also manages logging, DI, configuration, middleware, and
    so on.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`builder.Build()` 返回一个 `WebApplication` 实例。它是 Web API 项目的宿主，负责应用程序的启动和生命周期管理。它还管理日志记录、依赖注入、配置、中间件等。
- en: Run the application with `dotnet run` or `dotnet watch`, and you will see all
    requests will return a `Hello world!` response, regardless of the URL. This is
    because the `app.Run()` method handles all requests. In this case, the middleware
    short-circuits the pipeline and returns the response directly. We can also call
    it *terminal middleware*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dotnet run` 或 `dotnet watch` 运行应用程序，你将看到所有请求都将返回一个 `Hello world!` 响应，无论
    URL 如何。这是因为 `app.Run()` 方法处理所有请求。在这种情况下，中间件短路了管道并直接返回响应。我们也可以称之为 *终端中间件*。
- en: 'To use multiple middleware components, we can use the `app.Use()` method. The
    `app.Use()` method adds a middleware component to the pipeline. Update the `Program.cs`
    file as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用多个中间件组件，我们可以使用 `app.Use()` 方法。`app.Use()` 方法将中间件组件添加到管道中。按照以下方式更新 `Program.cs`
    文件：
- en: '[PRE29]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the application and request the `/weatherforecast` endpoint. You can see
    the following output in the console:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并请求 `/weatherforecast` 端点。你可以在控制台看到以下输出：
- en: '[PRE30]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `WebApplication` instance uses an `app.Use()` method to add a simple middleware
    component to the pipeline. The middleware component is an anonymous function that
    takes two parameters: `context` and `next`. Let’s take a closer look at these:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebApplication` 实例使用 `app.Use()` 方法将一个简单的中间件组件添加到管道中。该中间件组件是一个匿名函数，它接受两个参数：`context`
    和 `next`。让我们更详细地看看这些：'
- en: The `context` parameter is an instance of the `HttpContext` class that contains
    request and response information
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context` 参数是 `HttpContext` 类的实例，它包含请求和响应信息。'
- en: The `next` parameter is a delegate that is used to pass the request to the next
    middleware component in the pipeline
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next` 参数是一个委托，用于将请求传递给管道中的下一个中间件组件。'
- en: The `await next()` statement passes the request to the next middleware component
    in the pipeline
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await next()` 语句将请求传递给管道中的下一个中间件组件。'
- en: 'This middleware does not do anything with the request and response. It only
    outputs some information to the console. Let us add another middleware component
    to the pipeline. Update the `Program.cs` file as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此中间件对请求和响应不做任何处理。它只向控制台输出一些信息。让我们向管道中添加另一个中间件组件。按照以下方式更新 `Program.cs` 文件：
- en: '[PRE31]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In this example, we add two middleware components to the pipeline. The first
    middleware component adds a `ClientName` HTTP header to the request. The second
    middleware component sets the response status code to `202 Accepted`. Run the
    application and request the `/weatherforecast` URL. You will see the following
    output in the console:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们向管道中添加了两个中间件组件。第一个中间件组件向请求中添加一个 `ClientName` HTTP 头部。第二个中间件组件将响应状态码设置为
    `202 已接受`。运行应用程序并请求 `/weatherforecast` URL。你将在控制台看到以下输出：
- en: '[PRE32]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note the following points:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下要点：
- en: The original request does not contain the `ClientName` HTTP header. So, the
    value of the `ClientName` HTTP header in `Middleware 1` is empty.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始请求不包含 `ClientName` HTTP 头部。因此，`Middleware 1` 中 `ClientName` HTTP 头部的值为空。
- en: Before `Middleware 1` passes the request to `Middleware 2`, `Middleware 1` adds
    the `ClientName` HTTP header to the request.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Middleware 1` 将请求传递给 `Middleware 2` 之前，`Middleware 1` 将 `ClientName` HTTP
    头部添加到请求中。
- en: '`Middleware 1` does not output `My Middleware 1 - After` to the console after
    its `await next(context);` code. Instead, `Middleware 2` outputs the `ClientName`
    HTTP header value to the console.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Middleware 1` 在其 `await next(context);` 代码之后不会向控制台输出 `My Middleware 1 - After`。相反，`Middleware
    2` 将 `ClientName` HTTP 头部的值输出到控制台。'
- en: '`Middleware 2` changes the response status code to `202 Accepted`. The response
    will be passed to `Middleware 1`. Then, `Middleware 1` outputs `My Middleware
    1 - After` with the new response status code.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Middleware 2` 将响应状态码更改为 `202 已接受`。响应将被传递给 `Middleware 1`。然后，`Middleware 1`
    使用新的响应状态码输出 `My Middleware 1 - After`。'
- en: That indicates how middleware components work in the pipeline.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明了中间件组件在管道中的工作方式。
- en: How to assemble middleware components
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何组装中间件组件。
- en: 'Besides the `app.Use()` method, the `WebApplication` class also provides `Map()`,
    `MapWhen()`, `UseWhen()`, and `Run()` methods to add middleware components to
    a pipeline. The following table shows the differences between these methods:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`app.Use()`方法之外，`WebApplication`类还提供了`Map()`、`MapWhen()`、`UseWhen()`和`Run()`方法来向管道中添加中间件组件。以下表格显示了这些方法之间的区别：
- en: '| **Method** | **Description** |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `app.Map()` | Maps a request path to a sub-request pipeline. The middleware
    component is only executed when the request path matches the specified path. |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `app.Map()` | 将请求路径映射到子请求管道。只有当请求路径与指定的路径匹配时，中间件组件才会执行。 |'
- en: '| `app.MapWhen()` | Runs a sub-request pipeline when a given predicate is matched.
    |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `app.MapWhen()` | 当匹配给定的谓词时，运行子请求管道。 |'
- en: '| `app.Use()` | Adds an inline delegate to the application’s request pipeline.
    |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `app.Use()` | 将内联委托添加到应用程序的请求管道中。 |'
- en: '| `app.UseWhen()` | Adds an inline delegate to the application’s request pipeline
    when a given predicate is matched. It is rejoined to the main pipeline if it does
    not short-circuit or contain terminal middleware. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `app.UseWhen()` | 当匹配给定的谓词时，将内联委托添加到应用程序的请求管道中。如果没有短路或包含终端中间件，它将重新连接到主管道。
    |'
- en: '| `app.Run()` | Adds a terminal middleware component to the pipeline. It prevents
    further middleware components from processing requests. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `app.Run()` | 将终端中间件组件添加到管道中。它阻止其他中间件组件处理请求。 |'
- en: Table 4.3 – The differences between the app.Map(), app.MapWhen(), app.Use(),
    app.UseWhen(), and app.Run() methods
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.3 – app.Map(), app.MapWhen(), app.Use(), app.UseWhen(), 和 app.Run() 方法之间的区别
- en: 'To handle a request, we use `app.Map()` or `app.MapWhen()` to configure which
    request path (or predicate) should be handled by which middleware component. The
    `app.Use()` and `app.Run()` methods are used to add middleware components to the
    pipeline. One pipeline can have multiple `app.Use()` methods. But only one `app.Run()`
    method is allowed in one pipeline, and the `app.Run()` method must be the last
    method in the pipeline. The following diagram illustrates the process:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理请求，我们使用`app.Map()`或`app.MapWhen()`来配置哪个请求路径（或谓词）应该由哪个中间件组件处理。`app.Use()`和`app.Run()`方法用于将中间件组件添加到管道中。一个管道可以有多个`app.Use()`方法。但一个管道中只允许有一个`app.Run()`方法，并且`app.Run()`方法必须是管道中的最后一个方法。以下图表说明了这个过程：
- en: '![Figure 4.8 – The relationship between the app.Map(), app.Use(), and app.Run()
    methods](img/B18971_04_08.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8 – app.Map(), app.Use(), 和 app.Run() 方法之间的关系](img/B18971_04_08.jpg)'
- en: Figure 4.8 – The relationship between the app.Map(), app.Use(), and app.Run()
    methods
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – app.Map(), app.Use(), 和 app.Run() 方法之间的关系
- en: Let’s see an example. We will develop a lottery application that allows users
    to call an API to check whether they get the lucky number. Lucky numbers are generated
    randomly. We will add a couple of middleware components to the pipeline.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。我们将开发一个抽奖应用程序，允许用户调用API来检查他们是否得到了幸运数字。幸运数字是随机生成的。我们将向管道中添加几个中间件组件。
- en: 'Update the `Program.cs` file as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Program.cs`文件更新如下：
- en: '[PRE33]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is a fun lottery program. Let’s see how it is configured:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的抽奖程序。让我们看看它是如何配置的：
- en: 'First, we use the `app.Map()` method to map the `/lottery` request path to
    a sub-request pipeline. In this part, there are a couple of things to do:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用`app.Map()`方法将`/lottery`请求路径映射到一个子请求管道。在这一部分，有几件事情要做：
- en: We use a `Random` instance to generate a lucky number. Note that this number
    is generated only once when the application starts.
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用一个`Random`实例来生成幸运数字。请注意，这个数字在应用程序启动时只生成一次。
- en: Next, we add a middleware component to the pipeline using the `app.UseWhen()`
    method. This middleware works only when the request has a query string. If the
    query string is the same as the lucky number, it uses `app.Run()` to write the
    response. This branch is done.
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`app.UseWhen()`方法将一个中间件组件添加到管道中。这个中间件仅在请求包含查询字符串时工作。如果查询字符串与幸运数字相同，它将使用`app.Run()`来写入响应。这个分支就完成了。
- en: 'Next, we add another middleware component when the request does not have a
    query string. This middleware consists of two sub-middleware components:'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，当请求没有查询字符串时，我们添加另一个中间件组件。这个中间件由两个子中间件组件组成：
- en: The first one generates a random number and adds it to the HTTP header, then
    passes it to the second sub-middleware.
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个生成一个随机数并将其添加到HTTP头中，然后将其传递给第二个子中间件。
- en: The second one uses `app.UseWhen()` to check the HTTP headers of the request.
    If the HTTP header contains the lucky number, it uses `app.Run()` to write the
    response. This branch is done. This part shows how we use the `app.UseWhen()`
    method to rejoin a middleware component to the main pipeline.
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个使用`app.UseWhen()`来检查请求的HTTP头部。如果HTTP头部包含幸运数字，它使用`app.Run()`来写入响应。这部分分支已完成。这部分展示了我们如何使用`app.UseWhen()`方法将中间件组件重新连接到主管道。
- en: Next, we add a middleware component to the pipeline using the `app.Run()` method.
    This middleware component is used to handle all other requests for the `/lottery`
    URL. It writes the response to the client and shows the number that the client
    has chosen. Note that if the user already got the lucky number, this part will
    not be executed.
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`app.Run()`方法向管道添加一个中间件组件。这个中间件组件用于处理所有其他对`/lottery` URL的请求。它将响应写入客户端并显示客户端选择的数字。请注意，如果用户已经获得了幸运数字，这部分将不会执行。
- en: At the end of the program, we have another middleware component using the `app.Run()`
    method. This middleware component is used to handle all other requests. It shows
    how to play the game.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序结束时，我们还有一个使用`app.Run()`方法的中间件组件。这个中间件组件用于处理所有其他请求。它展示了如何玩游戏。
- en: Run the application and request the `/lottery` endpoint a couple of times. Sometimes,
    you will see you win the lottery. Or, you can include a query string in the URL,
    such as `/lottery?1`. You should be able to notice that the lucky number is the
    same for all requests. If you restart the application, the lucky number may change,
    because it is generated randomly when the application starts.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并多次请求`/lottery`端点。有时，您会看到您赢得了彩票。或者，您可以在URL中包含查询字符串，例如`/lottery?1`。您应该能够注意到所有请求中的幸运数字是相同的。如果您重新启动应用程序，幸运数字可能会改变，因为它是应用程序启动时随机生成的。
- en: 'There are a couple of things to note:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点需要注意：
- en: A middleware component is initialized only once when the application starts.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件组件在应用程序启动时只初始化一次。
- en: You can mix the `app.Map()`, `app.MapWhen()`, `app.Use()`, `app.UseWhen()`,
    and `app.Run()` methods in one pipeline. But be careful to use them in the right
    order.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在一个管道中混合使用`app.Map()`, `app.MapWhen()`, `app.Use()`, `app.UseWhen()`和`app.Run()`方法。但请注意，要按正确的顺序使用它们。
- en: '`app.Run()` must be the last method in a pipeline.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.Run()`必须是管道中的最后一个方法。'
- en: You cannot change the response after `await next();` or `await next.Invoke();`
    is called because it may cause a protocol violation or corrupt the response body
    format. For example, if the response has been sent to the client, if you change
    the headers or the status code, it will throw an exception. If you want to change
    the response, please do so before `await next();` or `await next.Invoke();` is
    called.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用`await next();`或`await next.Invoke();`之后，您不能更改响应，因为这可能导致协议违规或损坏响应体格式。例如，如果响应已经发送到客户端，如果您更改了头部或状态码，将会抛出异常。如果您想更改响应，请在调用`await
    next();`或`await next.Invoke();`之前进行更改。
- en: 'You may wonder what the difference between `app.MapWhen()` and `app.UseWhen()`
    is. Both of them are used to configure a conditional middleware execution. The
    differences are as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道`app.MapWhen()`和`app.UseWhen()`之间的区别。它们都用于配置条件中间件执行。区别如下：
- en: '`app.MapWhen()`: Used to branch the request pipeline based on the given predicate'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.MapWhen()`: 用于根据给定的谓词分支请求管道'
- en: '`app.UseWhen()`: Used to conditionally add a branch in the request pipeline
    that is rejoined to the main pipeline if it does not short-circuit or contain
    a terminal middleware'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.UseWhen()`: 用于在请求管道中条件性地添加一个分支，如果不短路或包含终端中间件，则将其重新连接到主管道'
- en: 'To clarify the difference, update the `Program.cs` file as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清区别，按照以下方式更新`Program.cs`文件：
- en: '[PRE34]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the application using `dotnet run` and request the `http://localhost:5170/?branch=1`
    URL. You will see the console window outputs the following message:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dotnet run`运行应用程序并请求`http://localhost:5170/?branch=1` URL。您将看到控制台窗口输出以下消息：
- en: '[PRE35]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: And the response is `Hello world!`. If you request any other URL, such as `http://localhost:5170/test`,
    you will still see a `Hello world!` response. But you will not see the console
    window that outputs the log message. That says `app.UseWhen()` only works when
    the predicate is `true`. If the predicate is `false`, the pipeline will continue
    to execute the next middleware component.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 响应是 `Hello world!`。如果你请求任何其他 URL，例如 `http://localhost:5170/test`，你仍然会看到 `Hello
    world!` 的响应。但你看不到输出日志消息的控制台窗口。这说明 `app.UseWhen()` 只在谓词为 `true` 时起作用。如果谓词为 `false`，管道将继续执行下一个中间件组件。
- en: 'Next, let us try to change `app.UseWhen()` to `app.MapWhen()`. Update the `Program.cs`
    file as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试将 `app.UseWhen()` 改为 `app.MapWhen()`。更新 `Program.cs` 文件如下：
- en: '[PRE36]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Run the application and request the `http://localhost:5170/?branch=1` URL again.
    You will see a log message in the console window, but it returns a `404` error!
    Why?
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序并请求 `http://localhost:5170/?branch=1` URL。你将在控制台窗口中看到日志消息，但它返回一个 `404`
    错误！为什么？
- en: That is because the `app.MapWhen()` method is used to branch the request pipeline
    based on the given predicate. If the predicate is `true`, the request pipeline
    will be branched to the sub-pipeline defined in this `app.MapWhen()` method. But
    when the `next()` method is called, it does not have a next middleware component
    to execute, even though there is an `app.Run()` method defined at the end of the
    program. So, it returns a `404` error.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为使用了 `app.MapWhen()` 方法根据给定的谓词分支请求管道。如果谓词为 `true`，请求管道将分支到由本 `app.MapWhen()`
    方法定义的子管道。但当调用 `next()` 方法时，它没有下一个中间件组件可以执行，尽管在程序末尾定义了 `app.Run()` 方法。因此，它返回一个
    `404` 错误。
- en: 'To make it work, we need to add another `app.Run()` method to the sub-pipeline.
    Update the `Program.cs` file as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其工作，我们需要在子管道中添加另一个 `app.Run()` 方法。更新 `Program.cs` 文件如下：
- en: '[PRE37]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, run the application again and request the `http://localhost:5170/?branch=1`
    URL. You can see the logging message is `From MapWhen(): Branch used = 1`, and
    the response is returned as expected.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，再次运行应用程序并请求 `http://localhost:5170/?branch=1` URL。你可以看到日志消息是 `From MapWhen():
    Branch used = 1`，并且响应按预期返回。'
- en: The middleware mechanism is very powerful. It makes the ASP.NET Core application
    incredibly flexible. But it may cause issues if you make incorrect orders. Please
    use it wisely.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件机制非常强大。它使 ASP.NET Core 应用程序具有极高的灵活性。但如果你使用错误的顺序，可能会导致问题。请明智地使用它。
- en: In this section, we introduced how to apply middleware components using delegate
    methods. ASP.NET Core provides a lot of built-in middleware components to simplify
    development. In the next section, we will explore some of the built-in middleware
    components.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了如何使用委托方法应用中间件组件。ASP.NET Core 提供了许多内置的中间件组件以简化开发。在下一节中，我们将探讨一些内置的中间件组件。
- en: Built-in middleware
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置中间件
- en: 'ASP.NET Core framework provides a lot of built-in middleware components. Check
    the code of the `Program.cs` file. You can find some code like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 框架提供了许多内置的中间件组件。检查 `Program.cs` 文件的代码。你可以找到一些像这样的代码：
- en: '[PRE38]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There are some middleware components to enable Swagger, HTTPS redirection,
    authorization, and so on. You can find a full list of built-in middleware components
    here: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-8.0#built-in-middleware](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-8.0#built-in-middleware).'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些中间件组件可以启用 Swagger、HTTPS 重定向、授权等。你可以在这里找到内置中间件组件的完整列表：[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-8.0#built-in-middleware](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-8.0#built-in-middleware)。
- en: 'Here are some common built-in middleware components. Note the **Order** column.
    Some middleware components must be called in a specific order. Some middleware
    may terminate the requests:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些常见的内置中间件组件。注意**顺序**列。一些中间件组件必须按特定顺序调用。某些中间件可能会终止请求：
- en: '| **Middleware** | **Description** | **Order** |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| **中间件** | **描述** | **顺序** |'
- en: '| --- | --- | --- |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Authentication | Enables authentication support. | Before `HttpContext.User`
    is needed. Terminal for OAuth callbacks. |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 认证 | 启用认证支持。 | 在 `HttpContext.User` 需要之前。OAuth 回调的终止点。 |'
- en: '| Authorization | Enables authorization support. | Immediately after the Authentication
    middleware. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 授权 | 启用授权支持。 | 在认证中间件之后立即执行。 |'
- en: '| CORS | Configures **cross-origin resource** **sharing** (**CORS**). | Before
    components that use CORS. `UseCors` currently must go before `UseResponseCaching`.
    |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 跨源资源共享 (CORS) | 配置 **跨源资源** **共享** (CORS)。 | 在使用 CORS 的组件之前。`UseCors` 目前必须放在
    `UseResponseCaching` 之前。 |'
- en: '| Health Check | Checks the health status of the application and its dependencies.
    | Terminal if a request matches a health check endpoint. |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 健康检查 | 检查应用程序及其依赖项的健康状态。 | 如果请求匹配健康检查端点，则为终端。 |'
- en: '| HTTPS Redirection | Redirects all HTTP requests to HTTPS. | Before components
    that consume the URL. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| HTTPS 重定向 | 将所有 HTTP 请求重定向到 HTTPS。 | 在消耗 URL 的组件之前。 |'
- en: '| Response Caching | Enables response cache. | Before components that require
    caching. `UseCors` must come before `UseResponseCaching`. |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 响应缓存 | 启用响应缓存。 | 在需要缓存的组件之前。`UseCors` 必须在 `UseResponseCaching` 之前。 |'
- en: '| Endpoint Routing | Defines and constrains request routes. | Terminal for
    matching routes. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 端点路由 | 定义和约束请求路由。 | 匹配路由的终端。 |'
- en: Table 4.4 – Common built-in middleware components
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.4 – 常见内置中间件组件
- en: We will not cover all the built-in middleware components in this book. But we
    will introduce some of them in the following sub-sections, such as rate-limiting,
    request timeouts, short-circuits, and so on.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不会涵盖所有内置中间件组件。但我们将介绍其中的一些，例如速率限制、请求超时、短路等。
- en: Using the rate-limiting middleware
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用速率限制中间件
- en: The rate-limiting middleware is a new built-in middleware provided in ASP.NET
    Core 7\. It is used to limit the number of requests that a client can make in
    a given time window. It is very useful to prevent **distributed denial-of-service**
    (**DDoS**) attacks.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 速率限制中间件是 ASP.NET Core 7 中提供的新内置中间件。它用于限制客户端在给定时间窗口内可以发出的请求数量。它对于防止 **分布式拒绝服务
    (DDoS**) 攻击非常有用。
- en: 'The rate-limiting middleware defines four policies:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 速率限制中间件定义了四个策略：
- en: Fixed window
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定窗口
- en: Sliding window
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑动窗口
- en: Token bucket
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令牌桶
- en: Concurrency
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发
- en: This section is just to introduce how to use the middleware, so we will not
    cover details of the policies. We will use the fixed window policy in this section.
    This policy uses a fixed time window to limit the number of requests. For example,
    we can limit the number of requests to 10 per 10 seconds. When the time window
    expires, a new time window starts, and the counter is reset to 0.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 本节仅介绍如何使用中间件，因此我们将不涵盖策略的详细信息。在本节中，我们将使用固定窗口策略。此策略使用固定时间窗口来限制请求数量。例如，我们可以将每 10
    秒的请求数量限制为 10。当时间窗口到期时，新的时间窗口开始，计数器重置为 0。
- en: 'Update the `Program.cs` file as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式更新 `Program.cs` 文件：
- en: '[PRE39]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding code adds the rate-limiting middleware to a minimal API request
    pipeline. It creates a fixed window policy named `fixed`. The `options` property
    means a maximum of 5 requests per each 10-second window are allowed.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将速率限制中间件添加到最小 API 请求管道中。它创建了一个名为 `fixed` 的固定窗口策略。`options` 属性表示每个 10 秒窗口最多允许
    5 个请求。
- en: Run the application and request the `http://localhost:5170/rate-limiting-mini`
    URL 10 times. You will see the response is `Hello 638005...`. But the sixth request
    will be pending until the time window expires. You can try other policies if you
    want. To practice more, you can move the configuration for the policy to the `appsettings.json`
    file.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并请求 `http://localhost:5170/rate-limiting-mini` URL 10 次。您将看到响应为 `Hello
    638005...`。但第六次请求将挂起，直到时间窗口到期。如果您想尝试其他策略，可以尝试。为了练习更多，您可以将策略的配置移动到 `appsettings.json`
    文件中。
- en: 'To apply this rate-limiting middleware to a controller-based API, we need to
    add the `EnableRateLimiting` attribute to the controller or action, as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此速率限制中间件应用于基于控制器的 API，我们需要将 `EnableRateLimiting` 属性添加到控制器或操作中，如下所示：
- en: '[PRE40]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we will introduce another built-in middleware component: the request
    timeout middleware.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍另一个内置中间件组件：请求超时中间件。
- en: Using the request timeouts middleware
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用请求超时中间件
- en: ASP.NET Core 8 introduces the request timeout middleware, which allows developers
    to set a timeout for an endpoint. If the request is not completed within the allotted
    time, a `HttpContext.RequestAborted` cancellation token is triggered, allowing
    the application to handle the timeout request. This feature helps to prevent the
    application from being blocked by long-running requests.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 8 引入了请求超时中间件，允许开发者为端点设置超时时间。如果请求在分配的时间内未完成，则触发 `HttpContext.RequestAborted`
    取消令牌，允许应用程序处理超时请求。此功能有助于防止应用程序被长时间运行的请求阻塞。
- en: 'To apply the request timeout middleware to the ASP.NET Core web API project,
    update the `Program.cs` file as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 要将请求超时中间件应用于ASP.NET Core Web API项目，请按如下方式更新`Program.cs`文件：
- en: '[PRE41]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The request timeout middleware can be used for a specific endpoint. To do this,
    we need to add the `EnableRequestTimeout` attribute to the controller or action,
    as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 请求超时中间件可以用于特定的端点。为此，我们需要将`EnableRequestTimeout`属性添加到控制器或操作中，如下所示：
- en: '[PRE42]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, we use the `RequestTimeout` attribute to set the timeout
    to 5 seconds. In the action method, we use a `Task.Delay()` method to simulate
    a long-running task. The delay time is generated randomly. If the request is not
    completed within 5 seconds, a `Request.HttpContext.RequestAborted` cancellation
    token is triggered. Then, we can handle the timeout request in the `catch` block.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用`RequestTimeout`属性将超时设置为5秒。在操作方法中，我们使用`Task.Delay()`方法来模拟一个长时间运行的任务。延迟时间随机生成。如果请求在5秒内未完成，则触发`Request.HttpContext.RequestAborted`取消令牌。然后，我们可以在`catch`块中处理超时请求。
- en: Run the application using the `dotnet run` command and request the `/api/request-timeout`
    endpoint a few times. Sometimes, you will get a `503` response. Note that the
    request timeout middleware does not work in the debug mode. To test this middleware,
    please ensure that the debugger is not attached to the application.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dotnet run`命令运行应用程序，并对`/api/request-timeout`端点进行几次请求。有时，你会得到一个`503`响应。请注意，请求超时中间件在调试模式下不工作。要测试此中间件，请确保调试器未附加到应用程序。
- en: 'Similarly, if you want to apply this middleware to a minimal API, you can use
    the `WithRequestTimeout` method, as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果您想将此中间件应用于最小API，可以使用`WithRequestTimeout`方法，如下所示：
- en: '[PRE43]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The timeout configuration can be configured with a policy. Then, we can apply
    the policy to the controller or action. Update the `Program.cs` file as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 超时配置可以使用策略进行配置。然后，我们可以将策略应用于控制器或操作。按如下方式更新`Program.cs`文件：
- en: '[PRE44]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding code defines three timeout policies. `DefaultPolicy` is used
    when no policy is specified. `ShortTimeoutPolicy` is used for short-running requests
    with a timeout of 2 seconds, while `LongTimeoutPolicy` is used for long-running
    requests with a timeout of 10 seconds. To apply the policy to the controller or
    action, the `EnableRequestTimeout` attribute can be used as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了三个超时策略。`DefaultPolicy`在未指定策略时使用。`ShortTimeoutPolicy`用于超时为2秒的短运行请求，而`LongTimeoutPolicy`用于超时为10秒的长运行请求。要将策略应用于控制器或操作，可以使用`EnableRequestTimeout`属性，如下所示：
- en: '[PRE45]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If the action method does not specify a policy, `DefaultPolicy` will be used.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作方法未指定策略，则将使用`DefaultPolicy`。
- en: Using the short-circuit middleware
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用短路中间件
- en: The short-circuit middleware is another new middleware component introduced
    in ASP.NET Core 8\. This middleware is used to short-circuit a request when it
    is not necessary to continue processing the request. For example, web robots may
    request the `/robots.txt` file to check if the website allows crawling. As a web
    API application, we do not need to process this request. However, the execution
    of the request pipeline will still continue. The short-circuit middleware can
    be used to short-circuit the request and return a response directly.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 短路中间件是ASP.NET Core 8中引入的另一个新的中间件组件。此中间件用于在不需要继续处理请求时短路请求。例如，网络爬虫可能会请求`/robots.txt`文件以检查网站是否允许爬取。作为一个Web
    API应用程序，我们不需要处理此请求。然而，请求管道的执行仍然会继续。可以使用短路中间件来短路请求并直接返回响应。
- en: 'To apply the short-circuit middleware to a specific endpoint, add the following
    code to the `Program.cs` file:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 要将短路中间件应用于特定的端点，请将以下代码添加到`Program.cs`文件中：
- en: '[PRE46]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding code uses the `ShortCircuit()` method to short-circuit the request.
    If the request path is `/robots.txt`, it will return a text/plain response directly.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用`ShortCircuit()`方法来短路请求。如果请求路径是`/robots.txt`，它将直接返回一个text/plain响应。
- en: 'Another way to use the short-circuit middleware is to use `MapShortCircuit`
    as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 使用短路中间件的另一种方法是使用`MapShortCircuit`如下所示：
- en: '[PRE47]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this example, when a request is made to `/robots.txt` or `/favicon.ico`,
    a `404 Not Found` response will be returned directly. This ensures that the server
    is not burdened with unnecessary requests.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，当请求`/robots.txt`或`/favicon.ico`时，将直接返回`404 Not Found`响应。这确保了服务器不会被不必要的请求所负担。
- en: Important note
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The short-circuit middleware should be placed at the start of the pipeline to
    prevent other middleware components from processing the request unnecessarily.
    This will ensure that the request is handled in the most efficient manner.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 短路中间件应该放置在管道的开始处，以防止其他中间件组件不必要地处理请求。这将确保请求以最有效的方式处理。
- en: ASP.NET Core provides a wide range of built-in middleware components. These
    components use extension methods such as `AddXXX()` and `UseXXX()` to add middleware
    components to the pipeline. In the following section, we will explore how to create
    a custom middleware component and apply it to the pipeline using an extension
    method.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core提供了一系列内置的中间件组件。这些组件使用`AddXXX()`和`UseXXX()`等扩展方法将中间件组件添加到管道中。在下一节中，我们将探讨如何创建自定义中间件组件，并使用扩展方法将其应用到管道中。
- en: Creating a custom middleware component
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义中间件组件
- en: 'If the built-in middleware cannot meet your requirements, you can create your
    own middleware components. A custom middleware component does not have to derive
    from a base class or an interface. But a middleware class does need to follow
    some conventions:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内置的中间件无法满足您的需求，您可以创建自己的中间件组件。自定义中间件组件不需要从基类或接口派生。但是，中间件类确实需要遵循一些约定：
- en: It must have a public constructor that accepts a `RequestDelegate` parameter.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须有一个接受`RequestDelegate`参数的公共构造函数。
- en: It must have a public method named `Invoke()` or `InvokeAsync()` that accepts
    a `HttpContext` parameter and returns a `Task`. The `HttpContent` parameter must
    be the first parameter.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须有一个名为`Invoke()`或`InvokeAsync()`的公共方法，该方法接受一个`HttpContext`参数并返回一个`Task`。`HttpContent`参数必须是第一个参数。
- en: It can use DI to inject additional dependencies.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以使用依赖注入（DI）来注入额外的依赖项。
- en: An extension method is needed to add the middleware to the `IApplicationBuilder`
    instance.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个扩展方法来将中间件添加到`IApplicationBuilder`实例。
- en: Consider this scenario. For better tracking, we want to use the concept of correlation
    ID in the application. The correlation ID is a unique identifier for each request.
    It is used to track the request through the application, especially in a microservice
    architecture. ASP.NET Core provides a `HttpContext.TraceIdentifier` property to
    store the unique identifier. By default, Kestrel generates the ID using the `{ConnectionId}:{Request
    number}` format; for example, `0HML6LNF87PBV:00000001`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景。为了更好地跟踪，我们希望在应用中使用关联ID的概念。关联ID是每个请求的唯一标识符。它用于跟踪请求在应用中的路径，尤其是在微服务架构中。ASP.NET
    Core提供了一个`HttpContext.TraceIdentifier`属性来存储唯一标识符。默认情况下，Kestrel使用`{ConnectionId}:{Request
    number}`格式生成ID；例如，`0HML6LNF87PBV:00000001`。
- en: If we have multiple services, such as *Service A* and *Service B*, when the
    client calls *Service A*, *Service A* will generate a `TraceIdentifier` instance
    for the current request, then *Service A* will call *Service B*, and *Service
    B* will generate another `TraceIdentifier` instance. It is hard to track the request
    through multiple services. We need to use the same `TraceIdentifier` instance
    for the request to be tracked.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有多个服务，例如*服务A*和*服务B*，当客户端调用*服务A*时，*服务A*将为当前请求生成一个`TraceIdentifier`实例，然后*服务A*将调用*服务B*，而*服务B*将生成另一个`TraceIdentifier`实例。在多个服务中跟踪请求是困难的。我们需要为要跟踪的请求使用相同的`TraceIdentifier`实例。
- en: 'The idea is to generate a correlation ID for each request chain. Then, set
    it in the `X-Correlation-Id` header for request/response as well. When we call
    *Service B* from *Service A*, attach the `X-Correlation-Id` header to the HTTP
    request headers so that we can attach the `X-Correlation-Id` value in the logs
    for future diagnostics. To do this, we need to create a custom middleware component.
    Create a new class named `CorrelationIdMiddleware` in the project folder:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是为每个请求链生成一个关联ID。然后，将其设置在请求/响应的`X-Correlation-Id`头中。当我们从*服务A*调用*服务B*时，将`X-Correlation-Id`头附加到HTTP请求头中，这样我们就可以在日志中附加`X-Correlation-Id`值，以便未来的诊断。为此，我们需要创建一个自定义中间件组件。在项目文件夹中创建一个名为`CorrelationIdMiddleware`的新类：
- en: '[PRE48]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding code, the `CorrelationIdMiddleware` class has a public constructor
    that accepts a `RequestDelegate` parameter. It also has a public method named
    `InvokeAsync()` that accepts a `HttpContext` parameter and returns a `Task` instance.
    The `InvokeAsync()` method is the entry point of the middleware. It gets the correlation
    ID from the request header. If it is not found, it generates a new one. Then,
    it sets the `HttpContext.TraceIdentifier` property and adds the correlation ID
    to the response header. Finally, it calls the next middleware component in the
    pipeline. It also uses a logger via DI to log the correlation ID.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`CorrelationIdMiddleware` 类有一个接受 `RequestDelegate` 参数的公共构造函数。它还有一个名为
    `InvokeAsync()` 的公共方法，该方法接受一个 `HttpContext` 参数并返回一个 `Task` 实例。`InvokeAsync()`
    方法是中间件的入口点。它从请求头中获取关联 ID。如果未找到，则生成一个新的 ID。然后，它设置 `HttpContext.TraceIdentifier`
    属性并将关联 ID 添加到响应头中。最后，它调用管道中的下一个中间件组件。它还通过 DI 使用记录器记录关联 ID。
- en: 'Next, add a new extension method to the `IApplicationBuilder` instance:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向 `IApplicationBuilder` 实例添加一个新的扩展方法：
- en: '[PRE49]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we can apply the correlation ID middleware in the `Program.cs` file:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `Program.cs` 文件中应用关联 ID 中间件：
- en: '[PRE50]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Open the `WeatherForecastController.cs` file and add the following code to
    the `Get()` method:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `WeatherForecastController.cs` 文件，并将以下代码添加到 `Get()` 方法中：
- en: '[PRE51]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Run the application and request the `http://localhost:5170/WeatherForecast`
    URL. You will see the response header contains the `X-Correlation-Id` property,
    as shown next:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并请求 `http://localhost:5170/WeatherForecast` URL。您将看到响应头包含 `X-Correlation-Id`
    属性，如下所示：
- en: '[PRE52]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can also see the correlation ID in the log, such as the following:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在日志中看到关联 ID，如下所示：
- en: '[PRE53]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this way, we can use the correlation ID to track the request through multiple
    services, especially in a microservice architecture.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以使用关联 ID 在多个服务中跟踪请求，尤其是在微服务架构中。
- en: We did not call any other services in this example. You can have a try yourself.
    Create another service and call it from the current service. Apply the same correlation
    ID middleware in another service. It can get the `X-Correlation-Id` header from
    the request headers and continue to use it. Then, you will see the same correlation
    ID is used for each request chain in both services.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们没有调用任何其他服务。您可以自己尝试。创建另一个服务并从当前服务中调用它。在另一个服务中应用相同的关联 ID 中间件。它可以从请求头中获取
    `X-Correlation-Id` 头信息并继续使用它。然后，您将看到在两个服务的每个请求链中都使用了相同的关联 ID。
- en: Important note
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The preceding example is purely for demonstration purposes. Microsoft provides
    a NuGet package called `Microsoft.AspNetCore.HeaderPropagation` that can be used
    to propagate headers to downstream services. You can find the sample code here:
    [https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/HeaderPropagation/samples/HeaderPropagationSample](https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/HeaderPropagation/samples/HeaderPropagationSample).
    You can also check [*Chapter 16*](B18971_16.xhtml#_idTextAnchor671) to learn more
    about the distributed tracing using OpenTelemetry.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例纯粹是为了演示目的。Microsoft 提供了一个名为 `Microsoft.AspNetCore.HeaderPropagation` 的 NuGet
    包，可用于将头信息传播到下游服务。您可以在以下位置找到示例代码：[https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/HeaderPropagation/samples/HeaderPropagationSample](https://github.com/dotnet/aspnetcore/tree/main/src/Middleware/HeaderPropagation/samples/HeaderPropagationSample)。您还可以查看
    [*第 16 章*](B18971_16.xhtml#_idTextAnchor671) 以了解更多关于使用 OpenTelemetry 进行分布式跟踪的信息。
- en: Summary
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the logging framework in ASP.NET Core, and
    introduced a third-party logging framework, Serilog, to help us write logs to
    different sinks, such as files, console, and Seq, which is a tool that analyzes
    logs using structured logging. We also learned what middleware is, how to use
    the built-in middleware components, and how to create a custom middleware component.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 ASP.NET Core 中的日志框架，并介绍了一个第三方日志框架 Serilog，帮助我们将日志写入不同的存储，如文件、控制台和
    Seq，这是一个使用结构化日志分析日志的工具。我们还学习了什么是中间件，如何使用内置的中间件组件，以及如何创建自定义中间件组件。
- en: It is time to implement some real business logic in the next chapter. We will
    introduce **Entity Framework Core** (**EF Core**), a powerful **object-relational
    mapper** (**ORM**) framework, to help us access the database.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将实现一些实际的业务逻辑。我们将介绍 **Entity Framework Core** (**EF Core**)，一个强大的 **对象关系映射器**
    (**ORM**) 框架，帮助我们访问数据库。
