- en: Chapter 10. Pattern Implementation Using Object/Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most modern programming languages (partially or completely) support **Functional
    Programming** (**FP**) constructs these days. As outlined in the previous chapters,
    the advent of many-core computing is a factor in this progressive evolution. In
    some cases, we can encode a solution using OOP, and there can be a functional
    version of the solution as well. The most pragmatic use of the FP constructs can
    be undertaken by judiciously mixing them with OOP code. This is also called object/functional
    programming, and is becoming a dominant paradigm in languages such as F#, Scala,
    Ruby, and so on. The C# programming language is not an exception. There are instances
    where programmers abuse FP constructs to make themselves appear modern, often
    resulting in unreadable code. Programming being a social activity (in addition
    to its intellectual appeal), the readability of code is as important as its elegance
    and performance. In this chapter, we will take a closer look at this popular paradigm
    by applying it in the context of GoF patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A strategy pattern implementation using FP/OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fresh look at the iterator pattern using FP/OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MapReduce programming idiom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new spin on the template method pattern using FP/OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A strategy pattern implementation using FP/OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To focus on the programming model aspect, let us write a bubble sort routine
    to sort an array of the `int`, `double`, or `float` types. In a sort routine,
    we need to compare adjacent elements to decide whether one should swap the position
    of the elements. In computer science literature, this is called a **comparator**.
    Since we are using generic programming techniques, we can write a generic comparator
    interface to model the comparison action that would need to be performed while
    sorting is happening, and we will apply the strategy pattern to provide comparators
    based on types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Even though we can use a single generic implementation for comparing elements,
    in real life we might need concrete classes that are specific to the types. We
    will implement two concrete classes for the comparison of integers and doubles.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Armed with the comparison classes, we can write a generic sort routine by parameterizing
    the comparison classes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippets show how the bubble sort routine can be invoked
    for sorting integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent version for sorting doubles is given next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The OOP version of the code is simple and intuitive. But we need to resort to
    interface declaration and its implementation to write our code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most cases, the comparison logic can be given at the call site, using lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Using FP constructs to make the code better
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lambda functions can be used to write a comparison strategy routine in a much
    terser and intuitive manner. We can leverage the C# function type `Func<TIn,TResult>`
    construct to do this. Let's rewrite the sort routine to leverage this idiom. We
    could also impart this sort capability to the array types using extension methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can invoke the routine by explicitly defining a `Func<T1,T2,TReturn>` method
    to do the comparison. The following code snippet demonstrates this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also invoke the routine by writing a call site lambda, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to sort a double array, the following code snippet will do the
    trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The strategy routine, implemented as lambda expressions, made the code much
    terse and readable as well.
  prefs: []
  type: TYPE_NORMAL
- en: A fresh look at the iterator pattern using FP/OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C# programming language has built-in support for the iterator pattern using
    the `foreach` loop construct. Any programmer worth his salt might have written
    code to iterate over a collection and apply some kind of transformation. To get
    things in perspective, let's globally write some code to compute the arithmetic
    mean (average) of a set of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding imperative code does the job really well, and it is quite readable.
    Let us explore whether we can improve the situation further. If you take a closer
    look, the code iterates through a collection, and applies some logic which is
    context-dependent. If we want to calculate the product of numbers, we need to
    write the same code by slightly changing the operation. While computing the geometric
    mean, we compute the product of the numbers. To parametrize the computation, we
    will use a lambda expression or function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us write an aggregator function, which will iterate through an array of
    numbers and perform an operation we specify at the call site. We will use the
    function to compute the arithmetic sum (called **sigma**) or the multiplicative
    sum (called **PI**) by passing the transformer function as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us see how we can write the arithmetic mean function using our aggregator
    function. The following code uses a lambda expression to specify the computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The geometric mean can be computed in the following way (for brevity, we have
    ignored robustness concerns such as the presence of a zero, empty, or null array):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To put everything together, we will write a standard deviation (`STD`) method
    to compute the standard deviation of the elements in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `STD` method takes the average of the list of numbers as a first step, and
    uses the value (`avg`) to compute the variance. For variance computation, the
    average is subtracted from each number and squared to make the resulting value
    positive, before accumulating it to a running sum (`b`) variable. Finally, the
    square root function is invoked to compute the standard deviation. The resulting
    code is readable, and can be used as a basis for other transformations on the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: MapReduce programming idiom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the FP world, **MapReduce** is considered as a programming idiom.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The process of mapping can be described as the application of a function or
    computation on each element of a sequence to produce a new sequence. Reduction
    gathers computed elements to produce the result of a process, algorithm, or a
    functional transformation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2003, two Google engineers (Sanjay Ghemawat and Jeff Dean) published a paper
    about how the company used the MapReduce programming model to simplify their distributed
    programming tasks. The paper entitled *MapReduce: Simplified Data Processing on
    Large Clusters* is available on the public domain. This particular paper was very
    influential, and the Hadoop distributed programming model was based on the ideas
    outlined in the paper. You can search the Internet to find the details of the
    paper and the origin of the Hadoop data operating system.'
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the complexity, we are going to implement a MapReduce function to
    apply the computation on an array of doubles. The following `Map` function applies
    a lambda on each element of the array, and returns another array; this actually
    transforms the original array without mutating it. For large arrays, in order
    to speed up the operation, we can leverage the `Parallel.For` construct in the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The MapReduce model can also be considered as the scatter/gather model of computation.
    In the last example, we leveraged parallel programming techniques to scatter the
    computation into different tasks, which would be scheduled in different threads.
    This way, computation for large arrays can be made faster. In the distributed
    version scenario, we scatter the computation to different machines. In the reduce
    scenario, we accumulate or aggregate the result of computation that occurred at
    the map stage. The following code shows the use of a serial operation in aggregating
    the value to an accumulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding two functions can be used to compute standard deviation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For the time being, we are parking our discussion on the MapReduce programming
    model. It is a very vast topic, at least in the context of distributed computing
    environments. The Microsoft Azure platform offers a MapReduce implementation as
    part of its services. To be a modern developer, one should understand the MapReduce
    programming model and its stream processing counterparts available as part of
    various offerings.
  prefs: []
  type: TYPE_NORMAL
- en: A new spin on the template method pattern using FP/OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will demonstrate how the template method pattern can be
    implemented using imperative programming techniques, and we will refactor the
    code to write an FP one. As a concrete example, we plan to use the computation
    of **Internal rate of return** (**IRR**) as a running example.
  prefs: []
  type: TYPE_NORMAL
- en: 'To focus on the essentials, let us quickly hack an engine to compute the IRR,
    given a series of payments (`List<double>`), the rate, and the period. As a first
    step, we need to compute the present value of a series of payments by using the
    technique of discounting. The following routine computes the present value of
    the series of payments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The definition of IRR goes as follows**:'
  prefs: []
  type: TYPE_NORMAL
- en: An IRR is a computation that maps a series of payments that are supposed to
    accrue to the present value by finding the rate at which the series of payments
    has to be discounted to make the future value equivalent to the present value.
  prefs: []
  type: TYPE_NORMAL
- en: The following routine has been ported from the book, *Financial Numerical Recipes
    in C++*, Bernt Arne Odegard. For details, one can consult section 3.2.1 (material
    on IRR) of the book available on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With the routine under our belt, we can create an IRR calculation class that
    will use the template method pattern to receive the input for the computation
    of IRR, based on the series of future payments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us create a class for the purpose of specifying inputs to the IRR computation
    sub system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the template method pattern implementation, we define an `abstract` base
    class, which does the bulk of the computation, and an `abstract` method, which
    the concrete class has to override to create an object out of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Since the compute method is flagged as abstract, we cannot instantiate an object.
    The main thing which we can do is override the class and provide the content of
    the `abstract` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the preceding class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Using FP for the template method pattern implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use lambda functions to simplify the template method pattern implementation.
    Instead of overriding a method after sub-classing the abstract class, we will
    use anonymous delegates to achieve the same objective. The resulting code, given
    next, is very simple and easy to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The class can be leveraged as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A quick note on the observer pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The functional programming model is well suited for implementing the observer
    pattern. Microsoft Corporation has already created a library, christened Rx, to
    exploit this synergy. This library implements a subset of features that falls
    under the category of compositional event streams. We will be covering the relationship
    between the observer pattern and functional programming from the next chapter
    onwards.
  prefs: []
  type: TYPE_NORMAL
- en: Does FP replace GoF patterns?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a notion among some programmers that functional programming can help
    to keep us away from GoF patterns. As far as the authors of this book are concerned,
    it is bit of an overstatement. In this chapter, we have already seen how GoF implementations
    can be made simple and better using functional language idioms. But the examples
    in this book are mostly written using C#. If we are using F# or Haskell, there
    are techniques available, in the rich type system of those languages, to do away
    with some of the GoF patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two examples are:'
  prefs: []
  type: TYPE_NORMAL
- en: Partial function applications have made the builder pattern unnecessary for
    FP programming languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional pattern matching helps us to eliminate the visitor pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you take a closer look at the scheme of things, the GoF pattern was a solution
    for the static and rigid type system of C++. After that, languages such as Java
    node C#, on reflection, came to the fore to simplify the implementation of GoF
    patterns. The FP can be treated as yet another enhancement. A dynamic language
    with FP support can help us implement GoF patterns better, or sometimes completely
    do away with patterns. But, completely replacing GoF patterns is bit of a shot
    in the dark!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you saw how imperative code (aka OOP code) can be mixed with
    FP constructs to write implementations of some of the GoF design patterns. Some
    functional programmers say that the GoF design patterns were conceived as a mechanism
    to overcome the limitations of an OOP in general (C++ in particular). If a language
    supports good FP constructs, most pattern implementations are unnecessary. According
    to our understanding, this view is a bit extreme and a middle path between FP
    and OOP seems to be a better option. In the coming days, FP idioms will become
    more and more popular and the progress will be a smooth transition. In the next
    chapter, we will delve into the nuances of functional reactive programming techniques.
    This is a very important paradigm where FP and events come together to provide
    us with frameworks such as .NET **Reactive Extensions** (**Rx**).
  prefs: []
  type: TYPE_NORMAL
