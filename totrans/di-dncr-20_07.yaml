- en: Interception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed two pillars of the DI ecosystem in the previous two
    chapters. Those pillars provided us with ways to identify dependencies, register
    them and then manage their lifetimes as required. In this chapter, we are going
    to cover something different which addresses the architectural problem of DI.
  prefs: []
  type: TYPE_NORMAL
- en: An application without security, logging, caching, transaction management, and
    so on seems very incomplete. When we write codes to cover up all these functionalities
    for the app, we might end up writing repetitive codes in each module all around
    the application. Even if Dependency Injection has an existence in our application,
    solving the purpose of managing the requirements of a class and trying to provide
    all the types needed for logging, or others as mentioned previously, violates
    SRP and DRY. Thus, we need a different approach to solve this problem and that
    is **Interception**. Simply put, Interception will help us dynamically inject
    blocks of code wherever required.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you might have a question regarding when and how we can inject this code.
    Let's hold on to the *how* for now and focus on the *when*. We will discuss the
    *how* soon. To answer *when*, the injection can be done before or after, or it
    can even totally replace the actual method execution.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will understand what Interception is and how it can be implemented.
    We will find out possible techniques to interrupt the flow of execution. Definitely,
    we will discuss why we even need *Interception*.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns and principles of Interception in .NET Core is the next thing we are
    going to illustrate. We will even extend the concept of Interception in ASP.NET
    MVC Core using filters and middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Cross-cutting concerns and aspects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aspect-oriented programming** (**AOP**): Its types, advantages, disadvantages,
    and process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demos of each type of AOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interception adoption in ASP.NET Core MVC using filters and middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Interception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I will introduce you to *Interception* along with the connection
    it has with the *Dependency Injection*.
  prefs: []
  type: TYPE_NORMAL
- en: Interception is another important pillar. Interception is the process through
    which we can easily intercept the call between a consumer and a service in order
    to execute certain codes before or after the service is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows what happens with and without the Interception
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/280c7e04-d3e5-4578-b67b-515d13b3436c.png)'
  prefs: []
  type: TYPE_IMG
- en: If we consider the preceding request as a call that comes to the index action
    of a controller named `CompanyController` and before the company details are served
    to the client, we can run a few bookkeeping tasks such as *Who requested the company
    details?*, *When was the call **made?*, *I**s the user authorized* *to receive
    the company details?*, and so on. For all these tasks, we have to stop the flow
    in the controller to do all these operations, and after we are done, we can again
    resume the main task of returning data. But all these tasks can't be written inside
    the controller action, because the main responsibility of the action is to return
    the company details. If we write everything inside the action method, it would
    violate SRP.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's find out by a class that requires basic logging as a part of its operations.
    A `CompanyRepository` might have a method to assign a `User` to a `Company`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, a client asks you to log some important information while this operation
    takes place, just for bookkeeping and future reference. The information could
    be the start time of the operation, end time of the operation, who requested for
    the operation, exceptions if any, and so on. The instant solution that comes to
    your mind might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice the bold lines. `ILogger` can be injected to the repository through a
    constructor for log operations. We can also put `try...catch` block and log exceptions.
    Everything looks good, but don't you think the class is doing more than what it
    is intended for and that we are violating the **Single Responsibility Principle**
    (**SRP**). Therefore, let's think of another solution. How about the following?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We introduced a decorated `CompanyRepository` named as `LoggingCompanyRepository`,
    which is managing the logging part. It is initialized by taking repository and
    logger dependencies and executing the method as needed with log entries. Following
    the Decorator Pattern, the new class tries to coordinate the work between the
    repository and logger.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final task would be to compose the decorator, which has the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We can create the instances of `SqlCompanyRepository` and `SqlLogger` which
    derive from related abstractions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we create the instance of the decorator by injecting these dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We return the `CompanyService` instance with the decorated repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refer to the following code for these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is what Interception is all about. We are able to interrupt the call made
    to `AssignUserToCompany` of the concrete class `SqlCompanyRepository` because
    the `Service` is now composed of a decorator with the concrete class, instead
    of the direct code block. When you call the method, it would first go to the decorator's
    method and then call the concrete class method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram explains the flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/216a1091-ff1a-4ed5-8bc4-65a81ac9da54.png)'
  prefs: []
  type: TYPE_IMG
- en: Patterns and principles for Interception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You must be getting a hint that I want you to taste the DI from the perspective
    of not only injecting dependencies, but also managing and maintaining code for
    a good architecture. We explored the Decorator Pattern in the last section, which
    enabled us to decorate the concrete implementation with a little additional code
    without even touching any classes in the application. This forms the basis of
    Interception.
  prefs: []
  type: TYPE_NORMAL
- en: With Interception, we clearly followed SOLID principles of Software Design.
    The moment we started designing the decorator class, that class played a vital
    role in the SRP. `CompanyRepository` is managing the database part and the `LoggingCompanyRepository`
    takes the responsibility for logging.
  prefs: []
  type: TYPE_NORMAL
- en: The **Liskov Substitution Principle** (**LSP**) demands that the consumer should
    not feel the change of any implementations of the dependency. We achieved this
    by the decorator implementing the same abstraction that the `Service` demanded,
    which is `CompanyRepository` so that we would be able to replace the original
    one `SqlCompanyRepository` with the decorator one `LoggingCompanyRepository`,
    without any breakage to the service codes.
  prefs: []
  type: TYPE_NORMAL
- en: As we were doing all the preceding steps, we did not change any class for implementing
    the decorator. Instead, we extended, which strongly followed the Open/Closed Principle.
    There is no such necessity to touch the `Service` class or the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: The principles behind the Interception following SOLID gives us a hint as to
    how the Decorator Pattern is closely related to DI, since DI supports Interception.
    The Decorator Pattern is the fundamental building block of the concept, but the
    way we implemented it does not solve the architectural problems in hand. Let's
    analyze the associated benefits and problems.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of the Decorator approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the Decorator approach, we achieved many benefits. Refer to the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Service` does not know what repository it is receiving. Notice that `CompanyRepository`
    and `LoggingCompanyRespository` are both declared as `CompanyRepository` instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just because the types are the same, there is no need to do any changes to the `Service`
    class. Moreover, we added logging behavior to the `CompanyRepository` class without
    even changing it. It supports the Open/Closed principle. All classes are intact.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We were able to intercept the concrete `SqlCompanyRepository` methods in order
    to have log entries. Thus, we did not violate the SRP of the repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, we did not realize a few problems with this approach. This structure
    would lead us to a bad architecture in the long run. Let's find out why.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of dealing with the instances manually, always use DI Container to resolve
    the dependencies. We will see how we can work with DI Container for Interception
    in a while.
  prefs: []
  type: TYPE_NORMAL
- en: Problems of the Decorator approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a typical project, we will have many of these repositories and services.
    We will definitely encounter the following problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine the number of lines of codes you would have to write to compose the
    decorators in order to do Interceptions for hundreds of classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next thing is very important, which is actually the basis of our topic in
    discussion. What if you have to log in a thousand methods of those hundred classes.
    This is common and we need it in almost every method. Think of the work involved
    and the size of your app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to all these, we will end up going for a different approach for intercepting
    calls to methods using Aspects. DI Containers make it easy for us to design aspects
    and attach Interceptors. Let's move on.
  prefs: []
  type: TYPE_NORMAL
- en: Aspect-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Object-oriented programming** (**OOP**) deals with techniques to solve real-world
    problems with underlying object models. To design a software, we need to adopt
    OOP along with good design methodologies in order to make it maintainable, consistent
    and reliable. There are many such patterns or problems we will encounter during
    the application development which are of design decisions, that can neither be
    solved by OOP practices nor with procedural approaches.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will address one design decision that can be managed easily
    by Aspects. To clarify, we can consider a simple example which is very often seen
    in codes and that is **logging**. We do logging in almost every method. This means
    you are repeating codes everyday violating the **DRY** (**Don't Repeat Yourself**)
    principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows you the repeated codes of logging commonly found
    in your codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d5d05ef-62f3-4930-99ba-0d81f67aec70.png)'
  prefs: []
  type: TYPE_IMG
- en: If I tell you that we can package those logging lines into one modular piece
    of code and just ask all the methods that need logging, to just import that while
    running, what would be your reaction? Yes, that is what an aspect is all about.
    So, we can write an aspect to manage logging. The pattern we follow in order to
    implement an aspect in our app is known as **Aspect-oriented programming** (**AOP**)*.*
    Itaims to separate or modularise these repeated codes from the core functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sneak peak of the solution with an aspect called `LoggingAspect`,
    which packages all the logging codes inside it and is attached to the methods
    as an attribute above the method (written like `[LoggingAspect]`). Don''t worry
    about the rules for how the logging lines are applied to the methods at the particular
    location such as *start* or *end* for now. We will learn all these soon, which
    are the concepts behind AOP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1715faca-ea25-4ace-bdbb-b785b0910fab.png)'
  prefs: []
  type: TYPE_IMG
- en: When we follow AOP in our application, we can easily attach these modules automatically
    to our methods. Thus, developers have all the freedom to only focus on the business
    logic or core concerns inside the methods, instead of worrying about all the repetitive
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-cutting concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **concern** can be defined as a part of a system providing some specific
    functionality. If you consider a typical example of saving a user in your system,
    it may have a business logic something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Validate all fields of user for proper datatype, `null` values, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check for the user existence in the system by a unique value such as `Email`
    or `UserName`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a user does not exist, create the user, otherwise update the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All these steps are denoted as **Business Logic**, which might be different
    in different applications since it depends on your requirements and design. So,
    our `SaveUser` method's principal duty is to perform all these steps, which can
    be defined as a **Main Concern**.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in a typical application, these are not the only things that happen
    inside a `SaveUser` method. You might have to do the following during saving a
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the logged-in user is authorized to save the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in text/database that `SaveUser` started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Perform the *Business Logic* (all the steps previously defined) ] - Main Concern.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in text/database that the `SaveUser` method succeeded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Steps 1, 2, and 3 are the steps which are secondary and don't align with the
    Main Concern. But these steps can't be ignored. Moreover, these particular steps
    are performed in almost every method of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'While our method is trying to run the Main Concern, these guys try to interfere
    and cut the execution and do something else. That''s why they are known as **Cross-Cutting
    Concerns**. These concerns are located throughout the application and affect the
    entire architecture. Have a look at the following diagram where the arrows indicate
    the Main Concern and the rectangular areas represent the Cross-Cutting Concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae91997c-b0ae-47a3-b12b-9fee783f0f59.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Aspect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In simple words, when we see some repetitive patterned codes throughout our
    app, that's the clue for us to consider them as Cross-Cutting Concerns. These are
    the code patches, which do not fit with the Main Concern inside the method in
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: When I say *aspect* in the programming paradigm, it basically states the behavioral
    pattern independent of the actual task/concern at hand. So, when you package the
    Cross-Cutting Concerns into one modular piece that can be injected to the methods,
    you actually design an aspect.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we want to log at certain lines inside many methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, `Log` class methods help us to log debug steps and exceptions inside
    a method. This particular pattern can be seen often at many places in the app.
    That is what a Cross-Cutting Concern is. The actual task at hand for the `SaveUser`
    method is to update the user details such as `UserName`, `Email`, `Password`,
    and so on, but this method also takes the responsibility to log some lines into
    files, which violates the SRP. Also, when these kinds of patterns are repeated
    across the project, it does not follow the DRY principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following diagram, which depicts logging as a common paradigm across
    layers of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23be4d3a-508f-4637-b303-3d1741f67b18.png)'
  prefs: []
  type: TYPE_IMG
- en: So, here, AOP comes to our rescue which encapsulates this pattern to log the
    start, log the end, and log the exception, and then wrap it around the `SaveUser`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Another common scenario is wrapping our database operations with a `Transaction`
    block consisting of `Begin Transaction`, and `Commit/Rollback Transaction`. How
    about having someone else handling that part for us, while we concentrate on the
    core codes to operate on the database?
  prefs: []
  type: TYPE_NORMAL
- en: Cross-cutting concerns can be commonly found in the application where you log
    steps, handle exceptions, manage cache, access control, and so on. For example,
    while handling exceptions, you wrap your code using a `try..catch` block so that
    you are able to operate on that exception found (log to text file/database or
    send email to admin, and so on). This particular pattern is needed inside every
    method. Now we need to find out a way to ask (more specifically wrap) every method
    that we need for exception handling, instead of adding the `try..catch` lines
    inside it. Thus, that wrapped modular piece can be termed as an aspect, which
    eventually wraps all methods instructed to it to perform the exception handling,
    instead of the methods themselves doing the same.
  prefs: []
  type: TYPE_NORMAL
- en: Aspect characteristics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we try to encapsulate these Cross-Cutting Concerns to create aspects,
    we actually make sure they follow some characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wrapper:** All these aspects will be a wrapper around some business functionalities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single Responsibility Principle (SRP): **The wrapper is concerned only about
    one particular task. For example, logging will only do the task of logging and
    nothing else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decorator Pattern: **The aspect then attached with the existing functions
    with the Decorator Pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open Close Principle: **When these repetitive codes were in business functions
    and we if needed any change in them in the future, then we would have to change
    the business function as it contains those pieces, which violates the Open Close
    Principle. Now, when we isolated those pieces to a module, the business functions
    became *Open* for extension, but *Close* to change.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Refer to the following diagram for a pictorial explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b1bffb1-1fbd-416e-8c42-fd5c4b1815b5.png)'
  prefs: []
  type: TYPE_IMG
- en: AOP is not a competitor of OOP. Both are totally different. One is not a replacement
    for the other. With all these characteristics, AOP helps us to maintain a good
    structure for the project, hence resulting in a good OOP practice.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let me summarise the important advantages of AOP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increases modularity:** Common functionality is centralized into independent
    modules and is attached those modules or aspects at many places in the app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manages Cross-Cutting Concerns:** The concerns which are scattered comes
    to one place which can be managed easily without making any code change to the
    actual business codes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better architecture: **Separation of these concerns into singly responsible
    aspects helps us to architect and organise business needs without unnecessarily
    repeating ourselves in the codes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aspect attached locations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are basically three locations where an Aspect can be attached to a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**On Start:** When we want an aspect to execute immediately before the underlying
    function execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**On Error: **Obviously, an aspect at this location will run only if an exception
    occurs in the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**On Success:** Runs immediately after the method execution. However, it is
    limited to the functions which don''t throw exceptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of AOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two techniques in AOP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interceptors:** Dynamic, which attaches the interceptors during runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IL Code Weaving:** Static, which runs after compilation and inserts code
    into the assembly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static (post-compilation) ones include Fody, SheepAspect, Mono.Cecil, and PostSharp.
    Static might be faster, but we get more flexibility in a dynamic one, as we can
    change the code dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the aspects to the code depends on the framework used. There are different
    techniques to attach the aspects such as writing attributes, XML configuration,
    and fluent interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating Interception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To intercept means to prevent something or someone from reaching an intended destination.
  prefs: []
  type: TYPE_NORMAL
- en: Interception (a programming paradigm), helps us to design aspects and inject
    cross-cutting concerns wherever demanded at the runtime. Using an Interceptor,
    we can easily intercept the calls to methods and properties in a class. To achieve
    this, we usually end up using an **Inversion Of Control** (**IoC**) container.
  prefs: []
  type: TYPE_NORMAL
- en: IoC provides the class functionality and then wraps it with our requested interceptor.
    Suppose somewhere in the code you ask for a class (say `Student`) to the IoC container
    of a specific type (say `IStudent`), which has an aspect for logging, then the
    IoC container would be able to provide the class (`Student`) with an interceptor
    decorated with it for the aspect demanded.
  prefs: []
  type: TYPE_NORMAL
- en: Interceptors are managed by external components that create dynamic decorators
    dealing with wrapping the aspects around your existing business components.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of Interceptors is that they are not bound by the compilation
    process and don't modify our assemblies post-build. In other words, it's just
    the configurations for IoC containers, which you can easily take to another project
    instead of taking the DLLs and compiling them again.
  prefs: []
  type: TYPE_NORMAL
- en: However, Interceptors are configurable to work either at runtime or compile
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Unity, Ninject, Spring.NET, Castle Windsor, LinFu, Autofac, LOOM.NET, Seasar,
    and so on are some IoC containers that allow injecting Interception at compile
    time or runtime.
  prefs: []
  type: TYPE_NORMAL
- en: These IoC containers use a Dynamic Proxy to create in-memory decorators that
    wrap your existing code. Those Dynamic Proxies are responsible for code execution.
    Thus, it allows execution of the wrapper aspect as well as the underlying code
    being wrapped.
  prefs: []
  type: TYPE_NORMAL
- en: The Interception process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Interception process can be depicted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8dfd86a3-37b0-4b8c-abab-fd43c45fcb5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The calling code asks IoC container about the type it is looking for. For example,
    the `IExampleInterface` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IoC container now tries to match the concrete implementation of the type requested,
    which it can return back to the calling code that is `Example` class. While it
    is doing this, it recognizes that the type is already configured to use an interceptor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of directly returning to the calling code, the IoC container now sends
    the Interceptor and the implementation class for the requested type to the Dynamic
    Proxy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Dynamic Proxy now takes the concrete class and wraps it with the interceptor.
    Then it generates a class implementing the type initially requested with an instance
    of the concrete class given by the IoC container and the interceptor. After that,
    it returns back that implementation of the requested type to the IoC container.
    That is the `Interceptor` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IoC container now sends back the `Interceptor` class generated by Dynamic
    Proxy to the calling code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling code executes the returned class which in turn runs the interceptor
    and the underlying code of the concrete class `Example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Castle Windsor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Castle Windsor is an Inversion of Control Container. This library is a part
    of the open source project known as the **Castle Project**. The Castle Project
    ([http://www.castleproject.org/](http://www.castleproject.org/)) provides reusable
    libraries for many purposes. Castle has many components and Windsor is the DI
    CONTAINER component of the Castle Project. However, it can be used independently
    of other Castle components.
  prefs: []
  type: TYPE_NORMAL
- en: We have many other libraries available on the market such as Microsoft Unity,
    Autofac, Ninject, and so on. Each framework offers slightly different advantages
    and features. However, at the bottom, they implement the same for most of the
    core concepts, including Type Registration, Resolution, and Injection. You can,
    no doubt use any of these to apply Interception in your application.
  prefs: []
  type: TYPE_NORMAL
- en: There is no such logic as to why we are going to use Castle Windsor though.
    Using this tool, we can easily attach Interceptors to our codes. We will see that
    in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Demonstration for using the Castle Windsor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start to implement one Interceptor using the `Nuget` package Castle
    Windsor. First of all, create a Console App, go to Nuget Package Manager and install
    the Castle Windsor package. After successful installation, your Project Reference
    will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb4c6919-282d-4667-869f-45ff7e086a2f.png)'
  prefs: []
  type: TYPE_IMG
- en: So, it installs `Castle.Core` and `Castle.Windsor`. Now we are ready to create
    an Interceptor.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Interceptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will do a simple Logging Interceptor which will log steps as well as exceptions
    for us. Let's name that `LoggingInterceptor.cs`. To qualify as an Interceptor,
    the class should implement the `Interceptor` interface. The only method inside
    this interface is `Intercept` which takes `IInvocation` as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block illustrates what I said:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The call `invocation.Proceed()` just calls the underlying method which is supposed
    to be intercepted. That means, when any method which is registered to use this
    interceptor, it will come to this method, which in turn, calls the same method
    from here with the `Proceed()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To investigate the actual benefit of having an interceptor, we will add more
    codes here in the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is to design an interface and a concrete class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So, the `PrintName()` method prints the name using `FirstName` and `LastName`.
    We will intercept this method and try to add log steps using an interceptor.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching an Interceptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important part now is `ExampleRegistration`, which implements the interface
    `IRegistration` of `Castle.MicroKernel.Registration` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the place where we register `LoggingInterceptor` (refer to the first
    comment in the following code block) and then declare that `Example`, class which
    will be intercepted by `LoggingInterceptor` (refer to the second comment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not the least, the `main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We take an `IWindsorContainer` instance. First, we register our `ExampleRegistration`
    class which contains our target method and interceptor configurations. Then, `_container.Resolve()`
    helps us to get the required instance implementing `IExample`.
  prefs: []
  type: TYPE_NORMAL
- en: As we have already defined that `Example` is the class implementing `IExample`
    in the `Register()` method of the `ExampleRegistration` class, one instance of
    `Example` class is created. Then, we have a `PrintName()` call inside the `try`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to run the app and see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d2113fb-eda5-4e43-ac81-c3c26325555b.png)'
  prefs: []
  type: TYPE_IMG
- en: Clearly, before printing the name, the first thing that executes is the log
    Starts message. Secondly, the actual method execution which prints the name. After
    that, as we expected, the Success and Exit messages. Exit means it exited from
    the interceptor.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, we did not get any exception, so that message got skipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to see that. The modified `Example` class will be like the
    following with a `throw new Exception()` code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Forcefully, we are throwing one exception before the `Console.WriteLine`. We
    will see the following output when we run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5317171d-e369-4988-a854-624bf766e51a.png)'
  prefs: []
  type: TYPE_IMG
- en: Interestingly, we don't see the Success log message, but the Exit message is
    printed and the actual execution of the method which was printing the name did
    not happen either. That is because the Exit message will definitely get printed
    no matter what happens to the calling code as that is inside the `finally` block
    of the interceptor.
  prefs: []
  type: TYPE_NORMAL
- en: We manually threw an exception before the actual code execution to print the
    name, which resulted in printing the exception log message along with Start and
    Exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple Interceptors can be attached to a single class. There are two types
    of interceptor registrations, coded as follows. You can use either the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`     kernel.Register(        Component.For()       .ImplementedBy()      
    .Interceptors<LoggingInterceptor,           AnotherInterceptor>());`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or you can use this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`    kernel.Register(      Component.For<IExample>()      .ImplementedBy<Example>()
         .Interceptors(new InterceptorReference[] {      InterceptorReference.ForType<LoggingInterceptor>(),
         InterceptorReference.ForType<AnotherInterceptor>() }).Anywhere);`'
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate Language (IL) Weaving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this type of AOP, the aspects are attached to the underlying code after the
    application has been compiled. This post-compilation process alters the assemblies
    at the IL level so that the aspect hook points are called where they are configured.
  prefs: []
  type: TYPE_NORMAL
- en: If I explain in simple words, it is a process by which the aspect codes are
    interjected into the original code after compilation, but that happens only to
    the IL code (original source code remains intact) and packaged into the assemblies.
    Your original code will be intact. However, along with your code, the aspect blocks
    will be included and the assembly gets the modified code. Unlike Interception,
    where the codes are interjected at the runtime, this process is static and codes
    are included beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: The most widely used tool for weaving is PostSharp, which we will demo in a
    while. Others include LOOM.NET, Fody, SheepAspect, Mono.Cecil, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: IL Weaving process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since I explained the process, let''s see that in action in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3600f40b-ce25-455e-9e7a-3c1e55138211.png)'
  prefs: []
  type: TYPE_IMG
- en: Simple, isn't it! Now that we understand how the process goes along, it's time
    to get our hands dirty on some real code and try it out.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an aspect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting up, we need to add the `Nuget` package named as PostSharp to
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an aspect, we need to design the class which would inherit from the `OnMethodBoundaryAspect`
    aspect class, which is an abstract class inside the `PostSharp.Aspects` namespace.
    This can be seen in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`OnMethodBoundaryAspect` helps to write code which can execute before or after
    a method execution or in the case of an exception. As you can see from the previous
    class, we are overriding the `OnEntry`, `OnExit`, `OnException` and `OnSucess`
    methods. There are other aspect classes which can solve the different purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `main` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you run the app, nothing happens. We get a confirmation if we can
    see the generated assembly codes.
  prefs: []
  type: TYPE_NORMAL
- en: ILSpy is the open-source .NET assembly browser and decompiler. You can download
    it from [http://ilspy.net/](http://ilspy.net/). This will help us see the actual
    codes packaged inside the assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the ILSpy application and then select the assembly of our app,
    it will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9afb9af-a342-460e-a017-2037ad8ce301.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see the `Example` class has code intact. No other code got inserted
    into the assembly. That's because we have not yet attached the Weaver with our
    `Example` class. Let's do that next.
  prefs: []
  type: TYPE_NORMAL
- en: If you encounter a PostSharp license error while building the app, that means
    you have to purchase one license. You can also use the free license, which has
    certain limitations. You can find the download page at [https://www.postsharp.net/essentials](https://www.postsharp.net/essentials).
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the aspect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attaching the aspect is very easy. You can simply add the weaver as an attribute
    to the classes you want to wrap the aspect to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the bold line above the `PrintName` method in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We attributed the `[LoggingWeaverAspect]` around the `Example` class. Now,
    let''s run it and see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14e6bbc1-bd8f-4254-baa1-d27cc33bd5ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Have a look at the assembly code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02849973-1275-4e45-9366-8391ef64d4da.png)'
  prefs: []
  type: TYPE_IMG
- en: The red boxes here indicate the code which was inserted into the assembly after
    you built the application. Since we had one `OnException` in the weaver aspect,
    the `PrintName()` method now contains a `try...catch` block. Finally, `OnEntry` is
    at the beginning and `OnExit` is inside. After the `Console.Writeline()`, we can
    see the `OnSuccess` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we get an exception before the actual execution of the method (before `Console.WriteLine()`
    in this case), we will see the following output without the success message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1e66995-aca1-4118-b724-0d483ae8322e.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we've had a sneak peek at the concepts, let's explore how Interception
    is implemented in .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Interception in ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core implements the concept of Interception to interrupt the calls to
    controller actions and request-response pipeline. We can do this by different
    techniques known as filters and middleware. We will discuss each one with examples
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Filters allow ASP.NET Core to intercept action methods. You can configure one
    global filter which would run every time one controller action is requested, or
    have individual unique filters for some action methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The filters would implement one of the filter interface residing in the `Microsoft.AspNet.Mvc.Filters`
    namespace. Let''s see a simple filter skeleton as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example, `SomeFilter` implements `IActionFilter`.
     `OnActionExecuting` and  `OnActionExecuted`, as the names suggest, would run
    when an action is being executed and completes execution respectively.
  prefs: []
  type: TYPE_NORMAL
- en: If you recall the principle of Interception (which says that the *process by
    which we can run some code before or after the method which is being executed
    or totally replace that*), you will notice that these `IActionFilter` methods
    also follow the principle and are intended to intercept the calls to a controller
    action method.
  prefs: []
  type: TYPE_NORMAL
- en: Global filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose you want to create an interceptor which would intercept all the action
    methods. Sounds like a common or globally declared code block that can be termed
    as a **Global filter**. Registering a filter to the MVC filters using the service
    collection inside `ConfigureServices` would make a filter globally executable
    or interceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following code, which is the only line to convert a normal filter
    to a Global filter except the definition of the filter, which of course you need
    to code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`SomeGlobalFilter` can also be injected with dependencies. The following code
    block can be considered as a Global filter, where `ISomeService` is injected using
    the most popular Constructor Injection Pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Did you notice one thing? The parameterized constructor in `SomeGlobalFilter`
    is injected with the dependency of type `ISomeService`. Not optional though, but
    it can be done if we need any of the required dependency in filters. Imagine,
    if we need to add a log entry in the database whenever an action starts execution,
    something like a bookkeeping of what events occur in what sequence. To achieve
    this, we can inject a service and then use its methods to operate on the database.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way to attach filters is to write attributes for required actions.
    When you do global, it applies to all the actions. However, if we want to attach
    to certain actions only, then we can write attributes. Let''s take a look at an
    action method which is attributed with `SomeFilter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7f41471-53db-4914-bf27-962f70922f23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The compiler is complaining. If you hover, it will say SomeFilter is not an
    attribute class. It actually expects the `SomeFilter` like as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice the name of the filter which was changed to `SomeFilterAttribute` and
    derived from `Attribute` abstract class. This is by syntax. Also, attributes require
    parameterless constructors. But to intercept, we need to implement some filter
    interface like `IActionFilter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this, we can take the help of the  `TypeFilterAttribute` class
    which derives from the `Attribute` class and takes a type through its constructor.
    Thus, the following code shows the correct pattern to use a filter as an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of important things to note here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We have not registered `SomeFilter` in the entry point of the app; still, it
    works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TypeFilter` attribute helps to create an instance of `SomeFilter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we are playing with .NET Core, we should get the filter instance from the
    service registrations, instead of creating it dynamically through `TypeFilter`.
    That is where the `ServiceFilterAttribute` class comes onto the scene. Let''s
    see how we can modify the code to use `ServiceFilter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Are you sure this change will work? No, it won''t. When you run the app, you
    will see the error captured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9824fd1-d0dc-45fd-8f93-65851f826231.png)'
  prefs: []
  type: TYPE_IMG
- en: Ah, I know! Now you got what we missed. This is a very familiar exception when
    you are working with DI. As I said, `ServiceFilter` finds the filter instance
    from the service collection; if you don't register it, it will definitely throw
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is what you need to make it work. It is not mandatory to
    make it transient though, it depends on your scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Middleware, what it is known for, intercepts the pipeline of execution, and
    the developer can do anything before the response is served to the client. We
    will see how exactly we can implement Middlewares to intercept in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Middleware in ASP.NET core follows the Interception technique to interject
    aspects between request and response. It''s basically some block of code which
    is registered with the application pipeline. The following diagram shows how Request
    goes through Middlewares one by one before Response comes out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/933025b8-e773-4af0-9cbf-f34f38b955cb.png)'
  prefs: []
  type: TYPE_IMG
- en: A large amount of Middleware can be inserted into the pipeline. Each Middleware
    decides whether to pass the execution to the next one and can perform some logic
    before and after the invocation of the next component. These components are designed
    to solve specific purposes like logging, exception handling, authorizing, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `IApplicationBuilder` interface helps us register the Middleware using
    the `app.Use` inside the `Configure()`. Let''s check a simple code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have two Middlewares and then `app.Run`. When we run this, we will see the
    following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6ccb1b3-9b7d-4664-9e8d-964b2ce97a62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is a catch here. If you refresh the page, without building the code,
    the following is what you see next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce483d01-0a7a-4828-a190-ce4deb8b1637.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason is I have concatenated the string and when you refresh the page,
    it directly comes to the Middleware 1 followed by Middleware 2 and then `app.Run`.
    As the variable got initialised inside the `Configure`, it has an application
    scope. It will be appended henceforth. If you refresh the page again, you will
    see another set of the same messages getting appended to what you see in the preceding
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the way Middlewares hijack the application pipeline and execute before
    the response is delivered to the client. Let''s consider another code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'What do you think the output will be? Check it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/276333d2-1a54-42ed-89b6-7feaf2824c53.png)'
  prefs: []
  type: TYPE_IMG
- en: Middleware 2 got missed. That is because we wrote `app.Run` before Middleware
    2\. `app.Run` is the exit point which terminates the pipeline. Anything after
    that won't be considered by the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, definitely, code before and after invoke is called, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`   app.Use(async (context, next) =>     {     // Do something before the next
    middleware is         invoked.          await next.Invoke();     // Do something
    after next middleware invocation.    });`'
  prefs: []
  type: TYPE_NORMAL
- en: Ordering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a simple rule that the order in which they are registered is the order
    in which they will be executed. The ordering plays an important role while one
    component depends on another. The exception is something which may occur anytime,
    anywhere, within the app. So, we need to register it first before everything else,
    so that we can easily capture the exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We explored what aspects are and how to determine Cross-Cutting Concerns in
    a typical programming scenario. There are specific locations where aspects can
    be tagged, which we illustrated next.
  prefs: []
  type: TYPE_NORMAL
- en: Aspect-oriented programming helps us to run custom logic before, after, or even
    replacing the method completely, where it is registered. We saw static as well
    as dynamic techniques to attach aspects with IL Weaving and Interceptors respectively.
    Interception is the technique which is more preferred over IL Weaving as it dynamically
    runs the registered block of code (otherwise called an aspect). On the other hand,
    IL Weaving deals with assembly update after the build process is over to insert
    aspect codes into the methods registered.
  prefs: []
  type: TYPE_NORMAL
- en: We then got into a thorough discussion on how Interception is adopted in ASP.NET
    Core in the form of filters and Middlewares.
  prefs: []
  type: TYPE_NORMAL
- en: Filters can intercept the path of action method execution, which can be either
    be attributed to the method as required, or can be registered with service collection
    to label it as a Global filter.  One line of registration of a filter can make
    the filter intercept all action methods easily.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware is a technique in ASP.NET Core which allows us to insert built-in/custom
    code chunks into the request-response pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned all the fundamental concepts of DI, in [Chapter 8](795befd2-857f-40d2-ba05-cb2921168bcc.xhtml),
    *Patterns - Dependency Injection*, we are going to discover different techniques/patterns
    to inject dependencies into the clients.
  prefs: []
  type: TYPE_NORMAL
