- en: Chapter 12. Reactive Programming Using .NET Rx Extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章. 使用.NET Rx扩展进行反应式编程
- en: In the previous chapter, we saw how reactive programming shapes you up for scalability
    and responsiveness. We saw how these two attributes are supported in event-driven
    applications that enable it to readily respond to events, failures, and loads.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了反应式编程如何让你为可扩展性和响应性做好准备。我们看到了这两个属性如何在支持事件驱动的应用程序中得到支持，这些应用程序能够迅速响应事件、失败和负载。
- en: 'Now in this chapter we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在本章我们将：
- en: Take a deep dive into the Reactive Extensions (Rx) library and see how we write
    asynchronous and event-driven programs using observable sequences and LINQ query
    operators
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入研究Reactive Extensions (Rx)库，看看我们如何使用可观察序列和LINQ查询运算符编写异步和事件驱动程序。
- en: We will also take a detailed look at some sample use cases and their implementations
    with Rx to clearly understand how Observables, LINQ, and Schedulers in the .NET
    Framework are leveraged to create concurrent and responsive applications that
    can work with asynchronous data streams
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将详细探讨一些示例用例及其使用Rx的实现，以便清楚地了解如何在.NET框架中利用Observables、LINQ和调度器来创建可以处理异步数据流的并发和响应式应用程序。
- en: By the end of this chapter, you will understand why Rx has been touted as the
    next big thing, and one that will become the de facto event-driven programming
    model, gaining traction and acceptance in various mainstream programming languages.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将理解为什么Rx被吹捧为下一个大事件，并且将成为事实上的事件驱动编程模型，在各种主流编程语言中获得势头和认可。
- en: Streams as a way of life
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流作为生活方式
- en: As you saw in the previous chapter, the fundamental success to reactive programs
    is to convert events into immutable and observable streams. Program composition
    becomes very easy and intuitive with this format, and you can create a unifying
    interface using the .NET Rx extensions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一章中看到的，反应式程序的基本成功在于将事件转换为不可变和可观察的流。使用这种格式，程序组合变得非常简单直观，你可以使用.NET Rx扩展来创建统一的接口。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is really important to understand, as wielding a hammer like Rx doesn't
    make you Thor. You don't necessarily start seeing every single implementation
    as a nail and drive your hammer down on it. As Uncle Ben once advised Peter aka
    Spiderman - "With great power comes great responsibility".
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点非常重要，因为像Rx这样的工具并不能让你变成雷神索尔。你并不一定把每个实现都看作是钉子，然后用力敲打。正如本叔叔曾经劝告彼得，也就是蜘蛛侠：“能力越大，责任越大”。
- en: 'Let''s understand this more by looking at the palette of options available,
    and making sound decisions on what can be done. Consider the following image:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看可用的选项集，我们可以更深入地理解这一点，并做出明智的决定。考虑以下图像：
- en: '![Streams as a way of life](img/image_12_001.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![流作为生活方式](img/image_12_001.jpg)'
- en: 'As you can see in the preceding figure, in terms of unifying the worlds, Rx
    brings forth bridges that help you work seamlessly across these programming models.
    To quickly recap what we read in [Chapter 11](dn-dsnptn_ch11.html "Chapter 11. What
    is Reactive Programming?"), *What is Reactive Programming?*, take a look at the
    following table:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前图所示，在统一世界方面，Rx提供了桥梁，帮助你在这类编程模型之间无缝工作。为了快速回顾我们在第11章（[第11章. 什么是反应式编程？](dn-dsnptn_ch11.html
    "第11章. 什么是反应式编程？")）中阅读的内容，请查看以下表格：
- en: '| **Factory methods** | **Unfold methods** | **Bridges** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **工厂方法** | **展开方法** | **桥梁** |'
- en: '|'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`Observable.Return`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.Return`'
- en: '`Observable.Empty`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.Empty`'
- en: '`Observable.Never`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.Never`'
- en: '`Observable.Throw`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.Throw`'
- en: '`Observable.Create`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.Create`'
- en: '|'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`Observable.Range`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.Range`'
- en: '`Observable.Interval`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.Interval`'
- en: '`Observable.Timer`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.Timer`'
- en: '`Observable.Generate`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.Generate`'
- en: '|'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`Observable.Start`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.Start`'
- en: '`Observable.FromEventPattern`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.FromEventPattern`'
- en: '`Task.ToObservable`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.ToObservable`'
- en: '`Task<T>.ToObservable`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task<T>.ToObservable`'
- en: '`IEnumerable<T>.ToObservable`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>.ToObservable`'
- en: '`Observable.FromAsyncPattern`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.FromAsyncPattern`'
- en: '|'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: As reiterated earlier, we don't replace existing asynchrony. The .NET events,
    async methods, tasks, and so on, have their use and are perfect in their own worlds.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们并不取代现有的异步性。.NET事件、异步方法、任务等都有它们的使用，并且在自己的世界中是完美的。
- en: Rx just becomes the glue to unify these worlds, provides compositionality, and
    helps build bridges.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Rx只是将这些世界统一起来的粘合剂，提供了组合性，并帮助建立桥梁。
- en: Now, let's get started on some examples that will help us understand how to
    put Rx to best use in our day-to-day programming. Only certain pragmatic aspects
    are highlighted leveraging key constructs in Rx, as complete coverage warrants
    another book in its own size.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始一些示例，这些示例将帮助我们理解如何在日常编程中最佳地使用Rx。仅突出显示了一些实用方面，利用Rx中的关键结构，因为完整的覆盖范围需要另一本同样大小的书。
- en: Spell checker using events composition
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件组合的拼写检查器
- en: 'This first example is a Windows application that integrates the previously
    implemented spell checker (from [Chapter 9](dn-dsnptn_ch09.html "Chapter 9. Functional
    Programming Techniques for Better State Management"), *Functional Programming
    Techniques for Better State* *Management*) using Rx, and explores how this can
    be leveraged to suggest alternatives and corrections. Consider the following code
    snippet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个示例是一个Windows应用程序，它集成了之前实现的拼写检查器（来自[第9章](dn-dsnptn_ch09.html "第9章。更好的状态管理功能编程技术")，*更好的状态管理功能编程技术*），并使用Rx探索了如何利用它来建议替代方案和更正。考虑以下代码片段：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Initialize your input from here, with some basic controls that we will need,
    that is, a text box (used for keyword search) and a list box that provides suggestions/corrections
    for a given keyword. Take a look at the following code snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里初始化您的输入，包括我们需要的某些基本控件，即一个文本框（用于关键字搜索）和一个列表框，它为给定关键字提供建议/更正。看看以下代码片段：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we will need to create a `DispatcherScheduler` that schedules units of
    work on the dispatcher of the current UI thread. The delegate `onInputChange`
    is created to clear the suggestions in the list box whenever the input keyword
    changes. Consider the following code snippet:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个`DispatcherScheduler`，它将在当前UI线程的调度器上安排工作单元。创建了一个名为`onInputChange`的委托，用于在输入关键字更改时清除列表框中的建议。考虑以下代码片段：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will define an observable stream/sequence on the input based by subscribing
    to the `TextChanged` event of the text box using the `FromEventPattern` bridge.
    We will further filter the input stream based on minimum characters (three, in
    this case) and distinct entries (helps us throttle the lookup frequency). A valid
    output from this input sequence will trigger the delegate that clears the list
    box contents and gets it ready to receive a new set of suggestions as and when
    they are available. Consider the following code snippet:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在输入上定义一个可观察流/序列，通过订阅文本框的`TextChanged`事件使用`FromEventPattern`桥接器。我们还将根据最小字符数（在这个例子中是三个）和唯一条目（有助于降低查找频率）进一步过滤输入流。从该输入序列的有效输出将触发委托，清除列表框内容并使其准备好接收新的一组建议，当它们可用时。考虑以下代码片段：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This defines the second observable sequence that fetches suggestions based
    on the first sequence (keyword) we defined in the preceding code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了第二个可观察序列，它根据我们在前面代码中定义的第一个序列（关键字）获取建议：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is an important step where we declaratively specify to continue fetching
    suggestions until the keyword changes (the first observable sequence for us here).
    If you notice, this is done here using the `TakeUntil` operator:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的步骤，我们声明性地指定继续获取建议，直到关键字更改（对我们来说，这是第一个可观察序列）。如果您注意到，这里使用的是`TakeUntil`运算符：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will then define delegates (`onEachSuggest`, `onSuggestError`, and `onSuggestComplete`)
    for the `Subscribe` method to receive push-based notifications, as shown in the
    following piece of code (`onEachSuggest` tend to add received suggestions to the
    list box as and when they are received):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将为`Subscribe`方法定义委托（`onEachSuggest`、`onSuggestError`和`onSuggestComplete`），以接收基于推送的通知，如以下代码片段所示（`onEachSuggest`倾向于在收到建议时将其添加到列表框）：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the final step where we will specify to observe on the dispatcher of
    the UI thread (it is absolutely critical for you to make the necessary UI updates)
    and subscribe on the default task scheduler instance (Rx will decide one for you
    based on the principle of least concurrency). Consider the following code snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一步，我们将指定在UI线程的调度器上观察（对于您来说，进行必要的UI更新是绝对关键的）并订阅默认任务调度程序实例（Rx将根据最小并发原则为您选择一个）。考虑以下代码片段：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s quickly see the supporting Model code (refactored the earlier `NorvigSpellChecker`
    code to make it a singleton and implement the `ISpellCheckerModel` interface)
    as well. This interface helps in returning the results as an enumerable list,
    which can further be converted to an observable sequence. Lets take a look at
    the following code snippet:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看支持模型代码（将早期的`NorvigSpellChecker`代码重构为单例并实现`ISpellCheckerModel`接口）。此接口有助于将结果作为可枚举列表返回，这可以进一步转换为可观察序列。让我们看一下以下代码片段：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is the old code from [Chapter 9](dn-dsnptn_ch09.html "Chapter 9. Functional
    Programming Techniques for Better State Management"), *Functional Programming
    Techniques for Better State Management*, based on Peter Norvig''s post: [http://norvig.com/spell-correct.html](http://norvig.com/spell-correct.html),
    modified to become a singleton. Consider the following code snippet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[第9章](dn-dsnptn_ch09.html "第9章。更好的状态管理功能编程技术")中的旧代码，*更好的状态管理功能编程技术*，基于Peter
    Norvig的帖子：[http://norvig.com/spell-correct.html](http://norvig.com/spell-correct.html)，修改为单例。考虑以下代码片段：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Some key things to notice here are:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一些关键点是：
- en: The use of the `FromEventPattern` bridge to subscribe to the `TextChanged` event
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`FromEventPattern`桥接器订阅`TextChanged`事件
- en: The classic use case for a Singleton (to prevent Training Model corpus creation
    repeatedly every time a word is looked up) to create and cache the dictionary
    for future use
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例的经典用例（为了防止每次查找单词时重复创建训练模型语料库）以创建和缓存字典以供将来使用
- en: It will be worthwhile to take a look at the Singleton implementation that has
    leveraged .NET 4's `Lazy<T>` type for thread safety, lazy instantiation, and not
    resorting to the conventional double-check locking idiom, where explicit locking
    is used
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得一看的是利用.NET 4的`Lazy<T>`类型实现线程安全、延迟实例化和不使用传统的双重检查锁定惯用语的Singleton实现
- en: The use of the `Where` and `DistinctUntilChanged` operators to restrict lookup
    for unique four letter words and beyond
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Where`和`DistinctUntilChanged`运算符限制查找独特的四字母词及其以上
- en: 'The screenshots of our spell checker in action are shown as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示展示了我们的拼写检查器在实际操作中的截图：
- en: '![Spell checker using events composition](img/image_12_002.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![使用事件组合的拼写检查器](img/image_12_002.jpg)'
- en: 'The supporting console helps you understand the sequence of actions behind
    the scenes, as shown in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 支持控制台帮助您理解幕后操作的顺序，如下面的截图所示：
- en: '![Spell checker using events composition](img/image_12_003.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![使用事件组合的拼写检查器](img/image_12_003.jpg)'
- en: MVVM on Rx
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVVM on Rx
- en: Now, let's convert the preceding example to see how we can apply this for a
    classic MVVM implementation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将前面的示例转换为如何将其应用于经典的MVVM实现。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: MVVM is an important application development framework that has its roots with
    **Windows Presentation Framework** (**WPF**). It is best suited for event-driven
    programming where you achieve clear **Separation of Concerns**, thereby facilitating
    parallel development (Model, View, and View Model) and testability.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM是一个重要的应用程序开发框架，其根源与**Windows Presentation Framework**（**WPF**）有关。它最适合事件驱动编程，其中你实现了清晰的**关注点分离**，从而促进了并行开发（模型、视图和视图模型）和可测试性。
- en: '![MVVM on Rx](img/image_12_004.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![MVVM on Rx](img/image_12_004.jpg)'
- en: As you observe (no pun intended) in the preceding solution model, the `TextChanged`
    event of the text box, where the word to be looked up is entered, will indicate
    to the `ISubject<T>` type here, one that implements both `IObservable<T>` and
    `IObserver<T>` interfaces, thereby enabling you to conveniently observe and publish
    items to subscribers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的解决方案模型中观察到的（无意中用了双关语），要查找的单词输入的文本框的`TextChanged`事件将指示这里的`ISubject<T>`类型，它实现了`IObservable<T>`和`IObserver<T>`接口，从而让你能够方便地观察和向订阅者发布项目。
- en: 'Ensure that you have the appropriate dependencies/packages installed via the **NuGet**
    package manager and referenced properly. The ones under consideration here include
    the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已通过**NuGet**包管理器安装了适当的依赖项/包，并且正确引用。这里考虑的包括以下内容：
- en: '`System.Reactive.Core`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Reactive.Core`'
- en: '`System.Reactive.Interfaces`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Reactive.Interfaces`'
- en: '`System.Reactive.Linq`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Reactive.Linq`'
- en: '`System.Reactive.PlatformServices`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Reactive.PlatformServices`'
- en: '`System.Reactive.Windows.Threading`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Reactive.Windows.Threading`'
- en: 'The code for the View layer is shown as follows. Take note (highlighted) of
    the data binding with the corresponding view model:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，这是视图层的代码。请注意（突出显示）与相应视图模型的数据绑定：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, an instance of View Model is created and the Model (code in
    reference is the same one used for the earlier example) instance is specified.
    The text changes are routed to the subject in View Model through the `TextChanged`
    event. Synchronization, with respect to the data bindings, (against the suggestion
    list box), happens automatically through property change notifications from View
    Model, which happens to implement the `INotifyPropertyChanged` interface. The
    data source for the bindings is retained in the View Model. Let''s take a look
    at the View Model now:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，创建了一个视图模型实例，并指定了模型（代码中引用的是之前示例中使用的相同实例）。文本更改通过`TextChanged`事件路由到视图模型中的主题。关于数据绑定，同步（针对建议列表框）通过视图模型（实现了`INotifyPropertyChanged`接口）的属性更改通知自动发生。数据源保留在视图模型中。现在让我们看看视图模型：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we will use the `CallerMemberName` attribute to avoid specifying the
    member name as a string argument to the called method:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用`CallerMemberName`属性来避免将成员名称作为字符串参数传递给被调用方法：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, this final step provides the necessary magic in terms of:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这一最终步骤在以下方面提供了必要的魔法：
- en: Providing the most recent changes in the sequence (the `Switch` operator)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供序列中最新的更改（`Switch`运算符）
- en: Looking up suggestions for only four letter words and above (the `Where` operator)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找四个字母以上的单词的建议（`Where`运算符）
- en: Looking up suggestions only if the new value entered is different from old (the
    `DistinctUntilChanged` operator)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当输入的新值与旧值不同时才查找建议（`DistinctUntilChanged`运算符）
- en: 'And, finally, looking up on a background thread using the schedulers task/thread
    pool and returning suggestions on the UI thread''s dispatcher. Take a look at
    the following code snippet:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，使用调度器的任务/线程池在后台线程上查找，并在UI线程的调度器上返回建议。请看以下代码片段：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This View Model clearly shows how Observables, LINQ (`Where` and `DistinctUntilChanged`),
    and Schedulers are put to good practical use. As highlighted in the preceding
    code, the lookup, which is done on a background thread, lets the observer, in
    this case, the data source, that is, the `BindingList<string>`, know through property
    change notifications; thereby, triggering automatic content refresh in the `Suggestions`
    list box. Another thing to note is the adept usage of the `SubscribeOn`/`ObserveOn`
    pair to prevent blocking of UI thread and yet update UI objects on it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图模型清楚地展示了如何将可观察的、LINQ（`Where`和`DistinctUntilChanged`）和调度器用于实际应用。正如前面的代码所强调的，在后台线程上进行的查找让观察者，在这种情况下，数据源，即`BindingList<string>`，通过属性更改通知知道；从而触发`Suggestions`列表框中的自动内容刷新。另一个需要注意的事情是`SubscribeOn`/`ObserveOn`对的熟练使用，以防止阻塞UI线程，同时在该线程上更新UI对象。
- en: 'There are some key things to notice here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关键点需要注意：
- en: The use of `Switch` operator, in addition to the `Where` and `DistinctUntilChanged`
    operators, to ensure the liveliness in search in terms of showing the latest and
    relevant changes with respect to the sequence
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Switch`运算符，除了`Where`和`DistinctUntilChanged`运算符外，以确保在显示与序列相关的最新和相关信息方面的搜索活力。
- en: This will also serve as an example of the **Collection Pipeline** pattern, where
    your computation becomes a sequence of operations by taking a collection/sequence
    from one operation and feeding to another
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这也将作为一个**收集管道**模式的例子，其中你的计算通过从一个操作中获取集合/序列并传递给另一个操作而成为一系列操作
- en: It leverages immutability, comprehensions (declarative query syntax in LINQ),
    laziness, and parallelism to achieve this.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它利用不可变性、列表解析（LINQ中的声明性查询语法）、惰性和并行性来实现这一点。
- en: 'The screenshot of our spell checker in action is shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了我们的拼写检查器正在工作的截图：
- en: '![MVVM on Rx](img/image_12_005.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![MVVM on Rx](img/image_12_005.jpg)'
- en: An asynchronous logger
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步日志记录器
- en: Logging and Audit trail is an important cross-cutting or horizontal concern
    in the day-to-day application that we create. There are various third-party tools
    that we leverage; and we have seen how to write one ourselves in depth in [Chapter
    3](dn-dsnptn_ch03.html "Chapter 3. A Logging Library"), *A Logging Library*. Here,
    we will see how to impart reactive behavior to a custom-logging component.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 日志和审计跟踪是我们日常创建的应用程序中的一个重要横切或横向关注点。我们利用了各种第三方工具；并且在[第3章](dn-dsnptn_ch03.html
    "第3章。日志库")“日志库”中深入探讨了如何自己编写一个。在这里，我们将看到如何赋予自定义日志组件反应性。
- en: We will use the same spell checker example in the preceding section and see
    how to integrate logging capability into the existing code base.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用前一个节中的相同拼写检查器示例，并查看如何将日志功能集成到现有的代码库中。
- en: 'We will start off by initializing the log collection as a `BindingList`, the
    same way we got the corrections/suggestions initialized:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先初始化日志收集为`BindingList`，就像我们初始化更正/建议的方式一样：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following `AddToLog` method will be the generic logging method used to
    hand off the log text to the observer waiting on the `_logchanged` subject. You
    can see instrumentation code throughout the methods, shown as follows, for applicability
    and clarity:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`AddToLog`方法将是通用的日志方法，用于将日志文本传递给等待在`_logchanged`主题上的观察者。您可以在方法中看到用于适用性和清晰性的仪器代码，如下所示：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following `DoLogging` method sets the observer, the `OnEachLog` method
    in our case, to listen for log text sequences/feeds from the observable `_logChanged`
    based on its `onNext` method invocations via the `AddToLog` method, thus, facilitating
    both publication and subscription using the `_logchanged` subject:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`DoLogging`方法设置观察者，在我们的案例中是`OnEachLog`方法，通过`AddToLog`方法的`onNext`方法调用从可观察的`_logChanged`监听日志文本序列/馈送，从而通过`_logchanged`主题促进发布和订阅：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This binding list is bound to the `Listbox` specifically used in this example
    to view the logs. This change''s property is further routed to the UI thread that
    senses the change in the bounded data source list in our case against the list
    box and forces a refresh. If you observe carefully, the logging feature is purely
    asynchronous and is handled by a background thread-a worker thread from thread
    pool in this case. Consider the following code snippet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此绑定列表绑定到本例中专门用于查看日志的`Listbox`。此更改的属性进一步路由到UI线程，该线程检测我们案例中绑定数据源列表（针对列表框）的变化，并强制刷新。如果您仔细观察，日志功能完全是异步的，并由后台线程处理——在本例中是线程池中的工作线程。考虑以下代码片段：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The logs can be further persisted using the store, such as file, database,
    and so on, of your choice. You can also use this to clearly understand the data
    flow from an observer and subscriber standpoint. The modified application will
    look like the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用存储，例如文件、数据库等，进一步持久化日志。您也可以使用此方法清楚地了解从观察者和订阅者角度的数据流。修改后的应用程序将如下所示：
- en: '![An asynchronous logger](img/image_12_006.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![异步日志记录器](img/image_12_006.jpg)'
- en: Near real-time visualizer/dashboard
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几乎实时可视化器/仪表板
- en: 'Dashboards are natural candidates for viewing real-time, or near real-time,
    data. Reactive constructs can be very effectively utilized in realizing utility
    dashboards from a reporting standpoint. Let''s look at an interesting scenario
    where election poll results are viewed on a real-time basis as and when the poll
    feeds come in from different states. Again, this has no resemblance to the actual
    polling process, but just conceptualized here in a fictitious manner that will
    enable learning and throw light on various interesting possibilities of leveraging
    reactive programming for such a reporting application. Consider the following
    code snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板是查看实时或接近实时数据的自然候选者。反应式结构可以非常有效地用于从报告的角度实现实用仪表板。让我们看看一个有趣的场景，即选举投票结果在实时基础上，随着来自不同州的投票馈送的到来而查看。这再次与实际的投票过程没有任何相似之处，但在这里以虚构的方式概念化，这将使学习并阐明利用反应式编程为这种报告应用程序的各种有趣可能性。考虑以下代码片段：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is the first stage in the prototype where we start building the simulation
    model for data sequences/streams, in our case, votes from multiple states. Here,
    we are initializing a certain number of votes per state. The `Take` query operator
    is utilized here, in case you noticed:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是原型的第一阶段，我们开始构建数据序列/流（在我们的案例中是来自多个州的投票）的模拟模型。在这里，我们为每个州初始化一定数量的投票。如果您注意到了，这里使用了`Take`查询运算符：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is the next stage in the prototype, where we will filter democratic and
    republican votes from the simulation model''s stream source, which is generated
    in the preceding code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是原型的下一阶段，我们将从模拟模型的流源中过滤民主党和共和党的投票，该流源在前面代码中生成：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we will initialize and create the data series for the X and Y axis needed
    by the chart component. This way the series are bound to the charting component:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将初始化和创建图表组件所需的X轴和Y轴的数据系列。这样，系列就绑定到图表组件：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is the stage where we kick-start simulation, that is, a generation of
    votes specified per state:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是启动模拟的阶段，即根据每个州生成指定的投票：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following two helper methods, `GetDemocraticVotes` and `GetRepublicanVotes`,
    used as a part of kick-starting simulation ensure that the observers (the following
    lambda function in this case) are bound and listening for changes as and when
    the votes start streaming in. The filtered votes are channeled to these respective
    helper methods and will continuously increment the respective vote counters on
    a near real-time basis:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个辅助方法，`GetDemocraticVotes` 和 `GetRepublicanVotes`，作为启动模拟的一部分，确保观察者（在这种情况下是下面的
    lambda 函数）被绑定并监听投票开始流入时的变化。过滤后的投票被引导到这些相应的辅助方法，并将持续在近乎实时的基础上增加相应的投票计数器：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following `GenerateVotes` method is the real vote generator (infinite,
    as you see) limited by the number specified using the Take operator, as indicated
    in the preceding code. This uses the generator function `CauchyDistribution` internally
    to generate the votes randomly and non-uniformly:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `GenerateVotes` 方法是真正的投票生成器（无限，正如你所见），通过使用 Take 操作符指定的数字进行限制，正如前面代码所示。这个方法内部使用生成函数
    `CauchyDistribution` 来随机且非均匀地生成投票：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This timer control helps in refreshing the chart control, which is based on
    the preset frequency, with values indicating votes scored by the two parties in
    the various states under consideration. Now, one important thing that you need
    to understand here is that as and when you traverse layers of subscribers and
    observers, you tend to introduce latency, again, based on the kind of schedulers
    you employ for concurrency, which makes the final output near real-time as opposed
    to real time not to introduce any interpretable subjectivity here. One should
    strive to reduce these layers and choose the right schedulers through multiple
    trials and calibrations to minimize these latencies and meet the required SLAs.
    Consider the following code snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计时器控制有助于根据预设频率刷新图表控制，其值表示在考虑的各种状态下两个党派的得票数。现在，你需要理解的一个重要问题是，当你遍历订阅者和观察者的层级时，你倾向于引入延迟，这再次基于你为并发所采用的调度器类型，这使得最终输出接近实时，而不是实时，以避免引入任何可解释的主观性。应该努力减少这些层级，并通过多次试验和校准来选择正确的调度器，以最小化这些延迟并满足所需的
    SLA。考虑以下代码片段：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As can you see, the program is divided into multiple stages, which are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，程序被分为多个阶段，具体如下：
- en: '**Stage1**: A simulation model building block'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段1**：模拟模型构建块'
- en: '**Stage2**: Filtering votes based on `Party`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段2**：基于 `Party` 过滤投票'
- en: '**Stage3**: Publish to subscribers'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段3**：发布给订阅者'
- en: '**Stage4**: Dashboard renderer'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段4**：仪表板渲染器'
- en: 'The near real-time dashboard will look like the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 近乎实时的仪表板将如下所示：
- en: '![Near real-time visualizer/dashboard](img/image_12_007.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![近乎实时的可视化器/仪表板](img/image_12_007.jpg)'
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As you saw, we have gone through some interesting and pragmatic examples that
    illustrate the applicability of reactive programming principles. The idea is to
    make you aware of the possibilities and warm you up for some serious programming
    tasks ahead. We believe you are in a position to appreciate this paradigm now,
    and possibly able to relate to it as a natural way of expressing solution models
    in a declarative manner, which involved a lot of plumbing code earlier. The power
    of composability that you get in this model is quite evident. Now, in the next
    chapter, we will go on to explore RxJS, the reactive programming JavaScript library
    that helps you brace for web programming.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们经历了一些有趣且实用的例子，这些例子说明了响应式编程原则的应用。目的是让你了解可能性，并为接下来的严肃编程任务做好准备。我们相信你现在能够欣赏这种范式，并且可能能够将其视为以声明方式表达解决方案模型的自然方式，这在以前需要大量的管道代码。在这个模型中，你获得的可组合性力量是非常明显的。现在，在下一章中，我们将继续探索
    RxJS，这是一个响应式编程 JavaScript 库，它帮助你为网络编程做好准备。
