- en: 3D Animation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D 动画
- en: 'In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Configuring a character's Avatar and idle animation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置角色的 Avatar 和空闲动画
- en: Moving your character with root motion and Blend Trees
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用根运动和混合树移动你的角色
- en: Mixing animations with Layers and Masks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用层和遮罩混合动画
- en: Organizing States into Sub-State Machines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将状态组织到子状态机中
- en: Transforming the Character Controller via script
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过脚本转换角色控制器
- en: Adding rigid props to animated characters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向动画角色添加刚体道具
- en: Using Animation Events to throw an object
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动画事件抛出对象
- en: Applying Ragdoll physics to a character
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将布娃娃物理应用到角色上
- en: Rotating the character's torso to aim a weapon
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将角色的身体旋转以瞄准武器
- en: Creating geometry with Probuilder
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Probuilder 创建几何体
- en: Creating a game with the 3D Gamekit
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 3D Gamekit 创建游戏
- en: Importing third-party 3D models and animations from Mixamo
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Mixamo 导入第三方 3D 模型和动画
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The **Mecanim** animation system has revolutionized how characters are animated
    and controlled within Unity. In this chapter, we will learn how to take advantage
    of its flexibility, power, and friendly and highly visual interface.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mecanim** 动画系统彻底改变了在 Unity 中对角色进行动画和控制的模式。在本章中，我们将学习如何利用其灵活性、强大功能和友好且高度可视化的界面。'
- en: The big picture
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整体情况
- en: 'Controlling a playable character with the **Mecanim** system might look like
    a complex task, but it is actually very straightforward:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **Mecanim** 系统控制可玩角色可能看起来是一个复杂任务，但实际上非常直接：
- en: '![](img/34f06f4e-109a-415a-8a94-972a3bbab6ea.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34f06f4e-109a-415a-8a94-972a3bbab6ea.png)'
- en: By the end of the chapter, you will have gained a basic understanding of the
    Mecanim system. For a more complete overview of the subject, consider taking a
    look at Jamie Dean's *Unity Character Animation with Mecanim*, also published
    by Packt Publishing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将获得对 Mecanim 系统的基本理解。为了更全面地了解这个主题，可以考虑阅读 Jamie Dean 的 *Unity Character
    Animation with Mecanim*，由 Packt Publishing 出版。
- en: 'All the recipes will make use of Mixamo motion packs. Mixamo is a complete
    solution for character production, rigging, and animation. In fact, the character
    used was designed with Mixamo''s character creation software called Fuse and rigged
    with the Mixamo Auto-Rigger. You can find out more about Mixamo and their products
    at Unity''s Asset Store or the Mixamo website:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有食谱都将使用 Mixamo 动作包。Mixamo 是一个完整的角色制作、绑定和动画解决方案。实际上，所使用的角色是用 Mixamo 的角色创建软件
    Fuse 设计的，并使用 Mixamo Auto-Rigger 进行绑定。你可以在 Unity 的 Asset Store 或 Mixamo 网站上了解更多关于
    Mixamo 和他们的产品：
- en: '[https://assetstore.unity.com/packages/3d/animations/melee-axe-pack-35320](https://assetstore.unity.com/packages/3d/animations/melee-axe-pack-35320)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://assetstore.unity.com/packages/3d/animations/melee-axe-pack-35320](https://assetstore.unity.com/packages/3d/animations/melee-axe-pack-35320)'
- en: '[https://www.mixamo.com/](https://www.mixamo.com/)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.mixamo.com/](https://www.mixamo.com/)'
- en: Please note that although Mixamo offers **Mecanim**-ready characters and animation
    clips, for the recipes in this chapter, we will use unprepared animation clips.
    The reason for this is to make you more confident when dealing with assets obtained
    by other methods and sources.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管 Mixamo 提供了 **Mecanim**-兼容的角色和动画剪辑，但对于本章中的食谱，我们将使用未准备好的动画剪辑。这样做的原因是为了让你在处理通过其他方法和来源获得的资产时更有信心。
- en: Configuring a character's Avatar and idle animation
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置角色的 Avatar 和空闲动画
- en: One feature that makes **Mecanim** so flexible and powerful is the ability to
    quickly reassign Animation Clips from one character to another. This is made possible
    through the use of **Avatars**, which are basically a layer between your character's
    original rig and Unity's **Animator** system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使 **Mecanim** 非常灵活和强大的一个特性是能够快速将动画剪辑从一个角色重新分配到另一个角色。这是通过使用 **Avatar** 实现的，它基本上是在你的角色的原始绑定和
    Unity 的 **Animator** 系统之间的一层。
- en: In this recipe, we will learn how to configure an **Avatar** skeleton on a rigged
    character.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何在绑定的角色上配置 **Avatar** 骨架。
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need the MsLaser@T-Pose.fbx and Swat@rifle_aiming_idle.fbx
    files, which are provided in the `09_03` folder.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，你需要 MsLaser@T-Pose.fbx 和 Swat@rifle_aiming_idle.fbx 文件，这些文件位于 `09_03`
    文件夹中。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To configure an Avatar skeleton, follow these steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置一个 Avatar 骨架，请按照以下步骤操作：
- en: Import the MsLaser@T-Pose.fbx and Swat@rifle_aiming_idle.fbx files into your
    project.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 MsLaser@T-Pose.fbx 和 Swat@rifle_aiming_idle.fbx 文件导入到你的项目中。
- en: Select the MsLaser@T-Pose model from the Project panel.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目面板中选择 MsLaser@T-Pose 模型。
- en: 'In the Inspector, under MsLaser@T-Pose Import Settings, activate the Rig section.
    Change Animation Type to Humanoid. Then, leave Avatar Definition as Create From
    this Model. Now, click Apply to apply these settings. Finally, click on the Configure...
    button:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，在 MsLaser@T-Pose 导入设置下，激活“机械臂”部分。将动画类型更改为“类人”。然后，将“头像定义”保留为“从该模型创建”。现在，点击“应用”以应用这些设置。最后，点击“配置...”按钮：
- en: '![](img/87582a63-d224-4996-92ad-46f949695cdb.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87582a63-d224-4996-92ad-46f949695cdb.png)'
- en: 'The Inspector will show the newly created **Avatar**. Observe how Unity correctly
    mapped the bones of our character to its structure, assigning, for instance, the
    mixamoRig:LeftForeArm bone as the Avatar''s Lower Arm. We could, of course, reassign
    bones if needed. For now, just click on the Done button to close the view:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查器将显示新创建的**头像**。观察 Unity 如何正确地将我们角色的骨骼映射到其结构中，例如，将 mixamoRig:LeftForeArm 骨分配为头像的下臂。当然，如果需要，我们可以重新分配骨骼。现在，只需点击“完成”按钮来关闭视图：
- en: '![](img/bd882499-ea2a-46e9-95a9-8669556fc202.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd882499-ea2a-46e9-95a9-8669556fc202.png)'
- en: Now that we have our **Avatar** ready, let's configure our animation for the
    Idle state. From the Project panel, select the Swat@rifle_aiming_idle file.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了**头像**，让我们为空闲状态配置动画。从项目面板中选择 Swat@rifle_aiming_idle 文件。
- en: Select the Rig section, change Animation Type to Humanoid, and leave Avatar
    Definition as Create From this Model. Confirm by clicking on Apply.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“机械臂”部分，将动画类型更改为“类人”，并将“头像定义”保留为“从该模型创建”。通过点击“应用”来确认。
- en: 'Select the Animations section (to the right of the Rig). The rifle_aiming_idle
    clip should be selected. Drag MsLaser@T-Pose to the Preview area at the bottom
    of the **Inspector**:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“动画”部分（位于“机械臂”右侧）。应选择 rifle_aiming_idle 剪辑。将 MsLaser@T-Pose 拖动到检查器底部的预览区域：
- en: '![](img/3a193af9-5bb5-4d3b-a0db-f27766a6f40a.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a193af9-5bb5-4d3b-a0db-f27766a6f40a.png)'
- en: 'With rifle_aiming_idle selected from the Clips list, check the Loop Time and
    Loop Pose options. Also, click on the Clamp Range button to adjust the timeline
    to the actual time of the **Animation Clip**. Then, under Root Transform Rotation,
    check Bake Into Pose and select Based Upon | Original. Under Root Transform Position
    (Y), check Bake Into Pose and select Based upon Original. Under Root Transform
    Position (XZ), leave Bake Into Pose unchecked and select Based Upon (at Start)
    | Center of Mass. Finally, click on Apply to confirm the changes:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在剪辑列表中选择 rifle_aiming_idle，检查“循环时间”和“循环姿态”选项。然后，点击“限制范围”按钮以调整时间轴到**动画剪辑**的实际时间。接着，在“根变换旋转”下，检查“烘焙到姿态”并选择“基于
    | 原始”。在“根变换位置（Y）”下，检查“烘焙到姿态”并选择“基于原始”。在“根变换位置（XZ）”下，不检查“烘焙到姿态”并选择“基于（在开始时） | 重心”。最后，点击“应用”以确认更改：
- en: '![](img/bcae7636-51cf-4628-a618-905a08048cff.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bcae7636-51cf-4628-a618-905a08048cff.png)'
- en: 'In order to access **Animation Clips** and play them, we need to create a Controller.
    Do this by choosing Project panel menu: Create | Animator Controller. Name it
    MainCharacter.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了访问**动画剪辑**并播放它们，我们需要创建一个控制器。通过选择项目面板菜单：创建 | 动画控制器。将其命名为 MainCharacter。
- en: Double-click on the Animator Controller to open the **Animator** panel.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击“动画控制器”以打开“**动画器**”面板。
- en: 'From the **Animator** panel, right-click on the grid to open a context menu.
    Then, select the Create State | Empty option. A new box named New State will appear.
    It will be in orange, indicating that it is the default state:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画器**面板中，右键单击网格以打开上下文菜单。然后，选择“创建状态 | 空白”选项。将出现一个名为“新状态”的新框，它将呈橙色，表示它是默认状态：
- en: '![](img/b5d8d019-5a2f-466b-ba7e-d62e86df030f.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b5d8d019-5a2f-466b-ba7e-d62e86df030f.png)'
- en: 'Select New State and, in the Inspector, change its name to Idle. Also, in the
    Motion field, choose rifle_aiming_idle by either selecting it from the list or
    dragging it from the Project panel:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“新状态”，在检查器中将其名称更改为“空闲”。此外，在“动作”字段中，通过从列表中选择或从项目面板拖动来选择 rifle_aiming_idle：
- en: '![](img/ed89f835-c4a4-4670-b3f3-881e6eee7baf.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed89f835-c4a4-4670-b3f3-881e6eee7baf.png)'
- en: Drag the MsLaser@T-Pose model from the Project panel into the Hierarchy and
    place it in the Scene.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 MsLaser@T-Pose 模型从项目面板拖动到层次结构中，并将其放置在场景中。
- en: 'Select MsLaser@T-Pose from the Hierarchy and observe its **Animator** component
    in the Inspector. Then, assign the newly created MainCharacter controller to its
    Controller field:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从层次结构中选择 MsLaser@T-Pose 并观察检查器中的**动画器**组件。然后，将新创建的 MainCharacter 控制器分配到其控制器字段：
- en: '![](img/8e06a3e2-4293-4a2f-b575-47216ae51927.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e06a3e2-4293-4a2f-b575-47216ae51927.png)'
- en: Play your **Scene** to see the character correctly animated.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放您的**场景**以查看角色是否正确动画化。
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Preparing our character for animation took many steps. First, we created its
    Avatar, based on the character model's original bone structure. Then, we set up
    the **Animation Clip** (which, as the character mesh, is stored in an .fbx file),
    using its own Avatar.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为动画准备我们的角色需要许多步骤。首先，我们根据角色模型的原始骨骼结构创建了其Avatar。然后，我们使用其自己的Avatar设置了**动画片段**（与角色网格一样，存储在.fbx文件中）。
- en: After this, we adjusted the Animation Clip, clamping its size and making it
    a loop. We also baked its Root Transform Rotation to follow the original file's
    orientation. Finally, an Animator Controller was created, and the edited **Animation
    Clip** was made into its default Animation State.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们调整了动画片段，限制了其大小并使其循环。我们还烘焙了其根变换旋转以跟随原始文件的朝向。最后，创建了一个动画控制器，并将编辑后的**动画片段**设置为默认动画状态。
- en: The concept of the Avatar is what makes Mecanim so flexible. Once you have an
    **Animator Controller**, you can apply it to other humanoid characters, as long
    as they have an Avatar body mask.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Avatar的概念使得Mecanim非常灵活。一旦你有了**动画控制器**，你就可以将其应用于其他具有Avatar身体蒙版的类人角色。
- en: There's more...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here are some ways to go further with this recipe.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些方法可以进一步扩展这个配方。
- en: Use Controller with another 3D character Avatar
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用控制器与另一个3D角色Avatar
- en: 'Let''s swap MsLaser for a Mascot 3D character. Do the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用Mascot 3D角色替换MsLaser。执行以下操作：
- en: Import the provided model, mascot.fbx.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的模型，mascot.fbx。
- en: The apply steps 3 and 4 for this character to create its Avatar.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此角色应用步骤3和4以创建其Avatar。
- en: Drag an instance of the model into the **Scene**.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模型实例拖入**场景**中。
- en: In the Inspector for its Animator Component, set the Controller to the MainCharacter
    Animator Controller you created in this recipe.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其动画组件的检查器中，将控制器设置为你在本配方中创建的MainCharacter Animator Controller。
- en: Run the Scene; you should see the mascot playing the rifle_aiming_idle animation
    clip.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景；你应该看到吉祥物正在播放rifle_aiming_idle动画片段。
- en: See also
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: To read more information about the Animator Controller, check out Unity's documentation
    at [http://docs.unity3d.com/Manual/class-AnimatorController.html](http://docs.unity3d.com/Manual/class-AnimatorController.html).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于动画控制器（Animator Controller）的信息，请查看Unity的文档：[http://docs.unity3d.com/Manual/class-AnimatorController.html](http://docs.unity3d.com/Manual/class-AnimatorController.html)。
- en: Moving your character with root motion and Blend Trees
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用根运动和混合树（Blend Trees）移动你的角色
- en: The Mecanim animation system is capable of applying Root Motion to characters.
    In other words, it actually moves the character according to the animation clip,
    as opposed to arbitrarily translating the character model while playing an in-place
    animation cycle. This makes most of the Mixamo animation clips perfect for use
    with Mecanim.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Mecanim动画系统能够将根运动（Root Motion）应用于角色。换句话说，它实际上根据动画片段移动角色，而不是在播放原地动画循环时任意平移角色模型。这使得Mixamo的大多数动画片段非常适合与Mecanim一起使用。
- en: Another feature of the animation system is Blend Trees, which can blend Animation
    Clips smoothly and easily. In this recipe, we will take advantage of these features
    to make our character walk/run forward and backward, and also strafe right and
    left at different speeds.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 动画系统的另一个特性是混合树，它可以平滑且容易地混合动画片段。在这个配方中，我们将利用这些特性使我们的角色能够向前和向后行走/奔跑，以及在不同速度下向右和向左横移。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared a Unity package named Character_02, containing
    a character and featuring a basic **Animator Controller**. The package can be
    found inside the `09_02` folder, along with the FBX files for the animation clips
    you need.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们准备了一个名为Character_02的Unity包，其中包含一个角色和一个基本的**动画控制器**。该包位于`09_02`文件夹中，同时包含了所需动画片段的FBX文件。
- en: There are two ways to import animations in Unity. One approach involves having
    each animation as a separate file, named in the form `modelName@animation`, such
    as `MsLazer@idle`, `MsLazer@jumping`, and so on. The other approach is when a
    model has several animations all in a single take, in which case you can break
    the take into separate named animation clips in the Unity editor, specifying the
    start and end frame for each clip. In this chapter, we'll use the first approach,
    since it's more straightforward. Learn more from the Unity documentation at [https://docs.unity3d.com/Manual/Splittinganimations.html](https://docs.unity3d.com/Manual/Splittinganimations.html).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中导入动画有两种方法。一种方法是将每个动画作为一个单独的文件导入，文件名采用`modelName@animation`的形式，例如`MsLazer@idle`、`MsLazer@jumping`等。另一种方法是一个模型包含多个动画，所有动画都在一个动作中，在这种情况下，您可以在Unity编辑器中将动作分解成单独的命名动画剪辑，为每个剪辑指定起始和结束帧。在本章中，我们将使用第一种方法，因为它更直接。更多内容请参阅Unity文档[https://docs.unity3d.com/Manual/Splittinganimations.html](https://docs.unity3d.com/Manual/Splittinganimations.html)。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To apply Root Motion to your character using Blend Trees, follow these steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Blend Trees将根运动应用到角色上，请按照以下步骤操作：
- en: 'Import Character_02.unityPackage into a new project. Also, import the following
    FBX files:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Character_02.unityPackage导入到新项目中。同时，导入以下FBX文件：
- en: Swat@rifle_run
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swat@rifle_run
- en: Swat@run_backward
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swat@run_backward
- en: Swat@strafe
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swat@strafe
- en: Swat@strafe_2
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swat@strafe_2
- en: Swat@strafe_left
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swat@strafe_left
- en: Swat@strafe_right
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swat@strafe_right
- en: Swat@walking
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swat@walking
- en: Swat@walking_backward
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swat@walking_backward
- en: We need to configure our Animation Clips. From the Project panel, select Swat@rifle_run.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要配置我们的动画剪辑。从项目面板中选择Swat@rifle_run。
- en: 'Activate the Rig section. Change Animation Type to Humanoid and Avatar Definition
    to Create From this Model. Confirm by clicking on Apply:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活“机械”部分。将动画类型更改为“人类”并将“头像定义”更改为“从该模型创建”。通过点击“应用”进行确认：
- en: '![](img/488103ca-0a42-4c68-bce1-3285395ed716.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/488103ca-0a42-4c68-bce1-3285395ed716.png)'
- en: Now, activate the Animations section (to the right of Rig). Clip rifle_run should
    be selected. The Preview area (at the bottom of the **Inspector**) will display
    the message No model is available for preview. Drag MsLaser@T-Pose onto the Preview
    area.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，激活“动画”部分（位于“机械”右侧）。选择“clip_rifle_run”。在**检查器**底部的预览区域将显示消息“没有模型可供预览”。将MsLaser@T-Pose拖动到预览区域。
- en: 'With asset Swat@rifle_run still selected in the Project panel, in the **Inspector**
    check the Loop Time and Loop Pose options. Also, click on the Clamp Range button
    to adjust the timeline to the actual time of the animation clip. Click on Apply
    to confirm these changes:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中仍然选择Swat@rifle_run资产，在**检查器**中勾选Loop Time和Loop Pose选项。然后，点击“限制范围”按钮调整时间轴到动画剪辑的实际时间。点击“应用”以确认这些更改：
- en: '![](img/c27e89d8-2cbf-401a-9dbf-4d61af337893.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c27e89d8-2cbf-401a-9dbf-4d61af337893.png)'
- en: 'Then, under Root Transform Rotation, check Bake Into Pose and select Based
    Upon | Original. Under Root Transform Position (Y), check Bake Into Pose and select
    Based Upon (at Start) | Original. Under Root Transform Position (XZ), leave Bake
    Into Pose unchecked and select Based Upon (at Start) | Center of Mass. Finally,
    click on Apply to confirm the changes:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在“根变换旋转”下，勾选“烘焙到姿态”并选择“基于 | 原始”。在“根变换位置（Y）”下，勾选“烘焙到姿态”并选择“基于（在开始时） | 原始”。在“根变换位置（XZ）”下，不勾选“烘焙到姿态”并选择“基于（在开始时）
    | 重心”。最后，点击“应用”以确认更改：
- en: '![](img/8ace8f4c-4f86-46e2-9add-64cda34e9120.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ace8f4c-4f86-46e2-9add-64cda34e9120.png)'
- en: 'Repeat steps 3 to 6 for each one of the following animation clips: Swat@run_backward,
    Swat@strafe, Swat@strafe_2, Swat@strafe_left, Swat@strafe_right, Swat@walking,
    and Swat@walking_backward.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对以下每个动画剪辑重复步骤3到6：Swat@run_backward、Swat@strafe、Swat@strafe_2、Swat@strafe_left、Swat@strafe_right、Swat@walking和Swat@walking_backward。
- en: 'Add a 3D Plane to the **Scene**, choose menu: Create | 3D Object | Plane.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景**中添加一个3D平面，选择菜单：创建 | 3D对象 | 平面。
- en: Drag an instance of the MsLaser prefab into the **Scene** and position it on
    the 3D Plane.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将MsLaser预制体的实例拖动到**场景**中，并将其放置在3D平面上。
- en: 'From the Hierarchy panel, select the MsLaser GameObject. In the **Inspector**,
    add a Character Controller component to it (click Add Component and choose Component
    | Physics | Character Controller). Then, set its Skin Width to 0.0001 and its
    Center as (0, 0.9, 0); also, change its Radius to 0.34 and its Height to 1.79:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从层次结构面板中选择MsLaser GameObject。在**检查器**中，向其添加一个Character Controller组件（点击添加组件并选择组件
    | 物理 | Character Controller）。然后，将其Skin Width设置为0.0001，将其Center设置为（0，0.9，0）；也将其Radius设置为0.34，将其Height设置为1.79：
- en: '![](img/1a6ab6f6-580e-4e68-8958-da19d36f1304.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a6ab6f6-580e-4e68-8958-da19d36f1304.png)'
- en: In the Project panel, double-click the MainCharacter controller asset file;
    it should open in the **Animator** panel.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，双击MainCharacter控制器资产文件；它应该在**动画器**面板中打开。
- en: 'In the top-left corner of the **Animator** panel, select the Parameters section
    and use the + sign to create three new Parameters (Float) named xSpeed, zSpeed,
    and Speed:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画器**面板的右上角，选择参数部分，并使用加号创建三个新的参数（浮点数）命名为xSpeed、zSpeed和Speed：
- en: '![](img/3a925c86-f9db-4cf0-9aef-ee082e67a429.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a925c86-f9db-4cf0-9aef-ee082e67a429.png)'
- en: 'We do have an Idle state for our character, but we need new ones. Right-click
    on the grid area and, from the context menu, navigate to Create State | From New
    Blend Tree. In the **Inspector**, change its name from the Default Blend Tree
    to Move:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们确实为我们的角色有一个空闲状态，但我们还需要新的状态。右键单击网格区域，从上下文菜单中导航到创建状态 | 从新混合树。在**检查器**中，将名称从默认混合树更改为移动：
- en: '![](img/cd6c1355-cc9f-4db0-9de3-b7abe36e0b27.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd6c1355-cc9f-4db0-9de3-b7abe36e0b27.png)'
- en: 'Double-click on the Move state. You will see the empty blend tree that you
    have created. Select it and in the **Inspector**, rename it Move. Then, change
    its Blend Type to 2D Freeform Directional, also setting xSpeed and zSpeed in the
    Parameters tab. Finally, using the + sign from the bottom of the Motion list,
    add nine new Motion Fields:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击移动状态。您将看到您创建的空混合树。选择它，在**检查器**中将其重命名为移动。然后，将其混合类型更改为2D自由形式方向，也在参数选项卡中设置xSpeed和zSpeed。最后，使用运动列表底部的加号，添加九个新的运动字段：
- en: '![](img/cbbc374c-8258-446b-9403-c95be58d4d9f.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cbbc374c-8258-446b-9403-c95be58d4d9f.png)'
- en: 'Now, populate the Motion list with the following motion clips and respective
    Pos X and Pos Y values: Run_backwards, 0, -1; Walking_backwards, 0,-0.5; Rifle_aiming_idle,
    0, 0; Walking, 0, 0.5; Rifle_run, 0, 1; Strafe, -1, 0; Strafe_left, -0.5, 0; Strafe_right,
    0.5, 0; Strafe_2, 1, 0\. You can populate the Motion list by selecting it from
    the list or, if there is more than one clip with the same name, you can drag it
    from the Project panel onto the slot by expanding the appropriate model icon:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下动作剪辑和相应的Pos X和Pos Y值填充运动列表：Run_backwards, 0, -1；Walking_backwards, 0,-0.5；Rifle_aiming_idle,
    0, 0；Walking, 0, 0.5；Rifle_run, 0, 1；Strafe, -1, 0；Strafe_left, -0.5, 0；Strafe_right,
    0.5, 0；Strafe_2, 1, 0。您可以通过从列表中选择它来填充运动列表，或者如果有多个具有相同名称的剪辑，您可以通过展开相应的模型图标，将其从项目面板拖动到槽中：
- en: '![](img/5dbc5888-9733-4f2a-9468-3fe3fb2b7a9f.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5dbc5888-9733-4f2a-9468-3fe3fb2b7a9f.png)'
- en: 'To return to the Base Layer, either double-click on the grid background of
    the **Animator** panel, or click the Base Layer button in the information bar
    along the top of the **Animator** panel:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要返回到基础层，要么双击**动画器**面板的网格背景，要么单击面板顶部的信息栏中的基础层按钮：
- en: '![](img/186b5ece-e528-41b5-a05b-fbd2765ee2ac.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/186b5ece-e528-41b5-a05b-fbd2765ee2ac.png)'
- en: Since we have the rifle_aiming_idle Motion clip in our Move blend tree, we can
    get rid of the original Idle state. Right-click on the Idle state box and, from
    the menu, select Delete. The Move blend state will become the new default state,
    turning orange.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在移动混合树中有rifle_aiming_idle动作剪辑，我们可以删除原始的空闲状态。右键单击空闲状态框，从菜单中选择删除。移动混合状态将变为新的默认状态，变为橙色。
- en: 'Now, we must create the script-class that will actually transform the player''s
    input into those variables that are created to control the animation. Create a
    new C# script-class named BasicController, and add an instance-object as a component
    of the MsLazer GameObject:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须创建一个脚本类，它将实际将玩家的输入转换为创建来控制动画的变量。创建一个新的C#脚本类名为BasicController，并将实例对象作为MsLazer游戏对象的组件添加：
- en: '[PRE0]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Play your **Scene** and test the game. You should be able to control your character
    with the arrow keys (or *WASD* keys). Keeping the *Shift* key pressed will slow
    it down.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放您的**场景**并测试游戏。您应该能够使用箭头键（或*WASD*键）控制您的角色。按住*Shift*键会减慢速度。
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Whenever the BasicController script detects any directional keys in use, it
    sets the Speed variable of the Animator state to a value higher than 0, changing
    the Animator state from Idle to Move. The Move state, in turn, blends the motion
    clips that it was populated with, according to the input values for xSpeed (obtained
    from Horizontal Axis input, typically the *A* and *D* keys) and zSpeed (obtained
    from Vertical Axis input, typically the *W* and *S* keys). Since **Mecanim** is
    capable of applying root motion to the characters, our character will actually
    move in the resulting direction.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当基本控制器（BasicController）脚本检测到任何方向键被使用时，它会将动画器状态（Animator state）的Speed变量设置为大于0的值，将动画器状态从Idle变为Move。Move状态反过来会根据xSpeed（从水平轴输入获得，通常是*A*和*D*键）和zSpeed（从垂直轴输入获得，通常是*W*和*S*键）的输入值混合它所填充的运动剪辑。由于**Mecanim**能够将根运动应用于角色，我们的角色实际上会沿着结果方向移动。
- en: 'For instance, if the *W* and *D* keys are pressed, the xSpeed and zSpeed values
    will rise to 1.0\. From the **Inspector**, it is possible to see that such a combination
    will result in a blend between the motion clips called rifle_run and strafe_2,
    making the character run diagonally (to the front and right):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果按下*W*和*D*键，xSpeed和zSpeed的值将上升到1.0。从**检查器**中可以看到，这种组合将导致名为rifle_run和strafe_2的运动剪辑之间的混合，使角色以对角线方向（向前和向右）奔跑：
- en: '![](img/ed26ed0d-90e1-4ac6-8eeb-82a2367f27ab.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed26ed0d-90e1-4ac6-8eeb-82a2367f27ab.png)'
- en: 'Our BasicController includes three checkboxes for more options: Move Diagonally,
    which is set as true by default and allows for blends between forward/backward
    and left/right clips; Mouse Rotate, which is set as true by default and allows
    for rotating the character with the mouse, changing their direction while moving;
    and Keyboard Rotate, which is set as false by default and allows for rotating
    the character through simultaneous use of the left/right and forward/backward
    directional keys.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本控制器（BasicController）包括三个复选框以提供更多选项：对角移动（Move Diagonally），默认设置为true，允许在前后和左右剪辑之间混合；鼠标旋转（Mouse
    Rotate），默认设置为true，允许使用鼠标旋转角色，在移动时改变其方向；以及键盘旋转（Keyboard Rotate），默认设置为false，允许通过同时使用左右和前后方向键来旋转角色。
- en: There's more...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here are some sources of further information about these topics.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于这些主题的更多信息来源。
- en: Our blend tree used the 2D Freeform Directional Blend Type. However, if we only had four
    Animation Clips (forward, backward, left, and right), 2D Simple Directional would
    have been a better option.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的混合树使用了2D自由形式方向混合类型。然而，如果我们只有四个动画剪辑（前进、后退、左转和右转），2D简单方向混合将是一个更好的选择。
- en: 'Learn more about Blend Trees and 2D blending from Unity''s Documentation:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从Unity的文档中了解更多关于混合树和2D混合的信息：
- en: '[http://docs.unity3d.com/Manual/BlendTree-2DBlending.html](http://docs.unity3d.com/Manual/BlendTree-2DBlending.html)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Unity3D官方文档](http://docs.unity3d.com/Manual/BlendTree-2DBlending.html)'
- en: 'Also, if you want to learn more about the **Mecanim** Animation System, there
    are some links that you might want to check out, such as Unity''s documentation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您想了解更多关于**Mecanim**动画系统的信息，有一些链接您可能想查看，例如Unity的文档：
- en: '[http://docs.unity3d.com/Manual/AnimationOverview.html](http://docs.unity3d.com/Manual/AnimationOverview.html)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Unity3D官方文档](http://docs.unity3d.com/Manual/AnimationOverview.html)'
- en: '**Mecanim** Example Scenes are available from the Unity **Asset Store**:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mecanim**示例场景可以从Unity **资源商店**获取：'
- en: '[https://www.assetstore.unity3d.com/en/#!/content/5328](https://www.assetstore.unity3d.com/en/#!/content/5328)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Unity3D资源商店](https://www.assetstore.unity3d.com/en/#!/content/5328)'
- en: '**Mecanim** Video Tutorial are available here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mecanim**视频教程在此处提供：'
- en: '[http://unity3d.com/pt/learn/tutorials/topics/animation](http://unity3d.com/pt/learn/tutorials/topics/animation)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Unity3D官方教程](http://unity3d.com/pt/learn/tutorials/topics/animation)'
- en: Mixing animations with Layers and Masks
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用层和遮罩混合动画
- en: Mixing animations is a great way of adding complexity to your animated characters
    without requiring a vast number of animated clips. Using Layers and Masks, we
    can combine different animations by playing specific clips for specific body parts
    of the character.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 混合动画是增加动画角色复杂性的好方法，而不需要大量动画剪辑。使用层和遮罩，我们可以通过播放角色的特定身体部分的特定剪辑来组合不同的动画。
- en: In this recipe, we will apply this technique to our animated character, triggering
    animation clips for firing a rifle and throwing a grenade with the character's
    upper body. We will do this while keeping the lower body moving or idle, according
    to the player's input.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将应用这项技术到我们的动画角色上，通过角色的上半身触发开枪和投掷手榴弹的动画片段。我们将根据玩家的输入，在保持下半身移动或空闲的同时完成这些操作。
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared a Unity Package named Mixing, containing a
    basic **Scene** that features an animated character. We have also provided the
    FBX animation clips Swat@firing_rifle.fbx and Swat@toss_grenade.fbx. These files
    can be found in the `09_03` folder.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们准备了一个名为Mixing的Unity包，其中包含一个具有动画角色的基本**场景**。我们还提供了FBX动画片段Swat@firing_rifle.fbx和Swat@toss_grenade.fbx。这些文件可以在`09_03`文件夹中找到。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To mix animations using layers and masks, follow these steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用层和遮罩混合动画，请按照以下步骤操作：
- en: Create a new 3D project and import the Mixing Unity Package, as well as the
    FBX files Swat@firing_rifle.fbx and Swat@toss_grenade.fbx.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的3D项目并导入Mixing Unity包，以及FBX文件Swat@firing_rifle.fbx和Swat@toss_grenade.fbx。
- en: Then, from the Project panel, open the mecanimPlayground level.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从项目面板中打开mechanimPlayground级别。
- en: We need to configure the **Animation Clips**. Select the Swat@firing_rifle asset in
    the Project panel.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要配置**动画片段**。在项目面板中选择Swat@firing_rifle资产。
- en: 'Select the Rig section. Change Animation Type to Humanoid, and Avatar Definition
    to Create From this Model. Confirm this by clicking on Apply:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**绑定**部分。将动画类型更改为Humanoid，并将头像定义更改为从此模型创建。通过点击**应用**确认这一更改：
- en: '![](img/52d3eac7-bc86-4f67-9bf6-76ab65010dcf.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52d3eac7-bc86-4f67-9bf6-76ab65010dcf.png)'
- en: 'Now, activate the **Animations** section. The `firing_rifle` clip should be
    selected; click on the **Clamp Range** button to adjust the timeline and check
    the **Loop Time** and **Loop Pose** options. Under **Root Transform Rotation**,
    check Bake Into Pose and select Based **Upon** | **Original**. Under **Root Transform
    Position** (**Y**), check **Bake Into Pose** and select **Based Upon** (at Start)
    | Original. Under **Root Transform Position** (**XZ**), leave **Bake** Into Pose
    unchecked. Click on **Apply** to confirm the changes:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，激活**动画**部分。选择`firing_rifle`片段；点击**限制范围**按钮调整时间轴并勾选**循环时间**和**循环姿态**选项。在**根变换旋转**下，勾选**烘焙到姿态**并选择**基于**
    | **原始**。在**根变换位置**（**Y**）下，勾选**烘焙到姿态**并选择**基于**（在开始时）| **原始**。在**根变换位置**（**XZ**）下，不勾选**烘焙到姿态**。点击**应用**以确认更改：
- en: '![](img/cce6703a-9c38-4747-98c5-dd67a9a68993.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cce6703a-9c38-4747-98c5-dd67a9a68993.png)'
- en: Select the `Swat@toss_grenade` animation clip. Select the Rig section. Then,
    change **Animation Type** to Humanoid and Avatar Definition to **Create From**
    this Model. Confirm it by clicking on Apply.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Swat@toss_grenade`动画片段。选择**绑定**部分。然后，将**动画类型**更改为Humanoid并将头像定义更改为**从**此模型创建。通过点击**应用**确认。
- en: Now, activate the **Animations** section. The `toss_grenade` animation clip
    should be selected. Click the Clamp Range button to adjust the timeline, and leave
    the **Loop Time** and **Loop Pose** options unchecked. Under Root **Transform
    Rotation****,** check **Bake** Into **Pose** and select **Based Upon** | **Original****.**
    Under **Root Transform Position** (**Y**), check **Bake** Into **Pose** and select
    Based Upon (at Start) | Original. Under Root Transform Position (XZ), leave Bake
    Into Pose unchecked. Click on Apply to confirm the changes.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，激活**动画**部分。选择`toss_grenade`动画片段。点击**限制范围**按钮调整时间轴，并取消选中**循环时间**和**循环姿态**选项。在**根变换旋转**下，勾选**烘焙到姿态**并选择**基于**
    | **原始**。在**根变换位置**（**Y**）下，勾选**烘焙到姿态**并选择**基于**（在开始时）| **原始**。在**根变换位置**（XZ）下，不勾选**烘焙到姿态**。点击**应用**以确认更改。
- en: Let's create a Mask. From the Project panel, click on the Create button and
    add an Avatar Mask to the project. Name it BodyMask.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个遮罩。从项目面板中，点击创建按钮并向项目添加一个Avatar Mask。将其命名为BodyMask。
- en: 'Select the **BodyMask** tab and, in the **Inspector,** expand the Humanoid
    section. Green body sections and IK spots are selected (all are by default), and
    red are unselected. Deselect the character''s two legs, the circle base the feet
    are standing on, and the two feet IK spots (they should turn red):'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**BodyMask**标签，并在**检查器**中展开Humanoid部分。绿色身体部分和IK点被选中（默认全部选中），红色未被选中。取消选中角色的两条腿、脚下的圆形底座以及两个脚的IK点（它们应该变成红色）：
- en: '![](img/30adaa9d-857e-4ea0-9d68-23a2da9ad5d8.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/30adaa9d-857e-4ea0-9d68-23a2da9ad5d8.png)'
- en: In the **Project** panel, double-click the `MainCharacter` controller asset
    file; it should open up in the Animator panel.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中，双击`MainCharacter`控制器资产文件；它应该在**动画器**面板中打开。
- en: In the Animator panel, create a new layer by clicking on the **+** sign in the
    top-left **Layers** tab, above the Base Layer.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画器**面板中，通过点击左上角的**层**标签中的**+**号创建一个新层，位于基础层之上。
- en: 'Name the new `layerUpperBody` and click on the gear icon for the settings.
    Then, change its **Weight** to 1 and select the **BodyMask** in the Mask slot.
    Also, change Blending to Additive:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新层命名为`layerUpperBody`并点击设置图标。然后，将其**权重**设置为1并在遮罩槽中选择**BodyMask**。同时，将混合模式更改为叠加：
- en: '![](img/ded015b1-998f-40a3-a9d6-857ff9a70480.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ded015b1-998f-40a3-a9d6-857ff9a70480.png)'
- en: Now, in the Animator panel, with the `UpperBody` layer selected, create three
    new empty states (by right-clicking on the grid area and navigating to Create
    State | Empty from the menu). Name the default (orange) state null, and the other
    twoFire and Grenade.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**动画器**面板中，选择`UpperBody`层，通过右键点击网格区域并从菜单中选择创建状态|空创建三个新的空状态。将默认（橙色）状态命名为null，其他两个命名为Fire和Grenade。
- en: 'Now, access the **Parameters** tab and add two new parameters of type Bool, Fire
    and Grenade:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，访问**参数**选项卡并添加两个类型为Bool的新参数，**Fire**和**Grenade**：
- en: '![](img/f8a63d47-4f4b-4b17-81bd-bb78231970d9.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f8a63d47-4f4b-4b17-81bd-bb78231970d9.png)'
- en: 'Select the Fire state and, in the **Inspector,** add the firing_rifle Animation
    Clip to the Motion field:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Fire状态，并在**检查器**中，将firing_rifle动画剪辑添加到**运动**字段：
- en: '![](img/22cb9520-f6ca-4ca4-9d3b-955f2a07f1e7.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/22cb9520-f6ca-4ca4-9d3b-955f2a07f1e7.png)'
- en: Now, select the **Grenade** state and, in the **Inspector,** add the `toss_grenade`
    animation clip to the Motion field.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择**手榴弹**状态，并在**检查器**中，将`toss_grenade`动画剪辑添加到**运动**字段。
- en: Right-click on the null state box and, from the menu, select **Make Transition**.
    Then, drag the white arrow onto the Fire box.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击null状态框，从菜单中选择**创建过渡**。然后，将白色箭头拖到Fire框上。
- en: 'Select the arrow (it will turn blue). From the **Inspector,** uncheck the Has
    **Exit Time** option. Then, access the Conditions list, click on the **+** sign
    to add a new condition, and set it as Fire and true:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择箭头（它将变为蓝色）。从**检查器**中，取消勾选**有退出时间**选项。然后，访问**条件**列表，点击**+**号添加一个新条件，并将其设置为触发和为真：
- en: '![](img/a17149d4-7bab-45fe-8293-c5ac548a4ba4.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a17149d4-7bab-45fe-8293-c5ac548a4ba4.png)'
- en: Now, make a **Transition** from null to Grenade. Select the arrow (it will turn
    blue). From the **Inspector,** uncheck the Has **Exit Time** option. Then, access
    the Conditions list, click on the **+** sign to add a new condition, and set it
    as Grenade and true.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从null状态到手榴弹状态创建一个**过渡**。选择箭头（它将变为蓝色）。从**检查器**中，取消勾选**有退出时间**选项。然后，访问**条件**列表，点击**+**号添加一个新条件，并将其设置为手榴弹和为真。
- en: Now, create transitions from Fire to null, and from **Grenade** to null. Then,
    select the arrow that goes from Fire to null and, in the Conditions box, select
    the Fire and false options. Leave the Has **Exit Time** option checked.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从Fire到null和从**手榴弹**到null创建过渡。然后，选择从Fire到null的箭头，并在**条件**框中选择Fire和**false**选项。保留**有退出时间**选项的勾选。
- en: 'Finally, select the **Transition** arrow that goes from **Grenade** to null.
    In the **Conditions** box, select the options **Grenade**, false. Leave the Has
    **Exit Time** option checked. See the screenshot for these setting choices:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，选择从**手榴弹**到null的**过渡**箭头。在**条件**框中，选择**手榴弹**、**false**选项。保留**有退出时间**选项的勾选。参见截图以了解这些设置选项：
- en: '![](img/e1b92465-bee4-4eb4-a3e7-2aae698b6284.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e1b92465-bee4-4eb4-a3e7-2aae698b6284.png)'
- en: 'Open the `BasicController` C# script-class in your code editor (in Project folder `Scripts`).
    Immediately before the end of the `Update()` function, add the following code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码编辑器（在项目文件夹`Scripts`中）中打开`BasicController` C#脚本类。在`Update()`函数的末尾之前立即添加以下代码：
- en: '[PRE1]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save the script and play your Scene. You will be able to trigger the `firing_rifle`
    and `toss_grenade` animations by clicking on the fire button and pressing the
    *F* key. Observe how the character's legs still respond to the Move animation
    state, so that the character can keep walking backward while throwing the grenade.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并播放场景。您可以通过点击火按钮并按*F*键来触发`firing_rifle`和`toss_grenade`动画。观察角色的腿部仍然响应移动动画状态，这样角色在投掷手榴弹时可以继续向后走。
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once the Avatar mask is created, it can be used as a way of filtering the body
    parts that would actually play the animation states of a particular layer. In
    our case, we have constrained our `fire_rifle` and `toss_grenade` animation clips
    to the upper body of our character, leaving the lower body free to play movement-related
    animation clips such as walking, running, and strafing.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了Avatar遮罩，它就可以用作过滤实际播放特定层动画状态的身体部分的方式。在我们的例子中，我们将`fire_rifle`和`toss_grenade`动画剪辑限制在角色的上半身，使下半身可以自由播放与移动相关的动画剪辑，如行走、跑步和侧滑。
- en: There's more...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here are some ways to go further with this recipe.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些进一步使用这个配方的方法。
- en: Override versus Additive blending
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖与加法混合
- en: You might have noticed that the `UpperBody` layer has a parameter named Blending,
    which we have set to Additive. This means that animation states in this layer
    will be added to the ones from the lower layers.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`UpperBody`层有一个名为Blending的参数，我们将其设置为Additive。这意味着此层中的动画状态将添加到来自下层的状态。
- en: If changed to Override, the animation from this would override animation states
    from the lower layers when played. In our case, Additive helps in keeping the
    aim stable when firing while running.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更改为覆盖，当播放时，此动画将覆盖下层的动画状态。在我们的例子中，Additive有助于在跑步时保持瞄准稳定。
- en: 'For more information on Animation Layers and Avatar Body Masks, check out Unity''s
    documentation:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有关动画层和Avatar身体遮罩的更多信息，请查看Unity的文档：
- en: '[http://docs.unity3d.com/Manual/AnimationLayers.html](http://docs.unity3d.com/Manual/AnimationLayers.html)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://docs.unity3d.com/Manual/AnimationLayers.html](http://docs.unity3d.com/Manual/AnimationLayers.html)'
- en: '[http://docs.unity3d.com/Manual/class-AvatarMask.html](http://docs.unity3d.com/Manual/class-AvatarMask.html)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://docs.unity3d.com/Manual/class-AvatarMask.html](http://docs.unity3d.com/Manual/class-AvatarMask.html)'
- en: Organizing States into Sub-state Machines
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将状态组织到子状态机中
- en: 'Whenever content in the **Animator** panel gets too cluttered, you can always
    consider organizing your **Animation States** into **Sub-State Machines**. In
    this recipe, we will use this technique to organize animation states for turning
    the character. Also, since the animation clips provided do not include Root Motion,
    we will use the opportunity to illustrate how to overcome the lack of Root Motion
    via a script, using it to turn the character 45 degrees to the left and right:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当**动画器**面板中的内容过于杂乱时，你总是可以考虑将你的**动画状态**组织到**子状态机**中。在这个配方中，我们将使用这种技术来组织旋转角色的动画状态。此外，由于提供的动画剪辑不包括Root
    Motion，我们将利用这个机会说明如何通过脚本克服Root Motion的不足，使用它将角色向左和向右旋转45度：
- en: '![](img/9cee99f8-ed72-4175-9b9f-b6d9ea875bdc.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9cee99f8-ed72-4175-9b9f-b6d9ea875bdc.png)'
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared a Unity Package named **Turning,** containing
    a basic scene that features an animated character. We have also provided the FBX
    animation clips `Swat@turn_right_45_degrees.fbx` and `Swat@turn_left.fbx.` These
    files can be found in the `09_04` folder.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们准备了一个名为**Turning**的Unity包，其中包含一个具有动画角色的基本场景。我们还提供了FBX动画剪辑`Swat@turn_right_45_degrees.fbx`和`Swat@turn_left.fbx.`这些文件可以在`09_04`文件夹中找到。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To organize States into Sub-State Machines, please follow these steps:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要将状态组织到子状态机中，请按照以下步骤操作：
- en: Create a new 3D project and import the Mixing Unity Package, as well as the
    FBX files `Swat@turn_right_45_degrees.fbx` and `Swat@turn_left.fbx.`
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的3D项目，并导入Mixing Unity包，以及FBX文件`Swat@turn_right_45_degrees.fbx`和`Swat@turn_left.fbx.`
- en: Then, from the **Project** panel, open the `mecanimPlayground` level.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从**项目**面板中打开`mecanimPlayground`级别。
- en: We need to configure the **Animation** Clips. Select the `Swat@turn_left` asset in
    the **Project** panel.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要配置**动画剪辑**。在**项目**面板中选择`Swat@turn_left`资产。
- en: Choose the Rig section. Change **Animation Type** to **Humanoid** and **Avatar
    Definition** to Create From this Model. Confirm by clicking on **Apply.**
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Rig部分。将**动画类型**更改为**Humanoid**，将**Avatar定义**更改为从该模型创建。通过点击**应用**来确认。
- en: 'Now, choose the **Animations** section. The `turn_left` clip should be selected.
    Click the **Clamp Range** button to adjust the timeline and check the **Loop Time**
    option. **Under Root Transform Rotation**, check **Bake Into Pose** and navigate
    to Based Upon | Original. **Under** **Root Transform Position** (**Y**), check
    **Bake Into Pose** and select **Based Upon (at Start)** | **Original**. **Under
    Root Transform Position (XZ)**, leave **Bake Into Pose** unchecked. Click on **Apply**
    to confirm the changes:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择**动画**部分。选择`turn_left`剪辑。点击**限制范围**按钮调整时间轴并检查**循环时间**选项。在**根变换旋转**下，检查**烘焙到姿态**并导航到基于
    | 原始。在**根变换位置**（**Y**）下，检查**烘焙到姿态**并选择**基于（开始）** | **原始**。在**根变换位置（XZ）**下，不检查**烘焙到姿态**。点击**应用**以确认更改：
- en: '![](img/8addff17-b81f-46bb-8c34-f1b8248584f1.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8addff17-b81f-46bb-8c34-f1b8248584f1.png)'
- en: Repeat steps 4 and 5 for `Swat@turning_right_45_degrees.`
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`Swat@turning_right_45_degrees`重复步骤4和5。
- en: In the **Project** panel, double-click the `MainCharacter` controller asset
    file; it should open in the **Animator** panel.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中，双击`MainCharacter`控制器资产文件；它应该在**动画器**面板中打开。
- en: From the top-left corner of the **Animator** panel, select the **Parameters**
    section and use the **+** sign to create the two new Parameters (Boolean) named
    `TurnLeft` and `TurnRight.`
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**动画器**面板的左上角，选择**参数**部分，并使用**+**符号创建两个新的参数（布尔值）命名为`TurnLeft`和`TurnRight`。
- en: 'Right-click on the grid area. From the context menu, select Create `Sub-State`
    Machine. In the Inspector, rename it Turn:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网格区域右键单击。从上下文菜单中选择创建**子状态机**。在检查器中，将其重命名为转。
- en: '![](img/37266a4b-8c2c-40b8-afaf-b99db355ce5a.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/37266a4b-8c2c-40b8-afaf-b99db355ce5a.png)'
- en: Double-click on the **Turn Sub-State Machine**. Right-click on the grid area,
    select **Create State** | **Empty****,** and add a new state. Rename it to **Turn
    Left.** Then, add another state named **Turn Right**.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**转子状态机**。在网格区域右键单击，选择**创建状态** | **空**，并添加一个新状态。将其重命名为**向左转**。然后，添加另一个名为**向右转**的状态。
- en: 'From the **Inspector,** populate Turn Left with the `turn_left` motion clip.
    Then, populate **Turn Right** with `turning_right_45_degrees`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，将`turn_left`动作剪辑填充到**向左转**。然后，将**向右转**填充为`turning_right_45_degrees`：
- en: '![](img/fce897ee-abff-43dc-81b3-a7f3e2271627.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fce897ee-abff-43dc-81b3-a7f3e2271627.png)'
- en: In the **Animator** panel, return to the **Base Layer** (click Base Layer in
    the information bar along the top of this panel).
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画器**面板中，返回到**基础层**（点击此面板顶部的信息栏中的基础层）。
- en: 'Create two **Transitions** from **State Move**, one into the **Turn Left** sub-state,
    and one into the **Turn Right** sub-state:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**状态移动**创建两个**转换**，一个进入**向左转**子状态，另一个进入**向右转**子状态：
- en: '![](img/0836a058-4b84-4a1e-842d-f8d9564ff3d8.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0836a058-4b84-4a1e-842d-f8d9564ff3d8.png)'
- en: Create two return **Transitions,** from the Turn Left back to Move sub-state,
    and from the Turn Right sub-state back to Move. Do this by entering the Turn sub-state, dragging
    the **Transition** arrows from Turn Left and Turn Right into (Up) **Base Layer**,
    and choosing **State Move.**
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个返回**转换**，从**向左转**返回到**移动**子状态，以及从**向右转**子状态返回到**移动**。通过进入**转**子状态，将**转换**箭头从**向左转**和**向右转**拖动到（向上）**基础层**，并选择**状态移动**。
- en: Select the **Transition** arrow that goes from Turn Right to (Up) Base Layer.
    It will turn blue. From the **Inspector,** uncheck the **Has Exit Time** option.
    Then, access the Conditions list, click the **+** sign to add a new condition,
    and set it as **TurnRight** and **false:**
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择从**向右转**到（向上）基础层的**转换**箭头。它将变为蓝色。在**检查器**中，取消选中**有退出时间**选项。然后，访问条件列表，点击**+**符号添加一个新条件，并将其设置为**TurnRight**和**false**：
- en: '![](img/3ab1a0d5-0246-4185-af0b-0342c434d943.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ab1a0d5-0246-4185-af0b-0342c434d943.png)'
- en: Select the arrow that goes from (Up) Base Layer to Turn Right. From the **Inspector,**
    uncheck the Has Exit Time option. Then, access the Conditions list, click the
    + sign to add a new condition, and set it as **TurnRight** and **true.**
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择从（向上）基础层到**向右转**的箭头。在**检查器**中，取消选中**有退出时间**选项。然后，访问条件列表，点击**+**符号添加一个新条件，并将其设置为**TurnRight**和**true**。
- en: Repeat steps 14 and 15 with the arrows that go between (Up) Base Layer and Turn
    Left, using TurnLeft as a condition this time.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**向左转**作为条件，重复步骤14和15，使用（向上）基础层和**向左转**之间的箭头。
- en: 'Open the `BasicController` C# script-class in your code editor (folder Project
    | Scripts). Immediately after the `if(controller.isGrounded)` line, add this:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中（文件夹项目 | 脚本）打开`BasicController` C# 脚本类。在`if(controller.isGrounded)`行之后立即添加以下内容：
- en: '[PRE2]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Save your script-class. Then, select the `MsLaser` character and, from the **Inspector,**
    select the **Basic Controller** component. Leave the Move Diagonally and Mouse
    Rotate options unchecked. Also, leave the Keyboard Rotate option checked.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的脚本类。然后，选择`MsLaser`角色，并在**检查器**中，选择**基本控制器**组件。不检查移动对角线和鼠标旋转选项。同时，检查键盘旋转选项。
- en: Play the **Scene.** You will be able to turn left and right by using the *Q*
    and *E* keys respectively.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放**场景**。您可以通过使用*Q*和*E*键分别向左和向右转动。
- en: How it works...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As should be clear from the recipe, Sub-State Machines work in a similar way
    to groups or folders, allowing you to encapsulate a series of state machines into
    a single entity for easier reference. States from the Sub-State Machines can be
    Transitioned from external states, in our case the Move state, or even from different
    sub-state machines.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从菜谱中可以看出，子状态机的工作方式与组或文件夹类似，允许您将一系列状态机封装成一个单一实体，以便更容易引用。子状态机的状态可以从外部状态转换，在我们的例子中是移动状态，甚至可以从不同的子状态机转换。
- en: Regarding character rotation, we have overcome the lack of root motion by using
    the `transform.Rotate(Vector3.up` * `(Time.deltaTime * -45.0f)`, Space.World)
    command to make the character actually turn around when the Q and E keys are held
    down.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 关于角色旋转，我们通过使用`transform.Rotate(Vector3.up` * `(Time.deltaTime * -45.0f)`, Space.World)`命令克服了根运动的不足，使角色在按下Q和E键时实际上可以转身。
- en: 'This command was used in conjunction with `animator.SetBool("TurnLeft", true)`,
    which triggers the right animation clip:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令与`animator.SetBool("TurnLeft", true)`一起使用，触发了右侧的动画剪辑：
- en: '![](img/9ab32fd2-834a-415a-8000-2d3b36734e9b.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9ab32fd2-834a-415a-8000-2d3b36734e9b.png)'
- en: Transforming the Character Controller via scripts
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过脚本转换角色控制器
- en: Applying Root Motion to your character might be a very practical and accurate
    way to animate it. However, every now and then, you might need to manually control
    one or two aspects of the character's movement. Perhaps you only have an in-place
    animation to work with, or maybe you want the character's movement to be affected
    by other variables. In these cases, you will need to override **Root Motion**
    via a script.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将根运动应用于您的角色可能是一种非常实用和精确的动画方式。然而，时不时地，您可能需要手动控制角色的一个或两个方面。也许您只有原地动画可以工作，或者可能希望角色的移动受到其他变量的影响。在这些情况下，您将需要通过脚本覆盖**根运动**。
- en: To illustrate this issue, this recipe makes use of an animation clip for jumping,
    which originally moves the character only in the Y-axis. In order to make her
    move forward or backward while jumping, we will learn how to access the character's
    velocity to inform the jump direction via a script.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个问题，这个菜谱使用了一个跳跃的动画剪辑，它最初只将角色在Y轴上移动。为了使她在跳跃时向前或向后移动，我们将学习如何通过脚本访问角色的速度来通知跳跃方向。
- en: Getting ready
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared a Unity Package named Jumping, containing
    a basic scene that features an animated character. We have also provided the FBX
    animation clip `Swat@rifle_jump.` These files can be found in the `09_05` folder.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们准备了一个名为Jumping的Unity包，其中包含一个具有动画角色的基本场景。我们还提供了FBX动画剪辑`Swat@rifle_jump`。这些文件可以在`09_05`文件夹中找到。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To apply Root Motion via a script, please follow these steps:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过脚本应用根运动，请按照以下步骤操作：
- en: Create a new 3D project and import the Jumping Unity Package, as well as the
    FBX `Swat@rifle_jump.fbx` file.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的3D项目，并导入Jumping Unity包以及FBX文件`Swat@rifle_jump.fbx`。
- en: Then, from the Project panel, open the `mecanimPlayground` level.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从项目面板中打开`mecanimPlayground`级别。
- en: We need to configure the **Animation** Clips. Select the `Swat@rifle_jump` asset in
    the **Project** panel.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要配置**动画**剪辑。在**项目**面板中选择`Swat@rifle_jump`资产。
- en: Select the Rig section. Change Animation Type to Humanoid and Avatar Definition
    to Create From this Model. Confirm this by clicking on Apply.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Rig部分。将动画类型更改为Humanoid，并将Avatar Definition更改为Create From this Model。通过点击应用来确认这一点。
- en: 'Now, activate the **Animations** section. The `rifle_jump` clip should be selected.
    Click the Clamp Range button to adjust the timeline, and check the Loop Time and
    Loop Pose options. Under Root Transform Rotation, check Bake Into Pose and select
    Based Upon | Original. Under Root Transform Position (Y), leave Bake into Pose
    unchecked and select **Based** Upon (at Start) | Original. Under Root Transform
    Position (XZ), leave Bake Into Pose unchecked. Click on **Apply** to confirm the
    changes:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，激活**动画**部分。选择`rifle_jump`剪辑。点击“限制范围”按钮调整时间轴，并勾选“循环时间”和“循环姿态”选项。在根变换旋转下，勾选“烘焙到姿态”并选择基于“原始”。在根变换位置（Y）下，不勾选“烘焙到姿态”并选择**基于**（在开始时）|**原始**。在根变换位置（XZ）下，不勾选“烘焙到姿态”。点击**应用**以确认更改：
- en: '![](img/96b4285f-1037-4c73-9b2e-60de1a85b657.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/96b4285f-1037-4c73-9b2e-60de1a85b657.png)'
- en: In the **Project** panel, double-click the `MainCharacter` controller asset
    file; it should open up in the Animator panel.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中，双击`MainCharacter`控制器资产文件；它应该在动画面板中打开。
- en: 'From the top-left corner of the Animator panel, select the Parameters section
    and use the **+** sign to create a new **Trigger** parameter named Jump:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从动画面板的左上角选择“参数”部分，并使用**+**符号创建一个名为“跳跃”的新**触发**参数：
- en: '![](img/39a6240f-a419-4a9a-8d00-0fea4a227ed0.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39a6240f-a419-4a9a-8d00-0fea4a227ed0.png)'
- en: Add a new State named Jump. Do this by right-clicking the grid area and choosing
    Create State | Empty, then changing its name in the Inspector.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为“跳跃”的新状态。通过在网格区域右键单击并选择“创建状态 | 空白”，然后在检查器中更改其名称来完成此操作。
- en: 'Select the **Jump** state. Then, from the **Inspector,** populate it with the
    `rifle_jump` motion clip:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“跳跃”状态。然后，从**检查器**中填充它，使用`rifle_jump`动作剪辑：
- en: '![](img/57ca2d32-4d46-4642-94d1-e635b194fe82.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/57ca2d32-4d46-4642-94d1-e635b194fe82.png)'
- en: 'Create a **Transition** from Any State to Jump (using the Make Transition right-mouse-click
    menu). Select the **Transition,** uncheck Has Exit Time, and add a Condition for
    Trigger Jump:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从任何状态到“跳跃”创建一个**转换**（使用“创建转换”右键单击菜单）。选择**转换**，取消勾选“具有退出时间”，并添加一个触发器条件“跳跃”：
- en: '![](img/4f122a2c-759a-4219-8faa-b1c5429ac82f.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4f122a2c-759a-4219-8faa-b1c5429ac82f.png)'
- en: 'Now, create a **Transition** from Jump to Move. Ensure the Has Exit Time option
    is checked:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从“跳跃”到“移动”创建一个**转换**。确保勾选“具有退出时间”选项：
- en: '![](img/c110b9e8-cb8c-440d-8a5f-6c872a95cf74.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c110b9e8-cb8c-440d-8a5f-6c872a95cf74.png)'
- en: Open the `BasicController` C# script-class in your code editor (folder Project
    | Scripts).
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码编辑器（文件夹项目 | 脚本）中打开`BasicController`C#脚本类。
- en: 'Right before the `Start()` function, add the following code:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start()`函数之前，添加以下代码：
- en: '[PRE3]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Immediately after the `if(controller.isGrounded)` line, add this:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`if(controller.isGrounded)`行之后立即添加以下内容：
- en: '[PRE4]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, add a new function at the end of the code for this script-class. So
    it is inserted immediately before the final brace  (`}`) of the code:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在脚本类的代码末尾添加一个新的函数。因此，它被插入到代码的最后一个大括号（`}`）之前：
- en: '[PRE5]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save your script and play the Scene. You will be able to jump around using the
    spacebar. Observe how the character's velocity affects the direction of the jump.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并播放场景。你可以使用空格键进行跳跃。观察角色的速度如何影响跳跃的方向。
- en: How it works...
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Observe that once this function is added to the script, the Apply Root Motion
    field in the Animator component changes from a checked box to Handled by Script:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到一旦这个函数被添加到脚本中，动画组件中的“应用根运动”字段就会从勾选框变为“由脚本处理”：
- en: '![](img/5e23a15e-9164-4c63-a06a-aee63fa715fb.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e23a15e-9164-4c63-a06a-aee63fa715fb.png)'
- en: The reason is that in order to override the animation clip's original movement,
    we have placed a series of commands inside Unity's OnAnimatorMove() function to
    move our character controller while jumping. The `controller.Move (deltaPosition)` line
    of code basically replaces the jump's direction from the original animation with
    the deltaPosition 3D Vector, which is made up of the character's velocity at the
    instant before the jump (x and z-axis) and the calculation between the jumpHeight
    variable and gravity over time (y-axis).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于，为了覆盖动画剪辑的原始运动，我们在Unity的`OnAnimatorMove()`函数内放置了一系列命令来移动我们的角色控制器，使其在跳跃时移动。代码中的`controller.Move
    (deltaPosition)`行基本上用deltaPosition 3D向量替换了跳跃的方向，这个向量由跳跃瞬间的角色速度（x和z轴）以及跳跃高度变量随时间与重力的计算（y轴）组成。
- en: The Transition from Any State to Animation State Jump has the condition that
    the Jump Transition has fired (become true). In the code, we activate the Trigger
    Jump in the Animator Controller with the ` SetTrigger("Jump")` statement. Triggers
    are like Bool Parameters, but when set become True for one instance, then automatically
    return to false again. This means there is no need to write extra code to set
    the Trigger to False.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从任何状态到动画状态的转换跳转的条件是跳转转换已触发（变为真）。在代码中，我们使用`SetTrigger("Jump")`语句在动画控制器中激活Trigger
    Jump。触发器就像布尔参数一样，但设置后变为真，然后自动返回假。这意味着不需要编写额外的代码来将触发器设置为假。
- en: Triggers are perfect for events that happen, and then you want things to return
    to normal afterwards. The Transition from the Jump Animation State back to Move
    does not need any condition, so after the Jump animation has played, the character
    returns to the Move state.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器非常适合发生事件，然后你想让事情恢复正常。从跳转动画状态回到移动状态的转换不需要任何条件，所以跳转动画播放后，角色返回到移动状态。
- en: Adding rigid props to animated characters
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将刚体属性添加到动画角色中
- en: If you haven't included a sufficient number of props for your character when
    modeling and animating it, you might want to give her the chance to collect new
    ones at runtime. In this recipe, we will learn how to instantiate a GameObject
    and assign it to a character while respecting the animation hierarchy.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在建模和动画角色时没有包含足够数量的属性，你可能想给她在运行时收集新属性的机会。在这个食谱中，我们将学习如何在尊重动画层次结构的同时实例化GameObject并将其分配给角色。
- en: Getting ready
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared a Unity Package named Props, containing a
    basic Scene that features an animated character and a prefab named badge. There
    is also a Texture named `texture_pickupBadge.png.` The files can be found in the
    `09_06` folder.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们准备了一个名为Props的Unity包，其中包含一个具有动画角色和名为徽章的预制件的基场景。还有一个名为`texture_pickupBadge.png`的纹理。这些文件可以在`09_06`文件夹中找到。
- en: How to do it...
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To add a rigid prop at runtime to an animated character, follow these steps:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行时将刚体属性添加到动画角色中，请按照以下步骤操作：
- en: Create a new 3D project and import the Props Unity Package and the `texture_pickupBadge.png` Texture.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的3D项目，并导入Props Unity包和`texture_pickupBadge.png`纹理。
- en: Then, from the **Project** panel, open the `mecanimPlayground` level.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从**项目**面板打开`mecanimPlayground`级别。
- en: From the **Project** panel, add the badge prop to the scene by dragging it into
    the Hierarchy.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**面板，通过拖动到层次结构中，将徽章属性添加到场景中。
- en: 'Make the badge a child of the `mixamorig:Spine2` Transform (use the Hierarchy
    tree to navigate to MsLaser | `mixamorig:Hips` | `mixamorig:Spine` | `mixamorig:Spine1`
    | `mixamorig:Spine2``).` Then, make the badge object visible above the character''s
    chest by changing its Transform Position to (-0.08, 0, 0.15) and Rotation to (0.29,
    0.14, -13.29):'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将徽章设置为`mixamorig:Spine2`变换的子对象（使用层次结构树导航到MsLaser | `mixamorig:Hips` | `mixamorig:Spine`
    | `mixamorig:Spine1` | `mixamorig:Spine2``）。然后，通过将变换位置更改为(-0.08, 0, 0.15)和旋转更改为(0.29,
    0.14, -13.29)，使徽章对象在角色的胸部上方可见：
- en: '![](img/26e4046a-4723-4896-babb-388487b518bd.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26e4046a-4723-4896-babb-388487b518bd.png)'
- en: Make a note of the **Position** and **Rotation** values, and delete the badge
    object from the scene.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录**位置**和**旋转**值，并从场景中删除徽章对象。
- en: Add a 3D Cube named Cube-pickup to the Scene by choosing **Create** | **3D Object**
    | **Cube****.** In the **Inspector,** set its **Transform Position** to (0, 0.5,
    2) and check the Is Trigger option for the Box Collider component.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**创建** | **3D对象** | **立方体**，将名为Cube-pickup的3D立方体添加到场景中。在**检查器**中，将它的**变换位置**设置为(0,
    0.5, 2)，并检查Box Collider组件的Is Trigger选项。
- en: Drag the `texture_pickupBadge.png` Texture from the **Project** panel onto the Cube-pickup GameObject.
    You should see the Pickup Badge text written on all sides of the Cube.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`texture_pickupBadge.png`纹理从**项目**面板拖动到Cube-pickup游戏对象上。你应该能看到拾取徽章文本写在立方体的所有面上。
- en: 'In the **Project** panel, create a new C# script-class named **AddProp** containing
    the following code, and add an instance-object as a component to the Cube-pickup
    GameObject:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中，创建一个名为**AddProp**的新C#脚本类，包含以下代码，并将其作为组件添加到Cube-pickup游戏对象中：
- en: '[PRE6]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Select the Cube-pickup GameObject and look at the properties of the **Prop
    Manager (Script)** component in the Inspector. Populate the public variables as
    follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Cube-pickup游戏对象，并查看检查器中**属性管理器（脚本）**组件的属性。按照以下方式填充公共变量：
- en: 'Prop: the badge prefab'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性：徽章预制件
- en: 'Target Bone: the `mixamorig:Spine2` transform inside the `MsLaser` **Hierarchy** GameObject'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标骨骼：`MsLaser` **层次结构** GameObject 内的 `mixamorig:Spine2` 变换
- en: 'Position Offset: (-0.08, 0, 0.15)'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置偏移量：(-0.08, 0, 0.15)
- en: 'Rotation Offset: (0.29, 0.14, -13.29)'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转偏移量：(0.29, 0.14, -13.29)
- en: 'Destroy Trigger: checked (true)'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁触发器：勾选（true）
- en: '![](img/afb575be-e9ad-4684-97f4-65b7497a1cc2.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/afb575be-e9ad-4684-97f4-65b7497a1cc2.png)'
- en: 'Run the **Scene.** Using the WASD keyboard control scheme, direct the character
    to the the Cube-pickup GameObject. Colliding with it will add a badge to the character
    the first time. If public variable **Destroy Trigger** was checked, then the Cube-pickup
    GameObject should be removed from the Scene after the first collision:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 **场景**。使用 WASD 键盘控制方案，将角色引导到 Cube-pickup GameObject。第一次碰撞将向角色添加徽章。如果公共变量
    **销毁触发器** 被勾选，那么 Cube-pickup GameObject 应在第一次碰撞后从场景中移除：
- en: '![](img/ae7f53cf-d82d-4c19-bf28-9c13a6f77ee6.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae7f53cf-d82d-4c19-bf28-9c13a6f77ee6.png)'
- en: How it works...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once it's been triggered by the character, the scripted instance-object attached
    to the Cube-pickup GameObject instantiates the assigned prefab, making it a child
    of the bones that they have been "placed into." The **Position Offset** and **Rotation
    Offset** can be used to fine-tune the exact position of the prop relative to its
    parent Transform. As the props become parented by the bones of the animated character,
    they will follow and respect the parent character GameObejct's hierarchy and animation.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦被角色触发，附加到 Cube-pickup GameObject 的脚本实例对象将实例化指定的预制体，使其成为它们“放置”的骨骼的子对象。**位置偏移量**
    和 **旋转偏移量** 可以用来微调道具相对于其父变换的确切位置。随着道具成为动画角色的骨骼的父对象，它们将跟随并尊重父角色 GameObject 的层次结构和动画。
- en: The `AlreadyHalreadyHasChildObject()` method checks for preexisting props of
    the same name before actually instantiating a new one, so we don't attempt to
    instantiate the prop more than once as a new child of the target bone.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`AlreadyHalreadyHasChildObject()` 方法在实例化新对象之前检查是否存在同名的前置道具，因此我们不会尝试将道具作为目标骨骼的新子对象实例化超过一次。'
- en: There's more...
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here are some ways to go further with this recipe.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些方法可以进一步扩展这个菜谱。
- en: Removing props with a script
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用脚本移除道具
- en: 'You can make a similar script to remove props. In this case, the `OnTriggerEnter(...)`
    method would invoke the following `RemoveProp()` method:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写一个类似的脚本来移除道具。在这种情况下，`OnTriggerEnter(...)` 方法将调用以下 `RemoveProp()` 方法：
- en: '[PRE7]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Setting Active if there's only one type of Prop
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果只有一个类型的道具，则设置活动状态
- en: If there will only be one prop, then rather than having the code Instantiate
    a new GameObject, you could have the prop always in the Hierarchy but initially
    not active, and then when the pickup Trigger object is hit, you change the prop
    GameObject to be active.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有一个道具，那么而不是让代码实例化一个新的 GameObject，你可以让道具始终在层次结构中，但最初不活动，然后在拾取触发器对象被击中时，你将道具
    GameObject 设置为活动状态。
- en: 'Although less flexible, it''s a much simpler script. Do the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不太灵活，但这是一个更简单的脚本。执行以下操作：
- en: Drag the badge **Prefab** and make it a child of the `mixamorig:Spine2` Transform,
    then set **Position** and **Rotation** as you did in Step 4 of the previous recipe.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动徽章 **预制体** 并使其成为 `mixamorig:Spine2` 变换的子对象，然后设置 **位置** 和 **旋转**，就像在上一道菜的第
    4 步中做的那样。
- en: In the **Inspector,** uncheck the Active checkbox for the whole badge GameObject
    at the top.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 中，取消勾选顶部整个徽章 GameObject 的活动复选框。
- en: 'Replace the content of the C# script-manager with the following code:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 C# 脚本管理器的内容替换为以下代码：
- en: '[PRE8]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With the Cube-pickup GameObject selected in the **Hierarchy,** in the Inspector
    drag the badge child of mixamorig:Spine2 into the public slot for the Prop Object
    variable of the Prop Manager (Script) component.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 中选择 Cube-pickup GameObject，在 **检查器** 中将 mixamorig:Spine2 的徽章子对象拖入公共槽位，用于道具管理器（脚本）组件的
    Prop Object 变量。
- en: Using Animation Events to throw an object
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动画事件抛出对象
- en: 'Now that your animated character is ready, you might want to coordinate some
    of her actions with her animation states. In this recipe, we will show this by
    making the character throw an object whenever the appropriate animation clip reaches
    a particular tie point in the animation. To do so, we will make use of **Animation**
    Events, which basically trigger a function from the animation clip''s timeline.
    This feature, introduced in the Mecanism system, should feel familiar to those
    experienced with the Add Event feature of the classic **Animation** panel:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/523ca6f8-ee07-4f39-bf52-d5eec4e64100.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we have prepared a Unity Package named **Throwing,** containing
    a basic scene that features an animated character and a **prefab** named **EasterEgg.**
    The files can be found in the `09_07` folder.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make an animated character throw an object, follow these steps:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 3D project and import the Props Unity Package and the `EasterEgg` Texture.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `mecanimPlayground` level.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the level and press *F* on your keyboard. The character will move as if
    she is throwing something with her right hand.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C# script-class named `ThrowObject,` and add an instance-object
    as a component to the character''s `MsLaser` GameObject:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the **Hierarchy,** ensure the **MsLaser** GameObject is selected. In the **Inspector,**
    examine its **Throw Object (Script)** component. Populate the following:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Prop: The `EasterEgg` prefab'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hand: `mixamorig:RightHand`'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pos Offset: Set to (0; 0.07, 0.04)'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Force: Set to (0; 200, 500)'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/eb4b94fa-7b65-42ee-9df4-7f0f625775ec.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: From the **Project** panel, select the `Swat@toss_grenade` asset file. In the
    **Inspector,** select the **Animation** section, scroll down to the **Events**
    section, and expand it.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Explore the **Animation** preview panel and see how, as you drag the preview
    playhead along the preview **Timeline,** the playhead also moves correspondingly
    in the **Events** timeline. At the bottom of the **Preview** panel, the time,
    percentage, and Frame properties are displayed. When you click the add event button,
    a new **Animation Event** will be added in the **Events Timeline** at the current
    playhead position, so ensure you have the playhead at the correct frame before
    creating a new **Animation** Event:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1ddda731-39e9-48fd-bb67-63378d4d8d4a.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
- en: You may view the contents of this panel by focussing on the avatar animation
    itself when moving the playhead, and visually choosing the appropriate frame when
    the character is the desired position for the event. Or, you may already know
    the time/percentage/frame number at which you wish the Animation Event to be created,
    and so be focussing on the numerical values at the bottom of the Preview panel.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two **Animation Events** in the Events section as follows:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '017.9%: Set Function to Prepare'
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '057.1%: Set Function to Throw'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, click the Apply button:'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/0a763495-1ff1-435a-af2c-ceb19953071d.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: Play your **Scene.** Your character will now be able to throw an **Easter Egg**
    when you press the F key.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放你的 **场景**。当你按下 F 键时，你的角色现在将能够投掷一个 **复活节彩蛋**。
- en: How it works...
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Once the `toss_grenade` animation reaches the points to which we have set our
    **Events,** the `Prepare()` and `Throw()` methods are invoked.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Once the `toss_grenade` animation reaches the points to which we have set our
    **Events,** the `Prepare()` and `Throw()` methods are invoked.
- en: The `Prepare()` method instantiates a prefab, now named projectile, in the character's
    hand (Projectile Offset values are used to fine-tune its position), also making
    it respect the character's hierarchy. Also, it disables the prefab's collider
    and destroys its Rigidbody component, provided it has one.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: The `Prepare()` method instantiates a prefab, now named projectile, in the character's
    hand (Projectile Offset values are used to fine-tune its position), also making
    it respect the character's hierarchy. Also, it disables the prefab's collider
    and destroys its Rigidbody component, provided it has one.
- en: The `Throw()` method enables the projectile's collider and adds a Rigidbody
    component to it, making it independent from the character's hand. Finally, it
    adds a relative force to the projectile's Rigidbody component, so it will behave
    as if thrown by the character. The Compensation YAngle can be used to adjust the
    direction of the grenade, if necessary.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: The `Throw()` method enables the projectile's collider and adds a Rigidbody
    component to it, making it independent from the character's hand. Finally, it
    adds a relative force to the projectile's Rigidbody component, so it will behave
    as if thrown by the character. The Compensation YAngle can be used to adjust the
    direction of the grenade, if necessary.
- en: Applying Ragdoll physics to a character
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Applying Ragdoll physics to a character
- en: 'Action games often make use of Ragdoll physics to simulate the character''s
    body''s reaction to being affected by a hit or explosion. In this recipe, we will
    learn how to set up and activate Ragdoll physics for our character whenever she
    touches a spiky object. We will also use the opportunity to reset the character''s
    position and animations a number of seconds after that event has occurred:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 动作游戏通常利用 Ragdoll 物理来模拟角色身体对受到打击或爆炸影响的反应。在这个配方中，我们将学习如何设置并激活角色在接触带刺物体时触发的 Ragdoll
    物理效果。我们还将利用这个机会在事件发生后几秒钟重置角色的位置和动画：
- en: '![](img/fce4514f-6356-4231-9ce9-28555981a8d5.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fce4514f-6356-4231-9ce9-28555981a8d5.png)'
- en: Getting ready
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared a Unity Package named Ragdoll, containing
    a basic scene that features an animated character, and a prefab already placed
    in the scene named Spawnpoint. The files can be found in the `09_08` folder.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们准备了一个名为 Ragdoll 的 Unity 包，其中包含一个具有动画角色的基本场景，以及已经放置在场景中的名为 Spawnpoint
    的预制件。文件可以在 `09_08` 文件夹中找到。
- en: How to do it...
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To apply Ragdoll physics to your character, follow these steps:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Ragdoll 物理应用于你的角色，请按照以下步骤操作：
- en: Create a new 3D project and import the Ragdoll Unity Package.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 3D 项目并导入 Ragdoll Unity 包。
- en: Open the `mecanimPlayground` level.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `mecanimPlayground` 级别。
- en: You will see the animated MsLaser character and a disc, Spawnpoint.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到动画化的 MsLaser 角色和一个圆盘，Spawnpoint。
- en: First, let's create and set up our Ragdoll. Create a new 3D Ragdoll by choosing **Create**
    | **3D Object** | **Ragdoll....** The **Ragdoll** wizard should pop up.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建并设置我们的 Ragdoll。通过选择 **创建** | **3D 对象** | **Ragdoll....** 创建一个新的 3D Ragdoll。应该会弹出
    **Ragdoll** 向导。
- en: 'Assign the transforms as follows:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Assign the transforms as follows:'
- en: 'Pelvis: `mixamorig:Hips`'
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '骨盆: `mixamorig:Hips`'
- en: 'Left Hips: `mixamorig:LeftUpLeg`'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '左髋关节: `mixamorig:LeftUpLeg`'
- en: 'Left Knee: `mixamorig:LeftLeg`'
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '左膝: `mixamorig:LeftLeg`'
- en: 'Left Foot: `mixamorig:LeftFoot`'
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '左脚: `mixamorig:LeftFoot`'
- en: 'Right Hips: `mixamorig:RightUpLeg`'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '右髋关节: `mixamorig:RightUpLeg`'
- en: 'Right Knee: `mixamorig:RightLeg`'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '右膝: `mixamorig:RightLeg`'
- en: 'Right Foot: `mixamorig:RightFoot`'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '右脚: `mixamorig:RightFoot`'
- en: 'Left Arm: `mixamorig:LeftArm`'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '左臂: `mixamorig:LeftArm`'
- en: 'Left Elbow: `mixamorig:LeftForeArm`'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '左肘: `mixamorig:LeftForeArm`'
- en: 'Right Arm: `mixamorig:RightArm`'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '右臂: `mixamorig:RightArm`'
- en: 'Right Elbow: `mixamorig:RightForeArm`'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '右肘: `mixamorig:RightForeArm`'
- en: 'Middle Spine: `mixamorig:Spine1`'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '中间脊柱: `mixamorig:Spine1`'
- en: 'Head: mixamorig:Head'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '头部: mixamorig:Head'
- en: 'Total Mass: 20'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '总质量: 20'
- en: 'Strength: 50'
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '力度: 50'
- en: 'See the screenshot for these settings:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'See the screenshot for these settings:'
- en: '![](img/37968fc7-da9b-49cb-9c97-c3c97c67378e.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37968fc7-da9b-49cb-9c97-c3c97c67378e.png)'
- en: Select the **MsLaser** GameObject in the Hierarchy. In the **Inspector,** set
    its **Tag** to **Player.**
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择 **MsLaser** GameObject。在 **检查器** 中，将其 **标签** 设置为 **Player**。
- en: 'Create a new C# script-class named `RagdollCharacter` and add an instance-object
    as a component to the **MsLaser** GameObject:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Create a new C# script-class named `RagdollCharacter` and add an instance-object
    as a component to the **MsLaser** GameObject:'
- en: '[PRE10]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This recipe needs something to collide with; create a GameObject named death-object.
    You could create a simple 3D Cube (menu: **Create** | 3D **Object** | **Cube****).**
    However, any 3D object with a Physics Collider will be fine for the player''s
    character to interact with.'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个配方需要与某物发生碰撞；创建一个名为 death-object 的 GameObject。你可以创建一个简单的 3D 立方体（菜单：**创建** |
    3D **对象** | **立方体****）。**然而，任何具有物理碰撞器的 3D 对象都适合玩家角色与之交互。
- en: 'It''s more fun to have a visually interesting 3D model to interact with. When
    creating the screenshots for this recipe, we used the high-quality, low-poly,
    free Stilized Crystal assets from LowlyPoly in the Unity Asset Store as example
    objects you might use to cause a Ragdoll collision in a game:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 与一个视觉上有趣的 3D 模型交互更有趣。在为这个配方创建截图时，我们使用了来自 Unity Asset Store 中的 LowlyPoly 的高质量、低多边形、免费的
    Stilized Crystal 资产作为示例对象，你可能会使用这些对象在游戏中引起小丑娃娃碰撞：
- en: '[https://assetstore.unity.com/packages/3d/props/stylized-crystal-77275](https://assetstore.unity.com/packages/3d/props/stylized-crystal-77275)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://assetstore.unity.com/packages/3d/props/stylized-crystal-77275](https://assetstore.unity.com/packages/3d/props/stylized-crystal-77275)'
- en: '![](img/f53c0851-5482-4096-ab7b-fbbd077c6bc7.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f53c0851-5482-4096-ab7b-fbbd077c6bc7.png)'
- en: 'Create a new C# script-class named `DeadlyObject,` and attach an instance-object
    as a component to the death-object GameObject:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 C# 脚本类名为 `DeadlyObject`，并将实例对象作为组件附加到 death-object GameObject 上：
- en: '[PRE11]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Play the **Scene.** Using the WASD keyboard control scheme, direct the character
    to the death-object GameObject. Colliding with it will activate the character's
    Ragdoll physics and apply an explosion to it. As a result, the character will
    be thrown a considerable distance away and will no longer be in control of its
    body's movement, akin to a Ragdoll.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放 **场景**。使用 WASD 键盘控制方案，将角色引导到 death-object GameObject。与之碰撞将激活角色的 Ragdoll 物理并对其应用爆炸。结果，角色将被抛出相当远的距离，并且将不再控制其身体的运动，类似于小丑娃娃。
- en: How it works...
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Unity''s Ragdoll Wizard assigns the Collider, Rigidbody, and Character Joint components to
    selected transforms. In conjunction, those components make Ragdoll physics possible.
    However, they must be disabled whenever we want our character to be animated and
    controlled by the player. In our case, we switch those components on and off using
    the `RagdollCharacter` script and its two functions: `ActivateRagdoll()` and `DeactivateRagdoll().`
    The latter includes instructions to respawn our character in the appropriate place.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 的 Ragdoll 工具将 Collider、Rigidbody 和 Character Joint 组件分配给选定的变换。结合这些组件，使得
    Ragdoll 物理成为可能。然而，每当我们要让我们的角色被动画化和由玩家控制时，它们必须被禁用。在我们的例子中，我们使用 `RagdollCharacter`
    脚本及其两个函数 `ActivateRagdoll()` 和 `DeactivateRagdoll()` 来开关这些组件。后者包括将我们的角色在适当位置重新生成的指令。
- en: For testing purposes, we have also created the `DeadlyObject` script, which
    calls the `RagdollCharacter` script's function named `ActivateRagdoll().` It also
    applies an explosion to our ragdoll character, throwing it outside the range of
    the explosion.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，我们还创建了名为 `DeadlyObject` 的脚本，该脚本调用 `RagdollCharacter` 脚本中名为 `ActivateRagdoll()`
    的函数。它还对我们的小丑娃娃角色应用了爆炸，将其抛出爆炸范围之外。
- en: There's more...
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here are some ways to go further with this recipe.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些进一步改进这个配方的方法。
- en: Using a new player GameObject rather than deactivating and moving to a respawn
    point
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新的玩家 GameObject 而不是禁用并移动到重生点
- en: 'Instead of resetting the character''s transform settings, you could have destroyed
    its GameObject and instantiated a new one over the respawn point using Tags. For
    an example of how to do this, check out Unity''s documentation: [http://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html](http://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是重置角色的变换设置，你可以销毁它的 GameObject，并在重生点使用标签实例化一个新的。例如，如何做到这一点，请参阅 Unity 的文档：[http://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html](http://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)
- en: Rotating the character's torso to aim a weapon
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将角色的身体旋转以瞄准武器
- en: 'When playing a Third-Person Character, you might want her to aim her weapon
    at a target that is not directly in front of her, without making her change direction.
    In this case, you will need to apply what is called a Procedural Animation, which
    does not rely on pre-made animation clips, but rather on the processing of other
    data, such as player input, to animate the character. In this recipe, we will
    use this technique to rotate the character''s spine by moving the mouse, allowing
    for adjustments in the character''s aim. We will also use this opportunity to
    cast a ray from the character''s weapon and display a crosshair over the nearest
    target. Please note that this approach will only work with cameras standing behind
    the third-person controlled characters:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当播放第三人称角色时，你可能希望她瞄准的目标不是直接在她面前，而无需改变她的方向。在这种情况下，你需要应用所谓的程序动画，它不依赖于预制的动画片段，而是依赖于其他数据的处理，例如玩家输入，以动画化角色。在这个菜谱中，我们将使用这种技术通过移动鼠标来旋转角色的脊柱，从而允许调整角色的瞄准。我们还将利用这个机会从角色的武器发射一条射线，并在最近的目标上显示准星。请注意，这种方法**仅适用于位于第三人称控制角色背后的相机**：
- en: '![](img/7b4e1c26-5a69-4201-8fe2-9a08f21ccc56.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b4e1c26-5a69-4201-8fe2-9a08f21ccc56.png)'
- en: Getting ready
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared a Unity Package named `AimPointer,` containing
    a basic scene that features an animated character. The package, which also includes
    the `crossAim` sprite to be used as a crosshair for aiming, can be found inside
    the `09_09` folder.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们准备了一个名为`AimPointer`的 Unity 包，其中包含一个具有动画角色的基本场景。该包还包括用作瞄准准星的`crossAim`精灵，可以在`09_09`文件夹中找到。
- en: How to do it...
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To rotate the character''s torso to aim a weapon, do the following:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 要旋转角色的躯干以瞄准武器，请执行以下操作：
- en: Create a new project and import the `AimPointer` Unity Package.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目并导入`AimPointer` Unity 包。
- en: Open the `mecanimPlayground` level. In the **Inspector** and **Scene** panels,
    you will see an animated character named **MsLaser** holding the **pointerPrefab**
    object.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`mecanimPlayground`级别。在**检查器**和**场景**面板中，你会看到一个名为**MsLaser**的动画角色，手持**pointerPrefab**对象。
- en: 'Create a new C# script-class named `MouseAim,` and add an instance-object as
    a component to the **MsLaser** GameObject:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 C# 脚本类名为`MouseAim`，并将实例对象作为组件添加到**MsLaser**游戏对象：
- en: '[PRE12]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the **Hierarchy,** create a new UI Image named Image-crosshair by choosing
    **Create** | **UI** | **Image****.**
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，通过选择**创建** | **UI** | **图像**来创建一个新的 UI 图像，命名为 Image-crosshair。
- en: 'In the **Inspector** for the Rect Transform component, set its Width and Height
    to 16 and populate the **Source Image** field with the `crossAim` sprite:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在矩形变换组件的**检查器**中，将其宽度和高度设置为16，并在**源图像**字段中填充`crossAim`精灵：
- en: '![](img/86d601c1-1cc0-4eb1-b0a2-e38e039819f3.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86d601c1-1cc0-4eb1-b0a2-e38e039819f3.png)'
- en: 'Select the **MsLaser** GameObject in the **Hierarchy,** and in the **Inspector**
    for the Mouse Aim component, populate the following:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择**MsLaser**游戏对象，并在鼠标瞄准组件的**检查器**中填充以下内容：
- en: 'Spine: `mixamorig:Spine` (in **MsLaser** | **mixamorigHips****)**'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脊柱：`mixamorig:Spine`（在**MsLaser** | **mixamorigHips**）
- en: 'Weapon: `pointerPrefab` (in **MsLaser|Hips|Spine|Spine1|Spine2|RightShoulder|Arm|ForeArm|Hand**)'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 武器：`pointerPrefab`（在**MsLaser|Hips|Spine|Spine1|Spine2|RightShoulder|Arm|ForeArm|Hand**）
- en: Crosshair: Image-crosshair GameObject
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准星：Image-crosshair 游戏对象
- en: '![](img/1d04192a-a3c9-4549-8a1f-993225b39756.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d04192a-a3c9-4549-8a1f-993225b39756.png)'
- en: Play the Scene. You will now be able to rotate the character's torso by moving
    the mouse. Even better, the Image-crosshair UI image will be displayed at the
    top of the object that is being aimed at by the pointer.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放场景。现在，你可以通过移动鼠标来旋转角色的躯干。更好的是，Image-crosshair UI 图像将显示在指针所指向的对象的顶部。
- en: How it works...
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You might have noticed that all the code invoked for rotating the character's
    spine is inside the `LateUpdate()` method, as opposed to the more common `Update()`
    method. The reason for this is to make sure that all the transform manipulation
    will be executed after the original animation clip is played, overriding it.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有用于旋转角色脊柱的代码都位于`LateUpdate()`方法内部，而不是更常见的`Update()`方法中。这样做的原因是为了确保所有的变换操作都会在原始动画片段播放之后执行，从而覆盖它。
- en: Regarding the spine rotation, our script adds the horizontal and vertical speed
    of the mouse to the xAxis and yAxis float variables. These variables are then
    constrained within the specified limits, avoiding distortions to the character's
    model. Finally, the spine object transform rotations for the x and y axes are
    set to xAxis and yAxis respectively. The z axis is preserved from the original
    Animation Clip.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 关于脊柱旋转，我们的脚本将鼠标的水平速度和垂直速度添加到xAxis和yAxis浮点变量中。然后，这些变量被限制在指定的范围内，避免对角色模型的扭曲。最后，将脊柱对象沿x轴和y轴的变换旋转设置为xAxis和yAxis。z轴保留原始动画剪辑中的原始值。
- en: Additionally, our script uses a Raycast command to detect whether there is an
    object's collider in the direction of the weapon's aim, in which case, a crosshair
    will be drawn on the screen.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的脚本使用射线投射命令来检测武器瞄准方向上是否存在物体的碰撞器，在这种情况下，屏幕上会显示一个准星。
- en: There's more...
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here are some ways to go further with this recipe.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些方法可以进一步改进这个菜谱。
- en: Generic solution for Cameras other than the Main Camera
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 针对除主摄像机之外的其他摄像机的通用解决方案
- en: Since this recipe's script was tailored for cameras standing behind third-person-controlled
    characters, we have included a more generic solution to the problem - in fact,
    a similar approach to the one presented in *Unity 4.x Cookbook, Packt Publishing*.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个菜谱的脚本是为站在第三人称控制角色背后的摄像机定制的，因此我们包括了一个更通用的解决方案来解决这个问题——实际上，与*Unity 4.x Cookbook,
    Packt Publishing*中提出的方法类似。
- en: An alternate script named `MouseAimLookAt,` which can be found inside the `09_09`
    folder, starts by converting our bi-dimensional mouse cursor screen's coordinates
    to three-dimensional world space coordinates (stored in a point variable). Then,
    it rotates the character's torso towards the point location, using the `LookAt()`
    command to do so. Additionally, it makes sure that the spine does not extrapolate
    minY and maxY angles, which would otherwise causing distortions to the character
    model.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为`MouseAimLookAt`的备用脚本，可以在`09_09`文件夹中找到，它首先将我们的二维鼠标光标屏幕坐标转换为三维世界空间坐标（存储在点变量中）。然后，它使用`LookAt()`命令将角色的身体旋转到点位置。此外，它确保脊柱不会外推minY和maxY角度，否则会导致角色模型的扭曲。
- en: Also, we have included a Compensation `YAngle` variable, which makes it possible
    for us to fine-tune the character's alignment with the mouse cursor. Another addition
    is the option to freeze the X-axis rotation, in case you just want the character
    to rotate their torso laterally but not look up or down. Again, this script uses
    a **Raycast** command to detect objects in front of the weapon, drawing a crosshair
    on the screen when they are present.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还包括了一个补偿`YAngle`变量，这使得我们可以微调角色与鼠标光标的对齐。另一个新增功能是冻结X轴旋转，以防你只想让角色横向旋转身体，而不想向上或向下看。同样，这个脚本使用射线投射命令来检测武器前方是否存在物体，当它们存在时，在屏幕上绘制一个准星。
- en: Creating geometry with Probuilder
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Probuilder创建几何形状
- en: A recent addition to the 3D Unity tools is **Probuilder,** which allows you
    to create and manipulate geometry inside the Unity Editor. Much more powerful
    than the existing **Terrain** editor, **Probuilder** allows you to create 3D Primitives
    and then manipulate them, such as by extruding or moving Vertices, Edges, or Faces,
    and then painting with colors or texturing with Materials.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 3D Unity工具的最新增项是**Probuilder**，它允许你在Unity编辑器内部创建和操作几何形状。比现有的**地形**编辑器更强大，**Probuilder**允许你创建3D原语，然后对其进行操作，例如通过拉伸或移动顶点、边缘或面积，然后使用颜色或材质进行着色或纹理化。
- en: In this recipe, we'll create some geometry that might be useful for an original
    game, or to add to a 3D Gamekit Scene (such as the Scene worked with in the following
    recipe).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一些可能对原创游戏或添加到3D Gamekit场景（如以下菜谱中使用的场景）有用的几何形状。
- en: 'If you''ve not used a 3D modeling package before (such as Blender, 3D Studio
    Max, or Maya), then it is well worth exploring the different features of **Probuilder.**
    You''ll learn key concepts, including the following:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有使用过3D建模软件（如Blender、3D Studio Max或Maya），那么探索**Probuilder**的不同功能是非常值得的。你将学习到关键概念，包括以下内容：
- en: 'Vertex: Point where lines touch—a corner where edges touch'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点：线条接触的点——边缘接触的角落
- en: 'Edges: Straight line between two vertices'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘：两个顶点之间的直线
- en: 'Faces: Flat 2D surfaces, usually a rectangle or triangular'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面积：平面的二维表面，通常是矩形或三角形
- en: Getting ready
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe uses the free Unity Asset Store and Package Manager packages.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱使用了免费的Unity Asset Store和包管理器包。
- en: How to do it...
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To create geometry with Probuilder, follow these steps:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Probuilder创建几何体，请按照以下步骤操作：
- en: Create a new Unity 3D project.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 3D项目。
- en: Use the **Package Manager** to install the **Probuilder** package.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**包管理器**安装**Probuilder**包。
- en: Display the **Probuilder** panel with **Tools** | **Probuilder** | **Window****.**
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过**工具** | **Probuilder** | **窗口**显示**Probuilder**面板。
- en: Dock the panel (next to the **Hierarchy** works well). Choose **Text Mode**
    or **Icon Mode**, as you prefer, via the right mouse button's context menu.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将面板（在**Hierarchy**旁边）停靠。通过右键鼠标的上下文菜单选择**文本模式**或**图标模式**，根据你的喜好。
- en: Create a new **Probuilder** Plane by clicking **New Shape** and choosing **Plane**
    from the **Shape Tool** window. Accept the default options and click the green
    **Build Plane** button.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**新建形状**并从**形状工具**窗口中选择**平面**来创建一个新的**Probuilder**平面。接受默认选项并点击绿色的**构建平面**按钮。
- en: With the new **Probuilder** Plane selected in the Hierarchy, you'll see the
    object selected in the Scene panel and its properties in the Inspector. We can
    see in the Inspector that, as well as its Transform, Mesh, and Mesh Renderer components,
    there are two special Probuilder components, `Pb_mesh_nnnnn` and `Pb_Object` (Script).
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择新的**Probuilder**平面，你将在场景面板中看到选中的对象及其属性。在检查器中，我们可以看到，除了其变换、网格和网格渲染器组件外，还有两个特殊的Probuilder组件，`Pb_mesh_nnnnn`和`Pb_Object`（脚本）。
- en: '`Pb_mesh_nnnnn` is a special component that stores the data for the 3D object
    mesh of this GameObject; this data can be edited in the **Scene** panel at design
    time. At runtime, a Unity Mesh is created based on this data.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pb_mesh_nnnnn`是一个特殊组件，用于存储该GameObject的3D对象网格数据；这些数据可以在设计时的**场景**面板中编辑。在运行时，基于这些数据创建一个Unity网格。'
- en: '![](img/bda71a43-8db9-43a3-97c7-b7d85f1181e7.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bda71a43-8db9-43a3-97c7-b7d85f1181e7.png)'
- en: 'Note that when a **Probuilder** GameObject is selected, there is a small **Probuilder**
    tool icon bar displayed in the Scene panel, allowing the Object, Vertex, Edge,
    and Face detection modes:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，当选择**Probuilder** GameObject时，场景面板中会显示一个小**Probuilder**工具图标栏，允许Object、Vertex、Edge和Face检测模式：
- en: '![](img/abae42b2-3862-4823-97c3-c76646b7b950.png)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/abae42b2-3862-4823-97c3-c76646b7b950.png)'
- en: 'Let''s make a depression in the middle of our Plane. Choose Face selection
    (the rightmost of the four **Probuilder** section icons), and using the Shift key
    for multiple section, select the four inner faces (selected faces turn Yellow).
    Then, use the Y-axis arrow to move these four selected faces downwards:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在平面的中间做一个凹陷。选择面选择（四个**Probuilder**部分图标中最右边的一个），并使用Shift键进行多部分选择，选择四个内部面（选中的面变为黄色）。然后，使用Y轴箭头将这些四个选中的面向下移动：
- en: '![](img/8d0411fb-5bb8-47ed-81e3-10a4772de6fb.png)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d0411fb-5bb8-47ed-81e3-10a4772de6fb.png)'
- en: Let's Vertex Paint some color on the object. This is easier to do carefully
    when there are more faces. First, in the Probuilder panel, click the Subdivide
    tool.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在物体上用Vertex Paint添加一些颜色。当物体有更多面时，这样做会更仔细。首先，在Probuilder面板中，点击Subdivide工具。
- en: 'Now, click Probuilder Vertex Colors +. The **Probuilder** Vertex Painter pop-up
    panel should be displayed. Click the red color and choose a darker red. Then,
    click the white square above your color to choose this dark red brush color. Make
    the brush size big (2 or 3), and paint all over the Plane to make it all dark
    red. Now, click the white square in the Vertex Painter panel to choose the yellow
    brush, and make the brush size smaller (say 1.5). Now, click on just the nine
    vertices in the middle of the depressed region of the Plane. Now, you should have
    a dark red Plane with yellow in the lower parts of it:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击Probuilder Vertex Colors +。应该会显示**Probuilder** Vertex Painter弹出面板。点击红色颜色并选择一个更深的红色。然后，点击你颜色上方的白色方块来选择这个深红色画笔颜色。将画笔大小调大（2或3），并将整个平面涂成深红色。现在，点击Vertex
    Painter面板中的白色方块来选择黄色画笔，并将画笔大小调小（比如1.5）。现在，点击平面下陷区域中间的九个顶点。现在，你应该有一个深红色的平面，其下部分为黄色：
- en: '![](img/373b51c4-9452-4f43-8ba9-9d5ba284879a.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/373b51c4-9452-4f43-8ba9-9d5ba284879a.png)'
- en: Save your Scene. Since the **Probuilder** Mesh data is stored in the Scene data,
    you'll lose all your Probuilder work if you forget to save your Scene.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的场景。由于**Probuilder**网格数据存储在场景数据中，如果你忘记保存场景，你将丢失所有的Probuilder工作。
- en: How it works...
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You've added the Probuilder package to a new 3D project and used the **Probuilder**
    tools panel to add a **Probuilder** mesh object to the Scene. You've used the
    face selection tool to allow you to select and then move some of the faces to
    create a depression. You then subdivided the object to give you more faces to
    work with for final detailed working. Finally, you learned to Vertex Paint with
    difference colors and brush sizes.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 您已将Probuilder包添加到新的3D项目中，并使用**Probuilder**工具面板将**Probuilder**网格对象添加到场景中。您已使用面选择工具来允许您选择并移动一些面以创建一个凹陷。然后您细分了对象，以便您有更多的面来为最终详细工作使用。最后，您学习了使用不同颜色和画笔大小的Vertex
    Paint。
- en: '**Probuilder** offers many more features, including creating object by drawing
    a line-by-line polygon and Texturing surfaces rather than just simple Vertex Painting.
    Learn more about **Probuilder** here:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '**Probuilder** 提供了许多更多功能，包括通过绘制线状多边形来创建对象以及纹理表面，而不仅仅是简单的Vertex Painting。在这里了解更多关于**Probuilder**的信息：'
- en: 'Unity Technology **Probuilder** documentation manual: [https://docs.unity3d.com/Packages/com.unity.probuilder@3.0/manual/index.html](https://docs.unity3d.com/Packages/com.unity.probuilder@3.0/manual/index.html)'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity Technology **Probuilder** 文档手册：[https://docs.unity3d.com/Packages/com.unity.probuilder@3.0/manual/index.html](https://docs.unity3d.com/Packages/com.unity.probuilder@3.0/manual/index.html)
- en: 'Unity Technology **Probuilder** videos: [https://www.youtube.com/user/Unity3D/search?query=Probuilder](https://www.youtube.com/user/Unity3D/search?query=Probuilder)'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity Technology **Probuilder** 视频：[https://www.youtube.com/user/Unity3D/search?query=Probuilder](https://www.youtube.com/user/Unity3D/search?query=Probuilder)
- en: Creating a game with the 3D Gamekit
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用3D Gamekit创建游戏
- en: 'A collection of Unity 3D tools has been combined to become the Unity 3D **GameKit**.
    In this recipe, we''ll create a new **Scene** and make use of some of the kit''s
    Prefabs and Scripts to illustrate how characters can interact with objects such
    as doors and pickups:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 将一系列Unity 3D工具组合在一起成为Unity 3D **GameKit**。在这个菜谱中，我们将创建一个新的**场景**并使用一些套件的预制件和脚本来说明角色如何与门和拾取等对象交互：
- en: '![](img/c41cfef5-dfc9-4a95-b2d9-fdb64a8c96aa.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c41cfef5-dfc9-4a95-b2d9-fdb64a8c96aa.png)'
- en: Getting ready
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe uses the free **Unity Asset Store** and **Package Manager** packages.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱使用了免费的**Unity Asset Store**和**包管理器**包。
- en: How to do it...
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a game with the 3D Gamekit, follow these steps:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用3D Gamekit创建游戏，请按照以下步骤操作：
- en: Create a new Unity 3D project.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 3D项目。
- en: 'Use the Package Manager to install the following packages (required by the
    3D GameKit):'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用包管理器安装以下包（3D GameKit所需）：
- en: Cinemachine
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cinemachine
- en: Post Processing (agree to the Quality Settings pop-up diaglog)
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后处理（同意质量设置弹出对话框）
- en: Probuilder
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Probuilder
- en: 'Import the **3D GameKit** (free from Unity Technologies) from the Asset Store:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从资产商店导入**3D GameKit**（来自Unity Technologies，免费）：
- en: '![](img/a82197e1-10a8-46fe-87bf-ee8e0f187c4a.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a82197e1-10a8-46fe-87bf-ee8e0f187c4a.png)'
- en: Agree to the Quality Settings pop-up diaglog. After a few minutes (in which
    it is setting up a project with lots of assets), you'll see a new folder in the
    Project panel named 3DGamekit.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同意质量设置弹出对话框。经过几分钟（在此期间，它正在设置一个包含大量资产的项目），您将在项目面板中看到一个名为3DGamekit的新文件夹。
- en: Close and then reopen the Unity Editor.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭并重新打开Unity编辑器。
- en: First, open the example **Scene** provided and explore the 3D world by controlling
    the 3D Ellen character.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开提供的示例**场景**，通过控制3D Ellen角色来探索3D世界。
- en: Movement is standard *WASD-SPACE*/arrow keys. Camera control is via the mouse
    pointer. Click the left mouse button to use a weapon.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 移动是标准的*WASD-SPACE*/箭头键。通过鼠标指针控制摄像机。点击左鼠标按钮使用武器。
- en: 'Create a new 3D **GameKit** Scene by choosing Kit Tools | Create New Scene.
    You''ll then be asked to name the **Scene**, and a new **Scene** asset file will
    be created in your Project | Assets folder. You''ll see there are quite a few
    special GameObjects in the Hierarchy of your new **Scene**:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择“工具”|“创建新场景”来创建一个新的3D **GameKit** 场景您将被要求命名**场景**，并在您的项目|资产文件夹中创建一个新的**场景**资产文件。您会看到在您新**场景**的层次结构中有很多特殊的GameObject：
- en: '![](img/d0ce5460-ef14-4600-b9e9-6682ec9d54e2.png)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0ce5460-ef14-4600-b9e9-6682ec9d54e2.png)'
- en: As you can see, the new **Scene** starts off containing an animated 3D character
    (Ellen) on a ProBuilder 3D Plane that forms the ground she is standing on.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，新的**场景**一开始就包含一个动画3D角色（Ellen）在一个ProBuilder 3D平面上，这个平面是她站立的地方。
- en: Add a small door in the Scene. Drag a clone of the DoorSmall Prefab from the
    Project panel (Assets | 3DGamekit | Prefabs | Interactables) into the middle of
    the 3D Plane **Scene**.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中添加一个小门。从项目面板（Assets | 3DGamekit | Prefabs | Interactables）拖动DoorSmall Prefab的副本到3D
    Plane **场景**的中间。
- en: Add a Crystal in the **Scene**, on the opposite side of the door from where
    the Ellen character starts. Drag a clone of the Crystal Prefab from the Project
    panel (Assets | 3DGamekit | Prefabs | Interactables) into the **Scene** behind
    the door.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景**中添加一个Crystal，位于门对面，Ellen角色开始的地方。从项目面板（Assets | 3DGamekit | Prefabs |
    Interactables）拖动Crystal Prefab的副本到门后面的**场景**中。
- en: 'Now, add some walls on either side of the door, so the door must be opened
    in order for Ellen to reach the Crystal. Drag two clones of Prefab Wall2x from
    the Project panel (Assets | 3DGamekit | Prefabs | Interactables) into the **Scene**:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在门的两侧添加一些墙壁，这样Ellen才能打开门才能到达Crystal。从项目面板（Assets | 3DGamekit | Prefabs |
    Interactables）拖动两个Prefab Wall2x的副本到**场景**中：
- en: '![](img/1224aa6b-91a4-4692-9184-2f984cc1f317.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1224aa6b-91a4-4692-9184-2f984cc1f317.png)'
- en: 'We now need to connect the PressurePad to the Door, so when Ellen steps on
    the PressurePad it sends a message to open the door. This is very straightforward,
    since the Door has a GameCommandReceiver component, which can be linked to the
    PressurePad''s Send on Trigger Enter (Script) component. Select the PressurePad
    GameObject in the Hierarchy and drag DoorSmall into the public Interactive Object
    slot of its Send on Trigger Enter (Script) component:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要将压力垫连接到门，这样当Ellen踏上压力垫时，它会发送一个打开门的信号。这非常直接，因为门有一个GameCommandReceiver组件，可以链接到压力垫的Send
    on Trigger Enter (Script)组件。在层次结构中选择PressurePad GameObject，并将其拖动到其Send on Trigger
    Enter (Script)组件的公共Interactive Object槽位中：
- en: '![](img/04421538-cb59-41b5-ba19-7f99f4658a55.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/04421538-cb59-41b5-ba19-7f99f4658a55.png)'
- en: Run the **Scene**. When Ellen steps onto the PressurePad, the Door should open.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行**场景**。当Ellen踏上压力垫时，门应该打开。
- en: We now need to make the Crystal collidable by adding a Box Collider. Add a Box
    Collider component to GameObject Crystal and check its On Trigger option.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要通过添加一个Box Collider来使Crystal可碰撞。将Box Collider组件添加到GameObject Crystal上，并检查其On
    Trigger选项。
- en: 'The **3D Gamekit** has inventory features. Let''s make the Crystal collectable
    by the player by adding an Inventory Item (Script) component. In the **Inspector**,
    click Add Component, then type inven and choose the Inventory Item scripted component.
    For that component, type Crystal as the name of the Inventory Key:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**3D Gamekit**具有库存功能。让我们通过添加一个Inventory Item (Script)组件来使Crystal可收集。在**检查器**中，点击添加组件，然后输入inven并选择Inventory
    Item脚本组件。对于该组件，输入Crystal作为库存键：'
- en: '![](img/cd5e7d90-f9fa-4f87-824d-9544e5c5d6cb.png)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd5e7d90-f9fa-4f87-824d-9544e5c5d6cb.png)'
- en: The Inventory Key names must match between the Inventory Object and the Inventory
    slot.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 库存对象和库存槽位之间的库存键名称必须匹配。
- en: Now, we can add an Inventory Controller (Script) component to Ellen, with a
    slot for a Crystal. In the Hierarchy, select the Ellen GameObject. In the **Inspector**,
    click Add Component, then type inven and choose the Inventory Item scripted component.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以向Ellen添加一个Inventory Controller (Script)组件，并为Crystal设置一个槽位。在层次结构中，选择Ellen
    GameObject。在**检查器**中，点击添加组件，然后输入inven并选择Inventory Item脚本组件。
- en: 'In the **Inspector**, we now need to configure the properties of the Inventory
    Controller (Script) component as follows:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，我们现在需要按照以下方式配置Inventory Controller (Script)组件的属性：
- en: Change the Size from `0` to `1`
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将大小从`0`改为`1`
- en: For its Key, type Crystal
  id: totrans-469
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于其键，输入Crystal
- en: For the On Add() events, click the plus sign, +, to create a new event.
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于On Add()事件，点击加号，+，以创建一个新事件。
- en: Drag Ellen into the Object slot for the new event (below Runtime Only).
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Ellen拖入新事件的对象槽位（下方为Runtime Only）。
- en: Change the function from No Function to InventoryController Add Item.
  id: totrans-472
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数从无功能更改为InventoryController Add Item。
- en: 'Finally, type the name of this item in the Inventory as Crystal:'
  id: totrans-473
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在库存中输入此物品的名称为Crystal：
- en: '![](img/6e3770da-70b6-4b32-8fda-ec00df5d6dad.png)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e3770da-70b6-4b32-8fda-ec00df5d6dad.png)'
- en: Run the **Scene**. Ellen can now open the Door via the **PressurePad** and walk
    into the Crystal, which is added to her inventory.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行**场景**。Ellen现在可以通过**压力垫**打开门并走进Crystal，Crystal被添加到她的库存中。
- en: How it works...
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have dipped our toes into the wide range of features of the **3D GameKit**.
    Hopefully, this recipe gave you an idea of how to work with the provided **Prefabs,**
    and how **3D Gamekit** components could be added to custom GameObjects.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涉猎了 **3D GameKit** 的广泛功能。希望这个菜谱能给你一个如何使用提供的 **预制件**，以及如何将 **3D Gamekit**
    组件添加到自定义 GameObject 的想法。
- en: 'Check out these links to learn more:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以获取更多信息：
- en: 'The 3DGamekit reference guide: [https://unity3d.com/learn/tutorials/projects/3d-game-kit/introduction-3d-reference-guide?playlist=51061](https://unity3d.com/learn/tutorials/projects/3d-game-kit/introduction-3d-reference-guide?playlist=51061)'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3DGamekit 参考指南：[https://unity3d.com/learn/tutorials/projects/3d-game-kit/introduction-3d-reference-guide?playlist=51061](https://unity3d.com/learn/tutorials/projects/3d-game-kit/introduction-3d-reference-guide?playlist=51061)
- en: 'The Unity 3DGamekit walkthrough pages: [https://unity3d.com/learn/tutorials/projects/3d-game-kit/introduction-walkthrough?playlist=51061](https://unity3d.com/learn/tutorials/projects/3d-game-kit/introduction-walkthrough?playlist=51061)'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 3DGamekit 演示页面：[https://unity3d.com/learn/tutorials/projects/3d-game-kit/introduction-walkthrough?playlist=51061](https://unity3d.com/learn/tutorials/projects/3d-game-kit/introduction-walkthrough?playlist=51061)
- en: 'Download the 3DGameKit, including a sample Scene, from the Asset Store: [https://assetstore.unity.com/packages/essentials/tutorial-projects/3d-game-kit-beta-115747?_ga=2.127077645.1823824032.1533576706-1834737598.1481552646](https://assetstore.unity.com/packages/essentials/tutorial-projects/3d-game-kit-beta-115747?_ga=2.127077645.1823824032.1533576706-1834737598.1481552646)'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从资产商店下载3DGameKit，包括一个示例场景：[https://assetstore.unity.com/packages/essentials/tutorial-projects/3d-game-kit-beta-115747?_ga=2.127077645.1823824032.1533576706-1834737598.1481552646](https://assetstore.unity.com/packages/essentials/tutorial-projects/3d-game-kit-beta-115747?_ga=2.127077645.1823824032.1533576706-1834737598.1481552646)
- en: Importing third-party 3D models and animations from Mixamo
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Mixamo 导入第三方 3D 模型和动画
- en: While there are many **3D models** and animations available and ready to use
    in Unity from the Asset Store, there are many more sources of 3D assets from third-party
    organisations. Mixamo (now part of Adobe) offers a fantastic range of characters
    and animations via their web-based system.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Unity资产商店中有许多现成的3D模型和动画可供使用，但来自第三方组织的3D资产来源还有很多。Mixamo（现在是Adobe的一部分）通过其基于网络的系统提供了一系列令人惊叹的角色和动画。
- en: 'In this recipe, we''ll select and download a character and some animations,
    formatting them for use with Unity and controlling the animations with an Animation
    Controller State Chart:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将选择并下载一个角色和一些动画，为使用Unity进行格式化，并使用动画控制器状态图来控制动画：
- en: '![](img/f4718f36-a89d-4b84-854d-a9457d4759cf.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4718f36-a89d-4b84-854d-a9457d4759cf.png)'
- en: Getting ready
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe uses the free Adobe Mixamo system, so you'll need to sign up for
    an account with them if you don't have one already.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱使用了免费的 Adobe Mixamo 系统，所以如果你还没有账户，你需要注册一个账户。
- en: How to do it...
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To import third-party **3D models** and animations from Mixamo, follow these
    steps:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Mixamo 导入第三方 **3D 模型** 和动画，请按照以下步骤操作：
- en: Open a web browser and visit [Mixamo.com](http://Mixamo.com).
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开网页浏览器并访问 [Mixamo.com](http://Mixamo.com)。
- en: Sign up/log in with your Mixamo/Adobe account.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的 Mixamo/Adobe 账户注册/登录。
- en: Select the Characters section (from navigation bar at top-left of web page)
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择左侧导航栏顶部的**角色**部分
- en: Select your character, such as Lola B Styperek. You'll see this character appear
    in the right-hand preview panel.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的角色，例如Lola B Styperek。你将在右侧预览面板中看到这个角色。
- en: 'Download your character, choosing FBX For Unity (.fbx) and T-pose:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载你的角色，选择 FBX For Unity (.fbx) 和 T-pose：
- en: '![](img/397a60b1-597c-4d9b-af3f-d5f1e83f9158.png)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![](img/397a60b1-597c-4d9b-af3f-d5f1e83f9158.png)'
- en: Create a new 3D Unity project, and in the Project panel create a folder named
    `Models`.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 3D Unity 项目，并在项目面板中创建一个名为 `Models` 的文件夹。
- en: Import the downloaded FBX file into the `Models` folder.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下载的 FBX 文件导入到 `Models` 文件夹。
- en: Select the asset file in the Project panel, and in the **Inspector** select
    the Materials section.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中选择资产文件，然后在**检查器**中选择材质部分。
- en: 'Click the Extract Textures... button and extract the model''s Textures into
    your `Models` folder. If asked to fix an issue with a Material using a Texture
    as a Normal Map, choose Fix Now:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 Extract Textures... 按钮，并将模型的纹理提取到你的 `Models` 文件夹。如果需要修复使用纹理作为法线图的材质问题，请选择
    Fix Now：
- en: '![](img/77520cdc-deb0-4abd-8235-2fd285ef3ccd.png)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77520cdc-deb0-4abd-8235-2fd285ef3ccd.png)'
- en: 'Drag the clone of the character from the Project panel into the **Scene**:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将角色克隆从项目面板拖动到**场景**：
- en: '![](img/68886c91-6df0-4d83-a425-af2e3c470839.png)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68886c91-6df0-4d83-a425-af2e3c470839.png)'
- en: We need an Animator Controller to manage animations. Create a new **Animator**
    Controller file in the Project panel named Lola-Animator-Controller.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个动画师控制器来管理动画。在项目面板中创建一个新的**动画师**控制器文件，命名为Lola-Animator-Controller。
- en: Select Lola B Styperek in the Hierarchy. In the **Inspector**, you'll see a
    Controller slot for the **Animator** component. Drag the Lola-Animator-Controller file from
    the Project panel into the Animator | Controller slot.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级中选择Lola B Styperek。在**检查器**中，你会看到一个**动画师**组件的控制器槽位。将Project面板中的Lola-Animator-Controller文件拖动到动画师
    | 控制器槽位中。
- en: 'Now, let''s animate this model. Go back to the [Mixamo.com](http://Mixamo.com)
    webpage and select an animation, such as Golf Drive. Click the Download button
    and choose these options:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为这个模型制作动画。回到[Mixamo.com](http://Mixamo.com)网页并选择一个动画，例如高尔夫挥杆。点击下载按钮并选择以下选项：
- en: 'Format: FBX for Unity (.fbx)'
  id: totrans-506
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式：Unity的FBX (.fbx)
- en: 'Frames per second: 30'
  id: totrans-507
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每秒帧数：30
- en: 'Skin: Without skin'
  id: totrans-508
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 皮肤：无皮肤
- en: 'Keyframe reduction: none'
  id: totrans-509
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键帧减少：无
- en: '![](img/3aa7162c-1935-448b-9c91-9cca66f9a239.png)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3aa7162c-1935-448b-9c91-9cca66f9a239.png)'
- en: Import the Animation Clip FBX file (lola_b_styperek@Golf Drive.fbx in this case)
    into the Animation folder of your Unity project.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将动画剪辑FBX文件（在本例中为lola_b_styperek@Golf Drive.fbx）导入到Unity项目的动画文件夹中。
- en: Double-click the Lola-Animator-Controller file to open the Animator (state machine)
    editor panel.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击Lola-Animator-Controller文件以打开动画师（状态机）编辑面板。
- en: 'Drag the Golf Drive Animation Clip into the **Animator** panel; it should appear
    as an orange state, with a Transition from Entry to it (that is, this one state
    becomes the default state):'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将高尔夫挥杆动画剪辑拖动到**动画师**面板中；它应该显示为橙色状态，并从进入状态转换到它（即，这个状态成为默认状态）：
- en: '![](img/1b2d65df-90ed-454c-a685-aedddadfbdaf.png)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b2d65df-90ed-454c-a685-aedddadfbdaf.png)'
- en: 'Run the **Scene**. You should now see Lola practicing her golf swing. If you
    have the character selected in the Hierarchy and can view the **Animator** panel,
    you''ll see that the Golf Swing Animation Clip (State) is playing:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行**场景**。你现在应该看到Lola在练习她的高尔夫挥杆。如果你在层级中选择了角色并且可以查看**动画师**面板，你会看到高尔夫挥杆动画剪辑（状态）正在播放：
- en: '![](img/6727d629-0207-4e43-874e-80cba29a5418.png)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6727d629-0207-4e43-874e-80cba29a5418.png)'
- en: How it works...
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Mixamo exports 3D rigged character models and **Animation Clips** in FBX format.
    The **Materials** for models are embedded in the FBX file, so we had to extract
    them once the model was imported into Unity.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: Mixamo导出FBX格式的3D绑定角色模型和**动画剪辑**。模型的**材质**嵌入在FBX文件中，因此我们在将模型导入Unity后必须提取它们。
- en: Unity controls the animation of models with an Animator Controller, so we had
    to create one for our character model and then drag in the Animation Clip we wished
    to use to animate our model.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: Unity使用动画师控制器控制模型的动画，因此我们必须为我们的人物模型创建一个，然后拖入我们希望用于动画模型的动画剪辑。
- en: There's more...
  id: totrans-520
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Here are some ways to go further with this recipe.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些进一步使用这个食谱的方法。
- en: Looping the animation
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画循环
- en: Select the Animation Clip in the Project panel, and in the **Inspector** check
    its Loop Time option, then click the Apply button to make the change to this asset
    file. When you run the **Scene**, Lola will now repeat the animation indefinitely.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目面板中选择动画剪辑，然后在**检查器**中检查其循环时间选项，然后点击**应用**按钮以将更改应用到这个资产文件。当你运行**场景**时，Lola现在将无限期地重复动画。
- en: Scripting events to control when Animation Clips are played
  id: totrans-524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写脚本事件以控制动画剪辑何时播放
- en: Additional Animation Clips can be added to the State Chart in the character's
    Animator Controller. You can then define variables and Triggers, to define when
    Animations Transition from one clip to another. Many of the recipes in this chapter
    illustrate ways to allow scripts to influence the Transition from one Animation
    Clip (State) to another.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在角色的动画师控制器中的状态图中添加额外的动画剪辑。然后你可以定义变量和触发器，以定义动画何时从一个剪辑（状态）转换到另一个剪辑。本章中的许多食谱说明了允许脚本影响一个动画剪辑（状态）到另一个动画剪辑（状态）转换的方法。
- en: Information sources about importing models and animations into Unity
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于将模型和动画导入Unity的信息来源
- en: 'Learn more about model and animation importing from the following:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下内容了解更多关于模型和动画导入的信息：
- en: 'Unity docs on importing **3D Models**: [https://docs.unity3d.com/Manual/HOWTO-importObject.html](https://docs.unity3d.com/Manual/HOWTO-importObject.html)'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity关于导入3D模型的文档：[https://docs.unity3d.com/Manual/HOWTO-importObject.html](https://docs.unity3d.com/Manual/HOWTO-importObject.html)
- en: 'Unity docs about the **Model Import Settings** window: [https://docs.unity3d.com/Manual/class-FBXImporter.html](https://docs.unity3d.com/Manual/class-FBXImporter.html)'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 关于 **模型导入设置** 窗口的文档：[https://docs.unity3d.com/Manual/class-FBXImporter.html](https://docs.unity3d.com/Manual/class-FBXImporter.html)
- en: 'Unity docs about the **Model** tab: [https://docs.unity3d.com/Manual/FBXImporter-Model.html](https://docs.unity3d.com/Manual/FBXImporter-Model.html)'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 关于 **模型** 选项卡的文档：[https://docs.unity3d.com/Manual/FBXImporter-Model.html](https://docs.unity3d.com/Manual/FBXImporter-Model.html)
- en: 'Unity docs about **Model** file formats: [https://docs.unity3d.com/Manual/3D-formats.html](https://docs.unity3d.com/Manual/3D-formats.html)'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 关于 **模型文件格式** 的文档：[https://docs.unity3d.com/Manual/3D-formats.html](https://docs.unity3d.com/Manual/3D-formats.html)
- en: 'Samples of **Mixamo** free assets in the **Asset Store**:'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mixamo** 免费资源在 **资源商店** 中的示例：'
- en: '[https://assetstore.unity.com/packages/3d/animations/melee-axe-pack-35320](https://assetstore.unity.com/packages/3d/animations/melee-axe-pack-35320)'
  id: totrans-533
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://assetstore.unity.com/packages/3d/animations/melee-axe-pack-35320](https://assetstore.unity.com/packages/3d/animations/melee-axe-pack-35320)'
- en: '[https://assetstore.unity.com/packages/3d/animations/magic-pack-36269](https://assetstore.unity.com/packages/3d/animations/magic-pack-36269)'
  id: totrans-534
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://assetstore.unity.com/packages/3d/animations/magic-pack-36269](https://assetstore.unity.com/packages/3d/animations/magic-pack-36269)'
