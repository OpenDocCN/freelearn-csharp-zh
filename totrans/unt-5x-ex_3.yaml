- en: Chapter 3. Project B – the Space Shooter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter enters new territory now as we begin development work on our second
    game, which is a twin-stick space shooter. The twin-stick genre simply refers
    to any game in which the player input for motion spans two dimensions or axes,
    typically one axis for movement and one for rotation. Example twin-stick games
    include *Zombies Ate My Neighbors* and *Geometry Wars*. Our game will rely heavily
    on coding in C#, as we''ll see. The primary purpose of this is to demonstrate
    by example just how much can be achieved with Unity procedurally (that is, via
    script), even without using the editor and level-building tools. We''ll still
    use these tools to some extent but not as much here, and that''s a deliberate
    and not an accidental move. Consequently, this chapter assumes that you have not
    only completed the game project created in the previous two chapters, but also
    have a good, basic knowledge of C# scripting generally, though not necessarily
    in Unity. So, let''s roll up our sleeves, if we have any, and get stuck in making
    a twin-stick shooter. This chapter covers the following important topics as well
    as others:'
  prefs: []
  type: TYPE_NORMAL
- en: Spawning and prefabs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twin-stick controls and axial movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Player controllers and shooting mechanics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic enemy movement and AI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to see the game created here, and its related work, in abstract terms,
    that is, as general tools and concepts with multiple applications. For your own
    projects, you may not want to make a twin-stick shooter, and that's fine. I cannot
    possibly know every kind of game that you want to make. However, it's important
    to see the ideas and tools used here as being transferrable, as being the kind
    of things you can creatively use for your own games. Being able to see this is
    very important when working with Unity or any engine.
  prefs: []
  type: TYPE_NORMAL
- en: Looking ahead – the completed project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before getting stuck in with the twin-stick shooter game, let's see what the
    completed project looks like and how it works. See *Figure 3.1*. The game to be
    created will contain one scene only. In this scene, the player controls a spaceship
    that can shoot oncoming enemies. The directional keyboard arrows, and WASD, move
    the spaceship around the level, and it will always turn to face the mouse pointer.
    Clicking the left mouse button will fire ammo.
  prefs: []
  type: TYPE_NORMAL
- en: '![Looking ahead – the completed project](img/B05118_03_01.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: The completed twin-stick shooter game'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The completed `TwinStickShooter` project, as discussed in this chapter and the
    next, can be found in the book companion files in the `Chapter03/TwinStickShooter
    folder`.
  prefs: []
  type: TYPE_NORMAL
- en: Most assets for this game (including sound and textures) were sourced from the
    freely accessible site, [OpenGameArt.org](http://OpenGameArt.org). Here, you can
    find many game assets available through the public domain or creative common licenses
    or other licenses.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with a space shooter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, create a blank Unity 3D project without any packages or specific
    assets. Details about creating new projects can be found in [Chapter 1](ch01.html
    "Chapter 1. The Coin Collection Game – Part 1"), *The Coin Collection Game – Part
    1*. We''ll be coding everything from scratch this time around. Once a project
    is generated, create some basic folders to structure and organize the project
    assets from the outset. This is very important to keep track of your files as
    you work. Create folders for `Textures`, `Scenes`, `Materials`, `Audio`, `Prefabs`,
    and `Scripts`. See *Figure 3.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with a space shooter](img/B05118_03_02.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Create folders for structure and organization'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, our game will depend on some graphical and audio assets. These are included
    in the book companion files in the `Chapter03/Assets` folder, but can also be
    downloaded online from [OpenGameArt.org](http://OpenGameArt.org). Let''s start
    with textures for the player spaceship, enemy spaceships, and star-field background.
    Drag and drop `Textures` from Windows Explorer or Finder to the Unity **Project**
    panel in the `Textures` folder. Unity imports and configures the textures automatically.
    *See Figure 3.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with a space shooter](img/B05118_03_03.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Importing Texture assets for the spaceship, enemies, star background,
    and ammo'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use of the provided assets is optional. You can create your own if you prefer.
    Just drag and drop your own textures in place of the included assets, and you
    can still follow along with the tutorial just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Unity imports image files as regular textures for use on 3D objects,
    and it assumes that their pixel dimensions are a power-2 size (4, 8, 16, 32, 64,
    128, 256, and so on). If the size is not actually one of these, then Unity will
    up-scale or down-scale the texture to the nearest valid size. This is not appropriate
    behavior, however, for a 2D top-down space shooter game in which imported textures
    should appear at their native (imported) size without any scaling or automatic
    adjustment. To fix this, select all the imported textures and, from the **Object
    Inspector**, change their **Texture Type** from **Texture** to **Sprite (2D and
    UI)**. Once changed, click on the **Apply** button to update the settings and
    the textures will retain their imported dimensions. See *Figure 3.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with a space shooter](img/B05118_03_04.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Changing the Texture type for imported textures'
  prefs: []
  type: TYPE_NORMAL
- en: 'After changing the **Texture Type** setting to **Sprite (2D and UI)**, also
    remove the check mark from the **Generate Mip Maps** box, in case this box is
    enabled. This will prevent Unity from automatically downgrading the quality of
    textures based on their distance from the camera in the scene. This ensures that
    your textures retain their highest quality. More information on 2D texture settings
    and Mip Maps can be found at the online Unity documentationat [http://docs.unity3d.com/Manual/class-TextureImporter.html](http://docs.unity3d.com/Manual/class-TextureImporter.html).
    *See Figure 3.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with a space shooter](img/B05118_03_05.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: Removing MipMapping from imported textures'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can easily drag and drop your textures to the scene adding them as
    sprite objects. You can''t drag and drop them from the **Project** panel to the
    viewport, but you can drag and drop them from the **Project** panel to the **Hierarchy**
    panel. When you do this, the texture will automatically be added as a sprite object
    in the **Scene**. We''ll make frequent use of this feature as we work at creating
    spaceship objects. See *Figure 3.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with a space shooter](img/B05118_03_06.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Adding sprites to the scene'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s import music and sound effects, which are also included in the
    book companion files in the `Chapter03/Assets/Audio` folder. These assets were
    downloaded from [OpenGameArt.org](http://OpenGameArt.org). To import the audio,
    simply drag and drop the files from Windows Explorer or Mac Finder to the **Project**
    panel. When you do this, Unity automatically imports and configures the assets.
    You can give the audio a test from within the Unity Editor by pressing play on
    the preview toolbar from the **Object Inspector**. See *Figure 3.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with a space shooter](img/B05118_03_07.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: Previewing audio from the Object Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with texture files, Unity imports audio files using a set of default parameters.
    These parameters are typically suitable for short sound effects such as footsteps,
    gunshots, and explosions, but for longer tracks such as music, they can be problematic,
    causing long level-loading times. To fix this, select the music track in the **Project**
    panel, and from the **Object Inspector**, disable the **Preload Audio Data** checkbox.
    From the **Load Type** drop-down box, select the **Streaming** option. This ensures
    that the music track is streamed as opposed to loaded wholly in memory at level
    startup. See *Figure 3.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with a space shooter](img/B05118_03_08.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: Configuring music tracks for streaming'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a player object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve now imported most assets for the twin-stick shooter and we''re ready
    to create a player spaceship object, that is, the object that the player will
    control and move around. Creating this might seem a trivial matter of simply dragging
    and dropping the relevant player sprite from the **Project** panel to the scene,
    but things are not so simple. The player is a complex object with many different
    behaviors, as we''ll see. For this reason, more care needs to be taken about creating
    the player. To get started, create an empty game object in the scene by navigating
    to **GameObject** | **Create Empty** from the application menu and name the object,
    `Player`. See *Figure 3.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player object](img/B05118_03_09.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Starting to create the player'
  prefs: []
  type: TYPE_NORMAL
- en: 'The newly created object may or may not be centered at the world origin of
    *(0, 0, 0)* and its rotation properties may not be consistently `0` across **X**,
    **Y**, and **Z**. To ensure a completely zeroed transform, you could manually
    set the values to `0` by entering them directly in the **Transform** component
    for the object in the **Object Inspector**. However, you can set them all to `0`
    automatically by clicking on the cog icon at the top left corner of the **Transform**
    component and selecting **Reset** from the context menu. See *Figure 3.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player object](img/B05118_03_10.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Resetting the Transform component'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, drag and drop the `Player` drop ship sprite (in the `Textures` folder)
    from the **Project** panel to the **Hierarchy** panel, making it a child of the
    empty player object. Then, rotate the drop ship sprite by `90` degrees in **X**
    and `-90` degrees in **Y**. This makes the sprite oriented in the direction of
    its parent''s forward vector and also flattened on the ground plane. The game
    camera will take a top-down view. See *Figure 3.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player object](img/B05118_03_11.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: Aligning the Player ship'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can confirm that the ship sprite has been aligned correctly in relation
    to its parent by selecting the `Player` object and viewing the blue forward vector
    arrow. The front of the ship sprite and the blue forward vector should be pointing
    in the same direction. If they''re not, then continue to rotate the sprite by
    90 degrees until they''re in alignment. This will be important later when coding
    player movement to make the ship travel in the direction it''s looking. See *Figure
    3.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player object](img/B05118_03_12.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.12: The blue arrow is called the forward vector'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `Player` object should react to physics, that is, the `Player` object
    is solid and affected by physical forces. It must collide with other solids and
    also take damage from enemy ammo when hit. To facilitate this, two additional
    components should be added to the `Player` object, specifically, a **Rigidbody**
    and **Collider**. To do this, select the `Player` object (not the `Sprite` object)
    and navigate to **Component** | **Physics** | **Rigidbody** from the application
    menu. Then, choose `Component` | **Physics** | **Capsule Collider** from the menu.
    This adds both a **Rigidbody** and **Collider**. See *Figure 3.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player object](img/B05118_03_13.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.13: Adding a Rigidbody and Capsule Collider to the Player object'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Collider** component is used to approximate the volume of the object
    and the **Rigibody** component uses the **Collider** to determine how physical
    forces should be applied realistically. Let''s adjust **Capsule Collider** a little
    because the default settings typically do not match up with the `Player` sprite
    as intended. Specifically, adjust the **Direction**, **Radius**, and **Height**
    values until **Capsule** encompasses the `Player` sprite and represents the volume
    of the player. See *Figure 3.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player object](img/B05118_03_14.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.14: Adjusting the spaceship Capsule Collider'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `Rigidbody` component is configured to approximate objects
    that are affected by gravity and fall to the ground, bumping into and reacting
    to other solids in the scene. This is not appropriate for a spaceship that flies
    around. Consequently, the `Rigidbody` should be adjusted. Specifically, remove
    the **Use Gravity** check mark to prevent the object from falling to the ground.
    Additionally, enable the **Freeze Position** **Y** checkbox and the **Freeze Rotation**
    **Z** checkbox to prevent the spaceship moving and rotating around axes that are
    undesirable in a 2D top-down game. See *Figure 3.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a player object](img/B05118_03_15.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.15: Configuring the Rigidbody component for the player spaceship'
  prefs: []
  type: TYPE_NORMAL
- en: Excellent work! We've now configured the player spaceship object successfully.
    Of course, it still doesn't move or do anything specific in the game. This is
    simply because we haven't added any code yet. That's something we'll turn to next—making
    the player object respond to user input.
  prefs: []
  type: TYPE_NORMAL
- en: Player input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Player` object is now created in the scene, configured with both **Rigidbody**
    and **Collider** components. However, this object doesn''t respond to player controls.
    In a twin-stick shooter, the player provides input on two axes and can typically
    shoot a weapon. This often means that keyboard WASD buttons guide player movements
    up, down, left, and right. In addition, mouse movement controls the direction
    in which the player is looking and aiming and the left mouse button typically
    fires a weapon. This is the control scheme required for our game. To implement
    this, we''ll need to create a `PlayerController` script file. Right-click on the
    `Scripts` folder of the **Project** panel and create a new C# script file named
    `PlayerController.cs`. See *Figure 3.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Player input](img/B05118_03_16.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.16: Creating a player controller C# script file'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PlayerController.cs` script file, the following code (as shown in *Code
    Sample 3.1*) should be featured. Comments follow this sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 3.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayerController` class should be attached to the `Player` object in the
    scene. Overall, it accepts input from the player and will control the movement
    of the spaceship.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Awake` function is called once when the object is created at the level
    start. During this function, two components are retrieved, namely, the **Transform**
    component for controller player rotation and the **Rigidbody** component for controller
    player movement. The **Transform** component can be used to control player movement
    through the **Position** property, but this ignores collisions and solid objects.
    The **Rigidbody** component, in contrast, prevents the player object from passing
    through other solids.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `FixedUpdate` function is called once on each update of the physics system,
    which is a fixed number of times per second. `FixedUpdate` differs from `Update`,
    which is called once per frame and can vary on a per second basis as the frame
    rate fluctuates. If you ever need to control an object through the physics system,
    using components such as **Rigidbody**, then you should always do so in `FixedUpdate`
    and not `Update`. This is a Unity convention that you should remember for best
    results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Input.GetAxis` function is called on each `FixedUpdate` to read the axial
    input data from an input device, such as the keyboard or gamepad. This function
    reads from two named axes, `Horizontal` (left-right) and `Vertical` (up-down).
    These work in a normalized space of *-1* to *1*. This means that when the left
    key is pressed and held down, the `Horizontal` axis returns *-1* and, when the
    right key is being pressed and held down, the `Horizontal` axis returns *1*. A
    value of *0* indicates that either no relevant key is being pressed or both left
    and right are being pressed together, canceling each other out. A similar principle
    applies for the `Vertical` axis. Up refers to *1*, down to *-1*, and no keypress
    relates to *0*. More information on the `GetAxis` function can be found online
    in the Unity documentation at [http://docs.unity3d.com/ScriptReference/Input.GetAxis.html](http://docs.unity3d.com/ScriptReference/Input.GetAxis.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Rigidbody.AddForce` function is used to apply a physical force to the `Player`
    object, moving it in a specific direction. `AddForce` encodes a velocity, moving
    the object in a specific direction by a specific strength. The direction is encoded
    in the `MoveDirection` vector, which is based on player input from both the `Horizontal`
    and `Vertical` axes. This direction is multiplied by our maximum speed to ensure
    that the object travels as fast as needed. For more information on `AddForce`,
    see the online Unity documentation at [http://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html](http://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Camera.ScreenToWorldPoint` function is used to convert the screen position
    of the mouse cursor in the game window into a position in the game world, giving
    the player a target destination to look at. This code is responsible for making
    the player look at the mouse cursor always. However, as we'll see soon, some further
    tweaking is required to make this code work properly. For more information on
    `ScreenToWorldPoint`, see the Unity online documentation at [http://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html](http://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the game camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding code allows you to control the `Player` object, but there are
    some problems. One of them is that the player doesn''t seem to face the position
    of the mouse cursor, even though our code is designed to achieve this behavior.
    The reason is that the camera, by default, is not configured as it needs to be
    for a top-down 2D game. We''ll fix this in this section. To get started, the scene
    camera should have a top-down view of the scene. To achieve this, switch the **Scene**
    viewport to a top-down 2D view by clicking on the **ViewCube**, the up arrow in
    the top right corner of the **Scene** viewport. This switches your viewport to
    a top view. See *Figure 3.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the game camera](img/B05118_03_17.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.17: The viewcube can change the viewport perspective'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that the viewport is in a top view because the viewcube will list
    **Top** as the current view. See *Figure 3.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the game camera](img/B05118_03_18.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.18: Top view in the Scene viewport'
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, you can have the scene camera conform to the viewport camera exactly,
    giving you an instant top-down view for your game. To do this, select the **Camera**
    in the **Scene** (or from the **Hierarchy** panel) and then choose **GameObject**
    | **Align With View** from the application menu. See *Figure 3.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the game camera](img/B05118_03_19.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.19: Aligning the camera to the Scene viewport'
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes your game look much better than before, but there''s still a problem.
    When the game is running, the spaceship still doesn''t look at the mouse cursor
    as intended. This is because the camera is a **Perspective** camera and the conversion
    between a screen point and world point is leading to unexpected results. We can
    fix this by changing the camera to an **Orthographic** camera, which is a truly
    2D camera that allows no perspective distortion. To do this, select the **Camera**
    in the scene, and from the **Object Inspector**, change the **Projection** setting
    from **Perspective** to **Orthographic**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the game camera](img/B05118_03_20.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.20: Changing the Camera to Orthographic mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every orthographic camera has a **Size** field in the **Object Inspector**,
    which is not present for perspective cameras. This field controls how many units
    in the world view correspond to pixels on the screen. We want a 1:1 ratio or relationship
    between world units to pixels in order to ensure that our textures appear at the
    correct size and cursor movement has the intended effect. The target resolution
    for our game will be Full HD, which is 1920 x 1080, and this has an aspect ratio
    of 16:9\. For this resolution, the orthographic **Size** should be `5.4`. The
    reasons for this value are beyond the scope of this book, but the formula to arrive
    at it is *screen height (in pixels) / 2 / 100*. Therefore, *1080 / 2 / 100 = 5.4*.
    See *Figure 3.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the game camera](img/B05118_03_21.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.21: Changing orthographic size for a 1:1 pixel-to-screen ratio'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, make sure that your **Game** tab view is configured to display the
    game at a **16:9** aspect ratio. If it isn''t, click on the aspect drop-down list
    at the top left corner of the **Game** view and choose the **16:9** option. See
    *Figure 3.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the game camera](img/B05118_03_22.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.22: Displaying the game at a 16:9 aspect ratio'
  prefs: []
  type: TYPE_NORMAL
- en: Now try running the game, and you have a player spaceship that moves based on
    WASD input and also turns to face the mouse cursor. Great work! See *Figure 3.23*.
    The game is really taking shape. However, there's lots more work to do.
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the game camera](img/B05118_03_23.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.23: Turning to face the cursor!'
  prefs: []
  type: TYPE_NORMAL
- en: Bounds locking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On previewing the game thus far, the spaceship probably looks too large. We
    can fix this easily by changing the scale of the `Player` object. I've used a
    value of `0.5` for the **X**, **Y**, and **Z** axes. See *Figure 3.24*. However,
    even with a more sensible scale, a problem remains. Specifically, it's possible
    to move the player outside the boundaries of the screen without limit. This means
    that the player can fly off into the distance, out of view, and never be seen
    again. Instead, the camera should remain still and the player movement should
    be limited to the camera view or bounds so that it never exits the view.
  prefs: []
  type: TYPE_NORMAL
- en: '![Bounds locking](img/B05118_03_24.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.24: Rescaling the player'
  prefs: []
  type: TYPE_NORMAL
- en: There are different ways to achieve bounds locking, most of which involve scripting.
    One way is to simply clamp the positional values of the `Player` object between
    a specified range, a minimum and maximum. Consider *Code Sample 3.2* for a new
    C# class called `BoundsLock`. This script file should be attached to the player.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 3.2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `LateUpdate` function is always called after all the `FixedUpdate` and `Update`
    calls, allowing an object to modify its position before it's rendered to the screen.
    More information on `LateUpdate` can be found at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Mathf.Clamp` function ensures that a specified value is capped between
    a minimum and maximum range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use the `BoundsLock` script, simply drag and drop the file to the `Player`
    object and specify minimum and maximum values for its position. These values are
    specified in world position coordinates and can be determined by temporarily moving
    the `Player` object to the camera extremes and recording its position from the
    **Transform** component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Code Sample 3.2](img/B05118_03_25.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.25: Setting Bounds Lock'
  prefs: []
  type: TYPE_NORMAL
- en: Now take the game for a test run by pressing play on the toolbar. The player
    spaceship should remain in view and be unable to move offscreen. Splendid!
  prefs: []
  type: TYPE_NORMAL
- en: Health
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both the player spaceship and enemies need health. Health is a measure of a
    character''s presence and legitimacy in the scene, typically scored as a value
    between 0-100\. 0 means death and 100 means full health. Now, although health
    is, in many respects, specific to each instance, (The player has a unique health
    bar and each enemy has theirs.) there are nevertheless so many things in common,
    in terms of behavior, between player and enemy health that it makes sense to code
    health as a separate component and class that can be attached to all objects that
    need health. Consider *Code Sample 3.3*, which should be attached to the player
    and all enemies or objects that need health. Comments follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 3.3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Health` class maintains object health through a `private` variable, `_HealthPoints`,
    which is accessed through a C# property, `HealthPoints`. This property features
    both `get` and `set` accessors to return and set the `Health` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `_HealthPoints` variable is declared as `SerializedField`, allowing its
    value to be visible in the **Inspector**. This helps us see the value of the player's
    health during runtime and debug and test the effects of our code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Health` class is an example of event-driven programming. This is because
    the class could have continually checked the status of object health during an
    `Update` function; checking to see whether the object had died by its health falling
    below *0*. Instead, the check for death is made during the C# property `set` method.
    This makes sense because `set` is the only place where health will ever change.
    This means that Unity is saved from a lot of work in each frame. That's great
    performance saving!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Health` class uses the `SendMessage` function. This function lets you call
    any other public function on any component attached to the object by specifying
    the function name as a string. In this case, a function called `Die` will be executed
    on every component attached to the object (if such a function exists). If no function
    of a matching name exists, then nothing happens for that component. This is a
    quick and easy way to run customized behavior on an object in a type-agnostic
    way without using any polymorphism. The disadvantage is that `SendMessage` internally
    uses a process called `Reflection`, which is slow and performance-prohibitive.
    For this reason, `SendMessage` should be used infrequently only for death events
    and similar events, but not frequently, such as every frame. More information
    on `SendMessage` can be found at the online Unity documentation at [http://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html](http://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When health falls below *0*, triggering a death condition, the code will instantiate
    a death particle system to show an effect on death if a particle system is specified
    (more on this shortly).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the `Health` script is attached to the player spaceship, it appears as
    a component in the **Inspector**. It contains a field for a **Death Particles
    Prefab**. This is an optional field (it can be null), specifying a particle system
    to be spawned when the object dies. This lets you create explosions or blood splatter
    effects easily when objects die. See *Figure 3.26*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 3.3](img/B05118_03_26.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.26: Attaching the Health script'
  prefs: []
  type: TYPE_NORMAL
- en: Death and particles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this twin-stick shooter game, both the player and enemies are spaceships.
    When they''re destroyed, they should explode in a fiery ball. This is really the
    only kind of effect that would be believable. To achieve explosions, we can use
    a particle system. This simply refers to a special kind of object that features
    two main parts, namely, a **Hose** (or **Emitter**) and **Particles**. The emitter
    refers to the part that spawns or generates new particles into the world and the
    particles are many small objects or pieces that, once spawned, move and travel
    along their own trajectories. In short, particle systems are ideal to create rain,
    snow, fog, sparkles, and explosions. We can create our own Particle Systems from
    scratch using the menu option, **GameObject** | **Particle System**, or we can
    use any premade particle system included with Unity. Let''s use some of the premade
    particle systems. To do this, import the `ParticleSystems` package to the project
    by navigating to **Assets** | **Import Package** | **ParticleSystems** from the
    application menu. See *Figure 3.27*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Death and particles](img/B05118_03_27.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.27: Importing Particle Systems to the project'
  prefs: []
  type: TYPE_NORMAL
- en: After the **Import** dialog appears, leave all settings at their defaults, and
    simply click on **Import** to import the complete package, including all particle
    systems. The `ParticleSystems` will be added to the **Project** panel in the `Standard
    Assets` | `ParticleSystems` | `Prefabs` folder. See *Figure 3.28*. You can test
    each of the particle systems by simply dragging and dropping each prefab to the
    scene. Note that you can only preview a particle system in the **Scene** viewport
    while it is selected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Death and particles](img/B05118_03_28.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.28: Particle Systems imported to the Project panel'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice from *Figure 3.28* that an **Explosion** system is included among the
    default assets, which is great news! To test, we can just drag and drop the explosion
    to the scene, press play on the toolbar, and see the explosion in action. Good!
    We''re almost done, but there''s still a bit more work. We''ve now seen that an
    appropriate particle system is available and we could just drag and drop this
    system to the **Death Particles Prefab** slot in the **Health** component in the
    **Inspector**. This will work technically: when a player or enemy dies, the explosion
    system will be spawned, creating an explosion effect. However, the particle system
    will never be destroyed! This is problematic because, on each enemy death, a new
    particle system will be spawned. This raises the possibility that, after many
    deaths, the scene will be full of disused particle systems. We don''t want this;
    it''s bad for performance and memory usage to have a scene full of unused objects
    lingering around. To fix this, we''ll modify the explosion system slightly, creating
    a new and modified prefab that''ll suit our needs. To create this, drag and drop
    the existing explosion system anywhere to the scene and position it at the world
    origin. See *Figure 3.29*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Death and particles](img/B05118_03_29.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.29: Adding an Explosion system to the scene for modification'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must refine the particle system to destroy itself soon after instantiation.
    By making a prefab from this arrangement, each and every generated explosion will
    eventually destroy itself. To make an object destroy itself after a specified
    interval, we''ll create a new C# script. I''ll name this script `TimeDestroy.cs`.
    Refer the following code in *Code Sample 3.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 3.4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `TimeDestroy` class simply destroys the object to which it's attached after
    a specified interval (`DestroyTime`) has elapsed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Invoke` function is called in the `Start` event. Invoke will execute a
    function of the specified name once, and only once, after a specified interval
    has elapsed. The interval is measured in seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like `SendMessage`, the `Invoke` function relies on `Reflection`. For this reason,
    it should be used sparingly for best performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Die` function will be executed by `Invoke` after a specified interval to
    destroy the `gameobject` (such as a particle system).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, drag and drop the `TimedDestroy` script file to the explosion particle
    system in the scene and then press play on the toolbar to test that the code works
    and the object is destroyed after the specified interval, which can be adjusted
    from the **Inspector**. See *Figure 3.30*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 3.4](img/B05118_03_30.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.30: Adding a TimeDestroy script to an explosion Particle System'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TimeDestroy` script should remove the explosion particle system after
    the delay expires. So let''s create a new and separate prefab from this modified
    version. To do this, rename the explosion system in the **Hierarchy** panel to
    `ExplosionDestroy`, and then drag and drop the system from the **Hierarchy** to
    the **Project** panel in the `Prefabs` folder. Unity automatically creates a new
    prefab, representing the modified particle system. See *Figure 3.31*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 3.4](img/B05118_03_31.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.31: Create a timed explosion prefab'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, drag and drop the newly created prefab from the **Project** panel to the
    **Death Particle System** slot on the **Health** component for the **Player**
    in the **Object Inspector**. This ensures that the prefab is instantiated when
    the player dies. See *Figure 3.32*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 3.4](img/B05118_03_32.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.32: Configuring the health script'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the game now, you''ll see that you cannot initiate a player death
    event to test the particle system generation. Nothing exists in the scene to destroy
    or damage the player, and you cannot manually set the **Health** points to `0`
    from the **Inspector** in a way that is detected by the C# property `set` function.
    For now, however, we can insert some test death functionality into the `Health`
    script that triggers an instant kill when the spacebar is pressed. Refer to *Code
    Sample 3.5* for the modified `Health` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'On running the game now, with the modified `Health` script, you can trigger
    an instant player death by pressing the spacebar key on the keyboard. When you
    do this, the player object is destroyed and the particle system is generated until
    the timer destroys that too. Excellent work! We now have a playable, controllable
    player character that supports health and death functionality. Things are looking
    good. See *Figure 3.33*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 3.4](img/B05118_03_33.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.33: Trigger the Explosion particle system'
  prefs: []
  type: TYPE_NORMAL
- en: Enemies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to create something for the player to shoot and destroy, which
    can also destroy us, namely, enemy characters. These take the form of roaming
    spaceships that will be spawned into the scene at regular intervals and will follow
    the player, drawing nearer and nearer. Essentially, each enemy represents a complex
    of multiple behaviors working together and these should be implemented as separate
    scripts. Let''s consider them in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Health**: Each enemy supports health functionality. They begin the scene
    with a specified amount of health and will be destroyed when that health falls
    below *0*. We already have a `Health` script created to handle this behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Movement**: Each enemy will constantly be in motion, traveling in a straight
    line along a forward trajectory. That is, each enemy will continually travel forward
    in the direction it is looking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Turning**: Each enemy will rotate and turn toward the player even when the
    player moves. This ensures that the enemy always faces the player and, in combination
    with the movement functionality, will always be traveling toward the player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scoring**: Each enemy rewards the player with a score value when destroyed.
    Thus, the death of an enemy will increase the player score.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Damage**: Each enemy causes damage to the player on collision. Enemies cannot
    shoot but will harm the player on proximity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we''ve identified the range of behaviors applicable to an enemy, let''s
    create an enemy in the scene. We''ll make one specific enemy, create a prefab
    from that, and use it as the basis to instantiate many enemies. Start by selecting
    the player character in the scene and duplicate the object with *Ctrl* + **D**
    or select **Edit** | **Duplicate** from the application menu. This initially creates
    a second player. See *Figure 3.34*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enemies](img/B05118_03_34.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.34: Duplicating the Player object'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rename the object to `Enemy` and ensure that it is not tagged as `Player`,
    as there should be one and only one object in the scene with the `Player` tag,
    namely, the real player. In addition, temporarily disable the `Player` game object,
    allowing us to focus more clearly on the `Enemy` object in the **Scene** tab.
    See *Figure 3.35*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enemies](img/B05118_03_35.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.35: Removing a Player tag from the enemy, if applicable'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the sprite child object of the duplicated enemy, and from the **Object
    Inspector**, click on the **Sprite** field of the **Sprite Renderer** component
    to pick a new sprite. Pick one of the darker imperial ships for the enemy character,
    and the sprite will update for the object in the viewport. See *Figure 3.36*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enemies](img/B05118_03_36.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.36: Selecting a sprite for the Sprite Renderer component'
  prefs: []
  type: TYPE_NORMAL
- en: 'After changing the sprite to an enemy character, you may need to adjust the
    rotation values to align the sprite to the parent forward vector, ensuring that
    the sprite is looking in the same direction as the forward vector. See *Figure
    3.37*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enemies](img/B05118_03_37.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.37: Adjusting enemy sprite rotation'
  prefs: []
  type: TYPE_NORMAL
- en: Now, select the parent object for the enemy and remove the **Rigidbody**, **PlayerController**,
    and `BoundsLock` components, but keep the **Health** component as the enemy should
    support health. See *Figure 3.38*. In addition, feel free to resize the **Capsule
    Collider** component to better approximate the `Enemy` object.
  prefs: []
  type: TYPE_NORMAL
- en: '![Enemies](img/B05118_03_38.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.38: Adjusting enemy sprite rotation'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start coding the enemy, focusing on movement. Specifically, the enemy
    should continually move in the forward direction at a specified speed. To achieve
    this, create a new script file named `Mover.cs`. This should be attached to the
    `Enemy` object. The code for this class is included in *Code Sample 3.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 3.6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Mover` script moves an object at a specified speed (`MaxSpeed` per second)
    along its forward vector. To do this, it uses the **Transform** component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Update` function is responsible for updating the position of the object.
    In short, it multiplies the forward vector by the object speed and adds this to
    its existing position to move the object further along its line of sight. The
    `Time.deltaTime` value is used to make the motion frame rate independent—moving
    the object per second as opposed to per frame. More information on `deltaTime`
    can be found in the online Unity documentation at [http://docs.unity3d.com/ScriptReference/Time-deltaTime.html](http://docs.unity3d.com/ScriptReference/Time-deltaTime.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Press play on the toolbar to test run your code. It''s always good practice
    to frequently test code like this. Your enemy may move too slow or too fast. If
    so, stop playback to exit game mode, and select the enemy in the scene. From the
    **Object Inspector**, adjust the **Max Speed** value of the **Mover** component.
    See *Figure 3.39*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 3.6](img/B05118_03_39.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.39: Adjusting enemy speed'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to moving in a straight line, the enemy should also continually
    turn to face the player wherever they move. To achieve this, we''ll need another
    script file that works similarly to the player controller script. While the player
    turns to face the cursor, the enemy turns to face the player. This functionality
    should be encoded in a new script file called `ObjFace.cs`. This script should
    be attached to the enemy. See *Code Sample 3.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 3.7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ObjFace` script will always rotate an object so that its forward vector
    points towards a destination point in the scene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Awake` event, the `FindGameObjectWithTag` function is called to retrieve
    a reference to the one and only object in the scene tagged as a player, which
    should be the player spaceship. The player represents the default look-at destination
    for an enemy object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Update` function is called automatically once per frame and will generate
    a displacement vector from the object location to the destination location, and
    this represents the direction in which the object should be looking. The `Quaternion.LookRotation`
    function accepts a direction vector and will rotate an object to align the forward
    vector with the supplied direction. This keeps the object looking towards the
    destination. More information on `LookRotation` can be found at the online Unity
    documentation at [http://docs.unity3d.com/ScriptReference/Quaternion.LookRotation.html](http://docs.unity3d.com/ScriptReference/Quaternion.LookRotation.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is looking excellent! However, before testing this code, make sure that
    the `Player` object in the scene is tagged as **Player**, is enabled, and the
    enemy is offset away from the player. Be sure to enable the **Follow Player**
    checkbox from the **Obj Face** component in the **Object Inspector**. When you
    do this, the enemy will always turn to face the player. See *Figure 3.40*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 3.7](img/B05118_03_40.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.40: Enemy spaceship moving towards the player'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if and when the enemy finally collides with the player, it should deal
    out damage and potentially kill the player. To achieve this, a collision between
    the enemy and player must be detected. Let''s start by configuring the enemy.
    Select the **Enemy** object, and from the **Object Inspector**, enable the **Is
    Trigger** checkbox in the **Capsule Collider** component. This changes the **Capsule
    Collider** component to allow a true intersection between the player and enemy
    and prevent Unity from blocking the collision. See *Figure 3.41*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 3.7](img/B05118_03_41.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.41: Changing the Enemy Collider to a trigger'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll create a script that detects collisions and will continually deal
    out damage to the player as and when they occur and for as long as the collision
    state remains. Refer to the following code (`ProxyDamage.cs`), which should be
    attached to the enemy character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 3.8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ProxyDamage` script should be attached to an enemy character and it will
    deal out damage to any colliding object with a `Health` component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OnTriggerStay` event is called once every frame for as long as an intersection
    state persists. During this function, the `HealthPoints` value of the `Health`
    component is reduced by the `DamageRate` (which is measured as damage per second).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After attaching the `ProxyDamage` script to an enemy, use the **Object Inspector**
    to set the **Damage Rate** of the **Proxy Damage** component. This represents
    how much health should be reduced on the player, per second, during a collision.
    For a challenge, I''ve set the value to `100` health points. See *Figure 3.42*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 3.8](img/B05118_03_42.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.42: Setting the Damage Rate for a Proxy Damage component'
  prefs: []
  type: TYPE_NORMAL
- en: Now let's give things a test run. Press play on the toolbar and attempt a collision
    between the player and enemy. After one second, the player should be destroyed.
    Things are coming along well. However, we'll need more than one enemy to make
    things challenging.
  prefs: []
  type: TYPE_NORMAL
- en: Enemy spawning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make the level fun and challenging, we''ll need more than simply one enemy.
    In fact, for a game that''s essentially endless, we''ll need to continually add
    enemies. These should be added gradually over time. Essentially, we''ll need either
    regular or intermittent spawning of enemies, and this section will add that functionality.
    Before we can do this, however, we''ll need to make a prefab from the enemy object.
    This can be achieved easily. Select the enemy in the **Hierarchy** panel and then
    drag and drop it to the **Project** panel in the `Prefabs` folder. This creates
    an `Enemy` prefab. See *Figure 3.43*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enemy spawning](img/B05118_03_43.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.43: Creating an Enemy prefab'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll make a new script (`Spawner.cs`) that spawns new enemies in the
    scene over time within a specified radius from the player spaceship. This script
    should be attached to a new, empty game object in the scene. See *Code Sample
    3.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 3.9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Spawner` class will spawn instances of `ObjToSpawn` (a prefab) on each
    interval of `Interval`. The interval is measured in seconds. The spawned objects
    will be created within a random radius from a center point, `Origin`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During the `Start` event, the `InvokeRepeating` function is called to continually
    execute the `Spawn` function on every interval to spawn a new enemy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Spawn` function will create instances of the enemy in the scene at a random
    radius from an origin point. Once spawned, the enemy will behave as normal, heading
    toward the player for an attack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Spawner` class is a global behavior that applies scene-wide. It does not
    depend on the player specifically, nor on any specific enemy. For this reason,
    it should be attached to an empty game object. Create one of these by selecting
    **GameObject** | **Create Empty** from the application menu. Name this `Spawner`
    and attach the `Spawner` script to it. See *Figure 3.44*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 3.9](img/B05118_03_44.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.44: Creating an empty game object'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once added to the scene, from the **Object Inspector**, drag and drop the `Enemy`
    prefab to the **Obj To Spawn** field in the **Spawner** component. Set the **Interval**
    to `2` seconds and increase the **Max Radius** to `5`. See *Figure 3.45*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 3.9](img/B05118_03_45.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.45: Configuring the Spawner for Enemy objects'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now (drum roll), let''s try the level. Press play on the toolbar and take the
    game for a test run. You should now have a level with a fully controllable player
    character surrounded by a growing army of tracking enemy ships! Excellent work!
    See *Figure 3.46*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 3.9](img/B05118_03_46.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.46: Spawned enemy objects moving toward the player'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Good job on getting this far! The space shooter is really taking shape now,
    featuring a controllable player character that relies on native physics, twin-stick
    mechanics, enemy ships, and a scene-wide spawner for enemies. All these ingredients
    together still don''t make a game: we can''t shoot, we can''t increase the score,
    and we can''t destroy enemies. These issues will need to be addressed, along with
    other technical issues that we''ll certainly encounter. Nevertheless, we now have
    a solid foundation for moving further, and in the next chapter, we''ll complete
    the shooter.'
  prefs: []
  type: TYPE_NORMAL
