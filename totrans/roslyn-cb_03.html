<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Writing IDE Code Fixes, Refactorings, and Intellisense Completion Providers</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Creating, debugging, and executing a <kbd>CodeFixProvider</kbd> to fix a compiler warning</li>
<li>Applying batch code fixes (FixAll) across different scopes: document, project, and solution</li>
<li>Creating a custom <kbd>FixAllProvider</kbd> to fix all occurrences of an issue across a scope</li>
<li>Creating a <kbd>CodeRefactoringProvider</kbd> to refactor source code to recommend using C# 7.0 tuples</li>
<li>Creating a <kbd>CompletionProvider</kbd> to provide additional intellisense items while editing code</li>
<li>Writing unit tests for a <kbd><kbd>CodeFixProvider</kbd></kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Code fix providers and code refactoring providers are extensions to the Visual Studio IDE to edit the user source code to fix issues and refactor it without introducing functional changes respectively. Users see a light bulb in the code editor to invoke the code action (fix/refactoring) to automatically edit their code. Additionally, code fixes can provide FixAll support, which allows fixing multiple similar issues across a document, project, or solution with a single code action.</p>
<p>Completion providers are extensions to the Visual Studio IDE to show additional completion items in the intellisense completion list when a user is editing source code, and to auto-generate code when a user commits a specific completion item.</p>
<p>This chapter enables C# developers to write, debug, execute, and test these IDE extensions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating, debugging, and executing a CodeFixProvider to fix a compiler warning</h1>
                </header>
            
            <article>
                
<p>Code fix providers are IDE extensions to fix diagnostics in source code, which are reported by compilers and/or analyzers. These are built on top of Roslyn's Workspaces layer and operate on the current document being edited. When the user invokes a command such as <em>Ctrl</em> + dot in Visual Studio editor, the IDE code fix engine computes all the diagnostics in the current line span and identifies all the code fix providers that have registered to fix one or more of the reported diagnostics. Each of these code fix providers are then invoked with a code fix context containing the current document, diagnostics, and span. Fixers operate on the underlying syntax tree associated with the document by adding, removing, or editing the syntax nodes within the tree, and returning the new document with the fixed code. They might also alter the contents of the containing project or solution to fix the diagnostic. When the user commits the fix by pressing the <em>Enter</em> key, the code fix engine applies this code fix to the user code.</p>
<p>In this section, we will write a <kbd>CodeFixProvider</kbd> to fix the compiler warning <em>CS0219</em> (<a href="https://docs.microsoft.com/en-us/dotnet/csharp/misc/cs0219">https://docs.microsoft.com/en-us/dotnet/csharp/misc/cs0219</a>) (the variable <kbd>variable</kbd> is assigned but its value is never used). For example, the following code sample contains two unused variables <kbd>a</kbd> and <kbd>b</kbd> and the code fix will remove the local declaration statement with unused variable <kbd>a</kbd> and remove the declaration <kbd>b = 1</kbd> in the next declaration statement:</p>
<pre>
    public class MyClass<br/>    {<br/>       public static void Main()<br/>       {<br/>          int a = 0;   // CS0219 for '<em>a'</em><br/>          int b = 1, c = 2; // CS0219 for '<em>b'</em><br/>          System.Console.WriteLine(c);<br/>       }<br/>    }
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You will need to have Visual Studio 2017 installed on your machine to execute the recipes in this chapter. You can install a free community version of Visual Studio 2017 from <a href="https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15">https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15</a>.</p>
<p>Additionally, you can refer to the recipe, <em>Creating, debugging, and executing an analyzer project in Visual Studio,</em> from <a href="9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml">Chapter 1</a>, <em>Writing Diagnostic Analyzers,</em> to install the analyzer + code fix project templates and create a default project from the template, say <kbd>CSharpAnalyzers</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open <kbd>CSharpAnalyzers.sln</kbd> in Visual Studio and open source file <kbd>CodeFixProvider.cs</kbd> in the project <kbd>CSharpAnalyzers</kbd>.</li>
<li>Change the <kbd>title</kbd> of the code fix provider from <kbd>"Make Uppercase"</kbd> to <kbd>"Remove unused local"</kbd> and change <kbd>FixableDiagnosticIds</kbd> property to return <kbd>"CS0219"</kbd> instead of <kbd>CSharpAnalyzersAnalyzer.DiagnosticId</kbd>:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" height="355" src="assets/b14ad973-4d84-4f17-ba87-3c8d3ed90745.png" width="657"/></div>
<ol start="3">
<li>Replace the implementation of the <kbd>RegisterCodeFixesAsync</kbd> method with the code from <kbd>CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/CodeFixProvider.cs/</kbd> method named <kbd>RegisterCodeFixesAsync</kbd><strong><em>.</em></strong></li>
<li>Add the helper methods <kbd>GetSyntaxNodeToRemoveAsync</kbd> and <kbd>RemoveDeclarationAsync</kbd> to the source file with the code from <kbd>CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/CodeFixProvider.cs</kbd>.</li>
</ol>
<p> </p>
<ol start="5">
<li>Set breakpoints at the first line of the newly added methods <kbd>RegisterCodeFixesAsync</kbd> and <kbd>RemoveDeclarationAsync</kbd>.</li>
<li>Set <kbd>CSharpAnalyzers.Vsix</kbd> as the startup project and press <em>F5</em> to start a new VS instance with the code fix provider enabled.</li>
<li>In the new VS instance, create a new C# class library project, say <kbd>ClassLibrary</kbd>, and replace the existing code with the following:</li>
</ol>
<pre style="padding-left: 90px">
public class Class1<br/>{<br/>  public void Method1()<br/>  {<br/>    // Local declaration statement with unused local ('a')<br/>    int a = 0;<br/><br/>    // Local declaration statement with a used ('c') and ununused local ('b').<br/>    int b = 1, c = 2;<br/>    System.Console.WriteLine(c);<br/><br/>    // Local declaration statement where unused local ('d') initializer is non-constant.<br/>    int d = c;<br/><br/>    // Local declaration statement with errors ('e').<br/>    if (true)<br/>      var e = 1;<br/>  }<br/>}
</pre>
<ol start="8">
<li>Put the cursor on the line <kbd>int a = 0;</kbd> and verify the breakpoint in <kbd>RegisterCodeFixesAsync</kbd> is hit. Remove this breakpoint and then you can either step through the method with <em>F10</em> or hit <em>F5</em> to continue execution.</li>
</ol>
<p> </p>
<ol start="9">
<li>Verify that the light bulb shows up with a hyperlink to <kbd>Show potential fixes</kbd> under the source line:<br/>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-366 image-border" height="300" src="assets/928633a8-24e6-4b64-93d8-7c20f4b70d45.png" width="588"/></div>
</li>
<li>Click on the light bulb and verify the breakpoint in <kbd>RemoveDeclarationAsync</kbd> is hit. <span>Remove this breakpoint and then you can either step through the method with</span> <em>F10</em> <span>or hit</span> <em>F5</em> <span>to continue</span> <span>execution</span><span>.</span></li>
<li>Click on the light bulb again and verify the <span class="packt_screen">Remove unused local</span> code fix is offered with a preview of code change by the fix:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" height="222" src="assets/bbfa27ab-026c-4464-b5f7-76ce55936776.png" width="511"/></div>
<ol start="12">
<li>Hit enter to apply the code fix and verify that the unused local declaration statement is removed.</li>
<li>Move the cursor to unused local <kbd>b</kbd> and press keys <em>Ctrl</em> + dot and verify the same code fix is offered, and applying the fix removes the declaration <kbd>b = 1</kbd><em>,</em> but retains the local declaration for <kbd>c</kbd>:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" height="230" src="assets/8c2aa0d1-a42b-4644-95ef-24269c67e304.png" width="630"/></div>
<ol start="14">
<li>Verify that no code fixes are offered for a local <kbd>d</kbd> with a non-constant initializer and local <kbd>e</kbd> with a different compiler error.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Code fix providers are VS IDE extensions that can register code actions for fixing compiler or analyzer diagnostics of specified diagnostic IDs. The primary APIs on <kbd>CodeFixProvider</kbd> are:</p>
<ul>
<li><kbd>FixableDiagnosticIds</kbd> property (abstract): An immutable array of diagnostics IDs that the code fix provider can fix. Any compiler or analyzer diagnostic that is reported with one of the specified diagnostic IDs is a candidate for a code fix from the provider, and <kbd>RegisterCodeFixesAsync</kbd> is called with each such diagnostic.</li>
<li><kbd>RegisterCodeFixesAsync</kbd> method <span>(abstract)</span>: This is the method to register code actions for fixable diagnostics. This method is invoked by the code fix engine whenever it needs to compute the code actions for diagnostics reported on a current source line in the VS IDE. This method takes a <kbd>CodeFixContext</kbd> argument, which contains a set of one or more diagnostics to be fixed for a given diagnostic span and document. All the diagnostics in the context have a fixable diagnostic ID. The <kbd>CodeFixProvider</kbd> can map the diagnostic span to the syntax node in the document and analyze it to register one or more code actions to fix one or more diagnostics in the context. <kbd>CodeAction</kbd> contains the following primary members:
<ul>
<li><kbd>Title</kbd> property: This is the string that shows up with the light bulb when the code fix is offered.</li>
<li><kbd>Callback</kbd> method: This is the delegate to be called back when the user applies a registered code action. This method returns the changed document or solution and the code fix engine applies the changes to the workspace.</li>
<li><kbd>EquivalenceKey</kbd> property: This is the string representing the equivalence class of code actions that this code action belongs to. If the code fix provider supports <kbd>FixAllProvider</kbd>, then a FixAll code fix batches all code actions in the equivalence class of the invoked code action and fixes all of them simultaneously.</li>
<li><kbd>GetFixAllProviderAsync</kbd> method (virtual): Code fix providers can optionally override this method and return a non-null <kbd>FixAllProvider</kbd> if they want FixAll support for their code actions. We will discuss this in more detail in the next recipe.</li>
</ul>
</li>
</ul>
<p><kbd>CodeFixProvider</kbd> implemented in this recipe has a single fixable diagnostic ID: <kbd>CS0219</kbd>, a compiler diagnostic flagging unused local variable declarations. Let's expand on the implementation details of <kbd>RegisterCodeFixesAsync</kbd> override and its helpers.</p>
<p>The first part of <kbd>RegisterCodeFixesAsync</kbd> computes a syntax node to remove for the variable that was flagged by invoking <kbd>GetNodeToRemoveAsync</kbd><em>,</em> and bails out if we get a null node:</p>
<pre>
 public sealed override async Task RegisterCodeFixesAsync(CodeFixContext context)<br/> {<br/>   var diagnostic = context.Diagnostics.First();<br/><br/>   // Get syntax node to remove for the unused local.<br/>   var nodeToRemove = await GetNodeToRemoveAsync(context.Document, diagnostic, context.CancellationToken).ConfigureAwait(false);<br/>   if (nodeToRemove == null)<br/>   {<br/>     return;<br/>   }
</pre>
<p>The initial part of <kbd>GetNodeToRemoveAsync</kbd> computes the syntax node that was flagged by the diagnostic:</p>
<pre>
private async Task&lt;SyntaxNode&gt; GetNodeToRemoveAsync(Document document, Diagnostic diagnostic, CancellationToken cancellationToken)<br/>{<br/>  var root = await document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false);<br/>  var diagnosticSpan = diagnostic.Location.SourceSpan;<br/><br/>  // Find the variable declarator identified by the diagnostic.<br/>  var variableDeclarator = root.FindToken(diagnosticSpan.Start).Parent.AncestorsAndSelf().OfType&lt;VariableDeclaratorSyntax&gt;().First();
</pre>
<p>We first get the syntax root of the document being fixed. We then find the syntax token in the root at the start of the diagnostic span and find the first ancestor node of type <kbd>VariableDeclaratorSyntax</kbd>. For example, consider the following local declaration statement:</p>
<pre>
int b = 1, c = 2;
</pre>
<p>The entire statement is a <kbd>LocalDeclarationStatementSyntax</kbd> node. It has a child syntax node <kbd>VariableDeclarationSyntax</kbd>, which represents <kbd>int b = 1, c = 2</kbd>, and the syntax token for the semicolon. The variable declaration syntax node contains two variable declarator nodes, each of type <kbd>VariableDeclaratorSyntax</kbd>, and text <kbd>b = 1</kbd> and <kbd>c = 2</kbd>, respectively. The <kbd>VariableDeclaratorSyntax</kbd> node contains a token for the <kbd>IdentifierName</kbd> and a syntax node for the initializer of type <kbd>EqualsValueClauseSyntax</kbd>. <kbd>CS0219</kbd> is reported on the <kbd>IdentifierName</kbd> token for the unused variable declarator.</p>
<div class="mce-root CDPAlignLeft CDPAlign CDPAlignCenter packt_infobox">Use the Roslyn <a href="https://blogs.msdn.microsoft.com/csharpfaq/2014/04/17/visualizing-roslyn-syntax-trees/">SyntaxVisualizer</a> to understand the parsed syntax node/tokens for a given C# or VB source code:</div>
<p class="mce-root CDPAlignLeft CDPAlign CDPAlignCenter"><img class="image-border" height="1058" src="assets/d66f9e4e-ad4e-4532-a35e-cf651484d56f.png" width="2915"/></p>
<p>The next part of <kbd>GetNodeToRemoveAsync</kbd> implements certain defensive checks to bail out early without registering any code action as shown in the following code snippet:</p>
<pre>
  if (variableDeclarator == null)<br/>  {<br/>   return null;<br/>  }<br/><br/>  // Bail out if the initializer is non-constant (could have side effects if removed).<br/>  if (variableDeclarator.Initializer != null)<br/>  {<br/>   var semanticModel = await document.GetSemanticModelAsync(cancellationToken).ConfigureAwait(false);<br/>   if (!semanticModel.GetConstantValue(variableDeclarator.Initializer.Value).HasValue)<br/>   {<br/>    return null;<br/>   }<br/>  }<br/><br/>  // Bail out for code with syntax errors - parent of a declaration is not a local declaration statement.<br/>  var variableDeclaration = variableDeclarator.Parent as VariableDeclarationSyntax;<br/>  var localDeclaration = variableDeclaration?.Parent as LocalDeclarationStatementSyntax;<br/>  if (localDeclaration == null)<br/>  {<br/>   return null;<br/>  }
</pre>
<p>We first bail out if the diagnostic was reported on a token which does not have a <strong><kbd>VariableDeclaratorSyntax</kbd></strong> ancestor. We also bail out if the variable initializer is a non-constant, as removing it with the code fix can cause functional change by not executing the initializer code. Finally, we check if the variable declarator has a <kbd>VariableDeclarationSyntax</kbd> parent, which has a <kbd>LocalDeclarationStatementSyntax</kbd> parent.</p>
<div class="packt_infobox">Defensive checks in the code fix provider are very important checks to protect us against an unexpected third-party analyzer reporting diagnostic with same diagnostic ID, but on a different syntax node kind to what our fixer expects. We should ensure that we gracefully bail out instead of crashing unexpectedly or registering an incorrect code fix.</div>
<p>Finally, the method computes and returns the syntax node to be removed by the code fix:</p>
<pre>
  // If the statement declares a single variable, the code fix should remove the whole statement.<br/>  // Otherwise, the code fix should remove only this variable declaration.<br/>  SyntaxNode nodeToRemove;<br/>  if (variableDeclaration.Variables.Count == 1)<br/>  {<br/>   if (!(localDeclaration.Parent is BlockSyntax))<br/>   {<br/>    // Bail out for error case where local declaration is not embedded in a block.<br/>    // Compiler generates errors CS1023 (Embedded statement cannot be a declaration or labeled statement)<br/>    return null;<br/>   }<br/><br/>   nodeToRemove = localDeclaration;<br/>  }<br/>  else<br/>  {<br/>   nodeToRemove = variableDeclarator;<br/>  }<br/><br/>  return nodeToRemove;<br/> }
</pre>
<p>We have two cases to cover:</p>
<ul>
<li>If the local declaration statement declares only a single variable, then we can remove the entire statement. We also cover an additional bail out case where a local declaration is not parented by a block statement, in which case, removing the local declaration statement will cause a syntax error. Given that the compiler already reports a diagnostic <em>CS1023</em> (embedded statement cannot be a declaration or labeled statement) for this case, we just bail out.</li>
<li>Otherwise, if the local declaration statement declares multiple variables, we can remove just the variable declarator.</li>
</ul>
<p>Once we have a non-null syntax node to remove, we register a code fix to remove the declaration node:</p>
<pre>
  // Register a code action that will invoke the fix.<br/>  var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);<br/>  context.RegisterCodeFix(<br/>   CodeAction.Create(<br/>    title: title,<br/>    createChangedDocument: c =&gt; RemoveDeclarationAsync(context.Document, root, nodeToRemove, c),<br/>    equivalenceKey: title),<br/>   diagnostic);<br/> }
</pre>
<p>We create a standard CodeAction, using the <kbd>CodeAction.Create</kbd> API, with the title <kbd>Remove unused local</kbd>, and use the same equivalance key. We register <kbd>RemoveDeclarationAsync</kbd> as the callback method to be invoked when the user applies the code fix:</p>
<pre>
 private Task&lt;Document&gt; RemoveDeclarationAsync(Document document, SyntaxNode root, SyntaxNode declaration, CancellationToken cancellationToken)<br/> {<br/>  var syntaxGenerator = SyntaxGenerator.GetGenerator(document);<br/>  var newRoot = syntaxGenerator.RemoveNode(root, declaration);<br/>  return Task.FromResult(document.WithSyntaxRoot(newRoot));<br/> }
</pre>
<p>This method uses the <kbd>SyntaxGenerator</kbd> helper utility to remove the declaration node from the original syntax root and returns the new document created with the new syntax root.</p>
<div class="packt_tip"><kbd>SyntaxGenerator</kbd> is a powerful syntax factory with APIs to add, remove, or edit syntax nodes in a language agnostic way. It works for both VB and C# syntax nodes, and enables writing code fix providers that fix issues across both languages, without requiring language-specific implementations. See <a href="http://source.roslyn.io/#q=SyntaxGenerator">http://source.roslyn.io/#q=SyntaxGenerator</a> for <kbd>SyntaxGenerator</kbd> reference source.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applying batch code fixes (FixAll) across different scopes: document, project, and solution</h1>
                </header>
            
            <article>
                
<p>In this section, you will learn how to apply batch code fixes to fix multiple instances of similar diagnostics across different scopes. We will apply the FixAll code fix for the <span class="packt_screen">Make uppercase</span> code fix in the default analyzer + code fix template project and fix multiple type names across the document, project, and solution scopes so they all contain upper case letters only. We will show you how to invoke a FixAll code fix from the editor light bulb, and then use the FixAll preview changes dialog to selectively choose the fixes to apply to your solution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You will need to have Visual Studio 2017 installed on your machine to execute the recipes in this chapter. You can install a free community version of Visual Studio 2017 from <a href="https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15">https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15</a><strong><em>.</em></strong></p>
<p>Additionally, you should execute the recipe <em>Creating, debugging, and executing an analyzer project in Visual Studio</em>, from the first <a href="9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml">chapter 1</a>, <em>Writing Diagnostic Analyzers</em> to install the Analyzer + Code fix project templates and create a default project from the template, say <kbd>CSharpAnalyzers</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol start="1">
<li>Open <kbd>CSharpAnalyzers.sln</kbd> in Visual Studio. Set <kbd>CSharpAnalyzers.Vsix</kbd> as the start-up project and press <em>F5</em> to start a new VS instance with the code fix provider enabled.</li>
<li>In the new VS instance, create a new C# class library project, say <kbd>ClassLibrary</kbd>, and replace the existing code with the following:</li>
</ol>
<pre style="padding-left: 90px">
public class Class1<br/>{<br/> public class Class2<br/> {<br/> }<br/>}<br/><br/>public class Class3<br/>{<br/>}
</pre>
<ol start="3">
<li>Add a new source file, say <kbd>Class4.cs</kbd>, to the project with the following code:</li>
</ol>
<pre style="padding-left: 90px">
public class Class4<br/>{<br/>}
</pre>
<ol start="4">
<li>Add a new C# class library project to the solution, say <kbd>ClassLibrary2.csproj</kbd>, rename the source file to <kbd>Class5.cs</kbd><strong>,</strong> and replace its source with the following:</li>
</ol>
<pre style="padding-left: 90px">
public class Class5<br/>{<br/>}
</pre>
<ol start="5">
<li>Verify five diagnostics in the error list, one for each class: Type name 'XXX' contains lower case letters<em>.</em></li>
<li>Place the cursor on <kbd>Class1</kbd>, and hit <em>Ctrl</em> + dot to bring up the light bulb for code fix <span class="packt_screen">Make uppercase</span><em><em>.</em></em></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="257" src="assets/95a7bcd7-2119-4d85-bb71-7c1172203f81.png" width="523"/></div>
<ol start="7">
<li>Click on the hyperlink <span class="packt_screen">Fix all occurrences</span> in <span class="packt_screen">Document</span> to bring up the <span class="packt_screen">Preview Changes - Fix All Occurrences</span> dialog. Click on the <span class="packt_screen">Apply</span> button to apply the <span class="packt_screen">Make uppercase</span> fix to all types in <kbd>Class1.cs</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="332" src="assets/be660758-6948-4031-9e2b-71ffcf68fb4f.png" width="370"/></div>
<ol start="8">
<li>Verify that <kbd>Class1</kbd>, <kbd>Class2</kbd><em>,</em> and <kbd>Class3</kbd> are changed to <kbd>CLASS1</kbd>, <kbd>CLASS2</kbd> and <kbd>CLASS3</kbd><em>,</em> respectively, but <kbd>Class4</kbd> and <kbd>Class5</kbd> are unchanged.</li>
<li>Press <em>Ctrl</em> + <em>Z</em> to undo the batch code fix and verify the solution returns to the same state as before applying the fix all code fix.</li>
<li>Again press <em>Ctrl</em> + dot, but this time click on <span class="packt_screen">Fix all occurrences in Project</span><span>.</span></li>
<li><span>Uncheck the checkbox next to</span> <kbd>public class CLASS2</kbd> <span>and verify that</span> <kbd>CLASS2</kbd> <span>is switched back to</span> <kbd>Class2</kbd> <span>in the preview changes dialog:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="337" src="assets/f5a86fa7-034e-4577-81aa-493cec472ed8.png" width="376"/></div>
<ol start="12">
<li>Apply the fix and verify that <kbd>Class1</kbd>, <kbd>Class3</kbd>, and <kbd>Class4</kbd> are changed to <kbd>CLASS1</kbd>, <kbd>CLASS3</kbd>, and <kbd>CLASS4</kbd>, respectively, but <kbd>Class2</kbd> and <kbd>Class5</kbd> are unchanged.</li>
<li>Press <em>Ctrl</em> + <em>Z</em> to undo the project level code fix and verify changes to both source files <kbd>Class1.cs</kbd> and <kbd>Class4.cs</kbd> are reverted.</li>
<li>Again press <em>Ctrl</em> + dot, and this time click on <span class="packt_screen">Fix all occurrences in Solution</span><span>.</span></li>
<li>Apply the code fix and verify all five classes are changed to upper case, and <em>Ctrl</em> + <em>Z</em> <span>reverts the changes to all types in the solution.</span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a custom FixAllProvider to fix all occurrences of an issue across a scope</h1>
                </header>
            
            <article>
                
<p>In this section, we will show you how to a write a custom FixAll code fix provider to batch fix diagnostics. We will use the code fix implemented in the first recipe of this chapter to <kbd>Remove unused local</kbd><em>.</em> As shown in that recipe, removal of an unused local might have different code fixes based on whether the enclosing local declaration statement declares a single or multiple variables. Additionally, we might have multiple unused locals declared in the single statement, and if all the locals declared in a statement are unused, the batch fix should remove the entire statement. Hence, we cannot use the well-known batch fixer. For example, for the following code, the batch fix should delete the entire first two local declaration statements, but only the declarator for <kbd>d</kbd> in the third declaration statement:</p>
<pre>
public class MyClass<br/>{<br/>   public static void M()<br/>   {<br/>      int a = 0;   // CS0219 for 'a'<br/>      int b = 1, c = 2; // CS0219 for 'b' and 'c'<br/>      int d = 3, e = 4; // CS0219 for 'd'<br/>      System.Console.WriteLine(e);<br/>   }<br/>}
</pre>
<div class="packt_infobox">The default well-known <kbd>BatchFixer</kbd> used by code fixers only works well for simple code fixes. For other scenarios, we need to write a custom fix all provider. See (<a href="https://github.com/dotnet/roslyn/blob/master/docs/analyzers/FixAllProvider.md">https://github.com/dotnet/roslyn/blob/master/docs/analyzers/FixAllProvider.md</a>) for documentation on FixAll providers and limitations of the well-known BatchFixer.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>You should execute the first recipe in this chapter,</span> <em>Creating, debugging and executing a code fix provider to fix a compiler warning</em> <span>to implement a code fix provider to</span> <kbd>Remove unused local</kbd><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol start="1">
<li>Open <kbd>CSharpAnalyzers.sln</kbd> in Visual Studio <span>and add two new source files to the project</span> <kbd>CSharpAnalyzers</kbd><span>:</span>
<ul>
<li><kbd>CustomFixAllProvider.cs</kbd></li>
<li><kbd>CustomFixAllCodeAction.cs</kbd></li>
</ul>
</li>
<li>Add code to <kbd>CustomFixAllProvider.cs</kbd> to implement a custom fix all provider from <kbd>CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/CustomFixAllProvider.cs</kbd>.</li>
<li>Add code to <kbd>CustomFixAllCodeAction.cs</kbd> from <kbd>CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/CustomFixAllCodeAction.cs</kbd> to implement a custom <kbd>CodeAction</kbd>, which is returned by <kbd>CustomFixAllProvider.GetFixAsync</kbd>.</li>
<li>Make the following edits to <kbd>CodeFixProvider.cs</kbd>:
<ul>
<li>Change <kbd>GetNodeToRemoveAsync</kbd> to be an internal static method</li>
<li>Change <kbd>GetFixAllProviderAsync</kbd> to return a <kbd>new CustomFixAllProvider()</kbd></li>
</ul>
</li>
<li>Set <kbd>CSharpAnalyzers.Vsix</kbd> as the start-up project and press <em>F5</em> to start a new VS instance with the code fix provider enabled.</li>
<li>In the new VS instance, create a new C# class library project, say <kbd>ClassLibrary</kbd>, and replace the existing code with the following:</li>
</ol>
<pre style="padding-left: 90px">
public class Class1<br/>{<br/> public static void M()<br/> {<br/>  int a = 0; // CS0219 for 'a'<br/>  int b = 1, c = 2; // CS0219 for 'b' and 'c'<br/>  int d = 3, e = 4; // CS0219 for 'd'<br/>  System.Console.WriteLine(e);<br/> }<br/>}
</pre>
<ol start="7">
<li>Add a new source file, say <kbd>Class2.cs</kbd> to the project with the following code:</li>
</ol>
<pre style="padding-left: 90px">
public class Class2<br/>{<br/> public static void M()<br/> {<br/>  int a = 0; // CS0219 for 'a'<br/>  int b = 1, c = 2; // CS0219 for 'b' and 'c'<br/>  int d = 3, e = 4; // CS0219 for 'd'<br/>  System.Console.WriteLine(e);<br/> }<br/>}
</pre>
<ol start="8">
<li>Add a new C# class library project to the solution, say <kbd>ClassLibrary2.csproj</kbd>, rename the source file to <kbd>Class3.cs</kbd><strong>,</strong> and replace its source with the following:</li>
</ol>
<pre style="padding-left: 90px">
public class Class3<br/>{<br/> public static void M()<br/> {<br/>  int a = 0; // CS0219 for 'a'<br/>  int b = 1, c = 2; // CS0219 for 'b' and 'c'<br/>  int d = 3, e = 4; // CS0219 for 'd'<br/>  System.Console.WriteLine(e);<br/> }<br/>}
</pre>
<ol start="9">
<li>Verify 12 diagnostics in the error list, one for each unused variable across the three classes<em>.</em></li>
<li>Place the cursor on local <em>'a'</em> in <kbd>Class1.cs</kbd>, and hit <em>Ctrl</em> + dot to bring up the light bulb for code fix <kbd>Remove unused local</kbd><em><em>.</em></em></li>
</ol>
<p> </p>
<ol start="11">
<li>Click on the hyperlink <span class="packt_screen">Fix all occurrence</span><span class="packt_screen">s in</span> <span class="packt_screen">Document</span> to bring up the <span class="packt_screen">Preview Changes - Fix All Occurrences</span> dialog. Click on the <span class="packt_screen">Apply</span> button to apply the <span class="packt_screen">Remove unused local</span> to remove all four unused locals (<em>'</em><kbd>a</kbd><em>', '</em><kbd>b</kbd><em>', '</em><kbd>c</kbd><em>'</em> and <em>'</em><kbd>d</kbd><em>'</em>) in the <kbd>Class1.cs</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="443" src="assets/ddcdc30c-56a6-4ede-a0e4-c0864b8ff700.png" width="477"/></div>
<ol start="12">
<li>Switch to unused local declarations in <kbd>Class2.cs</kbd> and attempt to <span class="packt_screen">Fix All Occurences</span> in the solution/project scope and verify all unused locals are remove in the selected scope.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>FixAll providers are VS IDE extensions that register code actions for batch fixes corresponding to code actions registered by a specific code fix provider. The primary APIs on <kbd>FixAllProvider</kbd> are:</p>
<ul>
<li><kbd>GetSupportedFixAllScopes</kbd> property (virtual): This <span class="c">gets the supported scopes for fixing all occurrences of a diagnostic. By default, it returns document, project, and solution scopes</span>.</li>
<li><kbd>GetSupportedFixAllDiagnosticIds</kbd> method <span>(virtual)</span>: This <span class="c">gets the diagnostic IDs for which fix all occurrences is supported. By default, it returns the</span> <kbd>FixableDiagnosticIds</kbd> <span class="c">of the corresponding code fix provider.</span></li>
<li><kbd>GetFixAsync</kbd> method (abstract): This is the primary method that takes a <kbd>FixAllContext</kbd> argument and returns a code action for a batch fix corresponding to <kbd>FixAllContext</kbd> parameters: <kbd>CodeFixProvider</kbd>, <kbd>DiagnosticIds</kbd> to fix, <kbd>FixAllScope</kbd> and <kbd>EquivalenceKey</kbd> for the origin code action.</li>
</ul>
<p>The code fix engine invokes the <kbd>CodeFixProvider.GetFixAllProviderAsync</kbd> method to get the optional FixAll provider supported by the code fixer. In our implementation, we ensure that we return <kbd>CustomFixAllProvider</kbd> for this method. Let's expand on the implementation details of <kbd>CustomFixAllProvider</kbd>.</p>
<p><kbd>CustomFixAllProvider</kbd> only overrides the <kbd>GetFixAsync</kbd> method. The first part of <kbd>GetFixAsync</kbd> computes fix title and the documents to fix for the current <kbd>FixAllScope</kbd>:</p>
<pre>
 public override async Task&lt;CodeAction&gt; GetFixAsync(FixAllContext fixAllContext)<br/> {<br/>  var diagnosticsToFix = new List&lt;KeyValuePair&lt;Document, ImmutableArray&lt;Diagnostic&gt;&gt;&gt;();<br/>  string titleFormat = "Remove all unused locals in {0} {1}";<br/>  string title = null;<br/>  var documentsToFix = ImmutableArray&lt;Document&gt;.Empty;<br/><br/>  switch (fixAllContext.Scope)<br/>  {<br/>   case FixAllScope.Document:<br/>   {<br/>    documentsToFix = ImmutableArray.Create(fixAllContext.Document);<br/>    title = string.Format(titleFormat, "document", fixAllContext.Document.Name);<br/>    break;<br/>   }<br/><br/>   case FixAllScope.Project:<br/>   {<br/>    documentsToFix = fixAllContext.Project.Documents.ToImmutableArray();<br/>    title = string.Format(titleFormat, "project", fixAllContext.Project.Name);<br/>    break;<br/>   }<br/><br/>   case FixAllScope.Solution:<br/>   {<br/>    foreach (Project project in fixAllContext.Solution.Projects)<br/>    {<br/>     documentsToFix = documentsToFix.AddRange(project.Documents);<br/>    }<br/><br/>    title = "Add all items in the solution to the public API";<br/>    break;<br/>   }<br/><br/>   case FixAllScope.Custom:<br/>    return null;<br/>   default:<br/>    break;<br/>  }
</pre>
<p>Then, we iterate through all the computed documents and compute the diagnostics to fix for each document and store them in a map. We return our <kbd>CustomFixAllCodeAction</kbd> with the computed title and diagnostics:</p>
<pre>
 foreach (Document document in documentsToFix)<br/> {<br/>  ImmutableArray&lt;Diagnostic&gt; diagnostics = await fixAllContext.GetDocumentDiagnosticsAsync(document).ConfigureAwait(false);<br/>  diagnosticsToFix.Add(new KeyValuePair&lt;Document, ImmutableArray&lt;Diagnostic&gt;&gt;(document, diagnostics));<br/> }<br/><br/> return new CustomFixAllCodeAction(title, fixAllContext.Solution, diagnosticsToFix);
</pre>
<p>Let's go through the implementation details for <kbd>CustomFixAllCodeAction</kbd><em>.</em> The primary method that the custom code action overrides is <kbd>GetChangedSolutionAsync</kbd>. This method gets the new solution with edits from the batch fix. The code fix engine invokes this method when the user attempts to apply the batch fix .</p>
<p>The initial part of <kbd>GetChangedSolutionAsync</kbd> computes all local declaration and variable declarator syntax nodes to remove for each document, in a map named <kbd>nodesToRemove</kbd>, carrying out very basic batching of syntax nodes to fix:</p>
<pre>
  protected override async Task&lt;Solution&gt; GetChangedSolutionAsync(CancellationToken cancellationToken)<br/>  {<br/>   var nodesToRemoveMap = new Dictionary&lt;Document, HashSet&lt;SyntaxNode&gt;&gt;();<br/>   foreach (KeyValuePair&lt;Document, ImmutableArray&lt;Diagnostic&gt;&gt; pair in _diagnosticsToFix)<br/>   {<br/>    Document document = pair.Key;<br/>    ImmutableArray&lt;Diagnostic&gt; diagnostics = pair.Value;<br/>    var nodesToRemove = new HashSet&lt;SyntaxNode&gt;();<br/>    foreach (var diagnostic in diagnostics)<br/>    {<br/>     var nodeToRemove = await CSharpAnalyzersCodeFixProvider.GetNodeToRemoveAsync(document, diagnostic, cancellationToken).ConfigureAwait(false);<br/>     if (nodeToRemove != null)<br/>     {<br/>      nodesToRemove.Add(nodeToRemove);<br/>     }<br/>    }
</pre>
<p>The second part tries to identify local declaration statements with multiple variable declarations, where all the declared locals are unused, and hence the entire statement can be removed. For such cases, we add the local declaration statement to <kbd>nodesToRemove</kbd> and remove all the individual unused variable declarators in the local declaration statement from <kbd>nodeToRemove</kbd> map:</p>
<pre>
    var candidateLocalDeclarationsToRemove = new HashSet&lt;LocalDeclarationStatementSyntax&gt;();<br/>    foreach (var variableDeclarator in nodesToRemove.OfType&lt;VariableDeclaratorSyntax&gt;())<br/>    {<br/>     var localDeclaration = (LocalDeclarationStatementSyntax)variableDeclarator.Parent.Parent;<br/>     candidateLocalDeclarationsToRemove.Add(localDeclaration);<br/>    }<br/><br/>    foreach (var candidate in candidateLocalDeclarationsToRemove)<br/>    {<br/>     var hasUsedLocal = false;<br/>     foreach (var variable in candidate.Declaration.Variables)<br/>     {<br/>      if (!nodesToRemove.Contains(variable))<br/>      {<br/>       hasUsedLocal = true;<br/>       break;<br/>      }<br/>     }<br/><br/>     if (!hasUsedLocal)<br/>     {<br/>      nodesToRemove.Add(candidate);<br/>      foreach (var variable in candidate.Declaration.Variables)<br/>      {<br/>       nodesToRemove.Remove(variable);<br/>      }<br/>     }<br/>    }
</pre>
<p>Finally, we iterate through all the <kbd>{Document, HashSet&lt;SyntaxNode&gt;}</kbd> pairs and for each document compute the new root with all the unused locals removed from the entire tree. We create a new document with the new root and apply the document change to the latest solution, which is tracked as <kbd>newSolution</kbd>. At the end of the loop, <kbd>newSolution</kbd> represents the current solution with all document changes applied, and is returned by the method:</p>
<pre>
   Solution newSolution = _solution;<br/><br/>   foreach (KeyValuePair&lt;Document, HashSet&lt;SyntaxNode&gt;&gt; pair in nodesToRemoveMap)<br/>   {<br/>    var document = pair.Key;<br/>    var root = await document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false);<br/>    var syntaxGenerator = SyntaxGenerator.GetGenerator(document);<br/>    var newRoot = syntaxGenerator.RemoveNodes(root, pair.Value);<br/>    newSolution = newSolution.WithDocumentSyntaxRoot(document.Id, newRoot);<br/>   }<br/><br/>   return newSolution;
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a CodeRefactoringProvider to refactor source code to recommend using C# 7.0 tuples</h1>
                </header>
            
            <article>
                
<p>Code refactoring providers are IDE extensions to refactor source code for better code structuring, without affecting the functional or semantic behavior of the code. These are built on top of Roslyn's Workspaces layer and operate on the current document being edited. When a user invokes a command such as <em>Ctrl</em> + dot in Visual Studio editor, the IDE code refactoring engine computes all the refactorings that can refactor the code in the currently selected text span in the editor. Each of these providers are then invoked with a code refactoring context containing the current document and span. Refactorings operate on the underlying syntax tree associated with the document by adding, removing, or editing the syntax nodes within the tree and returning the new document with the refactored code. They might also alter the contents of the containing project or solution. When the user commits the refactoring by pressing the <em>Enter</em> key, the code refactoring engine applies this refactoring to the user code.</p>
<p>In this section, we will write a <kbd>CodeRefactoringProvider</kbd> to propose the usage of tuple expressions<em>,</em> a C# 7.0 feature, in methods returning more than one value. Prior to C# 7.0, methods that wanted to return more than one value had the following possible implementations:</p>
<ol>
<li>Declare a non-void return type of one of the return values and <kbd>out</kbd> parameters for the remaining returned values.</li>
<li>Declare a void return type and <em>out</em> parameters for each of the returned values.</li>
<li>Declare a new type wrapping these values as fields, and return an instance of that type.</li>
</ol>
<p>With C# 7.0, the recommended implementation is to declare a tuple return type with elements defined for types of each of the returned values and have no out parameters. We will write a refactoring to identify the existing code with pattern 1 earlier and recommend a refactoring to use tuples. For example, consider the following methods returning multiple return values:</p>
<pre>
private int MethodReturningTwoValues(out int x)<br/>{<br/> x = 0;<br/> return 0;<br/>}<br/><br/>private int MethodReturningThreeValues(out int x, int y, out int z)<br/>{<br/> x = 0;<br/> z = 1;<br/> return y;<br/>}
</pre>
<p>Our code refactoring will offer to convert these methods to:</p>
<pre>
private (int, int) MethodReturningTwoValues()<br/>{<br/> int x;<br/> x = 0;<br/> return (0, x);<br/>}<br/><br/>private (int, int, int) MethodReturningThreeValues(int y)<br/>{<br/> int x;<br/> int z;<br/> x = 0;<br/> z = 1;<br/> return (y, x, z);<br/>}
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You will need to have Visual Studio 2017 installed on your machine to execute the recipes in this chapter. You can install a free community version of Visual Studio 2017 from <a href="https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15">https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15</a><strong><em>.</em></strong></p>
<p>Additionally, you should have installed the .NET Compiler Platform SDK to get the <kbd>CodeRefactoring</kbd> project template. For reference, see the recipe, <em>Creating, debugging, and executing an analyzer project in Visual Studio</em>, in <a href="9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml">Chapter 1</a>, <em>Writing Diagnostic Analyzers.</em></p>
<div class="packt_infobox">By default, the <kbd>CodeRefactoring</kbd> project template targets <em>.NET Portable v4.5</em> and references version <em>1.0.1</em> of <kbd>Microsoft.CodeAnalysis</kbd> packages. As we intend to use the C# 7.0 syntax, we need to upgrade the <kbd>CodeAnalysis</kbd> packages to version 2.0.0 or later, which are based on .NET Standard and hence require the referencing project to be based on .NET standard templates or target .NET Framework v4.6 or higher. For this recipe, we change the project to target .NET Framework v4.6.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Start Visual Studio and click on <span class="packt_screen">File</span> | <span class="packt_screen">New</span> | <span class="packt_screen">Project...</span></li>
<li>Change the project target framework combo box to the .NET Framework 4.6 (or above). Under <span class="packt_screen">Visual C#</span> | <span class="packt_screen">Extensibility</span>, choose <span class="packt_screen">Code Refactoring (VSIX)</span>, name your project <kbd>CodeRefactoring</kbd><strong>,</strong> and click on <span class="packt_screen">OK</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign" style="padding-left: 60px"><img class="image-border" height="474" src="assets/9a36cd4d-e003-4c0b-83b5-f1115f77ba1d.png" width="686"/></div>
<ol start="3">
<li>You should now have a solution with two projects: <kbd>CodeRefactoring</kbd> and <kbd>CodeRefactoring.Vsix</kbd>.</li>
<li>Change the <kbd>CodeRefactoring</kbd> project to target <em>.NET Framework v4.6</em> using the following steps:
<ul>
<li style="list-style-type: none">
<ul>
<li>Unload the project and edit <kbd>csproj</kbd> in Visual Studio</li>
<li>Remove the properties <kbd>ProjectTypeGuids</kbd> and <kbd>TargetFrameworkProfile</kbd></li>
</ul>
</li>
</ul>
<ul>
<li>Change the property <kbd>TargetFrameworkVersion</kbd> from <em>v4.5</em> to <em>v4.6.</em></li>
<li>Replace the last <span class="packt_screen">Imports</span> element in the file from portable targets to non-portable targets, that is, replace the line <kbd>&lt;Import Project="$(MSBuildExtensionsPath32)\Microsoft\Portable\$(TargetFrameworkVersion)\Microsoft.Portable.CSharp.targets" /&gt;</kbd> with <kbd>&lt;Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" /&gt;</kbd></li>
<li>Save changes and reload the project</li>
</ul>
</li>
</ol>
<ol start="5">
<li>Right-click on project in solution explorer, click on Manage NuGet Packages, and update <kbd>Microsoft.CodeAnalysis.CSharp.Workspaces</kbd> to <em>2.0.0</em>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="380" src="assets/b0d6778e-6938-40d1-8ee1-90f643271039.png" width="715"/></div>
<ol start="6">
<li>Open <kbd>CodeRefactoringProvider.cs</kbd> in the <kbd>CodeRefactoringProvider</kbd> project and replace the existing implementation of the <kbd>ComputeRefactoringAsync</kbd> method with the code at <kbd>CodeRefactoring/CodeRefactoring/CodeRefactoringProvider.cs/</kbd> Method named <kbd>ComputeRefactoringAsync</kbd><strong><strong><em>.</em></strong></strong></li>
</ol>
<p> </p>
<ol start="7">
<li>Add the following helper to compute <em>out</em> parameters from a parameter list:</li>
</ol>
<pre style="padding-left: 90px">
private static IEnumerable&lt;ParameterSyntax&gt; GetOutParameters(MethodDeclarationSyntax methodDecl)<br/> =&gt; methodDecl.ParameterList.Parameters.Where(parameter =&gt; parameter.Modifiers.Any(m =&gt; m.Kind() == SyntaxKind.OutKeyword));
</pre>
<ol start="8">
<li>Remove the existing method <kbd>ReverseTypeNameAsync</kbd> and replace it with <kbd>UseValueTupleAsync</kbd> and a couple of helper methods, <kbd>GenerateTupleType</kbd> and <kbd>GenerateTupleExpression</kbd>, from code at <kbd>CodeRefactoring/CodeRefactoring/CodeRefactoringProvider.cs/</kbd> Methods named <kbd>GenerateTupleType and GenerateTupleExpression</kbd>. Additionally, also add a new using statement at the top of the file: <kbd>using Microsoft.CodeAnalysis.Formatting;</kbd></li>
<li>Set <kbd>CodeRefactoring.Vsix</kbd> as the Startup project and click on <em>F5</em> to build the refactoring and start debugging a new instance of Visual Studio with the refactoring enabled.</li>
<li>In the new Visual Studio instance, create a new C# class library project, say <kbd>ClassLibrary</kbd> and add the following two methods to <kbd>Class1</kbd>:</li>
</ol>
<pre style="padding-left: 90px">
private int MethodReturningTwoValues(out int x)<br/>{<br/> x = 0;<br/> return 0;<br/>}<br/><br/>private int MethodReturningThreeValues(out int x, int y, out int z)<br/>{<br/> x = 0;<br/> z = 1;<br/> return y;<br/>}
</pre>
<ol start="11">
<li>Right-click on the <span class="packt_screen">project node <span><span>|</span></span></span> <span class="packt_screen">Manage Nuget Packages</span> and add NuGet package reference to <kbd>System.ValueTuple</kbd>.</li>
<li>Put the caret on <kbd>MethodReturningTwoValues</kbd> and hit <em>Ctrl</em> + dot and verify that we are offered a refactoring to <span class="packt_screen">Use ValueTuple return type</span><em>:</em></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="296" src="assets/3dd67329-3a00-4a5b-a926-115c7efb7219.png" width="580"/></div>
<ol start="13">
<li>Apply the refactoring and verify that the method signature changes to return value tuple.</li>
<li>Similarly, put the caret on <kbd>MethodReturningThreeValues</kbd> and hit <em>Ctrl</em> + dot and verify we are offered a refactoring to <span class="packt_screen">Use ValueTuple return type</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="363" src="assets/cbcf251c-0e8c-47e3-8e87-86e606b3d586.png" width="536"/></div>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Code refactoring providers are VS IDE extensions that can register code actions for refactoring code to a recommended pattern without introducing any functional changes. The primary API on <kbd>CodeRefactoringProvider</kbd> is:</p>
<ul>
<li><kbd>ComputeRefactoringsAsync</kbd> method <span>(abstract)</span>: This is a method to register code actions for refactorings. This method is invoked by the code refactoring engine whenever it needs to compute the refactorings to offer on the current source line in the VS IDE. This method takes a <kbd>CodeRefactoringContext</kbd> argument, which contains the current span and document. <kbd>CodeRefactoringProvider</kbd> can map the span to syntax node in the document and analyze it to register one more code actions in the context. <strong>CodeAction</strong> contains the following primary members:
<ul>
<li><strong><kbd>Title</kbd></strong> property: String that shows up with the light bulb when the code refactoring is offered.</li>
<li><kbd>Callback</kbd> method: Delegate to be called back when the user applies a registered code action. This method returns the changed document or solution and the code refactoring engine applies the changes to the workspace.</li>
</ul>
</li>
</ul>
<p>Let's expand on the implementation details of <kbd>ComputeRefactoringsAsync</kbd> and its helpers.</p>
<p>The first part of <kbd>ComputeRefactoringsAsync</kbd> computes syntax node for the current span:</p>
<pre>
public sealed override async Task ComputeRefactoringsAsync(CodeRefactoringContext context)<br/>{<br/> var root = await context.Document.GetSyntaxRootAsync(context.CancellationToken).ConfigureAwait(false);<br/><br/> // Find the node at the selection.<br/> var node = root.FindNode(context.Span);
</pre>
<p>The next part of the method implements certain defensive checks to bail out early without registering any code action:</p>
<pre>
// Only offer a refactoring if the selected node is a method declaration node with non-void return type and at least one 'out' var.<br/> var methodDecl = node as MethodDeclarationSyntax;<br/> if (methodDecl == null ||<br/>  methodDecl.ReturnType.Kind() == SyntaxKind.VoidKeyword ||<br/>  !GetOutParameters(methodDecl).Any())<br/> {<br/>  return;<br/> }<br/><br/> // Check if the compilation references System.ValueTuple<br/> var hasValueTuple = false;<br/> if (context.Document.Project.SupportsCompilation)<br/> {<br/>  var compilation = await context.Document.Project.GetCompilationAsync(context.CancellationToken).ConfigureAwait(false);<br/>  var systemValueTuple = compilation?.GetTypeByMetadataName(@"System.ValueTuple");<br/>  if (systemValueTuple != null &amp;&amp; systemValueTuple.ContainingAssembly.Name.Equals(@"System.ValueTuple"))<br/>  {<br/>   hasValueTuple = true;<br/>  }<br/> }
</pre>
<p>We first check if we are currently operating on a <kbd>MethodDeclarationSyntax</kbd> node with non-void return type and at least one out parameter. We also bail out if the analyzed compilation doesn't define a type named <kbd>System.ValueTuple</kbd> in <kbd>System.ValueTuple</kbd> assembly reference.</p>
<p>Finally, the method registers a code action with the title to display in the light bulb and a callback<em>,</em> <kbd>UseValueTupleAsync</kbd><em>,</em> to compute the refactoring:</p>
<pre>
 if (hasValueTuple)<br/> {<br/>  // Create a code action to transform the method signature to use tuples.<br/> var action = CodeAction.Create("Use ValueTuple return type", c =&gt; UseValueTupleAsync(context.Document, methodDecl, c));<br/><br/>  // Register this code action.<br/>  context.RegisterRefactoring(action);<br/> }
</pre>
<p><kbd>UseValueTupleAsync</kbd> uses the C# <kbd>SyntaxFactory</kbd> helper utility to edit the signature and body of the method declaration from the original syntax root, and returns the new document created with the new syntax root.</p>
<p>The first part of the method computes the new parameter list for refactored code. We remove all the <em>out</em> parameters from the parameter list and change the return type to be a tuple type. For example, for a method returning type T, and having parameters, A a, out B b, out C c, we return a <kbd>TupleTypeSyntax</kbd> (T, B, C) and change the method parameter list to contain just <q>A a</q><strong>:</strong></p>
<pre>
 // Compute the new parameter list with all the out parameters removed.<br/> var outParameters = GetOutParameters(methodDecl);<br/> var newParameters = methodDecl.ParameterList.Parameters.Where(p =&gt; !outParameters.Contains(p));<br/> var newParameterList = methodDecl.ParameterList.Update(<br/>  methodDecl.ParameterList.OpenParenToken,<br/>  new SeparatedSyntaxList&lt;ParameterSyntax&gt;().AddRange(newParameters),<br/>  methodDecl.ParameterList.CloseParenToken);<br/> methodDecl = methodDecl.WithParameterList(newParameterList);<br/><br/> // Compute the new return type: Tuple type with the original return type as first element and<br/> // types for all original out parameters as subsequent elements.1<br/> var newReturnType = GenerateTupleType(methodDecl.ReturnType, outParameters);<br/> methodDecl = methodDecl.WithReturnType(newReturnType);
</pre>
<p>The next part of the method adds local declaration statements at the top of the method body block for each <em>out</em> parameter in the original parameter list. For the preceding example, we will add local declaration statements <kbd>B b;</kbd> and <kbd>C c;</kbd>:</p>
<pre>
 // Add local declaration statements as the start of the method body to declare locals for original out parameters.<br/> var newStatements = new List&lt;StatementSyntax&gt;(outParameters.Count());<br/> foreach (var outParam in outParameters)<br/> {<br/>  var variableDeclarator = SyntaxFactory.VariableDeclarator(outParam.Identifier);<br/>  var variableDeclarationSyntax = SyntaxFactory.VariableDeclaration(outParam.Type, SyntaxFactory.SingletonSeparatedList(variableDeclarator));<br/>  var localDeclarationStatement = SyntaxFactory.LocalDeclarationStatement(variableDeclarationSyntax);<br/>  newStatements.Add(localDeclarationStatement);<br/> }<br/><br/> var statements = methodDecl.Body.Statements;<br/> var newBody = methodDecl.Body.WithStatements(methodDecl.Body.Statements.InsertRange(0, newStatements));<br/> methodDecl = methodDecl.WithBody(newBody);
</pre>
<p>Then, we gather all the <kbd>ReturnStatementSyntax</kbd> nodes in the original method implementation and replace their expression with a tuple expression created by concatenating the original return expression with the identifier names of the newly declared locals. For our example, this will replace statements of the form <kbd>return x;</kbd> with <kbd>return (x, b, c);</kbd>:</p>
<pre>
 // Replace all return statement expressions with tuple expressions: original return expression<br/> // as the first argument and identifier name for original out parameters as subsequent arguments.<br/> var returnStatements = methodDecl.Body.DescendantNodes().OfType&lt;ReturnStatementSyntax&gt;();<br/> var replacementNodeMap = new Dictionary&lt;ReturnStatementSyntax, ReturnStatementSyntax&gt;(returnStatements.Count());<br/> foreach (var returnStatement in returnStatements)<br/> {<br/>  var tupleExpression = GenerateTupleExpression(returnStatement.Expression, outParameters);<br/>  var newReturnStatement = SyntaxFactory.ReturnStatement(tupleExpression);<br/>  replacementNodeMap.Add(returnStatement, newReturnStatement);<br/> }<br/><br/> methodDecl = methodDecl.ReplaceNodes(returnStatements, computeReplacementNode: (o, n) =&gt; replacementNodeMap[o]);
</pre>
<p>Finally, we apply the formatter annotation on the method <kbd>decl</kbd> to ensure that formatting is done by the formatter engine. We then replace the updated <kbd>methodDecl</kbd> node in the original root and return the updated document:</p>
<pre>
 // Add formatter annotation to format the edited method declaration and body.<br/> methodDecl = methodDecl.WithAdditionalAnnotations(Formatter.Annotation);<br/><br/> // Return new document with replaced method declaration.<br/> var newRoot = root.ReplaceNode(originalMethodDecl, methodDecl);<br/> return document.WithSyntaxRoot(newRoot);<br/>}
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There s more...</h1>
                </header>
            
            <article>
                
<p>Our current implementation of the refactoring is incomplete -- we change the method signature to return tuple types, but do not update the call sites to consume them. For example, the highlighted callsite here will be broken by our refactoring:</p>
<pre>
private void M()<br/>{<br/> int x;<br/> int y = <strong>MethodReturningTwoValues</strong>(out x);<br/>}<br/><br/>private int MethodReturningTwoValues(out int x)<br/>{<br/> x = 0;<br/> return 0;<br/>}
</pre>
<p>We leave it as an exercise for the reader to enhance this refactoring to use the <kbd>FindReferences</kbd> API (<a href="http://source.roslyn.io/#q=FindReferencesSearchEngine.FindReferencesAsyn">http://source.roslyn.io/#q=FindReferencesSearchEngine.FindReferencesAsyn</a>) to find callsites of the method and edit the code to fix the callsite. For the preceding example, we need to replace the <kbd>MethodReturningTwoValues</kbd> invocation with the highlighted code.</p>
<pre>
private void M()<br/>{<br/> int x;<br/><strong> (int, int) t1 = MethodReturningTwoValues();</strong><br/><strong> x = t1.Item2;</strong><br/> int y = <strong>t1.Item1</strong>;<br/>}
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a CompletionProvider to provide additional intellisense items while editing code.</h1>
                </header>
            
            <article>
                
<p><kbd>CompletionProviders</kbd> are IDE extensions that provide completion items in the intellisense list when user is editing code in the Visual Studio IDE:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="197" src="assets/e910df99-d4d7-4e0f-8ca6-076fd9e29d59.png" width="520"/></div>
<p>The preceding screenshot shows a completion list with all the accessible instance members from the current type and base types, and is generally shown when the user types <kbd>this.</kbd> inside executable code. Users can hit a commit character, such as <em>Enter</em> key, to invoke auto-complete with the chosen member.</p>
<p>In this section, we will write a <kbd>CompletionProvider</kbd> to provide the same <em>accessible members</em> completion items, but without requiring the user to have typed a <kbd>this</kbd> before a <kbd>.</kbd> character (yay! from all the lazy folks like me). Additionally, when invoked within a static method, the completion provider will provide only <em>static</em> accessible members in the completion list.</p>
<div class="CDPAlignCenter CDPAlign" style="padding-left: 30px"><img class="alignnone size-full wp-image-371 image-border" height="247" src="assets/7a743a1b-8549-4d16-992a-c4c953bc46cc.png" width="333"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You will need to have Visual Studio 2017 installed on your machine to execute the recipes in this chapter. You can install a free community version of Visual Studio 2017 from <a href="https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15">https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15</a><strong><em>.</em></strong></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol start="1">
<li>Open Visual Studio, click on <span class="packt_screen">File <span><span>|</span></span></span> <span class="packt_screen">New Project <span><span>|</span></span></span> <span class="packt_screen">Visual C# <span><span>|</span></span></span> <span class="packt_screen">Class library</span>, ensure the .NET framework combo box is set to <em>v4.6.2,</em> and create a project named <kbd>CompletionProvider</kbd>.</li>
<li>In solution explorer, right-click on the project node and execute the <kbd>Manage NuGet Packages</kbd> command to bring up the <span class="packt_screen">NuGet Package Manager</span>. Add NuGet package references to <kbd>Microsoft.CodeAnalysis</kbd> and <kbd>Microsoft.CodeAnalysis.Features</kbd>, both version <em>2.0.0.</em></li>
<li>Rename the source file <kbd>Class1.cs</kbd> to <kbd>CustomCompletionProvider.cs</kbd> and add source code for <kbd>CustomCompletionProvider</kbd> from the code sample at <kbd>CompletionProvider/CompletionProvider/CustomCompletionProvider.cs/Type</kbd> named <kbd>CustomCompletionProvider</kbd>.</li>
<li>Add a C# VSIX project named <kbd>CompletionProvider.Vsix</kbd> to the solution.</li>
<li>Replace the content of <kbd>source.extension.vsixmanifest</kbd> in the VSIX project with the following:</li>
</ol>
<pre style="padding-left: 90px">
&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;PackageManifest Version="2.0.0"  &gt;<br/> &lt;Metadata&gt;<br/> &lt;Identity Id="CompletionProvider.Vsix.ccf1c2f5-d03f-42a2-a1b9-c05d10efda2c" Version="1.0" Language="en-US" Publisher="Packt publishing" /&gt;<br/> &lt;DisplayName&gt;CompletionProvider.Vsix&lt;/DisplayName&gt;<br/> &lt;Description&gt;Roslyn completion provider.&lt;/Description&gt;<br/> &lt;/Metadata&gt;<br/> &lt;Installation&gt;<br/> &lt;InstallationTarget Id="Microsoft.VisualStudio.Pro" Version="[15.0]" /&gt;<br/> &lt;/Installation&gt;<br/> &lt;Dependencies&gt;<br/> &lt;Dependency Id="Microsoft.Framework.NDP" DisplayName="Microsoft .NET Framework" d:Source="Manual" Version="[4.5,)" /&gt;<br/> &lt;/Dependencies&gt;<br/> &lt;Assets&gt;<br/> &lt;Asset Type="Microsoft.VisualStudio.MefComponent" d:Source="Project" d:ProjectName="CompletionProvider" Path="|CompletionProvider|"/&gt;<br/> &lt;/Assets&gt;<br/> &lt;Prerequisites&gt;<br/> &lt;Prerequisite Id="Microsoft.VisualStudio.Component.CoreEditor" Version="[15.0,16.0)" DisplayName="Visual Studio core editor" /&gt;<br/> &lt;Prerequisite Id="Microsoft.VisualStudio.Component.Roslyn.LanguageServices" Version="[15.0,16.0)" DisplayName="Roslyn Language Services" /&gt;<br/> &lt;/Prerequisites&gt;<br/>&lt;/PackageManifest&gt;
</pre>
<ol start="6">
<li>Add a project-to-project reference from <kbd>CompletionProvider.Vsix</kbd> to <kbd>CompletionProvider</kbd>.</li>
<li>Set <kbd>CompletionProvider.Vsix</kbd> as the start-up project and click on <em>F5</em> to build the completion provider and start debugging a new instance of Visual Studio with the provider enabled.</li>
<li>In the new Visual Studio instance, create a new C# class library project, say <kbd>ClassLibrary</kbd> and add the following code to the source file:</li>
</ol>
<pre style="padding-left: 90px">
public class Base<br/>{<br/> protected static int StaticMemberBase;<br/> public int InstanceMemberBase;<br/>}<br/><br/>public class Derived : Base<br/>{<br/> private static int staticMemberDerived;<br/> internal int InstanceMemberDerived;<br/><br/> private void InstanceMethod()<br/> {<br/>  .<br/> }<br/><br/> private static void StaticMethod()<br/> {<br/>  .<br/> }<br/>}
</pre>
<ol start="9">
<li>Put the caret after the <kbd>.</kbd> in <kbd>InstanceMethod</kbd> and hit <em>Ctrl</em> + <em>SpaceBar</em> to bring up our custom completion list. Verify all the instance members of type <kbd>Derived</kbd>, and accessible instance members of base type <kbd>Base</kbd> and <kbd>System.Object</kbd> are shown in the completion list.</li>
<li>Select a member, say <kbd>InstanceMemberDerived</kbd>, and hit the <em>Enter</em> key and verify that the <kbd>.</kbd> is replaced with <kbd>this.InstanceMemberDerived</kbd>.</li>
<li><span>Put the caret</span> <span>after the</span> <kbd>.</kbd> <span>in</span> <kbd>StaticMethod</kbd> <span>and hit</span> <em>Ctrl</em> + <em>Spacebar</em> <span>to bring up the completion list. Verify all the static members of type</span> <em>Derived</em> <span>and accessible static members of base type</span> <kbd>Base</kbd> <span>and</span> <kbd>System.Object</kbd> <span>are shown in the completion list.</span></li>
<li>Select a member, say <kbd>StaticMemberBase</kbd>, and hit the <em>Enter</em> key, and verify that the <kbd>.</kbd> is replaced with <kbd>Base.StaticMemberBase</kbd>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Completion providers are VS IDE extensions that can register completion items to be shown in the Visual Studio IDE when the user is editing source code. The primary APIs on <kbd>CompletionProvider</kbd> are:</p>
<ul>
<li><kbd>ShouldTriggerCompletion</kbd> method (virtual): This is the method to decide if completion should be invoked for the given editing context. This method takes the following arguments: <kbd>SourceText</kbd> of the document being edited, <kbd>caretPosition</kbd> at which completion was invoked, <kbd>CompletionTrigger</kbd> (which contains the trigger kind - insertion, deletion, and so on, and the trigger character), and <kbd>OptionSet</kbd> for completion.</li>
<li><kbd>ProvideCompletionsAsync</kbd> method <span>(abstract)</span>: This is the method to register completion items. This method is invoked by the completion engine whenever it needs to compute the completions to offer on the current completion trigger in the VS IDE. This method takes a <kbd>CompletionContext</kbd> argument, which contains the current caret position, document, completion trigger and options. <kbd>CompletionContext</kbd> exposes methods to add one or more completion items. <kbd>CompletionItem</kbd> contains the following primary components: <kbd>DisplayText</kbd> to be shown in the completion list, optional <kbd>FilterText</kbd> and <kbd>SortText</kbd> to modify the default filtering and sorting, respectively, the text <kbd>Span</kbd> of the syntax element is associated with the completion, a dictionary of <kbd>&lt;string, string&gt; Properties</kbd>, an array of <kbd>Tags</kbd>, and set of <kbd>CompletionRules</kbd> for how the completion items are handled.</li>
<li><kbd>GetDescriptionAsync</kbd> method (virtual): This method gets the description to show in the quick info for each completion item.</li>
<li><kbd>GetChangeAsync</kbd> method (virtual): This method gets the <kbd>CompletionChange</kbd> to be applied when the user commits a specific completion item. <kbd>CompletionChange</kbd> contains the set of one or more text changes to apply to the document and new caret position after committing the completion item.</li>
</ul>
<p>Let's expand on the implementation details of each of the preceding overrides in our <kbd>CustomCompletionProvider</kbd>.</p>
<p>Our implementation of <kbd>ShouldTriggerCompletion</kbd> first checks whether completion is invoked for the insertion trigger:</p>
<pre>
public override bool ShouldTriggerCompletion(SourceText text, int caretPosition, CompletionTrigger trigger, OptionSet options)<br/>{<br/> switch (trigger.Kind)<br/> {<br/>  case CompletionTriggerKind.Insertion:<br/>   return ShouldTriggerCompletion(text, caretPosition);<br/><br/>  default:<br/>   return false;<br/> }<br/>}
</pre>
<p>The helper method <kbd>ShouldTriggerCompletion</kbd> checks if the current character is <kbd>.</kbd> and the previous character is either a whitespace, tab, or new line character. If so, we return true; otherwise we return false.</p>
<pre>
private static bool ShouldTriggerCompletion(SourceText text, int position)<br/>{<br/> // Provide completion if user typed "." after a whitespace/tab/newline char.<br/> var insertedCharacterPosition = position - 1;<br/> if (insertedCharacterPosition &lt;= 0)<br/> {<br/>  return false;<br/> }<br/><br/> var ch = text[insertedCharacterPosition];<br/> var previousCh = text[insertedCharacterPosition - 1];<br/> return ch == '.' &amp;&amp;<br/>  (char.IsWhiteSpace(previousCh) || previousCh == 't' || previousCh == 'r' || previousCh == 'n');<br/>}
</pre>
<p><kbd>ProvideCompletionsAsync</kbd> implementation checks up front if we should register any completion items, and bails out if we are not in the supported completion context. We also bail out if we are not editing inside a method body.</p>
<pre>
public async override Task ProvideCompletionsAsync(CompletionContext context)<br/>{<br/> var model = await context.Document.GetSemanticModelAsync(context.CancellationToken).ConfigureAwait(false);<br/> var text = await model.SyntaxTree.GetTextAsync(context.CancellationToken).ConfigureAwait(false);<br/> if (!ShouldTriggerCompletion(text, context.Position))<br/> {<br/>  return;<br/> }<br/><br/> // Only provide completion in method body.<br/> var enclosingMethod = model.GetEnclosingSymbol(context.Position, context.CancellationToken) as IMethodSymbol;<br/> if (enclosingMethod == null)<br/> {<br/>  return;<br/> }
</pre>
<p>We then compute all the accessible members in the current context using the helper methods <kbd>GetAccessibleMembersInThisAndBaseTypes</kbd> and <kbd>GetBaseTypesAndThis</kbd>:</p>
<pre>
private static ImmutableArray&lt;ISymbol&gt; GetAccessibleMembersInThisAndBaseTypes(ITypeSymbol containingType, bool isStatic, int position, SemanticModel model)<br/>{<br/> var types = GetBaseTypesAndThis(containingType);<br/> return types.SelectMany(x =&gt; x.GetMembers().Where(m =&gt; m.IsStatic == isStatic &amp;&amp; model.IsAccessible(position, m)))<br/> .ToImmutableArray();<br/>}<br/><br/>private static IEnumerable&lt;ITypeSymbol&gt; GetBaseTypesAndThis(ITypeSymbol type)<br/>{<br/> var current = type;<br/> while (current != null)<br/> {<br/>  yield return current;<br/>  current = current.BaseType;<br/> }<br/>}
</pre>
<p>We then iterate through all the members to suggest, ignoring constructors, and create and register a completion item for each member:</p>
<pre>
var membersToSuggest = GetAccessibleMembersInThisAndBaseTypes(<br/> enclosingMethod.ContainingType,<br/> isStatic: enclosingMethod.IsStatic,<br/> position: context.Position - 1,<br/> model: model);<br/><br/>// Add completion for each member.<br/>foreach (var member in membersToSuggest)<br/>{<br/> // Ignore constructors<br/> if ((member as IMethodSymbol)?.MethodKind == MethodKind.Constructor)<br/> {<br/>  continue;<br/> }<br/><br/> // Add receiver and description properties.<br/> var receiver = enclosingMethod.IsStatic ? member.ContainingType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat) : "this";<br/> var description = member.ToMinimalDisplayString(model, context.Position - 1);<br/><br/> var properties = ImmutableDictionary&lt;string, string&gt;.Empty<br/>  .Add(Receiver, receiver)<br/>  .Add(Description, description);<br/><br/> // Compute completion tags to display.<br/> var tags = GetCompletionTags(member).ToImmutableArray();<br/><br/> // Add completion item.<br/> var item = CompletionItem.Create(member.Name, properties: properties, tags: tags);<br/> context.AddItem(item);<br/>}
</pre>
<p>We use the member's <kbd>Name</kbd> property as the <kbd>DisplayText</kbd> value for the completion item.</p>
<p>We compute a couple of strings, namely, <kbd>Receiver</kbd> and <kbd>Description</kbd>, and store them as string properties on the completion item. These properties are used in <kbd>GetChangeAsync</kbd> and <kbd>GetDescriptionAsync</kbd> method overrides, respectively. <kbd>Receiver</kbd> is essentially the string to add to the left of the <kbd>.</kbd> character when user commits a completion item: <kbd>this</kbd> for instance members, and containing type's <kbd>name</kbd> for static members. <kbd>Description</kbd> is the text to show in the quick info for each completion item. We use the symbol's minimal display string as the description, but this can be enhanced to show colored tokens and use content from the XML documentation comments on the symbol.</p>
<p>We also compute and attach a set of string <kbd>Tags</kbd> to the completion items. These tags determine the glyphs to show for the completion items. Examples are symbol glyph: field, method, property, and so on, and accessibility glyph: private, protected, internal, public, and so on.</p>
<p><kbd>GetDescriptionAsync</kbd> override directly uses the Description property stored on the completion item to compute the <kbd>CompletionDescription</kbd>:</p>
<pre>
public override Task&lt;CompletionDescription&gt; GetDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken)<br/>{<br/> return Task.FromResult(CompletionDescription.FromText(item.Properties[Description]));<br/>}
</pre>
<p><kbd>GetChangeAsync</kbd> override uses the computed <em>Receiver</em> property and the item's <kbd>DisplayText</kbd> to form the <kbd>newText "{receiver}.{item.DisplayText}"</kbd> to be used in the text change when the user commits the completion item. The <kbd>TextSpan</kbd> of the text change uses <kbd>item.Span.Start - 1</kbd> as the start value and <kbd>1</kbd> as the length to account for the existing <kbd>.</kbd> character to be removed:</p>
<pre>
public override Task&lt;CompletionChange&gt; GetChangeAsync(Document document, CompletionItem item, char? commitKey, CancellationToken cancellationToken)<br/>{<br/> // Get new text replacement and span.<br/> var receiver = item.Properties[Receiver];<br/> var newText = $"{receiver}.{item.DisplayText}";<br/> var newSpan = new TextSpan(item.Span.Start - 1, 1);<br/><br/> // Return the completion change with the new text change.<br/> var textChange = new TextChange(newSpan, newText);<br/> return Task.FromResult(CompletionChange.Create(textChange));<br/>}
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing unit tests for a CodeFixProvider</h1>
                </header>
            
            <article>
                
<p>In this section, we will show you how to write and execute unit tests for a <kbd>CodeFixProvider</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p style="padding-left: 30px"><span>You will need to have created and opened an analyzer + code fixer project, say</span> <kbd>CSharpAnalyzers</kbd> <span>in Visual Studio 2017. Refer to the recipe,</span> <em>Creating, debugging, and executing an analyzer project in Visual Studio</em>, <span>in <a href="9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml">Chapter 1</a>, <em>Writing Diagnostic Analyzers</em> for guidance.</span></p>
<div class="packt_infobox">Note that the template unit test project contains unit tests for both the <kbd>DiagnosticAnalyzer</kbd> and <kbd>CodeFixProvider</kbd>. This chapter deals with <kbd>CodeFixProvider</kbd> testing only. Refer to the recipe, <em>Writing unit tests for an analyzer project</em> in <a href="9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml">Chapter 1</a>, <em>Writing Diagnostic Analyzers</em> for diagnostic analyzer unit tests.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol start="1">
<li>Open <kbd>UnitTests.cs</kbd> in the <kbd>CSharpAnalyzers.Test</kbd> project in the solution explorer to view the default unit tests created for the default symbol analyzer and code fix provider in the project (Type names should not contain lower case letters):</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="297" src="assets/46d1c8ea-ca5c-49a2-89fd-916547876e95.png" width="333"/></div>
<ol start="2">
<li>Click on <span class="packt_screen">Test</span> | <span class="packt_screen">Windows</span> | <span class="packt_screen">Test Window</span> to open the <span class="packt_screen">Test Explorer</span> window to view the unit tests in the project. The default project has two unit tests:
<ul>
<li><kbd>TestMethod1</kbd>: This tests the scenario where analyzer diagnostic does not fire on the test code.</li>
<li><kbd>TestMethod2</kbd>: This tests the scenario where analyzer diagnostic does fire on the test code and the code fix provider fixes the diagnostic.</li>
</ul>
</li>
</ol>
<p style="padding-left: 90px">Delete <kbd>TestMethod1</kbd> as we only care about <kbd>CodeFixProvider</kbd> tests.</p>
<ol start="3">
<li>Run the unit tests for the project by right-clicking on <span class="packt_screen">Not Run tests</span> node in the <span class="packt_screen">Test Explorer</span> and execute <kbd>Run selected tests</kbd> context menu command and verify that the <kbd>TestMethod2</kbd> passes:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="407" src="assets/c0dd4466-6188-4633-8618-1fd8f8360be6.png" width="697"/></div>
<ol start="4">
<li>Edit the test source to remove all the usings and add a new nested type <kbd>TypeName2</kbd> inside <kbd>TypeName</kbd> in both the test string and <kbd>fixTest</kbd> string:</li>
</ol>
<pre style="padding-left: 90px">
public void TestMethod2()<br/>{<br/> var test = @"<br/>  namespace ConsoleApplication1<br/>  {<br/>   class TypeName<br/>   {<br/>    <strong>class TypeName2</strong><br/><strong>    {</strong><br/><strong>    }</strong><br/>   }<br/>  }";<br/><br/> ...<br/><br/> var fixtest = @"<br/>  namespace ConsoleApplication1<br/>  {<br/>   class TYPENAME<br/>   { <br/>    <strong>class TypeName2</strong><br/><strong>    {</strong><br/><strong>    }</strong> <br/>   }<br/>  }";
</pre>
<ol start="5">
<li>Edit <kbd>TestMethod1</kbd> to fix the expected line number of the original expected diagnostic add a new excepted diagnostic for the new test code:</li>
<li>Right-click on <kbd>TestMethod2</kbd> in the editor and execute <span class="packt_screen">Run tests</span> context menu command, and verify the test now fails with the diagnostic mismatch assert - expected 1, actual 2.</li>
</ol>
<pre style="padding-left: 90px">
var expected = new[] {<br/> new DiagnosticResult {<br/>  Id = "CSharpAnalyzers",<br/>  Message = String.Format("Type name '{0}' contains lowercase letters", "TypeName"),<br/>  Severity = DiagnosticSeverity.Warning,<br/>  Locations =<br/>   new[] { new DiagnosticResultLocation("Test0.cs", <strong>4</strong>, 15) }<br/> },<br/> <strong>new DiagnosticResult {</strong><br/><strong>  Id = "CSharpAnalyzers",</strong><br/><strong>  Message = String.Format("Type name '{0}' contains lowercase letters", "TypeName2"),</strong><br/><strong>  Severity = DiagnosticSeverity.Warning,</strong><br/><strong>  Locations =</strong><br/><strong>   new[] { new DiagnosticResultLocation("Test0.cs", 6, 19) }</strong><br/><strong> }</strong><br/>};
</pre>
<ol start="7">
<li>Fix the expected <kbd>fixTest</kbd> code to contain <kbd>TYPENAME2</kbd> and verify that the test passes now.</li>
<li>Run the unit test again and note that the test still fails, but now it fails due to a difference in the fixed test code - <kbd>fixTest</kbd> has class <kbd>TypeName2</kbd> with lowercase letters, but the actual test code has <kbd>TYPENAME2</kbd>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>An analyzer + code fix unit test project allows us to write unit tests for the execution of our analyzer/code fix provider on different code samples. Each unit test is marked with a <kbd>TestMethod</kbd> attribute and defines sample test code, expected diagnostics reported by the analyzer on that code (if any), expected fixed test code after executing the code fix provider on the sample test code, and invocation of test helper methods, here <kbd>VerifyCSharpFix</kbd><em>,</em> to verify code fix.</p>
<p>To understand the basics of unit tests and the test framework for our unit test framework, refer to the <em>How it works... section</em> of the recipe, <em>Writing unit tests for an analyzer project</em> <span>in <a href="9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml">Chapter 1</a>,</span> <em>Writing Diagnostic Analyzers</em> <span>for diagnostic analyzer unit tests.</span></p>
<p><span>In this section, we will give a brief explanation of the abstract type that our unit test container derives from:</span> <kbd>CodeFixVerifier</kbd>. This type contains the <kbd>VerifyCSharpFix</kbd> and <kbd>VerifyBasicFix</kbd> helper methods for running C# and VB <kbd>CodeFixProvider</kbd> unit tests, respectively. These methods call into a common helper method <kbd>VerifyFix</kbd>, which works as follows:</p>
<ol start="1">
<li>This method takes the original and expected sample test code as inputs - the original code on which to apply the code fixes, and the expected code after the code fixes have been applied.</li>
<li>It also takes the language name, analyzer, and code fix provider, along with the index of the code action to apply, in case the fixer registers multiple code actions.</li>
<li>It runs the analyzer on the original test code to get the analyzer diagnostics. It also computes the compiler diagnostics on the test code.</li>
<li>It uses the first analyzer diagnostic to create a <kbd>CodeFixContext</kbd> and invokes the code fix provider's <kbd>RegisterCodeFixesAsync</kbd> method with this context.</li>
<li>Then, it applies the registered code action at the given code fix index to compute the new document.</li>
<li>It re-executes the analyzer on the new document to get new analyzer diagnostics.</li>
<li>Until there is at least one new analyzer diagnostic, it repeats the steps 4-6 to apply the code fix on the new document.</li>
<li>Finally, it verifies the contents of the new document against the expected fixed code.</li>
</ol>
<p> </p>


            </article>

            
        </section>
    </body></html>