- en: Chapter 3. Demystifying Xamarin.Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s now time to take a deeper dive into Xamarin.Android to see how it pulls
    off the same magic as Xamarin.iOS. In this chapter, we will see that Xamarin.iOS
    and Xamarin.Android share many of the same design goals. However, Xamarin.Android
    does not rely on static compilation. Many of the goals are achieved through completely
    different methods. This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Mono CLR and Dalvik VM—working side by side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application packaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mono assemblies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xamarin.Android bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes for the `ApplicationManifest.xml` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mono CLR and Dalvik VM – working side by side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android apps run within the **Dalvik Virtual Machine** (**Dalvik VM**), which
    is somewhat similar to a Java VM, but optimized for devices with limited resources.
    As we discussed in [Chapter 1](ch01.html "Chapter 1. Xamarin and Mono – a Pathway
    to the Unnatural"), *Xamarin and Mono – a Pathway to the Unnatural*, Xamarin products
    are based on the Mono platform that has its own VM called the **Common Language
    Runtime** (**CLR**). The key question to ask here is, "In which environment does
    a Xamarin.Android app run?" The answer is both. If you take a look at the next
    diagram, you will see for yourself how these two runtimes coexist:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mono CLR and Dalvik VM – working side by side](img/0838OT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Both environments seem quite different from each other, so how does an app run
    in both? Xamarin.Android's power is achieved through a concept called peer objects
    and a Java framework called **Java Native Interface** (**JNI**).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Java Native Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with JNI. This is a framework that allows non-Java code with languages
    such as C++ or C#, as an example, to call or be called by Java code running inside
    a JVM. As you can see from the previous diagram, JNI is a critical component in
    the overall Xamarin.Android architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find some supporting information on JNI, particularly on peer objects,
    in [Chapter 2](ch02.html "Chapter 2. Demystifying Xamarin.iOS"), *Xamarin.Android
    Architecture* in Packt Publishing's *Xamarin Mobile Application Development for
    Android*, *Mark Reynolds*.
  prefs: []
  type: TYPE_NORMAL
- en: Peer objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Peer objects are a pair of objects that work together to carry out the functionality
    of an Android app. One of these is a managed object residing in the Mono CLR,
    while the other is a Java object residing in the Dalvik VM.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Android is delivered with a set of assemblies called the Android binding
    libraries. Classes in the Android binding libraries correspond to the Java classes
    in the Android application framework, and the methods on the binding classes act
    as wrappers, to call corresponding methods on Java classes. These binding classes
    are commonly known as **Managed Callable Wrappers** (**MCW**). Because whenever
    you create a C# class that inherits from one of these binding classes, a corresponding
    Java proxy class is generated at build time. The Java proxy contains a generated
    override for each overridden method in your C# class and acts as a wrapper to
    call the corresponding method on the C# class.
  prefs: []
  type: TYPE_NORMAL
- en: Peer objects can be created from within the Dalvik VM by the Android application
    framework or from within the Mono CLR by the code you write in the overridden
    methods. A reference between the two peer objects is kept by each instance of
    a MCW and can be accessed through the `Android.Runtime.IJavaObject.Handle` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see for yourself how peer objects collaborate together here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Peer objects](img/0838OT_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xamarin.Android application packaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android applications are delivered for installation in an Android package format,
    which is an archive file with a `.apk` extension. An Android package contains
    the apps code and all of the supporting files required to run the app that includes
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Dalvik executables (`*.dex` files)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application manifest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Xamarin.Android apps follow the same standard with the following additions:'
  prefs: []
  type: TYPE_NORMAL
- en: C# code is compiled into assemblies and stored in a top-level folder named `assemblies`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mono runtime libraries are stored along with other native libraries in the `lib`
    folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Mono assemblies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like Xamarin.iOS, Xamarin.Android ships with an extended subset of Silverlight
    and desktop .NET assemblies. Together, these libraries provide the .NET runtime
    library support for developers, including namespaces such as `System.IO` and `System.Threading`.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Android is not binary compatible with assemblies compiled for a different
    profile, meaning your code must be recompiled to generate assemblies, specifically
    targeting the Xamarin.Android profile. This is essentially the same thing you
    have to do if you're targeting other profiles such as Silverlight or .NET 4.5.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a complete list of assemblies that ship with Xamarin.Android, you can refer
    to [http://docs.xamarin.com/guides/android/under_the_hood/assemblies](http://docs.xamarin.com/guides/android/under_the_hood/assemblies).
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Android bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Xamarin.Android also ships with a set of binding libraries that provide the
    support for Android development. The binding libraries form the second big part
    of the magic behind Xamarin.Android similar to the way in which the Mono CLR and
    Dalvik VM function. The following sections delve into the details of these bindings.
  prefs: []
  type: TYPE_NORMAL
- en: The design principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A number of goals or design principles guided the development of the binding
    libraries. These principles are critical to make C# developers productive in an
    Android development. The following represents a summary of the design principles,
    where you will notice some similarities with the Xamarin.iOS bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: Allow developers to subclass Java classes in the same way they subclass other
    .NET classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make common Java tasks easy, and tough Java tasks possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expose JavaBean properties as C# properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expose a strongly typed API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expose C# delegates (lambdas, anonymous methods, and `System.Delegate`) instead
    of single-method interfaces when appropriate and applicable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a mechanism to call arbitrary Java libraries (`Android.Runtime.JNIEnv`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: A complete discussion around these principles can be found at [http://docs.xamarin.com/guides/android/advanced_topics/api_design](http://docs.xamarin.com/guides/android/advanced_topics/api_design).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To the greatest extent possible, JavaBean properties in the Android framework
    classes are transformed into C# properties. The following rules are always followed
    whenever this takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, read/write properties are created for both the getter and setter method
    pairs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read-only properties are created for getters without the corresponding setter
    methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the rare case that only a setter exists, no write-only properties are created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, no properties are created when the type will be an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events versus listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android APIs follow the Java pattern in order to define and hook up event listeners.
    C# developers should be more familiar with the similar concepts of delegates and
    events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of Java event listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This following is the equivalent code that uses C# events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The Android bindings provide events when possible. The following rules are
    followed:'
  prefs: []
  type: TYPE_NORMAL
- en: When the listener has a set prefix such as `setOnClickListener`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the listener callback has a void return
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the listener accepts only a single parameter, the interface has only a
    single method, and the interface name ends with `Listener`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an event is not created due to one of the rules enlisted here, a specific
    delegate is generated that supports the appropriate signature.
  prefs: []
  type: TYPE_NORMAL
- en: Special help with collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The native Android APIs uses list, set, and map collections extensively from
    `java.util`. The Android bindings expose these collections using interfaces from
    `System.Collections.Generic`. In addition, Xamarin.Android provides a set of helper
    classes that implement each corresponding .NET collection and provides faster
    marshaling because they do not actually perform a copy. The following table shows
    how these classes map:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Java type | .NET interface | Helper class |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.Set<E>` | `ICollection<T>` | `Android.Runtime.JavaSet<T>` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.List<E>` | `IList<T>` | `Android.Runtime.JavaList<T>` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.Map<K,V>` | `IDictionary<TKey,TValue>` | `Android.Runtime.JavaDictionary<K,V>`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.Collection<E>` | `ICollection<T>` | `Android.Runtime.JavaCollection<T>`
    |'
  prefs: []
  type: TYPE_TB
- en: Xamarin.Android allows you to pass any collection (which implements the correct
    interface) into the Android API methods. For example, `List` implements `IList`
    and can be used when an `IList` entity is required. However, for performance reasons,
    it is recommended that you use the helper classes anytime you need to pass any
    of these collection types into an Android API method.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java and C# both support interfaces; however, Java supports additional capabilities.
    Also, both support the ability to define a set of method names and signatures.
    In addition, Java supports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Nested interface definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fields (`public final static` only)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, the following items describe how the Android bindings provide the
    following Java interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: A C# interface with the same name but prefixed by `I` and containing method
    declarations is created. For example, `android.view.Menu` is created as `Android.Views.IMenu`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An abstract class with the same name as the Java interface is generated, which
    contains definitions for the constants from the Android interface. For example,
    the constants from `android.view.Menu` are placed in the generated abstract class
    `Android.Views.Menu`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A C# interface is generated for each nested interface and is given a name prefixed
    by `I`, the name of the parent Java interface, followed by the name of the nested
    Java interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes in the Android bindings that implement an Android interface containing
    constants get a nested `InterfaceConsts` type generated that also contains definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping nested classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java and C# both support the definition of nested classes. However, Java supports
    two types of nested classes: static and non-static. The following points clarify
    how it does this:'
  prefs: []
  type: TYPE_NORMAL
- en: Java static nested classes are the same as C# nested classes and are translated
    directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-static nested classes, also known as inner classes, are somewhat different;
    additional rules apply:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reference to an instance of the containing type must be provided as a parameter
    in the constructor to the inner class.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of inheriting from an inner class, the derived class must be nested
    within a type. This type inherits properties from the class that contains the
    base inner class, and the derived class must provide a constructor of the same
    type as the C# containing type.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping the Runnable interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java provides the `java.lang.Runnable` interface with a single method, `run()`,
    in order to implement delegation. The Android platform makes use of this interface
    in a number of places such as `Activity.runOnUIThread()` and `View.post()`.
  prefs: []
  type: TYPE_NORMAL
- en: C# provides the `System.Action` delegate for a method with a void return and
    no parameters; thus, it maps very nicely to the `Runnable` interface. The Android
    bindings provide overloads that accept an `Action` parameter for all API members
    that accept a `Runnable` interface in the native API.
  prefs: []
  type: TYPE_NORMAL
- en: The `IRunnable` overloads were also left in place so that types that are returned
    from other API calls can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In many places, the Android APIs uses `int` constants as parameters to specify
    processing options. To increase type safety, the Android bindings create enumerations
    to replace `int` constants when possible. The following example shows the use
    of the `ActivityFlags.NewTaskenum` value rather than the native `FLAG_ACTIVITY_NEW_TASK`
    constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Another great advantage of using an `enum` class is the enhanced support that
    you get with code completion in IDEs such as Xamarin Studio and Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Xamarin.Android generates a file named `Resource.Designer.cs` in the `Resources`
    folder of your project. This file contains constants for all of the resources
    referenced in your app and serves the same purpose as the `R.java` file generated
    for traditional Android apps.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes for the ApplicationManifest.xml file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android applications have a manifest file (`AndroidManifest.xml`) that tells
    the Android platform everything it needs to know to successfully run the application,
    including the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: The minimum API level required by the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware/software features used or required by the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permissions required by the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initial activity to start when the application is launched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries required by the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xamarin.Android provides a robust set of .NET attributes that can be used to
    adorn your C# classes so that much of the information required in `ApplicationManifest.xml`
    will be automatically generated at compile time. Use of these attributes simplifies
    the task of keeping the manifest in sync with your code. For example, if you rename
    an `Activity` class, the next time you compile, the corresponding `<Activity/>`
    element in the manifest is automatically updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates the use of the `Activity` attribute to specify
    the launch activity for an app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following entry in the `ApplicationManifest.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Although .NET attributes are a convenient way to keep your code and manifest
    file in sync, the use of these attributes is not required.
  prefs: []
  type: TYPE_NORMAL
- en: Editor for the ApplicationManifest.xml file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Xamarin Studio also provides an editor for `ApplicationManifest.xml`. This
    can be used instead of attributes or to edit content that cannot be set through
    the use of attributes such as the hardware/software features required and permissions.
    The following screenshot depicts the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editor for the ApplicationManifest.xml file](img/0838OT_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since Xamarin.Android apps run in two different VMs, garbage collection is
    somewhat complex and creates some interesting challenges. Therefore, we have devoted
    significant time to discuss this process. Xamarin.Android uses Mono''s simple
    generational garbage collector, which supports two types of collections called
    minor and major:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minor collections**: These collections are cheap and thus invoked frequently.
    Minor collections collect recently allocated and dead objects and are invoked
    after every few MB of allocations. You can manually invoke a minor collection
    with the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Major collections**: These collections are expensive and are thus invoked
    less frequently. Major collections reclaim all dead objects and are only invoked
    when memory is exhausted for the current heap size. You can manually invoke a
    major collection with the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can review a more detailed discussion on Mono's simple generational garbage
    collector at [http://www.mono-project.com/Compacting_GC](http://www.mono-project.com/Compacting_GC).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before we continue with the discussion, it will help us if we group objects
    in an app into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Managed objects**: These are any C# objects you create from standard libraries
    such as the Mono runtime libraries. They are garbage collected like any other
    C# object and have no special connection to any classes from the Android bindings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java objects**: These are Java objects that reside in the Dalvik VM that
    were created as a part of some process, but not exposed to a managed object through
    JNI. These objects are collected as any other Java object, and there is little
    that we need to discuss about them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Peer objects**: As we mentioned earlier, peer objects are a managed object
    and Java object pair that communicates via JNI. It works together to carry out
    the functionality of an Android app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JNI global and weak references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JNI references come in a couple of different types and they have a big impact
    on when objects can be collected. Specifically, we will discuss two types of JNI
    references, which are global and weak references:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global reference**: A JNI global reference is a reference from "native",
    or in our case managed code, to a Java object managed by the Dalvik VM. A JNI
    global reference is established between peer objects when they are initially created.
    A JNI global reference will prevent the Dalvik garbage collector from performing
    the required action as it indicates the object is still in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weak reference**: A JNI weak reference also allows a managed object to reference
    a Java object, but the difference is that a weak reference will *not* prevent
    the Dalvik VM GC from collecting it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will see how these differ later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Mono collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mono collections are where the fun happens. As mentioned earlier, simple managed
    objects are collected normally, but peer objects are collected by performing the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: All managed peers are eligible for Mono collection, meaning they are not referenced
    by any other managed objects. They have their JNI global reference replaced with
    a JNI weak reference. This allows the Dalvik VM to collect the Java peer if no
    other Java objects in the VM reference them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Dalvik VM GC is invoked that allows the Java peers with weak global references
    to be collected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Managed peers with a JNI weak reference, as created in step 1, are evaluated.
    If the Java peer has been collected, then the managed peer is also collected.
    If the Java peer has not been collected, then it is replaced with a JNI global
    reference and the managed peer is not collected until a future GC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The end result is that an instance of a managed peer will live as long as it's
    referenced by a managed code or its corresponding Java peer is referenced by a
    Java code. To shorten the lifetime of peers, dispose of peer objects when they
    are no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  prefs: []
  type: TYPE_NORMAL
- en: Calling the `Dispose()` method manually severs the connection between the peers
    by freeing the JNI global reference, thus allowing each VM to collect the objects
    as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From Xamarin.Android 4.1.0 version onwards, a full garbage collection is performed
    automatically when a `gref` threshold has crossed 90 percent of the known maximum
    `gref` values for the platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you perform an automatic collection, a message similar to the following
    is displayed in the debug log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Invocations of the automatic GC are nondeterministic and might not happen at
    best times. If you are experiencing a pause in processing, look for messages in
    the logcat that might indicate that an automatic GC occurred. When this scenario
    occurs, you can consider when you can use `Dispose()` to reduce the lifetime of
    the peer.
  prefs: []
  type: TYPE_NORMAL
- en: Helping the GC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of ways in which you can help the GC with the collection
    process. The following sections provide some additional thoughts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Disposing of peer objects**: Get rid of managed peers when they are no longer
    needed and consider invoking a minor GC. As we mentioned earlier, the Mono GC
    does not have a complete picture of the memory situation. To Mono, peer objects
    appear to take up only 20 bytes because the MCWs don''t add instance variables.
    Hence, all of the memory is associated with the corresponding Java object and
    allocated to the Dalvik VM. If you have an instance of `Android.Graphics.Bitmap`
    loaded with a 2 MB image, the Mono GC only sees the 20 bytes and thus disposing
    of the object will be a low priority to the GC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduce direct references in peer objects**: Whenever a managed peer is scanned
    during GC, the entire object graph is scanned, meaning every object it directly
    references is scanned as well. Objects with a significant number of direct references
    can cause a pause when the GC runs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minor collections**: Minor collections are relatively cheap. You can consider
    invoking minor collections at the end of an activity or after completing a significant
    set of service calls or background processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Major collections**: Major collections are expensive and should rarely be
    performed manually. Only consider manually invoking a major collection after a
    significant processing cycle when a large amount of resource has been freed and
    you can live with a pause in the app''s responsiveness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xamarin.Android Designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Xamarin provides a plugin for Xamarin Studio that can be used to design layout
    files for Xamarin.Android apps. The designer supports a **Content** mode for visual
    drag-and-drop and a **Source** mode for XML-based editing. The following screenshot
    depicts the designer opened in the **Content** mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Xamarin.Android Designer](img/0838OT_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the architecture of Xamarin.Android, discussed
    the design goals, and looked at some of the details of its implementation. We
    also looked at how memory management works with a Xamarin.Android app. In the
    next chapter, we will start developing a Xamarin.iOS app.
  prefs: []
  type: TYPE_NORMAL
