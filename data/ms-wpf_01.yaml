- en: A Smarter Way of Working with WPF
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能化使用WPF的方法
- en: When **Windows Presentation Foundation** (**WPF**) was first released as part
    of the .NET Framework Version 3.0 in 2006, it was billed as the future of desktop
    application **Graphical User Interface** (**GUI**) languages and supporters claimed
    that it would put an end to the previous GUI technology, Windows Forms. However,
    as time passed, it has fallen far short of this claim.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当**Windows Presentation Foundation**（**WPF**）在2006年作为.NET Framework 3.0的一部分首次发布时，它被誉为桌面应用程序**图形用户界面**（**GUI**）语言的未来，支持者声称它将结束之前的GUI技术，即Windows
    Forms。然而，随着时间的推移，它远远没有达到这一预期。
- en: There are three main reasons that WPF has not taken off as widely as previously
    expected. The first reason has nothing to do with WPF and stems from the recent
    push to host everything in the cloud and having web interfaces rather than desktop
    applications. The second reason relates to the very steep learning curve and a
    very different way of working that is required to master WPF.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: WPF没有像预期的那样广泛流行，主要原因有三个。第一个原因与WPF无关，源于最近将一切托管在云中，并使用Web界面而不是桌面应用程序的趋势。第二个原因是WPF的学习曲线非常陡峭，需要一种非常不同的工作方式才能掌握。
- en: The last reason is that it is not a very efficient language and if a WPF application
    has lots of 'bells and whistles' in, then either the client computers will need
    to have additional RAM and/or graphics cards installed, or they could face a slow
    and stuttering user experience.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个原因是它不是一个非常高效的编程语言，如果一个WPF应用程序有很多“花哨的功能”，那么客户端计算机可能需要安装额外的RAM和/或显卡，或者它们可能会面临缓慢和卡顿的用户体验。
- en: This explains why many companies that make use of WPF today are in the finance
    industry, where they can afford to upgrade all users' computers to be able to
    run their applications optimally. This book will aim to make WPF more accessible
    to the rest of us by providing practical tips and tricks to help build our real-world
    applications more easily and more efficiently.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了为什么许多今天使用WPF的公司都在金融行业，在那里他们可以承担起升级所有用户的计算机以优化运行其应用程序的费用。本书的目标是通过提供实用的技巧和窍门，使WPF对我们其他人来说更容易接近，帮助我们更容易、更高效地构建现实世界的应用程序。
- en: One of the simplest changes with the biggest workflow improvements that we can
    make to improve the way we work with WPF is to follow the MVVM software architectural
    pattern. It describes how we can organize our classes to make our applications
    more maintainable, testable, and generally simpler to understand. In this chapter,
    we will take a closer look at this pattern and discover how it can help us to
    improve our applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做出的最简单且对工作流程改进最大的改变之一，就是遵循MVVM软件架构模式来改进我们使用WPF的方式。它描述了如何组织我们的类，使我们的应用程序更易于维护、测试，并且通常更容易理解。在本章中，我们将更深入地研究这个模式，并了解它如何帮助我们改进我们的应用程序。
- en: After discovering what MVVM is and what its benefits are, we'll learn several
    new ways to communicate between the various components in this new environment.
    We'll then focus on the physical structure of the code base in a typical MVVM
    application and investigate a variety of alternative arrangements.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在发现MVVM是什么以及它的好处之后，我们将学习几种在新的环境中在各个组件之间进行通信的新方法。然后，我们将专注于典型MVVM应用程序的代码库的物理结构，并调查各种替代安排。
- en: What is MVVM and how does it help?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是MVVM以及它如何帮助？
- en: '**Model-View-View Model** (**MVVM**) is a software architectural pattern that
    was famously introduced by John Gossman on his blog back in 2005 and is now commonly
    used when developing WPF applications. Its main purpose is to provide a *Separation
    of Concerns* between the business model, the **User Interface** (**UI**), and
    the business logic. It does this by dividing them into three distinct types of
    core components: Models, Views, and View Models. Let''s take a look at how they
    are arranged and what each of these components represent:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-视图模型**（**MVVM**）是一种软件架构模式，它由John Gossman在2005年在其博客上著名地引入，现在在开发WPF应用程序时被广泛使用。它的主要目的是在业务模型、**用户界面**（**UI**）和业务逻辑之间提供**关注点分离**。它是通过将它们分为三种不同的核心组件：模型、视图和视图模型来实现的。让我们看看它们的排列方式以及每个组件代表什么：'
- en: '![](img/98dd5eb7-7c66-4c06-ae58-b093dafc0a60.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/98dd5eb7-7c66-4c06-ae58-b093dafc0a60.png)'
- en: As we can see here, the **View Models** component sits between the **Models**
    and the **Views** and provides two-way access to each of them. It should be noted
    at this point that there should be no direct relationship between the **Views**
    and **Models** components and only loose connections between the other components.
    Let's now take a closer look at what each of these components represent.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，**视图模型**组件位于**模型**和**视图**之间，并为它们各自提供双向访问。此时应注意的是，**视图**和**模型**组件之间不应存在直接关系，而其他组件之间只有松散的联系。现在让我们更详细地看看每个组件代表什么。
- en: Models
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: Unlike the other MVVM components, the Model constituent comprises of a number
    of elements. It encompasses the business data model along with its related validation
    logic and also the **Data Access Layer** (**DAL**), or data repositories, that
    provide the application with data access and persistence.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他MVVM组件不同，模型组成部分包括多个元素。它包括业务数据模型及其相关的验证逻辑，以及提供应用程序数据访问和持久性的**数据访问层**（**DAL**）或数据存储库。
- en: The data model represents the classes that hold the data in the application.
    They typically mirror the columns in the database more or less, although it is
    common that they are hierarchical in form, and so may require joins to be performed
    in the data source in order to fully populate them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模型表示在应用程序中持有数据的类。它们通常在某种程度上反映了数据库中的列，尽管它们通常是层次结构的，因此可能需要在数据源中执行连接操作以完全填充它们。
- en: One alternative would be to design the data model classes to fit the requirements
    in the UI, but either way, the business logic or validation rules will typically
    reside in the same project as the data model.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代方案是设计数据模型类以适应UI的要求，但无论哪种方式，业务逻辑或验证规则通常都会驻留在与数据模型相同的项目中。
- en: The code that is used to interface with whatever data persistence technology
    is used in our application is also included within the Models component of the
    pattern. Care should be taken when it comes to organizing this component in the
    code base, as there are a number of issues to take into consideration. We'll investigate
    this further in a while, but for now, let's continue to find out more about the
    components in this pattern.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 用于与我们在应用程序中使用的任何数据持久化技术接口的代码也包含在模式的模型组件中。在代码库中组织此组件时，应谨慎行事，因为有许多问题需要考虑。我们稍后再进一步探讨这个问题，但现在，让我们继续了解这个模式中的组件。
- en: View Models
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图模型
- en: The View Models can be explained easily; each View Model provides its associated
    View with all of the data and functionality that it requires. In some ways, they
    can be considered to be similar to the old Windows Forms code behind files, except
    that they have no direct relationship with the View that they are serving. A better
    analogy, if you're familiar with MVC, would be that they are similar to the Controllers
    in the **Model-View-Controller** (**MVC**) software architectural pattern. In
    fact, in his blog, John describes the MVVM pattern as being a variation of the
    MVC pattern.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型可以很容易地解释；每个视图模型都为其关联的视图提供所需的所有数据和功能。在某种程度上，它们可以被认为是类似于旧Windows Forms代码背后的文件，除了它们与它们所服务的视图没有直接关系。如果你熟悉MVC，一个更好的类比是，它们类似于**模型-视图-控制器**（**MVC**）软件架构模式中的控制器。实际上，在John的博客中，他将MVVM模式描述为MVC模式的变体。
- en: They have two-way connections with the Model component in order to access and
    update the data that the Views require, and often, they transform that data in
    some way to make it easier to display and interact within the UI. They also have
    two-way connections with the Views through data binding and property change notification.
    In short, View Models form the bridge between the Model and the View, which otherwise
    have no connection to each other.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 他们与模型组件有双向连接，以便访问和更新视图所需的数据，并且通常以某种方式转换这些数据，使其更容易在用户界面中显示和交互。他们还通过数据绑定和属性更改通知与视图进行双向连接。简而言之，视图模型构成了模型和视图之间的桥梁，否则它们之间没有直接的联系。
- en: However, it should be noted that the View Models are only loosely connected
    to the Views and Model components through their data binding and interfaces. The
    beauty of this pattern enables each element to be able to function independently
    from each other.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，应注意的是，视图模型仅通过其数据绑定和接口与视图和模型组件松散连接。这种模式的美丽之处在于，它使每个元素能够独立于彼此运行。
- en: To maintain the separation between the View Models and the View, we avoid declaring
    any properties of UI-related types in the View Model. We don't want any references
    to UI-related DLLs in our View Models project, and so we make use of custom `IValueConverter`
    implementations to convert them to primitive types. For example, we might convert
    `Visibility` objects from the UI to plain `bool` values or convert the selection
    of some colored `Brush` objects to an `Enum` instance that is safe to use in the
    View Model. We will see several examples of converters throughout this book, but
    for now, let's continue.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持视图模型和视图之间的分离，我们避免在视图模型中声明任何与 UI 相关类型的属性。我们不希望在视图模型项目中包含任何与 UI 相关的 DLL 引用，因此我们使用自定义的
    `IValueConverter` 实现来将它们转换为原始类型。例如，我们可能将 UI 中的 `Visibility` 对象转换为普通的 `bool` 值，或将某些彩色
    `Brush` 对象的选择转换为在视图模型中安全使用的 `Enum` 实例。我们将在本书中看到几个转换器的示例，但现在让我们继续。
- en: Views
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: The Views define the appearance and layout of the UI. They typically connect
    with a View Model through the use of their `DataContext` property and display
    the data that it supplies. They expose the functionality provided by the View
    Model by connecting its commands to the UI controls that the users interact with.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 视图定义了 UI 的外观和布局。它们通常通过使用它们的 `DataContext` 属性与视图模型连接，并显示它提供的数据。它们通过将视图模型的命令连接到用户与之交互的
    UI 控件来公开视图模型提供的功能。
- en: In general, the basic rule of thumb is that each View has one associated View
    Model. This does not mean that a View cannot data bind to more than one data source
    or that we cannot reuse View Models. It simply means that, in general, if we have
    a class called `SecurityView`, it is more than likely that we'll also have an
    instance of a class named `SecurityViewModel` that will be set as the value of
    that View's `DataContext` property.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，基本规则是每个视图都有一个相关的视图模型。这并不意味着视图不能绑定到多个数据源，或者我们不能重用视图模型。这仅仅意味着，一般来说，如果我们有一个名为
    `SecurityView` 的类，那么我们很可能也会有一个名为 `SecurityViewModel` 的类的实例，该实例将被设置为该视图的 `DataContext`
    属性的值。
- en: Data binding
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定
- en: One often overlooked aspect of the MVVM pattern is its requirement for data
    binding. We could not have the full **Separation of Concerns** without it, as
    there would be no easy way of communicating between the Views and View Models.
    The XAML markup, data binding classes, and `ICommand` and `INotifyPropertyChanged`
    interfaces are the main tools in WPF that provide this functionality.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 模式经常被忽视的一个方面是其对数据绑定的要求。没有它，我们就无法实现完整的 **关注点分离**，因为没有简单的方法在视图和视图模型之间进行通信。XAML
    标记、数据绑定类以及 `ICommand` 和 `INotifyPropertyChanged` 接口是 WPF 中提供此功能的主要工具。
- en: The `ICommand` interface is how commanding is implemented in the .NET Framework.
    It provides behavior that implements and even extends the ever useful Command
    pattern, in which an object encapsulates everything needed to perform an action.
    Most of the UI controls in WPF have `Command` properties that we can use to connect
    them to the functionality that the commands provide.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`ICommand` 接口是 .NET Framework 中命令实现的方式。它提供了实现并甚至扩展了始终有用的命令模式的行为，在该模式中，一个对象封装了执行动作所需的所有内容。WPF
    中的大多数 UI 控件都有 `Command` 属性，我们可以使用这些属性将它们连接到命令提供的功能。'
- en: The `INotifyPropertyChanged` interface is used to notify binding clients that
    property values have been changed. For example, if we had a `User` object and
    it had a `Name` property, then our `User` class would be responsible for raising
    the `PropertyChanged` event of the `INotifyPropertyChanged` interface, specifying
    the name of the property each time its value was changed. We'll look much deeper
    into all of this later, but now let's see how the arrangement of these components
    help us.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`INotifyPropertyChanged` 接口用于通知绑定客户端属性值已更改。例如，如果我们有一个 `User` 对象，并且它有一个 `Name`
    属性，那么我们的 `User` 类将负责触发 `INotifyPropertyChanged` 接口的 `PropertyChanged` 事件，每次其值更改时指定属性名称。我们将在稍后更深入地探讨所有这些内容，但现在让我们看看这些组件的排列如何帮助我们。'
- en: So how does MVVM help?
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么 MVVM 如何帮助呢？
- en: One major benefit of adopting MVVM is that it provides the crucial Separation
    of Concerns between the business model, the UI, and the business logic. This enables
    us to do several things. It frees the View Models from the Models, both the business
    model and the data persistence technology.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 采用 MVVM 的一大好处是它为业务模型、UI 和业务逻辑之间提供了至关重要的关注点分离。这使我们能够做几件事情。它使视图模型从模型中解放出来，无论是业务模型还是数据持久化技术。
- en: This in turn enables us to reuse the business model in other applications and
    swap out the DAL and replace it with a mock data layer so that we can effectively
    test the functionality in our view models without requiring any kind of real data
    connection.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这反过来又使我们能够在其他应用程序中重用业务模型，并替换掉数据访问层（DAL），用模拟数据层（mock data layer）来替换它，这样我们就可以在不需要任何真实数据连接的情况下，有效地测试我们的视图模型中的功能。
- en: It also disconnects the Views from the View logic that they require, as this
    is provided by the View Models. This allows us to run each component independently,
    which has the advantage of enabling one team to work on designing the Views, while
    another team works on the View Models. Having parallel work streams enables companies
    to benefit from vastly reduced production times.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它还切断了视图与它们所需的视图逻辑之间的联系，因为这是由视图模型提供的。这使得我们可以独立运行每个组件，这有一个优点，即允许一个团队设计视图，而另一个团队则专注于视图模型。并行工作流使得公司能够从大幅缩短的生产时间中受益。
- en: Furthermore, this separation also makes it easier for us to swap the Views for
    a different technology without needing to change our Model code. We may well need
    to change some aspects of the View Models, for example, the new technology used
    for the Views may not support the `ICommand` interface, but in principle, the
    amount of code that we would need to change would be fairly minimal.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种分离还使得我们能够在不修改模型代码的情况下，轻松地用不同的技术替换视图。我们可能需要更改视图模型的一些方面，例如，用于视图的新技术可能不支持
    `ICommand` 接口，但原则上，我们需要更改的代码量将是相当小的。
- en: The simplicity of the MVVM pattern also makes WPF easier to comprehend. Knowing
    that each View has a View Model that provides it with all the data and functionality
    that it requires means that we always know where to look when we want to find
    where our data bound properties have been declared.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 模式的简单性也使得 WPF 更易于理解。知道每个视图（View）都有一个视图模型（View Model）为其提供所有所需的数据和功能，这意味着当我们想要找到数据绑定属性在哪里声明时，我们总是知道该往哪里看。
- en: Is there a downside?
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么有缺点吗？
- en: There are, however, a few drawbacks to using MVVM, and it will not help us in
    every situation. The main downside to implementing MVVM is that it adds a certain
    level of complexity to our applications. First, there's the data binding, which
    can take some time to master. Also, depending on your version of Visual Studio,
    data binding errors may only appear at runtime and can be very tricky to track
    down. We will however look into solutions for this in the next chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 MVVM 也有一些缺点，并且它并不适用于所有情况。实现 MVVM 的主要缺点是它给我们的应用程序增加了一定的复杂性。首先，有数据绑定，这可能需要一些时间来掌握。此外，根据您的
    Visual Studio 版本，数据绑定错误可能仅在运行时出现，并且可能非常难以追踪。然而，我们将在下一章中探讨解决这个问题的方法。
- en: Then, there are different ways to communicate between the Views and View Models
    that we need to understand. Commanding and handling events in an unusual way takes
    a while to get used to. Having to discover the optimal arrangement of all the
    required components in the code base also takes time. So, there is a steep learning
    curve to climb before we can become competent at implementing MVVM for sure. This
    book will cover all of these areas in detail and attempt to lessen the gradient
    of that learning curve.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要了解视图和视图模型之间通信的不同方式。以不寻常的方式执行命令和处理事件需要一段时间来适应。在代码库中找到所有所需组件的最佳排列也需要时间。因此，在确保能够熟练实现
    MVVM 之前，我们需要攀登一个陡峭的学习曲线。本书将详细涵盖所有这些领域，并尝试减少学习曲线的梯度。
- en: However, even when we are well practiced at the pattern, there are still occasional
    situations when it wouldn't make sense to implement MVVM. One example would be
    if our application was going to be very small, it would be unlikely that we would
    want to have unit tests for it or swap out any of its components. It would, therefore,
    be impractical to go through the added complexity of implementing the pattern
    when the benefits of the Separation of Concerns that it provides, were not required.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使我们对这种模式非常熟练，仍然有偶尔的情况，在这种情况下实现 MVVM 并没有意义。一个例子是，如果我们的应用程序非常小，我们不太可能想要为其编写单元测试或替换其任何组件。因此，当它提供的关注点分离（Separation
    of Concerns）的好处并不需要时，通过增加模式的复杂性来实现它是不切实际的。
- en: Debunking the myth about code behind
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消除关于代码后置的神话
- en: One of the great misconceptions about MVVM is that we should avoid putting any
    code into the code behind files of our Views. While there is some truth to this,
    it is certainly not true in all situations. If we think logically for a moment,
    we already know that the main reason to use MVVM is to take advantage of the Separation
    of Concerns that its architecture provides. Part of this separates the business
    functionality in the View Model from the user interface-related code in the Views.
    Therefore, the rule should really be that *we should avoid putting any business
    logic into the code behind files of our Views*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关于MVVM的一个重大误解是，我们应该避免将任何代码放入视图的代码后文件中。虽然这一点有一定的真实性，但并不是在所有情况下都适用。如果我们稍微逻辑思考一下，我们已经知道使用MVVM的主要原因之一是利用其架构提供的关注点分离。其中一部分是将视图模型中的业务功能与视图中的用户界面相关代码分离。因此，规则实际上应该是*我们应该避免将任何业务逻辑放入视图的代码后文件中*。
- en: Keeping this in mind, let's look at what code we might want to put into the
    code behind file of a View. The most likely suspects would be some UI-related
    code, maybe handling a particular event, or launching a child window of some kind.
    In these cases, using the code behind the file would be absolutely fine. We have
    no business-related code here, and so we have no need to separate it from the
    other UI-related code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们看看我们可能想要放入视图代码后文件的代码。最有可能的嫌疑人是一些与UI相关的代码，可能是处理某个特定事件，或者启动某种类型的子窗口。在这些情况下，使用代码后文件是完全可行的。这里没有与业务相关的代码，所以我们没有理由将其与其他UI相关代码分离。
- en: On the other hand, if we had written some business-related code in a View's
    code behind file, then how could we test it? In this case, we would have no way
    to separate this from the View, no longer have our Separation of Concerns and,
    therefore, would have broken our implementation of MVVM. So in cases like this,
    the myth is no longer a myth... it is good advice.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们已经在视图的代码后文件中编写了一些与业务相关的代码，那么我们该如何测试它呢？在这种情况下，我们将无法将这部分代码与视图分离，不再有我们的关注点分离（Separation
    of Concerns），因此也就破坏了我们对MVVM的实现。所以在这种情况下，这个神话不再是神话...它是一条好的建议。
- en: 'However, even in cases like this where we want to call some business-related
    code from a View, it *is* possible to achieve without breaking any rules. As long
    as our business code resides in a View Model, it can be tested through that View
    Model, so it''s not so important where it is called from during runtime. Understanding
    that we can always access the View Model that is data bound to a View''s `DataContext`
    property, let''s look at this simple example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使在像这种情况一样，我们想要从视图调用一些与业务相关的代码时，也是有可能在不违反任何规则的情况下实现的。只要我们的业务代码位于视图模型中，它就可以通过该视图模型进行测试，因此在运行时它被调用的位置并不那么重要。理解了我们可以始终访问绑定到视图的`DataContext`属性的视图模型，让我们来看一个简单的例子：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, there are some who would balk at this code example, as they correctly believe
    that Views should not know anything about their related View Models. This code
    effectively ties this View Model to this View. If we wanted to change the UI layer
    in our application at some point or have designers work on the View, then this
    code would cause us a problem. However, we need to be realistic... what is the
    likelihood that we will really need to do that?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有些人可能会对这个代码示例感到犹豫，因为他们正确地认为视图（Views）不应该了解任何关于它们相关的视图模型（View Models）的信息。这段代码实际上将这个视图模型与这个视图绑定在一起。如果我们想在某个时候更改应用程序的UI层或者让设计师处理视图，那么这段代码就会给我们带来问题。然而，我们需要保持现实...我们真正需要这样做的机会有多大？
- en: If it is likely, then we really shouldn't put this code into the code behind
    file and instead handle the event by wrapping it in an Attached Property, and
    we'll see an example of this in the next section. However, if it is not at all
    likely, then there is really no problem with putting it there.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种情况很可能会发生，那么我们真的不应该将这段代码放入代码后文件中，而是通过将其包装在一个附加属性（Attached Property）中处理事件，我们将在下一节中看到这个例子。然而，如果这种情况根本不可能发生，那么将其放在那里实际上并没有问题。
- en: For example, if we have a `UserView`, that has one accompanying `UserViewModel`
    class and we are certain that we will not need to change it, then in this case,
    we can safely use the above code, without fear that direct cast will cause an
    Exception to be thrown. Let's follow rules when they make sense for us to follow
    them, rather than blindly sticking to them because somebody in a different scenario
    said they were a good idea.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个`UserView`，它有一个相应的`UserViewModel`类，并且我们确信我们不需要更改它，那么在这种情况下，我们可以安全地使用上述代码，无需担心直接转换会导致异常抛出。让我们在它们对我们有意义时遵循规则，而不是盲目地坚持它们，因为某人在不同场景中说它们是个好主意。
- en: One other situation when we can ignore this 'No code behind' rule is when writing
    self-contained controls based on the `UserControl` class. In these cases, the
    code behind files are often used for defining Dependency Properties and/or handling
    UI events and for implementing general UI functionality. Remember though, if these
    controls are implementing some business-related functionality, we should write
    that into a View Model and call it from the control so that it can still be tested.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况下，我们可以忽略“无代码后端”规则，那就是在基于`UserControl`类编写自包含控件时。在这些情况下，后端代码文件通常用于定义依赖属性和/或处理UI事件，以及实现通用UI功能。但请记住，如果这些控件实现了某些与业务相关的功能，我们应该将其写入视图模型，并在控件中调用它，以便仍然可以进行测试。
- en: There is definitely a perfect sense in the general idea of avoiding writing
    business-related code in the code behind files of our Views and we should always
    try to do so. However, we now hopefully understand the reasoning behind this idea
    and can use our logic to determine whether it is Okay to do it or not in each
    particular case that may arise.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在视图的后端文件中编写与业务相关的代码的一般想法确实很有意义，我们应该始终尝试这样做。然而，我们现在可能已经理解了这个想法背后的原因，并可以使用我们的逻辑来确定在每个可能出现的特定情况下是否可以这样做。
- en: Learning how to communicate again
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何再次进行沟通
- en: 'As we tend not to handle UI events directly, when using MVVM, we need alternative
    ways to implement the same functionality that they provide. Different methods
    are required to reproduce the functionality of different events. For example,
    the functionality of the `SelectionChanged` event of a collection control is typically
    reproduced by data binding a View Model property to the `SelectedItem` property
    of the collection control:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们倾向于不直接处理UI事件，当使用MVVM时，我们需要实现它们提供相同功能的替代方法。需要不同的方法来重现不同事件的功能。例如，集合控件`SelectionChanged`事件的功能通常通过将视图模型属性数据绑定到集合控件的`SelectedItem`属性来重现：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this example, the setter of the `CurrentItem` property will get called by
    the WPF Framework each time a new item is selected from the `ListBox`. Therefore,
    instead of handling the `SelectionChanged` event in the code behind, we can call
    any method directly from the property setter in the View Model:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`CurrentItem`属性的设置器将在每次从`ListBox`中选择新项目时由WPF框架调用。因此，我们可以在视图模型的属性设置器中直接调用任何方法，而不是在代码后端处理`SelectionChanged`事件：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that we need to keep any methods that we call from data bound property
    setters from doing too much, as the time that it takes to execute them could negatively
    affect the performance when entering data. However, in this example, we would
    typically use this method to start an asynchronous data access function using
    a value from the current item or alter the value of another property in the View
    Model.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要确保从数据绑定属性设置器调用的任何方法不要做得太多，因为执行它们所需的时间可能会在输入数据时对性能产生负面影响。然而，在这个例子中，我们通常会使用这个方法来启动一个异步数据访问函数，使用当前项的值或更改视图模型中另一个属性的值。
- en: 'Many other UI events can be replaced with some form of `Trigger` in the XAML
    markup directly. For example, imagine that we had an `Image` element that was
    set as the `Content` property value of a `Button` control and that we wanted the
    `Image` element to be semi-transparent when the `Button` was disabled. Instead
    of handling the `UIElement.IsEnabledChanged` event in the code behind file, we
    could write a `DataTrigger` in a `Style` that we could apply to the `Image` element:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他UI事件可以直接在XAML标记中使用某种形式的`Trigger`来替换。例如，假设我们有一个`Image`元素，它被设置为`Button`控件的`Content`属性值，并且我们希望当`Button`被禁用时，`Image`元素是半透明的。我们可以在后端文件中处理`UIElement.IsEnabledChanged`事件，而不是在`Style`中编写一个`DataTrigger`，并将其应用于`Image`元素：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Binding syntax will be covered in detail in [Chapter 4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml),
    *Becoming Proficient With Data Binding*, but in short, the binding in this `DataTrigger`
    is specifying the target as the `IsEnabled` property of the ancestor (or parent)
    of the `Image` element with a type of `Button`. When this binding target has a
    value of `False`, the `Opacity` property of the `Image` will be set to `0.5` and
    set back to its original value when the target property value is `True`. Therefore,
    the `Image` element in our `Button` will become semi-transparent when the `Button`
    is disabled.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定语法将在第 4 章“精通数据绑定”中详细介绍，但简而言之，这个 `DataTrigger` 中的绑定指定了目标为具有 `Button` 类型的 `Image`
    元素的祖先（或父）的 `IsEnabled` 属性。当这个绑定目标值为 `False` 时，`Image` 的 `Opacity` 属性将被设置为 `0.5`，并在目标属性值变为
    `True` 时恢复到原始值。因此，当按钮被禁用时，我们的 `Button` 中的 `Image` 元素将变为半透明。
- en: Introducing the ICommand interface
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 ICommand 接口
- en: 'When it comes to button clicks in WPF and MVVM, instead of handling the well-known
    `Click` event, we typically use some form of command that implements the `ICommand`
    interface. Let''s take a look at an example of a basic standard command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 WPF 和 MVVM 中的按钮点击时，我们通常使用实现 `ICommand` 接口的一些形式的命令来处理众所周知的 `Click` 事件。让我们看看一个基本标准命令的例子：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Please note that in this book, we will display code with two-space tabs, instead
    of the more commonly used four-space tabs, in order to enable more characters
    of each code snippet to fit onto each line.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这本书中，我们将使用两个空格的缩进来显示代码，而不是更常用的四个空格缩进，以便使每个代码片段的更多字符能够适应每一行。
- en: We can see that it has an `Execute` method, where the functionality that the
    command provides is performed. The `CanExecute` method is called by the `CommandManager`
    at various points over time, when it believes that the output value may have changed.
    We'll cover this in more detail later, but basically, raising the `CanExecuteChanged`
    event is one of the ways to trigger the `CommandManager` to do this. The output
    of the `CanExecute` method specifies whether the `Execute` method can be called
    or not.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它有一个 `Execute` 方法，其中执行了命令提供的功能。`CanExecute` 方法在 `CommandManager` 认为输出值可能发生变化的各种时间点被调用。我们将在稍后更详细地介绍这一点，但基本上，引发
    `CanExecuteChanged` 事件是触发 `CommandManager` 执行此操作的一种方式。`CanExecute` 方法的输出指定了是否可以调用
    `Execute` 方法。
- en: You can imagine how cumbersome it would be if we had to create one of these
    classes for every action that we needed to implement. Furthermore, there is no
    context of where the command was called from other than the single command parameter.
    This means that if we wanted the command to add an item into a collection, we
    would have to put both the collection and the item to add into another object
    so that they could both be passed through the single input parameter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，如果我们需要为每个需要实现的操作创建这样一个类，那将会多么繁琐。此外，除了单个命令参数之外，没有上下文可以说明命令是从哪里被调用的。这意味着，如果我们想让命令向一个集合中添加一个项目，我们就必须将集合和要添加的项目都放入另一个对象中，这样它们才能通过单个输入参数传递。
- en: 'When using MVVM, rather than implementing the commands in the standard way,
    we tend to use a single, reusable implementation that allows us to handle actions
    with standard methods directly in the View Model. This enables us to use commands
    without having to create a separate class for each one. There are a number of
    variations of this command, but its simplest form is shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 MVVM 时，我们倾向于使用一个单一、可重用的实现来处理命令，这允许我们在 View Model 中直接使用标准方法来处理操作。这使得我们无需为每个命令创建一个单独的类。这个命令有许多变体，但它的最简单形式如下所示：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `action` parameter of type `Action<object>` will hold the reference to the
    method that will be called when the command is executed and the `object` generic
    parameter relates to the optionally used command parameter. The `canExecute` parameter
    of type `Predicate<object>` will hold the reference to the method that will be
    called to verify whether the command can be executed or not and its `object` generic
    parameter relates to the optionally used command parameter again.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 `Action<object>` 的 `action` 参数将持有在执行命令时将被调用的方法的引用，而 `object` 泛型参数与可选使用的命令参数相关。类型为
    `Predicate<object>` 的 `canExecute` 参数将持有在验证命令是否可以执行时将被调用的方法的引用，其 `object` 泛型参数再次与可选使用的命令参数相关。
- en: The `CanExecuteChanged` event should be raised whenever the `canExecute` parameter
    value changes. It is typically handled by command sources, such as the `Button` control,
    to set their `IsEnabled` property value appropriately. When a command source receives
    a notification that this event has been raised, it will call the `ICommand.CanExecute` method
    to check the new value. Therefore, when a command can execute, its data bound
    control will be enabled and when it can't, its data bound control will be disabled.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当`canExecute`参数值发生变化时，应该触发`CanExecuteChanged`事件。通常，这个事件由命令源，例如`Button`控件，来适当地设置它们的`IsEnabled`属性值来处理。当一个命令源收到这个事件已被触发的通知时，它将调用`ICommand.CanExecute`方法来检查新的值。因此，当一个命令可以执行时，其数据绑定控件将被启用，而当它不能执行时，其数据绑定控件将被禁用。
- en: The `CommandManager.RequerySuggested` event will be raised when the `CommandManager` detects
    a change in the UI that could reflect on whether a command could execute or not.
    For example, this could be due to a user interaction, such as the selection of
    an item in a collection or some other change in focus. Therefore, connecting one
    to the other seems to be a logical thing to do. In fact, an example of this is
    actually found in the source code of the .NET `RoutedCommand` class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CommandManager`检测到UI的变化，这可能影响命令是否可以执行时，将触发`CommandManager.RequerySuggested`事件。例如，这可能是由于用户交互，如选择集合中的项目或其他焦点变化。因此，将它们连接起来似乎是合乎逻辑的事情。实际上，这种做法的例子可以在.NET
    `RoutedCommand`类的源代码中找到。
- en: 'This command class is typically used in the View Model classes, as shown in
    the following example, where the command functionality comes from the `Save` method
    and the `bool` return value of the `CanSave` method determines whether the command
    can execute or not:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令类通常用于视图模型类中，如下面的示例所示，其中命令功能来自`Save`方法，而`CanSave`方法的`bool`返回值决定了命令是否可以执行：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A safer way to ensure that the command is never called *by code* when the `CanExecute`
    condition is not satisfied would be to make this alteration; however, note that
    the `CommandManager` class will always perform this check before calling any commands
    anyway:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CanExecute`条件不满足时，确保命令不会被代码调用的一种更安全的方法是进行这种修改；然而，请注意，`CommandManager`类在调用任何命令之前总是会执行这个检查：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Full credit for this custom command should go to Josh Smith, as his `RelayCommand`
    class was the first implementation like this that I came across, although there
    are several variations to be found online. The beauty of this particular implementation
    should not be underestimated. Not only is it simple, elegant, and saves us from
    writing large amounts of code, but it also makes testing our functionality much
    easier, as our command code can now be defined right in our View Models.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个自定义命令，全部的功劳应该归功于Josh Smith，因为他的`RelayCommand`类是我遇到的第一种类似实现，尽管网上可以找到几种变体。这种特定实现的美丽之处不应被低估。它不仅简单、优雅，节省了我们编写大量代码，而且还使得测试我们的功能变得更加容易，因为我们的命令代码现在可以直接定义在我们的视图模型中。
- en: We'll look at this `ActionCommand` again and in more detail in [Chapter 3](b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml),
    *Writing Custom Application Frameworks*, but for now, let's move on to the next
    method of communication.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml)“编写自定义应用程序框架”中再次详细地查看这个`ActionCommand`，但到目前为止，让我们继续到下一个通信方法。
- en: Handling events in Attached Properties
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在附加属性中处理事件
- en: 'There is one way to handle events in WPF without having to resort to writing
    code in the code behind file of a View. Using Attached Properties, we can encapsulate
    the handling of events and effectively expose their behavior using properties
    that we can data bind to in our Views. Let''s take a look at a simple example
    using the `PreviewKeyDown` event:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPF中，有一种处理事件的方法，无需在视图的代码背后文件中编写代码。使用附加属性，我们可以封装事件的处理，并有效地通过我们可以数据绑定到视图中的属性来公开它们的行为。让我们看看使用`PreviewKeyDown`事件的简单示例：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As can be seen in this example, the event is handled by attaching an event handler
    in the normal way, except that all relating code is encapsulated within the class
    that declares the Attached Property. Let's take a closer look. First, we declare
    an Attached Property named `OnEnterKeyDown` of type `ICommand` in a class named
    `TextBoxProperties`, and we pass a reference of our handling method to the `PropertyChangedCallback`
    delegate parameter of the `PropertyMetadata` constructor.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，事件通过以正常方式附加事件处理程序来处理，但所有相关代码都被封装在声明附加属性的类中。让我们更仔细地看看。首先，我们在名为`TextBoxProperties`的类中声明了一个名为`OnEnterKeyDown`的附加属性，其类型为`ICommand`，并将我们处理方法的引用传递给`PropertyMetadata`构造函数的`PropertyChangedCallback`委托参数。
- en: The `GetOnEnterKeyDown` and `SetOnEnterKeyDown` methods represent the normal
    way to get and set Attached Property values. In the unfortunately named `OnOnEnterKeyDownChanged`
    method, which will be called when the property value changes, we look at the `NewValue`
    and `OldValue` values of the `DependencyPropertyChangedEventArgs` input parameter
    in order to decide whether we need to attach or detach the event handler to the
    `PreviewKeyDown` event of the relevant `TextBox`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetOnEnterKeyDown`和`SetOnEnterKeyDown`方法代表了获取和设置附加属性值的正常方式。在不幸命名的`OnOnEnterKeyDownChanged`方法中，当属性值改变时将被调用，我们查看`DependencyPropertyChangedEventArgs`输入参数的`NewValue`和`OldValue`值，以决定我们是否需要将事件处理程序附加或从相关`TextBox`的`PreviewKeyDown`事件中分离。'
- en: If the `OldValue` value is `null` and the `NewValue` value is not `null`, it
    means that there was no previous value, and so the property is being set for the
    first time. In this case, we want to attach the event handler. Conversely, when
    the `OldValue` value is not `null` and the `NewValue` value is `null`, it means
    that there previously was a value, which has been removed, so we should detach
    the event handler.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`OldValue`值为`null`且`NewValue`值不为`null`，这意味着没有之前的值，因此属性是第一次被设置。在这种情况下，我们想要附加事件处理程序。相反，当`OldValue`值不为`null`且`NewValue`值为`null`时，这意味着之前有一个值，该值已被删除，因此我们应该分离事件处理程序。
- en: Finally, the `TextBox_OnEnterKeyDown` event handling method first detects whether
    either the *Enter* key or the *Return* key were pressed. If one was pressed, the
    data bound `ICommand` instance is checked for `null` and if the command can execute,
    it is then executed. Therefore, we have effectively wrapped a `PreviewKeyDown`
    event in an Attached Property and can now execute any command that has been data
    bound to it when the user presses *Enter* on their keyboard.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`TextBox_OnEnterKeyDown`事件处理方法首先检测是否按下了*Enter*键或*Return*键。如果其中一个被按下，则会检查数据绑定的`ICommand`实例是否为`null`，如果命令可以执行，则执行它。因此，我们有效地将一个`PreviewKeyDown`事件封装在一个附加属性中，现在可以在用户按下键盘上的*Enter*键时执行任何已数据绑定到它的命令。
- en: 'In order to use this Attached Property, we must first add a XAML namespace
    prefix for our `Attached` folder in the XAML file of the View that this functionality
    is required in. Note that the `TextBoxProperties` class will be declared in the
    `Attached` folder of the Views project and so, its namespace will be as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这个附加属性，我们必须首先在需要此功能的视图的XAML文件中为我们的`Attached`文件夹添加一个XAML命名空间前缀。请注意，`TextBoxProperties`类将在视图项目的`Attached`文件夹中声明，因此其命名空间如下：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Microsoft''s convention for naming these prefixes is for the first character
    to be a lowercase letter, but it has always made more sense to me to simply use
    the last segment of the declared namespace, which will start with a capital letter.
    Once you have defined the prefix, you can use the Attached Property, as shown
    in the following example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 微软为这些前缀命名的约定是第一个字符为小写字母，但对我来说，简单地使用声明的命名空间的最后一段，并以大写字母开头，似乎更有意义。一旦你定义了前缀，你就可以使用附加属性，如下面的示例所示：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Any UI events that we might need to handle in our applications can be encapsulated
    in Attached Properties in this same way. At first, this might seem to be a complicated
    way to handle events, compared with having a simple handler in a code behind file,
    but once we have a collection of these properties declared, we will find ourselves
    having to create fewer and fewer new ones. Think of them as simply being a reusable
    way of converting events into properties.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要在我们的应用程序中处理的任何UI事件都可以以这种方式封装在附加属性中。起初，与在代码背后文件中有一个简单的处理程序相比，这似乎是一种处理事件复杂的方法，但一旦我们声明了这些属性的集合，我们会发现自己需要创建越来越少的新属性。把它们看作是将事件转换为属性的可重用方式。
- en: Making use of delegates
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用委托
- en: Delegates are very similar to events and, in fact, events can be thought of
    as a particular kind of delegate. They are a very simple tool to use to pass a
    signal or message from one place to another in the program. Unlike when creating
    custom events, we are not forced to use particular input parameters, for example,
    some form of the `EventArgs` class. We are totally unconstrained when creating
    custom delegates and are able to define our own method signatures, including both
    input and output parameter types.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 委托与事件非常相似，实际上，事件可以被视为一种特定的委托。它们是在程序中将信号或消息从一个地方传递到另一个地方的非常简单的工具。与创建自定义事件不同，我们不必使用特定的输入参数，例如`EventArgs`类的一些形式。在创建自定义委托时，我们完全不受约束，能够定义自己的方法签名，包括输入和输出参数类型。
- en: As most of you will already be familiar with events and event handling, you'll
    already inadvertently know how to use delegates too. Let's look at a simple example.
    Imagine that we have a parent View Model that spawns child View Models and that
    one of these child View Models is paired with a View that enables administrative
    users to select security permissions. Now, let's imagine that the parent View
    that relates to the parent View Model has a menu that needs to be updated depending
    on the user's selection in the child View. How do we notify the parent View Model
    upon selection?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你们大多数人已经熟悉事件和事件处理，你们可能已经无意中知道了如何使用委托。让我们看看一个简单的例子。想象一下，我们有一个父视图模型，它会生成子视图模型，其中之一与一个视图配对，该视图允许管理员用户选择安全权限。现在，让我们想象一下，与父视图模型相关的父视图有一个菜单，需要根据用户在子视图中的选择进行更新。我们如何在选择时通知父视图模型？
- en: 'This is where delegates save the day. Keeping this example simple initially,
    let''s say that we just need to notify the parent View Model that a particular
    change has been made so that it can refresh the current user''s security permissions
    from a database. In this case, we only need to pass a signal, so we can create
    a delegate with no input or output parameters. We can declare it in the View Model
    that will be sending the signal, in this case, the child View Model:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代表们拯救世界的地方。为了使这个例子简单起见，我们先假设我们只需要通知父视图模型（ViewModel）已经做出了一些特定的更改，以便它可以从数据库中刷新当前用户的权限。在这种情况下，我们只需要传递一个信号，因此我们可以创建一个没有输入或输出参数的委托。我们可以在将要发送信号的视图模型中声明它，在这种情况下，是子视图模型：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that we define it in the same way that we define an abstract method, except
    that the `abstract` keyword is replaced with the `delegate` keyword after the
    access modifier. In short, a delegate defines a type that references a method
    with a particular signature. Now that we have defined our signaling delegate,
    we need to create a way for elements outside the View Model to use it. For this,
    we can simply create a property of the type of our new delegate *in the same View
    Model*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们定义它的方式与定义抽象方法的方式相同，只是在访问修饰符之后将`abstract`关键字替换为`delegate`关键字。简而言之，委托定义了一个引用具有特定签名的方法的类型。现在我们已经定义了我们的信号委托，我们需要创建一种方式，让视图模型之外的其他元素可以使用它。为此，我们可以在同一个视图模型中简单地创建一个新委托类型的属性：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we don''t need any property change notifications for this property, we can
    save ourselves some typing and take advantage of the .NET Auto-Implemented Property
    syntax. Bear in mind that delegates work in a multicast way like events, meaning
    that we can attach more than one handler to each one. In order to do this, we
    need to use the `+=` operator to add handlers for the delegate, and in this example,
    we would want to do that in the parent View Model when the child View is instantiated:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不需要为这个属性提供任何属性更改通知，我们可以节省一些打字时间，并利用.NET自动实现属性语法。请注意，委托以多播方式工作，就像事件一样，这意味着我们可以为每个委托附加多个处理程序。为了做到这一点，我们需要使用`+=`运算符为委托添加处理程序，在这个例子中，我们希望在子视图实例化时在父视图模型中这样做：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we have assigned the `RefreshSecurityPermissions` method in the parent
    View Model to be the handler for this delegate. Note that we omit the parenthesis
    and the input parameters if there were any when attaching the handler. Now, you
    may be wondering, "*What does the method signature of this handler look like?*",
    but you already have the answer to this. If you remember, we declared the delegate
    with the signature of the method that we want to handle it. Therefore, any method
    that shares this signature can be a handler for this type of delegate:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将父视图模型中的`RefreshSecurityPermissions`方法指定为处理此代理的事件处理程序。请注意，在附加处理程序时，我们省略了括号以及如果有任何输入参数也一并省略。现在，你可能想知道，“*这个处理程序的方法签名是什么样的？*”，但你已经有了答案。如果你记得，我们声明代理时使用了我们想要处理的方法的签名。因此，任何具有相同签名的函数都可以成为此类代理的处理程序：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that the name used is irrelevant and all that matters when matching the
    delegate signature are the input and output parameters. So, we now have our delegate
    declared and hooked up to a handler in the parent View Model, but it's still not
    going to do anything because we haven't actually called it yet. In our example,
    it's the child View Model that is going to call the delegate because that's the
    object that needs to send out the information or signal in this case.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所使用的名称无关紧要，在匹配代理签名时，重要的是输入和输出参数。因此，我们现在已经声明了代理，并将其连接到父视图模型中的处理程序，但它仍然不会做任何事情，因为我们还没有实际调用它。在我们的例子中，是子视图模型将要调用代理，因为这是需要发送信息或信号的物体。
- en: 'When calling delegates, we must always remember to check for `null` before
    trying to use them because there may be no handlers attached. In our example,
    we''d call our `Signal` delegate via the `OnSecurityPermissionChanged` property
    at the point that we need to send the signal from the child View Model, let''s
    say in reaction to a user changing their own security permissions:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用代理时，我们必须始终记得在使用之前检查`null`，因为可能没有附加处理程序。在我们的例子中，我们将在需要从子视图模型发送信号的时刻调用我们的`Signal`代理，比如说，当用户更改自己的安全权限时：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, we could do so using the more concise null conditional operator
    in C# Version 6.0, which calls the delegate''s `Invoke` method if it is not `null`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用C# 6.0中更简洁的空条件运算符来完成，如果代理不是`null`，它将调用代理的`Invoke`方法：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that we do need to include the parenthesis when calling the delegate in
    the first example even though `OnSecurityPermissionChanged` is a property. This
    is because the delegate type of the property relates to a method and it is that
    method that we are calling. Please bear in mind that the first of these methods
    is not thread safe, so if thread safety is important for your application, then
    you will need to use the latter way.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使在第一个例子中调用代理时需要包括括号，即使`OnSecurityPermissionChanged`是一个属性。这是因为属性的代理类型与一个方法相关联，而我们正在调用的是这个方法。请记住，这些方法中的第一个不是线程安全的，所以如果你的应用程序需要线程安全，那么你需要使用后面的方式。
- en: We now have the complete picture, but while it is common to have a signal-sending
    delegate such as this, it is not overly useful because it only passes a signal
    with no other information. In many real-world scenarios, we would typically want
    to have some sort of input parameter so that we could pass some information, rather
    than just a signal.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了完整的画面，但尽管有一个像这样的信号发送代理很常见，但它并不特别有用，因为它只传递信号而没有其他信息。在许多实际场景中，我们通常会想要有一个某种输入参数，这样我们就可以传递一些信息，而不仅仅是信号。
- en: 'For example, if we wanted to be notified with details each time a user selected
    a different item from a collection control in the UI, we could add a `CurrentItem`
    property into a generic `BaseCollection` class in our application and data bind
    it to the data bound collection control''s `SelectedItem` property. This `CurrentItem`
    property would then be called by the WPF Framework each time a user makes a new
    selection, and so we can call our new delegate from its property setter:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要在用户每次从UI中的集合控件中选择不同的项目时收到通知，我们可以在我们的应用程序中的通用`BaseCollection`类中添加一个`CurrentItem`属性，并将其绑定到数据绑定集合控件的`SelectedItem`属性。每次用户进行新的选择时，WPF框架都会调用这个`CurrentItem`属性，因此我们可以从其属性设置器调用我们新的代理：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Delegates can be used to communicate between any related classes as long as
    they have access to the class that exposes the delegate so that they can attach
    a handler. They are commonly used to send information between child Views or View
    Models and their parents, or even between Views and View Models, but they can
    also be used to pass data between any two connected parts of the application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 代理可以用于在任何相关类之间进行通信，只要它们可以访问公开代理的类，以便它们可以附加处理程序。它们通常用于在子视图或视图模型及其父级之间发送信息，甚至可以在视图和视图模型之间使用，但它们也可以用于在应用程序的任何两个连接部分之间传递数据。
- en: Structuring the application code base
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化应用程序代码库
- en: Now that we have a better understanding of the MVVM pattern, let's look at how
    we might implement it in a WPF application. What should the folder structure of
    our application be like? Clearly, we'll need somewhere to put our Models, Views,
    and View Models; however, how we arrange them will somewhat depend on the overall
    size of our application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 MVVM 模式有了更好的理解，让我们看看我们如何在 WPF 应用程序中实现它。我们的应用程序文件夹结构应该是什么样的？显然，我们需要一个地方来放置我们的
    Models、Views 和 View Models；然而，它们的排列将部分取决于我们应用程序的整体大小。
- en: As we have heard, very small projects do not really suit MVVM because implementing
    it can involve a lot of preparation and often, the benefits do not apply. For
    small WPF applications, we would typically have just one project in our WPF application.
    In these cases, our classes would be separated into different folders within the
    single project.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所听到的，非常小的项目并不真正适合 MVVM，因为实现它可能需要大量的准备工作，而且通常，好处并不适用。对于小型 WPF 应用程序，我们通常在我们的
    WPF 应用程序中只有一个项目。在这些情况下，我们的类将在这个单一的项目中分离到不同的文件夹中。
- en: With larger scale applications, we arrange our classes in the same basic structure,
    but as there are more classes and more chance that we want to reuse some of this
    code, it makes sense to use separate projects instead of folders. Either way,
    our classes should end up with the same CLR namespaces, as they tend to follow
    the structure of the application, regardless of whether those classes were separated
    using folders or projects.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大规模的应用程序，我们按照相同的基本结构排列我们的类，但由于有更多的类，我们想要重用其中一些代码的可能性更大，因此使用单独的项目而不是文件夹是有意义的。无论如何，我们的类最终应该具有相同的
    CLR 命名空间，因为它们往往遵循应用程序的结构，无论这些类是使用文件夹还是项目进行分离。
- en: While the CLR namespace in our startup project might be something along the
    lines of `CompanyName.ApplicationName`, the namespace of the classes in the Models
    component would be, or start with, `CompanyName.ApplicationName.Models`. For the
    purpose of the remainder of this book, we will assume that we are dealing with
    a large-scale WPF application and using projects for the separation of our classes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在我们初创项目的 CLR 命名空间可能类似于 `CompanyName.ApplicationName`，但 Models 组件中类的命名空间将是，或者以，`CompanyName.ApplicationName.Models`
    开头。在本书的剩余部分，我们将假设我们正在处理一个大规模的 WPF 应用程序，并使用项目来分离我们的类。
- en: 'There is nothing in the MVVM pattern that dictates what structure our code
    base should have, although there are clues. We will clearly need `Views` and `ViewModels`
    projects, but the `Models` project is less clearly defined. There are several
    elements within the Models component of MVVM, but we don''t necessarily want to
    group them all into a single project in our code base. There are other projects
    that will be required too. Let''s visualize some possible structures so that we
    can get started with building our application:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 模式中没有规定我们的代码库应该有什么结构，尽管有一些线索。我们显然需要 `Views` 和 `ViewModels` 项目，但 `Models`
    项目定义得不太明确。MVVM 的 Models 组件中有几个元素，但我们不一定想将它们全部组合到我们的代码库中的单个项目中。还需要其他项目。让我们可视化一些可能的结构，这样我们就可以开始构建我们的应用程序了：
- en: '![](img/0faeb42c-346d-4736-a08d-6c26003769a3.png)![](img/26ebd2db-8063-469d-9f44-f7822aa24234.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/0faeb42c-346d-4736-a08d-6c26003769a3.png)![图片2](img/26ebd2db-8063-469d-9f44-f7822aa24234.png)'
- en: These examples offer an insight into what the project structure of an MVVM-based
    WPF application might look like. However, nothing is set in stone and we are free
    to rename and to reorganize our application projects as we see fit. The important
    thing is how the components are connected together rather than the arrangement
    of the application files.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了基于 MVVM 的 WPF 应用程序的项目结构可能是什么样的。然而，没有任何东西是固定不变的，我们可以根据需要重命名和重新组织我们的应用程序项目。重要的是组件之间的连接方式，而不是应用程序文件的排列。
- en: After we have developed a number of WPF applications, we get a feel for which
    project names and which structure we prefer, so I'd suggest trying a few variations
    and seeing which you feel more comfortable working with. Of course, some of us
    may not have the luxury of being able to create or alter the structure of the
    application that we work on. Let's first focus on the projects common to both
    example structures.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发了一系列 WPF 应用程序之后，我们会对哪些项目名称和哪些结构更偏好有所体会，所以我建议尝试几种不同的变体，看看哪种你感觉更舒适地工作。当然，我们中的一些人可能没有足够的自由来创建或修改我们所工作的应用程序的结构。让我们首先关注两个示例结构共有的项目。
- en: We see that the `Images` and `Resources` folders reside in the startup project.
    While this is customary, they *can* technically reside in any project or even
    in their own project. However, I prefer to keep them in this project because it
    provides a marginal performance benefit. Typically, when using MVVM, the only
    other files in the startup project will be the `MainWindow.xaml` and `MainWindow.xaml.cs` files, unless
    they reside with the other views, and the `App.xaml` (possibly with its code behind
    file) and `app.config` files.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `Images` 和 `Resources` 文件夹位于启动项目中。虽然这是惯例，但它们在技术上可以位于任何项目中，甚至可以位于它们自己的项目中。然而，我更喜欢将它们放在这个项目中，因为这提供了一点点性能优势。通常，在使用
    MVVM 时，启动项目中除了 `MainWindow.xaml` 和 `MainWindow.xaml.cs` 文件外，还可能有其他视图文件，以及 `App.xaml`（可能还有其代码后文件）和
    `app.config` 文件。
- en: The `Images` folder contains the images and icons that are displayed in the
    UI controls, whereas the `Resources` folder normally contains any resource files,
    such as XML schemas or text or data files that are used by the application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`Images` 文件夹包含在 UI 控件中显示的图像和图标，而 `Resources` 文件夹通常包含任何资源文件，例如 XML 架构或文本或数据文件，这些文件被应用程序使用。'
- en: The next project is named `Converters` and is fairly self-explanatory. It only
    contains classes that have implemented the `IValueConverter` or `IMultiValueConverter` interfaces
    and are used for converting data-bound values in the Views. These classes are
    all reusable and the DLL from this project should be kept up to date and shared
    among our other applications.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个项目被命名为 `Converters`，其名称相当直观。它只包含实现了 `IValueConverter` 或 `IMultiValueConverter`
    接口的类，并且用于在视图中将数据绑定值进行转换。这些类都是可重用的，并且从这个项目中生成的 DLL 应该保持最新状态，并在我们的其他应用程序之间共享。
- en: Both examples show an `Extensions` project, but this is entirely optional and
    not a requirement of the MVVM pattern. I just happen to find Extension Methods
    to be an essential part of .NET development, having built up a large collection
    of invaluable helper methods. After getting used to being able to call `Add` on
    an `IEnumerable` instance or `ToObservableCollection` on a query result, for example,
    I now reuse them in every application. We'll see some examples of these in [Chapter
    3](b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml), *Writing Custom Application Frameworks*,
    [Chapter 9](549ddd97-63f4-4e6c-8df3-6455ede31a4c.xhtml), *Implementing Responsive
    Data Validation*, and [Chapter 10](506906a3-83cb-4b51-9ac5-3c00e650198a.xhtml),
    *Completing That Great User Experience*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例都显示了一个名为 `Extensions` 的项目，但这完全是可选的，并不是 MVVM 模式的必需品。我恰好发现扩展方法是 .NET 开发的一个基本组成部分，因为我已经建立了一个包含大量宝贵辅助方法的庞大集合。例如，在习惯了在
    `IEnumerable` 实例上调用 `Add` 或在查询结果上调用 `ToObservableCollection` 之后，我现在在每一个应用程序中都重用它们。我们将在第
    3 章 [编写自定义应用程序框架](b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml)、第 9 章 [实现响应式数据验证](549ddd97-63f4-4e6c-8df3-6455ede31a4c.xhtml)和第
    10 章 [完成那个伟大的用户体验](506906a3-83cb-4b51-9ac5-3c00e650198a.xhtml)中看到这些示例。
- en: The next common project that we can see is a project called `Managers`. Others
    may prefer to call this `Engines`, `Services`, or something similar, but that
    is just a personal preference, and either way, the content will be the same. In
    this project, we typically find a number of classes that together provide a wide
    variety of functionality to the View Models.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来可以看到的下一个常见项目是一个名为 `Managers` 的项目。其他人可能更喜欢将其称为 `Engines`、`Services` 或类似名称，但这只是个人偏好，无论如何，内容都是相同的。在这个项目中，我们通常会发现许多类，这些类共同为视图模型提供了广泛的功能。
- en: For example, in this project, we might find classes named `ExportManager`, `FeedbackManager`,
    `HardDriveManager`, `WindowManager`, and so on.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这个项目中，我们可能会找到名为 `ExportManager`、`FeedbackManager`、`HardDriveManager`、`WindowManager`
    等的类。
- en: It is important to have a project like this, where we have one common place
    to provide all of the required specialized functionality for our application,
    rather than having to repeat the code in each View Model that requires that certain
    functionality. These classes are totally reusable between applications and this
    arrangement also promotes behavioral consistency throughout the application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个这样的项目非常重要，这个项目可以为我们提供一个共同的地方，用于提供应用所需的所有专用功能，而不是在每个需要该功能的 View Model 中重复代码。这些类可以在不同的应用之间完全重用，并且这种安排也有助于在整个应用中保持行为一致性。
- en: For example, without consolidating all of our functionality in this project,
    we might be tempted to copy and paste certain bits of code from one View Model
    to another. If the code then requires a change in the future, we may not remember
    that it has been copied and only update it in one View Model, thereby breaking
    the consistency of the application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果没有在这个项目中整合所有功能，我们可能会倾向于从一个 View Model 复制和粘贴某些代码到另一个 View Model。如果代码在未来需要更改，我们可能不会记得已经复制了它，并且只在一个
    View Model 中更新它，从而破坏了应用的一致性。
- en: Another benefit of utilizing a project like this is that it reduces the number
    of references that the other projects need. The `Managers` project will typically
    require many references to be added, whereas the View Model and other classes
    that make use of its functionality will only need to add a single reference to
    this project.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 利用此类项目的另一个好处是，它减少了其他项目所需的引用数量。通常，`Managers` 项目需要添加许多引用，而使用其功能的 View Model 和其他类只需添加对该项目的单个引用。
- en: Some or all of the functionality from these classes can be exposed through a
    `BaseViewModel` class and can therefore be made available to every View Model.
    We'll see more about this in [Chapter 3](b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml),
    *Writing Custom Application Frameworks*, but for now, let's start to look at the
    differences between the two structures.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类的一些或所有功能可以通过 `BaseViewModel` 类公开，因此可以提供给每个 View Model。我们将在第 3 章[编写自定义应用程序框架](b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml)中了解更多关于这一点，但现在，让我们开始探讨两种结构之间的差异。
- en: In the first structure example, the `Business` folder within the `Models` project
    simply represents the business data models of the application. There's no real
    need to have these classes in a separate `Business` folder other than the fact
    that it highlights that they are connected with the `ViewModels.Business` View
    Models and the `Views.Business` Views.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个结构示例中，`Models` 项目中的 `Business` 文件夹仅代表应用的业务数据模型。除了它们与 `ViewModels.Business`
    视图模型和 `Views.Business` 视图相关联的事实之外，实际上没有必要将这些类放在单独的 `Business` 文件夹中。
- en: Technically, the data model classes in our application should represent our
    business objects and not contain any properties that bear no relevance to the
    business model, such as properties named `CurrentItem` or `IsSelected`. If this
    were the case and they were defined in their own project, as shown in the first
    example, then we could reuse their DLL in our other business applications. Alternatively,
    perhaps we already have a DLL representing the business model from another application
    that we will be reusing in the next application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，我们应用中的数据模型类应该代表我们的业务对象，而不应包含任何与业务模型无关的属性，例如名为 `CurrentItem` 或 `IsSelected`
    的属性。如果情况如此，并且它们在它们自己的项目中定义，如第一个示例所示，那么我们可以在我们的其他业务应用中重用它们的 DLL。或者，也许我们已经有了一个代表另一个应用中的业务模型的
    DLL，我们将在下一个应用中重用它。
- en: In either of these cases, we would need to add other folders into the `ViewModels`
    project in which we would implement an additional View Model class for each business
    model class to be displayed. This arrangement is shown in the `ViewModels`. Business
    folder of the first example and demonstrates the separation of the data model
    from the Views.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况中，我们都需要在 `ViewModels` 项目中添加其他文件夹，在这些文件夹中，我们将为每个要显示的业务模型类实现一个额外的 View Model
    类。这种安排在第一个示例的 `ViewModels` 中的 `Business` 文件夹中显示，并展示了数据模型与视图之间的分离。
- en: 'In these classes, we would encapsulate each public business model property
    in a new property that raised change notification and add any further properties
    required by the UI. It would look similar to the following example, where the
    `BaseBusinessViewModel` class simply implements the `INotifyPropertyChanged` interface:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些类中，我们将每个公共业务模型属性封装在一个新的属性中，该属性会触发更改通知，并添加UI所需的任何其他属性。它看起来类似于以下示例，其中`BaseBusinessViewModel`类只是实现了`INotifyPropertyChanged`接口：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When implementing this pattern, after each data object was loaded from the
    data source, it would need to be wrapped in one of these View Model classes before
    being displayed in the UI:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现这个模式时，在从数据源加载每个数据对象之后，在将其显示在UI之前，需要将其包装在这些视图模型类之一中：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Following the pattern in the first example structure through to the `Views`
    project, we see that it also contains a `Business` folder. Typically, we could
    find a small, individual object-sized View there for each of these business model-related
    View Models. However, in the vast majority of applications, this additional level
    of separation between the business model and the UI is simply unrequired. Also,
    following this pattern adds a small overhead to all implementation and data access
    times.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 按照第一个示例结构中的模式，一直应用到`Views`项目，我们可以看到它也包含一个`Business`文件夹。通常，我们可以在那里为每个与业务模型相关的视图模型找到一个小型的、单独的对象大小的视图。然而，在绝大多数应用中，这种业务模型和UI之间的额外分离级别是根本不必要的。此外，遵循这种模式还会给所有实现和数据访问时间增加一点开销。
- en: For some, a viable alternative would be to simply add the properties and property
    change notification required by the UI straight into the data model classes. If
    we don't need this separation, then there is little point in writing all of the
    extra code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些人来说，一个可行的替代方案是将UI所需的属性和属性更改通知直接添加到数据模型类中。如果我们不需要这种分离，那么编写所有额外代码就几乎没有意义。
- en: 'I am a great fan of Agile practices and one of the twelve principles from the
    *Manifesto for Agile Software Development* summarizes this point perfectly:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常推崇敏捷实践，敏捷软件开发宣言中的十二条原则之一完美地总结了这一点：
- en: '"Simplicity--the art of maximizing the amount of work not done--is essential"'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: “简洁——最大化未完成工作的艺术——是至关重要的”
- en: This simpler, alternative implementation is shown in the `DataModels` project
    of the second example, where the business model classes are combined with the
    UI-related properties, along with the business rules or validation logic.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更简单、替代的实现方式在第二个示例的`DataModels`项目中展示，其中业务模型类与UI相关的属性相结合，以及业务规则或验证逻辑。
- en: In other types of applications, you may find a separate validation layer that
    sits between the DAL and the code behind the UI layer. But as we'll see in [Chapter
    9](549ddd97-63f4-4e6c-8df3-6455ede31a4c.xhtml), *Implementing Responsive Data
    Validation*, with WPF, we can build validation right into the business classes,
    along with the properties that they are validating.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他类型的应用中，你可能会找到一个位于DAL和UI层后面的代码之间的单独验证层。但正如我们将在第9章[实现响应式数据验证](549ddd97-63f4-4e6c-8df3-6455ede31a4c.xhtml)中看到的那样，使用WPF，我们可以在业务类中直接构建验证，包括它们正在验证的属性。
- en: This `DataModels` project contains a number of sub-folders, grouping similar
    types of classes together. The `Collections` folder typically contains an extension
    of the `ObservableCollection<T>` class for each data model class in the application.
    The `Enums` folder is also often well used in most WPF applications, as enumerations
    are great to use when data bound to either radio buttons or checkboxes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`DataModels`项目中，包含了许多子文件夹，将相似类型的类分组在一起。`Collections`文件夹通常包含应用程序中每个数据模型类的`ObservableCollection<T>`类的扩展。`Enums`文件夹在大多数WPF应用中也经常被使用，因为枚举在绑定到单选按钮或复选框时非常有用。
- en: The interfaces found in the `Interfaces` folder are essential to enable the
    functionality of the base classes, as we'll see in [Chapter 3](b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml),
    *Writing Custom Application Frameworks*. If we're likely to use a large number
    of delegates in our application, then it also makes sense to organize them into
    a separate `Delegates` folder as well. Otherwise, if a delegate is strongly tied
    to a particular class, they can just be declared locally in the classes that will
    be raising them.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Interfaces`文件夹中找到的接口对于启用基类的功能至关重要，正如我们将在[第3章](b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml)中看到的，*编写自定义应用程序框架*。如果我们可能在我们应用程序中使用大量的代理，那么将它们组织到一个单独的`Delegates`文件夹中也是有意义的。否则，如果一个代理与特定的类紧密相关，它们可以直接在将引发它们的类中声明。
- en: One other alternative would be to have a single class in the `Models` project
    that encapsulates all of the application delegates, although this would require
    prefixing the name of this class to the delegate names when using them, for example,
    `Delegates.CloseRequest`. Declaring each delegate in the class that uses them
    enables us to reference them directly, for example, `CloseRequest`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择可能是在`Models`项目中有一个单独的类，它封装了所有的应用程序代理，尽管这样做在使用它们时需要将这个类的名称作为前缀添加到代理名称之前，例如，`Delegates.CloseRequest`。在使用它们的类中声明每个代理使我们能够直接引用它们，例如，`CloseRequest`。
- en: The data model classes in this project could be thought of as View Models too,
    although View Models that only serve the display of individual objects, as opposed
    to those that serve the main application Views. They would have a base class that
    implements the `INotifyPropertyChanged` interface like the main View Models, but
    then it would also typically implement a validation error interface too.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目中的数据模型类也可以被视为视图模型，尽管它们只服务于单个对象的显示，而不是服务于主应用程序的视图。它们将有一个基类，实现与主视图模型相同的`INotifyPropertyChanged`接口，然后通常还会实现一个验证错误接口。
- en: They also differ from the main application View Models because they generally
    provide no functionality other than validation to their associated Views. We can
    think of these classes as mere data containers with a few extra properties to
    enable effective communication with the UI.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也与主应用程序的视图模型不同，因为它们通常只为它们关联的视图提供验证以外的功能。我们可以将这些类视为仅具有一些额外属性以实现与UI有效通信的简单数据容器。
- en: When following this structure, we can render these individual object-sized View
    Models in the UI using data templates, so we generally don't need to declare a
    separate View for each of them. Furthermore, we may want to display the same objects
    differently in different parts of the application, or even switch their display
    in response to some user action and that is also easier to accomplish with data
    templates.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当遵循这种结构时，我们可以使用数据模板在UI中渲染这些单个对象大小的视图模型，所以我们通常不需要为每个它们声明一个单独的视图。此外，我们可能希望在应用程序的不同部分以不同的方式显示相同的对象，或者甚至根据某些用户操作切换它们的显示，而这也可以通过数据模板更容易地实现。
- en: This explains why these objects do not reside in the View Models project along
    with the main application View Models. If you remember, each View Model should
    only have one associated View. For the purpose of this book, this simpler, alternative
    implementation is the pattern that we will be following. Now, let's continue by
    investigating the DAL of the application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了为什么这些对象不与主应用程序的视图模型一起位于`View Models`项目中。如果你还记得，每个视图模型应该只关联一个视图。为了本书的目的，这种更简单、替代的实现方式是我们将遵循的模式。现在，让我们继续通过调查应用程序的DAL（数据访问层）来继续。
- en: The `DataProviders` project from the first example is responsible for providing
    access to the persisted data source of the application. Another commonly used
    name is `Repositories`, but again, you can call it what you like. The important
    thing is that it has an essential `Interfaces` folder that contains one or more
    interfaces that form the connection between the data source(s) and the rest of
    the application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例中的`DataProviders`项目负责提供对应用程序持久数据源的访问。另一个常用的名称是`Repositories`，但同样，你可以称它为你喜欢的名字。重要的是它有一个包含一个或多个接口的`Interfaces`文件夹，这些接口形成了数据源（们）与应用程序其余部分之间的连接。
- en: The `DataProviders` and `Interfaces` folders in the second example appear within
    the `Models` project, but they have the same responsibilities. Either way, it
    is through the use of these interfaces that we are able to disconnect the data
    source and replace it with a mock source of some kind when testing. We will look
    at an example of this in [Chapter 3](b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml),
    *Writing Custom Application Frameworks*, but for now, let's continue.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，“数据提供程序”和“接口”文件夹位于“模型”项目中，但它们具有相同的职责。无论如何，正是通过使用这些接口，我们能够断开数据源，并在测试时用某种类型的模拟源替换它。我们将在[第3章](b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml)“编写自定义应用程序框架”中查看一个示例，但现在让我们继续。
- en: The `ViewModels` project is fairly easy to understand, as it just contains View
    Models. You may be wondering why there is a `Commands` folder inside it. If we
    were using commands in the old fashioned way, writing a separate class for each
    command, then we could end up with a great many classes and that would probably
    warrant putting them into their own project.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: “视图模型”项目相当容易理解，因为它只包含视图模型。你可能想知道为什么它里面有一个“命令”文件夹。如果我们像过去那样使用命令，为每个命令编写一个单独的类，那么我们可能会得到很多类，这可能会要求我们将它们放入自己的项目中。
- en: However, if you remember, we will be using only one single command, the `ActionCommand`.
    As this will be used by the View Model classes alone, it makes sense to include
    it in their project. We've already covered the differences in the View Models
    and Views projects between the two example structures, so let's finish off looking
    at the remaining common parts.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你记得，我们将只使用一个单独的命令，即“操作命令”。由于这个命令将由视图模型类单独使用，因此将其包含在它们的项目中是有意义的。我们已经讨论了两个示例结构之间视图模型和视图项目之间的差异，所以让我们完成对剩余共同部分的查看。
- en: We often find an `Attached` folder in the `Views` project that contains the
    Attached Properties that are used in the application. As these classes contain
    View-related code and are only used by the Views, it is logical that they should
    reside here. Alongside that, we see the `Controls` folder where we find reusable
    user controls and/or custom controls, such as a custom textbox that spawns a child
    window to help with editing when clicked or a custom clock face that can be used
    to enter a time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常在“视图”项目中找到一个名为“附件”的文件夹，其中包含应用程序中使用的附件属性。由于这些类包含与视图相关的代码，并且仅由视图使用，因此它们应该位于此处是合乎逻辑的。除此之外，我们还可以看到“控件”文件夹，其中包含可重用的用户控件和/或自定义控件，例如，当点击时可以弹出一个子窗口以帮助编辑的自定义文本框，或者可以用来输入时间的自定义时钟面。
- en: At the bottom of both example structures, we see the test projects that contain
    the code that tests our application. If your application needs testing, this is
    a good pattern to follow. By prefixing the name of the projects that we will be
    testing with a `Test` domain, they will all appear in the Visual Studio Solution
    Explorer in one group, either above or below the other projects, and in the same
    order as the projects being tested.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个示例结构的底部，我们看到包含测试应用程序代码的测试项目。如果你的应用程序需要测试，这是一个很好的模式。通过在我们的测试项目名称前加上“测试”域，它们将全部出现在Visual
    Studio解决方案资源管理器中的一个组中，要么在其它项目之上或之下，并且按照测试项目的顺序排列。
- en: 'The `Mocks` project typically hosts the application objects to be used while
    testing the application. This would normally include any mock data generation
    or provider classes and mock `Manager` classes. We may need to create these mock
    `Manager` classes if we don''t want to use expensive resources while testing,
    or in case they access any UI elements that we also want to avoid when testing.
    Let''s take a look at an example of one possible method of a `UiThreadManager`
    class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: “模拟”项目通常包含在测试应用程序时使用的应用程序对象。这通常包括任何模拟数据生成或提供程序类以及模拟“管理器”类。如果我们不想在测试时使用昂贵的资源，或者它们访问我们希望在测试时避免的任何UI元素，我们可能需要创建这些模拟“管理器”类。让我们看看`UiThreadManager`类的一个可能的方法示例：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This method is fairly straightforward and enables us to pass a reference to
    any method that we want to run asynchronously. It simply passes the method reference
    to the `Task.Run` method and lets it do its thing. It can be called like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法相当直接，使我们能够传递任何我们想要异步运行的方法的引用。它只是将方法引用传递给`Task.Run`方法，并让它自行处理。它可以这样调用：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, running code asynchronously in unit tests can have unpredictable results
    that may make them fail. Therefore, when testing, we need to use a `MockUiThreadManager`
    class and implement its `RunAsynchronously` method, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在单元测试中异步运行代码可能会产生不可预测的结果，这可能导致测试失败。因此，在测试时，我们需要使用`MockUiThreadManager`类并实现其`RunAsynchronously`方法，如下所示：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this method, we can see that we use the `RunSynchronously` method of the
    `Task` class to run the referenced method synchronously, or in other words, immediately
    and on the same thread. In effect, this simply bypasses the functionality of the
    original method. Using these mock objects enable us to run different code while
    testing than we do at runtime. We'll see more examples of these mock objects in
    [Chapter 3](b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml), *Writing Custom Application
    Frameworks*, but let's first take a look back at what we have covered so far.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们可以看到我们使用`Task`类的`RunSynchronously`方法来同步运行引用的方法，换句话说，立即在同一线程上运行。实际上，这仅仅绕过了原始方法的功能。使用这些模拟对象，我们可以在测试时运行与运行时不同的代码。我们将在[第3章](b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml)中看到更多这些模拟对象的例子，*编写自定义应用程序框架*，但让我们首先回顾一下到目前为止我们已经覆盖了什么内容。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have discovered what the MVVM architectural pattern is and
    the benefits of using it when developing WPF applications. We're now in a better
    position to decide which applications to use it with and which not to. We started
    looking into the various new ways of communicating between the various components
    of this pattern and also investigated the most common ways of organizing our source
    code. We are now ready to start setting out our own application structures.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经了解了MVVM架构模式及其在开发WPF应用程序时的好处。我们现在处于更好的位置来决定哪些应用程序可以使用它，哪些不适用。我们开始研究这种模式中各个组件之间通信的各种新方法，并调查了组织源代码最常见的方式。我们现在准备开始制定我们自己的应用程序结构。
- en: In the next chapter, before we properly get started building our application,
    we'll look at several methods of the sometimes tricky task of debugging our data
    bound values. We'll discover other useful tips and tricks that we can use to help
    us to iron out any problems that may occur in our applications so that once we
    start building, we'll be able to avoid wasting time with problems that may arise.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，在我们正式开始构建我们的应用程序之前，我们将探讨几种调试数据绑定值这一有时棘手任务的方法。我们将发现其他有用的技巧和窍门，这些技巧和窍门可以帮助我们消除应用程序中可能出现的任何问题，这样一旦我们开始构建，我们就能避免浪费时间在可能出现的问题上。
