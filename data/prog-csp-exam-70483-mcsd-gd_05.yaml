- en: Creating and Implementing Events and Callbacks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和实现事件与回调
- en: This chapter focuses on events and callbacks in C#. They are important to understand
    since they give us more control over programs. An event is a message or notification
    from an object when either its property has been changed or a button has been
    clicked. A callback, also known as a delegate, holds a reference to a function.
    C# comes with Lambda expressions, which can be used to create delegates. These
    are also called anonymous methods.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍C#中的事件和回调。了解它们很重要，因为它们使我们能够更好地控制程序。事件是对象属性更改或按钮被点击时发出的消息或通知。回调，也称为代理，持有函数的引用。C#自带Lambda表达式，可以用来创建代理。这些也被称为匿名方法。
- en: We will also spend some time looking at a new operator, known as a Lambda operator.
    These are used in Lambda expressions. They were introduced in version 3.0 of C#
    so that developers could instantiate delegates. Lambda expressions replaced the
    anonymous methods that were introduced in C# 2.0 and are now widely used.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将花一些时间了解一个新的运算符，称为Lambda运算符。这些用于Lambda表达式。它们是在C# 3.0版本中引入的，以便开发人员可以实例化代理。Lambda表达式取代了C#
    2.0中引入的匿名方法，并且现在被广泛使用。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding delegates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解代理
- en: Handling and raising events
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理和引发事件
- en: By the end of this chapter, you will know what delegates are and how you can
    use them in events and callbacks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解代理是什么以及如何在事件和回调中使用它们。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The exercises in this chapter can be practiced using Visual Studio 2012 or above
    with .NET Framework 2.0 or above. However, any new C# features from 7.0 onward
    require that you have Visual Studio 2017 installed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的练习可以使用Visual Studio 2012或更高版本以及.NET Framework 2.0或更高版本进行练习。然而，从7.0版本开始的所有新的C#功能都需要您安装Visual
    Studio 2017。
- en: If you don't have a license for any of the aforementioned products, you can
    download the community version of Visual Studio 2017 from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有上述任何产品的许可证，您可以下载Visual Studio 2017的社区版，网址为：[https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)。
- en: The sample code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide](https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在GitHub上找到：[https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide](https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide)。
- en: Understanding delegates
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解代理
- en: A **delegate** is nothing but a reference to a method, along with some parameters
    and a return type. When a delegate is defined, it can be associated with any instance
    that provides a compatible signature and a return type of the method. In other
    terms, delegates can be defined as function pointers in C and C++. However, delegates
    are type-safe, secure, and object-oriented.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**代理**实际上只是一个方法引用，包括一些参数和一个返回类型。当定义代理时，它可以与任何提供兼容签名和方法返回类型的实例相关联。换句话说，代理在C和C++中可以定义为函数指针，但代理是类型安全、安全且面向对象的。'
- en: A delegate model follows the observer pattern, which allows the subscriber to
    register with and receive notifications from the provider. To get a better understanding
    of the observer pattern, take a look at the references provided at the end of
    this chapter, in the *Further reading* section.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模型遵循观察者模式，允许订阅者注册并从提供者接收通知。为了更好地理解观察者模式，请参阅本章末尾的“进一步阅读”部分提供的参考资料。
- en: A classic example of a delegate is event handlers in a Windows application,
    which are methods that are invoked by delegates. In the context of events, a delegate
    is an intermediary between the event source and the code that handles the event.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 代理的一个经典例子是Windows应用程序中的事件处理器，这些是代理调用的方法。在事件处理的上下文中，代理是事件源和处理事件代码之间的中介。
- en: Delegates are ideal for callbacks because of their ability to pass methods as
    parameters. Delegates are derived from the `System.Delegate` class.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代理能够将方法作为参数传递，因此它们非常适合回调。代理是从`System.Delegate`类派生出来的。
- en: 'The general syntax of `delegate` is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`delegate`的一般语法如下：'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An example of a delegate declaration is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 代理声明的示例如下：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, the delegate that's been defined can be referenced
    by any method that has a single string parameter and returns a string variable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，定义的委托可以被任何具有单个字符串参数并返回字符串变量的方法引用。
- en: Instantiating a delegate
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化一个委托
- en: The named method can be used to a when we're using versions of C# prior to 2.0\.
    Version 2.0 introduced a new way to instantiate delegates. We will try to understand
    these methods in the upcoming sections. Version 3.0 of C# replaces anonymous methods
    with Lambda expressions, which are now widely used.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用C# 2.0之前的版本时，可以使用命名方法。2.0版本引入了一种新的实例化委托的方法。我们将在接下来的章节中尝试理解这些方法。C# 3.0版本用Lambda表达式替换了匿名方法，Lambda表达式现在被广泛使用。
- en: Initiating delegates using NamedMethod
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命名方法初始化委托
- en: 'Let''s look at an example of `NamedMethod` so that we can understand how to
    initiate a `delegate`. This is the method that was used prior to C# 2.0:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`NamedMethod`的一个例子，以便我们了解如何初始化一个`delegate`。这是在C# 2.0之前使用的方法：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, first, we defined a delegate called `MathDelegate`, which
    accepts `2` parameters, `1` integer and another double type. Then, we defined
    a class where we wanted to invoke `MathDelegate` using a named method known as
    `Multiply`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先我们定义了一个名为`MathDelegate`的委托，它接受`2`个参数，`1`个整数和另一个双精度类型。然后，我们定义了一个类，我们想在其中使用一个名为`Multiply`的命名方法来调用`MathDelegate`。
- en: The `MathDelegate d = m.Multiply;` line is where we assigned a named method
    to a delegate.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`MathDelegate d = m.Multiply;`这一行是将一个命名方法赋值给委托。'
- en: Named method delegates can encapsulate a static or instance method with any
    accessible class or structure that matches the type of delegate. This allows the
    developer to extend these methods.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 命名方法委托可以封装任何可访问的类或结构，这些类或结构与委托类型匹配，从而允许开发者扩展这些方法。
- en: 'In the following example, we will see how a delegate can be mapped to static
    and instance methods. Add the following method to the `Chapter5Samples` class
    we created previously:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将看到如何将委托映射到静态和实例方法。将以下方法添加到我们之前创建的`Chapter5Samples`类中：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we defined two methods: the first one is a normal method,
    while the second one is a static method. In the case of invoking delegates using
    a named method, we can either use the first normal method or the second static
    method:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了两个方法：第一个是一个普通方法，而第二个是一个静态方法。在调用使用命名方法的委托的情况下，我们可以使用第一个普通方法或第二个静态方法：
- en: '`SampleDelegate d = helper.InstanceMethod;`: This is a normal method.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SampleDelegate d = helper.InstanceMethod;`: 这是一个普通方法。'
- en: '`d = HelperClass.StaticMethod;`: This is a static method.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d = HelperClass.StaticMethod;`: 这是一个静态方法。'
- en: Initiating a delegate using anonymous functions
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用匿名函数初始化委托
- en: In a situation where creating new methods can be classed as overhead, C# allows
    us to initiate a delegate and specify a code block. The delegate will process
    this code block when it is invoked. This is the method that's used in C# 2.0 to
    invoke delegates. They are also known as anonymous methods.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新方法可能被视为开销的情况下，C# 允许我们初始化一个委托并指定一个代码块。当委托被调用时，它将处理这个代码块。这是C# 2.0中用于调用委托的方法。它们也被称为匿名方法。
- en: An expression or a statement that's defined inline instead of a delegate type
    is known as an anonymous function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个内联定义的表达式或语句，而不是委托类型，被称为匿名函数。
- en: 'There are two types of anonymous function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种匿名函数：
- en: Lambda expressions
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: Anonymous methods
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名方法
- en: We will look at these two types of functions in the upcoming subsections. However,
    before we move on, we should also understand one new operator, called the **Lambda
    operator**. This is used to represent Lambda expressions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的小节中查看这两种类型的函数。然而，在继续之前，我们还应该了解一个新运算符，称为**Lambda运算符**。这个运算符用于表示Lambda表达式。
- en: Lambda expressions
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: With C# 3.0, Lambda expressions were introduced and are widely used in invoking
    delegates. Lambda expressions are created using Lambda operators. On the left-hand
    side of the operator, we specify the input parameters, while on the left-hand
    side, we specify the expression or code block. When a Lambda operator is used
    in an expression body, it separates the member's name from the member's implementation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 3.0开始，引入了Lambda表达式，并且在调用委托时被广泛使用。Lambda表达式是通过Lambda运算符创建的。在运算符的左侧，我们指定输入参数，而在右侧，我们指定表达式或代码块。当Lambda运算符在表达式体中使用时，它将成员的名称与其实现分开。
- en: The Lambda operator is represented as a `=>` token. This operator is right-associative
    and has the same precedence as an assignment operator. An assignment operator
    assigns a right-hand operand value to a left-hand operand.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 操作符表示为 `=>` 符号。这个操作符是右结合的，并且与赋值操作符具有相同的优先级。赋值操作符将右侧操作数的值赋给左侧操作数。
- en: 'In the following code, we are using a Lambda operator to compare a specific
    word in a string array and return it. Here, we are applying a Lambda expression
    to each element of the `words` array:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们使用 Lambda 操作符来比较字符串数组中的一个特定单词并返回它。在这里，我们将 Lambda 表达式应用于 `words` 数组的每个元素：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example also shows how we can use a LINQ query to get the same output.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例还展示了我们如何使用 LINQ 查询来获得相同的结果。
- en: 'We are trying to find "apple" from an array of words using a LINQ query. Any
    enumerable collection allows us to query using LINQ and returns the desired output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试使用 LINQ 查询从一个单词数组中找到 "apple"。任何可枚举集合都允许我们使用 LINQ 进行查询，并返回所需的结果：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A Lambda expression is the right-hand side operator of a Lambda operator and
    is widely used in expression trees.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式是 Lambda 操作符的右侧操作符，并且在表达式树中得到了广泛的应用。
- en: More information on expression trees can be on the Microsoft documentation website.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于表达式树的信息可以在 Microsoft 文档网站上找到。
- en: This Lambda expression must be a valid expression. If the member type is void,
    it's classed as a statement expression.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Lambda 表达式必须是一个有效的表达式。如果成员类型是 void，它会被归类为语句表达式。
- en: From C# 6 onward, these expressions support method and property get statements,
    while from C# 7 onward, these expressions support constructors, finalizers, property
    set statements, and indexers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 6 开始，这些表达式支持方法和属性获取语句，而从 C# 7 开始，这些表达式支持构造函数、析构函数、属性设置语句和索引器。
- en: 'In the following code, we are using an expression to write the first name and
    last name of the variable and we have also used the `Trim()` function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们使用表达式来编写变量的第一个名字和最后一个名字，并且我们还使用了 `Trim()` 函数：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this basic understanding of Lambda expressions and the Lambda operator,
    we can move on and look at how we can use Lambda expressions to invoke a delegate.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 Lambda 表达式和 Lambda 操作符有了基本理解之后，我们可以继续探讨如何使用 Lambda 表达式来调用委托。
- en: 'Recall that a Lambda expression can be represented like so:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，Lambda 表达式可以表示如下：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the following example, two extra lines have been added to the existing method
    to invoke the delegate using a Lambda expression. `X` is the input parameter,
    where the type of `X` is identified by the compiler:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们向现有方法中添加了两行代码来使用 Lambda 表达式调用委托。`X` 是输入参数，其中 `X` 的类型由编译器确定：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Anonymous methods
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名方法
- en: C# 2.0 introduced anonymous methods, while C# 3.0 introduced Lambda expressions,
    which were later replaced with anonymous methods.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: C# 2.0 引入了匿名方法，而 C# 3.0 引入了 Lambda 表达式，后来 Lambda 表达式被匿名方法所取代。
- en: One case where anonymous methods provide functionality that isn't possible when
    using a Lambda expression is that they allow us to avoid parameters. These allow
    anonymous methods to be converted into delegates with a number of different signatures.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Lambda 表达式时，匿名方法提供了一些使用 Lambda 表达式时无法实现的功能，例如，它们允许我们避免参数。这些允许匿名方法转换为具有不同签名的委托。
- en: 'Let''s look at an example of how to use anonymous methods to initiate a delegate:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用匿名方法来初始化委托的示例：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, we defined a string delegate and wrote some inline code
    to invoke it. The following is the code where we defined the inline delegate,
    also known as an anonymous method:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个字符串委托并编写了一些内联代码来调用它。以下是我们定义内联委托（也称为匿名方法）的代码：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following code shows how we can create an anonymous method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何创建匿名方法：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we created a code block and passed it as a `delegate` parameter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个代码块并将其作为 `delegate` 参数传递。
- en: An anonymous method will throw an error if the runtime encounters any jump statements,
    such as `goto`, `break`, or `continue`, inside the code block and the target is
    outside the code block. Also, in a scenario where a jump statement is outside
    the code block and the target is in it, with the `int` anonymous method, an exception
    will be thrown.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在代码块内部遇到任何跳转语句（如 `goto`、`break` 或 `continue`），并且目标在代码块外部，匿名方法将抛出错误。此外，在跳转语句在代码块外部且目标在内部的情况下，使用
    `int` 匿名方法将抛出异常。
- en: 'Any local variables that are created outside of the delegate''s scope and contained
    in an anonymous method declaration are called *outer* variables of the anonymous
    method. For example, in the following code segment, `n` is an outer variable:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在委托作用域之外创建并包含在匿名方法声明中的局部变量被称为匿名方法的*外部变量*。例如，在下面的代码段中，`n`是一个外部变量：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Anonymous methods are not allowed on the left-hand side of the is operator.
    No unsafe code can be accessed or used in an anonymous method, including the `in`,
    `ref`, or `out` parameters of an outer scope.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名方法不允许在is操作符的左侧。在匿名方法中不能访问或使用不安全代码，包括外部作用域的`in`、`ref`或`out`参数。
- en: Variance in delegates
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托中的方差
- en: C# supports variance in delegate types with matching method signatures. This
    feature was introduced in .NET Framework 3.5\. This means delegates can now be
    assigned with matching signatures but also that methods can return derived types.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: C#支持具有匹配方法签名的委托类型中的协变。这个特性是在.NET Framework 3.5中引入的。这意味着委托现在可以分配具有匹配签名的委托，同时方法也可以返回派生类型。
- en: If a method has a return type derived from the one defined in a delegate, it
    is defined as covariance in delegates. Similarly, if a method has fewer derived
    parameter types than those defined in a delegate, it is defined as contravariance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法的返回类型是从在委托中定义的类型派生出来的，那么它在委托中定义为协变。同样，如果一个方法具有比在委托中定义的派生参数类型更少的类型，那么它定义为逆变。
- en: Let's look at an example to understand covariance. For the purpose of this example,
    we will create a few classes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解协变。为了这个例子，我们将创建几个类。
- en: 'Here, we will create the `ParentReturnClass`, `Child1ReturnClass`, and `Child2Return`
    classes. Each of these has a string type property. Both child classes are inherited
    from `ParentReturnClass`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建`ParentReturnClass`、`Child1ReturnClass`和`Child2Return`类。这些类中的每一个都有一个字符串类型属性。这两个子类都是从`ParentReturnClass`继承的：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s add two new methods to the previously defined helper class, each
    returning the respective child classes we defined earlier:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向之前定义的辅助类添加两个新方法，每个方法返回我们之前定义的相应子类：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we will define a delegate that returns `ParentReturnClass`. We''ll also
    define a new method that will initiate this delegate for each of the child methods.
    One important point to observe in the following code is that we have used explicit
    typecast to convert `ParentReturnClass` into `ChildReturnClass1` and `ChildReturnClass2`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义一个返回`ParentReturnClass`的委托。我们还将定义一个新的方法，将为每个子方法初始化这个委托。在下面的代码中，一个重要的观察点是，我们使用了显式类型转换将`ParentReturnClass`转换为`ChildReturnClass1`和`ChildReturnClass2`：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, the delegate is returning `ParentReturnClass`. However,
    both `ChildMethod1` and `ChildMethod2` are returning child classes that were inherited
    from `ParentReturnClass`. This means that methods that return more derived types
    than those defined in the delegate are permitted. This is called covariance.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，委托返回`ParentReturnClass`。然而，`ChildMethod1`和`ChildMethod2`都返回从`ParentReturnClass`继承的子类。这意味着允许返回比在委托中定义的类型更派生的类型的方法。这被称为协变。
- en: 'Now, let''s look at another example to understand contravariance. Extend the
    previously created helper class by adding a new method that accepts `ParentReturnClass`
    as a parameter and returns void:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再看另一个例子来了解逆变。通过添加一个接受`ParentReturnClass`作为参数并返回void的新方法来扩展之前创建的辅助类：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Define a delegate that accepts `Child1ReturnClass` as a parameter:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个接受`Child1ReturnClass`作为参数的委托：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, create a method to initiate the delegate:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个初始化委托的方法：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because method one works with the parent class, it will definitely work with
    the class that is inherited from the parent class. C# permits fewer derived types
    as parameters than those defined in the delegate.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因为第一个方法与父类一起工作，所以它肯定可以与从父类继承的类一起工作。C#允许的派生类型参数比在委托中定义的少。
- en: Built-in delegates
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置委托
- en: 'So far, we have seen how we can create custom delegates and use them in our
    program. C# comes with a couple of built-in delegates, which developers can use
    instead of having to create custom delegates. They are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何创建自定义委托并在我们的程序中使用它们。C#自带一些内置委托，开发者可以使用它们而不是必须创建自定义委托。它们如下所示：
- en: '`Func`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Func`'
- en: '`Action`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Action`'
- en: '`Func` takes zero or more parameters and returns one value as an `out` parameter,
    whereas `Action` accepts zero or more parameters but returns nothing.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Func`接受零个或多个参数，并以一个`out`参数返回一个值，而`Action`接受零个或多个参数但不返回任何内容。'
- en: 'There is no requirement to declare an explicit delegate when working with `Func`
    or `Action`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `Func` 或 `Action` 时，不需要显式声明委托：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`Action` can be defined as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action` 可以定义为以下内容：'
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we mentioned earlier, both take zero or more parameters. C# supports 16 different
    forms of both delegates, all of which can be used in our program.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，它们都接受零个或多个参数。C# 支持 16 种不同的委托形式，所有这些都可以在我们的程序中使用。
- en: 'The general form of `Func` with two or more parameters is as follows. It takes
    comma-separated in and out parameters, where the last parameter is always an out
    parameter called `TResult`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Func` 具有两个或更多参数的一般形式如下。它接受逗号分隔的输入和输出参数，其中最后一个参数始终是一个名为 `TResult` 的输出参数：'
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Similar to `Func`, here is the general form for `Action` with two or more parameters:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Func` 类似，`Action` 具有两个或更多参数的一般形式如下：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Multicast delegates
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多播委托
- en: Invoking more than one method through a delegate is called multicasting. You
    can use `+`, `-`, `+=`, or `-+` to add or remove methods from the list of invoking
    methods. This list is called the invocation list. It's used in event handling.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过委托调用多个方法称为多播。您可以使用 `+`、`-`、`+=` 或 `-+` 来向调用方法列表中添加或删除方法。这个列表称为调用列表。它在事件处理中使用。
- en: 'The following example shows how we can invoke multiple methods by invoking
    a delegate. We have two methods, both of which accept a string parameter and display
    it on the screen. In the multicast delegate method, we are associating two methods
    with `stringdelegate`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了我们如何通过调用委托来调用多个方法。我们有两个方法，它们都接受一个字符串参数并在屏幕上显示它。在多播委托方法中，我们将两个方法与 `stringdelegate`
    关联：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Handling and raising events
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理和引发事件
- en: As we mentioned in the introduction of this chapter, events are any actions,
    such as a keypress, mouse movement, or I/O operation, performed by the user. Sometimes,
    events can be raised by system-generated operations such as creating/updating
    a record in a table.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章引言中提到的，事件是由用户执行的动作，例如按键、鼠标移动或 I/O 操作。有时，事件可以通过系统生成的操作引发，例如在表中创建/更新记录。
- en: .NET Framework events are based on the delegate model, which follows the observer
    pattern. The observer pattern allows a subscriber to register for notifications
    and a publisher to register for push notifications. It's like late binding and
    is a way for an object to broadcast that something has happened.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 框架事件基于委托模型，该模型遵循观察者模式。观察者模式允许订阅者注册通知，并允许发布者注册推送通知。这就像延迟绑定，是对象广播发生某些事情的一种方式。
- en: A design pattern that allows you to subscribe/unsubscribe to a stream of events
    coming from a publisher is called an observer pattern.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 允许您订阅/取消订阅来自发布者的事件流的模式称为观察者模式。
- en: For example, in the previous chapter, we worked on a code snippet where the
    program finds whether the character that was entered by the user is a vowel or
    not. Here, the user pressing a key on the keyboard is the publisher, which notifies
    the program regarding which key was pressed. Now, our program, which is a subscriber
    to the provider, responds to it by checking whether the character that was entered
    was a vowel or not and displays it on the screen.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在上一章中，我们处理了一个代码片段，该程序用于查找用户输入的字符是否为元音。在这里，用户按下键盘上的键是发布者，它通知程序有关按下的键。现在，我们的程序，作为提供者的订阅者，通过检查输入的字符是否为元音并显示在屏幕上对此做出响应。
- en: A message that's sent by an object to notify it that an action has occurred
    is called an event. The object that raises this event is called an event sender
    or publisher. An object that receives and responds to an event is called a subscriber.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对象发送的消息以通知它已发生某些操作称为事件。引发此事件的对象称为事件发送者或发布者。接收并响应事件的对象称为订阅者。
- en: A publisher event can have multiple subscribers, while a subscriber can handle
    publishing events. Remember that multicast delegates, which we discussed in the
    previous sections, are extensively used in events (publish-subscribe pattern).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者事件可以有多个订阅者，而订阅者可以处理发布事件。请记住，我们之前章节中讨论的多播委托在事件（发布-订阅模式）中得到了广泛的应用。
- en: By default, if a publisher has multiple subscribers, all are invoked synchronously.
    C# supports calling these event methods asynchronously. We will understand this
    in more detail in the upcoming chapters.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果发布者有多个订阅者，它们都会同步调用。C# 支持异步调用这些事件方法。我们将在接下来的章节中详细了解这一点。
- en: 'Before we dive into an example, let''s try to understand a few of the terms
    we are going to use:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入示例之前，让我们尝试理解我们将要使用的一些术语：
- en: '| `event` | This is a keyword that''s used to define an event in the `publisher`
    class in C#. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `event` | 这是一个关键字，用于在C#中的`publisher`类中定义事件。|'
- en: '| `EventHandler` | This method is used to handle an event. This may or may
    not have event data. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `EventHandler` | 此方法用于处理事件。这可能包含或不包含事件数据。|'
- en: '| `EventArgs` | It represents a base class for the class that contains event
    data. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `EventArgs` | 它代表包含事件数据的类的基类。|'
- en: 'Event handlers support two variations: one with no event data and another with
    event data. The following code represents a method that handles an event with
    no event data:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器支持两种变体：一种没有事件数据，另一种有事件数据。以下代码表示一个处理没有事件数据的事件的函数：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following code represents a method that handles an event with event data:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表示一个处理带有事件数据的事件的函数：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's look at an example and try to understand how we can raise events and handle
    them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例，并尝试理解我们如何引发事件并处理它们。
- en: In this scenario, we are going to have a banking application where customers
    make transactions such as creating new accounts, looking at their credit and debit
    amounts, and making requests for their total balance. We will raise events whenever
    such a transaction is made and notify the customer.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们将有一个银行应用程序，客户可以进行创建新账户、查看他们的信用和借记金额以及请求他们的总余额等交易。每当进行此类交易时，我们将引发事件并通知客户。
- en: 'We will start with an `Account` class (`publisher` class), along with all the
    supporting methods, such as `credit()`, `debit()`, `showbalance()`, and `initialdeposit()`.
    These are the types of transactions a customer can operate their account with.
    Because the customer needs to be notified whenever such a transaction happens,
    we will define an event and an event handler with event data to handle the event:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`Account`类（`publisher`类）开始，以及所有支持的方法，如`credit()`、`debit()`、`showbalance()`和`initialdeposit()`。这些都是客户可以操作其账户的交易类型。因为客户需要在每次此类交易发生时得到通知，我们将定义一个事件和一个带有事件数据的事件处理器来处理该事件：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You may have observed the new class that we used in the previous example, that
    is, `TrasactionEventArgs`. This class carries event data. We are going to define
    this class now, which inherits from the `EventArgs` base class. We are going to
    define two variables, `amt` and `type`, to carry variables to the event handler:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了我们在上一个示例中使用的新类，即`TrasactionEventArgs`。这个类携带事件数据。我们现在将定义这个类，它继承自`EventArgs`基类。我们将定义两个变量，`amt`和`type`，以携带变量到事件处理器：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s define a subscriber class to test how our event and event handler
    work. Here, we will define an `AlertCustomer` method whose signature matches the
    delegate that was declared in the `publisher` class. Pass a reference of this
    method to the delegate so that it reacts to the event:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个订阅者类来测试我们的事件和事件处理器是如何工作的。在这里，我们将定义一个`AlertCustomer`方法，其签名与在`publisher`类中声明的代理相匹配。将此方法的引用传递给代理，以便它对事件做出反应：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When you execute the preceding program, for each transaction made, a transaction
    handler event is raised that invokes the notify-customer method and displays what
    type of transactions took place on the screen, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行前面的程序时，对于每次进行的交易，都会引发一个交易处理器事件，该事件调用通知客户方法并在屏幕上显示发生了什么类型的交易，如下所示：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about delegates and how we can define, initiate,
    and use them in our program. We understood variance in delegates, built-in delegates,
    and multicast delegates. Finally, we looked at how delegates form the base for
    events before understanding events, event handlers, and `EventArgs`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了代理以及我们如何在程序中定义、启动和使用它们。我们了解了代理的变体、内置代理和多播代理。最后，我们在理解事件、事件处理器和`EventArgs`之前，研究了代理如何成为事件的基础。
- en: Now, we can say that events encapsulate delegates and that delegates encapsulate
    methods.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以说事件封装了代理，而代理封装了方法。
- en: In the next chapter, we will learn about multithreading and asynchronous processing
    in C#. We will understand and use threads in our program, and understand tasks,
    parallel classes, async, await, and much more.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习C#中的多线程和异步处理。我们将理解并使用程序中的线程，了解任务、并行类、async、await以及更多内容。
- en: Questions
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Delegates are ideal for ___ because of their ability to pass a method as a parameter.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理非常适合___，因为它们能够将方法作为参数传递。
- en: Multicast delegates
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多播代理
- en: Built-in delegates
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内置委托
- en: Callbacks
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回调
- en: Events
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件
- en: What are the different ways to initiate delegates? Choose all that apply.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些不同的方式来初始化委托？选择所有适用的。
- en: Anonymous methods
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匿名方法
- en: Lambda expressions
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: Named methods
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名方法
- en: All of the above
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有上述选项
- en: Which method can have a derived return type than the one defined in the delegate.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个方法可以有比在委托中定义的返回类型更派生的类型？
- en: Anonymous method
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匿名方法
- en: Covariance
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 协变
- en: Anonymous function
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匿名函数
- en: Lambda expression
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: Which built-in delegate accepts zero or more parameters and returns void?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个内置委托接受零个或多个参数并返回 void？
- en: '`Action`'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Action`'
- en: '`Func`'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Func`'
- en: '`event`'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`event`'
- en: '`delegate`'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`delegate`'
- en: Which of the following is used in the declaration of a C# event?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 C# 事件声明中，以下哪个被使用？
- en: '`event`'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`event`'
- en: '`delegate`'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`delegate`'
- en: '`EventHandler`'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EventHandler`'
- en: '`class`'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`class`'
- en: A subscriber can notify the publisher about a change that happened to an object.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅者可以通知发布者关于对象发生的更改。
- en: 'True'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'True'
- en: 'False'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'False'
- en: Answers
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '**Callbacks**'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**回调**'
- en: '**All of the above**'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**所有上述选项**'
- en: '**Covariance**'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**协变**'
- en: '**Action**'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Action**'
- en: '**event**'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**event**'
- en: '**False**'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**False**'
- en: Further reading
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To get a better understanding of the observer pattern, please take a look at
    [https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern](https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解观察者模式，请查看[https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern](https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern)。
- en: 'The following is a good article that talks about declaring, initiating, and
    using delegates. Samples can also be found there: [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/how-to-declare-instantiate-and-use-a-delegate](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/how-to-declare-instantiate-and-use-a-delegate).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一篇关于声明、初始化和使用委托的好文章。那里也可以找到示例：[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/how-to-declare-instantiate-and-use-a-delegate](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/how-to-declare-instantiate-and-use-a-delegate)。
