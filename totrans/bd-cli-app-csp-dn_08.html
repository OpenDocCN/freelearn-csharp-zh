<html><head></head><body>
		<div><h1 id="_idParaDest-117" class="chapter-number"><a id="_idTextAnchor120"/>8</h1>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor121"/>Building Modular and Extensible CLI Applications</h1>
			<p>Throughout the pages of this book, we have added more and more functionalities to <strong class="bold">Bookmarkr</strong>, our beloved CLI application.</p>
			<p>The problem is that we have also added more and more lines of code to the <code>Program.cs</code> file. The length of this file has grown from 191 lines of code by the end of <a href="B22400_03.xhtml#_idTextAnchor035"><em class="italic">Chapter 3</em></a> to 479 lines of code by the end of <a href="B22400_07.xhtml#_idTextAnchor105"><em class="italic">Chapter 7</em></a>.</p>
			<p>In this chapter, we will take a step back and refactor our code to make it more modular. This will make it easier to extend, test, and maintain.</p>
			<p>Refactoring is an essential part of the development life cycle. It should happen periodically in order to ensure that the quality of code is up to the standards.</p>
			<p>By taking this necessary step, we will greatly simplify adding more features, enhance the readability and stability of our application, and even introduce testability into it.</p>
			<p>More specifically, in this chapter, we’ll cover the following topics:</p>
			<ul>
				<li>Building the code map of the current application</li>
				<li>Deciding where to start refactoring</li>
				<li>Designing the project structure to support refactoring</li>
				<li>Refactoring a command</li>
				<li>Applying the dependency inversion principle</li>
				<li>Refactoring the <code>Program</code> class</li>
				<li>Running the program to validate that the refactoring didn’t break anything</li>
				<li>Pushing our refactoring to new boundaries</li>
			</ul>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor122"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the GitHub repository accompanying this book, <a href="https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter08">https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter08</a>.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor123"/>Step 1 – building a code map of the application</h1>
			<p>The first <a id="_idIndexMarker247"/>thing when you refactor an application is to get to know what you are about to refactor. This means having a high-level view of the application and its dependencies. This helps you visualize all the moving parts involved and better plan your refactoring activities by identifying where to start.</p>
			<p>If you have Visual Studio Enterprise edition, you can use its great architecture capabilities (such as code maps and dependency graphs) to visualize your code and its dependencies. However, since we are using Visual Studio Code (or if you don’t have the Enterprise edition of Visual Studio), we can do something else…</p>
			<p>Sure, we can run through the code and identify every moving part of it, but since this is a CLI application, let’s do something smarter. 😉</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor124"/>Using the Help menu to build the code map</h2>
			<p>The <code>System.CommandLine</code> is certainly great for learning how to use the application, but it is also great for figuring out the code map of the application.</p>
			<p>Let’s start by displaying the help menu at the root command by typing this command:</p>
			<pre class="console">
dotnet run -- -h</pre>			<p>We will get this result:</p>
			<div><div><img src="img/B22400_08_01.jpg" alt="Figure 8.1 – The help menu of the root command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – The help menu of the root command</p>
			<p>Next, we will <a id="_idIndexMarker249"/>repeat this operation (aka displaying the help menu) for each of the subcommands of the root command, then for each subcommand of every subcommand, then for… Okay, you get the idea! 😉</p>
			<p>Here is an example of the <code>link</code> command:</p>
			<div><div><img src="img/B22400_08_02.jpg" alt="Figure 8.2 – The help menu of the link command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – The help menu of the link command</p>
			<p>When should we stop? Well, when the current command has no more subcommands. Here is an example with the <code>link </code><code>add</code> command:</p>
			<div><div><img src="img/B22400_08_03.jpg" alt="Figure 8.3 – The help menu of the link add command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – The help menu of the link add command</p>
			<p>After<a id="_idIndexMarker250"/> completing this exercise, we will get the following code map:</p>
			<div><div><img src="img/B22400_08_04.jpg" alt="Figure 8.4 – The code map of the Bookmarkr application"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – The code map of the Bookmarkr application</p>
			<p>Okay, now that we have a clearer view of the moving parts in our application, what should we do next?</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor125"/>Step 2 – deciding where to start</h1>
			<p>It’s now time to decide what to refactor first.</p>
			<p>I would recommend not to start with the root command first, but rather with the subcommands of that root command.</p>
			<p>There is no right or wrong decision from there. You can pick up any subcommand you would like to start with. We will take the <code>export</code> command as an example in the remainder of this chapter.</p>
			<p>Although the <code>export</code> command does not have a subcommand, it will still help us lay out the foundation of the refactored version of <em class="italic">Bookmarkr</em>. More specifically, it will help us do the following:</p>
			<ul>
				<li>Define the project structure to support our refactoring</li>
				<li>Refactor it and hide its “complexity” (aka moving parts to the root command)</li>
				<li>Refactor the <code>Program</code> class and make it leaner, cleaner, and more concise</li>
				<li>Set up dependency injection for interacting between commands and external services (such as <code>BookmarkService</code>)</li>
			</ul>
			<p>Let’s start with designing the project structure that will support our refactoring activities.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor126"/>Step 3 – designing the project structure</h1>
			<p>Although<a id="_idIndexMarker251"/> one can design their project structure according to their tastes, I design mine in a way that makes it easy for whoever looks at my project to understand what it does and where each moving part is located.</p>
			<p>Following this principle, all commands will be grouped in a folder named <code>Commands</code>. This folder will be created at the root of the project structure.</p>
			<p>Since we will be refactoring the <code>export</code> command, let’s create a subfolder named <code>Export</code> where all the code artifacts involved in the <code>export</code> command will be located.</p>
			<p>Once we start refactoring another command, we will create a specific folder for it.</p>
			<p class="callout-heading">What about subcommands of a command?</p>
			<p class="callout">Following the principle<a id="_idIndexMarker252"/> of <strong class="bold">encapsulation</strong> in object-oriented programming, and since a subcommand can only be invoked through its parent command, I recommend locating subcommands in the same folder as their parent command.</p>
			<p class="callout">An example of that is the <code>link add</code> command. The <code>add</code> subcommand can only be called through its parent (<code>link</code>) command. Hence, their life cycles are closely related to each other.</p>
			<p class="callout">For that matter, the code artifact of the <code>add</code> command will be located close to the code artifact of its parent command (<code>link</code>), within the <code>Link</code> folder.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor127"/>Step 4 – refactoring the export command</h1>
			<p>Within<a id="_idIndexMarker253"/> the <code>Export</code> folder, let’s create a new C# file named <code>ExportCommand.cs</code>.</p>
			<p>Every command class (including <code>RootCommand</code>) derives from the <code>Command</code> base class. Furthermore, that base class provides an <code>AddCommand</code> method that takes a parameter of the <code>Command</code> type, which also means any class that derives from the <code>Command</code> class.</p>
			<p>Armed with this, we can start refactoring the <code>export</code> command by making the <code>ExportCommand</code> class derive from <code>Command</code>.</p>
			<p>After importing the required <code>using</code> statement, specifying the <code>namespace</code> name, and adding the required class constructor, the first iteration of our class looks like this:</p>
			<pre class="source-code">
using System.CommandLine;
namespace bookmarkr.Commands;
public class ExportCommand : Command
{
    #region Constructor
    public ExportCommand(string name, string? description = null)
        : base(name, description)
    {
    }
    #endregion
}</pre>			<p>The first <a id="_idIndexMarker254"/>things to move into this class are the options. The <code>export</code> command has only one option, <code>outputfileOption</code>.</p>
			<p>I like the fact that every component of my class is well-segmented. That’s why I am a fan of regions. For that reason, let’s add a region dedicated to options and move the code for the <code>outputfileOption</code> option within this region.</p>
			<p>The code looks like this:</p>
			<pre class="source-code">
#region Options
private Option&lt;FileInfo&gt; outputfileOption = new Option&lt;FileInfo&gt;(
    ["--file", "-f"],
    "The output file that will store the bookmarks"
)
{
    IsRequired = true
}.LegalFileNamesOnly();
#endregion</pre>			<p>We then need to associate this option with the command. We will do this by calling the <code>AddOption</code> method from within the constructor body, as follows:</p>
			<pre class="source-code">
#region Constructor
public ExportCommand(string name, string? description = null)
    : base(name, description)
{
    AddOption(outputfileOption);
}
#endregion</pre>			<p>The next<a id="_idIndexMarker255"/> thing to move is the call to the <code>SetHandler</code> method, which connects the command to its handler method. So, the updated version of the constructor looks like this:</p>
			<pre class="source-code">
#region Constructor
public ExportCommand(string name, string? description = null)
    : base(name, description)
{
    AddOption(outputfileOption);
    this.SetHandler(async (context) =&gt;
    {
        FileInfo? outputfileOptionValue = context.ParseResult.
        GetValueForOption(outputfileOption);
        var token = context.GetCancellationToken();
        await OnExportCommand(outputfileOptionValue!, token);
    });
}
#endregion</pre>			<p>Finally, the <a id="_idIndexMarker256"/>last piece of code to move into the new class is the command handler method. Once again, we will create a new region for that and move that final piece of code. We will also change the <code>static</code> modifier to <code>private</code>. The reason is that the class is not static (hence the removal of the <code>static</code> keyword) and the command handler method is private to that class (hence the use of the <code>private</code> keyword):</p>
			<pre class="source-code">
#region Handler method
private async Task OnExportCommand(FileInfo outputfile,
    CancellationToken token)
{
    // method body removed for brevity.
    // It is exactly similar to the one from the previous chapters.
}
#endregion</pre>			<p>If you are typing (or copying and pasting 😉) the code along the way, you can see at this point that the code does not compile because of two errors.</p>
			<p>The first one is straightforward to solve. It suffices to add the following statement at the top of the C# file:</p>
			<pre class="source-code">
using System.Text.Json;</pre>			<p>The second one is less obvious to solve. It indicates that the class can’t find an instance of the <code>BookmarkService</code> class.</p>
			<p>Of course, we could simply create an instance of that service within the current class. However, since <code>BookmarkService</code> is an external dependency to the <code>ExportCommand</code> class, doing so will break the principle of <strong class="bold">dependency inversion</strong> advocated by object-oriented programming.</p>
			<p>As a reminder, the<a id="_idIndexMarker257"/> principle of dependency inversion is one of the five SOLID principles of object-oriented programming and design. It states that high-level modules should not depend on low-level modules; both should depend on abstractions. Additionally, abstractions should not depend on details; details should depend on abstractions. This principle helps to decouple software modules, making the system more modular, flexible, and easier to maintain.</p>
			<p>What does that practically mean? It means that we should inject an instance of <code>BookmarkService</code> into the <code>ExportCommand</code> class.</p>
			<p>Let’s do this!</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor128"/>Step 5 – applying the dependency inversion principle</h1>
			<p>If you are<a id="_idIndexMarker258"/> familiar with the dependency inversion principle, you will certainly have already noticed that the <code>BookmarkService</code> class does not implement any interface.</p>
			<p>Let’s start by fixing this.</p>
			<p class="callout-heading">I am not familiar with the dependency inversion principle!</p>
			<p class="callout">If you are not, there are plenty of great resources to explore this principle. It is not a complicated principle to understand, and quite frankly, after you learn about it, it will seem so obvious to you that you will be wondering why you did not know about it earlier.</p>
			<p class="callout">A great explanation of that principle can be found at <a href="https://www.c-sharpcorner.com/article/dependency-inversion-principle-in-c-sharp/">https://www.c-sharpcorner.com/article/dependency-inversion-principle-in-c-sharp/</a>.</p>
			<p class="callout">I highly encourage you to go and review the implementation of the <code>BookmarkService</code> service before and after applying the dependency inversion principle in order to have a clear understanding of the benefits.</p>
			<p>Back to our project structure discussion, we will start by creating a new folder called <code>Services</code> that will group all our services classes. Within that folder, let’s create a specific folder for every service. In our case, we only have one service, so let’s create the <code>BookmarkService</code> folder. This <a id="_idIndexMarker259"/>folder will contain both the interface and the concrete implementation of our service.</p>
			<p>The folder structure for our service will then look like this:</p>
			<div><div><img src="img/B22400_08_05.jpg" alt="Figure 8.5 – The folder structure for the BookmarkService service"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – The folder structure for the BookmarkService service</p>
			<p>Next, let’s extract the <code>IBookmarkService</code> interface out of the <code>BookmarkService</code> class. The code for that interface looks like this:</p>
			<pre class="source-code">
namespace bookmarkr.Services;
public interface IBookmarkService
{
    void AddLink(string name, string url, string category);
    void AddLinks(string[] names, string[] urls, string[] categories);
    void ListAll();
    List&lt;Bookmark&gt; GetAll();
    void Import(List&lt;Bookmark&gt; bookmarks);
    BookmarkConflictModel? Import(Bookmark bookmark);
    List&lt;Bookmark&gt; GetBookmarksByCategory(string category);
}</pre>			<p>Now, let’s <a id="_idIndexMarker260"/>make the <code>BookmarkService</code> class implement the <code>IBookmarkService</code> interface:</p>
			<pre class="source-code">
namespace bookmarkr.Services;
public class BookmarkService : IBookmarkService
{
    // method body removed for brevity.
    // It is exactly similar to the one from the previous chapters.
}</pre>			<p>Notice that we changed the namespace name for these artifacts in order to better convey their intention.</p>
			<p>All that is left to do now is to inject that service into the <code>ExportCommand</code> class. This means two things:</p>
			<ol>
				<li>We will add a <code>private</code> property of the <code>IBookmarkService</code> type in the <code>ExportCommand</code> class that will allow us to invoke the methods of that service from within the command class (more specifically, from within the <code>OnExportCommand</code> method).</li>
				<li>We will inject an instance of that service through a constructor parameter.</li>
			</ol>
			<p>The updated code of the <code>ExportCommand</code> class looks like this now:</p>
			<pre class="source-code">
using System.CommandLine;
using System.Text.Json;
using bookmarkr.Services;
namespace bookmarkr.Commands;
public class ExportCommand : Command
{
    #region Properties
    private IBookmarkService _service;
    #endregion
    #region Constructor
    public ExportCommand(IBookmarkService service, string name, 
    string? description = null)
        : base(name, description)
    {
        _service = service;
        AddOption(outputfileOption);
        this.SetHandler(async (context) =&gt;
        {
            FileInfo? outputfileOptionValue = context.ParseResult.
            GetValueForOption(outputfileOption);
            var token = context.GetCancellationToken();
            await OnExportCommand(outputfileOptionValue!, token);
        });
    }
    #endregion
  // The "Options" region hasn't changed and removed for brevity.
#region Handler method
    private async Task OnExportCommand(FileInfo outputfile, 
    CancellationToken token)
    {
    // …
    var bookmarks = _service.GetAll();
    // …
    }
    #endregion
}</pre>			<p>This code <a id="_idIndexMarker261"/>is very straightforward to understand and does not require any particular explanation.</p>
			<p class="callout-heading">The dependency inversion principle may introduce complexity!</p>
			<p class="callout">Dependency injection can introduce some overhead in simple applications by requiring additional setup and configuration, such as adding extra interfaces, classes, and indirection, which can be unnecessary for straightforward projects with few dependencies.</p>
			<p class="callout">Therefore, it is important to find a balance between applying this principle without adding too much complexity to the code base.</p>
			<p>That is <a id="_idIndexMarker262"/>wonderful. We have come a long way since we started our refactoring journey!</p>
			<p>There is one last piece of code we haven’t refactored yet. It is the one for which we started this journey in the first place: the <code>Program</code> class.</p>
			<p>Let’s turn our attention to this class now…</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor129"/>Step 6 – refactoring the Program class</h1>
			<p>By<a id="_idIndexMarker263"/> refactoring the commands into their dedicated classes, the code to create and handle these commands will be removed from the <code>Program</code> class.</p>
			<p>Hence, the <code>Program</code> class will now only be used to compose our application. More specifically, the <code>Program</code> class will do the following:</p>
			<ol>
				<li>Instantiate the root command and register its subcommands.</li>
				<li>Instantiate and configure the <code>CommandLineBuilder</code> class and start the program.</li>
				<li>Configure logging.</li>
				<li>Configure dependency injection of the <code>BookmarkService</code> service.</li>
			</ol>
			<p>Here is the refactored code for the <code>Program</code> class (note that some parts of the code, including <code>using</code> statements, are not listed here for brevity and clarity):</p>
			<pre class="source-code">
using Microsoft.Extensions.DependencyInjection;
class Program
{
    static async Task&lt;int&gt; Main(string[] args)
    {
        FreeSerilogLoggerOnShutdown();
        /** DECLARE A VARIABLE FOR THE IBookmarkService **/
        IBookmarkService _service;
        /** INSTANTIATE THE ROOT COMMAND **/
        var rootCommand = new RootCommand(
            "Bookmarkr is a bookmark manager provided as a CLI 
            application.")
        {
        };
        rootCommand.SetHandler(OnHandleRootCommand);
        /** CONFIGURE DEPENDENCY INJECTION FOR THE IBookmarkService 
        **/
        var host = Host.CreateDefaultBuilder(args)
            .ConfigureServices((hostContext, services) =&gt;
            {
                // Register your services here
                services.AddSingleton&lt;IBookmarkService, 
                BookmarkService&gt;();
            })
            .Build();
        _service = host.Services.GetRequiredService&lt;IBookmarkService&gt;();
        /** REGISTER SUBCOMMANDS OF THE ROOT COMMAND **/
        rootCommand.AddCommand(new ExportCommand(_service, "export", 
        "Exports all bookmarks to a file"));
        /** THE BUILDER PATTERN **/
        // code removed for brevity.
    }
    /** HANDLER OF THE ROOT COMMAND **/
    static void OnHandleRootCommand()
    {
        Console.WriteLine("Hello from the root command!");
    }
    static void FreeSerilogLoggerOnShutdown()
    {
        // code removed for brevity.
    }
    static void ExecuteShutdownTasks()
    {
        // code removed for brevity.
    }
}</pre>			<p>This code is mostly straightforward to understand.</p>
			<p>The <a id="_idIndexMarker264"/>only part that is worth an explanation is how we perform dependency injection of services (here, with <code>BookmarkService</code>):</p>
			<ul>
				<li>We declare a variable of the <code>IBookmarkService</code> type that will be used to retrieve an instance of the injected service.</li>
				<li>We configure the dependency injection by leveraging the <code>HostBuilder</code> class provided by .NET and registering services to the <code>IServiceCollection</code> collection.</li>
				<li>We retrieve the instance of the registered services by calling <code>GetRequiredService</code> on the <code>IServiceCollection</code> collection and store a reference to the retrieved service into the variable we declared earlier.</li>
				<li>When creating an instance of a new command, we pass that variable as a parameter to the command’s constructor so that the new command receives an instance of the service.</li>
			</ul>
			<p>And voila! The service is automatically instantiated and injected into the various commands that require it.</p>
			<p>What’s great about this approach is that if we need to change the service implementation, all we need to do is modify the service registration to <code>IServiceCollection</code> and the rest will be magically taken care of.</p>
			<p>Note how the <code>Program.cs</code> file has shrunk from 479 lines of code to 115 lines of code!</p>
			<p>And the best part? Registering a new command to the root command is a matter of one extra line of code (aka, calling <code>AddCommand</code> on the root command and passing an instance of the new command to be registered), while injecting a new service is a matter of two lines of code: one for adding the service into the services collection and the other for getting a reference to that service in order to pass it to classes that require it.</p>
			<p class="callout-heading">Beware of the pitfalls!</p>
			<p class="callout">Common pitfalls in dependency injection include circular dependencies, where classes depend on each other, and unintended singleton behavior, which can arise from improper service lifetimes. Over-injection of dependencies can violate the Single-Responsibility Principle, while excessive reliance on service locators complicates testing. To avoid these issues, it’s crucial to manage service lifetimes carefully and follow best practices.</p>
			<p class="callout">I highly recommend that you check out the reading recommendations in <a href="B22400_14.xhtml#_idTextAnchor236"><em class="italic">Chapter 14</em></a> in order to explore this topic more deeply when necessary.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor130"/>Step 7 – running the program</h1>
			<p>Perfect! We <a id="_idIndexMarker265"/>have completed the refactoring of the <code>export</code> command. Let’s run the code to ensure that it still works as expected.</p>
			<p>The syntax to invoke the <code>export</code> command hasn’t changed. So, let’s invoke it the same way as before by typing the following:</p>
			<pre class="console">
dotnet run export --file 'bookmarks33.json'</pre>			<p>We will get the following results:</p>
			<div><div><img src="img/B22400_08_06.jpg" alt="Figure 8.6 – Invoking the export command after refactoring"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Invoking the export command after refactoring</p>
			<p>Wonderful! The application still works as expected.</p>
			<p>We have done a lot of refactoring to our application so far. But is that all? Or can we take it to another level?</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor131"/>Taking refactoring to new heights</h1>
			<p>You may have been wondering why we didn’t extract options and handler methods into their own code artifacts (such as classes).</p>
			<p>The reason is that options and handler methods (and also arguments) are usually unique to a specific command. For this reason, they are defined in the command class.</p>
			<p>However, in situations where they would need to be used by more than one command, we would have extracted them into their own code artifact. This reasoning is important to keep in mind in order to avoid over-complexifying our design by over-abstracting it.</p>
			<p>In the case of an option, we <a id="_idIndexMarker266"/>would have created a dedicated class. Here’s an example of <code>outputfileOption</code> we used in our <code>ExportCommand</code> class:</p>
			<pre class="source-code">
using System.CommandLine;
namespace bookmarkr.Options;
public class FileInfoOption : Option&lt;FileInfo&gt;
{
    public FileInfoOption(string[] aliases, string? description = 
    null, bool onlyAllowLegalFileNames = true, bool isRequired = true)
        : base(aliases, description)
    {
        if(onlyAllowLegalFileNames == true)
        {
            this.LegalFileNamesOnly();
        }
        this.IsRequired = isRequired;
    }
}</pre>			<p>We could then use this option in any command by creating an instance of it, as follows:</p>
			<pre class="source-code">
var outputfileOption = new FileInfoOption(["--file", "-f"], "The output file path");</pre>			<p>Here is how it <a id="_idIndexMarker267"/>would have looked for <code>ExportCommand</code>:</p>
			<pre class="source-code">
public class ExportCommand : Command
{
    #region Constructor
    public ExportCommand(IBookmarkService service, string name, 
    string? description = null)
        : base(name, description)
    {
        _service = service;
        outputfileOption = new FileInfoOption(["--file", "-f"], "The 
        output file path");
        AddOption(outputfileOption);
        // remaining of the code removed for brevity.
    }
    #endregion
    #region Options
    private FileInfoOption outputfileOption;
    #endregion
    // remaining of the code removed for brevity.
}</pre>			<p>Pay special <a id="_idIndexMarker268"/>attention to how the <code>outputfileOption</code> property is declared (in the <code>Options</code> region) and how it is instantiated and initialized in the constructor. Its usage is no different from before.</p>
			<p>In the case of a handler method, we would have created a base class that derives from <code>Command</code> (let’s call it <code>CommandWithBaseHandler</code>), add the handler method to it (allowing it to be overridden), and make our command classes derive from that <code>CommandWithBaseHandler</code> class rather than from the <code>Command</code> class.</p>
			<p>The <code>CommandWithBaseHandler</code> class could have looked like this:</p>
			<pre class="source-code">
using System.CommandLine;
namespace bookmarkr.Commands.Base;
public class CommandWithBaseHandler : Command
{
    public CommandWithBaseHandler(string name, string? description = 
    null)
        : base(name, description)
    {
    }
    public virtual async Task OnExportCommand(FileInfo outputfile, 
    CancellationToken token)
    {
        // method body removed for brevity.
    }
}</pre>			<p>Notice that <a id="_idIndexMarker269"/>the <code>OnExportCommand</code> method has been marked as <code>virtual</code>. This means that it provides a default implementation in the <code>CommandWithBaseHandler</code> class but allows that implementation to be overridden if needed.</p>
			<p>We could then have modified the <code>ExportCommand</code> class as follows:</p>
			<pre class="source-code">
using System.CommandLine;
using System.Text.Json;
using bookmarkr.Services;
using bookmarkr.Options;
using bookmarkr.Commands.Base;
namespace bookmarkr.Commands;
public class ExportCommand : CommandWithBaseHandler
{
    // the remaining code is not shown for brevity.
    // the OnExportCommand method is removed from this class since it 
    // has been moved to the CommandWithBaseHandler base class.
}</pre>			<p>Perfect! But <a id="_idIndexMarker270"/>where would these new code artifacts fit into our project structure? Great question!</p>
			<p>Let’s update our project structure to accommodate these new artifacts.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor132"/>Updating the project structure</h2>
			<p>Following <a id="_idIndexMarker271"/>the same principle regarding project structure that we applied so far, I suggest the following:</p>
			<div><div><img src="img/B22400_08_07.jpg" alt="Figure 8.7 – The project structure for commands"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – The project structure for commands</p>
			<p>Awesome! We now have an application that is more modular and easily extensible. Everything has its own place so it’s easier to read and navigate the application’s code.</p>
			<p class="callout-heading">Wait, extensible?!</p>
			<p class="callout">You may not have noticed, but the refactoring exercise we have done throughout this chapter not only enhanced our application from a modularity standpoint but also from an extensibility standpoint.</p>
			<p class="callout">Think about it: we can now easily involve other teammates in the development of our application, making delivering new features to our users even faster.</p>
			<p class="callout">Every team member can focus on their very own command, impacting only a small subset of code artifacts and, in most cases, they won’t modify the same files, reducing the number of merge conflicts that may occur when pushing their code into the source control.</p>
			<p>This<a id="_idIndexMarker272"/> refactoring also allows to speed up the onboarding process of new team members. Since every code artifact has its proper place, the code is easier to understand and to own. If you are looking for contributors to your application, this is a very important point to keep in mind!</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor133"/>Summary</h1>
			<p>In this chapter, we refactored <em class="italic">Bookmarkr</em> to make it more modular. Each command is now described in its own code file.</p>
			<p>By taking the time to refactor our CLI application, we have greatly enhanced its readability, maintainability, testability, and extensibility. It is now easier to add new capabilities, such as new commands (of course) as well as new features to existing commands.</p>
			<p>Speaking about that, in the next chapter, we will see how to call external services and APIs to extend the capabilities of our application.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor134"/>Your turn!</h1>
			<p>Following along with the provided code is a great way to learn through practice.</p>
			<p>A better way is by challenging yourself to achieve tasks. Hence, I challenge you to improve the <em class="italic">Bookmarkr</em> application by adding the following features.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor135"/>Task #1 – refactor the remaining commands</h2>
			<p>Even though this chapter proposes only one challenge, it will require effort on your side!</p>
			<p>Throughout the pages of this chapter, we have refactored the <code>export</code> command. You are now tasked with refactoring the other commands of the <em class="italic">Bookmarkr</em> application.</p>
			<p>For that matter, you can follow the same strategy and steps we used in our previous refactoring activity. By practicing it again and again, you will gain mastery of this process.</p>
			<p>You will find the version of the code that hasn’t been refactored in the <code>Program.Unrefactored.cs</code> file.</p>
			<p>Let’s do this!</p>
		</div>
	</body></html>