- en: Service Ecosystem Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we provided an overview of the containerization process
    and how to use containers to run a service. We also learned how to host the catalog
    service on containers using Docker and how to use the multistage build approach
    to create and run our container images.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses on some patterns that are used when multiple services are
    part of the same ecosystem. Then, we will look at the implementation of the communication
    between those services. We will also learn how to build a resilient connection
    between various web services that are part of the same system in order to avoid
    some of the common pitfalls related to data exchange.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the cart service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing resilient communication using an HTTP client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to event buses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to perform event bus communication using RabbitMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a general understanding of how to
    improve resilience using `Polly` and how to use an event bus to exchange information
    between two systems.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the cart service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the `Catalog.API` project handles the catalog items of our store, we
    don''t have anything that handles the cart features. In this section, we will
    discover a new .NET Core solution that implements a cart service to do this for
    us. Furthermore, we will introduce a new implementation approach: the **mediator
    pattern**. Before we walk through the implementation of this new service, let''s
    take a look at an overview of the project structure, which provides the catalog
    service and cart service solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c779dff6-90f2-4501-8699-c53546ea00fd.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding schema describes the project structure of the catalog service
    andthe cart service*.* As we already know, the catalog service implements the
    `API`, `Domain`, and `Infrastructure` projects in order to separate the different
    layers of the implementation and that it uses SQL Server, combined with Entity
    Framework Core, as the main data source. However, although the cart service follows
    a similar project structure, it uses a slightly different implementation pattern
    and stores cart data in Redis. Therefore, Redis, which is mainly used for caching
    purposes, offers a very lightweight/high-performance key-value data store that
    can be also used as a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cart service solution has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Cart.API` project contains the controller, which handles the incoming HTTP
    request from the client. It also includes the error processing aggregation point
    and the `Startup` class, which initializes the dependency injection engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Cart.Domain` project contains the mediator logic and the handlers that
    dispatch the operations to the underlying layers. Furthermore, it also includes
    the entities that are used by the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Cart.Infrastructure` project is the bridge between the web services and
    their dependencies, such as the data store and other third-party services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter won''t look at the development process of the cart service in
    detail: some of the technical aspects have already been discussed, namely, in
    [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml), *Building the Data Access
    Layer,* [Chapter 9](f8ac60e1-e948-4435-b804-e3e4ff305510.xhtml), *Implementing
    the Domain Logic*, and [Chapter 10](266d98e8-df54-4024-aefb-b5871b3b35fa.xhtml),
    *Implementing the RESTful HTTP Layer*. The introduction to the cart service will
    be useful for you to determine the different communication techniques between
    multiple web services. Although this chapter will cover some of the key parts
    of the implementation, such as the handlers, in order to proceed, you need to
    download the cart service source code from [https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3).'
  prefs: []
  type: TYPE_NORMAL
- en: The theory behind the mediator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mediator pattern is a way to encapsulate logic behind a unique entry point.
    It uses the concept of requests, responses, commands, or events to abstract the
    implementations behind a single entry point. This way of implementing the application
    logic helps the developers in your team keep the logic separated from the web
    part of the application. To understand how the mediator pattern works, let's take
    a look at its components.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding schema describes a simple implementation of the mediator pattern.
    The consumer of the mediator calls the `Send` method by referring to the `IMediator`
    interface. The mediator implementation passes a specific type of the `IRequest`
    interface. Therefore, the `Mediator` instance dispatches the messages to the destination
    handler, which is represented by the `IMessageHandler` implementation, using the
    concrete implementation of the `IRequest` interface. In the next chapter, we will
    learn how to use an `IMediator` interface to dispatch messages to specific handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we will use the mediator pattern with the command approach. There
    are slightly different ways to implement the mediator pattern. The project that
    we''ll be covering in this chapter uses a very popular mediator NuGet packaged
    called **MediatR**. MediatR is an all-in-one implementation of the mediator pattern
    that covers in-process messaging. You can find more information about the MediatR
    project on GitHub: [https://github.com/jbogard/MediatR](https://github.com/jbogard/MediatR).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purpose of the *cart service* implementation, we''re going to use the
    following components, all of which have been exposed by the MediatR library:'
  prefs: []
  type: TYPE_NORMAL
- en: The `IMediator` interface is the main entry point of the mediator pattern. It
    exposes a `Send` method, which is used to dispatch a command or a request to a
    specific handler in order to obtain a result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IRequestHandler` interface is a generic interface that's used to define
    the implementation of a handler. Each `IRequestHandler` type requires an `IRequest`
    type, which represents the request that's sent through the `IMediator` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IRequest` interface defines the request or the command type that's used
    to execute a specific handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have more information about how the mediator pattern works, we can
    continue with the concrete implementation of the cart service solution. In the
    next section, we will look at how we can define the domain model of the service
    and implement the data access layer abstraction over the Redis data store.
  prefs: []
  type: TYPE_NORMAL
- en: The domain model and the data access layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The domain model of the cart service represents the entities that we require
    to describe the cart session of a user. Specifically, the domain model of the
    cart service implements three different entity classes: `Cart`, `CartItem`, and
    `CartUser`. Like the catalog service, all the entities are stored in the `Cart.Domain`
    project, which will be referred to by the `Cart.Infrastructure` and `Cart.API`
    projects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `CartSession` class, which represents a single cart session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CartSession` entity represents a single cart instance that''s been created
    by a user. Therefore, it refers to the `CartUser` class, which contains the user''s
    information. Besides, the `CartSession` entity also provides the `IList<CartItems>`
    field, which represents the items in the cart and the quantity associated with
    each item. Let''s proceed by also defining the `CartItem` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CartItem` class implements a `CartItemId` field and a `Quantity` field.
    Furthermore, it also provides the `IncreaseQuantity` and `DecreaseQuantity` fields,
    which are used to increment and decrement the quantity of a specific item, respectively.
    Finally, it is possible to determine the `CartUser` class, which represents the
    user related to the cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For demonstration purposes, we are representing `CartUser` with only one property;
    this will contain the email of the user. The preceding entities are stored in
    the `Entities` folder, inside the `Cart.Domain` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have defined the domain model, we can proceed with the implementation
    of the data access abstraction. Specifically, the cart service will use the same
    access pattern we defined previously for the catalog service in order to get information
    about the cart sessions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `ICartRepository` method implements methods that retrieve and update our
    data, the `GetCarts` method retrieves the IDs of the current carts, and the `GetAsync`
    method gathers information about a specific cart. Finally, the `AddOrUpdateAsync`
    method allows us to update or add a new cart if it's not present in the data store,
    while `ICartRepository` defines the operations that are performed by our data
    store. In the next subsection, we will look at a concrete implementation of the
    `CartRepository` class.
  prefs: []
  type: TYPE_NORMAL
- en: This domain model has been simplified to provide an example of a possible implementation
    of the cart. In a real-world application, we should consider other essential information
    about the state of a cart.
  prefs: []
  type: TYPE_NORMAL
- en: The ICartRepository Redis implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cart service uses Redis ([https://redis.io/](https://redis.io/)) to store
    the cart's data. The actual implementation of the `CartRepository` class of the
    cart service uses a NuGet package powered by Stack Exchange called `StackExchange.Redis`.
    Furthermore, we will use the `Newtonsoft.Json` package to serialize the objects
    into Redis using JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concrete implementation of the `CartRepository` class will be located in
    the `Cart.Infrastructure` project, while the `ICartRepository` interface type
    will be located in the `Cart.Domain` project. Furthermore, the `Cart.Infrastructure`
    project will also depend on the `StackExchange.Redis` and `Newtonsoft.Json` packages.
    The `StackExchange.Redis` library provides a low-level abstraction of Redis, so
    that our .NET applications can read or write data on a Redis instance. Let''s
    take a look at the implementation of the `CartRepository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CartRepository` class uses the `StackExchange.Redis` library to interact
    with a Redis instance. It declares an `IDatabase` property, which represents a
    connection with the Redis instance, and it uses a custom settings class that defines
    the connection string associated with the Redis instance. During the initialization
    of the class, the constructor calls the `ConnectionMultiplexer` static instance
    to create a new database connection. Let''s proceed by having a look at the `ICartRepository`
    interface method''s implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines the core methods of the `ICartRepository` interface.
    The `GetCarts` method gathers all the keys that represent all the cart IDs stored
    in the Redis instance. The `GetAsync` method retrieves the details of a card by
    passing the ID of a specific cart and deserializing the resulting content in the
    `CartSession` entity. Finally, the `AddOrUpdateAsync` method adds or updates the
    information related to a cart ID by serializing its content and updating the data
    source using the `StringSetAsync` method, which is provided by the library. We
    are using Redis because, as an in-memory data structure store, it can retrieve
    information very quickly. In general, Redis'' primary purpose is to act as a caching
    system, but it can also be used to store information temporarily. Redis is not
    the best system to prevent data loss, however. All the data is processed in memory
    and it can only be saved by making a snapshot of the current state of memory.
    For more information, visit the following website: [https://redis.io/topics/persistence](https://redis.io/topics/persistence).'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding implementation of `CartRepository` produces two main pitfalls.
    First of all, Redis is not a database that's designed to scan and retrieve multiple
    keys. Furthermore, this kind of data store is designed to perform O(1) operations,
    just like a hash table or a dictionary. Therefore, the `GetCarts` method is very
    performance inefficient. An alternative and more efficient approach would be to
    store the list IDs in a specific and unique field and keep them updated every
    time we add/remove new cart records. Secondly, although the constructor of the
    `CartRepository` class calls the `ConnectionMultiplexer` static class every time
    the class is initialized, it is strongly suggested that you initialize the `IConnectionMultiplexer`
    interface as a singleton instance in order to avoid performance pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection describes the implementation of the handlers that expose
    the cart operations through the mediator logic. Furthermore, the handlers will
    call the underlying `ICartRepository` interface in order to perform the I/O process
    on Redis.
  prefs: []
  type: TYPE_NORMAL
- en: Handlers and routes implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *cart service* implements the handlers that reflect the different actions
    that occur on cart data in the domain part of our service. As we will see later
    in this chapter, the handlers are associated with a specific request and are executed
    by the `IMediator` interface, which is provided by the MediatR library. Also,
    in this case, these classes are located in the `Cart.Domain` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by taking a look at the implementation of the `CreateCartHandler`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is the definition of the `CreateCartHandler` class, which
    performs the creation cart process. The class uses the constructor injection technique
    to resolve the dependencies through the dependency injection engine of ASP.NET
    Core. Furthermore, the handler class depends on the `IMapper` and `ICartRepository`
    interfaces: the `IMapper` interface is used to map the `CartSession` instances
    with the `CartExtendedResponse` response class, while the `ICartRepository` interface
    is used to store the cart data on Redis through the use of the `AddOrUpdateAsync`
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The handler assigns a new `Guid` to the entity and it adds a `ValidityDate`
    of 2 months. Furthermore, it also assigns the new cart items list to the cart
    session by setting a default quantity of 1 for each item. In a similar manner,
    the `GetCartHandler` class implements the reading operations based on the `Id`
    of the cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the `Handle` method executes the `GetAsync(Guid id)` method that''s
    provided by the underlying repository interface and it maps the response to the
    `CartExtendedResponse` type. The last handler that''s implemented by the `Cart.Domain`
    project increases or decreases the quantity of an item in a specific cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The handler accepts `UpdateCartItemQuantityRequest`, which defines the `CartId`,
    `CartItemId`, and a Boolean that denotes whether the request is to increase or
    decrease the quantity of the specified item.
  prefs: []
  type: TYPE_NORMAL
- en: The handler uses the same dependencies that the other handlers do and it performs
    some additional checks about the removal of the item if the amount is equal to
    zero. If the quantity associated with `CartItemId` reaches `0`, then the item
    is removed from the cart session; otherwise, the quantity is updated and the cart
    proceeds by updating the Redis store and retrieving `cartDetail`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our handlers are in place, we will define the controller classes that
    will expose the HTTP routes for the web service.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing functionalities using CartController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve already mentioned, the cart service takes care of the operations
    that are performed on the cart page of the e-commerce store. Moreover, the service
    exposes the following route table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HttpVerb** | **URL** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `api/cart/{cartId}` | This action retrieves information about a specific
    cart and its inner products. |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `api/cart` | This action creates a new cart with a list of products
    specified in the body payload of the request. |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `api/cart/{cartId}/items/{id}` | This action increases the quantity
    of the specified item in the specified `cartId` by adding one unit. |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `api/cart/{cartId}/items/{id}` | This action decreases the quantity
    of the specified item in the specified `cartId` by removing one unit. |'
  prefs: []
  type: TYPE_TB
- en: 'The preceding table provides some details about the routes we need to define
    in our controller. Therefore, the following code snippet shows the implementation
    of this route table while using the `CartController` class in the `Cart.API` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in a similar way to the previously implemented controllers,
    `CartController` uses dependency injection to resolve its dependencies by initializing
    the `IMediator` interface. Let''s proceed by having a look at the implementation
    of the `Put` and `Delete` action methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `DELETE` and `PUT` methods use the `IsAddOperation` flag to inform the handler
    of whether the requested operation is being used to increase or decrease the quantity.
    Therefore, every time we call the routes using the `DELETE` HTTP verb and the
    `UPDATE` HTTP verb, the service will increase and reduce the amount of the item
    ID specified in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter skips a lot of the validation and REST-compliant features that
    we covered in [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml), *Building
    the Data Access Layer*, [Chapter 9](f8ac60e1-e948-4435-b804-e3e4ff305510.xhtml),
    *Implementing the Domain Logic*, and [Chapter 10](266d98e8-df54-4024-aefb-b5871b3b35fa.xhtml),
    *Implementing the RESTful HTTP Layer*, and then implemented in the `Catalog.API`
    project. As we will see from the next section onward, this chapter aims to show
    you how to share information and events between independent services. Therefore,
    the cart service will gather information related to the item by calling the catalog
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've looked at the implementation stack, we can proceed by implementing
    the communication between the catalog service and the cart service*.*
  prefs: []
  type: TYPE_NORMAL
- en: Implementing resilient communication using an HTTP client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we looked at an overview of the cart service's project
    structure. We learned how the cart service stores information inside a Redis instance
    and how it retrieves cart-related data for the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is necessary to note that there is a gap between the information stored
    in the Redis data source and the data that''s exposed by the service. Furthermore,
    by examining the `CartItem` entity, we can see that it only implements and retrieves
    `CartItemId` and `Quantity` information for the item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, we can see that `CartItemResponse` provides a lot of fields
    related to the item''s data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The additional information that's presented by the `CartItemResponse` class
    is fetched by calling the catalog services. Therefore, the cart service owns the
    data about the item ID and it can perform a `GET /api/items/{itemId}` request
    in order to retrieve the item's information. In this section, we will focus on
    the implementation of an HTTP client to expose the information that's owned by
    the catalog service.
  prefs: []
  type: TYPE_NORMAL
- en: It is important that you don't replicate information across web services. We
    need to be able to keep the data sources of web services as separated as possible.
    Each service owns a single data source and its appropriate information. It is
    a common practice to share information using HTTP calls to communicate between
    services. In the following example, we will see how the cart service calls the
    catalog service directly to retrieve item information. In a real-world application,
    all the HTTP calls between services are made by passing through a proxy to guarantee
    the reliability of the service.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the catalog HTTP client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is common practice to implement client libraries along with web services.
    Furthermore, it is the responsibility of a web service to provide a way to communicate
    with it. For that reason, we can represent the client''s implementation using
    the following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01d7bb66-9842-4ab0-9b42-71226466f10f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This allows us to publish the catalog service client library in an internal
    NuGet repository so that we can spread the client to other services. Moreover,
    the team that owns a specific service should know how it can be implemented and
    how to expose information in the right way. Let''s start by creating two new `classlib`
    projects in the `Catalog.API` solution, which can be found in the `src` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Catalog.API.Client` project will contain all the methods we need to query
    the catalog service. `Catalog.API.Contract` includes the requests and responses
    that are used by the client to transfer the data, so we can proceed by copying
    the classes contained in the `Responses` folder of the `Catalog.Domain` project
    into the `Catalog.API.Contract` project we created previously. The resulting folder
    structure will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to use the response models in a project, it is necessary to refer
    to `Catalog.API.Contract`. This practice is usually applied to the request and
    response classes. By doing this, it is possible to keep the contract of the API
    in a separate, continuous integration pipeline. As a second step, we need to create
    a new base client in the `Catalog.API.Client` project. The following `IBaseClient`
    interface defines the methods that are exposed by the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IBaseClient` interface establishes the interface of the client. It exposes
    two main methods: `GetAsync` and `BuildUri`. Both of these methods are implemented
    in the `BaseClient` concrete class. The `BaseClient` class depends on the `HttpClient`
    and the `string Url` of our APIs. The `GetAsync` method calls the `HttpClient`
    and uses the `Newtonsoft.Json` package to deserialize the response of the client
    in a generic model, `T`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue by defining the `ICatalogItemResource` interface and the `CatalogItemResource`
    classes. These classes represent the `Item` resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`ICatalogItemResource` exposes the `Get` method by accepting the `id` and `cancellationToken`.
    It returns a `Task<ItemResponse>` type. Therefore, the `CatalogItemResource` model
    is defined in the `Catalog.API.Client.Resources` project as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`CatalogItemResource` refers to the `IBaseClient` interface and it implements
    the `Get` method by using the `IBaseClient` interface. In the same way, `CatalogItemResource`
    is also in charge of providing the paths of the items'' resources by building
    the `Uri` of the web service. Besides this, `CatalogItemResource` uses the `IBaseClient`
    wrapper to perform HTTP operations. Let''s dig into the implementation of the
    `IBaseClass` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the `HttpClient` class that's provided by the framework
    to implement the `GetAsync<T>` generic method. Therefore, using this generic pattern
    allows us to deserialize the response using a custom model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can implement the actual client of the service by adding the following
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it is possible to use `Catalog.API.Client` to instantiate a new HTTP
    client instance and call the catalog service using a unique and universal contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have some standalone DLLs that provide everything we need, so that we
    can query the catalog web service. In the next section, we will learn how to perform
    HTTP calls to the catalog service using the client we implemented in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating an HTTP client into the cart service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to incorporate the HTTP client provided by the catalog service
    into the cart service. Therefore, we will add a new class whose ownership is to
    call the catalog service and retrieve the information that''s required for the
    specific cart. Let''s start by creating an interface in the `Cart.Domain` project
    called `ICatalogService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ICatalogService` interface is contained in the `Services` folder of the
    `Cart.Domain` project. It exposes an asynchronous method called `EnrichCartItem`,
    which accepts `CartItemResponse` and returns the same type. Like we did for the
    `ICartRepository` interface, we can create the concrete implementation of the
    `ICatalogService` interface in the `Cart.Infrastructure` project. Therefore, we
    can use the `ICatalogClient` interface we previously implemented in the *catalog
    service* to retrieve the catalog information. In a real-world application, these
    DLLs are usually managed as NuGet packages in the internal repository of the company.
    In our case, we will copy them and include them in the `Cart.Infrastructure` project,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s proceed by creating the `CatalogService` class in the `Cart.Infrastructure`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`CatalogService` resolves the `ICatalogClient` dependency using constructor
    injection. The class implements the `EnrichCartItem` function by calling the catalog
    service client in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the method retrieves information related to the catalog item and it maps
    that data into `CartItemResponse` using the `Map` method. As a result, we will
    have information about each item that''s been populated with the new data. It
    is possible to proceed by referring to the `ICatalogService` interface in the
    handlers that have been implemented in `Cart.Domain`. Let''s take `GetCartHandler`
    as an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can execute the `_catalogService.EnrichCartItem` method to retrieve the
    populated data for each `Item` in the `extendedResponse` object. In addition,
    `GetCartHandler` uses the `Task.WhenAll` method to wait for the tasks to complete
    and returns their data. To get this process working in the runtime execution,
    it is necessary to declare the following extension method, which will initialize
    the dependency and execute it in the `Startup` class of the `Cart.API` project
    by passing the endpoints of the APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`AddCatalogService` will be called in the `CofigureService` method of the `Startup`
    class. It adds `ICatalogClient` and `ICatlogService` to the dependency injection
    services by using a scoped life cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing resilience using Polly.NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous sections, we described how to achieve communication between
    the catalog service and the cart service. Now, we should be asking ourselves the
    following questions about the runtime execution and the communication between
    our services: what happens if the catalog service is down? What happens if the
    catalog service has a slow response time? The **Polly.NET** package comes in handy
    for these kinds of issues ([https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Polly.NET is based on *policies,* where each *policy* can be used individually
    or combined with others to provide resilience to the client. Out of the box, the
    library offers some standard resilience policies, such as retry, circuit breaker,
    and timeout*.* Let''s have a quick look at a sample policy so that we understand
    how to use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The previous code injects an `HttpClient` instance into `IMyService`. The `HttpClient`
    instance combines `RetryPolicy` with the `Polly` package. Furthermore, if the
    HTTP call returns a `404 NotFound` message, it triggers `RetryPolicy`, which retries
    the request after a specified amount of time that increases exponentially.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Polly into ICatalogService
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at how we can incorporate Polly.NET into the cart service*.* As we
    saw previously,our use case uses the catalog service to gather detailed information
    about the items in the user's cart and return them to the client. Furthermore,
    we will implement `CircuitBreakerPolicy` on `ICatalogClient`. `CircuitBreakerPolicy`
    follows the failing fast approach, which means that, even if the response of the
    catalog service doesn't arrive, the runtime continues with the execution of the
    application*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting, let''s add some Polly.NET packages to the `Cart.Infrastructure`
    project by using the `add package` command in the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s proceed by creating some policies for `ICatalogClient` by creating a
    new `CatalogServicePolicies` static class in `Cart.Infrastructure`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines two policies:'
  prefs: []
  type: TYPE_NORMAL
- en: The `RetryPolicy` static method defines the number of retries to carry out before
    proceeding with the other policies. It uses the `.HandleTransientHttpError` and
    `.OrResult` methods to detect all the failed conditions that have been returned
    by the client. Furthermore, it calls the `WaitAndRetryAsync` method, which restricts
    the `RetryPolicy` to a maximum of three retries. With each retry, it increases
    the sleep duration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CircuitBreaker` static method catches all the error conditions by using
    `.HandleTransientHttpError`. It calls the `.CircuitBreakerAsync` method to define
    `CircuitBreakerPolicy`. `CircuitBreakerPolicy` will be triggered after three attempts
    and will be active for 1 minute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can inject the definitions of these policies into our `HttpClient`
    instances, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are injecting these policies using the `AddPolicyHandler`
    method, and we are calling the `CatalogServicePolicies` static class to get them.
    It is also essential to notice that, before defining the policies, we use the
    `SetHandlerLifetime` method to determine the lifetime of `HttpClient`. This approach
    guarantees more resilient communication between the cart service and the catalog
    service. Furthermore, note that `Polly` policies can be applied to any third-party
    dependency call, which means that every time we rely on a third-party service,
    we need to anticipate this kind of approach in order to gracefully handle errors.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing events using an event bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we've seen how we can share information over HTTP by
    calling other web services. As we've already mentioned, it is important to not
    replicate information between services and, more importantly, that each service
    must be the owner of a single data source, which needs to be as isolated as possible.
    Another technique we can use to share information is pushing data using events.
    In this section, we will begin by examining one use case that is suitable for
    an event bus.
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose that one of the catalog items reaches an available stock amount
    of zero and enters the sold-out state. We need to propagate this information and
    tell the cart service that this specific item is sold out. This use case can be
    implemented using an event bus.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this architecture, take a look at the following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a923daf3-cd8e-4170-8127-60d1e6e849af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The catalog service triggers an event each time the available stock of an item
    reaches zero. The cart service listens for this event and then triggers the update
    of the cart that''s stored in the Redis data source. For this purpose, we will
    use RabbitMQ, which is one of the most common event buses. RabbitMQ provides a
    .NET package that can be used to implement the communication between two solutions:
    [https://github.com/rabbitmq/rabbitmq-dotnet-client](https://github.com/rabbitmq/rabbitmq-dotnet-client).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a RabbitMQ instance and publishing an event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Event bus communication is composed of two parts: the sender and the receiver.
    In the case of an event, the actors'' names are publishers and subscribers. The
    previous section described the implementation of the subscriber part. In this
    case, the catalog service will be the publisher and the cart service will be the
    subscriber. Before we look at how to implement the publisher part, we need to
    create a RabbitMQ instance using a Docker container by adding a `docker-compose.yml`
    file to the catalog service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker-compose.yml` file defines a new container called `catalog_esb`
    using the `rabbitmq:3-management-alpine` image. It also determines how two ports
    are mapped within the localhost network: `5672:5672` and `15672:15672`. The first
    port mapping is used to expose the RabbitMQ instance, while the second one is
    used to reveal the management console.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we need to define an extension method that configures RabbitMQ
    in the catalog web service. We can add the `RabbitMQ.Client` package to the `Catalog.Infrastructure`
    project using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we will also need to implement the `ItemSoldOutEvent` type in
    the `Catalog.Domain` project, under the `Events` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding class reflects the event that we''ve already implemented in the
    cart project, and it will be used to send the messages through the event bus.
    The event bus also requires a configuration class that represents the connection
    parameters to the RabbitMQ instance. The class will be stored in the `Configuration`
    folder of the `Catalog.Domain` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EventBusSettings` type describes the `HostName` of the RabbitMQ instance,
    the `User` and `Password` of the user, and the `EventQueue` name to use to push
    messages. Therefore, we can proceed by implementing the extension method that
    will set up and start the event bus in the `Catalog.Infrastructure` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines how we can publish events to RabbitMQ. The extension
    method performs the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: It initializes a new `EventBusSettings` with the `EventBus` string section passed
    as a parameter and adds the configuration as a singleton instance to the dependency
    injection engine of ASP.NET Core.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It initializes the transport protocol using the RabbitMQ type by initializing
    a new `ConnectionFactory` type. `ConnectionFactory` will provide all the tools
    related to the publication of messages through RabbitMQ.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It adds the new `ConnectionFactory` type into the dependency injection services
    as a singleton type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Moreover, it is possible to resolve the `ConnectionFactory`and `EventBusSettings`
    typesusing the out-of-the-box dependency injection of .NET Core, and proceed by
    publishing the events using the methods provided by the `RabbitMQ.Client` packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `ItemService` class uses dependency injection to inject a new `ConnectionFactory`
    instance and the `EventBusSettings` into the class. As you may have noticed, the
    `DeleteItemAsync` method also calls the `SendDeleteMessage` we defined. Furthermore,
    the `SendDeleteMessage` method uses the `CreateConnection` method in order to
    create a new connection with RabbitMQ. Then, it continues by creating a new fresh
    channel using the `CreateModel` method and defining a new queue that has the same
    name as the queue we defined in the `EventBusSettings` configuration. Finally,
    it proceeds by serializing the `ItemSoldOut` event and publishing the message
    using the `EventQueue` field. The whole procedure is wrapped into a try-catch
    block in order to be ignored in case there is a communication error between the
    catalog service and the queue. Now that we have set up the sender, we can call
    the previously defined `AddEventBus` extension method in the `Startup` class of
    `Catalog.API` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddEventBus` method now uses the `EventBus` section to provide the necessary
    configuration to the new instance of the `ConnectionFactory` type. Now, we can
    add the configuration to the `appsettings.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`ConnectionString` specifies the `catalog_esb` instance as the name of the
    host and the default `username` and `password` provided by RabbitMQ. Furthermore,
    it also specifies the `ItemSoldOut` endpoint name. Now, every time we delete an
    item in the catalog service, it will queue a new ItemSoldOut event into RabbitMQ.
    In the next chapter, we will see how to consume these messages in the cart service.
    In the next section, we will continue by learning how to set up and configure
    the cart service Docker image.'
  prefs: []
  type: TYPE_NORMAL
- en: Running the cart service using Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s learn how to run the previously implemented cart service using Docker.
    As we described in the previous chapter, we are going to define the `docker-compose.yml`
    file and the Dockerfile in the root of the cart service project. The `docker-compose`
    file will define two containers: the first hosts the cart service ASP.NET Core
    instance, while the other represents the Redis instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: First, the preceding code defines the `cart_api` container. It is part of `my_network`,
    which is defined in the same file, and it exposes ports `5002` (HTTP) and `5003`
    (HTTPS). It also refers to the Dockerfile that's located at the root of the project.
    Secondly, the `docker-compose.yml` file defines the `cart_db` container, which
    exposes the default port of Redis (`6378`). The `cart_db` container uses the Alpine
    version of Redis so that it can save on the container size. The container shares
    `my_network`.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are using a storage system running on a container. Note that
    this information is not persistent, for two reasons. The first reason is that
    Redis stores information using a TTL. The default TTL is 24 hours; after that
    time, the basket information is cleared. It is possible to specify anther TTL
    when you add a new key to the Redis instance. The second reason is that, once
    the `cart_db` container is killed, we will lose the information inside it. We
    are using a Redis instance in the form of a container just for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at an overview of the definition of the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The Dockerfile fulfills the same instructions as the ones defined for the `Catalog.API`
    project: it uses the `microsoft/dotnet:sdk` image to build the project and publish
    it and then it uses the `microsoft/dotnet:3.0-aspnetcore` image to run it. To
    get the containers working, we need to share information between the `Catalog.API`
    project and the `Cart.API` project containers. Moreover, it is necessary to initialize
    the containers in the same project by adding the following `.env` file to the
    same level that the `docker-compose.yml` file is at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `COMPOSE_PROJECT_NAME` variables set the project name. This value is prepended,
    along with the service name, to the container upon startup. Finally, it is possible
    to run both projects by executing the `docker-compose up --build` command in the
    `Catalog.API` and the `Cart.API` project folders: the `docker-compose` command
    in the `Catalog.API` folder will initialize the `catalog_api`, `catalog_db`, and
    the `catalog_esb` containers. On the other side, the execution of the `docker-compose`
    command in the `Cart.API` folder will initialize the `cart_api` and `cart_db`
    containers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, it is possible to create a new catalog item by executing the following
    sequence of HTTP calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'These two requests are direct to the `localhost:5000` URL, which represents
    the catalog web service. They return a `201 Created` HTTP status code with the
    ID of each created artist and genre entity. Furthermore, we can proceed by creating
    a new item in the catalog using the following HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can proceed by calling the cart API service in order to create a new
    cart session with the item we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can verify the communication between the catalog service and the
    cart service by calling the detail of the cart session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The cart service should respond with the details related to the item in the
    cart by fetching the information that was exposed by the catalog web service.
    If the catalog web service is down, the cart service will omit all the details
    of the items by returning only the corresponding ID.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how to implement different types of communication
    in service ecosystems. We looked closely at how to use an HTTP client to share
    information between services. We also looked at how we can use resilience techniques
    with `Polly`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we described how to use an event bus to fire events to a RabbitMQ queue;
    we used `RabbitMQ.Client` combined with RabbitMQ for this. The topics that were
    covered in this chapter will be useful when you need to transfer data or perform
    actions across two or more web services or systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to consume `ItemSoldOut` events through
    the use of the worker services capabilities of ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
