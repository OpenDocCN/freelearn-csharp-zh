- en: RPG Character Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now at an interesting point in our development. In this chapter, we will
    discuss the design of our RPG characters and look at some of the attributes and
    characteristics that we need to design and implement.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a breakdown of the topics covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Character definitions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base character class attributes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character states
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Character model:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rigging your model
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Character motion
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Animator controller
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation states
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Character controller
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Modification to animations
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Inverse kinematics
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character definitions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To have a meaningful and interesting RPG, the game should usually have more
    than one character class. In [Chapter 1](part0021.html#K0RQ0-7a1ef7ae3ef249cdb149f8344d2e8e79),
    *What is an RPG?* We defined the following class types:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Barbarians
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orcs
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Villagers
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won't be able to implement all of the character types, due to time. The demonstration
    of the implementation of one or two character types should give you a good foundation
    to develop your own character classes. After all, that is the overall objective
    of this book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: One of the main characters is, of course, the **Player Character** (**PC**).
    Let's go ahead and concentrate on the implementation of the PC, and then we can
    start defining and designing the `Barbarian` class, the `Villager` class, and
    perhaps the `Orc` class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: My character models will be from the Asset Store. You may either download the
    same characters or design your own. You can also use different types of character
    models. The point is to implement the character based on the specifications, which
    will be defined in this chapter and beyond.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Character assets
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I will be using the following assets from the Asset Store for my character
    models:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Fantasy Horde Barbarians
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fantasy Horde - Villagers
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fantasy Horde - Orc
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at some of the attributes that our player will have in general.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Base character class attributes
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start laying down the foundation we will need for the implementation
    of our character classes. The following is a list of attributes that will be part
    of the Base Character class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Character class name
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character class description
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'List of attributes:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strength
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dexterity
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Endurance
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Intelligence
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Social standing
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Agility
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Alertness
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Vitality
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Willpower
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The attributes you define for your characters depend on the character type,
    but there will be some similarities between all character attributes. We would
    like to implement these similarities in a base class that will be shared with
    all character classes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The list provided is just a sample, and you can add or subtract as you see fit.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s keep things simple. We will use only the five primary statistics for
    now, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '**Strength:** Strength is a measure of how physically solid a character is.
    Quality controls the most extreme weight the character can convey, skirmish assault
    as well as harm, and some of the time hit focuses. Protective layer and weapons
    may likewise have a strength prerequisite.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defense:** Defense is a measure of how flexible a character is. Protection
    more often than not diminishes harm taken by either a rate or a settled sum for
    each hit.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dexterity:** Dexterity is a measure of how deft a character is. Skill controls
    assault, development speed, and precision, and also dodging an adversary''s assault.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intelligence:** Intelligence is a measure of a character''s critical thinking
    capacity. Knowledge regularly controls a character''s capacity to understand remote
    dialects and their aptitude in enchantment. Now and again, insight controls what
    number of aptitude focuses the character gets at level up. In a few recreations,
    it controls the rate at which encounter focuses are earned, or the sum expected
    to level up. This is once in a while joined with shrewdness, and additionally
    self control.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health:** Health decides whether the character is alive or dead.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The attributes listed are attributes that will be inherited by all character
    classes. Now let''s put this into code. Create a new C# script and name it `BaseCharacter.cs`.
    Open the script and place the following code in the file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Character states
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'States are an important part of the character design. They will also drive
    the kind of actions and movement you will need to create for each state. For instance,
    at a minimum our character will need to have the following states implemented:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Idle
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walking
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumping
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacking
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Die
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You character may have more states defined; this is something that you, as the
    designer of the game, will need to identify and eventually implement. Each one
    of the states identified will need to be implemented as an animation. The person
    creating the character models will usually also develop the animations for the
    character.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the Orc model has the following states/animations defined:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.gif)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: You may consider implementing all of the states or some of the states. The theory
    and practice are the same either way.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: I can also use RawMocap data to animate the models, since the models I am using
    are Mecanim-ready, including Face Rigs. In fact, we will use some RawMocap data
    to animate the models.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: With the release of Unity 5, the *Mecanim Animation System* was introduced,
    which is used to create easy workflow and setup of animations on humanoid characters,
    retargeting animation from one character to the next, previewing the animation
    clips, managing complex interactions between animations with a visual tool, and
    animating different body parts with different logic.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: In fact, let's go ahead and download the asset from the Asset Store right now.
    Do a search on *Raw Mocap Data for Mecanim* in the Asset Store.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: The package contains several raw motion capture data files for your use. Be
    aware that you might have to make some adjustments on your own.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: When creating your character models, it is a good idea to follow the proper
    bone structure set up for your characters. This will help make controlling the
    states and the animations of your character easier, as well as re-using your Animation
    Controller on multiple characters. This is also true if you are going to use a
    character from the Asset Store.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Character model
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now consider how your player character is going to look. There are
    several approaches that can be taken. An easy way would be to have a predefined
    hero where the player does not have many options or much choice when it comes
    to customization of the character. The other way would be to provide the player
    the ability to change and modify their character to an extent or fully. This all
    really depends on your budget!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are going to do something in-between, to get the benefit of both worlds.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: You may use the Asset Store to download predefined characters that can be used
    as placeholders for your game while you create your own. You can even use some
    of the characters that are freely available through the Asset Store and modify
    them for your needs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Once you have determined your character model, the next step is to configure
    it and customize it for your game. The character model I have can be visually
    modified to represent several unique characters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: For instance, let's take a look at the default character models we will be working
    with, as detailed in the following sections.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Default character models
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here is a set of character models that have been purchased from the Asset Store.
    I like this set of models as they are simple and straightforward to work with.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Barbarian
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This model contains several body types—fat, regular, and skinny—which are set
    up by blendshapes on the body and cloth. It comes with 15 different body and accessories
    textures, one weapons texture, and two shield textures. This gives us a good range
    of unique character definitions and customization to enhance the range of different
    NPCs for the RPG.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take a look at how to utilize them when doing character customization.
    See the following screenshot for an example of a barbarian:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: The Barbarian model
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Villager
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Villager models give us two groups of models: child and adult. In the adult
    group, we have the male, female, and monk types. There are 16 male, three monk,
    eight female, four child, and two equipment textures provided. For the female
    type, there are two types of texture: standard hair, used for loose hair, and
    hat, used with head accessories such as a hat.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different sets of animations: one for the `Adult` mesh type and
    one for the `Child` mesh type. The child type has fewer states compared to the
    adult. See the following screenshot, depicting a male, female, and child villager:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: The Villager models
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Orc
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Orc model will be a bit different in its structure. All body-type meshes
    will be part of the main structure; there are three main models: Fat, Average,
    and Athletic. There might also be some legacy animations, which we will need to
    take care of when we start the configuration and programming or the `Orc` class.
    See the following screenshot of an orc:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: The Orc model
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drag and drop the Barbarian model from your project into the scene. You will
    need to study your character model carefully, and understand how it is built so
    that you can modify it during design time, as well as during runtime if necessary.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'This particular model has several visual elements attached for weapons, clothing,
    and so on. Your model may have been configured differently; if so, you will need
    to create your own attachment points and instantiate the weapons and/or other
    character related assets accordingly. See the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: Model hierarchy
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Select your character model and investigate the structure of the model. You
    will notice that there is a certain pattern and naming convention to the model
    hierarchy, as shown in the preceding screenshot. Some models might have animations
    attached. To check them, you will need to select the model from the Project window
    and select the Animation tab in the Inspector window to get a list of the embedded
    animations for the model, as shown in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: 'In the Inspector window, select the Animations tab shown in the preceding screenshot,
    and notice the Clips section for all animations developed for your character model,
    as indicated in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.gif)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: Notice that the animation clips have a start time and an end time. The actual
    character model is visually displayed at the bottom of the Inspector window.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Rigging your model
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There might be times that you will need to Rig your model to make it suitable
    for your game. This can be achieved by selecting your model source, and from the
    Inspector window selecting the Rig tab, as shown in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00060.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: 'In the Rig tab, there are several options that you can apply to your model.
    Assuming that your character is of Humanoid type, you will need to select the
    Humanoid Animation Type if not already selected. The Avatar Definition can also
    be either created from the model or assigned if you have an avatar defined. Finally,
    you can click on the Configure... button to see the configuration of the rigged
    model. See the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00061.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: Humanoid bone structure
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Notice from the preceding screenshot that your model has a mapping defined for
    its skeleton. If your model is of Humanoid type, and if your model structure has
    been named properly, the system will automatically assign the correct bones and
    joints. If your naming is not per Unity specification, you can navigate your model
    structure and manually assign each point in the Body, Head, Left Hand, and Right
    Hand.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The Muscles and Settings tabs will enable you to define and restrict the movement
    of the joints for your model. These can be very useful and practical for creating
    more realistic movements for your characters. You can study these topics further
    on your own, as they would require a whole chapter or two to cover them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Character motion
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, the motion and movement of the characters were done separately
    through code. With the introduction of *Mecanim*, you are now able to apply what
    is called *Root Motion*. This modifies the character's in-game transform based
    on the data in root motion.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use root motion for our characters. Root motion works with the
    Animator Controller and the Animation State Machine. The Body Transform and Orientation
    are stored in the Animation Clip. This makes it easier to create a state machine
    that plays the appropriate animation clip through the Animator Controller.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Animator Controller
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use the new Animator Controller to create our character
    states and determine the criteria for a change of states. Let's make a new folder
    in the Project window and name it `Animator`. Select the newly created folder.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: To create an Animator Controller, in the Project window, right-click and select
    *Create | Animator Controller*. Give it a name. I have called mine `BaseAnimatorController`.
    Double-click the controller to open the Animator window.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The Animator Controller is a very complex tool, and it will take you some time
    to study the different aspects and features that are available to you through
    it. The following screenshot is a snapshot of an empty controller. I have marked
    the main sections of the Animator window. There are two visible tabs, the Layers
    tab and the *Parameters* tab. In the *Layers*, tab you will be able to create
    different layers that hold your animation states and the relevant `Transitions`
    from one state to the next. The *Parameters* tab is where you define your parameters
    that will be accessed and modified by the Animator Controller, as well as through
    your code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a wide range of topics that you will need to know to fully appreciate
    the Mecanim system. We won''t be going through all of the aspects in this book,
    but we will touch on some of the key aspects that are needed for our game. See
    the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00062.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: Animation states
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a new state, you can simply drag and drop an animation from your
    Project window. This will name and assign the relevant animation to the state
    in the layer. You can also create an empty state by right-clicking in the layer
    and selecting *Create State* | *Empty*. When a state is created, you can click
    on the state and observe its properties in the Inspector window, as shown in the
    following screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00063.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: Your model may or may not have animations attached to it. The whole idea of
    the Mecanim system is to enable character modelers to work on their models, while
    animators can use the skeleton of a humanoid avatar to animate the character.
    This in turn makes it easier and better to have a set of animations applied to
    different types of character models!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: To identify the state, it is best to provide it with a unique name that can
    be easily recognized in the state diagram. You will need to assign a Motion to
    it; this is the animation clip that will be playing when the state is active.
    The next important property would be the *Transitions* property. A transition
    will determine the condition for which state will be moving to another state,
    if there is such a requirement.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, when the character is in an idle state, what condition is for
    the character to change its state to a walking state, to a running state and so
    forth, as shown in the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00064.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, you will see I have defined three different states:
    Idle, Walking, and Running. You will also notice that, in the *Parameters* tab,
    I have defined some parameters. These parameters are used to determine when to
    move from idle to walking, to running, and back. The parameters are there to help
    you create the conditions for your state machine.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: To create a Transition from one state to the next, right-click your state, and
    select *Make Transition*, then select the state it will transition to. This will
    create the visual arrow from the start state to the end state. Select the *Transition*
    arrow to get its properties, and set the conditions in the Inspector window.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The Walking and Running states are actually a Blend Tree in this instance. A
    Blend Tree is used to make the transition from one animation state to the next
    more natural. In order for the blended motion to make sense, the motions that
    are blended must be of similar nature and timing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Blend Trees are used to allow multiple animations to be blended smoothly by
    incorporating parts of them all to a varying degree. The amount that each of the
    motions contributes to the final effect is controlled using a blending parameter,
    which is just one of the numeric animation parameters associates with the Animator
    Controller.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the walking state could look something like the following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00065.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: Blend Tree example
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'In our first *Blend Tree* node, we have five outputs: `HumanoidWalkLeftSharp`,
    `HumanoidWalkLeft`, `WalkFWD`, `HumanoidWalkRight`, and `HumanoidWalkRightSharp`.
    These are the animation clips that will be playing based on the value of the parameter
    called *Horizontal*.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: These animations are from *Raw Mocap Data for Mecanim.*
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'In the behavior region, you will notice a few thresholds that have been set
    up for the parameter; these thresholds are what determines the animation to be
    played. The value of the Horizontal parameter is set through our C# code by passing
    in the value of the Horizontal Axis, which is defined in the Input Manager. See
    the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00066.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: When you select a *Blend Tree* node, your Inspector window will give you the
    ability to add or remove the different animation states, as well as the parameter
    and the threshold of the parameter that will determine which animation will be
    rendered.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The key to have a smooth looking blending in your animation is to pay attention
    to your animation data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our final state diagram:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00067.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: State diagram
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, I have gone ahead and implemented the state diagram for *Idle*,
    *Walking*, *Running*, *Idle Jump*, *Running Jump, Attack1/2/3*, *Punch*, and *Die*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The parameter that defines the transition from the Idle state to the Walking
    and Running states is the Speed parameter. If the Speed value is greater than
    0.1, it will transition from Idle to Walking; if it is greater than 0.6, it will
    transition from Walking to Running. The opposite is true for going from Running
    to Walking, and from Walking to Running.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Notice, however, that the character can only enter the Jump state from either
    the Idle state or from the Running state. The parameter that controls this transition
    is the `Jump` parameter, which is a Boolean value set by pressing the Space bar
    button on the keyboard.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: There are also three attack states that can be triggered from the Any state,
    as well as a Die state that can be entered from the Any state. Well, this is because
    your character can die at any given time if you are not careful!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how we can control these parameters.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Character controller
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time to enable our character to move around the scene. This is generally
    handled by the character controller. The character controller will be used to
    handle most of the interactions the player will have with the character in the
    game.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script and call it `BarbarianCharacterController.cs`. Enter
    the following code in the `BarbarianCharacterController` class. At the moment
    the code is very basic. Let''s get a listing of the code and we can start discussing
    the different parts of the code after the listing:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `Start()` function, we will get a reference to the Animator Controller.
    We will be using the `FixedUpdate()` function to perform our updates for the character
    movement, as shown in the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What is the difference between the `Update()` function and the `FixedUpdate()`?
    The `Update()` function is called every frame, and is used regularly to update
    the moving of non-physics objects, simple timers, and input processing. The update
    interval time varies for the `Update()` function. `FixedUpdate()` is called every
    physics step. The interval is consistent and used for adjusting physics on Rigidbody.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In the `FixedUpdate()` function, we get the inputs for our Horizontal and Vertical
    axes, we calculate the *speed* value, and set the parameters defined in the Animator
    Controller using the `animator.SetFloat()` function. These parameters are then
    used by the animator controller to decide which state the character is at.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: For instance, to go from an idle state to the walking state, the *speed* parameter
    needs to be greater than 0.1, and from walking to running, the *speed* parameter
    will need to be greater than 0.6, and the *run* parameter needs to be true. The
    opposite is true when you want to go back from the running state to the walking
    state and from the walking state to the idle state. The Horizontal and Vertical
    parameters control the movement for turning left or turning right. All these three
    parameters combined control what state and what animation the character is rendering.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The next step is for us to enable the *Jump*, Die and *Attack* states. The Jump
    state can be entered while the character is idle or running and the Jump Boolean
    variable is set to true. The jump condition is set in the `Update()` function
    when the space bar is pressed by the player. This sets the variable to true and
    passes the variable to the animator controller.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'The same mechanism is used for the attack and punch state. This is mapped to
    the following keys on the keyboard: *C* and *P*. Each one will set its Boolean
    value to true and pass it into the animator controller. The player can only enter
    these states from the Any state. We will leave it as is for now.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Die state is implemented, and for now we are using the keyboard
    input I to test it out. The main difference between the Die state and the other
    states so far is that the Die state can be entered from any state.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: We are not using Blend Trees for these states as there is only one type of animation
    for the state. You will also notice that the states can only be transitioned to
    from the Idle state. This is due to how the animations and model were set up initially.
    Yours could be different.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00068.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: Animator parameters
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The character can get into the Die and Attack states from any state. That is,
    your character player can die at any time in the game, whatever state he or she
    is in at the time. The jump states can be triggered from two states, idle and
    the running. You can improve these transitions and states based on the level of
    your animation complexity, but for now, this should do.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00069.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: These states are controlled through Boolean parameters defined in the animator.
    At this stage, you should be able to use your model to test the scene, as well
    as your character animations and states.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Modification to animations
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There might be times that you will need to make some changes and/or modifications
    to the existing modification that will make it work properly with your game and
    the state machine.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'The attack animations prepared for my character model need to be adjusted to
    make them loop while the character is still in that particular state. For instance,
    if I use the existing animation and the character state goes into attack mode,
    the animation will play only once. This is not what I intend to do; I am building
    the attack input to perform the attack while the attack key is pressed down. Changing
    the animation loop setting is easy. To do so, select the animation from your Project
    window and select the *Edit...* button from the Inspector window, as shown in
    the following screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: You will now be in the Edit mode of the animation, as displayed in the following
    screenshot. I have placed the Inspector window next to it, to illustrate the Animation
    tab, selecting each animation we want to modify, one at a time, and setting the
    Loop Time property to True.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'In this particular screenshot, you will also notice several other important
    properties for the animation, such as *Root Transform Rotation*, *Mirror*, *Curves*,
    *Events*, *Mask*, and *Motion*. We will use the Curves property when we set out
    Inverse Kinematics for some of our animations regarding our character. This basically
    sets the values of predefined parameters that can be used to set or get them through
    *Mecanim*. Take a look at the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00071.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: If your animations are attached to your model and your animations and models
    are older, you will most likely need to make some modifications to them.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: For instance, one of the main properties that you might have to set for a particular
    animation clip would be the *Loop Time* property, as shown in the preceding screenshot.
    This will make sure that the animation will loop as long as you are in the state
    which is running the animation. If looping is not enabled, the animation will
    run once and stop, even if you are still in the state representing the animation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the *Loop Time* property is set for the idle, walking, running and
    attacking animations. At the same time, not all animation clips need to be looped,
    for instance, the jump and die animations just need to be played once. You will
    need to do your diligence and check all of these properties.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Other animation will need to be modified to enable baking the transform into
    the model. For instance, the die and jump animations have the following properties
    checked: *Root Transform Rotation* and *Root Transform Position (Y)*; make sure
    that the *Bake Into Pose* property is checked. This is important, to make sure
    the animation and the skeletal movement of the character are harmonized at the
    root transform position.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Your animation might seem funky if these properties are not set properly. If
    there is something weird going on, make sure to double-check these properties.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: If you have not done so by now, you should attach your `BarbarianharacterController.cs`
    script to your player character.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Inverse Kinematics
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Inverse Kinematics** (**IK**) is important in game programming. It is typically
    used to make the character''s movement more realistic. One of the main uses of
    IK is the calculation of the player''s feet and how they relate to the ground
    they are standing on.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: In short, IK is used to determine the position and rotation of the joints of
    a character based on a given position in space. For instance, to make sure the
    foot of a player lands properly on the terrain it is walking on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Unity has a built-in IK system that can be used to do some basic calculations
    in this regard. Let's go ahead and implement the foot IK for our character. There
    are a few things that you will need to set up before we can enable IK for our
    humanoid character.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is check your layer in the Animator Controller and use
    the Engine icon to enter the Settings window. Make sure that *IK Pass* is checked,
    as shown in the following screenshot. You will also need to provide a Mask if
    you have not done so already. The mask is used to dictate which parts of the skeleton
    are affected by the IK. Take a look at the following screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Mask for Inverse Kinematics
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have set this up, the fun begins. We need to create a C# script that
    will handle our IK. Create a C# script and call it `IKHandle.cs`. Type the following
    code into the script:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This script is a bit involved. In order for the Inverse Kinematic, that is,
    IK, to work properly, we need to identify a couple of important points in space.
    One of these points is the position of the target in space that we want our foot
    to move to, and the second point in space is the hint. These two points in space
    are used to control the movement and translations of the skeleton for a particular
    joint to be made, in order to successfully complete the IK for the target position.
    Take a look at the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `LeftFootPosition` and `RightFootPosition` variables are used to represent
    the target position for the left and right foot during runtime. `LeftFootRotation`
    and `RightFootRotation` are used to store the rotation of the left and right foot.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: We also need two variables to actually reference our left and right foot in
    the model. This is done by the `LeftFoot` and `RightFoot` variables.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Some of these variables are initialized in the `Start()` function. Specifically,
    we get a reference to the left and right foot from the Animator Controller bone
    structure defined for humanoids.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Update()` function, we use `Physics.Raycast()` to perform some raycasting,
    to determine the position of our left and right foot. This data is then used and
    stored in the `LeftFootPosition` and `RightFootPosition` variables, with their
    equivalent rotation data in the `LeftFootRotation` and `RightFootRotation` variables.
    Take a look at the following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00073.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: Animation curves
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The actual IK animation is applied in the `OnAnimatorIK()` function. The `LeftFootWeight`
    and `RightFootWeight` variables are used to get the parameter values set for `MyLeftFoot`
    and `MyRightFoot` in the Animator Controller, through the animation clip `Curve`
    function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The key here is to properly define the curve of the animation clip that will
    be used to drive the weight of the IK. The preceding screenshot only shows the
    curve of the idle state. Both feet are on the ground, therefore the value is set
    to 1\. For your walking and running clips, your curve will be different.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `SetIKPositionWeight()` and `SetIKPosition()` functions are used
    to properly adjust the position and rotation of the feet relative to the ground!
    Notice that this is performed for each foot separately.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Attach the `IKHandle.cs` script to your character and do a test run. Notice
    the difference in your character and the way it is interacting with the floor
    or the terrain you have set up.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Setting the animation curve
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This step is very important for the IK to work. I am going to use the Idle
    animation to demonstrate what needs to be configured, to make sure the parameters
    in the animator controller are set properly. Take a look at the following screenshot:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00074.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: Animation curve modification
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: For the IK to work properly and look nice, you will need to set the curve for
    each animation that has to do with the motion of the feet. Since we have five
    sets of animations for walking and running, you will need to perform the same
    for each animation curve to properly set the weight value that will be passed
    to the IK script.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot of content in this chapter. We discussed the different character
    definitions we will be using for our game, looked at the base character class
    attributes that will be shared by all of our characters, and created the `BaseCharacter`
    class to be used later in the game. We also discussed the primary states our character
    will have in the game, and how to implement them using the Animator Controller.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how to rig our character model to be prepared for the Mecanim system,
    as well as how to use the Mecanim system to create animation and state diagrams
    that will determine how the character behaves during game play. Then we implemented
    our initial character controller script that handles the state of our character.
    This gave us the opportunity to look at the Blend Trees and transition from one
    state to the next using parameters. We then looked at how to modify animation
    clips if there is a need for it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何为我们的角色模型绑定，使其为Mecanim系统做好准备，以及如何使用Mecanim系统创建动画和状态图，这些图将决定角色在游戏中的行为。然后我们实现了我们的初始角色控制器脚本，该脚本处理我们角色的状态。这给了我们机会查看混合树以及使用参数从一个状态过渡到下一个状态。然后我们探讨了如果需要的话如何修改动画剪辑。
- en: Finally, we learned about Inverse Kinematics, which will help our character
    to behave more realistically in the game environment.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了逆运动学，这将帮助我们的角色在游戏环境中表现得更加真实。
- en: Having reached the end of the chapter, you should have a good grasp of all of
    the different components that work together to make your character look, behave,
    and move in the game environment.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 章节结束，你应该已经很好地掌握了所有共同作用使你的角色在游戏环境中看起来、表现和移动的不同组件。
- en: In the next chapter, we will be introducing non-character behaviors.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍非角色行为。
