<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Communication Protocols</h1>
                </header>
            
            <article>
                
<p>We've spent the first two chapters of this book discussing what makes networks hard to program for open communication and device agnosticism. These aspects of networks demand standardization, and in this chapter, we'll examine how standards provide a common language that the network software can communicate through. First, we'll learn about the governing body that defines those standards. We'll learn a bit about who they are and what objectives they sought to achieve. Once we understand who defined the common architecture of networks, we'll take a deep dive into the way they've organized and categorized each tier of the hierarchy of network layers.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The origin of the current standard for network architecture and a brief history of it, as well as some background on the organization that is responsible for it.</li>
<li>How application code interacts with networked resources through the application layer and what communication standards are provided for that layer.</li>
<li>How data is communicated out to, or read from, the network on the transport layer of the network architecture standard.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>As with <a href="7dd1ec0d-a43e-470e-ad8a-d86d69db2d9b.xhtml">Chapter 1</a>, <em>Networks in a Nutshell,</em> this will be more of a conceptual examination of the standards defined for networks. There is no specific technology as such that is required for this book. We'll be using the same technology for this chapter as we have in others: NET Core 2.1 SDK and either Visual Studio Code, or Visual Studio Community Edition to use as an IDE.</p>
<p>Check out the following video to see the code in action: [Placeholder link]</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Open Systems Interconnection network stack</h1>
                </header>
            
            <article>
                
<p>There are several steps in the process of sending or receiving a resource from a remote source over a network, and each of those steps has been deeply considered by the network engineers tasked with executing them. In this section, we'll look at who<em> </em>those network engineers were, and how<em> </em>they defined a general pattern for implementing each step in that process. This section will be all about the OSI, and how that specification defines the network stack of a given network device.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What exactly is the Open Systems Interconnection?</h1>
                </header>
            
            <article>
                
<p>In order to talk about communication protocols, we need to understand how each <span>protocol</span> fits into the larger picture of network connectivity, and to do that we need a common model for thinking about each step in the process. To that end, we have the OSI model for computer and telecommunication networks. This model seeks to organize the different steps of standardized communication to or from a given device into a tiered model of abstraction layers. Much like the logical topologies of a network, which we discussed in <a href="7dd1ec0d-a43e-470e-ad8a-d86d69db2d9b.xhtml">Chapter 1</a>, <em>Networks in a Nutshell, </em>the OSI model exists on a purely conceptual and abstract level.</p>
<p>As the name suggests, it was defined in such a way as to be useful as a reference<em> </em>while remaining entirely agnostic as to how any of the tiers defined in the model are ultimately implemented at the physical level. In fact, many implementations of communications protocols or standards do not<em> </em>cleanly map to the OSI network model. However, the model is broadly considered the gold standard, and has been since it was formalized in 1984. So, let's take a look at how that came to be.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The origins of the OSI</h1>
                </header>
            
            <article>
                
<p>The need for a standardized model for network implementations became apparent almost as soon as networking became possible. To that end, back in the late 1970s, two different organizations for governing standardization in computing set out to define such a model. <span>The first of these organizations was the</span><span> </span><strong><span>International Organization for Standardization</span></strong><span> (</span><span><strong>ISO</strong>). The other organization that set out to solve the same problem, at roughly the same time, was the <strong>International Telegraph and Telephone Consultative Committee</strong> (<strong>CCITT</strong>, initialized from the French translation of the name).</span></p>
<div class="packt_infobox"><span>Interestingly, the shortened name for the International Organization for Standardization, ISO, is </span>not<em> </em><span>an initialism of the name of the organization. Instead, since the name of the organization would be initialized differently in each language that it is recognized, the members chose to shorten the name to ISO. This is in reference of the Greek isos, which means equal, and speaks to the goal of the organization to bring about equal understanding.</span></div>
<p><span>The fact that two organizations sought to define their own model at roughly the same time as one another isn't entirely surprising. The problem was faced by engineers across a wide array of disciplines, and the lack of standardization was quickly becoming a bottleneck to progress in those disciplines. What is surprising, however, is how similar the solutions were to one another. Like Leibniz and Newton independently inventing calculus, these organizations incidentally arrived at a common solution to their common problem. However, this happy coincidence helped to expedite the standardization process, since the similarity of their solutions served to validate both models as being highly likely to be correct.</span></p>
<p><span>Given the success of both organization's efforts, it took only a handful of years before both models were merged into a single standard. Thus, in 1983, the Basic Reference Model for OSI<strong> </strong>was born. Over time, the name has, of course, been shortened to the OSI model. By 1984, each organization had published this new shared model under their own official reference documents, canonizing the model, and its specific protocols, within the international community. So, let's take a look at what that model entails.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Basic Reference Model</h1>
                </header>
            
            <article>
                
<p>The Basic Reference Model was formalized by ISO as standard ISO-7498 (and as standard X.200 by the ITU, the successor to the CCITT). The model could be cleanly broken into two parts. The first part is the abstract Basic Reference Model for networking. The second is the list of protocols the organizations saw fit to standardize for use by systems that implement the reference model.</p>
<p>The reference model defines network communication streams, as implemented by a compliant device on a network, in a hierarchy of seven distinct conceptual tiers, or layers, organized in a stack. This stack is defined as far down as the transmission of raw bits over physical media, and all the way up to the high-level application software that might use any resource distributed over a network.</p>
<div class="packt_infobox">For our purposes, as we describe these layers, when we say a layer is higher<em> </em>in the stack, we mean farther away from the hardware-level transmission of bits across a physical medium.</div>
<p>The model defines a strict mechanism of unidirectional interaction between layers. According to this communication standard, a given layer can only ever communicate with the layer directly beneath it through an abstract interface exposed by that lower layer. This interface is known as the <strong>service definition </strong>of a layer, and it defines the valid operations by which a higher layer can interact with any lower layers. The interaction model between layers of the OSI network stack shows the same:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-897 image-border" src="assets/7612d6ab-b762-4d3b-8ac6-e5b1fba0a536.png" style="width:20.33em;height:13.33em;"/></p>
<p>As data moves through the layers of the stack, each lower layer wraps the packet in its own series of headers and footers to be parsed by the recipient device. This contains information about what layer in the stack the data originated from, as well as how to parse it.<span> The data packet that gets passed down, layer-to-layer, through the network stack, is known as a </span><strong>Protocol Data Unit</strong> (<strong>PDU</strong>)<span>.</span></p>
<p>While service definitions provide an interface for interaction from one layer to the layer beneath it, <strong>protocols </strong>provide standardized interaction for an entity at a given level in the network stack to interact directly with a corresponding component at the same<em> </em>level on a remote host. These protocols assume smooth interaction down the stack of the originating host, and then back up the stack on the remote host. Once it has bubbled up the stack to the target layer of the remote host, the protocol determines how the receiving entity should process the data.</p>
<p>So, we can describe the entire process of data transmission through the OSI stack, as follows:</p>
<ol>
<li>An entity on the originating host creates a data packet, known as a PDU, at a given layer in the network stack, <strong>N</strong>.</li>
<li>The originating layer passes it down the stack by leveraging the service definition<strong> </strong>of the layer immediately beneath it.</li>
<li>Lower layers receive the PDU, each wrapping it in a set of headers and footers, to be parsed by the corresponding layer on the remote host.</li>
<li>Once the PDU has been wrapped in headers and footers by the bottom most layer of the stack, it is transmitted to the remote host.</li>
<li>Each layer of the stack on the remote host removes the headers and footers applied by the corresponding layer of the originating host, bubbling the PDU up through the stack.</li>
<li>The PDU is received by layer <strong>N</strong><em> </em>on the remote host. The receiving layer then parses the data of the PDU according to the specifications of a protocol<strong> </strong>for layer <strong>N</strong><em>, </em>as specified by the originating host.</li>
</ol>
<p>And just like that, our data is transmitted, reliably, over the network. That is the complete, if abstract, process of using protocols to transmit data units through the service definitions of each layer in the network stack. I know, it's a lot to take in at once, but it will become slightly more clear as we build up the picture more completely. So, with that, let's look at what the individual layers of the stack are, why they're ordered the way they are, and what they're ultimately responsible for.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The layers of the network stack</h1>
                </header>
            
            <article>
                
<p>As we examine each layer of the network stack and what it is ultimately responsible for, there are some key things to bear in mind. First, remember that the model is abstract at its core, and is only meant to serve as a reference. For this reason, there may be times where it's not obvious which layer a given responsibility or task belongs to. Second, bear in mind that as we discuss the responsibilities of each layer in the stack, we're speaking specifically about the responsibilities of that layer with respect to the successful transmission of data over the network<em>.</em> So, the responsibilities of the session layer in the context of the network stack are completely independent of, say, the management of a user session in the context of a web application.</p>
<p>Finally, it's useful to remember that the farther down<em> </em>the stack we go, the closer we get to the physical transmission of data over a physical medium<em>. </em>We'll be numbering the layers in our stack in descending order, from top to bottom, so that the smaller the number, the closer we are to the signals on the wire. This will be helpful when considering why one layer is lower than another, and how its responsibilities are distinct from those of the layer above it. With all of this in mind, let's dive in, top to bottom, through the OSI network stack.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Host/Media distinction</h1>
                </header>
            
            <article>
                
<p>The first thing to understand about the network stack is that there are different levels of abstraction that you can view. The higher up, conceptually, that you look at network interactions, the fewer layers there are, and the easier it is to distinguish between the responsibilities of those layers. Meanwhile, when you build a model closer to its concrete implementation, you see the distinctions between more subtle roles and responsibilities of each entity in that model. We're going to be looking at the full, lower-level model provided by the OSI reference model, but I want to take a moment to consider the higher-level distinction between entities on a network, which breaks down into two fundamental layers.</p>
<p>The first of these layers is the Host layer. This encapsulates the four higher levels of the OSI stack and describes entities or responsibilities specific to a given host trying to communicate on a network. In the most basic context of two-way communication between two hosts on a network, each host is responsible entirely for its own implementation of the OSI layers that aggregate up under the Host layer (hence the name). Bundling application data, specifying encoding and reliability expectations, and the methods for sending out a PDU to a given target all fits, loosely, under the Host layer.</p>
<p>The second layer in the higher-level view of networks is the Media layer. These layers describe the physical implementation of the network components between<em> </em>two hosts. This provides the expected functionality specified or requested by entities in the Host layers. Entities of this layer are typically implemented either on the hardware level, or in a low-level systems language such as C or C++. For this reason, entities of this layer will generally fall outside the scope of this book. However, C# provides abstractions that encapsulate and represent the functionality of entities in this layer, so it's important to understand how the layers that fall under the Media layer actually work on a basic level.</p>
<p>With that high-level distinction made, let's take a look at the full OSI model for networks, starting from the top.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The application layer</h1>
                </header>
            
            <article>
                
<p>The top most layer of the network stack is also the layer that most developers will interact with over the course of their careers. The application layer provides the highest-level interface for interaction with network communication. This is the layer that business application software uses to interact with the rest of the stack. There are a number of protocols leveraged by entities on the application layer, and we'll discuss them later in this chapter. For now though, it's only important to remember that the application layer serves as the access point between actual end user applications and the OSI network stack.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The presentation layer</h1>
                </header>
            
            <article>
                
<p>While it may sound like a way of visually<em> </em>representing the data, the presentation layer is actually a way of defining how the data is to be interpreted by any consumer that wants to look at it. This layer provides context for application-layer entities from different hosts to mutually interact with a PDU. Entities in the presentation layer are responsible for describing how data passed from the application layer should be interpreted on the other side of a given data transaction. It does the work of abstracting away the encoding or serialization of PDUs from the higher-level business logic of application layer entities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The session layer</h1>
                </header>
            
            <article>
                
<p>Entities on the session layer are responsible for establishing, maintaining, resuming, and terminating an active communication session between two hosts on a network. The entities at work on this layer provide communication mechanisms such as full-duplex interactions, half-duplex interactions, and simplex interactions, as specified by the constraints of the protocol used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Full-duplex, half-duplex, and simplex communication</h1>
                </header>
            
            <article>
                
<p>When a session is established between two hosts, there are a handful of ways that communication can happen over that session. The two most common are the full and half-duplex implementations. These simply describe a communication session that both connected parties can communicate over.</p>
<p>In a full-duplex session, both parties can communicate with one another simultaneously. The typical example for this kind of communication is a telephone call. On a phone call, both parties can talk and hear the other talking at the same time. The extent that someone can listen to what is being said to them while also speaking allows for much more efficient data transfer, and can facilitate reliable communication systems.</p>
<p>A half-duplex system is one where both parties can<em> </em>communicate over the session, but only one party can communicate at a given time. A common example of this is a two-way radio or walkie-talkie. On these systems, engaging the microphone of one radio will lock the channel and prevent the other radio from transmitting until the first microphone has disengaged. This can allow more reliable communication over a limited bandwidth, since there is less opportunity for signal interference.</p>
<p>Finally, a simplex communication session is one where only a single party can actually transmit data. That is, there is a sender and a receiver. A common example of this is network television; there is a single broadcast source, with multiple receivers actually accepting the transmitted signal. This is uncommon in most modern communication networks, since the additional cost of implementing a duplex communication session is often trivially small in relation to a simplex connection. However, it should be noted that a duplex communication system is simply a system of two simplex connections with one connection going in each direction between the hosts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The transport layer</h1>
                </header>
            
            <article>
                
<p>Entities in the transport layer use protocols specifically designed for interacting with other hosts and the network entities in between. It might seem redundant given our description of the presentation and session layer; however, there's an important role to be played here. The presentation layer is concerned with character encoding, or the mapping from platform-specific data representations to platform-agnostic descriptions of that representation. The transport layer, though, looks at the full block of encoded data that was passed down by the presentation layer, and determines how to break it apart. It's responsible for cutting the data into segments of otherwise useless streams of binary. And, importantly, it breaks those segments up in such a way that they can be reassembled on the other side of the connection. The transport layer is also responsible for error detection and recovery, with different protocols providing different levels of reliability.</p>
<p>This layer is the lowest layer in the Host layers umbrella previously described. Determining what transport mechanism can and will be supported by a host remains the responsibility of that host. However, it is the lowest boundary of a given host's responsibility in successfully implementing network interaction. Everything below this layer falls into the Media layer, and is the responsibility of the engineers who support the network that the host has been deployed on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The network layer</h1>
                </header>
            
            <article>
                
<p class="mce-root">Entities on the network layer manage interactions over the network topology. They're responsible for address resolution and routing data to target hosts once an address has been resolved. They also handle message delivery based on constraints or the resource availability of the physical network. So, while the transport layer determines the interactions between host-level tiers of the network stack on either side of a connection, the network layer is responsible for applying the transport protocol across the chain of devices that form the route between two hosts. The distinction between adjacent layers can be subtle, and we'll discuss some of the responsibilities specific to the network layer later in this chapter. So, if the distinction between transport and network layers is unclear, trust that we'll (at least, attempt to) clarify that distinction later.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The data-link layer</h1>
                </header>
            
            <article>
                
<p>The data-link layer falls very clearly into the Media layer's grouping, as entities in this layer provide the actual transfer of data between nodes in a network. It's responsible for error detection from the physical layer, and controls the flow of bits over physical media between nodes. So, for example, in a half-duplex communication setup, an entity in the data-link layer is responsible for restricting the transfer of data in one direction while data is being transferred in the other direction. Entities in this layer almost serve as the traffic lights directing traffic over the roads of a node-to-node connection. The data-link layer is broken down even further into two sub-layers by the <strong>Institution of Electrical and Electronics Engineers</strong> (<strong>IEEE</strong>) standard 802. These two sub-layers are as follows:</p>
<ul>
<li>The <strong>Medium Access-Control</strong> (<strong>MAC</strong>) layer: This sub-layer controls who can transmit data through<em> </em>the data-layer entity, and how that data can be transmitted.</li>
<li>The <strong>Logical Link Control</strong> (<strong>LLC</strong>) layer: This sub-layer encapsulates the logical protocols of network interaction. It is essentially the interface that provides the entities links as a set of abstract protocol operations.</li>
</ul>
<p>Driving home how narrowly specific the data-link layer is in terms of its responsibilities on a network, its most common protocol is the <strong>Point-to-Point Protocol</strong> (<strong>PPP</strong>). This just highlights that entities of the data-link layer really are only concerned with facilitating the connection between two points.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The physical layer</h1>
                </header>
            
            <article>
                
<p>Finally, <span>we've arrived at the bottom of the stack, </span><span>with the simplest layer to understand. The physical layer encapsulates the entities that are responsible for transmitting raw, unstructured data from one node in the network to another. This is the layer responsible for sending electrical signals that correspond to the strings of bits in a data packet. It encapsulates the devices responsible for modulating voltage, timing signals, and timing the frequency of wireless transmitters and receivers. Entities on this layer are explicitly outside of the scope of this book, but are an interesting concern regardless.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Putting it all together</h1>
                </header>
            
            <article>
                
<p>Now, we've seen how the OSI model organizes the responsibilities of transmitting data. Hopefully, by this point, it should be clear how each layer in the stack is intended to provide a reliable abstraction for the layer above it. However, the process of communicating with a remote host, in its entirety, may still seem a bit vague. So, let's consider a concrete example and address each of the concepts that we talked about as they arise through the process of data transmission.</p>
<p>First, let's assume that an entity on layer 5 of our host (the session layer) wants to establish a session with an entity on <strong>Layer 5</strong> in a remote host. I haven't said so explicitly until now, but we can always assume that an entity on a given layer on one host only ever communicates directly with a corresponding entity on the same<em> </em>layer in the remote host. So, for our example, an entity in layer 5 will communicate with a remote entity that also resides in layer 5.</p>
<p>Communicating with remote entities will always happen through a protocol<em>. </em>Given this, the first responsibility of any entity seeking to communicate with a remote host is to wrap the transmitted data in the headers and footers appropriate for that protocol. For our entity in the session layer, let's assume they are hoping to establish a session using the <strong>Session Control Protocol</strong> (<strong>SCP</strong>). This means that our local entity will produce the data necessary to establish a session, then wrap that data in SCP headers and footers, creating a well-formed PDU (hopefully, this makes it clear why the name describes this package). This ensures that the recipient host will be able to unwrap the data based on the information stored in the headers and footers of our PDU.</p>
<p>Since entities that reside on any layer above<em> </em>the physical layer cannot communicate directly with one another, we have to pass our PDU down the stack. In our example, we can reliably pass the PDU down to <strong>Layer 4</strong> by taking advantage of its service definition and trusting that the logical operations exposed through that definition are accurately implemented by all of the responsible entities below <strong>Layer 5</strong>. So, we don't need to know how <strong>Layer 4</strong> implements transport mechanisms. Instead, we simply ask<em> </em>it to use the appropriate transport mechanism for this particular instance and trust that it will do so appropriately.</p>
<p>This pattern of trusting that lower layers in the stack will correctly implement the operations being requested by higher layers in the stack continues all the way through to <strong>Layer 1</strong>. Over the course of this process, each layer in the stack will wrap the PDU in its own headers and footers. These standardized chunks of data give each intermediary layer on the receiving host enough information to know to pass the PDU up its own stack. By continuously wrapping the data in well-formed, well-understood chunks of binary data, each layer on the remote host can trust that the inner segment of data that is passed up the stack is exactly what should move up.</p>
<p>This process of wrapping the PDU in deeper and deeper layers of metadata continues down the stack until we reach <strong>Layer 1</strong>. <strong>Layer 1</strong> holds the physical connection from our host to the remote host. Once we've reached this level, we can step across the expanse of the network and start looking at how our PDU moves back up<em> </em>the network stack until it reaches our target entity on <strong>Layer 5</strong>. Entities on each layer of the remote host will diligently remove and read the headers and footers applied by the corresponding layer of the originating host. The information in those wrappers will indicate that the PDU is destined for a layer above<em> </em>the current layer, and so entities will simply strip their headers and bubble the rest of the data up<em> </em>the network stack.</p>
<p>Once the data has reached layer 5 on the remote host, an entity on that layer will read the headers and footers of the PDU that were applied on <strong>Layer 5</strong> of the originating host. This metadata will indicate that layer 5 is, in fact, the target layer for this particular PDU. The metadata will also indicate what protocol<em> </em>should be used to parse the data passed to the remote host. Using this information, the recipient host will have enough data to properly read the data in the PDU, and construct its own response PDU.</p>
<p>Once that response is received by the originating host, a session will be established, and be open for use by any entities above the session layer in the originating or remote host. This whole process is captured in t<span>he following diagram of the full life cycle of data</span> <span>transmission through the OSI stack</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0b4db4a2-00f7-451e-bdc4-58d7b8966e8e.png" style="width:37.67em;height:25.17em;"/></p>
<p>With this diagram in mind, is easy to see how the standardization provided by the OSI model makes it easier for engineers to program software for networks. The clean separation of concerns and the explicit pattern for passing data through the stack allows for well-formed contracts, against which all interested parties can design and develop. Engineers programming entities on the application layer can ignore the details of transporting data. They simply pass down a well-formed PDU through the stack.</p>
<p>Hopefully, this description clarifies how entities on specific layers expose their abstractions through a service definition, and how entities operating on the same layer of the network stack on different hosts reliably communicate through protocols. With this perspective in mind, let's take a closer look at the layers of this stack that we'll be programming for most frequently, as well as looking at some of the classes that C# provides to represent the entities of these layers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The application layer</h1>
                </header>
            
            <article>
                
<p>I mentioned it before, but it bears repeating,  application layer is where the vast<em> </em>majority of day-to-day network programming will take place. This is especially true within the .NET Core framework, since the libraries provided by that framework deliver a wide array of clean, easy-to-use abstractions for entities or responsibilities that must be programmed lower in the stack. So, first, let's see why we should be so concerned with the responsibilities of the application layer. We'll look at the kinds of responsibilities that are typically delegated to entities in the layer, and see how frequently those responsibilities overlap with the requirements faced by everyday .NET Core developers. Then, given the extensive range of use cases for entities in the application layer, we'll take a look at some of the common protocols used by entities at that tier of the stack. We'll seek to understand them on a fundamental level. We'll look at what classes and libraries we have available to us for each of those layers; however, after this chapter, my hope is that you'll have a deep enough understanding to be able to reconstruct those classes yourself.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The most common layer in the stack</h1>
                </header>
            
            <article>
                
<p>This might feel redundant at this point, but it really is worth driving home that the application layer is where the vast majority of .NET developers are going to be doing their network programming. Since that accounts for most of you, we're going to keep talking about it. But <em>why </em>is the application layer so important?</p>
<p>The crux of it is that the application layer serves as the gateway to network activities for your business logic. This becomes very apparent as you explore how thoroughly .NET has hidden the implementation details of any of the responsibilities of lower levels of the network stack. Essentially, if there is something that you need to specify about how your application should behave anywhere below the stack, you'll be doing so through<em> </em>a .NET library class.</p>
<p>I really can't stress enough how important it is to understand how the protocols behave under the hood. Knowing how the libraries are implemented will leave you better equipped to actually use them in the future. It's like learning to drive a stick shift. If you only ever learn the steps you have to perform to change gears, you'll likely get rusty without consistent practice. Over time, you'll have forgotten enough to not be able to drive a manual transmission anymore. However, if you learn <em>how </em>the steps you take serve to allow your car to drive, you'll never forget the steps themselves. Even if it's been years since you last drove a stick shift, you'll be able to reconstruct the steps you need to execute based on your understanding of what those steps actually accomplish. By this same measure, understanding exactly what<em> </em>the .NET core libraries are doing for you will enable you to use them more efficiently and correctly. You'll find yourself looking up the documentation less frequently and be better able to find the methods or properties you need through IntelliSense. That said, let's look closely at some of the most common protocols in the most common network layer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP – application to application communication</h1>
                </header>
            
            <article>
                
<p>Welcome to the bread and butter of almost every .NET Core developer working today. HTTP is by far the most common and useful protocol for applications to interact over networks currently in use today. Why is that? Because HTTP is the protocol that almost every single web page on the internet is served up on by remote hosts, and requested by local clients. That alone is reason enough to call it the most common protocol in use. If you want more evidence, though, consider that most native mobile applications that serve up web-hosted data request this data from APIs that are exposed via HTTP. It almost feels ridiculous to have to make a case for the importance of understanding HTTP, since I'm certain there won't be a single person reading this book who <em>doesn't </em>have at least some experience with, or understanding of, HTTP.</p>
<p class="mce-root">So, why bother covering it so thoroughly if most of my readers are assumed to have some basic understanding of it? The answer to that is twofold. First, it's because it is so common as a communication protocol! HTTP is so prevalent that it would be criminally negligent not to give it due consideration in a book purporting to teach network programming fundamentals. And the second reason is because, at least in my own personal experience, most developers, and even engineers who work with it daily, only have a passing or surface-level understanding of what the specification provides. My hope is that by the end of this book, anyone who has read it, cover to cover, can and will go forth and program software that leverages every aspect of their target networks confidently and competently. It wouldn't be possible to do that without a deep, thorough understanding of what HTTP is, why it was defined, and how it is used by thousands of applications every second of every day. With that in mind, let's take a look at the protocol.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is HTTP?</h1>
                </header>
            
            <article>
                
<p>As almost every reader of this book is likely to be shouting at its pages already, let's go on to HTTP<strong>.</strong> As should already be obvious, HTTP is a protocol implemented and leveraged by software that lives in the application layer of the OSI network stack. It's the primary mechanism of communication for applications exposed through the internet, and is designed for the transfer of<strong> </strong>hypermedia<strong> </strong>over a network. Hypermedia typically refers to hypertext documents<strong> </strong>that contain multimedia information, as well as hyperlinks<strong> </strong>that can be used to navigate to and load additional resources from other remote hosts.</p>
<p>The transfer<em> </em>component of HTTP is, fundamentally, a request/response protocol that assumes a client-server relationship between hosts in an active HTTP session. To understand how this is done, let's start with the notion of a client-server relationship.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The client - server model in HTTP</h1>
                </header>
            
            <article>
                
<p>Throughout this chapter, we've been referring to communication over a network as simply happening between originating and target hosts, as if the two were functionally identical, depending on which was sending a packet. In the client-server model, however, the two hosts actually perform distinct and specific duties, and so they are not conceptually interchangeable. A client<em> </em>entity is one who requests, and is granted, use of the services or resources provided (or served) by the server<em> </em>entity. Servers do not make active requests of clients, except when necessary to complete a service request already made by the client (for example, requesting additional login information from the client, when the client has initiated the transaction by requesting protected data). Likewise, clients are not expected to serve any specific resources to the server, except the information necessary for the server to sufficiently process and respond to a request.</p>
<p>Today, it's not uncommon for two applications to use HTTP to interact with one another in such a way that, depending on the interaction, either application could be considered the client or the server. For example, a desktop finance application might be responsible for storing local user data, while also using a remote API to access live data feeds about current interest rates on different kinds of loans. Now suppose the authors of that desktop application want to periodically access information about users of their software. In the case of a user logging onto their application to look up market rates for mortgages, the desktop application will request information from the remote API; so the desktop application is the client, while the API is the server. However, when the remote software decides to query instances of its desktop application for user data, the roles are reversed. The remote software will request the data from known hosts of the desktop application; the remote software is the client, requesting information from computers running the desktop applications, which are the servers in this scenario.</p>
<p>Alternatively, an application or host might be the client<em> </em>of one remote host, while simultaneously operating as the server<em> </em>for a different remote host. Consider the case of an API that responds to requests by aggregating information from a number of other APIs. In the act of servicing requests by their downstream consumers, the application in question is very obviously a server. However, when the application requests information from other APIs upstream, it is acting as the client.</p>
<p>I bring these examples up to highlight the fact that the client-server relationship is mostly conceptual. The assignment of client or server roles to a given host is specific to a given interaction context. If that context changes, so too might the conceptual role of the hosts involved. It's important that we avoid confusion by only referring to clients and servers within the context of a specific interaction. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Request/response</h1>
                </header>
            
            <article>
                
<p>In describing the nature of the client-server relationship, we've also touched on the nature of the HTTP request/response protocol. This protocol, as a way of serving up information, is fairly intuitive to understand. When a client makes a request of a server (the request part of request/response), the server, assuming it meets the specifications of the protocol, is expected to respond with meaningful information about the success or failure of that request, as well as by providing the specific data initially requested.</p>
<p>Sometimes, the complete process of requesting information and receiving a meaningful response requires several intermediary round-trips between the client and server to establish initial connections, determine the ability of the server to service the request, and then submit the information necessary to initiate the request. This entire process, however, will be considered a single request/response session from the perspective of application-layer software. This leads us nicely onto the subject of just how those sessions are initially established in the first place.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP sessions</h1>
                </header>
            
            <article>
                
<p>So far, we've talked about the back and forth of the request/response communication patterns of HTTP, but we've neglected the context that allows that chatter to happen so seamlessly. This fluid interaction is facilitated by an underlying session established prior to satisfying the first request made by a client. Historically, this session has been provided by a <strong>Transmission Control Protocol</strong> (<strong>TCP</strong>) connection established against a specific port on the host server. This port can be specified in the URI when designating your target host, but typically will use default ports for HTTP, such as <kbd>80</kbd>, <kbd>8080</kbd>, or <kbd>443</kbd> (for HTTPS, which we'll cover later in this book). Once the connection is established, round trips of HTTP communication can proceed freely until the session is terminated.</p>
<p>You might have noticed that I specifically said that TCP is historically<em> </em>used for HTTP. This is because, for each of the current versions of HTTP (1.0, 1.1, and now HTTP/2), TCP has been the standard transport layer protocol supporting it. However, in the current proposed specification for HTTP/3, the protocol is being modified to take advantage of alternative transport protocols, including the <strong>User Datagram Protocol</strong> (<strong>UDP</strong>), or Google's experimental <strong>Quick UDP Internet Connections</strong> (<strong>QUIC</strong>) protocol. While there are trade-offs associated with these alternate transport protocols, the underlying sessions they provide are the same from our point of view. Each of these protocols serve to establish a connection with a listening host and facilitate the transmission of request and response messages. Next, let's take a look at some of the operations a client might request of a server, and how those operations are specified through the HTTP standard by way of request verbs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Request methods</h1>
                </header>
            
            <article>
                
<p>When a client wants to make a request of a server, it must specify the method by which the server will be expected to respond to the given request. These method specifications are typically called <strong>HTTP verbs</strong>, since most of them describe an action<em> </em>to be taken by the server when processing a request sent by the client. The standard methods are as follows:</p>
<ul>
<li><strong>OPTIONS</strong>: This returns the list of other HTTP methods supported by the server at the given URL.</li>
<li><strong>TRACE</strong>: This is a utility method that will simply echo the original request as received by the server. It is useful for identifying any modifications made to the request by entities on the network while the request is in transit.</li>
<li><strong>CONNECT</strong>: CONNECT requests establish a transparent TCP/IP tunnel between the originating host and the remote host.</li>
<li><strong>GET</strong>: This retrieves a copy of the resource specified by the URL to which the HTTP request was sent. By convention, GET requests will only ever retrieve the resource, with no side-effects on the state of the resources on the server (however, these conventions can be broken by poor programming practices, as we'll see later in the book).</li>
<li><strong>HEAD</strong>: This method requests the same response as a GET request to a given URL, but without the body of the response. What is returned is only the response headers.</li>
<li><strong>POST</strong>: The POST method transmits data in the body of the request, and requests that the server store the content of the request body as a new resource hosted by the server.</li>
</ul>
<ul>
<li><strong>PUT</strong>: The PUT method is similar to the POST method in that the client is requesting that the server store the content of the request body. However, in the case of a PUT operation, if there is already content at the requested URL, this content is then modified and updated with the contents of the request body.</li>
<li><strong>PATCH</strong>: The PATCH method will perform partial<em> </em>updates of the resource at the requested URL, modifying it with the contents of the request body. A PATCH request will typically fail if there is no resource already on the server to be patched.</li>
<li><strong>DELETE</strong>: The DELETE method will permanently delete the resource at the specified URL.</li>
</ul>
<p>A server will not respond to a request method invoked against a given location unless the server has been configured to do so. This is because some of the methods defined by the HTTP standard can permanently impact the state of resources on that server, and so should only be invoked and processed when it is safe to irrevocably update that state. There are, however, a number of methods designated as safe, by convention. This simply means that they can be processed by a server without having any side-effects on the state of the resources on that server. HEAD, GET, OPTIONS, and TRACE are all conventionally designated as safe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Status codes</h1>
                </header>
            
            <article>
                
<p>Even when an application has constructed a valid HTTP request object, and submits that request to a valid path on an active host, it's not uncommon for the server to fail to properly respond. For this reason, HTTP designates, as part of a response object, a status code to communicate the ability of the server to properly service the request. HTTP status codes are, by convention, 3-digit numeric codes returned as part of every response. The first digit indicates the general nature of the response, and the second and third digits will tell you the exact issue encountered. In this way, we can say that status codes are categorized by their first digits.</p>
<div class="packt_tip">When you're writing software that responds to HTTP requests, it's important to send accurate status codes in response to different errors. HTTP is a standard that must be adhered to by developers in order to remain useful.</div>
<p>There are only five valid values for the first digit of an HTTP status code, and thus, five categories of responses; they are as follows:</p>
<ul>
<li><strong>1XX:</strong> Informational status code. This indicates that the request was in fact received, and the processing of that request is continuing.</li>
<li><strong>2XX:</strong> Success status code. This indicates that the request was successfully received and responded to.</li>
<li><strong>3XX:</strong> Redirection. This indicates that the requesting host must send their request to a new location for it to be successfully processed.</li>
<li><strong>4XX:</strong> Client Error. An error that is produced by the actions of the client, such as sending a malformed request or attempting to access resources from the wrong location.</li>
<li><strong>5XX:</strong> Server Error. There was a fault on the server preventing it from being able to fulfill a request. The client submitted the request correctly, but the server failed to satisfy it.</li>
</ul>
<p>Status codes are returned by servers for every HTTP request made against the server, and so can be very useful for building resiliency into your client software.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The HTTP message format</h1>
                </header>
            
            <article>
                
<p>Requests and responses in HTTP are always sent as plain text messages. Those plain text messages consist of a well-ordered, and well-structured, series of message segments that can be reliably parsed by the recipient. In requests, messages consist of three required message components and one optional component:</p>
<ul>
<li>The request line consists of the method, the path to the requested resource, and the specific protocol version that should be used to determine the validity of the rest of the message; for example, <kbd>GET /users/id/12 HTTP/1.1</kbd>.</li>
</ul>
<ul>
<li>A series of request headers and their values, for example, <kbd>Accept: application/json</kbd>.</li>
<li>An empty line.</li>
<li>(Optional) A request message body. This consists of content headers that provide metadata about the content type, as well as the content itself.</li>
</ul>
<p>Each segment is delineated by a <kbd>&lt;CR&gt;</kbd> <span>carriage return character </span>and an <kbd>&lt;LF&gt;</kbd> <span>line feed </span>character; these are special white-space characters whose specific <span><strong>American Standard Code for Information Interchange</strong> (</span><strong>ASCII</strong>) values allow them to reliably be used to indicate the breaks between segments in a message stream.</p>
<p>Meanwhile, an HTTP response consists of its own series of almost identically structured segments, each also delimited by the <kbd>&lt;CR&gt;&lt;LF&gt;</kbd> characters. Just as with the request message, it contains three required segments and one optional message body segment, as follows:</p>
<ul>
<li>A status line consisting of the specific protocol, the HTTP status code, and the reason phrase associated with that status code:
<ul>
<li><kbd>HTTP/1.1 401 Bad Request</kbd>: A response containing the 401 client error status code (indicating that the client sent an improper request message for the resource that it was looking for).</li>
<li><kbd>HTTP/2.0 201 Created</kbd>: A response indicating the 201 success status code, meaning that the desired resource has been created on the server.</li>
</ul>
</li>
<li>Headers, as with the request message segment, providing metadata about how the response should be parsed.</li>
<li>An empty line.</li>
<li>An optional message body.</li>
</ul>
<p>Those simple segments fully define every valid HTTP message sent across the internet. This accounts for millions of requests per second, between millions or billions of devices. It's the simplicity of the message specification that makes that kind of scale possible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP in C#</h1>
                </header>
            
            <article>
                
<p class="mce-root">Remembering the proper character delimiters and order for segments in an HTTP message, anyone should be able to build a request from scratch. Thankfully though, you don't have to remember those details; .NET Core has you covered with the <kbd>System.Net.Http</kbd> namespace. We'll explore this namespace in much greater detail later in the book, but for now, just trust that any feature or detail you find yourself needing to leverage HTTP communication in your application is exposed through that namespace. This namespace exposes enum types for status codes and header values, and an <kbd>HttpMethod</kbd> class to specify your message verb. As a library, it's rich with out-of-the-box features while remaining flexible and extensible enough to be leveraged in any use case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">FTP and SMTP – the rest of the application layer</h1>
                </header>
            
            <article>
                
<p>While we have developed a deep understanding of HTTP due to its prominence in the daily lives of network programmers, we must also take the time to mention and briefly look at some of the other common application-layer protocols in use today. In this section, we'll look at the <strong>File Transfer Protocol</strong> (<strong>FTP</strong>) and <strong>SSH File Transfer Protocol</strong> (<strong>SFTP</strong>), which allow for remote file copy operations and filesystem navigation; and the <strong>Simple Mail Transfer Protocol</strong> (<strong>SMTP</strong>), which is used for email transmission over networks.</p>
<p>Interestingly, with each of these protocols operating on the application layer, it's not uncommon to see one protocol provide the functionality that has historically fallen under the domain of another protocol. For example, the data-agnostic nature of HTTP's plain-text message structure makes it trivially simple to use HTTP to transfer complete file data over an HTTP session. It's as simple as writing software on the server to transmit files through the message body of the response. For this reason, FTP, and to a lesser degree, SMTP, have fallen out of favor with network programmers in recent years, in favor of implementing their responsibilities in HTTP-aware software hosts. The protocols remain, however, and it will benefit us to consider what their flaws and advantages are.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">FTP and SFTP</h1>
                </header>
            
            <article>
                
<p>FTP (and SFTP) leverages a client-server model similar to the one used by HTTP, but its connection specification is slightly more complicated than we saw before. Where HTTP sent messages over a single connection by way of a <span>series of </span><span>stateless request/response transactions, FTP maintains </span>two<em> </em><span>connections between the client and server over the course of a stateful session. One connection establishes a stateful control pipeline that tracks the current state of the directory exposed by the FTP server and submits the commands necessary to execute the desired file transfers. The other connection is stateless, and facilitates the transfer of the raw file data between hosts. Establishing both of these connections for a single FTP session introduces the benefit of reliability at the cost of latency and complexity. Moreover, the limited nature of tasks that can be reliably executed through FTP as a communication protocol has only served to limit its popular use as time goes on. Thankfully though, as was the case with HTTP, much of the details of implementing an FTP server or client is taken care of by way of the <kbd>System.Net</kbd> namespace in .NET core, and we'll explore those tools later on in this book.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SMTP</h1>
                </header>
            
            <article>
                
<p>Similar to FTP, the feature set supported by the SMTP is quite limited and narrowly tailored to performing a <span>few </span>specific tasks. However, the need to implement email servers is actually fairly common, and understanding the complexity of sending or receiving messages through SMTP remains a relevant and useful skill; certainly more so than with FTP these days. SMTP is a connection-oriented protocol for sending<em> </em>mail messages to remote servers that are configured to receive them. It leverages a client-server model leveraging reliable sessions, over which a series of commands and data-transfer processes transmit email, unilaterally, from the client to the server. The back-and-forth of an SMTP session is actually quite a bit more complicated than we saw with HTTP and FTP, and that complexity is beyond the scope of this chapter. For now though, it's sufficient to say that any network programmer worth their salt will have a sound understanding of HTTP, FTP, and SMTP.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Transport layer</h1>
                </header>
            
            <article>
                
<p>While the application layer is the layer of the OSI model that the vast majority of .NET developers work with in their daily lives, it would be useless without sound, reliable protocol implementations on the transport layer. It's on this layer that the connections are made and the data is streamed. It's the lowest layer in the stack that an individual host is directly responsible for, and in the transport layer, TCP and UDP reign supreme. Each provide their own mechanisms for delivering streams of data to their destination, and each present their own trade-offs, to be considered when choosing a transport protocol for your network services. As with all of these protocols, we'll take a closer look at them later in this book, but for now let's learn what they are and why they came to be.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TCP</h1>
                </header>
            
            <article>
                
<p>Developed in 1974 by engineers in the IEEE, the TCP is defined as a connection-based communication protocol that provides the reliable delivery of ordered packets. It's used to facilitate communication between hosts of all kinds from the internet, to SMTP clients and servers, <strong>Secure Shell</strong> (<strong>SSH</strong>) connections, FTP clients and servers, and HTTP. It is ubiquitous as the transport layer protocol of choice for almost all modern applications.</p>
<p>The broad adoption of TCP as the transport layer supporting most application-layer requests is primarily due to the reliability of a TCP connection. By convention, entities that implement TCP are written to detect packet loss and the out-of-order delivery of data streams, to re-request lost data, and to reorder the out-of-order streams. This error correction is resolved prior<em> </em>to returning that data back up the stack to the application layer entities making use of the TCP connection.</p>
<p>Of course, the obvious cost incurred by this error handling is latency and performance. Multiple round-trips to fetch, essentially, the same data two or three times can add substantial downtime to the client application. The reliability of TCP is ensured by leveraging a round-trip chain of request, acknowledgements of the receipt of a request, then another request, and so on. All the chatter incurred by this consistent back-and-forth makes TCP far from ideal for real-time applications, such as for gaming, video streaming, or video conferencing. Instead, where reliability or guaranteed ordering can be sacrificed in favor of performance, UDP or a similar protocol should be used as the transmission layer of choice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">UDP</h1>
                </header>
            
            <article>
                
<p>If the reliability of TCP is not strictly required for an application, then UDP begins to look like a very attractive option for its simplicity and performance. UDP is a simple, unreliable, and connectionless communication protocol for transmitting data over a network. Where TCP provided robust error handling through its pattern of repeated requests and acknowledgments, UDP has no handshaking or acknowledgment signals to indicate whether a packet was properly transmitted from host to host.</p>
<p>While UDP does not provide robust error-handling in the case of lost or unordered packets, it does, at the very least, provide error-checking on the packet level. It does so by using a checksum value stored in the header of the packet. The difference being that when an error is detected in a packet, the packet is simply dropped by the UDP entity, and no request is sent out to try to retrieve the packet again in a valid state.</p>
<p>This packet-delivery-oriented model of sending out individual packets without regard for their successful delivery also means that UDP data requests can be sent without any prior establishment of a connection between hosts. This lack of an initial round-trip greatly reduces overhead in software systems that need to make frequent, real-time connections between many hosts. In fact, this lack of an initial handshake is one of the primary distinguishing factors between connection and connectionless communication protocols, and that is a distinction that warrants elaboration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connection versus connectionless communication</h1>
                </header>
            
            <article>
                
<p>The idea of connectionless communication might seem like an oxymoron at first. How could two entities possibly communicate if they haven't connected first? How would one even know that the other exists to communicate with?</p>
<p>The underlying principle is that in a connection-based communication protocol, both hosts must first establish a line of communication before the<em> </em>transmission of any application-specific data can begin. The handshake sequence in TCP is the most obvious example of this. There is a complete round-trip of sent/received messages that must succeed before the connection is considered established, and data can be transmitted between hosts. That established line of communication is the 'connection' in this context. It consumes time and bandwidth, but provides reliability and error correction, and in almost all cases, the value of the reliability and error correction is worth far more than the costs incurred.</p>
<p>Meanwhile, in connectionless communication, data could be transmitted, and the communication terminated, without even a single<em> </em>complete round-trip from the client to the server, and back to the client again. The packet has sufficient information in its own headers to be properly routed to a listening host. Provided that host has no follow-up to the initial request, that communication will stop with only a one-way packet delivery. The low-latency of this transmission pattern could be a major benefit in certain application contexts.</p>
<p>There's still so much more to explore with both of these protocols, going forward, but that is the concern of a later chapter in this book. For now though, I hope this makes it clear why the transport layer and its protocols serve such a major role in designing and implementing high-performance and highly-reliable network software.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned everything there is to know about the OSI network model. First, we learned about the governing bodies that defined the standard reference model, including when and why they set out to solve the problem of unified network modeling. Then, we took a close look at the model they defined, including looking at every layer in their stack, and what responsibilities entities in those layers assume. We learned about how protocols<em> </em>define standardized communication patterns for entities operating on the same level in the network stack, but on separate hosts on a network. We saw how service definitions<em> </em>allow entities to pass data through the network stack and deliver messages to remote entities. </p>
<p>We also took a close look at some of the most common communication protocols, which we'll be interacting with in the rest of this book. We started with the king of all network protocols, HTTP. We looked at how HTTP sessions are established to allow communication between clients and servers. We saw how HTTP operates through a series of requests and responses using well-defined verbs<em> </em>to specify the operations to be performed in servicing those requests. We looked at TCP and UDP, and how the transport layer serves as the bus through which all application-layer network interactions must travel. Finally, we looked at how the network layer facilitates this communication through the IP addressing system, and discrete packet transmission.</p>
<p>With this foundation in place, we're well positioned to take a close look at how data is broken down into discrete packets and transmitted over the network through data streams in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What does OSI stand for, and what is the name of the organization that standardized it?</li>
<li>What is the abstraction layer via which layers of the OSI network stack communicate with layers beneath them?</li>
<li>How many layers are in the OSI network stack, and what are they?</li>
<li>What is the name of the standardization mechanism by which entities on the same layer of the network stack on different hosts communicate?</li>
<li>What does HTTP stand for? For which network layer is HTTP used as a communication protocol?</li>
<li>Name all of the HTTP verbs that a request can be sent from.</li>
<li>What are some of the primary differences between the TCP and UDP transport protocols?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>For more information about the OSI Reference Model, see <em>Building Modern Networks</em>, by <em>Steven Noble, Packt Publishing</em>.</p>
<p><span>Additionally, you can refer to</span> <span class="a-size-extra-large"><em>Computer Networking: Beginner's Guide for Mastering Computer Networking</em> <em>and the OSI Model</em> by <em>Ramon Nastase's,</em> and</span><span class="a-size-extra-large"> </span><span><em>The OSI Model for Network Engineers: Improve Your Network Troubleshooting,</em> by <em>Al Rivas</em>. </span>Both are available in e-book form on <a href="http://amazon.com">amazon.com</a>, and will provide a much more thorough examination of the OSI stack than I had time or space to cover in the context of this chapter.</p>


            </article>

            
        </section>
    </body></html>