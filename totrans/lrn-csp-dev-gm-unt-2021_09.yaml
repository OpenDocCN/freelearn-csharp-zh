- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic AI and Enemy Behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Virtual scenarios need conflicts, consequences, and potential rewards to feel
    real. Without these three things, there's no incentive for the player to care
    about what happens to their in-game character, much less continue to play the
    game. And while there are plenty of game mechanics that deliver on one or more
    of these conditions, nothing beats an enemy that will seek you out and try to
    end your session.
  prefs: []
  type: TYPE_NORMAL
- en: Programming an intelligent enemy is no easy task, and often goes hand in hand
    with long working hours and frustration. However, Unity has built-in features,
    components, and classes we can use to design and implement AI systems in a more
    user-friendly way. These tools will push the first playable iteration of *Hero
    Born* over the finish line and provide a springboard for more advanced C# topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll focus on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Unity navigation system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static objects and navigation meshes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigation agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Procedural programming and logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking and dealing damage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a loss condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring and keeping it DRY
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Navigating 3D space in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about navigation in real life, it's usually a conversation about
    how to get from point A to point B. Navigating around virtual 3D space is largely
    the same, but how do we account for the experiential knowledge we humans have
    accumulated since the day we first started crawling? Everything from walking on
    a flat surface to climbing stairs and jumping off of curbs is a skill we learned
    by doing; how can we possibly program all that into a game without going insane?
  prefs: []
  type: TYPE_NORMAL
- en: Before you can answer any of these questions, you'll need to know what navigation
    components Unity has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The short answer is that Unity has spent a lot of time perfecting its navigation
    system and delivering components that we can use to govern how playable and non-playable
    characters can get around. Each of the following components comes as standard
    with Unity and has complex features already built in:'
  prefs: []
  type: TYPE_NORMAL
- en: A **NavMesh** is essentially a map of the walkable surfaces in a given level;
    the NavMesh component itself is created from the level geometry in a process called
    baking. Baking a NavMesh into your level creates a unique project asset that holds
    the navigation data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a **NavMesh** is the level map, then a **NavMeshAgent** is the moving piece
    on the board. Any object with a NavMeshAgent component attached will automatically
    avoid other agents or obstacles it comes into contact with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The navigation system needs to be aware of any moving or stationary objects
    in the level that could cause a NavMeshAgent to alter their route. Adding NavMeshObstacle
    components to those objects lets the system know that they need to be avoided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this description of the Unity navigation system is far from complete,
    it's enough for us to move forward with our enemy behavior. For this chapter,
    we'll be focusing on adding a NavMesh to our level, setting up the Enemy Prefab
    as a NavMeshAgent, and getting the Enemy Prefab to move along a predefined route
    in a seemingly intelligent way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll only be using the NavMesh and NavMeshAgent components in this chapter,
    but if you want to spice up your level, take a look at how to create obstacles
    here: [https://docs.unity3d.com/Manual/nav-CreateNavMeshObstacle.html](https://docs.unity3d.com/Manual/nav-CreateNavMeshObstacle.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your first task in setting up an "intelligent" enemy is to create a NavMesh
    over the arena''s walkable areas. Let''s set up and configure our level''s NavMesh:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Environment** GameObject, click on the arrow icon next to **Static**
    in the **Inspector** window, and choose **Navigation Static**:![](img/B17573_09_01.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.1: Setting objects to Navigation Static'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click **Yes, change children** when the dialog window pops up to set all the
    **Environment** child objects to **Navigation Static**:![](img/B17573_09_02.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.2: Changing all child objects'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Go to **Window** | **AI** | **Navigation** and select the **Bake** tab. Leave
    everything set to their default values and click **Bake**. Once baking is finished,
    you'll see a new folder inside the **Scenes** folder with lighting, navigation
    mesh, and reflection probe data:![](img/B17573_09_03.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.3: Baking navigation mesh'
  prefs: []
  type: TYPE_NORMAL
- en: Every object in our level is now marked as **Navigation Static**, which means
    that our newly baked NavMesh has evaluated their accessibility based on its default
    NavMeshAgent settings. Everywhere you can see a light blue overlay in the preceding
    screenshot is a walkable surface for any object with a NavMeshAgent component
    attached, which is your next task.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up enemy agents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s register the Enemy Prefab as a NavMeshAgent:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Enemy Prefab in the **Prefabs** folder, click **Add Component** in
    the **Inspector** window, and search for **NavMesh Agent**:![](img/B17573_09_04.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.4: Adding a NavMeshAgent component'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click **+** **|** **Create Empty** from the **Hierarchy** window and name the
    GameObject `Patrol_Route`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Patrol_Route`, click **+** **|** **Create Empty** to add a child GameObject,
    and name it `Location_1`. Position `Location_1` in one of the corners of the level:![](img/B17573_09_05.png)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 9.5: Creating an empty patrol route object'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create three more empty child objects in `Patrol_Route`, name them `Location_2`,
    `Location_3`, and `Location_4`, respectively, and position them in the remaining
    corners of the level to form a square:![](img/B17573_09_06.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.6: Creating all empty patrol route objects'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Adding a NavMeshAgent component to the Enemy tells the NavMesh component to
    take notice and register it as an object that has access to its autonomous navigation
    features. Creating the four empty game objects in each corner of the level lays
    out the simple route we want our enemies to eventually patrol; grouping them in
    an empty parent object makes it easier to reference them in code and makes for
    a more organized Hierarchy window. All that's left is the code to make the enemy
    walk the patrol route, which you'll add in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Moving enemy agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our patrol locations are set and the Enemy Prefab has a NavMeshAgent component,
    but now we need to figure out how to reference those locations and get the enemy
    moving on its own. To do that, we''ll first need to talk about an important concept
    in the world of software development: procedural programming.'
  prefs: []
  type: TYPE_NORMAL
- en: Procedural programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though it's in the name, the idea behind procedural programming can be
    elusive until you get your head around it; once you do, you'll never see a code
    challenge the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Any task that executes the same logic on one or more sequential objects is the
    perfect candidate for procedural programming. You already did a little procedural
    programming when you debugged arrays, lists, and dictionaries with `for` and `foreach`
    loops. Each time those looping statements were executed, you performed the same
    call to `Debug.Log()`, iterating over each item sequentially. The idea now is
    to use that skill to get a more useful outcome.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common uses of procedural programming is adding items from one
    collection to another, often modifying them along the way. This works great for
    our purposes since we want to reference each child object in the `Patrol_Route`
    parent and store them in a list.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing the patrol locations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we understand the basics of procedural programming, it''s time to
    get a reference to our patrol locations and assign them to a usable list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `EnemyBehavior`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select `Enemy` and drag the `Patrol_Route` object from the **Hierarchy** window
    onto the **Patrol Route** variable in `EnemyBehavior`:![](img/B17573_09_07.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.7: Dragging Patrol_Route to the enemy script'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Hit the arrow icon next to the **Locations** variable in the **Inspector** window
    and run the game to see the list populate:![](img/B17573_09_08.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.8: Testing procedural programming'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s break down the code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it declares a variable for storing the `PatrolRoute` empty parent GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it declares a `List` variable to hold all the child `Transform` components
    in `PatrolRoute`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, it uses `Start()` to call the `InitializePatrolRoute()` method when
    the game begins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, it creates `InitializePatrolRoute()` as a private utility method to procedurally
    fill `Locations` with `Transform` values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that not including an access modifier makes variables and methods `private`
    by default.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we use a `foreach` statement to loop through each child GameObject in
    `PatrolRoute` and reference its Transform component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each Transform component is captured in the local `child` variable declared
    in the `foreach` loop.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we add each sequential `child` `Transform` component to the list of
    locations using the `Add()` method as we loop through the child objects in `PatrolRoute`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This way, no matter what changes we make in the **Hierarchy** window, `Locations`
    will always be filled in with all the `child` objects under the `PatrolRoute`
    parent.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: While we could have assigned each location GameObject to `Locations` by dragging
    and dropping them directly from the **Hierarchy** window into the **Inspector**
    window, it's easy to lose or break these connections; making changes to the location
    object names, object additions or deletions, or project updates can all throw
    a wrench into a class's initialization. It's much safer, and more readable, to
    procedurally fill GameObject lists or arrays in the `Start()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Due to that reasoning, I also tend to use `GetComponent()` in the `Start()`
    method to find and store component references attached to a given class instead
    of assigning them in the **Inspector** window.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need the enemy object to follow the patrol route we laid out, which
    is your next task.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the enemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With a list of patrol locations initialized on `Start()`, we can grab the enemy
    NavMeshAgent component and set its first destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `EnemyBehavior` with the following code and hit play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it adds the `UnityEngine.AI` `using` directive so that `EnemyBehavior`
    has access to Unity's navigation classes, in this case, `NavMeshAgent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it declares a variable to keep track of which patrol location the enemy
    is currently walking toward. Since `List` items are zero-indexed, we can have
    the Enemy Prefab move between patrol points in the order they are stored in `Locations`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it declares a variable to store the NavMeshAgent component attached to
    the Enemy GameObject. This is `private` because no other classes should be able
    to access or modify it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, it uses `GetComponent()` to find and return the attached NavMeshAgent
    component to the agent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it calls the `MoveToNextPatrolLocation()` method on `Start()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, it declares `MoveToNextPatrolLocation()` as a private method and sets
    `_agent.destinat``ion`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`destination` is a `Vector3` position in 3D space.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Locations[_locationIndex]` grabs the Transform item in `Locations` at a given
    index.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding `.position` references the Transform component's `Vector3` position.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, when our scene starts, locations are filled with patrol points and `MoveToNextPatrolLocation()`
    is called to set the destination position of the NavMeshAgent component to the
    first item at `_locationIndex 0` in the list of locations. The next step is to
    have the enemy object move from the first patrol location to all the other locations
    in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Our enemy moves to the first patrol point just fine, but then it stops. What
    we want is for it to continually move between each sequential location, which
    will require additional logic in `Update()` and `MoveToNextPatrolLocation()`.
    Let's create this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `EnemyBehavior` and hit play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it declares the `Update()` method and adds an `if` statement to check
    whether two different conditions are true:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`remainingDistance` returns how far the NavMeshAgent component currently is
    from its set destination`,` so we''re checking if that is less than 0.2.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pathPending` returns a `true` or `false` Boolean, depending on whether Unity
    is computing a path for the NavMeshAgent component.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If _`agent` is very close to its destination, and no other path is being computed,
    the `if` statement returns `true` and calls `MoveToNextPatrolLocation()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, we added an `if` statement to make sure that `Locations` isn''t empty
    before the rest of the code in `MoveToNextPatrolLocation()` is executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `Locations` is empty, we use the `return` keyword to exit the method without
    continuing.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This is referred to as defensive programming, and, coupled with refactoring,
    it is an essential skill to have in your arsenal as you move toward more intermediate
    C# topics. We will consider refactoring at the end of the chapter.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we set `_locationIndex` to its current value, `+1`, followed by the modulo
    (`%`) of `Locations.Count`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will increment the index from 0 to 4 and then restart it at 0 so that our
    Enemy Prefab moves in a continuous path.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The modulo operator returns the remainder of two values being divided—2 divided
    by 4 has a remainder of 2 when the result is an integer, so 2 % 4 = 2\. Likewise,
    4 divided by 4 has no remainder, so 4 % 4 = 0.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dividing an index by the maximum number of items in a collection is a quick
    way to always find the next item. If you're rusty on the modulo operator, revisit
    *Chapter 2*, *The Building Blocks of Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: We now need to check that the enemy is moving toward its set patrol location
    every frame in `Update()`; when it gets close, `MoveToNextPatrolLocation()` is
    fired, which increments `_locationIndex` and sets the next patrol point as the
    destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you drag the **Scene** view down next to the **Console** window, as shown
    in the following screenshot, and hit play, you can watch the Enemy Prefab walk
    around the corners of the level in a continuous loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_09_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: Testing the enemy patrol route'
  prefs: []
  type: TYPE_NORMAL
- en: The enemy now follows the patrol route around the outside of the map, but it
    doesn't seek out the player and attack when it's within a preset range. You'll
    use the NavAgent component to do just that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Enemy game mechanics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our enemy is on a continuous patrol circuit, it's time to give it some
    interaction mechanics of its own; there wouldn't be much risk or reward if we
    left it walking around with no way to act against us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Seek and destroy: changing the agent''s destination'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll be focusing on switching the target of the enemies' NavMeshAgent
    component when the player gets too close and dealing damage if a collision occurs.
    When the enemy successfully lowers the player's health, it will return to its
    patrol route until its next run-in with the player.
  prefs: []
  type: TYPE_NORMAL
- en: However, we're not going to leave our player helpless; we'll also add in code
    to track enemy health, detect when an enemy is successfully hit with one of the
    player's bullets, and when an enemy needs to be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Enemy Prefab is moving around on patrol, we need to get a reference
    to the player's position and change the destination of NavMeshAgent if it gets
    too close.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `EnemyBehavior`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s break down the code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it declares a `public` variable to hold the `Player` capsule's `Transform`
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we use `GameObject.Find("Player")` to return a reference to the player
    object in the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding `.transform` directly references the object's `Transform` value in the
    same line.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we set `_agent.destination` to the player's `Vector3` position in `OnTriggerEnter()`
    whenever the player enters the enemies' attack zone that we set up earlier with
    a Collider component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you play the game now and get too close to the patrolling enemy, you'll see
    that it breaks from its path and comes straight for you. Once it reaches the player,
    the code in the `Update()` method takes over again and the Enemy Prefab resumes
    its patrol.
  prefs: []
  type: TYPE_NORMAL
- en: We still need the enemy to be able to hurt the player in some way, which we'll
    learn how to do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Lowering player health
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While our enemy mechanic has come a long way, it's still anti-climactic to have
    nothing happen when the Enemy Prefab collides with the player Prefab. To fix this,
    we'll tie in the new enemy mechanics with the game manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `PlayerBehavior` with the following code and hit play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it declares a `private` variable to hold the reference to the instance
    of `GameBehavior` we have in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, it finds and returns the `GameBehavior` script that''s attached to the
    `Game Manager` object in the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `GetComponent()` on the same line as `GameObject.Find()` is a common way
    to cut down on unnecessary lines of code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since our player is the object being collided with, it makes sense to declare
    `OnCollisionEnter()` in `PlayerBehavior`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we check for the name of the colliding object; if it's the Enemy Prefab,
    we execute the body of the `if` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we subtract `1` from the public `HP` variable using the `_gameManager`
    instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever the enemy now tracks and collides with the player, the game manager
    will fire the set property on HP. The UI will update with a new value for player
    health, which means we have an opportunity to put in some additional logic for
    the loss condition later on.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting bullet collisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have our loss condition, it's time to add in a way for our player
    to fight back and survive enemy attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `EnemyBehavior` and modify it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it declares a `private int` variable called `_lives` with a `public`
    backing variable called `EnemyLives`. This will let us control how `EnemyLives`
    is referenced and set, just like in `GameBehavior`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we set the `get` property to always return `_lives`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we use `private set` to assign the new value of `EnemyLives` to `_lives`
    to keep them both in sync.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We haven't seen `private get` or `set` before, but they can have their access
    modifiers, just like any other executable code. Declaring `get` or `set` as `private`
    means that only the parent class has access to their functionality.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we add an `if` statement to check whether `_lives` is less than or equal
    to 0, meaning that the enemy should be dead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When that's the case, we destroy the `Enemy` GameObject and print out a message
    to the console.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Because `Enemy` is the object getting hit with bullets, it's sensible to include
    a check for those collisions in `EnemyBehavior` with `OnCollisionEnter()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, if the name of the colliding object matches a bullet clone object,
    we decrement `EnemyLives` by `1` and print out another message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the name we're checking for is `Bullet(Clone)`, even though our
    bullet Prefab is named `Bullet`. This is because Unity adds the `(Clone)` suffix
    to any object created with the `Instantiate()` method, which is how we made them
    in our shooting logic.
  prefs: []
  type: TYPE_NORMAL
- en: You can also check for the GameObjects' tag, but since that's a Unity-specific
    feature, we're going to leave the code as-is and do things with pure C#.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the player can fight back when the enemy tries to take one of its lives
    by shooting it three times and destroying it. Again, our use of the `get` and
    `set` properties to handle additional logic proves to be a flexible and scalable
    solution. With that done, your final task is to update the game manager with a
    loss condition.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the game manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To fully implement the loss condition, we need to update the manager class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `GameBehavior` and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **Hierarchy** window, right-click on **Win Condition**, choose **Duplicate**,
    and name it **Loss Condition**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the arrow to the left of **Loss Condition** to expand it, select the **Text**
    object, and change the text to **You lose...**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select **Game_Manager** in the **Hierarchy** window and drag **Loss Condition**
    into the **Loss Button** slot in the **Game Behavior (Script)** component:![](img/B17573_09_11.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.10: Game behavior script with text and button variables completed
    in the Inspector pane'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s break down the code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we declare a new button that we want to show when the player loses the
    game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we add in an `if` statement to check when `_playerHP` drops below `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it's `true`, `ProgessText` and `Time.timeScale` are updated and the loss
    button is activated.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the player is still alive following an enemy collision, `ProgessText` shows
    a different message: "Ouch… that''s got to hurt.".'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, change _`playerHP` to 1 in `GameBehavior.cs` and get the Enemy Prefab to
    collide with you and observe what happens.
  prefs: []
  type: TYPE_NORMAL
- en: That's a wrap! You've successfully added a "smart" enemy that can damage the
    player and be damaged right back, as well as a loss screen through the game manager.
    Before we finish this chapter, there's one more important topic that we need to
    discuss, and that's how to avoid repeating code.
  prefs: []
  type: TYPE_NORMAL
- en: Repeated code is the bane of all programmers, so it makes sense that you learn
    how to keep it out of your projects early on!
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring and keeping it DRY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Don''t Repeat Yourself** (**DRY**) acronym is the software developer''s
    conscience: it tells you when you''re in danger of making a bad or questionable
    decision, and gives you a feeling of satisfaction after a job well done.'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, repeated code is part of programming life. Trying to avoid it by
    constantly thinking ahead will put up so many roadblocks in your project that
    it won't seem worthwhile carrying on. A more efficient—and sane—approach to dealing
    with repeating code is to quickly identify it when and where it occurs and then
    look for the best way to remove it. This task is called refactoring, and our `GameBehavior`
    class could use a little of its magic right now.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we set the progress text and timescale in two separate
    places, but we could easily make ourselves a utility method to do this for us
    in a single place.
  prefs: []
  type: TYPE_NORMAL
- en: 'To refactor the existing code, you''ll need to update `GameBehavior.cs` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the code:'
  prefs: []
  type: TYPE_NORMAL
- en: We declared a new method called `UpdateScene`, which takes in a string parameter
    that we want to assign to `ProgressText` and sets `Time.timeScale` to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We deleted our first instance of duplicated code and used our new method to
    update our scene when the game is won.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We deleted our second instance of duplicated code and update the scene when
    the game is lost.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's always more to refactor if you look in the right places.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that, our enemy and player interactions are complete. We can dish out damage
    as well as take it, lose lives, and fight back, all while updating the on-screen
    GUI. Our enemies use Unity's navigation system to walk around the arena and change
    to attack mode when within a specified range of the player. Each GameObject is
    responsible for its behavior, internal logic, and object collisions, while the
    game manager keeps track of the variables that govern the game's state. Lastly,
    we learned about simple procedural programming and how much cleaner code can be
    when repeated instructions are abstracted out into their methods.
  prefs: []
  type: TYPE_NORMAL
- en: You should feel a sense of accomplishment at this point, especially if you started
    this book as a total beginner. Getting up to speed with a new programming language
    while building a working game is no easy trick. In the next chapter, you'll be
    introduced to some intermediate topics in C#, including new type modifiers, method
    overloading, interfaces, and class extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – AI and navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How is a NavMesh component created in a Unity scene?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What component identifies a GameObject to a NavMesh?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executing the same logic on one or more sequential objects is an example of
    which programming technique?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the DRY acronym stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JOIN us on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Join Now!
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code_9781801813945.png)'
  prefs: []
  type: TYPE_IMG
