<html><head></head><body>
<div><h1 class="chapterNumber"><a id="_idTextAnchor345"/>12</h1>
<h1 class="chapterTitle" id="_idParaDest-244"><a id="_idTextAnchor346"/>Simplifying Microservices with .NET Aspire</h1>
<p class="normal">.NET Aspire was conceived to simplify the testing of interacting microservices on development machines. In the <em class="italic">Running your microservices on Kubernetes</em> section of <a href="Chapter_8.xhtml#_idTextAnchor205"><em class="italic">Chapter 8</em></a>, <em class="italic">Practical Microservices Organization with Kubernetes</em>, we listed two testing techniques we can adopt on our development machines:</p>
<ul>
<li class="bulletList">Testing the interacting microservices with minikube while debugging each single microservice with the bridge technique</li>
<li class="bulletList">Exploiting Visual Studio native support for Docker to debug and test our microservices while they interact through a Docker virtual network</li>
</ul>
<p class="normal">While the minikube technique is complete and more realistic, it is time-consuming, so most of the testing/debugging is performed with Docker virtual networks.</p>
<p class="normal">.NET Aspire provides a simpler alternative to the direct usage of Docker networks. Moreover, it offers a simple way to configure the interaction between microservices and between each microservice and other resources. Finally, .NET Aspire projects can be compiled to produce instructions to both deploy all microservices on Azure Container Apps and to create some of the resources that they use on Azure. However, its main usage is in development and staging environments and it should not be used for automatically setting up actual production environments since it doesn’t handle all deployment options.</p>
<p class="normal">In this chapter, we will describe the basics of .NET Aspire together with all the services and opportunities it offers. More specifically, this chapter covers the following:</p>
<ul>
<li class="bulletList">.NET Aspire features and services</li>
<li class="bulletList"><a id="_idTextAnchor347"/>Configuring microservices and resources</li>
<li class="bulletList"><a id="_idTextAnchor348"/>Using .NET Aspire in practice</li>
<li class="bulletList">Deploying a .NET Aspire project</li>
</ul>
<h1 class="heading-1" id="_idParaDest-245"><a id="_idTextAnchor349"/>Technical requirements</h1>
<p class="normal">This chapter requires the following:</p>
<ol>
<li class="numberedList" value="1">Visual <a id="_idIndexMarker968"/>Studio 2022 free <em class="italic">Community Edition</em>, at least.</li>
<li class="numberedList"><strong class="keyWord">Docker Desktop</strong> for Windows (<a href="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a>), which, in turn, requires Windows Subsystem for Linux (WSL), which can be installed by following these steps:</li>
<li class="numberedList">Type <code class="codeHighlighted" style="font-weight: bold;">powershell</code> in the Windows 10/11 search bar.</li>
<li class="numberedList">When Windows PowerShell is proposed as a search result, click on <strong class="screenText">Run as an administrator</strong>.</li>
<li class="numberedList">In the Windows PowerShell administrative console that appears, run the <code class="codeHighlighted" style="font-weight: bold;">wsl --install</code> command.</li>
</ol>
<p class="normal">You can find the sample code for this chapter at <a href="https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp">https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp</a>.</p>
<h1 class="heading-1" id="_idParaDest-246"><a id="_idTextAnchor350"/>.NET Aspire features and services</h1>
<p class="normal">.NET Aspire takes care of the microservices interaction and offers other services, as follows:</p>
<ul>
<li class="bulletList">It handles <a id="_idIndexMarker969"/>the interaction with environment resources such as databases and message brokers in a very simple way. You don’t need to specify a connection string that might change when the microservice is deployed; it is enough that you declare the interaction between a microservice and a resource together with some general configuration. This is done with a .NET <a id="_idIndexMarker970"/>feature called <strong class="keyWord">local service discovery</strong>, which will be discussed in detail in the <em class="italic">Service discovery and its role in .NET Aspire</em> subsection.</li>
<li class="bulletList">It offers simulators of cloud services, together with common disk and in-memory databases and message brokers.</li>
<li class="bulletList">The interaction between microservices and other resources is configured declaratively in a dedicated .NET project, thus avoiding the usage of virtual addresses and connection strings inside the microservices code.</li>
<li class="bulletList">Once a .NET Aspire project is run, all microservices and resources are run, and interactions among microservices and resources are automatically handled.</li>
<li class="bulletList">While microservices are run in the development environment, both logs and statistics are collected.</li>
<li class="bulletList">As soon as a .NET Aspire project is run, a smart console appears in the browser that shows all collected statistics and logs, together with the links to access all microservice endpoints.</li>
</ul>
<p class="normal">Interactions <a id="_idIndexMarker971"/>between microservices and between microservices and other resources are declared in a special type of project called App Host. You can find the App Host project and all other Aspire templates by typing <code class="codeHighlighted" style="font-weight: bold;">Aspire</code> in the Visual Studio search box, as shown in the following figure:</p>
<figure class="mediaobject"><img alt="Figure 12.1: Aspire projects and solution templates" src="img/B31916_12_1.png"/></figure>
<p class="packt_figref">Figure 12.1: Aspire projects and solution templates</p>
<p class="normal">Another Aspire-specific <a id="_idIndexMarker972"/>project type is the .NET Aspire Service Defaults project, which provides extension methods to configure various services. In order to ensure that some basic services are configured in the same way in all microservices, we define them in this project and then call their extension methods in the <code class="codeHighlighted" style="font-weight: bold;">Program.cs</code> configuration of all microservice projects. Accordingly, all microservices must add a reference to this project.</p>
<p class="normal">As a default, all Aspire templates configure the following service defaults:</p>
<ul>
<li class="bulletList"><code class="inlineCode">HttpClient</code> service discovery: In the App Host configuration, microservices and resources are given names, and thanks to this configuration, <code class="inlineCode">HttpClient</code> can use virtual URLs based on these names instead of the actual resource URLs, which might depend <a id="_idIndexMarker973"/>on where the resources are deployed in the various environments (development, staging, production, etc.).</li>
<li class="bulletList"><code class="inlineCode">HttpClient</code> resiliency: Each <code class="inlineCode">HttpClient</code> call is automatically applied to all policies, as discussed in the <em class="italic">Resilient task execution </em>subsection of<em class="italic"> </em><a href="Chapter_2.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Demystifying Microservices Applications</em>. More specifically, retry, circuit break, timeout, and rate-limiting (bulkhead isolation) strategies are automatically applied and <a id="_idIndexMarker974"/>can be configured once and for all in the <strong class="keyWord">.NET Aspire Service Defaults</strong> project.</li>
<li class="bulletList">OpenTelemetry, which will be discussed in a dedicated subsection.</li>
<li class="bulletList">Public endpoints exposing microservice health conditions. Health checks are used both by the App Host orchestrator and by staging and production orchestrators such as Kubernetes (see the <em class="italic">Readiness, liveness, and startup probes</em> subsection of <a href="Chapter_8.xhtml#_idTextAnchor205"><em class="italic">Chapter 8</em></a>, <em class="italic">Practical Microservices Organization with Kubernetes</em>). Two default endpoints are provided: <code class="inlineCode">/health</code>, which returns a <code class="codeHighlighted" style="font-weight: bold;">200</code> HTTP code and a “healthy” test response if the microservice is healthy, and an <code class="inlineCode">/alive</code> endpoint, which returns a <code class="codeHighlighted" style="font-weight: bold;">200</code> HTTP code and a “healthy” test response if the microservice is running and has not crashed.</li>
<li class="bulletList">As a default, both endpoints are exposed only during development for security reasons. However, if the microservice is not accessible to external users, it can also be safely exposed in production. You need just to remove the condition on the environment in the <code class="inlineCode">MapDefaultEndpoints()</code> extension defined in the the .NET Aspire Service Defaults project.</li>
<li class="bulletList">If, instead, the microservice is a frontend, these endpoints can be exposed only if they are protected by both authentication and a throttling strategy that prevents denial of service attacks.</li>
</ul>
<p class="normal">You don’t need to manually add all these configurations since they are automatically added when the project is created. Most of the time, you will need to only change some parameters, such as the parameters of the various resiliency strategies.</p>
<p class="normal">Each microservice needs just to call <code class="codeHighlighted" style="font-weight: bold;">builder.AddServiceDefaults()</code> an<a id="_idTextAnchor351"/>d <code class="codeHighlighted" style="font-weight: bold;">app.MapDefaultEndpoints()</code> in order to apply all the configured defaults, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">var builder = WebApplication.CreateBuilder(args);
// Add service defaults &amp; Aspire client integrations.
<strong class="hljs-slc">builder.</strong><strong class="hljs-title-slc">AddServiceDefaults</strong><strong class="hljs-slc">();</strong>
// Add application specific services
builder.Services…..
…
// Build application host
var app = builder.Build();
//Configure application
app….
…
//Add default endpoints
<strong class="hljs-slc">app.</strong><strong class="hljs-title-slc">MapDefaultEndpoints</strong><strong class="hljs-slc">();</strong>
app.Run();
</code></pre>
<p class="normal">There are <a id="_idIndexMarker975"/>also Aspire-specific testing projects based on xUnit, NUnit, and MSTest. They have all the needed references to create an app host, launch the application, and communicate with microservices through URLs based on their names (service discovery).</p>
<p class="normal">As soon as you add a test project, it contains an initial example test with the whole code for creating the App Host and issuing a call to a microservice. This code is commented out, so you need just to add a reference to your App Host project to uncomment the code, and to replace the fake App Host project name and microservice name with your App Host project name and microservice name:</p>
<pre class="programlisting code"><code class="hljs-code"> // Arrange
//    var appHost = await DistributedApplicationTestingBuilder
.CreateAsync&lt;Projects.<strong class="hljs-property-slc">MyAspireApp_AppHost</strong>&gt;();
    //    appHost.Services.ConfigureHttpClientDefaults(clientBuilder =&gt;
//    {
//        clientBuilder.AddStandardResilienceHandler();
//    });        //
//    await using var app = await appHost.BuildAsync();
//    var resourceNotificationService = app.Services.
    //    GetRequiredService&lt;ResourceNotificationService&gt;();
//    await app.StartAsync();
//    // Act
//    var httpClient = app.CreateHttpClient("<strong class="hljs-comment-slc">webfrontend</strong>");
//    await resourceNotificationService
//    .WaitForResourceAsync("<strong class="hljs-comment-slc">webfrontend</strong>",
//    KnownResourceStates.Running).WaitAsync(TimeSpan.FromSeconds(30));
//    var response = await httpClient.GetAsync("/");
</code></pre>
<p class="normal">In the preceding code, the fake names that must be replaced are highlighted.</p>
<p class="normal">A template <a id="_idIndexMarker976"/>called <strong class="keyWord">.NET Aspire Empty App</strong> is also available, which creates both the App Host and Service <a id="_idIndexMarker977"/>Defaults projects, and a <strong class="keyWord">.NET Aspire Starter App</strong> template that adds some example microservices and resources, together <a id="_idIndexMarker978"/>with their App Host configurations.</p>
<p class="normal">The <strong class="keyWord">.NET Aspire Starter App</strong> template has a great didactic value because it immediately shows basic configurations, and how to configure and use <code class="inlineCode">HttpClient</code> with service discovery. Moreover, it is a good way to explore the console that appears in the browser when the application is launched with its statistics and logs, and the links to access all microservice endpoints. You are encouraged to create, explore, and run this project.</p>
<p class="normal">Service discovery is not an Aspire-specific feature but is a general .NET feature. It relies on various providers to map service names to actual URLs. We will discuss it in more detail in the next subsection.</p>
<h2 class="heading-2" id="_idParaDest-247"><a id="_idTextAnchor352"/>Service discovery and its role in .NET Aspire.</h2>
<p class="normal">Service discovery is an <code class="inlineCode">HttpClient</code> feature provided through extension methods defined in the <code class="inlineCode">Microsoft.Extensions.ServiceDiscovery</code> NuGet package.</p>
<p class="normal">Service names <a id="_idIndexMarker979"/>are mapped to actual URLs <a id="_idIndexMarker980"/>by using maps defined by providers. As a default, just the .NET configuration provider is added to the list of providers.</p>
<p class="normal">This provider tries to read these maps from the <code class="inlineCode">Service</code>s section of the project configuration, where they must be defined as follows:</p>
<pre class="programlisting code"><code class="hljs-code">"Services": {
    "myservice": {
      "https": [
        "10.46.24.91:80"
      ],
       "http": [
        "10.46.24.91:443"
      ]
    }
  }
</code></pre>
<p class="normal">When the service is called with <code class="inlineCode">http://myservice</code>, the endpoint specified in the <code class="codeHighlighted" style="font-weight: bold;">http</code> subsection is chosen; otherwise, if it is called with <code class="inlineCode">https://myservice</code>, the one in the <code class="codeHighlighted" style="font-weight: bold;">https</code> subsection is chosen.</p>
<p class="normal">The configuration-based provider is added with the following:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddServiceDiscovery();
</code></pre>
<p class="normal">The preceding <a id="_idIndexMarker981"/>code also adds the pass-through provider, which simply resolves each service name to the service name itself. In other words, the pass-through provider does nothing! It must be used when deploying to Kubernetes since, in Kubernetes, names are resolved by services.</p>
<p class="normal">Therefore, when deploying <a id="_idIndexMarker982"/>to Kubernetes, each Microservice must have an associated service whose name is identical to the microservice name.</p>
<p class="normal">For instance, if we have a microservice called <code class="inlineCode">routes_planning</code> that is deployed in a Kubernetes <code class="inlineCode">routes_planning</code> Deployment, then communications to <code class="inlineCode">routes_planning</code> must be passed through a Kubernetes service called <code class="inlineCode">routes-planning</code>.</p>
<p class="normal">If a service name is not resolved by the configuration-based provider, it is passed to the next provider, which is the pass-through provider.</p>
<p class="normal">Suppose we would like to deploy on Kubernetes but, first, we need to test our application with .NET Aspire. Do we need two different service discovery settings for these two environments?</p>
<p class="normal">The answer is no! In fact, .NET Aspire doesn’t use a configuration file to define the service maps. Instead, when the App Host project launches a microservice, it injects all service resolution rules it needs into environment variables that are then merged with all other microservice configuration information.</p>
<p class="normal">When the application is published to a Kubernetes cluster, there will be no App Host, so no service resolution maps are injected in the configuration, and all resolutions are passed to the pass-through provider.</p>
<p class="normal">One can also use <code class="inlineCode">AddServiceDiscoveryCore()</code>, which doesn’t add any default provider instead of <code class="inlineCode">AddServiceDiscovery()</code>. In this case, providers must be added manually by calling </p>
<p class="normal"><code class="inlineCode">AddPassThroughServiceEndpointProvider()</code> and <code class="inlineCode">AddConfigurationServiceEndpointProvider()</code>.</p>
<p class="normal">For instance, if we would like to add just the configuration-based provider, we can simply write the following:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddServiceDiscovery()
    .AddConfigurationServiceEndpointProvider();
</code></pre>
<p class="normal">Service discovery can be also customized by setting the properties of the <code class="inlineCode">ConfigurationServiceEndPointResolverOptions</code> option object. For instance, the following <a id="_idIndexMarker983"/>code changes the name of the <code class="inlineCode">Services</code> section in which to place all service name maps:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.Configure&lt;ConfigurationServiceEndPointResolverOptions&gt;(
    static options =&gt;
    {
        options.SectionName = "MyCustomResolverSection"
    });
</code></pre>
<p class="normal">Once we <a id="_idIndexMarker984"/>have added and configured service discovery, we must specify the HTTP clients that must use it. The following code applies service discovery to all HTTP clients:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.ConfigureHttpClientDefaults(http =&gt;
{
    http.AddServiceDiscovery();
});
</code></pre>
<p class="normal"><code class="inlineCode">ConfigureHttpClientDefaults</code> can also be used to add and configure the various resiliency policies for all HTTP clients:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.ConfigureHttpClientDefaults(http =&gt;
{
    http.AddStandardResilienceHandler();
    http.AddServiceDiscovery();
});
</code></pre>
<div><p class="normal">The preceding code is the default <code class="inlineCode">HttpClient</code> configuration added in all <strong class="keyWord">.NET Aspire Service Defaults</strong> projects.</p>
</div>
<p class="normal">Service discovery can also be added to a specific <code class="inlineCode">HttpClient</code>, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddHttpClient("myclient", static client =&gt;
{
    client.BaseAddress = new("https://routes_planning");
})
.AddServiceDiscovery();
</code></pre>
<p class="normal">When service discovery is in place, we can also write URIs such as <code class="codeHighlighted" style="font-weight: bold;">"https+http://routes_planning"</code> or <code class="codeHighlighted" style="font-weight: bold;">"http+https://routes_planning"</code>. In this case, service discovery will attempt to resolve the URI with the first protocol (<code class="codeHighlighted" style="font-weight: bold;">https</code> or <code class="codeHighlighted" style="font-weight: bold;">http</code>), and will move to the second protocol in the case of failure.</p>
<p class="normal">This is useful when we use <code class="codeHighlighted" style="font-weight: bold;">http</code> during development and <code class="codeHighlighted" style="font-weight: bold;">https</code> in staging and production. For this purpose, it is enough to define just <code class="codeHighlighted" style="font-weight: bold;">http</code> endpoints in the launch settings of all microservice projects. In fact, the App Host uses each microservice’s launch settings to create the service <a id="_idIndexMarker985"/>discovery maps that it injects into the environment variables. Therefore, only <code class="codeHighlighted" style="font-weight: bold;">http</code> maps would be generated during development, so the <code class="codeHighlighted" style="font-weight: bold;">https</code> resolution will fail. After deployment, instead, just the pass-through provider will work so the <code class="codeHighlighted" style="font-weight: bold;">https</code> resolution will succeed.</p>
<p class="normal">Up to this point, we supposed <a id="_idIndexMarker986"/>that each microservice has just a single endpoint, but sometimes, some services might have several endpoints, each on a different port. When a microservice has several endpoints, we must give names to all the endpoints except one (the default endpoint). Endpoint names are given in the service definition and configuration that is in the App Host. The following is the definition of a microservice with a default endpoint and a named endpoint whose name is <code class="codeHighlighted" style="font-weight: bold;">"aux"</code>:</p>
<pre class="programlisting code"><code class="hljs-code">var routesPlanning = builder.AddProject&lt;Projects.RoutesPlanningService&gt;("routes_planning ")
    .WithHttpsEndpoint(hostPort: 9999, name: "aux");
</code></pre>
<p class="normal">In this case, the generated configuration map will associate two URLs to the service name, one for the default endpoint and the other for the named endpoint, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">"Services": {
    "routes_planning": {
      "https": ["https://localhost:8080"],
      "aux": ["https://localhost:8090"]   
    }
  }
</code></pre>
<p class="normal">The default endpoint can<a id="_idTextAnchor353"/> be acces<a id="_idTextAnchor354"/>sed with <code class="codeHighlighted" style="font-weight: bold;">"https://routes_planning"</code>, while, for the named endpoint, we must add also the endpoint name to the URI, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">https://_aux.routes_planning
</code></pre>
<p class="normal">When using <a id="_idIndexMarker987"/>Aspire App Host, the preceding <a id="_idIndexMarker988"/>configuration is automatically created and injected into all services that need it, so we don’t need to worry about it.</p>
<p class="normal">However, if we deploy on Kubernetes, we must define a Kubernetes service that correctly resolves both <code class="codeHighlighted" style="font-weight: bold;">"https://routes_planning"</code> and <code class="codeHighlighted" style="font-weight: bold;">"https://_aux.routes_planning"</code>. This result is easily achieved with named ports, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">apiVersion: v1
kind: Service
metadata:
  name: routes_planning
spec:
  selector:
    name: routes_planning
  ports:
  - name: default
port: 8080
  - name: aux
    port: 8090
</code></pre>
<p class="normal">The port associated with the default endpoint must be given the <code class="inlineCode">default</code> name, while all ports associated with named endpoints must be given the same name as the endpoint.</p>
<p class="normal">Now that we understand the magic behind actual service URL discovery, let’s move on to the magic behind resource integration and automatic connection string handling.</p>
<h2 class="heading-2" id="_idParaDest-248"><a id="_idTextAnchor355"/>Resource integration and automatic resource configuration</h2>
<p class="normal">Resources needed for the various microservice projects can be simulated when the solution is run. It is <a id="_idIndexMarker989"/>enough to add <a id="_idIndexMarker990"/>the corresponding <a id="_idIndexMarker991"/>Aspire NuGet packages and declare and configure <a id="_idIndexMarker992"/>the resource in the App Host. There are extension methods for declaring the main databases, Redis, and the main message brokers such as RabbitMQ, Kafka, and even an Azure Service Bus simulator. For a complete list of all resources that can be added to an Aspire project and configured in its App Host, please refer to the official documentation on integration at <a href="https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/integrations-overview">https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/integrations-overview</a>.</p>
<p class="normal">Behind the curtain, all these resources are implemented with Docker images, so most extension methods also allow you to choose a specific Docker image and a specific version. Furthermore, since the App Host supports generic Docker images, one can implement extension methods for a custom resource that is not yet supported. However, the list of supported resources is growing quickly, so you should find all the resources you ne<a id="_idTextAnchor356"/>ed already implemented.</p>
<p class="normal">In the <em class="italic">Using .NET Aspire in practice </em>section of this chapter, you will see in detail how to integrate and configure SQL Server and RabbitMQ, and in the <em class="italic">Configuring Microservices and Resources</em> section, we will explain how to declare and configure both microservices and resources in the App Host.</p>
<p class="normal">When <a id="_idIndexMarker993"/>you configure <a id="_idIndexMarker994"/>a resource, you give it a name, and if the resource supports a connection string, that name is assumed to <a id="_idIndexMarker995"/>be the name of the connection string. Accordingly, when <a id="_idIndexMarker996"/>the App Host creates a resource, it computes its connection string and passes it in the <code class="inlineCode">ConnectionStrings</code> section of the configuration of all microservices that use that resource. This is done by placing the configuration string in an environment variable called <code class="inlineCode">ConnectionStrings__&lt;name&gt;</code>, where <code class="inlineCode">&lt;name&gt;</code> is the name that we gave to the resource.</p>
<p class="normal">For instance, suppose our application needs a SQL Server instance containing a database called <code class="codeHighlighted" style="font-weight: bold;">"mydatabase"</code>. In the App Host, we may declare these resources with the following:</p>
<pre class="programlisting code"><code class="hljs-code">var builder = DistributedApplication.CreateBuilder(args);
var sql = builder.AddSqlServer("sql");
var db = sql.AddDatabase("mydatabase ");
</code></pre>
<p class="normal">Now, if a microservice defined in the <code class="inlineCode">MyExampleProject</code> project must use the <code class="codeHighlighted" style="font-weight: bold;">"mydatabase"</code> database, it must declare it as follows:</p>
<pre class="programlisting code"><code class="hljs-code">builder.AddProject&lt;Projects.MyExampleProject&gt;()
       .<strong class="hljs-title-slc">WithReference</strong><strong class="hljs-slc">(db);</strong>
</code></pre>
<p class="normal">The <code class="inlineCode">WithReference(db)</code> call causes the connection string for accessing <code class="codeHighlighted" style="font-weight: bold;">"mydatabase"</code> in the SQL Server instance to be injected in the <code class="inlineCode">ConnectionStrings__mydatabase</code> environment variable of the <code class="inlineCode">MyExampleProject</code> microservice.</p>
<p class="normal">Clearly, when we configure a resource, we can also specify the credentials to access it instead of using the default credentials created by the extension method.</p>
<p class="normal">More details on how to configure resources and microservices in the App Host will be given in the next section.</p>
<p class="normal">Usually, together with the connection string, the App Host passes a whole configuration section containing more details on the resources, such as username and password. The format of this auxiliary <a id="_idIndexMarker997"/>data depends on the specific resource type. In the <em class="italic">Using .NET Aspire in practice</em> section of this chapter, we will see the RabbitMQ <a id="_idIndexMarker998"/>auxiliary information format. The auxiliary information format of all supported resources is available in the official documentation.</p>
<p class="normal">If we want <a id="_idIndexMarker999"/>to use an already existing resource, we don’t <a id="_idIndexMarker1000"/>need to declare <a id="_idIndexMarker1001"/>it in the App Host but we need to declare its connection string with <code class="inlineCode">builder.AddConnectionString</code> so that the App Host can inject it into all the microservices that need it. For instance, if the SQL Server database of the previous example already exists both in the development environment and in the deployment environment, the code must be modified as follows:</p>
<pre class="programlisting code"><code class="hljs-code">var builder = DistributedApplication.CreateBuilder(args);
var db = builder.AddConnectionString("parameterName", "database");
</code></pre>
<p class="normal">Here, <code class="inlineCode">parameterName</code> is the name of the parameter that contains the connection string in the App Host configuration file in the <code class="codeHighlighted" style="font-weight: bold;">"Parameters"</code> section, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">{
    "Parameters": {
        " parameterName ": " SERVER=XXX.XXX.X.XX;DATABASE=DATABASENAME ……"
    }
}
</code></pre>
<p class="normal">Needless to say, we can use .NET environments to provide different configurations in different environments.</p>
<p class="normal">The remainder of the code remains unchanged:</p>
<pre class="programlisting code"><code class="hljs-code">builder.AddProject&lt;Projects.MyExampleProject&gt;()
       .WithReference(db);
</code></pre>
<p class="normal">What happens to all the connection strings and the auxiliary resource data when the application is deployed in production or staging?</p>
<p class="normal">If deployment is manual, the same environment variable inserted by the App Host must be defined in the configuration of the target orchestrator. Thus, for instance, if the target orchestrator is Kubernetes, it must be defined in the <code class="codeHighlighted" style="font-weight: bold;">env</code> section of a Deployment. As we will see in more <a id="_idIndexMarker1002"/>detail in the <em class="italic">Deploying a .NET Aspire project</em> section, when we use automatic tools for configuring the <a id="_idIndexMarker1003"/>target orchestrator, there are two possibilities:</p>
<ul>
<li class="bulletList">If the automatic <a id="_idIndexMarker1004"/>tool is capable of provisioning <a id="_idIndexMarker1005"/>the required resources, it will also automatically configure all the environment variables, taking all the required information from the created resources</li>
<li class="bulletList">If the automatic tool doesn’t generate the required resources but only generates the code to configure all the microservices, it will ask the user for the environment variable values</li>
</ul>
<p class="normal">The next subsection details how to handle telemetry during development and when the application is deployed.</p>
<h2 class="heading-2" id="_idParaDest-249"><a id="_idTextAnchor357"/>Application telemetry</h2>
<p class="normal">Telemetry <a id="_idIndexMarker1006"/>enables the monitoring of <a id="_idIndexMarker1007"/>a microservices application as a whole by connecting adequately related events taking place in different microservices. More specifically, it collects the following data:</p>
<ul>
<li class="bulletList">Logging: Individual logs of all microservices and resources are collected and classified according to their generation time and source.</li>
<li class="bulletList">Tracing: Traces correlate log events that are part of the same logical activity (e.g., the handling of a single request), even if they’re spread across multiple machines or processes. Tracing is the starting point for diagnosing and debugging malfunctions.</li>
<li class="bulletList">Metrics: Various microservice metrics are collected by each executing microservice and are sent to a collection point.</li>
</ul>
<p class="normal">When the application is run in the development environment and uses the App Host as an orchestrator, each microservice’s telemetry is enabled by the <code class="inlineCode">ConfigureOpenTelemetry()</code> call configured in the <strong class="keyWord">.NET Aspire Service Defaults</strong> project. This call enables the collection of metrics and the transmission of these metrics together with the microservice logs to an <strong class="keyWord">OpenTelemetry</strong> endpoint <a id="_idIndexMarker1008"/>that implements the <strong class="keyWord">OpenTelemetry Protocol (OTLP)</strong>.</p>
<p class="normal">During development, the Aspire console that opens when the solution is run works as an OpenTelemetry endpoint, and the data for connecting with this endpoint is injected as an environment variable into all microservices by the App Host. Therefore, all the data we can see in this console comes from telemetry.</p>
<p class="normal">When the application is deployed, the same environment variables must contain the data of an OpenTelemetry <a id="_idIndexMarker1009"/>endpoint available in the deployment environment. Azure supports OTLP, so if, for instance, the application is <a id="_idIndexMarker1010"/>deployed to Azure Kubernetes, we must pass the data of the telemetry endpoint that is created together with the Azure Kubernetes cluster. It is also possible to pass OpenTelemetry data to tools such as Grafana, which was described in the <em class="italic">Kubernetes administrative tools</em> subsection of <a href="Chapter_9.xhtml#_idTextAnchor261"><em class="italic">Chapter 9</em></a>,<em class="italic"> Simplifying Containers and Kubernetes: Azure Container Apps</em><em class="italic"> and other Tools</em>.</p>
<p class="normal">The environment variables automatically injected in each microservice by the App Host that we must inject manually in the deployment environment are as follows:</p>
<ul>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;">OTEL_EXPORTER_OTLP_ENDPOINT</code>, which contains the URL of the OTLP endpoint.</li>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;">OTEL_SERVICE_NAME</code>, which contains the service name that the microservice must add to the data it sends. You should use the same name given to the microservice in the App Host configuration.</li>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;">OTEL_RESOURCE_ATTRIBUTES</code>, which contains a unique ID that univocally identifies each service instance. It must be added to all data, too, and must have the following format: <code class="codeHighlighted" style="font-weight: bold;">service.instance.id=&lt;unique name&gt;</code>. Typically, GUIDs are used as unique service names.</li>
</ul>
<p class="normal">Once you have clarified all the services offered by Aspire, you need to learn how to configure the App Host.</p>
<h1 class="heading-1" id="_idParaDest-250"><a id="_idTextAnchor358"/>Configuring microservices and resources</h1>
<p class="normal">The App <a id="_idIndexMarker1011"/>Host handles services as follows:</p>
<ol>
<li class="numberedList" value="1">.NET projects: These can be configured with <code class="inlineCode">var myService = builder.AddProject&lt;Projects.MyProjectName&gt;("myservicename");</code></li>
<li class="numberedList">Containers stored in some registry: These can be configured with <code class="inlineCode">var myService = builder.AddContainer("myservicename", "ContainerNameOrUri");</code></li>
<li class="numberedList">Executables: These can be configured with <code class="inlineCode">var myService = builder.AddExecutable("myservicename", "&lt;shell command&gt;", "&lt;executable working directory&gt;");</code></li>
<li class="numberedList">Dockerfiles to be built: These can be configured with <code class="inlineCode">var myService = bu<a id="_idTextAnchor359"/>ilder.AddDockerfile(</code>
<pre class="programlisting code-one"><code class="hljs-code"><code class="inlineCode">    "myservicename ", "relative/context/path");</code>
</code></pre>
</li>
</ol>
<p class="normal-one">where <code class="inlineCode">"relative/context/path"</code> is the folder containing the Dockerfile and all files needed to build the Dockerfile. This path must be relative to the directory that contains the App Host project file.</p>
<p class="normal">Each of the <a id="_idIndexMarker1012"/>preceding commands can be followed by several configuration options, passed with a fluent interface, as shown in this example:</p>
<pre class="programlisting code"><code class="hljs-code">var cache = builder.AddProject&lt;Projects……
var apiService = builder.AddProject&lt;Projects……
builder.AddProject&lt;Projects.MyAspireProject&gt;("webfrontend")   
   .WithReference(cache)
    .WaitFor(cache)
    .WithReference(apiService)
    .WaitFor(apiService);
</code></pre>
<p class="normal"><code class="inlineCode">WithReference</code> declares that the service communicates with the resource or service passed as an argument. It causes the injection of all environment variables containing the data needed by service discovery, connection strings, or other auxiliary resource information.</p>
<p class="normal"><code class="inlineCode">WaitFor</code> declares that the microservice must be started after the service or resource passed as the argument is running.</p>
<p class="normal"><code class="inlineCode">WithReplicas(int n)</code> is another important method of the fluent interface configuration. It declares that the microservice must be replicated <em class="italic">n</em> times. It is important if we plan to use an automatic tool to compile the App Host configuration into Kubernetes or Azure Container Apps configuration code.</p>
<p class="normal">Unfortunately, often, when in development mode, the limited power of our development machine doesn’t allow the same number of replicas that we need in production. Therefore, we should execute different configuration instructions in these cases.</p>
<p class="normal">The App Host configuration is executed both when we run the application on the development machine and when we use App Host configuration to generate code for other platforms. In the second case, we say that we are in publishing mode instead of running mode. Luckily, the <code class="inlineCode">builder</code> object contains information on the execution environment in the <code class="inlineCode">builder.ExecutionContext</code> property. In particular, we can use the <code class="inlineCode">builder.ExecutionContext.IsPublishMode</code> and <code class="inlineCode">builder.ExecutionContext.IsRunMode</code> properties to differentiate between the configuration in running mode and in publishing mode.</p>
<p class="normal">As already mentioned, in the <em class="italic">Service discovery and its role in .NET Aspire</em> subsection, we can also use the <code class="inlineCode">WithEndpoint</code> fluent interface method to declare auxiliary endpoints available on other ports:</p>
<pre class="programlisting code"><code class="hljs-code">var routesPlanning = builder.AddProject&lt;Projects.RoutesPlanningService&gt;("routes_planning ")
    .WithEndpoint(hostPort: 9999, name: "aux");
</code></pre>
<p class="normal"><code class="inlineCode">WithEndpoint</code> can be replaced by <code class="inlineCode">WithHttpsEndpoint</code> and <code class="inlineCode">WithHttpEndpoint</code> to declare, respectively, HTTPS-only and HTTP-only endpoints.</p>
<p class="normal">The <code class="inlineCode">WithExternalHttpEndpoints()</code> fluent interface method declares that the microservice endpoint must <a id="_idIndexMarker1013"/>be available outside of the application for application clients. These endpoints will be exposed with <code class="codeHighlighted" style="font-weight: bold;">Ingress</code> or <code class="codeHighlighted" style="font-weight: bold;">LoadBalancer</code> services when publishing the application on Kubernetes and with external ingresses when publishing the application on Azure Container Apps.</p>
<p class="normal">Resources used by microservices can be declared and configured with the same fluent interface. Each resource type requires a dedicated NuGet package that provides the needed extension methods to the fluent interface. All these extension methods are built on the <code class="inlineCode">builder.AddContainer</code> method since they use Docker images to implement the resources. Therefore, if a resource we need is not yet available, we can write the needed extension methods ourselves. However, as already mentioned, there are resources for all the main databases, Redis, all the main message brokers, and most Azure services. Some Azure resource configurators provision and use actual Azure resources, while others use local simulators. There are simulators for Azure Storage and Azure Service Bus.</p>
<p class="normal">Refer to the official documentation for a list of all available resource integrations: <a href="https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/integrations-overview">https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/integrations-overview</a>.</p>
<p class="normal">As a default, when the App Host is shut down, all database data is lost since all Docker images use temporary storage. However, we can use the <code class="inlineCode">WithDataVolume()</code> fluent interface method to force the usage of permanent Docker volume storage:</p>
<pre class="programlisting code"><code class="hljs-code">var sql = builder.AddSqlServer("sql")
                 .WithDataVolume();
var db = sql.AddDatabase("database");
</code></pre>
<p class="normal">When this method is called, a Docker volume with an auto-generated name is created. For more control over the volume name and the directory inside the container where it is mounted, you can use <code class="inlineCode">WithBindMount</code>:</p>
<pre class="programlisting code"><code class="hljs-code">var sql = builder.AddSqlServer("sql")
                 .WithBindMount("MyVolumeName", "/var/opt/mssql");
var db = sql.AddDatabase("database");
</code></pre>
<p class="normal">Most resources use a default username, such as <code class="inlineCode">sa</code>, and an auto-generated password. Both credentials are available through the resources information link of the App Host browser console. However, if data is not persisted with a volume, this password may change at each run.</p>
<p class="normal">Luckily, all resources provide the possibility to specify some parameters, and <code class="codeHighlighted" style="font-weight: bold;">username</code> and <code class="codeHighlighted" style="font-weight: bold;">password</code> are always among them.</p>
<p class="normal">Needless to say, parameters are not inserted directly in the code, for obvious reasons. They are taken from the <code class="codeHighlighted" style="font-weight: bold;">"Parameter"</code> section of the App Host configuration. Therefore, they can be inserted in <a id="_idIndexMarker1014"/>the App Host configuration file, so we can also provide a different value for each environment by using the usual .NET environment-based configuration file override.</p>
<p class="normal">The first step is the definition of a parameter object with the name of the <code class="codeHighlighted" style="font-weight: bold;">"Parameters"</code> property that contains the actual value:</p>
<pre class="programlisting code"><code class="hljs-code">var password = builder.AddParameter("sqlpassword", secret: true);
</code></pre>
<p class="normal">By setting <code class="inlineCode">secret</code> to <code class="inlineCode">true</code>, we enable the generation of a hint to store the parameter in a safe place when we run Aspire in publishing mode.</p>
<p class="normal">Then, the parameter is placed in the right place of the resource extension method, which is resource-specific:</p>
<pre class="programlisting code"><code class="hljs-code">var sql = builder.AddSqlServer("sql", password)
                 .WithBindMount("MyVolumeName", "/var/opt/mssql");
var db = sql.AddDatabase("database");
</code></pre>
<p class="normal">The actual value must be placed in the App Host project configuration file, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">{ 
  "Parameters": {
    "sqlpassword": "my_password_value",
   …
  },
  …
}
</code></pre>
<p class="normal">The next subsection describes how to integrate Azure Functions projects in .NET Aspire solutions.</p>
<h2 class="heading-2" id="_idParaDest-251"><a id="_idTextAnchor360"/>Azure Functions integration</h2>
<p class="normal">At the time of writing this book, the integration of Azure Functions projects in .NET Aspire solutions is <a id="_idIndexMarker1015"/>in preview. However, we will describe it briefly since it offers great opportunities.</p>
<p class="normal">At the moment, only Azure <a id="_idIndexMarker1016"/>Functions with the following triggers are supported: Azure Event Hubs, Azure Service Bus, Azure Blob storage, Azure Queue storage, Azure CosmosDB, HTTP, and Timer.</p>
<p class="normal">In order to configure an Azure Functions project, the App Host must reference the <code class="inlineCode">Aspire.Hosting.Azure.Functions</code> NuGet package. Once this reference has been added, an Azure Functions project can be configured, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">var myFunction = builder.AddAzureFunctionsProject&lt;Projects.MyFunctionsProject&gt;(
 " MyFunction ");
</code></pre>
<p class="normal">The <code class="inlineCode">AddAzureFunctionsProject</code> call can be chained with the usual configuration methods of all other project types, such as <code class="inlineCode">WithExternalHttpEndpoints()</code>.</p>
<p class="normal">Once defined in this way, <code class="inlineCode">myFunction</code> can be referred to by other projects with the usual methods:</p>
<pre class="programlisting code"><code class="hljs-code">builder.AddProject&lt;Projects.MyOtherProject&gt;()
       .WithReference(myFunction)
       .WaitFor(myFunction);
</code></pre>
<p class="normal">A local emulator of an Azure storage account may be added as follows:</p>
<pre class="programlisting code"><code class="hljs-code">var storage = builder.AddAzureStorage("storage")
                     .RunAsEmulator();
var myFunction = builder.AddAzureFunctionsProject&lt;Projects.MyFunctionsProject&gt;(
    " MyFunction ")
.WithHostStorage(storage)
</code></pre>
<p class="normal">The emulator relies on the <code class="inlineCode">Aspire.Hosting.Azure.Storage</code> NuGet package, which must be added to the App Host project.</p>
<p class="normal">References to other Azure resources can be added with <code class="inlineCode">WithReference</code>, as usual. For instance, an Azure function with a Blob storage trigger on an emulated blob may be defined as follows:</p>
<pre class="programlisting code"><code class="hljs-code">var storage = builder.AddAzureStorage("storage")
                     .RunAsEmulator();
var blob = storage.AddBlobs("blob");
var myFunction = builder.AddAzureFunctionsProject&lt;Projects.MyFunctionsProject&gt;(
    " MyFunction ")
.WithHostStorage(storage)
.WithReference(blob);
</code></pre>
<p class="normal">This concludes <a id="_idIndexMarker1017"/>our .NET Aspire description. In the next <a id="_idIndexMarker1018"/>section, we will see how to translate the Kubernetes example of <a href="Chapter_8.xhtml#_idTextAnchor205"><em class="italic">Chapter 8</em></a>, <em class="italic">Practical Microservices Organization with Kubernetes</em>, to run with Aspire. Finally, the <em class="italic">Deploying a .NET Aspire project</em> section will discuss how to use Aspire to generate the code for our target orchestrators, either manually or with automatic code generator tools.</p>
<h1 class="heading-1" id="_idParaDest-252"><a id="_idTextAnchor361"/>Using .NET Aspire in practice</h1>
<p class="normal">In this section, we will adapt the Kubernetes example of <a href="Chapter_8.xhtml#_idTextAnchor205"><em class="italic">Chapter 8</em></a>, <em class="italic">Practical Microservices Organization with Kubernetes</em>, to run with Aspire. As a first step, let’s copy the whole solution folder into <a id="_idIndexMarker1019"/>another in a different location, so we can modify it without destroying the previous version.</p>
<p class="normal">Then, let’s execute the following steps to prepare the overall solution:</p>
<ol>
<li class="numberedList" value="1">Add <a id="_idTextAnchor362"/>a new App Host project to the solution and call it <code class="codeHighlighted" style="font-weight: bold;">CarSharingAppHost</code>.</li>
<li class="numberedList">Add a new .NET Aspire Service Defaults project to the solution and call it<a id="_idTextAnchor363"/> <code class="codeHighlighted" style="font-weight: bold;">CarSharingServiceDefaults</code>.</li>
<li class="numberedList">Add a reference to the <code class="codeHighlighted" style="font-weight: bold;">FakeSource</code>, <code class="codeHighlighted" style="font-weight: bold;">FakeDestination</code>, and <code class="codeHighlighted" style="font-weight: bold;">RoutesPlanning</code> projects to the <code class="codeHighlighted" style="font-weight: bold;">CarSharingAppHost</code> project.</li>
<li class="numberedList">Add a reference to the <code class="codeHighlighted" style="font-weight: bold;">CarSharingServiceDefaults</code> project to the <code class="codeHighlighted" style="font-weight: bold;">FakeSource</code>, <code class="codeHighlighted" style="font-weight: bold;">FakeDestination</code>, and <code class="codeHighlighted" style="font-weight: bold;">RoutesPlanning</code> projects.</li>
<li class="numberedList">Right-click on the <code class="codeHighlighted" style="font-weight: bold;">CarSharingAppHost</code> project and, in the menu that appears, select <strong class="screenText">Set as Startup Project</strong>.</li>
</ol>
<p class="normal">The preceding steps prepare the solution for .NET Aspire. Now, let’s start modifying the code. As a first step, we must add service defaults to all the microservices. Therefore, let’s add <code class="inlineCode">builder.AddServiceDefaults();</code> to the <code class="inlineCode">program.cs</code> file of the <code class="codeHighlighted" style="font-weight: bold;">FakeSource</code>, <code class="codeHighlighted" style="font-weight: bold;">FakeDestination</code>, and <code class="codeHighlighted" style="font-weight: bold;">RoutesPlanning</code> projects. Then, we must add <code class="inlineCode">app.MapDefaultEndpoints()</code>, which adds health endpoints just to the <code class="inlineCode">program.cs</code> file of the <code class="codeHighlighted" style="font-weight: bold;">RoutesPlanning</code> project, since it is the only web project that we have among our microservices. It must be placed as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">var app = builder.Build();
<strong class="hljs-slc">app.</strong><strong class="hljs-title-slc">MapDefaultEndpoints</strong><strong class="hljs-slc">();</strong>
</code></pre>
<p class="normal">Now, let’s remember that we added all the microservices parameters as environment variables in their <code class="inlineCode">Properties/launcheSettings.json</code> file. We placed them in the Docker launch settings. Now, since these projects will not use Docker anymore while running in Aspire, we must <a id="_idIndexMarker1020"/>copy all these definitions into the other launch setting profile.</p>
<p class="normal">This is the launch settings code of the <code class="codeHighlighted" style="font-weight: bold;">RoutesPlanning</code> project after this change:</p>
<pre class="programlisting code"><code class="hljs-code">{
  "profiles": {
    "http": {
      "commandName": "Project",
      "environmentVariables": {
       
        //place here your environment variables
"ConnectionStrings__DefaultConnection": "Server=localhost;
            Database=RoutesPlanning;User Id=sa;Password=Passw0rd_;
            Trust Server Certificate=True;MultipleActiveResultSets=true",
        "ConnectionStrings__RabbitMQConnection": "host=localhost:5672;
 username=guest;password=_myguest;
publisherConfirms=true;timeout=10”,
        "Messages__SubscriptionIdPrefix": "routesPlanning",
        "Topology__MaxDistanceKm": "50",
        "Topology__MaxMatches": "5",
        "Timing__HousekeepingIntervalHours": "48",
        "Timing__HousekeepingDelayDays": "10",
        "Timing__OutputEmptyDelayMS": "500",
        "Timing__OutputBatchCount": "10",
        "Timing__OutputRequeueDelayMin": "5",
        "Timing__OutputCircuitBreakMin": "4"
      },
      "dotnetRunMessages": true,
      "applicationUrl": "http://localhost:5212"
    },
    "Container (Dockerfile)": {
…
…
</code></pre>
<p class="normal">We replaced <code class="inlineCode">host.docker.internal</code> with <code class="inlineCode">localhost</code> in all connection strings as, when running in Aspire, our microservices will not access the SQL database and the RabbitMQ message broker from inside a Docker container image but directly from the development machine.</p>
<p class="normal">Similarly, the launch <a id="_idIndexMarker1021"/>settings of <code class="codeHighlighted" style="font-weight: bold;">FakeSource</code> become the following:</p>
<pre class="programlisting code"><code class="hljs-code">{
  "profiles": {
    "FakeSource": {
      "commandName": "Project",
      "environmentVariables": {
        "DOTNET_ENVIRONMENT": "Development",
        "ConnectionStrings__RabbitMQConnection":
"host=localhost:5672;username=guest;
            password=_myguest;publisherConfirms=true;timeout=10"
      },
      "dotnetRunMessages": true
    },
    "Container (Dockerfile)": {
      "commandName": "Docker",
      "environmentVariables": {
        "ConnectionStrings__RabbitMQConnection":
 “host=host.docker.internal:5672;
 username=guest;password=_myguest;
            publisherConfirms=true;timeout=10”
      }
    }
  },
  "$schema": "https://json.schemastore.org/launchsettings.json"
}
</code></pre>
<p class="normal">Finally, the launch settings of <code class="codeHighlighted" style="font-weight: bold;">FakeDestination</code> become the following:</p>
<pre class="programlisting code"><code class="hljs-code">{
  "profiles": {
    "FakeDestination": {
      "commandName": "Project",
      "environmentVariables": {
        "DOTNET_ENVIRONMENT": "Development",
        "ConnectionStrings__RabbitMQConnection":
"host=localhost:5672;username=guest;
            password=_myguest;publisherConfirms=true;timeout=10"
      },
      "dotnetRunMessages": true
    },
    "Container (Dockerfile)": {
      "commandName": "Docker",
      "environmentVariables": {
        "ConnectionStrings__RabbitMQConnection":
 “host=host.docker.internal:5672;
 username=guest;password=_myguest;
 publisherConfirms=true;timeout=10"
      }
    }
  },
  "$schema": "https://json.schemastore.org/launchsettings.json"
}
</code></pre>
<p class="normal">The content of both the RabbitMQ and SQL Server connection strings shows that we decided to use pre-existing RabbitMQ and SQL instances that run outside of Aspire. This was the simplest choice for this solution since the whole code was already organized to run this way. However, it is often the best choice when we start a solution from scratch since instances that live when the App <a id="_idIndexMarker1022"/>Host is not running are simpler to handle during development.</p>
<p class="normal">In fact, we can pass database migrations to the database with no need to launch the App Host while we are working with migrations. Similarly, we can inspect RabbitMQ from its browser console when the App Host is not running.</p>
<p class="normal">Another alternative would be to split the whole App Host configuration code into two code zones. The first code zone contains databases and message brokers that we need to manipulate when the application is not running, and the second code zone contains all other resources and microservices configuration.</p>
<p class="normal">When we need to manipulate the resources defined in the first code zone, we comment out the whole second zone code and run the App Host. After finishing working with migrations and inspecting the RabbitMQ queue, we uncomment the second code zone that defines and configures all other resources and microservices, and run the whole application.</p>
<p class="normal">The preceding methodology can be refined by defining a Boolean App Host environment variable that selects the second configuration zone with an <code class="inlineCode">if</code> statement.</p>
<p class="normal">After this premise, we can write our configuration code in the App Host <code class="inlineCode">program.cs</code> file.</p>
<p class="normal">Since, in our case, each microservice has multiple launch settings profiles, we must specify the right profile to use with each microservice in the <code class="inlineCode">AddProject</code> fluent interface method.</p>
<p class="normal">Moreover, since <code class="codeHighlighted" style="font-weight: bold;">FakeSource</code> sends data to the <code class="codeHighlighted" style="font-weight: bold;">RoutesPlanning</code> microservice, and the <code class="codeHighlighted" style="font-weight: bold;">RoutesPlanning</code> microservice sends data to the <code class="codeHighlighted" style="font-weight: bold;">FakeDestination</code> service, we must ensure that <code class="codeHighlighted" style="font-weight: bold;">RoutesPlanning</code> starts after <code class="codeHighlighted" style="font-weight: bold;">FakeDestination</code> has been started and <code class="codeHighlighted" style="font-weight: bold;">FakeSource</code> starts only after <code class="codeHighlighted" style="font-weight: bold;">RoutesPlanning</code> has started. We don’t need <code class="inlineCode">WithReference</code> since not all microservices communicate directly, but rather, communicate through a RabbitMQ instance, and <code class="inlineCode">WithReference</code> is only needed to inject information for communicating directly with a resource. We don’t <a id="_idIndexMarker1023"/>need to declare a reference to RabbitMQ either, since we are using an external RabbitMQ instance that runs outside of the App Host, so we already have its connection string.</p>
<p class="normal">It is easy to fulfill all constraints with the following configuration code:</p>
<pre class="programlisting code"><code class="hljs-code">var builder = DistributedApplication.CreateBuilder(args);
var fakeDestination=builder.AddProject&lt;Projects.FakeDestination&gt;("fakedestination",
 "FakeDestination");
var routesPlanning = builder.AddProject&lt;Projects.RoutesPlanning&gt;("routesplanning", "http")
    .WaitFor(fakeDestination);
builder.AddProject&lt;Projects.FakeSource&gt;("fakesource", "FakeSource")
    .WaitFor(routesPlanning);
builder.Build().Run();
</code></pre>
<p class="normal">Here, the second argument of each <code class="inlineCode">AddProject</code> call is the name of the launch profile to use for each microservice.</p>
<p class="normal">Let’s ensure that both the RabbitMQ and SQL Server external Docker containers are running, and then launch our solution.</p>
<p class="normal">If everything is working properly, you should see something like the following figure in the Aspire browser console:</p>
<figure class="mediaobject"><img alt="Figure 12.2: App Host resources list" src="img/B31916_12_2.png"/></figure>
<p class="packt_figref">Figure 12.2: App Host resources list</p>
<p class="normal">Let’s click the <strong class="keyWord">Console</strong> icon in the left menu to inspect all microservice logs. Let’s choose <strong class="screenText">fakedestination</strong>; you should see something like the following figure:</p>
<figure class="mediaobject"><img alt="Figure 12.3: The fakedestination console" src="img/B31916_12_3.png"/></figure>
<p class="packt_figref">Figure 12.3: The fakedestination console</p>
<p class="normal">Logs should contain information about the connection with RabbitMQ through EasyNetQ and about the worker service start. Finally, you should see two messages coming from the <code class="codeHighlighted" style="font-weight: bold;">RoutesPlanning</code> microservice that declare that two matches have been found.</p>
<p class="normal">Since all Microservices <a id="_idIndexMarker1024"/>use the same RabbitMQ connection string, we can improve the whole code organization by removing it from each microservice’s launch settings and factoring it out into the App Host configuration with the help of <code class="inlineCode">AddConnectionString</code>, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">builder.AddConnectionString("RabbitMQParameterName", "RabbitMQConnection");
</code></pre>
<p class="normal">Here, <code class="inlineCode">RabbitMQParameterNam</code>e is the name of the App Host configuration parameter that contains the actual connection string:</p>
<pre class="programlisting code"><code class="hljs-code">{
  "Parameters": {
    "RabbitMQParameterName": "host=localhost:5672;username=guest;
            password=_myguest;
        publisherConfirms=true;timeout=10"
    }
}
</code></pre>
<p class="normal">In the next subsection, we will describe how to modify the code to run RabbitMQ inside the App Host.</p>
<h2 class="heading-2" id="_idParaDest-253"><a id="_idTextAnchor364"/>RabbitMQ integration</h2>
<p class="normal">RabbitMQ is supported by Aspire integration so we can run it also inside the App Host. The first step for <a id="_idIndexMarker1025"/>doing this is the addition of the <code class="inlineCode">Aspire.Hosting.RabbitMQ</code> NuGet package.</p>
<p class="normal">Then, we need <a id="_idIndexMarker1026"/>to configure the RabbitMQ instance:</p>
<pre class="programlisting code"><code class="hljs-code">var username = builder.AddParameter("rabbitmqusername", secret: true);
var password = builder.AddParameter("rabbitmqpassword", secret: true);
var rabbitmq = builder.AddRabbitMQ("RabbitMQConnection", username, password)
       .WithManagementPlugin()
       .WithDataVolume(isReadOnly: false);
</code></pre>
<p class="normal">Here, we added a volume to persist data after the App Host is shut down and required the installation of the browser management console, so we can inspect all queues and can also configure the instance. The actual username and password must be provided in the <code class="codeHighlighted" style="font-weight: bold;">"Parameters"</code> section of the App Host configuration file:</p>
<pre class="programlisting code"><code class="hljs-code">{
  "Parameters": {
    "rabbitmqusername": "&lt;username&gt;",
    "rabbitmqpassword": "&lt;password&gt;"
    }
}
</code></pre>
<p class="normal">After that, we must declare a reference to this RabbitMQ instance in all microservices with <code class="inlineCode">WithReference(rabbitmq)</code>.</p>
<p class="normal">At this point, we need to remove the RabbitMQ connection strings from all the launch settings of our microservices since the same connection string will now be injected by the App Host.</p>
<p class="normal">Unfortunately, the injected connection string is not in the format needed by EasyNetQ but has the following format:</p>
<pre class="programlisting code"><code class="hljs-code"><code class="inlineCode">amqp://username:password@&lt;host url&gt;:5672</code>.
</code></pre>
<p class="normal">The simplest way to solve this problem is to write a string manipulation method that converts this string and adds all other auxiliary information. We can define this method in the Service Defaults project so it will be available to all microservices.</p>
<p class="normal">We need just to extract the URL, username, and password and then we may use them to build the connection string in the format needed by EasyNetQ. This can be done by splitting the string on <code class="inlineCode">//</code>, then on <code class="inlineCode">@</code>, and finally, on <code class="inlineCode">:</code> to get username and password.</p>
<p class="normal">In the last section, we will describe how to get the configuration needed by our target orchestrator for an Aspire project.</p>
<h1 class="heading-1" id="_idParaDest-254"><a id="_idTextAnchor365"/>Deploying a .NET Aspire project</h1>
<p class="normal">.NET Aspire can <a id="_idIndexMarker1027"/>be used to test an application or a small part <a id="_idIndexMarker1028"/>of a complex microservice application on the development machine, thus replacing minikube and Docker networks.</p>
<p class="normal">However, small applications can be completely implemented in Aspire and then the Aspire code can be used to generate the configuration of the target orchestrator. This generation can be manual or based on automatic tools.</p>
<p class="normal">Both manual generation and automatic tools rely on a JSON manifest that can be created automatically and that describes the application configuration. The JSON manifest can be generated by adding the following launch profile to the App Host project’s <code class="inlineCode">launchSettings.json</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">"profiles": {
"generate-manifest": {
"commandName": "Project",
"launchBrowser": false,
"dotnetRunMessages": true,
"commandLineArgs": "--publisher manifest --output-path aspire-
                        manifest.json"
}
…
</code></pre>
<p class="normal">Once added to <code class="inlineCode">launchSettings.json</code>, this profile appears in the Visual Studio profile selection combo next to the <strong class="keyWord">Run</strong> button. It is enough to select the <code class="codeHighlighted" style="font-weight: bold;">"generate-manifest"</code> profile and run the solution. When the solution runs, the application is compiled but, instead of running, it creates the JSON manifest in the App Host project folder.</p>
<p class="normal">You can manually read this manifest and use the information it contains to configure your orchestrator, or you can use automatic tools that generate the manifest and use it to automatically configure an orchestrator.</p>
<p class="normal">Visual Studio natively supports the deployment of Azure Container Apps. Publishing to Azure Container Apps is straightforward. It is enough to right-click on the solution’s App Host project and select <strong class="keyWord">Publish</strong>. After that, you can select the Azure Container Apps publish target. The procedure will drive you to connect to your Azure subscription and provide all the information needed to publish the application,</p>
<p class="normal">The <strong class="keyWord">Publish</strong> wizard will <a id="_idIndexMarker1029"/>publish all microservices as Azure Container Apps <a id="_idIndexMarker1030"/>applications and will provision all other resources defined in the App Host in Azure, such as databases and other Azure resources.</p>
<p class="normal">An external tool called Aspir8 (<a href="https://prom3theu5.github.io/aspirational-manifests/getting-started.html">https://prom3theu5.github.io/aspirational-manifests/getting-started.html</a>) is also available, which is capable of deploying the application on <a id="_idIndexMarker1031"/>a Kubernetes cluster. However, in this case, it will create just Kubernetes Deployments and Services.</p>
<p class="normal">Once installed, Aspir8 supports the following commands:</p>
<ul>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;">aspirate init</code>: Initializes the Aspir8 project in the current directory</li>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;">aspirate generate</code>: Generates Kubernetes manifests based on the .NET Aspire app host manifest</li>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;">aspirate apply</code>: Applies the generated Kubernetes manifests to the Kubernetes cluster</li>
<li class="bulletList"><code class="codeHighlighted" style="font-weight: bold;">aspirate destroy</code>: Deletes the resources created by the <code class="codeHighlighted" style="font-weight: bold;">apply</code> command</li>
</ul>
<p class="normal">For a simple application, you can deploy directly on a Kubernetes cluster, and in the case of more complex applications, you can use the Kubernetes manifest as a starting point for designing the needed Kubernetes configuration.</p>
<p class="normal">The <code class="codeHighlighted" style="font-weight: bold;">apply</code> and <code class="codeHighlighted" style="font-weight: bold;">destroy</code> commands need a <code class="codeHighlighted" style="font-weight: bold;">kubectl</code> installation, and all operations are performed using the current <code class="codeHighlighted" style="font-weight: bold;">kubectl</code> context. Please refer to the <em class="italic">Interacting with Kubernetes: kubectl, minikube, and AKS </em>section of<em class="italic"> </em><a href="Chapter_8.xhtml#_idTextAnchor205"><em class="italic">Chapter 8</em></a>, <em class="italic">Practical Microservices Organization with Kubernetes</em>, for a definition of the <code class="codeHighlighted" style="font-weight: bold;">kubectl</code> context.</p>
<p class="normal">If you would like to manually inspect the manifest generated by the App Host, please refer to its official format documentation at <a href="https://learn.microsoft.com/en-us/dotnet/aspire/deployment/manifest-format">https://learn.microsoft.com/en-us/dotnet/aspire/deployment/manifest-format</a>.</p>
<h1 class="heading-1" id="_idParaDest-255"><a id="_idTextAnchor366"/>Summary</h1>
<p class="normal">In this chapter, we described the opportunities and services offered by .NET Aspire. We discussed how to configure a complex application made of microservices and other resources in the App Host project, and discussed in detail how service discovery works both in general and specifically with .NET Aspire.</p>
<p class="normal">We described how environment variables containing all the information needed for the interaction between microservices and resources are automatically injected into all microservices by the App Host.</p>
<p class="normal">Finally, we discussed how Aspire implements observability with the help of telemetry, and how App Host configuration can be used to generate automatic configuration for the target orchestrators.</p>
<p class="normal">This chapter concludes our amazing journey among the concepts and technologies of modern distributed computing. We hope that you enjoyed reading this book as much as we enjoyed writing it.</p>
<h1 class="heading-1" id="_idParaDest-256"><a id="_idTextAnchor367"/>Questions</h1>
<ol>
<li class="numberedList" value="1">What are the Aspire-specific .NET SDK projects?</li>
</ol>
<p class="normal-one">.NET Aspire Starter Project, .NET Aspire Empty Project, .NET Aspire App Host, .NET Aspire Service Defaults, .and various NET Aspire Test projects.</p>
<ol>
<li class="numberedList" value="2">Is service discovery an Aspire-specific feature?</li>
</ol>
<p class="normal-one">No, it is a general .NET feature.</p>
<ol>
<li class="numberedList" value="3">How many service discovery providers come with the Aspire default settings?</li>
</ol>
<p class="normal-one">Just two.</p>
<ol>
<li class="numberedList" value="4">What is the best way to handle pre-existing resources that are not defined with the App Host but are shared by several microservices?</li>
</ol>
<p class="normal-one">The usage of <code class="inlineCode">AddConnectionString</code>.</p>
<ol>
<li class="numberedList" value="5">Does Aspir8 provision Azure resources, too?</li>
</ol>
<p class="normal-one">No, at moment it provisions just Kubernetes resources.</p>
<ol>
<li class="numberedList" value="6">What is the purpose of the <code class="inlineCode">WithReference</code> fluent interface method?</li>
</ol>
<p class="normal-one">Declaring that a resource depends on another resource, meaning it needs information such as, URLs, and connection string, of that resource.</p>
<h1 class="heading-1" id="_idParaDest-257"><a id="_idTextAnchor368"/>Further reading</h1>
<ul>
<li class="bulletList">Official Aspire documentation: <a href="https://learn.microsoft.com/en-us/dotnet/aspire/get-started/aspire-overview">https://learn.microsoft.com/en-us/dotnet/aspire/get-started/aspire-overview</a></li>
<li class="bulletList">All available Aspire integrations: <a href="https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/integrations-overview">https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/integrations-overview</a></li>
<li class="bulletList">App Host configuration manifest format: <a href="https://learn.microsoft.com/en-us/dotnet/aspire/deployment/manifest-format ">https://learn.microsoft.com/en-us/dotnet/aspire/deployment/manifest-format</a></li>
<li class="bulletList">Aspir8: <a href="https://prom3theu5.github.io/aspirational-manifests/getting-started.html">https://prom3theu5.github.io/aspirational-manifests/getting-started.html</a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-258"><a id="_idTextAnchor369"/>Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/PSMCSharp">https://packt.link/PSMCSharp</a></p>
<p class="normal"><img alt="A qr code with black squares  AI-generated content may be incorrect." src="img/B31916_Discord-QR-Code.png"/></p>
</div>


<div><p class="BM-packtLogo"><img alt="" role="presentation" src="img/Packt_Logo_New.png"/></p>
<p class="normal"><a href="http://packtpub.com">packtpub.com</a></p>
<p class="normal">Subscribe to our online digital library for full access to over 7,000 books and videos, as well as industry leading tools to help you plan your personal development and advance your career. For more information, please visit our website.</p>
<h1 class="heading-1" id="_idParaDest-259"><a id="_idTextAnchor370"/>Why subscribe?</h1>
<ul>
<li class="bulletList">Spend less time learning and more time coding with practical eBooks and Videos from over 4,000 industry professionals</li>
<li class="bulletList">Improve your learning with Skill Plans built especially for you</li>
<li class="bulletList">Get a free eBook or video every month</li>
<li class="bulletList">Fully searchable for easy access to vital information</li>
<li class="bulletList">Copy and paste, print, and bookmark content</li>
</ul>
<p class="normal">A<a id="_idTextAnchor371"/>t <a href="http://www.packtpub.com">www.packtpub.com</a>, you can also read a collection of free technical articles, sign up for a range of free newsletters, and receive exclusive discounts and offers on Packt books and eBooks.</p>
<p class="eop"/>
<h1 class="mainHeading" id="_idParaDest-260"><a id="_idTextAnchor372"/>Other Books You May Enjoy</h1>
<p class="normal">If you enjoyed this book, you may be interested in these other books by Packt:</p>
<p class="normal"><a href="https://www.packtpub.com/en-in/product/c-13-and-net-9-modern-cross-platform-development-fundamentals-9781835881231"><img alt="" role="presentation" src="img/9781835881231.jpg"/></a></p>
<p class="normal"><strong class="keyWord">C# 13 and .NET 9 – Modern Cross-Platform Development Fundamentals</strong></p>
<p class="normal">Mark J. Price</p>
<p class="normal">ISBN: 978-1-83588-123-1</p>
<ul>
<li class="bulletList">Discover the new features of .NET 9, including more flexible params and new LINQ like CountBy and Index</li>
<li class="bulletList">Leverage the new ASP.NET Core 9 features for optimized static assets, OpenAPI document generation, and HybridCache</li>
<li class="bulletList">Utilize the native AOT publish capability for faster startup and reduced memory footprint</li>
<li class="bulletList">Build rich web user interface experiences using Blazor in ASP.NET Core 9</li>
<li class="bulletList">Integrate and update databases in your applications using Entity Framework Core 9 models</li>
<li class="bulletList">Query and manipulate data using LINQ</li>
<li class="bulletList">Build powerful services using Minimal APIs</li>
</ul>
<p class="normal"><a href="https://www.packtpub.com/en-in/product/software-architecture-with-c-12-and-net-8-9781805122456"><img alt="" role="presentation" src="img/9781805122456.jpg"/></a></p>
<p class="normal"><strong class="keyWord">Software Architecture with C# 12 and .NET 8</strong></p>
<p class="normal">Gabriel Baptista, Francesco Abbruzzese</p>
<p class="normal">ISBN: 978-1-80512-245-6</p>
<ul>
<li class="bulletList">Program and maintain Azure DevOps and explore GitHub Projects</li>
<li class="bulletList">Manage software requirements to design functional and non-functional needs</li>
<li class="bulletList">Apply architectural approaches such as layered architecture and domain-driven design</li>
<li class="bulletList">Make effective choices between cloud-based and data storage solutions</li>
<li class="bulletList">Implement resilient frontend microservices, worker microservices, and distributed transactions</li>
<li class="bulletList">Understand when to use test-driven development (TDD) and alternative approaches</li>
<li class="bulletList">Choose the best option for cloud development, from IaaS to Serverless</li>
</ul>
<p class="eop"/>
<h1 class="heading-1" id="_idParaDest-261"><a id="_idTextAnchor373"/>Packt is searching for authors like you</h1>
<p class="normal">If you’re interested in becoming an author for Packt, please visit <a href="http://authors.packtpub.com">authors.packtpub.com</a> and apply today. We have worked with thousands of developers and tech professionals, just like you, to help them share their insight with the global tech community. You can make a general application, apply for a specific hot topic that we are recruiting an author for, or submit your own idea.</p>
<p class="eop"/>
<h1 class="heading-1" id="_idParaDest-262"><a id="_idTextAnchor374"/>Share your thoughts</h1>
<p class="normal">Once you’ve read <em class="italic">Practical Serverless and Microservices with C#</em>, we’d love to hear your thoughts! Please <a href="https://packt.link/r/1836642016">click here to go straight to the Amazon review page</a> for this book and share your feedback.</p>
<p class="normal">Your review is important to us and the tech community and will help us make sure we’re delivering excellent quality content.</p>
</div>
</body></html>