<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-302"><a id="_idTextAnchor303"/>14</h1>
			<h1 id="_idParaDest-303"><a id="_idTextAnchor304"/>The One with the Linux Leaps</h1>
			<p><em class="italic">Systems Programming in C# </em><em class="italic">on Linux</em></p>
			<p>I remember the time when only the really cool kids worked on Linux. Windows was for serious people. That was where the work was done. Sure, many servers ran Unix or Linux, but those working on those platforms were considered somewhat weird. They usually had beards, wore sandals, and spoke a language none of the rest of the people had ever heard.</p>
			<p>OK, maybe I am exaggerating. Perhaps this shows how I felt about Linux or how intimidated I was by that operating system and its users. Linux has always been considered a more mature but complex operating system. It is more secure, faster, and better to maintain. It is also more complicated to use. Most of the work is done in the command line, although graphical user interfaces exist.</p>
			<p>These days, things are different. Linux is everywhere. And for good reasons, too – Linux is an excellent operating system to run your system in the current online, connected world.</p>
			<p>With the introduction of <strong class="bold">.NET Core</strong> and <strong class="bold">.NET 5</strong>, developers who traditionally only used Windows can also compile their code to run on Linux. And that opens up a whole new world.</p>
			<p>Of course, there are downsides. Linux is more complex than Windows, especially if you have worked on Windows for a long time. Even though .NET can run on Linux, not all the classes and tools you might be used to are available.</p>
			<p>This chapter is meant to help you get on your way should you want to run your .NET applications on Linux. Don’t worry – I do not want you to start wearing sandals or become a typical 1970s-type developer. That is entirely optional. So, let’s get your inner penguin out and start hacking on Linux!</p>
			<p>In this chapter, we will ask the following questions:</p>
			<ul>
				<li>What is Linux?</li>
				<li>How do I do basic things in Linux?</li>
				<li>How do I develop for Linux?</li>
				<li>How do I deploy to Linux?</li>
				<li>How can I write background services for Linux?</li>
			</ul>
			<p>This chapter contains some history, some theory, and a lot of practical information and samples. Are you ready to follow along?</p>
			<h1 id="_idParaDest-304"><a id="_idTextAnchor305"/>Technical requirements</h1>
			<p>You will find all the code in this chapter in our repository  at this URL: <a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter14">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter14</a>.</p>
			<p>If you want to follow along, you need a Linux machine. But during development, you actually do not need that. All you need is WSL. <strong class="bold">WSL</strong> stands for <strong class="bold">Windows Subsystem for Linux</strong>. The official name is WSL2, as we are at version 2 these days, but let’s stick with WSL here.</p>
			<p>WSL is a lightweight virtual machine that runs a Linux distribution (I will explain what that is later on) on your Windows machine. You can quickly move to that machine and use it like a “real” Linux machine. You can even deploy directly from Visual Studio and debug your apps on WSL.</p>
			<p>To install WSL, follow these steps:</p>
			<ol>
				<li>In Powershell, use the <code>wsl --install</code> command (you have to be an administrator to do this). Be aware that this might take a couple of gigabytes of hard disk space on your machine.</li>
			</ol>
			<p>And that’s it. No <em class="italic">step 2</em>. You can now go to the <code>Ubuntu</code>. That looks like this:</p>
			<div><div><img alt="Figure 1﻿4.1: Running Ubuntu from the Windows Start menu" src="img/B20924_15_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1: Running Ubuntu from the Windows Start menu</p>
			<p>Alternatively, you can install other versions of Linux, but I will use <strong class="bold">Ubuntu 20.04</strong> in this book. What you pick doesn’t matter; just do what you feel most comfortable with.</p>
			<p>Alternatively, you can create a virtual machine using HyperV, deploy a Docker container with Linux, get a second machine to install Linux on, or run Linux from a bootable USB stick. The choice is yours.</p>
			<h1 id="_idParaDest-305"><a id="_idTextAnchor306"/>An overview of Linux</h1>
			<p>Before<a id="_idIndexMarker1127"/> discussing how to program for Linux, we should discuss what it is. The short answer is that it is an operating system. While that is absolutely true, it does not sufficiently explain all that Linux can do. I can say that a bike is a transporting device, but that also applies to the Saturn 5 rocket that took astronauts to the moon. We need a bit more information.</p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor307"/>A short history of Linux</h2>
			<p>The history <a id="_idIndexMarker1128"/>of Linux is quite fascinating. Understanding the timeline and circumstances under which it was developed can help you appreciate some of the design decisions and choices. So, here is a short timeline of the history of Linux:</p>
			<ol>
				<li><strong class="bold">Early beginnings</strong><ul><li>In 1983, Richard Stallman announced the GNU Project. The idea was to create a free Unix-like operating system. Unix was the leading operating system in those days. The GNU Project developed many components, but one key piece, the kernel, was missing.</li><li>In 1987, Andrew S. Tanenbaum created Minix. Minix was a Unix-like system. It was intended for educational purposes and was very popular among students. One of them was a young man named Linus Torvalds.</li></ul></li>
				<li><strong class="bold">The birth </strong><strong class="bold">of Linux</strong><ul><li>In 1991, Linus Torvalds, a student at the University of Helsinki in Finland, started developing his kernel. It was just a hobby; he wanted to have something to do. On August 25, 1991, he announced his project in a newsgroup posting, seeking input from others. This is what later became the Linux kernel.</li><li>On 5th October, 1991, Torvalds released version 0.02 of Linux. It could run Bash (a terminal) and GCC (a C-compiler).</li></ul></li>
				<li><strong class="bold">Development </strong><strong class="bold">and growth</strong><ul><li>In 1992, Linux was released under the GNU <strong class="bold">General Public License</strong> (<strong class="bold">GPL</strong>), allowing anyone to use, modify, and distribute the software.</li><li>In the <a id="_idIndexMarker1129"/>mid 1990s, Linux snowballed in popularity. Distributions, such as Slackware and Debian, were both released in 1993.</li><li>In 1994, Linux version 1.0 was released. It was a significant milestone; this was the first stable release.</li></ul></li>
				<li><strong class="bold">Commercial and </strong><strong class="bold">community expansion</strong><ul><li>In 1996, Tux the Penguin was chosen as the official Linux mascot.</li><li>The late 1990s saw companies such as Red Hat and SUSE begin to offer commercial Linux distributions. Since these also included support, this was the moment enterprises jumped on board.</li><li>In 1999, IBM announced support for Linux.</li></ul></li>
				<li><strong class="bold">The 21st century and </strong><strong class="bold">mainstream adoption</strong><ul><li>In 2001, version 2.4 of the Kernel was released, including USB, PC cards, and other hardware support.</li><li>2002–2003 saw major companies such as HP and Dell offering Linux on their servers.</li><li>In 2004, Canonical released its Linux distribution, which was way more user-friendly. This enabled the general public to use it as well.</li><li>In 2005, Linus Torvalds released a side project called Git. Yes, that Git. The tool you probably use every day. Git was an essential tool for Linux development.</li></ul></li>
				<li><strong class="bold">The </strong><strong class="bold">modern era</strong><ul><li>In 2011, Linux was the dominant operating system in the server market. It powers the majority of web servers, including those of major companies such as Google, Amazon, and Facebook.</li><li>In 2013, Google released Android, a mobile, Linux-based smartphone operating system.</li><li>In the 2020s, Linux continues to dominate the server space, cloud infrastructure, supercomputing, and IOT devices.</li></ul></li>
			</ol>
			<p>One of the key<a id="_idIndexMarker1130"/> factors that led to the success of Linux was its open source nature. Everybody can look at the sources, download them, adopt them, and do whatever they want. And it is and always will be for free.</p>
			<p>Will all this in mind, it is no wonder that we, as system programmers, also need to learn about Linux.</p>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor308"/>What is Linux?</h2>
			<p>The name<a id="_idIndexMarker1131"/> Linux itself can be confusing at times. Let me shed some light on that and help you clarify things.</p>
			<h3>The Linux kernel</h3>
			<p>The <strong class="bold">Linux kernel</strong> is <a id="_idIndexMarker1132"/>the heart of what we call Linux. It is the core of the operating system. The <a id="_idIndexMarker1133"/>kernel manages the systems’ hardware and resources, such as memory and CPUs. Some of the key responsibilities of the Kernel are as follows:</p>
			<ul>
				<li><strong class="bold">Process management</strong>: It decides which process runs and for how long</li>
				<li><strong class="bold">Memory management</strong>: It keeps track of every byte in the systems’ memory and manages the allocation and deallocation of memory space</li>
				<li><strong class="bold">Device management</strong>: It manages communications with all devices attached to the system</li>
				<li><strong class="bold">System calls</strong>: It also provides an interface between the aforementioned systems and the applications that want to use them</li>
			</ul>
			<p>The kernel is comparable <a id="_idIndexMarker1134"/>with the <strong class="bold">Windows </strong><strong class="bold">NT kernel</strong>.</p>
			<h3>Other components</h3>
			<p>Linux usually<a id="_idIndexMarker1135"/> comes with a set of other components as well. Some of the most commonly found components are as follows:</p>
			<ul>
				<li><strong class="bold">System libraries</strong>: These<a id="_idIndexMarker1136"/> are essential collections of functions that programs can use to perform tasks, such as file handling and mathematical computations. A good example is the GNU C library, the foundation for most C or C++ programs.</li>
				<li><code>init</code> program. This program manages system startup. Other examples are Bash, a shell program, and various command-line tools.</li>
				<li><strong class="bold">Daemons</strong>: These<a id="_idIndexMarker1138"/> are background services that perform various<a id="_idIndexMarker1139"/> tasks, such as handling print jobs, managing network connections, or scheduling tasks.</li>
			</ul>
			<p class="callout-heading">Bash? What is that?</p>
			<p class="callout">Names of software or parts in Linux differ from the names you’ll find in Windows. Windows is more serious in its naming, while Linux is more playful. <strong class="bold">Bash</strong>, for instance, stands for <strong class="bold">Bourne Again Shell</strong>, named <a id="_idIndexMarker1140"/>after its creator, Stephen Bourne. He wanted to create a better shell than the most used shell back then – the Thompson shell. So he merged “born again” with his own surname and came up with this new name. You’ll find these kinds of names a lot when working with Linux!</p>
			<p>There are a lot more components, and sometimes, the choice of where to place components might seem arbitrary. But in general, this distinction works.</p>
			<h3>Added software</h3>
			<p>When you<a id="_idIndexMarker1141"/> install Linux, you often get a lot more software. These are the user-facing programs and the software that the users interact with. There are command-line-based programs and GUI-based programs. Which ones are distributed depends on what package you have downloaded or purchased.</p>
			<h3>Distributions</h3>
			<p>A <a id="_idIndexMarker1142"/>Linux <code>Ubuntu</code> in the Windows Store and click <strong class="bold">Get</strong>.</p>
			<p>Hundreds of distros are available, mostly for free, but some you have to pay for. The following table is a list of the most used distros, grouped by usage category:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-13">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Category</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Distribution</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">General </strong><strong class="bold">desktop use</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Ubuntu</p>
						</td>
						<td class="No-Table-Style">
							<p>Known for its user-friendliness, large community, and robust support</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Linux Mint</p>
						</td>
						<td class="No-Table-Style">
							<p>Based on Ubuntu, popular due to its ease of use and traditional desktop environment</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Fedora</p>
						</td>
						<td class="No-Table-Style">
							<p>Known for its cutting-edge features and close relationship with Red Hat</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Lightweight</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Lubuntu</p>
						</td>
						<td class="No-Table-Style">
							<p>A lighter, faster, and energy-saving variant of Ubuntu that uses LXQt</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Xubuntu</p>
						</td>
						<td class="No-Table-Style">
							<p>An official Ubuntu variant that uses the XFCE desktop environment</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Puppy Linux</p>
						</td>
						<td class="No-Table-Style">
							<p>Extremely lightweight, designed to run on older hardware</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Privacy </strong><strong class="bold">and security</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Tails</p>
						</td>
						<td class="No-Table-Style">
							<p>Aimed at preserving privacy and anonymity, based on Debian</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Qubes OS</p>
						</td>
						<td class="No-Table-Style">
							<p>Focuses on security through isolation, using virtual machines</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Kali Linux</p>
						</td>
						<td class="No-Table-Style">
							<p>Designed for penetration testing and security auditing</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Server </strong><strong class="bold">and enterprise</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>CentOS/AlmaLinux/Rocky Linux</p>
						</td>
						<td class="No-Table-Style">
							<p>Community-supported rebuilds of <strong class="bold">Red Hat Enterprise </strong><strong class="bold">Linux</strong> (<strong class="bold">RHEL</strong>)</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Ubuntu Server</p>
						</td>
						<td class="No-Table-Style">
							<p>The server edition of Ubuntu, known for its ease of use and broad support</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Debian</p>
						</td>
						<td class="No-Table-Style">
							<p>Known for its stability and robustness, often used on servers</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Development</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Arch Linux</p>
						</td>
						<td class="No-Table-Style">
							<p>Favored by developers for its simplicity and control</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Fedora</p>
						</td>
						<td class="No-Table-Style">
							<p>Offers cutting-edge software and technologies</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>openSUSE</p>
						</td>
						<td class="No-Table-Style">
							<p>Known for its developer-friendly tools and YaST configuration tool</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Media </strong><strong class="bold">production</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Ubuntu Studio</p>
						</td>
						<td class="No-Table-Style">
							<p>Specifically tailored for audio, video, and graphic design</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>AV Linux</p>
						</td>
						<td class="No-Table-Style">
							<p>Custom-built for multimedia content creators</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Fedora Design Suite</p>
						</td>
						<td class="No-Table-Style">
							<p>Comes with a range of open source creative applications</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Education</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Edubuntu</p>
						</td>
						<td class="No-Table-Style">
							<p>An Ubuntu flavor designed for use in classrooms and educational environments</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Kano OS</p>
						</td>
						<td class="No-Table-Style">
							<p>Designed for use with the Kano computer kit, aimed at teaching kids how to code</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Debian Edu/Skolelinux</p>
						</td>
						<td class="No-Table-Style">
							<p>A custom Debian Pure Blend, designed for educational use</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Gaming</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>SteamOS</p>
						</td>
						<td class="No-Table-Style">
							<p>Developed by the Valve Corporation for gaming consoles</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Ubuntu GamePack</p>
						</td>
						<td class="No-Table-Style">
							<p>Comes pre-installed with many games and emulators</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Lakka</p>
						</td>
						<td class="No-Table-Style">
							<p>A lightweight Linux distribution that transforms a small computer into a full-blown game console</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Special </strong><strong class="bold">Purpose</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Raspberry Pi OS (formerly Raspbian)</p>
						</td>
						<td class="No-Table-Style">
							<p>Optimized for the Raspberry Pi hardware</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Clear Linux</p>
						</td>
						<td class="No-Table-Style">
							<p>Developed by Intel, optimized for performance and security on Intel hardware</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Tiny Core Linux</p>
						</td>
						<td class="No-Table-Style">
							<p>An extremely small, highly modular, and flexible Linux distribution</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 14.1: Some of the available Linux distros</p>
			<p>As you<a id="_idIndexMarker1143"/> can see, there is a distro tailored just for you. However, remember that the kernel is probably the same or at least very similar for all of them. The biggest difference between the distros is the added software and the configuration you get out of the box.</p>
			<h1 id="_idParaDest-308"><a id="_idTextAnchor309"/>A quick primer to use Linux</h1>
			<p>In the<a id="_idIndexMarker1144"/> early days of my career, I knew I was very good with computers. They held no surprises for me. I knew how to control them; I was the master of the machine. That lasted until I sat behind my first Linux machine. That was when I realized I only knew a lot about Windows and how to use that platform. I was at a loss. I could not even get the contents of a directory on the screen.</p>
			<p>To my defense, this was in the early 1990s. Linux was just released, and we did not have the wealth of information online that we have today. The World Wide Web had just been invented, search engines did not exist, and information was hard to find. Today, things are more straightforward – there are tons of sources out there that can help you get up to speed with something new.</p>
			<p>I’m going<a id="_idIndexMarker1145"/> to help you learn some of the basics so that you can play around with Linux without pulling your hair out. I am not going to discuss any of the available GUI systems. There are plenty of them, and some of them are very good. But using them is as easy as using Windows. Honestly, real work happens when you are on a command line. So, that is what I focus on from now on.</p>
			<p>I also assume you have figured out how to install WSL on your machine and can open a Terminal. I also have a tip – install the Windows Terminal from the Windows Store. The Windows Terminal is an excellent tool for opening different shells, including Linux ones. This is what it looks like:</p>
			<div><div><img alt="Figure 1﻿4.2: A Terminal application opening a new Linux shell" src="img/B20924_15_2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2: A Terminal application opening a new Linux shell</p>
			<p>You can open multiple windows, each with its shell. You can open a PowerShell window next to a Ubuntu window and even the old-style Command Prompt. You have everything you need ready at your fingertips.</p>
			<p class="callout-heading">Casing – beware!</p>
			<p class="callout">Before we dive into the commands, there is one thing you should know – <em class="italic">Linux is case-sensitive; Windows is not</em>. Trust me – this has tripped up many people in the past and will probably confuse people in the future. So, keep this in mind. A directory can have two files with the same name that only differ in casing. It is possible to have the <code>MyAwesomeApp</code> and <code>myAwesomeApp</code> files in the same place. If you come from a Windows background, you will often make this mistake; you cannot find a file that you know is there, which I see a lot. Check your casing.</p>
			<p>If you have chosen a Terminal, open the shell for Linux. Now, you are ready to try out some commands!</p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor310"/>Basic commands</h2>
			<p>I want to <a id="_idIndexMarker1146"/>give you a list of the most used Linux commands with their equivalents on Windows. But before diving into those lists, I want to share the best command – <code>man</code>. This keyword opens the manual pages for any command you want to learn more about. For instance, the equivalent of <code>dir</code> on Windows is <code>ls</code>. Type <code>man ls</code> and press <em class="italic">Enter</em> to learn more about it. Doing this results in pages and pages of information about the command, parameters, and examples. This works for almost all commands.</p>
			<h3>Basic navigation and file management</h3>
			<p>Navigating <a id="_idIndexMarker1147"/>the filesystem is probably essential when using an OS. For Linux, you should know these commands:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-11">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Task</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Windows command</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Linux command</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">List </strong><strong class="bold">directory contents</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>dir</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>ls</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Lists files and directories in the current path</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Change directory</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>cd</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>cd</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Changes the current directory</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Print </strong><strong class="bold">working directory</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>cd</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>pwd</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Displays the current directory</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Copy files</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>copy</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>cp</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Copies files</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Move/rename files</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>move</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>mv</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Moves or renames files</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Delete files</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>del</code> or <code>erase</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>rm</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Removes files</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Delete directories</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>rmdir</code> or <code>rd</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>rmdir</code> or <code>rm -r</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Removes directories</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Create directories</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>mkdir</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>mkdir</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Creates directories</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 14.2: Navigation and file management commands</p>
			<p>The <a id="_idIndexMarker1148"/>commands work more or less as you would expect. So, try them!</p>
			<h3>File viewing and editing</h3>
			<p>If you <a id="_idIndexMarker1149"/>want to learn more about the contents of a file or edit the contents, these commands are there to do just that:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table003-7">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Task</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Windows c</strong><strong class="bold">ommand</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Linux command</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">View </strong><strong class="bold">file contents</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>type</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>cat</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Displays file contents</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Edit files</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>notepad</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>nano</code>, <code>vi</code>, or <code>vim</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Edits files</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">View file </strong><strong class="bold">contents (paged)</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>more</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>less</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Views file contents page by page</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 14.3: File viewing and editing</p>
			<p>A word of warning – if you start using VI or VIM for the first time, ensure that you have a web page open with the commands to use in those tools. Working with those tools can be pretty complicated when you have no experience with them!</p>
			<h3>System information and processes</h3>
			<p>If you want<a id="_idIndexMarker1150"/> to learn more about the system you are on or are keen to learn about the running processes, give these commands a try:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table004-5">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Task</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Windows command</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Linux command</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Display </strong><strong class="bold">system info</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>systeminfo</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>uname -a</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Displays system information</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Display </strong><strong class="bold">process info</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>tasklist</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>ps</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Lists running processes</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Kill processes</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>taskkill</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>kill</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Terminates processes</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Show </strong><strong class="bold">disk usage</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>dir </code><code>or chkdsk</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>df</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Displays disk space usage</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Show </strong><strong class="bold">file size</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>dir</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>du</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Displays file and directory sizes</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 14.4: System information and process commands</p>
			<p>These commands are invaluable when you start to write your own software on Linux. Running these commands gives you a lot of information that you might need later on!</p>
			<h3>Network commands</h3>
			<p>As system <a id="_idIndexMarker1151"/>programmers, we often work with networks or have our software communicate over networks. In those cases, it is good to know how to learn more about the network on our systems. These are commands that can help you:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table005-4">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Task</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Windows command</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Linux command</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Ping</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>ping</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>ping</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Checks network connectivity</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">IP configuration</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>ipconfig</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>ifconfig</code> or <code>ip</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Displays or configures IP network settings</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Trace route</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><code>tracert</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>traceroute</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Traces the path to a network host</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 14.5: Networking commands</p>
			<p>Most of these <a id="_idIndexMarker1152"/>commands are similar to their Windows counterparts, so you should have no problem remembering and using them.</p>
			<h3>Package management</h3>
			<p>Many <a id="_idIndexMarker1153"/>distros come packed with software, but it is very likely your distro might miss something that you may find invaluable. But don’t worry – Linux has tools to install them. This is a short list of some of them:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table006-3">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Task</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Windows command</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Linux c</strong><strong class="bold">ommand</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Install software</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Varies (e.g., <code>msiexec</code>)</p>
						</td>
						<td class="No-Table-Style">
							<p><code>apt-get install</code>, <code>yum install</code>, or <code>dnf install</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Installs software packages</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Update software</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Windows Update</p>
						</td>
						<td class="No-Table-Style">
							<p><code>apt-get update</code> or <code>apt-get upgrade</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Updates software packages</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Remove software</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Varies (e.g., Control Panel)</p>
						</td>
						<td class="No-Table-Style">
							<p><code>apt-get remove</code>, <code>yum remove</code>, or <code>dnf remove</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Removes software packages</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 14.6: Package management commands</p>
			<p>You will <a id="_idIndexMarker1154"/>run into these commands a lot more later on in this chapter.</p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor311"/>Elevated privileges</h2>
			<p>Linux is <a id="_idIndexMarker1155"/>built around security. One of the effects is that you are more or less forced to run all the commands as a regular user. You are not an administrator, even though you logged in as one. You cannot do everything you want.</p>
			<p>You can easily change that. You can give yourself root privileges<a id="_idIndexMarker1156"/> using the <code>su</code> command, meaning <strong class="bold">super-user</strong>. <strong class="bold">Root</strong> here means you are at the top level of all user rights; you can do anything you want. However, don’t do that. I have rarely had a reason to become the root of my systems. In the Linux community, becoming root is frowned upon.</p>
			<p>If you need to elevate your rights to do something, use <a id="_idIndexMarker1157"/>the <code>sudo</code> command. This command stands for <code>sudo</code>. If so, you give the command the root rights it might need once, and then the system immediately returns to the normal privilege. Only the command on that line can use these elevated privileges.</p>
			<p>The first time you use <code>sudo</code> in a session, you must supply the administrative password you entered when installing your distro. Your system remembers those credentials for the duration of the session, so you do not have to do that every time.</p>
			<p>Let me show you how that works. I use the <code>whoami</code> command, which provides information about the currently logged-in user. If I use that command, it returns my name. However, when I do that again, I add <code>sudo</code> before it, and it returns <code>root</code>. Immediately after that, it reverts to returning my name. This screenshot shows that in action:</p>
			<div><div><img alt="Figure 1﻿4.3: Sudo in action" src="img/B20924_15_3.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3: Sudo in action</p>
			<p>As you <a id="_idIndexMarker1158"/>can see, it also asks me for my password. If I issue the same or another command and use <code>sudo</code>, it will use the cached credentials. But remember that this is only valid in this session. If I open another Terminal window and repeat the same exercise, the system will ask me for my password again.</p>
			<p>Using <code>sudo</code> is another example of how Linux makes things as secure as possible.</p>
			<p>It’s useful to know many more commands, but this at least gives you a starting point. Remember that <code>man</code> is your friend here!</p>
			<p>Now that you can confidently find your way in your Linux distro, it’s time to see how we can work with the OS as developers.</p>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor312"/>Developing for Linux</h1>
			<p>One of the first pieces <a id="_idIndexMarker1159"/>of software written for Linux was GCC, created in 1991. <code>python3</code> command into the terminal, and you are ready to go. But we do not do Python; we do .NET. And that means we have another road to take.</p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor313"/>Installing .NET on Linux</h2>
			<p>I mentioned <a id="_idIndexMarker1161"/>previously that Linux usually has a lot of development tools pre-installed. However, .NET is not one of those pre-installed environments. The good news is that it is not hard to install.</p>
			<p>Before I tell<a id="_idIndexMarker1162"/> you how to get .NET on the system, I want to discuss my choice of development machines.</p>
			<p>I love Visual Studio. I think it is by far the best IDE available. There are others, and I know many people who prefer other tools over Visual Studio, but I am not one of them.</p>
			<p>One of the IDEs that many people use is <strong class="bold">Visual Studio Code</strong>. And I agree with them that <strong class="bold">VS Code</strong> (to use its shorter name) is a great tool. However, I prefer the richness of the complete edition of Visual Studio when I work on a real-world system.</p>
			<p>If you prefer VS Code, you can use that, of course. You can install VS Code on many different platforms, including Linux. There are many tutorials online that tell you how to do this.</p>
			<p>I have bad and good news if you want to stay with Visual Studio.</p>
			<p>The bad news is that you cannot install Visual Studio on a Linux machine. The good news is that you do not have to. You can install it on your Windows machine and then deploy and debug directly on the Linux system. And that is what we will do in the rest of this chapter.</p>
			<p>However, to run .NET applications on your Linux system, you must have the Runtime. The Runtime contains all that is needed to run your .NET applications. This is great if you want to prepare your production system for your applications. But if you want to debug and test your applications on a Linux machine, you<a id="_idIndexMarker1163"/> also need the <strong class="bold">.NET SDK</strong>. The SDK contains the Runtime, so you do not need to install both.</p>
			<h3>Installing the .NET Runtime</h3>
			<p>Let’s discuss <a id="_idIndexMarker1164"/>installing the Runtime first. Again, you only need the Runtime on machines that will run your software. If you want to compile your code, you need the SDK.</p>
			<p>Open a Terminal on your Linux distro (or a Ubuntu Terminal on your Windows machine).</p>
			<p>Enter the following commands:</p>
			<pre class="console">
sudo apt-get update
sudo apt-get install -y wget apt-transport-https</pre>			<p>The <a id="_idIndexMarker1165"/>first command updates all packages on your system. The second one installs the HTTPS transport software if it is not already there. It is probably already on your system, but this ensures that is the case. We need <code>https</code> to download the software.</p>
			<p>Microsoft ensures all their software is signed, so you can trust it. However, to verify that signature, you need to have their public key. This is how we get that key on our system:</p>
			<pre class="console">
wget https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
sudo dpkg -i packages-microsoft-prod.deb</pre>			<p>These commands get the keys and install them on our system. Now, we can use them to verify the downloads from Microsoft.</p>
			<p>This was all only preparation. Now, it is finally time to install the Runtime. This is how we do that:</p>
			<pre class="console">
sudo apt-get update
sudo apt-get install -y dotnet-runtime-8.0</pre>			<p>First, we make sure everything is updated. Then, we get the Runtime package.</p>
			<p>And that’s it. If this command finishes, we can test it by running the command:</p>
			<pre class="console">
dotnet --list-runtimes</pre>			<p>You should see the .NET 8 Runtime in the (concise) list of runtimes.</p>
			<h3>Installing the SDK</h3>
			<p>If you <a id="_idIndexMarker1166"/>want to build and debug your Linux distro, you need more software. You must install the SDK. Fortunately, that process is almost the same as installing the Runtime. If you have installed the Runtime, you can enter the following command:</p>
			<pre class="console">
sudo apt-get update
sudo apt-get install -y dotnet-sdk-8.0</pre>			<p>This set of commands first updates all packages and then installs the SDK.</p>
			<p>If you haven’t <a id="_idIndexMarker1167"/>installed the Runtime, you first have to repeat all the steps I showed you during the Runtime installation, except for the last one (the installation of the Runtime itself). You still need to update, get, and install the keys.</p>
			<p>Test the installation of the SDK by calling the following:</p>
			<pre class="console">
dotnet --list-sdks</pre>			<p>You should now see a list of the SDKS – well, I say list, but you will probably only see one item.</p>
			<p>You can further test the installation by doing a quick test, like this:</p>
			<pre class="console">
dotnet new console</pre>			<p>This command creates a new console application. When that is done, do this:</p>
			<pre class="console">
dotnet build .</pre>			<p>This builds <code>.csproj</code> in the current folder. The result ends up in the <code>/bin/Debug/net8.0</code> folder. The program’s name is the same as the folder in which you placed your project. If you didn’t create a directory, it is the name of your user. In my case, the program is called <code>dvroegop</code>, so I can run it like this:</p>
			<pre class="console">
./dvroegop</pre>			<p>I can see a friendly <code>Hello, World</code> message, so apparently it all works!</p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor314"/>Running a .NET background worker on Linux</h2>
			<p>We have had<a id="_idIndexMarker1168"/> enough theory for the moment, I think. Let’s get practical. Fire up Visual Studio and start a new background worker project. In the <a id="_idIndexMarker1169"/>wizard, accept all defaults until the project is ready. In the code, we leave everything as it is, including the default template printing a message every second. Run it to see that it all works.</p>
			<p>If all goes well, you will have a new background worker running on Windows. Great! But we have seen tons of those already. Let’s move our program to Linux. To do that, we have to do a couple of things.</p>
			<h3>Run your app in the WSL</h3>
			<p>We can publish <a id="_idIndexMarker1170"/>directly from Visual Studio to your WSL installation. To do that, do the following.</p>
			<p>Open your project, and go to the run menu. In the dropdown, you should see the option to deploy to WSL. This looks like this:</p>
			<div><div><img alt="Figure 1﻿4.4: Use WSL as your debugging environment in Visual Studio" src="img/B20924_15_4.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4: Use WSL as your debugging environment in Visual Studio</p>
			<p>Select the <strong class="bold">WSL</strong> option in the dropdown.</p>
			<p>If you have more than one distro installed in WSL, you might get a warning in Visual Studio that the default WSL does not have the correct SDK installed. If that is the case, just click the <strong class="bold">Install</strong> button to fix it.</p>
			<p>The <code>launchSettings.json</code> file in the <code>Properties</code> folder of your project should also have the WSL option. This determines which distro Visual Studio will launch. If none is specified, it takes the default. In my case, I have both Ubuntu 20 and Ubuntu 22 installed, so I have to make a choice. I can instruct Visual Studio to take version 22 by changing my <code>launchSettings.json</code> to look like this:</p>
			<pre class="source-code">
"WSL": {
  "commandName": "WSL2",
  "environmentVariables": {
    "DOTNET_ENVIRONMENT": "Development"
  },
  "distributionName": "Ubuntu-22.04"</pre>			<p>The<a id="_idIndexMarker1171"/> distribution name is an empty string by default, resulting in Visual Studio using the default environment to run your system. Since I have specified my desired distro name, it uses that distro instead.</p>
			<p>You can change the default distro by opening a command prompt or using the PowerShell Terminal. Then, get the list of installed distros using this command.</p>
			<pre class="console">
wsl –-list</pre>			<p>You will see the list of installed distros on your machine. On my machine, this looks like this:</p>
			<pre class="console">
Windows Subsystem for Linux Distributions:
Ubuntu-22.04 (Default)
docker-desktop-data
docker-desktop
Ubuntu-20.04</pre>			<p>Then, you can pick one to be the default by issuing this command:</p>
			<pre class="console">
wsl –-set-default Ubuntu-22.04</pre>			<p>Of course, you can specify whatever distro you want. I happen to like <code>Ubuntu-22.04</code>.</p>
			<p>What happens is quite interesting. Visual Studio does a lot of work to ensure we do not have to worry about deployment. Here is a simplified overview of what happens when you click <strong class="bold">Run</strong> after you select WSL as your environment:</p>
			<ol>
				<li>Visual Studio builds your project as a cross-platform system.</li>
				<li>Visual Studio then uses WSL to start up an instance of the subsystem.</li>
				<li>Using WSL, Visual Studio then copies all the output files to the subsystem.</li>
				<li>Visual Studio copies VSDBG, which is the remote debugger, to WSL.</li>
				<li>It sets up VSDBG, giving it the proper permissions and enabling network communication.</li>
				<li>Visual Studio then starts VSDBG in the WSL and attaches your application.</li>
				<li>Finally, Visual Studio attaches itself to the running VSDBG instance.</li>
			</ol>
			<p>The result is <a id="_idIndexMarker1172"/>that you can use the IDE just like you are used to. You can set breakpoints, break the application, inspect variables, read system information, and so on. You will see little difference between running your app locally and running it on the WSL.</p>
			<h3>Deploy your app to a Linux environment</h3>
			<p>Running your <a id="_idIndexMarker1173"/>application directly from Visual Studio is pretty cool. Still, ultimately, you want to deploy your app to the system. That’s not that hard to do.</p>
			<p>In Visual Studio, right-click on your project and choose to publish.</p>
			<p>Build a new publish profile like you are used to, with a tiny difference – set the target runtime to <strong class="bold">linux-x64</strong>. Setting this framework will ensure that your app runs on Linux!</p>
			<p>If you want, you can also deploy your app to your WSL distro. You can use a handy shortcut in Windows Explorer – navigate to the <code>\\wsl.localhost\Ubuntu-22.04\home\[username]\</code> folder. Make sure to replace <code>[username]</code> with your username from the WSL. You can create a new folder to act as the publish profile recipient.</p>
			<p>You can enter that folder in the profile’s target location – that way, Visual Studio automatically sends all the artifacts to the right place. My profile settings look like this.</p>
			<div><div><img alt="Figure 1﻿4.5: A publish profile for a Linux/WSL target" src="img/B20924_15_5.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5: A publish profile for a Linux/WSL target</p>
			<p>If you do this<a id="_idIndexMarker1174"/> and then press the <strong class="bold">Publish</strong> button, your code ends up where it needs to be. Now, you can run the program from the WSL distro. Of course, if you have another Linux system running, you can use the same mechanism. If you can’t make a share, you can always publish it locally and then use a tool such as SCP to copy the files.</p>
			<p>I think we have discussed this matter enough. Next, let’s discuss developing for Linux!</p>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor315"/>Make your code cross-platform</h1>
			<p>The beauty of .NET is that it is cross-platform. The IL runs almost everywhere. If you build an application, it will <a id="_idIndexMarker1175"/>work on your Windows and Linux machines.</p>
			<p class="callout-heading">Running an exe on Linux?</p>
			<p class="callout">No, you cannot run your Windows <code>exe</code> on Linux. An EXE file is a typical Windows construct. The file layout is specific to that platform, and Linux systems have another way to handle executables. However, the compiler also produces a DLL file if you build your system. That file can be run with the <code>dotnet</code> command. So, if your system is called <code>MyAwesomeApp.exe</code>, you will also find a <code>MyAwesomeApp.dll</code> in the <code>Build</code> directory. On all supported platforms, you can run your application using the <code>dotnet MyAwesomeApp.dll command</code>, which works on Windows and Linux.</p>
			<p>But that doesn’t mean you can copy your binaries, run them, and expect everything to work fine. There are some caveats you should be aware of. But don’t worry – we’ll cover them one by one here.</p>
			<p class="callout-heading">Permissions in Linux</p>
			<p class="callout">Here is the first caveat – scripts and applications cannot run by default. They do not have the correct permissions. Each file has a set of permissions, telling the OS what it can do with it. These permissions differ per category. There are permissions for the user, a group, and others. The permissions themselves can be read, write, or execute. You use the <code>chmod</code> (<code>man chmod</code> to get all the inside information, but remember that to make your application runnable, you have to use the <code>chmod +x [yourapplicationname]</code> command. The <code>+x</code> part tells Linux you can execute it.</p>
			<p>Once you get the hang of it, you will find it is easy to switch between Windows and Linux. But to be completely honest, I have been known to try the <code>chmod</code> command on my Windows machine. Don’t tell anyone I confessed to this!</p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor316"/>How code can help you</h2>
			<p>The<a id="_idIndexMarker1176"/> people who made .NET have gone out of their way to make it as easy as possible for those who need to support multiple platforms. Whereas in the “old days,” you had to have a lot of compiler directives or even different versions of your code, you can now do a lot in code and have the system figure out how to handle things. Let’s look at some of them.</p>
			<h3>Finding out where you run</h3>
			<p>Now and then, you want to<a id="_idIndexMarker1177"/> know what platform a system runs on. There is a class called <code>OperatingSystem</code> that helps with that. It is a very simple class, but it can be tremendously powerful. Look at the following snippet:</p>
			<pre class="source-code">
if(OperatingSystem.IsWindows())
    _logger.LogInformation("Worker running on Windows");
else if(OperatingSystem.IsLinux())
    _logger.LogInformation("Worker running on Linux");</pre>			<p>The <code>OperatingSystem</code> class has many more methods like this, but I am sure you get the idea. You can also use this class to determine the software’s specific version of a platform if you need to know that. So, all the information you need is available.</p>
			<h3>Paths and directories</h3>
			<p>If you <a id="_idIndexMarker1178"/>played around in WSL using the commands I gave you earlier in this chapter, you might have noticed that paths look quite different from what you may be used to.</p>
			<p>For instance, the path to my home directory when I browse in Windows looks like this:</p>
			<pre class="source-code">
C:\Users\dvroe</pre>			<p>My main drive is the C drive, with a <code>Users</code> folder with a subfolder, <code>dvroe</code>.</p>
			<p>In my Linux distro, my <code>home</code> folder can be found at this location:</p>
			<pre class="source-code">
/home/dvroegop</pre>			<p>Apparently, it can be found by going to the root, then the <code>home</code> subfolder, and finally, to the <code>dvroegop</code> folder.</p>
			<p>There is no mention of a drive. In addition, all the slashes are the other way around.</p>
			<p>Drives are available, but they are in a different place. Linux has a root path called <code>/mnt</code>. You can find a folder for all the drives on your machine in that folder. So, in Windows, the drive is the root of all paths; in Linux, it is a subfolder of <code>/mnt</code>.</p>
			<p>In your code, you<a id="_idIndexMarker1179"/> should never need to worry about what kind of slashes to use or how to structure your path to contain the right drive. The <code>Path</code> class contains all the tools you need. Look at this code:</p>
			<pre class="source-code">
var directorySeparatorChar = Path.DirectorySeparatorChar;
var pathSeparator = Path.PathSeparator;
var currentPath = Directory.GetCurrentDirectory();
var newPath = currentPath + directorySeparatorChar + "newFolder";
var betterWay = Path.Combine(currentPath, "newFolder");
var twoPaths = currentPath + pathSeparator + newPath;
$"DirectorySeparatorChar: {directorySeparatorChar}".Dump(consoleColor);
$"PathSeparator: {pathSeparator}".Dump(consoleColor);
$"Current Path: {currentPath}".Dump(consoleColor);
$"newPath: {newPath}".Dump(consoleColor);
$"betterWay: {betterWay}".Dump(consoleColor);
$"twoPaths: {twoPaths}".Dump(consoleColor);</pre>			<p>In this sample, I combine two parts of a path. You should never do that. I just wanted to show you what happens if you use <code>DirectorySeparator</code>. A better way to do this is to use <code>Path.Combine()</code>, as I also show in this code. That way, you can be sure to always get the right results.</p>
			<p class="callout-heading">A path separator versus a directory separator</p>
			<p class="callout">I have <a id="_idIndexMarker1180"/>shown you both a path separator and a <a id="_idIndexMarker1181"/>directory separator in the sample. Many developers use path separators and directory separators interchangeably, but they are different things in this case. A directory separator is a character that separates different parts of an entire directory name. For <a id="_idIndexMarker1182"/>instance, the <code>c:\users\yourname\mydata</code> path contains the three <code>\</code> directory separators. A path separator is used if you need multiple <a id="_idIndexMarker1183"/>directories in one string.</p>
			<p class="callout">A good example is the <code>%PATH%</code> environment variable, which shows all the directories that Windows uses to search for executables. They come in a long list separated by a path separator. In Windows and Linux, all these characters differ.</p>
			<p>A similar thing<a id="_idIndexMarker1184"/> happens with line endings. Windows uses two characters – return and line feed <code>('\r\n')</code>. Linux uses line feed only – <code>('\n')</code>. If you want to be sure your code works everywhere, use this code:</p>
			<pre class="source-code">
$"End of the output: {Environment.NewLine}".Dump(consoleColor);</pre>			<p>That solves this problem for you.</p>
			<h1 id="_idParaDest-316"><a id="_idTextAnchor317"/>Writing services for Linux</h1>
			<p>This <a id="_idIndexMarker1185"/>book has mentioned background processes quite a lot. We’ve seen how to write them and how to deploy them. But how does that work on Linux? Let’s find out!</p>
			<p>A background service in Linux is<a id="_idIndexMarker1186"/> called a <strong class="bold">daemon</strong>. This software runs in the background and doesn’t immediately interact with a user. That sounds like something we, as system programmers, should recognize.</p>
			<p>We can create a Worker Service in Visual Studio to write such software. Build it, then deploy it to a folder on your Linux distro.</p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor318"/>The service description</h2>
			<p>Before <a id="_idIndexMarker1187"/>you do that, add a new file to the project; this is the system description that Linux needs to register your services.</p>
			<p>I called my file <code>crossplatformservice.service</code>. It looks like this:</p>
			<pre class="source-code">
[Unit]
Description=My .NET Core Worker Service
After=network.target
[Service]
WorkingDirectory=/home/dvroegop/service
ExecStart=/usr/bin/dotnet /home/dvroegop/service/14_CrossPlatformService.dll
Restart=always
# Restart service after 10 seconds if the dotnet service crashes:
RestartSec=10
KillSignal=SIGINT
SyslogIdentifier=crossplatformservice
User=dvroegop
Environment=ASPNETCORE_ENVIRONMENT=Production
[Install]
WantedBy=multi-user.target</pre>			<p>Obviously, you should make sure the paths in this file correspond to your paths. I doubt you have a folder called `dvroegop' on your machine. Let’s investigate what this file does.</p>
			<p>The <code>Unit</code> section <a id="_idIndexMarker1188"/>contains metadata and the dependencies for the service. A <code>Description</code> is a human-readable description.</p>
			<p><code>After</code> specifies when the service should start. Here, we state that the service should start when the network has been initialized.</p>
			<p>The <code>Service</code> section configures how the service should be run and managed. The parts of this section are explained in the following table:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table007-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Element</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>WorkingDirectory</code></p>
						</td>
						<td class="No-Table-Style">
							<p>This is where the application will be executed. Can be used for relative path resolution.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>ExecStart</code></p>
						</td>
						<td class="No-Table-Style">
							<p>This is the command used to start the service.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Restart</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Defines the restart policy. <code>always</code> means it always restarts after a crash or unexpected stop.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>RestartSec</code></p>
						</td>
						<td class="No-Table-Style">
							<p>This is the delay before restarting the service.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>KillSignal</code></p>
						</td>
						<td class="No-Table-Style">
							<p>This defines the signal used to terminate the service. <code>SIGINT</code> is the most used one; we’ll look into this later on.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>SyslogIdentifier</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Sets a name for the service’s log entries.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>User</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Runs the service as a specified user.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Environment</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Sets the environment variables needed for the service.</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 14.7: The service elements for a service description</p>
			<p>Finally, we <a id="_idIndexMarker1189"/>have the <code>Install</code> section. This indicates how and when a service should be installed and started. The <code>WantedBy</code> element specifies the target to which this service should be linked. In our case, we used <code>multi-user.target</code>, which means it runs in a multi-user, non-graphical environment. This is typical for services such as ours.</p>
			<p>Make sure you add this file to your deployment.</p>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor319"/>Installing the service</h2>
			<p>We can <a id="_idIndexMarker1190"/>install the service once you have the binaries and the service description file on your Linux distro. In a Terminal, do the following.</p>
			<p>Move the service description file to the correct directory. If you are in the publish directory on your distro, issue the following command:</p>
			<pre class="console">
sudo mv crossplatformservice.service /etc/systemd/system</pre>			<p>You need to use <code>sudo</code>; a regular user has no right to access that folder.</p>
			<p>Now, we have to restart the system manager configuration. Do that with this command:</p>
			<pre class="console">
sudo systemctl daemon-reload</pre>			<p>Once the configuration is reloaded and has read our service description file, we can enable the service:</p>
			<pre class="console">
sudo systemctl enable crossplatformservice</pre>			<p>The name <code>crossplatformservice</code> is the one that I used in the <code>SyslogIdentifier</code> setting in the description file.</p>
			<p>If the Linux system restarts, our service will also start. But you don’t have to reboot – you can also manually start the service to see whether everything works out fine. Do this with the following command:</p>
			<pre class="console">
sudo systemctl start crossplatformservice</pre>			<p>The results are probably disappointing; you see nothing. But you can verify if it all worked out by using this command:</p>
			<pre class="console">
sudo systemctl status crossplatformservice</pre>			<p>This command returns the status, confirming that everything works as expected.</p>
			<p>If you want more information, you can look in the log files. All logs are collected by Linux, and acquiring them is done with this command:</p>
			<pre class="console">
sudo journalctl -u crossplatformservice</pre>			<p>This command shows the last entries in the logs. Since many applications use the log, we can filter the results to only show the ones belonging to our service. That is what the -u parameter does.</p>
			<p>You should get the expected data on your screen to confirm that the service works!</p>
			<h2 id="_idParaDest-319"><a id="_idTextAnchor320"/>Uninstalling the service</h2>
			<p>You might<a id="_idIndexMarker1191"/> want to get rid of the service on your development machine. That’s not too difficult; just reverse the steps we just took.</p>
			<ol>
				<li>First, stop the service:<pre class="source-code">
<strong class="bold">sudo systemctl stop crossplatformservice</strong></pre></li>				<li>Then, disable the service:<pre class="source-code">
<strong class="bold">sudo systemctl disable crossplatformservice</strong></pre></li>				<li>Remove the service description file:<pre class="source-code">
<strong class="bold">sudo rm /etc/systemd/system/crossplatformservice. Service</strong></pre></li>				<li>After that, reload the daemon configuration:<pre class="source-code">
<strong class="bold">sudo systemctl daemon-reload</strong></pre></li>				<li>And that’s it. To verify that the service really is deleted, use this command:<pre class="source-code">
<strong class="bold">sudo systemctl status crossplatformservice</strong></pre></li>			</ol>
			<p>That last command should return an error, as our service no longer exists.</p>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor321"/>Handling signals</h2>
			<p>In the<a id="_idIndexMarker1192"/> service description file, we told the system that our application could be stopped with the <code>SIGINT</code> signal. But that was not really true, as we haven’t done anything to process signals.</p>
			<p class="callout-heading">What are signals?</p>
			<p class="callout">A signal can be compared to events on a Windows machine, or, if you remember from earlier chapters, instances of Windows messages. In other words, they are messages that are sent to your application. Some are predefined, while others are user-defined, meaning you can also use them to communicate between programs. In this case, we are talking about the two most used messages in Linux. That’s all there is to it.</p>
			<p>Signals are<a id="_idIndexMarker1193"/> ways for the operating system to send messages to your application or service. Two of the most used signals are <code>SIGINT</code> and <code>SIGTERM</code>. The first one, <code>SIGINT</code>, requests an interrupt – the OS wants to stop the service. The second, <code>SIGTERM</code>, is meant to stop the application immediately. I agree that it is hard to see the difference between these two, but there is logic here – <code>SIGINT</code> is usually a response to a user doing something, such as pressing <em class="italic">Ctrl</em> + <em class="italic">C</em>. You could say that a user is responsible for sending <code>SIGINT</code>. The <code>SIGTERM</code> signal is from the OS or other services if they think our service needs to be terminated.</p>
			<p>We must write code to handle these signals and make our application behave nicely.</p>
			<p>To do that, we must import a NuGet package. In this case, we need <code>Mono.Posix.NETStandard</code>.</p>
			<p>Once you have done that, go to the <code>Worker</code> class and add the following method to that class:</p>
			<pre class="source-code">
private void RegisterSignalHandlers()
{
    // This is the default behavior for SIGTERM
    AppDomain.CurrentDomain.ProcessExit +=
        (sender, eventArgs) =&gt; $"Process exit".Dump();
    // Handle the signals
    UnixSignal[] signals =
    {
        new(Signum.SIGINT),
        new(Signum.SIGTERM)
    };
    var signalThread = new Thread(() =&gt;
    {
        while (true)
        {
            var index = UnixSignal.WaitAny(signals);
            SignalHandler(signals[index].Signum);
        }
    })
    {
        IsBackground = true
    };
    signalThread.Start();
}</pre>			<p>This method does <a id="_idIndexMarker1194"/>two things. First, it registers <code>eventhandler</code> for the “normal” <code>ProcessExit</code> event. This event is called when a process needs to terminate and is part of the .NET Runtime. In Linux, this is called when <code>SIGTERM</code> is used.</p>
			<p>Next, we tell the system to listen to the <code>SIGINT</code> and <code>SIGTERM</code> signals. We create an array with these values and start a new background thread. All that the thread does is wait for those signals to arrive. When they do, it calls the <code>SignalHandler()</code> method. This method looks like this:</p>
			<pre class="source-code">
private void SignalHandler(Signum signal)
{
    switch (signal)
    {
        case Signum.SIGINT:
            _logger.LogInformation("Received SIGINT");
            break;
        case Signum.SIGTERM:
            _logger.LogInformation("Received SIGTERM");
            break;
        default:
            _logger.LogInformation($"Received signal {(int)signal}");
            break;
    }
    Environment.Exit(0);
}</pre>			<p>This<a id="_idIndexMarker1195"/> method is simple enough – we write to the log that we received and then terminate the program.</p>
			<p>In the constructor of the <code>Worker</code> class, we add the call to <code>RegisterSignalHandlers()</code>, and then we are good to go.</p>
			<p>Run the program from Linux (not as a service, but as a regular program), press <em class="italic">Ctrl</em> + <em class="italic">C</em>, and note the messages telling you that we managed to capture the signal. Cool, isn’t it?</p>
			<h1 id="_idParaDest-321"><a id="_idTextAnchor322"/>Summing up</h1>
			<p>Now, you should have all the knowledge to start working on Linux programs. Linux is the platform of choice for many services. Services, of course, are something we as system programmers work with all the time. Although a great platform, Linux has a steep learning curve. Many things are similar to what you are used to in Windows but differ slightly, whereas other things are entirely new or unique to the platform.</p>
			<p>It takes time to learn it well. But with what we’ve discussed in this chapter, you are well on your way to feeling at home with Linux. We explored the history of the platform, and we discussed some of its most used commands. We discussed development and looked at how to write daemons for Linux.</p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor323"/>Let’s recap</h2>
			<p>Sit back. Take a deep breath. You’ve made it. You’ve reached the end of the book. And I hope you learned a thing or two.</p>
			<p>Don’t underestimate what we’ve done. We’ve answered so many questions:</p>
			<ul>
				<li>What is systems programming?</li>
				<li>How do we use low-level APIs?</li>
				<li>How do we use the Win32 API?</li>
				<li>How can we make our software run faster?</li>
				<li>How can we make our software memory efficient?</li>
				<li>What is I/O and how do we use it?</li>
				<li>What is the best way to have systems communicate over a network?</li>
				<li>How do we monitor and log what our systems are doing?</li>
				<li>What is the ultimate way to debug these low-level systems?</li>
				<li>How do we even deploy it all?</li>
				<li>How do we work with Linux?</li>
			</ul>
			<p>That’s a lot of information! But you have taken the challenge. You can call yourself a specialist in writing fast-performing, memory-efficient, network-aware, secure, and cross-platform low-level system software. That’s a long title, but you deserve it!</p>
			<p>And don’t forget – these newfound skills made you a better developer. These skills can be applied to all sorts of projects, not only systems programming. The basic principles stand and are applicable everywhere. I look forward to hearing from you and discovering what you are going to do with what you have learned. The best way to learn new techniques is to try them out. So, I urge you to try the samples and write awesome system software. I have faith in you!</p>
		</div>
	</body></html>