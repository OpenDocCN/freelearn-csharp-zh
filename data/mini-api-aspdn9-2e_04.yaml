- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Handling HTTP Methods and Routing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 HTTP 方法与路由
- en: In [*Chapter 2*](B20968_02.xhtml#_idTextAnchor033) , we discussed ways that
    you can define endpoints and use routing within a minimal API. That was from a
    high level.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 2 章*](B20968_02.xhtml#_idTextAnchor033) 中，我们讨论了如何在最小化 API 中定义端点和使用路由的方法。那是一个高层次的观点。
- en: However, in this chapter, we will discuss in more detail how routes and endpoints
    can be configured for the handling of incoming requests. We will go into more
    detail about how you can use route parameters to be more specific about the required
    parameters received by each endpoint, and we will also explore examples of request
    validation, wherein we ensure that the request is properly formed, issuing the
    relevant response as necessary.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章中，我们将更详细地讨论如何配置路由和端点以处理传入的请求。我们将更详细地介绍如何使用路由参数来更具体地说明每个端点接收到的所需参数，我们还将探讨请求验证的示例，确保请求正确形成，并在必要时发出相关响应。
- en: Finally, no API can be deemed reliable if its endpoints do not adequately recover
    from receiving invalid data so we will also explore ways in which validation errors
    can be handled gracefully.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果一个 API 的端点不能充分地从接收无效数据中恢复，那么它就不能被认为是可靠的，因此我们还将探讨如何优雅地处理验证错误。
- en: To gain a better understanding of these topics, we will use an example application
    for managing tasks. The application is part of a productivity suite, which has
    an API for managing to-do lists and projects. By building elements of this API,
    you will gain a more in-depth understanding of how requests are received by minimal
    APIs and how they are handled.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些主题，我们将使用一个用于管理任务的示例应用程序。该应用程序是生产力套件的一部分，它有一个用于管理待办事项列表和项目的 API。通过构建这个
    API 的元素，你将更深入地了解最小化 API 如何接收请求以及如何处理它们。
- en: 'In summary, this chapter will cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本章将涵盖以下主要主题：
- en: Handling requests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理请求
- en: Defining endpoints in the Todo API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Todo API 中定义端点
- en: Managing route parameters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理路由参数
- en: Request validation and error handling
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求验证和错误处理
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter is available in the GitHub repository at: [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)
    .'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在 GitHub 仓库中找到：[https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)。
- en: You can of course follow along and write the code yourself as you read the chapter
    if you have Visual Studio 2022 / Visual Studio Code installed with . NET 9.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了带有 .NET 9 的 Visual Studio 2022 / Visual Studio Code，你当然可以边读章节边编写代码。
- en: Handling requests
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理请求
- en: To handle incoming requests, we first need a set of minimal API endpoints for
    those requests to be sent to. Let’s recap what we explored in [*Chapter 2*](B20968_02.xhtml#_idTextAnchor033)
    , around creating minimal API endpoints with varying HTTP methods ( **GET** ,
    **POST** , **PUT** , **DELETE** , and **PATCH** ). We can refresh our memories
    by creating some static *mock* data that will represent the task entities our
    API is handling. Then, we can define some simple endpoints that manipulate or
    query that data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理传入的请求，我们首先需要一个最小化的 API 端点集合，以便将这些请求发送到。让我们回顾一下在 [*第 2 章*](B20968_02.xhtml#_idTextAnchor033)
    中我们探索的内容，即创建具有不同 HTTP 方法的最小化 API 端点（**GET**、**POST**、**PUT**、**DELETE** 和 **PATCH**）。我们可以通过创建一些静态的
    *模拟* 数据来刷新我们的记忆，这些数据将代表我们的 API 处理的任务实体。然后，我们可以定义一些简单的端点来操作或查询这些数据。
- en: 'Let’s create the mock data first. We’ll do this by creating a simple **TodoItem**
    class, and a static list for instances of this class to reside in:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建模拟数据。我们将通过创建一个简单的 **TodoItem** 类和一个静态列表来实现，该列表将包含这个类的实例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The **TodoItem** class can stay quite simple for the time being. It can be
    expanded upon later with more specific properties as we understand our needs further.
    The same approach can be taken with the next piece of code, which for now will
    be a list of **TodoItem** , simply called **ToDoItems** . In this list, we store
    instances of **TodoItem** to be handled by endpoints during requests. Let’s place
    this list in **Program.cs** :'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，**TodoItem** 类可以保持相当简单。随着我们对需求的进一步了解，它可以扩展到具有更具体属性的类。同样的方法也可以用于下一段代码，目前它将是一个
    **TodoItem** 的列表，简单地称为 **ToDoItems**。在这个列表中，我们存储实例化的 **TodoItem**，以便在请求期间由端点处理。让我们将这个列表放在
    **Program.cs** 中：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have our temporary data storage solution in the form of a list,
    we can focus on creating endpoints for handling requests and managing todo items.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了以列表形式存在的临时数据存储解决方案，我们可以专注于创建处理请求和管理 todo 项的端点。
- en: Defining endpoints in the Todo API
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Todo API 中定义端点
- en: 'It’s advisable to start as simple as possible in creating a minimal API. After
    all, the name *minimal API* connotes simplicity. This isn’t just simplicity for
    simplicity’s sake though. For now, our API only needs to cover one area: todo
    items. Sure, the scope might expand further in the future, and minimal APIs can
    still be crafted in such a way that they are expandable and therefore somewhat
    future-proofed, but until more requirements become apparent (for example, assigning
    to-do items to users, adding to-do items to specific projects, etc.), the aim
    is minimalism. With this in mind, we will, for now, keep our endpoints in **Program.cs**
    .'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建最小 API 时，尽可能简单是明智的。毕竟，*最小 API* 这个名字本身就意味着简单。但这并不仅仅是为了简单。目前，我们的 API 只需要覆盖一个领域：todo
    项。当然，范围可能会在未来进一步扩大，最小 API 仍然可以以可扩展的方式构建，因此具有一定的未来性，但在更多需求变得明显之前（例如，将待办事项分配给用户，将待办事项添加到特定项目等），目标是保持最小化。考虑到这一点，我们现在将保持我们的端点在
    **Program.cs** 中。
- en: 'We should now ask ourselves a simple question: *What do I want to do in* *this
    API?*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该问自己一个简单的问题：*在这个 API 中，我想做什么？*
- en: By this, I mean the actions that the API will need to facilitate. For example,
    fetching todo items, updating todo items, deleting todo items, and so on.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意思是 API 需要促进的动作。例如，获取 todo 项，更新 todo 项，删除 todo 项等。
- en: In understanding the *verbs* that are part of the actions of your API, we can
    identify the required HTTP methods. Consider the basic actions required for todo
    items. We will certainly want to *retrieve* todo items. That will require an HTTP
    **GET** method. Moreover, we will also want to *create* a **TodoItem** object.
    This will require an HTTP **POST** method. Let’s start with the first example,
    retrieving some todo items, and then build up from there.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解构成您 API 行动的一部分的 **动词** 时，我们可以确定所需的 HTTP 方法。考虑对 todo 项的基本操作。我们当然会想要 *检索* todo
    项。这将需要一个 HTTP **GET** 方法。此外，我们还将想要 *创建* 一个 **TodoItem** 对象。这将需要一个 HTTP **POST**
    方法。让我们从第一个例子开始，检索一些 todo 项，然后在此基础上构建。
- en: Getting todo items
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取 todo 项
- en: If you’ve read through [*Chapter 2*](B20968_02.xhtml#_idTextAnchor033) , you
    will have already seen examples of how an HTTP **GET** method can be created as
    an endpoint in minimal APIs. For this project, we will first create an endpoint
    that simply retrieves the contents of **List<TodoItem>** , which we created previously.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经阅读了 [*第 2 章*](B20968_02.xhtml#_idTextAnchor033)，您将已经看到如何在最小 API 中创建 HTTP
    **GET** 方法作为端点的示例。对于这个项目，我们首先创建一个端点，它简单地检索我们之前创建的 **List<TodoItem>** 的内容。
- en: 'To achieve this, we need to *map* an HTTP **GET** method onto the instance
    of **WebApplication** on which our minimal API is running. There are several functions
    within **WebApplication** that achieve this. Each of them is prefixed with the
    word **Map** and followed by the relevant method verb. In this example, we’ll
    use **MapGet()** :'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '为了实现这一点，我们需要将 HTTP **GET** 方法映射到我们的最小 API 所运行的 **WebApplication** 实例上。在 **WebApplication**
    中有几个函数可以实现这一点。每个函数都以单词 **Map** 开头，后面跟着相关的方法动词。在这个例子中，我们将使用 **MapGet()** :'
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code, an HTTP **GET** method has been mapped to the **/todoitems** route,
    meaning that should a user request the API’s base URL, followed by **/todoitems**
    , this endpoint would be reached.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，一个 HTTP **GET** 方法已被映射到 **/todoitems** 路由，这意味着如果用户请求 API 的基本 URL，然后是 **/todoitems**，则会到达此端点。
- en: For example, if our URL is hosted at [https://example.org/reallysimpletodoapi](https://example.org/reallysimpletodoapi)
    , accessing [https://example.org/reallysimpletodoapi/todoitems](https://example.org/reallysimpletodoapi/todoitems)
    will reach this endpoint.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的 URL 域名是 [https://example.org/reallysimpletodoapi](https://example.org/reallysimpletodoapi)，访问
    [https://example.org/reallysimpletodoapi/todoitems](https://example.org/reallysimpletodoapi/todoitems)
    将会到达这个端点。
- en: Now we can get to the handling of the request, which happens in the function
    body. Notice that the endpoint we’ve created has a lambda expression after the
    route definition. The expression body is currently empty. It is within this expression
    body that we will handle the request by retrieving the requested data and responding
    to the client.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以进入请求的处理，这发生在函数体中。注意，我们创建的端点在路由定义之后有一个 lambda 表达式。当前表达式体是空的。我们将在该表达式体中通过检索所需数据并响应用户来处理请求。
- en: In this case, because we are simply returning the contents of the **ToDoItems**
    list, the data is readily available, but how do we get that data back to the client?
    ASP.NET provides us with a helper object in the form of **IResult** , whose **Results**
    object exposes various methods for responding to requests. This takes care of
    the fundamental aspects of returning a response, such as the status code, response
    body, and so on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，因为我们只是返回 **ToDoItems** 列表的内容，数据已经准备好了，但我们如何将数据返回给客户端呢？ASP.NET 提供了一个名为
    **IResult** 的辅助对象，其 **Results** 对象公开了各种用于响应请求的方法。这处理了返回响应的基本方面，如状态码、响应体等。
- en: 'For this simple HTTP **GET** method, we can return an HTTP **200 OK** response
    along with the requested data by simply returning the result of **Results.OK(ToDoItems)**
    . This function generates the relevant status code and takes an argument of type
    **object** , representing the data that should be returned to the client. Once
    added, the endpoint should look like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的 HTTP **GET** 方法，我们只需通过返回 **Results.OK(ToDoItems)** 的结果，就可以返回一个 HTTP
    **200 OK** 的响应，并附带所需的数据。这个函数生成相关的状态码，并接受一个类型为 **object** 的参数，代表应返回给客户端的数据。一旦添加，端点应该看起来像这样：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So far, the focus has been on routing requests into the API for the purposes
    of retrieving data. We will also need to create new data in the system; so, let
    us turn our attention to the creation of todo items.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的重点一直是将请求路由到 API 以检索数据。我们还需要在系统中创建新数据；因此，让我们将注意力转向待办事项的创建。
- en: Creating Todo items
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建待办事项
- en: 'Let’s now look at another critical operation for APIs: creating an entity.
    To create a new **TodoItem** , we would use an HTTP **POST** method.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个对 API 至关重要的操作：创建实体。要创建一个新的 **TodoItem**，我们会使用 HTTP **POST** 方法。
- en: The mapping of an HTTP **POST** method is similar to the code we’ve just written
    for mapping a **GET** method. Once again, we use a method prefixed with the word
    **Map** . This method is **MapPost()** . However, there is a slight difference
    in the syntax compared to our **GET** method, as we now need to receive a data
    structure. In the case of creating a **TodoItem** , we will require the client
    to send an object of type **TodoItem** , represented in JSON format on the client-side.
    ASP.NET will then take care of parsing the JSON into a strongly typed instance
    of **TodoItem** , which we can use whilst handling the request.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP **POST** 方法的映射与我们在映射 **GET** 方法时编写的代码类似。再次使用以 **Map** 为前缀的方法。这个方法是 **MapPost()**。然而，与我们的
    **GET** 方法相比，语法上有一点不同，因为我们现在需要接收一个数据结构。在创建 **TodoItem** 的情况下，我们将需要客户端发送一个类型为 **TodoItem**
    的对象，客户端以 JSON 格式表示。然后 ASP.NET 将负责将 JSON 解析为 **TodoItem** 的强类型实例，我们可以在处理请求时使用它。
- en: 'To allow the method to receive an object as part of the incoming request, we
    can take the parentheses at the beginning of the lambda expression within the
    endpoint’s body and add the object to it. For example, notice how the previous
    endpoint we created, which retrieves a **TodoItem** , has these empty parentheses:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让方法能够接收作为传入请求一部分的对象，我们可以在端点体中的 lambda 表达式开头的括号中添加该对象。例如，注意我们之前创建的用于检索 **TodoItem**
    的端点，它有这些空括号：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The handling of our minimal API endpoints is represented by a lambda expression.
    Lambda expressions open with an input in the form of parameters, which are passed
    in through these empty parentheses, as shown in the following code. This means
    that for our HTTP **POST** endpoint, we can add a parameter of type **TodoItem**
    to the **MapPost()** method we are adding, like so:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对最小 API 端点的处理是通过 lambda 表达式表示的。Lambda 表达式以参数的形式开始，这些参数通过这些空括号传入，如下面的代码所示。这意味着对于我们的
    HTTP **POST** 端点，我们可以在添加的 **MapPost()** 方法中添加一个类型为 **TodoItem** 的参数，如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we have an HTTP **POST** endpoint, sitting on the **/todoitems** route,
    just like our HTTP **GET** endpoint. The difference is that not only does it respond
    to a different HTTP verb, but it also requires the client to send a JSON payload
    mirroring the structure of **TodoItem** .
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个 HTTP **POST** 端点，位于 **/todoitems** 路径上，就像我们的 HTTP **GET** 端点一样。不同之处在于，它不仅响应不同的
    HTTP 动词，而且还需要客户端发送一个与 **TodoItem** 结构相对应的 JSON 负载。
- en: 'We don’t yet have anything inside the lambda expression within the endpoint,
    meaning that nothing will happen when a client sends a request. Let’s finally
    handle the request by adding the incoming **TodoItem** to the list and then returning
    the relevant response:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在端点内的 lambda 表达式中我们还没有任何内容，这意味着当客户端发送请求时，不会发生任何操作。让我们最终通过将传入的 **TodoItem** 添加到列表中，然后返回相关响应来处理请求：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Just like in the **GET** example, we are using **Results** to form a response
    and send it back to the client. However, we have opted for a slightly different
    response in this case. As the request is intended to create an entity, it is appropriate
    to return an **HTTP 201 CREATED** status code on successful creation, hence the
    use of **Results.Created();** .
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 **GET** 示例中一样，我们使用 **Results** 来构建响应并将其发送回客户端。然而，在这种情况下，我们选择了稍微不同的响应。因为请求的目的是创建一个实体，所以在成功创建后返回一个
    **HTTP 201 CREATED** 状态码是合适的，因此使用了 **Results.Created();** 。
- en: Updating existing Todo items
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新现有的 Todo 项目
- en: When it comes to updating a **Todoitem** , we have a couple of HTTP methods
    at our disposal. Let’s start with an HTTP **PUT** method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到更新一个 **Todoitem** 时，我们有几个 HTTP 方法可供选择。让我们从 HTTP **PUT** 方法开始。
- en: 'An HTTP **PUT** requires the client to send a full copy of the entity being
    updated. It will then replace the entity with the copy. It is a *full update*
    . Therefore, we need to create an endpoint that receives a **TodoItem** as part
    of the request, before finding the relevant item in our list and then replacing
    it with the incoming **TodoItem** . First, we’ll create an empty **PUT** endpoint
    sitting on the **/todoitems** route that expects the item as an object parameter:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP **PUT** 要求客户端发送要更新的实体的完整副本。然后它会用副本替换实体。这是一个 *完整更新*。因此，我们需要创建一个端点，它接收请求中的
    **TodoItem** 作为对象参数，在找到我们列表中的相关项目并将其替换为传入的 **TodoItem** 之前：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, the request should be handled by finding the **TodoItem** that we intend
    to update. We can do this using a **Language Integrated Query** ( **LINQ** ) query
    to find the item by its unique ID, with **FindIndex();** .
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请求应该通过找到我们打算更新的 **TodoItem** 来处理。我们可以使用一个 **Language Integrated Query**
    ( **LINQ** ) 查询通过其唯一的 ID 来找到该项目，使用 **FindIndex();** 。
- en: LINQ queries
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 查询
- en: A LINQ query with lambda expressions in C# lets you easily search and manipulate
    data in collections such as lists. You start by defining your data source, then
    use methods such as **Where** to filter the data and **Select** ” to choose what
    you want from the data. Each method takes a lambda expression, which is a simple
    function that defines your criteria. In our example, we’re using a LINQ query
    to find the index of an item in a list that shares the same ID as a given item.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，使用 lambda 表达式的 LINQ 查询可以让你轻松地在集合（如列表）中搜索和操作数据。你首先定义你的数据源，然后使用如 **Where**
    的方法来过滤数据，使用 **Select** 来选择你想要的数据。每个方法都接受一个 lambda 表达式，这是一个简单的函数，它定义了你的标准。在我们的例子中，我们使用
    LINQ 查询来找到列表中与给定项目具有相同 ID 的项目的索引。
- en: 'Once found, **TodoItem** can be replaced with the incoming item:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到，**TodoItem** 可以被替换为传入的项目：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice how we did not return **Results.OK** again in this example. Because we’re
    simply updating a resource, the client is not expecting content to be returned;
    so, we indicate success by returning an **HTTP 204 NO CONTENT** status code using
    **Results.NoContent();** .
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中我们没有再次返回 **Results.OK**。因为我们只是更新一个资源，客户端不期望返回内容；所以我们通过返回一个 **HTTP 204
    NO CONTENT** 状态码来表示成功，使用 **Results.NoContent();** 。
- en: 'Updating **TodoItem** via HTTP **PATCH** is handled slightly differently. Unlike
    **PUT** , we handle the request by once again finding the relevant item, but this
    time, we only change specific properties of the item, as dictated by the request
    parameters. This is usually used in scenarios where you want to create an endpoint
    on a route that is for a specific update. So, in this case, we will no longer
    create the endpoint on the **/todoitems** route. Instead, we will be specific
    about what we want to change by mapping the **PATCH** method to the **/updateTodoItemDueDate**
    route. In this example, we are creating an endpoint intended for a single purpose
    – to change the due date on the target **TodoItem** :'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过HTTP **PATCH**更新**待办事项**的处理方式略有不同。与**PUT**不同，我们通过再次找到相关项目来处理请求，但这次，我们只更改项目的一些特定属性，这些属性由请求参数指定。这通常用于你希望在路由上创建一个特定更新端点的场景。因此，在这种情况下，我们不再在**/todoitems**路由上创建端点。相反，我们将通过将**PATCH**方法映射到**/updateTodoItemDueDate**路由来具体说明我们想要更改的内容。在这个例子中，我们创建了一个旨在单一目的的端点——更改目标**待办事项**的截止日期：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code looks like the **PUT** method we created, but you can see that the
    parameters are quite different. Instead of requiring the full **ToDoItems** object
    to be sent in by the client, we instead ask for two parameters, an **int** parameter
    (to find the target item by ID) and a **DateTime** parameter containing the new
    due date. It is then possible to find the target item with another LINQ query,
    and then only update its **DueDate** property.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来像我们创建的**PUT**方法，但你可以看到参数有所不同。我们不是要求客户端发送完整的**ToDoItems**对象，而是要求两个参数，一个**int**参数（通过ID查找目标项目）和一个包含新截止日期的**DateTime**参数。然后可以使用另一个LINQ查询找到目标项目，然后只更新其**DueDate**属性。
- en: So far, we’ve handled scenarios wherein we need to get all items, create an
    item, and update items. We will next look at scenarios in which we intend to get
    single items and delete items. However, to do this, we first need to explore the
    concept of route parameters.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经处理了需要获取所有项目、创建项目以及更新项目的场景。接下来，我们将探讨我们打算获取单个项目和删除项目的场景。然而，为了做到这一点，我们首先需要了解路由参数的概念。
- en: Managing route parameters
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理路由参数
- en: '**Route parameters** give us the ability to capture values from the URL of
    an API endpoint. This is useful in many scenarios where we need to target specific
    entities, such as when requesting a **TodoItem** by its ID.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由参数**赋予我们从API端点的URL中捕获值的能力。这在许多需要针对特定实体进行操作的场景中非常有用，例如在通过ID请求**待办事项**时。'
- en: Route parameters are quite simple to add, and work using curly braces to define
    the parameters to be captured from the URL.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 添加路由参数非常简单，并且使用花括号来定义从URL中捕获的参数。
- en: 'Let’s use a **GET** request as an example. In this request, the client requests
    a **TodoItem** with the ID:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个**GET**请求为例。在这个请求中，客户端请求具有以下ID的**待办事项**：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Like the generic **GET** request we created to fetch all todo items, this endpoint
    is sitting on the **/todoitems** route. However, it has an extra section appended
    to this route in the URL. The client is expected to also add an ID value as an
    extra URL section. This is shown by the presence of **{id}** in the route.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们创建的用于获取所有待办事项的通用**GET**请求一样，这个端点位于**/todoitems**路由上。然而，在URL中附加了该路由的一个额外部分。客户端预期也会添加一个ID值作为额外的URL部分。这通过路由中存在的**{id}**来表示。
- en: This use of parameters within curly braces is how ASP.NET handles dynamic content
    in the route URL. Using a form of templating, it can replace the section of the
    URL where we added **{id}** with the value specified by the client.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在花括号中使用参数的方法是ASP.NET处理路由URL中动态内容的方式。通过模板化的一种形式，它可以替换我们添加**{id}**的URL部分，并用客户端指定的值替换。
- en: 'Another example of this can be seen in an HTTP **DELETE** endpoint. Again,
    when deleting **TodoItem** , we want to delete a specific item so we will once
    again need to pass in an ID for the target to be deleted. Let’s write the code
    for this in which we will map a new HTTP **DELETE** method to the **/todoitems**
    route. On the route, we’ll add a route parameter to pass the ID for the **TodoItem**
    to be deleted:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的另一个例子可以在HTTP **DELETE**端点中看到。再次强调，当删除**待办事项**时，我们想要删除特定的项目，因此我们还需要传递一个ID来指定要删除的目标。让我们编写这段代码，我们将映射一个新的HTTP
    **DELETE**方法到**/todoitems**路由。在路由上，我们将添加一个路由参数来传递要删除的**待办事项**的ID：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: On receiving a **DELETE** request on the **/todoitems** route, if an **int**
    has been appended to the URL, it will be stripped out and used within the request
    as a parameter. The subject of parameter data type is an important one. In the
    **DELETE** example, we passed an **int** as an ID parameter because that is the
    data type used on the ID property of the **TodoItem** class ( our model).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到对 **/todoitems** 路由的 **DELETE** 请求时，如果 URL 上附加了一个 **int**，它将被剥离并在请求中作为参数使用。参数数据类型的问题非常重要。在
    **DELETE** 示例中，我们传递了一个 **int** 作为 ID 参数，因为这是在 **TodoItem** 类（我们的模型）的 ID 属性上使用的数据类型。
- en: 'What if someone sends a different data type as the parameter, such as a string?
    We would need to handle this of course, but we shouldn’t have to ensure that the
    incoming ID is an **int** within the code. There is a better way of ensuring that
    the request only hits the route if the parameters being sent are of the correct
    data type: **route** **parameter constraints** .'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人发送了不同的数据类型作为参数，比如一个字符串呢？我们当然需要处理这种情况，但不需要在代码中确保传入的 ID 是一个 **int**。确保请求只有在发送的参数是正确数据类型时才击中路由的更好方法是：**路由参数约束**。
- en: Adding a constraint to a route parameter makes it so that the incoming parameter
    must be formed in a particular way for the route to be found and the request received.
    In our **DELETE** endpoint, we can use a parameter constraint to dictate that
    the parameter must be an integer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由参数上添加约束会使传入的参数必须以特定方式形成，以便找到路由并接收请求。在我们的 **DELETE** 端点中，我们可以使用参数约束来规定参数必须是一个整数。
- en: 'Adding a constraint to the parameter is very simple. We just append a **:**
    character to the parameter, followed by the constraint. Let’s add a constraint
    to our **DELETE** endpoint to ensure the route is only used when the **id** parameter
    is of type **int** :'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 向参数添加约束非常简单。我们只需在参数后追加一个 **:** 字符，然后跟约束。让我们向我们的 **DELETE** 端点添加一个约束，以确保只有当 **id**
    参数是 **int** 类型时才使用该路由：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have the constraint in place, if a request was received that could
    not be treated as an **int** , the API would return a **404 NOT FOUND** response.
    It does this because the constraint stops ASP.NET from attempting to use the parameter
    as an ID, because it has already evaluated the data type thanks to the constraint.
    The result is that no other suitable route is found. (Unless there is a route
    on the **/todoitems** URL that can receive a string and is also an HTTP **DELETE**
    method.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们已经设置了约束，如果收到一个无法作为 **int** 处理的请求，API 将返回 **404 NOT FOUND** 响应。它这样做是因为约束阻止了
    ASP.NET 尝试将参数用作 ID，因为它已经通过约束评估了数据类型。结果是找不到其他合适的路由。（除非在 **/todoitems** URL 上有一个可以接收字符串并且也是
    HTTP **DELETE** 方法的路由。） '
- en: Parameter constraints are not limited to data types. Parameters can be constrained
    by string length, numerical ranges, regex patterns; the list goes on.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 参数约束不仅限于数据类型。参数可以通过字符串长度、数值范围、正则表达式模式等进行约束；列表还在继续。
- en: 'Let’s constrain the **DELETE** range even further by adding a range constraint.
    We’ll make it so that the route can only delete the first 100 IDs. We can add
    multiple constraints to a single route like so:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加范围约束进一步约束 **DELETE** 范围。我们将使其只能删除前 100 个 ID。我们可以像这样将多个约束添加到单个路由中：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By chaining another constraint onto the existing one, we have now enforced that
    the **Id** parameter must be an **int** and that its value must be between **1**
    and **100** .
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将另一个约束链接到现有的约束上，我们现在强制执行了 **Id** 参数必须是一个 **int**，并且其值必须在 **1** 到 **100** 之间。
- en: '*Table 4.1* shows some other constraint examples:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 4.1* 展示了一些其他约束示例：'
- en: '| **Constraint Type** | **Route Example** | **Constraint Detail** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **约束类型** | **路由示例** | **约束详情** |'
- en: '| Length | **/** **users/{username:length(3,20)}** | The username string must
    be between three and twenty characters long |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 长度 | **/** **users/{username:length(3,20)}** | 用户名字符串长度必须在三个到二十个字符之间 |'
- en: '| Length | **/** **users/{username:length(8)}** | The username string must
    be exactly eight characters long |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 长度 | **/** **users/{username:length(8)}** | 用户名字符串必须正好有八个字符长 |'
- en: '| Min Length | **/** **users/{username:minlength(5)}** | The username string
    must be at least five characters long |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 最小长度 | **/** **users/{username:minlength(5)}** | 用户名字符串必须至少有五个字符长 |'
- en: '| Max Length | **/** **users/{username:maxlength(30)}** | The username string
    must be no more than thirty characters long |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 最大长度 | **/** **users/{username:maxlength(30)}** | 用户名字符串长度不得超过三十个字符 |'
- en: '| Regular Expression | **/** **addNewCreditCard/{cardNumber:regex(^3[47][0-9]{{13}}$)}**
    | The credit card number must conform to the pattern of an American Express card
    number |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 正则表达式 | **/** **addNewCreditCard/{cardNumber:regex(^3[47][0-9]{{13}}$)}**
    | 信用卡号码必须符合美国运通卡号的模式 |'
- en: 'Table 4.1: Examples of parameter constraints in minimal APIs'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1：最小 API 中参数约束的示例
- en: Now that we are more focused on how parameters are passed into our requests,
    we can focus our attention on the request body, in which we do the main handling
    of the request. A major part of handling any request is validation. Minimal APIs,
    like any other API, will receive data within requests, which must suit the conditions
    needed to handle the request. Let’s look at some validation techniques we can
    use to manage the request flow and handle any errors that may arise as a result
    of any violations of validation rules.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们更关注参数如何传递到我们的请求中，我们可以将注意力集中在请求体上，在其中我们主要处理请求。处理任何请求的主要部分是验证。最小 API，就像任何其他
    API 一样，将在请求中接收数据，这些数据必须满足处理请求所需的条件。让我们看看我们可以用来管理请求流和处理可能因违反验证规则而出现的任何错误的验证技术。
- en: Request validation and error handling
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求验证和错误处理
- en: 'There are several different methods of validation at our disposal. We’re going
    to look at two of them in this section: **manual validation** and **data annotation**
    and **model** **binding validation** .'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种不同的验证方法可供选择。在本节中，我们将探讨其中的两种：**手动验证**和**数据注解**以及**模型绑定验证**。
- en: Manual validation
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动验证
- en: This kind of validation is the simplest, as you are writing code inside the
    route handler (the body of the lambda expression within an endpoint) that validates
    the request and decides on the appropriate response.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种验证是最简单的，因为您是在路由处理程序（端点内的 lambda 表达式体）内部编写代码来验证请求并决定适当的响应。
- en: 'We’ve already applied manual validation in some parts of the todo items API.
    For example, the **PATCH** method we created to update the due date on items first
    checks for the **Todo** item with the target ID. It *could* just assume that **TodoItem**
    exists in the list, but instead, we check first to see if it exists and then return
    a **404 NOT FOUND** status code if this is the case:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在待办事项 API 的某些部分应用了手动验证。例如，我们创建的用于更新项目截止日期的 **PATCH** 方法首先检查具有目标 ID 的 **Todo**
    项。它**可以**假设 **TodoItem** 已存在于列表中，但相反，我们首先检查它是否存在，如果存在，则返回 **404 NOT FOUND** 状态码：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By adding this manual check, we are actively validating and handling an exceptional
    scenario. Having validation in an API endpoint is not just best practice, it is
    critical. Manual validation is the most basic form of validation. The problem
    is it relies on the intuition of a human; the developer writing the code. This
    is a subject of some debate because a lot of validation methods have gaps, but
    relying solely on manual validation can result in fragile APIs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加这个手动检查，我们正在积极验证和处理异常情况。在 API 端点中进行验证不仅是一种最佳实践，而且是至关重要的。手动验证是验证的最基本形式。问题是它依赖于编写代码的开发者的直觉。这是一个有争议的话题，因为许多验证方法都有漏洞，但仅依赖手动验证可能会导致脆弱的
    API。
- en: 'To mitigate this, we can also adopt a more standardized framework for validation,
    one provided by ASP.NET: validation with data annotations.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这种情况，我们还可以采用一个更标准化的验证框架，由 ASP.NET 提供的：使用数据注解的验证。
- en: Validation with data annotations and model binding
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据注解和模型绑定进行验证
- en: As demonstrated by the simple API example we’ve built in this chapter, models
    are an important aspect of minimal APIs. They allow us to represent the entities
    that incoming requests retrieve, move, and transform. In the todo items API, we
    created a **TodoItem** class as a model, and then stored the entities in **List<TodoItem>**
    .
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章中我们构建的简单 API 示例所示，模型是最小 API 的重要方面。它们允许我们表示传入请求检索、移动和转换的实体。在待办事项 API 中，我们创建了一个
    **TodoItem** 类作为模型，然后将实体存储在 **List<TodoItem>** 中。
- en: It is possible to validate a request’s data by the way it binds to specific
    models. For example, in the **TodoItem** model, it is reasonable to expect that
    the **Title** field should be populated when **TodoItem** is created.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过请求绑定到特定模型的方式验证请求的数据。例如，在 **TodoItem** 模型中，当创建 **TodoItem** 时，合理地期望 **Title**
    字段被填充。
- en: We can specify a field’s requirements by annotating it with an attribute. Attributes
    are handy pieces of metadata that allow us to apply constraints to code. One of
    the most common uses of attributes in this case is the **[** **Required]** attribute.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过注解字段来指定字段的要求。属性是有用的元数据片段，允许我们向代码应用约束。在这种情况下，属性的最常见用途之一是 **[** **Required]**
    属性。
- en: The attributes we need are part of the **System.ComponentModel.DataAnnotations**
    namespace.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的属性是 **System.ComponentModel.DataAnnotations** 命名空间的一部分。
- en: Required namespace for validation
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 验证的必需命名空间
- en: As in the **Todo** class, **System.ComponentModel.DataAnnotations** must also
    be added to **Program.cs** for validation to be performed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与 **Todo** 类一样，**System.ComponentModel.DataAnnotations** 也必须添加到 **Program.cs**
    中以执行验证。
- en: 'Add this namespace to the top of the **TodoItem** class, followed by the **[Required]**
    attribute above the **Title** field:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将此命名空间添加到 **TodoItem** 类的顶部，然后在 **Title** 字段上方添加 **[Required]** 属性：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Adding a **[Required]** attribute is not enough on its own to trigger validation.
    We still need to invoke validation within our requests. However, we can do this
    once within the request, and then all items requiring validation will be validated,
    according to the attributes we applied. Here’s how we can invoke validation of
    our model from the **POST** request we created earlier:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 仅添加一个 **[Required]** 属性本身不足以触发验证。我们仍然需要在我们的请求中调用验证。但是，我们可以在请求中调用一次，然后所有需要验证的项目都将根据我们应用的属性进行验证。以下是如何从我们之前创建的
    **POST** 请求中调用我们的模型验证的方法：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, we have initialized a new collection, a list of **ValidationResult**
    . This will contain information about the success or failure of validation. We
    will return this collection to the client if validation fails.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们初始化了一个新的集合，一个 **ValidationResult** 的列表。这将包含有关验证成功或失败的信息。如果验证失败，我们将返回此集合给客户端。
- en: We also create a new **ValidationContext** , passing in the item that is to
    be validated. Because we want to validate the **TodoItem** instance that is sent
    as a payload, we pass this into **ValidationContext** .
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个新的 **ValidationContext**，传入要验证的项目。因为我们想验证作为有效负载发送的 **TodoItem** 实例，所以我们将其传递给
    **ValidationContext**。
- en: We can then invoke validation by calling **Validator.TryValidateObject()** ,
    passing in the item as the validation target, the context we created that will
    be validated against, and the collection into which results will be saved, followed
    by a Boolean value of **true** , to state that all properties should be validated.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过调用 **Validator.TryValidateObject()** 来执行验证，传入项目作为验证目标，我们将要验证的上下文，以及将保存结果的集合，最后是一个布尔值
    **true**，表示应验证所有属性。
- en: 'Now, when a request is sent that omits a **Title** field from the payload,
    the following error JSON is automatically generated and sent back to the client:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当发送一个请求，从有效负载中省略了 **Title** 字段时，以下错误 JSON 将自动生成并发送回客户端：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This validation and error handling all happen automatically, thanks to the use
    of attributes and the built-in validator.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了属性和内置验证器，所有这些验证和错误处理都是自动发生的。
- en: The error message shown is automatically generated because of the **[Required]**
    attribute. This can be overridden by adding a parameter to the attribute.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的错误信息是自动生成的，因为使用了 **[Required]** 属性。这可以通过向属性添加参数来覆盖。
- en: 'Here is the updated code on the **TodoItem** model, with a custom error message:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是更新后的 **TodoItem** 模型代码，包含自定义的错误信息：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we can see the custom error message in the generated error response JSON:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在生成的错误响应 JSON 中看到自定义的错误信息：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**[Required]** is just one of many validation attributes that data annotations
    have to offer. There are many other constraints you can add. Some examples of
    these include the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**[Required]** 只是数据注解提供的许多验证属性之一。您还可以添加许多其他约束。以下是一些这些约束的示例：'
- en: '**[EmailAddress]** : This ensures the value conforms to the format of an email
    address.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[EmailAddress]** : 这确保值符合电子邮件地址的格式。'
- en: '**[AllowedValues]** : This forces the use of specific values.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[AllowedValues]** : 这强制使用特定的值。'
- en: '**[DeniedValues]** : This is the opposite of **[AllowedValues]** , denying
    the use of specific values.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[DeniedValues]** : 这与 **[AllowedValues]** 相反，拒绝使用特定的值。'
- en: '**[StringLength(x)]** : This requires that a string value be of a certain length.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[StringLength(x)]** : 这要求字符串值具有特定的长度。'
- en: '**[CreditCard]** : The annotated value must be a valid credit card format.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[CreditCard]** : 注释的值必须是有效的信用卡格式。'
- en: These are just a few of the many attributes that can be used to validate incoming
    responses, returning appropriate errors as needed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是可以用来验证传入响应的许多属性中的几个，根据需要返回适当的错误。
- en: Managing HTTP methods and handling requests are critical aspects of minimal
    APIs, as it is in any API implementation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 管理HTTP方法和处理请求是最小API的关键方面，就像在任何API实现中一样。
- en: Validation with filters
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用过滤器进行验证
- en: You can also apply more specific validation rules with filters. **IEndpointFilter**
    is an interface that can be implemented to perform validation of the incoming
    request information before it hits the logic within an endpoint.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用过滤器应用更具体的验证规则。**IEndpointFilter**是一个接口，可以用来在请求到达端点内的逻辑之前对传入的请求信息进行验证。
- en: There is a handy extension method, **AddEndPointFilter<T>** , which allows you
    to attach a class implementing **IEndpointFilter** to an endpoint.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个方便的扩展方法，**AddEndPointFilter<T>**，它允许你将实现**IEndpointFilter**接口的类附加到端点上。
- en: 'Let’s explore an example of this against a **POST** endpoint on our todo API.
    We’ll create a rule where a todo item cannot be assigned to anyone named Joe Bloggs:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过我们的todo API上的**POST**端点来探索这个例子。我们将创建一个规则，其中todo项不能分配给任何名为Joe Bloggs的人：
- en: 'Create a class that implements **IEndpointFilter** . This class will be required
    to define a function called **Invoke** , returning **ValueTask<object?>** . The
    function takes **EndPointFilterInvocationContext** and **EndpointFilterDelegate**
    as parameters in order to carry out the validation logic:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现**IEndpointFilter**接口的类。这个类需要定义一个名为**Invoke**的函数，返回**ValueTask<object?>**。该函数接受**EndPointFilterInvocationContext**和**EndpointFilterDelegate**作为参数，以便执行验证逻辑：
- en: '[PRE20]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**EndPointFilterInvocationContext** will contain the incoming **TodoItem**
    , as it represents the context of the endpoint we are validating. Inside **InvokeAsync**
    , define logic to gain access to the incoming **TodoItem** from the endpoint’s
    context and then validate that we are not attempting to assign it to Joe Bloggs.
    If we are, return the appropriate response so that validation fails:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**EndPointFilterInvocationContext**将包含传入的**TodoItem**，因为它代表了我们要验证的端点的上下文。在**InvokeAsync**内部，定义逻辑以从端点的上下文中访问传入的**TodoItem**，然后验证我们不是试图将其分配给Joe
    Bloggs。如果是这样，返回适当的响应，使验证失败：'
- en: '[PRE21]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, for validation that passes, we want to pass the flow of execution
    back to the original endpoint (or any other chained logic attached to it, a bit
    like we do for a middleware pipeline). Do this by returning a call to **EndpointFilterDelegate**
    , which we received as a parameter, passing in the endpoint context:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于验证通过的情况，我们希望将执行流程返回到原始端点（或附加到其上的任何其他链式逻辑，就像我们对中间件管道所做的那样）。通过返回对**EndpointFilterDelegate**的调用，我们作为参数接收，并传入端点上下文来完成此操作：
- en: '[PRE22]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, add the filter validation to the endpoint as shown:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按照以下方式将过滤器验证添加到端点：
- en: '[PRE23]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Alternatively, if you want to define the endpoint filter inline, you can do
    so by passing in an anonymous function instead of a type after **AddEndpointFilter**
    :'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，如果你想内联定义端点过滤器，可以在**AddEndpointFilter**之后传递一个匿名函数而不是类型：
- en: '[PRE24]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that you’ve gained some insight into the various ways we can achieve validation
    for different API endpoints, let’s recap the things we’ve learned in this chapter.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了我们可以用来为不同的API端点实现验证的各种方法，让我们回顾一下本章学到的内容。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a high-level view of HTTP methods and how they are
    handled. We explored in further detail the way in which requests can be routed,
    allowing essential parameters to be lifted out of route definitions with routing
    parameters.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们以高级视角概述了HTTP方法及其处理方式。我们进一步探讨了请求的路由方式，允许通过路由参数从路由定义中提取基本参数。
- en: We also delved into the basics of validation, firstly by placing constraints
    on our API routes to ensure that the data received is formatted in an appropriate
    manner. Following this, we learned how to handle validation in different ways,
    including manual validation, and the use of data annotations in models to invoke
    validation in a centralized fashion within the endpoint body.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还深入探讨了验证的基础知识，首先是通过在我们的API路由上放置约束来确保接收到的数据格式正确。随后，我们学习了如何以不同的方式处理验证，包括手动验证，以及在模型中使用数据注释在端点体内部集中调用验证。
- en: Throughout the chapter, we saw examples of how errors can be captured through
    validation techniques, and how informative error responses should be handed back
    to clients to inform their debugging strategies.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何通过验证技术捕捉错误，以及如何将具有信息量的错误响应反馈给客户端，以指导他们的调试策略。
- en: By now, you should be capable of putting together a basic yet functional minimal
    API project. In the next chapter, we will learn how to introduce custom functionalities
    to our application pipelines in the form of middleware.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该能够构建一个基本但功能齐全的最小API项目。在下一章中，我们将学习如何以中间件的形式向我们的应用程序管道中引入自定义功能。
