- en: Scaling RESTful Services (Performance of Web Services)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展RESTful服务（Web服务的性能）
- en: In the world of the web, everyone is either writing or looking for a web application.
    As demand increases, every web application needs to be able to serve more requests—sometimes
    thousands of requests a day. Applications should therefore be written to handle
    this huge requests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络世界中，每个人要么在编写，要么在寻找一个网络应用程序。随着需求的增加，每个网络应用程序都需要能够服务更多的请求——有时每天成千上万的请求。因此，应用程序应该编写成能够处理这些大量请求。
- en: Say, as an example, that you are part of a development and support team that
    is responsible for developing the company's flagship product, FlixOne Store. This
    product is popular and gains traction, leading to your e-commerce website (FlixOne)
    being inundated with consumer traffic. The payment service in your system is slow,
    which has almost brought the whole thing down, causing you to lose customers.
    Although this is an imaginary scenario, it can happen in real life and can lead
    to a loss of business. To avoid such a scenario, you should think about the scalability
    of the FlixOne application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你是一个开发和支持团队的一员，负责开发公司的旗舰产品FlixOne Store。这个产品很受欢迎，并且获得了关注，导致你的电子商务网站（FlixOne）被消费者流量淹没。你系统中的支付服务很慢，这几乎使整个系统崩溃，导致你失去了客户。虽然这是一个虚构的场景，但在现实生活中确实可能发生，并可能导致业务损失。为了避免这种情况，你应该考虑FlixOne应用程序的可扩展性。
- en: Scalability is one of the most important non-functional requirements for a critical
    system. Serving a couple of users with hundreds of transactions is not the same
    as serving millions of users with several million transactions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性是关键系统最重要的非功能性需求之一。为几百个用户提供数百笔交易与为几百万用户提供几百万笔交易的服务并不相同。
- en: In this chapter, we will discuss scalability in general. We'll also discuss
    how to scale RESTful services, what to consider when we design them, and how to
    avoid cascading failures using different patterns including techniques, libraries,
    and tools that can also be helpful for our regular applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一般性的可扩展性。我们还将讨论如何扩展RESTful服务，设计它们时需要考虑的因素，以及如何使用不同的模式来避免级联故障，包括技术、库和工具，这些也可以帮助我们的常规应用程序。
- en: 'By the end of this chapter, you will have learned about:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解以下内容：
- en: Clustering
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群
- en: Load balancing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡
- en: An introduction to scalability
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性简介
- en: Clustering
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群
- en: Clustering is a way to provide the same service on more than one server. With
    the addition of more servers, you can avoid uncontrolled situations, such as failovers,
    system crashes, and so on. In the context of databases, clustering refers to the
    ability of several server instances to connect with a single server. Fault tolerance
    and load balancing are two of the main advantages of clustering.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 集群是在多个服务器上提供相同服务的一种方式。随着更多服务器的添加，你可以避免不受控制的情况，例如故障转移、系统崩溃等。在数据库的上下文中，集群指的是几个服务器实例能够连接到单个服务器的能力。容错性和负载均衡是集群的两个主要优点。
- en: Load balancing
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负载均衡
- en: A load balancer is a useful tool when clustering. You can define a **load balance**
    as a device that helps to distribute network or application traffic within and
    across the cluster servers, and to improve the responsiveness of the application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群中，负载均衡器是一个有用的工具。你可以定义**负载均衡**为一个帮助在集群服务器内部和之间分配网络或应用程序流量的设备，并提高应用程序的响应性。
- en: In implementation, a load balancer is placed between the client and the servers.
    It helps to balance multiple application requests across multiple servers. In
    the other words, a load balancer reduces individual server time and prevents application
    server failure.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现中，负载均衡器被放置在客户端和服务器之间。它有助于在多个服务器之间平衡多个应用程序请求。换句话说，负载均衡器减少了单个服务器的时间并防止应用程序服务器故障。
- en: How does it work?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: 'A load balancer works to make sure that an application''s server is available.
    If one application''s server is unavailable, the load balancer redirects all new
    requests to the available servers, as illustrated in the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器的工作是确保应用程序的服务器可用。如果一个应用程序的服务器不可用，负载均衡器将所有新的请求重定向到可用的服务器，如下面的图示所示：
- en: '![](img/867aa115-47b5-4579-8b1b-e94c3e9f7bc8.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![集群图](img/867aa115-47b5-4579-8b1b-e94c3e9f7bc8.png)'
- en: In the preceding diagram, you can see a load balancer in its typical environment,
    where a system accepts multiple requests from different sources over the internet,
    which are then managed from multiple servers by the load balancer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，您可以看到负载均衡器在其典型环境中，系统通过互联网从不同来源接受多个请求，然后由负载均衡器从多个服务器进行管理。
- en: In .NET, this arrangement is also known as a web farm ([https://www.codeproject.com/Articles/114910/What-is-the-difference-between-Web-Farm-and-Web-Ga](https://www.codeproject.com/Articles/114910/What-is-the-difference-between-Web-Farm-and-Web-Ga)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，这种配置也被称为Web农场 ([https://www.codeproject.com/Articles/114910/What-is-the-difference-between-Web-Farm-and-Web-Ga](https://www.codeproject.com/Articles/114910/What-is-the-difference-between-Web-Farm-and-Web-Ga))。
- en: 'A load balancer uses various algorithms, also known as load balancer methods:
    the least connection method, round-robin method, least response time method, least
    bandwidth method, least packets method, custom load method, and more.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器使用各种算法，也称为负载均衡方法：最少连接方法、轮询方法、最少响应时间方法、最少带宽方法、最少数据包方法、自定义负载方法等。
- en: A load balancer plays an important role in the scalability of an application
    as it makes sure that an application's server is available for server requests.
    Note that you will need to arrange your hardware infrastructure without a code
    change to cater for a load balancer (however, there will be some scenarios that
    call for a code change). There are a lot of load balancers on the market, such
    as Incapsula ([https://www.incapsula.com/](https://www.incapsula.com/)), F5 ([https://www.f5.com/](https://www.f5.com/)),
    Citrix Netscaler ([https://www.citrix.com/](https://www.citrix.com/)), Dyn ([https://dyn.com/](https://dyn.com/)),
    Amazon Elastic Load Balancing, and Amazon ELB ([https://aws.amazon.com/](https://aws.amazon.com/)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器在应用程序的可扩展性中扮演着重要角色，因为它确保应用程序的服务器能够处理服务器请求。请注意，您可能需要在代码不变的情况下安排您的硬件基础设施以适应负载均衡器（尽管，有些情况下可能需要代码更改）。市场上有很多负载均衡器，例如Incapsula
    ([https://www.incapsula.com/](https://www.incapsula.com/))、F5 ([https://www.f5.com/](https://www.f5.com/))、Citrix
    Netscaler ([https://www.citrix.com/](https://www.citrix.com/))、Dyn ([https://dyn.com/](https://dyn.com/))）、Amazon
    Elastic Load Balancing和Amazon ELB ([https://aws.amazon.com/](https://aws.amazon.com/))。
- en: In the coming sections, we will look at the different ways you can scale systems.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将探讨您可以扩展系统的不同方法。
- en: Introduction to scalability
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性简介
- en: Every application has its own ability to serve requests. An application’s ability
    refers to its performance and how it meets its objectives when load is increased.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都有其自己的服务请求能力。应用程序的能力指的是其性能以及当负载增加时如何满足其目标。
- en: Many web applications refer to this as a number of requests in a stipulated
    time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Web应用程序将此称为在规定时间内的请求数量。
- en: It’s very important to make the right design decision when designing your web
    application; design decisions impact the scalability of your service. Be sure
    to strike the right balance so that your approach considers your services as well
    as their infrastructure, along with any need for scaling.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计您的Web应用程序时做出正确的设计决策非常重要；设计决策会影响您服务的可扩展性。确保找到正确的平衡点，以便您的方案不仅考虑服务，还要考虑其基础设施，以及任何扩展需求。
- en: Performance and scalability are two different characteristics of a system. Performance
    deals with the throughput of the system, whereas scalability deals with serving
    the desired throughput for a larger number of users, or a larger number of transactions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 性能和可扩展性是系统的两个不同特性。性能涉及系统的吞吐量，而可扩展性涉及为更多用户或更多交易处理所需吞吐量。
- en: Scaling in (vertical scaling)
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向内扩展（垂直扩展）
- en: '**Scaling in** or **scaling up** (also called **vertical scaling**) is a way
    of achieving scalability through the addition of more resources, such as memory
    or faster processors, to the same machine. This is not always applicable to all
    applications, as costing is also a factor when considering vertical scaling.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**向内扩展**或**向上扩展**（也称为**垂直扩展**）是通过向同一机器添加更多资源（如内存或更快的处理器）来实现可扩展性的方法。这并不总是适用于所有应用程序，因为成本也是考虑垂直扩展时的一个因素。'
- en: You can also upgrade your resources or hardware instead of adding new resources
    to your machine. For example, if you have 8 GB of RAM, you can upgrade it to 16
    GB, and the same thing would be applicable for processors and other resources.
    Unfortunately, with upgrades in hardware, there is a limit to how much you can
    scale the machine. This may lead to simply shifting the bottleneck, rather than
    solving the real problem of improving scalability.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以升级资源或硬件，而不是向机器添加新资源。例如，如果您有8 GB的RAM，您可以将其升级到16 GB，同样的情况也适用于处理器和其他资源。不幸的是，随着硬件的升级，机器的可扩展性有一定的限制。这可能会导致仅仅是将瓶颈转移，而不是解决提高可扩展性的真正问题。
- en: You can also migrate your application to an entirely different machine, such
    as simply migrating your application to a more powerful MacOS, for example.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以将应用程序迁移到完全不同的机器上，例如简单地迁移到更强大的MacOS，例如。
- en: Scaling vertically does not involve any code changes so it is an easy task,
    but it does involve extra cost as it is quite an expensive technique. Stack Overflow
    is one of those rare examples of a .NET-based system that is scaled vertically.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直扩展不涉及任何代码更改，因此这是一个简单的任务，但它涉及额外的成本，因为这是一种相当昂贵的技巧。Stack Overflow是那些罕见的基于.NET的系统之一，它进行了垂直扩展。
- en: Scaling out (horizontal scaling)
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展（横向扩展）
- en: Scaling up, scaling out, or horizontal scaling adds more servers or nodes to
    service requests, rather than resources. If you do not want to scale up your application,
    there is always a way to scale it out.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展（向上扩展）、扩展（向外扩展）或横向扩展是通过添加更多服务器或节点来服务请求，而不是资源。如果您不想扩展应用程序，总有一种方法可以将其扩展。
- en: Scaling out is a successful strategy when the application code does not depend
    on the server it is running on. However, if a request needs to be executed on
    a specific server, that is, if the application code has server affinity, it will
    be difficult to scale that out. In the case of stateless code, it is easier execute
    on any server. Hence, scalability is improved when stateless code is run on horizontally-scaled
    machines or clusters.Due to the nature of horizontal scaling, it is a commonly
    used approach across the industry. There are  many examples of large scalable
    systems managed in this way, such as Google, Amazon, and Microsoft.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序代码不依赖于其运行的服务器时，横向扩展是一种成功的策略。然而，如果需要在一个特定的服务器上执行请求，即如果应用程序代码具有服务器亲和性，那么横向扩展将会很困难。在无状态代码的情况下，在任何服务器上执行都更容易。因此，当无状态代码在横向扩展的机器或集群上运行时，可扩展性得到了提高。由于横向扩展的性质，这在整个行业中是一种常用的方法。有许多大型可扩展系统以这种方式管理，例如Google、Amazon和Microsoft。
- en: Linear scalability
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性可扩展性
- en: Linear scalability refers to scaling an application vertically with the application
    of Amdahl's law ([https://en.wikipedia.org/wiki/Amdahl%27s_law](https://en.wikipedia.org/wiki/Amdahl%27s_law)).
    Here, you can also think about parallel computing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 线性可扩展性指的是应用阿姆达尔定律（[https://en.wikipedia.org/wiki/Amdahl%27s_law](https://en.wikipedia.org/wiki/Amdahl%27s_law)）来垂直扩展应用程序。在这里，您也可以考虑并行计算。
- en: Parallel computing is a type of computing architecture that indicates simultaneous
    processing with the execution of several processors.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 并行计算是一种计算架构，它表明通过执行多个处理器来实现同时处理。
- en: 'The benefits of linear scalability in your application include:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 线性可扩展性在您的应用程序中的好处包括：
- en: No code changes are required
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要代码更改
- en: Extra resources can be easily added
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以轻松添加额外资源
- en: There is physical availability
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在物理可用性
- en: Distributed caching
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式缓存
- en: With the help of distributed caching techniques, we can improve the scalability
    of our RESTful web services (web API). A distributed cache can be stored on multiple
    nodes of a cluster. A distributed cache enhances a web service's throughput, as
    the cache no longer requires an I/O trip to any external resource.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分布式缓存技术，我们可以提高我们RESTful Web服务的可扩展性（Web API）。分布式缓存可以存储在集群的多个节点上。分布式缓存提高了Web服务的吞吐量，因为缓存不再需要任何I/O跳转到任何外部资源。
- en: 'This approach has the following advantages:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有以下优点：
- en: Clients get the same results
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端获得相同的结果
- en: The distributed cache is backed up by a persistence store and runs as a different
    remote process; even if the app server restarts or has any problems, it in no
    way affects the cache
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式缓存由持久化存储支持，并作为一个不同的远程进程运行；即使应用程序服务器重新启动或出现任何问题，也不会影响缓存
- en: The source's data store has fewer requests made to it
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源数据存储对其的请求较少
- en: Caching persisted data (data-tier caching)
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存持久化数据（数据层缓存）
- en: Similar to application performance, you should also be considering database
    performance. By caching persisted data, you will get better performance after
    adding a caching layer to your database. This is also important when read requests
    are heavily used in an application. We will now take a look at EF Core’s levels
    of caching as an example.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与应用性能类似，你也应该考虑数据库性能。通过缓存持久化数据，在数据库中添加缓存层之后，你会获得更好的性能。这在应用中大量使用读取请求时也非常重要。现在，我们将以
    EF Core 的缓存级别为例进行探讨。
- en: First-level caching
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一级缓存
- en: This is an inbuilt session cache enabled by EF Core. From the first request
    from a service, an object is retrieved from the database and is stored in an EF
    Core session. In other words, EF Object Context and DbContext maintain state information
    about the entities they are managing. As soon as the context is no longer available,
    its state information is also gone.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个由EF Core启用的内置会话缓存。从服务的第一个请求开始，从数据库中检索一个对象并将其存储在EF Core会话中。换句话说，EF Object
    Context和DbContext维护它们所管理的实体的状态信息。一旦上下文不再可用，其状态信息也随之消失。
- en: Second-level caching
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二级缓存
- en: Second-level caching is important for applications that have been developed
    in a mostly distributed manner or have-long running requests that need persisted
    data, such as web applications. Second-level caching exists outside the scope
    of a transaction or application, and these caches are available for any context
    or instance. You can use the caching mechanism available to your application instead
    of writing your own code, such as Memcached.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主要采用分布式方式开发的应用或需要持久化数据的长时间运行请求，如Web应用，二级缓存非常重要。二级缓存存在于事务或应用范围之外，这些缓存对任何上下文或实例都可用。你可以使用应用提供的缓存机制，而不是编写自己的代码，例如Memcached。
- en: Application caching
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用缓存
- en: Application caching or application-tier caching helps to cache any object in
    an application. This further improves the scalability of an application. In the
    following section, we will discuss the various caching mechanisms available.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 应用缓存或应用层缓存有助于缓存应用中的任何对象。这进一步提高了应用的扩展性。在下一节中，我们将讨论可用的各种缓存机制。
- en: CacheCow
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CacheCow
- en: CacheCow comes into the picture when you want to implement HTTP caching on both
    the client and server. This is a lightweight library and ASP.NET web API support
    is currently available. CacheCow is open source and comes with an MIT license
    that is available on GitHub ([https://github.com/aliostad/CacheCow](https://github.com/aliostad/CacheCow)).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想在客户端和服务器上实现HTTP缓存时，CacheCow就派上用场。这是一个轻量级库，目前支持ASP.NET Web API。CacheCow是开源的，并附带MIT许可证，可在GitHub上找到（[https://github.com/aliostad/CacheCow](https://github.com/aliostad/CacheCow)）。
- en: 'To get started with CacheCow, you need to get ready for both the server and
    client by taking the following steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用CacheCow，你需要通过以下步骤为服务器和客户端做好准备：
- en: Install the `Install-Package CacheCow.Server` NuGet package within your ASP.NET
    Web API project; this will be your server.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的ASP.NET Web API项目中安装`Install-Package CacheCow.Server` NuGet包；这将是你服务器。
- en: Install the `Install-Package CacheCow.Client` NuGet package within your client
    project; the client application will be WPF, Windows Form, Console, or any other
    web application.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的客户端项目中安装`Install-Package CacheCow.Client` NuGet包；客户端应用将是WPF、Windows Form、控制台或任何其他Web应用。
- en: Create a cache store. You need to create a cache
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个缓存存储。你需要创建一个
- en: store
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储
- en: on the server side that requires a database for storing cache metadata ([https://github.com/aliostad/CacheCow/wiki/Getting-started#cache-store](https://github.com/aliostad/CacheCow/wiki/Getting-started#cache-store)).
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在服务器端存储缓存元数据的缓存存储（[https://github.com/aliostad/CacheCow/wiki/Getting-started#cache-store](https://github.com/aliostad/CacheCow/wiki/Getting-started#cache-store)）。
- en: Memcached
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Memcached
- en: 'Memcached is an open source project that is customizable; you can use the source
    code and add to and update it as per your requirements. Memcached is defined by
    its official page ([https://memcached.org/](https://memcached.org/)) as:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Memcached是一个可定制的开源项目；你可以使用源代码，并根据你的需求对其进行添加和更新。Memcached由其官方页面（[https://memcached.org/](https://memcached.org/））定义为：
- en: '"An in-memory key-value store for small chunks of arbitrary data (strings,
    objects) from results of database calls, API calls, or page rendering."'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '"一个用于存储来自数据库调用、API 调用或页面渲染结果的任意数据小块（字符串、对象）的内存中键值存储。"'
- en: Refer to [https://www.deanhume.com/memcached-for-c-a-walkthrough/](https://www.deanhume.com/memcached-for-c-a-walkthrough/)
    for a complete walkthrough.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下链接获取完整教程[https://www.deanhume.com/memcached-for-c-a-walkthrough/](https://www.deanhume.com/memcached-for-c-a-walkthrough/)。
- en: Azure Redis Cache
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure Redis Cache
- en: 'Azure Redis Cache is built on top of an open source store called Redis ([https://github.com/antirez/redis](https://github.com/antirez/redis)),
    which is an in-memory database and persists on disk. As per Microsoft''s description
    ([https://azure.microsoft.com/en-in/services/cache/](https://azure.microsoft.com/en-in/services/cache/)):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Redis Cache建立在名为Redis的开源存储之上([https://github.com/antirez/redis](https://github.com/antirez/redis))，这是一个内存数据库，数据持久化在磁盘上。根据Microsoft的描述([https://azure.microsoft.com/en-in/services/cache/](https://azure.microsoft.com/en-in/services/cache/))：
- en: '"Azure Redis Cache is based on the popular open source Redis cache. It gives
    you access to a secure, dedicated Redis cache, managed by Microsoft and accessible
    from any application within Azure."'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: “Azure Redis Cache基于流行的开源Redis缓存。它为您提供了访问由Microsoft管理的安全、专用的Redis缓存，并且可以从Azure中的任何应用程序访问。”
- en: 'Getting started with Azure Redis Cache is very simple if you take the following
    steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照以下步骤操作，开始使用Azure Redis Cache非常简单：
- en: Create a web API project. Refer to our code example in previous chapters.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Web API项目。参考我们之前章节中的代码示例。
- en: Implement Redis. For a referral point, use [https://github.com/StackExchange/StackExchange.Redis](https://github.com/StackExchange/StackExchange.Redis).
    Also, install the `Install-Package StackExchange.Redis` NuGet package.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现Redis。参考点为[https://github.com/StackExchange/StackExchange.Redis](https://github.com/StackExchange/StackExchange.Redis)。同时，安装`Install-Package
    StackExchange.Redis` NuGet包。
- en: Update your config file for CacheConnection ([https://docs.microsoft.com/en-us/azure/redis-cache/cache-dotnet-how-to-use-azure-redis-cache#NuGet](https://docs.microsoft.com/en-us/azure/redis-cache/cache-dotnet-how-to-use-azure-redis-cache#NuGet)).
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您的CacheConnection配置文件([https://docs.microsoft.com/en-us/azure/redis-cache/cache-dotnet-how-to-use-azure-redis-cache#NuGet](https://docs.microsoft.com/en-us/azure/redis-cache/cache-dotnet-how-to-use-azure-redis-cache#NuGet))。
- en: Then, publish on Azure ([https://docs.microsoft.com/en-us/azure/redis-cache/cache-web-app-howto#publish-and-run-in-azure](https://docs.microsoft.com/en-us/azure/redis-cache/cache-web-app-howto#publish-and-run-in-azure)).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在Azure上发布([https://docs.microsoft.com/en-us/azure/redis-cache/cache-web-app-howto#publish-and-run-in-azure](https://docs.microsoft.com/en-us/azure/redis-cache/cache-web-app-howto#publish-and-run-in-azure))。
- en: Communication (asynchronous)
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信（异步）
- en: 'The term communication is self-explanatory; it is the act of interaction between
    services. Examples of this include the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“通信”是自解释的；它是服务之间交互的行为。以下是一些例子：
- en: A service communicating with another service within the same application
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一应用程序内部与另一个服务通信的服务
- en: A service communicating with another service outside of the application (external
    services)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与应用程序外部（外部服务）的其他服务通信的服务
- en: A service communicating with a component (internal or external)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个与组件（内部或外部）通信的服务
- en: This communication happens over the HTTP protocol as messages or data traverse
    over the wire.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通信通过HTTP协议进行，消息或数据通过网络传输。
- en: Your application's performance impacts how services communicate with each other.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您应用程序的性能会影响服务之间如何通信。
- en: 'Asynchronous communication is one of the methods that help to scale applications.
    In ASP.NET Core, we can achieve this by using asynchronous HTTP calls (asynchronous
    programming): [https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 异步通信是帮助扩展应用程序的方法之一。在ASP.NET Core中，我们可以通过使用异步HTTP调用（异步编程）来实现这一点：[https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/)
- en: You should be careful with operations while handling asynchronous communications,
    for example, when adding a new product with an image. A system is designed so
    that it creates a thumbnail of the images in different sizes. This is a time-consuming
    task that could lead to a performance hit if handled incorrectly. From a design
    perspective, an asynchronous operation would not work in this scenario. Here,
    you should implement something like a task with a callback that tells the system
    when a job is complete. Sometimes, you may also require middleware to handle requests.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理异步通信时，你应该小心操作，例如，在添加带有图片的新产品时。系统被设计成可以创建不同尺寸的图片缩略图。这是一个耗时任务，如果处理不当可能会导致性能下降。从设计角度来看，异步操作在这种情况下是不可行的。在这里，你应该实现一个带有回调的任务，告诉系统何时完成工作。有时，你可能还需要中间件来处理请求。
- en: The best way to implement asynchronous communication is with an asynchronous
    RESTful API.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 实现异步通信的最佳方式是使用异步 RESTful API。
- en: When creating a scalable system, you must always think about asynchronous communication.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建可扩展的系统时，你必须始终考虑异步通信。
- en: Summary
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed scalability, including the libraries available
    to help with it, tools, and so on. We then discussed how to scale RESTful services,
    what to consider when we design them, and how to avoid cascading failure using
    different patterns.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了可扩展性，包括帮助实现它的库、工具等等。然后我们讨论了如何扩展 RESTful 服务，设计它们时需要考虑什么，以及如何使用不同的模式避免级联故障。
- en: In the coming chapters, we will discuss and build a web client to call and consume
    RESTful services.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论并构建一个网络客户端来调用和消费 RESTful 服务。
