# 有限上下文

到目前为止，我们已经花费了大量时间在我们的“市场”系统上，因为它将是一个单一的应用程序，有一个 API，可能还有一个与该 API 通信以服务其用户的 Web UI。然而，现在是我们退一步，看看大局的时候了。

我从 15 岁开始编写软件；因此，在撰写这本书的时候，我在行业中的经验接近 30 年。我构建的一些系统已经被新的东西所取代，而一些系统仍然非常活跃，由其他开发者进一步开发。今天，作为一名软件架构师和顾问，我在行业中继续前行，参与了许多实际活动，例如原型设计、建模和编写生产代码。多年来，我不仅作为开发者不断进步，编写出更好的代码，而且对构建复杂系统的基本原理有了更深入的理解。这些知识和经验使我能够为我的公司创造更成功的系统，这些系统将在几年内不断进化，而无需进行大规模的重写。

我认为使我成为一个更好的开发者和架构师的事情之一是意识到系统很少可以被建模为单一且不可分割的东西，作为一个单一单元。我们在第二章中讨论了语言的上下文性质，“语言与上下文”，并希望这能让你理解上下文的重要性。

在我的职业生涯中，我看到了许多被实现为单一代码库的复杂系统，它们有一个单一的数据模型来支持。在本章中，我们将更深入地探讨这种方法，并希望说服你它并不总是有效，而且有更好的方法。我们将花一些时间讨论如何使用语言上下文来发现整个系统中可以更高效地开发的部分，这些部分具有良好程度的隔离和自主性。

在本章中，你将学习：

+   语言边界如何帮助识别系统边界

+   有限上下文的定义

+   将系统拆分为部分的好处

+   当上下文边界不明确时，需要考虑哪些因素

# 单一模型陷阱

让我们看看软件通常是如何开始的，当开发者第一次接触键盘并开始编写代码时，希望构建一些有用的东西。我们将跟随软件公司（或 IT 部门）在多年中为满足用户需求而采取的通常进展，他们努力使软件更有用，增加功能并修复问题。接下来我所描述的是软件解决方案通常的进化增长，这种增长可以在任何地方找到。可能我即将描绘的画面中的一些部分你会觉得熟悉，并且与你的经验产生共鸣。

# 从小做起

我们很少遇到那些有宏伟计划用壮丽的软件征服世界，为人类解决巨大问题的公司。好吧，有些企业尝试过但不可避免地失败了，这可能是人们很少忘记的宝贵教训之一。更常见的是，企业试图解决人们经常遇到的真实问题。至少，这是公司运营者所相信的。所以，作为一个开发者，你可能会在一个规模合理的系统上工作，除非你为像微软或 SAP 这样的软件巨头工作。但不要弄错，他们也是从小开始的，尽管大多数人忘记了这一点。

当几个开发者开始对一个系统进行工作时，一切运作得相当顺利，因为团队规模小，目标希望很明确。如果他们试图解决的问题真实存在，解决方案可行，公司可能会在花费一两年时间构建软件的第一个版本后很快开始赚钱。到那时，系统仍然相对较小，构建它的人数不会超过几个工程师。像 Uber、AirBnB 和 GitHub 这样的公司都是这样开始的。

在一开始，一切都很顺利。然后，在某个时刻，系统变得相当大，由于系统规模的原因，生产力开始下降。一个单一的数据模型因为许多不同的原因被修改，多个产品所有者或项目经理之间的利益冲突开始出现，他们各自有自己的团队在不同的系统部分工作，开始因为日益增长的冲突而挣扎。协调工作增加，因为不同的团队在系统中触及了他们未曾预料到的地方，但他们必须这样做才能完成工作。但通常这样的变更会干扰其他团队的工作。发布需要高度协调，有时发布的工作量甚至超过了创建功能的工作量。公司从不周五发布，因为风险太高，人们几乎可以肯定在测试阶段没有发现所有错误，尽管质量保证团队已经尽力了。修复错误变成了一项具有挑战性和艰巨的任务；修复一个错误开发者会创造两个新的错误。

这听起来熟悉吗？如果不熟悉——你非常幸运，可能你工作的公司已经在做领域驱动设计（DDD）或类似的事情。对我来说，在行业里度过了几十年，这种情况非常普遍。说实话，我从没在一家没有这些问题的公司工作过。那么，这样一个既小又简洁的系统是如何最终变成一个无法管理的怪物，让开发者不敢触碰的呢？

# 复杂性，再次

如果你已经在软件开发行业工作了几年，并在一家或多家公司工作过，你很可能参与过一些生产系统的工作。通常，处于生产状态的系统以某种方式为用户提供价值。这样的系统可能是一个全球范围内的人们用来解决日常任务的产品，比如在线购物或通过实时地图追踪他们的宠物。其他系统则用于内部，以支持公司员工的工作，并通过这种方式间接地贡献到价值链中。这可能包括供应链管理、财务、账单、调度或收益管理系统。许多公司开发他们的内部系统，这些系统包含了公司多年来通过其成功的历史传承下来的最高级别的领域知识。

通常，人们需要软件来解决复杂问题。复杂问题很少能通过简单的解决方案来解决；我们在第一章，“为什么是领域驱动设计？”和第二章，“语言和上下文”中花了大量时间讨论这个问题。处理复杂系统的一个不可避免的特点是，这些系统会随着时间的推移而增长。工程师们越来越掌握业务洞察力，并在代码中捕捉用户不断变化的需求。这种进化进步不可避免地导致软件的复杂性不断增加，反映了软件试图解决的商业问题的复杂性。

因此，即使最初的计划是构建一个相对简单的解决方案来解决我们认为人们在日常工作中遇到的一两个问题，希望他们通过购买我们的产品来感谢我们，我们发现自己从一开始就站在了一个滑梯上。我们的用户永远不会完全满意。没有人愿意为不发展的事物持续付费。所以，除非你正在为智能手机开发一个简单、吸引人的游戏应用，希望有数百万人一次性付费，否则你很可能正在构建一个随着时间的推移而演变的软件。

更多的时候，我们无法为我们的软件创建一个能够持续多年的模型。我们对领域的理解在变化，我们的无知在减少，我们对用户及其愿望的了解也在增加。三个月前还清楚的事情，现在可能就不那么清晰了，去年还非常合适的模型现在可能已经成为了一个障碍。但是，我们是否一直在花费时间寻找更好的模型，并重构我们的代码以反映这些新的见解呢？嗯，不一定。

当系统处于初期且市场竞争压力巨大时，开发者们被迫优先交付新功能。因此，软件在功能数量、代码行数、数据库表数量以及它们之间的关系上不断增长。我们没有时间停下来，深呼吸，审视模型以查看是否可以进行改进。我甚至不会提及为已经交付的功能重构代码的时间——事情已经完成；项目经理很少会理解重写已工作代码的需求。

但这还不是最糟糕的部分。正如我之前提到的，几乎所有系统都是从一个小型的代码库开始的。一个小的持久化模型，或者我们更常听到的，*数据模型*，随之而来。我们可能甚至没有类图，但肯定有人花时间为系统创建了一个关系模型，因为关系数据库被视为几乎在这个世界上持久化任何事物的*默认*选择，尤其是如果你在一个由企业和公司主导的.NET 空间工作，这些企业和公司更喜欢使用来自微软的一切。所以，大多数情况下，我们选择 SQL Server。

也许我画出的这幅图太暗了，但在我几十年的行业工作中，我见过它很多次，很难让它变得柔和。这一切是否让你感到熟悉？那么，究竟哪里出了问题？当然，我们可以把所有的问题都归咎于 SQL 数据库，并试图将它们改变得更加花哨，但我们真的能确定通过这样做就能解决上述问题中的任何一个吗？毕竟，数据库只是工具，就像任何其他工具一样，它被使用或误用。

# 大泥球

我在上一个部分描述的是一种被称为*大泥球*（或更精确地说，反模式）的图案。这个术语是由布莱恩·马里克提出的，后来由布莱恩·福特和约瑟夫·约德在他们的论文中普及，该论文出人意料地名为*大泥球*，发表于 1997 年([`www.laputan.org/mud/`](http://www.laputan.org/mud/))。

开发者并不是有意创建后来可以用这个可怕的术语来描述的软件。我们在管理层的压力下不断工作，他们希望从我们所构建的软件中获得价值，他们看到的价值是新的功能。因此，我们实际上没有时间来改进我们软件的结构。至少，这是当我们被问及为什么代码如此复杂且难以维护时，我们给出的最常见的借口。

但是，这是真的吗？这是我们忘记架构和设计的唯一原因吗？当然，给出的原因是有效的，但不是唯一的。我们往往忘记的是，我们并没有真正构建系统。这样的系统已经存在，我们的软件只是某个系统的一部分。

想想任何一种商业。如果你在银行工作，银行就是系统。它可能在没有目前银行员工使用的软件的情况下就已经存在了。银行之间相互连接，并且受到严格的监管。他们有客户，客户对银行提供的服务可靠性以及资金安全有一定的期望。这仅仅是我们周围可以找到的无数例子中的一个。

我们反复犯同样的错误，那就是将软件视为一个独立的系统来开发，而忽略了它只是更大系统的一部分，而这个更大的系统本身也是一个系统。正如我之前所写的，软件通常解决复杂问题，因此存在于某个复杂系统的大景观中。那么，什么是系统？

在唐娜·H·米多斯所著的《系统思考》一书中，将系统定义为元素集，这些元素是相互连接的。这些元素以协调的方式组织。

从如此简短的定义中，我们可以学到许多令人惊讶的东西；目前，让我们集中关注这样一个事实：没有系统只由一个部分组成，系统的各个部分总是相互连接，相互之间交换信息，而这正是我们常常忘记的东西。系统部分不是类、模块、数据库表或存储过程。这些都是某个系统部分的原子。我们通常试图把太多的部分放在一个盒子里，称之为软件系统。让我们检查一个简单的例子，以说明我们不可避免地走向一团糟的大泥球的道路。

想想一个处理客户订单的电子商务系统。显然，我们需要一个地方来保存我们销售的所有产品的信息。当然，我们必须能够下订单并跟踪订单周期，从下单的那一刻直到交付。我们从小处着手，创建一个简单的模型，比如这个：

![](img/9cd7ad90-e3a6-4a8a-91d1-557b6b7cbd50.png)

简单的电子商务模型

当然，过了一会儿，我们意识到每条订单行上的价格不能参考产品价格，而必须在创建行时固定，所以我们也将这一点实现。后来，我们得到了一个要求保留供应商信息的要求。然后，我们必须添加产品图片 URL。当我们开始真正做事时，我们必须保留库存水平信息。不久之后，我们得到了一个要求添加产品包装信息以及尺寸和重量，以便能够计算运费。在我们意识到这一点之前，我们的模型看起来已经相当不同了：

![](img/616e2b0b-c1a5-40ba-b411-bab7a3631f2e.png)

随着时间的推移，模型变得越来越大

你可能会注意到完整的模型肯定不同，因为你可以找到像`PaymentMethodId`、`PaymentTermsId`和`PaymentId`这样的引用，这些必须指向某些表。但我认为这已经足够展示其本质了。

我在这里要说明的是，我们可以清楚地看到，一个小的原始模型在来自不同方向的需求驱动下不受控制地增长，试图一次性满足所有需求。你可能注意到`Product`表中的一个字段，称为`UpdatedAt`。这不是我发明的，而是在一个样本模型中发现的，作为 Stack Overflow 上某个问题的答案。现在，让我们想象一下我们放入这个字段中的日期的意义。是在那个日期更新了产品的名称吗？或者价格？或者，也许，库存水平？所有这些变化都有完全不同的原因；然而，我们只有一个字段来保存更改的日期和时间。

这种模型的危险是什么？最终，有无数的产品在其后端有这种模型，其中一些甚至相当成功。但我不这么认为。这样的公司和产品通常是在这种模型下繁荣，而不是因为这种模型。让我们看看当不同利益相关者请求功能时会发生什么：

![图片](img/e3a82bde-4532-4ccf-99b5-8b5f61e090af.png)

不仅仅是代码需要耦合。它适用于整个组织。

销售团队现在对以套餐形式销售产品感兴趣。他们告诉我们，这相当简单——我们只需要创建一种**特殊类型的产品**和简单的父子关系。他们并没有真正考虑供应链，但我们目前所有这些信息都集中在一个地方。如果这个虚构的包装产品的不同组件来自不同的供应商，那么实际上**谁是**它的供应商呢？库存水平似乎更加复杂，我们似乎必须按需计算？

销售团队还希望与客户保持更紧密的关系，并在他们停止从我们这里购买时给他们打电话。也许他们找到了另一个供应商，我们可以给他们提供折扣？为了做到这一点，我们**只需**跟踪每个客户的销售总额，并将这些数字与我们的历史数据进行比较。但是，我们没有历史数据，那么我们最初从哪里得到这样的数据呢？

财务团队希望看到支付产品后客户的总未结金额，即所谓的**信贷额度客户**。如果他们付款延迟，财务部门应根据金额决定不同的催收策略。他们认为这只是在`客户`表中**添加另一个字段**。

我们还必须处理营销团队的要求。他们希望通过展示更多产品的图片来提高销量。目前我们只有一张图片，他们至少想要三张；但理想情况下，他们需要任何产品无限数量的图片。因此，我们或者需要在`产品`表中**仅添加两个更多字段**，或者添加一个包含多对多关系的照片新表；但在后一种情况下，我们必须处理数据迁移。

所有这些请求都有潜在的冲突。我们可以清楚地看到，当开发人员开始工作在这些新功能上时，模型的相同部分将被触及。让我们给这幅图增加更多损害，并记住我们有三个开发团队。一个团队只做后端更改，另外两个团队做前端工作——一个用于网页，另一个用于传统的 WinForm 客户端。

现在的问题是，我们有三种相互冲突的力量推动他们的请求传递给开发者，而且还有三个相互冲突的开发团队在同一个模型的同一部分工作。很难想象，如果前端团队在后台团队对数据库模型进行必要的更改以及所有必要的层之前完成他们的工作，他们能否完成。

总体来看，我们可以看到，对于任何比`Hello World`应用更不平凡的事物，单一的模型很可能会导致一团糟。这种情况可能在几个月后发生，但如果有一个小团队的好开发者，公司可能会对这样的模型感到满意一段时间。但是，一旦业务和系统增长，泥潭怪物就会到来，可能会造成很多损害。至少，生产力会受到影响。最严重的情况是，客户会因为缺乏进展和整体应用性能而感到非常烦恼，以至于他们可能会离开。

# 系统结构

我知道到目前为止，我描绘了一幅相当令人恐惧的画面——当软件无疑地滑向成为一个无法管理的意大利面代码团。你可能会想：如果我们最终陷入恐怖之地，那还有什么意义呢？当我们发现自己身处其中时，我们可以从头开始，从过去的学习中构建一个新的、闪亮的、明亮的系统，使用最新的技术，一切都会再次变得顺利。我们稍后会回到大重写的话题，但现在，让我们思考一下为什么新系统会比旧系统更好。

无论我们是在计划创建一个新的软件系统还是重构旧的系统，至少我们可以做一件事来确保我们的软件在相当长的一段时间内保持良好的状态。我们可能无法使用最喜爱的编程语言、新的闪亮的银弹框架或一个花哨的新数据库，因为我们的组织有一些难以或无法对抗的限制。这些限制很少对我们设计模型的方式施加重大的限制。在领域设计方面，模型是我们找到构建更好软件的关键。

在第三章，“事件风暴法”，我们讨论了领域模型。我们应该记住，模型并不代表现实世界。相反，模型提供了一个简化的现实世界版本，这对于构建特定的软件是相关的。在这本书的整个过程中，我们学会了避免给我们的模型提供比解决我们用软件试图解决的具体问题绝对必要的更多信息和行为。

但现在我们看到，随着软件关注点的增加，模型中所需的信息量也在增加。同时，我们清楚地看到，这些信息是由开发者故意组合成一个单一模型的，他们倾向于用无关的属性丰富领域对象。这通常是因为领域对象名称在不同领域之间似乎相同，但开发者没有意识到这一点。

现在，我们将探讨如何更好地构建我们的软件结构，为具有相似名称但含义不同的概念提供清晰的分离。DDD 提供了 *边界上下文* 的概念来定义这种分离，我们将探讨如何寻找和定义这些上下文的边界。

请不要误解，当我写关于系统结构化、远离单一模型并引入边界时，这并不意味着拥有多个可执行文件、使用微服务、迁移到 Docker 等等。使领域模型变得合理化是最重要的主题，我们将在下一章中触及实现细节。

# 语言边界

记得我们在讨论聚合设计主题时提到的 *变化速度* 吗？所以，你可能想知道我们现在是否在原地打转。确实，我们可以清楚地看到，像产品的缩略图 URL 或照片 URL 这样的东西与产品价格或库存水平没有任何关系。如果产品受欢迎并且我们有足够的客户，库存水平可能会每秒变化。价格也可能动态变化，但我们预计它会更加稳定。然而，照片、重量和包装尺寸可能永远不会改变。将所有这些信息放在一个聚合中并不是我们愿意接受的事情，而且我们已经学到了这一点。

那么，我们把它放在哪里呢？我们是否创建几个名为 `Product` 的聚合？虽然这听起来可能有些奇怪，但如果我们能识别出每个聚合将存在的边界，答案可能是 *是的*。我们还必须与我们的领域专家交谈，并获取更多见解，至少关于语言方面。那里可能会有一些新的发现，例如库存水平确实被称为 `Inventory`，而不是 `Product`。但对于其他领域，如销售、营销和采购，他们可能使用相同的术语，但含义不同。正如我们在 第二章 中学习的，*语言与上下文*，我们可以看到上下文在那里正在变化。

当我看到像`Customer`、`Person`、`Contact`或`Order`这样非常常见的词语在一个庞大的代码库中散布时，我的脑海中就会响起警钟。这里可能有龙或，更具体地说，一个大泥球。这个系统的开发者没有足够谨慎地深入研究领域特定性，以找到这些术语在业务的不同部分中的含义。如果我们看看之前图中`Product`的例子，我们就可以看到没有特定原因地将不相关的概念放在一个对象中。

我无法强调这种做法对软件及其以外的危险程度。想想您可能参加的与两位领域专家的会议。一位会告诉您添加更多图片以丰富目录。另一位只对配送过程感兴趣，需要产品的重量和包装细节来计算运费。您可能会注意到他们语言上的差异，并且从这样的对话中，您可能会了解到您已经拥有或计划实施的单一模型不会满足业务需求。

因此，定义关于词语意义的边界上下文，寻找特殊性，并渴望真正理解这些词语被使用的上下文，这是找到上下文边界的第一种也是最有力的方法：

![](img/ac75fdbe-476c-4f73-ae09-e1d64424241a.png)

词语在上下文中改变含义

如您所见，一个在特定上下文中具有不同含义的单个术语可以在其自身的上下文中以简洁的意义进行建模。我们不再只有一个具有无关属性的单一对象，而是有多个。这些新对象要小得多，只包含与特定上下文相关的信息。在一个上下文中对对象所做的更改不应影响其他上下文中具有相同名称的所有其他对象，并且可以由在该上下文中进行更改的开发者自由地进行，从而消除或至少最小化在其他地方引入问题的风险。自然地，这引出了边界上下文的下一个目的和好处：开发团队的自主性。

上下文边界的另一个方面是扩展的*告诉，不要询问*原则。原始原则是由 Alec Sharp 在他的 1997 年出版的书籍《Smalltalk by Example》中提出的。

如您可能从自己的经验中注意到的，在生产的软件中有很多使用过程式风格的代码，即使它是用面向对象的语言编写的。不幸的是，基于.NET 的项目深受其害，特别是那些使用 WinForms 和 ASP.NET ([`dotnet.microsoft.com/apps/aspnet`](https://dotnet.microsoft.com/apps/aspnet)) WebForms 编写的项目。我见过许多应用程序，其业务逻辑集中在代码中——在 UI 元素后面，分散在许多`OnClick`事件处理器中。

设计更好的软件使用独立的类来实现业务逻辑。将业务逻辑从 UI 逻辑和持久性中隔离出来的模式被称为**多层架构**或**n 层架构**。维基百科将这个术语定义为一种**客户端-服务器**类型的架构，但这并不完全准确。如果应用程序是一个桌面富客户端应用程序或具有服务器端渲染功能的 Web 应用程序，其中所有操作都会导致与服务器的一次往返，那么即使没有分离客户端和服务器代码，也可以有多个层次。

当我们在寻找上下文边界时，一个可以帮助我们找到它们的指标是所需做出决策所需信息的可用性。当用户（这可能包括其他系统）向领域模型发送命令时，模型本身必须能够处理这个命令，而无需去系统的其他部分获取信息。这可能在开始时有些令人困惑，因为我们可能会看到一些命令需要大量的信息，而这些信息我们认为是位于执行命令的上下文之外。让我们再次看看电子商务的例子：

![图片](img/9e6a4f14-4746-4b78-8de2-56e386cf6d33.png)

做出决定需要几个查询

当我们告诉`Sales`上下文的领域模型放置一个订单时，它似乎需要从其他上下文中获取大量信息来做出决策。这可能会造成相当多的困惑，如果我们没有经过思考就跟随直觉，我们几乎无法抵制把整个系统的所有信息放在一个地方的冲动。而且，大泥球问题再次出现。

在现实中，我们只需要从其他环境中获取信息的一小部分来做出那个决定。此外，如果我们考虑影响该信息的命令，我们可以清楚地看到，其中没有任何一个会触及销售环境。例如，库存水平仅在`Inventory`环境中更新。客户的可用信用额度在协议的初始信用额和未付款发票数量之间保持平衡。客户的联系信息以一种完全独立的方式更新，与其他任何事物无关。

但是，你可能已经注意到，仍然存在一定程度的信息交换。库存水平是如何变化的？客户的未付款金额是如何更新的？当然，有一些动作会触发这些更新。我们感觉这些触发器与订单处理有关，这甚至可能会增加我们把这些东西放在一起的确信度。

但等等，订单下单时库存水平并不一定会减少。我们可能需要与领域专家澄清这一点，但可以肯定的是，库存只有在订单发货时才会更新，而这可能不是由“销售”部门处理，而是由“发货”上下文处理。同样，总未结金额也只有在发送订单发票时才会更新。这反过来可能只发生在订单发货或交付时。所以，你可以看到这些上下文之间的联系并不是那么直接和简单。其中涉及更多的逻辑，我们可能一开始甚至都没有考虑到。

在下一章中，我们将简要讨论跨上下文通信的话题，但现在我可以告诉你，它遵循相同的“只告诉，不询问”原则。上下文在执行每个命令后都会发出领域事件，正如我们在第三章“事件风暴”中学到的，甚至在早期章节中已经实现。我们从未使用这些事件来共享信息，但这正是必要且仅必要的数据跨越上下文边界的方式。因此，我们可能需要一些原本未考虑到的上下文特定对象。让我们看看“下单”命令的修订图和执行它所需的详细信息：

![图片](img/045a56d0-a7ba-4210-bc39-3a5e4e800619.png)

只告诉的流程

在这里，你可以看到已经没有“询问”箭头了。我们所做的只是“告诉”其他人去做某事，或者某事已经完成。

有两点我想引起你的注意：

+   你可能会想知道为什么 CRM 上下文没有与“销售”上下文共享任何信息。我们难道不需要客户详情来下单吗？并不完全是这样。我们可能需要这些信息来知道客户的名字和联系详情，以便知道订单需要送到哪里。但没有任何这些详情是决定我们是否可以下单所必需的。当然，我们可能会遇到更复杂的要求，当某些送货地址的订单无法下单时，但这需要与领域专家澄清，并且显然需要更多的领域知识才能将这些约束纳入系统中。

+   我经常听到抱怨，说在不同上下文中保持同一物理实体的信息会导致数据重复。在前面图表中展示的模型中，情况并非如此。我们共享的信息并不完全等同于每个上下文中我们保留的数据。例如，可供销售的产品数量并不一定复制当前的库存项目。可能涉及一些更复杂的规则，而销售领域对这些规则保持愉快的不知情，这些规则完全属于“库存”上下文内部。但是，一些数据肯定会被重复，这是为了保持我们的模型整洁而付出的微小代价。在多个地方保留相同的数据并没有什么害处，现在的磁盘空间并不是一个大问题。

但我们绝对必须确保保持信息同步是可靠的，这一点我们将在下一章中探讨。

# 团队自主性

如果你曾经使用过看板或者至少了解过它，你可能记得这个方法的圣杯是减少**工作在进度中**（**WIP**）。你可以从看板实践者那里学到很多东西，但如果你不限制 WIP，你其实并没有在做看板。顺便说一句，这也是为什么团队在尝试这种方法时经常失败的原因。

最初，将工作分成小批量以消除队列和沿价值创造流储存材料的想法来自制造业。你可能听说过源自看板的**丰田之道**，或者由 Eliyahu M. Goldratt 提出的**约束理论**（**ToC**）。尽管这些方法的哲学来自一个相当不同的行业，其中一些方面与软件行业截然不同，但我想要强调以下两个原则，我们可以直接将这些原则应用到我们的工作中，以便更有效地交付业务价值：限制工作在进度中和提高吞吐量。

# 限制工作在进度中

当一个团队或个人开发者同时处理一个待办事项列表时，完成列表中的任何一项通常会比他们只专注于一件事情花费更多的时间。这种情况尤其是因为上下文切换，正如我在第二章“语言与上下文”中提到的。当我们从一项任务切换到另一项任务时，总会有一段时间损失，这是为了将我们的思维状态调整到可以高效地处理新任务。我们未完成的事情越多，需要记住的事情就越多，当我们回到未完成的任务时，就需要从记忆和笔记中恢复这些事情。

当团队在一个具有单一模型和单一单体代码库的系统中工作时，这些团队将需要相互协调。协调可能需要防止因无关原因而更改共享类别的变化。他们还可能需要确保在一个团队进行更改之前，另一个团队做一些前置工作。数据迁移、回归测试、协调发布等等——我们对团队之间这种类型的依赖关系非常熟悉。

但是管理层很少关心这种依赖关系。如果在站立会议期间，一个团队报告说他们正在等待另一个团队完成他们的工作，他们的经理会要求他们在等待期间做其他事情。当这种情况发生时，他们会得到一个无法立即完成的 WIP 项目，因此他们会从待办事项中拉出一个项目并开始工作。那个项目可能也会有一些依赖关系，因此未完成的工作数量会像雪球一样滚雪球般增加。团队开始互相指责，因为他们都在等待别人，以至于什么都没有交付。

在这种情况下，受影响最大的是吞吐量。

# 提高吞吐量

如果交付管道中的某个步骤很慢，整个管道的生产能力不会超过这个单个步骤。当团队在一个单一代码库和单一模型上工作时，他们可能会遇到两个主要问题。首先，正如前一段所述，总是不断增长的工作在进度中。持续的协调和连续的等待导致大量未完成的工作。一些来自*进行中*列表的项目在等待结束后最终会再次被处理，但随后是上下文切换。有时，团队可能会花费几天或几周的时间来恢复几个月前搁置的工作。在跨团队协调——等待其他人完成前置工作并回到新上下文——这段时间内，时间被浪费了。在这段时间里，没有产生任何价值，但钱就像团队在做一些有用的事情一样被花掉了。

可能影响吞吐量的另一个因素是瓶颈。如果所有变更都需要由两个团队完成，无论一个团队的速度有多快或有多聪明，如果另一个团队速度慢或人员不足或技能不够，那么工作将不会在两个团队中最慢的那个团队完成其部分之前完成。这种情况通常发生在组织不是基于领域专业知识或功能，而是基于技术技能来划分团队的情况下。一个典型的例子是前端团队、后端团队和数据库团队。你不需要所有三个团队，只要有两个就足以对价值链造成巨大的损害。在数据库模式更改之前，后端无法完成任何工作。在后台工作成形之前，至少在 API 合约的形式（如果公司足够有技能来拥抱基于合约的开发）中，前端团队几乎无法做什么，而不会面临重写一半代码的风险。

当团队以这种方式组织时，我们可以在现实生活中观察到康威定律最糟糕的例子。

# 康威定律

五十年前，在 1968 年，Melvin E. Conway 发表了名为《委员会如何发明？》的论文([`www.melconway.com/research/committees.html`](http://www.melconway.com/research/committees.html))。也许这篇论文最被引用的部分就是我们现在称之为**康威定律**的表述，它指出如果一个组织设计一个系统，它将产生一个与该组织通信结构副本的设计。

我现在不想让你负担太多细节，但请记住，这个定义变得如此相关，以至于 2017 年 DDD 欧洲会议的主题就是康威定律。

在本章的背景下，我个人的观察是，组织如何构建团队直接影响了他们软件的结构，这非常证实了 Mel Conway 的假设。我给出了一个技术导向团队的例子，因为我在我职业生涯中不止一次经历过。在一个组织中，我看到负责系统用户界面 Web 部分的团队与负责同一系统的丰富客户端的团队发生了如此多的冲突，以至于他们决定为各自创建一个独立的领域模型，并支持一个独立的数据库模型，以便使用。这是为了完全避免这些团队之间有阻塞依赖，因为他们找不到一个好的协调方式。这些团队之间因为互相指责而流了很多血，但在我看来，这种情况是不可避免的，没有人应该为此负责，除了决定以这种方式构建团队的管理层。

团队间的协调很少有效，通常会导致延误，花费大量时间在会议和上下文切换上。它还会在团队之间产生紧张关系，并增加陷入责任游戏的危险。我们可以谈论*提高沟通*多年，但这甚至不会稍微改善协调。

# 松耦合，高内聚

我可能已经让你淹没在我们行业今天大规模遭受的问题的海洋中。让我为这幅图带来一些光明，并给你一些线索，关于我们如何可以改善这种情况。

作为开发者，我们经常听到我们需要努力追求代码中的松耦合和高内聚。总的来说，一个单元负责一件事的原则不仅适用于我们代码中的类，例如，也适用于**面向服务的架构**（**SOA**）中的服务。它同样适用于团队的责任。围绕团队的技术专长来构建团队是不太理想的。让我们看看当有两个不同的功能请求时，这样的团队可能会如何运作：

![图片](img/0c9416cb-57f5-4c33-9ce2-6158645f76e9.png)

需要协调的流程

图中展示的流程被大大简化了，但你能理解这个概念。那些团队在完成这两个故事时所做的、分布在各个工作块之间的所有空白区域几乎都是浪费的。这些时间本可以用来等待、上下文切换以及当不同团队的开发者需要就其他团队交付成果中的工作顺序和发现的问题达成一致时进行的小规模协调。最终，在规定的时间内没有完成任何交付，团队不断在任务之间切换，但发布却一直被不断推迟。

然而，如果团队是围绕业务功能或领域组织起来的，情况将完全不同：

![图片](img/6ba01d02-141b-425d-bc92-f33bd8c56ec1.png)

无需协调的流程

不要被工作的线性流程所误导，因为它被放置在单一的时间线上。所有这些步骤都可以在迭代中进行，但如果团队需要协调，迭代本身并不能救你。

即使工作量或多或少相同，尽管由于更好的专注度和更深入的领域知识，这可能会更少，但协调努力和上下文切换已经消失了。两个团队都能够独立发布并准备好接受新任务。

高度一致性和松散耦合的团队是备受赞誉的 Netflix 文化的基本原则之一，例如。使这种结构甚至可行的一个先决条件是每个团队都有明确的操作边界。然而，这并不意味着团队必须被分配到单一边界上下文中工作。你可能会识别出六个上下文，但只有三个团队。在这种情况下，首先需要考虑团队规模。如果每个团队有 10 名成员，可能希望有更多规模较小的团队。五人团队在保持信息共享紧密和反馈循环短方面是可行的。

但是，一个团队可以拥有的上下文数量没有限制。我可以很容易地想象一个由只有 10 名工程师的初创公司开发的相当复杂的系统。他们可能会发现，由于他们试图解决的问题的复杂性，系统需要用 10 个边界上下文来建模。如果他们把所有开发人员分成两个五人团队，每个团队可以处理多个上下文。这里最重要的方面是上下文的拥有权，因此团队不应共享上下文。所有权的转让是可能的，但应该是罕见的，并且应该是完整的，以便在转让完成后，只有一个团队拥有该上下文。

边界上下文与团队之间的匹配也可以提供公司可能需要的工程师数量的指示。如果核心业务领域被正确识别，大多数开发人员很可能会在核心领域工作。随着时间的推移，可能会出现一个团队专注于核心业务问题，而另一个团队则处理所有支持性子域的工作，例如账户管理、支付处理和账单。当软件的复杂性增加时，这些支持性子域可能会转移到新的团队。如果已经确定了新的核心领域，其他团队需要负责。

# 地理位置

关于康威定律的最后一个要点是团队的物理位置。这可能令人惊讶，但这一方面非常重要。如今，越来越多的公司雇佣远程工作者，他们在家工作，并在地球的不同部分保持开放式办公室。请记住，尽管这种劳动力分布可以更广泛地获取人才，但也带来了与本地团队和分布式团队完全不同的沟通负担。

如果一个边界上下文被分配给一个包含不同国家成员的团队，或者更糟糕的是，在完全不同的时区，将涉及很高的风险。如果这个团队的工程师是经验丰富的远程工作者，可能根本不是问题。但如果这个团队的人习惯在办公室工作，突然被要求与一个在他们计划回家时醒来的人一起工作，可能根本行不通。因此，如果你的公司没有太多与远程员工一起工作的经验，保持地理集中化是一个好主意。

这不应该被视为雇佣其他国家人员并让他们远程工作的障碍。但你可能希望有几个人能坐在同一个地方，或者至少住在同一个城镇，这样他们可以高效沟通，定期会面，甚至共享一个办公室，并将他们称为一个团队。这样的团队可以轻松地承担你软件的一个或多个边界上下文的所有权。协调负担的减轻和高度自主性——这些明确定义的边界上下文的益处无疑将使远程团队更加成功和高效。

事实上，我相信我们听到的许多失败，当公司在开设远程办公室一段时间后宣布这次经历是失败时，这与这些公司无法将分配给远程团队的工作明确为边界上下文有关。如果团队在一个共享的代码库上工作，他们必须协调。他们可能会做出相互冲突的更改，而当团队地理上分散时，所有这些负担和挫败感都会增加 10 倍。

# 摘要

在本章中，我们终于开始使用“边界上下文”这个术语。对于刚开始学习领域驱动设计（DDD）的人来说，这往往被忽视。在埃里克·埃文斯（Eric Evans）的《边界上下文》一书中，它被解释在战略设计部分，这部分在书中出现得相当晚。在介绍边界上下文概念之前，这本书介绍了许多有用的模式。自然地，人们开始使用他们所知道的东西，有时发现这已经足够了。

但不要误解，DDD（领域驱动设计）的力量并不在于聚合（aggregates）和仓储（repositories）。如果你有一个针对大型、复杂软件系统的单一模型，拥有聚合和仓储并不能帮助你。当大量开发者使用单一模型时，他们会面临广泛的协调需求、冲突的变更、回归错误、认知过载和持续的上下文切换问题。在这样一个系统中，上下文没有得到适当的阐述，但这并不意味着它们不存在。只要业务中有人专门执行不同的业务功能，这些上下文就会存在。上下文隐藏在大量的代码行、众多类和包含关于发生的一切信息的数据库表中。因此，上下文切换是存在的，无论你是否喜欢。

正如我第一次从 Vaughn Vernon 那里听说，DDD（领域驱动设计）是在边界上下文中开发的一种通用语言。我非常喜欢这个定义。它将 DDD 的两个最重要的原则带到了聚光灯下。没有什么比正确使用语言更重要，然后为具有相同但含义不同的词汇找到语言边界。这将是我们找到上下文边界的第一个明显步骤。

康威定律（Conway's law）是你不能忽视的东西。如果团队不是按照业务能力和功能来组织，而是按照技术责任来专业化，即使完美的边界上下文也无法帮助你。只有围绕系统功能方面组织、负责一个或多个边界上下文、能够有效且成功工作的跨职能团队才能做到这一点。这是因为定义良好的上下文边界为团队带来了最高的自主权，只要不超过一个团队拥有一个边界上下文。这并不意味着你的组织必须有与已识别的边界上下文数量一样多的团队。一个团队可能可以处理多个上下文，但反之则不然。高一致性和松散耦合不仅适用于类和服务；这些原则对于构建能够交付成功的团队是基本的。

不要忘记你同事的位置。分布式团队如果由有远程工作经验的人组成，是可以工作的。但远程团队可以负责一个或多个边界上下文，因为它们不需要与其他团队进行大量的协调。
