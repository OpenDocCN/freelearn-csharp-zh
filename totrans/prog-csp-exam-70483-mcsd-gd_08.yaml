- en: Creating and Using Types in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Types are the building blocks of a C# program. Even while writing a basic C#
    program, we must use the right types while creating our program. In [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml),
    *Understanding Classes, Structures, and Interfaces*, we learned the basics of
    types in a C# program. We learned about the value and reference type variables
    that are present in a C# program.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to awareness of the different types, we should also understand that
    it's quite important for us to use each type in the best possible circumstance
    or situation. We also should be aware of the best practices regarding the creation
    and usage of these types. We will be going through this in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will walk through the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use properties to enforce encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using of optional and named parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating indexed properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different operations related to string manipulation in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will have an overview of **reflection** and try to understand how it can
    help us find, execute, and create types at runtime. In [Chapter 10](b7bdae98-fc5b-4430-bb0d-b8541ca64f8d.xhtml),
    *Find, Execute, and Create Types at Runtime Using Reflection*, we will do a deep
    dive into reflection.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like in the previous chapters covered in this book, the programs explained in
    this book will be developed in Visual Studio 2017.
  prefs: []
  type: TYPE_NORMAL
- en: The sample code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples](https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples).
  prefs: []
  type: TYPE_NORMAL
- en: Creating types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we create a variable in C#, it provides us with plenty of options to choose
    the appropriate type of the variable. For example, we can choose the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We can choose an `enum` type if we would like the variable to acquire a defined
    set of variables. For example, if we define `Day` as an `enum` type, it can acquire
    the values `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`,
    and `Sunday`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, if we choose an `int` type, we tell **common language runtime** (**CLR**)
    that it cannot have decimal digits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hence, while defining types for any variables, we have to analyze the usage
    of the variable logically and then declare its type in C#. In the next section,
    we will just do a brief revision of the different types that we covered in the
    *Data types in C#* section in [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml),
    *Understanding Classes, Structures, and Interfaces*.
  prefs: []
  type: TYPE_NORMAL
- en: Types in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml), *Understanding
    Classes, Structures, and Interfaces*, we learned that a variable can acquire the
    following types of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Value types**: In value types, the variables contain the actual value of
    the variable. This basically implies that if any change is made to a value type
    variable in a different scope of the program, the change is not reflected back
    once the control shifts to the calling function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference types**: The data member contains the exact address of the variable
    in memory. As the variable just contains a reference to a memory address, two
    separate reference type variables can point to the same memory address. Therefore,
    if a change is made in a reference type variable, the change is made directly
    at the memory location of the variable and hence is carried forward to the different
    scopes present in the program execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pointer types**: Pointers are another type of variable possible in C#. The
    pointer type is used to save the memory address of variable allowing us to any
    operation involving the memory location of the variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will do a deep dive into pointers and understand the
    implications and benefits of using them in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Unsafe code and the use of pointer types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In languages such as C or C++, developers have the features to create *pointers*
    or `*`, which is an object that stores the memory address of another variable.
    This object allowed very low-level access of the memory to the application. However,
    due to the possibility of *dangling pointers,* the performance of the application
    suffers greatly. A dangling pointer is a potential situation that could exist
    in C when a pointer object is still pointing to a memory location that is no longer
    allocated in the application. Please refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/802e881c-7877-43ee-bb98-865128cbac44.png)'
  prefs: []
  type: TYPE_IMG
- en: In the diagram, we have an application running in C or C++ that declared Pointer
    B and pointed it to the memory address of variable A. The pointer saves the memory
    address of the variable. Hence, in other words, Pointer B will not contain the
    memory address of variable A. Now, at some point during the program run, memory
    location A was released by the application. Even though the memory was released,
    there could be circumstances when we do not explicitly clear out the contents
    of the pointers containing the respective memory address. Due to this mistake
    or oversight, Pointer B was not updated to point to a new block of memory or pointing
    it to null. As a result, the pointer is still referring to a memory location that
    no longer exists in the application. This situation is called **dangling pointers**.
  prefs: []
  type: TYPE_NORMAL
- en: C# removes the possibility of dangling pointers because, explicitly, it does
    not allow the use of pointers. Instead, it encourages people to use *reference
    types*. The memory management of *reference types* is managed by a garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](b13c398c-8c38-4c9e-804f-2e0a2eb0ddbe.xhtml), *Managing the Object
    Life Cycle*, we will look further at how the garbage collector works in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are still some circumstances when developers feel the need to
    use pointers in their C# application. This is useful in scenarios where we need
    to do some operations with the underlying operating system, such as Windows or
    Linux, in which the application is running. In such circumstances, we will need
    pointers. To cater to such scenarios, C# has the concept of `unsafe` *code* in
    which it allows developers to use pointers in their code. The code that uses pointers
    must be classified clearly with an identifier of `unsafe`. This keyword conveys
    the message to **Common Language Runtime** (**CLR**) that the code block is unmanaged
    or unsafe—or, in other words, has used pointers. Let's go through a code example
    to see how we use pointer types in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code example, we are creating a function block in which we are using
    a pointer variable. We will be saving the address of an `int` type in an `int`
    pointer type variable. Please refer to the following screenshot. Note that the
    user gets an error when they try to compile the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/510e540a-326a-4c58-aedf-aa5e70fec8a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The reason is that, by default, the C# compiler will not allow any code containing
    a pointer or `unsafe` code block to be executed. We can override this behavior
    of C# by using the `unsafe` keyword in the function block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To allow the compilation of `unsafe` code, we will need to change the build
    setting in Visual Studio. To update the settings, we need to right-click on the
    Project and click on Properties. Now, navigate to the Build section. Please refer
    to the following screenshot, which highlights the Visual Studio setting that we
    need to specify to allow compilation of `unsafe` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ace30ca-abea-4c55-9fe6-ed2b5b31f0ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we have revisited the different types possible in C#. The next section explains
    the guiding principles that help us select a particular variable type over another.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the type of variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml), *Understanding Classes,
    Structures, and Interfaces*, in the *Data types in C#* section, we saw the different
    data types that are possible for both value and reference types. We also did a
    code implementation to see the difference in the behavior of `Struct`, which is
    a value type, and `Class`, which is a reference type. In this section, we will
    do a deep dive and see this difference in behavior and how it can help us to choose
    the correct type for our variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze how the following code statements for value and reference types
    and see how they differ in implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have declared the value type variables `x` and `y`.
    While declaring, the `x` variable has been assigned a value. In the next step,
    we are assigning `x` to `y`. Similarly, we have a class named `Class` and we have
    created an object of `c`. In the next statement, we have declared another object
    of the same class and have assigned `c` to `c2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please refer to the following diagram, which shows how these types are implemented
    and managed inside memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73206554-2d6c-496d-be16-c0840aab7814.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding diagram, we have declared variable `x` as an `int` data type
    and `c` as an object of the `Car` class. Now, we know that `int` is a value type,
    while `Class` is a reference type. So let''s try to analyze why the behavior differs
    for both of them:'
  prefs: []
  type: TYPE_NORMAL
- en: For `x`, in the first statement, that is, `int x = 10`, a block of memory is
    reserved by the application. The rectangular block below the declaration conveys
    that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, when we execute the `int y = x` statement, we are declaring another variable,
    `y`, and it is assigned the value currently in `x`. What it does internally is
    it allocates another block of memory for `y` in memory. Therefore, as `x` and
    `y` are not pointing to the same memory location, they will hold different values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, if we look at the `Car` class, we have just declared two
    attributes in it: the registration number and color. Now, when we use the `new`
    statement, what it does is that it creates an object for the class and allocates
    it memory. However, as against the value type implementation, it does not save
    the value in the object. Instead, in the object, it just saves a reference to
    the allocated memory block. In the rectangular shape in the preceding diagram,
    you will see that, once the `c` object is created for the `Car` class, a pointer
    is saved in the created object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, when we execute the `Car c2 = c;` statement, internally, it creates a new
    object, `c2`, but does not allocate a new memory block for the object. Instead,
    it just saves a reference to the memory location shared with the object, `c`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As illustrated by the preceding implementation, whenever a new value type variable
    is declared, a new block of memory is reserved by the application, which is different
    from reference type variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, in much simpler terms, the following factors can help us to choose between
    value and reference type:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A value type variable is logically immutable**: In very simple terms, it
    means that on every declaration of the value type, a new block of memory is reserved
    by the application. As they are different memory allocations, it implies that
    if we execute any operation on one memory location, the change is not transmitted
    across to the other memory location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Whether there are lots of objects**: If there lots of objects being created
    in the application, it might be better to not create them as value type as it
    would exponentially increase the memory requirements of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Whether the object is small**: If the object is small, then it may make sense
    to have them as value type variables. However, if we think that the object is
    bound to have too many properties, a reference type variable will make more sense.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory management**: Value type variables are managed on a stack whereas
    reference type variables are managed on a heap. When we move to [Chapter 9](b13c398c-8c38-4c9e-804f-2e0a2eb0ddbe.xhtml),
    *Manage the Object Life Cycle*, we will look further into memory management and
    how the garbage collector works.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a fair understanding of how we can create and consume different
    data types in a C# application, we will be looking at some of the features of
    C# that help us to set correct behavior for the different types we use in the
    application. In the next section, we will be looking at static variables and how
    they are implemented in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Static variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we went over the section on value type versus reference type, we understood
    that all of the objects created in C# have a definite scope in the program execution.
    However, there could be some circumstances when we would like to have a variable
    acquire a constant value that is consistent across all instances of the objects.
    We can do this using the `Static` keyword. A `Static` keyword in a modifier in
    C# ensures that just one instance of the variable is created and its scope is
    throughout the entire run of the program. We can use a `Static` variable against
    a class, its member variable, and its member methods and constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at code examples involving the `Static` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Static member variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at how we can use the `Static` keyword against
    a class and its member variables. In the following code example, we have created
    a `Static` class called `Configuration`. Just for the sake of explanation, we
    will not be using the `Static` keyword for a member variable present in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to compile the program. We get an error stating that the `ConnectionString`
    member variable must be declared `static` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6928a105-8aa5-4b1c-8cd7-77d02081d970.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we use the `static` keyword against the `ConnectionString` member variable
    as well, the error goes away. This is the correct representation of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to use `Set`/`Get` value in the member variable, we can access it
    directly by using the name of the class. Here is the code snippet for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we had a `Static` class `Configuration` in which
    it was mandatory to have the `static` modifier against all of the member variables
    and properties. However, there could be some circumstances when we don't want
    the entire class to be static but just a particular member variable present inside
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve this in C# by using the `static` modifier not against the class
    but against the particular member variable. If we need to use this in the preceding
    code, the following would be the updated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: However, there will be no change in the way we access this property. It can
    still be done by using the name of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Static methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C#, a class can have two types of methods: static methods and non-static
    methods. Static methods are shared across the different instances of the class
    objects, whereas non-static methods are unique for each instance. Just like static
    member variables, we can declare a method as static by the use of the `static`
    keyword and can access them by directly using the class name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example indicates how we create a `static` method in a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute a static method, we can use the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will look at constructors and how they are implemented
    in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Constructors are called whenever an object is created for a `class` or `struct`
    type. They can help us to set some default values against the member variables
    present in these types.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml), *Understanding Classes,
    Structures, and Interfaces*, while understanding the difference between a `class`
    and `struct` type, we mentioned that, unlike classes, structs do now have a default
    constructor. That constructor, in programming terms, is known as a **parameter
    less constructor**. If a programmer does not specify any constructor for the class,
    then whenever an object is created for the class the default constructor triggers
    and sets default values against the member variables present in the class. The
    default values are set in accordance with the default values of the type of those
    member variables.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of syntax, a constructor is just a method the name of which is the
    same as that of its respective type. In the method signature, it has got a parameter
    list that can be mapped to the member variables present in the type. It does not
    have any return type.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that a class or struct can have multiple constructors each differing
    with each other based on the parameter list present in the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a code example in which we will implement constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we have declared an `Animal` class with two member
    variables, `Name` and `Type`. We have also declared a two-parameter constructor
    in which we are passing `Name` and `Type` as string parameters. Using the `this`
    operator, we are then assigning the values passed to the member variables present
    in the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the following code implementation to call this constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will look at how named parameters are implemented in
    C#.
  prefs: []
  type: TYPE_NORMAL
- en: Named parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Named parameters were introduced in C# 4.0, and they allow us to pass arguments
    to a method/constructor/delegate/indexer using parameter names instead of the
    sequence in which the parameters are passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using named parameters, developers no longer need to be concerned about the
    sequence in which they need to pass parameters. As long as they associate the
    values being passed with the right parameter name, the sequence will not matter.
    The parameter names are compared against the names of the parameters in the method
    definition. Let''s look at the following code example to understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we are calculating compound interest by passing
    the principal amount, interest rate, and number of years for which the amount
    was put in the bank.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we call the method without using named parameters, we would use the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If we look closely at the preceding example, while calling the function, the
    developer will need to be fully aware of the sequence of the principle and interest
    rate parameters. That's because if the developer makes a mistake while calling
    the function, the resultant output will be incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: 'With named parameters, we can call the method using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in the preceding code, we are not passing values to the parameters
    in the sequence there are defined in the method. Instead, we are using parameter
    names to map the passing values with the parameters declared in the method. In
    the next section, we will look at another feature, *optional parameters,* which
    was introduced in C# 4.0 along with named parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Optional parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optional parameters in C# allow us to define a method in such a way that some
    of the parameters are optional. In other words, while defining the function for
    the optional parameters, a default value is specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, while calling the method, no value is passed for the optional parameter,
    it assumes a default value. Let''s look at a code example to understand how optional
    parameters work in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we have defined a `MultiplyNumbers` method with
    three parameters, `num1`, `num2`, and `num3`. The `num1` parameter is mandatory,
    while the other two parameters, `num2` and `num3`, are optional.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that, while defining the function, the optional parameters, if any,
    must come after all of the required parameters have been specified in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to execute the preceding method, we can use any of the following
    code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that there would be no compiler errors and if any optional parameters are
    not passed, the default value defined in the function declaration would be used.
    In the next section, we will look at how generic types are implemented in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Generics types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics allow us to design classes and methods without the notion of data types.
    In simpler terms, when we talk about methods, generics allow us to define methods
    without specifying the type of the input variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the following code implementation and see how it can help
    us. In the following example, we have created a function that compares the values
    between two `int` variables, `A` and `B`. If the value is the same, it returns
    `true`; however, if the value is not same, it returns `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say we try to pass a variable with a data type that is not `int`.
    In the following screenshot, we are trying to pass `string` instead of `int`,
    to which the compiler gives us an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/584e7232-e0d1-4df1-9649-492b26818b65.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As illustrated in the following screenshot, it will give us the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff83eaec-b056-4d41-a548-7d51c30582fe.png)'
  prefs: []
  type: TYPE_IMG
- en: As illustrated by the preceding screenshot, the `IsEqual` function is accepting
    inputs of the `int` type. However, while calling the function, we are passing
    variables of the `string` type. Due to the type mismatch, the compiler is showing
    the error.
  prefs: []
  type: TYPE_NORMAL
- en: To correct this error, we need to make the `IsEqual` function generic. We can
    do this by altering the function so that instead of accepting the input variables
    of the `int` type, it can accept the input variables of the `object` type.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that all of the variables in C# inherit from `object`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code example, we are calling the `IsEqual` function twice and are passing
    different input parameters. In the first call, we are passing `string`; however,
    in the second call, we are passing `int`. Note that when we compile the project,
    no compile time error is retrieved and the function compares the passed variables
    irrespective of type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the preceding code implementation will be generic for all of the data
    types, it will lead to the following issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance degradation**:In the `IsEqual` function definition, the data
    types of variables is `object`. Due to this, for all calls being made to this
    function, the variables will need to be converted from their original type, that
    is, `int` or `string`, into `object`. This conversion will be an extra load for
    the application, which will lead to performance degradation. In programming terms,
    this conversion is known as **boxing and unboxing**, which we will cover shortly
    in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type unsafe**: This approach will not be type unsafe. For example, I will
    call the function by passing the following variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If I do so, the compiler will not give any error, even though we understand
    that the call makes no sense. To avoid these issues while still providing us with
    the capability of making the calls generic, C# provides us with the tool of using
    *generic types*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using generic types, we can avoid specifying any data type to the input variables
    of the functions. Hence, the implementation of `IsEqual` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, please note that we are using `T` to illustrate
    the data type, hence making it generic for all data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are not using `object`, there will be no boxing and unboxing of variables.
    If we still try to pass incorrect data types to this function, as illustrated
    in the following screenshot, the compiler will give us an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dce39b3e-cc88-4d9e-bc76-a67b944712cc.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next topic, we will not go through the different concepts C# uses to
    work on the types of the data variables. We will go through how we can use boxing
    and unboxing in C# to convert one data type into another and the different things
    we should keep in mind when we are consuming variables of different types.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming data types in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# is a strongly-typed language. This basically means that, when we declare
    a variable with a particular data type, as in the following example, we cannot
    declare the `x` variable again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to this, we cannot assign to this `x` variable any value that is
    not an integer. Hence, the following statement will give us an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To overcome this strongly typed feature, C# provides some capabilities when
    we are consuming a type. This includes boxing and unboxing of value type variables,
    use of the dynamics keyword, and implicit and explicit conversion of a variable
    of one data type to a variable of a different data type. Let's go through each
    of these concepts and understand how they work in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Boxing and unboxing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C#, boxing means converting a value type variable into a reference type variable.
    Unboxing is the opposite of boxing. It refers to the conversion of a reference
    type variable into a value type variable. Boxing and unboxing are detrimental
    to the performance of the application as they are an overhead to the compiler.
    As developers, we should try to avoid them as much as possible; however, it's
    not always possible and there are several instances that we encounter during programming
    that make us use this concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example to see how boxing and unboxing works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code implementation, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We have declared a variable, `i`, of the `int` type and have assigned it a value
    of `3`. Now we know that, being `int`, this is a value type reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we declare an `obj` variable of the `object` type and have assigned it
    the value in `i`. We know that `object` is a reference type variable. Therefore,
    internally, the CLR will undergo boxing and convert the value into the `i` variable
    into a reference type variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, in the third statement, we are doing the reverse. We are trying to assign
    the value in a reference type variable, that is, `obj`, to a value type variable,
    `i`. At this stage, the CLR will do the unboxing of the value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Please note that, while doing boxing, we do not need to explicitly cast the
    value type to a reference type. However, when we are doing the unboxing, we need
    to explicitly specify the type into which we are converting the variable. This
    approach of explicitly specifying the type into which we are converting a variable
    is known as casting. To do casting, we can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: What it basically means is that there are possibilities that this conversion
    can lead to an exception of the `InvalidCastException` type. For example, in the
    preceding example, we know that the value in `obj` is `10`. However, if it were
    to acquire a value that cannot be cast to an `int` value, for example, `string`,
    the compiler will give us a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the next section, we will look at the different techniques C# provides
    us with for converting between data types.
  prefs: []
  type: TYPE_NORMAL
- en: Type conversions in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type conversion in C# basically implies converting a variable from one data
    type into another. Now we will look into the different types of conversions available
    in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implicit conversion is done by the compiler automatically. It''s done by the
    compiler without any intervention or command from the developer. The following
    two conditions must be fulfilled for a compiler to execute implicit type conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No data** **l****oss**: The compiler must determine that if it executes the
    conversion implicitly, there will be no data loss. In [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml),
    *Understanding Classes, Structures, and Interfaces*, in the *Data Types* section,
    we saw that each data type acquires a space in memory. Therefore, if we try to
    assign a variable with the type as `float`, which acquires 32 bytes of memory,
    to double, which acquires 64 bytes of memory, we can be sure that there won''t
    be any data loss in the conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No chance of cast exception**: The compiler must determine that there is
    no chance of an exception during the casting of the value from one data type to
    another. For example, if we try to set a `string` value to a `float` variable,
    the compiler will not do the implicit conversion as it would be an invalid cast.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s look at the following code implementation to see how implicit conversion
    works in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we have declared a variable, `i`, of the `int`
    type and have assigned it a value of `100`. In the next statement, we have declared
    a variable, `f`, of the `float` type and have assigned it the value in `i`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the compiler would determine that both the required conditions for implicit
    conversions are being met, that is, `float` acquires more memory than `int` and
    there is no chance of an invalid cast exception—an `int` value is also a valid
    value in a `float` variable. Hence, the compiler gives no error and does the implicit
    conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we do the reverse, which is trying to assign a `float` value in
    `int`, the compiler will determine that the conditions are not being fulfilled
    and will give us a compile-time error. Please refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcd025b4-b567-4c1f-8397-14a238c0ad19.png)'
  prefs: []
  type: TYPE_IMG
- en: However, in certain circumstances, even if there is a chance of data loss, we
    would still like to have those conversions. C# provides us with *explicit conversion*,
    which allows us to explicitly instruct the compiler to let the conversion take
    place. Let's go through how *explicit conversion* takes place.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the compiler is not able to implicitly change the type of variables, but
    we still want the conversion to happen, we need to explicitly instruct the compiler
    to convert the value. This is referred to as *explicit conversion*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to do explicit conversion in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using a type cast operation**: In this, we use the base data type to instruct
    the compiler to do explicit conversion. For example, for the code implementation
    that we were trying in the preceding example, the following would be the syntax:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are explicitly telling the compiler to do type conversion
    by using the `int` class conversion before the float variable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the** `Convert` **class**: C# provides us with the `Convert` class,
    which we can use to do type casting between multiple data types. If we were to
    use the `Convert` class instead of the `int` keyword, the following would be the
    syntax:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert class can be used for type casting among different data types. Please
    refer to the following screenshot to get an idea of the different options that
    are available in the `Convert` class. Depending on the usage, we can use the appropriate
    method in the `Convert` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f5171d1-5c82-499b-85c0-85c8a71d192d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Hence, the overall implementation of the program will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try to run this program to see the output it gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54cf7e2a-e0a1-420a-8833-6692490ed6f2.png)'
  prefs: []
  type: TYPE_IMG
- en: It implies that when we use the type cast keyword, that is, `(int)k`, the compiler
    tried to extract the integer component from the `float` variable, `k`, which turned
    out to be `100`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when we used the `Convert` class, that is, `Convert.ToInt32(k)`,
    it tried to extract the nearest integer to the float variable, `k`, which turned
    out to be `101`. This is one of the key differences that developers need to be
    aware of while deciding between using type casting and the `Convert` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we are looking at explicit type conversions, we need to be aware of two
    helper methods that help us do conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Parse`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TryParse`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both the `Parse` and `TryParse` methods are used to convert `string` into a
    different data type. However, there is a slight difference in the way invalid
    case exceptions are handled. Let''s look at the following example to see how they
    work and the difference between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have declared a string object and have assigned
    it a value of `100`. Now, we are trying to convert the value into an integer using
    the `Parse` method. When we run the program, we see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3d439ed-e0cf-44b3-9532-2f306ed94e51.png)'
  prefs: []
  type: TYPE_IMG
- en: It implies that the parse method converts the string into its integer equivalent
    and assigns the value to another variable, `num`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s suppose the value in the number is `100wer`. Now, it''s evident
    that the value in the `number` string cannot be converted into `int` because it
    has some characters that cannot be categorized in an integer object. When we run
    this program, we get the following exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5cbe848-768a-4b09-9e8b-09bc6c571ba4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To avoid such situations, we use `TryParse`. In `TryParse`, CLR tries to convert
    the string object into the specified data type. However, if the conversion returns
    an error, `TryParse` returns `false` or, in other words, *the conversion failed*.
    In other cases, it returns true. Hence, if we were to write the same implementation
    with `TryParse`, we would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding program, we have declared a variable of the `string` type
    and we are using `TryParse` to convert this value into a variable of the `int`
    type. We are checking whether the conversion is a success. If it''s a success,
    we print out the number and in other cases, we print a statement to show that
    there was an error during the type conversion. When we run the program, we get
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d07724f-5c34-4655-b6b4-a5936b275a7e.png)'
  prefs: []
  type: TYPE_IMG
- en: As we see from the output, the compiler tells us that there was an error doing
    the `TryParse`; however, it does not throw an exception in the application as
    opposed to the `Parse` method, which threw an invalid case exception in the same
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will do a quick recap of encapsulation, which we covered
    in [Chapter 3](8acdf308-13c5-4298-bdba-7bef6e8b087b.xhtml), *Understanding Object-Oriented
    Programming*, and we'll see how to implement properties for class member variables
    objects, allowing us to consume them without worrying about the hidden complexities.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously, we went through the following concepts in [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml),
    *Understanding Classes, Structures, and Interfaces*, and [Chapter 3](8acdf308-13c5-4298-bdba-7bef6e8b087b.xhtml),
    *Understanding Object-Oriented Programming*:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing modifiers and how they help us to control access to methods and fields
    in the same class, in the same assembly, and in the derived classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation and how it helps us to group together related fields and methods
    together in the same object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, there is another concept in encapsulation called properties, which
    makes sure that no one can have direct access to the data fields outside the class.
    This helps us to make sure that we have control over the modification of the data
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: A property is very similar to the field of a class. Just like the field of a
    class, it has a type, name, and access modifier. However, what makes it different
    is the presence of accessors. Accessors are the `get` and `set` keywords that
    allow us to set and retrieve values from a field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what the syntax of a property looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, please note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: For the `SampleProperty` class, we have declared a `name` field and a `Name`
    property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `name` field has been marked `private`, hence it won't be accessed outside
    the `SampleProperty` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Name` property has been marked `public` and has the `get` and `set` accessors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `set` method, we are checking whether the value passed is null or not.
    If it's null, we are raising an argument exception. Therefore, we are putting
    rules around the value that can be set on the `name` field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this way, properties help us in consume the fields of a class.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings are a very important data type in C#. The string data type is used for
    saving text as `string`. In programming terms, it's a sequence of characters.
    String is a reference type variable unlike other basic data type variables, such
    as `int`, `float`, and `double`, which are value type variables. Also, strings
    are immutable in nature, that is, the values present in them cannot change. In
    this section, we will look at different operations related to this data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When we are assigning a `Test` value to the already declared `string` objects,
    internally, CLR allocates a new memory block for the modified `string` object.
    Hence, for every operation that we do on a string, instead of modifying of the
    same `string` object, a new `string` object is declared in CLR. Due to this, we
    need to be very careful while doing operations on `string`, for example, if we
    execute the following loop operation on a string object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are concatenating the string object, `s`, with a character,
    `a`, in the loop. This loop will run `100` times. Therefore, the CLR will go on
    allocating more and more memory for the `string` object. Hence, due to memory
    usage, performance-wise, the preceding operation is not good.
  prefs: []
  type: TYPE_NORMAL
- en: To help to improve this feature in `string`, C# provides us with two built-in
    classes, `Stringbuilder` and `StringWriter`, which we will discuss next. We will
    also look at some of the features available with us for executing string searching
    in C#.
  prefs: []
  type: TYPE_NORMAL
- en: StringBuilder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Stringbuilder` is an internal class provided by C# that helps us to improve
    `string` manipulation functions. To explain the idea, we will be executing a `for`
    loop from `0` to `100` and will be concatenating the resultant output in each
    loop with the letter `a`. Internally, a string builder uses a buffer to modify
    the string value instead of allocating memory on every string manipulation. The
    following code example shows how we can use string builder for string manipulation
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are declaring a `StringBuilder` object, `sb`, and
    are appending its value with `a` in the loop. Internally, instead of allocating
    memory on every concatenation, `StringBuilder` will use an internal buffer to
    manage these operations.
  prefs: []
  type: TYPE_NORMAL
- en: StringReader and StringWriter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `StringReader` and `StringWriter` classes derive from the `TextReader` and
    `TextWriter` classes respectively. `TextReader` and `TextWriter` are used for
    dealing with APIs such as reading from an XML file, generating an XML file, or
    reading from a file.
  prefs: []
  type: TYPE_NORMAL
- en: We will study the `TextReader` and `TextWriter` classes more in [Chapter 14](ed867897-1e3b-47fe-b646-28484f783f37.xhtml),
    *Performing I/O Operations*.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `StringReader` and `StringWriter` classes, we can interact with these
    I/O operations by manipulating the objects of strings and string builders.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through the following example in order to understand the methods better.
    In the following example, using `StringWriter`, we are firstly creating an extract
    of an XML file and then we will pass the resultant XML representation to `StringReader`,
    which will try to read an element present in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code example, we are using `XMLWriter` to create an XML file
    with the start element as `Student` and an attribute of `Name`. We are saving
    the string representation of the XML file using `StringWriter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we print the output of the program; we will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a68b5ea5-6854-4116-92f4-e517e562ee0d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, in the following code snippet, we will use `StringReader` to read through
    this XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we are passing a string parameter to the function, which is
    first converted into a `StringReader` object. From that `StringBuilder` object,
    we are creating an `XmlReader` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ReadToFollowing` function reads the XML file until it finds an element
    with the respective name, which is passed as a parameter to the function. In the
    preceding code example, we are passing a parameter of `Name` to the `XmlReader`
    object. Based upon the XML file we have passed to it, it will take us to the element
    `Rob`. To read the text representation of the element, we can use the `ReadInnerXml`
    function on the `reader` object. Hence, in the preceding example, the `studentName`
    variable will be assigned the value of `Rob`. If we execute the code snippet,
    we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca8789ae-ce24-45c5-8943-a61418924161.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will go through some functions we can use to search
    for particular characters in a string object.
  prefs: []
  type: TYPE_NORMAL
- en: String searching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, string searching involves searching the presence of a
    particular letter or string in another string. C# provides several methods for
    doing this.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that C# is a case-sensitive language. Therefore, searching for a
    character, let's suppose *C*, is not the same as searching for the character *c*
    in the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please refer to the following different types of searching that are possible
    with the `string` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Contains`: When we want to check whether a particular character exists in
    the string, we use the `Contains` function. The following example checks whether
    a character, `z`, exists in the string object. If it exists, it returns `true`;
    otherwise, it returns `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, using the `Contains` function, we are checking whether
    `z` occurs in the string against which we are calling the function. As we are
    calling it for a variable with the value `hello australia`, it will return the
    `false` value as `z` does not occur in the string. Hence, we get the following
    output when the code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e726d1e7-4fb5-4bbc-8a35-05a8f098a627.png)'
  prefs: []
  type: TYPE_IMG
- en: '`IndexOf`: We use this function if we want to find out the index in the string
    at which a particular character is present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, in the following code example, we are finding the first and the
    last index of occurrence of the `a` character in the string `hello australia`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the program, we will get the first occurrence as 6 and the
    last occurrence as 14\. The `IndexOf` function retrieves the index the first appearance
    of a character or a string in the string against which we are using the function.
    Please also note that it does not ignore spaces. Hence, the whitespace is also
    counted as a character. Similarly, the `LastIndexOf` function retrieves the last
    index of the appearance of the respective character or string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad91476c-0e17-41d2-8c33-6ccd430b106c.png)'
  prefs: []
  type: TYPE_IMG
- en: Please note that in C#, for any array or string, the index of the first character
    is zero.
  prefs: []
  type: TYPE_NORMAL
- en: '`StartsWith`/`EndsWith`: We use this function if we want to check whether a
    string starts or ends with a particular character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code example shows a scenario in which we are checking whether
    the same string object used previously starts with `h` and ends with `h`. In the
    following code, in the first statement, we are checking whether the `s` string
    variable starts with `h`. Based on the evaluation, we print the output in the
    console window. Similarly, in the next statement, we are checking whether the
    same string variable ends with `h`. Based on the evaluation, we print the output
    in the console window again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Please refer to the following output for the preceding code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1b02d4e-a82a-4a9e-82e7-ff5db9ae53ef.png)'
  prefs: []
  type: TYPE_IMG
- en: '`Substring`: We use this function if we want to extract a substring from a
    particular string object. There are two variants of substring possible in C#.
    In one, we specify just the start index and extract the substring from that particular
    index. In another variant, we specify both the start and end index and extract
    the characters present in that substring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a code example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we are finding two substrings of a string object,
    `hello australia`.
  prefs: []
  type: TYPE_NORMAL
- en: In the first substring, we have passed the start index as 3 and the end index
    as 6\. Therefore, the substring will return us the values, `lo aus`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second substring, we are just passing the start index, 3\. Hence, it
    will return the entire string from this index. The following is the screenshot
    of the output from this execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ce71ca3-d860-434c-b634-e699c5b69c1a.png)'
  prefs: []
  type: TYPE_IMG
- en: These are the different string manipulation functions available in C#. In the
    next section, we will go through an overview of reflection and learn how it helps
    us to get structure—in other words, classes and their methods and properties—from
    an assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reflection in C# means inspecting the contents of an assembly at run time.
    It returns the metadata for each class present in the assembly—so, it returns
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the properties present in the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the methods along with their return types and function parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the attributes present in the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 10](b7bdae98-fc5b-4430-bb0d-b8541ca64f8d.xhtml), *Find, Execute,
    and Create Types at Runtime Using Reflection*, we will do a deep dive on reflection;
    however, in this chapter, we will just go through a code sample of how we can
    implement reflection in C# to decode all of the metadata present in the assembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use reflection, we need to include the `System.Reflection` namespace, which
    helps us to use required classes such as `Assembly`. Please refer to the following
    function, which reads a particular assembly based on its path and reads all of
    the classes, methods, and parameters present in the assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code base, we have declared a fully qualified path for an assembly
    in C#. Next, we have declared an object of the `Assembly` class and have retrieved
    an array of all `Types` present in the assembly. Then, we are looping through
    each type and finding out the methods in each of those types. Once we have a list
    of methods for each of the types, we retrieve the list of parameters present in
    that method and their parameter types.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to manage types in C#. We had a recap of the
    different data types available in C#. We did a deep dive into value and reference
    types in C#. We also had a review of the pointer data type and learned how it
    works. We had a look at some of the practices a user can use to choose the type
    of a variable. We had a look at generic types and learned how they help us to
    improve the performance of a system.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we looked at the different techniques we use to consume a type declared
    in C#. We learned how boxing and unboxing work in C#. We then had a look at how
    to we consume these data types. We also looked at type conversions, both implicit
    and explicit, and learned how they help us to convert one data type into another.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we had a look at `Properties` and how it helps us to have more control
    over setting and retrieving values from the field attributes of a class. Then,
    we worked on strings and learned how they work. We looked at the immutable nature
    of strings. We looked at using `StringBuilder`, `StringWriter`, and `StringReader`,
    which help us to improve the performance aspect of using strings. We then looked
    at the different functions in C# that help us to do different manipulation functions
    on a string. Finally, we did a high-level review of reflection and, using a code
    example, we learned how we can retrieve the metadata present in an assembly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how garbage collection is performed in
    C#. We will look at how the CLR manages memory for different data types in C#.
    We will look at how C# allows us to manage "unmanaged resources" or the "pointer
    types" that we saw in this chapter. We will also look at how we implement the
    `IDisposable` interface to manage unmanaged resources.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the keyword we use in the program function when we are using a pointer
    declaration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sealed
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Safe
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Internal protected
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Unsafe
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What would be the output of the following code snippet?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '100'
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile-time error
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '101'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Runtime error
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What would be the output of the following code snippet?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It's present
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's not present
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Unsafe**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Compile-time error**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**It''s not present**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
