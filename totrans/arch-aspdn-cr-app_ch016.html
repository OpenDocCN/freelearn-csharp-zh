<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>15 Object Mappers, Aggregate Services, and Façade</title>
<link href="../styles/stylesheet1.css" rel="stylesheet" type="text/css"/>
<link href="../styles/stylesheet2.css" rel="stylesheet" type="text/css"/>
<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>
<section class="level1 pkt" data-number="16" id="object-mappers-aggregate-services-and-façade">
<h1 data-number="16"><span class="koboSpan" id="kobo.1.1" xmlns="http://www.w3.org/1999/xhtml">15 Object Mappers, Aggregate Services, and Façade</span></h1>
<section class="level2" data-number="16.1" id="before-you-begin-join-our-book-community-on-discord-14">
<h2 data-number="16.1"><span class="koboSpan" id="kobo.2.1" xmlns="http://www.w3.org/1999/xhtml">Before you begin: Join our book community on Discord</span></h2>
<p><span class="koboSpan" id="kobo.3.1" xmlns="http://www.w3.org/1999/xhtml">Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</span></p>
<p><a href="https://packt.link/EarlyAccess"><span class="koboSpan" id="kobo.4.1" xmlns="http://www.w3.org/1999/xhtml">https://packt.link/EarlyAccess</span></a></p>
<p><span class="koboSpan" id="kobo.5.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Qr code Description automatically generated" src="../media/file93.png" style="width:10em"/></span></p>
<p><span class="koboSpan" id="kobo.6.1" xmlns="http://www.w3.org/1999/xhtml">In this chapter, we explore object mapping. </span><span class="koboSpan" id="kobo.6.2" xmlns="http://www.w3.org/1999/xhtml">As we saw in the previous chapter, working with layers often leads to copying models from one layer to another. </span><span class="koboSpan" id="kobo.6.3" xmlns="http://www.w3.org/1999/xhtml">Object mappers solve that problem. </span><span class="koboSpan" id="kobo.6.4" xmlns="http://www.w3.org/1999/xhtml">We first look at manually implementing an object mapper. </span><span class="koboSpan" id="kobo.6.5" xmlns="http://www.w3.org/1999/xhtml">Then, we improve our design by regrouping the mappers under a mapper service, exploring the Aggregate Services, and Mapping façade patterns along the way. </span><span class="koboSpan" id="kobo.6.6" xmlns="http://www.w3.org/1999/xhtml">Finally, we replace that manual work with two open-source tools that helps us generate business value instead of writing mapping code.In this chapter, we cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1" xmlns="http://www.w3.org/1999/xhtml">Overview of object mapping and object mappers</span></li>
<li><span class="koboSpan" id="kobo.8.1" xmlns="http://www.w3.org/1999/xhtml">Implementing a simple object mapper</span></li>
<li><span class="koboSpan" id="kobo.9.1" xmlns="http://www.w3.org/1999/xhtml">Exploring the too-many-dependencies code smell</span></li>
<li><span class="koboSpan" id="kobo.10.1" xmlns="http://www.w3.org/1999/xhtml">Exploring the Aggregate Services pattern</span></li>
<li><span class="koboSpan" id="kobo.11.1" xmlns="http://www.w3.org/1999/xhtml">Implementing a Mapping Façade by leveraging the Façade pattern</span></li>
<li><span class="koboSpan" id="kobo.12.1" xmlns="http://www.w3.org/1999/xhtml">Using the Service Locator pattern to create a flexible Mapping Service in front of our mappers</span></li>
<li><span class="koboSpan" id="kobo.13.1" xmlns="http://www.w3.org/1999/xhtml">Using AutoMapper to map an object to another, replacing our homebrewed code</span></li>
<li><span class="koboSpan" id="kobo.14.1" xmlns="http://www.w3.org/1999/xhtml">Using Mapperly instead of AutoMapper</span></li>
</ul>
</section>
<section class="level2" data-number="16.2" id="object-mapper">
<h2 data-number="16.2"><span class="koboSpan" id="kobo.15.1" xmlns="http://www.w3.org/1999/xhtml">Object mapper</span></h2>
<p><span class="koboSpan" id="kobo.16.1" xmlns="http://www.w3.org/1999/xhtml">What is object mapping? </span><span class="koboSpan" id="kobo.16.2" xmlns="http://www.w3.org/1999/xhtml">In a nutshell, it is the action of copying the value of an object’s properties into the properties of another object. </span><span class="koboSpan" id="kobo.16.3" xmlns="http://www.w3.org/1999/xhtml">But sometimes, properties’ names do not match; an object hierarchy may need to be flattened and transformed. </span><span class="koboSpan" id="kobo.16.4" xmlns="http://www.w3.org/1999/xhtml">As we saw in the previous chapter, each layer can own its own model, which can be a good thing, but that comes at the price of copying objects from one layer to another. </span><span class="koboSpan" id="kobo.16.5" xmlns="http://www.w3.org/1999/xhtml">We can also share models between layers, but even then, we usually need to map one object into another. </span><span class="koboSpan" id="kobo.16.6" xmlns="http://www.w3.org/1999/xhtml">Even if it’s just to map your models to </span><strong><span class="koboSpan" id="kobo.17.1" xmlns="http://www.w3.org/1999/xhtml">Data Transfer Objects</span></strong><span class="koboSpan" id="kobo.18.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.19.1" xmlns="http://www.w3.org/1999/xhtml">DTOs</span></strong><span class="koboSpan" id="kobo.20.1" xmlns="http://www.w3.org/1999/xhtml">), it is almost inevitable.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.21.1" xmlns="http://www.w3.org/1999/xhtml">Remember that DTOs define our API’s contract. </span><span class="koboSpan" id="kobo.21.2" xmlns="http://www.w3.org/1999/xhtml">Independent contract classes help maintain the system, making us choose when to modify them. </span><span class="koboSpan" id="kobo.21.3" xmlns="http://www.w3.org/1999/xhtml">If you skip that part, each time you change your model, it automatically updates your endpoint’s contract, possibly breaking some clients. </span><span class="koboSpan" id="kobo.21.4" xmlns="http://www.w3.org/1999/xhtml">Moreover, if you input your model directly, a malicious user could try to bind the values of properties that they should not, leading to potential security issues (known as </span><strong><span class="koboSpan" id="kobo.22.1" xmlns="http://www.w3.org/1999/xhtml">over-posting</span></strong><span class="koboSpan" id="kobo.23.1" xmlns="http://www.w3.org/1999/xhtml"> or </span><strong><span class="koboSpan" id="kobo.24.1" xmlns="http://www.w3.org/1999/xhtml">over-posting attacks</span></strong><span class="koboSpan" id="kobo.25.1" xmlns="http://www.w3.org/1999/xhtml">). </span><span class="koboSpan" id="kobo.25.2" xmlns="http://www.w3.org/1999/xhtml">Having good data exchange contracts is one of the keys to designing robust systems.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.26.1" xmlns="http://www.w3.org/1999/xhtml">In the previous projects, the mapping logic was hardcoded, sometimes duplicated and adding additional responsibilities to the class doing the mapping. </span><span class="koboSpan" id="kobo.26.2" xmlns="http://www.w3.org/1999/xhtml">In this chapter, we extract the mapping logic into object mappers to fix that issue.</span></p>
<section class="level3" data-number="16.2.1" id="goal-14">
<h3 data-number="16.2.1"><span class="koboSpan" id="kobo.27.1" xmlns="http://www.w3.org/1999/xhtml">Goal</span></h3>
<p><span class="koboSpan" id="kobo.28.1" xmlns="http://www.w3.org/1999/xhtml">The object mapper’s goal is to copy the value of an object’s properties into the properties of another object. </span><span class="koboSpan" id="kobo.28.2" xmlns="http://www.w3.org/1999/xhtml">It encapsulates the mapping logic away from where the mapping takes place. </span><span class="koboSpan" id="kobo.28.3" xmlns="http://www.w3.org/1999/xhtml">The mapper is also responsible for transforming the values from the original format to the destination format when both objects do not follow the same structure.</span></p>
</section>
<section class="level3" data-number="16.2.2" id="design-14">
<h3 data-number="16.2.2"><span class="koboSpan" id="kobo.29.1" xmlns="http://www.w3.org/1999/xhtml">Design</span></h3>
<p><span class="koboSpan" id="kobo.30.1" xmlns="http://www.w3.org/1999/xhtml">We can design object mappers in many ways. </span><span class="koboSpan" id="kobo.30.2" xmlns="http://www.w3.org/1999/xhtml">Here is the most basic object mapper design:</span></p>
<figure>
<span class="koboSpan" id="kobo.31.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 15.1: Basic design of the object mapper" src="../media/file94.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.32.1" xmlns="http://www.w3.org/1999/xhtml">Figure 15.1: Basic design of the object mapper</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.33.1" xmlns="http://www.w3.org/1999/xhtml">In the diagram, the </span><strong><span class="koboSpan" id="kobo.34.1" xmlns="http://www.w3.org/1999/xhtml">Consumer</span></strong><span class="koboSpan" id="kobo.35.1" xmlns="http://www.w3.org/1999/xhtml"> uses the </span><code><span class="koboSpan" id="kobo.36.1" xmlns="http://www.w3.org/1999/xhtml">IMapper</span></code><span class="koboSpan" id="kobo.37.1" xmlns="http://www.w3.org/1999/xhtml"> interface to map an object of </span><code><span class="koboSpan" id="kobo.38.1" xmlns="http://www.w3.org/1999/xhtml">Type1</span></code><span class="koboSpan" id="kobo.39.1" xmlns="http://www.w3.org/1999/xhtml"> to an object of </span><code><span class="koboSpan" id="kobo.40.1" xmlns="http://www.w3.org/1999/xhtml">Type2</span></code><span class="koboSpan" id="kobo.41.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.41.2" xmlns="http://www.w3.org/1999/xhtml">That’s not very reusable, but it illustrates the concept. </span><span class="koboSpan" id="kobo.41.3" xmlns="http://www.w3.org/1999/xhtml">By using the power of </span><strong><span class="koboSpan" id="kobo.42.1" xmlns="http://www.w3.org/1999/xhtml">generics</span></strong><span class="koboSpan" id="kobo.43.1" xmlns="http://www.w3.org/1999/xhtml">, we can upgrade that simple design to this more reusable version:</span></p>
<figure>
<span class="koboSpan" id="kobo.44.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 15.2: Generic object mapper design" src="../media/file95.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.45.1" xmlns="http://www.w3.org/1999/xhtml">Figure 15.2: Generic object mapper design</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.46.1" xmlns="http://www.w3.org/1999/xhtml">This design lets us map any </span><code><span class="koboSpan" id="kobo.47.1" xmlns="http://www.w3.org/1999/xhtml">TSource</span></code><span class="koboSpan" id="kobo.48.1" xmlns="http://www.w3.org/1999/xhtml"> to any </span><code><span class="koboSpan" id="kobo.49.1" xmlns="http://www.w3.org/1999/xhtml">TDestination</span></code><span class="koboSpan" id="kobo.50.1" xmlns="http://www.w3.org/1999/xhtml"> by implementing the </span><code><span class="koboSpan" id="kobo.51.1" xmlns="http://www.w3.org/1999/xhtml">IMapper&lt;TSource, TDestination&gt;</span></code><span class="koboSpan" id="kobo.52.1" xmlns="http://www.w3.org/1999/xhtml"> interface once per mapping rule. </span><span class="koboSpan" id="kobo.52.2" xmlns="http://www.w3.org/1999/xhtml">One class could also implement multiple mapping rules. </span><span class="koboSpan" id="kobo.52.3" xmlns="http://www.w3.org/1999/xhtml">For example, we could implement the mapping of </span><code><span class="koboSpan" id="kobo.53.1" xmlns="http://www.w3.org/1999/xhtml">Type1</span></code><span class="koboSpan" id="kobo.54.1" xmlns="http://www.w3.org/1999/xhtml"> to </span><code><span class="koboSpan" id="kobo.55.1" xmlns="http://www.w3.org/1999/xhtml">Type2</span></code><span class="koboSpan" id="kobo.56.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.57.1" xmlns="http://www.w3.org/1999/xhtml">Type2</span></code><span class="koboSpan" id="kobo.58.1" xmlns="http://www.w3.org/1999/xhtml"> to </span><code><span class="koboSpan" id="kobo.59.1" xmlns="http://www.w3.org/1999/xhtml">Type1</span></code><span class="koboSpan" id="kobo.60.1" xmlns="http://www.w3.org/1999/xhtml"> in the same class (a bidirectional mapper).Another way would be to use the following design and create an </span><code><span class="koboSpan" id="kobo.61.1" xmlns="http://www.w3.org/1999/xhtml">IMapper</span></code><span class="koboSpan" id="kobo.62.1" xmlns="http://www.w3.org/1999/xhtml"> interface with a single method that handles all of the application’s mapping:</span></p>
<figure>
<span class="koboSpan" id="kobo.63.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 15.3: Object mapping using a single IMapper as the entry point" src="../media/file96.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.64.1" xmlns="http://www.w3.org/1999/xhtml">Figure 15.3: Object mapping using a single IMapper as the entry point</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.65.1" xmlns="http://www.w3.org/1999/xhtml">The biggest advantage of this last design is the ease of use. </span><span class="koboSpan" id="kobo.65.2" xmlns="http://www.w3.org/1999/xhtml">We always inject a single </span><code><span class="koboSpan" id="kobo.66.1" xmlns="http://www.w3.org/1999/xhtml">IMapper</span></code><span class="koboSpan" id="kobo.67.1" xmlns="http://www.w3.org/1999/xhtml"> instead of one </span><code><span class="koboSpan" id="kobo.68.1" xmlns="http://www.w3.org/1999/xhtml">IMapper&lt;TSource, TDestination&gt;</span></code><span class="koboSpan" id="kobo.69.1" xmlns="http://www.w3.org/1999/xhtml"> per type of mapping, which reduces the number of dependencies and the complexity of consuming such a mapper.You can implement object mapping in any way your imagination allows, but the critical part is that the mapper is responsible for mapping an object to another. </span><span class="koboSpan" id="kobo.69.2" xmlns="http://www.w3.org/1999/xhtml">A mapper should avoid complex processes, such as loading data from a database and whatnot. </span><span class="koboSpan" id="kobo.69.3" xmlns="http://www.w3.org/1999/xhtml">It should copy the values of one object into another: that’s it. </span><span class="koboSpan" id="kobo.69.4" xmlns="http://www.w3.org/1999/xhtml">Think about the </span><strong><span class="koboSpan" id="kobo.70.1" xmlns="http://www.w3.org/1999/xhtml">Single Responsibility Principle</span></strong><span class="koboSpan" id="kobo.71.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.72.1" xmlns="http://www.w3.org/1999/xhtml">SRP</span></strong><span class="koboSpan" id="kobo.73.1" xmlns="http://www.w3.org/1999/xhtml">) here: the class must have a single reason to change, and since it’s an object mapper, that reason should be object mapping.Let’s jump into some code to explore the designs in more depth with each project.</span></p>
</section>
<section class="level3" data-number="16.2.3" id="project-mapper">
<h3 data-number="16.2.3"><span class="koboSpan" id="kobo.74.1" xmlns="http://www.w3.org/1999/xhtml">Project – Mapper</span></h3>
<p><span class="koboSpan" id="kobo.75.1" xmlns="http://www.w3.org/1999/xhtml">This project is an updated version of the Clean Architecture code from the previous chapter. </span><span class="koboSpan" id="kobo.75.2" xmlns="http://www.w3.org/1999/xhtml">The project aims to demonstrate the design’s versatility of encapsulating entity mapping logic into mapper classes, moving that logic away from the consumers. </span><span class="koboSpan" id="kobo.75.3" xmlns="http://www.w3.org/1999/xhtml">Of course, the project is again focused on the use case at hand, making learning the topics easier.First, we need an interface that resides in the </span><code><span class="koboSpan" id="kobo.76.1" xmlns="http://www.w3.org/1999/xhtml">Core</span></code><span class="koboSpan" id="kobo.77.1" xmlns="http://www.w3.org/1999/xhtml"> project so the other projects can implement the mapping they need. </span><span class="koboSpan" id="kobo.77.2" xmlns="http://www.w3.org/1999/xhtml">Let’s adopt the second design that we saw:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.78.1" xmlns="http://www.w3.org/1999/xhtml">namespace Core.Mappers;
public interface IMapper&lt;TSource, TDestination&gt;
{
    TDestination Map(TSource entity);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.79.1" xmlns="http://www.w3.org/1999/xhtml">With this interface, we can start by creating the data mappers. </span><span class="koboSpan" id="kobo.79.2" xmlns="http://www.w3.org/1999/xhtml">But first, let’s start by creating record classes instead of anonymous types to name the DTOs returned by the endpoints. </span><span class="koboSpan" id="kobo.79.3" xmlns="http://www.w3.org/1999/xhtml">Here are all the DTOs (from the </span><code><span class="koboSpan" id="kobo.80.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.81.1" xmlns="http://www.w3.org/1999/xhtml"> file):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.82.1" xmlns="http://www.w3.org/1999/xhtml">// Input stock DTOs
public record class AddStocksCommand(int Amount);
public record class RemoveStocksCommand(int Amount);
// Output stock DTO
public record class StockLevel(int QuantityInStock);
// Output "read all products" DTO
public record class ProductDetails(int Id, string Name, int QuantityInStock);
// Output Exceptions DTO
public record class ProductNotFound(int ProductId, string Message);
public record class NotEnoughStock(int AmountToRemove, int QuantityInStock, string Message);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.83.1" xmlns="http://www.w3.org/1999/xhtml">Three of the four output DTOs need mapping:</span></p>
<ul>
<li><code><span class="koboSpan" id="kobo.84.1" xmlns="http://www.w3.org/1999/xhtml">Product</span></code><span class="koboSpan" id="kobo.85.1" xmlns="http://www.w3.org/1999/xhtml"> to </span><code><span class="koboSpan" id="kobo.86.1" xmlns="http://www.w3.org/1999/xhtml">ProductDetails</span></code></li>
<li><code><span class="koboSpan" id="kobo.87.1" xmlns="http://www.w3.org/1999/xhtml">ProductNotFoundException</span></code><span class="koboSpan" id="kobo.88.1" xmlns="http://www.w3.org/1999/xhtml"> to </span><code><span class="koboSpan" id="kobo.89.1" xmlns="http://www.w3.org/1999/xhtml">ProductNotFound</span></code></li>
<li><code><span class="koboSpan" id="kobo.90.1" xmlns="http://www.w3.org/1999/xhtml">NotEnoughStockException</span></code><span class="koboSpan" id="kobo.91.1" xmlns="http://www.w3.org/1999/xhtml"> to </span><code><span class="koboSpan" id="kobo.92.1" xmlns="http://www.w3.org/1999/xhtml">NotEnoughStock</span></code></li>
</ul>
<blockquote>
<p><span class="koboSpan" id="kobo.93.1" xmlns="http://www.w3.org/1999/xhtml">Why not map the </span><code><span class="koboSpan" id="kobo.94.1" xmlns="http://www.w3.org/1999/xhtml">StockLevel</span></code><span class="koboSpan" id="kobo.95.1" xmlns="http://www.w3.org/1999/xhtml"> DTO? </span><span class="koboSpan" id="kobo.95.2" xmlns="http://www.w3.org/1999/xhtml">In our case, the </span><code><span class="koboSpan" id="kobo.96.1" xmlns="http://www.w3.org/1999/xhtml">StockService</span></code><span class="koboSpan" id="kobo.97.1" xmlns="http://www.w3.org/1999/xhtml"> returns an </span><code><span class="koboSpan" id="kobo.98.1" xmlns="http://www.w3.org/1999/xhtml">int</span></code><span class="koboSpan" id="kobo.99.1" xmlns="http://www.w3.org/1999/xhtml"> when we add or remove stocks, so converting a primitive value like an </span><code><span class="koboSpan" id="kobo.100.1" xmlns="http://www.w3.org/1999/xhtml">int</span></code><span class="koboSpan" id="kobo.101.1" xmlns="http://www.w3.org/1999/xhtml"> into a </span><code><span class="koboSpan" id="kobo.102.1" xmlns="http://www.w3.org/1999/xhtml">StockLevel</span></code><span class="koboSpan" id="kobo.103.1" xmlns="http://www.w3.org/1999/xhtml"> object does not require an object mapper. </span><span class="koboSpan" id="kobo.103.2" xmlns="http://www.w3.org/1999/xhtml">Moreover, creating such an object mapper adds no value and makes the code more complex. </span><span class="koboSpan" id="kobo.103.3" xmlns="http://www.w3.org/1999/xhtml">If the service had returned an object, creating a mapper that maps an object to </span><code><span class="koboSpan" id="kobo.104.1" xmlns="http://www.w3.org/1999/xhtml">StockLevel</span></code><span class="koboSpan" id="kobo.105.1" xmlns="http://www.w3.org/1999/xhtml"> would have made more sense.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.106.1" xmlns="http://www.w3.org/1999/xhtml">Let’s start with the product mapper (from the </span><code><span class="koboSpan" id="kobo.107.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.108.1" xmlns="http://www.w3.org/1999/xhtml"> file):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.109.1" xmlns="http://www.w3.org/1999/xhtml">public class ProductMapper : IMapper&lt;Product, ProductDetails&gt;
{
    public ProductDetails Map(Product entity)
        =&gt; new(entity.Id ?? </span><span class="koboSpan" id="kobo.109.2" xmlns="http://www.w3.org/1999/xhtml">default, entity.Name, entity.QuantityInStock);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.110.1" xmlns="http://www.w3.org/1999/xhtml">The preceding code is straightforward; the </span><code><span class="koboSpan" id="kobo.111.1" xmlns="http://www.w3.org/1999/xhtml">ProductMapper</span></code><span class="koboSpan" id="kobo.112.1" xmlns="http://www.w3.org/1999/xhtml"> class implements the </span><code><span class="koboSpan" id="kobo.113.1" xmlns="http://www.w3.org/1999/xhtml">IMapper&lt;Product,</span></code> <code><span class="koboSpan" id="kobo.114.1" xmlns="http://www.w3.org/1999/xhtml">ProductDetails&gt;</span></code><span class="koboSpan" id="kobo.115.1" xmlns="http://www.w3.org/1999/xhtml"> interface. </span><span class="koboSpan" id="kobo.115.2" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.116.1" xmlns="http://www.w3.org/1999/xhtml">Map</span></code><span class="koboSpan" id="kobo.117.1" xmlns="http://www.w3.org/1999/xhtml"> method returns a </span><code><span class="koboSpan" id="kobo.118.1" xmlns="http://www.w3.org/1999/xhtml">ProductDetails</span></code><span class="koboSpan" id="kobo.119.1" xmlns="http://www.w3.org/1999/xhtml"> instance. </span><span class="koboSpan" id="kobo.119.2" xmlns="http://www.w3.org/1999/xhtml">The highlighted code ensures the </span><code><span class="koboSpan" id="kobo.120.1" xmlns="http://www.w3.org/1999/xhtml">Id</span></code><span class="koboSpan" id="kobo.121.1" xmlns="http://www.w3.org/1999/xhtml"> property is not </span><code><span class="koboSpan" id="kobo.122.1" xmlns="http://www.w3.org/1999/xhtml">null</span></code><span class="koboSpan" id="kobo.123.1" xmlns="http://www.w3.org/1999/xhtml">, which should not happen. </span><span class="koboSpan" id="kobo.123.2" xmlns="http://www.w3.org/1999/xhtml">We could also add a guard clause to ensure the </span><code><span class="koboSpan" id="kobo.124.1" xmlns="http://www.w3.org/1999/xhtml">Id</span></code><span class="koboSpan" id="kobo.125.1" xmlns="http://www.w3.org/1999/xhtml"> property is not </span><code><span class="koboSpan" id="kobo.126.1" xmlns="http://www.w3.org/1999/xhtml">null</span></code><span class="koboSpan" id="kobo.127.1" xmlns="http://www.w3.org/1999/xhtml">.All in all, the </span><code><span class="koboSpan" id="kobo.128.1" xmlns="http://www.w3.org/1999/xhtml">Map</span></code><span class="koboSpan" id="kobo.129.1" xmlns="http://www.w3.org/1999/xhtml"> method takes a </span><code><span class="koboSpan" id="kobo.130.1" xmlns="http://www.w3.org/1999/xhtml">Product</span></code><span class="koboSpan" id="kobo.131.1" xmlns="http://www.w3.org/1999/xhtml"> as input and outputs a </span><code><span class="koboSpan" id="kobo.132.1" xmlns="http://www.w3.org/1999/xhtml">ProductDetails</span></code><span class="koboSpan" id="kobo.133.1" xmlns="http://www.w3.org/1999/xhtml"> instance containing the same values.Then let’s continue with the exception mappers (from the </span><code><span class="koboSpan" id="kobo.134.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.135.1" xmlns="http://www.w3.org/1999/xhtml"> file):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.136.1" xmlns="http://www.w3.org/1999/xhtml">public class ExceptionsMapper : IMapper&lt;ProductNotFoundException, ProductNotFound&gt;, IMapper&lt;NotEnoughStockException, NotEnoughStock&gt;
{
    public ProductNotFound Map(ProductNotFoundException exception)
        =&gt; new(exception.ProductId, exception.Message);
    public NotEnoughStock Map(NotEnoughStockException exception)
        =&gt; new(exception.AmountToRemove, exception.QuantityInStock, exception.Message);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.137.1" xmlns="http://www.w3.org/1999/xhtml">Compared to the </span><code><span class="koboSpan" id="kobo.138.1" xmlns="http://www.w3.org/1999/xhtml">ProductMapper</span></code><span class="koboSpan" id="kobo.139.1" xmlns="http://www.w3.org/1999/xhtml"> class, the </span><code><span class="koboSpan" id="kobo.140.1" xmlns="http://www.w3.org/1999/xhtml">ExceptionsMapper</span></code><span class="koboSpan" id="kobo.141.1" xmlns="http://www.w3.org/1999/xhtml"> class implements the two remaining use cases by implementing the </span><code><span class="koboSpan" id="kobo.142.1" xmlns="http://www.w3.org/1999/xhtml">IMapper</span></code><span class="koboSpan" id="kobo.143.1" xmlns="http://www.w3.org/1999/xhtml"> interface twice. </span><span class="koboSpan" id="kobo.143.2" xmlns="http://www.w3.org/1999/xhtml">The two </span><code><span class="koboSpan" id="kobo.144.1" xmlns="http://www.w3.org/1999/xhtml">Map</span></code><span class="koboSpan" id="kobo.145.1" xmlns="http://www.w3.org/1999/xhtml"> methods handle mapping an exception to its DTO, leading to one class being responsible for mapping exceptions to DTOs.Let’s look at the </span><code><span class="koboSpan" id="kobo.146.1" xmlns="http://www.w3.org/1999/xhtml">products</span></code><span class="koboSpan" id="kobo.147.1" xmlns="http://www.w3.org/1999/xhtml"> endpoint (original value from the </span><code><span class="koboSpan" id="kobo.148.1" xmlns="http://www.w3.org/1999/xhtml">clean-architecture</span></code><span class="koboSpan" id="kobo.149.1" xmlns="http://www.w3.org/1999/xhtml"> project of </span><em><span class="koboSpan" id="kobo.150.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 14</span></em><span class="koboSpan" id="kobo.151.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.152.1" xmlns="http://www.w3.org/1999/xhtml">Layering and Clean Architecture</span></em><span class="koboSpan" id="kobo.153.1" xmlns="http://www.w3.org/1999/xhtml">):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.154.1" xmlns="http://www.w3.org/1999/xhtml">app.MapGet("/products", async (
    IProductRepository productRepository, 
    CancellationToken cancellationToken) =&gt;
{
    var products = await productRepository.AllAsync(cancellationToken);
    return products.Select(p =&gt; new
    {
        p.Id,
        p.Name,
        p.QuantityInStock
    });
});</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.155.1" xmlns="http://www.w3.org/1999/xhtml">Before analyzing the code, let’s look at the updated version (from the </span><code><span class="koboSpan" id="kobo.156.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.157.1" xmlns="http://www.w3.org/1999/xhtml"> file):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.158.1" xmlns="http://www.w3.org/1999/xhtml">app.MapGet("/products", async (
    IProductRepository productRepository, 
    IMapper&lt;Product, ProductDetails&gt; mapper, 
    CancellationToken cancellationToken) =&gt;
{
    var products = await productRepository.AllAsync(cancellationToken);
    return products.Select(p =&gt; mapper.Map(p));
});</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.159.1" xmlns="http://www.w3.org/1999/xhtml">In the preceding code, the request delegate uses the mapper to replace the copy logic (the highlighted lines of the original code). </span><span class="koboSpan" id="kobo.159.2" xmlns="http://www.w3.org/1999/xhtml">That simplifies the handler, moving the mapping responsibility into mapper objects instead (highlighted in the preceding code)—one more step toward the SRP.Let’s skip the add stocks endpoint since it is very similar to the remove stocks endpoint but simpler, and let’s focus on the later (original value from the </span><code><span class="koboSpan" id="kobo.160.1" xmlns="http://www.w3.org/1999/xhtml">clean-architecture</span></code><span class="koboSpan" id="kobo.161.1" xmlns="http://www.w3.org/1999/xhtml"> project of </span><em><span class="koboSpan" id="kobo.162.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 14</span></em><span class="koboSpan" id="kobo.163.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.164.1" xmlns="http://www.w3.org/1999/xhtml">Layering and Clean Architecture</span></em><span class="koboSpan" id="kobo.165.1" xmlns="http://www.w3.org/1999/xhtml">):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.166.1" xmlns="http://www.w3.org/1999/xhtml">app.MapPost("/products/{productId:int}/remove-stocks", async (
    int productId, 
    RemoveStocksCommand command, 
    StockService stockService, 
    CancellationToken cancellationToken) =&gt;
{
    try
    {
        var quantityInStock = await stockService.RemoveStockAsync(productId, command.Amount, cancellationToken);
        var stockLevel = new StockLevel(quantityInStock);
        return Results.Ok(stockLevel);
    }
    catch (NotEnoughStockException ex)
    {
        return Results.Conflict(new
        {
            ex.Message,
            ex.AmountToRemove,
            ex.QuantityInStock
        });
    }
    catch (ProductNotFoundException ex)
    {
        return Results.NotFound(new
        {
            ex.Message,
            productId,
        });
    }
});</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.167.1" xmlns="http://www.w3.org/1999/xhtml">Once again, before analyzing the code, let’s look at the updated version (from the </span><code><span class="koboSpan" id="kobo.168.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.169.1" xmlns="http://www.w3.org/1999/xhtml"> file):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.170.1" xmlns="http://www.w3.org/1999/xhtml">app.MapPost("/products/{productId:int}/remove-stocks", async (
    int productId, 
    RemoveStocksCommand command, 
    StockService stockService, 
    IMapper&lt;ProductNotFoundException, ProductNotFound&gt; notFoundMapper, 
    IMapper&lt;NotEnoughStockException, NotEnoughStock&gt; notEnoughStockMapper, 
    CancellationToken cancellationToken) =&gt;
{
    try
    {
        var quantityInStock = await stockService.RemoveStockAsync(productId, command.Amount, cancellationToken);
        var stockLevel = new StockLevel(quantityInStock);
        return Results.Ok(stockLevel);
    }
    catch (NotEnoughStockException ex)
    {
        return Results.Conflict(notEnoughStockMapper.Map(ex));
    }
    catch (ProductNotFoundException ex)
    {
        return Results.NotFound(notFoundMapper.Map(ex));
    }
});</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.171.1" xmlns="http://www.w3.org/1999/xhtml">The same thing happened for this request delegate, but we injected two mappers instead of just one. </span><span class="koboSpan" id="kobo.171.2" xmlns="http://www.w3.org/1999/xhtml">We moved the mapping logic from inline using an anonymous type to the mapper objects. </span><span class="koboSpan" id="kobo.171.3" xmlns="http://www.w3.org/1999/xhtml">Nevertheless, a code smell is emerging here; can you smell it? </span><span class="koboSpan" id="kobo.171.4" xmlns="http://www.w3.org/1999/xhtml">We will investigate this after we are done with this project; meanwhile, keep thinking about the number of injected dependencies.Now that the delegates depend on interfaces with object mappers encapsulating the mapping responsibility, we must configure the composition root and bind the mapper implementations to the </span><code><span class="koboSpan" id="kobo.172.1" xmlns="http://www.w3.org/1999/xhtml">IMapper&lt;TSource, TDestination&gt;</span></code><span class="koboSpan" id="kobo.173.1" xmlns="http://www.w3.org/1999/xhtml"> interface. </span><span class="koboSpan" id="kobo.173.2" xmlns="http://www.w3.org/1999/xhtml">The service bindings look like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.174.1" xmlns="http://www.w3.org/1999/xhtml">.AddSingleton&lt;IMapper&lt;Product, ProductDetails&gt;, ProductMapper&gt;()
.AddSingleton&lt;IMapper&lt;ProductNotFoundException, ProductNotFound&gt;, ExceptionsMapper&gt;()
.AddSingleton&lt;IMapper&lt;NotEnoughStockException, NotEnoughStock&gt;, ExceptionsMapper&gt;()</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.175.1" xmlns="http://www.w3.org/1999/xhtml">Since </span><code><span class="koboSpan" id="kobo.176.1" xmlns="http://www.w3.org/1999/xhtml">ExceptionsMapper</span></code><span class="koboSpan" id="kobo.177.1" xmlns="http://www.w3.org/1999/xhtml"> implements two interfaces, we bind both to that class. </span><span class="koboSpan" id="kobo.177.2" xmlns="http://www.w3.org/1999/xhtml">That is one of the beauties of abstractions; the remove stocks delegate asks for two mappers but receives an instance of </span><code><span class="koboSpan" id="kobo.178.1" xmlns="http://www.w3.org/1999/xhtml">ExceptionsMapper</span></code><span class="koboSpan" id="kobo.179.1" xmlns="http://www.w3.org/1999/xhtml"> twice without even knowing it.We could also register the classes so the same instance is injected twice, like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.180.1" xmlns="http://www.w3.org/1999/xhtml">.AddSingleton&lt;ExceptionsMapper&gt;()
.AddSingleton&lt;IMapper&lt;ProductNotFoundException, ProductNotFound&gt;, ExceptionsMapper&gt;(sp =&gt; sp.GetRequiredService&lt;ExceptionsMapper&gt;())
.AddSingleton&lt;IMapper&lt;NotEnoughStockException, NotEnoughStock&gt;, ExceptionsMapper&gt;(sp =&gt; sp.GetRequiredService&lt;ExceptionsMapper&gt;())</span></code></pre>
</div>
<blockquote>
<p><span class="koboSpan" id="kobo.181.1" xmlns="http://www.w3.org/1999/xhtml">Yes, I did that double registration of the same class on purpose. </span><span class="koboSpan" id="kobo.181.2" xmlns="http://www.w3.org/1999/xhtml">That proves we can compose an application as we want without impacting the </span><strong><span class="koboSpan" id="kobo.182.1" xmlns="http://www.w3.org/1999/xhtml">consumers</span></strong><span class="koboSpan" id="kobo.183.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.183.2" xmlns="http://www.w3.org/1999/xhtml">That is done by depending on abstractions instead of implementations, as per the </span><strong><span class="koboSpan" id="kobo.184.1" xmlns="http://www.w3.org/1999/xhtml">Dependency Inversion Principle</span></strong><span class="koboSpan" id="kobo.185.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.186.1" xmlns="http://www.w3.org/1999/xhtml">DIP</span></strong><span class="koboSpan" id="kobo.187.1" xmlns="http://www.w3.org/1999/xhtml">—the “D” in SOLID). </span><span class="koboSpan" id="kobo.187.2" xmlns="http://www.w3.org/1999/xhtml">Moreover, the division into small interfaces, as per the </span><strong><span class="koboSpan" id="kobo.188.1" xmlns="http://www.w3.org/1999/xhtml">Interface Segregation Principle</span></strong><span class="koboSpan" id="kobo.189.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.190.1" xmlns="http://www.w3.org/1999/xhtml">ISP</span></strong><span class="koboSpan" id="kobo.191.1" xmlns="http://www.w3.org/1999/xhtml">—the “I” in SOLID), makes that kind of scenario possible. </span><span class="koboSpan" id="kobo.191.2" xmlns="http://www.w3.org/1999/xhtml">Finally, we can glue all those pieces together using the power of </span><strong><span class="koboSpan" id="kobo.192.1" xmlns="http://www.w3.org/1999/xhtml">Dependency Injection</span></strong><span class="koboSpan" id="kobo.193.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.194.1" xmlns="http://www.w3.org/1999/xhtml">DI</span></strong><span class="koboSpan" id="kobo.195.1" xmlns="http://www.w3.org/1999/xhtml">).</span></p>
</blockquote>
</section>
<section class="level3" data-number="16.2.4" id="conclusion-22">
<h3 data-number="16.2.4"><span class="koboSpan" id="kobo.196.1" xmlns="http://www.w3.org/1999/xhtml">Conclusion</span></h3>
<p><span class="koboSpan" id="kobo.197.1" xmlns="http://www.w3.org/1999/xhtml">Before exploring more alternatives, let’s see how object mapping can help us follow the </span><strong><span class="koboSpan" id="kobo.198.1" xmlns="http://www.w3.org/1999/xhtml">SOLID</span></strong><span class="koboSpan" id="kobo.199.1" xmlns="http://www.w3.org/1999/xhtml"> principles:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.200.1" xmlns="http://www.w3.org/1999/xhtml">S</span></strong><span class="koboSpan" id="kobo.201.1" xmlns="http://www.w3.org/1999/xhtml">: Using mapper objects helps to separate the responsibility of mapping types from the consumers, making it easier to maintain and refactor the mapping logic.</span></li>
<li><strong><span class="koboSpan" id="kobo.202.1" xmlns="http://www.w3.org/1999/xhtml">O</span></strong><span class="koboSpan" id="kobo.203.1" xmlns="http://www.w3.org/1999/xhtml">: By injecting mappers, we can change the mapping logic without changing the code of their consumers.</span></li>
<li><strong><span class="koboSpan" id="kobo.204.1" xmlns="http://www.w3.org/1999/xhtml">L</span></strong><span class="koboSpan" id="kobo.205.1" xmlns="http://www.w3.org/1999/xhtml">: N/A</span></li>
<li><strong><span class="koboSpan" id="kobo.206.1" xmlns="http://www.w3.org/1999/xhtml">I</span></strong><span class="koboSpan" id="kobo.207.1" xmlns="http://www.w3.org/1999/xhtml">: We explored different designs that provide a small mapper interface that reduces the dependencies between the components.</span></li>
<li><strong><span class="koboSpan" id="kobo.208.1" xmlns="http://www.w3.org/1999/xhtml">D</span></strong><span class="koboSpan" id="kobo.209.1" xmlns="http://www.w3.org/1999/xhtml">: The consumers depend only on abstractions, moving the implementation’s binding to the composition root and inverting the dependency flow.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.210.1" xmlns="http://www.w3.org/1999/xhtml">Now that we’ve explored how to extract and use mappers, let’s look at the code smell that emerged.</span></p>
</section>
</section>
<section class="level2" data-number="16.3" id="code-smell-too-many-dependencies">
<h2 data-number="16.3"><span class="koboSpan" id="kobo.211.1" xmlns="http://www.w3.org/1999/xhtml">Code smell – Too many dependencies</span></h2>
<p><span class="koboSpan" id="kobo.212.1" xmlns="http://www.w3.org/1999/xhtml">Using this kind of mapping could become tedious in the long run, and we would rapidly see scenarios such as injecting three or more mappers into a single request delegate or controller. </span><span class="koboSpan" id="kobo.212.2" xmlns="http://www.w3.org/1999/xhtml">The consumer would likely already have other dependencies, leading to four or more.That should raise the following flag:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.213.1" xmlns="http://www.w3.org/1999/xhtml">Does the class do too much and have too many responsibilities?</span></li>
</ul>
<p><span class="koboSpan" id="kobo.214.1" xmlns="http://www.w3.org/1999/xhtml">In this case, the fine-grained </span><code><span class="koboSpan" id="kobo.215.1" xmlns="http://www.w3.org/1999/xhtml">IMapper</span></code><span class="koboSpan" id="kobo.216.1" xmlns="http://www.w3.org/1999/xhtml"> interface pollutes our request delegates with tons of dependencies on mappers, which is not ideal and makes our code harder to read.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.217.1" xmlns="http://www.w3.org/1999/xhtml">The preferred solution would be to move the exception-handling responsibility away from the delegates or controllers, leveraging a middleware or an exception filter, for example. </span><span class="koboSpan" id="kobo.217.2" xmlns="http://www.w3.org/1999/xhtml">This tactic would move boilerplate code away from the endpoints.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.218.1" xmlns="http://www.w3.org/1999/xhtml">Since we are talking about mappers, we will explore more object mapping concepts to help us with this problem instead, which applies to many use cases.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.219.1" xmlns="http://www.w3.org/1999/xhtml">As a rule of thumb, you want to </span><strong><span class="koboSpan" id="kobo.220.1" xmlns="http://www.w3.org/1999/xhtml">limit the number of dependencies to three or less</span></strong><span class="koboSpan" id="kobo.221.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.221.2" xmlns="http://www.w3.org/1999/xhtml">Over that number, ask yourself if there is a problem with that class; does it have too many responsibilities? </span><span class="koboSpan" id="kobo.221.3" xmlns="http://www.w3.org/1999/xhtml">Having more than three dependencies is not inherently wrong; it just indicates that you should investigate the design. </span><span class="koboSpan" id="kobo.221.4" xmlns="http://www.w3.org/1999/xhtml">If nothing is wrong, keep it at 4 or 5, or 10; it does not matter. </span><span class="koboSpan" id="kobo.221.5" xmlns="http://www.w3.org/1999/xhtml">If you find a way to reduce the number of dependencies or that the class actually does too many things refactor the code.If you don’t like having that many dependencies, you could extract service aggregates that encapsulate two or more dependencies and inject that aggregate instead. </span><span class="koboSpan" id="kobo.221.6" xmlns="http://www.w3.org/1999/xhtml">Beware that moving your dependencies around does not fix anything; it just moves the problem elsewhere if there was a problem in the first place. </span><span class="koboSpan" id="kobo.221.7" xmlns="http://www.w3.org/1999/xhtml">Using aggregates could increase the readability of the code, though.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.222.1" xmlns="http://www.w3.org/1999/xhtml">Instead of blindly moving dependencies around, analyze the problem to see if you could create classes with actual logic that could do something useful to reduce the number of dependencies.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.223.1" xmlns="http://www.w3.org/1999/xhtml">Next, let’s have a quick look at aggregating services.</span></p>
</section>
<section class="level2" data-number="16.4" id="pattern-aggregate-services">
<h2 data-number="16.4"><span class="koboSpan" id="kobo.224.1" xmlns="http://www.w3.org/1999/xhtml">Pattern – Aggregate Services</span></h2>
<p><span class="koboSpan" id="kobo.225.1" xmlns="http://www.w3.org/1999/xhtml">Even if the Aggregate Services pattern is not a magic problem-solving pattern, it is a viable alternative to injecting too many dependencies into another class. </span><span class="koboSpan" id="kobo.225.2" xmlns="http://www.w3.org/1999/xhtml">Its goal is to aggregate many dependencies in a class to reduce the number of injected services in other classes, grouping dependencies together. </span><span class="koboSpan" id="kobo.225.3" xmlns="http://www.w3.org/1999/xhtml">The way to manage aggregates would be to group them by concern or responsibility. </span><span class="koboSpan" id="kobo.225.4" xmlns="http://www.w3.org/1999/xhtml">Putting a bunch of services in another service just for the sake of it is rarely the way to go; aim for cohesion.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.226.1" xmlns="http://www.w3.org/1999/xhtml">Creating one or more aggregation services that expose other services can be a way to implement service discovery in a project. </span><span class="koboSpan" id="kobo.226.2" xmlns="http://www.w3.org/1999/xhtml">Like always, analyze if the problem is not elsewhere first. </span><span class="koboSpan" id="kobo.226.3" xmlns="http://www.w3.org/1999/xhtml">Loading a service that exposes other services can be handy. </span><span class="koboSpan" id="kobo.226.4" xmlns="http://www.w3.org/1999/xhtml">However, this may create issues, so don’t put everything into an aggregate firsthand either.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.227.1" xmlns="http://www.w3.org/1999/xhtml">Here is an example of a mapping aggregate to reduce the number of dependencies of a </span><strong><span class="koboSpan" id="kobo.228.1" xmlns="http://www.w3.org/1999/xhtml">Create-Read-Update-Delete</span></strong><span class="koboSpan" id="kobo.229.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.230.1" xmlns="http://www.w3.org/1999/xhtml">CRUD</span></strong><span class="koboSpan" id="kobo.231.1" xmlns="http://www.w3.org/1999/xhtml">) controller that allows the creation, updating, deletion, and reading of one, many, or all products. </span><span class="koboSpan" id="kobo.231.2" xmlns="http://www.w3.org/1999/xhtml">Here’s the aggregate service code and a usage example:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.232.1" xmlns="http://www.w3.org/1999/xhtml">public interface IProductMappers
{
    IMapper&lt;Product, ProductDetails&gt; EntityToDto { get; }
    IMapper&lt;InsertProduct, Product&gt; InsertDtoToEntity { get; }
    IMapper&lt;UpdateProduct, Product&gt; UpdateDtoToEntity { get; }
}
public class ProductMappers : IProductMappers
{
    public ProductMappers(IMapper&lt;Product, ProductDetails&gt; entityToDto, IMapper&lt;InsertProduct, Product&gt; insertDtoToEntity, IMapper&lt;UpdateProduct, Product&gt; updateDtoToEntity)
    {
        EntityToDto = entityToDto ?? </span><span class="koboSpan" id="kobo.232.2" xmlns="http://www.w3.org/1999/xhtml">throw new ArgumentNullException(nameof(entityToDto));
        InsertDtoToEntity = insertDtoToEntity ?? </span><span class="koboSpan" id="kobo.232.3" xmlns="http://www.w3.org/1999/xhtml">throw new ArgumentNullException(nameof(insertDtoToEntity));
        UpdateDtoToEntity = updateDtoToEntity ?? </span><span class="koboSpan" id="kobo.232.4" xmlns="http://www.w3.org/1999/xhtml">throw new ArgumentNullException(nameof(updateDtoToEntity));
    }
    public IMapper&lt;Product, ProductDetails&gt; EntityToDto { get; }
    public IMapper&lt;InsertProduct, Product&gt; InsertDtoToEntity { get; }
    public IMapper&lt;UpdateProduct, Product&gt; UpdateDtoToEntity { get; }
}
public class ProductsController : ControllerBase
{
    private readonly IProductMappers _mapper;
    // Constructor injection, other methods, routing attributes, ...
    </span><span class="koboSpan" id="kobo.232.5" xmlns="http://www.w3.org/1999/xhtml">public ProductDetails GetProductById(int id)
    {
        Product product = ...; // Fetch a product by id
        ProductDetails dto = _mapper.EntityToDto.Map(product);
        return dto;
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.233.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.234.1" xmlns="http://www.w3.org/1999/xhtml">IProductMappers</span></code><span class="koboSpan" id="kobo.235.1" xmlns="http://www.w3.org/1999/xhtml"> aggregate could be logical in this example as it groups the mappers used by the </span><code><span class="koboSpan" id="kobo.236.1" xmlns="http://www.w3.org/1999/xhtml">ProductsController</span></code><span class="koboSpan" id="kobo.237.1" xmlns="http://www.w3.org/1999/xhtml"> class under its umbrella. </span><span class="koboSpan" id="kobo.237.2" xmlns="http://www.w3.org/1999/xhtml">It is responsible for mapping </span><code><span class="koboSpan" id="kobo.238.1" xmlns="http://www.w3.org/1999/xhtml">ProductsController</span></code><span class="koboSpan" id="kobo.239.1" xmlns="http://www.w3.org/1999/xhtml">-related domain objects to DTOs and vice versa while the controller gives up this responsibility.You can create aggregate services with anything, not just mappers. </span><span class="koboSpan" id="kobo.239.2" xmlns="http://www.w3.org/1999/xhtml">That’s a fairly common pattern in DI-heavy applications (which can also point to some design flaws).Now that we’ve explored the Aggregate Services pattern, let’s explore how to make a mapping façade instead.</span></p>
</section>
<section class="level2" data-number="16.5" id="pattern-mapping-façade">
<h2 data-number="16.5"><span class="koboSpan" id="kobo.240.1" xmlns="http://www.w3.org/1999/xhtml">Pattern – Mapping Façade</span></h2>
<p><span class="koboSpan" id="kobo.241.1" xmlns="http://www.w3.org/1999/xhtml">We studied façades already; here, we explore another way to organize our many mappers by leveraging that design pattern.Instead of what we just did, we will create a mapping façade to replace our aggregate services. </span><span class="koboSpan" id="kobo.241.2" xmlns="http://www.w3.org/1999/xhtml">The code consuming the façade will be more elegant because it uses the </span><code><span class="koboSpan" id="kobo.242.1" xmlns="http://www.w3.org/1999/xhtml">Map</span></code><span class="koboSpan" id="kobo.243.1" xmlns="http://www.w3.org/1999/xhtml"> methods directly instead of the properties. </span><span class="koboSpan" id="kobo.243.2" xmlns="http://www.w3.org/1999/xhtml">The responsibility of the façade is the same as the aggregate, but it implements the interfaces instead of exposing them as properties.Let’s look at the code:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.244.1" xmlns="http://www.w3.org/1999/xhtml">public interface IProductMapperService : 
    IMapper&lt;Product, ProductDetails&gt;, 
    IMapper&lt;InsertProduct, Product&gt;, 
    IMapper&lt;UpdateProduct, Product&gt;
{
}
public class ProductMapperService : IProductMapperService
{
    private readonly IMapper&lt;Product, ProductDetails&gt; _entityToDto;
    private readonly IMapper&lt;InsertProduct, Product&gt; _insertDtoToEntity;
    private readonly IMapper&lt;UpdateProduct, Product&gt; _updateDtoToEntity;
    // Omitted constructor injection code
    public ProductDetails Map(Product entity)
    {
        return _entityToDto.Map(entity);
    }
    public Product Map(InsertProduct dto)
    {
        return _insertDtoToEntity.Map(dto);
    }
    public Product Map(UpdateProduct dto)
    {
        return _updateDtoToEntity.Map(dto);
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.245.1" xmlns="http://www.w3.org/1999/xhtml">In the preceding code, the </span><code><span class="koboSpan" id="kobo.246.1" xmlns="http://www.w3.org/1999/xhtml">ProductMapperService</span></code><span class="koboSpan" id="kobo.247.1" xmlns="http://www.w3.org/1999/xhtml"> class implements the </span><code><span class="koboSpan" id="kobo.248.1" xmlns="http://www.w3.org/1999/xhtml">IMapper</span></code><span class="koboSpan" id="kobo.249.1" xmlns="http://www.w3.org/1999/xhtml"> interfaces through the </span><code><span class="koboSpan" id="kobo.250.1" xmlns="http://www.w3.org/1999/xhtml">IProductMapperService</span></code><span class="koboSpan" id="kobo.251.1" xmlns="http://www.w3.org/1999/xhtml"> interface and delegates the mapping logic to each injected mapper: a façade wrapping multiple individual mappers. </span><span class="koboSpan" id="kobo.251.2" xmlns="http://www.w3.org/1999/xhtml">Next, we look at the </span><code><span class="koboSpan" id="kobo.252.1" xmlns="http://www.w3.org/1999/xhtml">ProductsController</span></code><span class="koboSpan" id="kobo.253.1" xmlns="http://www.w3.org/1999/xhtml"> that consumes the façade:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.254.1" xmlns="http://www.w3.org/1999/xhtml">public class ProductsController : ControllerBase
{
    private readonly IProductMapperService _mapper;
    // Omitted constructor injection, other methods, routing attributes, ...
    </span><span class="koboSpan" id="kobo.254.2" xmlns="http://www.w3.org/1999/xhtml">public ProductDetails GetProductById(int id)
    {
        Product product = ...; // Fetch a product by id
        ProductDetails dto = _mapper.Map(product);
        return dto;
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.255.1" xmlns="http://www.w3.org/1999/xhtml">From the consumer standpoint (the </span><code><span class="koboSpan" id="kobo.256.1" xmlns="http://www.w3.org/1999/xhtml">ProductsController</span></code><span class="koboSpan" id="kobo.257.1" xmlns="http://www.w3.org/1999/xhtml"> class), I find it cleaner to write</span><code><span class="koboSpan" id="kobo.258.1" xmlns="http://www.w3.org/1999/xhtml">_mapper.Map(...)</span></code><span class="koboSpan" id="kobo.259.1" xmlns="http://www.w3.org/1999/xhtml"> instead of </span><code><span class="koboSpan" id="kobo.260.1" xmlns="http://www.w3.org/1999/xhtml">_mapper.SomeMapper.Map(...)</span></code><span class="koboSpan" id="kobo.261.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.261.2" xmlns="http://www.w3.org/1999/xhtml">The consumer does not want to know what mapper is doing what mapping; it only wants to map what needs mapping. </span><span class="koboSpan" id="kobo.261.3" xmlns="http://www.w3.org/1999/xhtml">If we compare the Mapping Façade with the Aggregate Services of the previous example, the façade takes the responsibility of choosing the mapper and moves it away from the consumer. </span><span class="koboSpan" id="kobo.261.4" xmlns="http://www.w3.org/1999/xhtml">This design distributes the responsibilities between the classes better.This was an excellent opportunity to review the Façade design pattern. </span><span class="koboSpan" id="kobo.261.5" xmlns="http://www.w3.org/1999/xhtml">Nonetheless, now that we've gone through multiple mapping options and examined the issue of having too many dependencies, it's time to move forward on our object mapping adventure with an enhanced version of our mapping façade.</span></p>
</section>
<section class="level2" data-number="16.6" id="project-mapping-service">
<h2 data-number="16.6"><span class="koboSpan" id="kobo.262.1" xmlns="http://www.w3.org/1999/xhtml">Project – Mapping service</span></h2>
<p><span class="koboSpan" id="kobo.263.1" xmlns="http://www.w3.org/1999/xhtml">The goal is to simplify the implementation of the Mapper façade with a universal interface. </span><span class="koboSpan" id="kobo.263.2" xmlns="http://www.w3.org/1999/xhtml">To achieve this, we are implementing the diagram shown in </span><em><span class="koboSpan" id="kobo.264.1" xmlns="http://www.w3.org/1999/xhtml">Figure 13.3</span></em><span class="koboSpan" id="kobo.265.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.265.2" xmlns="http://www.w3.org/1999/xhtml">Here’s a reminder:</span></p>
<figure>
<span class="koboSpan" id="kobo.266.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 15.4: Object mapping using a single IMapper interface" src="../media/file97.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.267.1" xmlns="http://www.w3.org/1999/xhtml">Figure 15.4: Object mapping using a single IMapper interface</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.268.1" xmlns="http://www.w3.org/1999/xhtml">Instead of naming the interface </span><code><span class="koboSpan" id="kobo.269.1" xmlns="http://www.w3.org/1999/xhtml">IMapper</span></code><span class="koboSpan" id="kobo.270.1" xmlns="http://www.w3.org/1999/xhtml">, we will use the name </span><code><span class="koboSpan" id="kobo.271.1" xmlns="http://www.w3.org/1999/xhtml">IMappingService</span></code><span class="koboSpan" id="kobo.272.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.272.2" xmlns="http://www.w3.org/1999/xhtml">This name is more suitable because it is not mapping anything; it is a dispatcher servicing the mapping request to the right mapper. </span><span class="koboSpan" id="kobo.272.3" xmlns="http://www.w3.org/1999/xhtml">Let’s take a look:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.273.1" xmlns="http://www.w3.org/1999/xhtml">namespace Core.Mappers;
public interface IMappingService
{
    TDestination Map&lt;TSource, TDestination&gt;(TSource entity);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.274.1" xmlns="http://www.w3.org/1999/xhtml">That interface is self-explanatory; it maps any </span><code><span class="koboSpan" id="kobo.275.1" xmlns="http://www.w3.org/1999/xhtml">TSource</span></code><span class="koboSpan" id="kobo.276.1" xmlns="http://www.w3.org/1999/xhtml"> to any </span><code><span class="koboSpan" id="kobo.277.1" xmlns="http://www.w3.org/1999/xhtml">TDestination</span></code><span class="koboSpan" id="kobo.278.1" xmlns="http://www.w3.org/1999/xhtml">.On the implementation side, we are leveraging the </span><strong><span class="koboSpan" id="kobo.279.1" xmlns="http://www.w3.org/1999/xhtml">Service Locator</span></strong><span class="koboSpan" id="kobo.280.1" xmlns="http://www.w3.org/1999/xhtml"> pattern, so I called the class </span><code><span class="koboSpan" id="kobo.281.1" xmlns="http://www.w3.org/1999/xhtml">ServiceLocatorMappingService</span></code><span class="koboSpan" id="kobo.282.1" xmlns="http://www.w3.org/1999/xhtml">:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.283.1" xmlns="http://www.w3.org/1999/xhtml">namespace Core.Mappers;
public class ServiceLocatorMappingService : IMappingService
{
    private readonly IServiceProvider _serviceProvider;
    public ServiceLocatorMappingService(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider ?? </span><span class="koboSpan" id="kobo.283.2" xmlns="http://www.w3.org/1999/xhtml">throw new ArgumentNullException(nameof(serviceProvider));
    }
    public TDestination Map&lt;TSource, TDestination&gt;(TSource entity)
    {
        var mapper = _serviceProvider.GetService&lt;IMapper&lt;TSource, TDestination&gt;&gt;();
        if (mapper == null)
        {
            throw new MapperNotFoundException(typeof(TSource), typeof(TDestination));
        }
        return mapper.Map(entity);
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.284.1" xmlns="http://www.w3.org/1999/xhtml">The logic is simple:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.285.1" xmlns="http://www.w3.org/1999/xhtml">Find the appropriate </span><code><span class="koboSpan" id="kobo.286.1" xmlns="http://www.w3.org/1999/xhtml">IMapper&lt;TSource, TDestination&gt;</span></code><span class="koboSpan" id="kobo.287.1" xmlns="http://www.w3.org/1999/xhtml"> service, then map the entity with it</span></li>
<li><span class="koboSpan" id="kobo.288.1" xmlns="http://www.w3.org/1999/xhtml">If you don’t find any, throw a </span><code><span class="koboSpan" id="kobo.289.1" xmlns="http://www.w3.org/1999/xhtml">MapperNotFoundException</span></code></li>
</ul>
<p><span class="koboSpan" id="kobo.290.1" xmlns="http://www.w3.org/1999/xhtml">The key to that design is to register the mappers with the IoC container instead of the service itself. </span><span class="koboSpan" id="kobo.290.2" xmlns="http://www.w3.org/1999/xhtml">Then we use the mappers without knowing every single one of them, like in the previous example. </span><span class="koboSpan" id="kobo.290.3" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.291.1" xmlns="http://www.w3.org/1999/xhtml">ServiceLocatorMappingService</span></code><span class="koboSpan" id="kobo.292.1" xmlns="http://www.w3.org/1999/xhtml"> class doesn’t know any mappers; it just dynamically asks for one whenever needed.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.293.1" xmlns="http://www.w3.org/1999/xhtml">The Service Locator pattern should not be part of the application’s code. </span><span class="koboSpan" id="kobo.293.2" xmlns="http://www.w3.org/1999/xhtml">However, it can be helpful at times. </span><span class="koboSpan" id="kobo.293.3" xmlns="http://www.w3.org/1999/xhtml">For example, we are not trying to cheat DI in this case. </span><span class="koboSpan" id="kobo.293.4" xmlns="http://www.w3.org/1999/xhtml">On the contrary, we are leveraging its power.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.294.1" xmlns="http://www.w3.org/1999/xhtml">Using a service locator is wrong when acquiring dependencies in a way that removes the possibility of controlling the program’s composition from the composition root, which breaks the IoC principle.</span></p>
</blockquote>
<blockquote>
<p><span class="koboSpan" id="kobo.295.1" xmlns="http://www.w3.org/1999/xhtml">In this case, we load mappers dynamically from the IoC container, limiting the container’s ability to control what to inject which is acceptable since it has little to no negative impact on the program’s maintainability, flexibility, and reliability. </span><span class="koboSpan" id="kobo.295.2" xmlns="http://www.w3.org/1999/xhtml">For example, we can replace the </span><code><span class="koboSpan" id="kobo.296.1" xmlns="http://www.w3.org/1999/xhtml">ServiceLocatorMappingService</span></code><span class="koboSpan" id="kobo.297.1" xmlns="http://www.w3.org/1999/xhtml"> implementation with another class without affecting the </span><code><span class="koboSpan" id="kobo.298.1" xmlns="http://www.w3.org/1999/xhtml">IMappingService</span></code><span class="koboSpan" id="kobo.299.1" xmlns="http://www.w3.org/1999/xhtml"> interface consumers.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.300.1" xmlns="http://www.w3.org/1999/xhtml">Now, we can inject that service everywhere we need mapping and use it directly. </span><span class="koboSpan" id="kobo.300.2" xmlns="http://www.w3.org/1999/xhtml">We already registered the mappers, so we only need to bind the </span><code><span class="koboSpan" id="kobo.301.1" xmlns="http://www.w3.org/1999/xhtml">IMappingService</span></code><span class="koboSpan" id="kobo.302.1" xmlns="http://www.w3.org/1999/xhtml"> to its </span><code><span class="koboSpan" id="kobo.303.1" xmlns="http://www.w3.org/1999/xhtml">ServiceLocatorMappingService</span></code><span class="koboSpan" id="kobo.304.1" xmlns="http://www.w3.org/1999/xhtml"> implementation and update the consumers. </span><span class="koboSpan" id="kobo.304.2" xmlns="http://www.w3.org/1999/xhtml">Here’s the DI binding:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.305.1" xmlns="http://www.w3.org/1999/xhtml">.AddSingleton&lt;IMappingService, ServiceLocatorMappingService&gt;();</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.306.1" xmlns="http://www.w3.org/1999/xhtml">If we look at the new implementation of the remove stocks endpoint, we can see we reduced the number of mapper dependencies to one:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.307.1" xmlns="http://www.w3.org/1999/xhtml">app.MapPost("/products/{productId:int}/remove-stocks", async (
    int productId, 
    RemoveStocksCommand command, 
    StockService stockService, 
    IMappingService mapper, 
    CancellationToken cancellationToken) =&gt; {
    try
    {
        var quantityInStock = await stockService.RemoveStockAsync(productId, command.Amount, cancellationToken);
        var stockLevel = new StockLevel(quantityInStock);
        return Results.Ok(stockLevel);
    }
    catch (NotEnoughStockException ex)
    {
        return Results.Conflict(mapper.Map&lt;NotEnoughStockException, NotEnoughStock&gt;(ex));
    }
    catch (ProductNotFoundException ex)
    {
        return Results.NotFound(mapper.Map&lt;ProductNotFoundException, ProductNotFound&gt;(ex));
    }
});</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.308.1" xmlns="http://www.w3.org/1999/xhtml">The preceding code is similar to the previous sample, but we replaced the mappers with the new service (the highlighted lines). </span><span class="koboSpan" id="kobo.308.2" xmlns="http://www.w3.org/1999/xhtml">And that’s it; we now have a universal mapping service that delegates the mapping to any mapper we register with the IoC container.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.309.1" xmlns="http://www.w3.org/1999/xhtml">Even if you are not likely to implement object mappers manually often, exploring and revisiting those patterns and a code smell is very good and will help you craft better software.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.310.1" xmlns="http://www.w3.org/1999/xhtml">This is not the end of our object mapping exploration. </span><span class="koboSpan" id="kobo.310.2" xmlns="http://www.w3.org/1999/xhtml">We have two tools to explore, starting with AutoMapper, which does all the object mapping work for us.</span></p>
</section>
<section class="level2" data-number="16.7" id="project-automapper">
<h2 data-number="16.7"><span class="koboSpan" id="kobo.311.1" xmlns="http://www.w3.org/1999/xhtml">Project – AutoMapper</span></h2>
<p><span class="koboSpan" id="kobo.312.1" xmlns="http://www.w3.org/1999/xhtml">We just covered different ways to implement object mapping, but here we leverage an open-source tool named AutoMapper that does it for us instead of implementing our own.Why bother learning all of that if a tool already does it? </span><span class="koboSpan" id="kobo.312.2" xmlns="http://www.w3.org/1999/xhtml">There are a few reasons to do so:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.313.1" xmlns="http://www.w3.org/1999/xhtml">It is important to understand the concepts; you don’t always need a full-fledged tool like AutoMapper.</span></li>
<li><span class="koboSpan" id="kobo.314.1" xmlns="http://www.w3.org/1999/xhtml">It allowed us to cover multiple patterns we can use in other contexts and apply them to components with different responsibilities. </span><span class="koboSpan" id="kobo.314.2" xmlns="http://www.w3.org/1999/xhtml">So, all in all, you should have learned multiple new techniques during this object mapping progression.</span></li>
<li><span class="koboSpan" id="kobo.315.1" xmlns="http://www.w3.org/1999/xhtml">Lastly, we dug deeper into applying the SOLID principles to write better programs.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.316.1" xmlns="http://www.w3.org/1999/xhtml">The AutoMapper project is also a copy of the Clean Architecture sample. </span><span class="koboSpan" id="kobo.316.2" xmlns="http://www.w3.org/1999/xhtml">The biggest difference between this project and the others is that we don’t need to define any interface because AutoMapper exposes an </span><code><span class="koboSpan" id="kobo.317.1" xmlns="http://www.w3.org/1999/xhtml">IMapper</span></code><span class="koboSpan" id="kobo.318.1" xmlns="http://www.w3.org/1999/xhtml"> interface with all the methods we need and more.To install AutoMapper, you can install the </span><code><span class="koboSpan" id="kobo.319.1" xmlns="http://www.w3.org/1999/xhtml">AutoMapper</span></code><span class="koboSpan" id="kobo.320.1" xmlns="http://www.w3.org/1999/xhtml"> NuGet package using the CLI (</span><code><span class="koboSpan" id="kobo.321.1" xmlns="http://www.w3.org/1999/xhtml">dotnet add package AutoMapper</span></code><span class="koboSpan" id="kobo.322.1" xmlns="http://www.w3.org/1999/xhtml">), Visual Studio’s NuGet package manager, or by updating your </span><code><span class="koboSpan" id="kobo.323.1" xmlns="http://www.w3.org/1999/xhtml">.csproj</span></code><span class="koboSpan" id="kobo.324.1" xmlns="http://www.w3.org/1999/xhtml"> manually.The best way to define our mappers is by using AutoMapper’s profile mechanism. </span><span class="koboSpan" id="kobo.324.2" xmlns="http://www.w3.org/1999/xhtml">A profile is a simple class that inherits from </span><code><span class="koboSpan" id="kobo.325.1" xmlns="http://www.w3.org/1999/xhtml">AutoMapper.Profile</span></code><span class="koboSpan" id="kobo.326.1" xmlns="http://www.w3.org/1999/xhtml"> and contains maps from one object to another. </span><span class="koboSpan" id="kobo.326.2" xmlns="http://www.w3.org/1999/xhtml">We use profiles to group mappers together, but in our case, with only three maps, I decided to create a single </span><code><span class="koboSpan" id="kobo.327.1" xmlns="http://www.w3.org/1999/xhtml">WebProfile</span></code><span class="koboSpan" id="kobo.328.1" xmlns="http://www.w3.org/1999/xhtml"> class.Finally, instead of manually registering our profiles, we can scan one or more assemblies to load all of the profiles into AutoMapper by using the </span><code><span class="koboSpan" id="kobo.329.1" xmlns="http://www.w3.org/1999/xhtml">AutoMapper.Extensions.Microsoft.DependencyInjection</span></code><span class="koboSpan" id="kobo.330.1" xmlns="http://www.w3.org/1999/xhtml"> package.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.331.1" xmlns="http://www.w3.org/1999/xhtml">When installing the </span><code><span class="koboSpan" id="kobo.332.1" xmlns="http://www.w3.org/1999/xhtml">AutoMapper.Extensions.Microsoft.DependencyInjection</span></code><span class="koboSpan" id="kobo.333.1" xmlns="http://www.w3.org/1999/xhtml"> package you don’t have to load the </span><code><span class="koboSpan" id="kobo.334.1" xmlns="http://www.w3.org/1999/xhtml">AutoMapper</span></code><span class="koboSpan" id="kobo.335.1" xmlns="http://www.w3.org/1999/xhtml"> package.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.336.1" xmlns="http://www.w3.org/1999/xhtml">There is more to AutoMapper than what we cover here, but it has enough resources online, including the official documentation, to help you dig deeper into the tool. </span><span class="koboSpan" id="kobo.336.2" xmlns="http://www.w3.org/1999/xhtml">The goal of this project is to do basic object mapping.In the </span><em><span class="koboSpan" id="kobo.337.1" xmlns="http://www.w3.org/1999/xhtml">Web</span></em><span class="koboSpan" id="kobo.338.1" xmlns="http://www.w3.org/1999/xhtml"> project, we must create the following maps:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.339.1" xmlns="http://www.w3.org/1999/xhtml">Map </span><code><span class="koboSpan" id="kobo.340.1" xmlns="http://www.w3.org/1999/xhtml">Product</span></code><span class="koboSpan" id="kobo.341.1" xmlns="http://www.w3.org/1999/xhtml"> to </span><code><span class="koboSpan" id="kobo.342.1" xmlns="http://www.w3.org/1999/xhtml">ProductDetails</span></code></li>
<li><span class="koboSpan" id="kobo.343.1" xmlns="http://www.w3.org/1999/xhtml">Map </span><code><span class="koboSpan" id="kobo.344.1" xmlns="http://www.w3.org/1999/xhtml">NotEnoughStockException</span></code><span class="koboSpan" id="kobo.345.1" xmlns="http://www.w3.org/1999/xhtml"> to </span><code><span class="koboSpan" id="kobo.346.1" xmlns="http://www.w3.org/1999/xhtml">NotEnoughStock</span></code></li>
<li><span class="koboSpan" id="kobo.347.1" xmlns="http://www.w3.org/1999/xhtml">Map </span><code><span class="koboSpan" id="kobo.348.1" xmlns="http://www.w3.org/1999/xhtml">ProductNotFoundException</span></code><span class="koboSpan" id="kobo.349.1" xmlns="http://www.w3.org/1999/xhtml"> to </span><code><span class="koboSpan" id="kobo.350.1" xmlns="http://www.w3.org/1999/xhtml">ProductNotFound</span></code></li>
</ul>
<p><span class="koboSpan" id="kobo.351.1" xmlns="http://www.w3.org/1999/xhtml">To do that, we create the following </span><code><span class="koboSpan" id="kobo.352.1" xmlns="http://www.w3.org/1999/xhtml">WebProfile</span></code><span class="koboSpan" id="kobo.353.1" xmlns="http://www.w3.org/1999/xhtml"> class (in the </span><code><span class="koboSpan" id="kobo.354.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.355.1" xmlns="http://www.w3.org/1999/xhtml"> file, but could live anywhere):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.356.1" xmlns="http://www.w3.org/1999/xhtml">using AutoMapper;
public class WebProfile : Profile
{
    public WebProfile()
    {
        CreateMap&lt;Product, ProductDetails&gt;();
        CreateMap&lt;NotEnoughStockException, NotEnoughStock&gt;();
        CreateMap&lt;ProductNotFoundException, ProductNotFound&gt;();
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.357.1" xmlns="http://www.w3.org/1999/xhtml">A profile in AutoMapper is nothing more than a class where you create maps in the constructor. </span><span class="koboSpan" id="kobo.357.2" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.358.1" xmlns="http://www.w3.org/1999/xhtml">Profile</span></code><span class="koboSpan" id="kobo.359.1" xmlns="http://www.w3.org/1999/xhtml"> class adds the required methods for you to do that, such as the </span><code><span class="koboSpan" id="kobo.360.1" xmlns="http://www.w3.org/1999/xhtml">CreateMap</span></code><span class="koboSpan" id="kobo.361.1" xmlns="http://www.w3.org/1999/xhtml"> method. </span><span class="koboSpan" id="kobo.361.2" xmlns="http://www.w3.org/1999/xhtml">What does that do?Invoking the method </span><code><span class="koboSpan" id="kobo.362.1" xmlns="http://www.w3.org/1999/xhtml">CreateMap&lt;Product, ProductDetails&gt;()</span></code><span class="koboSpan" id="kobo.363.1" xmlns="http://www.w3.org/1999/xhtml"> tells AutoMapper to register a mapper that maps </span><code><span class="koboSpan" id="kobo.364.1" xmlns="http://www.w3.org/1999/xhtml">Product</span></code><span class="koboSpan" id="kobo.365.1" xmlns="http://www.w3.org/1999/xhtml"> to </span><code><span class="koboSpan" id="kobo.366.1" xmlns="http://www.w3.org/1999/xhtml">ProductDetails</span></code><span class="koboSpan" id="kobo.367.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.367.2" xmlns="http://www.w3.org/1999/xhtml">The other two </span><code><span class="koboSpan" id="kobo.368.1" xmlns="http://www.w3.org/1999/xhtml">CreateMap</span></code><span class="koboSpan" id="kobo.369.1" xmlns="http://www.w3.org/1999/xhtml"> calls are doing the same for the other two maps. </span><span class="koboSpan" id="kobo.369.2" xmlns="http://www.w3.org/1999/xhtml">That’s all we need for now because AutoMapper maps properties using conventions, and both our model and DTO classes have the same sets of properties with the same names.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.370.1" xmlns="http://www.w3.org/1999/xhtml">In the preceding examples, we defined some mappers in the </span><code><span class="koboSpan" id="kobo.371.1" xmlns="http://www.w3.org/1999/xhtml">Core</span></code><span class="koboSpan" id="kobo.372.1" xmlns="http://www.w3.org/1999/xhtml"> layer. </span><span class="koboSpan" id="kobo.372.2" xmlns="http://www.w3.org/1999/xhtml">In this example, we rely on a library, so it is even more important to consider the dependency flow. </span><span class="koboSpan" id="kobo.372.3" xmlns="http://www.w3.org/1999/xhtml">We are mapping objects only in the </span><code><span class="koboSpan" id="kobo.373.1" xmlns="http://www.w3.org/1999/xhtml">Web</span></code><span class="koboSpan" id="kobo.374.1" xmlns="http://www.w3.org/1999/xhtml"> layer, so there is no need to put the dependency on AutoMapper in the </span><code><span class="koboSpan" id="kobo.375.1" xmlns="http://www.w3.org/1999/xhtml">Core</span></code><span class="koboSpan" id="kobo.376.1" xmlns="http://www.w3.org/1999/xhtml"> layer. </span><span class="koboSpan" id="kobo.376.2" xmlns="http://www.w3.org/1999/xhtml">Remember that all layers depend directly or indirectly on </span><code><span class="koboSpan" id="kobo.377.1" xmlns="http://www.w3.org/1999/xhtml">Core</span></code><span class="koboSpan" id="kobo.378.1" xmlns="http://www.w3.org/1999/xhtml">, so having a dependency on AutoMapper in that layer means all layers would also depend on it.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.379.1" xmlns="http://www.w3.org/1999/xhtml">Therefore, in this example, we created the </span><code><span class="koboSpan" id="kobo.380.1" xmlns="http://www.w3.org/1999/xhtml">WebProfile</span></code><span class="koboSpan" id="kobo.381.1" xmlns="http://www.w3.org/1999/xhtml"> class in the </span><code><span class="koboSpan" id="kobo.382.1" xmlns="http://www.w3.org/1999/xhtml">Web</span></code><span class="koboSpan" id="kobo.383.1" xmlns="http://www.w3.org/1999/xhtml"> layer instead, limiting the dependency on AutoMapper to only that layer. </span><span class="koboSpan" id="kobo.383.2" xmlns="http://www.w3.org/1999/xhtml">Having only the </span><code><span class="koboSpan" id="kobo.384.1" xmlns="http://www.w3.org/1999/xhtml">Web</span></code><span class="koboSpan" id="kobo.385.1" xmlns="http://www.w3.org/1999/xhtml"> layer depend on AutoMapper allows all outer layers (if we were to add more) to control how they do object mapping, giving more independence to each layer. </span><span class="koboSpan" id="kobo.385.2" xmlns="http://www.w3.org/1999/xhtml">It is also a best practice to limit object mapping as much as possible.</span></p>
</blockquote>
<blockquote>
<p><span class="koboSpan" id="kobo.386.1" xmlns="http://www.w3.org/1999/xhtml">I’ve added a link to </span><em><span class="koboSpan" id="kobo.387.1" xmlns="http://www.w3.org/1999/xhtml">AutoMapper Usage Guidelines</span></em><span class="koboSpan" id="kobo.388.1" xmlns="http://www.w3.org/1999/xhtml"> in the </span><em><span class="koboSpan" id="kobo.389.1" xmlns="http://www.w3.org/1999/xhtml">Further reading</span></em><span class="koboSpan" id="kobo.390.1" xmlns="http://www.w3.org/1999/xhtml"> section at the end of the chapter.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.391.1" xmlns="http://www.w3.org/1999/xhtml">Now that we have one profile, we need to register it with the IoC container, but we don’t have to do this by hand; we can scan for profiles from the composition root by using one of the </span><code><span class="koboSpan" id="kobo.392.1" xmlns="http://www.w3.org/1999/xhtml">AddAutoMapper</span></code><span class="koboSpan" id="kobo.393.1" xmlns="http://www.w3.org/1999/xhtml"> extension methods to scan one or more assemblies:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.394.1" xmlns="http://www.w3.org/1999/xhtml">builder.Services.AddAutoMapper(typeof(WebProfile).Assembly);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.395.1" xmlns="http://www.w3.org/1999/xhtml">The preceding method accepts a </span><code><span class="koboSpan" id="kobo.396.1" xmlns="http://www.w3.org/1999/xhtml">params Assembly[] assemblies</span></code><span class="koboSpan" id="kobo.397.1" xmlns="http://www.w3.org/1999/xhtml"> argument, meaning we can pass multiple </span><code><span class="koboSpan" id="kobo.398.1" xmlns="http://www.w3.org/1999/xhtml">Assembly</span></code><span class="koboSpan" id="kobo.399.1" xmlns="http://www.w3.org/1999/xhtml"> instances to it.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.400.1" xmlns="http://www.w3.org/1999/xhtml">That </span><code><span class="koboSpan" id="kobo.401.1" xmlns="http://www.w3.org/1999/xhtml">AddAutoMapper</span></code><span class="koboSpan" id="kobo.402.1" xmlns="http://www.w3.org/1999/xhtml"> extension method comes from the </span><code><span class="koboSpan" id="kobo.403.1" xmlns="http://www.w3.org/1999/xhtml">AutoMapper.Extensions.Microsoft.DependencyInjection</span></code><span class="koboSpan" id="kobo.404.1" xmlns="http://www.w3.org/1999/xhtml"> package.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.405.1" xmlns="http://www.w3.org/1999/xhtml">Since we have only one profile in one assembly, we leverage that class to access the assembly by passing the </span><code><span class="koboSpan" id="kobo.406.1" xmlns="http://www.w3.org/1999/xhtml">typeof(WebProfile).Assembly</span></code><span class="koboSpan" id="kobo.407.1" xmlns="http://www.w3.org/1999/xhtml"> argument to the </span><code><span class="koboSpan" id="kobo.408.1" xmlns="http://www.w3.org/1999/xhtml">AddAutoMapper</span></code><span class="koboSpan" id="kobo.409.1" xmlns="http://www.w3.org/1999/xhtml"> method. </span><span class="koboSpan" id="kobo.409.2" xmlns="http://www.w3.org/1999/xhtml">From there, AutoMapper scans for profiles in that assembly and finds the </span><code><span class="koboSpan" id="kobo.410.1" xmlns="http://www.w3.org/1999/xhtml">WebProfile</span></code><span class="koboSpan" id="kobo.411.1" xmlns="http://www.w3.org/1999/xhtml"> class. </span><span class="koboSpan" id="kobo.411.2" xmlns="http://www.w3.org/1999/xhtml">If there were more than one, it would register all it finds.The beauty of scanning for types like this is that once you register AutoMapper with the IoC container, you can add profiles in any registered assemblies, and they get loaded automatically; there’s no need to do anything else afterward but to write useful code. </span><span class="koboSpan" id="kobo.411.3" xmlns="http://www.w3.org/1999/xhtml">Scanning assemblies also encourages composition by convention, making it easier to maintain in the long run. </span><span class="koboSpan" id="kobo.411.4" xmlns="http://www.w3.org/1999/xhtml">The downside of assembly scanning is that debugging can be hard when something is not registered because the registration process is less explicit.Now that we’ve created and registered the profiles with the IoC container, it is time to use AutoMapper. </span><span class="koboSpan" id="kobo.411.5" xmlns="http://www.w3.org/1999/xhtml">Let’s look at the three endpoints we created initially:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.412.1" xmlns="http://www.w3.org/1999/xhtml">app.MapGet("/products", async (
    IProductRepository productRepository, 
    IMapper mapper, 
    CancellationToken cancellationToken) =&gt;
{
    var products = await productRepository.AllAsync(cancellationToken);
    return products.Select(p =&gt; mapper.Map&lt;Product, ProductDetails&gt;(p));
});
app.MapPost("/products/{productId:int}/add-stocks", async (
    int productId, 
    AddStocksCommand command, 
    StockService stockService, 
    IMapper mapper, 
    CancellationToken cancellationToken) =&gt;
{
    try
    {
        var quantityInStock = await stockService.AddStockAsync(productId, command.Amount, cancellationToken);
        var stockLevel = new StockLevel(quantityInStock);
        return Results.Ok(stockLevel);
    }
    catch (ProductNotFoundException ex)
    {
        return Results.NotFound(mapper.Map&lt;ProductNotFound&gt;(ex));
    }
});
app.MapPost("/products/{productId:int}/remove-stocks", async (
    int productId, 
    RemoveStocksCommand command, 
    StockService stockService, 
    IMapper mapper, 
    CancellationToken cancellationToken) =&gt;
{
    try
    {
        var quantityInStock = await stockService.RemoveStockAsync(productId, command.Amount, cancellationToken);
        var stockLevel = new StockLevel(quantityInStock);
        return Results.Ok(stockLevel);
    }
    catch (NotEnoughStockException ex)
    {
        return Results.Conflict(mapper.Map&lt;NotEnoughStock&gt;(ex));
    }
    catch (ProductNotFoundException ex)
    {
        return Results.NotFound(mapper.Map&lt;ProductNotFound&gt;(ex));
    }
});</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.413.1" xmlns="http://www.w3.org/1999/xhtml">The preceding code shows how similar it is to use AutoMapper to the other options. </span><span class="koboSpan" id="kobo.413.2" xmlns="http://www.w3.org/1999/xhtml">We inject an </span><code><span class="koboSpan" id="kobo.414.1" xmlns="http://www.w3.org/1999/xhtml">IMapper</span></code><span class="koboSpan" id="kobo.415.1" xmlns="http://www.w3.org/1999/xhtml"> interface, then use it to map the entities. </span><span class="koboSpan" id="kobo.415.2" xmlns="http://www.w3.org/1999/xhtml">Instead of explicitly specifying both </span><code><span class="koboSpan" id="kobo.416.1" xmlns="http://www.w3.org/1999/xhtml">TSource</span></code><span class="koboSpan" id="kobo.417.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.418.1" xmlns="http://www.w3.org/1999/xhtml">TDestination</span></code><span class="koboSpan" id="kobo.419.1" xmlns="http://www.w3.org/1999/xhtml"> like in the previous example, when using AutoMapper, we must specify only the </span><code><span class="koboSpan" id="kobo.420.1" xmlns="http://www.w3.org/1999/xhtml">TDestination</span></code><span class="koboSpan" id="kobo.421.1" xmlns="http://www.w3.org/1999/xhtml"> generic parameter, reducing the code's complexity.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.422.1" xmlns="http://www.w3.org/1999/xhtml">Suppose you are using AutoMapper on an </span><code><span class="koboSpan" id="kobo.423.1" xmlns="http://www.w3.org/1999/xhtml">IQueryable</span></code><span class="koboSpan" id="kobo.424.1" xmlns="http://www.w3.org/1999/xhtml"> collection returned by EF Core. </span><span class="koboSpan" id="kobo.424.2" xmlns="http://www.w3.org/1999/xhtml">In that case, you should use the </span><code><span class="koboSpan" id="kobo.425.1" xmlns="http://www.w3.org/1999/xhtml">ProjectTo</span></code><span class="koboSpan" id="kobo.426.1" xmlns="http://www.w3.org/1999/xhtml"> method, which limits the number of fields that EF will query to those you need. </span><span class="koboSpan" id="kobo.426.2" xmlns="http://www.w3.org/1999/xhtml">In our case, that changes nothing because we need the whole entity.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.427.1" xmlns="http://www.w3.org/1999/xhtml">Here is an example that fetches all products from EF Core and projects them to </span><code><span class="koboSpan" id="kobo.428.1" xmlns="http://www.w3.org/1999/xhtml">ProductDto</span></code><span class="koboSpan" id="kobo.429.1" xmlns="http://www.w3.org/1999/xhtml"> instances:</span></p>
</blockquote>
</blockquote>
<pre><code><span class="koboSpan" id="kobo.430.1" xmlns="http://www.w3.org/1999/xhtml">public IEnumerable&lt;ProductDto&gt; GetAllProducts()
{
    return _mapper.ProjectTo&lt;ProductDto&gt;(_db.Products);
}</span></code></pre>
<blockquote>
<p><span class="koboSpan" id="kobo.431.1" xmlns="http://www.w3.org/1999/xhtml">Performance-wise, this is the recommended way to use AutoMapper with EF Core.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.432.1" xmlns="http://www.w3.org/1999/xhtml">One last yet significant detail is that we can assert whether our mapper configurations are valid when the application starts. </span><span class="koboSpan" id="kobo.432.2" xmlns="http://www.w3.org/1999/xhtml">This does not identify missing mappers but validates that the registered ones are configured correctly. </span><span class="koboSpan" id="kobo.432.3" xmlns="http://www.w3.org/1999/xhtml">The recommended way of doing this is in a unit test. </span><span class="koboSpan" id="kobo.432.4" xmlns="http://www.w3.org/1999/xhtml">To make this happen, I made the autogenerated </span><code><span class="koboSpan" id="kobo.433.1" xmlns="http://www.w3.org/1999/xhtml">Program</span></code><span class="koboSpan" id="kobo.434.1" xmlns="http://www.w3.org/1999/xhtml"> class public by adding the following line at the end:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.435.1" xmlns="http://www.w3.org/1999/xhtml">public partial class Program { }</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.436.1" xmlns="http://www.w3.org/1999/xhtml">Then I created a test project named </span><code><span class="koboSpan" id="kobo.437.1" xmlns="http://www.w3.org/1999/xhtml">Web.Tests</span></code><span class="koboSpan" id="kobo.438.1" xmlns="http://www.w3.org/1999/xhtml"> that contain the following code:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.439.1" xmlns="http://www.w3.org/1999/xhtml">namespace Web;
public class StartupTest
{
    [Fact]
    public async Task AutoMapper_configuration_is_valid()
    {
        // Arrange
        await using var application = new AutoMapperAppWebApplication();
        var mapper = application.Services.GetRequiredService&lt;IMapper&gt;();
        mapper.ConfigurationProvider.AssertConfigurationIsValid();
    }
}
internal class AutoMapperAppWebApplication : WebApplicationFactory&lt;Program&gt;{}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.440.1" xmlns="http://www.w3.org/1999/xhtml">In the preceding code, we validate that all the AutoMapper maps are valid. </span><span class="koboSpan" id="kobo.440.2" xmlns="http://www.w3.org/1999/xhtml">To make the test fail, you can uncomment the following line of the </span><code><span class="koboSpan" id="kobo.441.1" xmlns="http://www.w3.org/1999/xhtml">WebProfile</span></code><span class="koboSpan" id="kobo.442.1" xmlns="http://www.w3.org/1999/xhtml"> class:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.443.1" xmlns="http://www.w3.org/1999/xhtml">CreateMap&lt;NotEnoughStockException, Product&gt;();</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.444.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.445.1" xmlns="http://www.w3.org/1999/xhtml">AutoMapperAppWebApplication</span></code><span class="koboSpan" id="kobo.446.1" xmlns="http://www.w3.org/1999/xhtml"> class is there to centralize the initialization of the test cases when there is more than one.In the test project, I created a second test case ensuring the </span><code><span class="koboSpan" id="kobo.447.1" xmlns="http://www.w3.org/1999/xhtml">products</span></code><span class="koboSpan" id="kobo.448.1" xmlns="http://www.w3.org/1999/xhtml"> endpoint is reachable. </span><span class="koboSpan" id="kobo.448.2" xmlns="http://www.w3.org/1999/xhtml">For both tests to work together, we must change the database name to avoid seeding conflicts so each test runs on its own database. </span><span class="koboSpan" id="kobo.448.3" xmlns="http://www.w3.org/1999/xhtml">This has to do with how we seed the database in the </span><code><span class="koboSpan" id="kobo.449.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.450.1" xmlns="http://www.w3.org/1999/xhtml"> file, which is not something we usually do except for development or proofs of concept. </span><span class="koboSpan" id="kobo.450.2" xmlns="http://www.w3.org/1999/xhtml">Nonetheless, testing against multiple databases can come in handy to isolate tests.Here’s that second test case and updated </span><code><span class="koboSpan" id="kobo.451.1" xmlns="http://www.w3.org/1999/xhtml">AutoMapperAppWebApplication</span></code><span class="koboSpan" id="kobo.452.1" xmlns="http://www.w3.org/1999/xhtml"> class to give you an idea:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.453.1" xmlns="http://www.w3.org/1999/xhtml">public class StartupTest
{
    [Fact]
    public async Task The_products_endpoint_should_be_reachable()
    {
        await using var application = new AutoMapperAppWebApplication();
        using var client = application.CreateClient();
        using var response = await client.GetAsync("/products");
        response.EnsureSuccessStatusCode();
    }
    // Omitted AutoMapper_configuration_is_valid method
}
internal class AutoMapperAppWebApplication : WebApplicationFactory&lt;Program&gt;
{
    private readonly string _databaseName;
    public AutoMapperAppWebApplication([CallerMemberName]string? </span><span class="koboSpan" id="kobo.453.2" xmlns="http://www.w3.org/1999/xhtml">databaseName = default)
    {
        _databaseName = databaseName ?? </span><span class="koboSpan" id="kobo.453.3" xmlns="http://www.w3.org/1999/xhtml">nameof(AutoMapperAppWebApplication);
    }
    protected override IHost CreateHost(IHostBuilder builder)
    {
        builder.ConfigureServices(services =&gt;
        {
            services.AddScoped(sp =&gt;
            {
                return new DbContextOptionsBuilder&lt;ProductContext&gt;()
                    .UseInMemoryDatabase(_databaseName)
                    .UseApplicationServiceProvider(sp)
                    .Options;
            });
        });
        return base.CreateHost(builder);
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.454.1" xmlns="http://www.w3.org/1999/xhtml">Running the tests ensures that the mapping in our application works and that one of the endpoints is reachable. </span><span class="koboSpan" id="kobo.454.2" xmlns="http://www.w3.org/1999/xhtml">We could add more tests, but those two cover about 50% of our code.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.455.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.456.1" xmlns="http://www.w3.org/1999/xhtml">CallerMemberNameAttribute</span></code><span class="koboSpan" id="kobo.457.1" xmlns="http://www.w3.org/1999/xhtml"> used in the preceding code is part of the </span><code><span class="koboSpan" id="kobo.458.1" xmlns="http://www.w3.org/1999/xhtml">System.Runtime.CompilerServices</span></code><span class="koboSpan" id="kobo.459.1" xmlns="http://www.w3.org/1999/xhtml"> namespace and allows its decorated member to access the name of the method that called it. </span><span class="koboSpan" id="kobo.459.2" xmlns="http://www.w3.org/1999/xhtml">In this case, the </span><code><span class="koboSpan" id="kobo.460.1" xmlns="http://www.w3.org/1999/xhtml">databaseName</span></code><span class="koboSpan" id="kobo.461.1" xmlns="http://www.w3.org/1999/xhtml"> parameter receives the test method name.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.462.1" xmlns="http://www.w3.org/1999/xhtml">And this closes the AutoMapper project. </span><span class="koboSpan" id="kobo.462.2" xmlns="http://www.w3.org/1999/xhtml">At this point, you should begin to be familiar with object mapping. </span><span class="koboSpan" id="kobo.462.3" xmlns="http://www.w3.org/1999/xhtml">I’d recommend you evaluate whether AutoMapper is the right tool for the job whenever a project needs object mapping. </span><span class="koboSpan" id="kobo.462.4" xmlns="http://www.w3.org/1999/xhtml">You can always load another tool or implement your own mapping logic if AutoMapper does not suit your needs. </span><span class="koboSpan" id="kobo.462.5" xmlns="http://www.w3.org/1999/xhtml">If too much mapping is done at too many levels, maybe another application architecture pattern would be better, or some rethinking is in order.AutoMapper is convention-based and does a lot on its own without any configuration from us. </span><span class="koboSpan" id="kobo.462.6" xmlns="http://www.w3.org/1999/xhtml">It is also configuration-based, caching the conversions to improve performance. </span><span class="koboSpan" id="kobo.462.7" xmlns="http://www.w3.org/1999/xhtml">We can also create </span><strong><span class="koboSpan" id="kobo.463.1" xmlns="http://www.w3.org/1999/xhtml">type converters</span></strong><span class="koboSpan" id="kobo.464.1" xmlns="http://www.w3.org/1999/xhtml">, </span><strong><span class="koboSpan" id="kobo.465.1" xmlns="http://www.w3.org/1999/xhtml">value resolvers</span></strong><span class="koboSpan" id="kobo.466.1" xmlns="http://www.w3.org/1999/xhtml">, </span><strong><span class="koboSpan" id="kobo.467.1" xmlns="http://www.w3.org/1999/xhtml">value converters</span></strong><span class="koboSpan" id="kobo.468.1" xmlns="http://www.w3.org/1999/xhtml">, and more. </span><span class="koboSpan" id="kobo.468.2" xmlns="http://www.w3.org/1999/xhtml">AutoMapper keeps us away from writing that boring mapping code.Yet, AutoMapper is old, feature complete, and is almost unavoidable due to the number of projects that uses it. </span><span class="koboSpan" id="kobo.468.3" xmlns="http://www.w3.org/1999/xhtml">However, it is not the fastest, which is why we are exploring Mapperly next.</span></p>
</section>
<section class="level2" data-number="16.8" id="project-mapperly">
<h2 data-number="16.8"><span class="koboSpan" id="kobo.469.1" xmlns="http://www.w3.org/1999/xhtml">Project – Mapperly</span></h2>
<p><span class="koboSpan" id="kobo.470.1" xmlns="http://www.w3.org/1999/xhtml">Mapperly is a newer object mapper library that leverages source generation to make it lightning-fast. </span><span class="koboSpan" id="kobo.470.2" xmlns="http://www.w3.org/1999/xhtml">To get started, we must add a dependency on the </span><code><span class="koboSpan" id="kobo.471.1" xmlns="http://www.w3.org/1999/xhtml">Riok.Mapperly</span></code><span class="koboSpan" id="kobo.472.1" xmlns="http://www.w3.org/1999/xhtml"> NuGet package.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.473.1" xmlns="http://www.w3.org/1999/xhtml">Source generators were introduced with .NET 5, allowing developers to generate C# code during compilation.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.474.1" xmlns="http://www.w3.org/1999/xhtml">There are many ways to create object mappers with Mapperly and many options to adjust the mapping process. </span><span class="koboSpan" id="kobo.474.2" xmlns="http://www.w3.org/1999/xhtml">The following code sample is similar to the others but using Mapperly. </span><span class="koboSpan" id="kobo.474.3" xmlns="http://www.w3.org/1999/xhtml">We cover the following ways to use Mapperly:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.475.1" xmlns="http://www.w3.org/1999/xhtml">Injecting a mapper class.</span></li>
<li><span class="koboSpan" id="kobo.476.1" xmlns="http://www.w3.org/1999/xhtml">Using a static method.</span></li>
<li><span class="koboSpan" id="kobo.477.1" xmlns="http://www.w3.org/1999/xhtml">Using an extension method.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.478.1" xmlns="http://www.w3.org/1999/xhtml">Let’s start with the injected mapper. </span><span class="koboSpan" id="kobo.478.2" xmlns="http://www.w3.org/1999/xhtml">First, the class must be </span><code><span class="koboSpan" id="kobo.479.1" xmlns="http://www.w3.org/1999/xhtml">partial</span></code><span class="koboSpan" id="kobo.480.1" xmlns="http://www.w3.org/1999/xhtml"> for the source generator to extend it (that is how source generators work). </span><span class="koboSpan" id="kobo.480.2" xmlns="http://www.w3.org/1999/xhtml">Decorate the class with the </span><code><span class="koboSpan" id="kobo.481.1" xmlns="http://www.w3.org/1999/xhtml">[Mapper]</span></code><span class="koboSpan" id="kobo.482.1" xmlns="http://www.w3.org/1999/xhtml"> attribute (highlighted). </span><span class="koboSpan" id="kobo.482.2" xmlns="http://www.w3.org/1999/xhtml">Then, in that partial class, we must create one or more </span><code><span class="koboSpan" id="kobo.483.1" xmlns="http://www.w3.org/1999/xhtml">partial</span></code><span class="koboSpan" id="kobo.484.1" xmlns="http://www.w3.org/1999/xhtml"> methods that have the signature of the mappers we want to create (like the </span><code><span class="koboSpan" id="kobo.485.1" xmlns="http://www.w3.org/1999/xhtml">MapToProductDetails</span></code><span class="koboSpan" id="kobo.486.1" xmlns="http://www.w3.org/1999/xhtml"> method), like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.487.1" xmlns="http://www.w3.org/1999/xhtml">[Mapper]
public partial class ProductMapper
{
    public partial ProductDetails MapToProductDetails(Product product);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.488.1" xmlns="http://www.w3.org/1999/xhtml">Upon compilation, the code generator creates the following class (I formatted the code to make it easier to read):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.489.1" xmlns="http://www.w3.org/1999/xhtml">public partial class ProductMapper
{
    public partial ProductDetails MapToProductDetails(Product product)
    {
        var target = new ProductDetails(
            product.Id ?? </span><span class="koboSpan" id="kobo.489.2" xmlns="http://www.w3.org/1999/xhtml">throw new ArgumentNullException(nameof(product.Id)),
            product.Name, 
            product.QuantityInStock
        );
        return target;
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.490.1" xmlns="http://www.w3.org/1999/xhtml">Mapperly writes the boilerplate code for us in a generated </span><code><span class="koboSpan" id="kobo.491.1" xmlns="http://www.w3.org/1999/xhtml">partial</span></code><span class="koboSpan" id="kobo.492.1" xmlns="http://www.w3.org/1999/xhtml"> class, which is why it is so fast.To use the mapper, we must register it with the IoC Container and inject it into our endpoint. </span><span class="koboSpan" id="kobo.492.2" xmlns="http://www.w3.org/1999/xhtml">Let’s make it a singleton once again:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.493.1" xmlns="http://www.w3.org/1999/xhtml">builder.Services.AddSingleton&lt;ProductMapper&gt;();</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.494.1" xmlns="http://www.w3.org/1999/xhtml">Then, we can inject and use it like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.495.1" xmlns="http://www.w3.org/1999/xhtml">app.MapGet("/products", async (
    IProductRepository productRepository, 
    ProductMapper mapper, 
    CancellationToken cancellationToken) =&gt;
{
    var products = await productRepository.AllAsync(cancellationToken);
    return products.Select(p =&gt; mapper.MapToProductDetails(p));
});</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.496.1" xmlns="http://www.w3.org/1999/xhtml">The highlighted code in the preceding block shows we can use our mapper like any other class. </span><span class="koboSpan" id="kobo.496.2" xmlns="http://www.w3.org/1999/xhtml">The biggest drawback is that we may end up injecting many mappers into a single class or endpoint if we do not consider how we create them wisely.Moreover, we must register all of our mappers with the IoC container, which creates a lot of boilerplate code but makes the process explicit. </span><span class="koboSpan" id="kobo.496.3" xmlns="http://www.w3.org/1999/xhtml">On the other hand, we could scan the assembly for all classes decorated with the </span><code><span class="koboSpan" id="kobo.497.1" xmlns="http://www.w3.org/1999/xhtml">[Mapper]</span></code><span class="koboSpan" id="kobo.498.1" xmlns="http://www.w3.org/1999/xhtml"> attribute.If you want an abstraction layer like an interface for your mapper, you must design that yourself because Mapperly only generates the mappers. </span><span class="koboSpan" id="kobo.498.2" xmlns="http://www.w3.org/1999/xhtml">Here is an example:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.499.1" xmlns="http://www.w3.org/1999/xhtml">public interface IMapper
{
    NotEnoughStock MapToDto(NotEnoughStockException source);
    ProductNotFound MapToDto(ProductNotFoundException source);
    ProductDetails MapToProductDetails(Product product);
}
[Mapper]
public partial class Mapper : IMapper
{
    public partial NotEnoughStock MapToDto(NotEnoughStockException source);
    public partial ProductNotFound MapToDto(ProductNotFoundException source);
    public partial ProductDetails MapToProductDetails(Product product);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.500.1" xmlns="http://www.w3.org/1999/xhtml">The preceding code centralizes all the mapper methods under the same class and interface, allowing you to inject an interface similar to AutoMapper. </span><span class="koboSpan" id="kobo.500.2" xmlns="http://www.w3.org/1999/xhtml">In subsequent chapters, we explore ways to organize mappers and app code that does not involve creating a central mapper class.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.501.1" xmlns="http://www.w3.org/1999/xhtml">To inspect the generated code, you can add the </span><code><span class="koboSpan" id="kobo.502.1" xmlns="http://www.w3.org/1999/xhtml">EmitCompilerGeneratedFiles</span></code><span class="koboSpan" id="kobo.503.1" xmlns="http://www.w3.org/1999/xhtml"> property in a </span><code><span class="koboSpan" id="kobo.504.1" xmlns="http://www.w3.org/1999/xhtml">PropertyGroup</span></code><span class="koboSpan" id="kobo.505.1" xmlns="http://www.w3.org/1999/xhtml"> tag inside your project file and set its value to </span><code><span class="koboSpan" id="kobo.506.1" xmlns="http://www.w3.org/1999/xhtml">true</span></code><span class="koboSpan" id="kobo.507.1" xmlns="http://www.w3.org/1999/xhtml"> like this:</span></p>
</blockquote>
<pre><code><span class="koboSpan" id="kobo.508.1" xmlns="http://www.w3.org/1999/xhtml">&lt;PropertyGroup&gt;
    &lt;EmitCompilerGeneratedFiles&gt;true&lt;/EmitCompilerGeneratedFiles&gt;
&lt;/PropertyGroup&gt;</span></code></pre>
<blockquote>
<p><span class="koboSpan" id="kobo.509.1" xmlns="http://www.w3.org/1999/xhtml">Then the generated C# files will be available under the </span><code><span class="koboSpan" id="kobo.510.1" xmlns="http://www.w3.org/1999/xhtml">obj\Debug\net8.0\generated</span></code><span class="koboSpan" id="kobo.511.1" xmlns="http://www.w3.org/1999/xhtml"> directory. </span><span class="koboSpan" id="kobo.511.2" xmlns="http://www.w3.org/1999/xhtml">Change the </span><code><span class="koboSpan" id="kobo.512.1" xmlns="http://www.w3.org/1999/xhtml">net8.0</span></code><span class="koboSpan" id="kobo.513.1" xmlns="http://www.w3.org/1999/xhtml"> subdirectory to the SDK version and </span><code><span class="koboSpan" id="kobo.514.1" xmlns="http://www.w3.org/1999/xhtml">Debug</span></code><span class="koboSpan" id="kobo.515.1" xmlns="http://www.w3.org/1999/xhtml"> by your configuration.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.516.1" xmlns="http://www.w3.org/1999/xhtml">Next, we explore how to make a static mapper, which follows a very similar process, but we must make both the class and the method </span><code><span class="koboSpan" id="kobo.517.1" xmlns="http://www.w3.org/1999/xhtml">static</span></code><span class="koboSpan" id="kobo.518.1" xmlns="http://www.w3.org/1999/xhtml"> like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.519.1" xmlns="http://www.w3.org/1999/xhtml">[Mapper]
public static partial class ExceptionMapper
{
    public static partial ProductNotFound Map(ProductNotFoundException exception);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.520.1" xmlns="http://www.w3.org/1999/xhtml">Mapperly takes the preceding code and generates the following (formatted for improved readability):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.521.1" xmlns="http://www.w3.org/1999/xhtml">public static partial class ExceptionMapper
{
    public static partial ProductNotFound Map(ProductNotFoundException exception)
    {
        var target = new ProductNotFound(
            exception.ProductId, 
            exception.Message
        );
        return target;
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.522.1" xmlns="http://www.w3.org/1999/xhtml">Once again, the code generator writes the boilerplate code. </span><span class="koboSpan" id="kobo.522.2" xmlns="http://www.w3.org/1999/xhtml">The difference is that we don’t have to inject any dependency since it is a static method. </span><span class="koboSpan" id="kobo.522.3" xmlns="http://www.w3.org/1999/xhtml">We can use it this way (I only included the catch block, the rest of the code is unchanged):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.523.1" xmlns="http://www.w3.org/1999/xhtml">catch (ProductNotFoundException ex)
{
    return Results.NotFound(ExceptionMapper.Map(ex));
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.524.1" xmlns="http://www.w3.org/1999/xhtml">It is pretty straightforward but creates a strong bond between the generated class and its consumers. </span><span class="koboSpan" id="kobo.524.2" xmlns="http://www.w3.org/1999/xhtml">You can use those static methods if having a hard dependency on a static class is acceptable for your project.The last way to map objects we are exploring is very similar, but we create an extension method in the same class instead of just a static method. </span><span class="koboSpan" id="kobo.524.3" xmlns="http://www.w3.org/1999/xhtml">Here’s the new method:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.525.1" xmlns="http://www.w3.org/1999/xhtml">public static partial NotEnoughStock ToDto(this NotEnoughStockException exception);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.526.1" xmlns="http://www.w3.org/1999/xhtml">The generated code for that method looks like the following (formatted):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.527.1" xmlns="http://www.w3.org/1999/xhtml">public static partial NotEnoughStock ToDto(this NotEnoughStockException exception)
{
    var target = new NotEnoughStock(
        exception.AmountToRemove, 
        exception.QuantityInStock, 
        exception.Message
    );
    return target;
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.528.1" xmlns="http://www.w3.org/1999/xhtml">The only difference is the addition of the </span><code><span class="koboSpan" id="kobo.529.1" xmlns="http://www.w3.org/1999/xhtml">this</span></code><span class="koboSpan" id="kobo.530.1" xmlns="http://www.w3.org/1999/xhtml"> keyword, making a regular static method into an extension method that we can use like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.531.1" xmlns="http://www.w3.org/1999/xhtml">catch (NotEnoughStockException ex)
{
    return Results.Conflict(ex.ToDto());
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.532.1" xmlns="http://www.w3.org/1999/xhtml">An extension method is more elegant than a static method, yet it creates a bond similar to the static method. </span><span class="koboSpan" id="kobo.532.2" xmlns="http://www.w3.org/1999/xhtml">Once again, choosing how you want to proceed with your mapping is up to you.One noteworthy thing about Mapperly is that its analyzers yield information, warnings, or errors when the mapping code is incorrect or potentially incorrect. </span><span class="koboSpan" id="kobo.532.3" xmlns="http://www.w3.org/1999/xhtml">The severity of the messages is configurable. </span><span class="koboSpan" id="kobo.532.4" xmlns="http://www.w3.org/1999/xhtml">For example, if we add the following method in the </span><code><span class="koboSpan" id="kobo.533.1" xmlns="http://www.w3.org/1999/xhtml">ExceptionMapper</span></code><span class="koboSpan" id="kobo.534.1" xmlns="http://www.w3.org/1999/xhtml"> class, Mapperly yields the </span><code><span class="koboSpan" id="kobo.535.1" xmlns="http://www.w3.org/1999/xhtml">RMG013</span></code><span class="koboSpan" id="kobo.536.1" xmlns="http://www.w3.org/1999/xhtml"> error:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.537.1" xmlns="http://www.w3.org/1999/xhtml">public static partial Product NotEnoughStockExceptionToProduct(
    NotEnoughStockException exception
);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.538.1" xmlns="http://www.w3.org/1999/xhtml">Error message:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.539.1" xmlns="http://www.w3.org/1999/xhtml">RMG013 Core.Models.Product has no accessible constructor with mappable arguments</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.540.1" xmlns="http://www.w3.org/1999/xhtml">Moreover, the two exception mapper methods yield messages about properties that do not exist on the target class as information. </span><span class="koboSpan" id="kobo.540.2" xmlns="http://www.w3.org/1999/xhtml">Here’s an example of such a message:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.541.1" xmlns="http://www.w3.org/1999/xhtml">RMG020 The member TargetSite on the mapping source type Core.ProductNotFoundException is not mapped to any member on the mapping target type ProductNotFound</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.542.1" xmlns="http://www.w3.org/1999/xhtml">With those in place, we know when something is or can be wrong, which safeguards us from misconfigurations.Let’s wrap this chapter up.</span></p>
</section>
<section class="level2" data-number="16.9" id="summary-14">
<h2 data-number="16.9"><span class="koboSpan" id="kobo.543.1" xmlns="http://www.w3.org/1999/xhtml">Summary</span></h2>
<p><span class="koboSpan" id="kobo.544.1" xmlns="http://www.w3.org/1999/xhtml">Object mapping is an unavoidable reality in many cases. </span><span class="koboSpan" id="kobo.544.2" xmlns="http://www.w3.org/1999/xhtml">However, as we saw in this chapter, there are several ways of implementing object mapping, taking that responsibility away from the other components of our applications or simply coding it inline manually.At the same time, we took the opportunity to explore the Aggregate Services pattern, which gives us a way to centralize multiple dependencies into one, lowering the number of dependencies needed in other classes. </span><span class="koboSpan" id="kobo.544.3" xmlns="http://www.w3.org/1999/xhtml">That pattern can help with the too-many-dependencies code smell, which, as a rule of thumb, states that we should investigate objects with more than three dependencies for design flaws. </span><span class="koboSpan" id="kobo.544.4" xmlns="http://www.w3.org/1999/xhtml">When moving dependencies into an aggregate, ensure there is cohesion within the aggregate to avoid adding unnecessary complexity to your program and just moving the dependencies around.We also explored leveraging the Façade pattern to implement a mapping façade, which led to a more readable and elegant mapper.Afterward, we implemented a mapper service that mimicked the façade. </span><span class="koboSpan" id="kobo.544.5" xmlns="http://www.w3.org/1999/xhtml">Despite being less elegant in its usage, it was more flexible.We finally explored is AutoMapper and Mapperly, two open-source tools that do object mapping for us, offering us many options to configure the mapping of our objects. </span><span class="koboSpan" id="kobo.544.6" xmlns="http://www.w3.org/1999/xhtml">As we explored, just using the default convention of AutoMapper allowed us to eliminate all of our mapping code. </span><span class="koboSpan" id="kobo.544.7" xmlns="http://www.w3.org/1999/xhtml">On Mapperly’s side, we had to define the mapper contracts using partial classes and methods to let its code generator implement the mapping code for us. </span><span class="koboSpan" id="kobo.544.8" xmlns="http://www.w3.org/1999/xhtml">You can choose from many existing object mapper libraries, AutoMapper being one of the oldest, most famous, and hated at the same time, while Mapperly is one of the newest and fastest but yet in its infancy.Hopefully, as we are putting more and more pieces together, you are starting to see what I had in mind at the beginning of this book when stating this was an architectural journey.Now that we are done with object mapping, we explore the Mediator and CQRS patterns in the next chapter.</span></p>
</section>
<section class="level2" data-number="16.10" id="questions-14">
<h2 data-number="16.10"><span class="koboSpan" id="kobo.545.1" xmlns="http://www.w3.org/1999/xhtml">Questions</span></h2>
<p><span class="koboSpan" id="kobo.546.1" xmlns="http://www.w3.org/1999/xhtml">Let’s take a look at a few practice questions:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.547.1" xmlns="http://www.w3.org/1999/xhtml">Is it true that injecting an Aggregate Service instead of multiple services improves our system?</span></li>
<li><span class="koboSpan" id="kobo.548.1" xmlns="http://www.w3.org/1999/xhtml">Is it true that using mappers helps us extract responsibilities from consumers to mapper classes?</span></li>
<li><span class="koboSpan" id="kobo.549.1" xmlns="http://www.w3.org/1999/xhtml">Is it true that you should always use AutoMapper?</span></li>
<li><span class="koboSpan" id="kobo.550.1" xmlns="http://www.w3.org/1999/xhtml">When using AutoMapper, should you encapsulate your mapping code into profiles?</span></li>
<li><span class="koboSpan" id="kobo.551.1" xmlns="http://www.w3.org/1999/xhtml">How many dependencies should start to raise a flag telling you that you are injecting too many dependencies into a single class?</span></li>
</ol>
</section>
<section class="level2" data-number="16.11" id="further-reading-12">
<h2 data-number="16.11"><span class="koboSpan" id="kobo.552.1" xmlns="http://www.w3.org/1999/xhtml">Further reading</span></h2>
<p><span class="koboSpan" id="kobo.553.1" xmlns="http://www.w3.org/1999/xhtml">Here are some links to build upon what we learned in the chapter:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.554.1" xmlns="http://www.w3.org/1999/xhtml">If you want more information on object mapping, I wrote an article about that in 2017, titled </span><em><span class="koboSpan" id="kobo.555.1" xmlns="http://www.w3.org/1999/xhtml">Design Patterns: ASP.NET Core Web API, Services, and Repositories | Part 9: the NinjaMappingService and the Façade Pattern</span></em><span class="koboSpan" id="kobo.556.1" xmlns="http://www.w3.org/1999/xhtml">: </span><a href="https://adpg.link/hxYf"><span class="koboSpan" id="kobo.557.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/hxYf</span></a></li>
<li><span class="koboSpan" id="kobo.558.1" xmlns="http://www.w3.org/1999/xhtml">AutoMapper official website: </span><a href="https://adpg.link/5AUZ"><span class="koboSpan" id="kobo.559.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/5AUZ</span></a></li>
<li><em><span class="koboSpan" id="kobo.560.1" xmlns="http://www.w3.org/1999/xhtml">AutoMapper Usage Guidelines</span></em><span class="koboSpan" id="kobo.561.1" xmlns="http://www.w3.org/1999/xhtml"> is an excellent do/don’t list to help you do the right thing with AutoMapper, written by the library’s author: </span><a href="https://adpg.link/tTKg"><span class="koboSpan" id="kobo.562.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/tTKg</span></a></li>
<li><span class="koboSpan" id="kobo.563.1" xmlns="http://www.w3.org/1999/xhtml">Mapperly (GitHub): </span><a href="https://adpg.link/Dwcj"><span class="koboSpan" id="kobo.564.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/Dwcj</span></a></li>
</ul>
</section>
<section class="level2" data-number="16.12" id="answers-11">
<h2 data-number="16.12"><span class="koboSpan" id="kobo.565.1" xmlns="http://www.w3.org/1999/xhtml">Answers</span></h2>
<ol>
<li><span class="koboSpan" id="kobo.566.1" xmlns="http://www.w3.org/1999/xhtml">Yes, an Aggregate Service can improve a system, but not necessarily. </span><span class="koboSpan" id="kobo.566.2" xmlns="http://www.w3.org/1999/xhtml">Moving dependencies around does not fix design flaws; it just moves those flaws elsewhere.</span></li>
<li><span class="koboSpan" id="kobo.567.1" xmlns="http://www.w3.org/1999/xhtml">Yes, mappers help us follow the SRP. </span><span class="koboSpan" id="kobo.567.2" xmlns="http://www.w3.org/1999/xhtml">However, they are not always needed.</span></li>
<li><span class="koboSpan" id="kobo.568.1" xmlns="http://www.w3.org/1999/xhtml">No, it is not suitable for every scenario. </span><span class="koboSpan" id="kobo.568.2" xmlns="http://www.w3.org/1999/xhtml">For example, when the mapping logic becomes complex, consider not using AutoMapper. </span><span class="koboSpan" id="kobo.568.3" xmlns="http://www.w3.org/1999/xhtml">Too many mappers may also mean a flaw in the application design itself.</span></li>
<li><span class="koboSpan" id="kobo.569.1" xmlns="http://www.w3.org/1999/xhtml">Yes, use profiles to organize your mapping rules cohesively.</span></li>
<li><span class="koboSpan" id="kobo.570.1" xmlns="http://www.w3.org/1999/xhtml">Four or more dependencies should start to raise a flag. </span><span class="koboSpan" id="kobo.570.2" xmlns="http://www.w3.org/1999/xhtml">Once again, this is just a guideline; injecting four or more services into a class can be acceptable.</span></li>
</ol>
</section>
</section>
</body>
</html>
