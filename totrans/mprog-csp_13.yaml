- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying Cross-Cutting Concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As software projects evolve, they gain a certain structure, and if the team
    is disciplined, it will be somewhat consistent. When you get more team members,
    you might even document the structure. In addition to structure, you might also
    have ways of doing things and clear recipes of what needs to be done when creating
    different types of functionalities for the different parts of the stack. For global
    ownership, you might have these written down as well.
  prefs: []
  type: TYPE_NORMAL
- en: This is where cross-cutting concerns can come to the rescue. In this chapter,
    we will look at how to increase productivity for you as a developer by removing
    mundane tasks and improving consistency, and reducing risks. We will also look
    at how cross-cutting concerns can improve the maintainability of your software.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What are cross-cutting concerns?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging the ASP.NET pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization based on metadata or structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter13](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter13)),
    and it builds on top of the **Fundamentals** code that is found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)).
  prefs: []
  type: TYPE_NORMAL
- en: You will need Postman ([https://www.postman.com](https://www.postman.com)) for
    testing the APIs created in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What are cross-cutting concerns?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the lead-in to the chapter suggests, you might find yourself in your project
    with guidelines, formalized or not, that give you recipes for how to do things.
    For instance, to write a **representational state transfer** (**REST**) API that
    performs actions in your application, you might have a list of things defined
    that is there to help you remember what to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Check authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether the input is valid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether the action is allowed as per business rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add logging for the action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform the action by calling the domain logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translate the result from the domain to something digestible for REST consumption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember to wrap the call to the domain in **try {} catch {}** and return the
    correct error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each of these steps, there is always the risk that the developer will forget.
    This can pose a risk, cause security issues, data consistency, or other problems.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I’m a huge fan of automating anything that is repetitive. Computers
    are really good at doing repetitive tasks, so why not let the human in front focus
    on delivering the business value?
  prefs: []
  type: TYPE_NORMAL
- en: Cross-cutting concerns are basically those things that are applied once and
    henceforth continue to be there. Some cross-cutting concerns can be entirely automatic
    and need no extra intervention from the developer once applied, while others tend
    to be more configurable and context-based.
  prefs: []
  type: TYPE_NORMAL
- en: Logging is probably the most canonical example of a cross-cutting concern. If
    you, for instance, know what to add in a log statement for every call to a Web
    API controller in your ASP.NET application, you can quite easily do so by adding
    an action filter.
  prefs: []
  type: TYPE_NORMAL
- en: I tend to focus a lot on how we can boost the productivity of a team. With that
    in mind, you can do quite a bit of automation. To understand this better, we can
    use an example from ASP.NET Web APIs. Let’s say you’re building an application
    that has a frontend, and you need to provide an API for the frontend. Typically,
    your domain logic shouldn’t be in the API layer, as that is just a transport mechanism.
    An opportunity here is to automatically generate the API layer from the domain
    layer based on a convention. The convention could be derived from the namespace
    that could then automatically create the correct route. This would then remove
    an entire layer.
  prefs: []
  type: TYPE_NORMAL
- en: One of the possible benefits of applying cross-cutting concerns is that you
    end up writing less code in the implementations where you’d normally add the things
    it automates. This is also a good thing from a maintenance perspective. It makes
    it easier to maintain. For instance, if you want to change the behavior of your
    system rather than having to change it in multiple places, you’d have a single
    place to change it.
  prefs: []
  type: TYPE_NORMAL
- en: One of my favorite cross-cutting concerns is for Web APIs to have a consistent
    result and also not just rely on the HTTP status codes but rather consistently
    include all needed information to the consumer about the call.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the ASP.NET pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST APIs are based on the HTTP standard. The standard is a protocol standard
    and will not necessarily reflect in a good way what really happened when you performed
    an operation.
  prefs: []
  type: TYPE_NORMAL
- en: One way to do this would be to create a common result object that all Web API
    controller actions need to return. But that would then become one of these recipes
    that could be forgotten and leave the solution in an inconsistent state.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of having a common result object is undoubtedly desirable, but we should
    work towards returning it automatically for all Web API calls. However, there
    is a difference between performing an operation and getting data. Basically, in
    HTTP, that is what the different verbs are for, HTTP GET represents getting data,
    while verbs such as POST, PUT, or DELETE represent the operations you want to
    perform.
  prefs: []
  type: TYPE_NORMAL
- en: These types of operations are typically what you tend to perform as operations
    on a database in a data-driven application. You’ll often use the same model for
    all the operations, and you’re basically just modifying data.
  prefs: []
  type: TYPE_NORMAL
- en: I’m an advocate for the **Command Query Responsibility Segregation** (**CQRS**)
    principle, coined by Greg Young ([https://www.martinfowler.com/bliki/CQRS.html](https://www.martinfowler.com/bliki/CQRS.html)),
    which is a further formalization of Bertrand Meyers’ **Command Query Separation**
    (**CQS**) principle ([https://www.martinfowler.com/bliki/CommandQuerySeparation.html](https://www.martinfowler.com/bliki/CommandQuerySeparation.html)).
  prefs: []
  type: TYPE_NORMAL
- en: The CQRS principle challenges the common approach of treating everything as
    data in a **Create, Read, Update, and Delete** (**CRUD**) manner. It focuses on
    explicitly modeling the state change in a system and represents the intention
    of changing with a **command**, while retrieving data is represented as **queries**.
    Since CQRS is an evolution of CQS, it also implies that commands represent a changing
    state and do not return a value, while queries return a value but do not change
    any state.
  prefs: []
  type: TYPE_NORMAL
- en: We’re not going to dive any deeper into CQRS or CQS, but we want to utilize
    the concept of command and, with that, limit the surface area for what we want
    to support in the sample in this chapter. The sample here has nothing to do with
    CQRS, but being an advocate for it, I figured I’d slip it into the conversation,
    hoping it triggers some curiosity…haha.
  prefs: []
  type: TYPE_NORMAL
- en: Building consistent result objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s build a simple system that registers employees exposed as a REST API.
    The goal is to provide a consistent result object for all commands being performed.
    We define a command in this context to be an HTTP POST call to any Web API controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a folder called **Chapter13**. Change into this folder in
    your command line and create a new web-based project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take advantage of the **Fundamentals** project in the GitHub repository
    mentioned in the *Technical requirements* section. You should add a project reference
    to it for this chapter by doing the following in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will leverage the concept of an **action filter**, a building block provided
    by ASP.NET Core. In [*Chapter 3*](B19418_03.xhtml#_idTextAnchor041), *Demystifying
    through Existing Real-World Examples*, we touched on this building block for changing
    the default behavior related to validation—a good example of a cross-cutting concern.
  prefs: []
  type: TYPE_NORMAL
- en: In ASP.NET Core, you, as a developer, have 100% flexibility on the behavior
    of your Web API controllers. That means that you decide what to return to the
    client, and you also decide whether or not you really care about the validation
    result. As we did in [*Chapter 3*](B19418_03.xhtml#_idTextAnchor041), *Demystifying
    through Existing Real-World Examples*, we will be a bit more opinionated and not
    let the controller’s actions decide whether or not something is valid, but handle
    this in a cross-cutting manner. In addition to this, we want to wrap this up in
    a nice way for the consumer to get the result consistently.
  prefs: []
  type: TYPE_NORMAL
- en: Create a subfolder in **Chapter13** called **Commands**. This is where you’ll
    create the necessary infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by adding a consistent representation of a validation result. ASP.NET
    Core has the concept of **ModelError**; you could use this directly if you’d like.
    But **ModelError** represents both **Exception** and a validation error. Those
    are different concerns that I personally would like to separate and make clearer.
    Being in an invalid state is different from having an exceptional non-recoverable
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file in the **Commands** folder called **ValidationResult.cs**. You can
    make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code introduces a type called **ValidationResult**, which holds an error
    and the member the error is for. With the member clearly in the result, the consumer
    can map the error back to the object it sent. As a user interface, this is very
    useful as you can then easily show the error directly for the user input field
    that is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since ASP.NET Core has its **ModelError** and you’ve now introduced a type
    representing just the validation result, you would want something that converts
    to your type. Add a file called **ModelErrorExtensions.cs** to the **Commands**
    folder and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code introduces an extension method for the **ModelError** type and takes
    a specific member as a string to associate the error. By default, all JSON serialization
    in ASP.NET Core will be camel cased; the code, therefore, converts the member
    to camel case. It even supports deeply nested members by its navigational path
    represented with a dot for each level in the nested hierarchy. The **ToCamelCase()**
    method call comes from **StringExtensions** found in the **Fundamentals** project
    referenced previously.
  prefs: []
  type: TYPE_NORMAL
- en: CommandResult
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With a representation of validation, you can now create the common result type
    for all operations or commands. We call this **CommandResult**. It will encapsulate
    all the different aspects of an API call in a structured manner. To do this, add
    a file called **CommandResult.cs** to the **Commands** folder and make it look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The code introduces a **CommandResult** type that holds the concrete information
    related to validation results and whether there was an exception that might have
    occurred. In addition, it contains properties that allow you to easily conclude
    whether or not the result represents success. If the result is not a success,
    you can dive into whether or not it is related to authorization, validity, or
    an exception. It also introduces the **CorrelationId** property, which identifies
    the call that was performed and could be used for tracing back in logs or tracing
    systems to understand whether an exception occurred and why it happened.
  prefs: []
  type: TYPE_NORMAL
- en: With the formalized **CommandResult** in place, you’ll need something that will
    produce this. This is where the ASP.NET Core action filter mechanism comes in
    handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **CommandActionFilter.cs** to the **Commands** folder and
    make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code gives you a bare-bones action filter by implementing the **IAsyncActionFilter**
    interface. The action filter is only interested in HTTP POST methods, as discussed
    earlier, and the rest of the implementation will take place within that clause.
    If it is not an HTTP POST method, it just forwards the request to the next middleware
    using the **next()** method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start filling in the blanks. Inside the scope of the HTTP POST method
    clause, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The code handles whether **ModelState** is valid, meaning that all validators
    have run successfully and thus didn’t report anything invalid. This can mean one
    of two things:'
  prefs: []
  type: TYPE_NORMAL
- en: There is an exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s all OK, and the action was performed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within the **IsValid** clause, the code calls **next()**, which invokes the
    rest of the ASP.NET Core pipeline, ultimately calling the Web API controller action.
    The **result** object is of the **ActionExecutedContext** type, which holds information
    about the call to the action. On it, you’ll find **Exception** and **Result**.
    If there is an exception, the code unwinds all the messages recursively through
    **InnerException** of each exception and then resets the **Exception** property
    on the **result** object to **null** to avoid the default output of exceptions
    of ASP.NET Core from kicking in. If there are no exceptions, the code looks to
    capture the actual result if it is **ObjectResult** from the action.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Even though we said commands should only perform a state change and not return
    a result, there are cases where you need to return something to the client. This
    could be important information, such as the key of an object created, which could
    then be leveraged directly by the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing you will need is to create an instance of **CommandResult**
    and populate validation results and exceptions. Add the following code after the
    previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The code creates an instance of the **CommandResult** type and sets the properties
    on it. **CorrelationId** is generated as a new **Guid**, **ValidationResults**
    is derived from **ModelState** using the extension method you put in earlier for
    converting, and **ExceptionMessages** comes from the code you put in for unwinding
    the exceptions. Then it puts in **ExceptionStackTrace** if there is any or just
    **string.Empty** if not. Finally, it forwards the response from the controller
    action directly, if any.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though you’ve now encapsulated the result in something that is more readable
    and consistent for the consumer, it is still good practice to set the correct
    HTTP status code. Add the following code after the instantiation of **CommandResult**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code says that when we’re not authorized, it is an HTTP **401** status code,
    while if not valid, it is a **409** status code, and if there is an exception,
    it is **500**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For **CommandResult** to be the actual result you get as output, you’ll need
    to explicitly set the **Result** property on **ActionExecutedContext** if we were
    validly authorized, or directly on **ActionExecutingContext**, which is passed
    as the first parameter of the method of the action filter. Add the following code
    right after the previous block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code creates a new **ObjectResult** with **CommandResult** as content and
    sets it on either the **ActionExecutedContext** object or **ActionExecutingContext**.
    This will guarantee that you consistently get the same structure whether you’ve
    called the controller action or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a concrete sample that will make use of this new and improved
    pipeline. Add a file called **Employee.cs** in the root of the **Chapter13** project
    and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The code introduces a **record** type that represents an employee with only
    two properties: **FirstName** and **LastName**. It instructs that these properties
    are both required by leveraging the **[****Required]** attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the API to work you’ll need a controller. Add a file called **EmployeesController**
    in the root of the **Chapter13** project and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The code introduces a controller with an action for registering an employee.
    The **[FromBody]** attribute in front of the **employee** argument says that the
    content of **employee** is found in the HTTP request body. The action returns
    an integer and is hardcoded to return **1**. Keep in mind that this is more of
    an example of where you could return your key if needed. It would be perfectly
    fine not to return anything and make the method return **void**. With the **[Route]**
    attribute in front of the class, the route for the API will be **/api/employees**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the **Program.cs** file and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The code adds all controllers by convention and maps the routes of these. When
    adding controllers, the code adds **CommandActionFilter** as a filter to the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'That should be enough to take it for a spin. Run the project using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a similar output to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now test the API using Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Posting with Postman
  prefs: []
  type: TYPE_NORMAL
- en: Set the verb to be **POST**, and then use the URL from the output of your run
    and add **/api/employees** to the URL. Then select **JSON** in the **Body** tab,
    add an empty JSON document, and click **Send**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Use **POST** for a valid object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In Postman, you should then get a successful result back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – A successful posting in Postman
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see a response similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You now have a clear, consistent result object for all **POST** actions. ASP.NET
    Core is very extensible and flexible, and most of the parts can be extended to
    perform cross-cutting concerns; authorization is a good example.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization based on metadata or structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the approach for setting authorization for controllers in ASP.NET
    Core uses the **[Authorize]** attribute or the fluent interface when registering
    controllers or endpoints. For some scenarios, this can be very explicit, and in
    applications with a large number of controller endpoints, you might want to consider
    securing them in a cross-cutting manner.
  prefs: []
  type: TYPE_NORMAL
- en: If sections of your application are just meant to be used by users with a given
    role, this could be a great candidate for applying security policies for all of
    these based on namespace. Through structure, we get the implicit metadata that
    follows the types, and we can use that as a way to make decisions for us.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we need to put in a few things. First of all, we need to have a
    mechanism for authenticating users. For this sample, we will use hardcoded users
    to avoid the complexity of having to set up proper authentication with an identity
    provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need a file called **HardCodedAuthenticationOptions.cs** in the root
    of **Chapter13** and then add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The code introduces an option type that will be used by the custom hardcoded
    identity provider. It doesn’t have any options since the provider will be completely
    hardcoded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a file called **HardCodedAuthenticationHandler.cs** in the root of
    **Chapter13** and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The code implements **AuthenticationHandler<>** and takes the dependencies the
    base class needs into the constructor and passes these down. The **HandleAuthenticateAsync()**
    method will always return a successful authentication with a hardcoded principal
    with an identity on it. For the time being, the identity has the role of **User**.
  prefs: []
  type: TYPE_NORMAL
- en: You will need an authorization policy that is specific to this sample. It should
    say you have to be an **Admin** within namespaces starting with a specific string.
    In ASP.NET, this is done by implementing a requirement, which is basically the
    configuration object for the policy, and then a handler that is capable of handling
    the requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **AdminForNamespace.cs** in the root of **Chapter13** and
    make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The code holds the configuration in the form of a namespace string that will
    be used in the code that checks the policy. **IAuthorizationRequirement** is an
    empty marker interface with nothing to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need the handler. Add a file called **AdminForNamespaceHandler.cs**
    in the root of **Chapter13** and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This overrides the abstract **HandleRequirementAsync()** method from the base
    class. In the **context** argument, there is a property called **Resource**. For
    Web API controller actions, this is typical of type **HttpContext**. The code,
    therefore, checks whether it is **HttpContext** and then has the implementation
    of the policy within that clause. In **HttpContext**, you can get the endpoint
    information. In the endpoint, there is metadata associated with it, and for our
    purpose, we’re looking for the specific controller information. The **ControllerActionDescriptor**
    metadata contains the actual method that is supposed to be called on your controller.
    On this, the code gets **DeclaringType** and uses its namespace to see whether
    the namespace requirement matches. If the type has a namespace that starts with
    the requirement and the user does not have the **Admin** role, it fails the **context**,
    meaning that the user is not authorized. You can provide reasons and more details
    for failing, but for this sample, we’re just keeping it clean.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If the user is **Admin**, it will succeed. It will also succeed if the namespace
    does not start with the requirement.
  prefs: []
  type: TYPE_NORMAL
- en: With the policy handler in place, you need it to be hooked up so that it actually
    gets called. The default approach in ASP.NET Core is to add policies during the
    setup of the authorization. This approach, however, takes away the cross-cutting
    opportunity as you would then need to be explicit regarding the controllers whose
    policies should be applied. Instead, you’ll implement **IAuthorizationPolicyProvider**
    and set up the policies in this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **CrossCuttingPoliciesProvider.cs** in the root of **Chapter13**.
    It should be made to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The code sets up **AuthorizationPolicy** that includes the **AdminForNamespace**
    policy. **IAuthorizationPolicyProvider** requires you to implement methods for
    getting policies for different scenarios; all of these return the same policy.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Returning the same policy for **GetDefaultPolicyAsync()**, **GetFallbackPolicyAsync()**,
    and **GetPolicyAsync()** might not be the desired behavior. This is done for the
    simplicity of the sample.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will be tying the authorization back into **CommandActionFilter**
    you created earlier, and to do that, we have to communicate the authorization
    results that are returned. Unfortunately, this information is not easily accessible
    in the following stages of the ASP.NET Core pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **HttpContextExtensions.cs** in the root of **Chapter13**
    and make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The code uses the **Items** dictionary on **HttpContext** and provides both
    a set method and a get method for working with **PolicyAuthorizationResult**.
    **Items** is a key/value store that can hold anything as part of the current Web
    request. This is perfect for when you want to make something available to other
    stages.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core provides specific middleware for dealing with the result of authorization.
    Add a file called **CrossCuttingAuthorizationMiddlewareResultHandler.cs** and
    make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The code implements the **IAuthorizationMiddlewareResultHandler** interface,
    which holds a **HandleAsync()** method. This method gets called after all policies
    have been handled but before the action filters. The implementation of **HandleAsync()**
    puts **authorizationResult** on **HttpContext** for the availability of later
    stages. It then uses the default implementation of the interface called **AuthorizationMiddlewareResultHandler**
    to invoke the rest of the pipeline, only now simulating a success. The reason
    it simulates success is to trick the handler to perform the action filters. We
    want **CommandActionFilter** to add support for authorization and return the **CommandResult**
    structure consistently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **CommandActionFilter.cs** file in the **Commands** folder within
    **Chapter13** and make the top of the method look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The change you’re performing is making use of the authorization result. If the
    authorization result has not succeeded, you don’t want to call the rest of the
    pipeline, but you want to capture it in the command result.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same file and method, change how you create **CommandResult** to include
    the **IsAuthorized** property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The code now has **CommandResult** that includes **IsAuthorized**. Since the
    rest of the action filter takes this into consideration, you should also be getting
    the correct HTTP status codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Program.cs** file in the root of the **Chapter13** project and change
    it to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The changes introduce both authentication and authorization and hooks **Services**
    into the different handlers and providers you have created. For the authentication,
    it sets up the hardcoded handler as the default authentication schema and configures
    the scheme to use the handler type you created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the application and performing the same operation as before using Postman
    should yield the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – An unauthorized result in Postman
  prefs: []
  type: TYPE_NORMAL
- en: 'The output should have **isAuthorized** set to **false**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try to change the role of the user to **Admin**. Open the **HardCodedAuthenticationHandler.cs**
    file in the root of **Chapter13** and change the role from **User** to **Admin**.
    To do this, find the line that says the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the application now and performing the same operation again should
    give you a result where you’re authorized:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_13_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – An authorized result in Postman
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON output should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This should give you an idea of what is possible. With ASP.NET Core, you can
    go deep into replacing default behavior and customizing it to your needs, which
    is fabulous when you’re looking to apply some cross-cutting concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipes are pieces of code that clearly specify, in a linear manner, what they
    do, are a great tool for new developers. The developer can really see what’s going
    on, reason about the code, and find errors. As the developer, team, and project
    mature, the recipes start to feel like unnecessary chores or at least become very
    repetitive. Not only is this something that potentially affects productivity,
    but these kinds of repetitive tasks are easy to get wrong. Getting it wrong could
    pose multiple risks to the system:'
  prefs: []
  type: TYPE_NORMAL
- en: Security risks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The risk of persisting invalid data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The risk of allowing operations that are not allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The risk of losing operational insight due to a lack of logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tradeoff between imperative procedural code that a developer can quickly
    reason about and the need for a consistent system is one you should consider.
    In smaller projects, it might not be worth the cognitive load of being “different”
    in applying things cross-cuttingly, while in larger systems, it might be completely
    crucial. There could be a correlation with the size of the team as well—the bigger
    the team, the more things you want to automate and standardize.
  prefs: []
  type: TYPE_NORMAL
- en: Applying cross-cutting concerns can be extremely powerful, but it can feel like
    a black box if the developers don’t know about it and can’t understand why something
    is happening. My advice on that is to make sure all developers are educated on
    how cross-cutting concerns are handled and ensure that it is possible to follow
    code paths. Rather than documenting the recipes, my suggestion would be to document
    how they are automated and how developers can, for instance, debug things.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll dive into how you can go deeper by leveraging aspect-oriented
    programming.
  prefs: []
  type: TYPE_NORMAL
