- en: Chapter 7. Sharing with MvvmCross
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. 与 MvvmCross 共享
- en: 'In the previous chapter, we covered the basic approaches to reusing code across
    projects and platforms. In this chapter, we will take the next step and look at
    how the use of design patterns and frameworks can increase the amount of code
    that can be reused. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了跨项目和平台重用代码的基本方法。在本章中，我们将进一步探讨如何使用设计模式和框架来增加可重用代码的数量。我们将涵盖以下主题：
- en: An introduction to MvvmCross
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MvvmCross 简介
- en: The MVVM design pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM 设计模式
- en: Core concepts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心概念
- en: Views, ViewModels, and commands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图、ViewModel 和命令
- en: Data binding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据绑定
- en: Navigation (ViewModel to ViewModel)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航（ViewModel 到 ViewModel）
- en: The project organization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目组织
- en: The startup process
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动过程
- en: Creating `NationalParks.MvvmCross`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `NationalParks.MvvmCross`
- en: It's more than a little ambitious to try to cover MvvmCross along with a working
    example in a single chapter. Our approach will be to introduce the core concepts
    at a high level and then dive in and create the national parks sample app using
    MvvmCross. This will give you a basic understanding of how to use the framework
    and the value associated with its use. With that in mind, let's get started.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个章节中尝试涵盖 MvvmCross 以及一个工作示例，这无疑有些雄心勃勃。我们的方法将是首先从高层次介绍核心概念，然后深入其中，使用 MvvmCross
    创建国家公园示例应用。这将帮助你基本了解如何使用该框架及其使用价值。考虑到这一点，让我们开始吧。
- en: Introducing MvvmCross
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 MvvmCross
- en: MvvmCross is an open source framework that was created by Stuart Lodge. It is
    based on the **Model-View-ViewModel** (**MVVM**) design pattern and is designed
    to enhance code reuse across numerous platforms, including Xamarin.Android, Xamarin.iOS,
    Windows Phone, Windows Store, WPF, and Mac OS X. The MvvmCross project is hosted
    on GitHub and can be accessed at [https://github.com/MvvmCross/MvvmCross](https://github.com/MvvmCross/MvvmCross).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: MvvmCross 是由 Stuart Lodge 创建的开源框架。它基于 **模型-视图-ViewModel** （**MVVM**）设计模式，旨在增强跨多个平台（包括
    Xamarin.Android、Xamarin.iOS、Windows Phone、Windows Store、WPF 和 Mac OS X）的代码重用。MvvmCross
    项目托管在 GitHub 上，可以通过 [https://github.com/MvvmCross/MvvmCross](https://github.com/MvvmCross/MvvmCross)
    访问。
- en: The MVVM pattern
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVVM 模式
- en: 'MVVM is a variation of the Model-View-Controller pattern. It separates logic
    traditionally placed in a **View** object into two distinct objects, one called
    **View** and the other called **ViewModel**. The View is responsible for providing
    the user interface and the ViewModel is responsible for the presentation logic.
    The presentation logic includes transforming data from the Model into a form that
    is suitable for the user interface to work with and mapping user interaction with
    the View into requests sent back to the Model. The following diagram depicts how
    the various objects in MVVM communicate:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 是模型-视图-控制器模式的变体。它将传统上放置在 **视图** 对象中的逻辑分离成两个不同的对象，一个称为 **视图**，另一个称为 **ViewModel**。视图负责提供用户界面，而
    ViewModel 负责表示逻辑。表示逻辑包括将数据从模型转换为用户界面可以处理的形式，以及将用户与视图的交互映射回发送回模型的请求。以下图表描述了 MVVM
    中各种对象之间的通信方式：
- en: '![The MVVM pattern](img/0838OT_07_03.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![MVVM 模式](img/0838OT_07_03.jpg)'
- en: 'While MVVM presents a more complex implementation model, there are significant
    benefits of it, which are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 MVVM 提供了一个更复杂的实现模型，但它具有显著的优点，如下所述：
- en: ViewModels and their interactions with Models can generally be tested using
    frameworks (such as NUnit) that are much easier than applications that combine
    the user interface and presentation layers
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ViewModels 及其与 Models 的交互通常可以使用框架（如 NUnit）进行测试，这些框架比结合用户界面和表示层的应用程序要容易得多。
- en: ViewModels can generally be reused across different user interface technologies
    and platforms
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ViewModels 通常可以在不同的用户界面技术和平台上重用。
- en: These factors make the MVVM approach both flexible and powerful.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些因素使得 MVVM 方法既灵活又强大。
- en: Views
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: Views in an MvvmCross app are implemented using platform-specific constructs.
    For iOS apps, Views are generally implemented as ViewControllers and XIB files.
    MvvmCross provides a set of base classes, such as `MvxViewContoller`, that iOS
    ViewControllers inherit from. Storyboards can also be used in conjunction with
    a custom presenter to create Views; we will briefly discuss this option in the
    section titled *Implementing the iOS user interface* later in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在MvvmCross应用程序中，视图使用平台特定的结构实现。对于iOS应用程序，视图通常实现为ViewControllers和XIB文件。MvvmCross提供了一组基类，例如`MvxViewController`，iOS
    ViewControllers从中继承。也可以与自定义演示者结合使用Storyboard来创建视图；我们将在本章后面的标题为*实现iOS用户界面*的部分简要讨论此选项。
- en: For Android apps, Views are generally implemented as `MvxActivity` or `MvxFragment`
    along with their associated layout files.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android应用程序，视图通常实现为`MvxActivity`或`MvxFragment`，以及它们相关的布局文件。
- en: ViewModels
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ViewModel
- en: ViewModels are classes that provide data and presentation logic to views in
    an app. Data is exposed to a View as properties on a ViewModel, and logic that
    can be invoked from a View is exposed as commands. ViewModels inherit from the
    `MvxViewModel` base class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel是提供数据表示逻辑的类，用于应用程序中的视图。数据作为ViewModel上的属性暴露给View，可以从View中调用的逻辑作为命令暴露。ViewModel继承自`MvxViewModel`基类。
- en: Commands
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令
- en: Commands are used in ViewModels to expose logic that can be invoked from the
    View in response to user interactions. The command architecture is based on the
    `ICommand` interface used in a number of Microsoft frameworks such as **Windows**
    **Presentation Foundation** (**WPF**) and Silverlight. MvvmCross provides `IMvxCommand`,
    which is an extension of `ICommand`, along with an implementation named `MvxCommand`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 命令在ViewModel中使用，以暴露可以从View中调用的逻辑，以响应用户交互。命令架构基于在许多Microsoft框架中使用的`ICommand`接口，例如**Windows**
    **演示基础**（**WPF**）和Silverlight。MvvmCross提供了`IMvxCommand`，它是`ICommand`的扩展，以及一个名为`MvxCommand`的实现。
- en: 'The commands are generally defined as properties on a ViewModel. For example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 命令通常定义为ViewModel上的属性。例如：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each command has an action method defined, which implements the logic to be
    invoked:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令都有一个定义了动作方法的实现，该方法实现了要调用的逻辑：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The commands must be initialized and the corresponding action method should
    be assigned:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 必须初始化命令，并将相应的动作方法分配：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Data binding
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据绑定
- en: 'Data binding facilitates communication between the View and the ViewModel by
    establishing a two-way link that allows data to be exchanged. The data binding
    capabilities provided by MvvmCross are based on capabilities found in a number
    of Microsoft XAML-based UI frameworks such as WPF and Silverlight. The basic idea
    is that you would like to bind a property in a UI control, such as the **Text**
    property of an **EditText** control in an Android app to a property of a data
    object such as the **Description** property of **NationalPark**. The following
    diagram depicts this scenario:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定通过建立允许数据交换的双向链接，促进了View和ViewModel之间的通信。MvvmCross提供的数据绑定功能基于在许多Microsoft基于XAML的UI框架中找到的功能，如WPF和Silverlight。基本思想是您希望将UI控件中的属性绑定，例如Android应用程序中**EditText**控制的**Text**属性绑定到数据对象的属性，如**NationalPark**的**Description**属性。以下图表描述了此场景：
- en: '![Data binding](img/0838OT_07_06.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![数据绑定](img/0838OT_07_06.jpg)'
- en: The binding modes
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定模式
- en: 'There are four different binding modes that can be used for data binding:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用四种不同的绑定模式进行数据绑定：
- en: '**OneWay binding**: This mode tells the data binding framework to transfer
    values from the ViewModel to the View and transfer any updates to properties on
    the ViewModel to their bound View property.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单向绑定**：此模式指示数据绑定框架将值从ViewModel传输到View，并将ViewModel上属性的任何更新传输到其绑定的View属性。'
- en: '**OneWayToSource binding**: This mode tells the data binding framework to transfer
    values from the View to the ViewModel and transfer updates to View properties
    to their bound ViewModel property.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单向源绑定**：此模式指示数据绑定框架将值从View传输到ViewModel，并将View属性的更新传输到其绑定的ViewModel属性。'
- en: '**TwoWay binding**: This mode tells the data binding framework to transfer
    values in both directions between the ViewModel and View, and updates on either
    object will cause the other to be updated. This binding mode is useful when values
    are being edited.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向绑定**：此模式指示数据绑定框架在ViewModel和View之间双向传输值，并且任一对象的更新都将导致另一个对象更新。当值正在编辑时，此绑定模式非常有用。'
- en: '**OneTime binding**: This mode tells the data binding framework to transfer
    values from ViewModel to View when the binding is established; in this mode, updates
    to ViewModel properties are not monitored by the View.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一次性绑定**：此模式告诉数据绑定框架在绑定建立时从 ViewModel 转移值到 View；在此模式下，ViewModel 属性的更新不会被 View
    监控。'
- en: The INotifyPropertyChanged interface
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`INotifyPropertyChanged` 接口'
- en: The `INotifyPropertyChanged` interface is an integral part of making data binding
    work effectively; it acts as a contract between the source object and the target
    object. As the name implies, it defines a contract that allows the source object
    to notify the target object when data has changed, thus allowing the target to
    take any necessary actions such as refreshing its display.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`INotifyPropertyChanged` 接口是使数据绑定有效运行的重要组成部分；它充当源对象和目标对象之间的契约。正如其名称所暗示的，它定义了一个契约，允许源对象在数据发生变化时通知目标对象，从而允许目标对象采取任何必要的行动，例如刷新其显示。'
- en: 'The interface consists of a single event—the `PropertyChanged` event—that the
    target object can subscribe to and that is triggered by the source if a property
    changes. The following sample demonstrates how to implement `INotifyPropertyChanged`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口由一个单一的事件——`PropertyChanged` 事件组成，目标对象可以订阅该事件，并且当源对象中的属性发生变化时，该事件会被触发。以下示例演示了如何实现
    `INotifyPropertyChanged`：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Binding specifications
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定规范
- en: 'Bindings can be specified in a couple of ways. For Android apps, bindings can
    be specified in layout files. The following example demonstrates how to bind the
    `Text` property of a `TextView` instance to the `Description` property in a `NationalPark`
    instance:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定可以通过几种方式指定。对于 Android 应用，绑定可以在布局文件中指定。以下示例演示了如何将 `TextView` 实例的 `Text` 属性绑定到
    `NationalPark` 实例的 `Description` 属性：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For iOS, binding must be accomplished using the binding API. `CreateBinding()`
    is a method than can be found on `MvxViewController`. The following example demonstrates
    how to bind the `Description` property to a `UILabel` instance:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 iOS，绑定必须使用绑定 API 完成。`CreateBinding()` 是可以在 `MvxViewController` 上找到的方法。以下示例演示了如何将
    `Description` 属性绑定到一个 `UILabel` 实例：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Navigating between ViewModels
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航到 ViewModel 之间
- en: 'Navigating between various screens within an app is an important capability.
    Within a MvvmCross app, this is implemented at the ViewModel level so that navigation
    logic can be reused. MvvmCross supports navigation between ViewModels through
    use of the `ShowViewModel<T>()` method inherited from `MvxNavigatingObject`, which
    is the base class for `MvxViewModel`. The following example demonstrates how to
    navigate to `DetailViewModel`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用内导航到各种屏幕是一个重要的功能。在 MvvmCross 应用中，这一功能是在 ViewModel 层实现的，以便导航逻辑可以被重用。MvvmCross
    通过使用从 `MvxNavigatingObject` 继承的 `ShowViewModel<T>()` 方法来支持 ViewModel 之间的导航，`MvxNavigatingObject`
    是 `MvxViewModel` 的基类。以下示例演示了如何导航到 `DetailViewModel`：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Passing parameters
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递参数
- en: 'In many situations, there is a need to pass information to the destination
    ViewModel. MvvmCross provides a number of ways to accomplish this. The primary
    method is to create a class that contains simple public properties and passes
    an instance of the class into `ShowViewModel<T>()`. The following example demonstrates
    how to define and use a `parameters` class during navigation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，需要将信息传递到目标 ViewModel。MvvmCross 提供了多种实现这一目标的方法。主要方法是通过创建一个包含简单公共属性的类，并将该类的实例传递给
    `ShowViewModel<T>()`。以下示例演示了如何在导航过程中定义和使用 `parameters` 类：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To receive and use parameters, the destination ViewModel implements an `Init()`
    method that accepts an instance of the `parameters` class:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接收和使用参数，目标 ViewModel 实现了一个 `Init()` 方法，该方法接受 `parameters` 类的实例：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Solution/project organization
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案/项目组织
- en: 'MvvmCross solutions are organized in a way that is similar to how we organized
    the PCL solution in [Chapter 6](ch06.html "Chapter 6. The Sharing Game"), *The
    Sharing Game.* Each MvvmCross solution will have a single core PCL project that
    houses the reusable code and a series of platform-specific projects that contain
    the various apps. The following diagram depicts the general structure:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: MvvmCross 解决方案的组织方式与我们如何在 [第 6 章](ch06.html "第 6 章。共享游戏") 中组织 PCL 解决方案的方式相似，即
    *共享游戏*。每个 MvvmCross 解决方案将有一个单独的核心 PCL 项目，其中包含可重用的代码，以及一系列包含各种应用的特定平台项目。以下图展示了总体结构：
- en: '![Solution/project organization](img/0838OT_07_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![解决方案/项目组织](img/0838OT_07_05.jpg)'
- en: The startup process
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动过程
- en: MvvmCross apps generally follow a standard startup sequence that is initiated
    by platform-specific code within each app. There are several classes that collaborate
    to accomplish the startup; some of these classes reside in the core project and
    some of them reside in the platform-specific projects. The following sections
    describe the responsibilities of each of the classes involved.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: MvvmCross 应用通常遵循一个标准的启动序列，该序列由每个应用中特定平台的代码启动。有几个类协同完成启动；其中一些类位于核心项目中，而另一些则位于特定平台的项目中。以下各节描述了每个参与类的职责。
- en: App.cs
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: App.cs
- en: 'The core project has an `App` class that inherits from `MvxApplication`. The
    `App` class contains an override to the `Initialize()` method so that at a minimum,
    it can register the first ViewModel that should be presented when the app starts:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 核心项目包含一个继承自 `MvxApplication` 的 `App` 类。`App` 类包含对 `Initialize()` 方法的重写，以便至少可以注册在应用启动时应展示的第一个
    ViewModel：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Setup.cs
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Setup.cs
- en: 'Android and iOS projects have a `Setup` class that is responsible for creating
    the `App` object from the core project during the startup. This is accomplished
    by overriding the `CreateApp()` method:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Android 和 iOS 项目都有一个 `Setup` 类，负责在启动期间从核心项目中创建 `App` 对象。这是通过重写 `CreateApp()`
    方法来实现的：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For Android apps, `Setup` inherits from `MvxAndroidSetup`. For iOS apps, `Setup`
    inherits from `MvxTouchSetup`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Android 应用，`Setup` 继承自 `MvxAndroidSetup`。对于 iOS 应用，`Setup` 继承自 `MvxTouchSetup`。
- en: The Android startup
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Android 启动
- en: 'Android apps are kicked off using a special `Activity` splash screen that calls
    the `Setup` class and initiates the MvvmCross startup process. This is all done
    automatically for you; all you need to do is include the splash screen definition
    and make sure it is marked as the launch activity. The definition is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Android 应用使用一个特殊的 `Activity` 启动屏幕启动，该屏幕调用 `Setup` 类并启动 MvvmCross 启动过程。所有这些都会自动为你完成；你所需要做的只是包含启动屏幕定义，并确保它被标记为启动活动。定义如下：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The iOS startup
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: iOS 启动
- en: 'The iOS app startup is slightly less automated and is initiated from within
    the `FinishedLaunching()` method of `AppDelegate`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 应用启动稍微自动化程度较低，并从 `AppDelegate` 的 `FinishedLaunching()` 方法中启动：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating NationalParks.MvvmCross
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 NationalParks.MvvmCross
- en: Now that we have basic knowledge of the MvvmCross framework, let's put that
    knowledge to work and convert the `NationalParks` app to leverage the capabilities
    we just learned.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 MvvmCross 框架有了基本了解，让我们将所学知识付诸实践，将 `NationalParks` 应用转换为利用我们刚刚学到的功能。
- en: Creating the MvvmCross core project
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 MvvmCross 核心项目
- en: We will start by creating the core project. This project will contain all the
    code that will be shared between the iOS and Android app primarily in the form
    of ViewModels. The core project will be built as a Portable Class Library.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建核心项目。该项目将包含在 iOS 和 Android 应用之间共享的所有代码，主要是以 ViewModel 的形式。核心项目将作为可移植类库构建。
- en: 'To create `NationalParks.Core`, perform the following steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `NationalParks.Core`，请执行以下步骤：
- en: From the main menu, navigate to **File** | **New Solution**.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单导航到 **文件** | **新建解决方案**。
- en: From the **New Solution** dialog box, navigate to **C#** | **Portable Library**,
    enter `NationalParks.Core` for the project **Name** field, enter `NationalParks.MvvmCross`
    for the **Solution** field, and click on **OK**.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **新建解决方案** 对话框中，导航到 **C#** | **可移植库**，在项目 **名称** 字段中输入 `NationalParks.Core`，在
    **解决方案** 字段中输入 `NationalParks.MvvmCross`，然后点击 **确定**。
- en: Add the MvvmCross starter package to the project from NuGet. Select the `NationalParks.Core`
    project and navigate to **Project** | **Add Packages** from the main menu. Enter
    `MvvmCross starter` in the search field.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 NuGet 将 MvvmCross 启动包添加到项目中。选择 `NationalParks.Core` 项目，从主菜单导航到 **项目** | **添加包**。在搜索字段中输入
    `MvvmCross starter`。
- en: Select the **MvvmCross – Hot Tuna Starter Pack** entry and click on **Add Package**.![Creating
    the MvvmCross core project](img/0838OT_07_01.jpg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **MvvmCross – Hot Tuna Starter Pack** 条目，然后点击 **添加包**。![创建 MvvmCross 核心项目](img/0838OT_07_01.jpg)
- en: 'A number of things were added to `NationalParks.Core` as a result of adding
    the package, and they are as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于添加了包，`NationalParks.Core` 中添加了一些内容，具体如下：
- en: A `packages.config` file, which contains a list of libraries (`dlls`) associated
    with the MvvmCross starter kit package. These entries are links to actual libraries
    in the `Packages` folder of the overall solution.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含与 MvvmCross 启动包相关联的库（`dlls`）列表的 `packages.config` 文件。这些条目是到整体解决方案 `Packages`
    文件夹中实际库的链接。
- en: A `ViewModels` folder with a sample ViewModel named `FirstViewModel`.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含名为`FirstViewModel`的示例ViewModel的`ViewModels`文件夹。
- en: An `App` class in `App.cs`, which contains an `Initialize()` method that starts
    the MvvmCross app by calling `RegisterAppStart()` to start `FirstViewModel`. We
    will eventually be changing this to start the `MasterViewModel` class, which will
    be associated with a View that lists national parks.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.cs`中的`App`类，其中包含一个`Initialize()`方法，通过调用`RegisterAppStart()`来启动`FirstViewModel`。我们最终将将其更改为启动与列出国家公园的视图关联的`MasterViewModel`类。'
- en: Creating the MvvmCross Android app
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建MvvmCross Android应用
- en: The next step is to create an Android app project in the same solution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在同一解决方案中创建Android应用项目。
- en: 'To create `NationalParks.Droid`, complete the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`NationalParks.Droid`，请完成以下步骤：
- en: Select the `NationalParks.MvvmCross` solution, right-click on it, and navigate
    to **Add** | **New Project**.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`NationalParks.MvvmCross`解决方案，右键单击它，然后导航到**添加** | **新建项目**。
- en: From the **New Project** dialog box, navigate to **C#** | **Android** | **Android
    Application**, enter `NationalParks.Droid` for the **Name** field, and click on
    **OK**.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**新项目**对话框中，导航到**C#** | **Android** | **Android Application**，在**名称**字段中输入`NationalParks.Droid`，然后点击**确定**。
- en: Add the MvvmCross starter kit package to the new project by selecting `NationalParks.Droid`
    and navigating to **Project** | **Add Packages** from the main menu.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择`NationalParks.Droid`并从主菜单导航到**项目** | **添加包**，将MvvmCross启动套件包添加到新项目中。
- en: 'A number of things were added to `NationalParks.Droid` as a result of adding
    the package, which are as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于添加了包，`NationalParks.Droid`中添加了一些内容，如下所示：
- en: '`packages.config`: This file contains a list of libraries (`dlls`) associated
    with the MvvmCross starter kit package. These entries are links to an actual library
    in the `Packages` folder of the overall solution, which contains the actual downloaded
    libraries.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packages.config`：此文件包含与MvvmCross启动套件包关联的库列表（`dlls`）。这些条目是到整体解决方案`Packages`文件夹中实际库的链接，其中包含实际下载的库。'
- en: '`FirstView` : This class is present in the `Views` folder, which corresponds
    to `FirstViewModel`, which was created in `NationalParks.Core`.'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirstView`：此类位于`Views`文件夹中，对应于在`NationalParks.Core`中创建的`FirstViewModel`。'
- en: '`FirstView`: This layout is present in `Resources\layout`, which is used by
    the `FirstView` activity. This is a traditional Android layout file with the exception
    that it contains binding declarations in the `EditView` and `TextView` elements.'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirstView`：此布局位于`Resources\layout`中，由`FirstView`活动使用。这是一个传统的Android布局文件，除了它包含在`EditView`和`TextView`元素中的绑定声明。'
- en: '`Setup`: This file inherits from `MvxAndroidSetup`. This class is responsible
    for creating an instance of the `App` class from the core project, which in turn
    displays the first ViewModel via a call to `RegisterAppStart()`.'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Setup`：此文件继承自`MvxAndroidSetup`。此类负责从核心项目创建`App`类的实例，然后通过调用`RegisterAppStart()`显示第一个ViewModel。'
- en: '`SplashScreen`: This class inherits from `MvxSplashScreenActivity`. The `SplashScreen`
    class is marked as the main launcher activity and thus initializes the `MvvmCross`
    app with a call to `Setup.Initialize()`.'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SplashScreen`：此类继承自`MvxSplashScreenActivity`。`SplashScreen`类被标记为主要启动活动，因此通过调用`Setup.Initialize()`初始化`MvvmCross`应用。'
- en: Add a reference to `NationalParks.Core` by selecting the `References` folder,
    right-click on it, select **Edit References**, select the **Projects** tab, check
    `NationalParks.Core`, and click on **OK**.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择`References`文件夹，右键单击它，选择**编辑引用**，选择**项目**选项卡，勾选`NationalParks.Core`，然后点击**确定**，为`NationalParks.Core`添加引用。
- en: Remove `MainActivity.cs` as it is no longer needed and will create a build error.
    This is because it is marked as the main launch and so is the new `SplashScreen`
    class. Also, remove the corresponding `Resources\layout\main.axml` layout file.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`MainActivity.cs`，因为它不再需要，并且将创建一个构建错误。这是因为它被标记为主要启动类，新的`SplashScreen`类也是如此。同时，删除相应的`Resources\layout\main.axml`布局文件。
- en: Run the app. The app will present `FirstViewModel`, which is linked to the corresponding
    `FirstView` instance with an `EditView` class, and `TextView` presents the same
    **Hello MvvmCross** text. As you edit the text in the `EditView` class, the `TextView`
    class is automatically updated by means of data binding. The following screenshot
    depicts what you should see:![Creating the MvvmCross Android app](img/0838OT_07_08.jpg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用。应用将展示 `FirstViewModel`，它与相应的 `FirstView` 实例通过 `EditView` 类链接，而 `TextView`
    展示相同的 **Hello MvvmCross** 文本。当你编辑 `EditView` 类中的文本时，`TextView` 类将通过数据绑定自动更新。以下截图展示了你应该看到的内容：![创建
    MvvmCross Android 应用](img/0838OT_07_08.jpg)
- en: Reusing NationalParks.PortableData and NationalParks.IO
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重用 NationalParks.PortableData 和 NationalParks.IO
- en: Before we start creating the Views and ViewModels for our app, we first need
    to bring in some code from our previous efforts that can be used to maintain parks.
    For this, we will simply reuse the `NationalParksData` singleton and the `FileHandler`
    classes that were created previously.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建应用中的视图和视图模型之前，我们首先需要引入之前工作中的一些代码，这些代码可以用来维护公园。为此，我们将简单地重用之前创建的 `NationalParksData`
    单例和 `FileHandler` 类。
- en: 'To reuse the `NationalParksData` singleton and `FileHandler` classes, complete
    the following steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要重用 `NationalParksData` 单例和 `FileHandler` 类，请完成以下步骤：
- en: Copy `NationalParks.PortableData` and `NationalParks.IO` from the solution created
    in [Chapter 6](ch06.html "Chapter 6. The Sharing Game"), *The Sharing Game*, to
    the `NationalParks.MvvmCross` solution folder.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `NationalParks.PortableData` 和 `NationalParks.IO` 从 [第 6 章](ch06.html "第 6
    章。共享游戏") 中创建的解决方案复制到 `NationalParks.MvvmCross` 解决方案文件夹中。
- en: Add a reference to `NationalParks.PortableData` in the `NationalParks.Droid`
    project.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NationalParks.Droid` 项目中添加对 `NationalParks.PortableData` 的引用。
- en: Create a folder named `NationalParks.IO` in the `NationalParks.Droid` project
    and add a link to `FileHandler.cs` from the `NationalParks.IO` project. Recall
    that the `FileHandler` class cannot be contained in the Portable Class Library
    because it uses file IO APIs that cannot be references from a Portable Class Library.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NationalParks.Droid` 项目中创建一个名为 `NationalParks.IO` 的文件夹，并将 `FileHandler.cs`
    文件从 `NationalParks.IO` 项目中添加链接。回想一下，`FileHandler` 类不能包含在可移植类库中，因为它使用了无法从可移植类库引用的文件
    IO API。
- en: Compile the project. The project should compile cleanly now.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译项目。现在项目应该可以干净地编译。
- en: Implementing the INotifyPropertyChanged interface
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现 INotifyPropertyChanged 接口
- en: We will be using data binding to bind UI controls to the `NationalPark` object
    and thus, we need to implement the `INotifyPropertyChanged` interface. This ensures
    that changes made to properties of a park are reported to the appropriate UI controls.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用数据绑定将 UI 控件绑定到 `NationalPark` 对象，因此我们需要实现 `INotifyPropertyChanged` 接口。这确保了对公园属性所做的更改被报告给适当的
    UI 控件。
- en: 'To implement `INotifyPropertyChanged`, complete the following steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 `INotifyPropertyChanged`，请完成以下步骤：
- en: Open `NationalPark.cs` in the `NationalParks.PortableData` project.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NationalParks.PortableData` 项目中打开 `NationalPark.cs` 文件。
- en: Specify that the `NationalPark` class implements `INotifyPropertyChanged` interface.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定 `NationalPark` 类实现 `INotifyPropertyChanged` 接口。
- en: 'Select the `INotifyPropertyChanged` interface, right-click on it, navigate
    to **Refactor** | **Implement interface**, and press *Enter*. Enter the following
    code snippet:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `INotifyPropertyChanged` 接口，右键单击它，导航到 **重构** | **实现接口**，然后按 *Enter*。输入以下代码片段：
- en: '[PRE13]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add an `OnPropertyChanged()` method that can be called from each property setter
    method:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个属性设置器方法中添加一个可调用的 `OnPropertyChanged()` 方法：
- en: '[PRE14]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Update each property definition to call the setter in the same way as it is
    depicted for the `Name` property:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新每个属性定义，以调用设置器的方式与 `Name` 属性所示相同：
- en: '[PRE15]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Compile the project. The project should compile cleanly. We are now ready to
    use the `NationalParksData` singleton in our new project, and it supports data
    binding.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译项目。现在项目应该可以干净地编译。我们现在可以使用 `NationalParksData` 单例在我们的新项目中，并且它支持数据绑定。
- en: Implementing the Android user interface
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现安卓用户界面
- en: 'Now, we are ready to create the Views and ViewModels required for our app.
    The app we are creating will follow the same flow that was used in previous chapters:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已准备好创建应用所需的视图和视图模型。我们正在创建的应用将遵循之前章节中使用的相同流程：
- en: A master list view to view national parks
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于查看国家公园的主列表视图
- en: A detail view to view details of a specific park
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于查看特定公园详细信息的详细视图
- en: An edit view to edit a new or previously existing park
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于编辑新或现有公园的编辑视图
- en: 'The process for creating views and ViewModels in an Android app generally consists
    of three different steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android应用程序中创建视图和ViewModel的过程通常包括三个不同的步骤：
- en: Create a ViewModel in the core project with the data and event handlers (commands)
    required to support the View.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在核心项目中创建一个ViewModel，其中包含支持视图所需的数据和事件处理程序（命令）。
- en: Create an Android layout with visual elements and data binding specifications.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含视觉元素和数据绑定规范的Android布局。
- en: Create an Android activity, which corresponds to the ViewModel and displays
    the layout.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Android活动，它对应于ViewModel并显示布局。
- en: In our case, this process will be slightly different because we will reuse some
    of our previous work, specifically, the layout files and the menu definitions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，这个过程将略有不同，因为我们将重用我们的一些先前工作，特别是布局文件和菜单定义。
- en: 'To reuse layout files and menu definitions, perform the following steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要重用布局文件和菜单定义，请执行以下步骤：
- en: Copy `Master.axml`, `Detail.axml`, and `Edit.axml` from the `Resources\layout`
    folder of the solution created in [Chapter 5](ch05.html "Chapter 5. Developing
    Your First Android App with Xamarin.Android"), *Developing Your First Android
    App with Xamarin.Android*, to the `Resources\layout` folder in the `NationalParks.Droid`
    project, and add them to the project by selecting the layout folder and navigating
    to **Add** | **Add Files**.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Master.axml`、`Detail.axml`和`Edit.axml`从[第5章](ch05.html "第5章. 使用Xamarin.Android开发您的第一个Android应用程序")中创建的解决方案的`Resources\layout`文件夹复制到`NationalParks.Droid`项目的`Resources\layout`文件夹中，并通过选择布局文件夹并导航到**添加**
    | **添加文件**将其添加到项目中。
- en: Copy `MasterMenu.xml`, `DetailMenu.xml`, and `EditMenu.xml` from the `Resources\menu`
    folder of the solution created in [Chapter 5](ch05.html "Chapter 5. Developing
    Your First Android App with Xamarin.Android"), *Developing Your First Android
    App with Xamarin.Android*, to the `Resources\menu` folder in the `NationalParks.Droid`
    project, and add them to the project by selecting the `menu` folder and navigating
    to **Add** | **Add Files**.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MasterMenu.xml`、`DetailMenu.xml`和`EditMenu.xml`从[第5章](ch05.html "第5章. 使用Xamarin.Android开发您的第一个Android应用程序")中创建的解决方案的`Resources\menu`文件夹复制到`NationalParks.Droid`项目的`Resources\menu`文件夹中，并通过选择`menu`文件夹并导航到**添加**
    | **添加文件**将其添加到项目中。
- en: Implementing the master list view
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现主列表视图
- en: We are now ready to implement the first of our View/ViewModel combinations,
    which is the master list view.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始实现我们的第一个视图/ViewModel组合，即主列表视图。
- en: Creating MasterViewModel
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建MasterViewModel
- en: The first step is to create a ViewModel and add a property that will provide
    data to the list view that displays national parks along with some initialization
    code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个ViewModel并添加一个将提供数据给显示国家公园的列表视图的属性，以及一些初始化代码。
- en: 'To create `MasterViewModel`, complete the following steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`MasterViewModel`，请完成以下步骤：
- en: Select the `ViewModels` folder in `NationalParks.Core`, right-click on it, and
    navigate to **Add** | **New File**.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NationalParks.Core`中的`ViewModels`文件夹上右键单击，并导航到**添加** | **新建文件**。
- en: In the **New File** dialog box, navigate to **General** | **Empty Class**, enter
    `MasterViewModel` for the **Name** field, and click on **New**.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新建文件**对话框中，导航到**常规** | **空类**，在**名称**字段中输入`MasterViewModel`，然后点击**新建**。
- en: 'Modify the class definition so that `MasterViewModel` inherits from `MvxViewModel`;
    you will also need to add a few `using` directives:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改类定义，使`MasterViewModel`继承自`MvxViewModel`；您还需要添加几个`using`指令：
- en: '[PRE16]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add a property that is a list of `NationalPark` elements to `MasterViewModel`.
    This property will later be data-bound to a list view:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MasterViewModel`中添加一个属性，该属性是一个`NationalPark`元素的列表。这个属性将稍后绑定到列表视图：
- en: '[PRE17]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Override the `Start()` method on `MasterViewModel` to load the `_parks` collection
    with data from the `NationalParksData` singleton. You will need to add a `using`
    directive for the `NationalParks.PortableData` namespace again:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MasterViewModel`上重写`Start()`方法，以从`NationalParksData`单例加载数据到`_parks`集合。您需要再次添加`NationalParks.PortableData`命名空间的`using`指令：
- en: '[PRE18]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We now need to modify the app startup sequence so that `MasterViewModel` is
    the first ViewModel that''s started. Open `App.cs` in `NationalParks.Core` and
    change the call to `RegisterAppStart()` to reference `MasterViewModel`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要修改应用程序启动顺序，以便`MasterViewModel`是第一个启动的ViewModel。在`NationalParks.Core`中打开`App.cs`，将`RegisterAppStart()`的调用更改为引用`MasterViewModel`：
- en: '[PRE19]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Updating the Master.axml layout
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新Master.axml布局
- en: Update `Master.axml` so that it can leverage the data binding capabilities provided
    by MvvmCross.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`Master.axml`，以便利用MvvmCross提供的数据绑定功能。
- en: 'To update `Master.axml`, complete the following steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新 `Master.axml`，请完成以下步骤：
- en: 'Open `Master.axml` and add a namespace definition to the top of the XML to
    include the `NationalParks.Droid` namespace:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Master.axml` 并在 XML 的顶部添加一个命名空间定义，以包含 `NationalParks.Droid` 命名空间：
- en: This namespace definition is required in order to allow Android to resolve the
    MvvmCross-specific elements that will be specified.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命名空间定义是必需的，以便允许 Android 解析将要指定的 MvvmCross 特定元素。
- en: 'Change the `ListView` element to a `Mvx.MvxListView` element:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ListView` 元素更改为 `Mvx.MvxListView` 元素：
- en: '[PRE20]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add a data binding specification to the `MvxListView` element, binding the
    `ItemsSource` property of the list view to the `Parks` property of `MasterViewModel`,
    as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `MvxListView` 元素添加数据绑定规范，将列表视图的 `ItemsSource` 属性绑定到 `MasterViewModel` 的 `Parks`
    属性，如下所示：
- en: '[PRE21]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add a list item template attribute to the element definition. This layout controls
    the content of each item that will be displayed in the list view:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向元素定义添加一个列表项模板属性。此布局控制列表视图中将显示的每个项的内容：
- en: '[PRE22]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create the `NationalParkItem` layout and provide `TextView` elements to display
    both the name and description of a park, as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `NationalParkItem` 布局，并提供 `TextView` 元素以显示公园的名称和描述，如下所示：
- en: '[PRE23]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add data binding specifications to each of the TextView elements:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据绑定规范添加到每个 TextView 元素中：
- en: '[PRE24]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Note that in this case, the context for data binding is an instance of an item
    in the collection that was bound to `MvxListView`, for this example, an instance
    of `NationalPark`.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，数据绑定的上下文是绑定到 `MvxListView` 的集合中的一项的实例，在这个例子中，是一个 `NationalPark` 的实例。
- en: Creating the MasterView activity
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 MasterView 活动
- en: Next, create `MasterView`, which is an `MvxActivity` instance that corresponds
    with `MasterViewModel`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建 `MasterView`，它是一个与 `MasterViewModel` 对应的 `MvxActivity` 实例。
- en: 'To create `MasterView`, complete the following steps:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `MasterView`，请完成以下步骤：
- en: Select the `ViewModels` folder in `NationalParks.Core`, right-click on it, navigate
    to **Add** | **New File**.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NationalParks.Core` 中的 `ViewModels` 文件夹中，右键单击它，导航到 **添加** | **新建文件**。
- en: In the **New File** dialog, navigate to **Android** | **Activity**, enter `MasterView`
    in the **Name** field, and select **New**.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **新建文件** 对话框中，导航到 **Android** | **Activity**，在 **名称** 字段中输入 `MasterView`，并选择
    **新建**。
- en: 'Modify the class specification so that it inherits from `MvxActivity`; you
    will also need to add a few `using` directives as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改类规范，使其继承自 `MvxActivity`；您还需要添加一些 `using` 指令，如下所示：
- en: '[PRE25]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Open `Setup.cs` and add code to initialize the file handler and path for the
    `NationalParksData` singleton to the `CreateApp()` method, as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Setup.cs` 并向 `CreateApp()` 方法添加代码以初始化 `NationalParksData` 单例的文件处理程序和路径，如下所示：
- en: '[PRE26]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Compile and run the app; you will need to copy the `NationalParks.json` file
    to the device or emulator using the Android Device Monitor. All the parks in `NationalParks.json`
    should be displayed.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行应用；您需要使用 Android 设备监控器将 `NationalParks.json` 文件复制到设备或模拟器。`NationalParks.json`
    中的所有公园都应显示。
- en: Implementing the detail view
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现详细视图
- en: Now that we have the master list view displaying national parks, we can focus
    on creating the detail view. We will follow the same steps for the detail view
    as the ones we just completed for the master view.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了显示国家公园的主列表视图，我们可以专注于创建详细视图。我们将对详细视图执行与刚刚完成的主视图相同的步骤。
- en: Creating DetailViewModel
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 DetailViewModel
- en: 'We start creating `DetailViewModel` by using the following steps:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下步骤开始创建 `DetailViewModel`：
- en: Following the same procedure as the one that was used to create `MasterViewModel`,
    create a new ViewModel named `DetailViewModel` in the `ViewModel` folder of `NationalParks.Core`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照创建 `MasterViewModel` 所使用的相同程序，在 `NationalParks.Core` 的 `ViewModel` 文件夹中创建一个新的名为
    `DetailViewModel` 的 ViewModel。
- en: 'Add a `NationalPark` property to support data binding for the view controls,
    as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `NationalPark` 属性以支持视图控件的数据绑定，如下所示：
- en: '[PRE27]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a `Parameters` class that can be used to pass a park ID for the park
    that should be displayed. It''s convenient to create this class within the class
    definition of the ViewModel that the parameters are for:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Parameters` 类，可以用来传递应显示的公园 ID。在参数的类定义中创建此类很方便：
- en: '[PRE28]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implement an `Init()` method that will accept an instance of the `Parameters`
    class and get the corresponding national park from `NationalParkData`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `Init()` 方法，该方法将接受 `Parameters` 类的实例并从 `NationalParkData` 获取相应的国家公园：
- en: '[PRE29]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Updating the Detail.axml layout
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新 Detail.axml 布局
- en: Next, we will update the layout file. The main changes that need to be made
    are to add data binding specifications to the layout file.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新布局文件。需要做的主要更改是向布局文件中添加数据绑定规范。
- en: 'To update the `Detail.axml` layout, perform the following steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新`Detail.axml`布局，执行以下步骤：
- en: 'Open `Detail.axml` and add the project namespace to the XML file:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Detail.axml`并将项目命名空间添加到XML文件中：
- en: 'Add data binding specifications to each of the `TextView` elements that correspond
    to a national park property, as demonstrated for the park name:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据绑定规范添加到每个对应于国家公园属性的`TextView`元素中，如下所示公园名称的示例：
- en: '[PRE30]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Creating the DetailView activity
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建`DetailView`活动
- en: Now, create the `MvxActivity` instance that will work with `DetailViewModel`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个将与`DetailViewModel`一起工作的`MvxActivity`实例。
- en: 'To create `DetailView`, perform the following steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`DetailView`，执行以下步骤：
- en: Following the same procedure as the one that was used to create `MasterView`,
    create a new view named `DetailView` in the `Views` folder of `NationalParks.Droid`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照之前创建`MasterView`时使用的相同程序，在`NationalParks.Droid`的`Views`文件夹中创建一个名为`DetailView`的新视图。
- en: Implement the `OnCreateOptionsMenu()` and `OnOptionsItemSelected()` methods
    so that our menus will be accessible. Copy the implementation of these methods
    from the solution created in [Chapter 6](ch06.html "Chapter 6. The Sharing Game"),
    *The Sharing Game*. Comment out the section in `OnOptionsItemSelect()` related
    to the `Edit` action for now; we will fill that in once the edit view is completed.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`OnCreateOptionsMenu()`和`OnOptionsItemSelected()`方法，以便我们的菜单可访问。现在暂时注释掉`OnOptionsItemSelected()`中与`Edit`操作相关的部分；一旦编辑视图完成，我们将填充这部分。
- en: Adding navigation
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加导航
- en: The last step is to add navigation so that when an item is clicked on in `MvxListView`
    on `MasterView`, the park is displayed in the detail view. We will accomplish
    this using a `command` property and data binding.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是添加导航，以便当在`MasterView`的`MvxListView`中点击项目时，公园将在详情视图中显示。我们将使用`command`属性和数据绑定来完成此操作：
- en: 'To add navigation, perform the following steps:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加导航，执行以下步骤：
- en: 'Open `MasterViewModel` and add an `IMvxCommand` property; this will be used
    to handle a park that is being selected:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MasterViewModel`并添加一个`IMvxCommand`属性；这将用于处理被选中的公园：
- en: '[PRE31]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create an `Action` delegate that will be called when the `ParkSelected` command
    is executed, as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Action`委托，当执行`ParkSelected`命令时将被调用，如下所示：
- en: '[PRE32]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Initialize the `command` property in the constructor of `MasterViewModel`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MasterViewModel`的构造函数中初始化`command`属性：
- en: '[PRE33]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, for the last step, add a data binding specification to `MvvListView` in
    `Master.axml` to bind the `ItemClick` event to the `ParkClicked` command on `MasterViewModel`,
    which we just created:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，最后一步，在`Master.axml`中的`MvvListView`上添加数据绑定规范，将`ItemClick`事件绑定到我们刚刚创建的`MasterViewModel`上的`ParkClicked`命令：
- en: '[PRE34]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Compile and run the app. Clicking on a park in the list view should now navigate
    to the detail view, displaying the selected park.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行应用。现在点击列表视图中的公园应该会导航到详情视图，显示选中的公园。
- en: Implementing the edit view
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现编辑视图
- en: We are now almost experts at implementing new Views and ViewModels. One last
    View to go is the edit view.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在几乎已经成为了实现新视图和视图模型的专家。接下来要做的最后一个视图是编辑视图。
- en: Creating EditViewModel
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建`EditViewModel`
- en: Like we did previously, we start with the ViewModel.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，我们从ViewModel开始。
- en: 'To create `EditViewModel`, complete the following steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`EditViewModel`，完成以下步骤：
- en: Following the same process that was previously used in this chapter to create
    `EditViewModel`, add a data binding property and create a `Parameters` class for
    navigation.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照本章之前用于创建`EditViewModel`的相同过程，添加数据绑定属性并创建一个`Parameters`类用于导航。
- en: 'Implement an `Init()` method that will accept an instance of the `Parameters`
    class and get the corresponding national park from `NationalParkData` in the case
    of editing an existing park or create a new instance if the user has chosen the
    `New` action. Inspect the parameters passed in to determine what the intent is:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`Init()`方法，该方法将接受`Parameters`类的实例，并在编辑现有公园的情况下从`NationalParkData`获取相应的国家公园，或者如果用户选择了`New`操作，则创建一个新的实例。检查传入的参数以确定意图：
- en: '[PRE35]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Updating the Edit.axml layout
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新`Edit.axml`布局
- en: Update `Edit.axml` to provide data binding specifications.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`Edit.axml`以提供数据绑定规范。
- en: To update the `Edit.axml` layout, you first need to open `Edit.axml` and add
    the project namespace to the XML file. Then, add the data binding specifications
    to each of the `EditView` elements that correspond to a national park property.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新 `Edit.axml` 布局，你首先需要打开 `Edit.axml` 并将项目命名空间添加到 XML 文件中。然后，将数据绑定规范添加到每个对应于国家公园属性的
    `EditView` 元素。
- en: Creating the EditView activity
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 EditView 活动
- en: Create a new `MvxActivity` instance named `EditView` to will work with `EditViewModel`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `EditView` 的新 `MvxActivity` 实例，它将与 `EditViewModel` 一起工作。
- en: 'To create `EditView`, perform the following steps:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `EditView`，请执行以下步骤：
- en: Following the same procedure as the one that was used to create `DetailView`,
    create a new View named `EditView` in the `Views` folder of `NationalParks.Droid`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照创建 `DetailView` 所使用的相同程序，在 `NationalParks.Droid` 的 `Views` 文件夹中创建一个名为 `EditView`
    的新视图。
- en: Implement the `OnCreateOptionsMenu()` and `OnOptionsItemSelected()` methods
    so that the `Done` action will accessible from the ActionBar. You can copy the
    implementation of these methods from the solution created in [Chapter 6](ch06.html
    "Chapter 6. The Sharing Game"), *The Sharing Game*. Change the implementation
    of `Done` to call the `Done` command on `EditViewModel`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `OnCreateOptionsMenu()` 和 `OnOptionsItemSelected()` 方法，以便从ActionBar中访问 `Done`
    操作。你可以从 [第 6 章](ch06.html "第 6 章。共享游戏") 中创建的解决方案中复制这些方法的实现，*共享游戏*。将 `Done` 的实现更改为调用
    `EditViewModel` 上的 `Done` 命令。
- en: Adding navigation
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加导航
- en: 'Add navigation to two places: when New (**+**) is clicked from `MasterView`
    and when **Edit** is clicked in `DetailView`. Let''s start with MasterView.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MasterView` 中点击 New (**+**) 和在 `DetailView` 中点击 **Edit** 时添加导航。让我们从 MasterView
    开始。
- en: 'To add navigation from `MasterViewModel`, complete the following steps:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 `MasterViewModel` 添加导航，完成以下步骤：
- en: 'Open `MasterViewModel.cs` and add a `NewParkClicked` command property along
    with the handler for the command. Be sure to initialize the command in the constructor,
    as follows:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MasterViewModel.cs` 并添加一个 `NewParkClicked` 命令属性以及该命令的处理程序。确保在构造函数中初始化命令，如下所示：
- en: '[PRE36]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that we do not pass in a parameter class into `ShowViewModel()`. This will
    cause a default instance to be created and passed in, which means that `ParkId`
    will be null. We will use this as a way to determine whether a new park should
    be created.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们不会将参数类传递给 `ShowViewModel()`。这将导致创建一个默认实例并将其传递，这意味着 `ParkId` 将为 null。我们将使用这种方式来确定是否应该创建一个新的公园。
- en: 'Now, it''s time to hook the `NewParkClicked` command up to the `actionNew`
    menu item. We do not have a way to accomplish this using data binding, so we will
    resort to a more traditional approach—we will use the `OnOptionsItemSelected()`
    method. Add logic to invoke the `Execute()` method on `NewParkClicked`, as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候将 `NewParkClicked` 命令连接到 `actionNew` 菜单项了。我们没有使用数据绑定来完成此操作的方法，因此我们将求助于更传统的做法——我们将使用
    `OnOptionsItemSelected()` 方法。添加逻辑以调用 `NewParkClicked` 的 `Execute()` 方法，如下所示：
- en: '[PRE37]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To add navigation from `DetailViewModel`, complete the following steps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 `DetailViewModel` 添加导航，完成以下步骤：
- en: 'Open `DetailViewModel.cs` and add a `EditParkClicked` command property along
    with the handler for the command. Be sure to initialize the command in the constructor,
    as shown in the following code snippet:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `DetailViewModel.cs` 并添加一个 `EditParkClicked` 命令属性以及该命令的处理程序。确保在构造函数中初始化命令，如下面的代码片段所示：
- en: '[PRE38]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that an instance of the `Parameters` class is created, initialized, and
    passed into the `ShowViewModel()` method. This instance will in turn be passed
    into the `Init()` method on `EditViewModel`.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，创建了一个 `Parameters` 类的实例，初始化并传递给 `ShowViewModel()` 方法。这个实例将反过来传递给 `EditViewModel`
    上的 `Init()` 方法。
- en: 'Initialize the `command` property in the constructor for `MasterViewModel`,
    as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MasterViewModel` 的构造函数中初始化 `command` 属性，如下所示：
- en: '[PRE39]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, update the `OnOptionsItemSelect()` method in `DetailView` to invoke the
    `DetailView.EditPark` command when the `Edit` action is selected:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新 `DetailView` 中的 `OnOptionsItemSelect()` 方法，以便在选择 `Edit` 操作时调用 `DetailView.EditPark`
    命令：
- en: '[PRE40]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Compile and run `NationalParks.Droid`. You should now have a fully functional
    app that has the ability to create new parks and edit the existing parks. Changes
    made to `EditView` should automatically be reflected in `MasterView` and `DetailView`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行 `NationalParks.Droid`。你现在应该有一个功能齐全的应用程序，它能够创建新的公园并编辑现有的公园。对 `EditView`
    所做的更改应自动反映在 `MasterView` 和 `DetailView` 中。
- en: Creating the MvvmCross iOS app
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 MvvmCross iOS 应用
- en: 'The process of creating the Android app with MvvmCross provides a solid understanding
    of how the overall architecture works. Creating the iOS solution should be much
    easier for two reasons: first, we understand how to interact with MvvmCross and
    second, all the logic we have placed in `NationalParks.Core` is reusable, so that
    we just need to create the View portion of the app and the startup code.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MvvmCross创建Android应用的过程提供了对整体架构如何工作的深入了解。由于以下两个原因，创建iOS解决方案应该会容易得多：首先，我们了解了如何与MvvmCross交互；其次，我们放置在`NationalParks.Core`中的所有逻辑都是可重用的，因此我们只需要创建应用视图部分和启动代码。
- en: 'To create `NationalParks.iOS`, complete the following steps:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`NationalParks.iOS`，请完成以下步骤：
- en: Select the `NationalParks.MvvmCross` solution, right-click on it, and navigate
    to **Add** | **New Project**.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`NationalParks.MvvmCross`解决方案，右键单击它，然后导航到**添加** | **新建项目**。
- en: From the **New Project** dialog, navigate to **C#** | **iOS** | **iPhone** |
    **Single View Application**, enter `NationalParks.iOS` in the Name field, and
    click on **OK**.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**新建项目**对话框中，导航到**C#** | **iOS** | **iPhone** | **单视图应用**，在名称字段中输入`NationalParks.iOS`，然后点击**确定**。
- en: Add the MvvmCross starter kit package to the new project by selecting `NationalParks.iOS`
    and navigating to **Project** | **Add Packages** from the main menu.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择`NationalParks.iOS`并从主菜单导航到**项目** | **添加包**，将MvvmCross启动套件包添加到新项目中。
- en: 'A number of things were added to `NationalParks.iOS` as a result of adding
    the package. They are as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于添加了包，`NationalParks.iOS`添加了一些内容。具体如下：
- en: '`packages.config`: This file contains a list of libraries associated with the
    MvvmCross starter kit package. These entries are links to an actual library in
    the `Packages` folder of the overall solution, which contains the actual downloaded
    libraries.'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packages.config`：这个文件包含与MvvmCross启动套件包关联的库列表。这些条目是到整体解决方案`Packages`文件夹中实际库的链接，其中包含实际下载的库。'
- en: '`FirstView`: This class is placed in the `Views` folder, which corresponds
    to the `FirstViewModel` instance created in `NationalParks.Core`.'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirstView`：这个类放在`Views`文件夹中，对应于在`NationalParks.Core`中创建的`FirstViewModel`实例。'
- en: '`Setup`: This class inherits from `MvxTouchSetup`. This class is responsible
    for creating an instance of the `App` class from the core project, which in turn
    displays the first ViewModel via a call to `RegisterAppStart()`.'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Setup`：这个类继承自`MvxTouchSetup`。这个类负责从核心项目创建`App`类的实例，然后通过调用`RegisterAppStart()`显示第一个ViewModel。'
- en: '`AppDelegate.cs.txt`: This class contains the sample startup code, which should
    be placed in the actual `AppDelete.cs` file.'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppDelegate.cs.txt`：这个类包含示例启动代码，应该放置在实际的`AppDelegate.cs`文件中。'
- en: Implementing the iOS user interface
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现iOS用户界面
- en: 'We are now ready to create the user interface for the iOS app. The good news
    is that we already have all the ViewModels implemented, so we can simply reuse
    them. The bad news is that we cannot easily reuse the storyboards from our previous
    work; MvvmCross apps generally use XIB files. One of the reasons for this is that
    storyboards are intended to provide navigation capabilities and an MvvmCross app
    delegates that responsibility to ViewModel and presenter. It is possible to use
    storyboards in combination with a custom presenter, but the remainder of this
    chapter will focus on using XIB files, as this is the more common use. The screen
    layouts as used in [Chapter 4](ch04.html "Chapter 4. Developing Your First iOS
    App with Xamarin.iOS"), *Developing Your First iOS App with Xamarin.iOS*, can
    be used as depicted in the following screenshot:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备为iOS应用创建用户界面。好消息是我们已经实现了所有的ViewModel，因此我们可以简单地重用它们。坏消息是我们不能轻易地重用之前工作的storyboards；MvvmCross应用通常使用XIB文件。其中一个原因是storyboards旨在提供导航能力，而MvvmCross应用将这一责任委托给了ViewModel和presenter。虽然可以使用storyboards与自定义presenter结合使用，但本章的剩余部分将专注于使用XIB文件，因为这更为常见。屏幕布局，如[第4章](ch04.html
    "第4章. 使用Xamarin.iOS开发您的第一个iOS应用")中所述的*使用Xamarin.iOS开发您的第一个iOS应用*，可以按照以下截图所示使用：
- en: '![Implementing the iOS user interface](img/0838OT_07_07.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![实现iOS用户界面](img/0838OT_07_07.jpg)'
- en: We are now ready to get started.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备开始。
- en: Implementing the master view
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现主视图
- en: The first view we will work on is the master view.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先工作的视图是主视图。
- en: 'To implement the master view, complete the following steps:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现主视图，请完成以下步骤：
- en: Create a new `ViewController` class named `MasterView` by right-clicking on
    the `Views` folder of `NationalParks.iOS` and navigating to **Add** | **New File**
    | **iOS** | **iPhone View Controller**.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`NationalParks.iOS`的`Views`文件夹上右键单击并导航到**添加** | **新建文件** | **iOS** | **iPhone
    视图控制器**，创建一个名为`MasterView`的新`ViewController`类。
- en: Open `MasterView.xib` and arrange controls as seen in the screen layouts. Add
    outlets for each of the edit controls.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MasterView.xib`，按照屏幕布局排列控件。为每个编辑控件添加出口。
- en: 'Open `MasterView.cs` and add the following boilerplate logic to deal with constraints
    on iOS 7, as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MasterView.cs`，添加以下模板逻辑以处理iOS 7上的约束，如下所示：
- en: '[PRE41]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Within the `ViewDidLoad()` method, add logic to create `MvxStandardTableViewSource`
    for `parksTableView`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad()`方法内，添加创建`parksTableView`的`MvxStandardTableViewSource`的逻辑：
- en: '[PRE42]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that the example uses the `Subtitle` cell style and binds the national
    park name and description to the title and subtitle.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，示例使用的是`Subtitle`单元格样式，并将国家公园名称和描述绑定到标题和副标题。
- en: 'Add the binding logic to the `ViewDidShow()` method. In the previous step,
    we provided specifications for properties of `UITableViewCell` to properties in
    the binding context. In this step, we need to set the binding context for the
    `Parks` property on `MasterModelView`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewDidShow()`方法中添加绑定逻辑。在上一步中，我们为`UITableViewCell`的属性提供了绑定上下文中的属性规范。在本步骤中，我们需要为`MasterModelView`上的`Parks`属性设置绑定上下文：
- en: '[PRE43]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Compile and run the app. All the parks in `NationalParks.json` should be displayed.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行应用程序。`NationalParks.json`中的所有公园都应显示出来。
- en: Implementing the detail view
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现详细视图
- en: 'Now, implement the detail view using the following steps:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤实现详细视图：
- en: Create a new `ViewController` instance named `DetailView`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`DetailView`的新`ViewController`实例。
- en: Open `DetailView.xib` and arrange controls as shown in the following code. Add
    outlets for each of the edit controls.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`DetailView.xib`，按照以下代码排列控件。为每个编辑控件添加出口。
- en: 'Open `DetailView.cs` and add the binding logic to the `ViewDidShow()` method:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`DetailView.cs`，并在`ViewDidShow()`方法中添加绑定逻辑：
- en: '[PRE44]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Adding navigation
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加导航
- en: Add navigation from the master view so that when a park is selected, the detail
    view is displayed, showing the park.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 从主视图添加导航，以便当选择一个公园时，显示详细视图，显示该公园。
- en: 'To add navigation, complete the following steps:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加导航，请完成以下步骤：
- en: 'Open `MasterView.cs`, create an event handler named `ParkSelected`, and assign
    it to the `SelectedItemChanged` event on `MvxStandardTableViewSource`, which was
    created in the `ViewDidLoad()` method:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MasterView.cs`，创建一个名为`ParkSelected`的事件处理程序，并将其分配给在`ViewDidLoad()`方法中创建的`MvxStandardTableViewSource`上的`SelectedItemChanged`事件：
- en: '[PRE45]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Within the event handler, invoke the `ParkSelected` command on `MasterViewModel`,
    passing in the selected park:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件处理程序内，调用`MasterViewModel`上的`ParkSelected`命令，并传入所选公园：
- en: '[PRE46]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Compile and run `NationalParks.iOS`. Selecting a park in the list view should
    now navigate you to the detail view, displaying the selected park.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行`NationalParks.iOS`。现在，从列表视图中选择一个公园应导航到详细视图，显示所选公园。
- en: Implementing the edit view
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现编辑视图
- en: We now need to implement the last of the Views for the iOS app, which is the
    edit view.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要实现iOS应用程序的最后几个视图之一，即编辑视图。
- en: 'To implement the edit view, complete the following steps:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现编辑视图，请完成以下步骤：
- en: Create a new `ViewController` instance named `EditView`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`EditView`的新`ViewController`实例。
- en: Open `EditView.xib` and arrange controls as in the layout screenshots. Add outlets
    for each of the edit controls.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`EditView.xib`，按照布局截图排列控件。为每个编辑控件添加出口。
- en: Open `EditView.cs` and add the data binding logic to the `ViewDidShow()` method.
    You should use the same approach to data binding as the approach used for the
    details view.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`EditView.cs`，并在`ViewDidShow()`方法中添加数据绑定逻辑。您应使用与详细视图相同的数据绑定方法。
- en: 'Add an event handler named `DoneClicked`, and within the event handler, invoke
    the `Done` command on `EditViewModel`:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`DoneClicked`的事件处理程序，并在事件处理程序内调用`EditViewModel`上的`Done`命令：
- en: '[PRE47]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In `ViewDidLoad()`, add `UIBarButtonItem` to `NavigationItem` for `EditView`,
    and assign the `DoneClicked` event handler to it, as follows:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad()`中，为`EditView`的`NavigationItem`添加`UIBarButtonItem`，并将其`DoneClicked`事件处理程序分配给它，如下所示：
- en: '[PRE48]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Adding navigation
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加导航
- en: 'Add navigation to two places: when New (**+**) is clicked from the master view
    and when **Edit** is clicked on in the detail view. Let''s start with the master
    view.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个地方添加导航：当从主视图点击**新建（**+**）**时，以及在详细视图中的**编辑**按钮上点击。让我们从主视图开始。
- en: 'To add navigation to the master view, perform the following steps:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要为主视图添加导航，执行以下步骤：
- en: 'Open `MasterView.cs` and add an event handler named `NewParkClicked`. In the
    event handler, invoke the `NewParkClicked` command on `MasterViewModel`:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MasterView.cs`文件，添加一个名为`NewParkClicked`的事件处理程序。在事件处理程序中，在`MasterViewModel`上调用`NewParkClicked`命令：
- en: '[PRE49]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In `ViewDidLoad()`, add `UIBarButtonItem` to `NavigationItem` for `MasterView`
    and assign the `NewParkClicked` event handler to it:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad()`中，为`MasterView`的`NavigationItem`添加`UIBarButtonItem`，并将`NewParkClicked`事件处理程序分配给它：
- en: '[PRE50]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To add navigation to the details view, perform the following steps:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要为详情视图添加导航，执行以下步骤：
- en: 'Open `DetailView.cs` and add an event handler named `EditParkClicked`. In the
    event handler, invoke the `EditParkClicked` command on `DetailViewModel`:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`DetailView.cs`文件，添加一个名为`EditParkClicked`的事件处理程序。在事件处理程序中，在`DetailViewModel`上调用`EditParkClicked`命令：
- en: '[PRE51]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In `ViewDidLoad()`, add `UIBarButtonItem` to `NavigationItem` for `MasterView`,
    and assign the `EditParkClicked` event handler to it:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad()`中，为`MasterView`的`NavigationItem`添加`UIBarButtonItem`，并将`EditParkClicked`事件处理程序分配给它：
- en: '[PRE52]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Refreshing the master view list
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 刷新主视图列表
- en: One last detail that needs to be taken care of is to refresh the `UITableView`
    control on `MasterView` when items have been changed on `EditView`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 需要最后注意的一个细节是在`EditView`上更改项目时刷新`MasterView`上的`UITableView`控件。
- en: 'To refresh the master view list, perform the following steps:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要刷新主视图列表，执行以下步骤：
- en: 'Open `MasterView.cs` and call `ReloadData()` on `parksTableView` within the
    `ViewDidAppear()` method of `MasterView`:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MasterView.cs`文件，并在`MasterView`的`ViewDidAppear()`方法中调用`parksTableView`的`ReloadData()`：
- en: '[PRE53]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Compile and run `NationalParks.iOS`. You should now have a fully functional
    app that has the ability to create new parks and edit existing parks. Changes
    made to `EditView` should automatically be reflected in `MasterView` and `DetailVIew`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行`NationalParks.iOS`。你现在应该有一个功能齐全的应用程序，它能够创建新的公园并编辑现有的公园。对`EditView`所做的更改应自动反映在`MasterView`和`DetailVIew`中。
- en: Considering the pros and cons
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑到优缺点
- en: 'After completing our work, we now have the basis to make some fundamental observations.
    Let''s start with the pros:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 完成我们的工作后，我们现在有了做一些基本观察的基础。让我们从优点开始：
- en: MvvmCross definitely increases the amount of code that can be reused across
    platforms. The ViewModels house the data required by the View, the logic required
    to obtain and transform the data in preparation for viewing, and the logic triggered
    by user interactions in the form of commands. In our sample app, the ViewModels
    were somewhat simple; however, the more complex the app, the more reuse will likely
    be gained.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MvvmCross无疑增加了可以在各个平台之间复用的代码量。ViewModel包含视图所需的数据，获取和转换数据以供查看所需的逻辑，以及由用户交互触发的命令逻辑。在我们的示例应用程序中，ViewModel相对简单；然而，应用程序越复杂，复用性可能就越高。
- en: As MvvmCross relies on the use of each platform's native UI frameworks, each
    app has a native look and feel and we have a natural layer that implements platform-specific
    logic when required.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于MvvmCross依赖于使用每个平台的本地UI框架，每个应用程序都有一个本地的外观和感觉，并且当需要时，我们有一个自然层实现特定平台的逻辑。
- en: The data binding capabilities of MvvmCross also eliminate a great deal of tedious
    code that would otherwise have to be written.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MvvmCross的数据绑定功能还消除了大量必须编写的繁琐代码。
- en: 'All of these positives are not necessarily free; let''s look at some cons:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些优点并不一定是免费的；让我们看看一些缺点：
- en: The first con is complexity; you have to learn another framework on top of Xamarin,
    Android, and iOS.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个缺点是复杂性；你必须在Xamarin、Android和iOS之上学习另一个框架。
- en: In some ways, MvvmCross forces you to align the way your apps work across platforms
    to achieve the most reuse. As the presentation logic is contained in the ViewModels,
    the views are coerced into aligning with them. The more your UI deviates across
    platforms; the less likely it will be that you can actually reuse ViewModels.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些方面，MvvmCross迫使你将应用程序在不同平台上的工作方式对齐，以实现最大的复用。由于表示逻辑包含在ViewModel中，视图被迫与之对齐。你的UI在各个平台上的偏差越大，你能够实际复用ViewModel的可能性就越小。
- en: With these things in mind, I would definitely consider using MvvmCross for a
    cross-platform mobile project. Yes, you need to learn an addition framework and
    yes, you will likely have to align the way some of the apps are laid out, but
    I think MvvmCross provides enough value and flexibility to make these issues workable.
    I'm a big fan of reuse and MvvmCross definitely pushes reuse to the next level.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些因素，我肯定会考虑在跨平台移动项目中使用 MvvmCross。是的，你需要学习一个额外的框架，而且你很可能需要调整一些应用布局的方式，但我认为
    MvvmCross 提供了足够的价值和灵活性，使得这些问题变得可行。我是一个重用的大粉丝，MvvmCross 确实将重用提升到了新的水平。
- en: Summary
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the high-level concepts of MvvmCross and worked
    through a practical exercise in order to convert the national parks apps to use
    the MvvmCross framework and the increase code reuse. In the next chapter, we will
    follow a similar approach to exploring the Xamarin.Forms framework in order to
    evaluate how its use can affect code reuse.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了 MvvmCross 的高级概念，并通过一个实际练习将国家公园应用转换为使用 MvvmCross 框架并增加代码重用。在下一章中，我们将采用类似的方法来探索
    Xamarin.Forms 框架，以评估其使用如何影响代码重用。
