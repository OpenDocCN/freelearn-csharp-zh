- en: Chapter 7. Trading Cupcakes and the Ultimate Battle for the Cake – Gameplay
    Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After going through different parts of the Unity engine, it''s time to come
    back to our game and finish it up. In doing this, we will explore another big
    topic: **gameplay programming**. In particular, we will see how data can be exchanged
    between different parts of a game. Since in our tower defense game there are still
    many parts to connect, and they can be implemented in thousands of different ways,
    I tried to choose different techniques in order to give you a different perspective
    on how things can be implemented within Unity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: How to implement a trading system to allow the player to buy, sell, and upgrade
    cupcake towers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting how the player can place cupcake towers on the map once they are bought
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How game over conditions can be triggered to display a winning or losing screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping track of the progress made by the player during the level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a spawn system for our Pandas, based on dividing the Pandas into waves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing and implementing a main menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to change a scene in Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As always, at the end of the chapter you can find the *Homework* section, which
    is full of exercises for you to bring your skills to a higher level. Some of these
    exercises will challenge you about the concepts learnt in the chapter, and they
    will guide you in improving our tower defense game.
  prefs: []
  type: TYPE_NORMAL
- en: But before we go straight into gameplay programming for our game, let's spend
    some time learning about gameplay programming in general.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To better understand this chapter, you should have followed all of the other
    chapters, since we are going to implement our scripts here on top of the ones
    we have previously created throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, for those readers who only did the first implementation in the
    previous chapter, I have kept the code of the first implementation. However, for
    those who did the second implementation, you shouldn't have a problem doing the
    same modifications to the code. In any case, it's recommended that you have the
    second implementation of the code in the game, because the next chapter will give
    us some ways to exploit its potential in the context of a larger game.
  prefs: []
  type: TYPE_NORMAL
- en: What does gameplay programming mean?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is not a unique definition for gameplay programming. Of course, it deals
    with building and developing the game, but for instance, does it include programming
    artificial intelligence? Or UIs? Or database connections? Or animation machines?
    Therefore, the definition depends on the context. However, it is interesting to
    note how the definition changes again, when you seek a job position. As a rule
    of thumb, based only on experience, the bigger and larger the company is, the
    better the gameplay programmer job position will be. In fact, in small companies,
    teams can be resource limited and therefore having a gameplay programmer means
    that he/she will do everything, whereas in larger teams where there are AI, UI,
    and animation programmers, the gameplay programmer is likely to be more a coordinator
    of all such roles, and therefore it is a higher position.
  prefs: []
  type: TYPE_NORMAL
- en: 'I would like to close this section with a quote from a blog of a game developer
    (Ask a Game Dev at [http://askagamedev.tumblr.com/post/72792621882/roles-in-the-industry-the-gameplay-programmer](http://askagamedev.tumblr.com/post/72792621882/roles-in-the-industry-the-gameplay-programmer)),
    who describes what it feels like to be a gameplay programmer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"As you can see, being a gameplay programmer is about solving problems even
    moreso than the designer - you have to really figure out all of the bits of the
    problem and solve them all. But you also have much more in-depth knowledge of
    how the entire system works. You get to create those systems. You get to be the
    first to see something awesome happen."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now, it's time to go into the specifics and get our tower defense game done!
  prefs: []
  type: TYPE_NORMAL
- en: Planning what is left to implement for our game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to do before we complete our game is to reorganize the ideas
    after having written down what we have done so far.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](part0016.xhtml#aid-F8901 "Chapter 1. A Flat World in Unity"),
    *A Flat World in Unity*, we imported all the Sprites and set them up properly.
    Then, in [Chapter 2](part0028.xhtml#aid-QMFO1 "Chapter 2. Baking Cupcake Towers"), *Baking
    Cupcake Towers*, we implemented the Projectile and Cupcake tower classes. In [Chapter
    3](part0043.xhtml#aid-190861 "Chapter 3. Communicating with the Player – the User
    Interface"), *Communicating with the Player – the User Interface*, we implemented
    the health and the sugar of the player, whereas in [Chapter 4](part0056.xhtml#aid-1LCVG1
    "Chapter 4. No Longer Alone – Sweet-Toothed Pandas Strike"), *No Longer Alone
    – Sweet-Toothed Pandas Strike*, we focused on animating our sweet-toothed Panda.
    Finally, in [Chapter 5](part0062.xhtml#aid-1R42S1 "Chapter 5. The Secret Ingredient
    Is a Dash of Physics"), *The Secret Ingredient Is a Dash of Physics*, we explored
    physics and how we can use it within our game, and in [Chapter 6](part0077.xhtml#aid-29DRA1
    "Chapter 6. Through a Sea of Sprinkles – Navigation in Artificial Intelligence"),
    *Through a Sea of Sprinkles – Navigation in Artificial Intelligence*, we gave
    the Pandas the possibility of moving along the path towards the sweet cake.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what''s left to do is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrate a trading system so the player can buy, sell, and upgrade cupcake
    towers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a mechanism to place the cupcake towers once they have been bought
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify how the player can select a specific cupcake tower
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up game over conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping track of the progress of the player during gameplay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a spawning system for our Pandas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a main menu for our game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After we have done all of this, we will basically have a functioning game. So,
    let's get started with the first on the list.
  prefs: []
  type: TYPE_NORMAL
- en: Trading cupcake towers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how to allow the player to trade towers. In particular,
    the player can either buy, sell, or upgrade a cupcake tower. Since these three
    actions have something in common, we will implement them by using **inheritance**.
    If you remember, we talked a bit about it in [Chapter 2](part0028.xhtml#aid-QMFO1
    "Chapter 2. Baking Cupcake Towers"), *Baking Cupcake Towers*, but now we have
    the possibility of seeing it in action. As a result, along the way we will have
    a better understanding of abstract methods and static variables, since we will
    use them again.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, each one of these trading actions that the player can perform
    are implemented separately. This is the structure we will implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Trading cupcake towers](img/image00594.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Each of the child scripts can be attached to a UI element, and that will be
    transformed into a button to perform that specific action. Let's start with the
    parent class.
  prefs: []
  type: TYPE_NORMAL
- en: The trading parent class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start to create a general class named `TradeCupcakeTower`, and open it
    with your favorite code editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Buying, selling, and upgrading require the user to click on their icon in the
    user interface (we will create the UI in the scene for the trading actions after
    we have scripted the whole trading system first), and so we need to provide a
    way to detect the click (or the tap in case of a mobile application) of the player.
    As we have talked about it in [Chapter 3](part0043.xhtml#aid-190861 "Chapter 3. Communicating
    with the Player – the User Interface"), *Communicating with the Player – the User
    Interface*, we can use a handler. Thus, we need to add the following library at
    the beginning of our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the definition of the class, we can add the click handler. Moreover,
    since this will be an abstract class, we need to specify it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When trading, we want to check the player''s sugar level (which is the currency
    of our game). As a result, we need to have a reference to the Sugar Meter, which
    is also shared among all the trading classes. Thus, we can make the variable protected
    and static:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to what we did in the last chapter when we had to get the reference
    to the game manager for all the Pandas (since also, in that case the variable
    was static), we need to get the reference to the Sugar Meter only once. As such,
    in the `Start()` function we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When the player sells or upgrades a tower, the trading system should know which
    tower the player is referring to (how the player selects a tower is left for later
    in *Selecting the towers* section). Therefore, again we can use a protected and
    static variable shared across all the trading operation classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need a function to set the selection (the current active tower), and
    it needs to be static, so it can be easily set by other scripts (as we will see
    later). The function just assigns the tower passed as a parameter to the static
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to implement the interface for handling the click. However,
    the sequence of actions that should be performed depends on if the player is either
    buying, selling, or upgrading. Therefore, we can leave the implementation to the
    child classes, and leave this as an abstract function (refer to [Chapter 2](part0028.xhtml#aid-QMFO1
    "Chapter 2. Baking Cupcake Towers"), *Baking Cupcake Towers*, on how abstract
    and virtual methods work) as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can save the script, and as a result our parent class is ready. Now, before
    we implement its children for specific trading actions that the player can perform,
    we need to modify the `CupcakeTowerScript`.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the CupcakeTowerScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in [Chapter 2](part0028.xhtml#aid-QMFO1 "Chapter 2. Baking Cupcake Towers"), *Baking
    Cupcake Towers*, we implemented many functionalities for our cupcake towers. However,
    there is more work to do on their script. In particular, we need to add some variables
    to store their prices and costs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the following self-explanatory variables, which we may
    want to set into the **Inspector** later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time we upgrade the cupcake tower, we want to raise both the `sellingValue,`
    because an upgraded tower is more valuable, and the `UpgradingCost`, because upgrading
    to higher levels requires more sugar. So, we can add the following lines of code
    in the `Upgrade()` function (the values may depend on your very specific balance
    of the game, but the next chapter will go into more detail on this and how to
    handle costs of towers in a dynamic way):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the script, and go into your cupcake tower prefabs and change the values
    of these three, new variables in the **Inspector** (again, feel free to use the
    values you prefer). Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying the CupcakeTowerScript](img/image00595.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we are ready to implement the trading actions, starting with buying.
  prefs: []
  type: TYPE_NORMAL
- en: Buying cupcake towers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will implement the script that handles the buying action.
    Let's start by creating a new script and name it TradeCupcakeTowers_Buying and
    open it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we still need to import the event systems library from the Unity
    engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the class declaration, we need to specify that we are going to extend the
    `TradeCupcakeTowers` class, instead of `MonoBehaviour`, in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the design of our user interface back in [Chapter 3](part0043.xhtml#aid-190861
    "Chapter 3. Communicating with the Player – the User Interface"), *Communicating
    with the Player – the User Interface*, we have three different kinds of towers
    that the player can buy. Each one of the buttons, once clicked, will instantiate
    a different tower. Therefore, we need to specify which cupcake tower prefab this
    instance of the script is referring to. Of course, its values should be set in
    the **Inspector** (we will see this later). So, let''s add the following variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to implement the abstract function inherited from its parent,
    to handle what happens when the player clicks on its icon. As such, we need to
    use the `override` property, and declare the method in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the first thing to do when the player clicks is to retrieve the price
    of the cupcake tower that the player wants to buy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to check if the player has enough sugar, by using the shared
    static variable, `sugarMeter`. If the player has enough sugar, then a new cupcake
    tower is instantiated (we will see how the player places the tower later in the
    chapter) and it is assigned as the active tower among the trading classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Save the script, and the buy functionality is implemented. Let's see how the
    player can sell the cupcake towers to get some sugar back.
  prefs: []
  type: TYPE_NORMAL
- en: Selling cupcake towers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will implement the script that handles the selling action.
    Create a new script and name it `TradeCupcakeTowers_Selling`, then open it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we still need to import the event systems library from the Unity
    engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did for the `TradeCupcakeTowers_Buying`, we need to inherit from the
    `TradeCupcakeTowers` class in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to implement the abstract function, to handle what happens when
    the player clicks on the selling icon. Again, we need to use the `override` property,
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Since selling is an action that the player is always able to perform, we don''t
    need to do any checks (except if there is an active tower), but rather retrieve
    the value of the cupcake tower and add that amount to the player''s savings. Then,
    remove the cupcake tower from the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can save the script. As a result, the selling functionality is also
    implemented. Only the upgrading one is left.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading cupcakes towers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we get to create the upgrading button. Create a script and name it `TradeCupcakeTowers_Upgrading`,
    then open it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we still need to import the event systems library from the Unity
    engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did for the other trading classes, we need to inherit from the `TradeCupcakeTowers`
    class in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to implement the abstract function, to handle what happens when
    the player clicks on the upgrading button. Once more, we need to use the `override` property,
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to what we did with the buying button, we need to check if the player
    can afford to upgrade the tower, and if the tower is actually upgradable (we had
    a Boolean flag for that, set back in [Chapter 2](part0028.xhtml#aid-QMFO1 "Chapter 2. Baking
    Cupcake Towers"), *Baking Cupcake Towers*). If so, the cost of the upgrade is
    subtracted from the player''s sugar, and the tower is finally upgraded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Save this script, and as a result we have completed all the trading functionalities.
    However, they are not present in the scene, so let's add them to our interface.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the trading options to the user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the scripts to implement all the different trading buttons,
    we need to actually place them within our scene/level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, let''s start to create three UI images, and attach to each one of
    them, the `TradeCupcakeTowers_Buying` script. As their **Source Image**, you can
    select the icons we have in our graphical package for the three different kind
    of towers we have. In case you didn''t implement them all, that''s alright, just
    remove the buttons you don''t need. If on the contrary, you have implemented more
    with your own graphics, feel free to add more of these buttons. Then, after you
    have properly scaled the buttons, place them within our interface as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the trading options to the user interface](img/image00596.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, in the **Inspector**, we need to assign their respective **Cupcake Tower
    Prefab**. Here is just one of the three buttons, shown as an example for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the trading options to the user interface](img/image00597.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Very well, now the player can buy towers! What about selling and upgrading them?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create another two UI images, and attach respectively, the `TradeCupcakeTowers_Selling`
    and `TradeCupcakeTowers_Upgrading` scripts to them. Then, use the icons for selling
    and upgrading you can find in our graphical package as **Source Image**. Scale
    the buttons properly, and place them within our interface as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the trading options to the user interface](img/image00598.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We don't have any variables to assign in the **Inspector**, so we can consider
    our trading system ready! Although to make it work properly, we still need to
    have a way to place our towers and a way to select the towers. These will be explored
    in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Placing the towers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the player has bought a cupcake tower, he or she should be able to decide
    where to place it. This section will explore how to implement this mechanism,
    which may be simple, but requires you pay attention to many things.
  prefs: []
  type: TYPE_NORMAL
- en: Sketching the idea of how it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways in which we can implement this system, but we will use colliders
    and a second script on the cupcake tower. As a result, you will also be able to
    learn new ways to handle situations in which information should be exchanged among
    the different game elements.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we will define some areas where it is allowed to place a tower,
    and we will do this through the use of colliders. Then, the game manager registers
    if the pointer of the player is within allowed areas. A second script, attached
    to the cupcake towers, uses this information from the game manager to actually
    allow the player to place cupcake towers. Moreover, once the tower is placed,
    the script attaches a collider to the cupcake tower. This will prevent a tower
    from being placed on top of others, and it will also be useful for implementing
    the selection system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the *Homework* section, you will find some exercises to improve what we are
    going to implement in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Allowed areas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, we should notice that the player is not free to place his towers
    wherever he wants to on the map. In fact, he cannot place them along the path
    where the Pandas are moving or in areas where there is water or other obstacles.
    Therefore, we need to specify this constraint within our game. Thus, we need to
    look at our map and find all the spots where the player can place the tower. In
    our case, the spots that we are looking for are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Allowed areas](img/image00599.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, they have a custom shape. Even if it is possible to implement
    custom shapes (which is left as an exercise to readers who want to challenge themselves),
    it can be much more convenient to think in terms of rectangles and thus to split
    our shapes into rectangles. Of course, this can be done in more than one way;
    however, the less rectangles that cover the entire area, the better from a computational
    point of view. On the other hand, by using more rectangles, you are able to better
    approximate your areas. So find your tradeoff.
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible choice could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Allowed areas](img/image00600.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the end, we have found 11 areas.
  prefs: []
  type: TYPE_NORMAL
- en: The idea here is that all these areas are **Box Colliders 2D** attached to the
    `Game Manager` object, which will check if the mouse is within one of these areas
    or not by toggling a flag. This flag will be read by the script we are going to
    implement in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by adding a **Box Collider 2D** on the **Game Manager** by clicking
    on** Component | Physics 2D | Box Collider 2D**. Then, we need to resize it to
    the same dimensions as one of the rectangles we have found, and by using the offset
    parameter, place it onto the map. At this stage in the book, you should be able
    to repeat this operation for all the areas of the map, without having their exact
    values written down here in the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the next stage is to modify the `GameManagerScript` to toggle the flag.
    Once we have opened the script, we can already add the flag as a Boolean variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we don''t want other scripts to change this variable, it is private,
    and therefore we need to expose a function to retrieve its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Unity offers us a couple of very handy functions to detect when the pointer
    of the player enters within an area. Their names are self-explanatory: `OnMouseEnter()`
    and `OnMouseExit()`. In the first function, we will set the flag to `true`, whereas
    in the second we will set the flag to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Save the script, and the setup for the allowed areas is ready.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the placement script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For placing the cupcake towers after having been bought, we need to create another
    script for our cupcake towers. You can rename it `PlacingCupcakeTowerScript`,
    and add it to the **Cupcake Tower Prefabs**.
  prefs: []
  type: TYPE_NORMAL
- en: Before modifying it, we need to uncheck the `CupcakeTowerScript` from the prefabs
    of our cupcake towers. In fact, a tower enters in the scene for the first time
    because the player has bought it. While in placing mode, the cupcake tower should
    not shoot. Once placed, the `CupcakeTowerScript` is enabled, and the tower is
    operative again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can open the newly-created script. We need to retrieve the `Game Manager`,
    since we will need it to check when the mouse is on an area where cupcake towers
    can be placed. As such, we can write the following code, which is the same we
    used in [Chapter 6](part0077.xhtml#aid-29DRA1 "Chapter 6. Through a Sea of Sprinkles
    – Navigation in Artificial Intelligence"), *Through a Sea of Sprinkles – Navigation
    in Artificial Intelligence*, to retrieve the `Game Manager` for the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Update()` function we are moving the tower to the mouse location (so
    at each frame, the tower will move with the mouse of the player), and if the player
    presses a key, we check if the pointer is actually over an allowed area. If so,
    the tower is placed, which means that the script that moves the tower is destroyed.
    Moreover, the `CupcakeTowerScript` is enabled again, and a collider is placed
    on the cupcake tower. In fact, this additional collider prevents the placing of
    other towers on top of this (and to select the tower in the next section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Save the script, and as a result the player is able to place cupcake towers
    once they are bought.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the towers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you remember, all the trading operations have a selected tower to deal with.
    In fact, when the player presses the sell button, the game should know which cupcake
    tower the player intends to sell. As such, the player should be able to select
    (and unselect) a tower, and this tower should notify the trading system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we need to slightly modify the `CupcakeTowerScript`. From
    the previous section, we know that when the tower is active, it has a collider
    to prevent placing other towers on top of it as well. But, we can also use this
    collider to detect if the player clicks on this very specific tower. In particular,
    we can use the self-explanatory function, `OnMouseDown()` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After saving the script, the player is able to select a specific tower among
    the ones he or she has in the game, and sell or upgrade it through the trading
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The Game Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced the `GameMangerScript`, but even after
    the second implementation of waypoints, we have left this script empty with no
    use. However, we do indeed need a game manager in our game to handle a couple
    of things. So, in case you have erased it from the last chapter, recreate it,
    along with a game object in the scene with such a script attached (the same way
    as if you erased the reference from the `PandaScript`, because we will need it
    later on).
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `Game Manager` as a hub for exchanging information between the
    player's health and the Pandas. In fact, the `Game Manager` will spawn Pandas
    in the scene divided into waves, and it's the only script to be aware of when
    the level starts and finishes and/or if the player has lost all the health. This
    makes the Game Manager the perfect candidate to handle and trigger the game over
    conditions. Let's start with them.
  prefs: []
  type: TYPE_NORMAL
- en: Game over conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When does our game reach an end? Well, there are two cases: when the player
    loses his/her health, which means the Pandas have eaten all the cake (losing condition),
    or when the player has shot down all the Pandas (winning condition). In either
    case, we need to show to the player the outcome and terminate the game.'
  prefs: []
  type: TYPE_NORMAL
- en: Game over feedback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our graphic package, there are two screens ready for when the game is over.
    Respectively, these are *Game Over*, used for the losing condition, and *You Win*,
    used for the winning condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two UI images, as we learnt in [Chapter 3](part0043.xhtml#aid-190861
    "Chapter 3. Communicating with the Player – the User Interface"), *Communicating
    with the Player – the User Interface*, and place the two sprites of our package,
    one for each UI image. You probably want to press the **Set Native Size** button,
    and then scale and move them, so that they are in the middle of the scene, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game over feedback](img/image00601.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can disable them, since they shouldn't be displayed until the game ends.
    However, we need to add a reference to them in the `Game Manager`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, open the `GameManagerScript` and let''s add these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the script, and from the **Inspector** assign the UI images we created
    previously, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game over feedback](img/image00602.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As a result, the `Game Manager` is able to activate one of the two when certain
    conditions are met. Let's see how to implement a function for that in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The GameOver function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To keep things ordered within our `GameManagerScript`, let's create a function
    to trigger what happens when the game ends. It will have a Boolean as a parameter
    to determine if the player has won or not.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, what exactly should happen when the game ends is up to you. You can
    save statistics and the score (if you have any), trigger nice and cool animations,
    display buttons to load next levels, and so on. In this book, we will just display
    the UI images created in the previous section, because the goal is to show you
    where and how to insert code for game over. Feel free to add your own implementation
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, let''s write down this function that, based on the parameter, will
    display the right screen to the player. Then, it stops the time of the game to
    create a kind of pause situation in the game. As a result, the game won''t be
    running when the game over screen appears (if any UI is present, it will still
    be possible for the player to press on it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find out more about `timeScale` here in the official documentation
    for Unity: [https://docs.unity3d.com/ScriptReference/Time-timeScale.html](https://docs.unity3d.com/ScriptReference/Time-timeScale.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Save the `GameManagerScript`, and let's explore when to trigger this function
    in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping track of the game's progress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Keeping track of the game''s progress is one of the fundamental functions of
    a Game Manager. So, the first thing we want to ask is: what should we keep track
    of?'
  prefs: []
  type: TYPE_NORMAL
- en: Definitely not the sugar possessed by the player, since it is separately handled
    within the Sugar Meter and the trading scripts. What about the player's health?
    Well, we do indeed want to keep track of it. In fact, when the player loses his/her
    health, the game ends as well, and the `Game Manager` needs to handle this case.
    What else? The `Game Manager` needs to keep track of how many Pandas the player
    shoots down, because in this way, the game manager is able to determine when the
    player wins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the first thing we need to do is to get a reference to the health of
    the player. We can add the following variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can initialize it in the `Start()` function, by adding this line at the
    beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need a variable to keep track of how many Pandas there are still to
    defeat, hence we can add the following variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It will be initialized by our spawning system, which we will implement soon.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to implement a couple of functions, which will be called, respectively,
    when a Panda is shot down, and when the player loses his/her health.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first, we don''t need any parameters or return values, since the `Game
    Manager` just acknowledges that a Panda has been shot down by decreasing the number
    of Pandas that still need to be defeated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Regarding the second function, we want to create a hub of communication between
    the Panda that is eating the cake and the player''s health. As such, we need to
    implement a function that takes the damage of the Panda as a parameter and subtract
    it from the player''s health. Then, it checks if the player is still alive, because
    if he/she is not, the `GameOver` function is triggered. In either case, at the
    end we need to decrease the number of Pandas still to defeat, because we remember
    that Pandas eat so much cake that they explode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Save the script, and open the `PandaScript` since now we need to slightly modify
    it. In particular, we need to call the functions just created in the `Game Manager`.
    From [Chapter 6](part0077.xhtml#aid-29DRA1 "Chapter 6. Through a Sea of Sprinkles
    – Navigation in Artificial Intelligence"), *Through a Sea of Sprinkles – Navigation
    in Artificial Intelligence*, we already have a reference to the `Game Manager`,
    which we can use to trigger these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first modification is to add the following variable to determine how much
    cake this specific Panda can eat when it bites (its value needs to be set in the
    Inspector, don''t forget it!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The second modification is in the `FixedUpdate()` function. In fact, we need
    to detract health from the player by using the `BiteTheCake()` function in the
    `Game Manager`. The highlighted part is what we have modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The third and last modification is in the `Hit()` function, in which we also
    need to trigger the `OneMorePandaInHeaven()` function of the Game Manager. We
    can do it in the following way (again the highlighted part is what is changed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Save the script, because we are going to explore how the Pandas are created/spawned
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Panda invasion – spawning Pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement the spawning system of the game. This can
    be done in many ways. However, since we have only one kind of Panda (at least
    for the moment), we will implement it in a simple way. In any case, we will use
    coroutines to implement the system, and we will see a template structure which
    we might also use in more complex spawning systems (in the next chapter, some
    ideas of more complex spawning systems will be provided).
  prefs: []
  type: TYPE_NORMAL
- en: What is a coroutine?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is a structure that Unity provides to allow functions to be interrupted
    and continued in other frames of the game. In the case of our spawning system,
    we don''t want to spawn all the Pandas at the same time, but a little bit over
    time. This over time can be controlled with coroutines. You can definitely learn
    more and see some examples in the official documentation here: [https://docs.unity3d.com/Manual/Coroutines.html](https://docs.unity3d.com/Manual/Coroutines.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the most important things to know about coroutines are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: They are special functions which have an `IEnumerator` as a return value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be started with the `StartCoroutine()` function and stopped with the
    `StopCourotine()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They cannot run/start within any `Update()` function. The reason is because
    the `Update()` function's nature is to be called one time per frame (or more),
    whereas the coroutine's nature is to run at the time they specify.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They can use a special instruction; yield: It allows them to wait for something,
    such as a fixed amount of time, the end of the frame, or even another coroutine.
    In any case, after the yield, they expect a return value. Common functions that
    are used with yield are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WaitForEndOfFrame()`: Waits until the next frame (official documentation:
    [https://docs.unity3d.com/ScriptReference/WaitForEndOfFrame.html](https://docs.unity3d.com/ScriptReference/WaitForEndOfFrame.html))'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WaitForSeconds()`: Waits a specific amount of time specified in seconds as
    a parameter (official documentation: [https://docs.unity3d.com/ScriptReference/WaitForSeconds.html](https://docs.unity3d.com/ScriptReference/WaitForSeconds.html))'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WaitUntil()`: Waits until a certain condition is met (official documentation:
    [https://docs.unity3d.com/ScriptReference/WaitUntil.html](https://docs.unity3d.com/ScriptReference/WaitUntil.html))'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Moreover, you can even implement custom yield instructions, as shown in the
    official documentation here: [https://docs.unity3d.com/ScriptReference/CustomYieldInstruction.html](https://docs.unity3d.com/ScriptReference/CustomYieldInstruction.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the most curious of you, coroutines are not threads. In fact, coroutines
    run on the same thread as the rest of the game.
  prefs: []
  type: TYPE_NORMAL
- en: It takes time to get used to them, since they are hard to make work when you
    have complex environments, and as such they are often considered as an advanced
    topic. But they unlock many potentialities in what can be done, which is fundamental
    for good gameplay programming. Unfortunately, in this book we don't have enough
    space to dedicate them a proper space, but I hope that with the official documentation,
    this small explanation, and the example of the spawning system in the next section,
    you will be able to better understand coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Sketching the idea of how it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will divide our game into waves. Each wave has a determined number of Pandas,
    which will be spawned over time at an increasing intensity. Once all of the Pandas
    of that wave have been shot down, the game will increase the number of spawned
    Pandas for the next wave and start it. When all the waves are completed by the
    player, the level can be considered as a win.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we will have a cycle in a coroutine which will manage the different
    waves and wait till the end of a wave before starting another one. A second routine
    will take care of the single wave, to spawn Pandas for it, and check when all
    the Pandas have been shot down by the player.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the spawning system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Designers should be provided with a way to place where the Pandas will be spawned.
    As such, we can create an empty game object, and call it `SpawningPoint`. Moreover,
    you can attach to it a gizmo, similar to what we have done with waypoints in the
    previous chapter. As a result, it will be visible in the **Scene** view. So, at
    the end you should have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the spawning system](img/image00603.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the `GameManagerScript` and let''s add a variable to keep track of where
    this `SpawningPoint` is. Since we just need the position, we can just take the
    Transform, instead of the whole game object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To set its value, let''s change the `Start()` function like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we need three more variables. One is for the prefab of the Panda to instantiate
    the right enemy, another is for the number of waves that the player has to face,
    and the last one for the number of Pandas per wave (which will increase between
    waves):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have saved the script, we have to assign the variable in the **Inspector**,
    as shown in the following screenshot (feel free to change the values to suit the
    balance of your game):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the spawning system](img/image00604.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Managing waves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to implement the first of the two coroutines aforementioned.
    In fact, this coroutine will cycle over all the waves, and call the second one
    to handle the single wave. Between waves, the number of spawned enemies is increased.
    If the player has won all the waves, then the `GameOver()` function is called
    in the winning mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, open the `GameManagerScript` and we can start to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the code, we call call the `PandaSpawner()` coroutine, which
    we implement in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The single wave
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now for the tough part. Here we need to write a coroutine that is able to handle
    a whole wave of Pandas. Therefore, let''s look at it step-by-step, starting with
    creating the coroutine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to do is to initialize the `numberOfPandasToDefeat` variable,
    to keep track of how many Pandas the player has defeated so far. Of course, we
    will initialize this number to be the same as the number of Pandas that will be
    spawned in the wave:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to cycle through all the Pandas to spawn, to progressively
    spawn them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the cycle, we need to first spawn the Pandas at their spawned position
    (with no rotation, which means having the identity as a **quaternion**). Then,
    we need to wait for a time that depends both on how many Pandas are left and by
    a random number. In particular, we will calculate the ratio of how many Pandas
    are left, and use it to interpolate between two times. As a result, the greater
    the number of Pandas spawned so far, the less time to wait. Then, this is added
    to a random number, to add a bit of chance in our game. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, this is not the only way to implement this and the numbers in the
    code are arbitrary. In a real game, everything should be decided in order to balance
    the game, by the hard work of designing and play testing. You can find a bit more
    about this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Outside the cycle, instead, we need to wait until all the Pandas have been
    shot down by the player (or some game over conditions have been met) before ending
    the coroutine, and so give back control to the `WavesSpawner()` coroutine for
    the next wave:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Save the script, and as a result, the player has to face many, terrible waves
    of sweet-toothed Pandas!
  prefs: []
  type: TYPE_NORMAL
- en: The main menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in many games, there is a main menu when the game starts, and so, also, in
    our game we cannot forget a main menu. This will give us the possibility to explore
    a bit more of what we have touched upon in [Chapter 1](part0016.xhtml#aid-F8901
    "Chapter 1. A Flat World in Unity"), *A Flat World in Unity*, about changing scenes
    in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the main menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learnt back in [Chapter 3](part0043.xhtml#aid-190861 "Chapter 3. Communicating
    with the Player – the User Interface"), *Communicating with the Player – the User
    Interface*, it's good practice to have a design of the user interface, and the
    main menu is an extension of the user interface. As such, it should be designed
    with the same principles of UI design in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'The menu for our game is very simple: we have a cool background, and three
    buttons placed just below the center of the screen. They are respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NEW GAME**: Creates a new game for the player, by loading the level we have
    been creating so far'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SETTINGS**: Triggers a setting screen, where the player can manipulate some
    options (this is left as an exercise, in the *Homework* section)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QUIT**: As the name suggests, it closes the game'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, our design will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the main menu](img/image00605.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the main menu in another scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create another scene in Unity, you can select **File** | **New Scene** from
    the top bar, but it's preferable to navigate in the **Project** panel within the
    `Scene` folder so that by right-clicking you can select **Create |** ** Scene**.
    In this second way, the scene will be directly created within the right folder;
    as a result, your project is ordered and tidy.
  prefs: []
  type: TYPE_NORMAL
- en: You can name the scene `Main Menu`, and then double-click to open it. And here
    from scratch again, there is an empty void to fill up with your creativity and
    fantasies!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you should have the skills to do the following without a step-by-step
    explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a UI image (which will automatically generate a **Canvas** as well as
    the **Event System**), and name it `Background`. Then, extend it to the whole
    screen, and place the cool background you have in mind.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tweak the canvas settings if you need to achieve what you have in mind.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create three buttons, change their graphics if you want, and their texts so
    to match **NEW GAME**, **SETTINGS**, and **QUIT** respectively. Place them, as
    in the design of the previous section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty GameObject where we will attach a script to handle all the different
    interactions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the three buttons, add an `OnClick()` event and drag the new empty object
    into the `object` variable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the menu is created, we can save the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have two scenes, if we want to include them in the final version of
    the game, we need to include them in the **Scenes In Build**. To do so, we need
    to open the building settings from the top bar menu by clicking on **File** |** Building
    Settings… **. You can drag and drop the scene in the **Scenes In Build** area
    from your **Project** panel, and they will appear there in a determined order.
    The numbers you see next to the scenes are the identifiers of the scene. For instance,
    we can use this identifier to specify which scene to load.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, be sure that the `Main Menu` scene is before our `Level_01`, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the main menu in another scene](img/image00606.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, it's time to create the script with all the functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Loading scenes through scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new script and call it `MainMenuFunctionalities`. Since its functions
    will be triggered by the `OnClick()` event, we need to make them public.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we have a function for loading the level of our game. If you
    remember, its ID is `1`. To load a scene in Unity, you use a special class called
    `SceneManager`. As such, we need to import its library by adding the following
    line of code at the beginning of our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `SceneManager` class along with the `UnityEngine.SceneManagement` library are
    relatively new in Unity. In fact, these allow you to perform many actions on scenes,
    such as loading them together, loading them dynamically, and unloading them, all
    at runtime. This gives you a new universe of possibilities, which I hope you will
    have chance to explore, since in this book we don''t have time to go through everything
    in detail. In any case, a good starting point is, as usual, the official documentation
    that you can find here: [https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html).'
  prefs: []
  type: TYPE_NORMAL
- en: For the more curious of you, before the `SceneManager` class, scenes were handled
    by the `Application` class. So, in case you have some outdated code, which still
    uses the `Application` class to load scenes, you know that it was written for
    previous versions of Unity. If that code belongs to your project, consider (if
    possible, due to legal issues) to update it using the `SceneManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: The most common function of the `SceneManager` class is `LoadScene()`, which
    can load another scene. One way to specify the scene is with its identifier (as
    we will do in our script), but there are also other ways, such as with a string
    containing the name of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement the function that will be called by the **NEW GAME** button
    in the following way, which is really simple and straight forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The function related to the **SETTINGS** button, instead, is left as an exercise
    (see *Homework* section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the function to quit the game uses the `Application` class (more on
    this class in the official documentation here: [https://docs.unity3d.com/ScriptReference/Application.html](https://docs.unity3d.com/ScriptReference/Application.html)),
    where there is a specific function to quit your game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that this function doesn't work in some circumstances, such as
    when the game is running in the editor (in Unity itself), or for instance, for
    web-based games. As such, closing a game that should be shipped on different platforms
    might require more work. More about multi-platform games in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script, and come back to the `OnClick()` events on the three buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign the correct function to each of them. Here is the example of how the
    **NEW GAME** button event should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading scenes through scripts](img/image00607.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: And also, the main menu has been implemented. With this, our game is basically
    completed and functioning. Let's recap what we have done and learnt so far in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Techniques we learnt in this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have reached this point of the chapter and book, it means that your
    game is completed. Let''s recap what we have learnt in terms of techniques, instead
    of topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inheritance**: We have implemented our trading system by using inheritance,
    and this gave us the possibility to explore it. In particular, we learnt a bit
    more about:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstract classes and methods**: So that their full implementation is left
    to child classes'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protected variables**: Which can be seen by some scripts but not all of them'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI handlers**: Can be automatically linked to have an interaction with the
    UI without settings events in the **Inspector**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interaction between mouse and camera**: To implement the placing script,
    we needed to transform the mouse coordinates into game coordinates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enabling/disabling scripts**: To implement functionalities, always in the
    placing script, we learnt how it is possible to disable and enable scripts to
    trigger functionalities when they are needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storing information**: Within the `Game Manager`, we learnt how other scripts
    can have access to them. Throughout all the chapters we have done this, and in
    different ways. In particular, we used public functions on the `Game Manager`
    that have been called by the other scripts. As a result, the **Game Manager**
    became a hub to exchange data between the different parts of the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using static functions**: To assign generic variables again, in the trading
    system, we have implemented a static function to set the active tower. As a result,
    any script can have access to that function without the need to get a reference
    to the specific trading class instance (moreover the parent class is abstract
    so it doesn''t have instances). This could have been done without many problems,
    because the variable assigned was already static and shared among all the instances
    of the trading classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementing coroutines**: To handle events that last over timein implementing
    the spawning system, we have used coroutines. These are special functions which
    have the possibility to be interrupted and continue in other frames of the game.
    This is the most powerful tool we have seen in this chapter, although it requires
    a bit more practice than other tools to master it, but it is definitely worth
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using UI events**: To implement the functions, in our main menu, we have
    implemented functions within a script to be triggered by the `OnClick()` event
    of the buttons. In this way, you avoid using UI handlers. The advantages of this
    method is that you can place all the functions within a single script and have
    a specific instance of that script to trigger (in case the script can be instantiated).
    On the other hand the disadvantage is that a lot of manual work for linking the
    events in the **Inspector** is required. UI handlers, on the contrary, have advantages
    and disadvantages flipped. As such, UI handlers are suitable for big scripts with
    many functions implemented in that which require a bit of interaction with the
    UI. For small functions, instead, it is better to have them all in a single script
    that creates a different script for each one of them. In any case, the best solution
    depends on the situation and which one is your goal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using colliders to identify zones**: We used the physics engine to detect
    if the mouse is hovering over certain zones when placing cupcake towers is allowed.
    Moreover, we used a collider on the cupcake towers to detect a click on it (so
    as to be selected) and to avoid placing other cupcake towers on top of others.
    These are just one of the many ways to use the Physics engine for non-physics
    related calculations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I hope you have learnt a lot in this chapter, and that you have grasped the
    basic concepts of each of the different techniques we have used. To improve both
    the game and your skills, I invite you do the exercises in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Homework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have covered many techniques on how to exchange information
    between different parts of our game, and learnt a bit about gameplay programming.
    Here there are some exercises to improve your skills and become a better game
    developer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sweet capital**: When the the game begins, Pandas start coming and the player
    should buy some cupcake tower to defend his/her cake. But, at the very beginning,
    the player doesn''t have any sugar to buy towers, nor he/she can kill some Pandas
    to get some sugar. Thus, add an initial sugar amount variable in the `Game Manager`
    (so that it can be set from the Inspector), and set this quantity in the `Sugar
    Meter` within the `Start()` function. As a result, the player will be immediately
    ready to fight Pandas.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The calm before the storm**: At this stage, when the game starts, the Pandas
    immediately come to eat the player''s delicious cake. However, the player should
    have the time to buy and place some cupcake towers at the beginning, with the
    capital set from the previous exercise. In the `wavesSpawner()` coroutine, set
    a timer before each wave to give the player the time to assess. Then, expose the
    right variables in the **Inspector**, so as to tweak the timer depending on the
    level. Consider, as a variant, that you can increase or decrease such a timer
    between waves.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Wave bonus (Part I)**: If you are planning to increase the number of Pandas
    spawned significantly between waves, then you should consider rewarding the player
    with some sugar once the wave is completed. Modify the `wavesSpawner()` coroutine
    to include a sweet bonus for the player. Then, expose the right variables in the
    Inspector to tweak the bonus for each level.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Wave bonus (Part II)**: After have done the previous exercise, make an array
    of bonuses, where its dimension changes according to the number of waves. Then,
    at the end of each wave, assign the right bonus to the player, so as to have the
    possibility to tweak the bonus not only for each level, but also for each wave.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Singleton pattern (Part I)**: In our game, there are some scripts that should
    have a single instance at the time, such as the `Game manager`, the `Health Bar`,
    or the `Sugar Meter`. As such, it''s best practice to make them unique, since
    some of our scripts rely on the implicit (but not granted) fact that there is
    only one instance of such classes. Therefore, you should implement a pattern called
    **singleton**. You can definitely search on the Internet how to implement it,
    but try to come up with your own personal solution. Many online implementations
    rely on a static variable to retrieve the single instance of the class. Since
    our script will find these classes with the `FindObjectOfType()` function, you
    can try to explore other ways. So, try to give your solution to the problem and
    implement it for the `GameMangerScript`, the `HealthBarScript`, and the `SugarMeterScript`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Singleton pattern (Part II)**: After Part I, you should have implemented
    the singleton pattern in your way. Now, look at the following two links: [http://wiki.unity3d.com/index.php/Singleton](http://wiki.unity3d.com/index.php/Singleton)
    and [https://unity3d.com/learn/tutorials/projects/2d-roguelike-tutorial/writing-game-manager](https://unity3d.com/learn/tutorials/projects/2d-roguelike-tutorial/writing-game-manager),
    since both implement the singleton pattern. Compare those to the ones you came
    up with, and highlight for each approach, the advantages and the disadvantages.
    Which approach do you think would work better in our game? Does the approach differ
    for the `Game Manager`, the `Health Bar`, or the `Sugar Meter`? Implement the
    singleton pattern you consider worthwhile for our tower defense game.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Improving the allowed areas (Part I)**: We have seen how it is possible to
    use colliders to check if the mouse is hovering over allowed areas, so that the
    placing script knows if it is a suitable place or not when it needs to release
    the cupcake towers. But what happens in the `Game Manager`? Even if there is no
    tower to place, it stills checks for allowed areas and updates its internal state.
    Think about a solution in which the `Game Manager` checks if the mouse is hovering
    over allowed areas only when the placing scripts asks for it. As a result, your
    new solution should improve the performance of the `Game Manager`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Improving the allowed areas (Part II)**: This exercise is independent from
    part I. In the allowed areas system, we have considered only the mouse. What about
    if you want to export the game on a mobile platform, such as on an Android device?
    In this situation, should the allowed area system be completely redesign or changed?
    As such, design and implement a system which is suitable for as many platforms
    as possible.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Improving the allowed areas (Part III)**: This exercise is independent from
    Parts I and II. The system of allowed areas we came up with is not really easy
    to use for a multi-level game (something that, most likely, you have), since you
    cannot place colliders in the `Game Manager Prefab` as they depend on the particular
    level. Can you think of an easier solution for level designers to tell the `Game
    Manager` which areas are allowed, level by level? Once you have designed such
    a system, implement it in our tower defense game.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Improving the allowed areas (Part IV)**: Consider all the solutions you have
    found for the different problems faced in Parts I, II, and III. Try to merge them
    together into an ultimate solution for the allowed areas. The goal is to create
    a system which is efficient (from a computational point of view), easy-to-use
    (for game and level designers), and multi-platform (so as to deploy the game on
    more than one platform) at the same time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Feedback to the player (Part I)**: This is a series of exercises all independent
    of each other, and they aim to improve the feedback that the game provides to
    the player, which is of vital importance for a game to be appealing. When the
    player trades, he/she sells, buys, or upgrades towers, but there is no feedback
    that the operation was a success. Therefore, you need to implement some visual
    feedback. Consider the following as smaller exercises:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When sugar is detracted or added to the `Sugar Meter`, add an animation so that
    a big number appears on the `Sugar Meter` showing the quantity that changed. Moreover,
    consider changing the color of this number based on the amount, and whether it
    is added or subtracted.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the sugar is detracted or added to the `Sugar Meter`, add an animation
    to show the numbers of the `Sugar Meter` changing, instead of suddenly changing
    the number displayed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When a tower is upgraded, consider placing an animation that plays on the tower.
    Same for when the tower is sold or placed (after have bought it).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feedback to the player (Part II)**: This is a series of exercises all independent
    of each other, and they aim to improve the feedback that the game provides to
    the player, which is of vital importance for a game to be appealing.When the player
    trades, he/she sells, buys, or upgrades towers, but there is no feedback about
    what the operations are going to do/change, such as: which one is the price of
    buying a tower? Therefore, you need to implement some visual feedback. Consider
    the following as smaller exercises:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the player hovers over one of the trading buttons, make the price (or the
    value in case of the selling button) appear somewhere (which needs to be decided
    carefully, since it impacts the design we did in [Chapter 3](part0043.xhtml#aid-190861
    "Chapter 3. Communicating with the Player – the User Interface"), *Communicating
    with the Player – the User Interface*), so the player can read it before, to perform
    the action.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When no tower is selected, both the selling and the upgrading buttons shouldn't
    be displayed as active. Change this, to display a disable button when the `currentActiveTower`
    variable is null.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementing a setting menu (Part I)**: In this chapter, we left this as
    an exercise, so let''s see what we need to do. The first thing to decide is what
    settings the player can change and how (a toggle? A slider? A drop-down menu?).
    In particular, you should have at least an audio toggle, and a quality settings
    drop-down menu, plus any options you would like to include. Then, make a complete
    design of the UI. Finally, in Unity create a new scene (or screen, whichever you
    prefer) and implement the settings screen by using UI elements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implementing a setting menu (Part II)**: In Part I, we did the design and
    implemented it within Unity. Now, we need to implement the functionalities (except
    the audio for now, which is left for the next chapter). So, create a script, and
    similar to what we did with the main menu, implement all the functionalities there,
    and link them to the UI elements through the use of events in the **Inspector**.
    To modify the quality settings and the audio settings, search the official documentation
    on how to do it (this is part of the exercise). Moreover, keep in mind that the
    next chapter might give you some other ideas of the kind of settings to implement.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Magic numbers (Part I)**: We already have encountered magic numbers in the
    previous chapters. They are numbers that appear within a script and without an
    explanation, and good practice says that it is better to avoid them as much as
    possible. Also in this chapter, we have left many of them; let''s try to remove
    them. The first magic number is the number *7* from the placing script when we
    create a new vector for the position of our tower. This number depends on the
    position of the camera and where the tower should be placed along the *z*-axis.
    As such, add some lines of code to calculate this number in a dynamic way (so
    if we decide to change the camera position or the *z*-depth of the towers, we
    can do it without changing the script, as a bonus, you will have the possibility
    of also having different kinds of towers on different z-depth layers, which can
    be useful to you in the same way). In particular, you need to subtract the *z*-axis
    of the tower from the *z*-axis of the camera.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Magic numbers (Part II)** : We have also left some magic numbers in the `Upgrade()`
    function of the `CupcakeTowerScript`. Create variables that can be set in the
    **Inspector**, to remove any magic numbers that are left (such as increasing the
    selling value or the upgrade cost).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored many techniques to exchange information and
    data between different scripts. In doing so, we have finished the implementation
    of our tower defense game.
  prefs: []
  type: TYPE_NORMAL
- en: The Pandas walk towards the player's cake to eat it, the cupcake towers shoot
    at them, and so Pandas die and they are periodically spawned as well. The player
    can buy, sell, and upgrade cupcake towers. A main menu is present and the player
    can either win or lose. So, our game is complete. Or is it not? Can we go even
    further? Let's find it out in the next chapter.
  prefs: []
  type: TYPE_NORMAL
