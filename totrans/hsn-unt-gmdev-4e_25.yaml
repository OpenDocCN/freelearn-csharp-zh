- en: '21'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '21'
- en: 'Massive Worlds: Introduction to DOTS'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 巨大世界：DOTS简介
- en: While Unity is a powerful and performant engine (when used properly), there’s
    a limit on how many GameObjects you can have without reaching performance limits.
    While the **Object-Oriented Programming** (**OOP**) paradigm provides a convenient
    way to code a game, due to its internal works, it won’t always take advantage
    of all the modern CPU features, like caching, **Single Instruction Multiple Data**
    (**SIMD**) operations, and multi-threading. While it isn’t impossible to use such
    features in OOP, doing so is not a trivial task and can lead to difficult-to-track
    bugs. Unity’s response to that issue was releasing the first production-ready
    version of the DOTS packages, which will help us with these problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Unity是一个强大且性能良好的引擎（当正确使用时），但你拥有的GameObject数量有限，否则会达到性能限制。虽然**面向对象编程**（**OOP**）范式提供了一种方便的方式来编写游戏，但由于其内部工作方式，它并不总是能充分利用所有现代CPU功能，如缓存、**单指令多数据**（**SIMD**）操作和多线程。虽然在OOP中使用这些功能并非不可能，但这样做并非易事，可能会导致难以追踪的bug。Unity针对该问题的解决方案是发布第一个生产就绪版本的DOTS包，这将帮助我们解决这些问题。
- en: 'In this chapter, we will examine the following build concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下构建概念：
- en: Understanding what DOTS is
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解DOTS是什么
- en: Creating our first DOTS game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个DOTS游戏
- en: Creating gameplay in DOTS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在DOTS中创建游戏玩法
- en: Let’s start by getting an idea of what DOTS is and why we should use it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解一下DOTS是什么以及为什么我们应该使用它。
- en: Understanding what DOTS is
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解DOTS是什么
- en: 'The Unity Data-Oriented Technology Stack (DOTS) is a set of Unity packages
    that allows us to write data-oriented code easily. While there are plenty of packages
    in the DOTS stack, let’s focus on the three key ones that serve as pillars for
    the rest:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Unity数据导向技术堆栈（DOTS）是一组Unity包，使我们能够轻松编写数据导向的代码。虽然DOTS堆栈中有许多包，但让我们专注于三个关键的包，它们是其余部分的支柱：
- en: '**Entities:** Unity takes on the ECS pattern. It replaces GameObjects and MonoBehaviours
    with Entities, Components, and Systems (ECS, a paradigm in Unity that separates
    data (components) from logic (systems), enhancing performance and scalability),
    a cache-friendly way to store and update our scene objects. It provides considerable
    performance boosts, especially in games with lots of objects.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体**：Unity采用ECS模式。它用实体、组件和系统（ECS，Unity中一种将数据（组件）与逻辑（系统）分离的范式，增强性能和可扩展性）替换GameObject和MonoBehaviours，这是一种缓存友好的方式来存储和更新我们的场景对象。它提供了相当大的性能提升，尤其是在拥有大量对象的游戏中。'
- en: '**Jobs:** The Unity way to create multi-threaded code. It groups data and code
    that processes jobs. They are executed in parallel thanks to the job scheduler,
    which guarantees that explicit dependencies between jobs are respected. This avoids
    classic multi-threading issues like deadlocks and race conditions. Unity uses
    Jobs to boost the performance of its different systems, like rendering or physics.
    It cannot be applied to regular MonoBehaviour methods like Update without significant
    modifications, but entities are highly compatible with jobs.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作业**：Unity创建多线程代码的方式。它将处理作业的数据和代码分组。它们在作业调度器的并行执行下运行，该调度器保证尊重作业之间的显式依赖关系。这避免了经典的多线程问题，如死锁和竞态条件。Unity使用作业来提高其不同系统的性能，如渲染或物理。它不能应用于未经重大修改的常规MonoBehaviour方法，如Update，但实体与作业高度兼容。'
- en: '**Burst**: A code compiler capable of converting C# scripts to highly optimized
    native code. It uses LLVM, which applies advanced optimizations when compiling.
    The code to convert needs to use a subset of C#, called **High Performant C#**
    (**HPC**#), so it cannot be applied to any script without (sometimes) considerable
    modification.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Burst**：一种代码编译器，可以将C#脚本转换为高度优化的本地代码。它使用LLVM，在编译时应用高级优化。要转换的代码需要使用C#的一个子集，称为**高性能C#**（**HPC**#），因此它不能应用于任何脚本而不进行（有时）相当大的修改。'
- en: While these packages can be used separately (especially the Jobs and Burst packages),
    the idea is to mix them to parallelize our game logic written in ECS using Jobs,
    while Burst makes it run as fast as possible. The other DOTS packages provide
    different features like rendering (Entities Graphics), physics (Unity Physics
    and Havok), and networking (Netcode for Entities).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些包可以单独使用（尤其是作业和突发包），但想法是将它们混合起来，以并行化我们使用作业编写的ECS游戏逻辑，同时Burst使其尽可能快地运行。其他DOTS包提供不同的功能，如渲染（实体图形）、物理（Unity物理和Havok）和网络（实体网络代码）。
- en: 'All of this sounds great and exciting, but there are some caveats when using
    this technology. Here’s a list of the most important ones:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都听起来很棒，但使用这项技术时有一些注意事项。以下是最重要的几点：
- en: It’s a fundamental change from the GameObject approach. This means that you
    must relearn how to do the same things you are already comfortable doing with
    GameObjects and MonoBehaviours.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是从GameObject方法的基本转变。这意味着你必须重新学习如何做你已经习惯用GameObject和MonoBehaviours做的事情。
- en: The learning curve can be steep, depending on your programming experience. This
    is caused by the limited C# features available due to HPC#, custom APIs to learn,
    and the multi-threaded nature of its code. Even if the Jobs package is easy to
    use, it adds challenges that aren’t present in single-thread code.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习曲线可能很陡峭，这取决于你的编程经验。这是由于HPC#的限制导致的C#功能有限，需要学习自定义API，以及其代码的多线程特性。即使Jobs包易于使用，它也增加了单线程代码中不存在的挑战。
- en: It’s in its early stages. It’s likely that its API will change considerably
    in the short term (for the better!). Luckily, the data-oriented principles won’t
    change, meaning that we won’t need to relearn them again, just the APIs involved.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还处于早期阶段。短期内其API可能发生重大变化（变得更好！）幸运的是，面向数据的原则不会改变，这意味着我们不需要再次学习它们，只需学习相关的API。
- en: Some GameObjects features aren’t available in DOTS yet, like UI, audio, terrain,
    or animations. For now, you need to implement such features in GameObjects and
    synchronize them with their respective entities. It is a hard endeavor that requires
    several custom solutions.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些GameObject功能在DOTS中尚不可用，如UI、音频、地形或动画。目前，您需要在GameObject中实现这些功能，并将它们与其相应的实体同步。这是一项艰巨的任务，需要几个自定义解决方案。
- en: 'Regardless, these obstacles didn’t stop ambitious games from being made with
    DOTS, like V-Rising and Cities Skylines 2\. The idea of discussing DOTS’ caveats
    is not to intimidate but to understand when it is justified to use it. The games
    I just mentioned are great examples of where DOTS shines, given that those games
    simulate huge worlds with lots of objects. Here’s a non-comprehensive list of
    games that could benefit from using DOTS:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不论如何，这些障碍并没有阻止使用DOTS制作雄心勃勃的游戏，如V-Rising和Cities Skylines 2。讨论DOTS的注意事项的目的不是恐吓，而是理解何时使用它是合理的。我刚才提到的游戏是DOTS发光的绝佳例子，因为这些游戏模拟了拥有大量对象的大型世界。以下是一个不全面的列表，列出了可能从使用DOTS中受益的游戏：
- en: Big worlds with several objects that require complex simulation logic to run
    in a performant way. Some examples of this are massively multiplayer online games
    (MMOs), city-builder games, or big RPGs that simulate vast worlds like Cyberpunk
    2077 or Assassin’s Creed.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要复杂模拟逻辑以高效运行的大型世界和多个对象。此类示例包括大型多人在线游戏（MMOs）、城市建造游戏或模拟庞大世界的RPG，如Cyberpunk 2077或刺客信条。
- en: Complex simulations require real-life behavior, like wind-tunnel simulations,
    architecture visualization, or even galaxy star simulations.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的模拟需要现实生活中的行为，如风洞模拟、建筑可视化，甚至星系星模拟。
- en: Specific features of a GameObjects-based game can use DOTS, like a crowd in
    a football stadium or complex particle systems. DOTS and GameObjects can coexist
    in the same game.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于GameObject的游戏的特定功能可以使用DOTS，例如足球场的观众群或复杂的粒子系统。DOTS和GameObject可以在同一游戏中共存。
- en: On the other hand, simple games that run properly with GameObjects don’t need
    the difficulties and current limitations of DOTS. For example, fighting games
    that require two main objects (the fighters) and a minimal environment are not
    good candidates. Other examples are casual open-world exploration games like Firewatch,
    which, even if they feature big landscapes to explore, have a simple enough logic
    to get away with some clever tricks using GameObjects. In the end, Firewatch was
    made without DOTS.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，运行良好的简单游戏不需要DOTS的困难和当前限制。例如，需要两个主要对象（战斗者）和最小环境的格斗游戏不是好的候选者。其他例子是像Firewatch这样的休闲开放世界探索游戏，即使它们有探索的大型景观，但逻辑足够简单，可以通过使用GameObject的一些巧妙技巧来应对。最终，Firewatch没有使用DOTS。
- en: These limitations will be sorted in the future, making all types of games using
    DOTS viable, but for now, let’s avoid starting a project in a way that might risk
    its development. I’m not saying that DOTS is risky, but I want to be clear that
    not every game is worth the effort and pitfalls of relearning a new tech from
    scratch.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制将在未来得到解决，使得所有类型的游戏使用DOTS都变得可行，但到目前为止，让我们避免以可能风险其开发的方式开始一个项目。我并不是说DOTS是危险的，但我想清楚地表明，并不是每个游戏都值得从头开始重新学习新技术所付出的努力和风险。
- en: If, after careful consideration and research, you think your future project
    might benefit from using DOTS, then stick with us; in the next section, we are
    going to learn how DOTS works by doing a simple introductory project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经过仔细考虑和研究后认为你的未来项目可能从使用 DOTS 中受益，那么请继续跟随我们；在下一节中，我们将通过一个简单的入门项目来学习 DOTS 的工作原理。
- en: Creating our first DOTS game
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建第一个 DOTS 游戏
- en: There is plenty to learn in order to create performant games with DOTS, so let’s
    start by creating a simple project featuring cubes moving forward. Emphasis on
    cubes – we are going to have thousands of them! I know it is not the most exciting
    project, but bear with me, as in the *Creating Gameplay in the DOTS* section in
    this chapter, we will convert it into an actual (but simple) game.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建具有高性能的 DOTS 游戏，有很多东西需要学习，所以让我们从一个简单的项目开始，该项目包含向前移动的立方体。强调立方体——我们将拥有成千上万个！我知道这不是最令人兴奋的项目，但请耐心等待，因为在本章的*在
    DOTS 中创建游戏玩法*部分，我们将将其转换成一个实际（但简单）的游戏。
- en: 'In this section, we will examine the following DOTS concepts:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下 DOTS 概念：
- en: Creating a DOTS project
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 DOTS 项目
- en: Creating entities with subscenes
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用子场景创建实体
- en: Creating components and bakers
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建组件和烘焙器
- en: Creating systems using Jobs and Burst
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工作（Jobs）和爆发（Burst）创建系统
- en: Debugging systems jobs and queries
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试系统工作（jobs）和查询（queries）
- en: Let’s start by discussing how to set up a project to be compatible with DOTS.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论如何设置一个与 DOTS 兼容的项目。
- en: Creating a DOTS project
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 DOTS 项目
- en: 'The first step for creating a DOTS project is the one you should already know
    by this point in the book: creating a brand-new URP project. If you are not sure
    how to do it, please refer to *Chapter 1*, *Embark on Your Unity Journey*. Make
    sure you are using the **3D (URP)** template, as DOTS is only compatible with
    URP and HDRP, and we didn’t cover HDRP in this book. You can also add DOTS to
    an existing project if needed.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 DOTS 项目的第一步是你应该在本章的这个阶段已经知道的：创建一个全新的 URP 项目。如果你不确定如何操作，请参阅*第 1 章*，*踏上你的 Unity
    之旅*。确保你使用的是**3D (URP**)模板，因为 DOTS 只与 URP 和 HDRP 兼容，而本书没有涵盖 HDRP。如果需要，你也可以将 DOTS
    添加到现有项目中。
- en: 'Now, it’s time to install the needed DOTS packages. We mentioned that there
    are three key packages: Entities, Jobs, and Burst, and we also mentioned that
    the rest of the packages are built on top of them. Aside from those packages,
    we need **Entities Graphics** to render our entities. Given that this package
    has dependencies on the core DOTS packages, just installing it will bring the
    holy three packages.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候安装所需的 DOTS 包了。我们提到有三个关键包：实体（Entities）、工作（Jobs）和爆发（Burst），我们也提到其余的包都是基于它们构建的。除了这些包之外，我们还需要**实体图形（Entities
    Graphics**）来渲染我们的实体。鉴于这个包依赖于核心 DOTS 包，只需安装它就会带来神圣的三个包。
- en: 'If you don’t remember how to install packages, please refer to the *Installing
    ProBuilder* section from *Chapter 3*,*From Blueprint to Reality: Building with
    Terrain and ProBuilder*. Those instructions install the **ProBuilder** package,
    but the steps can be extrapolated to install this one. At the time of writing
    this chapter, **Entities Graphics** is in version 1.0.16.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了如何安装包，请参阅*第 3 章*的*从蓝图到现实：使用地形和 ProBuilder 构建*中的*安装 ProBuilder*部分。那些说明安装了**ProBuilder**包，但步骤可以推广到安装这个包。在撰写本章时，**实体图形**版本为
    1.0.16。
- en: '![](img/B21361_21_01.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_01.png)'
- en: 'Figure 21.1: Installing Entities Graphics and also the Entities package as
    a dependency'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.1：安装实体图形以及作为依赖的实体包
- en: You might receive a message about the **Burst** package being updated, which
    might cause Unity to be unstable. As usual, restart Unity when installing a new
    package to fix the issue.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会收到有关**Burst**包更新的消息，这可能会导致 Unity 不稳定。像往常一样，在安装新包时重新启动 Unity 以修复问题。
- en: 'The next thing to do is to change the URP settings to use Forward+, a new URP
    rendering path that is utilized by DOTS for rendering. Do the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是更改 URP 设置以使用 Forward+，这是 DOTS 用于渲染的新 URP 渲染路径。执行以下操作：
- en: 'Select the currently used SRP asset as explained in the *Configuring performant
    shadows* section of *Chapter 12*, *Enlightening Worlds: Illuminating Scenes with
    the Universal Render Pipeline*. In my case, the asset is called **URP-HighFidelity**,
    so you can also search for it by name in the **Project** panel.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择当前使用的 SRP 资产，如*第 12 章*的*配置高性能阴影*部分中所述。在我的情况下，该资产被称为**URP-HighFidelity**，因此你也可以在**项目**面板中通过名称搜索它。
- en: '![](img/B21361_21_02.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_02.png)'
- en: 'Figure 21.2: Seeing the current SRP asset in use.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.2：查看当前SRP资源的使用情况。
- en: In the **Renderer List** of the SRP asset, double-click its first element to
    select the renderer asset. In my case, it is called **URP-HighFidelity-Renderer**,
    so again, you can just search it in the **Project** panel.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在SRP资源的**渲染器列表**中，双击其第一个元素以选择渲染器资源。在我的情况下，它被称为**URP-HighFidelity-Renderer**，所以再次，你可以在**项目**面板中搜索它。
- en: '![](img/B21361_21_03.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_21_03.png)'
- en: 'Figure 21.3: Selecting the Renderer asset used by the SRP asset'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.3：选择SRP资源使用的渲染器资源
- en: In the renderer asset, set the **Rendering Path** option to **Forward+**.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染器资源中，将**渲染路径**选项设置为**Forward+**。
- en: '![](img/B21361_21_04.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_21_04.png)'
- en: 'Figure 21.4: Activating Forward+ as the current rendering path'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.4：激活Forward+作为当前渲染路径
- en: Press the **Play** button in the editor to make sure everything works fine.
    If you see a warning message in the console like the one in *Figure 21.5*, make
    sure you are modifying the proper asset. The console message will tell you the
    name of the asset to change.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中按下**播放**按钮以确保一切正常工作。如果你在控制台看到像*图21.5*中的警告消息，请确保你正在修改正确的资源。控制台消息将告诉你需要更改的资源名称。
- en: '![](img/B21361_21_05.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_21_05.png)'
- en: 'Figure 21.5: Warning message when playing a DOTS project and not using Forward+'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.5：在播放DOTS项目且未使用Forward+时的警告消息
- en: Consider that the other URP renderer assets might be used if the game allows
    changing the quality settings if the game features an options menu. In such a
    case, change all renderer assets to use Forward+.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到如果游戏允许更改质量设置并且游戏具有选项菜单，可能还会使用其他URP渲染器资源。在这种情况下，将所有渲染器资源更改为使用Forward+。
- en: 'A discussion about Forward+ is beyond the scope of this chapter. For more info,
    check the following link: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/rendering/forward-plus-rendering-path.html](mailto:https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/rendering/forward-plus-rendering-path.html)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Forward+的讨论超出了本章的范围。更多信息，请查看以下链接：[https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/rendering/forward-plus-rendering-path.html](mailto:https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/rendering/forward-plus-rendering-path.html)
- en: There is an extra step that is not necessary for DOTS to work, but that will
    make the editor experience faster. Just go to **Edit | Project Settings | Editor**
    and check the **Enter Play Mode Options** checkbox. This will avoid the costly
    domain reload process that happens whenever we play a game in the editor. While
    this might be necessary in GameObject-based projects, pure DOTS projects can avoid
    it. Enable this option when doing a hybrid DOTS game.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个额外的步骤对于DOTS工作不是必需的，但它会使编辑器体验更快。只需转到**编辑 | 项目设置 | 编辑器**并勾选**进入播放模式选项**复选框。这将避免在编辑器中每次播放游戏时发生的昂贵域重新加载过程。虽然这可能对于基于GameObject的项目是必要的，但纯DOTS项目可以避免它。在制作混合DOTS游戏时启用此选项。
- en: 'There are ways to use the Play Mode Options in GameObject projects. Check the
    following documentation link for more info: [https://docs.unity3d.com/Manual/ConfigurableEnterPlayMode.html](https://docs.unity3d.com/Manual/ConfigurableEnterPlayMode.html)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有方法可以在GameObject项目中使用播放模式选项。查看以下文档链接以获取更多信息：[https://docs.unity3d.com/Manual/ConfigurableEnterPlayMode.html](https://docs.unity3d.com/Manual/ConfigurableEnterPlayMode.html)
- en: Now that we have our project properly set up, let’s create our first entity.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确设置了项目，让我们创建我们的第一个实体。
- en: Creating entities with subscenes
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用子场景创建实体
- en: While entities work differently from GameObjects, you are still going to use
    GameObjects to create entities in the editor. The idea is to use the familiar
    Unity tools you are used to working with, like the **Scene**, **Hierarchy**, and
    **Inspector** panels, and even Prefabs. This works by converting specific GameObjects
    and their components into their entity equivalents. We will also instantiate entities
    via scripting later in this chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实体与GameObject的工作方式不同，但你仍然会在编辑器中使用GameObject来创建实体。想法是使用你熟悉的Unity工具，如**场景**、**层次结构**和**检查器**面板，甚至预制体。这是通过将特定的GameObject及其组件转换为它们的实体等效物来实现的。我们将在本章后面通过脚本实例化实体。
- en: To convert GameObjects to entities in the editor, we are going to use the baking
    system. It uses bakers – scripts responsible for converting specific components
    to their entities’ equivalents. Some DOTS packages come with bakers to convert
    specific Unity components; for example, Entities Graphics has bakers to convert
    the `MeshFilter` and the `MeshRenderer` components to their entities’ versions.
    The converted versions might differ considerably from the original ones, and usually,
    one component can be converted to several ECS components. If you don’t install
    the Entities Graphics package, `MeshFilter` and `MeshRenderer` will be discarded
    when converting them, as there’s no baker in the project for them, making your
    entity not be rendered. Later in this chapter, we will create our own bakers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要在编辑器中将GameObject转换为实体，我们将使用烘焙系统。它使用烘焙器——负责将特定组件转换为其实体等效的脚本。一些DOTS包附带烘焙器以转换特定的Unity组件；例如，Entities
    Graphics 包含将`MeshFilter`和`MeshRenderer`组件转换为其实体版本的烘焙器。转换后的版本可能与原始版本有很大差异，通常一个组件可以转换为多个ECS组件。如果您没有安装Entities
    Graphics包，`MeshFilter`和`MeshRenderer`在转换时将被丢弃，因为项目中没有为它们提供烘焙器，这将导致您的实体无法渲染。在本章的后面部分，我们将创建自己的烘焙器。
- en: The way to tell Unity which GameObjects should be converted is via a subscene,
    which is another scene that will contain just the GameObjects to convert. The
    idea is for a main scene to load the entities subscene by using the SubScene component,
    which is responsible for converting and loading the entities in the subscene.
    Note that the conversion happens in the editor, meaning that no conversion happens
    when playing the game from a build. This allows loading subscenes extremely fast,
    thanks to the way scenes are serialized.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉Unity哪些GameObject应该被转换的方法是通过子场景，这是一个将仅包含要转换的GameObject的另一个场景。主要场景通过使用负责转换和加载子场景中的实体的SubScene组件来加载实体子场景。请注意，转换发生在编辑器中，这意味着在从构建中玩游戏时不会发生转换。这允许通过场景序列化的方式快速加载子场景。
- en: 'To create a subscene, do the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建子场景，请执行以下操作：
- en: In an existing scene, right-click in any empty space of the Hierarchy and select
    the **New Sub Scene | Empty Scene** option. If you see the option grayed out,
    make sure to save the main scene first.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有场景中，在层次结构中的任何空白空间处右键单击，并选择**New Sub Scene | Empty Scene**选项。如果您看到该选项变灰，请确保首先保存主场景。
- en: '![](img/B21361_21_06.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_06.png)'
- en: 'Figure 21.6: Creating a subscene'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.6：创建子场景
- en: In the save-file prompt, save the subscene like you save a regular scene.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在保存文件提示中，像保存常规场景一样保存子场景。
- en: This will create a GameObject with the **SubScene** component in the main scene.
    It will have the Scene Asset property set to reference the subscene file we created.
    If the **New Sub Scene** option is not available, create the subscene asset and
    GameObject manually until it looks like *Figure 21.7*.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在主场景中创建一个带有**SubScene**组件的GameObject。它将具有Scene Asset属性设置为引用我们创建的子场景文件。如果**New
    Sub Scene**选项不可用，手动创建子场景资产和GameObject，直到它看起来像*图21.7*。
- en: '![](img/B21361_21_07.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_07.png)'
- en: 'Figure 21.7: A subscene component that loads the subscene asset we just created'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.7：加载我们刚刚创建的子场景资源的子场景组件
- en: Make sure the checkbox of the subscene GameObject in the Hierarchy is checked,
    as it allows you to edit the subscene and add objects to it.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在层次结构中子场景GameObject的复选框被勾选，因为它允许您编辑子场景并向其中添加对象。
- en: Create a cube using **GameObject | 3D Object | Cube** and drag it inside the
    subscene in the Hierarchy. Make sure you create it inside the subscene by noting
    the indentation seen in *Figure 21.8*. If it is created outside the subscene,
    the cube will look right, but because it is still a regular GameObject.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**GameObject | 3D Object | Cube**创建一个立方体，并将其拖动到层次结构中的子场景内。确保您在子场景内创建它，注意*图21.8*中看到的缩进。如果它是在子场景外创建的，立方体看起来是正确的，但因为它仍然是一个常规的GameObject。
- en: '![](img/B21361_21_08.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_08.png)'
- en: 'Figure 21.8: Indentation that shows that the Cube is inside the subscene'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.8：显示立方体位于子场景内的缩进
- en: To confirm the cube was converted, select it and check if the **Entity Baking
    Preview** is at the bottom of the **Inspector**. Click it to show a list of ECS
    components converted from the cube’s original components.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要确认立方体已被转换，选择它并检查**Inspector**底部的**Entity Baking Preview**。点击它以显示从立方体的原始组件转换而来的ECS组件列表。
- en: '![](img/B21361_21_09.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_09.png)'
- en: 'Figure 21.9: Entity Baking Preview showing the ECS components created from
    your original Cube'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.9：显示从您的原始立方体创建的ECS组件的Entity Baking Preview
- en: Make sure the scene camera is pointing to the cube, and then play the game.
    You must see the cube being rendered in the **Game** panel. Make sure that the
    camera is not inside the subscene; we need it to be a classic GameObject.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保场景相机指向立方体，然后开始游戏。你必须看到立方体在 **游戏** 面板中被渲染。确保相机不在子场景内部；我们需要它成为一个经典的 GameObject。
- en: And that’s it! You created your very first entity! Of course, it doesn’t do
    anything fancy, but now we are ready to add custom behavior to it, starting by
    adding ECS components.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你已经创建了你的第一个实体！当然，它并没有做什么特别的事情，但现在我们可以开始添加自定义行为到它上面，首先是通过添加 ECS 组件。
- en: Creating components and bakers
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建组件和烘焙器
- en: Before creating ECS components, let’s discuss how they differ from GameObject
    components. Think of GameObject components as individual tools in a toolbox –
    each one is designed for a specific task, like rendering shapes or detecting collisions.
    They work independently but together create the functionality of an object in
    your game. On the other hand, ECS components are more like raw materials in a
    factory line; they don’t do anything on their own. Instead, they are efficiently
    processed and assembled by systems to create the desired behavior. This shift
    from using individual tools (GameObject components) to processing raw materials
    (ECS components) enables Unity to optimize game performance, especially in complex
    scenes with many objects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 ECS 组件之前，让我们先讨论一下它们与 GameObject 组件的不同之处。将 GameObject 组件想象成一个工具箱中的单个工具——每个工具都是为了特定的任务而设计的，比如渲染形状或检测碰撞。它们独立工作，但共同构成了你在游戏中对象的功能。另一方面，ECS
    组件更像是工厂生产线上的原材料；它们本身不执行任何操作。相反，它们被系统高效地处理和组装，以创建所需的行为。这种从使用单个工具（GameObject 组件）到处理原材料（ECS
    组件）的转变，使得 Unity 能够优化游戏性能，尤其是在包含许多对象的复杂场景中。
- en: While we still want to add components to entities to add behavior to them, the
    responsibilities of ECS components are limited to holding only data. This means
    they won’t have Updates or other events like `OnTriggerEnter`; it’s just pure
    data. They can have methods to facilitate operating on that data but not the core
    gameplay logic.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们仍然想要向实体添加组件以添加行为，但 ECS 组件的责任仅限于仅持有数据。这意味着它们不会有 Updates 或其他事件，如 `OnTriggerEnter`；它们只是纯粹的数据。它们可以有方法来方便地操作这些数据，但不能是核心游戏逻辑。
- en: You might be wondering where our logic will be placed then, and the answer is
    systems. We will create them later in this chapter, but first, let’s add the entity
    data required for our gameplay logic to work.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道我们的逻辑将放在哪里，答案是系统。我们将在本章后面创建它们，但首先，让我们添加我们的游戏逻辑所需的工作实体数据。
- en: With data, I am referring to variables like our character’s bullets, the score,
    health points, position, and so on. We usually create fields in `MonoBehaviours`
    for such purposes, and here’s no different, but this time, we won’t use classes
    that inherit from `MonoBehaviour`. Instead, we are going to use structs that implement
    `IComponentData`. Structs allow the Entities package to manage the memory of our
    components differently from how the **Garbage Collector** works by organizing
    it in a way that leverages the CPU cache. Structs are also compatible with HPC#,
    the subset of C# compatible with Burst. More about Burst and CPU caching will
    be discussed later in this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的数据是指像我们角色的子弹、分数、健康点、位置等这样的变量。我们通常在 `MonoBehaviours` 中创建字段来达到这样的目的，这里也没有不同，但这次，我们不会使用继承自
    `MonoBehaviour` 的类。相反，我们将使用实现 `IComponentData` 的 struct。Struct 允许 Entities 包以与
    **垃圾回收器** 工作方式不同的方式管理我们组件的内存，通过以利用 CPU 缓存的方式组织它。Structs 还与 HPC# 兼容，这是与 Burst 兼容的
    C# 子集。关于 Burst 和 CPU 缓存将在本章后面进行讨论。
- en: 'The difference between structs and classes in C# is outside the scope of this
    book. You can learn more about this here: [https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中 struct 和 class 的区别超出了本书的范围。你可以在这里了解更多信息：[https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct)
- en: You can create a component by creating a script using the plus button in the
    **Project** panel, selecting the **C# script** option, and naming the script like
    the component you want to create. Don’t create the script using the **Add Component**
    button in the Inspector, as we need some extra steps before adding components
    to the to-be-converted GameObjects. We recommend putting all your ECS components’
    scripts inside a `Scripts/ECS/Components` folder to easily distinguish between
    your regular Unity scripts and the ECS scripts.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在**项目**面板中使用加号按钮创建一个脚本，选择**C#脚本**选项，并按你想要创建的组件命名来创建一个组件。不要使用**检查器**中的**添加组件**按钮创建脚本，因为我们需要在将组件添加到待转换的GameObject之前执行一些额外步骤。我们建议将所有ECS组件的脚本放在一个`Scripts/ECS/Components`文件夹中，以便轻松区分你的常规Unity脚本和ECS脚本。
- en: As we want our cube to move forward, we need a velocity value. Components with
    transform data like position and rotation were added by Transform bakers included
    in the Entities package. To create our velocity ECS component, start by creating
    a script called `Velocity` and put the following code inside it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想让我们的立方体向前移动，我们需要一个速度值。具有转换数据（如位置和旋转）的组件是由Entities包中包含的Transform烘焙器添加的。要创建我们的速度ECS组件，首先创建一个名为`Velocity`的脚本，并在其中放入以下代码。
- en: '![](img/B21361_21_10.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_10.png)'
- en: 'Figure 21.10: An ECS component that holds the velocity of the entity'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.10：一个包含实体速度的ECS组件
- en: Remember that we shouldn’t use classes; use structs instead. While you can use
    classes, they will be a different type of component (managed component) that is
    considerably less performant, and we don’t need them now. Also, notice how we
    included the `Unity.Entities` namespace. And that’s it! We have our first ECS
    component! But we are not finished yet. If you try to add this component to our
    cube in the subscene, it won’t work. Our component won’t be listed in the **Add
    Component** button in the **Inspector**, and you can’t even drag and drop the
    script file as usual. Remember that the baker system needs a baker for our ECS
    component and a MonoBehaviour to convert.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们不应该使用类；而应该使用结构体。虽然你可以使用类，但它们将是一种不同类型的组件（受管理组件），性能会低得多，而且我们现在不需要它们。此外，注意我们如何包含了`Unity.Entities`命名空间。就这样！我们有了我们的第一个ECS组件！但我们的任务还没有完成。如果你尝试将这个组件添加到子场景中的立方体，它将不会工作。我们的组件不会在**检查器**的**添加组件**按钮中列出，你甚至不能像往常一样拖放脚本文件。记住，烘焙系统需要一个用于我们的ECS组件的烘焙器以及一个用于转换的`MonoBehaviour`。
- en: 'The idea is to use GameObjects and `MonoBehaviours` to use the existing Unity
    tools to create scenes and convert them to entities through bakers. So far, we
    created the ECS component, but we still need the `MonoBehaviour` version of that
    component to add it to the subscene GameObjects. The `MonoBehaviour` version of
    our component is called the **Authoring Component**, and the ECS component is
    the **Runtime Component**. To create the authoring component, create a regular
    component with the fields we want to configure from the editor. In the following
    image, you can see the `VelocityAuthoring` component:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是使用GameObject和`MonoBehaviours`来使用现有的Unity工具创建场景，并通过烘焙器将它们转换为实体。到目前为止，我们创建了ECS组件，但我们仍然需要该组件的`MonoBehaviour`版本以将其添加到子场景的GameObject中。我们组件的`MonoBehaviour`版本被称为**编写组件**，而ECS组件是**运行时组件**。要创建编写组件，创建一个常规组件，从编辑器配置我们想要的字段。在下面的图像中，你可以看到`VelocityAuthoring`组件：
- en: '![](img/B21361_21_11.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_11.png)'
- en: 'Figure 21.11: The authoring component for our Velocity runtime component'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.11：我们的速度运行时组件的编写组件
- en: It’s just the classic MonoBehaviour component we are used to creating, with
    the same fields our runtime component will have. Now that we have a component
    that we can add to our authoring GameObjects in the subscene, just add it to the
    cube. If you check the **Entity Baking Preview** pane at the bottom of the **Inspector**,
    no new ECS component was added. We still need to create the baker to convert `VelocityAuthoring`
    into `Velocity`. A baker is a class that inherits from the `Baker` class and converts
    authoring components into runtime components. In the next image, you can see the
    baker for our `VelocityAuthoring` component.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们习惯创建的经典`MonoBehaviour`组件，具有与我们的运行时组件相同的字段。现在，我们有了可以添加到子场景中的编写GameObject的组件，只需将其添加到立方体即可。如果你检查**检查器**底部的**实体烘焙预览**面板，没有添加新的ECS组件。我们仍然需要创建烘焙器将`VelocityAuthoring`转换为`Velocity`。烘焙器是一个从`Baker`类继承的类，它将编写组件转换为运行时组件。在下一张图像中，你可以看到我们的`VelocityAuthoring`组件的烘焙器。
- en: '![](img/B21361_21_12.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_12.png)'
- en: 'Figure 21.12: The baker that converts the VelocityAuthoring component to the
    runtime component'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.12：将 VelocityAuthoring 组件转换为运行时组件的烘焙器
- en: As you can see, we created a class that inherits from `Baker<VelocityAuthoring>`,
    meaning that this will be the baker for `VelocityAuthoring` when the baking system
    does the conversion. In the `Bake` method, we receive the instance of the authoring
    component to convert, accessing its data to create the runtime component.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们创建了一个从 `Baker<VelocityAuthoring>` 继承的类，这意味着当烘焙系统进行转换时，这将作为 `VelocityAuthoring`
    的烘焙器。在 `Bake` 方法中，我们接收要转换的实例化创作组件，访问其数据以创建运行时组件。
- en: First, we get the entity created for the converted GameObject by using the `GetEntity`
    method. Its only parameter highlights that we want this object to move during
    play mode. Hence, it’s dynamic. Then, we create the instance of the runtime component,
    and we set its velocity value to be the same as the authoring component. This
    way, we make sure that the value set in the Inspector is the one that the runtime
    component will have. Finally, we use the `AddComponent` method to add the runtime
    component to the converted entity.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `GetEntity` 方法获取为转换的 GameObject 创建的实体。它的唯一参数突出显示了我们想要在播放模式期间移动此对象。因此，它是动态的。然后，我们创建运行时组件的实例，并将其速度值设置为与创作组件相同。这样，我们确保在检查器中设置的值是运行时组件将拥有的值。最后，我们使用
    `AddComponent` 方法将运行时组件添加到转换后的实体。
- en: 'For more information about the different transform usage flags used in `GetEntity`,
    check this link: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/transforms-usage-flags.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/transforms-usage-flags.html)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `GetEntity` 中使用的不同变换使用标志的更多信息，请参阅此链接：[https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/transforms-usage-flags.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/transforms-usage-flags.html)
- en: If you save your scripts and make sure the authoring component is added to the
    cube, the **Entity Baking Preview** pane should show the **Velocity** runtime
    component. You can click it and confirm that its value is the same as the authoring
    component.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保存了你的脚本并确保将创作组件添加到立方体中，**实体烘焙预览** 窗口应该会显示 **Velocity** 运行时组件。你可以点击它并确认其值与创作组件相同。
- en: '![](img/B21361_21_13.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_13.png)'
- en: 'Figure 21.13: The Entity Baking Preview shows how our runtime component reflects
    the authoring component value'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.13：实体烘焙预览显示了我们的运行时组件如何反映创作组件的值
- en: While this seems like a lot to create a component, in real projects, this becomes
    a powerful tool. Authoring components might add several runtime components, sometimes
    conditionally. For example, the **Rigidbody** baker in the **Unity Physics** package
    will add different components depending on whether **Is Kinematic** is checked
    or unchecked.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建组件看起来需要很多工作，但在实际项目中，这成为一种强大的工具。创作组件可能会添加几个运行时组件，有时是条件性的。例如，**Unity 物理包**
    中的 **Rigidbody** 烘焙器将根据是否勾选或取消勾选 **Is Kinematic** 添加不同的组件。
- en: Now that we have the needed data, let’s create the system to move our cube.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了所需的数据，让我们创建一个系统来移动我们的立方体。
- en: Creating systems using Jobs and Burst
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用作业和 Burst 创建系统
- en: Regular MonoBehaviours not only have data but also the logic to create the behavior
    they represent. Sometimes, they need data from other components, like the position
    in `Transform`, so they use methods like `GetComponent` to access other components’
    data. In ECS, this works quite differently.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的 MonoBehaviours 不仅具有数据，还有创建它们所代表的行为的逻辑。有时，它们需要来自其他组件的数据，例如 `Transform` 中的位置，因此它们使用
    `GetComponent` 等方法来访问其他组件的数据。在 ECS 中，这工作方式相当不同。
- en: Given ECS components have just data, the logic goes into a different place called
    **Systems**. They apply the game logic, such as moving or rotating objects, to
    the entities that require such logic. The way for systems to identify which entities
    must have their logic applied is via their data. Systems will query all entities
    that have specific sets of components for their logic to work and will iterate
    the resulting entities to apply that logic. In this case, we want to move entities,
    but not all entities, just the entities that have the `Velocity` component and
    position data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的 ECS 组件仅包含数据，逻辑则进入一个称为 **系统** 的不同位置。它们将游戏逻辑，例如移动或旋转对象，应用于需要此类逻辑的实体。系统通过其数据来识别哪些实体必须应用其逻辑。系统将查询所有具有特定组件集的实体，以便其逻辑能够工作，并将迭代结果实体以应用该逻辑。在这种情况下，我们想要移动实体，但不是所有实体，只是具有
    `Velocity` 组件和位置数据的实体。
- en: The clarification that our system requires to have position data might be confusing,
    given that all GameObjects have a **Transform** component. This is not necessarily
    true in DOTS, and it’s explained in more detail in the `TransformUsageFlags` property
    info box we mentioned before. In this project, we will always use `TransformUsageFlag.Dynamic`,
    so for this case, we can assume all entities will have transformation data such
    as position, rotation, and scale.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有GameObject都有**变换**组件，因此我们的系统需要具有位置数据这一说明可能令人困惑。在DOTS中这并不一定正确，这在前文提到的`TransformUsageFlags`属性信息框中有更详细的解释。在这个项目中，我们将始终使用`TransformUsageFlag.Dynamic`，因此对于这种情况，我们可以假设所有实体都将具有诸如位置、旋转和缩放之类的变换数据。
- en: 'To make our movement system, first, we need to create a script, as seen in
    the following image:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的运动系统，首先，我们需要创建一个脚本，如下面的图像所示：
- en: '![](img/B21361_21_14.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_14.png)'
- en: 'Figure 21.14: An empty ECS system that serves as the base to create our movement
    system'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.14：一个空ECS系统，用作创建我们的运动系统的基础
- en: A system consists of a partial struct that implements the `ISystem` interface.
    It needs to be partial given that DOTS relies on code generators, meaning that
    lots of boilerplate code to make a system work will be in another `MovementSystem`
    partial struct created automatically for us. We also added an `OnUpdate` method,
    the equivalent to the MonoBehaviour’s `Update` method, but with a very important
    difference.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个系统由一个实现`ISystem`接口的部分结构组成。由于DOTS依赖于代码生成器，因此需要部分实现，这意味着使系统正常工作的许多样板代码将位于为我们自动创建的另一个`MovementSystem`部分结构中。我们还添加了一个`OnUpdate`方法，这是MonoBehaviour的`Update`方法的等效方法，但有一个非常重要的区别。
- en: 'Again, the `partial` keyword is outside the scope of the book. Check the following
    link for more info: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/partial-classes-and-methods](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/partial-classes-and-methods)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`partial`关键字超出了本书的范围。有关更多信息，请查看以下链接：[https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/partial-classes-and-methods](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/partial-classes-and-methods)
- en: The regular `Update` method belongs to specific components, meaning that the
    `Update` will be executed once per component instance. If we have 100 `GameObjects`
    with a `MonoBehaviour` that has an `Update` method, that method will be executed
    100 times per frame, once for each `GameObject`. But in this case, by default,
    there’s always a single instance of our system in the game, which is created automatically
    by the Entities package, regardless of the entities present in the scene. This
    means that our movement systems `OnUpdate` method will be executed once per frame
    as soon as we play the game, just because the system script exists. There are
    ways to prevent the automatic system creation, to have more than one instance
    of a system, and to prevent the `OnUpdate` execution, but let’s keep things simple.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的`Update`方法属于特定的组件，这意味着`Update`将在每个组件实例上执行一次。如果我们有100个带有`MonoBehaviour`和`Update`方法的`GameObjects`，那么该方法将在每帧执行100次，每次针对一个`GameObject`。但在这个情况下，默认情况下，游戏中始终有一个我们的系统实例，它由实体包自动创建，不管场景中存在哪些实体。这意味着我们的运动系统`OnUpdate`方法将在我们开始玩游戏时每帧执行一次，仅仅因为系统脚本存在。有方法可以防止自动系统创建，拥有多个系统实例，并防止`OnUpdate`执行，但让我们保持简单。
- en: After saving your system script, to make sure it is working, play the game and,
    during play mode, open the `Systems` panel in **Window | Entities | System**.
    This window will list all the systems that are running and their performance metrics.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 保存好系统脚本后，为了确保其正常工作，请玩游戏并在游戏模式中，在**窗口 | 实体 | 系统**中打开`系统`面板。此窗口将列出所有正在运行的系统和它们的性能指标。
- en: '![](img/B21361_21_15.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_15.png)'
- en: 'Figure 21.15: The Systems window showing our Movement System.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.15：显示我们的运动系统的系统窗口。
- en: The next step is to iterate all entities that have the `Velocity` and the `LocalTransform`
    component. The latter is one of the several Transform ECS equivalents added by
    the Transform bakers. There are several ways to iterate entities, but let’s first
    see the most common and performant way, using jobs. Jobs are structs that contain
    the logic we want to apply in multiple threads, and the data needed to apply it,
    such as delta time or the positions of the objects to move. In our case, the data
    will be the entity components and some extra data, like delta time. To iterate
    entities, we have a type of job called `IJobEntity`. There are plenty of job types
    for different purposes, but for ECS, we will be using `IJobEntity` most of the
    time.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是迭代所有具有`Velocity`和`LocalTransform`组件的实体。后者是Transform bakers添加的几个Transform
    ECS等效组件之一。迭代实体有多种方式，但让我们首先看看最常见且性能最高的方式，即使用作业。作业是包含我们想要在多个线程中应用逻辑和数据（如delta时间或要移动的对象的位置）的结构体。在我们的案例中，数据将是实体组件和一些额外数据，如delta时间。为了迭代实体，我们有一种名为`IJobEntity`的作业类型。有大量的作业类型用于不同的目的，但对于ECS，我们大部分时间将使用`IJobEntity`。
- en: 'In the following figure, you can see a job script that moves all entities with
    `Velocity` and `LocalTransform`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，你可以看到一个移动所有具有`Velocity`和`LocalTransform`的实体的作业脚本：
- en: '![](img/B21361_21_16.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图21.16](img/B21361_21_16.png)'
- en: 'Figure 21.16: A job to move entities that have LocalTransform and Velocity
    components'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.16：一个移动具有局部变换和速度组件的实体的作业
- en: 'There are a lot of things happening here, so let’s analyze this script piece
    by piece:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，所以让我们逐个分析这个脚本：
- en: We created a partial struct that implements `IJobEntity`in a script that uses
    the `Unity.Entities` and `Unity.Transforms` namespaces.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在脚本中创建了一个部分结构体，该结构体实现了`IJobEntity`，该脚本使用了`Unity.Entities`和`Unity.Transforms`命名空间。
- en: This struct has an execute method with two parameters, one of type `LocalTransform`and
    the other of `Velocity`type. It’s no coincidence that these parameters match the
    exact components we need to move entities. The parameters defined in the `Execute`method
    of an `IJobEntity`serve to tell ECS that we want to iterate entities with such
    components, ignoring the ones without them.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个结构体有一个带有两个参数的执行方法，一个是`LocalTransform`类型，另一个是`Velocity`类型。这些参数与我们需要移动实体的确切组件相匹配并非巧合。在`IJobEntity`的`Execute`方法中定义的参数用于告诉ECS我们想要迭代具有此类组件的实体，忽略没有这些组件的实体。
- en: The `LocalTransform`parameter is prefixed by a `ref` keyword, while `Velocity`is
    prefixed by an `in` keyword. Those are ways to tell ECS the privileges we want
    over those components. `Ref` means that we will modify `LocalTransform`, while
    `in` means we will only read the data of `Velocity`. For the job system to make
    sure any job is safe to execute in parallel with others, it needs to know how
    the data in them will be treated. Two jobs that write the same data (for example,
    two jobs that move objects in different ways) cannot be executed in parallel to
    prevent race conditions and using locks. However, two jobs that read the same
    data can execute in parallel, given that read-only operations are thread-safe.
    Always define parameters as `in` (read-only) whenever possible, using `re` only
    when necessary.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LocalTransform`参数前缀为`ref`关键字，而`Velocity`前缀为`in`关键字。这些是告诉ECS我们想要对这些组件拥有什么权限的方式。`Ref`表示我们将修改`LocalTransform`，而`in`表示我们只读取`Velocity`的数据。为了确保任何作业都可以安全地与其他作业并行执行，作业系统需要知道它们中的数据将如何被处理。两个写入相同数据的作业（例如，以不同方式移动对象的两个作业）不能并行执行，以防止竞态条件和使用锁。然而，如果只读操作是线程安全的，那么可以并行执行读取相同数据的两个作业。始终尽可能将参数定义为`in`（只读），只在必要时使用`ref`。'
- en: We calculate the number of meters to move as usual by multiplying the velocity
    with delta time. We didn’t access delta time, as usual, using `Time.deltaTime`.
    To allow for safe job parallelization, they are designed to deal only with the
    data inside the job, avoiding accessing static variables whenever possible. That’s
    why delta time is a field in the struct so that later when we instantiate the
    job in our system, we will fill this data.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过将速度乘以delta时间来计算移动的米数。我们通常不是使用`Time.deltaTime`来访问delta时间。为了允许安全的作业并行化，它们被设计成只处理作业内部的数据，尽可能避免访问静态变量。这就是为什么delta时间是一个结构体字段，这样当我们在我们系统中实例化作业时，我们将填充这些数据。
- en: In `MonoBehaviours`, modifying the axes returned by `transform.position` directly
    (not storing it in a variable) is not possible; given that `transform.position`
    returns a copy of the position, modifying it will throw an error. The same applies
    to any other getter. But in ECS, it’s perfectly valid, given that we are manipulating
    the data by reference, not just a copy. We accessed `LocalTransform`via a `ref`
    keyword, meaning that we are accessing the position memory directly. In regular
    `MonoBehaviours`, this is not possible, given the position of our GameObjects
    is stored in the C++ side of a Transform, so copies are necessary.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MonoBehaviours` 中，直接修改由 `transform.position` 返回的轴（不将其存储在变量中）是不可能的；因为 `transform.position`
    返回的是位置的一个副本，修改它将引发错误。同样适用于任何其他获取器。但在 ECS 中，这是完全有效的，因为我们是通过引用而不是副本来操作数据的。我们通过 `ref`
    关键字访问了 `LocalTransform`，这意味着我们直接访问了位置内存。在常规的 `MonoBehaviours` 中，这是不可能的，因为我们的 GameObjects
    的位置存储在 Transform 的 C++ 方面，因此需要副本。
- en: Jobs can access mutable static data if they are not Burst-compiled (more on
    this later). But even if that is possible, it is highly dangerous as the ECS safety
    systems cannot prevent two jobs from modifying such static data. That’s why it
    is safer to copy the data to the job as we did with `Time.deltaTime`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果作业不是 Burst 编译的（关于这一点稍后讨论），则作业可以访问可变静态数据。但即使这是可能的，也是非常危险的，因为 ECS 安全系统无法防止两个作业修改此类静态数据。这就是为什么将数据复制到作业中，就像我们使用
    `Time.deltaTime` 一样，更安全。
- en: Now, the only responsibility of `MovementSystem` is to instantiate the job,
    fill in its data, and schedule it. By scheduling it, the job system will take
    care of checking when it is safe to execute our job, considering how other systems’
    jobs might read and write the same data our job needs. Remember that the idea
    of defining read-write or read-only access for our components when using the `ref`
    and `in` keywords is to allow the job scheduler to take such considerations.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`MovementSystem` 的唯一责任是实例化作业，填写其数据，并安排它。通过安排它，作业系统将负责检查何时执行我们的作业是安全的，考虑到其他系统的作业可能如何读取和写入我们的作业所需的数据。记住，使用
    `ref` 和 `in` 关键字定义我们的组件的读写或只读访问权限的想法是允许作业调度器考虑这些因素。
- en: 'Our system’s OnUpdate method will look like the following figure:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们系统的 `OnUpdate` 方法将如下所示：
- en: '![](img/B21361_21_17.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_21_17.png)'
- en: 'Figure 21.17: The movement system instancing MoveJob and scheduling it'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.17：移动系统实例化 MoveJob 并安排它
- en: As you can see, we simply instantiate the job, filling the `DeltaTime` field
    with this frame’s delta time, and then we schedule the job using `ScheduleParallel`.
    The first thing to notice is that we used `SystemAPI.Time.DeltaTime` is the ECS
    way to get the frame’s delta time.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只是实例化作业，将 `DeltaTime` 字段填充为这一帧的 delta time，然后使用 `ScheduleParallel` 安排作业。首先要注意的是，我们使用了
    `SystemAPI.Time.DeltaTime`，这是 ECS 获取帧 delta time 的方法。
- en: ECS has its own timing mechanism, and while we can still use `Time.DeltaTime`,
    we should stick to the ECS version to work properly with the rest of the systems.
    Also, we didn’t specify the entities the job will iterate. Systems code generators
    know the entities we want to iterate based on the system job’s `Execute` method
    parameters, so we don’t need to worry about providing this data to the job.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ECS 有自己的计时机制，虽然我们仍然可以使用 `Time.DeltaTime`，但我们应该坚持使用 ECS 版本来与系统的其余部分正常工作。此外，我们没有指定作业将迭代的实体。系统代码生成器知道我们想要迭代的实体，基于系统作业的
    `Execute` 方法参数，所以我们不需要担心向作业提供此数据。
- en: Finally, we used the `ScheduleParallel` method to not only tell the job scheduler
    to schedule our job but also to tell it that we want to iterate the entities in
    parallel. This means that the job worker threads (usually one for each CPU core)
    will be processing different entities, reducing the time it takes to execute our
    logic by spreading the work. You can also use `Schedule` instead, which processes
    all our entities in a single core but still in parallel with other jobs. For now,
    we will stick with `ScheduleParallel` for most cases.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用了 `ScheduleParallel` 方法，不仅告诉作业调度器安排我们的作业，还告诉它我们想要并行迭代实体。这意味着作业工作线程（通常每个
    CPU 核心一个）将处理不同的实体，通过分散工作来减少执行我们的逻辑所需的时间。您也可以使用 `Schedule`，它在一个核心中处理所有我们的实体，但仍然与其他作业并行。目前，我们将继续使用
    `ScheduleParallel` 大多数情况。
- en: 'Now we need the final piece of the DOTS tri-force, Burst. Remember, Burst will
    take HPC# compliant code and convert it into performant native code. Here’s a
    non-comprehensive list of requirements of HPC#:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要DOTS三叉戟的最后一部分，Burst。记住，Burst会将HPC#兼容的代码转换为高性能的本地代码。以下是一个非详尽的HPC#要求的列表：
- en: Using managed references (objects) is not possible. This includes strings, arrays,
    lists, dictionaries, and most of the C# libraries, like `System.Collections`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用托管引用（对象）是不可能的。这包括字符串、数组、列表、字典以及大多数C#库，如`System.Collections`。
- en: Exceptions (try/catch) work in the editor, but they will abort execution in
    builds.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常（try/catch）在编辑器中工作，但在构建中会终止执行。
- en: '`Debug.Log` support is limited to constant strings, string interpolation, and
    `string.Format`.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Debug.Log`的支持仅限于常量字符串、字符串插值和`string.Format`。'
- en: 'Static read-only data and constants are safe. Mutable static data isn’t unless
    the `SharedStatic`struct is used: [https://docs.unity3d.com/Packages/com.unity.burst@1.8/manual/csharp-shared-static.html](mailto:https://docs.unity3d.com/Packages/com.unity.burst@1.8/manual/csharp-shared-static.html)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态只读数据和常量是安全的。除非使用`SharedStatic`结构，否则可变静态数据不安全：[https://docs.unity3d.com/Packages/com.unity.burst@1.8/manual/csharp-shared-static.html](mailto:https://docs.unity3d.com/Packages/com.unity.burst@1.8/manual/csharp-shared-static.html)
- en: We have used HPC# in the code so far, so we just need to tag the code to Burst-compile
    using the `BurstCompile` attribute. In systems, you can add this attribute to
    the `OnUpdate` method, and for jobs, add the attribute to the `job` struct to
    Burst-compile its `Execute` method.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在代码中使用了HPC#，所以我们只需要使用`BurstCompile`属性标记代码以进行Burst编译。在系统中，您可以将此属性添加到`OnUpdate`方法中，对于作业，将属性添加到`job`结构中以Burst编译其`Execute`方法。
- en: '![](img/B21361_21_18.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_18.png)'
- en: 'Figure 21.18: Burst-compiling our systems and jobs'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.18：Burst编译我们的系统和作业
- en: 'There are some considerations to follow in your code to make Burst work even
    faster. Check this link for more information: [https://docs.unity3d.com/Packages/com.unity.burst@1.8/manual/optimization-overview.html](mailto:https://docs.unity3d.com/Packages/com.unity.burst@1.8/manual/optimization-overview.html)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中遵循一些注意事项可以使Burst工作得更快。查看此链接获取更多信息：[https://docs.unity3d.com/Packages/com.unity.burst@1.8/manual/optimization-overview.html](mailto:https://docs.unity3d.com/Packages/com.unity.burst@1.8/manual/optimization-overview.html)
- en: Now, you can play the game and observe how our cube will move forward. Feel
    free to copy the cube several times over the scene until you have hundreds or
    even thousands of them. See how the game performance doesn’t suffer!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以玩游戏并观察我们的立方体如何向前移动。您可以随意将立方体复制到场景中，直到您有数百甚至数千个。看看游戏性能是否受到影响！
- en: It is easy for the systems to not work as expected when entities are misconfigured,
    like forgetting to add the `Velocity` component. This can cause systems to not
    find the entities they need. Let’s see how to debug systems to see the entities
    they found, which jobs they are scheduling, and check if their code is Burst-compiled.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当实体配置错误，例如忘记添加`Velocity`组件时，系统可能无法按预期工作。这可能导致系统找不到它们需要的实体。让我们看看如何调试系统以查看它们找到的实体、它们正在安排的作业以及检查它们的代码是否是Burst编译的。
- en: Debugging system jobs and queries
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试系统作业和查询
- en: Systems apply logic by iterating entities that have specific components, using
    jobs and other methods. To debug a non-working system, we should check if it is
    finding entities. To do so, the system code generator creates instances of `EntityQuery`,
    a type responsible for finding entities with specific components. Our `MoveJob`
    job requires entities with `LocalTransform` and `Velocity`, so an entity query
    is generated automatically in the `MovementSystem` for it to schedule its job.
    Systems could iterate different groups of entities (for example, when scheduling
    more than one job), so systems can have several queries. Entity queries can also
    be created manually for other purposes, but we don’t need them now.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 系统通过迭代具有特定组件的实体，使用作业和其他方法来应用逻辑。为了调试一个不工作的系统，我们应该检查它是否正在查找实体。为此，系统代码生成器创建了`EntityQuery`的实例，这是一种负责查找具有特定组件的实体的类型。我们的`MoveJob`作业需要具有`LocalTransform`和`Velocity`组件的实体，因此`MovementSystem`会自动为它生成一个实体查询以安排其作业。系统可以迭代不同的实体组（例如，在安排多个作业时），因此系统可以有多个查询。实体查询也可以手动创建用于其他目的，但现在我们不需要它们。
- en: 'Entity queries are fast due to them caching archetype chunks. These memory
    chunks store entities that have the same set of components, so it’s easy to track
    where the required entities are located. For more info on archetypes, see the
    following link: [https://docs.unity3d.com/Packages/com.unity.entities@1.1/manual/concepts-archetypes.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.1/manual/concepts-archetypes.html)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 实体查询速度快，因为它们缓存了原型块。这些内存块存储具有相同组件集的实体，因此很容易追踪所需实体的位置。有关原型的更多信息，请参阅以下链接：[https://docs.unity3d.com/Packages/com.unity.entities@1.1/manual/concepts-archetypes.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.1/manual/concepts-archetypes.html)
- en: We can use the **Systems** window (**Window | Entities | Systems**) during play
    mode to see how many entities our system is finding and all the queries that find
    them. Check the **Entity Count** column of a system. Also, after selecting the
    system in the list, the **Inspector** will show the system queries, informing
    each query component.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在播放模式下使用**系统**窗口（**窗口 | 实体 | 系统**）来查看我们的系统找到了多少实体以及所有找到它们的查询。检查系统的**实体计数**列。此外，在列表中选择系统后，**检查器**将显示系统查询，并告知每个查询组件。
- en: '![](img/B21361_21_19.png)Figure 21.19: Checking system’s queries using the
    Systems window and the Inspector'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/B21361_21_19.png)图21.19：使用系统窗口和检查器检查系统的查询'
- en: Use the **Relationships** tab to see which entities match the query. In the
    following image, you can see that our query is finding our cube.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**关系**选项卡来查看哪些实体与查询匹配。在以下图像中，你可以看到我们的查询正在找到我们的立方体。
- en: '![](img/B21361_21_20.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_20.png)'
- en: 'Figure 21.20: Checking the entities matching the system’s queries.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.20：检查与系统查询匹配的实体。
- en: If your queries don’t match the expected entities, check if such entities have
    the required components. It’s easy to forget to add the authoring components into
    our entities or even forget to put the authoring GameObjects inside the subscene,
    mistakenly leaving them in the main scene.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的查询没有匹配到预期的实体，请检查这些实体是否具有所需的组件。很容易忘记将创作组件添加到我们的实体中，甚至忘记将创作游戏对象放入子场景中，错误地将它们留在主场景中。
- en: 'Another thing to check is if our system is scheduling the job and to see if
    the system and the jobs are Burst-compiled. To do so, we can do the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件事要检查的是我们的系统是否正在安排作业，以及系统和作业是否是Burst编译的。为此，我们可以执行以下操作：
- en: 'Open the Unity Profiler as we saw in *Chapter 18*, *Performance Wizardry: Optimizing
    Your Game with Profiler Tools*.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Unity分析器，就像我们在第18章中看到的那样，*性能巫术：使用分析器工具优化你的游戏*。
- en: Capture profiling data during play mode and select any frame.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在播放模式下捕获分析数据，并选择任何一帧。
- en: Enable the **Timeline** view if you are not already there by clicking any place
    in the CPU usage module, clicking the **Hierarchy** button to display the selection
    box, and clicking **Timeline**.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有在**时间轴**视图中，可以通过点击CPU使用模块中的任何位置，点击**层次结构**按钮以显示选择框，然后点击**时间轴**来启用该视图。
- en: '![](img/B21361_21_21.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_21.png)'
- en: 'Figure 21.21: Enabling Timeline mode in the Profiler’s CPU module'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.21：在分析器的CPU模块中启用时间轴模式
- en: Search for your job in the **timeline** by using the mouse wheel to zoom in.
    Your system should be inside the **SimulationSystemGroup** profiler marker. Note
    that even if we have thousands of entities, our system is only scheduling a job
    to iterate them, so its marker will be very small.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用鼠标滚轮放大来在**时间轴**中搜索你的作业。你的系统应该在**SimulationSystemGroup**分析器标记内。请注意，即使我们有成千上万的实体，我们的系统也只安排一个作业来迭代它们，所以它的标记会非常小。
- en: '![](img/B21361_21_22.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_22.png)'
- en: 'Figure 21.22: Finding our systems in the profiler'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.22：在分析器中找到我们的系统
- en: Check the marker color. If it’s light green, it means it is burst compiled.
    If it is light blue, it is not, meaning we didn’t add the `BurstCompile`attribute
    to the `OnUpdate`method, or we tried to Burst-compile non-HPC# code. Notice how
    the non-Burst-compiled version is significantly slower than the Burst-compiled
    one in the following image.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查标记颜色。如果是浅绿色，则表示它是Burst编译的。如果是浅蓝色，则不是，这意味着我们没有将`BurstCompile`属性添加到`OnUpdate`方法中，或者我们尝试了Burst编译非HPC#代码。注意以下图像中非Burst编译版本比Burst编译版本慢得多。
- en: '![](img/B21361_21_23.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_23.png)'
- en: 'Figure 21.23: Non-Burst compiled system code'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.23：非Burst编译的系统代码
- en: In the profiler, click the three dots button in the top-right part of the timeline
    (not the similar button in the top-right corner of the window) and enable **Show
    Flow Events**. This will enable us to see the jobs our system schedules.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在分析器中，点击时间线右上角的三点按钮（不是窗口右上角类似的三点按钮）并启用**显示流程事件**。这将使我们能够看到系统安排的工作。
- en: '![](img/B21361_21_24.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_24.png)'
- en: 'Figure 21.24: Enabling flow events'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.24：启用流程事件
- en: Select our system in the timeline and follow the lines to the jobs. You should
    see several instances of it in different threads, as each instance deals with
    different groups of entities (if there are enough). Remember to expand the job
    thread group using the gray triangle at its left to see the job’s details.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在时间线中选择我们的系统，并跟随线条到工作。你应该在多个线程中看到它的几个实例，因为每个实例处理不同的实体组（如果足够的话）。记得使用左侧的灰色三角形展开工作线程组，以查看工作详情。
- en: '![](img/B21361_21_25.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_25.png)'
- en: 'Figure 21.25: Checking the jobs scheduled by our system.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.25：检查系统安排的工作。
- en: Check if the job’s marker color is light green. If it’s not, remember to add
    the `BurstCompile`method to the `job` struct (not the `Execute` method).
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查作业的标记颜色是否为浅绿色。如果不是，请记住将`BurstCompile`方法添加到`job`结构体中（而不是`Execute`方法）。
- en: In this section, we discussed how to create and configure a DOTS project and
    how to create a subscene where we placed GameObjects to convert them to entities.
    We also created a runtime component (`Velocity`), added to our converted entities
    by a baker (`VelocityBaker`), which converted the authoring component (`VelocityAuthoring`)
    to the runtime component. We used the velocity value to create a system that scheduled
    a job that applied that velocity to each entity’s `LocalTransform` position, moving
    the entities. Finally, we saw how to debug our systems, check the queries they
    created to iterate entities in jobs, and see the system-job relationship and performance
    using the Unity Profiler.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何创建和配置一个DOTS项目，以及如何创建一个子场景，我们将GameObject放置其中以将其转换为实体。我们还创建了一个运行时组件（`Velocity`），通过baker（`VelocityBaker`）添加到转换后的实体中，该组件将作者组件（`VelocityAuthoring`）转换为运行时组件。我们使用速度值创建了一个系统，该系统安排了一个工作，将速度应用于每个实体的`LocalTransform`位置，从而移动实体。最后，我们看到了如何调试我们的系统，检查它们创建的查询以在作业中迭代实体，并使用Unity
    Profiler查看系统-作业关系和性能。
- en: Of course, we have just scratched the DOTS surface. In the next section, we
    will see how to create more interesting gameplay, like moving and spawning enemies.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们只是刚刚触及DOTS的表面。在下一节中，我们将看到如何创建更有趣的游戏玩法，如移动和生成敌人。
- en: Creating gameplay in DOTS
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在DOTS中创建游戏玩法
- en: 'Lots of things we do in MonoBehaviours, like instantiating objects or getting
    other object data (for example, their position), are quite differently implemented
    in DOTS. In this section, we will examine how to achieve these things in DOTS:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在MonoBehaviours中做的许多事情，比如实例化对象或获取其他对象数据（例如，它们的位置），在DOTS中的实现方式相当不同。在本节中，我们将检查如何在DOTS中实现这些事情：
- en: Moving using input and tag components
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用输入和标签组件移动
- en: Creating seeking missiles using component lookups
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组件查找创建寻找导弹
- en: Destroying the character with entity command buffers
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实体命令缓冲区销毁角色
- en: Dealing with errors in bursted code
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理爆发的代码中的错误
- en: Instantiating missiles with entity Prefabs
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实体预制体实例化导弹
- en: Making the camera follow our character
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让摄像机跟随我们的角色
- en: Exploring other DOTS features
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索其他DOTS功能
- en: Let’s start by discussing how to modify our movement code to respond to input.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论如何修改我们的移动代码以响应输入。
- en: Moving using input and tag components
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用输入和标签组件移动
- en: 'Let’s start creating gameplay by using input to move the cube. We need to change
    our movement job to provide it with the input values. We will do this the same
    way as we provided delta time by passing the input values to the job. In the next
    image, you can see the needed changes:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用输入来移动立方体开始创建游戏玩法。我们需要更改我们的移动作业，以便为其提供输入值。我们将以与通过传递输入值到作业中提供delta time相同的方式进行此操作。在下一张图片中，你可以看到所需的变化：
- en: '![](img/B21361_21_26.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_26.png)'
- en: 'Figure 21.26: Moving our character based on our input'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.26：根据我们的输入移动我们的角色
- en: While `LocalTransform` has a `Translate` method, it doesn’t move in relative
    coordinates. That’s why we needed to construct the movement vectors by using the
    `Right` and `Forward` methods, which provide such directions relative to our object.
    We apply a similar update to our position for forward movement by adding a vector
    along the forward direction, multiplied by the current input’s `Vertical` value
    and `DeltaTime`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `LocalTransform` 有一个 `Translate` 方法，但它并不是在相对坐标中移动。这就是为什么我们需要使用 `Right` 和
    `Forward` 方法来构建运动向量，这些方法提供了相对于我们对象的这些方向。我们通过在前进方向上添加一个向量，并将其乘以当前输入的 `Vertical`
    值和 `DeltaTime` 来对位置进行类似的更新，以实现向前移动。
- en: 'Finally, we modified our system to provide the input values like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们修改了我们的系统，以提供如下输入值：
- en: '![](img/B21361_21_27.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图21.27：为移动任务提供输入值](img/B21361_21_27.png)'
- en: 'Figure 21.27: Providing input values to the move job'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图21.27：为移动任务提供输入值](img/B21361_21_27.png)'
- en: We used the legacy input system here for simplicity. Feel free to use the new
    one. Now, you can play the game and control the cubes with input. We deleted all
    the extra cubes, leaving just one to represent our player.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里为了简单起见使用了传统的输入系统。你可以自由地使用新的系统。现在，你可以玩游戏并使用输入来控制立方体。我们删除了所有额外的立方体，只留下一个来代表我们的玩家。
- en: Something to consider is that while our movement system will move anything with
    the `Velocity` component, there can be other objects with velocity that could
    move in different ways (for example, via AI). We need to differentiate the objects
    that will apply velocity via input and the ones that apply it differently. One
    way would be to rename our `velocity` component to something like “`PlayerVelocity`”
    and then create other velocity components for the other future movement methods.
    While that will work, it might not be the best approach, depending on your game
    requirements. Let’s say we have a velocity area that speeds up any entity in an
    area. If we use the multi-component approach, our area will need to consider all
    the different velocity components we have, complicating our code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的是，虽然我们的移动系统会移动带有 `Velocity` 组件的任何东西，但可能会有其他具有速度的对象以不同的方式移动（例如，通过AI）。我们需要区分通过输入应用速度的对象和以不同方式应用速度的对象。一种方法是将我们的
    `velocity` 组件重命名为类似“`PlayerVelocity`”的东西，然后为其他未来的移动方法创建其他速度组件。虽然这会起作用，但这可能不是最佳方法，具体取决于你的游戏需求。假设我们有一个加速区域，它会加速区域内的任何实体。如果我们使用多组件方法，我们的区域将需要考虑我们拥有的所有不同的速度组件，这会使我们的代码变得复杂。
- en: Another approach could be adding a unique component to our player entity to
    differentiate it from other entities, requesting such a component in our job.
    But such a component doesn’t need any data. Can we add a component with no data?
    Yes! We call them tag components. As the name suggests, they serve as a way to
    mark entities for systems to find them easily.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法可能是给我们的玩家实体添加一个独特的组件来区分它与其他实体，在我们的任务中请求这样的组件。但这样的组件不需要任何数据。我们能否添加一个没有数据的组件？是的！我们称它们为标签组件。正如其名所示，它们作为标记实体以便系统可以轻松找到的一种方式。
- en: If you read the archetypes link provided before, you should be aware that adding
    tag components will split entities into different chunks. Avoid adding too many
    unique tag components to individual entities to prevent having too many chunks
    with just a few entities inside. This phenomenon is called archetype fragmentation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了之前提供的原型链接，你应该知道添加标签组件会将实体分割成不同的块。为了避免有太多只有少数实体的块，请避免为单个实体添加过多的唯一标签组件。这种现象被称为原型碎片化。
- en: First, let’s create the runtime component, authoring component, and baker for
    our `Player` tag. Remember to add the `PlayerAuthoring` component to our player
    entity (the cube).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为我们的 `Player` 标签创建运行时组件、创作组件和烘焙器。请记住将 `PlayerAuthoring` 组件添加到我们的玩家实体（立方体）中。
- en: '![](img/B21361_21_28.png)Figure 21.28: Scripts needed to create a player tag
    component'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图21.28：创建玩家标签组件所需的脚本](img/B21361_21_28.png)'
- en: 'We didn’t create a new `Player` component to add. Instead, we used the `AddComponent<Player>`
    API specifying `Player` as the component to add. Once added to the player entity,
    let’s use this tag component in our job to make it only move entities with it.
    While we can add `Player` as a job’s `execute` method parameter, as we did with
    the previous components, we won’t read or write data on it – it doesn’t have data
    after all. Instead, another way to tell our job to iterate entities with specific
    components is by using the `WithAll` attribute, as seen in the next image:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有创建一个新的`Player`组件来添加。相反，我们使用了`AddComponent<Player>` API，指定`Player`为要添加的组件。一旦添加到玩家实体中，让我们使用这个标签组件在我们的任务中使其仅移动带有该标签的实体。虽然我们可以像之前添加其他组件那样将`Player`作为任务的`execute`方法参数，但我们不会读取或写入它上的数据——毕竟它没有数据。相反，另一种让我们的任务迭代具有特定组件的实体的方法是使用`WithAll`属性，如下一张图片所示：
- en: '![](img/B21361_21_29.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_29.png)'
- en: 'Figure 21.29: Making the job’s autogenerated query to look for entities with
    the Player tag.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.29：使任务的自动生成的查询看起来像是在寻找带有 Player 标签的实体。
- en: This way, we can reuse the `Velocity` component with the guarantee that each
    entity receives the required logic. Now, let’s add an enemy to our game.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以重用`Velocity`组件，并保证每个实体都接收到所需的逻辑。现在，让我们在我们的游戏中添加一个敌人。
- en: Creating seeking missiles using component lookups
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用组件查找创建追踪导弹
- en: 'In this example project, we will make the player evade seeking missiles that
    will constantly spawn. To do so, we will need a missile entity with the following
    data:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例项目中，我们将使玩家躲避不断生成的追踪导弹。为此，我们需要一个具有以下数据的导弹实体：
- en: '**Position and rotation**: represented by `LocalTransform`.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置和旋转**：由`LocalTransform`表示。'
- en: '**Movement velocity**: the same `Velocity` we already have.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动速度**：我们已有的相同`Velocity`。'
- en: '**Steering velocity**: a new `Steering` component we will create.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转向速度**：我们将创建的新`Steering`组件。'
- en: '**A target entity to follow**: a new `Target` component we will create.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**要跟随的目标实体**：我们将创建的新`Target`组件。'
- en: 'Steering velocity should be a straightforward component to create. Just do
    the same as we did to create the movement velocity component, but name it differently.
    Regarding the Target component, it will look like the following figure:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 转向速度应该是一个创建起来相当直接组件。只需像创建移动速度组件那样做，但名称不同。至于`Target`组件，它看起来如下所示：
- en: '![](img/B21361_21_30.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_30.png)'
- en: 'Figure 21.30: Creating the Target component'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.30：创建目标组件
- en: The first thing to notice is that we are using the `Entity` type as the `Target`
    component value. This is the ECS equivalent of having a reference to a target
    GameObject. We use the entity reference to get data from it, like its position.
    Notice that the authoring component references a GameObject because, while editing,
    we still use GameObjects, so we are referencing the `Player` GameObject that will
    be converted to an entity. Finally, the baker not only needs to call `GetEntity`
    to get the entity we are converting to add components but also to get the converted
    entity of the target GameObject.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们正在使用`Entity`类型作为`Target`组件的值。这是 ECS 中拥有目标 GameObject 引用的等效。我们使用实体引用从它获取数据，例如其位置。请注意，编写组件引用
    GameObject，因为在编辑时我们仍然使用 GameObject，所以我们引用的是将被转换为实体的`Player`GameObject。最后，烘焙器不仅需要调用`GetEntity`来获取我们正在转换以添加组件的实体，还需要获取目标
    GameObject 的转换后的实体。
- en: Now, you can create a sphere called `Missile` in the subscene and add the `Velocity`,
    `SteeringVelocity`, and `Target` authoring components. Remember to configure the
    `Target` component by dragging the player GameObject in the subscene to the **Value**
    property.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在子场景中创建一个名为`Missile`的球体，并添加`Velocity`、`SteeringVelocity`和`Target`的编写组件。请记住通过将玩家
    GameObject 从子场景拖动到**值**属性来配置`Target`组件。
- en: '![](img/B21361_21_31.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_31.png)'
- en: 'Figure 21.31: Creating the missile authoring GameObject'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.31：创建导弹的 GameObject
- en: Now, we can create a system to move the missiles towards the player. While we
    could create a `Missile` tag component as we did with the player, we have enough
    components to make the steering system find the missiles. We will make this system
    iterate entities with `Velocity`, `SteeringVelocity`, and `Target`, given that
    non-steering entities are unlikely to have this specific set of entities in our
    game so far.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个系统来将导弹移动到玩家位置。虽然我们可以像对玩家那样创建一个`Missile`标签组件，但我们已经有足够的组件让转向系统找到导弹。我们将使这个系统迭代具有`Velocity`、`SteeringVelocity`和`Target`的实体，鉴于到目前为止我们的游戏中不太可能有非转向实体具有这样一组特定的实体。
- en: 'This is how the steering job will look:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是转向任务将看起来：
- en: '![](img/B21361_21_32.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_21_32.png)'
- en: 'Figure 21.32: Steering job'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.32：转向任务
- en: The first thing to notice is the `TransformLookup` field of type `ComponentLookup`.
    So far, for the data we read from the entities we are iterating, we used the `ref`
    and `in` parameters as ways to access them, but this time, we need access to data
    from entities other than the ones the job iterates, so we can’t use the parameters.
    As the name suggests, a lookup allows us to get data from other entities, meaning
    we can retrieve components from entities using them. We are using it to get the
    target’s transform into the `targetTransform` variable, providing the target entity
    in brackets.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是`TransformLookup`字段，其类型为`ComponentLookup`。到目前为止，对于我们从正在迭代的实体中读取的数据，我们使用了`ref`和`in`参数作为访问它们的方式，但这次，我们需要访问除任务迭代的实体之外的其他实体的数据，因此我们不能使用这些参数。正如其名所示，查找允许我们从其他实体中获取数据，这意味着我们可以使用它们检索实体的组件。我们正在使用它将目标的变换获取到`targetTransform`变量中，并在括号中提供目标实体。
- en: Another thing to notice is that we have the `LocalToWorld` lookup. The ECS transform
    systems use this other component to store the local-to-world matrices. This means
    that this component has the world position, rotation, and scale of the target
    entity, unlike `LocalTransform`, which provides the local ones. This component
    allows us to get the world space entity position, regardless of where the parent
    transforms are.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点要注意的是，我们有`LocalToWorld`查找。ECS变换系统使用这个其他组件来存储局部到世界矩阵。这意味着这个组件具有目标实体的世界位置、旋转和缩放，与提供局部值的`LocalTransform`不同。这个组件允许我们获取世界空间中的实体位置，而不管父变换在哪里。
- en: We also used this component due to a tricky issue. Our job is to modify the
    position of entities in relation to other entities’ positions. We also use `ScheduleParallel`
    to schedule jobs, creating several jobs that handle different entities. This can
    lead to one job instance reading the position of an entity that another job instance
    is writing, which can cause several issues. Unity can detect such cases and warn
    us, but in this case, it is not needed, given we are reading the `LocalToWorld`
    component to get the target’s position while we are modifying the missile entities’
    positions via `LocalTransform`. This way, we don’t risk reading and writing the
    same component simultaneously. Actually, `LocalToWorld’s` data is derived from
    the `LocalTransform` value by one of the several ECS transform systems. Also,
    notice how the lookup is declared as `ReadOnly`, given we won’t modify other entities’
    `LocalToWorld`; we just read them. Modifying `LocalToWorld` won’t make sense because,
    as we mentioned before, its value is calculated from `LocalTransform` before rendering
    the entities.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还因为一个棘手的问题而使用了这个组件。我们的任务是修改实体相对于其他实体位置的位置。我们还使用`ScheduleParallel`来安排任务，创建处理不同实体的多个任务。这可能导致一个任务实例读取另一个任务实例正在写入的实体的位置，这可能会引发多个问题。Unity可以检测此类情况并警告我们，但在此情况下，这并不必要，因为我们正在通过`LocalTransform`修改导弹实体的位置时，同时读取`LocalToWorld`组件以获取目标的位置。这样，我们就不会同时读取和写入相同的组件。实际上，`LocalToWorld`的数据是由几个ECS变换系统之一从`LocalTransform`值派生出来的。请注意，由于我们不会修改其他实体的`LocalToWorld`，查找被声明为`ReadOnly`；我们只是读取它们。修改`LocalToWorld`没有意义，因为我们之前提到，其值是在渲染实体之前从`LocalTransform`计算出来的。
- en: 'We tried to explain the transform system as briefly as possible, but for more
    info about how it works, check this link: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/transforms-concepts.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/transforms-concepts.html)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尽量简要地解释了变换系统，但若想了解更多关于其工作原理的信息，请查看此链接：[https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/transforms-concepts.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/transforms-concepts.html)
- en: Finally, we also check if the target entity is null, although we are not using
    the regular null, but `Entity.Null`. Structs cannot be null, given they are not
    reference types; they always have a value. `Entity.Null` is a special value that
    entity variables have when not referencing entities. The rest of the steering
    job uses regular vector math to apply steering.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们也检查目标实体是否为空，尽管我们不是使用常规的空，而是使用`Entity.Null`。结构体不能为空，因为它们不是引用类型；它们始终有一个值。`Entity.Null`是当实体变量不引用实体时具有的特殊值。转向任务的其余部分使用常规向量数学来应用转向。
- en: 'Finally, the system that schedules this job looks like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，安排此任务的系统看起来像这样：
- en: '![](img/B21361_21_33.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_21_33.png)'
- en: 'Figure 21.33: Steering system scheduling the steering job'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.33：转向系统调度转向工作
- en: We used the `GetComponentLookup`method to provide the component lookup to our
    job. We used `true` as the first parameter to let it know that we needed a read-only
    lookup. Component lookups are expensive to use, given they introduce indirection,
    causing cache misses. It is always preferred to use jobs to get entity data, but
    in this case, they are the only way to get other entity data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `GetComponentLookup` 方法为我们的工作提供组件查找。我们将 `true` 作为第一个参数，让它知道我们需要一个只读查找。由于组件查找会引入间接引用，导致缓存未命中，因此使用组件查找的成本很高。始终首选使用工作来获取实体数据，但在这个案例中，它们是获取其他实体数据的唯一方式。
- en: 'For more information about what a cache miss is and how DOTS deals with them,
    check the following blog post: [https://blog.innogames.com/unitys-performance-by-default-under-the-hood/](https://blog.innogames.com/unitys-performance-by-default-under-the-hood/)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有关缓存未命中的更多信息以及 DOTS 如何处理它们，请查看以下博客文章：[https://blog.innogames.com/unitys-performance-by-default-under-the-hood/](https://blog.innogames.com/unitys-performance-by-default-under-the-hood/)
- en: Now, just play the game and observe the missile following the player. Consider
    setting a small velocity but a high steering velocity (like `2.0`) to let the
    missile rotate fast enough to approach the player.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需玩游戏并观察导弹跟随玩家。考虑设置一个较小的速度但一个较高的转向速度（如 `2.0`），以便导弹旋转得足够快，接近玩家。
- en: Now that we have the missile, let’s make it destroy the player when it is close
    enough.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了导弹，让我们让它在与玩家足够接近时摧毁玩家。
- en: Destroying the character with entity command buffers
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用实体命令缓冲区销毁角色
- en: 'To let the missile destroy the player, we need to detect when it’s close enough.
    In regular GameObjects, we can implement this via triggers (`OnTriggerEnter`),
    but discussing the DOTS physics package is out of the scope of this chapter. Instead,
    we are going to create a job with simple distance checks, as seen in the following
    image:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让导弹摧毁玩家，我们需要检测它是否足够接近。在常规 GameObject 中，我们可以通过触发器 (`OnTriggerEnter`) 来实现这一点，但讨论
    DOTS 物理包超出了本章的范围。相反，我们将创建一个具有简单距离检查的工作，如下面的图像所示：
- en: '![](img/B21361_21_34.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_34.png)'
- en: 'Figure 21.34: Distance checks in ECS'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.34：ECS 中的距离检查
- en: This job works similarly to the steering job but does squared distance checks.
    Now, the tricky part is destroying the entity. Given there could be several jobs
    running in parallel iterating entities, it’s not safe to delete an entity right
    away. The only safe place to delete, create, or modify entities’ components, operations
    also known as structural changes, is on the main thread, and jobs run in job worker
    threads. When a system makes structural changes on the main thread, a sync point
    is generated, meaning that the main thread will be blocked until all jobs iterating
    entities finish, which can cause severe delays. Another issue is that, given we
    can have several systems that require structural changes, we run the risk of introducing
    several sync points. The best approach is to accumulate several structural changes
    and let specific systems execute them – ideally, just one. This way, we reduce
    the number of sync points, and that’s the exact purpose of **Entity Command Buffer**
    (**ECB**) systems.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工作与转向工作类似，但进行平方距离检查。现在，棘手的部分是销毁实体。考虑到可能有多个工作并行迭代实体，立即删除实体是不安全的。唯一安全的地方是在主线程上删除、创建或修改实体组件，这些操作也称为结构变化，工作在作业工作者线程上运行。当一个系统在主线程上进行结构变化时，会生成一个同步点，这意味着主线程将被阻塞，直到所有迭代实体的工作完成，这可能导致严重的延迟。另一个问题是，由于我们可以有多个需要结构变化的自定义系统，我们面临引入多个同步点的风险。最佳方法是累积多个结构变化，并让特定的系统执行它们——理想情况下，只有一个。这样，我们减少了同步点的数量，这正是
    **实体命令缓冲区**（**ECB**）系统的作用。
- en: 'Structural changes can be costly in terms of performance. For more details
    on them, check this link: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/concepts-structural-changes.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/concepts-structural-changes.html)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 结构变化在性能方面可能会造成成本。有关更多详细信息，请查看此链接：[https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/concepts-structural-changes.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/concepts-structural-changes.html)
- en: ECB systems have APIs to create **Entity Command Buffers** (**ECBs**), allowing
    systems and jobs to enqueue commands in them, such as to instantiate or destroy
    entities. Our destroy system will use them to enqueue the player destruction when
    the missile is near enough. Let’s start by modifying our job to receive an ECB
    and use it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ECB 系统有 API 可以创建 **实体命令缓冲区**（**ECBs**），允许系统和任务将命令排队到其中，例如实例化或摧毁实体。我们的摧毁系统将使用它们在导弹足够接近时排队玩家摧毁。让我们先修改我们的任务以接收一个
    ECB 并使用它。
- en: '![](img/B21361_21_35.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_21_35.png)'
- en: 'Figure 21.35: Using ECBs to destroy the target entity'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.35：使用 ECB 摧毁目标实体
- en: We added a variable to pass the ECB to our job, which will be provided by the
    system when creating it. Then, we used the ECB’s `DestroyEntity` method, specifying
    that we want to destroy the target entity. The zero we provide is a way to sort
    the commands before executing them, but in this case, we don’t need any specific
    order.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个变量来传递 ECB 到我们的任务中，该变量将在创建时由系统提供。然后，我们使用了 ECB 的 `DestroyEntity` 方法，指定我们要摧毁目标实体。我们提供的零是一种在执行之前对命令进行排序的方式，但在这个情况下，我们不需要任何特定的顺序。
- en: 'To better understand the need for a sorting key in ECBs, check this link: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-entity-command-buffer-playback.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-entity-command-buffer-playback.html)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地理解在 ECB 中排序键的需求，请查看此链接：[https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-entity-command-buffer-playback.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-entity-command-buffer-playback.html)
- en: 'Then, we need to create a system like the following image:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要创建一个类似于以下图像的系统：
- en: '![](img/B21361_21_36.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_21_36.png)'
- en: 'Figure 21.36: Destroy close target system'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.36：摧毁接近目标系统
- en: 'We accessed the `Singleton` component from an ECB system called `EndSimulationEntityCommandBufferSystem`,
    using the `GetSingleton` API. This method allows us to get the unique instance
    of an ECS component, provided we are sure there’s only one. You might be wondering:
    can systems have components? And yes, they can. In data-driven games, all data
    sharing happens through components. Every system has an entity to which they can
    add components and share data with other systems and jobs. Given there’s only
    one instance of this ECB system, we know we have just one instance of the `Singleton`
    component. It has the `CreateCommandBuffer` method, which creates an ECB whose
    commands will be executed when the ECB system updates. The `EndSimulationEntityCommandBufferSystem`
    system will execute its ECB commands at the end of the simulation system before
    the presentation of the ones that render our entities’ graphics. This way, our
    jobs can enable structural changes (like destroy) to be executed safely in the
    main thread later, along with commands from other systems that use the same ECB
    system.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从名为 `EndSimulationEntityCommandBufferSystem` 的 ECB 系统中访问了 `Singleton` 组件，使用的是
    `GetSingleton` API。此方法允许我们在确定只有一个实例的情况下获取 ECS 组件的唯一实例。你可能想知道：系统可以有组件吗？答案是肯定的。在数据驱动的游戏中，所有数据共享都通过组件进行。每个系统都有一个实体，它们可以向其实例化组件并与其他系统和任务共享数据。鉴于这个
    ECB 系统只有一个实例，我们知道 `Singleton` 组件也只有一个实例。它有一个 `CreateCommandBuffer` 方法，该方法创建一个
    ECB，其命令将在 ECB 系统更新时执行。`EndSimulationEntityCommandBufferSystem` 系统将在模拟系统结束时执行其
    ECB 命令，在渲染我们实体图形的命令之前。这样，我们的任务可以在稍后安全地在主线程中执行结构更改（如摧毁），以及其他使用相同 ECB 系统的系统的命令。
- en: We need to provide the world our system lives in as the first parameter of this
    method. A world is a set of entities and systems that can run in parallel to other
    worlds. For example, in the `Netcode for Entities` package, we can run the server
    and client worlds in parallel when the player acts as the game’s host. We have
    just one world in this case.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将我们的系统所在的世界作为此方法的第一个参数提供。世界是一组可以与其他世界并行运行的实体和系统。例如，在 `Netcode for Entities`
    包中，当玩家作为游戏的主机时，我们可以并行运行服务器和客户端世界。在这种情况下，我们只有一个世界。
- en: 'Read more about worlds here: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/concepts-worlds.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/concepts-worlds.html)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里了解更多关于世界的信息：[https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/concepts-worlds.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/concepts-worlds.html)
- en: We also called the `AsParallelWriter` method, which returns an ECB version that
    allows it to be used in several threads. Remember that our job executes multiple
    instances in parallel, so the parallel writer version makes sure it’s safe to
    use in our job’s instances. Finally, we provided the ECB to the job.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还调用了`AsParallelWriter`方法，它返回一个ECB版本，允许它在多个线程中使用。记住，我们的工作在并行执行多个实例，因此并行写入器版本确保它在我们的工作实例中是安全的。最后，我们将ECB提供给工作。
- en: If you press play now and let the missile catch the player, you will see how
    it disappears! But wait! Now the console is spamming errors. While familiar, these
    errors are not quite the same as the ones we are used to receiving in GameObject-based
    projects; these are more cryptic. That’s because the error happened in bursted
    code (short for Burst-compiled code), and errors here behave a little bit differently.
    Let’s explore how to debug them.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在按播放并让导弹捕捉到玩家，你会看到它消失了！但是等等！现在控制台正在不断显示错误。虽然这些错误很熟悉，但它们与我们通常在基于GameObject的项目中收到的错误不完全一样；它们更加晦涩。这是因为错误发生在突发代码中（简称Burst-compiled
    code），这里的错误行为略有不同。让我们探索如何调试它们。
- en: Dealing with errors in bursted code
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理突发代码中的错误
- en: In the next image, you can see the error we received in the previous step.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一张图片中，你可以看到我们在上一步中收到的错误。
- en: '![](img/B21361_21_37.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_37.png)'
- en: 'Figure 21.37: Burst error logs'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.37：突发错误日志
- en: First is a familiar C# error, but the stack trace is very verbose. After carefully
    reading it, you can see that each stack trace line is prefixed by a “#” symbol,
    showing the name of the called method. Following these symbols, we can find our
    job in line 5, but not much more info. We can infer where our code failed by checking
    the next line – in this case, the `ComponentLookup` call. Given our job uses lookups
    just once, we can infer that we are trying to get the transform of the target
    entity, but that it doesn’t exist anymore.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是一个熟悉的C#错误，但堆栈跟踪非常冗长。仔细阅读后，你可以看到每行堆栈跟踪都由一个“#”符号作为前缀，显示被调用方法的名称。在这些符号之后，我们可以在第5行找到我们的工作，但信息不多。我们可以通过检查下一行来推断我们的代码失败的位置——在这种情况下，是`ComponentLookup`调用。鉴于我们的工作只使用一次查找，我们可以推断我们正在尝试获取目标实体的变换，但它已经不存在了。
- en: '![](img/B21361_21_38.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_38.png)'
- en: 'Figure 21.38: Burst error stack trace'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.38：突发错误堆栈跟踪
- en: To make stack traces clearer, you can disable Burst in the editor. That will
    make the error logs look like usual, indicating the line where the error happened.
    Disable it by unchecking the **Jobs | Burst | Enable Compilation** option. Play
    again to see that now the logs indicate the line of the job where the error happens
    (line 21). I recommend getting familiar with the Burst errors log, as in builds,
    we cannot fall back into non-bursted code without recompiling our player after
    removing the `BurstCompile` attributes. Moreover, disabling Burst while developing
    can help iteration times, given that compiling Burst code takes longer than regular
    code, and while developing, we don’t need peak performance all the time.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使堆栈跟踪更清晰，你可以在编辑器中禁用Burst。这将使错误日志看起来像通常一样，指示错误发生的行。通过取消选中**工作 | 突发 | 启用编译**选项来禁用它。再次播放以查看现在日志指示错误发生的作业行（第21行）。我建议熟悉Burst错误日志，因为在构建中，我们无法在没有重新编译我们的玩家后移除`BurstCompile`属性的情况下回退到非突发代码。此外，在开发过程中禁用Burst可以帮助迭代时间，因为编译Burst代码比常规代码要长，而在开发过程中，我们并不总是需要峰值性能。
- en: 'Regarding the error, it happened because the entity the missile was steering
    to (the player) was destroyed when we got close to it. To solve this, we can modify
    the `SteeringJob` job’s `Execute` method, like in the following image:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个错误，它发生在当我们接近导弹所指向的实体（玩家）时，该实体被摧毁了。为了解决这个问题，我们可以修改`SteeringJob`作业的`Execute`方法，如下面的图片所示：
- en: '![](img/B21361_21_39.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_39.png)'
- en: 'Figure 21.39: Checking if the entity has LocalToWorld components'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.39：检查实体是否有LocalToWorld组件
- en: 'We also need to do the same for the `DestroyCloseTargetJob` job’s `Execute`
    method:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对`DestroyCloseTargetJob`作业的`Execute`方法做同样的处理：
- en: '![](img/B21361_21_40.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_21_40.png)'
- en: 'Figure 21.40: Checking if the entity has LocalToWorld components'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.40：检查实体是否有LocalToWorld组件
- en: Now, we not only check if the target entity is null but also if it has a transform
    using the `TryGetComponent` lookup method. This method returns a boolean indicating
    whether the requested entity has the requested component, returning it in the
    out parameter. If the entity doesn’t have the component or the entity doesn’t
    exist, the method will return `false`. This way, we are quitting the job early
    if the target entity doesn’t have the component or was destroyed. In MonoBehaviours,
    a null check would be enough, but in DOTS, it isn’t. Leaving aside the specifics
    that allow that in MonoBehaviours, an `Entity` variable like target, internally,
    is just an integer ID. ECS uses it in a lookup table to determine where the entity
    data is stored (which chunk). `Entity.Null` is just an invalid ID, and given Unity
    won’t set all the entity references to have an invalid ID when it is destroyed,
    the null check is still successful. This way, even if the target entity is destroyed,
    the entity referenced in our `Target` component still has a valid ID. Also, observe
    how we removed the line where we used the lookup, given the `TryGetMethod` already
    gives us the target’s `LocalToWorld` component in the `out` parameter, so there’s
    no need to get the component twice.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不仅检查目标实体是否为空，还检查它是否使用了 `TryGetComponent` 查找方法来获取转换。此方法返回一个布尔值，指示请求的实体是否具有请求的组件，并将其返回在输出参数中。如果实体没有组件或实体不存在，该方法将返回
    `false`。这样，如果目标实体没有组件或已被销毁，我们就可以提前退出工作。在 MonoBehaviours 中，仅进行空检查就足够了，但在 DOTS 中则不行。抛开在
    MonoBehaviours 中允许这样做的一些具体细节，一个像 target 这样的 `Entity` 变量在内部只是一个整数 ID。ECS 使用它在查找表中确定实体数据存储的位置（哪个块）。`Entity.Null`
    只是一个无效的 ID，并且由于 Unity 不会在销毁时将所有实体引用设置为无效 ID，因此空检查仍然有效。这样，即使目标实体被销毁，我们 `Target`
    组件中引用的实体仍然有一个有效的 ID。此外，注意我们如何移除了使用查找的行，因为 `TryGetMethod` 已经在 `out` 参数中给出了目标的 `LocalToWorld`
    组件，所以没有必要获取组件两次。
- en: You can go the extra mile and set the target to `Entity.Null` if the `TryGetComponent`
    method fails. Given using lookups is performance-heavy, early-quitting the method
    before we use it would be better.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `TryGetComponent` 方法失败，你可以将目标设置为 `Entity.Null`。鉴于使用查找是性能密集型的，在使用它之前提前退出方法会更好。
- en: Now, let’s instantiate more missiles to make the game more interesting.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实例化更多的导弹，使游戏更有趣。
- en: Instantiating missiles with entity Prefabs
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用实体 Prefab 实例化导弹
- en: We can approach the missile spawner by creating `spawner` entities – entities
    with a `Spawner` component that references the Prefab to instantiate and has the
    amount to instantiate and the frequency of instantiation. You might think, shouldn’t
    we create separate components for each piece of spawner data? We can do that,
    but there’s a performance overhead for each component used in a job and entity
    queries. We don’t have any reason to think that, in this example, any of our spawner
    data will be used in a different way, so this time we will use a single component.
    Try to mix data into a single component whenever you know all of it will be accessed
    at the same time.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建具有 `Spawner` 组件的 `spawner` 实体来接近导弹生成器——这些实体引用要实例化的 Prefab，并具有要实例化的数量和实例化频率。你可能认为，我们不应该为每个生成器数据创建单独的组件吗？我们可以这样做，但每个在作业和实体查询中使用的组件都会带来性能开销。我们没有理由认为在这个例子中，我们的任何生成器数据将以不同的方式使用，所以这次我们将使用单个组件。当你知道所有数据都将同时被访问时，尽量将数据混合到单个组件中。
- en: 'The `Spawner` component will look like the following image:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spawner` 组件将看起来像以下图片：'
- en: '![](img/B21361_21_41.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_21_41.png)'
- en: 'Figure 21.41: The Spawner component and baker'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.41：Spawner 组件和 baker
- en: Notice that our `Spawner` runtime component has a `Prefab` entity field. Before,
    we used such a field to reference the missile’s target, but now we are using it
    to reference the Prefab to instantiate. We will create the missile Prefab and
    reference it in the spawner authoring component using a `GameObject` field. The
    Prefab reference can be converted using the `GetEntity` method again. We also
    have a target reference, given we want the spawned missiles to follow the player.
    The spawner needs to provide the target reference to the missiles. Remember to
    create the `spawner` GameObject with the `spawner` components in the subscene
    and configure it, dragging the `player` to the `target` property and the missile
    `Prefab` to the `Prefab` property.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的`Spawner`运行时组件有一个`Prefab`实体字段。以前，我们使用这样的字段来引用导弹的目标，但现在我们使用它来引用要实例化的预制体。我们将创建导弹预制体，并使用`GameObject`字段在生成器创作组件中引用它。可以使用`GetEntity`方法再次转换预制体引用。我们还有一个目标引用，因为我们想让生成的导弹跟随玩家。生成器需要向导弹提供目标引用。请记住，在子场景中创建带有`spawner`组件的`spawner`GameObject，并对其进行配置，将`player`拖到`target`属性，将导弹`Prefab`拖到`Prefab`属性。
- en: 'The Prefabs referenced by an ECS component will also be converted as an entity
    in our subscene, but they will have the special Prefab tag component. This allows
    the Prefab entity to exist in the subscene but will make ECS ignore it to prevent
    rendering or updating it. For more information about Prefab baking, check this:
    [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/baking-prefabs.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/baking-prefabs.html)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 由ECS组件引用的预制体也将被转换为我们的子场景中的实体，但它们将具有特殊的预制体标签组件。这允许预制体实体存在于子场景中，但会使ECS忽略它以防止渲染或更新它。有关预制体烘焙的更多信息，请参阅：[https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/baking-prefabs.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/baking-prefabs.html)
- en: 'Now, we need a system and a job to iterate all spawner entities, using an ECB
    to instantiate missiles:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个系统和一项工作来遍历所有生成器实体，使用ECB来实例化导弹：
- en: '![](img/B21361_21_42.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_21_42.png)'
- en: 'Figure 21.42: The missile spawner job'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.42：导弹生成器工作
- en: While we can instantiate our Prefabs one by one, it is better to instantiate
    several in one shot, so we instead created an array of entities and provided it
    to the Instantiate method. This Instantiate method overload creates as many instances
    as elements in the provided array, filling it with references to the soon-to-be-created
    instances (we are using ECBs). Then, we iterate that array and set the position
    of the missiles in a way that they spawn one separated from the others by 5 units.
    We also make them target the player by setting their target component. It might
    be confusing to change the value of a component by replacing it with a new component
    instance, but it’s a common practice in ECS. It is also very cheap, as components
    are structs.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以逐个实例化我们的预制体，但一次性实例化多个会更好，所以我们创建了一个实体数组并将其提供给`Instantiate`方法。这个`Instantiate`方法的重载会根据提供的数组中的元素数量创建实例，并用即将创建的实例的引用（我们正在使用ECB）填充它。然后，我们遍历这个数组，以5个单位间隔的方式设置导弹的位置。我们还通过设置目标组件使它们瞄准玩家。通过用新的组件实例替换来更改组件的值可能会让人困惑，但在ECS中这是一种常见的做法。由于组件是结构体，所以这也非常高效。
- en: 'Finally, we need the system to schedule the job:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要系统安排工作：
- en: '![](img/B21361_21_43.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_21_43.png)'
- en: 'Figure 21.43: The spawner system'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.43：生成器系统
- en: In the `OnUpdate` method, the only new thing is the usage of `Time.ElapsedTime`
    to get the current game time. But then you can see the addition of an `OnCreate`
    method, the equivalent of `Awake` for a system. Here, we use the `RequireForUpdate`
    method to specify that we need the existence of at least one entity with the `Player`
    component for this system to execute. This way, we prevent the system from instantiating
    missiles when the `Player` is destroyed.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnUpdate`方法中，唯一的新特性是使用`Time.ElapsedTime`来获取当前游戏时间。但随后你可以看到新增了一个`OnCreate`方法，它是系统的`Awake`方法的等价物。在这里，我们使用`RequireForUpdate`方法来指定我们需要至少存在一个带有`Player`组件的实体，以便此系统执行。这样，我们防止在`Player`被销毁时系统实例化导弹。
- en: Now that we have our spawner system, let’s make the camera follow our character.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的生成器系统，让我们让摄像机跟随我们的角色。
- en: Making the camera follow our character
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让摄像机跟随我们的角色
- en: 'Our camera is still a regular GameObject, but our player is an entity. Systems
    can access GameObjects in their `OnUpdate` method, provided that the method has
    not been compiled with the Burst compiler. The system to make the camera follow
    our character will look like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的相机仍然是一个普通的 GameObject，但我们的玩家是一个实体。系统可以在其 `OnUpdate` 方法中访问 GameObject，前提是该方法是未使用
    Burst 编译器编译的。使相机跟随我们的角色的系统将看起来像这样：
- en: '![](img/B21361_21_44.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图21.44](img/B21361_21_44.png)'
- en: 'Figure 21.44: The system for the camera to follow the player'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.44：相机跟随玩家的系统
- en: As stated before, `OnUpdate` is not burst (it doesn’t have the *BurstCompile*
    attribute) and won’t use jobs, given it needs to access the main camera and its
    transform, which are non-HPC#-compatible reference types. Then, we used the `TryGetSingletonEntity`
    API to retrieve the reference to the only entity we expect to have the `Player`
    tag. Given missiles can destroy the player, we also use this API to check if the
    player entity still exists. Then, we use the `GetComponent` method to get the
    position of the existing player entity. While we could have used component lookups
    as we did before, given we are writing code directly in the system, we can use
    this method as a short way to do the same.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`OnUpdate` 不是爆发式（它没有 `*BurstCompile*` 属性）且不会使用作业，因为它需要访问主相机及其变换，这些是非 HPC#
    兼容的引用类型。然后，我们使用了 `TryGetSingletonEntity` API 来检索我们期望具有 `Player` 标签的唯一实体的引用。鉴于导弹可以摧毁玩家，我们也使用此
    API 来检查玩家实体是否仍然存在。然后，我们使用 `GetComponent` 方法来获取现有玩家实体的位置。虽然我们可以像之前那样使用组件查找，但鉴于我们直接在系统中编写代码，我们可以使用这种方法作为完成相同任务的快捷方式。
- en: You have created your first DOTS game! Remember, you can get access to the full
    project made in this chapter in the book’s Git repository. Finally, as always,
    there is way more to learn about DOTS, so let’s do a brief exploration of some
    of the most important remaining APIs.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经创建了您的第一个 DOTS 游戏！记住，您可以在本书的 Git 仓库中找到本章制作的完整项目。最后，一如既往，关于 DOTS 的学习还有很多，所以让我们简要探索一些最重要的剩余
    API。
- en: Exploring other DOTS features
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索其他 DOTS 功能
- en: 'Several topics in this book deserve their own books, and ECS is no exception.
    Picking the most essential APIs to explain in this chapter and keeping the chapter
    as short as possible was quite difficult, as there is so much to explore. Because
    of that, aside from all the useful additional info we left in the info boxes,
    here I leave you a list of other DOTS concepts worth checking:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中有几个主题值得有它们自己的书籍，ECS 也不例外。在本章中挑选最重要的 API 来解释，并尽可能使章节简短，这相当困难，因为有很多东西可以探索。因此，除了我们在信息框中留下的所有有用附加信息外，我还为您留下一份其他值得检查的
    DOTS 概念列表：
- en: '**SystemAPI.Query**: A way to iterate entities in a system without jobs. Useful
    for entity-iterating code that uses managed references or static variables. Also,
    for simple things that are fast to execute, avoiding job scheduling costs. Link:
    [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-systemapi-query.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-systemapi-query.html)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SystemAPI.Query**：在不使用作业的情况下迭代系统中实体的一种方式。对于使用托管引用或静态变量的实体迭代代码非常有用。对于简单且执行速度快的事情，可以避免作业调度的成本。链接：[https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-systemapi-query.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-systemapi-query.html)'
- en: '**Entity Queries**: As explained before, the way jobs and other ECS APIs (like
    `SystemAPI.Query`) iterate entities. Link: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-entityquery-intro.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-entityquery-intro.html
    )'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体查询**：如前所述，作业和其他 ECS API（如 `SystemAPI.Query`）迭代实体的方式。链接：[https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-entityquery-intro.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-entityquery-intro.html)'
- en: '**Enableable Components**: Components that can be disabled. Entity queries
    will ignore entities that have their required components disabled. Useful for
    toggling on and off entity behaviors without adding/removing tag components, which
    is expensive because they need structural changes. Link: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-enableable.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-enableable.html)'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可启用组件**：可以禁用的组件。实体查询将忽略其所需组件被禁用的实体。这对于在无需添加/删除标签组件的情况下切换实体行为非常有用，因为这些操作成本高昂，因为它们需要结构变化。链接：[https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-enableable.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-enableable.html)'
- en: '**Cleanup Components**: The ECS equivalent to the `OnDestroy` event. Link:
    [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-cleanup.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-cleanup.html)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清理组件**：ECS 对应于 `OnDestroy` 事件的组件。链接：[https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-cleanup.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-cleanup.html)'
- en: '**Dynamic Buffers**: The ECS way to have array-like data in components. Link:
    [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-buffer.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-buffer.html)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态缓冲区**：ECS 中在组件中拥有类似数组数据的方式。链接：[https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-buffer.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-buffer.html)'
- en: '**Blob Assets**: The ECS equivalent of scriptable objects. Link: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/blob-assets-intro.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/blob-assets-intro.html)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blob 资产**：ECS 对应的可脚本化对象。链接：[https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/blob-assets-intro.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/blob-assets-intro.html)'
- en: '**Content Management**: The ECS version of Addressables. Link: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/content-management-intro.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/content-management-intro.html)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容管理**：Addressables 的 ECS 版本。链接：[https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/content-management-intro.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/content-management-intro.html)'
- en: 'Scene Loading: The ECS way of loading subscenes. Link: [https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/conversion-scene-overview.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/conversion-scene-overview.html)'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景加载：ECS 加载子场景的方式。链接：[https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/conversion-scene-overview.html](mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/conversion-scene-overview.html)
- en: 'Physics and Collisions: The ECS version of the physics system. Link: [https://docs.unity3d.com/Packages/com.unity.physics@1.0/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.physics@1.0/manual/index.html)'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理和碰撞：物理系统的 ECS 版本。链接：[https://docs.unity3d.com/Packages/com.unity.physics@1.0/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.physics@1.0/manual/index.html)
- en: 'Netcode for Entities: The ECS version of the networking system. Link: [https://docs.unity3d.com/Packages/com.unity.netcode@1.0/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.netcode@1.0/manual/index.html)'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体网络代码：网络系统的 ECS 版本。链接：[https://docs.unity3d.com/Packages/com.unity.netcode@1.0/manual/index.html](mailto:https://docs.unity3d.com/Packages/com.unity.netcode@1.0/manual/index.html)
- en: 'DOTS Best Practices: An extensive guide about DOTS best practices to maximize
    your game’s performance and understand DOTS internals: [https://learn.unity.com/course/dots-best-practices](https://learn.unity.com/course/dots-best-practices)'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOTS 最佳实践：关于 DOTS 最佳实践的全面指南，旨在最大化您游戏性能并理解 DOTS 内部机制：[https://learn.unity.com/course/dots-best-practices](https://learn.unity.com/course/dots-best-practices)
- en: 'ECS Samples: A Git repository containing several ECS samples and tutorials:
    [https://github.com/Unity-Technologies/EntityComponentSystemSamples](https://github.com/Unity-Technologies/EntityComponentSystemSamples)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECS 示例：一个包含多个 ECS 示例和教程的 Git 仓库：[https://github.com/Unity-Technologies/EntityComponentSystemSamples](https://github.com/Unity-Technologies/EntityComponentSystemSamples)
- en: Most of the links provided point to the ECS documentation. It’s recommended
    to read it entirely to know about all the tools you have for creating ECS applications.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的大多数链接都指向 ECS 文档。建议您通读全文，以便了解您用于创建 ECS 应用程序的所有工具。
- en: In this section, we have used input and tag components to move our player and
    component lookups to get info about other entities, and looked at diverse usages
    of entity command buffers to instantiate and destroy entities, and how to make
    our GameObject camera follow our ECS character. We also discussed different extra
    topics to deepen your DOTS knowledge.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用了输入和标签组件来移动我们的玩家，以及组件查找来获取其他实体的信息，并探讨了实体命令缓冲区的多种用法，包括实例化和销毁实体，以及如何使我们的
    GameObject 相机跟随 ECS 角色。我们还讨论了不同的额外主题，以加深您对 DOTS 的了解。
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to start using DOTS by creating our own components
    and systems to add gameplay to a simple game. We saw how to use input, and the
    DOTS transform API to move and rotate objects, and we also saw how to spawn and
    destroy objects.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过创建自己的组件和系统来开始使用 DOTS，为简单游戏添加游戏玩法。我们看到了如何使用输入和 DOTS 变换 API 来移动和旋转对象，还看到了如何生成和销毁对象。
- en: DOTS is a new engine on its own, running inside Unity. The way it works is vastly
    different, and except for a few systems like the rendering pipelines, almost all
    DOTS features work very differently from their GameObject counterparts. Also,
    DOTS is still quite new, meaning it still has missing features and could be subjected
    to substantial changes in the next versions.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: DOTS 是一个独立的引擎，运行在 Unity 内部。它的工作方式与以往大相径庭，除了渲染管线等少数系统外，几乎所有的 DOTS 功能都与 GameObject
    的对应功能有很大不同。此外，DOTS 仍然相对较新，这意味着它仍然缺少一些功能，并且可能在下一个版本中经历重大变化。
- en: This makes it a possible risk for creating new projects, but on the other hand,
    the performance it can achieve could be decisive for big and ambitious projects.
    It is an interesting piece of technology that can revolutionize game development,
    and every day, it is getting more powerful and stable. It’s a good time to start
    learning about it and be prepared for the future.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得创建新项目存在一定的风险，但另一方面，它所能达到的性能对于大型和雄心勃勃的项目可能是决定性的。这是一项可以彻底改变游戏开发的技术，而且每天都在变得更加强大和稳定。现在是开始学习它并为未来做准备的好时机。
- en: Learn more on Discord
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity 游戏开发专家以及作者本人一起阅读这本书。提出问题，为其他读者提供解决方案，通过 Ask Me Anything 会话与作者聊天，等等。扫描二维码或访问链接加入社区：
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: '![](img/QR_Code1498477041053909218.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1498477041053909218.png)'
