- en: Chapter 11. The Asynchronous Programming Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章。异步编程模型
- en: In this chapter, we will be learning about the new `async` and `await` keywords
    provided in .NET 4.5, along with the **Asynchronous Programming Model** (**APM**).
    The `async` and `await` keywords are .NET's latest method for making asynchronous
    and multithreaded programming simple for the developer. These new keywords make
    using the `BackgroundWorker` component harder to justify. The `async` keyword
    makes it seamless to turn an ordinary method into an asynchronous method that
    runs on a separate thread. Then you can continue processing in the main thread.
    When you are ready to wait for the results of the asynchronous method, you can
    then use the `await` keyword in your main thread to block until the method returns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 .NET 4.5 中提供的新的 `async` 和 `await` 关键字，以及 **异步编程模型**（**APM**）。`async`
    和 `await` 关键字是 .NET 为开发者提供的一种最新方法，使异步和多线程编程变得简单。这些新关键字使得使用 `BackgroundWorker`
    组件变得更加难以证明其合理性。`async` 关键字使得将普通方法转换为在单独线程上运行的异步方法变得无缝。然后你可以在主线程中继续处理。当你准备好等待异步方法的结果时，你可以在主线程中使用
    `await` 关键字来阻塞，直到方法返回。
- en: The Asynchronous Programming Model uses the `IAsyncResult` interface to accomplish
    the same type of design. In this design pattern, you create a delegate and then
    use the `BeginInvoke` and `EndInvoke` methods of the delegate to start the method
    and wait on it to complete. You can also use the `IAsyncResult` interface that
    is returned by the `BeginInvoke` method to poll to see if the asynchronous method
    has completed, or set a `wait` handle for the asynchronous method to complete.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程模型使用 `IAsyncResult` 接口来完成相同类型的设计。在这个设计模式中，你创建一个委托，然后使用该委托的 `BeginInvoke`
    和 `EndInvoke` 方法来启动方法并等待其完成。你也可以使用 `BeginInvoke` 方法返回的 `IAsyncResult` 接口来轮询以查看异步方法是否已完成，或者为异步方法设置一个
    `wait` 处理程序以完成。
- en: These two methods give us easy ways to implement functionality similar to the
    `BackgroundWorker` component that is used so heavily in Windows Forms applications
    and earlier versions of .NET. This functionality is especially useful in desktop
    applications when we do not want the main thread of the application to block.
    There are few things worse in desktop application design than having a user click
    on a button and the whole user interface freezes while some function is being
    performed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法为我们提供了实现类似于在 Windows Forms 应用程序和 .NET 早期版本中广泛使用的 `BackgroundWorker` 组件的功能的简单方法。这种功能在桌面应用程序中特别有用，当我们不希望应用程序的主线程被阻塞时。在桌面应用程序设计中，没有什么比用户点击按钮而整个用户界面在某个功能执行时冻结更糟糕的了。
- en: Let's start by looking at the Asynchronous Programming Model and how to use
    this design pattern to run a method in a thread separate from the main thread.
    Then we will have the main thread wait on its results.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看异步编程模型以及如何使用这种设计模式在主线程之外运行一个方法。然后我们将让主线程等待其结果。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The Asynchronous Programming Model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程模型
- en: Using an `AsyncCallback` delegate method
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `AsyncCallback` 委托方法
- en: The `async` and `await` keywords
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async` 和 `await` 关键字'
- en: Introduction to the Asynchronous Programming Model
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程模型简介
- en: The Asynchronous Programming Model is used by .NET classes to implement asynchronous
    designs. One example is the `BeginRead` and `EndRead` methods of `FileStream`.
    This allows the `FileStream` class to implement an asynchronous file read. The
    `StreamReader` and `StreamWriter` classes also have asynchronous methods. They
    implement this functionality using the `IAsyncResult` interface. In your customer
    classes, you can also implement this interface to allow you to have asynchronous
    functionality.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程模型被 .NET 类用于实现异步设计。一个例子是 `FileStream` 的 `BeginRead` 和 `EndRead` 方法。这允许 `FileStream`
    类实现异步文件读取。`StreamReader` 和 `StreamWriter` 类也有异步方法。它们使用 `IAsyncResult` 接口来实现这一功能。在你的自定义类中，你也可以实现这个接口，以便你拥有异步功能。
- en: The naming convention when using this interface is to prefix your method names
    with `Begin` and `End`. So, you would name one `BeginMyMethod` and the other `EndMyMethod`.
    The first method is the one you execute asynchronously. The second method is what
    you call to block your main thread when you want to wait on the `Begin` method
    to end and have it also return the results.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用此接口时，命名约定是在方法名称前加上`Begin`和`End`前缀。所以，你会命名一个`BeginMyMethod`和一个`EndMyMethod`。第一个方法是你要异步执行的方法。第二个方法是在你想要等待`Begin`方法结束并返回结果时调用以阻塞主线程的方法。
- en: Now, let's look at an example using the `BeginRead` and `EndRead` methods of
    the `FileStream` class. This same technique can be implemented using your own
    classes and implementing the `IAsyncResult` interface. You do not have to prefix
    your method names with `Begin` and `End`, but it is a good programming practice
    to follow the naming convention so that future developers using your classes will
    intuitively understand how they operate.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用`FileStream`类的`BeginRead`和`EndRead`方法的示例。同样的技术可以使用你自己的类并实现`IAsyncResult`接口来实现。你不需要在方法名称前加上`Begin`和`End`前缀，但遵循命名约定是一种良好的编程实践，这样未来的开发者在使用你的类时可以直观地理解它们的工作方式。
- en: How to do it
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'First, let''s open up Visual Studio and create a new console project called
    `FileReadAsync`. Then, let''s perform the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们打开Visual Studio并创建一个名为`FileReadAsync`的新控制台项目。然后，让我们执行以下步骤：
- en: 'Add two `using` statements for the `IO` and `Threading` classes, as shown here:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`IO`和`Threading`类添加两个`using`语句，如下所示：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s add the following code to the `Main` method:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将以下代码添加到`Main`方法中：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, finally, we need to add a file called `InputData.txt` to `C:\projects`.
    This will be the file that we read asynchronously. It can contain any text that
    you would like; for our example, the `InputData.txt` file looks like the following
    screenshot:![How to do it](img/8321EN_11_01.jpg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，最后，我们需要在`C:\projects`中添加一个名为`InputData.txt`的文件。这将是我们将要异步读取的文件。它可以包含任何你想要的文本；在我们的例子中，`InputData.txt`文件看起来如下截图所示：![如何操作](img/8321EN_11_01.jpg)
- en: 'Now, let''s build and run our application. You should see a screen like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建并运行我们的应用程序。你应该看到一个像这样的屏幕：
- en: '![How to do it](img/8321EN_11_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_11_02.jpg)'
- en: 'The program is waiting on the user to click on the return button; once the
    button is clicked, it will execute the asynchronous read of the data file. Once
    you click on return, you should see the following results:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 程序正在等待用户点击回车按钮；一旦按钮被点击，它将执行数据文件的非阻塞读取。一旦你点击回车，你应该看到以下结果：
- en: '![How to do it](img/8321EN_11_03.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_11_03.jpg)'
- en: If you click return again, the application will finish and exit. So, let's look
    at how this works.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次点击回车键，应用程序将结束并退出。所以，让我们看看它是如何工作的。
- en: How it works
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'This is a very simple example of an existing .NET class, `FileStream`, that
    implements the Asynchronous Programming Model with the two methods, `BeginRead`
    and `EndRead`. If you look at the method definition for the `BeginRead` method,
    you will see that it implements the `IAsyncResult` interface:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个现有的.NET类`FileStream`的非常简单的示例，它使用`BeginRead`和`EndRead`这两个方法实现了异步编程模型。如果你查看`BeginRead`方法的方法定义，你会看到它实现了`IAsyncResult`接口：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also view the method definition for the `EndRead` method as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以查看`EndRead`方法的方法定义，如下所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s look at your example project. In the following lines of code, we
    set up the `FileStream` object called `FS`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看你的示例项目。在以下代码行中，我们设置了名为`FS`的`FileStream`对象：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here we are declaring a new `FileStream` object with parameters that define
    the file to stream, the mode to open, the access to read, and the option to read
    asynchronously.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用定义文件流、打开模式、读取访问和异步读取选项的参数声明一个新的`FileStream`对象。
- en: 'Then we initiate the read operation asynchronously with the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用以下代码异步启动读取操作：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We then do some other work while the read operation is happening asynchronously
    on another thread. This "other" work is represented by the following three `Console.WriteLine`
    statements:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取操作在另一个线程上异步进行时，我们进行一些其他工作。这个“其他”工作由以下三个`Console.WriteLine`语句表示：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we block the main thread and wait on the `async` write to complete using
    this statement:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们阻塞主线程，并使用此语句等待异步写入完成：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This statement will complete when the read is complete and return the `IAsyncResult`
    object and the number of bytes read. We then write these results to the console
    using the following statements:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取完成时，此语句将完成并返回`IAsyncResult`对象和读取的字节数。然后我们使用以下语句将这些结果写入控制台：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We examine the `IsCompleted` method of `IAsyncResult` to make sure the read
    has completed even though we know it has because we blocked waiting on the `EndRead`
    method. We did this to preview another design pattern for the Asynchronous Programming
    Model, which we will not demonstrate in this chapter—the polling method. Instead
    of calling the `EndRead` method to block the main thread waiting on the `Main`
    method to complete, we can create a loop and periodically check the `IsCompleted`
    property of the `IAsyncResult` object returned by the `BeginRead` method. This
    is handy if we want to show a progress update throughout the read operation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查`IAsyncResult`的`IsCompleted`方法，以确保读取已完成，尽管我们知道它已经完成，因为我们阻塞等待`EndRead`方法。我们这样做是为了预览异步编程模型的一个设计模式，我们将在本章中不演示——轮询方法。我们不是通过调用`EndRead`方法来阻塞主线程等待`Main`方法完成，而是可以创建一个循环，并定期检查`BeginRead`方法返回的`IAsyncResult`对象的`IsCompleted`属性。如果我们想在读取操作期间显示进度更新，这会很有用。
- en: A third way to implement the Asynchronous Programming Model involves using a
    delegate method for processing when the read operation has completed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实现异步编程模型的第三种方法是在读取操作完成后使用委托方法进行处理。
- en: Using an AsyncCallback delegate method
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AsyncCallback委托方法
- en: We have seen how we can use the APM design pattern that is implemented in the
    `FileStream` class to perform an asynchronous read and then wait on the results.
    We also mentioned how we can poll to see if the asynchronous read has completed
    instead of blocking the main thread. Now, we will see how we can execute a delegate
    method when the asynchronous read has completed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用在`FileStream`类中实现的APM设计模式来执行异步读取，然后等待结果。我们还提到过，我们可以轮询以查看异步读取是否已完成，而不是阻塞主线程。现在，我们将看到如何在异步读取完成后执行委托方法。
- en: Using this method, we do not have to block the main thread waiting or perform
    the work of polling the `IsCompleted` property to see when the read has completed.
    We simply execute the `BeginRead` method and pass it a delegate method. We then
    go on our way and, when the read completes, the delegate method will be executed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们不需要阻塞主线程等待或执行轮询`IsCompleted`属性的工作来查看读取何时完成。我们只需执行`BeginRead`方法并传递一个委托方法。然后我们继续前进，当读取完成时，委托方法将被执行。
- en: 'Let''s look at the method header for the `BeginRead` method of the `FileStream`
    class. The following is the method definition:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`FileStream`类的`BeginRead`方法的方法头。以下是该方法的定义：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You will see that the fourth parameter passed to this method is an `AsyncCallback`
    delegate. In our previous example, we passed a null value for this parameter when
    we called this method. This time let's use a delegate method.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到传递给此方法的第四个参数是一个`AsyncCallback`委托。在我们之前的例子中，当我们调用此方法时，我们为这个参数传递了一个null值。这次让我们使用一个委托方法。
- en: How to do it
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现
- en: 'Let''s open Visual Studio and create a new console application called `FileReadAsyncWithDelegate`.
    Once this has been created, we will perform the following steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开Visual Studio并创建一个名为`FileReadAsyncWithDelegate`的新控制台应用程序。一旦创建完成，我们将执行以下步骤：
- en: 'Add two `using` statements for the `IO` and `Threading` classes, as shown:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`IO`和`Threading`类添加两个`using`语句，如下所示：
- en: '[PRE10]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, let''s add the following code to the `Main` method of our application:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们将以下代码添加到我们的应用程序的`Main`方法中：
- en: '[PRE11]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Before the `Main` method, we need to declare a static byte array so that it
    is available to both the `Main` method and our new delegate method. Add the following
    statement before the `Main` method.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法之前，我们需要声明一个静态字节数组，以便它对`Main`方法和我们的新委托方法都可用。在`Main`方法之前添加以下语句：
- en: '[PRE12]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we need to add our delegate method. Add the following code for our delegate
    method:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要添加我们的委托方法。为我们的委托方法添加以下代码：
- en: '[PRE13]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That is all the code we will need for this example. We do still need our `InputData.txt`
    file in `C:\projects`. It should still be there from when we created it in the
    last exercise.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本例中我们需要的所有代码。我们仍然需要在`C:\projects`中保留我们的`InputData.txt`文件。它应该仍然在从上次练习中创建它时存在。
- en: 'Now, build and run the application and you should see the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建并运行应用程序，你应该会看到以下内容：
- en: '![How to do it](img/8321EN_11_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现](img/8321EN_11_04.jpg)'
- en: 'Then press return and the application should display the following results:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按回车键，应用程序应该显示以下结果：
- en: '![How to do it](img/8321EN_11_05.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点](img/8321EN_11_05.jpg)'
- en: You will see that the results look almost identical to the results from the
    previous exercise. This is true. But how we achieve them is very different. This
    time, instead of blocking the main thread that is waiting on the read to complete,
    we initiated a delegate method on a separate thread and waited there for the read
    to complete and then display the results. Let's look at how we did it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到结果几乎与之前练习的结果相同。这是真的。但我们实现它们的方式非常不同。这次，我们不是阻塞等待读取操作完成的主线程，而是在一个单独的线程上启动了一个委托方法，并等待读取操作完成，然后显示结果。让我们看看我们是如何做到的。
- en: How it works
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'First, let''s look at our `Main` method. This time it is more streamlined and
    does less work. It essentially just creates the `FileStream` object and calls
    the `BeginRead` method and passes it a delegate method. That is it. Then it goes
    about its business. It does not wait on the read to complete, does not process
    the results, and does not close the `FileStream` object. The following code shows
    this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们的 `Main` 方法。这次它更加精简，做的工作更少。它本质上只是创建 `FileStream` 对象，调用 `BeginRead`
    方法，并传递一个委托方法。就是这样。然后它继续执行其他任务。它不会等待读取操作完成，不会处理结果，也不会关闭 `FileStream` 对象。以下代码展示了这一点：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The key here is the following statement:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于以下语句：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, instead of the fourth and fifth parameters being `null`, we pass a delegate
    method and the `FileStream` object to this method. This allows the `Main` method
    to then go about its business.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第四个和第五个参数不再是 `null`，我们向这个方法传递一个委托方法和 `FileStream` 对象。这允许 `Main` 方法继续执行其他任务。
- en: 'Now, let''s look at where the work is now being done—the delegate method, `ReadComplete`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看工作现在正在进行的地方——委托方法，`ReadComplete`：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first thing you will notice is that the `AsyncCallback` delegate definition
    requires a method that returns no value and receives an `IAsyncResult` parameter
    as input.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会注意到，`AsyncCallback` 委托定义需要一个不返回任何值且接收一个 `IAsyncResult` 参数作为输入的方法。
- en: 'We then get the `FileStream` object state using the following statement:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用以下语句获取 `FileStream` 对象的状态：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we wait on the read to complete and get the results using this statement:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们等待读取操作完成，并使用以下语句获取结果：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And finally, we process the results using these statements:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用以下语句处理结果：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That is all there is to it. We have spent the last two sections of this chapter
    looking at three ways to implement the APM:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容。我们已经在本章的最后两部分中探讨了三种实现 APM 的方法：
- en: Call the `Begin` method name, perform some action, and then block using the
    `End` method name until the asynchronous action is finished
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `Begin` 方法名，执行一些操作，然后使用 `End` 方法名进行阻塞，直到异步操作完成
- en: Call the `Begin` method name, continue processing, and periodically check the
    `IsCompleted` property of the `IAsyncResult` object to know when the asynchronous
    operation is completed
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `Begin` 方法名，继续处理，并定期检查 `IAsyncResult` 对象的 `IsCompleted` 属性，以了解异步操作何时完成
- en: Call the `Begin` method name to initiate the asynchronous operation and then
    implement a delegate method on a separate thread to wait on the asynchronous operation
    and process the results
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `Begin` 方法名以启动异步操作，然后在单独的线程上实现一个委托方法，等待异步操作并处理结果
- en: For the rest of the chapter, we will explore the new `async` and `await` keywords
    that were introduced in .NET Version 4.5.1.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将探讨在 .NET 版本 4.5.1 中引入的新 `async` 和 `await` 关键字。
- en: The async and await keywords
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步和 await 关键字
- en: 'In .NET 4.5, Microsoft introduced the `async` and `await` keywords that made
    it very easy for developers to implement asynchronous functionality in their methods.
    Adding the `async` keyword to the method header tells .NET''s CLR to run this
    method in a separate thread in the threadpool if it determines that the following
    two conditions are met: first, that running it in a separate thread will increase
    performance, and second, the `await` keyword is used in the method. An `async`
    method will either return void, `Task`, or `Task<TResult>`. Also, the naming convention
    is to postfix any methods that use the `async` keyword with `Async`. So, the method
    name should be `MyMethodAsync`. That is all there is to it. The implementation
    is similar to the APM but does not use the `IAsyncResult` interface or implement
    it.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 4.5中，Microsoft引入了`async`和`await`关键字，这使得开发者在方法中实现异步功能变得非常容易。将`async`关键字添加到方法头中告诉.NET的CLR，如果满足以下两个条件，则在该线程池中的单独线程上运行此方法：首先，运行它将提高性能；其次，在方法中使用`await`关键字。`async`方法将返回`void`、`Task`或`Task<TResult>`。此外，命名约定是将使用`async`关键字的任何方法后缀为`Async`。因此，方法名称应该是`MyMethodAsync`。这就是全部内容。实现与APM类似，但不使用`IAsyncResult`接口或实现它。
- en: The design pattern for using this method is for your program to run a method
    that uses the `async` keyword by running it in a separate task. It is then free
    to continue on. If the `async` method does not have a return value, then the main
    thread can just continue on. If there is a return value that the `Main` method
    cares about or wants to know when the asynchronous operation has completed, it
    can wait on the asynchronous task to complete and view the results. In the asynchronous
    task, the method will perform functions on its own thread and then call the `await`
    keyword when it wants to wait on some action to complete.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法的模式是让程序运行一个使用`async`关键字的独立任务中的方法。然后它可以继续执行。如果`async`方法没有返回值，则主线程可以继续执行。如果有主方法关心的返回值或想要知道异步操作何时完成，它可以在异步任务上等待完成并查看结果。在异步任务中，方法将在自己的线程上执行函数，然后在想要等待某些操作完成时调用`await`关键字。
- en: To demonstrate the use of these two new keywords, we will rewrite our previous
    application to read a file asynchronously using the `async` and `await` keywords.
    Let's get started.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这两个新关键字的使用，我们将重写我们之前的应用程序，使用`async`和`await`关键字异步读取文件。让我们开始吧。
- en: How to do it
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'First, let''s open Visual Studio and create a new console application called
    `FileReadUsingAsync`. Once we have this project created, perform the following
    steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们打开Visual Studio并创建一个名为`FileReadUsingAsync`的新控制台应用程序。一旦我们创建了此项目，请执行以下步骤：
- en: 'Add two `using` statements for the `IO` and `Threading` classes, as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个`using`语句用于`IO`和`Threading`类，如下所示：
- en: '[PRE20]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, let''s add the following statements to the `Main` method:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们将以下语句添加到`Main`方法中：
- en: '[PRE21]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will create the `ProcessFileAsync` method that will run inside the
    task we created in the `Main` method. This method will implement the `async` keyword
    and run asynchronously. Add the following code to create this method:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建`ProcessFileAsync`方法，该方法将在`Main`方法中创建的任务内运行。此方法将实现`async`关键字并异步运行。将以下代码添加到创建此方法：
- en: '[PRE22]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, this method will call another `async` method that will actually open the
    file and read the contents. This method, `ReadFileAsync`, will have the following
    code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，此方法将调用另一个`async`方法，该方法实际上会打开文件并读取内容。此方法`ReadFileAsync`将具有以下代码：
- en: '[PRE23]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'That is all there is to it. Let''s build our application and run it. We should
    see the following output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容。让我们构建我们的应用程序并运行它。我们应该看到以下输出：
- en: '![How to do it](img/8321EN_11_06.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_11_06.jpg)'
- en: 'At this point, the application is waiting for us, so we need to press return.
    Then we will see the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应用程序正在等待我们，因此我们需要按回车键。然后我们将看到以下输出：
- en: '![How to do it](img/8321EN_11_07.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_11_07.jpg)'
- en: 'Now, we have initiated the asynchronous reading of the file, performed some
    other work, and are waiting on the file reading to complete. Once it has completed,
    we should see the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经启动了文件的异步读取，执行了一些其他工作，并且正在等待文件读取完成。一旦完成，我们应该看到以下输出：
- en: '![How to do it](img/8321EN_11_08.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_11_08.jpg)'
- en: 'Now, if we press return again we will see the results of the read operation:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次按下回车键，我们将看到读取操作的结果：
- en: '![How to do it](img/8321EN_11_09.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_11_09.jpg)'
- en: Finally, if we press return one last time, the application will finish and exit.
    So, how did this all work?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们再按一次回车键，应用程序将完成并退出。那么，这一切是如何工作的呢？
- en: How it works
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'Now, let''s examine how this program works. First, take a look at the `Main`
    method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看这个程序是如何工作的。首先，看看 `Main` 方法：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is a simple method that creates a new task that executes an `async` method
    called `ProcessFileAsync`. It then starts the task and waits for it to finish.
    That is all. So, the `Main` method just spawns a task to do the work.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的创建一个执行名为 `ProcessFileAsync` 的 `async` 方法的任务的方法。然后它启动这个任务并等待其完成。就是这样。所以，`Main`
    方法只是生成一个任务来完成工作。
- en: 'Now, the `async` method `ProcessFileAsync` is executed in a separate thread
    from the `Main` method. This is shown by displaying the thread ID number. You
    will notice from the console output that the `Main` thread ID is different from
    the thread ID of the task running the `ProcessFileAsync` method. Let''s examine
    this method. The following is the code for us to dissect:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`async` 方法 `ProcessFileAsync` 是在 `Main` 方法之外的一个单独的线程中执行的。这通过显示线程 ID 号来体现。您会从控制台输出中注意到，`Main`
    线程的 ID 与执行 `ProcessFileAsync` 方法的任务的线程 ID 不同。让我们来分析这个方法。以下是我们需要剖析的代码：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This method''s main objective is to run the `async` method, `ReadFileAsync`.
    This is done with the following statement:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的主要目标是运行 `async` 方法 `ReadFileAsync`。这是通过以下语句实现的：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We then await this task with the following statement:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用以下语句等待这个任务：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding statement tells the method to start an `async` task and then wait
    on it to complete. Since the method it is calling has a return value of `Task<String>`,
    the `await task` statement returns a string value. The `ReadFileAsync` method
    takes a filename as the input and then returns a string that contains the contents
    of the file as a string. This method reads the file asynchronously on a separate
    thread from the main thread.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句告诉方法启动一个 `async` 任务并等待其完成。由于它调用的方法返回 `Task<String>` 类型的值，`await task` 语句返回一个字符串值。`ReadFileAsync`
    方法接受一个文件名作为输入，然后返回一个包含文件内容的字符串。这个方法在主线程之外的一个单独的线程上异步读取文件。
- en: 'The heart of the work is done in the `ReadFileAsync` method. Let''s look at
    this method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 工作的核心是在 `ReadFileAsync` 方法中完成的。让我们来看看这个方法：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we use the `async` keyword to designate this as an asynchronous method.
    This method creates a `FileStream` for the filename passed in and then calls the
    `StreamReader.ReadToEndAsync` method to asynchronously read the file. It uses
    the `await` keyword in this statement to signal .NET that this is an asynchronous
    operation:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `async` 关键字来指定这是一个异步方法。这个方法为传入的文件名创建一个 `FileStream`，然后调用 `StreamReader.ReadToEndAsync`
    方法以异步方式读取文件。它在这个语句中使用 `await` 关键字来通知 .NET 这是一个异步操作：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'By putting in the `wait` statement to slow down the processing a little, you
    can see the delay in execution between the following write statements:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过加入 `wait` 语句来稍微减慢处理速度，您可以看到以下写语句之间的执行延迟：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This allows you to see that the main thread is available while the file is being
    read on a separate thread.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您看到在单独的线程上读取文件的同时，主线程仍然是可用的。
- en: Another point to note is that by using the `async`/`await` programming method
    or the APM design pattern, we do not have to deal with the underlying code of
    starting, stopping, and managing threads. This is handled for us by .NET. We just
    have to write the logic and use the appropriate design pattern.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，通过使用 `async`/`await` 编程方法或 APM 设计模式，我们不必处理启动、停止和管理线程的底层代码。这由 .NET
    为我们处理。我们只需编写逻辑并使用适当的设计模式。
- en: This is a generic way to easily implement any asynchronous operation that can
    benefit an application's performance without having to design the entire application
    for parallelism or concurrency like we did with the producer-consumer or Pipelining
    design patterns. We can simply code a single task to run asynchronously.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通用的方法，可以轻松实现任何可以提升应用程序性能的异步操作，而无需像我们在生产者-消费者或管道设计模式中所做的那样，为并行性或并发性设计整个应用程序。我们可以简单地编写一个异步运行的任务。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned two very important ways to make a particular
    piece of functionality in an application run asynchronously from the main thread
    of the application. These two ways are the Application Programming Model and the
    `async`/`await` keywords. These two design techniques allow you to take advantage
    of the asynchronous execution of a task without designing an application around
    concurrency. This is especially useful for long-running tasks or tasks that access
    outside resources. In this way, we do not tie up the main thread of an application
    while we are waiting for something like a file read, an HTTP GET request, or a
    database read. These are all tasks whose duration is outside our control and not
    predictable. It therefore makes sense to perform these kinds of functions asynchronously
    so that our application's main thread can continue running.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了两种非常重要的方法，可以在应用程序的主线程中异步运行特定的功能。这两种方法就是应用程序编程模型和 `async`/`await` 关键字。这两种设计技术允许你利用任务的异步执行，而无需围绕并发设计应用程序。这对于长时间运行的任务或访问外部资源的任务特别有用。这样，在我们等待诸如文件读取、HTTP
    GET 请求或数据库读取之类的操作时，我们不会阻塞应用程序的主线程。这些都是持续时间超出我们控制且不可预测的任务。因此，以异步方式执行这些类型的函数是有意义的，这样我们应用程序的主线程就可以继续运行。
- en: These techniques are very useful when we do not have enough concurrent functionality
    to design a complete parallel application but have a particular task that can
    take a long time. These two methods are used in much the way the `BackgroundWorker`
    component is used and continues to make it obsolete.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们没有足够的并发功能来设计一个完整的并行应用程序，但有一个可能需要很长时间才能完成的特定任务时，这些技术非常有用。这两个方法的使用方式与 `BackgroundWorker`
    组件的使用方式非常相似，并且继续使其过时。
- en: The Application Programming Model is a design technique used when you create
    a class. You can create two methods and name them `BeginMethodName` and `EndMethodName`
    that implement the `IAsyncResult` interface. Then you can use them to start an
    asynchronous operation and, if needed, block the main thread waiting on the asynchronous
    operation to complete. This technique is used in many .NET classes such as the
    `FileStream`, `StreamReader`, and `StreamWriter`. But it can also be used by you
    when designing your classes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序编程模型是一种设计技术，用于你在创建类时使用。你可以创建两个方法并将它们命名为 `BeginMethodName` 和 `EndMethodName`，以实现
    `IAsyncResult` 接口。然后你可以使用它们来启动一个异步操作，如果需要，可以阻塞主线程等待异步操作完成。这种技术在许多 .NET 类中都有使用，例如
    `FileStream`、`StreamReader` 和 `StreamWriter`。但也可以在你设计类时使用它。
- en: The `async` and `await` keywords are a simple way to designate in a method's
    signature that it is meant to be performed as an asynchronous operation. The `async`
    keyword designates the method as an asynchronous method and the `await` keyword
    is used within the method to wait on a statement to complete before its method
    completes. This technique can be implemented within a class or as static methods
    within an application or helper class. These two techniques give the .NET developer
    two more tools in their toolbox to implement concurrent functionality.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 和 `await` 关键字是简单地在方法签名中指定它应该作为一个异步操作执行的一种方式。`async` 关键字将方法指定为异步方法，而
    `await` 关键字在方法中使用，用于等待一个语句完成，然后方法才完成。这种技术可以在类中实现，也可以在应用程序或辅助类中的静态方法中实现。这两个技术为
    .NET 开发者提供了两个额外的工具，以实现并发功能。'
- en: Throughout this book, we have explored many ways to implement concurrent and
    asynchronous functionality in .NET. This includes techniques that have been around
    from .NET 1.0 to techniques introduced in the latest .NET 4.5\. They range from
    simple asynchronous methods that do not allow blocking a main UI thread to objects
    for designing complete concurrent applications, to objects for processing sets
    of data concurrently. There are many ways and techniques to perform multithreaded
    functionality in .NET depending on the requirements of your specific application
    or task.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们探讨了在 .NET 中实现并发和异步功能的各种方法。这包括从 .NET 1.0 以来一直存在的技术，以及最新引入的 .NET 4.5 的技术。它们从不允许阻塞主
    UI 线程的简单异步方法，到用于设计完整并发应用程序的对象，再到用于并发处理数据集的对象。根据你特定应用程序或任务的需求，.NET 中有许多执行多线程功能的方法和技术。
- en: Now that you know all of what .NET has to offer, never waste an opportunity
    in your development to maximize the use of your computing hardware or its responsiveness
    by sticking to a single-threaded approach.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了.NET所能提供的一切，永远不要在开发过程中错过任何机会，通过坚持单线程方法来最大化利用你的计算硬件或其响应性。
