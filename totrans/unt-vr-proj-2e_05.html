<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Handy Interactables</h1>
                </header>
            
            <article>
                
<p class="calibre3"><span class="calibre6">You're in a virtual world with all this cool stuff; it is our nature to try to reach out and touch something. While gaze-based selection, as we saw in the previous chapter, is a good first step for interacting with virtual scenes, </span>most people intuitively want to use their hands. Most VR devices provide a hand controller to select, grab, and interact with virtual objects in the scene.</p>
<p class="calibre3">In this chapter, we introduce practices for capturing user input in Unity, illustrating how to use them in a simple VR scene. Everyone loves balloons, so in this project we will make balloons. We may even pop a few. We will continue from the previous chapter, using C# programming for basic scripting, and explore several software design patterns for user input. We will discuss the following topics:</p>
<ul class="calibre11">
<li class="calibre12">Polling for input device data</li>
<li class="calibre12">Using scriptable data objects for storing and retrieving input state</li>
<li class="calibre12">Invoking and subscribing to input events</li>
<li class="calibre12">Using interactable components provided with device-specific Unity packages</li>
</ul>
<p class="calibre3">An important lesson we will learn in this chapter is there is not just one way to handle user input for your VR application. There isn't even one <em class="calibre14">best way</em>. Unity includes several mechanisms for handling user input and, in general, messaging between objects. VR device manufacturers provide their own input controller objects and scripts for their SDK.</p>
<p class="calibre3">Furthermore, VR manufacturers and others offer convenient framework toolkits with higher-level components and prefabs. We recommend you become familiar with the toolkits provided for your target device. Study the demo scenes to see how the components work and their recommended practices, as we will do at the end of this chapter. </p>
<p class="calibre3">That said, in this chapter we will start with the very simple button press input, and progress from there, showing various design patterns. You won't always want to roll your own, but you should have an understanding of how things work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the scene</h1>
                </header>
            
            <article>
                
<p class="calibre3">To begin our exploration of input mechanisms, let's set up our scene. The plan is to let players create balloons. Everyone loves balloons!</p>
<p class="calibre3"><span class="calibre6">For this scene, you could start with a new scene (<span class="calibre6">File</span></span> | <span class="calibre6"><span class="calibre6">New Scene</span>) and then add the <span class="calibre6">MyMyselfEye</span> prefab we built in the previous chapter. Instead, I've decided to start with the Diorama scene created in the previous chapter, and remove all but the GroundPlane and PhotoPlane, as follows:</span></p>
<ol class="calibre15">
<li class="calibre12"><span>Open the <span>Diorama</span> scene</span></li>
<li class="calibre12"><span>Remove all the objects, except for <span>MyMyselfEye, Directional Light, GroundPlane</span></span> and <span><span>PhotoPlane</span></span></li>
<li class="calibre12">Position the <span>MeMyselfEye</span> at the scene origin, <span>Position</span> (0, 0, 0)</li>
<li class="calibre12">Select <span>File</span> | <span>Save Scene As</span> and give it a name, such as "Balloons"</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a balloon</h1>
                </header>
            
            <article>
                
<p class="calibre3">For the balloon, you can simply use a standard Unity sphere 3D primitive if you choose. Or you can find an object in the Unity Asset Store or elsewhere. We are using a low poly balloon object that we found on Google Poly (<a href="https://poly.google.com/view/a01Rp51l-L3" class="calibre10">https://poly.google.com/view/a01Rp51l-L3</a>) and which is provided with the download files for this chapter. </p>
<p class="calibre3">Either way, please parent the object so its origin (pivot point) is at the bottom, as follows:</p>
<ol class="calibre15">
<li class="calibre12">In<span> </span><span>Hierarchy</span>, create an empty object (<span>Create</span> | <span>Create Empty</span>) and name it "Balloon".</li>
<li class="calibre12">Reset its transform (<span>Transform</span> | <span>gear-icon</span> | <span>Reset</span>), then <span>Position</span> it at (0, 1, 1).</li>
<li class="calibre12">Drag the balloon prefab into the Hierarchy as a child object of Balloon (mine is found in the<span> </span><kbd class="calibre13">Assets/Poly/Assets/</kbd><span> </span>folder).</li>
<li class="calibre12">If you do not have a balloon model, use a sphere (<span>Create</span> | <span>3D Object</span> | <span>Sphere</span><span>). And add a </span>material, like the "Blue Material" we created in the previous chapter.</li>
<li class="calibre12">Set the child object's<span> </span><span>Position</span><span> </span>to (0, 0.5, 0) so its origin (pivot point) is at its bottom when referenced from the parent.</li>
</ol>
<p class="calibre3">The scene should look something like this:</p>
<div class="mce-root1"><img src="assets/7881a110-f890-4d78-bdc3-6132de13f1d1.png" class="calibre24"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making it a prefab</h1>
                </header>
            
            <article>
                
<p class="calibre3">Our intent is to instantiate new balloons from a prefab when your player presses a button on their controller. And when the button is released, the balloon gets released and it floats away.</p>
<p class="calibre3">Let's scale and position the balloon initially in the scene at a starting size and workable distance. We will also give it some physics properties by adding a <kbd class="calibre13">RigidBody</kbd> component: </p>
<div class="packttip">We discuss RigidBodies and Unity physics in more detail in <a href="77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml" target="_blank" class="calibre20">Chapter 8</a>, <em class="calibre2">Playing with Physics and Fire</em>.</div>
<ol class="calibre15">
<li class="calibre12">Select your Balloon object in<span> </span><span>Hierarchy</span></li>
<li class="calibre12">In<span> </span><span>Inspector</span>, set its<span> </span><span>Transform Scale</span><span> </span>to (0.1, 0.1, 0.1)</li>
</ol>
<p class="calibre3"> </p>
<ol start="3" class="calibre15">
<li class="calibre12">Set its<span> </span><span>Position</span><span> </span>to (0, 1, 1)</li>
<li class="calibre12">Use<span> </span><span>Add Component</span><span> </span>to add a<span> </span><span>Rigid Body</span></li>
<li class="calibre12">Uncheck the<span> </span><span>Use Gravity</span><span> </span>checkbox</li>
</ol>
<p class="calibre3">My balloon object now has the following properties:</p>
<div class="mce-root1"><img src="assets/15b70c9b-e8c5-4068-8f0a-0c94473f641e.png" class="calibre24"/></div>
<p class="calibre3"><span class="calibre6">Make it a prefab as follows:</span></p>
<ol class="calibre15">
<li class="calibre12">Drag the balloon object into your<span> </span><kbd class="calibre13">Prefabs/ </kbd>folder to make it a prefab object</li>
<li class="calibre12">Delete the original balloon object from your Hierarchy</li>
</ol>
<p class="calibre3">Okay. Now let's play around with controller buttons.</p>
<div class="packttip">If you ever want to modify a prefab, drag an instance of it back into the scene. Make the changes you want. Then, use the <span>Apply</span> button to save the changes back onto the prefab of the object. Delete the temporary instance from the Hierarchy if it's no longer needed in the scene.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic button input</h1>
                </header>
            
            <article>
                
<p class="calibre3">Unity includes a standard Input Manager for accessing traditional game controller, keyboard, mouse, and mobile touchscreen input. This can include specific button presses, joystick axes, and the device accelerometer, for example. It also supports input from VR and AR systems.</p>
<p class="calibre3">The Input Manager provides an abstraction layer over the physical input devices. For example, you can reference logical inputs, such as the <kbd class="calibre13">Fire1</kbd> button, which is mapped to a physical button. The mappings for your project can be set up and modified in <span class="calibre6">Edit</span> | <span class="calibre6">Project Settings</span> | <span class="calibre6">Input</span>. </p>
<div class="packtinfobox">For a general overview and details of Unity Input Manager, see <a href="https://docs.unity3d.com/Manual/ConventionalGameInput.html" class="calibre20">https://docs.unity3d.com/Manual/ConventionalGameInput.html</a>.  For scripting the Input class, see <a href="https://docs.unity3d.com/ScriptReference/Input.html" class="calibre20">https://docs.unity3d.com/ScriptReference/Input.html</a>. Input mapping for various VR devices can be found at <a href="https://docs.unity3d.com/Manual/vr-input.html" class="calibre20">https://docs.unity3d.com/Manual/vr-input.html</a><span>.</span></div>
<p class="calibre3">Let's take a look. To start, we will write a test script to get a specific button state and see how the Unity Input class works. A common logical button is the one named "Fire1." Let's see which button your input device uses for "Fire1."</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the Fire1 button</h1>
                </header>
            
            <article>
                
<p class="calibre3">We will now write a script, <kbd class="calibre13">MyInputController</kbd>, to detect when your user has pressed the <kbd class="calibre13">Fire1</kbd> button. Add the script to your <kbd class="calibre13">MeMyselfEye</kbd> object as follows:</p>
<ol class="calibre15">
<li class="calibre12">In <span>Hierarchy</span>, select the <span>MyMyselfEye</span> object</li>
<li class="calibre12">In <span>Inspector</span>, click <span>Add</span> <span>Component</span>, then <span>New Script</span></li>
<li class="calibre12">Name it <kbd class="calibre13">MyInputController</kbd> and press <span>Create And Add</span></li>
<li class="calibre12">Double-click the <kbd class="calibre13">MyInputController</kbd> script to open it for editing</li>
</ol>
<p class="calibre3">Edit the script as follows:</p>
<pre class="calibre18">public class MyInputController : MonoBehaviour <br class="title-page-name"/>{<br class="title-page-name"/>  void Update () <br class="title-page-name"/>  {<br class="title-page-name"/>    ButtonTest();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private void ButtonTest()<br class="title-page-name"/>  {<br class="title-page-name"/>    string msg = null;<br class="title-page-name"/><br class="title-page-name"/>    if (Input.GetButtonDown("Fire1"))<br class="title-page-name"/>      msg = "Fire1 down";<br class="title-page-name"/><br class="title-page-name"/>    if (Input.GetButtonUp("Fire1"))<br class="title-page-name"/>       msg = "Fire1 up";<br class="title-page-name"/><br class="title-page-name"/>    if (msg != null)<br class="title-page-name"/>      Debug.Log("Input: " + msg);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre3">In this script, in each frame Update, we call a private function, <kbd class="calibre13">ButtonTest</kbd>. This function builds a message string named <kbd class="calibre13">msg</kbd> that reports whether the <kbd class="calibre13">Fire1</kbd> button has just been pressed down or released. The call to <kbd class="calibre13">Input.GetButtonDown("Fire1")</kbd>, for example, will return a Boolean (true or false) value, which we check in the <kbd class="calibre13">if</kbd> statement. When either of these situations are true, the <kbd class="calibre13">msg</kbd> string is not empty (null) and gets printed to the Unity Console window:</p>
<ol class="calibre15">
<li class="calibre12">Press <span>Play</span> in the Unity editor to run the scene</li>
<li class="calibre12">When you press the Fire1 button on your input controller, you will see the <span>Input: Fire1 down</span> message as output</li>
<li class="calibre12">When you release the Fire1 button, you will see the <span>Input: Fire1 up</span> message, as shown here:</li>
</ol>
<div class="mce-root1"><img src="assets/28bb4769-3388-4884-b766-d1a4741302e1.png" class="calibre24"/></div>
<p class="calibre3">You can use even use this script to identify which physical button on your input controller maps to the logical <kbd class="calibre13">Fire1</kbd> button. Using OpenVR, for example, <kbd class="calibre13">Fire1</kbd> is triggered with the menu button on a Vive controller or the <strong class="calibre5">B</strong> button on the Oculus Touch controller ("Button.Two") as shown on the Unity Input System Mappings section in the Input for OpenVR Controllers page of the Unity manual  (<a href="https://docs.unity3d.com/Manual/OpenVRControllers.html" class="calibre10">https://docs.unity3d.com/Manual/OpenVRControllers.html</a>). Feel free to experiment with using other logical input names, and/or modifying the mappings using the Input project settings (<span class="calibre6">Edit</span> | <span class="calibre6">Project Settings</span> | <span class="calibre6">Input</span>). </p>
<p class="calibre3">Instead of using Unity logical inputs, it is also common to access the device directly through SDK components. Let's look into that in the  next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OpenVR trigger button</h1>
                </header>
            
            <article>
                
<p class="calibre3">If you have a VR device supported by OpenVR (HTC Vive, Oculus Rift, or Windows MR), let's modify the <kbd class="calibre13">ButtonTest</kbd> function to check for a pull and release of the trigger button.</p>
<p class="calibre3">To implement this, we need to provide our script with the specific input component that we want to query. In OpenVR, this is represented by the <kbd class="calibre13">SteamVR_TrackedObject</kbd> component, as shown in the following variation of our script:</p>
<pre class="calibre18">public class MyInputController : MonoBehaviour <br class="title-page-name"/>{<br class="title-page-name"/>  public SteamVR_TrackedObject rightHand;<br class="title-page-name"/><br class="title-page-name"/>  private SteamVR_Controller.Device device;<br class="title-page-name"/><br class="title-page-name"/>  void Update () <br class="title-page-name"/>  {<br class="title-page-name"/>    ButtonTest();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private void ButtonTest()<br class="title-page-name"/>  {<br class="title-page-name"/>    string msg = null;<br class="title-page-name"/><br class="title-page-name"/>    // SteamVR<br class="title-page-name"/>    device = SteamVR_Controller.Input((int)rightHand.index);<br class="title-page-name"/>    if (device != null &amp;&amp;  <br class="title-page-name"/>      device.GetPressDown(SteamVR_Controller.ButtonMask.Trigger))<br class="title-page-name"/>    {<br class="title-page-name"/>      msg = "Trigger press";<br class="title-page-name"/>      device.TriggerHapticPulse(700);<br class="title-page-name"/>    }<br class="title-page-name"/>    if (device != null &amp;&amp;  <br class="title-page-name"/>      device.GetPressUp(SteamVR_Controller.ButtonMask.Trigger)) <br class="title-page-name"/>    {<br class="title-page-name"/>      msg = "Trigger release";<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    if (msg != null)<br class="title-page-name"/>      Debug.Log("Input: " + msg);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre3">After saving this script, we need to populate the <kbd class="calibre13">rightHand</kbd> variable:</p>
<ol class="calibre15">
<li class="calibre12">In Unity, select <span>MeMyselfEye</span> so you can see the <span>My Input Controller</span> in the <span>Inspector</span></li>
<li class="calibre12">In the <span>Hierarchy</span>, unfold the <span>[CameraRig]</span> object</li>
<li class="calibre12">Click the <span>Controller (Right)</span> child object and drag it onto the <span>My Input Controller</span>'s Right Hand slot in the <span>Inspector</span></li>
</ol>
<p class="calibre3"><span class="calibre6">Given the <kbd class="calibre13">rightHand</kbd> object, we reference its <kbd class="calibre13">SteamVR_TrackedObject</kbd> component directly. In the <kbd class="calibre13">ButtonTest</kbd> function, we get the </span><em class="calibre14">device</em><span class="calibre6"> data using the right hand's device ID (<kbd class="calibre13">rightHand.index</kbd>), and check specifically for the trigger press status. As a bonus, I've shown you how to also provide a haptic buzz pulse on the device when the trigger is pressed. </span></p>
<p class="calibre3">Now when you press <span class="calibre6">Play</span>, pulling the controller trigger will be recognized. </p>
<p class="calibre3">Using the SDK components like this, you can access other inputs specific to the device not supported by the Unity Input Manager. The trigger on some controllers are not just pressed/unpressed but can return a percentage of press, represented as a value between 0.0 and 1.0. Another example is the touch-sensitive grips, buttons, and thumb pad on the Oculus Touch controllers and other controllers.</p>
<div class="packttip">Try modifying the script to recognize the controller <kbd class="calibre26">Grip</kbd> button instead, or other inputs. Hint: try <em class="calibre2"><span>SteamVR_Controller</span><span>.</span><span>ButtonMask</span><span>.</span></em><span><em class="calibre2">Grip</em>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Daydream controller clicks</h1>
                </header>
            
            <article>
                
<p class="calibre3">Google Daydream VR on Android may not respond, by default, to <kbd class="calibre13">Fire1</kbd> events. The following code shows how to access controller clicks directly:</p>
<pre class="calibre18">  private void ButtonTest()<br class="title-page-name"/>  {<br class="title-page-name"/>    string msg = null;<br class="title-page-name"/><br class="title-page-name"/>    if (GvrControllerInput.ClickButtonDown)<br class="title-page-name"/>      msg = "Button down";<br class="title-page-name"/>    if (GvrControllerInput.ClickButtonUp)<br class="title-page-name"/>      msg = "Button up";<br class="title-page-name"/><br class="title-page-name"/>    if (msg != null)<br class="title-page-name"/>      Debug.Log("Input: " + msg);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre3">In this case, we call the <kbd class="calibre13">GvrControllerInput</kbd> class static functions <kbd class="calibre13">ClickButtonDown</kbd> and <kbd class="calibre13">ClickButtonUp</kbd>. There is no need to identify a specific controller object because <kbd class="calibre13">GvrControllerInput</kbd> is a <em class="calibre14">singleton</em>. That is why we're guaranteed to have only one instance of it in the scene, so we can reference its data directly. This makes sense because on Daydream there will only be one hand controller, whereas on OpenVR there will be two.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Polling for clicks</h1>
                </header>
            
            <article>
                
<p class="calibre3">The simplest way to obtain user input is just <em class="calibre14">get</em> the current data from an input component. We've already seen this using the Input class and VR SDK. Presently, we will write our own input component that maps the Unity (or SDK) input to our own simple API in <kbd class="calibre13">MyInputController</kbd>. Then, we'll write a <kbd class="calibre13">BalloonController</kbd> that polls the input, as illustrated:</p>
<div class="mce-root1"><img src="assets/65788305-5dad-48b6-aba4-387704e3ee6e.png" class="calibre24"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Our own button interface functions</h1>
                </header>
            
            <article>
                
<p class="calibre3"><span class="calibre6">You may recall that the <kbd class="calibre13">MeMyselfEye</kbd> player rig may have device-specific toolkit child objects for a particular VR SDK. The version for OpenVR, for example, has their</span><span class="calibre6"> [CameraRig]</span> <span class="calibre6">prefab. The version for Daydream has the Daydream</span> <span class="calibre6">Player</span> <span class="calibre6">prefab. It makes sense to add our <kbd class="calibre13">MyInputController</kbd> component to <kbd class="calibre13">MeMyselfEye</kbd>, as it may make device-specific SDK calls. In this way, should you want to maintain camera rig prefabs for a variety of platforms, and swap them in and out as you build the project for a different VR target, the API that is exposed to the rest of your application will be consistent and independent of the specific device toolkit. </span></p>
<p class="calibre3">Our input controller will expose two custom API Functions,<span class="calibre6"> </span><kbd class="calibre13">ButtonDown </kbd>and<span class="calibre6"> </span><kbd class="calibre13">ButtonUp</kbd>. The implementation of these functions will be hidden from the components that call them. For example, we could write it to handle <kbd class="calibre13">Fire1</kbd> button presses as first but later change it to use a trigger press instead, or make a version for Daydream that does not use <kbd class="calibre13">Fire1</kbd>. Let's update the <kbd class="calibre13">MyInputController</kbd> by adding the following code:</p>
<pre class="calibre18">public bool ButtonDown()<br class="title-page-name"/>{<br class="title-page-name"/>  return Input.GetButtonDown("Fire1");<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public bool ButtonUp()<br class="title-page-name"/>{<br class="title-page-name"/>  return Input.GetButtonUp("Fire1");<br class="title-page-name"/>}</pre>
<p class="calibre3">Or you can modify the preceding code to use the button interface that works for you. For example, for Daydream you might use this instead:</p>
<pre class="calibre18">public bool ButtonDown()<br class="title-page-name"/>{<br class="title-page-name"/>  return GvrControllerInput.ClickButtonDown;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public bool ButtonUp()<br class="title-page-name"/>{<br class="title-page-name"/>  return GvrControllerInput.ClickButtonUp;<br class="title-page-name"/>}</pre>
<p class="calibre3">Now, we'll use our little <kbd class="calibre13">ButtonUp</kbd>/<kbd class="calibre13">ButtonDown</kbd> input API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating and releasing balloons</h1>
                </header>
            
            <article>
                
<p class="calibre3">Let's now create a <kbd class="calibre13">BalloonController</kbd> that will be the application component that creates and controls balloons. It will reference our <kbd class="calibre13">MyInputController</kbd>. Follow these steps:</p>
<ol class="calibre15">
<li class="calibre12">In <span>Hierarchy</span>, create an empty game object, reset its Transform, and name it <kbd class="calibre13">BalloonController</kbd></li>
<li class="calibre12">Create a new script on the object named <kbd class="calibre13">BalloonController</kbd> and open it for editing as follows:</li>
</ol>
<pre class="calibre44">public class BalloonController : MonoBehaviour <br class="title-page-name"/>{<br class="title-page-name"/>  public GameObject meMyselfEye;<br class="title-page-name"/><br class="title-page-name"/>  private MyInputController inputController;<br class="title-page-name"/><br class="title-page-name"/>  void Start () <br class="title-page-name"/>  {<br class="title-page-name"/>    inputController = meMyselfEye.GetComponent&lt;MyInputController&gt;();<br class="title-page-name"/>  }<br class="title-page-name"/> <br class="title-page-name"/>  void Update () <br class="title-page-name"/>  {<br class="title-page-name"/>    if (inputController.ButtonDown())<br class="title-page-name"/>    {<br class="title-page-name"/>      NewBalloon()<br class="title-page-name"/>    }<br class="title-page-name"/>    else if (inputController.ButtonUp())<br class="title-page-name"/>    {<br class="title-page-name"/>      ReleaseBalloon();<br class="title-page-name"/>    }<br class="title-page-name"/>    // else while button is still pressed, grow it<br class="title-page-name"/> }</pre>
<p class="calibre3">This is the skeleton of the controller. Given a reference to the <kbd class="calibre13">MeMyselfEye</kbd> object, the <kbd class="calibre13">Start()</kbd> function gets its <kbd class="calibre13">MyInputController</kbd> component and assigns it to the <kbd class="calibre13">inputController </kbd><span class="calibre6">variable</span><span class="calibre6">.</span></p>
<p class="calibre3"><kbd class="calibre13">Update()</kbd> is called each frame while your game is running. It will call <kbd class="calibre13">inputController.ButtonDown</kbd> or <kbd class="calibre13">ButtonUp</kbd> to see if the user has changed their input, and in response, either create or release a balloon. We'll write the functions next.</p>
<p class="calibre3">Note that we've also included a placeholder (as a comment) where we'll add the <kbd class="calibre13">GrowBalloon</kbd> function too. </p>
<p class="calibre3">Given the balloon prefab, the <kbd class="calibre13">BalloonController</kbd> can create new instances of it in our scene, by calling the Unity <kbd class="calibre13">Instantiate</kbd> function. Add the following <kbd class="calibre13">public</kbd> variable declaration at the top of your controller class for the balloon prefab:</p>
<pre class="calibre18"> public GameObject balloonPrefab;</pre>
<p class="calibre3">And add a <kbd class="calibre13">private</kbd> variable to hold the current instance of the balloon:</p>
<pre class="calibre18"> private GameObject balloon;</pre>
<p class="calibre3">Now, the <kbd class="calibre13">NewBalloon</kbd> function, which is called when the player presses the button, references the prefab and instantiates it as follows:</p>
<pre class="calibre18"> private void NewBalloon()<br class="title-page-name"/> {<br class="title-page-name"/>   balloon = Instantiate(balloonPrefab);<br class="title-page-name"/> }</pre>
<p class="calibre3">The <kbd class="calibre13">ReleaseBalloon</kbd> function is called when the player releases the button. It will apply a gentle upward force on the balloon so it floats skyward. We'll define a floatStrength variable and apply it to the object's RigidBody (the Unity physics engine and RigidBodies are explained in a later chapter):</p>
<pre class="calibre18"> public float floatStrength = 20f;</pre>
<p class="calibre3">And,</p>
<pre class="calibre18">private void ReleaseBalloon()<br class="title-page-name"/>{<br class="title-page-name"/>  balloon.GetComponent&lt;Rigidbody&gt;().AddForce(Vector3.up * floatStrength);<br class="title-page-name"/>  balloon = null;<br class="title-page-name"/>}</pre>
<p class="calibre3">Notice that we also clear the balloon variable (setting it to null), getting it ready for the next button press.</p>
<p class="calibre3">Save the file and in Unity:</p>
<ol class="calibre15">
<li class="calibre12">Drag the <span>MeMyselfEye</span> object from <span>Hierarchy</span> onto the BalloonController's <span>Me Myself Eye</span> slot in <span>Inspector</span></li>
<li class="calibre12">Drag the <span>Ballon</span> prefab from the Project's <kbd class="calibre13">Assets</kbd> folder onto the BalloonController's <span>Balloon Prefab</span> slot in <span>Inspector</span></li>
</ol>
<p class="calibre3">When you're ready, press <span class="calibre6">Play</span>. Inside VR, when you press the <kbd class="calibre13">Fire1</kbd> button (or whichever you programmed), a new balloon is instantiated. When you release it, the balloon floats upwards. In the following game window, I have pressed the button multiple times in succession, creating a series of balloons:</p>
<div class="mce-root1"><img src="assets/db562021-0983-467f-ad46-ad884fc34a20.png" class="calibre45"/></div>
<p class="calibre3">Here is the Hierarchy of the same game state, showing the cloned balloons in the <span class="calibre6">Hierarchy</span> (my prefab's name is <kbd class="calibre13">Balloon-poly</kbd>):</p>
<div class="mce-root1"><img src="assets/afc206b2-54f7-4659-aa3e-e565dfb26bce.png" class="calibre46"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inflating a balloon while pressed</h1>
                </header>
            
            <article>
                
<p class="calibre3">The next thing we want to do is inflate the balloon while you're still holding the button. We can do this by checking whether there's a current balloon instance from a button press, and modifying its scale each update by a specified grow rate. Let's define that first, to grow by 150% each second the button is held down (1.5 times):</p>
<pre class="calibre18">public float growRate = 1.5f;</pre>
<p class="calibre3">Now, modify the Update function with a third <kbd class="calibre13">else if</kbd> condition as follows:</p>
<pre class="calibre18">  else if (balloon != null)<br class="title-page-name"/>  {<br class="title-page-name"/>    GrowBalloon();<br class="title-page-name"/>  }</pre>
<p class="calibre3">And add the <kbd class="calibre13">GrowBalloon</kbd> function like this:</p>
<pre class="calibre18"> private void GrowBalloon()<br class="title-page-name"/> {<br class="title-page-name"/>   balloon.transform.localScale += balloon.transform.localScale * growRate * Time.deltaTime;<br class="title-page-name"/> }</pre>
<p class="calibre3">The <kbd class="calibre13">GrowBalloon</kbd> function will modify the balloon's local scale by a percentage of its current size. <kbd class="calibre13">growRate</kbd> is the rate of growth per second. So, we multiply that by the current fraction of a second in this frame (<kbd class="calibre13">Time.deltaTime</kbd>).</p>
<p class="calibre3">Press <span class="calibre6">Play</span> in Unity. When you press the controller button, you'll create a balloon, which continues to inflate until you release the button. Then the balloon floats up. Wow, that's actually pretty fun!</p>
<p class="calibre3">Next, we're going to refactor our code to use a different software pattern for getting user input, using scriptable objects.</p>
<div class="packtinfobox">No one writes code without expecting to change it. Programming is a dynamic art as you rethink how to do things, as requirements grow, and problems get fixed. Sometimes, these changes are not necessarily to add a new feature or fix a bug but to make the code cleaner, easier to use, and easier to maintain. This is called <strong class="calibre1">refactoring</strong>, when you change or rewrite parts of a program but do not necessarily change how the feature works from the player's perspective.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using scriptable objects for input</h1>
                </header>
            
            <article>
                
<p class="calibre3">In this example, we will further decouple our application from the underlying input device using a technique called <strong class="calibre5">scriptable</strong> <strong class="calibre5">objects</strong><strong class="calibre5">.</strong> These are data objects used for holding information such as game state, player preferences, or any other data that is not necessarily graphical. Scriptable objects are instantiated during runtime, much like MonoBehaviour ones, but do not live in the Hierarchy, have no Transform, nor other physics and rendering behaviors. </p>
<div class="packttip">It's useful to think of scriptable objects as <em class="calibre2">data containers</em> in your projects.</div>
<p class="calibre3">In the previous implementation, <kbd class="calibre13">BalloonController</kbd> requires a reference to the <kbd class="calibre13">MeMyselfEye</kbd> object to use its <kbd class="calibre13">MyInputController</kbd> component. Although the input controller component does separate you from the underlying SDK calls, if you modify your application to use a different <kbd class="calibre13">MeMyselfEye</kbd> (for example, from OpenVR to Daydream), you will need to find and replace all references to one <kbd class="calibre13">MeMyselfEye</kbd> in the scene and replace them with the new one. Here's will have the input controller populate a scriptable object, and then our <kbd class="calibre13">BalloonController</kbd> reference that object for the data, as illustrated here:</p>
<div class="mce-root1"><img src="assets/ec4cf25f-0253-44ae-ac25-a67e3a53c83e.jpg" class="calibre24"/></div>
<p class="calibre3">The process of implementing scriptable objects is a little more involved than game objects with components. But not much. Let's go!</p>
<div class="packtinfobox">Keep in mind this is just one example how to use scriptable objects and serves as an introduction to this powerful design pattern in Unity. For more information, see the Unity Tutorial <em class="calibre2">Introduction to</em> s<em class="calibre2">criptable</em> obj<em class="calibre2">ects</em> at <a href="https://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/scriptable-objects" class="calibre20">https://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/scriptable-objects</a><span>. Also, see <a href="232442fa-b5ba-4e11-9734-905b243e34a5.xhtml" target="_blank" class="calibre20">Chapter 9</a>, Exploring Interactive Spaces, for another example of scriptable objects for data management in a project.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the scriptable object</h1>
                </header>
            
            <article>
                
<p class="calibre3"><span class="calibre6">In this example, our object will just have one variable, for the current button action. We'll say the button can have one of three possible values: <kbd class="calibre13">PressedDown</kbd>, <kbd class="calibre13">ReleasedUp</kbd>, or <kbd class="calibre13">None</kbd>. We'll define the action as having occurred current during the current <kbd class="calibre13">Update</kbd>, then it's cleared to <kbd class="calibre13">None</kbd>. That is, rather than record the current button state (for example, is pressed), we are capturing the current button action (was just pressed), to be consistent with other examples in this chapter.</span></p>
<p class="calibre3">It's useful to keep scriptable objects in their own folder in the Project <kbd class="calibre13">Assets</kbd>:</p>
<ol class="calibre15">
<li class="calibre12">In the <strong class="calibre1">Project</strong> window, create a new folder under <em class="calibre2">Assets</em> named <kbd class="calibre13">ScriptableObjects</kbd></li>
<li class="calibre12">In the new folder, right-click and select <span>Create</span> | <span>C# Script</span></li>
<li class="calibre12">Name the script <kbd class="calibre13">MyInputAction</kbd></li>
<li class="calibre12">Then, open the <kbd class="calibre13">MyInputAction.cs</kbd> script for editing</li>
</ol>
<p class="calibre3"><span class="calibre6">Edit the <kbd class="calibre13">MyInputAction.cs</kbd> script as follows:</span></p>
<pre class="calibre18">[CreateAssetMenu(menuName = "My Objects/Input Action")]<br class="title-page-name"/>public class MyInputAction : ScriptableObject {<br class="title-page-name"/>  public enum ButtonAction { None, PressedDown, ReleasedUp };<br class="title-page-name"/>  public ButtonAction buttonAction;<br class="title-page-name"/>}</pre>
<p class="calibre3">Rather than inheriting from <kbd class="calibre13">MonoBehaviour</kbd>, we will define the class as a <kbd class="calibre13">ScriptableObject</kbd>. We represent the action using an enum to restrict its possible values to the selection list.</p>
<div class="packtinfobox"><span>"The </span><strong class="calibre1">enum</strong><span> keyword is used to </span>declare<span> an enumeration, a distinct type that consists of a set of named constants called the enumerator list.</span><span>" - <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum" class="calibre20">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum</a></span></div>
<p class="calibre3">Notice the first line of the preceding script. We provide a <em class="calibre14">property attribute</em> which generates a menu item in the Unity Editor for our object. Since scriptable objects are not added to the scene Hierarchy, we need a way to create them in the project. Using this attribute makes it easy, as follows:</p>
<ol start="1" class="calibre15">
<li class="calibre12">Save the script and return to Unity.</li>
<li class="calibre12">In the Unity editor main menu, navigate to <span>Assets</span> | <span>Create</span>.</li>
<li class="calibre12">You will see a new item, <span>My Objects</span>, with a submenu with an item <span>Input Action</span>, as directed in the <kbd class="calibre13">CreateAssetsMenu</kbd> property attribute in our script. The menu is shown next.</li>
<li class="calibre12">Choose <span>Input Action</span> to create an instance. By default, it will be created in the currently selected Project Assets folder. So if you have the <kbd class="calibre13">ScriptableObjects</kbd> folder open, it will be created there.</li>
<li class="calibre12">Rename the object <kbd class="calibre13">My Input Action Data</kbd>.</li>
</ol>
<div class="mce-root1"><img src="assets/6eb1b9b9-4382-4b39-9893-091da7609977.png" class="calibre24"/></div>
<p class="calibre3">If you select the new <kbd class="calibre13">My Input Action Data</kbd> object in your <kbd class="calibre13">ScriptableObjects/</kbd> folder, you can see its properties in the <span class="calibre6">Inspector</span>. In the following screen capture, I have clicked the <strong class="calibre5"><span class="calibre6">Button Action</span></strong> drop-down list to reveal the possible enum values we've specified in our code:</p>
<div class="mce-root1"><img src="assets/5f2f8d3f-50fa-435a-b1fa-ec685effef86.png" class="calibre24"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Populating the input action object</h1>
                </header>
            
            <article>
                
<p class="calibre3">The next step is to change <kbd class="calibre13">MyInputController.cs</kbd> to populate the input data object, using a reference to the object, as follows:</p>
<pre class="calibre18">public MyInputAction myInput;<br class="title-page-name"/><br class="title-page-name"/>void Update () <br class="title-page-name"/>{<br class="title-page-name"/>  if (ButtonDown())<br class="title-page-name"/>  {<br class="title-page-name"/>    myInput.buttonAction = MyInputAction.ButtonAction.PressedDown;<br class="title-page-name"/>  } else if (ButtonUp())<br class="title-page-name"/>  {<br class="title-page-name"/>    myInput.buttonAction = MyInputAction.ButtonAction.ReleasedUp;<br class="title-page-name"/>  } else<br class="title-page-name"/>  {<br class="title-page-name"/>    myInput.buttonAction = MyInputAction.ButtonAction.None;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre3">The script uses its own <kbd class="calibre13">ButtonDown</kbd> and <kbd class="calibre13">ButtonUp</kbd> functions to set the <kbd class="calibre13">buttonAction</kbd> as appropriate. These could even be changed from <em class="calibre14">public</em> to <em class="calibre14">private</em> to further encapsulate it. </p>
<p class="calibre3">Save the script. Then in Unity:</p>
<ol class="calibre15">
<li class="calibre12">Select <span><strong class="calibre1">MeMyselfEye</strong></span> object in Hierarchy</li>
<li class="calibre12">Find the <span>My Input Action Data</span> object in your <kbd class="calibre13">ScriptableObjects</kbd> folder</li>
<li class="calibre12">Drag it onto the <span>My Input</span> slot of the <span>My Input Controller (Script)</span> component, as shown here for my Steam version of <kbd class="calibre13">MeMyselfEye</kbd>:</li>
</ol>
<div class="mce-root1"><img src="assets/15e864f6-a58f-4dbf-8412-4b55731d4b69.png" class="calibre24"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing the input action object</h1>
                </header>
            
            <article>
                
<p class="calibre3">Now the <kbd class="calibre13">BalloonController</kbd> can access the input data object rather than <kbd class="calibre13">MeMyselfEye</kbd>. Otherwise is very similar and a simple refactor. Modify <kbd class="calibre13">BalloonController.cs</kbd> as follows.</p>
<p class="calibre3">First, we can remove any references to <kbd class="calibre13">MeMyselfEye</kbd> in the <kbd class="calibre13">BalloonController</kbd>, including the public variable and the entire <kbd class="calibre13">Start()</kbd> function (we do not need the <kbd class="calibre13">GetComponent&lt;MyInputController&gt;</kbd>).</p>
<p class="calibre3">Add a variable for the input data object:</p>
<pre class="calibre18">public MyInputAction myInput;</pre>
<p class="calibre3">And reference it in the <kbd class="calibre13">Update</kbd> conditions:</p>
<pre class="calibre18">void Update()<br class="title-page-name"/>{<br class="title-page-name"/>  if (myInput.buttonAction == MyInputAction.ButtonAction.PressedDown)<br class="title-page-name"/>  {<br class="title-page-name"/>    NewBalloon();<br class="title-page-name"/>  }<br class="title-page-name"/>  else if (myInput.buttonAction == MyInputAction.ButtonAction.ReleasedUp)<br class="title-page-name"/>  {<br class="title-page-name"/>    ReleaseBalloon();<br class="title-page-name"/>  }<br class="title-page-name"/>  else if (balloon != null)<br class="title-page-name"/>  {<br class="title-page-name"/>   GrowBalloon();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre3">Save the script. Then in Unity, as we did previously for <kbd class="calibre13">MyInputController</kbd>:</p>
<ol class="calibre15">
<li class="calibre12">Select the <span>BalloonController</span> object in <span>Hierarchy</span></li>
<li class="calibre12">Find the <span>My Input Action Data</span> object in your <kbd class="calibre13">ScriptableObjects</kbd> folder</li>
<li class="calibre12">Drag it onto the <span>My Input</span> slot of the <span>Balloon Controller</span> component</li>
</ol>
<p class="calibre3">Press <strong class="calibre5"><span class="calibre6">Play</span></strong>. The app should work just like before. Press the button to create a balloon, hold the button to inflate it, and release the button to release the balloon.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simulation testing with scriptable objects</h1>
                </header>
            
            <article>
                
<p class="calibre3">An interesting advantage of this architecture is how it facilitates testing. Having completely decoupled our application objects from the input device, we can simulate input actions without actually using physical input controllers. For example, try this:</p>
<ol class="calibre15">
<li class="calibre12">Select <span>MeMyselfEye</span> in <span>Hierarchy</span>. Then in <span>Inspector</span>, temporarily disable the <strong class="calibre1"><span>My Input Controller</span></strong> component by unchecking its checkbox.</li>
<li class="calibre12">Select the <span>My Input Action Data</span> object in the Project <kbd class="calibre13">ScriptableObjects/</kbd> folder</li>
<li class="calibre12">Press <strong class="calibre1">Play.</strong></li>
<li class="calibre12">While the game is running, in <span>Inspector</span>, change the <span>Button Action</span> from <span>None</span> to <span>PressedDown</span>.</li>
<li class="calibre12">The <span>BalloonController</span> thinks a <span>PressedDown</span> action has occurred. It creates a new balloon and begins inflating it.</li>
<li class="calibre12">In <span>Inspector</span><span>, change the</span> <span>Input Action</span> <span>to</span> <span>PressedUp</span>.</li>
<li class="calibre12">The <span>BalloonController</span> sees a <strong class="calibre1"><span>PressedUp</span></strong> action has occurred and releases the current balloon.</li>
</ol>
<p class="calibre3">When you're done testing, don't forget to re-enable the input controller component!</p>
<p class="calibre3">This kind of manual setup of object states for development and testing can be very helpful, especially as your project grows and gets more complex.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Unity events for input</h1>
                </header>
            
            <article>
                
<p class="calibre3">The third software pattern we will explore using Unity Events. Events allow decoupling of the source of the event from the consumer of the event. Basically, events are a messaging system where one object triggers an event. Any other objects in the project can listen for the event. It can subscribe a specific function to be called when the event occurs.</p>
<p class="calibre3">You can set this up using drag-and-drop via the Unity Inspector. Or you can subscribe listener functions in scripts. In this example, we will minimize the scripting involved, and use the Unity editor to subscribe to events.</p>
<div class="packttip">Events are a very rich topic and we can only introduce them here. For more information on using Unity Events, there are a lot of good references online, including the Unity tutorials <a href="https://unity3d.com/learn/tutorials/topics/scripting/events" class="calibre20">https://unity3d.com/learn/tutorials/topics/scripting/events</a> and <a href="https://unity3d.com/learn/tutorials/topics/scripting/events-creating-simple-messaging-system" class="calibre20">https://unity3d.com/learn/tutorials/topics/scripting/events-creating-simple-messaging-system</a><span>.</span></div>
<p class="calibre3">The following diagram illustrates the relationship between our input controller, which invokes events, and the balloon controller, which subscribes to the events:</p>
<div class="mce-root1"><img src="assets/b7ee0d95-05b4-4178-9d2a-f2c8f77d113f.jpg" class="calibre24"/></div>
<p class="calibre3"><span class="calibre6">It'</span><span class="calibre6">s important to note that, unlike normal events, these events do not need to be unsubscribed.</span></p>
<div class="packtinfobox"><span>If you are a developer and familiar with .NET, it may help to know that Unity Events are delegates. As explained in the Unity Manual, "UnityEvents can be added to any MonoBehaviour and are executed from code like a standard .net delegate. When a UnityEvent is added to a MonoBehaviour it appears in the Inspector and persistent callbacks can be added." </span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Invoking our input action events</h1>
                </header>
            
            <article>
                
<p class="calibre3">To implement our example using events, we'll first have the <kbd class="calibre13">MyInputController</kbd> trigger events when a button is pressed and another event when the button is released. </p>
<p class="calibre3">First, at the top of the script we need to declare that we are using the Unity event API. The we declare the two UnityEvents we will invoke. <span class="calibre6">The </span><kbd class="calibre13">Update()</kbd><span class="calibre6"> function only needs to invoke one event or the other as they happen. </span></p>
<p class="calibre3">The entire <kbd class="calibre13">MyInputController.cs</kbd> is as follows:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/>using UnityEngine.Events;<br class="title-page-name"/><br class="title-page-name"/>public class MyInputController : MonoBehaviour <br class="title-page-name"/>{<br class="title-page-name"/> public UnityEvent ButtonDownEvent;<br class="title-page-name"/> public UnityEvent ButtonUpEvent;<br class="title-page-name"/><br class="title-page-name"/> void Update()<br class="title-page-name"/> {<br class="title-page-name"/>   if (ButtonDown())<br class="title-page-name"/>     ButtonDownEvent.Invoke();<br class="title-page-name"/>   else if (ButtonUp())<br class="title-page-name"/>     ButtonUpEvent.Invoke();<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/> private bool ButtonDown()<br class="title-page-name"/> {<br class="title-page-name"/>   return Input.GetButtonDown("Fire1");<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/> private bool ButtonUp()<br class="title-page-name"/> {<br class="title-page-name"/>   return Input.GetButtonUp("Fire1");<br class="title-page-name"/> }<br class="title-page-name"/>}</pre>
<p class="calibre3"> That's it for this side of the equation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Subscribing to input events</h1>
                </header>
            
            <article>
                
<p class="calibre3">Using events, <kbd class="calibre13">BalloonController</kbd> does not need to check for input actions each frame Update. All that conditional logic can be bypassed. Instead, we'll drag and drop the components to subscribe them to events. The <kbd class="calibre13">Update</kbd> function now only needs to grow the balloon if it's already instantiated.</p>
<p class="calibre3">The entire <kbd class="calibre13">BalloonController.cs</kbd> now looks like this. Aside from being less code, please note that we changed the <kbd class="calibre13">NewBalloon</kbd> and <kbd class="calibre13">ReleaseBalloon</kbd> functions from <kbd class="calibre13">private</kbd> to <kbd class="calibre13">public</kbd> so we can reference them in the Inspector:</p>
<pre class="calibre18">public class BalloonController : MonoBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>  public GameObject balloonPrefab;<br class="title-page-name"/>  public float floatStrength = 20f;<br class="title-page-name"/>  public float growRate = 1.5f;<br class="title-page-name"/><br class="title-page-name"/>  private GameObject balloon;<br class="title-page-name"/><br class="title-page-name"/> void Update()<br class="title-page-name"/> {<br class="title-page-name"/>   if (balloon != null)<br class="title-page-name"/>     GrowBalloon();<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/> public void NewBalloon()<br class="title-page-name"/> {<br class="title-page-name"/>   balloon = Instantiate(balloonPrefab);<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/> public void ReleaseBalloon()<br class="title-page-name"/> {<br class="title-page-name"/>   balloon.GetComponent&lt;Rigidbody&gt;().AddForce(Vector3.up * floatStrength);<br class="title-page-name"/>   balloon = null;<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/> private void GrowBalloon()<br class="title-page-name"/> {<br class="title-page-name"/>   balloon.transform.localScale += balloon.transform.localScale * growRate * Time.deltaTime;<br class="title-page-name"/> }<br class="title-page-name"/>}</pre>
<p class="calibre3">To wire up the input events to our balloon controller:</p>
<ol class="calibre15">
<li class="calibre12">Select <span>MeMyselfEye</span> and look at its <span>Inspector</span> window</li>
<li class="calibre12">You will see the <span>My Input Controller</span> component now has two event lists, as we declared in its script</li>
<li class="calibre12">On the <span>Button Down Event</span> list, press the <span>+</span> in the lower-right to create a new item. </li>
<li class="calibre12">Drag the <span>BalloonController</span> from <span>Hierarchy</span> into the empty Object slot</li>
<li class="calibre12">In the function select list, choose <strong class="calibre1"><span>BalloonController</span></strong> | <strong class="calibre1"><span>NewBalloon</span></strong></li>
</ol>
<p class="calibre3">Repeat the process for the Button Up Event as follows:</p>
<ol class="calibre15">
<li class="calibre12">On the <span>Button Up Event</span> list, press the <span>+</span> in the lower-right to create a new item</li>
<li class="calibre12">Drag the <span>BalloonController</span> from <span>Hierarchy</span> into the empty Object slot</li>
<li class="calibre12">In the function select list, choose <strong class="calibre1"><span>BalloonController</span></strong> | <strong class="calibre1"><span>ReleaseBalloon</span></strong></li>
</ol>
<p class="calibre3">The component should now look like this:</p>
<div class="mce-root1"><img src="assets/58469bd5-2930-4ff0-9177-4f6d833f1acb.png" class="calibre24"/></div>
<p class="calibre3">Now when you press <span class="calibre6">Play</span> and press a button, the input controller invokes an event. The <em class="calibre14">NewBalloon</em> function is listening for these events and gets called. Likewise for the Button Up event.</p>
<p class="calibre3">This wiring can also be done entirely with scripting. We will not go into it here. As a developer, we more often are "users" of event systems set up by others. As your experience grows, you may find yourself implementing your own custom events.</p>
<div class="packtinfobox">For another detailed example of using Unity Events for user interface, consider <em class="calibre2">Augmented Reality for Developers</em>, a Unity projects book from Packt Publishing co-authored by the author of this book, Jonathan Linowes, and Krystian Babilinski.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Really using your hands</h1>
                </header>
            
            <article>
                
<p class="calibre3">The last couple of things we'll explore in the chapter involve getting your hands even more into virtual reality. In addition to <span class="calibre6">buttons and touch pads, </span>VR hand controllers can be tracked in 3D space along with your head. PC- and console-based VR, such as Rift, Vive, MR, and PSVR, are really very good at this, with full positionally tracked hand controllers for both left and right hands. Lower-end mobile VR, such as Daydream, has a single hand controller with limited tracking, but better than nothing.</p>
<p class="calibre3">To start, we'll take advantage of positional tracking by simply parenting the balloon to your hand model. On VR, without actual positional tracking, like Daydream, the location of your hand controller is approximated by the SDK software, but useful enough.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parenting balloons to your hand</h1>
                </header>
            
            <article>
                
<p class="calibre3">Suppose when you press the button, rather than creating the new balloon at a fixed position in space, it spawns and grows from your hand position. One way to accomplish this is to make the balloon instance a child of your hand controller object.</p>
<p class="calibre3">The BalloonController will need to know which hand pressed the button and parent the balloon to that controller object. Specifically, we'll pass the hand Game Object to the <kbd class="calibre13">NewBalloon</kbd> function as follows:</p>
<pre class="calibre18">public void NewBalloon(GameObject parentHand)<br class="title-page-name"/>{<br class="title-page-name"/>  if (balloon == null)<br class="title-page-name"/>  {<br class="title-page-name"/>    balloon = Instantiate(balloonPrefab);<br class="title-page-name"/>    balloon.transform.SetParent(parentHand.transform);<br class="title-page-name"/>    balloon.transform.localPosition = Vector3.zero;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre3">Note that in this function we added an extra test for (<kbd class="calibre13">balloon == null</kbd>), just to make sure we haven't called <kbd class="calibre13">NewBalloon</kbd> twice in a row without releasing the first one yet.</p>
<p class="calibre3">Like before, we instantiate a new balloon from the prefab.</p>
<p class="calibre3">Then, we set its parent to the <kbd class="calibre13">parentHand</kbd> object. This is comparable to dragging one object to become a child of another in the Hierarchy. The parent-child relationships between game objects are handled by the built-in <em class="calibre14">Transform</em> component so the API functions are on the transform.</p>
<p class="calibre3">Lastly, we reset the local position of the balloon. If you recall, the prefab was positioned at (0, 1, 1) or something like that. As a child of the hand, we want it attached directly at the pivot point of the hand model. (Alternatively, you could offset the balloon origin to a different attachment point as needed.)</p>
<p class="calibre3">Worth noting, there are variations of the <em class="calibre14">Instantiate</em> function that let you specify the parent and transforms all in one call. See <a href="https://docs.unity3d.com/ScriptReference/Object.Instantiate.html" class="calibre10">https://docs.unity3d.com/ScriptReference/Object.Instantiate.html</a> .</p>
<p class="calibre3"><span class="calibre6">Likewise, the <kbd class="calibre13">ReleaseBalloon</kbd> detaches the balloon from the hand before send it on its way, as follows:</span></p>
<pre class="calibre18"> public void ReleaseBalloon()<br class="title-page-name"/> {<br class="title-page-name"/>   if (balloon != null)<br class="title-page-name"/>   {<br class="title-page-name"/>     balloon.transform.parent = null;<br class="title-page-name"/>     balloon.GetComponent&lt;Rigidbody&gt;().AddForce(Vector3.up * floatStrength);<br class="title-page-name"/>   }<br class="title-page-name"/>   balloon = null;<br class="title-page-name"/> }</pre>
<p class="calibre3">How do we pass the hand game object to NewBalloon? Assuming your project is presently using the Unity Events we setup in the previous topic, it's very easy. In <span class="calibre6">Inspector</span> we need to update the <span class="calibre6">Button Down Event</span> function, since it now requires the game object argument:</p>
<ol class="calibre15">
<li class="calibre12">In Unity editor, select the <span>MeMyselfEye</span> object</li>
<li class="calibre12">In the <span>Button Down Event</span> list, the function may now say something like <kbd class="calibre13">Missing BalloonController.NewBalloon</kbd></li>
<li class="calibre12">Select the <span>function</span> dropdown and choose <span>BalloonController</span> | <span>NewBalloon(GameObject)</span></li>
</ol>
<p class="calibre3"> </p>
<ol start="4" class="calibre15">
<li class="calibre12">Unfold the <span>MeMyselfEye</span> object in <span>Hierarchy</span> and look for the hand model, then drag it onto the empty Game Object slot</li>
<li class="calibre12">If you are using OpenVR, the hand will be called <span>Controller (right)</span></li>
<li class="calibre12">If you are using Daydream, the hand will be called <span>GvrControllerPointer</span></li>
</ol>
<p class="calibre3">Here is a screenshot of me generating a bunch of balloons flying "over" the Grand Canyon, fun!</p>
<div class="mce-root1"><img src="assets/4a1140e8-35eb-42ae-b30f-556bc0639af3.png" class="calibre47"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Popping balloons</h1>
                </header>
            
            <article>
                
<p class="calibre3">To be honest, it's really hard to think about creating balloons without also wanting to pop them! For fun, let's do a quick implementation. You can come up with your own ideas how to improve on it.</p>
<p class="calibre3">The Unity physics engine can detect when two object collide. To do this, each object must have a <em class="calibre14">Collider</em> component attached. You can then have the collision trigger an event. And we can subscribe that event to make something else happen, like play an explosion effect. This gets set up on the balloon prefab. So when two balloons collide, they'll explode. Let's do that:</p>
<ol class="calibre15">
<li class="calibre12">Drag a copy of your Balloon prefab from Project <kbd class="calibre13">Assets prefabs</kbd> folder into the scene <span>Hierarchy</span><strong class="calibre1">.</strong></li>
<li class="calibre12">Select <span>Add Component</span> | <span>Physics</span> | <span>Sphere Collider</span>.</li>
<li class="calibre12">To scale and center the collider into position, click the <span>Edit Collider</span> icon in its component.</li>
<li class="calibre12">In the <strong class="calibre1">Scene</strong> window, the green collider outline has small anchor points you can click to edit. Note that the <em class="calibre2">Alt</em> key pins the center position and <em class="calibre2">Shift</em> locks the scale ratio.</li>
<li class="calibre12">Or, you can edit the <strong class="calibre1"><span>Center</span></strong> and <span>Radius</span> values directly. I like <span>Radius</span> 0.25 and <span>Center</span> (0, 0.25, 0) on my balloon.</li>
</ol>
<p class="calibre3">Now, we will add a script to handle the collision events. </p>
<ol class="calibre15">
<li class="calibre12"><span>Add Component</span> to create a new C# script,</li>
<li class="calibre12">Name it <kbd class="calibre13">Poppable</kbd></li>
<li class="calibre12">And open it for editing</li>
</ol>
<p class="calibre3">The <span class="calibre6"><kbd class="calibre13">Poppable</kbd></span> script will provide a callback function for <kbd class="calibre13">OnCollisionEnter</kbd> events. When another object with a collider enters this object's collider, our function will get called. At that point, we'll call <kbd class="calibre13">PopBalloon</kbd> which instantiates the explosion and destroys the balloon:</p>
<pre class="calibre18">public class Poppable : MonoBehaviour<br class="title-page-name"/>{<br class="title-page-name"/> public GameObject popEffect;<br class="title-page-name"/><br class="title-page-name"/> void OnCollisionEnter(Collision collision)<br class="title-page-name"/> {<br class="title-page-name"/>   PopBalloon();<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/> private void PopBalloon()<br class="title-page-name"/> {<br class="title-page-name"/>   Instantiate(popEffect, transform.position, transform.rotation);<br class="title-page-name"/>   Destroy(gameObject);<br class="title-page-name"/> }<br class="title-page-name"/>}</pre>
<p class="calibre3">You can see that the <kbd class="calibre13">OnCollisionEnter</kbd> gets a <kbd class="calibre13">Collision</kbd> argument with information including what game object collided with it. We will ignore this here but you might explore it more: <a href="https://docs.unity3d.com/ScriptReference/Collision.html" class="calibre10">https://docs.unity3d.com/ScriptReference/Collision.html</a>.</p>
<p class="calibre3">Save the script. Now, back in Unity:</p>
<ol class="calibre15">
<li class="calibre12">Select a particle system prefab from <strong class="calibre1">Project</strong> Assets, such as <kbd class="calibre13">Assets/Standard Assets/ParticleSystems/Prefabs/Explosion</kbd> (this is the one we used to kill Ethan in <a href="b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml" target="_blank" class="calibre10">Chapter 4</a>, <em class="calibre2">Gaze-Based Control</em>)</li>
<li class="calibre12">Drag the <span>effects</span> prefab onto the Poppable's <kbd class="calibre13">Pop Effect</kbd> slot</li>
<li class="calibre12">Save these changes back to the prefab by pressing <span>Apply</span></li>
<li class="calibre12">You can now delete the <span><strong class="calibre1">Balloon</strong></span> from the <span>Hierarchy</span></li>
</ol>
<p class="calibre3">Alright, let's try it. Press <span class="calibre6">Play</span>. Create a balloon. Then, reach out and push the button again so a new balloon collides with that one. Does it explode? Yikes!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interactable items</h1>
                </header>
            
            <article>
                
<p class="calibre3">Directly interacting with objects in VR, such as grabbing items and using them to perform other actions, is a bit more complex. And, it can be tricky to get right. So it doesn't make sense, especially in this book, to grow our own interaction system. Unfortunately, there is not a single standard toolkit either. But, there are more than a few very good toolkits you can use, albeit most are specific to individual target platforms.</p>
<p class="calibre3"><span class="calibre6">Generally, the architecture is similar among these solutions:</span></p>
<ul class="calibre11">
<li class="calibre12">Provides prefabs for the player camera rig</li>
<li class="calibre12">Camera rig includes objects for your hands, including input controller components</li>
<li class="calibre12">Hand objects include components that trigger events when interactions occur</li>
<li class="calibre12">An interactable component is added to any objects in the scene that can be interacted with using input events</li>
<li class="calibre12">Additional components and options extend the interactable behaviors</li>
</ul>
<p class="calibre3">Toolkits will include a number of demo scenes which provide rich examples how to use the particular toolkit. Often, it is more informative to study the demos to see how to use the toolkits than the actual documentation. </p>
<p class="calibre3">In this section, we introduce a grabbing and throwing mechanic using two toolkits, the <em class="calibre14">SteamVR InteractionSystem</em> and the <em class="calibre14">Daydream VR Elements</em>. The technique is similar for other platforms.</p>
<div class="packtinfobox">For Oculus SDK (without OpenVR), you will need to integrate the Oculus Avatar SDK (see <a href="721ca227-9208-4342-b6ac-a12799adbb2b.xhtml" target="_blank" class="calibre20">Chapter 12</a>, <em class="calibre2">Social VR Metaverse</em>, for details on Oculus Avatars). Also, here's a quick video showing how to add an <kbd class="calibre26">OVR Grabber</kbd> component to your <kbd class="calibre26">OVRCameraRig</kbd> controllers: <a href="https://www.youtube.com/watch?v=sxvKGVDmYfY" class="calibre20">https://www.youtube.com/watch?v=sxvKGVDmYfY</a><span>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interactables using SteamVR Interaction System</h1>
                </header>
            
            <article>
                
<p class="calibre3">The SteamVR Unity package includes an Interaction System, originally developed and used for minigames and scenes from Steam's impressive demo VR application, <em class="calibre14">The Lab</em> (<a href="http://store.steampowered.com/app/450390/The_Lab/" class="calibre10">http://store.steampowered.com/app/450390/The_Lab/</a>). It can be found in the <kbd class="calibre13">Assets/SteamVR/InteractionSystem/</kbd> folder. We recommend you explore the example scenes, prefabs, and scripts.</p>
<p class="calibre3">The Interaction System includes its own <span class="calibre6">Player</span> camera rig which replaces the default <span class="calibre6">[CameraRig]</span> we have been using. The Player hierarchy is shown here:</p>
<div class="mce-root1"><img src="assets/eee0c315-01b3-405a-9a23-6b36fb920243.png" class="calibre48"/></div>
<p class="calibre3">It includes a <em class="calibre14">VRCamera</em>, two hands (<em class="calibre14">Hand1</em> and <em class="calibre14">Hand2</em>), and other useful objects. Each hand includes an attach point (<em class="calibre14">Attach_ControllerTip</em>), a hover highlight (<em class="calibre14">ControllerHoverHighlight</em>), and a tooltips object (<em class="calibre14">ControllerButtonHints</em>). </p>
<ol class="calibre15">
<li class="calibre12">Locate the <strong class="calibre1"><span>Player</span></strong> prefab in <kbd class="calibre13">SteamVR/InteractionSystem/Core/Prefabs </kbd>and drag it as a child of <span>MyMyselfEye</span> in your scene <span>Hierarchy</span></li>
<li class="calibre12">Delete or disable the <span>[CameraRig]</span> object</li>
</ol>
<p class="calibre3">For compatibility with the current scene, we also need to update the <strong class="calibre5">NewBalloon</strong> argument in <strong class="calibre5">Button Down Event</strong>:</p>
<ol class="calibre15">
<li class="calibre12">Unfold the <span>Player</span> object in <span>Hierarchy</span> so you can see the <span>Hand1</span> and <span>Hand2</span> objects</li>
<li class="calibre12">Select the <span>MeMyselfEye</span> in <span>Hierarchy</span></li>
<li class="calibre12">Drag <span>Hand2</span> (or <span>Hand1</span>) from <strong class="calibre1"><span>Hierarchy</span></strong> onto the <span>GameObject</span> argument slot in the <span>Button Down Event</span> on the <span>My Input Controller</span> component</li>
</ol>
<p class="calibre3">Next, for interactable objects there is a large collection of components available. Review the <kbd class="calibre13">SteamVR/InteractionSystem/Core/Scripts</kbd> folder contents. We will use the <em class="calibre14">Throwable</em> one.</p>
<p class="calibre3">First, lets try this on a basic Cube. Then, we'll make the balloons grabbable and throwable too:</p>
<ol class="calibre15">
<li class="calibre12">In Hierarchy, create a cube (<span>Create</span> | <span>3D Object</span> | <span>Cube</span>).</li>
<li class="calibre12">Scale and position it within reaching distance of the Player. For example, <span>Scale</span> (0.3, 0.3, 0.3) and <strong class="calibre1"><span>Position</span></strong> (-0.25, 1.3, -0.25) may work.</li>
<li class="calibre12">With the Cube selected, <span>Add Component</span> <kbd class="calibre13">Throwable</kbd><span> from the Interaction System.</span></li>
<li class="calibre12">Notice this will automatically add other required components, including the base Interactable and a RigidBody.</li>
<li class="calibre12">On the <span>RigidBody</span> component, uncheck the <span>Use Gravity</span> checkbox, so it hangs in the air rather than falling to the ground when you play.</li>
</ol>
<p class="calibre3">Now when you press <span class="calibre6">Play</span>, reach out to the Cube so your controller penetrates (collides) it. Then, using the Trigger on your controller, grab the Cube and throw it <em class="calibre14">outta here</em>!</p>
<p class="calibre3">To make the balloons throwable, we modify the prefab:</p>
<ol start="1" class="calibre15">
<li class="calibre12">Drag a copy of the <span>Balloon</span> prefab from the <span>Project</span> window into the scene <span>Hierarchy</span></li>
<li class="calibre12"><span>Add Component</span> the Steam <span>Throwable</span></li>
<li class="calibre12">Press <span><strong class="calibre1">Apply</strong></span> to save the prefab</li>
<li class="calibre12">And delete the Balloon from the Hierarchy</li>
</ol>
<p class="calibre3">Press <span class="calibre6">Play</span>. Press the <span class="calibre6">Fire1</span> button to create and inflate a balloon. Release it. Then, grab it with the trigger. Throw the balloon. If you implemented the <em class="calibre14">Poppable</em> explosion earlier, it'll even explode like a projectile when it hits something, like the ground or the photo plane! </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interactables using Daydream VR Elements</h1>
                </header>
            
            <article>
                
<p class="calibre3">The base GoogleVR package does not include interactables, but you can find them in the Daydream Elements package. This package is a collection of demo scenes, components, and prefabs for using Daydream VR from the engineers at Google. To get the package:</p>
<ol class="calibre15">
<li class="calibre12">Visit the Daydream Elements' Github Releases page at <a href="https://github.com/googlevr/daydream-elements/releases" class="calibre10">https://github.com/googlevr/daydream-elements/releases</a></li>
<li class="calibre12">Download <kbd class="calibre13">DaydreamElements.unitypackage</kbd></li>
<li class="calibre12">Import it into your project using <strong class="calibre1"><span>Assets</span></strong> | <strong class="calibre1"><span>Import Package</span></strong> | <strong class="calibre1"><span>Custom Package...</span></strong></li>
</ol>
<p class="calibre3">The package includes a prefab named <kbd class="calibre13">ObjectManipulationPointer</kbd> which is a drop-in replacement for the <kbd class="calibre13">GvrControllerPointer</kbd> we have been using:</p>
<ol class="calibre15">
<li class="calibre12">In <span>Hierarchy</span>, unfold your <span>MeMyselfEye</span> and drill down to the <span>Player</span> object</li>
<li class="calibre12">Select <span>GvrControllerPointer</span> and disable it in Inspector</li>
<li class="calibre12">In the <span>Project</span> window, navigate to the <kbd class="calibre13">Assets/DaydreamElements/Elements/ObjectManipulationDemo/Prefabs/UI/</kbd> folder</li>
<li class="calibre12">Drag the <span>ObjectManipulationPointer</span> prefab into <span>Hierarchy</span> as a sibling of <span>GvrControllerPointer</span></li>
</ol>
<p class="calibre3">For compatibility with the current scene, we also need to update the<span class="calibre6"> </span><span class="calibre6">NewBalloon</span><span class="calibre6"> </span>argument in<span class="calibre6"> </span><span class="calibre6">Button Down Event</span>:</p>
<ol class="calibre15">
<li class="calibre12">Select the<span> </span><span>MeMyselfEye</span><span> </span><span>in</span><span> </span><span>Hierarchy</span></li>
<li class="calibre12">Drag <span><span>ObjectManipulationPointer</span> </span>from<span> </span><span>Hierarchy</span><span> </span>onto the <span>GameObject</span> argument slot in the<span> </span><span>Button Down Event</span><span> </span>on the<span> </span><span>My Input Controller</span><span> </span>component</li>
</ol>
<p class="calibre3">Next, for interactable objects we add a <kbd class="calibre13">MoveablePhysicsObject</kbd> component, found in <kbd class="calibre13">Assets/DaydreamElements/Elements/ObjectManipulationDemo/Scripts/</kbd>.</p>
<div class="packtinfobox">Additional information on Daydream Elements object manipulation can be found at <a href="https://developers.google.com/vr/elements/object-manipulation" class="calibre20">https://developers.google.com/vr/elements/object-manipulation</a>.</div>
<p class="calibre3">First, lets try this on a basic Cube. Then, we'll make the balloons grabbable and throwable too:</p>
<ol class="calibre15">
<li class="calibre12">In <span>Hierarchy</span>, create a cube (<span>Create</span> | <span>3D Object</span> | <span>Cube</span>).</li>
<li class="calibre12">Scale and position it within reaching distance of the Player. For example,<span> </span><span>Scale </span>(0.25, 0.25, 0.25) and<span> </span><span>Position</span><span> </span>(-0.4, 0.75, -0.3) may work.</li>
<li class="calibre12">With the Cube selected,<span> </span><span>Add Component</span><span> </span><kbd class="calibre13">MoveablePhysicsObject</kbd><span>. </span></li>
<li class="calibre12">Notice this will automatically add a<span> </span><kbd class="calibre13">RigidBody</kbd> component if not present.</li>
<li class="calibre12">On the<span> </span><kbd class="calibre13">RigidBody</kbd><span> </span>component, uncheck the<span> Use Gravity</span><span> </span>checkbox, so it hangs in the air rather than falling to the ground when you play.</li>
</ol>
<p class="calibre3">Now when you press<span class="calibre6"> </span><span class="calibre6">Play</span>, use your controller so its laser beam hits the cube. Then, press the clicker button on your controller to grab it. Move it around and press again to release it.</p>
<p class="calibre3">Since the app is presently using the same button to create new balloons and manipulate the laser pointer, we get a balloon each time we use the button. Consider that a bug in your application. We will leave this as an exercise for you to implement the logic, for example, to tell <em class="calibre14">MyInputController</em> to not invoke events if the <em class="calibre14">MoveablePhysicsObject</em> is busy moving something. </p>
<div class="packttip">Hint: you could add a script component to Cube that checks the MoveablePhysicsObject state and disables MyInputController actions when the object is Selected. This is not well documented but look at the source code for MoveablePhysicsObjects.cs and its base class, BaseInteractiveObjects.cs.</div>
<p class="calibre3">To make the balloons throwable, we modify the prefab:</p>
<ol class="calibre15">
<li class="calibre12">Drag a copy of the<span> </span><span>Balloon</span><span> </span>prefab from the<span> </span><span>Project</span><span> </span>window into the scene<span> </span><span>Hierarchy</span></li>
<li class="calibre12"><span>Add Componen</span><strong class="calibre1"><span>t</span></strong><span> </span>the <span>MoveablePhysicsObject</span></li>
<li class="calibre12">Click <span>Apply</span><span> </span>to save the prefab</li>
<li class="calibre12">And delete the Balloon from Hierarchy</li>
</ol>
<p class="calibre3">Press<span class="calibre6"> </span><span class="calibre6">Play</span>. Press the<span class="calibre6"> </span>button to create and inflate a balloon. Release it. Then, try to grab it with the laser pointer. If you implemented the<span class="calibre6"> </span><em class="calibre14">Poppable</em><span class="calibre6"> </span>explosion earlier, it'll even explode like a projectile when it hits something! </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="calibre3">In this chapter, we explored a variety of software patterns for handling user input for your VR projects. The player uses a controller button to create, inflate, and release balloons into the scene. First, we tried the standard Input class for detecting logical button clicks, like the "Fire1" button, and then learned how to access device-specific SDK input, such as the OpenVR trigger button with haptic feedback. </p>
<p class="calibre3">In our scene, we implemented a simple input component for polling the button actions. Then, we refactored the code to use scriptable objects to hold the input action data. In the third implementation, we used Unity Events to message input actions to listening components. We also enhanced the scene to attach the balloon to your virtual hand position, and added the ability to pop the balloons as  explosive projectiles! Lastly, we used an interactable framework (for SteamVR and Daydream) to implement grabbing and throwing mechanics, using components provided in given toolkits rather than attempting to write our own.</p>
<p class="calibre3">In the next chapter, we will further explore user interactions, using the Unity UI (user interface) system for implementing information canvases, buttons, and other UI controls. </p>
<p class="calibre3"> </p>
<p class="calibre3"> </p>
<p class="calibre3"> </p>


            </article>

            
        </section>
    </body></html>