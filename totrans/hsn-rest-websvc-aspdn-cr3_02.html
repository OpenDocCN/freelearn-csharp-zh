<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">REST 101 and Getting Started with ASP.NET Core</h1>
                </header>
            
            <article>
                
<p>Nowadays, almost all applications rely on web services. A lot of them operate using the RESTful method. The resource-centric approach and the simplicity of the REST style have become an industry standard. Therefore, it is essential to understand the theory behind the REST way of working and why it is important. <span>This chapter will introduce you to the <strong>Representational State Transfer</strong> (<strong>REST</strong>) method. We will see what the definition of REST is and how to identify REST-compliant web services. We will also </span>introduce .NE<span>T Core 3.1 and ASP.NET Core, the b</span><span>rand new version of the open-source, cross-platform framework provided by Microsoft.</span></p>
<p>In summary, this chapter covers the following topics:</p>
<ul>
<li>Overview of REST architectural elements</li>
<li>A brief introduction to the .NET ecosystem</li>
<li>Why you should choose .NET to build a RESTful web service</li>
</ul>
<p><span>By the end of this chapter, you will have an overview of some</span><span> useful tools and IDEs that you can use to start developing on .NET Core.</span></p>
<p>This chapter will cover some of the base concepts of <span>.NET Core 3.1 and ASP.NET Core</span><span>. You need to have</span><span> either</span><span> Windows, Linux, or macOS installed. The setup process will depend on which OS you are using. We'll look at the different tools that can be used to develop apps and web services in .NET Core. </span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">REST</h1>
                </header>
            
            <article>
                
<p>What is REST? <span> </span><span><strong>Representational State Transfer</strong> (<strong>REST</strong>) is usually defined as a software architecture style that applies some constraints to a web service. It identifies a set of resource-centric rules that describe the roles and the interaction between the constraints of a distributed hypermedia system, instead of focusing on the implementation of the components. Although it is quite rare to find a REST service that does not use HTTP</span>, the definition does not mention any of these topics and instead describes REST as media- and protocol-agnostic.</p>
<p>The preceding definition can be further explained with an example. Consider an e-commerce website. When you browse a list of products and click on one them, the browser interprets your click as a request to a specific resource; in this case, the details of the product you clicked on. The browser makes an HTTP call to the URI, which corresponds to the details of the product and asks for a specific resource using the URI. This process is shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/45c0c1b9-0d12-48e2-8f11-351aa8738e9a.png"/></div>
<p>The concept of REST is pretty similar: the client asks the server for a specific resource, and this allows them to navigate and obtain other information about resources stored on the server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The importance of being REST compliant</h1>
                </header>
            
            <article>
                
<p>Before we discuss REST, we should understand the importance of web services in the modern application development world.</p>
<p>A typical modern application uses web services to obtain and query data. Any company that develop any product or solution uses web services to deliver and track information. <span>This is because it can be difficult to replicate all the data and every behavior you need for every client who uses your application.</span> Web services are also useful for providing access to third-party clients and services. Consider, for example, the <strong>Application Programming Interfaces</strong> (<strong>APIs</strong>) of Google Maps or Instagram: these platforms expose information through HTTP to share it with other companies and services.</p>
<p>The REST approach to web service architecture became increasingly popular because it is straightforward and clear. Unlike some old methods, such as the <strong>Simple Object Access Protocol</strong> (<strong>SOAP</strong>) or the <strong>Windows Communication Foundation</strong> (<strong>WCF</strong>), REST services provide a clean way of querying data. Different information can be obtained using different URIs without the need for adding any overhead to requests. </p>
<p>Today, more than ever, our services need to be prepared to scale so that they can be adapted to consumers. In a world of <span>different technologies and distributed </span><span>teams</span><span> </span><span>around the globe, we should be able to transform our architecture to solve complex business challenges. HTTP and REST help us address these challenges.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">REST requirements</h1>
                </header>
            
            <article>
                
<p><span>Roy Thomas Fielding is the main person behind the formalization of the </span>HTTP protocol and the REST style: he described them in his dissertation, <em>Architectural Styles and the Design of Network-based Software Architectures</em> (<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm</a>). Moreover, <span>Fielding's dissertation clearly defines</span> the constraints of a REST system, as follows:</p>
<ul>
<li>Uniform interface</li>
<li>Stateless</li>
<li>Cacheable</li>
<li>Client-server</li>
<li>Layered system</li>
<li>Code on demand</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>All of these, apart from code on demand, are essential when we wish to define a web service as REST-compliant. To explain these concepts, we will use the APIs provided by The New York Times: <a href="https://developer.nytimes.com/">https://developer.nytimes.com/</a>. To use these APIs, you need to go through a pre-authentication process. You can get an API key for this from the following link: <a href="https://developer.nytimes.com/signup">https://developer.nytimes.com/signup</a>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Uniform interface</h1>
                </header>
            
            <article>
                
<p>Uniform interface refers to the separation between the client and the server. This is advantageous because it means that the two systems are independent. The first principle of a uniform interface is that it should be r<em>esource-based,</em> which means that we should start to think in a <em>resource-oriented way</em>. Therefore, every object or entity inside our system is a resource and a URI uniquely identifies each of them. F<span>urthermore, if we think about the HTTP protocol, each resource is presented to the client in the form of XML or JSON to decouple the client from the server.</span></p>
<p>Let's use The New York Times APIs to understand this topic. Consider the following URI:</p>
<pre>http://api.nytimes.com/svc/archive/v1/2018/6.json?api-key={your_api_key}</pre>
<p>It contains some precise information about the resources we are asking for, including the following: </p>
<ul>
<li>The fact that we are getting information from the <em>archive</em> section of the newspaper data</li>
<li><span>The specific month we are asking for; in this case, June 2018</span></li>
<li>The fact that the resource will be serialized using <em>JSON format</em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Manipulation of resources through representations</h1>
                </header>
            
            <article>
                
<p>Let's take another API request provided by The New York Times:</p>
<pre>https://api.nytimes.com/svc/books/v3/lists.json?api-key={your_api_key}&amp;list=hardcover-fiction</pre>
<p>This provides a list of books based on a category; in this case, this category is <kbd>Hardcover Fiction</kbd>. Let's analyze the response:</p>
<pre>{<br/>    "status": "OK",<br/>    "copyright": "Copyright (c) 2018 The New York Times Company. All Rights <br/>      Reserved.",<br/>    "num_results": 15,<br/>    "last_modified": "2018-06-28T02:38:01-04:00",<br/>    "results": [<br/>        {<br/>            "list_name": "Hardcover Fiction",<br/>            "display_name": "Hardcover Fiction",<br/>            "published_date": "2018-07-08",<br/>            "isbns": [<br/>                {<br/>                    "isbn10": "1780898401",<br/>                    "isbn13": "9780316412698"<br/>                }<br/>            ],<br/>            "book_details": [<br/>                {<br/>                    "title": "THE PRESIDENT IS MISSING",<br/>                    "contributor": "by Bill Clinton and James Patterson",<br/>                    "author": "Bill Clinton and James Patterson",<br/>                    "contributor_note": "",<br/>                    "price": 0,<br/>                    "age_group": "",<br/>                    "publisher": "Little, Brown and Knopf"<br/>                }<br/>            ],<br/>            "reviews": [<br/>                {<br/>                    "book_review_link": "",<br/>                    "first_chapter_link": ""<br/>                }<br/>            ]<br/>        }<br/>        ....<br/>    ]<br/>}</pre>
<p>As you can see, this is a clear representation of the resource. The client has all the required <span>information</span><span> </span><span>to process and modify data using APIs (if the APIs allow that). </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Self-descriptive messages</h1>
                </header>
            
            <article>
                
<p>Let's look at the response of the following call:</p>
<pre>https://api.nytimes.com/svc/books/v3/lists.json?api-key={your_api_key}&amp;list=hardcover-fiction</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As we mentioned previously, the response is a representation of the data, either stored in a data source or obtained from another system. In any case, some information is missing: how does the client know the format of the response? This kind of information is usually written in the response header. For example, here are all the headers of the previous request:</p>
<pre>accept-ranges: bytes<br/>access-control-allow-headers:<span>Accept, Content-Type, X-Forwarded-For, X-Prototype-Version, X-Requested-With</span><br/>access-control-allow-methods: GET, OPTIONS<br/>access-control-allow-origin: *<br/>access-control-expose-headers: Content-Length, X-JSON<br/>age: 0<br/>connection: keep-alive<br/>content-length: 14384<br/>content-type: application/json; charset=UTF-8<br/>date: Tue, 03 Jul 2018 12:47:08 GMT<br/>server: Apache/2.2.15 (CentOS)<br/>vary: Origin<br/>via: kong/0.9.5<br/>x-cache: MISS<br/>x-kong-proxy-latency: 4<br/>x-kong-upstream-latency: 29<br/>x-ratelimit-limit-day: 1000<br/>x-ratelimit-limit-second: 5<br/>x-ratelimit-remaining-day: 988<br/>x-ratelimit-remaining-second: 4<br/>x-varnish: 63737329</pre>
<p class="mce-root">The <em>headers</em> part tells the client that the response should be processed using a specific <kbd>content-type</kbd><em>;</em> in this case, <kbd>application/json</kbd><em>.</em> It also provides information about encoding, caching, and related meta information, such as the <kbd>age</kbd><span> </span>header, which contains the time in seconds that the object has been in the proxy cache.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hypermedia as the Engine of Application State</h1>
                </header>
            
            <article>
                
<p><span>Services usually deliver a state to clients via body content, response codes, and response headers. Above all, <em>hypermedia-driven services (HATEOAS)</em> include the URI of other resources within their responses. </span>The following example describes the concept of HATEOAS<span>:</span></p>
<pre>{<br/>    "links": {<br/>        "self": { "href": "http://example.com/people" },<br/>        "item": [<br/>            { "href": "http://example.com/people/1", "title": "Kendrick <br/>             West" },<br/>            { "href": "http://example.com/people/2", "title": "Anderson <br/>             Rocky" }<br/>        ]<br/>    },<br/>}</pre>
<p>The previous response provides a list of people, together with the URIs that specify detailed information of each person. Therefore, the client knows the right URI of the request to use in order to get the information regarding each resource.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stateless</h1>
                </header>
            
            <article>
                
<p>Being stateless is a crucial characteristic of a REST service. Indeed, HTTP, as a stateless protocol, <span>doesn't keep track of all the information about the connection between the client and the server once the communication ends.  </span></p>
<p>A stateless protocol forces the client to fulfill the request with all the required information each time it needs some information from the server. Let's take one of the previous URIs:</p>
<pre>https://api.nytimes.com/svc/books/v3/lists.json?api-key={your_api_key}&amp;list=hardcover-fiction</pre>
<p>The client has to send the <em>API key</em> with each request to be authenticated by the server. Furthermore, it must store the API key information<span>.</span></p>
<p>Statelessness is very important if we wish to take advantage of REST services. Nowadays, with the rise of highly distributed systems, it is difficult to deal with stateful services <span>because this requires the states to be managed and replicated on different servers</span>. A stateless approach helps delegate state management to the client. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client-server separation</h1>
                </header>
            
            <article>
                
<p>The main aim of REST services is to decouple the server and the client. This is very important because it helps keep unique business logic and data storage for each client application. Applications are usually distributed across a multitude of different clients, including the web, smartphones, smart TVs, and the IoT. A REST approach helps us prevent logic replication across clients. This means that the client does not have any business logic or storage, and the server does not deal with user interfaces or the presentation layer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Layered system</h1>
                </header>
            
            <article>
                
<p>The concept of a layered system is strictly related to the <span>structure of the </span><span>infrastructure of our application. RESTful services allow a loosely coupled approach because the information is transferred over a protocol – in most cases, HTTP – and each server has a single high-level purpose. </span>Proxy servers, web servers, and database servers are usually isolated and they cover a purpose in our feature, <span>if you have one server that provides all the required features, it is often hard to maintain and scale.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Richardson maturity model</h1>
                </header>
            
            <article>
                
<p>The <em>Richardson maturity model</em> is a model that was developed by Leonard Richardson, and its purpose is to measure the maturity of APIs by providing some general criteria. The model has four classification steps, from <strong>Level 0</strong> to <strong>Level 3</strong>. The highest level corresponds to a more compliant service. <span>This model isn't just for theoretical purposes; it also helps us understand some of the recommended methods for web service development. L</span>et's take a look at an overview of these different levels. The following diagram shows the structure of the levels in the Richardson maturity model:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0f85cdef-13d5-45cc-a224-12d1f075e2ae.png" style=""/></div>
<p>A generic service is at <strong>Level 0: The Swamp of Plain Old XML</strong> when it<em> </em>uses a generic protocol superficially (in the case of web services, this is HTTP). An example of this is a heavy SOAP web service. SOAP implementations use only one URI and only one HTTP verb, and they wrap each request message within a massive envelope.</p>
<p class="mce-root"/>
<p>As we mentioned previously, thinking in terms of resources is the best way to understand and design an API. Therefore, a generic service that's at <strong>Level 1</strong> uses multiple URIs associated with different resources. For example, if we think about an API of a general store, we could obtain the complete list of product categories by calling this sample URI:</p>
<pre>GET https://api.mystore.com/v1/categories </pre>
<p>At the same time, we can get the details of a single category by calling the following URI:</p>
<pre>GET https://api.mystore.com/v1/categories/{category_id}</pre>
<p>On the other hand, we can get a list of products related to a single category by calling the following URI:</p>
<pre>GET https://api.mystore.com/v1/categories/{category_id}/products</pre>
<p>As you can see, we can obtain different information by calling different URIs. There is no envelop, and all the requested information is contained in the URI. </p>
<p>Level 2, which is related to HTTP verbs, introduces the use of HTTP verbs to enhance the information that's transferred on request. Let's take the previous request URI as an example:</p>
<pre>https://api.mystore.com/v1/categories/{category_id}/products</pre>
<p>This can produce different results, depending on the HTTP verb. The following table shows the meanings of various HTTP verbs:</p>
<table border="1" style="border-collapse: collapse">
<tbody>
<tr>
<td>
<div class="CDPAlignCenter CDPAlign"><strong>HTTP verbs</strong></div>
</td>
<td>
<div class="CDPAlignCenter CDPAlign"><strong>Performed operations</strong></div>
</td>
<td>
<div class="CDPAlignCenter CDPAlign"><strong>Example</strong></div>
</td>
</tr>
<tr>
<td>
<div class="CDPAlignCenter CDPAlign"><kbd>GET</kbd></div>
</td>
<td>
<div class="CDPAlignCenter CDPAlign">Retrieves information about a resource</div>
</td>
<td>
<pre class="CDPAlignCenter CDPAlign CDPAlignLeft">GET /v1/categories/ HTTP/1.1<br/>Host: api.mystore.com<br/>Content-Type: application/json</pre></td>
</tr>
<tr>
<td>
<div class="CDPAlignCenter CDPAlign"><kbd>POST</kbd></div>
</td>
<td>
<div class="CDPAlignCenter CDPAlign">Creates a new item related to the resource</div>
</td>
<td>
<pre class="CDPAlignCenter CDPAlign CDPAlignLeft">POST /v1/categories/ HTTP/1.1<br/>Host: api.mystore.com<br/>Content-Type: application/json<br/><br/>{<br/> "categoryId": 1,<br/> "categoryDescription": "Vegetables"<br/>}</pre></td>
</tr>
<tr>
<td>
<div class="CDPAlignCenter CDPAlign"><kbd>PUT</kbd></div>
</td>
<td>
<div class="CDPAlignCenter CDPAlign">Replaces an item related to the resource</div>
</td>
<td>
<pre class="CDPAlignLeft CDPAlign">PUT /v1/categories/1 HTTP/1.1<br/>Host: api.mystore.com<br/>Content-Type: application/json<br/><br/>{<br/>  "categoryId": 1,<br/>  "categoryDescription": "Fruits and Vegetables"<br/>}</pre></td>
</tr>
<tr>
<td>
<div class="CDPAlignCenter CDPAlign"><kbd>PATCH</kbd></div>
</td>
<td>
<div class="CDPAlignCenter CDPAlign">Updates <span>an item related to the resource</span></div>
</td>
<td>
<pre class="CDPAlignLeft CDPAlign">PUT /v1/categories/1 HTTP/1.1<br/>Host: api.mystore.com<br/>Content-Type: application/json<br/><br/>{<br/>  "categoryDescription": "Fruits and Vegetables"<br/>}</pre></td>
</tr>
<tr>
<td>
<div class="CDPAlignCenter CDPAlign"><kbd>DELETE</kbd></div>
</td>
<td>
<div class="CDPAlignCenter CDPAlign">Deletes an item related to the resource</div>
</td>
<td>
<pre class="CDPAlignLeft CDPAlign">DELETE /v1/categories/1 HTTP/1.1<br/>Host: api.mystore.com<br/>Content-Type: application/json</pre></td>
</tr>
</tbody>
</table>
<p> </p>
<p>Different HTTP verbs correspond to various data operations. As opposed to a <strong>Level 0</strong> service, which doesn't use any specifications of HTTP to deliver information, a <strong>Level 2</strong> service takes advantage of HTTP specifications to deliver as much information as possible. Finally, a system with<strong> </strong>a <strong>Level 3</strong> service implements the concept of HATEOAS. As we discussed in the previous section, a HATEOAS provides the resource's URI inside its response. A clear advantage of this approach is that the client doesn't need any information on its side to navigate through the web service's resources. Most importantly, if our web service adds the resource's URI, the client immediately has all the information they need.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing ASP.NET Core</h1>
                </header>
            
            <article>
                
<p class="p1">At the time of writing this book, .NET Core 3.1 is the <strong>LTS</strong> (short for <strong>Long Term Support</strong>) version of the framework powered by Microsoft and the community. ASP.NET Core is the highly modular web framework that runs over the .NET Core platform: it can be used to develop a wide range of web solutions, such as web applications, web assembly client applications and <span>web API </span>projects.</p>
<p>To learn about some of the basic concepts of ASP.NET Core, we need to understand the <strong>Model View Controller</strong> (<strong>MVC</strong>) pattern that is implemented in ASP.NET Core. </p>
<p>MVC separates our web application by grouping implementations into three different areas. <span>In a web environment, the starting point is usually a web request that's made by a client or a generic user. The request passes through a middleware pipeline, and the controller then handles it. The controllers also perform some logic operations and populate our <em>model</em>.</span></p>
<p><span>The m</span><span>odel is the representation of the state of the application. When it is associated with a view, it is called a </span><strong>view model</strong><span>. Once the model is populated, the controller returns a specific view, depending on the request. The purpose of the views is to present data through HTML pages.</span></p>
<p>In the case of a web API stack, which is the typical way of building web services in ASP.NET Core, the process is the same except for the view part. Instead of this, the controller serializes the model in the response.</p>
<p>To understand how ASP.NET Core helps developers build web services, let's go through the history of the ASP.NET framework.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The evolution of ASP.NET</h1>
                </header>
            
            <article>
                
<p>The first version of ASP.NET was released in 2002 when Microsoft decided to invest in web development. They released ASP.NET Web Forms, which is a set of UI components that we can use to build web interfaces. The core idea of this approach was to provide a very high-level abstraction tool that can produce a GUI for the web. Providing this level of abstraction was a good idea because developers were not familiar with the web. However, ASP.NET Web Forms came with a lot of downsides. First of all, developers had limited control over HTML, and components had to store information in a <em>v</em><em>iew state, </em>which was transferred and updated between the client and the server. Furthermore, the components were not correctly separated, and developers tended to mix the presentation code with the business logic code.</p>
<p>In order to improve the experience of developing web applications, Microsoft announced the arrival of ASP.NET MVC in 2007. <span>This new development platform ran on the ASP.NET framework and used concepts from other development platforms that implemented MVC patterns, such as Ruby on Rails. The ASP.NET MVC framework still </span><span>had</span><span> </span><span>some points of weakness. It was built on ASP.NET, which means it had to maintain its retro compatibility with old web forms and web services frameworks such as WCF. Furthermore, it only ran on Windows servers combined with <strong>Internet Information Services</strong> (<strong>IIS</strong>).</span></p>
<p>The latest web framework to be developed by Microsoft is ASP.NET Core. It runs on .NET Core, which is cross-platform and open source. With ASP.NET Core, Microsoft made the choice to release a new lightweight framework that does not have any back-compatibility components derived from previous versions of ASP.NET.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The new .NET ecosystem</h1>
                </header>
            
            <article>
                
<p>Let's look at an overview of the .NET ecosystem to understand the different frameworks that act as the foundations of ASP.NET Core. Some of the information provided here may sound obvious, but it is essential to clarify the differences between different runtimes and frameworks:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7274e7a2-f816-46bc-a757-727e6661ce84.png" style=""/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The first block is related to <strong>Desktop Packs</strong>, which provides the tools for the development of desktop applications starting from <strong>.NET Core 3.0</strong>. We will not use these tools in this book since they are strictly related to desktop development.</p>
<p>The second block is related to the cross-platform part of .NET Core. This set of tools allows developers to build applications on the <strong>WEB</strong>, <strong>DATA</strong>, and <strong>AI/ML</strong> domain. The <strong>WEB</strong> section refers to ASP.NET Core, which is a collection of libraries <span>that comes with</span> .NET Core. Usually, ASP.NET Core is combined with the <strong>DATA</strong> access part. Later in this book, we will see how we can use <strong>EF Core</strong> to access the database layer. Finally, the <strong>AI/ML</strong> section, which will not be discussed in this book, provides useful tools in the machine learning domain. At the bottom of the preceding diagram, we have a common layer, that is, <strong>.NET STANDARD</strong>. It allows developers to build third-party libraries that can be used by the <strong>Desktop Packs</strong> and by the <strong>WEB</strong>, <strong>DATA</strong>, and <strong>AI/ML</strong> parts.</p>
<p>In conclusion, the new .NET ecosystem can be used by any developer, including cloud developers, web developers, and desktop developers. As we mentioned previously, it also runs anywhere and on any platform. In this book, all of our examples will be based on .NET Core.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">.NET STANDARD</h1>
                </header>
            
            <article>
                
<p><strong>.NET STANDARD</strong> was introduced along with .NET Core. The aim of the <strong>.NET STANDARD</strong> is to provide a common API surface for .NET Core and .NET Framework. It works as a unique <strong>Base Class Library</strong> (<strong>BCL</strong>) for our applications in both .NET Framework and .NET Core. <span>The release of .NET Standard 2.0 has introduced </span><span>32,000 compatible APIs</span><span> and supports the following framework versions:</span></p>
<ul>
<li><span>.</span><span>NET Framework 4.6.1 +</span></li>
<li><span>.NET Core 2.0 +</span></li>
<li><span>Mono 5.4 +</span></li>
</ul>
<p>Recently, Microsoft introduced .NET Standard 2.1. This new version provides new APIs that were introduced as part<span> of the open-source development of .NET Core 3.0.  .NET Standard 2.1 will be the common point between the new versions of .NET Core, starting from the 3.0 version, and the other versions of the upcoming frameworks, such as Mono.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>You may wish to choose the .NET Standard for different reasons:</p>
<ul>
<li>To build third-party libraries that are compatible with both .NET Core and .NET Framework. In that case, your package will target .NET Standard 2.0. Eventually, if you want to use the newly optimized APIs that we described previously, it is possible to use multi-targeting to target both .NET Standard 2.0 and .NET Standard 2.1.</li>
<li>To migrate your .NET Framework codebase gradually by isolating logic on .NET Standard projects.</li>
</ul>
<p>For example, consider a class library project which is used by different versions of .NET. The library may run on either .NET Core or .NET Framework. To avoid maintainability pitfalls, the library package can be compiled for multiple versions of .NET Standard and it can be used by both a<em> .NET Core</em> and a <em>.NET Framework</em> solution<em>.</em> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why use ASP.NET Core to build RESTful web services?</h1>
                </header>
            
            <article>
                
<p>There is a massive choice of web frameworks that allow developers to build REST web services. One such framework is ASP.NET Core on .NET Core 3.1.  .NET Core 3.1 provides a new, lightweight, cross-platform and opensource way to build web applications. Most importantly, it is designed to be cloud-ready: the framework is no longer part of the server, unlike in .NET Framework; instead, it is shipped with the application.</p>
<p class="mce-root">Another key point is that .NET Core maintains a <em>high level of modularity</em>, which adheres to the Unix philosophy and allows you to use only what you need in tailored applications. ASP.NET Core also introduces two new hosting solutions for web applications and web services:</p>
<ul>
<li><strong>Kestrel</strong>: T<span>he default HTTP server for ASP.NET Core. It supports HTTPS and web sockets, and it runs on Windows, Linux, and macOS. <em>Kestrel</em> is usually combined with a <em>reverse-proxy, </em>such as NGINX, IIS, or Apache.</span></li>
<li><strong>HTTP.sys</strong>: A<span> Windows-only HTTP server that can be used as an alternative to Kestrel on Windows.</span></li>
</ul>
<p class="mce-root"/>
<p>ASP.NET Core and .NET Core are developed by Microsoft and the community, and they are <em>open source projects</em>. In the case of ASP.NET Core, open source isn't just a buzzword; all the features are community-driven, and the ASP.NET team <span>streams a community standup video on YouTube every week, in which they discuss roadmaps, deadlines, and issues.</span> All the .NET Core code is available on GitHub at the following links:</p>
<ul>
<li><strong><span>.NET Core</span></strong>: The repository of .NET Core (<a href="https://github.com/dotnet/core">https://github.com/dotnet/core</a>)</li>
<li><strong><span>ASP.NET Core</span></strong>: Contains all the references to ASP.NET Core projects (<a href="https://github.com/aspnet/AspNetCore">https://github.com/aspnet/AspNetCore</a>)</li>
</ul>
<p>All the repositories usually come with a roadmap and some contributing guidelines. It is possible to open issues and contribute to the code base. Microsoft has also founded the .NET foundation, <span>an independent organization that fosters open development and collaboration around the .NET ecosystem.</span></p>
<p>The ASP.NET Core team is also focused on the<span> performance of the framework. All the benchmark results are available on GitHub: </span><a href="https://github.com/aspnet/benchmarks">https://github.com/aspnet/benchmarks</a><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing your development environment</h1>
                </header>
            
            <article>
                
<p>In this section, we will show you how to set up your development environment so that you can develop web services using ASP.NET Core. As we mentioned previously, .NET Core is cross-platform, so it can run on the most common OSes. We will also look at how to interact with the .NET Core CLI, which is the starting point for building, running, developing, and testing our services. </p>
<p>First of all, let's start by downloading .NET Core 3.1 from <a href="https://www.microsoft.com/net/download/">https://www.microsoft.com/net/download/</a>. In our case, we'll install the SDK version, which contains all the components that are required for our development environment, including ASP.NET Core.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">.NET Core CLI</h1>
                </header>
            
            <article>
                
<p>Unlike the .NET framework, .NET Core provides an easy to use CLI that exposes all the necessary functionalities we can use to build applications and services. Once .NET Core is installed on your machine, run the <kbd>dotnet --help</kbd> command. You will see the following result:</p>
<pre>.NET Core SDK (3.1.100)<br/>Usage: dotnet [runtime-options] [path-to-application] [arguments]<br/><br/>Execute a .NET Core application.<br/><br/>runtime-options:<br/>  --additionalprobingpath &lt;path&gt; Path containing probing policy and<br/>    assemblies to probe for.<br/>  --additional-deps &lt;path&gt; Path to additional deps.json file.<br/>  --fx-version &lt;version&gt; Version of the installed Shared Framework to <br/>    use to run the application.<br/>  --roll-forward &lt;setting&gt; Roll forward to framework version (LatestPatch, <br/>    Minor, LatestMinor, Major, LatestMajor, Disable).<br/><br/>path-to-application:<br/>  The path to an application .dll file to execute.<br/><br/>Usage: dotnet [sdk-options] [command] [command-options] [arguments]<br/><br/>Execute a .NET Core SDK command.<br/><br/>sdk-options:<br/>  -d|--diagnostics Enable diagnostic output.<br/>  -h|--help Show command line help.<br/>  --info Display .NET Core information.<br/>  --list-runtimes Display the installed runtimes.<br/>  --list-sdks Display the installed SDKs.<br/>  --version Display .NET Core SDK version in use.<br/><br/>SDK commands:<br/>  add Add a package or reference to a .NET project.<br/>  build Build a .NET project.<br/>  build-server Interact with servers started by a build.<br/>  clean Clean build outputs of a .NET project.<br/>  help Show command line help.<br/>  list List project references of a .NET project.<br/>  migrate Migrate a project.json project to an MSBuild project.<br/>  msbuild Run Microsoft Build Engine (MSBuild) commands.<br/>  new Create a new .NET project or file.<br/>  nuget Provides additional NuGet commands.<br/>  pack Create a NuGet package.<br/>  publish Publish a .NET project for deployment.<br/>  remove Remove a package or reference from a .NET project.<br/>  restore Restore dependencies specified in a .NET project.<br/>  run Build and run a .NET project output.<br/>  sln Modify Visual Studio solution files.<br/>  store Store the specified assemblies in the runtime package store.<br/>  test Run unit tests using the test runner specified in a .NET project.<br/>  tool Install or manage tools that extend the .NET experience.<br/>  vstest Run Microsoft Test Engine (VSTest) commands.<br/><br/>Additional commands from bundled tools:<br/>  dev-certs Create and manage development certificates.<br/>  fsi Start F# Interactive / execute F# scripts.<br/>  sql-cache SQL Server cache command-line tools.<br/>  user-secrets Manage development user secrets.<br/>  watch Start a file watcher that runs a command when files change.<br/><br/>Run 'dotnet [command] --help' for more information on a command.</pre>
<p class="p1">The first thing to notice is the version of .NET Core, which is the version of .NET Core, that is, <kbd><span class="s1">.NET Core SDK (3.1.100)</span></kbd><span class="s1">, followed by a list of <strong>Software Development Kit</strong> (<strong>SDK</strong>) commands. This contains the commands that are commonly executed during the development stage, such as <kbd>dotnet build</kbd>, <kbd>dotnet restore</kbd>, and <kbd>dotnet run</kbd>. These are used to build our projects, restore the NuGet dependencies, and run our project, respectively. A</span>nother relevant section is a<em>dditional tools,</em> which contain all the third-party CLI packages we will require, such as EF Core. In fact, the .NET Core CLI allows you to extend its functionality by adding specific tools in the form of NuGet packages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IDEs and development tools in ASP.NET Core</h1>
                </header>
            
            <article>
                
<p>.NET Core CLI is a base <span>upon which higher-level tools such as IDEs, code editors, and <strong>continuous integration</strong> (<strong>CI</strong>) tools can be placed. Even though .NET Core is a cross-platform framework, there are various tools that can be used to build web applications and services on different platforms. The following table provides a recap of the different IDEs and editors that can be used to build ASP.NET Core:</span></p>
<table border="1" style="border-collapse: collapse;width: 90%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 51%"><strong>Softwares</strong></td>
<td style="width: 13%">
<div class="CDPAlignCenter CDPAlign"><strong>Windows</strong></div>
</td>
<td style="width: 14%">
<div class="CDPAlignCenter CDPAlign"><strong>Linux</strong></div>
</td>
<td style="width: 12.5479%">
<div class="CDPAlignCenter CDPAlign"><strong>macOS X</strong></div>
</td>
</tr>
<tr>
<td style="width: 51%">
<div class="CDPAlignCenter CDPAlign">Visual Studio 2019 (Community, Pro, and Enterprise)</div>
</td>
<td style="width: 13%">
<div class="CDPAlignCenter CDPAlign">Supported</div>
</td>
<td style="width: 14%">
<div class="CDPAlignCenter CDPAlign">-</div>
</td>
<td style="width: 12.5479%">
<div class="CDPAlignCenter CDPAlign">-</div>
</td>
</tr>
<tr>
<td style="width: 51%">
<div class="CDPAlignCenter CDPAlign">Visual Studio Code and OmniSharp</div>
</td>
<td style="width: 13%">
<div class="CDPAlignCenter CDPAlign"><span>Supported</span></div>
</td>
<td style="width: 14%">
<div class="CDPAlignCenter CDPAlign"><span>Supported</span></div>
</td>
<td style="width: 12.5479%">
<div class="CDPAlignCenter CDPAlign"><span>Supported</span></div>
</td>
</tr>
<tr>
<td style="width: 51%">
<div class="CDPAlignCenter CDPAlign">Rider </div>
</td>
<td style="width: 13%">
<div class="CDPAlignCenter CDPAlign">Supported </div>
</td>
<td style="width: 14%">
<div class="CDPAlignCenter CDPAlign"><span>Supported</span></div>
</td>
<td style="width: 12.5479%">
<div class="CDPAlignCenter CDPAlign"><span>Supported</span></div>
</td>
</tr>
<tr>
<td style="width: 51%">
<div class="CDPAlignCenter CDPAlign">Visual Studio for Mac </div>
</td>
<td style="width: 13%">
<div class="CDPAlignCenter CDPAlign"><span>-</span></div>
</td>
<td style="width: 14%">
<div class="CDPAlignCenter CDPAlign"><span>-</span></div>
</td>
<td style="width: 12.5479%">
<div class="CDPAlignCenter CDPAlign"><span>Supported</span></div>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>As you can see, it is possible to use different IDEs and code editors for different platforms. The choice you make usually depends on different factors. Let's look at an overview of the different editors:</p>
<ul>
<li><strong>Visual Studio 2019 (Community, Pro, and Enterprise)</strong>: An editor that is well-known to anyone who has already developed on the .NET ecosystem. The community version of this product is totally free, and you can find it at <a href="https://visualstudio.microsoft.com/it/downloads/">https://visualstudio.microsoft.com/it/downloads/</a>.<em> </em>Visual Studio 2019 is the most comfortable choice if you wish to start building on Windows.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<ul>
<li><strong>Visual Studio Code and OmniSharp</strong>: A popular and open source editor powered by Microsoft and the community. It is cross-platform and built on Electron. OmniSharp is a useful third-party package for Visual Studio Code and other code editors that provides some integration with .NET Core projects. It also provides an IntelliSense feature.</li>
<li><strong>Rider</strong>: A brand new IDE powered by JetBrains and based on the IntelliJ platform and ReSharper. It is compatible with every platform, but it is not free. I've tried it in large projects, and it works well, primarily to provide the ReSharper integration out of the box.</li>
<li><strong>Visual Studio for Mac</strong>: A new IDE powered by Microsoft. It is only compatible with macOS and provides a few functionalities we can use to write C# or F# code in the .NET Core ecosystem. This IDE is still at an early stage, but it has a lot of advanced features.</li>
</ul>
<p>In conclusion, tools such as Visual Studio 2019, Rider, and Visual Studio for Mac provide a great experience when combined with .NET Core. On the other hand, Visual Studio Code is the lightest and fastest editor. In the upcoming chapters and code demonstrations, I will use the .NET Core CLI to reproduce the same steps in different operating systems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have taken an overview of the REST style by considering some concrete some concrete examples. We also learned about some of the basic concepts of the .NET ecosystem, including how it is structured and why ASP.NET Core is an excellent choice if we wish to build web services. We also looked at an overview of the .NET Core CLI and the IDEs and code editors related to the .NET ecosystem.</p>
<p>The topics we covered in this chapter provide a good understanding of what REST means and why is important to follow this kind of principle when we develop a web service. Furthermore, we also looked at the fundamentals for setting up .NET Core in our local environment.</p>
<p>The next chapter will focus on ASP.NET Core and ASP.NET Core MVC. You'll learn how to set up a project using the .NET CLI and explore some of the fundamentals concepts of ASP.NET Core.  </p>


            </article>

            
        </section>
    </body></html>