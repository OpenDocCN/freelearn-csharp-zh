- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Building Interactive Forms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建交互式表单
- en: In this chapter, we will focus on the essential skills needed to construct interactive
    forms in Blazor. Forms are a critical component of many web applications, and
    Blazor provides tools that significantly simplify form creation and handling.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注构建 Blazor 中交互式表单所需的基本技能。表单是许多网络应用程序的关键组件，Blazor 提供了简化表单创建和处理的工具。
- en: We will start by learning how to bind simple and nested models to a form for
    capturing and managing user input. Next, we will explore the built-in input components
    provided by Blazor. These components help standardize form behavior across different
    platforms, ensuring consistency and reducing the amount of custom code needed.
    We will also cover techniques for interpreting keystrokes and making the form
    intuitive. At the end of the chapter, we will address the security aspect of form
    handling and the role of the **anti-forgery** token. Implementing these security
    measures is crucial for protecting your applications from common web threats such
    as **Cross-Site Request Forgery** ( **CSRF** ) attacks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习如何将简单和嵌套模型绑定到表单以捕获和管理用户输入。接下来，我们将探索 Blazor 提供的内置输入组件。这些组件有助于在不同平台上标准化表单行为，确保一致性并减少所需的自定义代码量。我们还将介绍解释按键和使表单直观的技术。在本章结束时，我们将讨论表单处理的安全性方面以及**反伪造**令牌的作用。实施这些安全措施对于保护你的应用程序免受常见的网络威胁，如**跨站请求伪造**（**CSRF**）攻击至关重要。
- en: By the end of this chapter, you will have the practical knowledge to create,
    manage, and secure forms in Blazor applications – all vital for developing reliable,
    interactive, and user-friendly web applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将具备在 Blazor 应用程序中创建、管理和保护表单的实用知识——这对于开发可靠、交互式和用户友好的网络应用程序至关重要。
- en: 'Here’s the list of recipes we’ll cover in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章我们将涵盖的菜谱列表：
- en: Binding a simple model to a form
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将简单模型绑定到表单
- en: Submitting static forms without full page reload
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交静态表单而无需完整页面刷新
- en: Binding nested models to a form
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将嵌套模型绑定到表单
- en: Utilizing built-in input components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用内置输入组件
- en: Handling file uploads with a form
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表单处理文件上传
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will keep the examples simple and focus on showcasing all the angles of
    setting up forms in Blazor. At the beginning of each recipe, you will find instructions
    on where to find required samples and which directories to create. With that said,
    you will need these basic tools for Blazor development:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持示例简单，专注于展示在 Blazor 中设置表单的所有角度。在每个菜谱的开头，你将找到有关查找所需样本和创建哪些目录的说明。也就是说，你需要以下基本工具进行
    Blazor 开发：
- en: A modern IDE (that supports Blazor development)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持 Blazor 开发的现代 IDE
- en: A modern web browser (that supports WebAssembly)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持 WebAssembly 的现代网络浏览器
- en: Browser DevTools (that could be a part of the modern browser already)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器 DevTools（可能是现代浏览器的一部分）
- en: A Blazor project (where you’ll write your code)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Blazor 项目（你将在其中编写代码）
- en: In the *Handling file uploads with a form* recipe, we’ll utilize a NuGet package
    – **Microsoft.AspNetCore.Http.Features** – that’s not pre-installed by default,
    so you might as well add it to your project now.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *使用表单处理文件上传* 菜谱中，我们将使用一个 NuGet 包 – **Microsoft.AspNetCore.Http.Features**
    – 该包默认未安装，因此你现在可以将其添加到你的项目中。
- en: 'You can find all the code samples on GitHub at : [https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter06](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter06)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到所有代码示例：[https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter06](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter06)
- en: Binding a simple model to a form
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将简单模型绑定到表单
- en: In the development of modern web applications, forms are ubiquitous and essential.
    Whether registering user details, collecting feedback, or entering information,
    forms serve as the primary interface for user input. Blazor supports a traditional
    HTML **<form>** markup but elevates the experience with its native **EditForm**
    component. **EditForm** integrates seamlessly with Blazor’s data binding capabilities
    and provides a streamlined, efficient approach to form management.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代网络应用程序的开发中，表单无处不在且至关重要。无论是注册用户详细信息、收集反馈还是输入信息，表单都是用户输入的主要界面。Blazor 支持传统的
    HTML **<form>** 标记，但通过其本地的 **EditForm** 组件提升了用户体验。**EditForm** 与 Blazor 的数据绑定功能无缝集成，并提供了一种简化和高效的表单管理方法。
- en: Let’s add the first small form that binds to a simple data model and allows
    the user to create a new event by providing its name.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加第一个小型表单，该表单绑定到简单的数据模型，并允许用户通过提供其名称来创建新事件。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we start creating a form and bind it to a simple model, do the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建表单并将其绑定到简单模型之前，请执行以下操作：
- en: Create a **Chapter06** / **Recipe01** directory – this will be your working
    directory
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **Chapter06** / **Recipe01** 目录 – 这将是你的工作目录
- en: Copy the **Models.cs** file from the **Chapter06** / **Data** directory in the
    GitHub repository
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 GitHub 仓库中的 **Chapter06** / **Data** 目录复制 **Models.cs** 文件
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To implement a form supporting a simple data model, follow these steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现支持简单数据模型的表单，请按照以下步骤操作：
- en: 'Create a routable **EventManager** component:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个可路由的 **EventManager** 组件：
- en: '[PRE0]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Within the **@code** block of **EventManager** , declare a **Model** object
    and decorate it with a **SupplyParameterFromForm** attribute:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **EventManager** 的 **@code** 块中，声明一个 **Model** 对象，并用 **SupplyParameterFromForm**
    属性进行装饰：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Still inside the **@code** block, override the **OnInitialized()** lifecycle
    method with conditional initialization of the **Model** parameter if it’s unset.
    Additionally, implement a **Save()** method as a placeholder to simulate saving
    the form:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 **@code** 块中，如果未设置，则使用条件初始化重写 **OnInitialized()** 生命周期方法。此外，实现一个 **Save()**
    方法作为占位符来模拟保存表单：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the markup of **EventManager** , embed an **EditForm** component and bind
    it to the **Model** parameter. Include an input field for entering **Model.Name**
    and a submit button that triggers the **Save()** method:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **EventManager** 的标记中嵌入一个 **EditForm** 组件，并将其绑定到 **Model** 参数。包括一个用于输入 **Model.Name**
    的输入字段和一个触发 **Save()** 方法的提交按钮：
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we create a routable **EventManager** component, which will serve
    as the container for our form.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们创建一个可路由的 **EventManager** 组件，它将作为我们表单的容器。
- en: In *step 2* , within the **@code** block of **EventManager** , we declare a
    **Model** parameter for our form with a form-specific attribute – **SupplyParameterFromForm**
    – enabling Blazor to automatically populate the **Model** object with values from
    the associated form. In *step 3* , we finalize the **@code** block of **EventManager**
    . We override the **OnInitialized()** lifecycle method to seamlessly initialize
    the **Model** parameter to an empty object unless it already carries a value.
    Additionally, we introduce a **Save()** method, acting as a placeholder to mimic
    the saving of changes made to the form.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 2* 中，在 **EventManager** 的 **@code** 块中，我们为我们的表单声明一个 **Model** 参数，并使用一个特定于表单的属性
    – **SupplyParameterFromForm** – 使 Blazor 能够自动将关联表单的值填充到 **Model** 对象中。在 *步骤 3*
    中，我们最终确定 **EventManager** 的 **@code** 块。我们重写 **OnInitialized()** 生命周期方法，以便无缝地将
    **Model** 参数初始化为空对象，除非它已经包含值。此外，我们引入一个 **Save()** 方法，作为占位符来模拟保存对表单所做的更改。
- en: In *step 4* , we tackle the implementation of the **EventManager** markup, leveraging
    Blazor’s built-in **EditForm** component. We assign our **Model** object to the
    **Model** parameter of the **EditForm** component and the **Save()** method to
    the **OnSubmit** callback, automating the invocation of **Save()** upon form submission.
    Crucially, we set a unique value for the **FormName** parameter of **EditForm**
    , allowing Blazor to properly resolve the form data. Within the form, we incorporate
    a simple input box, binding it to the **Model.Name** property, and include a submit
    button to facilitate form submission.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 4* 中，我们处理 **EventManager** 标记的实现，利用 Blazor 内置的 **EditForm** 组件。我们将我们的
    **Model** 对象分配给 **EditForm** 组件的 **Model** 参数，并将 **Save()** 方法分配给 **OnSubmit**
    回调，以便在表单提交时自动调用 **Save()**。关键的是，我们为 **EditForm** 的 **FormName** 参数设置一个唯一值，允许 Blazor
    正确解析表单数据。在表单中，我们包含一个简单的输入框，将其绑定到 **Model.Name** 属性，并包含一个提交按钮以方便表单提交。
- en: We opted not to declare any render mode intentionally, resulting in static server-side
    rendering of our page. While this approach ensures quick rendering and minimal
    resource utilization on the server, submitting the form requires a full page reload
    – similar to **MVC** or **Razor** **pages** applications.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有意不声明任何渲染模式，导致我们的页面在服务器端进行静态渲染。虽然这种方法确保了快速渲染和服务器上资源利用的最小化，但提交表单需要完整的页面刷新 –
    类似于 **MVC** 或 **Razor** **pages** 应用程序。
- en: There’s more
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: Each parameter of the **EditForm** component has a corresponding Blazor attribute,
    compatible with standard HTML, which means you can customize the behavior of your
    forms extensively without relying on the **EditForm** component. You can retain
    the standard HTML **<form>** markup and customize it to your needs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**EditForm**组件的每个参数都有一个对应的Blazor属性，与标准HTML兼容，这意味着您可以在不依赖于**EditForm**组件的情况下广泛自定义表单的行为。您可以保留标准的HTML
    **<form>**标记，并根据需要对其进行自定义。'
- en: 'To give you a practical example, here’s how you can implement our form using
    the HTML **<** **form>** markup:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给您一个实际示例，以下是您可以使用HTML **<form>**标记实现我们的表单的方法：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We construct a simple form, leveraging the default HTML **form** element. We
    declare the form’s unique name, the method to call on submit, and that Blazor
    should execute a **post** action when submitting the data. However, as we no longer
    leverage the **EditForm** component, Blazor will force us to provide an anti-forgery
    token for security reasons. For that, we leverage a built-in **AntiforgeryToken**
    component, but we will explore that component in detail in the *Securing a form
    with an anti-forgery token* recipe, at the end of the chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个简单的表单，利用默认的HTML **form**元素。我们声明了表单的唯一名称，提交时调用的方法，以及Blazor在提交数据时应执行**post**操作。然而，由于我们不再使用**EditForm**组件，Blazor将强制我们提供防伪造令牌以进行安全原因。为此，我们利用内置的**AntiforgeryToken**组件，但我们将详细探讨该组件，在章节末尾的*使用防伪造令牌保护表单*配方中。
- en: Submitting static forms without full page reload
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无需完整页面刷新提交静态表单
- en: Blazor, leveraging the diffing algorithm (we talked about it in the *Hooking
    into event delegates* recipe in [*Chapter 3*](B22020_03.xhtml#_idTextAnchor095)
    ), offers an **enhanced navigation** feature, which optimizes user interactions
    by reducing unnecessary re-renderings and updating only the parts of the UI that
    have changed rather than reloading entire pages. Interactive render modes have
    the diffing algorithm enabled by default, but forms rendered in **static server-side
    render** ( **SSR** ) mode do not. In this recipe, we will explore how to enable
    the enhanced navigation on the **EditForm** component using the **Enhanced** parameter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor利用差异算法（我们在[*第3章*](B22020_03.xhtml#_idTextAnchor095)中的*挂钩到事件委托*配方中讨论过），提供了一个**增强导航**功能，通过减少不必要的重新渲染，仅更新UI中已更改的部分而不是重新加载整个页面来优化用户交互。交互式渲染模式默认启用差异算法，但以**静态服务器端渲染**（**SSR**）模式渲染的表单则不启用。在本配方中，我们将探讨如何使用**Enhance**参数在**EditForm**组件上启用增强导航。
- en: Let’s enable enhanced navigation on the **Event** creation form and prevent
    the form from reloading the entire page upon submission while maintaining its
    operation in SSR mode.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启用**Event**创建表单的增强导航，并在保持其SSR模式操作的同时，防止表单在提交时重新加载整个页面。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we explore form enhancing, do the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索表单增强之前，请执行以下操作：
- en: Create a **Chapter06** / **Recipe02** directory – this will be your working
    directory
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建**Chapter06** / **Recipe02**目录——这将成为您的工作目录
- en: Copy the **EventManager** component from the *Binding a simple model to a form*
    recipe or from the **Chapter06** / **Recipe01** directory of the GitHub repository
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*将简单模型绑定到表单*配方或从GitHub仓库中的**Chapter06** / **Recipe01**目录复制**EventManager**组件
- en: Copy the **Models.cs** file from the **Chapter06** / **Data** directory in the
    GitHub repository
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub仓库中的**Chapter06** / **Data**目录复制**Models.cs**文件
- en: How to do it…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To enable enhanced navigation on your form, navigate to the **EventManager**
    component and set the **Enhance** parameter value of the **EditForm** component:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在您的表单上启用增强导航，请导航到**EventManager**组件，并设置**EditForm**组件的**Enhance**参数值：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we navigate to the **EventManager** component and set the value
    of the **Enhance** parameter on the **EditForm** component. Since **Enhance**
    is of type **bool** , merely stating the parameter name is equivalent to declaring
    **Enhance="true"** . This simple adjustment is all it takes to enable the enhanced
    navigation on your form. If you’ve been developing MVC applications, you can conceptualize
    the enhancement using **Html.BeginForm** when the form is not enhanced and **Ajax.BeginForm**
    with the **Enhance** attribute in place.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们导航到**EventManager**组件，并在**EditForm**组件上设置**Enhance**参数的值。由于**Enhance**是**bool**类型，仅声明参数名称就相当于声明**Enhance="true"**。这个简单的调整就足以在您的表单上启用增强导航。如果您一直在开发MVC应用程序，您可以在表单未增强时使用**Html.BeginForm**，并在**Enhance**属性就位时使用**Ajax.BeginForm**来概念化增强。
- en: Although the **EventManager** component continues to render statically on the
    server, with enhanced navigation activated, Blazor now monitors UI changes more
    effectively. Full-page reload is no longer required when a user submits the form,
    which results in a smoother and more responsive user experience while still leveraging
    the benefits of the SSR.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管**EventManager**组件在服务器上继续以静态方式渲染，但激活了增强导航后，Blazor现在更有效地监控UI变化。当用户提交表单时不再需要完整页面刷新，这导致用户体验更加流畅和响应，同时仍然利用了SSR的好处。
- en: There’s more…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The **Enhance** parameter, similar to other parameters of the **EditForm** component,
    has an equivalent attribute compatible with plain HTML forms – **data-enhance**
    .
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与**EditForm**组件的其他参数类似，**Enhance**参数有一个与纯HTML表单兼容的等效属性——**data-enhance**。
- en: 'Here’s how you can attach **data-enhance** to your **<** **form>** tag:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何将**data-enhance**附加到你的**<form>**标签上的方法：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We leverage the default HTML **form** element and declare the form’s unique
    name, the method to call on submit, and that Blazor should execute a **post**
    action when submitting the data. Next to those already familiar attributes, we
    attach the **data-enhance** attribute. The order of attributes has no impact on
    the form’s functionality.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用默认的HTML **form**元素并声明表单的唯一名称、提交时调用的方法以及Blazor在提交数据时应执行**post**操作。在那些已经熟悉的属性旁边，我们附加了**data-enhance**属性。属性的顺序不会影响表单的功能。
- en: Binding nested models to a form
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将嵌套模型绑定到表单
- en: In this recipe, we’ll explore the management of **nested models** within forms
    in Blazor. Nested models are complex data structures where a model contains other
    models as properties. They’re common when we capture detailed or structured information,
    such as a user profile with multiple addresses or an order with multiple items.
    However, managing forms with complex and nested data models can get out of hand
    as the depth of the data structure grows. Keeping track of each input field and
    ensuring proper binding can be challenging, making the form less maintainable
    and more prone to errors. The **Editor<T>** component simplifies the handling
    of complex object scenarios as it encapsulates the binding of each field to its
    corresponding property, giving you a narrowed view of the current form context.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将探索Blazor中表单内嵌套模型的管理。嵌套模型是包含其他模型作为属性的复杂数据结构。当我们捕获详细或结构化信息时，它们很常见，例如具有多个地址的用户资料或具有多个项目的订单。然而，随着数据结构深度的增加，管理具有复杂和嵌套数据模型的表单可能会变得难以控制。跟踪每个输入字段并确保适当的绑定可能具有挑战性，这使得表单难以维护且更容易出错。**Editor<T>**组件通过封装每个字段与其对应属性的绑定，简化了复杂对象场景的处理，为你提供了一个当前表单上下文的窄化视图。
- en: Let’s enhance our event creation form with a nested object, allowing us to add
    information about the event’s duration.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过嵌套对象增强我们的活动创建表单，以便我们可以添加有关活动持续时间的详细信息。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we start the implementation of a nested form, do the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现嵌套表单之前，请执行以下操作：
- en: Create a **Chapter06** / **Recipe03** directory – this will be your working
    directory
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建**Chapter06** / **Recipe03**目录——这将是你的工作目录
- en: Copy the **EventManager** component from the *Submitting static forms without
    full page reload* recipe or from the **Chapter06** / **Recipe02** directory of
    the GitHub repository
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*Submitting static forms without full page reload*食谱或从GitHub仓库的**Chapter06**
    / **Recipe02**目录复制**EventManager**组件
- en: Copy the **Models.cs** file from the **Chapter06** / **Data** directory in the
    GitHub repository
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub仓库中的**Chapter06** / **Data**目录复制**Models.cs**文件
- en: How to do it…
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement a maintainable nested form:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现可维护的嵌套表单：
- en: 'Create an **EventDurationForm** component inheriting from **Editor<EventPeriod>**
    :'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个继承自**Editor<EventPeriod>**的**EventDurationForm**组件：
- en: '[PRE7]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the markup of the **EventDurationForm** component, utilize the **InputDate**
    component and add two fields for setting the **Start** and **End** properties
    of the base **EventPeriod** model:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**EventDurationForm**组件的标记中，使用**InputDate**组件并添加两个字段来设置基础**EventPeriod**模型的**Start**和**End**属性：
- en: '[PRE8]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the **EventManager** component, navigate to the **@code** block and extend
    the **Save()** method to log **Model.Period** details to the console:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**EventManager**组件中，导航到**@code**块并扩展**Save()**方法以将**Model.Period**的详细信息记录到控制台：
- en: '[PRE9]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the **EventManager** markup, integrate an instance of the **EventDurationForm**
    component within **EditForm** , between the existing label and the **submit**
    button, and bind it to the **Model.Period** nested property:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**EventManager**标记中，将**EventDurationForm**组件的实例集成到**EditForm**中，在现有的标签和**submit**按钮之间，并将其绑定到**Model.Period**嵌套属性：
- en: '[PRE10]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we create the **EventDurationForm** component, dedicated to handling
    the period settings of an event. To properly reference the necessary model, we
    include a **@using** directive for the assembly of the **EventPeriod** model and
    use the **@inherits** directive to derive from the generic **Editor<T>** component,
    setting **T** as our **EventPeriod** model. Next, in *step 2* , we add the markup
    of the **EventDurationForm** component. As the **Editor<T>** component implements
    the **@bind-Value** pattern, we can directly interact with the underlying model
    through the local **Value** property. We embed two date input fields using the
    **InputDate** component, binding them to the **Value.Start** and **Value.End**
    properties. For now, we will skip the built-in form components in Blazor as we
    explore them in a subsequent recipe.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 1**中，我们创建了**EventDurationForm**组件，专门用于处理事件的期间设置。为了正确引用必要的模型，我们包括一个**@using**指令用于**EventPeriod**模型的程序集，并使用**@inherits**指令从泛型**Editor<T>**组件派生，将**T**设置为我们的**EventPeriod**模型。接下来，在**步骤
    2**中，我们添加了**EventDurationForm**组件的标记。由于**Editor<T>**组件实现了**@bind-Value**模式，我们可以通过本地的**Value**属性直接与底层模型交互。我们使用**InputDate**组件嵌入两个日期输入字段，并将它们绑定到**Value.Start**和**Value.End**属性。目前，我们将跳过Blazor中的内置表单组件，因为我们将在后续食谱中探索它们。
- en: In *step 3* , we shift our focus to the **EventManager** component. In the **@code**
    block, we extend the **Save()** placeholder method to log **Model.Period** details
    to the console. It will allow us to validate the binding of our nested model.
    Finally, in *step 4* , we jump to the markup of the **EventManager** component
    and integrate the **EventDurationForm** component into the existing **EditForm**
    markup, right before the submit button. By utilizing the bind-Value pattern, we
    bind the **Model.Period** object directly to **EventDurationForm** .
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 3**中，我们将注意力转向**EventManager**组件。在**@code**块中，我们扩展了**Save()**占位符方法，将**Model.Period**的详细信息记录到控制台。这将使我们能够验证嵌套模型的绑定。最后，在**步骤
    4**中，我们转向**EventManager**组件的标记，并将**EventDurationForm**组件集成到现有的**EditForm**标记中，就在提交按钮之前。通过使用bind-Value模式，我们直接将**Model.Period**对象绑定到**EventDurationForm**。
- en: We’ve effectively encapsulated the markup and logic of managing the event period
    without complexifying the main **EditForm** instance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有效地封装了管理事件期间的标记和逻辑，而没有使主要的**EditForm**实例复杂化。
- en: There’s more…
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Throughout all the recipes exploring the **EditForm** capabilities, we have
    consistently utilized static server rendering. It’s a strategic choice, allowing
    you to highlight any potential edge cases and particularities of the SSR mode
    and providing a comprehensive understanding of how forms behave under different
    rendering conditions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索**EditForm**功能的所有食谱中，我们一直使用静态服务器渲染。这是一个战略选择，允许你突出显示任何潜在边缘情况和SSR模式的特殊性，并提供对表单在不同渲染条件下行为的全面理解。
- en: However, if you choose to employ any of the interactive rendering modes available
    in Blazor, forms will continue to function correctly. By adding the **@renderMode**
    directive to your components, you can easily switch between rendering modes depending
    on the needs of your application. Whether you need server-side rendering for its
    robustness and security or client-side rendering for its interactivity and speed
    — **EditForm** will operate smoothly and efficiently.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你选择使用Blazor中可用的任何交互式渲染模式，表单将继续正常工作。通过向你的组件添加**@renderMode**指令，你可以根据应用程序的需求轻松地在渲染模式之间切换。无论你需要服务器端渲染的健壮性和安全性，还是客户端渲染的交互性和速度，**EditForm**都将平稳高效地运行。
- en: Utilizing built-in input components
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用内置输入组件
- en: In this recipe, we’ll explore how quickly you can set up both simple and complex
    forms using Blazor’s native form support and built-in input components. The benefit
    of using Blazor lies in its ability to handle much of the heavy lifting involved
    in form creation, such as data binding, event handling, maintaining state, or
    parsing user input to expected values. You’re then free to focus on other aspects
    of the user interface.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将探讨如何快速设置简单和复杂表单，使用Blazor的本地表单支持和内置输入组件。使用Blazor的好处在于它能够处理在表单创建中涉及的大量繁重工作，如数据绑定、事件处理、维护状态或解析用户输入到预期值。然后你可以自由地关注用户界面的其他方面。
- en: Let’s showcase Blazor’s built-in input components by creating a comprehensive
    form where the system administrator provides a detailed definition of the events
    they are planning.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个全面的表单来展示Blazor的内置输入组件，在这个表单中，系统管理员可以详细定义他们计划举办的活动。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we build the event creator, do the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建事件创建器之前，执行以下操作：
- en: Create a **Chapter06** / **Recipe04** directory – this will be your working
    directory
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Chapter06** / **Recipe04**目录 – 这将是你的工作目录
- en: Copy the **EventManager** and **EventDurationForm** components from the *Binding
    nested models to a form* recipe or copy their implementation from the **Chapter06**
    / **Recipe03** directory of the GitHub repository
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*绑定嵌套模型到表单*食谱或从GitHub仓库的**Chapter06** / **Recipe03**目录复制**EventManager**和**EventDurationForm**组件，或复制它们的实现：
- en: Copy the **Models.cs** file from the **Chapter06** / **Data** directory in the
    GitHub repository
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub仓库中的**Chapter06** / **Data**目录复制**Models.cs**文件
- en: How to do it…
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the event creator with built-in input components:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现具有内置输入组件的事件创建器：
- en: 'Open the **EventManager** component and, in the **@code** block, update the
    **Save()** method:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**EventManager**组件，并在**@code**块中更新**Save()**方法：
- en: '[PRE11]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Navigate to the markup section of the **EventManager** component and locate
    the **EditForm** markup. All subsequent steps will take place within this form.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**EventManager**组件的标记部分，找到**EditForm**标记。所有后续步骤都将在这个表单内进行。
- en: 'Wrap the existing **InputText** instance, **EventDurationForm** instance, and
    the save button in separate paragraph **<** **p>** tags:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的**InputText**实例、**EventDurationForm**实例和保存按钮分别包裹在单独的段落**<** **p>**标签中：
- en: '[PRE12]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In a new paragraph, below the **EventDurationForm** paragraph, add an **InputCheckbox**
    component and bind it to the **Model.IsActive** property:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的段落中，位于**EventDurationForm**段落下方，添加一个**InputCheckbox**组件并将其绑定到**Model.IsActive**属性：
- en: '[PRE13]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add another paragraph – this time with an **InputNumber** component – and bind
    it to the **Model.Capacity** property:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个段落 – 这次使用**InputNumber**组件 – 并将其绑定到**Model.Capacity**属性：
- en: '[PRE14]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create another paragraph and embed the **InputSelect** component within it,
    binding it to the **Model.Type** property. Render the select options using values
    from the **EventType** enum:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个段落，并在其中嵌入**InputSelect**组件，将其绑定到**Model.Type**属性。使用**EventType**枚举的值来渲染选择选项：
- en: '[PRE15]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In another paragraph, incorporate an **InputRadioGroup** component and bind
    it to the **Model.Location** property. Use **EventVenues.All** values and an **InputRadio**
    component to render each radio option:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个段落中，包含一个**InputRadioGroup**组件，并将其绑定到**Model.Location**属性。使用**EventVenues.All**值和一个**InputRadio**组件来渲染每个单选选项：
- en: '[PRE16]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In a separate paragraph, place an **InputTextArea** component and bind it to
    the **Model.Description** property:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个单独的段落中，放置一个**InputTextArea**组件并将其绑定到**Model.Description**属性：
- en: '[PRE17]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we enhance the **EventManager** component. In *step 1* , we
    navigate to the **@code** block and update the **Save()** method, where, leveraging
    the **Model.Json** auto-property, we convert the entire **Model** object to JSON
    and write out the result to the console, so we can peek at the state of the saved
    **Model** instance.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们增强了**EventManager**组件。在*步骤1*中，我们导航到**@code**块并更新**Save()**方法，在这里，利用**Model.Json**自动属性，我们将整个**Model**对象转换为JSON，并将其结果写入控制台，以便我们可以查看已保存的**Model**实例的状态。
- en: In *step 2* , we shift to the **EditForm** markup available in the markup of
    the **EventManager** component. In *step 3* , we wrap the existing fields into
    organized paragraphs with **<p>** tags. We use the **InputText** component to
    render a text input element bound to the **Model.Name** property, allowing a user
    to set the name of an event. Next, with the **EventDurationForm** component, we
    encapsulate the setting of the event period, utilizing **InputDate** components
    for date entries. **InputDate** supports a variety of time formats and includes
    a built-in calendar picker – out of the box. We conclude the structurization of
    the form by wrapping the submit button in another set of **<** **p>** tags.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 2**中，我们将注意力转向**EventManager**组件标记中的**EditForm**标记。在**步骤 3**中，我们使用**<p>**标签将现有的字段组织成有结构的段落。我们使用**InputText**组件来渲染一个与**Model.Name**属性绑定的文本输入元素，使用户能够设置事件的名称。接下来，使用**EventDurationForm**组件，我们封装了事件期间的设置，利用**InputDate**组件进行日期输入。**InputDate**支持多种时间格式，并包含一个内置的日历选择器——即插即用。我们通过将提交按钮包裹在另一组**<p>**标签中，完成了表单的结构化。
- en: In *step 4* , we introduce an **InputCheckbox** component in a new paragraph,
    binding it to the **Model.IsActive** property. **InputCheckbox** renders a checkbox
    input type that’s perfect for handling **bool** properties, so we allow the user
    to toggle the active status of the event.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 4**中，我们在新段落中引入了一个**InputCheckbox**组件，并将其绑定到**Model.IsActive**属性。**InputCheckbox**渲染一个复选框输入类型，非常适合处理**bool**属性，因此我们允许用户切换事件的活动状态。
- en: In *step 5* , we add an **InputNumber** component in another paragraph, linking
    it to the **Model.Capacity** property. **InputNumber** accepts any primitive numeric
    type, which makes it ideal for setting the maximum number of event participants.
    In *step 6* , we embed an **InputSelect** component within another paragraph and
    bind it to the **Model.Type** property to facilitate selecting the event type.
    **InputSelect** is a generic component, so you can easily cover a variety of objects
    within. However, remember that the **select** option **value** must be of a primitive
    type. In our form, we populate the drop-down menu by iterating over the **EventType**
    enum from the sample **Data** directory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 5**中，我们在另一个段落中添加了一个**InputNumber**组件，并将其链接到**Model.Capacity**属性。**InputNumber**接受任何原始数值类型，这使得它非常适合设置事件参与者的最大数量。在**步骤
    6**中，我们在另一个段落中嵌入了一个**InputSelect**组件，并将其绑定到**Model.Type**属性，以方便选择事件类型。**InputSelect**是一个泛型组件，因此您可以轻松地覆盖多种对象。然而，请记住，**select**选项的**value**必须是原始类型。在我们的表单中，我们通过遍历样本**Data**目录中的**EventType**枚举来填充下拉菜单。
- en: In *step 7* , we allow the user to choose the event venue. We render an **InputRadioGroup**
    component and bind it to the **Model.Location** property. We also render multiple
    **InputRadio** components, each representing a venue from the **EventVenues.All**
    sample collection. Blazor automatically scopes all **InputRadio** components to
    the nearest parent element but wrapping them inside **InputRadioGroup** exposes
    additional functionalities of the checkbox group and gives us more control.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 7**中，我们允许用户选择事件地点。我们渲染了一个**InputRadioGroup**组件，并将其绑定到**Model.Location**属性。我们还渲染了多个**InputRadio**组件，每个组件代表**EventVenues.All**样本集合中的一个地点。Blazor自动将所有**InputRadio**组件的范围限定在最近的父元素，但将它们包裹在**InputRadioGroup**内可以暴露出复选框组的额外功能，并给我们更多的控制权。
- en: In *step 8* , we add an **InputTextArea** component within the final paragraph,
    providing a text area for the **Model.Description** property. **InputTextArea**
    generates an input of type **textarea** – ideal for longer descriptions, although
    it’s not a rich text editor.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 8**中，我们在最后一段中添加了一个**InputTextArea**组件，为**Model.Description**属性提供了一个文本区域。**InputTextArea**生成一个类型为**textarea**的输入——非常适合较长的描述，尽管它不是一个富文本编辑器。
- en: 'The form we’ve just built appears simple, but it renders fully functional,
    secured, and organized markup with little coding effort:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚构建的表单看起来很简单，但它通过很少的编码工作就渲染了完全功能、安全和有组织的标记：
- en: '![Figure 6.1: Functional, secure, and structured form using only built-in input
    components](img/B22020_06_1.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1：仅使用内置输入组件构建的功能性、安全性和结构化表单](img/B22020_06_1.jpg)'
- en: 'Figure 6.1: Functional, secure, and structured form using only built-in input
    components'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：仅使用内置输入组件构建的功能性、安全性和结构化表单
- en: Handling file uploads with a form
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表单处理文件上传
- en: In this recipe, we dive into managing file uploads in Blazor applications. File
    uploading is crucial for any modern web application that requires users to upload
    documents or images. The **InputFile** component simplifies the integration of
    file uploads with its simple but comprehensive API. Moreover, with a little additional
    coding, you can enable **drag-and-drop** behavior for file uploads.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们深入探讨在 Blazor 应用程序中管理文件上传。对于任何需要用户上传文档或图像的现代网络应用程序来说，文件上传至关重要。**InputFile**
    组件通过其简单但全面的 API 简化了文件上传的集成。此外，通过一些额外的编码，您可以启用文件上传的 **拖放** 行为。
- en: Let’s add a simple form that allows users to upload a file representing an event
    cover.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个简单的表单，允许用户上传代表活动封面的文件。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we implement the form with file uploads, do the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现带有文件上传的表单之前，执行以下操作：
- en: Create a **Chapter06** / **Recipe05** directory – this will be your working
    directory
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **Chapter06** / **Recipe05** 目录——这将是你的工作目录
- en: Copy **FileStorage** from the **Chapter06** / **Data** directory in the GitHub
    repository
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '从 GitHub 仓库中的 **Chapter06** / **Data** 目录复制 **FileStorage** '
- en: How to do it…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to enable file uploads in an interactive form:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在交互式表单中启用文件上传：
- en: 'Open your application’s **Program** file and add the **FileStorage** service
    to the dependency injection container:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的应用程序的 **Program** 文件，并将 **FileStorage** 服务添加到依赖注入容器中：
- en: '[PRE18]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create an **EventCover** class with a single **File** property of type **IBrowserFile**
    :'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个具有单个 **File** 属性的 **EventCover** 类，该属性的类型为 **IBrowserFile** :'
- en: '[PRE19]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a new routable **CoverUploader** component that renders in the **InteractiveWebAssembly**
    mode:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的可路由的 **CoverUploader** 组件，以 **InteractiveWebAssembly** 模式渲染：
- en: '[PRE20]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the **@code** block of **CoverUploader** , inject the **FileStorage** service
    and initialize a **Model** variable of type **EventCover** :'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **CoverUploader** 的 **@code** 块中，注入 **FileStorage** 服务并初始化一个类型为 **EventCover**
    的 **Model** 变量：
- en: '[PRE21]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Still within the **@code** block, implement a **FileChanged()** method that
    takes the **InputFileChangeEventArgs** parameter and assigns the file data to
    **Model.File** :'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '仍然在 **@code** 块中，实现一个 **FileChanged()** 方法，该方法接受 **InputFileChangeEventArgs**
    参数并将文件数据分配给 **Model.File** :'
- en: '[PRE22]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Lastly, in the **@code** block, implement a **SaveAsync()** method that initializes
    a file upload from the **Model** instance, using the **FileStorage** service:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 **@code** 块中，实现一个 **SaveAsync()** 方法，该方法从 **Model** 实例初始化文件上传，使用 **FileStorage**
    服务：
- en: '[PRE23]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the **CoverUploader** markup, add an **EditForm** component, bind it to
    the **Model** instance, and attach the **SaveAsync()** method to the **OnSubmit**
    form callback:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **CoverUploader** 标记中，添加一个 **EditForm** 组件，将其绑定到 **Model** 实例，并将 **SaveAsync()**
    方法附加到 **OnSubmit** 表单回调中：
- en: '[PRE24]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Inside the **EditForm** markup, add an **InputFile** component that invokes
    the **FileChanged()** method with its **OnChange** event and a simple submit button.
    Wrap both elements in paragraphs:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **EditForm** 标记内部，添加一个调用 **FileChanged()** 方法的 **InputFile** 组件，该组件使用其 **OnChange**
    事件，并添加一个简单的提交按钮。将这两个元素包裹在段落中：
- en: '[PRE25]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we navigate to the application’s **Program** file and register
    the **FileStorage** service into the dependency injection container. **FileStorage**
    is a fake service that pretends to upload a file to the storage of your choice.
    In *step 2* , we create an **EventCover** class with a single **File** property
    of type **IBrowserFile** . The **IBrowserFile** interface represents a file received
    from the user, encapsulating properties such as the file’s name, content type,
    size, and methods to access the file’s content.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们导航到应用程序的 **Program** 文件，并将 **FileStorage** 服务注册到依赖注入容器中。**FileStorage**
    是一个假服务，它假装将文件上传到您选择的存储。在 *步骤 2* 中，我们创建了一个具有单个 **File** 属性的 **EventCover** 类，该属性的类型为
    **IBrowserFile** 。**IBrowserFile** 接口表示从用户接收到的文件，封装了文件名、内容类型、大小等属性以及访问文件内容的各种方法。
- en: In *step 3* , we create a routable **CoverUploader** component and set it to
    render in **InteractiveWebAssembly** mode to enable interactivity on our form.
    In *step 4* , within the **@code** block of the **CoverUploader** component, we
    inject the **FileStorage** service to utilize its API for managing incoming files.
    We then initialize a **Model** object of type **EventCover** , which forms the
    backbone of our form. In *step 5* , within the same **@code** block, we implement
    a **FileChanged()** method that handles **InputFileChangeEventArgs** . The **InputFileChangeEventArgs**
    object contains an **IBrowserFile** payload, which we assign to the **File** property
    of our **Model** instance, capturing the user-selected file. In *step 6* , we
    add a **SaveAsync()** method where we read the **File** value into a stream and
    use the **FileStorage.UploadAsync()** method to upload the file bytes to our selected
    storage. We leverage the **using** keyword to ensure efficient resource management
    and no memory leaks. The **using** keyword, inside a method, works together with
    an **IDisposable** object and creates a temporary, disposable scope that automatically
    disposes of the attached object when the method execution completes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们创建了一个可路由的**CoverUploader**组件，并将其设置为以**InteractiveWebAssembly**模式渲染，以在我们的表单上启用交互性。在*步骤4*中，在**CoverUploader**组件的**@code**块内，我们注入了**FileStorage**服务，以利用其API来管理传入的文件。然后我们初始化一个类型为**EventCover**的**Model**对象，这构成了我们表单的骨干。在*步骤5*中，在同一个**@code**块内，我们实现了一个处理**InputFileChangeEventArgs**的**FileChanged()**方法。**InputFileChangeEventArgs**对象包含一个**IBrowserFile**有效负载，我们将其分配给我们的**Model**实例的**File**属性，捕获用户选择的文件。在*步骤6*中，我们添加了一个**SaveAsync()**方法，其中我们将**File**值读入一个流，并使用**FileStorage.UploadAsync()**方法将文件字节上传到我们选择的存储。我们利用**using**关键字来确保有效的资源管理和没有内存泄漏。在方法内部，**using**关键字与一个**IDisposable**对象一起工作，创建一个临时、可丢弃的作用域，当方法执行完成后自动丢弃所附加的对象。
- en: In *step 7* , we set up the markup for **CoverUploader** using the **EditForm**
    component. We give the form a unique name, bind it to our **Model** instance,
    and assign the **SaveAsync()** method as the submission fallback. Finally, in
    *step 8* , we build the body of the **EditForm** component. We incorporate the
    **InputFile** component and attach the **FileChanged()** method to its **OnChange**
    callback. The **OnChange** event seamlessly integrates with the **FileChanged()**
    logic in our **@code** block, handling the file selection initiated by the user.
    We also add a simple submit button that activates the form’s **OnSubmit** callback.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7*中，我们使用**EditForm**组件设置了**CoverUploader**的标记。我们给表单赋予一个唯一的名称，将其绑定到我们的**Model**实例，并将**SaveAsync()**方法作为提交的回退。最后，在*步骤8*中，我们构建了**EditForm**组件的主体。我们包含了**InputFile**组件，并将其**OnChange**回调绑定到**FileChanged()**方法。**OnChange**事件与我们的**@code**块中的**FileChanged()**逻辑无缝集成，处理用户发起的文件选择。我们还添加了一个简单的提交按钮，该按钮激活表单的**OnSubmit**回调。
- en: 'At the end, your form should look similar to mine:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您的表单应该看起来像我的一样：
- en: '![Figure 6.2: Form containing the InputFile component and a submit button](img/B22020_06_2.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：包含InputFile组件和提交按钮的表单](img/B22020_06_2.jpg)'
- en: 'Figure 6.2: Form containing the InputFile component and a submit button'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：包含InputFile组件和提交按钮的表单
- en: What about the drag-and-drop feature? Actually, the **InputFile** component
    inherently supports drag-and-drop functionality! Even though it looks like a button,
    **InputFile** renders an **input** area that has the drag-and-drop feature already
    enabled – you don’t need to add any additional code or any additional attributes.
    You may want to add additional styling to make **InputFile** look like a drop
    zone, but the functionality is available out of the box.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 关于拖放功能呢？实际上，**InputFile**组件本身支持拖放功能！尽管它看起来像一个按钮，但**InputFile**渲染了一个已经启用了拖放功能的**input**区域——您不需要添加任何额外的代码或任何额外的属性。您可能想要添加一些额外的样式，使**InputFile**看起来像一个拖放区域，但功能是现成的。
- en: Lastly, we didn’t implement any file type or size validation for the uploading
    (we will explore validation in [*Chapter 7*](B22020_07.xhtml#_idTextAnchor236)
    ). For the enterprise-ready application, you must consider putting such boundaries
    in place to protect your infrastructure as well as server resources.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们没有为上传实现任何文件类型或大小的验证（我们将在[*第7章*](B22020_07.xhtml#_idTextAnchor236)中探讨验证）。对于企业级应用程序，您必须考虑设置此类边界，以保护您的基础设施以及服务器资源。
- en: There’s more…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: What if you want to support file uploads and leverage the newest SSR render
    mode? In the SSR mode, Blazor pre-renders components on the server and serves
    only a static markup without any interactivity, so you can’t intercept the file
    the user tries to upload. However, if we consider enabling enhanced navigation
    and leveraging the **enctype** attribute, uploading files will work even in the
    SSR mode. The **enctype** HTML attribute specifies how the browser should encode
    the form data when submitting it to the server.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想支持文件上传并利用最新的SSR渲染模式呢？在SSR模式下，Blazor在服务器端预渲染组件，并仅提供静态标记而不具备任何交互性，因此你无法拦截用户尝试上传的文件。然而，如果我们考虑启用增强导航并利用**enctype**属性，即使在SSR模式下，上传文件也能正常工作。**enctype**HTML属性指定浏览器在提交表单到服务器时应如何编码表单数据。
- en: 'Let’s modify our existing interactive form to render in the SSR mode and still
    allow users to upload a file:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改现有的交互式表单，使其在SSR模式下渲染，同时允许用户上传文件：
- en: 'Update the **EventCover** class by changing the **File** property type from
    **IBrowserFile** to **IFormFile** . That’s part of the **Microsoft.AspNetCore.Http.Features**
    package, so you may need to add it to your project beforehand:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将**File**属性类型从**IBrowserFile**更改为**IFormFile**来更新**EventCover**类。这是**Microsoft.AspNetCore.Http.Features**包的一部分，因此你可能需要事先将其添加到你的项目中：
- en: '[PRE26]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, adjust the **CoverUploader** component to render in SSR mode by removing
    the **@** **renderMode** directive.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，调整**CoverUploader**组件以在SSR模式下渲染，通过删除**@** **renderMode**指令。
- en: 'In the **@code** block of the **CoverUploader** component, transform **Model**
    into a property and decorate it with **SupplyParameterFromForm** to enable automatic
    binding of the form data:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**CoverUploader**组件的**@code**块中，将**Model**转换为属性，并用**SupplyParameterFromForm**进行装饰以启用表单数据的自动绑定：
- en: '[PRE27]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Still within the **@code** block, override the **OnInitialized()** lifecycle
    method to adhere to the SSR form binding pattern and remove the **FileChanged()**
    method, as we won’t need it anymore:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**@code**块中，覆盖**OnInitialized()**生命周期方法以遵循SSR表单绑定模式，并移除**FileChanged()**方法，因为我们不再需要它了：
- en: '[PRE28]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Within the **CoverUploader** markup, enhance the **EditForm** component by
    adding the **Enhance** attribute, which activates enhanced navigation, and include
    the **enctype** attribute with the value **multipart/form-data** :'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**CoverUploader**标记内，通过添加**Enhance**属性来增强**EditForm**组件，该属性激活了增强导航，并包含具有值**multipart/form-data**的**enctype**属性：
- en: '[PRE29]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Lastly, replace the assignment of the **OnChange** callback on the **InputFile**
    component with the **name** HTML attribute and set its value to match the **Model.File**
    property so Blazor knows how to bind the selected file directly from the form:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将**InputFile**组件上的**OnChange**回调赋值替换为**name**HTML属性，并将其值设置为与**Model.File**属性匹配，这样Blazor就能直接从表单绑定选定的文件：
- en: '[PRE30]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Securing a form with an anti-forgery token
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反伪造令牌保护表单
- en: In this recipe, we explore an essential aspect of web security — protecting
    your application from CSRF attacks. CSRF attacks exploit the trust between our
    app and a user’s browser, making the browser perform unwanted actions using the
    user’s identity. An **anti-forgery token** , also known as a CSRF token, is a
    crucial security measure you must use to ensure that the requests sent to a server
    are genuine and originated from a legitimate user, not an attacker. Embedding
    an anti-forgery token in your forms practically creates a unique key sent with
    each post request. The server checks this token upon receiving a request; if the
    token is not present or is incorrect, the request is rejected, thus preventing
    unauthorized actions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们探讨了Web安全的一个基本方面——保护你的应用程序免受CSRF攻击。CSRF攻击利用了我们的应用程序与用户浏览器之间的信任，使得浏览器使用用户的身份执行不希望的操作。**反伪造令牌**，也称为CSRF令牌，是一项重要的安全措施，你必须使用它来确保发送到服务器的请求是真实的，并且来自合法用户，而不是攻击者。在表单中嵌入反伪造令牌实际上创建了一个与每个POST请求一起发送的唯一密钥。服务器在收到请求时检查此令牌；如果令牌不存在或是不正确的，请求将被拒绝，从而防止未经授权的操作。
- en: Let’s secure our event creation form with the anti-forgery token implementation
    offered in Blazor.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Blazor提供的反伪造令牌实现来保护我们的事件创建表单。
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we explore securing a form with the anti-forgery token, do the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索使用反伪造令牌保护表单之前，请执行以下操作：
- en: Create a **Chapter06** / **Recipe06** directory – this will be your working
    directory
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Chapter06** / **Recipe06**目录 – 这将是你的工作目录
- en: Copy the **Models.cs** file from the **Chapter06** / **Data** directory in the
    GitHub repository
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub仓库中的**Chapter06** / **Data**目录复制**Models.cs**文件
- en: How to do it…
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these instructions to secure your form with the anti-forgery token:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明使用防伪造令牌保护您的表单：
- en: 'On the server side of your solution, navigate to the **Program** file and,
    in the middleware configuration area, register the anti-forgery middleware:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您解决方案的服务器端，导航到**程序**文件，并在中间件配置区域注册防伪造中间件：
- en: '[PRE31]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a routable **EventManager** component:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个可路由的**EventManager**组件：
- en: '[PRE32]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Inside the **@code** block of the **EventManager** component, declare a **Model**
    object of type **Event** and decorate it with the **SupplyParameterFromForm**
    attribute:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**EventManager**组件的**@code**块内部，声明一个类型为**Event**的**Model**对象，并用**SupplyParameterFromForm**属性进行装饰：
- en: '[PRE33]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Still within the **@code** block of **EventManager** , override the **OnInitialized()**
    lifecycle method to conditionally initialize the **Model** instance if it is not
    already set and implement a **Save()** method to simulate the process of saving
    the form data:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**EventManager**的**@code**块中，重写**OnInitialized()**生命周期方法，以有条件地初始化尚未设置的**Model**实例，并实现一个**Save()**方法来模拟保存表单数据的过程：
- en: '[PRE34]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the markup section of the **EventManager** component, construct a standard
    HTML form with a unique name that triggers the **Save()** method when submitted:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**EventManager**组件的标记部分，构建一个具有唯一名称的标准HTML表单，在提交时触发**Save()**方法：
- en: '[PRE35]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Within the **<form>** area, include a text input field linked to the **Model.Name**
    property and a submit button. Most crucially, embed an **AntiforgeryToken** component
    within the form:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**<form>**区域中，包括一个与**Model.Name**属性链接的文本输入字段和一个提交按钮。最重要的是，在表单中嵌入**AntiforgeryToken**组件：
- en: '[PRE36]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works…
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we navigate to the **Program** file of the server-side project
    to enable anti-forgery security. We leverage the **app.UseAntiforgery()** extension
    method within the middleware area. The order of middleware registration is crucial;
    you must position the anti-forgery middleware thoughtfully based on other middleware
    in use. If your application includes authentication and authorization, ensure
    **app.UseAntiforgery()** is placed after **app.UseAuthentication()** and **app.UseAuthorization()**
    . If you have routing configured, place anti-forgery middleware after **app.UseRouting()**
    , but before **app.UseEndpoints()** if you register endpoint middleware.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们导航到服务器端项目的**Program**文件以启用防伪造安全。我们在中间件区域使用**app.UseAntiforgery()**扩展方法。中间件注册的顺序至关重要；您必须根据其他正在使用的中间件深思熟虑地定位防伪造中间件。如果您的应用程序包含身份验证和授权，确保**app.UseAntiforgery()**放置在**app.UseAuthentication()**和**app.UseAuthorization()**之后。如果您已配置路由，则在注册端点中间件之前，将防伪造中间件放置在**app.UseRouting()**之后，但在**app.UseEndpoints()**之前。
- en: In *step 2* , we create a routable **EventManager** component and include the
    necessary assembly reference with the **@using** directive to access the **Event**
    type. In *step 3* , within the **@code** block of the **EventManager** component,
    we declare a **Model** property of type **Event** to support our form. We leverage
    the **SupplyParameterFromForm** attribute to enable an automatic data binding
    between the **Model** and form fields. In *step 4* , we override the **OnInitialized()**
    method to conditionally initialize the **Model** instance if it’s still empty.
    We also implement a **Save()** method as a placeholder to simulate saving changes
    to the form. In *step 5* , we move to the markup of the **EventManager** component.
    We construct a standard HTML form, using **<form>** tags, that triggers the **Save()**
    method upon submission. In Blazor, each form must have a unique name, so we use
    the **@formname** attribute and name ours **event-form** . In *step 6* , we implement
    the form body. First, we embed the **AntiforgeryToken** component. Next, we add
    a text input field for the user to provide the event name and bind it to the **Model.Name**
    property. Finally, we include a **Save** button to enable submitting the form.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 2*中，我们创建一个可路由的**EventManager**组件，并使用**@using**指令包含必要的程序集引用以访问**Event**类型。在*步骤
    3*中，在**EventManager**组件的**@code**块内部，我们声明一个类型为**Event**的**Model**属性以支持我们的表单。我们利用**SupplyParameterFromForm**属性来启用**Model**和表单字段之间的自动数据绑定。在*步骤
    4*中，我们重写**OnInitialized()**方法以有条件地初始化如果它仍然是空的**Model**实例。我们还实现了一个**Save()**方法作为模拟保存表单更改的占位符。在*步骤
    5*中，我们转向**EventManager**组件的标记。我们构建一个标准的HTML表单，使用**<form>**标签，在提交时触发**Save()**方法。在Blazor中，每个表单都必须有一个唯一的名称，因此我们使用**@formname**属性并将我们的表单命名为**event-form**。在*步骤
    6*中，我们实现表单主体。首先，我们嵌入**AntiforgeryToken**组件。接下来，我们添加一个文本输入字段供用户输入事件名称，并将其绑定到**Model.Name**属性。最后，我们包括一个**Save**按钮以启用表单提交。
- en: 'With the **AntiforgeryToken** component in place, Blazor generates a hidden
    form field containing the anti-forgery token. We’ve embedded the **AntiforgeryToken**
    instance at the top of the form, but as it’s a hidden field, you can place it
    anywhere, as long as it remains part of the form. The token itself is part of
    the DOM, so you can inspect its value using your browser’s development tools:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了 **AntiforgeryToken** 组件之后，Blazor 会生成一个包含反伪造令牌的隐藏表单字段。我们已经在表单的顶部嵌入了 **AntiforgeryToken**
    实例，但由于它是一个隐藏字段，您可以将其放置在表单的任何位置，只要它仍然是表单的一部分即可。令牌本身是 DOM 的一部分，因此您可以使用浏览器的发展工具检查其值：
- en: '![Figure 6.3: Inspecting the anti-forgery token generated as part of the from
    markup](img/B22020_06_3.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3：检查作为表单标记一部分生成的反伪造令牌](img/B22020_06_3.jpg)'
- en: 'Figure 6.3: Inspecting the anti-forgery token generated as part of the from
    markup'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3：检查作为表单标记一部分生成的反伪造令牌
- en: There’s more…
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'I recommend using the **EditForm** component for all your forms due to its
    native Blazor integration and extensive API. So, why have we not covered adding
    the anti-forgery token to the **EditForm** markup? The reason is straightforward:
    **EditForm** comes with built-in anti-forgery support. Blazor automatically secures
    the **EditForm** instance, saving you the hassle of explicitly handling CSRF protection.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其原生的 Blazor 集成和广泛的 API，我建议您为所有表单使用 **EditForm** 组件。那么，为什么我们没有涵盖将反伪造令牌添加到 **EditForm**
    标记中的内容呢？原因很简单：**EditForm** 内置了反伪造支持。Blazor 会自动保护 **EditForm** 实例，从而让您无需显式处理 CSRF
    保护。
- en: Furthermore, we entirely skipped the implementation of anti-forgery tokens for
    client-side applications. Blazor WebAssembly apps run entirely in the browser
    and do not have a server-side processing pipeline where you would typically configure
    a middleware such as **app.UseAntiforgery()** . If your Blazor WebAssembly app
    interacts with server-side APIs, you should manage anti-forgery at the API level.
    However, if you already use **token-based authentication** to secure communication,
    anti-forgery tokens are generally not necessary. Token-based authentication, by
    its nature, mitigates the risks associated with CSRF, making additional anti-forgery
    tokens redundant. We will explore authentication and authorization further in
    [*Chapter 8*](B22020_08.xhtml#_idTextAnchor273) .
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们完全跳过了客户端应用程序反伪造令牌的实现。Blazor WebAssembly 应用完全在浏览器中运行，没有服务器端处理管道，在那里您通常会配置中间件，例如
    **app.UseAntiforgery()**。如果您的 Blazor WebAssembly 应用与服务器端 API 交互，您应该在 API 层面上管理反伪造。然而，如果您已经使用
    **基于令牌的认证** 来保护通信，反伪造令牌通常是不必要的。基于令牌的认证由于其本质，减轻了与 CSRF 相关的风险，使得额外的反伪造令牌变得多余。我们将在
    [*第 8 章*](B22020_08.xhtml#_idTextAnchor273) 中进一步探讨身份验证和授权。
- en: See also
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'If you’d like to learn more about token-based authentication, you can check
    this resource:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于基于令牌的身份验证的信息，您可以查看以下资源：
- en: '[https://learn.microsoft.com/en-us/xandr/digital-platform-api/token-based-api-authentication](https://learn.microsoft.com/en-us/xandr/digital-platform-api/token-based-api-authentication)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/xandr/digital-platform-api/token-based-api-authentication](https://learn.microsoft.com/en-us/xandr/digital-platform-api/token-based-api-authentication)'
