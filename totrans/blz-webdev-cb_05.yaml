- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Application State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the crucial aspect of maintaining and manipulating
    the state of a Blazor application. An **application state** is the runtime data
    that dictates the behavior and appearance of an application, reflecting user interactions
    and decisions.
  prefs: []
  type: TYPE_NORMAL
- en: We will walk through various strategies for state management, from encoding
    state in the URL for bookmarkable states and easy sharing to implementing in-memory
    state containers for rapid access. You’ll learn how to inject application state
    as a service, allowing centralized state management across different components,
    and how to persist state to ensure data continuity across sessions. Furthermore,
    we will explore techniques to resolve persisted state upon application load, invoking
    state changes from anywhere within an application, and monitoring these changes
    with dedicated listening components. We will pay special attention to sharing
    state across different render mode boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have a solid foundation in state management
    practices that will help you build dynamic, responsive, and stateful Blazor applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the recipes that will take us there:'
  prefs: []
  type: TYPE_NORMAL
- en: Having a bookmarkable state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an in-memory state container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting application state as a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking state changes from anywhere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolving persisted state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing state across interactive render mode boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The barrier of entry to that chapter is not high. You’ll need the following
    tools:'
  prefs: []
  type: TYPE_NORMAL
- en: A modern IDE (that supports Blazor development)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET 9 installed on your development machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modern web browser (one that supports Web Assembly and has DevTools)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bare-bone Blazor project (where you’ll write your code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find all the examples and data samples referenced in the following
    recipes in a dedicated GitHub repository at: [https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter05](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter05)
    . In each recipe that needs any samples, I will also point you to the directory
    where you can find them.'
  prefs: []
  type: TYPE_NORMAL
- en: Having bookmarkable state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will introduce the simplest yet powerful pattern of leveraging
    a URL to maintain and share application state. Unlike more complex state management
    strategies, embedding state flags directly in the URL doesn’t require in-memory
    persistence. A static URL allows users to bookmark a specific application state
    and facilitates the easy sharing of that state with others. We will follow the
    well-known **restful routing** pattern and elegantly map application states to
    readable and shareable URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a component that allows us to bookmark and view an entire event
    list or specific event information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start implementing a component with bookmarkable state, we need to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter05** / **Recipe01** directory – this will be our working directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **Api** and **Event** files from the **Chapter05** / **Data** directory
    in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement stateful URLs in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **Program** file of your application and register the **Api**
    service, as scoped in the application’s dependency injection container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a **Store** component with two navigable routes to facilitate user access
    to different application states through the URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the **@code** block of the **Store** component, inject the **Api** service
    and declare an **EventId** parameter that we will use to fetch specific event
    details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within the **@code** block, initialize the **Collection** and **Event**
    variables that will hold the fetched data, based on the application’s current
    state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the **OnParametersSetAsync()** life cycle method and implement the
    logic to update the component’s state, based on the parameters passed in the URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the markup of the **Store** component, add a section to render **Event**
    details conditionally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another section to the **Store** markup to render the **Collection** elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we navigate to the **Program** of the application and register
    the API service in the application’s dependency injection container, so we can
    inject it later when required.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , we create a routable **Store** component a slightly enhanced routing.
    We declare two routable paths – **/ch05r01/events** for rendering all available
    events and **/ch05r01/events/{eventId:guid}** for specific event details. By leveraging
    path parametrization and path constraints, we specify the **EventId** parameter
    within the curly braces, setting **Guid** as its expected value type.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3* , we initialize the **@code** block, where we declare the **EventId**
    parameter expected by the route. Blazor automatically intercepts and assigns path
    parameter values based on the name matching. We also inject the **Api** service
    from the provided sample data, allowing us to fetch event information seamlessly.
    In *step 4* , we initialize the **Collection** and **Event** variables. These
    are essential in supporting the dual states of the **Store** component – one for
    showcasing a list of available events and another for presenting details of a
    specific, selected event. In *step 5* , we fine-tune the rendering logic by overriding
    the **OnParametersSetAsync()** life cycle method. We determine whether the **EventId**
    was correctly resolved and fetch the details of that specific event, using the
    injected **Api** service. Otherwise, we retrieve the entire collection of available
    events.
  prefs: []
  type: TYPE_NORMAL
- en: From *step 6* , we implement the **Store** markup that supports two distinct
    states. To accommodate this, we include two conditional markup sections. If **Event**
    was fetched, indicating that a specific event’s details are ready for display,
    we render its **Id** and quickly return to skip any further logic. We cover the
    component’s alternative state in *step 7* by iterating over **Collection** . We
    render links to each event’s details, utilizing the **Store** component’s parametrized
    path and providing **item.Id** where the **eventId** parameter goes.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will find parameterized paths most useful in **CRUD** ( **Create, Read,
    Update, Delete** ) scenarios. Assuming we would implement a form within the **Store**
    component designed to attach to an **Event** object, we could ingeniously treat
    a **Guid.Empty** value as a trigger to initiate the creation process and initialize
    a new, empty **Event** model. Conversely, if a valid **Guid** is provided, we
    would fetch the existing **Event** from the API. We’ve effectively covered two
    scenarios with the same form and avoided code duplication.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the type for a value in a path isn’t a strict requirement. By default,
    Blazor will map parameters as strings, giving you the flexibility to parse them
    into the required type at a later stage. However, the real power lies in utilizing
    route constraints effectively. While parsing parameters later provides flexibility,
    I strongly recommend leveraging route constraints wherever possible. In the **Store**
    component example, by specifying a parameter type as **Guid** , if the route does
    not match due to the route constraint, Blazor shows a **NotFound** content – filtering
    out invalid inputs preemptively and enhancing the robustness and security of your
    application. We will explore routing and the **NotFound** content in [*Chapter
    9*](B22020_09.xhtml#_idTextAnchor308) .
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an in-memory state container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Efficiently managing interactions with external APIs is absolutely crucial in
    modern web development. An **in-memory state container** allows you to persist
    specific objects for an application lifetime unless configured otherwise. When
    you receive a comprehensive data object from the API upon the initial call, rather
    than fetching this data anew for every page transition, an in-memory state container
    facilitates the smooth transfer of the entire object throughout the various stages
    and pages of the application. Furthermore, an in-memory state container proves
    invaluable during multi-stage setup processes, allowing the current state of a
    complex setup object to be persistently carried forward without loss or repeated
    external calls.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a container where we will persist event information and display
    it after redirecting a user to an event details page.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into the implementation of an in-memory container, we need to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter05** / **Recipe02** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **Api** and **Event** files from the **Chapter05** / **Data** directory
    in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register the **Api** service as scoped in the application’s dependency injection
    container (you can check the *Having a bookmarkable state* recipe to see how)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implement the in-memory state container with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a generic **StateContainer<T>** class to hold any type of object in
    memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within **StateContainer<T>** , initialize a backing **_container** as a generic
    **Dictionary** where you will persist state objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the **Persist()** and **Resolve()** methods to **StateContainer<T>** that
    either store or retrieve objects from **_container** , using a **Guid** key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the **Program** application root and register the **StateContainer<Event>**
    in the dependency injection container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a static **Config** class and define a customized **PrerenderDisabled**
    render mode, based on **InteractiveWebAssembly** but with disabled pre-rendering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a routable **Store** component that renders in **PrerenderDisabled**
    mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **@code** section of **Store** , inject **StateContainer<Event>** to
    persist **Event** objects, **NavigationManager** to facilitate navigation, and
    **Api** to seed data from an external source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still inside the **@code** block, initialize a backing **Data** collection
    and override the **OnInitializedAsync()** life cycle method to fetch **Data**
    objects from **Api** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, in the **@code** block, implement a **ShowDetails()** method that stores
    a requested **Event** in the in-memory **StateContainer<Event>** and redirects
    to a page displaying the event details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **Store** markup, construct a loop where you render navigation buttons
    to all elements from the **Data** collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an **EventDetails** component with a route matching the one specified
    in the previous step and rendering in **PrerenderDisabled** mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **@code** section of **EventDetails** , inject **StateContainer<Event>**
    and declare an **EventId** parameter to capture an event identifier from the URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within the **@code** block, declare a **Model** variable to maintain
    the current component state and override the **OnParametersSet()** life cycle
    method to resolve **Model** from the injected **Container** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **EventDetails** markup, introduce a nullability check for **Model**
    , and render the current capacity of the underlying event if **Model** is successfully
    resolved:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start the implementation by laying the foundation of in-memory state persistence.
    In *step 1* , we add a generic class, **StateContainer<T>** . In *step 2* , we
    initialize a backing collection within **StateContainer<T>** to persist state
    objects. We opt for **Dictionary<Guid, T>** , as we will exploit its straightforward
    key-value API, but any alternative collection type would also work. In *step 3*
    , we implement the **Persist()** and **Resolve()** methods. The **Persist()**
    method, accepting **key** and **value** , allows us to add objects to our in-memory
    container. Concurrently, the **Resolve()** method allows to retrieve these objects
    using their keys. In *step 4* , we add our in-memory state container to the application’s
    dependency injection container. As we will be working with **Event** objects,
    we register **StateContainer<Event>** . We give it a **Scoped** lifetime to ensure
    that **Event** objects are available throughout the user session.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5* , we introduce a custom render mode – **PrerenderDisabled** . We
    place **PrerenderDisabled** in a new, static **Config** class so that it’s easily
    reusable. Why do we need a custom render mode? When you declare interactivity
    mode per component, Blazor serves pre-rendered content by default and hydrates
    the component state subsequently. In our case, this would raise exceptions, as
    the in-memory state container remains inaccessible during the initial component
    render. Our **PrerenderDisabled** mode, based on **InteractiveWebAssembly** ,
    solves that challenge.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6* , we create a routable **Store** component, referencing the sample
    data assembly, and we leverage **PrerenderDisabled** mode, defined in **Config**
    . In *step 7* , we inject the required services – **StateContainer<Event>** for
    object state persistence, **Navigation** for user-directed navigation, and **Api**
    for fetching events from an external data source. In *step 8* , we initialize
    the **Data** collection within the **Store** component and populate it by invoking
    **Api** in the **OnInitializedAsync()** life cycle method. In *step 9* , we define
    a **ShowDetails()** method that adds the selected **Event** object to the in-memory
    state container and redirects the user to an event details page. In *step 10*
    , we jump to the **Store** markup and render buttons, allowing us to navigate
    to the details of any element from the **Data** collection.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we also need to add the event details page. In *step 11* , we create an
    **EventDetails** component with a route matching the one chosen in *step 9* .
    We also declare its render mode to **PrerenderDisabled** - in line with the **Store**
    component. In *step 12* , we inject the **StateContainer<Event>** and declare
    **EventId** , allowing Blazor to intercept the event identifier directly from
    the page URL. In *step 13* , we declare **Model** for the **EventDetails** component
    and override the **OnParametersSet()** life cycle method, where we resolve the
    **Model** value using the intercepted **EventId** . Note that we leverage our
    **StateContainer<Event>** to fetch the **Model** details and avoid additional
    fetching from external sources. As we wrap up the implementation, in *step 14*
    , we complete the **EventDetails** component with a markup that checks for the
    **Model** state and displays information about the event’s current capacity.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interestingly, the in-memory state container isn’t just for holding onto data.
    It’s also handy when managing multi-step forms or complex configuration processes,
    as you can save and retrieve the progress efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: A critical aspect we’ve deliberately omitted is the mechanism for cleaning up
    the state container. Depending on your application’s requirements, you may need
    to persist state for different durations. By following our implementation above,
    simply registering **StateContainer<T>** as **Scoped** ensures that the state
    lives as long as the user session. However, you might face scenarios where you
    need more control over the life cycle of state objects. Should you need to clear
    the state when the user navigates away from a specific component or completes
    a set of steps, implementing **IDisposable** or utilizing **OwningComponentBase**
    for scoped disposal are more effective strategies.
  prefs: []
  type: TYPE_NORMAL
- en: A word of caution before we end this recipe – you must strategically assess
    the feasibility of in-memory state containers in your scenarios. The complexity
    of the persisted objects and the duration of their persistence might put an unnecessary
    strain on application memory and lead to performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting application state as a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will showcase a design pattern to streamline state management
    across your application by introducing an application state service and leveraging
    dependency injection. This method simplifies how components interact with each
    other, enabling them to seamlessly listen to or communicate changes in the application’s
    state. Leveraging dependency injection, you enhance the responsiveness of your
    application and maintain a clean architecture by avoiding tight coupling between
    components. With an application state service, your application remains agile,
    maintainable, and scalable, adapting to the evolving needs of web development.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement an injectable state service that allows us to post and receive
    success and failure messages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you dive into an injectable state service, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter05** / **Recipe03** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **Config** class with customized **PrerenderDisabled** render mode
    from the *Implementing an in-memory state container* recipe or the **Chapter05**
    / **Recipe03** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow this guide to implement an injectable state service in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a **StateArgs** base record and define the **SuccessArgs** and **FailureArgs**
    state arguments deriving from that base:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Introduce a **StoreState** class with an **event** delegate that can be subscribed
    to and a **Notify()** method that accepts **StateArgs** and triggers the **OnChanged**
    event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the **Program** class and register **StoreState** in the dependency
    injection container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a routable **Store** component that leverages **PrerenderDisabled**
    render mode and implements the **IDisposable** interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **Store** component **@code** block, inject **StoreState** and initialize
    a **Message** variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still in the **@code** block, implement a **ReactAsync()** method to convert
    **StateArgs** into user-friendly messages and apply UI changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **@code** block, override the **OnInitialized()** life cycle method
    to subscribe the **ReactAsync()** method to the **StoreState** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, within the **@code** block, implement the **Dispose()** method as required
    by **IDisposable** and unsubscribe **ReactAsync()** from the **StoreState** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **Store** component’s markup, add two buttons that, upon being clicked,
    call the **Notify()** method with either **SuccessArgs** or **FailureArgs** .
    Include a paragraph to display the current value of the **Message** variable as
    well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we define three object types – **StateArgs** , **SuccessArgs**
    , and **FailureArgs** – to represent states within our application. Leveraging
    inheritance and having **SuccessArgs** and **FailureArgs** inherit from **StateArgs**
    allows us to maintain simplicity in our state-handling logic. In *step 2* , we
    implement the **StoreState** class, which acts as an application state service.
    We expose an event – encapsulating an invocation of an asynchronous method with
    a **StateArgs** parameter and a **Notify()** method – allowing any component to
    communicate state changes. We’ve effectively encapsulated the complexities of
    state transitions behind a simple, intuitive interface. With **StoreState** ready
    to go, in *step 3* , we integrate it into our application’s dependency injection
    container within the **Program** class.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4* , we create a routable **Store** component to demonstrate the practical
    use of our application state service. We opt for custom **PrerenderDisabled**
    render mode to avoid potential rendering pitfalls; you learned about that in the
    *Implementing an in-memory state container* recipe. We also declare **Store**
    to implement the **IDisposable** interface, indicating that there will be a custom
    cleanup logic to execute. In *step 5* , we inject **StoreState** as **State**
    and initialize the **Message** variable, where we will capture user-friendly snapshots
    of the application’s state for display. In *step 6* , we implement a **ReactAsync()**
    method that acts as a dynamic resolver of **StateArgs** . We update the **Message**
    variable based on the **args** type, pivoting between success and failure states.
    Afterward, we invoke **StateHasChanged()** to notify that the UI state has changed,
    but we wrap it inside the **InvokeAsync()** method to ensure that our UI remains
    responsive and thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7* , we enable the **Store** component to listen to state changes broadcasted
    by **StoreState** . We override the **OnInitialized()** method and subscribe our
    **ReactAsync()** to **State.OnChanged** . In *step 8* , we implement the **Dispose()**
    method, enforced by the **IDisposable** interface. Here, we unsubscribe **ReactAsync()**
    from **State.OnChanged** to prevent memory leaks and guarantee graceful component
    disposal.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 9* , we put the **Store** markup in place. We add two buttons – one
    signals success while the other signals failure. Both utilize the **State.Notify()**
    method to orchestrate state changes. Below these buttons, we add paragraph tags
    and render **Message** to visualize the impact of our button’s interactions. To
    keep the example simple, we’re triggering state changes with buttons within the
    same component that listens to those state changes. However, you could place these
    buttons in any component across the application, and our **Store** will still
    accurately receive and react to the state notifications. That’s the true strength
    and agility of having an injectable application state service.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ve touched on the topic of events in .NET. We won’t dive
    deep into the .NET fundamentals in that book, but if you’re curious to learn more,
    check out the official Microsoft Learn resources: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/events/](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/events/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Invoking state changes from anywhere
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we’re exploring injecting state service globally in your Blazor
    application. State service can cover anything from a user’s app personalization
    to user session details or processing indicators. In our example, we’re implementing
    an overlay covering our interface during a long-running task. **Overlay** serves
    as a visual cue to users, signaling that their request is being executed and preventing
    any user interactions that could disrupt the ongoing process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we explore the strategy to globally inject state service and trigger
    an overlay, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter05** / **Recipe04** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **Api** and **Event** files from the **Chapter05** / **Data** directory
    in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **Overlay.css** file from the **Chapter05** / **Data** directory in
    the GitHub repository and rename it **Overlay.razor.css** ; after renaming, your
    IDE might display a compilation error – we will explain that behavior and fix
    the error by the end of this recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register the **Api** service as scoped in the application’s dependency injection
    container (check out the *Having a bookmarkable state* recipe to see how)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these instructions to add a globally injected overlay state handler:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an **OverlayState** class with an **OnChanged** event for subscribers
    to listen to and an **ExecuteAsync()** method that triggers **OnChanged** , both
    before and after executing any job passed to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Navigate to the **Program** class and register **OverlayState** in the dependency
    injection container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the main **_Imports.razor** file at the project level and inject
    the **OverlayState** , making it available across all components. You might need
    to reference the missing assembly as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an **Overlay** component that implements the **IDisposable** interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **@code** block of **Overlay** , initialize an **IsVisible** variable
    and define a **ReactAsync()** method to update **IsVisible** , based on state
    changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the **OnInitialized()** life cycle method in the **@code** block of
    the **Overlay** , and subscribe the **ReactAsync()** method to the **OverlayState.OnChanged**
    event for state change notifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within the **@code** block, implement a **Dispose()** **method to unsubscribe**
    **ReactAsync()** from the **OverlayState.OnChanged** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **Overlay** markup, include an **<overlay>** section that visually represents
    the overlay, and use the **IsVisible** variable to toggle the visibility of this
    section with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a routable **Store** component that renders in **InteractiveWebAssembly**
    mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **Store** component’s **@code** block, inject the **Api** service, and
    implement a **SyncAsync()** method to engage the **OverlayState** for managing
    overlay visibility while executing the **Api** service request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **Store** markup, embed the **Overlay** component, and include a button
    to trigger the **SyncAsync()** method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we create an **OverlayState** service. As we expect our overlay
    to have a binary nature – visible or hidden – we build a **bool** -based logic.
    We add a subscribable event of type **Func<bool, Task>** and implement an **ExecuteAsync()**
    method, which accepts an asynchronous **job** as a parameter. Within **ExecuteAsync()**
    , we toggle the overlay’s visibility by invoking the **OnChanged** event before
    and after the **job** execution, effectively showing the overlay during processing
    and hiding it upon completion. In *step 2* , we integrate **OverlayState** into
    the dependency injection container, and in *step 3* , we achieve **OverlayState**
    global accessibility by injecting it into the **_Imports.razor** file. **_Imports.razor**
    files in a Blazor application act as encapsulators of adding namespaces and directives,
    enabling them to be accessible across sibling or nested Razor components without
    declaring them explicitly in each.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4* , we create an **Overlay** component, interacting with **OverlayState**
    . As we will implement event-driven logic in **Overlay** , we declare it to implement
    the **IDisposable** interface. In *step 5* , we initiate an **IsVisible** variable
    to track the overlay’s visibility state and a **ReactAsync()** method to respond
    to those state changes. Now, we can leverage the **ReactAsync()** method to listen
    to the **OverlayState** event. In *step 6* , we override the **OnInitialized()**
    life cycle method to subscribe to the **OverlayState.OnChanged** event with **ReactAsync()**
    . Now, Blazor will communicate any changes in the overlay state to the **Overlay**
    UI. In *step 7* , we address potential memory leaks and unsubscribe from the **OnChanged**
    event within the **Dispose()** method. In *step 8* , we implement the **Overlay**
    markup. We introduce a custom **<overlay>** tag to avoid conflicts with other,
    standard DOM elements. We use the **IsVisible** flag to toggle the **visible**
    class, deciding whether an overlay is currently visible. Blazor will automatically
    associate the **Overlay.razor.css** collocated styles (which you’ve copied from
    the sample directory) and scope that styling to the **Overlay** component we just
    implemented.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 9* , we shift to showcasing the practical application of **OverlayState**
    and **Overlay** . We create a **Store** component and set it to render in **InteractiveWebAssembly**
    mode. In *step 10* , we inject the **Api** service and implement a **SyncAsync()**
    method. In the **SyncAsync()** method, we leverage **OverlayState.ExecuteAsync()**
    to encapsulate the execution of potentially time-consuming operations and display
    a visual cue in the form of an overlay, ensuring that the user is aware that their
    request is processing. In *step 11* , we introduce the **Store** markup by adding
    the **Overlay** component and a trigger button for the **SyncAsync()** method.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve injected the **OverlayState** globally across all components, we can
    decouple the **Overlay** presence from any component state. We can achieve that
    by incorporating the **Overlay** tag within the application’s layout file. With
    that, the overlay functionality is omnipresent – you can leverage the overlay
    from any application area with minimal fuss.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the layout could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Persisting state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In modern web development, the ability to persist application and session states
    is no longer a luxury but a necessity. Whether it’s to enhance user experience,
    safeguard user progress, or maintain preferences across sessions, state persistence
    plays a pivotal role in creating seamless and engaging digital experiences. Consider
    the convenience of saving local application configurations on the client side,
    such as a user’s preference for dark mode or their choice to receive push notifications.
    Similarly, persisting parts of the session state can be crucial for ensuring that
    users don’t lose valuable progress due to unexpected disruptions – imagine the
    frustration it would cause. These small touches can significantly boost the usability
    and personalization of any application. Let’s see how to persist state in your
    Blazor app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement an option to switch between light and dark modes and persist
    a proper setting flag in a user’s browser.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before implementing state persistence, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter05** / **Recipe05** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement state persistence:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an **{ASSEMBLY_NAME}.lib.module.js** file within the wwwroot directory
    of your client application, and define a **browserStorage** object with a **set**
    function that is capable of storing a **key** - **value** pair in either session
    storage or local storage, based on a **type** parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a generic, abstract **StorageValue** class with the **Key** and **Value**
    properties, aligning with the parameters expected by the **browserStorage.set**
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create **LocalStorageValue** and **SessionStorageValue** records – specific
    implementations of **StorageValue** for different browser storage types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a **BrowserStorage** class within your application, and inject the **IJSRuntime**
    service available in Blazor by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the **BrowserStorage** , define **const** values to ensure the consistency
    of the logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**_setFunc** to store the JavaScript function name'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**_local** and **_session** to reference the storage types:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Still inside **BrowserStorage** , implement a **PersistAsync()** method, accepting
    a **StorageValue<T>** parameter. Utilize **JsonSerializer** to convert the value
    to JSON and determine the appropriate storage location, before invoking the **browserStorage.set**
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the application’s **Program** class and register the **BrowserStorage**
    service in the dependency injection container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a routable **Settings** component that renders in **InteractiveWebAssembly**
    mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the **@code** block of **Settings** , inject **BrowserStorage** and
    declare constant keys dedicated to managing view mode persistence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still in the **@code** block, implement a **SetViewModeAsync()** method that
    takes a **mode** parameter, encapsulates it within a **LocalStorageValue<string>**
    object, and persists it using the **BrowserStorage.PersistAsync()** method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **Settings** component’s markup, introduce two buttons that utilize
    the **SetViewModeAsync()** method to adjust the application’s view mode – one
    to set light mode and the other for dark mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will require a piece of custom **JavaScript** to lay the
    foundation of our process. We utilize the **{ASSEMBLY_NAME}.lib.module.js** file,
    which resides in the **wwwroot** folder of our client-side project; if you don’t
    have it yet, create one. Blazor will automatically embed it, so explicit registration
    is not required. In *step 1* , we navigate to that **.js** file and define a **browserStorage**
    API. For now, we implement just a **set** function that accepts the **type** ,
    **key** , and **value** parameters, and depending on the specified **type** ,
    it invokes the **setItem** function of either the **sessionStorage** or **localStorage**
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , we create a **StorageValue** generic record with the **Key** and
    **Value** properties. By marking this record as **abstract** , we signal our intention
    to use it as a foundation for more specific storage values. And we implement just
    that in *step 3* , where we add **LocalStorageValue** and **SessionStorageValue**
    , both inheriting from **StorageValue** .
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4* , we initiate the **BrowserStorage** service. As we need to call
    a JavaScript function from our C# code, we inject Blazor’s baked-in **IJSRuntime**
    into our service. In *step 5* , we introduce a few **const** values to anchor
    our persistence logic. With **_setFunc** , we encapsulate the naming of the JavaScript
    function we want to call, while **_local** and **_session** identify the two available
    browser storage types. In *step 6* , we finalize the **BrowserStorage** implementation
    with the **PersistAsync()** generic method. However, browser storage allows us
    to store **string** types only. We address that constraint by leveraging the **JsonSerializer**
    to transform our **value** object into a **JSON** format. Then, using the **is**
    operator and our constant values, we resolve the appropriate browser storage type.
    Having all the required payload, we end the **PersistAsync()** logic by delegating
    work to the **browserStorage.set** function, with the help of the **IJSRuntime**
    reference and its **InvokeVoidAsync()** method. Now, we need to make our **BrowserStorage**
    available for components. In *step 7* , we navigate to the **Program** class and
    register **BrowserStorage** within the dependency injection container. Given the
    stateless nature of **BrowserStorage** , we opt for a **Transient** lifetime to
    avoid unnecessary memory use.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 8* , we create a **Settings** component and set it to render in **InteractiveWebAssembly**
    mode, ensuring the component’s interactivity. Then, in *step 9* , we inject **BrowserStorage**
    into the **Settings** and declare a few constant variables – **_key** , which
    holds the storage value key, and **_light** and **_dark** , which outline the
    available view modes. In *step 10* , we implement the **SetViewModeAsync()** method,
    where we initialize the **LocalStorageValue** variable with our **_key** and the
    **mode** parameter and invoke the **PersistAsync()** method of the injected **BrowserStore**
    service. To wrap it up, in *step 11* , we add two buttons to the **Settings**
    component markup. With these buttons, users can invoke the **SetViewModeAsync()**
    method and set the selected view mode in the browser’s local storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steps may vary a little between browsers, but here’s how you can peak the **viewMode**
    key value with Chrome DevTools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Peaking the value persisted in a browser’s local storage with
    Chrome DevTools](img/Figure_5.1_B22020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Peaking the value persisted in a browser’s local storage with Chrome
    DevTools'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve developed a custom JavaScript function to enable access to a browser’s
    storage, as this implementation remains functional across both server and client-side
    scenarios, offering broad compatibility and flexibility. When integrating JavaScript
    into Blazor applications, you must remember that services depending on **IJSRuntime**
    cannot be registered as singletons. **IJSRuntime** requires access to each user’s
    browser session, which makes it architecturally incompatible with the singleton
    initialization pattern and lifetime model.
  prefs: []
  type: TYPE_NORMAL
- en: However, for projects strictly confined to server-side Blazor, you should consider
    leveraging the built-in **ProtectedBrowserStorage** API. **ProtectedBrowserStorage**
    is a Blazor-native mechanism that enables browser storage access with a data encryption
    layer that doesn’t require custom JavaScript at all.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving persisted state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, you explored persisting application state within a browser’s
    storage. Building upon this foundation, in this recipe, we’ll focus on an equally
    crucial aspect – restoring that persisted state. That functionality is invaluable
    when dealing with user-specific local application personalization, such as the
    preference between dark or light mode or the consent to receive push notifications.
    With state persistence and resolution, you offer users the convenience of rejoining
    their sessions exactly where they left them. This continuity is fundamental in
    crafting a user-centric application and offering a personalized experience.
  prefs: []
  type: TYPE_NORMAL
- en: With the light or dark mode persisted in the last recipe, let’s implement an
    option to resolve a persisted view mode value when a component renders.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you start resolving persisted state, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter05** / **Recipe06** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **BrowserStorage** , **Settings** , and all **StorageValue** records
    from the *Persisting state* recipe or the **Chapter05** / **Recipe05** directory
    of the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re not following along the entire chapter but starting with this recipe,
    copy the **BlazorCookbook.App.Client.lib.module.js** file from the **wwwroot**
    directory of the **BlazorCookbook.App.Client** in the GitHub repository to the
    **wwwroot** of your project, and rename it to match your project assembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register the **BrowserStorage** as transient in your application’s **Program**
    class (check out the *Persisting state* recipe to see how)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these instructions to implement the resolution of persisted state:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **{ASSEMBLY_NAME}.lib.module.js** script file, and enhance **browserStorage**
    by adding a **get** function that retrieves the persisted value from storage,
    specified by the **type** parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **BrowserStorage** class, introduce a new **_getFunc** variable to hold
    the name of the newly created **browserStorage.get** JavaScript function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the **BrowserStorage** , implement a **ResolveAsync()** generic method,
    accepting a **StorageValue** parameter that fetches the persisted value from the
    appropriate browser storage. Utilize **JsonSerializer** to transform the retrieved
    string into the expected object type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move to the **Settings** component. Extend the **@code** section with a new
    **ViewMode** variable, and override the **OnAfterRenderAsync()** life cycle method
    with logic to resolve the persisted **viewMode** value in **ViewMode** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enhance the **Settings** component’s markup by adding a paragraph below the
    buttons to display the current **ViewMode** value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by enhancing our **browserStorage** API. In *step 1* , we navigate
    to the **{ASSEMBLY_NAME}.lib.module.js** script file and expand the **browserStorage**
    functionality with a **get** function. We mirror the **set** function’s implementation,
    utilizing the **type** parameter to select the appropriate storage type and fetching
    the value associated with the specified **key** .
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , we refine our **BrowserStorage** service implementation by introducing
    a **_getFunc** variable to store the name of our newly created **browserStorage.get**
    function, safeguarding against potential typo errors in future references. Following
    this, in *step 3* , we implement a **ResolveAsync()** generic method that mirrors
    the logic of the existing **PersistAsync()** method. **ResolveAsync()** takes
    a **StorageValue** parameter, identifies the correct storage using the **is**
    operator, and calls the **InvokeAsync()** generic method provided by **IJSRuntime**
    to pull the **value** from browser storage. Since this value returns as a JSON
    string, we utilize the **JsonSerializer** API to convert this string back into
    the desired data type.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4* , we shift to the **Settings** component, where we initialize a
    **ViewMode** variable to hold the resolved value of the user’s persisted view
    mode choice. We then override the **OnAfterRenderAsync()** life cycle method,
    where we use the injected **Storage** service and the newly introduced **ResolveAsync()**
    method to resolve the **ViewMode** value when the **Settings** component initially
    renders. Leveraging the **fast-return pattern** , we ensure that the method exits
    immediately during subsequent component state changes. Since Blazor executes our
    resolving logic post-render, we must invoke the **StateHasChanged()** method to
    refresh the UI with the updated values. Finally, in *step 5* , for the sake of
    simplicity, we add a paragraph below the action buttons within the **Settings**
    markup to display the current **ViewMode** value. Alternatively, you can apply
    CSS classes for light and dark modes to the DOM elements, should you have the
    supporting CSS in place.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used the **OnAfterRenderAsync()** method to resolve the **ViewMode** value
    for an architectural reason. Blazor blocks all **IJSRuntime** interactions in
    the initial phases of component initialization. Before the DOM is created, the
    component is essentially in a setup phase, initializing and fetching required
    data. Once rendering completes and the DOM structure is in place, Blazor allows
    us to invoke the **IJSRuntime** API and interact with loaded JavaScript functions.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing state across interactive render mode boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigating state management in Blazor apps becomes complicated when you switch
    from running solely in one render mode to mixing render modes, or using **InteractiveAuto**
    mode. The challenge arises from the recreation of a scoped state with every render
    mode change, due to the lack of automatic state sharing between server and client
    environments. You can tackle this fragmentation by designating a single, consistent
    source for state persistence. In this recipe, we will dive into a strategy where
    the client is the source of truth, and we will restore state from the browser
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a generic component base that allows us to share state across
    interactive render mode boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you dive into state sharing, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter05** / **Recipe07** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **BrowserStorage** and **StorageValue** objects from the *Resolving
    persisted state* recipe or from the **Chapters05** / **Recipe06** directory of
    the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re not following along the entire chapter but starting with this recipe,
    copy the **BlazorCookbook.App.Client.lib.module.js** file from the **wwwroot**
    directory of the **BlazorCookbook.App.Client** in the GitHub repository to the
    **wwwroot** of your project, and rename it to match your project assembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register the **BrowserStorage** as transient in your application’s **Program**
    class (check out the *Persisting state* recipe to see how)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement sharing state across interactive render mode
    boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a **CartState** class, with an **UpdateTime** property and an **Add()**
    method that mimics adding to the cart and refreshes **UpdateTime** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the **Program** class and register a global **CascadingValue**
    for **CartState** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a generic **CrossingInteractiveBoundary** component that implements
    the **IAsyncDisposable** interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the component’s **@code** section of **CrossingInteractiveBoundary**
    , define a unique state identifier, **_key** , inject **BrowserStorage** , and
    use **CascadingParameter** to intercept the generic **State** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within the **@code** block, override the **OnAfterRenderAsync()** life
    cycle method to hydrate **State** by fetching the persisted value with **SessionStorageValue**
    , via the **ResolveAsync()** method of **Storage** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, in the **@code** block, to preserve state upon disposal, implement
    a **DisposeAsync()** method, as mandated by the **IAsyncDisposable** contract,
    and send the updated **State** back to the browser storage through the **PersistAsync()**
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a routable **Cart** component that operates in **InteractiveAuto** render
    mode and inherits from the **CrossingInteractiveBoundary<CartState>** type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the layout of the **Cart** component, add a button that triggers the **Add()**
    method of **State** and a paragraph to display the current value of the **UpdateTime**
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we create a **CartState** state class with an **UpdateTime** property
    and an **Add()** method that refreshes **UpdateTime** with the current UTC, demonstrating
    the dynamic state interactions. In *step 2* , we navigate to the **Program** class,
    and by leveraging Blazor’s **AddCascadingValue()** extension method, we declare
    **CartState** as a globally accessible **CascadingValue** , ensuring that the
    state object is available throughout the application. We declare that the initial
    state of the cart is represented by a new instance of the **CartState** object.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3* , we introduce the cornerstone of our state-sharing mechanism –
    the **CrossingInteractiveBoundary** component. By implementing the **IAsyncDisposable**
    interface, we prepare **CrossingInteractiveBoundary** to have an asynchronous
    disposal logic. In *step 4* , we define a unique **_key** storage identifier and
    inject **BrowserStorage** to persist state beyond traditional life cycle boundaries.
    With the **CascadingParameter** attribute, we dynamically capture the **State**
    value, regardless of the currently expected type. In *step 5* , we override the
    **OnAfterRenderAsync()** life cycle method of the **CrossingInteractiveBoundary**
    to rehydrate **State** with previously persisted values from the browser’s session
    storage. We utilize the **try** - **catch** structure to gracefully handle scenarios
    where the user initializes state for the first time, so there’s no value to restore.
    In *step 6* , we complete the implementation with the **DisposeAsync()** method,
    but instead of releasing resources, we add logic to persist the **State** value
    with the **PersistAsync()** method of **Storage** . This way, we ensure that the
    state remains updated and recoverable, regardless of navigation actions or rendering
    mode transitions.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7* , we introduce the **Cart** component that renders in dynamic **InteractiveAuto**
    mode and inherits from **CrossingInteractiveBoundary** , with state represented
    by the **CartState** object. Blazor will seamlessly alternate between server-side
    and client-side rendering, which makes it a perfect environment to showcase the
    adaptive state-sharing logic of **CrossingInteractiveBoundary** . In *step 8*
    , we add the **Cart** markup – a button that invokes the **Add()** method of **CartState**
    and a paragraph displaying the current **UpdateTime** value.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The strategy we’ve explored in this recipe is not limited to cascading parameters.
    You can also leverage **BrowserStorage** to hydrate and persist the state of the
    state injected as a service (you learned how to implement injectable state in
    the *Injecting application state as a service* recipe). Depending on your architectural
    requirements, you can leverage a **REST API** or **gRPC** service and persist
    state on the server as well. Moreover, as the complexity and size of the state
    object grows, you’ll see that state hydration can cause a visible delay before
    the UI refreshes with the correct data. That’s where the **Overlay** component,
    which we implemented in the *Invoking state changes from anywhere* recipe, comes
    in handy. By temporarily obscuring the UI until state resolution completes, we
    ensure that users experience a seamless and cohesive interface.
  prefs: []
  type: TYPE_NORMAL
