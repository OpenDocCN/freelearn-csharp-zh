- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: The FIRSTHAND Guidelines of TDD
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD的FIRSTHAND指导原则
- en: TDD is more than a test-first unit testing or a Red-Green-Refactor approach.
    TDD includes best practices and guidelines that steer the way you work with unit
    testing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: TDD不仅仅是先测试单元测试或红-绿-重构的方法。TDD包括最佳实践和指导原则，这些原则指导你如何使用单元测试进行工作。
- en: 'I wanted to make a memorable list, from my experience, of the most useful guidelines
    on unit testing and TDD. So, here are nine proven best practices that I’ve abbreviated
    as **FIRSTHAND**. FIRSTHAND stands for:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我想根据我的经验，列出最有用的单元测试和TDD指导原则的难忘列表。因此，以下是我简称为**FIRSTHAND**的九项经过验证的最佳实践。FIRSTHAND代表：
- en: '*F*irst'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第一*'
- en: '*I*ntention'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*意图*'
- en: '*R*eadability'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可读性*'
- en: '*S*ingle-Behavior'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单一行为*'
- en: '*T*horoughness'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*彻底性*'
- en: '*H*igh-Performance'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高性能*'
- en: '*A*utomation'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自动化*'
- en: '*N*o Interdependency'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无依赖性*'
- en: '*D*eterministic'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*确定性*'
- en: In this chapter, we will go through each of these nine guidelines and support
    them with relevant practical examples. By the end of the chapter, you should have
    a fair understanding of the ecosystem of TDD and its guidelines.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将逐一介绍这九项指导原则，并通过相关的实际案例来支持它们。到本章结束时，你应该对TDD的生态系统及其指导原则有一个公正的理解。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found in the following GitHub repository:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch06](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch06)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch06](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch06)'
- en: The First guideline
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一条指导原则
- en: Unit tests should be written first. This might seem odd or unintuitive at the
    beginning, but there are valid reasons for this choice.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该首先编写。一开始这可能看起来很奇怪或不直观，但这个选择有合理的理由。
- en: Later means never
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 晚了就是永远
- en: How many times have you heard, *we’ll test it later*? I have never seen a team
    finishing a project and releasing it to production and then allocating time to
    unit test their code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你听过多少次“我们稍后再测试”的说法？我从未见过一个团队完成项目并发布到生产环境中后，再分配时间来对代码进行单元测试。
- en: Moreover, adding unit tests at the end will require code refactoring, which
    might break the product, and it is hard to justify to a non-technical person that
    a working system was broken because the team was adding unit tests. Actually,
    the statement *we broke production because we were adding unit tests* sounds ironic.
    Yes, you can refactor a working system while covered by other types of tests,
    such as Sintegration and acceptance tests, but it would be difficult to imagine
    that a team that didn’t have time to unit test previously had the time to build
    other tests that would fully cover the system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在最后添加单元测试将需要代码重构，这可能会破坏产品，并且很难向非技术人员解释一个正在运行的系统被破坏是因为团队正在添加单元测试。实际上，说“我们因为添加单元测试而破坏了生产”听起来很讽刺。是的，你可以在其他类型的测试（如S集成测试和验收测试）的覆盖下重构一个正在运行的系统，但很难想象一个之前没有时间进行单元测试的团队能有时间构建其他完全覆盖系统的测试。
- en: '*Testing first ensures that unit tests and features are developed hand in hand
    and tests are not omitted.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*先测试*确保单元测试和功能是同步开发的，测试不会被遗漏。'
- en: Being dependency injection ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好依赖注入
- en: 'When you get used to the modern software development style of creating a service
    and then injecting it, you will never look back. Software frameworks have evolved
    to make DI a first-class citizen. Here are a few examples:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你习惯了现代软件开发风格，即先创建服务然后注入它，你就不会回头了。软件框架已经发展到使DI成为一等公民。以下是一些例子：
- en: '**Angular Web Framework**: You can only obtain services in Angular via DI and
    you would struggle to do it in other ways.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular Web框架**：你只能通过依赖注入（DI）在Angular中获取服务，而其他方式则难以实现。'
- en: '**Microsoft MAUI**: MAUI is a revamp of Xamarin.Forms and one of the major
    changes from Xamarin is having DI as a first-class citizen.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Microsoft MAUI**：MAUI是Xamarin.Forms的改进版，其中一个主要变化是将DI作为一等公民。'
- en: '**.NET Core Console**: classical .NET Framework console applications did not
    support DI, but this is now natively supported in Core, which paved the way to
    have other libraries, built on top of console applications, to support DI, for
    example ASP.NET Core.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET Core控制台**：传统的.NET Framework控制台应用程序不支持DI，但现在在Core中原生支持，这为在控制台应用程序之上构建支持DI的其他库铺平了道路，例如ASP.NET
    Core。'
- en: '**ASP.NET Core**: One major difference between classical ASP.NET and ASP.NET
    Core is having DI as a first-class citizen.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ASP.NET Core**：经典ASP.NET和ASP.NET Core之间的一大区别是将依赖注入（DI）作为一等公民。'
- en: These are all strong signals to tell you that there is no escape from using
    DI. Having your software implemented and then adding DI later is going to require
    a major refactoring and rethinking everything.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是强烈的信号，告诉你无法逃避使用依赖注入（DI）。在软件实现后添加DI将需要重大的重构和重新思考一切。
- en: '*Starting with unit testing will enforce DI from the first moment.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*从单元测试开始将强制从第一刻起进行依赖注入（DI）*。'
- en: Designing from the client’s perspective
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从客户端的角度进行设计
- en: TDD encourages you to think from the client’s (the caller) needs rather than
    getting bogged down with the implementation details. You are encouraged to think
    of the OOP design such as class name, abstractions, deciding the method signature
    and return type before thinking of the implementation details like the method
    body.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: TDD鼓励你从客户端（调用者）的需求出发思考，而不是陷入实现细节。你被鼓励在考虑实现细节之前，先考虑面向对象设计，如类名、抽象、决定方法签名和返回类型。
- en: If you have a public interface (a combination of classes and methods) used by
    other systems or libraries, it is harder to change that interface as it is probably
    in-use by the other system, compared to changing the implementation of your code,
    say for optimization purposes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个被其他系统或库使用的公共接口（类和方法的组合），那么与改变你代码的实现相比，改变这个接口会更困难，因为它可能已经被其他系统使用。
- en: '*TDD enforces designing the code from the client’s perspective.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*TDD强制从客户端的角度设计代码*。'
- en: Promoting behavior testing
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 促进行为测试
- en: A unit test should care about *what* a **System Under Test** (**SUT**) does,
    *not how* it does it. In a unit test, you want to push a certain input, check
    how the dependencies are affected, and check the output. What you should not check
    is how the SUT worked internally to do all that.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该关注**系统在测试**（**SUT**）**做什么**，而不是**它是如何做的**。在单元测试中，你想要推送一定的输入，检查依赖项是如何受影响的，并检查输出。你不应该检查的是SUT内部是如何完成所有这些工作的。
- en: If you decide to check the internals of the SUT, your unit tests will become
    tightly coupled to the implementation details. This means every change in the
    method will have a rippling effect on the associated unit tests. This will lead
    to more unit tests and brittle tests. It is worth iterating here that *tests are
    an asset and a liability*. Having more tests, which are often unnecessary, means
    more maintenance.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定检查SUT的内部，你的单元测试将与实现细节紧密耦合。这意味着方法中的任何更改都会对相关的单元测试产生连锁反应。这将导致更多的单元测试和脆弱的测试。这里值得迭代的是，*测试既是资产也是负债*。拥有更多的测试，这些测试往往是多余的，意味着更多的维护。
- en: Testing first makes you naturally think about the inputs, outputs, and side
    effects, not about the details of the SUT implementation. Testing after implementation
    leads to what I refer to as *cheating*, where the developers look at the SUT implementation
    code and write their tests accordingly. This might inadvertently lead to testing
    implementation details.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 测试先行会让你自然地考虑输入、输出和副作用，而不是SUT实现的细节。在实现之后进行测试会导致我所说的*欺骗*，即开发者查看SUT实现代码并相应地编写测试。这可能会无意中导致测试实现细节。
- en: '*TDD promotes the unit testing mantra: Test behavior, not implementation details.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*TDD提倡单元测试的口号：测试行为，而不是实现细节*。'
- en: Eliminating false positives
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消除误报
- en: A false positive is when a test passes for the wrong reason. This doesn’t happen
    frequently, but when it does happen, it is hard to catch.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 误报是指测试因为错误的原因通过。这种情况并不常见，但一旦发生，就很难捕捉。
- en: '*TDD uses the red-green approach to eliminate false positives.*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*TDD使用红-绿方法来消除误报*。'
- en: Eradication of speculative code
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消除投机性代码
- en: We have all written code thinking, *perhaps we will need it in the future*,
    or *let me leave it here as other* *colleagues will find it useful*. The drawback
    of this approach is this code may never be used but will be maintained. Even worse,
    if it is used in the future, it may give the illusion that it has been tested,
    while, in fact, it has been waiting for a future developer to test it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都曾写过代码，心想，“也许我们将来会用得上”，或者“让我把它留在这里，因为其他” *同事* *可能会觉得它有用*。这种方法的缺点是，这段代码可能永远不会被使用，但需要维护。更糟糕的是，如果将来被使用，它可能会给人一种已经测试过的错觉，而实际上它只是在等待未来的开发者来测试它。
- en: '*TDD eradicates speculative code by writing production-only code.*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*TDD通过编写仅用于生产的代码来消除投机性代码*。'
- en: The Intention guideline
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 意图指南
- en: 'When your system grows, it drives more unit tests that will naturally cover
    system behavior and documentation. And with more tests comes greater responsibility:
    **readability** and **maintenance**.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的系统增长时，它将驱动更多的单元测试，这些测试将自然覆盖系统行为和文档。随着测试数量的增加，责任也更大：**可读性**和**维护性**。
- en: The tests will grow in quantity to an extent where the team will not remember
    the reason for writing them. You will be looking at a failing test and scratching
    your head for clues about the intention of the test.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的数量将增长到一定程度，以至于团队将无法记住编写它们的原因。你将看到失败的测试，并挠头寻找关于测试意图的线索。
- en: Your unit tests should be understood with the least possible time and effort;
    otherwise, they will be more of a liability than an asset. An agile software team
    should be prepared in advance for such test failure scenarios. Intention can be
    demonstrated by having a clear method signature and a well-structured method body.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你的单元测试应该以最短的时间和精力来理解；否则，它们将更多地成为负担而不是资产。敏捷软件开发团队应该提前准备好这样的测试失败场景。意图可以通过清晰的方法签名和良好的方法结构来体现。
- en: Starting with the method signature, here are two popular conventions that should
    clarify the unit test’s intention.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从方法签名开始，这里有两个流行的约定，应该可以阐明单元测试的意图。
- en: Method_Condition_Expectation
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法_条件_期望
- en: 'I have been using this convention in naming the unit test methods across the
    book: `Method_``Condition_Expectation`. This is a succinct naming convention that
    doesn’t allow innovative method names and, in my opinion, spares innovation for
    other tasks. It results in a more boring but standard method name. The following
    is an example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直在本书中用这个约定命名单元测试方法：`Method_``Condition_Expectation`。这是一个简洁的命名约定，不允许创新的方法名，在我看来，它为其他任务保留了创新。这导致了一个更无聊但标准的方法名。以下是一个例子：
- en: '`LoginUser_UsernameDoesntExist_ThrowsInvalidOperationException`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginUser_UsernameDoesntExist_ThrowsInvalidOperationException`'
- en: This is still not a precise convention, but it is good enough. For example,
    some developers may argue against using the word `Throws` as it is obvious because
    the word `Exception` is used.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然不是一个精确的约定，但已经足够好了。例如，一些开发者可能会反对使用`Throws`这个词，因为它很明显，因为使用了`Exception`这个词。
- en: What is important here is establishing, in a short amount of time, from the
    three parts seen in the preceding method name, the intention of this test.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是在短时间内，从前面方法名中看到的三部分，确定这个测试的意图。
- en: Note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I have seen teams omitting the `Method` part and just using `Condition_Expectation`,
    especially if the whole unit test class targets one method only.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到过一些团队省略了`Method`部分，只使用`Condition_Expectation`，特别是如果整个单元测试类只针对一个方法。
- en: Method_Should_When
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法_Should_When
- en: 'Another popular convention that allows more natural language is using the `Method_Should_When`.
    This convention is more akin to fluent coding, where the code flows like an English
    sentence. The following is an example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的约定，允许使用更自然语言的是使用`Method_Should_When`。这个约定更接近流畅编码，代码的流动就像一个英文句子。以下是一个例子：
- en: '`LoginUser_Should_Throw_InvalidOperationException_When_UsernameDoesntExist`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginUser_Should_Throw_InvalidOperationException_When_UsernameDoesntExist`'
- en: 'Sometimes, advocates of this convention like to also use **fluent assertions**
    for asserting:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这个约定的倡导者喜欢也使用**流畅断言**来进行断言：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you might have noticed, the previous code is different from the xUnit style
    used in the book:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，前面的代码与书中使用的xUnit风格不同：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you are interested in using fluent assertions, you can have a look at a .NET
    library called **Shouldly** ([https://github.com/shouldly/shouldly](https://github.com/shouldly/shouldly)).
    In [*Appendix 1*](B18370_14.xhtml#_idTextAnchor315), *Commonly Used Libraries
    with Unit Tests*, we discuss a similar library called *Fluent Assertions*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣于使用流畅断言，你可以看看一个名为**Shouldly**的.NET库（[https://github.com/shouldly/shouldly](https://github.com/shouldly/shouldly)）。在[*附录1*](B18370_14.xhtml#_idTextAnchor315)中，*常用单元测试库*，我们讨论了一个类似的库，名为*流畅断言*。
- en: The next part for clarifying the intention is clarifying the method body.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步明确意图是明确方法体。
- en: Unit test structure
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试结构
- en: The dominant method for structuring a unit test body is the popular **Arrange-Act-Assert**
    (**AAA**). Let’s shed more light on the intention of what each section should
    do.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化单元测试主体的主导方法是流行的**安排-行动-断言**（**AAA**）。让我们更深入地了解每个部分应该做什么的意图。
- en: Arrange
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Arrange
- en: '`Arrange` is meant to achieve two objectives:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arrange`旨在实现两个目标：'
- en: Initializing variables
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化变量
- en: Creating a SUT state
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建SUT状态
- en: The `Arrange` section might be shared with the constructor of the unit test
    class as the constructor might be doing some preparations to reduce the `Arrange`
    code across each unit test. In other words, there might be some *arrangements*
    happening outside this section. We will see examples of this in *Part 2*, *Building
    an Application with TDD*, of the book.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arrange`部分可能与单元测试类的构造函数共享，因为构造函数可能在进行一些准备以减少每个单元测试中的`Arrange`代码。换句话说，可能有一些*安排*发生在这个部分之外。我们将在本书的*第2部分*，*使用TDD构建应用程序*中看到这个例子。'
- en: 'Initializing the objects and initializing expectations happen in the `Arrange`
    section, and that is the obvious part. The not-so-obvious part is that this section
    sets a *state*. Here is an example to clarify what a state means:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化对象和初始化期望发生在`Arrange`部分，这是显而易见的。不那么明显的是，这个部分设置了一个*状态*。以下是一个澄清状态含义的例子：
- en: '`LoginUser_UsernameDoesntExist_ThrowsInvalidOperationException`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginUser_UsernameDoesntExist_ThrowsInvalidOperationException`'
- en: '`Arrange` will create a state where the user doesn’t exist in the system, and
    in most cases, that code will be tightly related to the `Condition` in `Method_Condition_Expectation`.
    In this case, the arrangement should be linked to `UsernameDoesntExist`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arrange`将创建一个用户在系统中不存在的状态，在大多数情况下，这段代码将与`Method_Condition_Expectation`中的`Condition`紧密相关。在这种情况下，安排应该与`UsernameDoesntExist`相关联。'
- en: Act
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行动
- en: '`Act` is mostly a single line of code that calls the same method specified
    in the first part of the method name. In the previous example, I expect the act
    to look like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Act`主要是一行代码，调用方法名第一部分指定的相同方法。在先前的例子中，我期望`act`看起来像这样：'
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This method reiterates the intention specified in the method’s signature and
    provides clean code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法重申了方法签名中指定的意图，并提供了干净的代码。
- en: Assert
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言
- en: '`Assert` is asserting the conditions in the last section of the method signature:
    `Expectation`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assert`正在断言方法签名最后部分的条件：`Expectation`。'
- en: The signature convention and the body structure work together to provide clear
    intentions. Keep in mind that no matter what convention you’ve used, the key is
    consistency and clarity.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 签名约定和主体结构共同作用，提供清晰的意图。请记住，无论你使用了什么约定，关键是保持一致性和清晰性。
- en: '*Clear-intention unit tests would promote easier maintenance and more accurate
    documentation.*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*清晰的意图单元测试将促进更易于维护和更准确的文档*。'
- en: The Readability guideline
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可读性指南
- en: Is this method readable? Do you need to run it and start debugging to understand
    what it does? Does the `Arrange` section make your eyes bleed? This might be violating
    the readability principle.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可读吗？你需要运行它并开始调试来理解它做什么吗？`Arrange`部分让你的眼睛感到不适吗？这可能会违反可读性原则。
- en: Having the Intention guideline established is fabulous, but it is not enough.
    You will have at least 10x more lines of code in your unit tests compared to your
    production code. All this needs to be maintained and grow with the rest of your
    system.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 建立意图指南是极好的，但这还不够。与你的生产代码相比，你的单元测试中至少会有10倍多的代码行。所有这些都需要维护并随着你的系统一起增长。
- en: Tidying up the unit test for readability follows the same practices as the production
    code. However, there are some scenarios that are more dominant in unit tests,
    which we are going to address here.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性而对单元测试进行整理遵循与生产代码相同的实践。然而，在单元测试中，有一些场景更为突出，我们将在这里解决这些问题。
- en: SUT constructor initialization
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SUT构造函数初始化
- en: 'Initializing your SUT will require that you prepare all the dependencies and
    pass them to the SUT, something like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化你的SUT将需要你准备所有依赖项并将它们传递给SUT，类似于这样：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we have done all the coding preparation, we can initialize the SUT (the
    controller, in our case) and pass to it the right parameters. This will be repeated
    in most of your same-SUT tests, which will make it a read nightmare. This code
    can easily go to the constructor of the unit test class and become something like
    this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了所有的编码准备工作，我们可以初始化SUT（在本例中为控制器）并传递给它正确的参数。这在大多数与SUT相同的测试中都会重复，这将使它成为一个阅读噩梦。这段代码可以轻松地移动到单元测试类的构造函数中，变成这样：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The beauty of the previous code is that it is reusable by all unit tests in
    the same class. The code in your unit test becomes something like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的美丽之处在于它对所有同一类的单元测试都是可重用的。你的单元测试中的代码变成了这样：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Arrange` size in your unit tests in this class has gone down. Remember,
    you are looking here at one unit test method, but you might have several unit
    tests for the same SUT.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中单元测试的`Arrange`大小已经降低。记住，你在这里看到的是一个单元测试方法，但你可能有多个针对同一SUT的单元测试。
- en: You might argue that while we have cleared some of the repeated code in our
    `Arrange`, it is still busy. Let’s get the builder design pattern to the rescue.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会争辩说，虽然我们在`Arrange`中清除了一些重复的代码，但它仍然很忙。让我们用构建器设计模式来解救。
- en: The builder pattern
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建器模式
- en: For the same SUT, every unit test’s arrangement varies slightly from others.
    The **builder design pattern** is useful when creating an object with lots of
    possible configuration options, which comes in handy for this scenario.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于同一SUT，每个单元测试的安排与其他单元测试略有不同。当创建具有许多可能配置选项的对象时，**构建器设计模式**很有用，这在这种情况下很有帮助。
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This is different from the **Gang of Four** (**GoF**) Builder design pattern.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这与**四人帮**（**GoF**）构建器设计模式不同。
- en: 'The builder class, for the previous example, looks like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的例子，构建器类看起来像这样：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'What is notable in this class is that:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中值得注意的是：
- en: 'Every method returns the class instance. This helps to chain methods like this:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个方法都返回类实例。这有助于像这样链式调用方法：
- en: '[PRE7]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Build()` method will combine all the configurations together to return
    a usable object.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Build()`方法将所有配置组合在一起，以返回一个可用的对象。'
- en: 'The refactored `Arrange` of the previous unit test looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之前单元测试的重构`Arrange`看起来像这样：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code takes advantage of the builder class that we created earlier.
    You can see the code clearly setting the next day’s temperature as 3.3 degrees.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码利用了我们之前创建的构建器类。你可以清楚地看到代码将第二天温度设置为3.3度。
- en: Using SUT constructor initialization and the builder pattern are just a few
    examples of making your unit tests readable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SUT构造函数初始化和构建器模式只是使你的单元测试可读性的几个例子。
- en: You can find the refactored class in `WeatherForecastTestsReadable.cs` and the
    original in `WeatherForecastTestsLessReadable.cs` in the companion source code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在配套源代码中的`WeatherForecastTestsReadable.cs`找到重构后的类，以及在`WeatherForecastTestsLessReadable.cs`中找到原始类。
- en: '*Readability promotes the healthy growth of your unit test’s codebase. Keep
    it in check from day one.*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*可读性促进了你的单元测试代码库的健康成长。从第一天开始就要保持其可控性。*'
- en: The Single-Behavior guideline
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一行为指南
- en: 'Every unit test should test one and only one behavior. Throughout this book,
    this concept has been enforced naturally by:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单元测试都应该测试一个且仅有一个行为。在整个书中，这个概念通过以下方式自然地得到了强化：
- en: The naming of the unit test method’s signature, which reflects one condition
    with one expectation
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试方法签名的命名，它反映了一个条件和一个期望
- en: A single AAA structure that enforced a single `Act`
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单一的AAA结构强制执行单一的`Act`
- en: Before digging further, I would like to define the word *behavior*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步挖掘之前，我想定义一下单词*行为*。
- en: What is behavior?
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是行为？
- en: 'The definition of behavior varies in the industry, so it is important to set
    an accurate one for the context of this book. Each SUT is supposed to do something.
    A SUT does this *thing* by:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 行为的定义在行业中有所不同，因此对于本书的上下文来说，设置一个准确的行为定义很重要。每个SUT都应该做某件事。SUT通过以下方式来完成*这件事*：
- en: '**Communicating with dependencies**: Communication can be by calling a method
    on a dependency or setting a field or a property – this is referred to as *external
    behavior*.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与依赖项通信**：通信可以通过在依赖项上调用方法或设置字段或属性来完成——这被称为*外部行为*。'
- en: '`Exception` or the return value (if a method is not a `void` or a `Task` method)
    – this is also referred to as *external behavior*.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exception`或返回值（如果方法不是`void`或`Task`方法）——这通常被称为*外部行为*。'
- en: '**Plumbing all together**: Doing various commands in preparation to receive
    the input, in preparation for the output (the return value), or in preparation
    for communicating with a dependency – this is referred to as the *internals* of
    the SUT, or *internal behavior*.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整体规划**：在接收输入、准备输出（返回值）或准备与依赖项通信之前执行各种命令——这被称为SUT的*内部*或*内部行为*。'
- en: External behavior propagates across the system, as it is touching other dependencies,
    while internal behavior is encapsulated in the SUT and not shown to the outside
    world.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 外部行为在系统中传播，因为它正在接触其他依赖项，而内部行为被封装在SUT中，不会展示给外界。
- en: When we use the word *behavior* on its own, we mean *external behavior*, so
    the Single-Behavior guideline refers to single external behavior. As usual, definitions
    seem more complicated than they are, so let’s fortify this definition with an
    example.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们单独使用“行为”这个词时，我们指的是“外部行为”，因此单一行为指南指的是单一外部行为。通常，定义似乎比实际要复杂，所以让我们用一个例子来加强这个定义。
- en: Example of behavior
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为的例子
- en: 'Let’s take this code from the **Weather Forecasting App** (**WFA**) that was
    introduced in [*Chapter 2*](B18370_02.xhtml#_idTextAnchor037), *Understanding
    Dependency Injection by Example*:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从**天气预报应用**（**WFA**）中取出这段代码，该应用在[*第2章*](B18370_02.xhtml#_idTextAnchor037)，*通过例子理解依赖注入*中介绍过：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, the external behaviors are all in the `_client.OneCallAsync`
    call and in the `return` statement. The rest of the code is all internal. You
    can think of the internal code’s role as preparing to trigger the `_client` dependency
    and to return a value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，所有外部行为都在 `_client.OneCallAsync` 调用和 `return` 语句中。其余的代码都是内部的。你可以将内部代码的作用视为准备触发
    `_client` 依赖项并返回一个值。
- en: The internal behaviors are no longer relevant once these two external behaviors
    are triggered; they are executed and forgotten, while the external behaviors propagate
    to other services.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦触发这两个外部行为，内部行为就不再相关；它们被执行并遗忘，而外部行为则传播到其他服务。
- en: Testing external behavior only
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅测试外部行为
- en: If the role of internals is to prepare for external behavior only, then testing
    external behavior will cover testing the whole code. You can think of it as the
    internal code being tested is a by-product of testing the external behavior.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内部代码的作用仅仅是准备外部行为，那么测试外部行为将涵盖测试整个代码。你可以将其视为测试内部代码是测试外部行为的副产品。
- en: 'Here are some examples of unit testing the behavior (external behavior). These
    examples are fully implemented in the source code in [*Chapter 3*](B18370_03.xhtml#_idTextAnchor066),
    *Getting Started with Unit Testing* (**WF** stands for **Weather Forecasting**):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些单元测试行为的例子（外部行为）。这些例子在源代码的[*第3章*](B18370_03.xhtml#_idTextAnchor066)，*开始单元测试*中得到了完全实现（**WF**代表**天气预报**）：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After executing these tests that are targeting external behavior only, a code
    coverage tool will show that all the code that was demonstrated in the previous
    example is covered by our test. This includes the code in the `GetReal()` public
    method and the code in the `MapFeelToTemp()` private method. Let’s have a look
    at an example of code coverage:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行仅针对外部行为的测试之后，代码覆盖率工具将显示所有在先前的例子中展示的代码都被我们的测试覆盖了。这包括`GetReal()`公共方法中的代码和`MapFeelToTemp()`私有方法中的代码。让我们看看代码覆盖率的一个例子：
- en: '![Figure 5.1 – Lines covered by behavior tests ](img/Figure_6.1_B18370.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 由行为测试覆盖的行](img/Figure_6.1_B18370.jpg)'
- en: Figure 5.1 – Lines covered by behavior tests
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 由行为测试覆盖的行
- en: In the preceding figure, I have used a VS plugin called **Fine Code Coverage**
    (**FCC**) to show the lines that are covered by the selected tests to the right.
    It shows that all the code lines in the SUT were covered by these tests. We will
    discuss coverage and this plugin tool in more detail in *The Thoroughness guideline*
    section.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我使用了一个名为**Fine Code Coverage**（**FCC**）的VS插件来显示所选测试覆盖的行。它显示所有SUT中的代码行都被这些测试覆盖了。我们将在*彻底性指南*部分更详细地讨论覆盖率和这个插件工具。
- en: Why not test internals?
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么不测试内部代码？
- en: 'One common mistake in unit testing is when developers try to test the internals
    of a SUT. Here are a few problems with testing internals:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试中的一个常见错误是当开发者试图测试SUT的内部代码。以下是测试内部代码的一些问题：
- en: The SUT is already covered when testing external behavior, so there’s no need
    to increase the number of unit tests, which will increase maintenance (liability).
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当测试外部行为时，SUT已经得到覆盖，因此不需要增加单元测试的数量，这将增加维护（责任）。
- en: Testing the internals will create tight coupling between the SUT and the tests,
    which will create brittle tests that will have to change often.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试内部代码将在SUT和测试之间创建紧密耦合，这将创建脆弱的测试，这些测试将不得不经常更改。
- en: Internals are usually hidden behind non-public methods; to test them, the code
    needs to change to public, which violates OOP’s encapsulation.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部代码通常隐藏在非公共方法后面；要测试它们，代码需要更改以公开，这违反了面向对象封装的原则。
- en: A single behavior per test
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个测试一个行为
- en: Now that the definition of behavior is clear, we can clarify what testing a
    single behavior means. Testing a single behavior works alongside the Intention
    guideline. If we are targeting a single behavior, our test will promote a better
    intention and more readability, and when it fails, we are supposed to pinpoint
    the reason promptly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在行为定义已经明确，我们可以澄清测试单个行为意味着什么。测试单个行为与意图指南并行工作。如果我们针对单个行为，我们的测试将促进更好的意图和可读性，当它失败时，我们应迅速找出原因。
- en: 'Single-behavior testing is made up of a SUT, a single condition, a single expectation,
    and minimal assertions. The unit test signatures in the previous list (section:
    *Testing external behavior only*) are examples of targeting a single behavior.
    Also, all the examples in this book follow the same guidelines.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 单个行为测试由一个SUT（系统单元）、一个条件、一个期望和最小断言组成。前述列表（章节：*仅测试外部行为*）中的单元测试签名是针对单个行为的例子。此外，本书中的所有示例都遵循相同的指南。
- en: '*A unit test method should test a single behavior and never test internals.*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*单元测试方法应该测试单个行为，而永远不应该测试内部结构*。'
- en: The Thoroughness guideline
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完整性指南
- en: 'When unit testing some naturally occurring questions are as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行单元测试时，以下是一些自然出现的问题：
- en: How many tests are enough?
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要进行多少测试才算足够？
- en: Do we have a test coverage metric?
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否有测试覆盖率指标？
- en: Should we test third-party components?
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否应该测试第三方组件？
- en: What system components should we unit test and what should we leave?
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该对哪些系统组件进行单元测试，以及我们应该留下哪些？
- en: The Thoroughness guideline attempts to set the answers to these questions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 完整性指南试图为这些问题的答案设定标准。
- en: Unit tests for dependency testing
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖项测试的单元测试
- en: When you encounter a dependency, whether this dependency is part of your system
    or a third-party dependency, you create a test double for it and isolate it in
    order to test your SUT.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当你遇到依赖项时，无论这个依赖项是否是系统的一部分还是第三方依赖项，你都会为它创建一个测试替身，并将其隔离以测试你的SUT。
- en: 'In unit tests, you do not directly call a third-party dependency; otherwise,
    your code will be an integration test and with that, you lose all the benefits
    of unit tests. For example, in unit tests, you do not call this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，你不会直接调用第三方依赖项；否则，你的代码将变成集成测试，这样你就失去了单元测试的所有好处。例如，在单元测试中，你不会调用以下内容：
- en: '`_someZipLibrary.Zip(fileSource, fileDestination);`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`_someZipLibrary.Zip(fileSource, fileDestination);`'
- en: For testing this, you create a test double for the `.zip` library to avoid calling
    the real thing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，你为`.zip`库创建一个测试替身，以避免调用真实的东西。
- en: This is an area that unit tests do not and should not cover, which leaves us
    with a coverage issue as some areas of the code are not unit-testable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个单元测试不覆盖且不应该覆盖的领域，这导致我们面临覆盖率问题，因为代码的某些部分无法进行单元测试。
- en: To test the interaction with dependencies and solve the previous problem of
    not being able to unit test some code, other types of tests can be employed, such
    as Sintegration, integration, and acceptance tests.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试与依赖项的交互并解决之前无法对某些代码进行单元测试的问题，可以采用其他类型的测试，例如S集成测试、集成测试和验收测试。
- en: We started to speak about *coverage*; now we can dig deeper into the topic.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始讨论*覆盖率*；现在我们可以更深入地探讨这个话题。
- en: What is code coverage?
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码覆盖率是什么？
- en: 'The first step in understanding thoroughness is understanding code coverage.
    **Code coverage** is the percentage of the system code lines executed by your
    tests (unit, Sintegration, integration, and so on) from the total system lines.
    Let’s assume we have a method that returns if an integer is even:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 理解完整性的第一步是理解代码覆盖率。**代码覆盖率**是您的测试（单元、S集成、集成等）从总系统行中执行的系统代码行的百分比。假设我们有一个返回整数是否为偶数的方法：
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s have a unit test that tests if a number is even:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个单元测试来测试一个数字是否为偶数：
- en: '`public void IsEven_EvenNumber_ReturnsTrue() {…}`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`public void IsEven_EvenNumber_ReturnsTrue() {…}`'
- en: This unit test would have covered the `if` line but it wouldn’t have executed
    the `else` line. This constitutes 50% code coverage. Obviously, having another
    test to test an odd number would have led to 100% coverage.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单元测试会覆盖`if`行，但不会执行`else`行。这构成了50%的代码覆盖率。显然，如果有另一个测试来测试奇数，就会达到100%的覆盖率。
- en: It is important to realize that code coverage is not necessarily the unit test
    coverage only, but it might be a combination of unit tests, Sintegration tests,
    and integration tests. However, out of all tests, unit tests usually cover the
    biggest chunk of the code, as they are easier to write than other tests. Also,
    when using the TDD style, you get high coverage as soon as the feature is implemented,
    as all relevant unit tests are already supplied.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到代码覆盖率并不一定是单元测试覆盖率，它可能是单元测试、集成测试和集成测试的组合。然而，在所有测试中，单元测试通常覆盖了代码的最大部分，因为它们比其他测试更容易编写。此外，在使用
    TDD 风格时，一旦实现了功能，您就会获得高覆盖率，因为所有相关的单元测试已经提供。
- en: Coverage measurement tools
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖率测量工具
- en: 'To measure how much of your code is covered by your tests, usually, you measure
    it in the **Continuous Integration** (**CI**) pipeline (which will be discussed
    in [*Chapter 11*](B18370_11.xhtml#_idTextAnchor265), *Implementing Continuous
    Integration with GitHub Actions*, of the book) and/or on the development machine.
    There are plenty of commercial options for running test coverage and a limited
    number of free options. Here are a few examples:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要测量您的代码被测试覆盖了多少，通常您会在 **持续集成**（**CI**）（将在本书的 [*第 11 章*](B18370_11.xhtml#_idTextAnchor265)，*使用
    GitHub Actions 实现持续集成* 中讨论）和/或开发机器上测量。有大量的商业选项用于运行测试覆盖率，以及有限的免费选项。以下是一些示例：
- en: NCover – commercial
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NCover – 商业版
- en: dotCover – commercial
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dotCover – 商业版
- en: NCrunch – commercial
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NCrunch – 商业版
- en: VS Enterprise code coverage – commercial
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VS Enterprise 代码覆盖率 – 商业版
- en: SonarQube – commercial and community
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SonarQube – 商业版和社区版
- en: AltCover – free
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AltCover – 免费版
- en: FCC – free plugin for VS
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FCC – VS 的免费插件
- en: 'If you want to see how code coverage works, you can install FCC by following
    these steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解代码覆盖率是如何工作的，可以按照以下步骤安装 FCC：
- en: From the menu, select **Extensions** | **Manage Extensions** and the **Manage
    Extensions** dialog will open.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择 **扩展** | **管理扩展**，将打开 **管理扩展** 对话框。
- en: Select **Online** | **Visual Studio Marketplace**.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **在线** | **Visual Studio Marketplace**。
- en: Search for `Fine Code Coverage` and then select **Download**.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 `细粒度代码覆盖率` 并选择 **下载**。
- en: '![Figure 5.2 – Installing FCC dialog ](img/Figure_6.2_B18370.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 安装 FCC 对话框](img/Figure_6.2_B18370.jpg)'
- en: Figure 5.2 – Installing FCC dialog
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 安装 FCC 对话框
- en: Restart VS.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动 VS。
- en: 'After installation, you can open the project from [*Chapter 3*](B18370_03.xhtml#_idTextAnchor066),
    *Getting Started with Unit Testing* and execute all your unit tests (**Test**
    | **Run All Tests**). This tool will be triggered automatically after several
    seconds of executing the tests. To see the results, a panel like the following
    one will appear at the bottom of VS to show you the results:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，您可以从 [*第 3 章*](B18370_03.xhtml#_idTextAnchor066)，*开始单元测试* 中打开项目并执行所有单元测试（**测试**
    | **运行所有测试**）。在执行测试几秒钟后，此工具将自动触发。要查看结果，将出现如下面板，显示在 VS 底部：
- en: '![Figure 5.3 – FCC analysis results ](img/Figure_6.3_B18370.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – FCC 分析结果](img/Figure_6.3_B18370.jpg)'
- en: Figure 5.3 – FCC analysis results
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – FCC 分析结果
- en: If you can’t see this panel, you might need to go, from the menu, to **View**
    | **Other Windows** | **Fine Code Coverage**.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看不到此面板，您可能需要从菜单中转到 **查看** | **其他窗口** | **细粒度代码覆盖率**。
- en: I am only interested in the production code cover, which is `Uqs.Weather` in
    this example. I can see that my total coverage is 55.2%.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我只对生产代码覆盖率感兴趣，在这个例子中是 `Uqs.Weather`。我可以看到我的总覆盖率是 55.2%。
- en: We will speak further about the previous code coverage results in the next few
    sections.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几节中进一步讨论之前的代码覆盖率结果。
- en: Unit test coverage spectrum
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试覆盖率范围
- en: 'Unit tests are excellent for testing the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试非常适合测试以下内容：
- en: Business logic
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务逻辑
- en: Validation logic
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证逻辑
- en: Algorithms
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法
- en: Interaction between components (not to be confused with integration between
    components)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件之间的交互（不要与组件之间的集成混淆）
- en: 'On the other hand, unit tests are not optimal for testing the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，单元测试并不适用于以下方面的测试：
- en: Integration between components – the call from component A passing through to
    component B, such as getting info from the database and analyzing the data
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件之间的集成 – 从组件 A 通过到组件 B 的调用，例如从数据库获取信息并分析数据
- en: Service booting components – such as `Program.cs`
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务启动组件，例如 `Program.cs`
- en: Direct call to dependencies (dependency testing, as discussed earlier)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接调用依赖项（如前所述的依赖项测试）
- en: 'Wrappers wrapping real components – such as `RandomWrapper` in the following
    example:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装真实组件的封装器 – 例如以下示例中的`RandomWrapper`：
- en: '[PRE12]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Unit tests should have no interest in testing anything in this class, as this
    is wrapping the real components directly.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试不应该对这个类中的任何内容感兴趣进行测试，因为这个类直接封装了真实组件。
- en: Now, if we go back to the results of the code coverage, it is clear why we have
    0% coverage for `Program.cs`, `NowWrapper.cs`, and `RandomWrapper.cs`. It is best
    that the code in these files is not tested by unit tests and we haven’t done that.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们回到代码覆盖率的成果，很明显为什么`Program.cs`、`NowWrapper.cs`和`RandomWrapper.cs`的覆盖率是0%。最好这些文件中的代码不要通过单元测试进行测试，而我们还没有这样做。
- en: '`WeatherForecastController` is 80% covered. You can open the file to see what
    FCC highlights.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeatherForecastController`的覆盖率是80%。你可以打开文件查看FCC的突出显示。'
- en: '![Figure 5.4 – Highlights from FCC ](img/Figure_6.4_B18370.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – FCC的突出显示](img/Figure_6.4_B18370.jpg)'
- en: Figure 5.4 – Highlights from FCC
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – FCC的突出显示
- en: It looks like not even a single line in `GetRandom` is tested as all are *red*.
    I might have not targeted this method in any of my tests. Obviously, having a
    complete method that is not tested would not have happened if I were using TDD;
    however, this is a method that comes with the VS sample code for the ASP.NET project.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来`GetRandom`中的每一行都没有被测试，因为它们都是红色的。我可能在我的任何测试中都没有针对这个方法。显然，如果没有使用TDD，一个完整的方法没有被测试是不会发生的；然而，这是一个随VS示例代码一起提供的ASP.NET项目的示例方法。
- en: Now that we understand what code coverage is and what can be covered, we can
    describe what being *thorough* in testing is.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了代码覆盖率是什么以及什么可以被覆盖，我们可以描述一下在测试中要全面是什么意思。
- en: Being thorough
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要全面
- en: Clearly, the best coverage level is 100%; or at least this should be the intention,
    but it is not easily achievable and sometimes, it isn’t worth the cost and effort
    to achieve it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，最佳的覆盖率水平是100%；或者至少这应该是目标，但它并不容易实现，有时，达到它并不值得付出成本和努力。
- en: First, as discussed, unit tests are not meant to provide 100% coverage, so they
    need to be backed up by other categories of tests. If we want to achieve 100%
    coverage using unit tests, we will shoehorn unit tests to test things that are
    not best suited for unit tests.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正如讨论的那样，单元测试的目的不是提供100%的覆盖率，因此它们需要由其他测试类别的测试来补充。如果我们想通过单元测试实现100%的覆盖率，我们将不得不强行将单元测试用于不适合单元测试的事情。
- en: Being thorough is doing a combination of unit testing, Sintegration testing,
    integration testing, and user acceptance testing.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要全面就是结合单元测试、S集成测试、集成测试和用户验收测试。
- en: The cost, time, and quality triangle
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 成本、时间和质量三角
- en: 'This is probably not the first time you’ve heard of this concept. It is a project
    management one and is not specific to software engineering. Here is the popular
    triangle:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是你第一次听到这个概念。这是一个项目管理概念，并不特定于软件工程。以下是流行的三角：
- en: '![Figure 5.5 – The cost, time, and quality triangle ](img/Figure_6.5_B18370.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 成本、时间和质量三角](img/Figure_6.5_B18370.jpg)'
- en: Figure 5.5 – The cost, time, and quality triangle
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 成本、时间和质量三角
- en: '**Quality** in our triangle represents how thorough we want to be. It is clearly
    a function of **Time** and **Cost**.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**质量**在我们的三角中代表我们希望多么全面。它显然是**时间**和**成本**的函数。'
- en: Testing, in general, is a time-consuming process and unit testing takes as much
    time, if not more, as writing production code. Unit tests are written by the same
    developers as the production code and they are not usually things that are done
    in parallel; they are done in series. The red-green-refactor process of TDD is
    done by the same individual or the team writing the code, not by a separate tester
    doing this in parallel.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，测试是一个耗时的过程，单元测试所需的时间与编写生产代码所需的时间相当，甚至更多。单元测试是由编写生产代码的同一开发者编写的，它们通常不是并行完成的事情；它们是按顺序完成的。TDD的红色-绿色-重构流程是由编写代码的同一个人或团队完成的，而不是由一个单独的测试人员在并行中进行。
- en: How thorough?
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多么全面？
- en: Aiming for over 80% coverage is good. 95% coverage is the max you would be able
    to have with reasonable effort. This is only the case for the combination of unit
    testing with Sintegration or unit testing with integration. Acceptance testing
    does not usually count toward your coverage.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 目标超过80%的覆盖率是好的。95%的覆盖率是在合理努力下可以达到的最大值。这仅适用于单元测试与S集成测试或单元测试与集成测试的组合。验收测试通常不计入覆盖率。
- en: Being more thorough and aiming for higher coverage is a matter of more time
    and cost. So, the question of how much coverage is a question for project management
    and your team.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 更加彻底并追求更高的覆盖率是更多时间和成本的问题。因此，覆盖率多少的问题是一个项目管理以及你团队的问题。
- en: '*Being thorough is aiming for high coverage using a combination of unit tests
    with Sintegration tests or unit tests with integration tests. This is taking into
    consideration the time, money, and quality triangle.*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*追求彻底是使用单元测试与S集成测试或单元测试与集成测试的组合来达到高覆盖率。这是在考虑时间、成本和质量三角关系。*'
- en: The High-Performance guideline
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高性能指南
- en: Your unit tests should not take, in today’s hardware, over 5 seconds to run,
    ideally no more than a couple of seconds after the tests are loaded. But why all
    this fuss? Can’t we just let them take whatever time is needed to run without
    sweating over it?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的硬件上，你的单元测试运行时间不应超过5秒，理想情况下，在测试加载后不超过几秒钟。但为什么会有这么多麻烦？我们难道不能让他们以所需的时间运行，而不必为此烦恼吗？
- en: First, your unit tests will have to run many times throughout the day. TDD is
    about running a chunk of your unit tests or all of them with every change; therefore,
    you don’t want to spend your time waiting and lose valuable time that could be
    spent more productively.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你的单元测试将在一天中多次运行。TDD是关于每次更改时运行你的一部分单元测试或所有单元测试；因此，你不想浪费时间等待，从而失去本可以更有效地利用的时间。
- en: Second, your unit tests need to provide fast feedback to your CI pipeline. You
    want your source control branches to be green all the time, so that other developers
    are pulling green code at any given time and, of course, it is ready to ship to
    production. This is even more important for larger teams.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，你的单元测试需要为你的CI管道提供快速的反馈。你希望你的源代码控制分支始终保持绿色，这样其他开发者就可以在任何时候拉取绿色代码，当然，这也意味着它已经准备好可以部署到生产环境中。这对大型团队来说尤为重要。
- en: So, how do you keep your unit tests performing as fast as possible? We will
    attempt to answer this question in the next sections.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你如何保持你的单元测试尽可能快地执行？我们将在下一节尝试回答这个问题。
- en: Integration as disguised units
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成作为伪装的单位
- en: I have seen this in many projects, where developers call their integration tests
    unit tests just because they are executed by NUnit or xUnit.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我在许多项目中都见过这种情况，开发者只是因为他们的集成测试是由NUnit或xUnit执行的，就将它们称为单元测试。
- en: Integration tests are slow by nature as they are doing IO operations, such as
    writing or reading from the disk, going to the database, and going over the network.
    These operations consume time and result in tests that take minutes or more to
    run.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试由于进行IO操作（如写入或读取磁盘、访问数据库和通过网络）而本身较慢。这些操作消耗时间，导致测试运行需要几分钟或更长时间。
- en: Unit tests use test doubles and rely on memory and CPU to run. Running 10K unit
    tests should take seconds after project load, so *make sure you are not executing
    integration tests*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试使用测试替身，并依赖于内存和CPU来运行。在项目加载后运行10K个单元测试应该只需几秒钟，所以*请确保你并没有执行集成测试*。
- en: CPU- and memory-intensive unit tests
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU和内存密集型单元测试
- en: You might be doing unit tests that rely on math libraries that are not treated
    as test doubles or you might have code that involves sophisticated logic.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在进行依赖数学库的单元测试，而这些库没有被当作测试替身，或者你可能有一些涉及复杂逻辑的代码。
- en: You can have multiple categories of unit tests that can be executed at different
    times. xUnit calls this feature a **trait**. You can have a trait to indicate
    slow tests.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以有多个可以在不同时间执行的单元测试类别。xUnit将此功能称为**特性**。你可以有一个特性来指示慢速测试。
- en: '*You can execute faster tests during your TDD and all tests before pushing
    to* *the codebase (source control).*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以在TDD期间执行更快的测试，并在将代码推送到* *代码库（源代码控制）* *之前执行所有测试。*'
- en: Having too many tests
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试过多
- en: Let’s assume that after becoming a TDD guru and reaching 100K tests, you start
    having tests that are taking over 5 seconds.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经成为TDD大师并达到了10K个测试，你开始遇到运行时间超过5秒的测试。
- en: 'I would directly ask:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我会直接问：
- en: '*Do you have a bloated monolith type of project?*'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你的项目是不是那种臃肿的单一类型？*'
- en: '*What is your problem: slow tests or a project that should be divided into
    microservices?*'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你的问题是什么：慢速测试还是应该拆分为微服务的项目？*'
- en: A temporary solution for this issue is having multiple VS solutions and figuring
    out how to divide related projects into various solutions.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题的一个临时解决方案是拥有多个VS解决方案，并找出如何将相关项目划分到不同的解决方案中。
- en: '*Having too many tests is a sign of weak architecture*. Employing an alternative
    architecture, such as microservices, can be considered and the unit tests problem
    may be sorted out automatically.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*过多的测试是架构薄弱的迹象。可以考虑采用替代架构，如微服务，这可能自动解决单元测试问题。*'
- en: '*High-performance unit tests are something you strive for from day one and
    keep in check while building your project.*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*高性能单元测试是你从第一天开始就追求的，并在构建项目时保持检查的。*'
- en: The Automation guideline
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化指南
- en: When we say automation, we mean CI. CI has a dedicated chapter in this book,
    [*Chapter 11*](B18370_11.xhtml#_idTextAnchor265), *Implementing Continuous Integration
    with GitHub Actions*, so we won’t go into the details here.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说自动化时，我们指的是持续集成（CI）。这本书中有一章专门介绍CI，即第11章[*第11章*](B18370_11.xhtml#_idTextAnchor265)，*使用GitHub
    Actions实现持续集成*，所以我们在这里不会深入细节。
- en: This guideline is about realizing that the unit tests will run on other platforms
    than your local development machine. So, how do you make sure your unit tests
    are ready for automation?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指南是关于意识到单元测试将在除本地开发机器以外的其他平台上运行。那么，你如何确保你的单元测试为自动化做好准备？
- en: CI automation from day 1
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从第一天开始进行CI自动化
- en: Agile teams dedicate the first sprint to setting up the environment, including
    the CI pipeline. This is usually called sprint or iteration zero. If CI is set
    up from day 1 to listen to source control, there is less chance it is omitted
    or a CI-incompatible test is introduced.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷团队将第一个冲刺用于设置环境，包括CI管道。这通常被称为冲刺或零迭代。如果从第一天开始设置CI以监听源代码控制，那么它被省略或引入了不兼容CI的测试的可能性就会更小。
- en: '*Implement CI from the start of the project.*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*从项目开始就实施CI。*'
- en: Platform-independent
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台无关性
- en: .NET is multi-platform and the trend nowadays is to use Linux servers to run
    CI pipelines. Also, the developer dev machine can be Windows, macOS, or Linux.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: .NET是多平台的，现在的趋势是使用Linux服务器来运行CI管道。此外，开发者的开发机器可以是Windows、macOS或Linux。
- en: '*Make sure your code does not rely on any OS-specific features*, if not really
    needed, so that you can have a free choice of which OS to use for the CI pipeline.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*确保你的代码不依赖于任何特定于OS的功能，如果不是真的需要，这样你就可以自由选择用于CI管道的操作系统。*'
- en: High performance on CI
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI上的高性能
- en: CI pipelines, nowadays, are leased services from CI providers such as Azure
    DevOps or GitHub Actions. These leased services are low in resources (CPU and
    memory) and are shared between multiple projects.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，CI管道通常是来自Azure DevOps或GitHub Actions等CI提供商的租赁服务。这些租赁服务资源有限（CPU和内存），并在多个项目之间共享。
- en: It is fair to say that tests will take double the time, if not more, to run
    on a CI pipeline in comparison to your local machine, assuming that you have a
    decent dev machine and you are not paying a fortune for your CI resources.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有不错的开发机器，并且没有为CI资源支付巨额费用，那么可以公平地说，测试的运行时间将是本地机器的两倍，甚至更多。
- en: This reiterates the fact that having high-performing tests is necessary.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这重申了高性能测试是必要的这一事实。
- en: '*Make sure whatever test you write on your dev machine is ready to run on CI*.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*确保你在开发机器上编写的任何测试都准备好在CI上运行。*'
- en: The No Interdependency guideline
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无依赖性指南
- en: 'First, I would like to elevate this from a guideline to a principle. This principle
    ensures that the unit test does not alter a state permanently; or, in other words,
    executing a unit test should not persist data. Based on this principle, we have
    the following rules:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我想把这个从指南提升为一个原则。这个原则确保单元测试不会永久更改状态；换句话说，执行单元测试不应持久化数据。基于这个原则，我们有以下规则：
- en: Test A shouldn’t affect test B.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试A不应该影响测试B。
- en: It doesn’t matter whether test A runs before test B.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试A是否在测试B之前运行无关紧要。
- en: It doesn’t matter whether we run test A and test B in parallel.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否并行运行测试A和测试B无关紧要。
- en: If you think about it, a unit test is creating test doubles and doing its operations
    in memory, and as soon as it finishes execution, all the changes are lost, except
    the test report. Nothing is saved in the database, in a file, or anywhere, because
    these dependencies were all provided as test doubles.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，单元测试就是在创建测试替身并在内存中执行其操作，一旦执行完成，所有的更改都会丢失，除了测试报告。因为所有这些依赖项都作为测试替身提供的，所以数据库、文件或任何地方都没有保存任何内容。
- en: Having this principle in place also ensures that the test runner, such as Test
    Explorer, can run the tests in parallel and use multi-threading if needed.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个原则，也确保测试运行器，如测试资源管理器，可以并行运行测试，并在需要时使用多线程。
- en: Ensuring this principle is a shared responsibility between the unit testing
    framework and the developer.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 确保这一原则是单元测试框架和开发者之间的共同责任。
- en: Unit testing framework responsibility
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试框架的责任
- en: 'The unit testing framework should make sure that the unit test class is re-initialized
    after executing each unit test method. A unit test class should not maintain the
    state in the same way that a normal class maintains the state. Let me demonstrate
    with an example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试框架应确保在执行每个单元测试方法后重新初始化单元测试类。单元测试类不应以与普通类维护状态相同的方式维护状态。让我用一个例子来演示：
- en: '[PRE13]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When a unit testing framework runs `UnitTest1` and `UnitTest2`, it should not
    run them from the same object; it creates a new object for each method run. This
    means that they do not share instance fields. Otherwise, if `UnitTest1` runs before
    `UnitTest2`, then we should be asserting for `6`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当单元测试框架运行`UnitTest1`和`UnitTest2`时，它不应该从同一个对象中运行它们；它为每个方法运行创建一个新的对象。这意味着它们不共享实例字段。否则，如果`UnitTest1`在`UnitTest2`之前运行，那么我们应该断言`6`。
- en: Important Note
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Modifying an instance field in a method, then asserting it in the same method,
    is not a good unit testing practice, but it has been done for demonstration purposes.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法中修改实例字段，然后在同一方法中对其断言，这不是好的单元测试实践，但为了演示目的，已经这样做了。
- en: xUnit does follow this principle of making sure the state is not shared. However,
    it can be instructed otherwise by using a static member.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit遵循确保状态不共享的原则。然而，可以通过使用静态成员来指示它做相反的事情。
- en: Developer’s responsibility
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发者的责任
- en: As a developer, you know that you should not persist data during a unit test.
    Otherwise, this is, by definition, not a unit test.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，你知道你不应该在单元测试期间持久化数据。否则，这从定义上讲，就不再是单元测试。
- en: 'If a developer is using test doubles to replace the database, the network,
    and other dependencies, they are respecting this rule by virtue. However, the
    problem arises if the developer decides to use static fields. Static fields will
    preserve the state between independent method calls. Let’s take this example:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者使用测试替身来替换数据库、网络和其他依赖项，他们通过这种方式遵守了这一规则。然而，如果开发者决定使用静态字段，问题就出现了。静态字段将在独立方法调用之间保留状态。让我们来看一个例子：
- en: '[PRE14]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The previous code fails this rule, as running `UnitTest2` before `UnitTest1`
    will fail the test. Actually, there is no guarantee that the second method will
    run after the first one based on their order in the class.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码违反了这一规则，因为在运行`UnitTest1`之前运行`UnitTest2`将导致测试失败。实际上，根据它们在类中的顺序，无法保证第二个方法会在第一个方法之后运行。
- en: 'There are instances where using static fields would promote better performance.
    Say we have an in-memory read-only database that we need to use in all tests.
    Also assume that this is taking a long time to initialize, such as 100 ms:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下使用静态字段可以提升性能。比如说，我们有一个需要用于所有测试的内存中只读数据库。假设初始化这个数据库需要很长时间，比如100毫秒：
- en: '[PRE15]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The field is read-only and the content of the class is also read-only, such
    as `readonly record`. Although, for this scenario, I argue if you need all the
    territories, or can you create a cutdown version suitable for unit testing? This
    might speed up loading and can remove the need for a static field.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 字段是只读的，类的内容也是只读的，例如`readonly record`。尽管如此，对于这种情况，我争论如果你需要所有领土，或者你能创建一个适合单元测试的简化版本吗？这可能加快加载速度，并可以消除对静态字段的需求。
- en: As a developer, you should be careful not to create a state between multiple
    unit tests. This is easy to miss if you are new to the unit testing field.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，你应该小心不要在多个单元测试之间创建状态。如果你是单元测试领域的初学者，这很容易忽略。
- en: '*No interdependency leads to easier-to-maintain code and reduces bugs in unit
    tests.*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*没有相互依赖导致代码更容易维护，并减少了单元测试中的错误。*'
- en: The Deterministic guideline
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定性指南
- en: 'A unit test should have a deterministic behavior and should lead to the same
    result. This should be the case regardless of the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该具有确定性行为，并应导致相同的结果。这应该不受以下因素的影响：
- en: '**Time**: This includes changes in time zone and testing at different times.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间**：这包括时区变化和在不同时间进行测试。'
- en: '**Environment**: Such as the local machine or CI/CD server.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境**：例如本地机器或CI/CD服务器。'
- en: Let’s discuss some cases where we risk making non-deterministic unit tests.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些可能导致非确定性单元测试的情况。
- en: Non-deterministic cases
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非确定性情况
- en: 'There are cases that can lead to non-deterministic unit tests. Here are a few
    of them:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况可能导致非确定性单元测试。以下是一些例子：
- en: Having interdependent unit tests, such as a test that writes to a static field.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有相互依赖的单元测试，例如写入静态字段的测试。
- en: Loading a file with an absolute path as the file location on the development
    machine will not match that on the automation machine.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发机器上将具有绝对路径的文件作为文件位置加载的文件将不会与自动化机器上的匹配。
- en: Accessing a resource that requires higher privileges. This can work, for example,
    when running VS as an admin but may fail when running from a CI pipeline.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问需要更高权限的资源。例如，当以管理员身份运行 VS 时，这可能有效，但可能从 CI 管道运行时失败。
- en: Using randomization methods without treating them as dependencies.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用随机化方法而不将其视为依赖项。
- en: Depending on the system’s time without treating it as a dependency.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于系统时间而不将其视为依赖项。
- en: Next, we will see a case of not depending on varying time, to make our unit
    test deterministic.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到一个不依赖于变化时间的案例，以使我们的单元测试具有确定性。
- en: Example of freezing time
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冻结时间的示例
- en: 'If your test relies on time, you should be using a test double to freeze the
    time to ensure a deterministic test. Here is an example:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的测试依赖于时间，你应该使用测试替身来冻结时间，以确保测试具有确定性。以下是一个示例：
- en: '[PRE16]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is a wrapper to allow injecting the current time as a dependency. To register
    the wrapper in `Program.cs`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包装器，允许将当前时间作为依赖项注入。要在 `Program.cs` 中注册包装器：
- en: '[PRE17]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Your service can look like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 您的服务可以看起来像这样：
- en: '[PRE18]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The calculation in the preceding code is for demo purposes and does not take
    into account daylight saving. To inject the current time from the unit tests:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的计算仅用于演示目的，并未考虑夏令时。要从单元测试中注入当前时间：
- en: '[PRE19]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous unit test has frozen the current time to a specified value. This
    made the code independent from the OS’s clock and thus made it deterministic.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的单元测试已将当前时间冻结到指定的值。这使得代码独立于操作系统的时钟，从而使其具有确定性。
- en: '*Running a unit test should always yield the same results, regardless of time
    or environmental factors.*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*运行单元测试应始终产生相同的结果，无论时间或环境因素如何。*'
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: FIRSTHAND accumulates valuable guidelines and best practices in the industry.
    I trust this chapter topped up the learnings of the previous chapters to help
    you understand TDD and its ecosystem. I also hope that it made these guidelines
    memorable as TDD comes up often in developer discussions and it is certainly likely
    to be an interview topic.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: FIRSTHAND 在行业中积累了宝贵的指南和最佳实践。我相信这一章补充了前几章的学习，帮助你理解 TDD 和其生态系统。我也希望它使这些指南记忆深刻，因为
    TDD 经常出现在开发者讨论中，并且它肯定是一个面试话题。
- en: This chapter marks the end of this section, where we looked at dependency injection,
    unit testing, and TDD. This section was only an introduction to TDD, with scattered
    small and mid-size examples. If you’ve made it to this point, then hats off, you
    have covered the basics of TDD.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本章标志着本节的结束，我们在这里探讨了依赖注入、单元测试和 TDD。本节只是对 TDD 的一个介绍，包含了一些零散的小型和中等示例。如果你已经到达这个位置，那么恭喜你，你已经掌握了
    TDD 的基础知识。
- en: The next section will take all the basics and apply them to more lifelike scenarios.
    To make sure that you are ready for this application and to mimic a realistic
    application that uses TDD, our next chapter will be about **domain-driven design**
    (**DDD**) as you will be using the DDD concepts in later chapters.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将把所有基础知识应用到更贴近现实场景中。为了确保你为这个应用程序做好准备，并模仿使用 TDD 的现实应用程序，我们的下一章将关于 **领域驱动设计**
    (**DDD**)，因为你将在后面的章节中使用 DDD 概念。
- en: 'Part 2: Building an Application with TDD'
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：使用 TDD 构建应用程序
- en: TDD is usually combined with a **Domain-Driven Design** (**DDD**) architecture.
    In this part, we will take what we’ve learned in *Part 1* and use it to build
    a complete application using TDD and DDD; in one instance, we will use a relational
    DB ([*Chapter 9*](B18370_09.xhtml#_idTextAnchor226)), and in another, a document
    DB ([*Chapter 10*](B18370_10.xhtml#_idTextAnchor245)) to show how this would affect
    our unit test implementation.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 通常与 **领域驱动设计** (**DDD**) 架构结合使用。在本部分中，我们将结合我们在 *第 1 部分* 中学到的知识，使用 TDD 和
    DDD 构建一个完整的应用程序；在一个实例中，我们将使用关系型数据库 ([*第 9 章*](B18370_09.xhtml#_idTextAnchor226))，在另一个实例中使用文档数据库
    ([*第 10 章*](B18370_10.xhtml#_idTextAnchor245)) 来展示这将对我们的单元测试实现产生什么影响。
- en: 'By the end of this part, you should be able to build an application using TDD
    and DDD from scratch. The following chapters are included in this part:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 到本部分结束时，你应该能够从头开始使用 TDD 和 DDD 构建应用程序。本部分包括以下章节：
- en: '[*Chapter 7*](B18370_07.xhtml#_idTextAnchor183), *A Pragmatic View of Domain-Driven
    Desig*'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 7 章*](B18370_07.xhtml#_idTextAnchor183)，*对领域驱动设计的实用观点*'
- en: '[*Chapter 8*](B18370_08_RN.xhtml#_idTextAnchor209), *Designing an Appointment
    Booking App*'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18370_08_RN.xhtml#_idTextAnchor209), *设计预约应用*'
- en: '[*Chapter 9*](B18370_09.xhtml#_idTextAnchor226), *Building an Appointment Booking
    App with Entity Framework and Relational DB*'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18370_09.xhtml#_idTextAnchor226), *使用Entity Framework和关系型数据库构建预约应用*'
- en: '[*Chapter 10*](B18370_10.xhtml#_idTextAnchor245), *Building an App with Repositories
    and Document DB*'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18370_10.xhtml#_idTextAnchor245), *使用仓储和文档数据库构建应用*'
