- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Visual Effects
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视觉效果
- en: The game does not currently have all of its features. We’ve gone from concept
    to blockout, then developed the game into a state where it is playable. This doesn’t
    mean we are finished quite yet! We need to look at how we can bring more emotional
    immersion to the player. Luckily for us, Unity provides fantastic assets and tools
    for us to take the current state of our game and visually turn it up another notch.
    This is done through various vehicles, such as shaders, particles, and other polishing
    tools that we will cover in *Chapter 12*, *Final Touches*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 目前游戏还没有全部的功能。我们已经从概念到草图，然后将游戏开发到可玩的状态。但这并不意味着我们马上就完成了！我们需要考虑如何让玩家有更多的情感沉浸感。幸运的是，Unity
    为我们提供了出色的资源和工具，让我们能够将游戏当前的状态提升到一个新的视觉层次。这是通过各种方式实现的，例如着色器、粒子和其他将在 *第 12 章，最终润色*
    中介绍的抛光工具。
- en: These topics are very complex. For now, we will go over the main focus of visual
    effects by looking at shaders and particles at a high level. Then, we will progress
    to an overview of their advanced forms. Because we are using the **Universal Render
    Pipeline** (**URP**) for this project, we will go over important tools such as
    Shader Graph, VFX Graph, and Shuriken. Shader Graph visually displays shader detailing
    and coding. VFX Graph was created to help you understand the various properties
    of GPU particles. Shuriken, a CPU-focused particle authoring tool, is available
    in all render pipelines. We will cover that as well.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题非常复杂。目前，我们将通过查看着色器和粒子来概述视觉效果的主要焦点。然后，我们将进一步概述它们的更高级形式。因为我们在这个项目中使用的是 **通用渲染管线**（**URP**），我们将介绍一些重要工具，如着色器图形、VFX
    图形和 Shuriken。着色器图形以视觉方式显示着色器的详细信息和编码。VFX 图形是为了帮助你理解 GPU 粒子的各种属性而创建的。Shuriken 是一个以
    CPU 为重点的粒子创作工具，在所有渲染管线中都有提供。我们也会介绍这一点。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Visual effects overview
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视觉效果概述
- en: Shader Graph
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色器图形
- en: 'Particle Systems:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子系统：
- en: Shuriken
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shuriken
- en: VFX Graph
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: VFX 图形
- en: Visual effects overview
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视觉效果概述
- en: Getting started with visual effects may feel daunting at the onset. We currently
    have a simple scene. The world won’t feel alive and immersive without time spent
    making deliberate answers to questions needing to be solved to progress the narrative
    and design of the game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用视觉效果可能会感到有些令人畏惧。我们目前有一个简单的场景。如果不花时间有意识地回答需要解决的问题，世界就不会感觉生动和沉浸。
- en: 'Throughout this book, you’ve worked through many general game design questions.
    You’ve been able to answer them yourself and may use them for any project you
    may want to work on. Then, you were given the answers we discovered ourselves
    while creating this project and how it would move forward. We had a pretty good
    idea of what the feel would be for the player: fantasy exploration in the simplest
    of terms. We now need to be able to go through our scene and find areas in which
    we need a touch more fantasy. Exploration is done through the mechanics and narrative
    design.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你已经处理了许多通用的游戏设计问题。你能够自己回答这些问题，并且可以使用它们来完成任何你想要工作的项目。然后，你得到了我们在创建这个项目时自己发现的答案以及它将如何发展。我们对玩家的感受有了一个相当好的想法：用最简单的话说，就是幻想探险。我们现在需要能够遍历我们的场景，找到需要更多幻想的地方。探险是通过机制和叙事设计来完成的。
- en: Fantasy is a broad term. We could have gone with any theme really. We decided
    to push through this vague starting point and found a theme of light science fiction
    focused on an ancient race. These beings hold onto the power of the celestial
    bodies of the natural space surrounding them. Working with nature, they at some
    point constructed a cave the player will explore. We need to come up with a way
    to embody this storytelling through visual gameplay, and the player accepting
    themself as the main character of this world is what we are aiming for.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 幻想是一个广泛的概念。我们实际上可以选择任何主题。我们决定克服这个模糊的起点，并找到了一个以古老种族为中心的轻科幻主题。这些生物紧握着他们周围自然空间中天体的力量。与自然合作，他们在某个时刻建造了一个玩家将探索的洞穴。我们需要想出一种方法来通过视觉游戏来体现这种叙事，而玩家接受自己作为这个世界的主角正是我们的目标。
- en: To carry out this visual storytelling, we need to incorporate the multiple visual
    effects tools available in Unity. Shader Graph allows us to build shaders that
    can have interesting properties that play with lights and twinkling effects in
    various ways. Shuriken provides us with particle systems to add ambient dust,
    glowing particles around bioluminescent plants, and simple details of other fantasy
    elements. VFX Graph allows us to push simple particles to the limit and bring
    GPU systems into play. By pushing GPU systems into play, VFX Graph will give us
    the ability to use many particles. Though this isn’t practical, you could spawn
    tens of millions of particles. Finally, we will use the lighting in Unity to provide
    hints to the player for where to look and set the mood and tone of the current
    action, system, or place.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这种视觉叙事，我们需要整合Unity中可用的多种视觉效果工具。Shader Graph允许我们构建具有有趣属性的着色器，这些属性可以以各种方式与光线和闪烁效果互动。Shuriken为我们提供了粒子系统，可以添加环境灰尘、围绕生物发光植物的发光粒子，以及其他幻想元素的简单细节。VFX
    Graph允许我们将简单的粒子推向极限，并使GPU系统发挥作用。通过利用GPU系统，VFX Graph将赋予我们使用许多粒子的能力。尽管这并不实用，但你可能可以生成数千万个粒子。最后，我们将使用Unity中的照明为玩家提供查看提示，并设定当前动作、系统或地点的氛围和基调。
- en: To start this chapter, we will be laying the foundation of terms and going over
    the individual visual effects tools in detail. After these explanations, we can
    then expand upon how we incorporate the tools that Unity has to offer into our
    workspace to create a visually immersive environment. Moving forward, this section
    may become a useful reference point to come back to re-familiarize yourself with
    the tools and their purpose.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始这一章，我们将奠定术语的基础，并详细说明单个视觉效果工具。在这些解释之后，我们可以进一步探讨如何将Unity提供的工具整合到我们的工作空间中，以创建一个视觉沉浸式环境。向前推进，这一部分可能成为一个有用的参考点，以便回来重新熟悉工具及其用途。
- en: Shader Graph
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shader Graph
- en: Shader Graph is a visual scripting tool designed to allow artist-driven shader
    creation. Shaders are scripts that inform the graphics pipeline how to render
    materials. A material is an instance of a shader with parameters set for a certain
    mesh inside of a GameObject. A simple example of this could be leather. If you
    think of leather, you could probably think about many different types of leather.
    What color is it? Is it shiny? Does it have a unique texture? All of these options
    are parameters in the shader that can be set in the material to render the object
    properly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Shader Graph是一个视觉脚本工具，旨在允许艺术家驱动的着色器创建。着色器是脚本，它告诉图形管线如何渲染材质。材质是着色器的一个实例，它为GameObject中的某个网格设置了参数。一个简单的例子是皮革。如果你想到皮革，你可能会想到许多不同类型的皮革。它是哪种颜色？它是闪亮的吗？它有独特的纹理吗？所有这些选项都是着色器中的参数，可以在材质中设置以正确渲染对象。
- en: In Unity, a shader is written in **High-Level Shader Language** (**HLSL**).
    Knowing how to properly write this code requires a detailed understanding of the
    graphics pipeline in your computer and can be a bit daunting to get going. The
    graphics pipeline is a complex conceptual model. Simplified, the computer goes
    through layers and stages to understand what 3D visual graphics are in a scene,
    then takes that information and renders those visuals to a 2D screen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，着色器是用**高级着色器语言**（**HLSL**）编写的。正确编写此代码需要详细了解你计算机中的图形管线，这可能有点令人望而却步。图形管线是一个复杂的概念模型。简化来说，计算机通过多个层次和阶段来理解场景中的3D视觉图形，然后根据这些信息将那些视觉效果渲染到2D屏幕上。
- en: In fact, just reading the paragraph above might’ve seemed a bit confusing. This
    is natural. There are many moving parts here and we will break this down within
    this portion of the chapter. In an effort to not dive in too deep with HLSL, we
    will be focusing purely on Shader Graph. If after spending time in Shader Graph
    you want to move into a more technical position, we recommend learning HLSL and
    handwriting shaders. Once you have learned HLSL and handwriting shaders you will
    have a solid foundation of general shader creation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，仅仅阅读上面的段落可能显得有些困惑。这是自然的。这里有很多动态部分，我们将在本章的这一部分中对其进行分解。为了不深入HLSL，我们将专注于Shader
    Graph。如果你在Shader Graph中花费了一些时间后想要进入更技术性的职位，我们建议学习HLSL并手动编写着色器。一旦你学会了HLSL并手动编写着色器，你将拥有一个坚实的通用着色器创建基础。
- en: Let’s go through the setup of Shader Graph first, then how to create a shader.
    We should then take some time to talk about basic and commonly used nodes that
    are used to create shaders. Nodes are a visual representation of a block or chunk
    of code. These nodes can be linked together to create larger functions of visually
    layered effects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have been talking about using the **URP** project, which should automatically
    have Shader Graph installed on it. If it isn’t installed, you can easily install
    it by heading to the **Package Manager** and installing it from the Unity Registry
    packages.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.1* below shows what’s needed to install Shader Graph properly.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: If you have a green checkmark like in the figure below, then it is installed
    already!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17304_09_01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Checking if Shader Graph is installed'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have either installed Shader Graph or verified it’s installed, let’s
    move on to creating your first shader.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Creation
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right-clicking in an open area of your project window gives you the marking
    menu for that space. We want to make a new shader, so we mouse over **Create**
    > **Shader** > **Universal Render Pipeline** and then get four options. These
    four options are the basics from URP that automatically set up the shader settings
    for you. Refer to *Figure 9.2* for the path to follow to create your shader.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B17304_09_02.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Path to create a shader in Unity Editor'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering, “Which one should I choose?” If so, that is a great question.
    Let’s go over all four of these types just in case you want to mess around with
    any of the other types after we move along with our choice. From top to bottom
    we have **Lit**, **Sprite Lit**, **Sprite Unlit**, and **Unlit** Shader Graphs
    to work with. Let’s go through each of these types in that order.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Lit Shader Graph
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Lit Shader Graph lets you render 3D objects with real-world lighting information.
    The shaders that use this will be using a **Physically Based Rendering** (**PBR**)
    lighting model. A PBR model allows 3D surfaces to have a photo-realistic quality
    of materials like stone, wood, glass, plastic, and metals across various lighting
    conditions. With the Lit Shader’s assistance, lighting and reflections across
    these objects can adhere to dynamic shifts, such as bright light to a dark cave
    environment, accurately.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Sprite Lit Shader Graph
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: URP comes with a 2D rendering and lighting system. This system would be used
    in this graph type as the items that this shader would be rendered on would be
    sprites. A sprite is a two-dimensional bitmap (an array of binary data that represents
    the color of each pixel) that is integrated into a larger scene. This will allow
    the sprites to take in the needed lighting information.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Sprite Unlit Shader Graph
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is similar to the Shader Lit Shader Graph above, but the difference with
    the Sprite Unlit Shader Graph is that it is considered always fully lit and will
    take in no lighting information. This graph also only uses the 2D rendering and
    lighting system in the URP.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这与上面的着色器光照着色器图类似，但与Sprite无光照着色器图的不同之处在于，它被认为是始终完全光照的，并且不会接收任何光照信息。此图也仅使用URP中的2D渲染和光照系统。
- en: Unlit Shader Graph
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无光照着色器图
- en: The unlit type of graph for URP uses the 3D PBR lighting model like the Lit
    Shader Graph type. The major difference is that it won’t take in lighting information.
    This is the most performant shader in URP.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: URP的无光照类型图使用与光照着色器图类型相同的3D PBR光照模型。主要区别是它不会接收光照信息。这是URP中最高效的着色器。
- en: Shader Graph interface
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 着色器图界面
- en: Choose the Lit Shader Graph type for our Shader Graph. When you right-click
    in the project window, a new shader file will be created. Double-clicking this
    file will open the **Shader Graph** window.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的着色器图选择光照着色器图类型。当你右击项目窗口时，将创建一个新的着色器文件。双击此文件将打开**着色器图**窗口。
- en: There are some pieces we should go over so you can understand what is covered
    in the following subsections. We need to go over the **Master Stack**, **Blackboard**,
    **Graph Inspector**, **Main Preview**, and then **Nodes**. In *Figure 9.3* below,
    four out of five of these sections are displayed. We will be going over them in
    detail in this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些内容我们需要讲解，以便你能够理解以下小节中涵盖的内容。我们需要讲解**主堆栈**、**黑板**、**图检查器**、**主预览**以及**节点**。在下面的*图9.3*中，显示了这些部分中的四个。我们将在本章中详细讲解它们。
- en: '![Graphical user interface  Description automatically generated](img/B17304_09_03.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面 自动生成描述](img/B17304_09_03.png)'
- en: 'Figure 9.3: Shader Graph window breakdown'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：着色器图窗口分解
- en: Master Stack
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主堆栈
- en: The green-outlined item in *Figure 9.3* is the Master Stack. There are two sections
    to the Master Stack, **Vertex** and **Fragment**. The **Vertex** block of the
    Master Stack contains instructions to the actual vertexes of the 3D object that
    the material with this assigned shader will be manipulated. Within this block,
    you can affect the vertex’s **Position**, **Normal**, or **Tangent** attribute.
    These three attributes occur everywhere in a 2D and 3D environment. **Position**
    represents a vertex’s location in object space. **Normal** is used to calculate
    which direction light reflects off or is emitted out from the surface. **Tangent**
    alters the appearance of vertexes on your surface to define the object’s horizontal
    (U) texture direction.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.3*中的绿色轮廓项是主堆栈。主堆栈分为两部分，**顶点**和**片段**。主堆栈的**顶点**块包含对具有此分配着色器的3D对象的实际顶点的指令。在此块中，你可以影响顶点的**位置**、**法线**或**切线**属性。这三个属性在二维和三维环境中无处不在。**位置**表示顶点在对象空间中的位置。**法线**用于计算光线从表面反射或从表面发出的方向。**切线**改变你表面上顶点的外观，以定义对象的水平（U）纹理方向。'
- en: In our case, we do not need to change any of the vertex attributes, so we will
    move on to the fragment shader portion and leave the object space alone.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们不需要更改任何顶点属性，所以我们将继续到片段着色器部分，并保持对象空间不变。
- en: Fragment instructions can be thought of as possible pixels on your screen. We
    can affect the pixels depending on the changes made to the inputs to the stack.
    The attributes that are listed in the fragment shader depend on the shader type
    we choose when making the shader.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 片段指令可以被视为屏幕上可能的像素。我们可以根据对堆栈输入所做的更改来影响像素。片段着色器中列出的属性取决于我们在创建着色器时选择的着色器类型。
- en: The blocks inside of the **Fragment** stack are called Fragment Nodes. If you
    do not need a particular Fragment Node, you can remove it by right-clicking on
    the **Fragment Node** individually and selecting **Delete**. You can also add
    other Fragment Nodes to the stack by right-clicking the bottom of the **Fragment**
    frame and selecting **Add Node**.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**片段**堆栈内部的块称为片段节点。如果你不需要特定的片段节点，可以通过右击**片段节点**单独选择**删除**来移除它。你也可以通过右击**片段**框架的底部并选择**添加节点**来向堆栈添加其他片段节点。'
- en: In *Figure 9.4*, you can see a selection of all the node choices to add to the
    stack. If your shader isn’t set up to accept those new Fragment Nodes, they will
    be gray and not usable. For now, let’s go through the Lit Shader Fragment options.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.4*中，你可以看到所有要添加到堆栈中的节点选择。如果你的着色器没有设置为接受那些新的片段节点，它们将呈灰色且不可用。现在，让我们来看看光照着色器片段选项。
- en: '![Graphical user interface  Description automatically generated](img/B17304_09_04.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，描述自动生成](img/B17304_09_04.png)'
- en: 'Figure 9.4: Fragment Node options'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：片段节点选项
- en: The Fragment Nodes in the Fragment stack represent the pixels that will potentially
    be displayed in clip space or on your screen. 3D objects also have a 2D representation
    of their faces in the form of UVs. UVs are a two-dimensional texture representation
    of a 3D object. UVs have a flat, 2D axis, 0 (U) to 1 (V) graph. This particular
    UV graph is a representation of each vertex on this UV plane stretched over a
    3D object. The UV graph is also called a UV texture space.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 片段堆栈中的片段节点代表将在裁剪空间或屏幕上潜在显示的像素。3D对象也有其面的二维表示形式，即UV。UV是3D对象的二维纹理表示。UV具有一个平坦的二维轴，从0（U）到1（V）的图表。这个特定的UV图表是表示在这个UV平面上拉伸到3D对象上的每个顶点的表示。UV图表也称为UV纹理空间。
- en: Looking at *Figure 9.5* below, you can see that the geometry has been unwrapped
    to make it flat. This is like papercraft or origami. Knowing how this works sets
    up the concept of how shaders can manipulate not only the vertex of a mesh but
    also the color of the faces.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下面的图9.5，您可以看到几何体已经被展开以使其扁平。这就像纸艺或折纸。了解这一点为着色器可以如何操纵网格的顶点以及面的颜色奠定了基础。
- en: '![A picture containing box, businesscard  Description automatically generated](img/B17304_09_05.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![包含盒子、名片的照片，描述自动生成](img/B17304_09_05.png)'
- en: 'Figure 9.5: Basic mesh, UV layout, gradient on base color'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：基本网格，UV布局，基础颜色上的渐变
- en: We wanted to show you how we achieved the gradient within Shader Graph for *Figure
    9.5*. Though this isn’t the simplest graph we could’ve started with, it does a
    good job of breaking down some key concepts early.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想向您展示我们如何在Shader Graph中实现图9.5中的渐变。虽然这并不是我们可以从最简单的图表开始的地方，但它很好地分解了一些关键概念。
- en: If you look at *Figure 9.6* below, you will see our graph to build a gradient
    that we placed in the **Base Color**. The gradient is then applied to the 0-1
    space of the 3D object we assigned this material with this shader. It is not a
    complex shader as it has hardcoded gradients coming from the UV node.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看下面的图9.6，您将看到我们构建渐变的图表，我们将其放置在**基础颜色**中。然后，将渐变应用于我们用此着色器分配的材料的3D对象的0-1空间。它不是一个复杂的着色器，因为它有从UV节点硬编码的渐变。
- en: We will add more complexity to the parameters we make in the **Blackboard**
    in the next section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中增加我们在**黑板**中设置的参数的复杂性。
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B17304_09_06.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，描述自动生成，中等置信度](img/B17304_09_06.png)'
- en: 'Figure 9.6: Test gradient shader'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：测试渐变着色器
- en: We will be breaking down commonly used nodes in the next part of this chapter.
    For now, a quick explanation of what we are doing will help break this down.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章下一部分分解常用节点。现在，快速解释我们所做的工作将有助于分解。
- en: Base color
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基础颜色
- en: We are taking the UV’s 0-1 space, represented here with two gradients, *x* and
    *y* in the Red and Green channels. Red and Green channels are a part of color
    space; there are **Red** (**R**), **Green** (**G**), **Blue** (**B**), and **Alpha**
    (**A**) channels. RGB represents the color values. The Alpha channel indicates
    the opacity of each pixel, from 0 (fully transparent) through to 1 (opaque).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用两个渐变，*x*和*y*，在红色和绿色通道中代表UV的0-1空间。红色和绿色通道是颜色空间的一部分；有**红色**（**R**）、**绿色**（**G**）、**蓝色**（**B**）和**Alpha**（**A**）通道。RGB代表颜色值。Alpha通道表示每个像素的不透明度，从0（完全透明）到1（不透明）。
- en: We’ve seen that the 0-1 space starts from the bottom left and ends linearly
    in the top right in Unity. This means that the Green channel will be a linear
    gradient from bottom to top. Splitting off that channel allows us to manipulate
    the 0-1 in a Lerp node, with red replacing black and teal replacing white. There
    is a lot going on throughout the next few sections, but stick with it! As we break
    down the nodes, it will be much easier to follow per node.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，在Unity中，0-1空间从左下角开始，线性地延伸到右上角。这意味着绿色通道将是从下到上的线性渐变。分离该通道允许我们在Lerp节点中操作0-1，用红色代替黑色，用青色代替白色。在接下来的几节中有很多事情要做，但请坚持下去！当我们分解节点时，将更容易逐个节点进行跟踪。
- en: Normal
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 法线
- en: Normals tell each fragment how they are supposed to react to light that hits
    the face.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 法线告诉每个片段它们应该如何对击中面的光线做出反应。
- en: This is extremely useful to add detail to a face without changing the silhouette,
    reducing the number of polygons needed for higher detail. Looking at *Figure 9.7*
    below, you can see that it looks as though there are bumps pulled out of the cube.
    This isn’t a color change; this is light reacting to the surface of the faces.
    If you look closely, there are no protrusions on the edges. This is because the
    shape of the cube didn’t change. This is just a cube that acts as it does because
    of the normal maps.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于在不改变轮廓的情况下增加面部细节非常有用，减少了用于更高细节所需的多边形数量。查看下面的*图9.7*，你可以看到似乎有凸起从立方体中拉出。这不是颜色变化；这是光线对表面反应的结果。如果你仔细看，边缘上没有凸起。这是因为立方体的形状没有改变。这只是一个立方体，由于法线贴图的作用而表现出这样的效果。
- en: '![Minecraft with RTX PBR Texturing Guide | GeForce News | NVIDIA](img/B17304_09_07.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Minecraft with RTX PBR Texturing Guide | GeForce News | NVIDIA](img/B17304_09_07.png)'
- en: 'Figure 9.7: Normals on a cube'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：立方体上的法线
- en: On the left side of *Figure 9.7*, the left cube is blue due to the normal map
    using its color scheme from the RGB channels in the tangent space. This means
    that a flat normal map would represent *0*, *0*, *1*. Red and Green channels are
    used to represent the shifts in how the light should act on either the *x* tangent
    or the *y* tangent. When we work with materials in *Chapter 12*, *Final Touches*,
    we will go further into detail about the functions of a normal map.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '在*图9.7*的左侧，左边的立方体由于法线贴图使用其从切线空间的RGB通道中的颜色方案而呈现蓝色。这意味着一个平坦的法线贴图将代表*0*，*0*，*1*。红色和绿色通道用于表示光线在*x*切线或*y*切线上的作用方式的变化。当我们处理*第12章*中的材质时，*最终润色*，我们将更详细地介绍法线图的功能。 '
- en: Metallic
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 金属
- en: Metallic is exactly what it sounds like. This is how metallic the material is!
    That isn’t a great definition though, so let’s try to break it down a little.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 金属材质听起来就是这样的。这就是这种材料的金属感！但这并不是一个很好的定义，所以让我们试着稍微分解一下。
- en: The metallic field is a scaler float from 0 to 1, with 0 being not metallic
    and 1 being bare metal. Metallic materials take in their surrounding environment’s
    color. In *Figure 9.8* we have four spheres with four different settings for their
    material properties. We’re only using the URP/Lit shader that comes with URP out
    of the box to test these out. For this section we will only look at the left two
    spheres. The far-left sphere is white and the metal setting is set to 0\. This
    material is not taking in any of the environment’s color. It’s only taking in
    lighting information and its base color of white.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 金属字段是一个从0到1的标量浮点数，0表示非金属，1表示裸金属。金属材质会吸收其周围环境的颜色。在*图9.8*中，我们有四个球体，它们的材质属性有四种不同的设置。我们只使用URP/Lit着色器来测试这些设置。对于这一部分，我们只查看左侧的两个球体。最左侧的球体是白色，金属设置为0。这种材质没有吸收任何环境的颜色。它只吸收光照信息及其基础颜色白色。
- en: The second sphere, though it still has white for a base color, has the metallic
    setting set to 1\. The smoothness is set to 0.5 to be neutral, which you will
    hear more about shortly. If you look closely the second sphere has the Unity default
    skybox in the color. Now we need to throw in smoothness to this material.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个球体，尽管它仍然以白色为基础颜色，但金属设置为1。平滑度设置为0.5以保持中性，你很快就会了解更多关于这一点。如果你仔细看，第二个球体有Unity默认的天空盒的颜色。现在我们需要在这个材质中加入平滑度。
- en: '![A picture containing egg  Description automatically generated](img/B17304_09_08.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![包含鸡蛋的图片  描述由自动生成](img/B17304_09_08.png)'
- en: 'Figure 9.8: From left to right: No metal, all metal, all metal not smooth,
    all metal all smooth'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：从左到右：无金属，全金属，全金属不光滑，全金属全光滑
- en: Smoothness
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 平滑度
- en: Continuing with *Figure 9.8*, we will move on to the right two spheres. The
    third sphere from the left is very interesting. This one has a base color of white,
    the metal setting set to 1, and smoothness set to 0\. This means that the entire
    sphere is fully diffused! Diffused in this instance means that all the colors
    of the environment are blended across the whole sphere, leading to an almost perfect
    true neutral gray. The fourth sphere is the same, but smoothness is set to 1\.
    This means that the entire sphere is reflecting the direct environment.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 继续查看*图9.8*，我们将转向右侧的两个球体。从左数第三个球体非常有趣。这个球体的基础颜色是白色，金属设置为1，平滑度设置为0。这意味着整个球体是完全漫反射的！在这个例子中，漫反射意味着环境中的所有颜色在整个球体上混合，导致几乎完美的真正中性灰色。第四个球体也是一样的，但平滑度设置为1。这意味着整个球体正在反射直接的环境。
- en: Emissive
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 发光
- en: For an object to emit or radiate light you look toward an **emissive map**.
    The purpose of an emissive map is to be able to push colors to have brighter values
    than 1\. Pushing past the value of 1 allows that part of your object to glow brightly.
    This is useful for lava, sci-fi lights, or anything you want to emit brightness.
    Otherwise, the Fragment Node defaults to black and no emission is created.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一个物体发出或辐射光线，你将目光投向一个**发射贴图**。发射贴图的作用是能够将颜色推到比1更亮的值。超过1的值允许物体的这部分发光。这对于熔岩、科幻灯光或任何你想发出亮度的东西很有用。否则，片段节点默认为黑色，不会创建发射。
- en: '![A picture containing rock, stone  Description automatically generated](img/B17304_09_09.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![包含岩石、石头的图片，自动生成描述](img/B17304_09_09.png)'
- en: 'Figure 9.9: Left is no emission, right has emission with 2.4 intensity, no
    bloom'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：左无发射，右有发射，强度为2.4，无辉光
- en: This doesn’t look like an emissive glowing mushroom! This is due to emission
    needing a post-processing volume. To do this, create an empty GameObject and name
    it `_PostProcess`. We’re naming it this to give it a distinctly different name.
    Using the underscore as a prefix, we’re letting our developers know that this
    object houses logic only. There aren’t GameObjects for use in the game itself.
    Then add a **Volume** component, seen below in *Figure 9.10*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不像一个发光的蘑菇！这是因为发射需要后处理体积。为此，创建一个空的GameObject并命名为`_PostProcess`。我们这样命名是为了给它一个独特的名字。使用下划线作为前缀，我们让我们的开发者知道这个对象只包含逻辑。在游戏中没有用于使用的GameObject。然后添加一个**体积**组件，如下面的*图9.10*所示。
- en: '![A picture containing text, electronics, screenshot  Description automatically
    generated](img/B17304_09_10.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、电子、屏幕截图的图片，自动生成描述](img/B17304_09_10.png)'
- en: 'Figure 9.10: Volume added to post-process GameObject'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：添加到后处理GameObject的体积
- en: We’re not done yet! We need to add a profile and an override to get our bloom
    set up. Pressing the **New** button on the right-hand side of the **Volume** component
    will create a profile for your settings to be added to. This allows you to store
    those settings for other scenes if you need to. When you add a profile, you will
    then be able to add an override.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成！我们需要添加一个配置文件和一个覆盖来设置我们的辉光。按下**体积**组件右侧的**新**按钮将创建一个配置文件以添加你的设置。这允许你存储这些设置以供其他场景使用。当你添加一个配置文件时，你将能够添加一个覆盖。
- en: We want to click on **Add Override**, then **Post Process**, and finally **Bloom**.
    Then select the `Intensity` Boolean checkbox to allow for intensity to be changed.
    Change it to `1`. The settings are shown below in *Figure 9.11*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要点击**添加覆盖**，然后**后处理**，最后**辉光**。然后选择`强度`布尔复选框以允许更改强度。将其更改为`1`。设置如下在*图9.11*所示。
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B17304_09_11.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，自动生成描述，中等置信度](img/B17304_09_11.png)'
- en: 'Figure 9.11: Bloom override for post-processing volume'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：后处理体积的辉光覆盖
- en: Now we see it emitting light around the mushroom on the screen. This isn’t adding
    light into the scene; it is only adding a brightness value outside of the mesh
    to the render on the screen.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们看到它在屏幕上的蘑菇周围发出光线。这不是在场景中添加光线；它只是在网格外部添加一个亮度值到屏幕上的渲染中。
- en: '![A picture containing hole  Description automatically generated](img/B17304_09_12.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![包含孔的图片，自动生成描述](img/B17304_09_12.png)'
- en: 'Figure 9.12: Left: no emissive, Right: emissive and bloom set up'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12：左无发射，右有发射和辉光设置
- en: We have a shiny, glowing mushroom! Go forth and add emission to things! We will
    now look into **Ambient Occlusion**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个闪亮的发光蘑菇！去添加发射吧！我们现在将探讨**环境光遮蔽**。
- en: Ambient Occlusion
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 环境光遮蔽
- en: The point of **Ambient Occlusion** (**AO**) is to add dark spots to sections
    to show creases. This adds a nice, clean effect of shadows even if there aren’t
    any specific lights making shadows. AO is designed for light at all angles. This
    attribute expects values from 0 to 1\. If you do not have an AO map for your model,
    it’s best to leave it at 1\. In *Chapter 12*, *Finishing Touches*, we will be
    working with Myvari’s material, which will have an AO map to go over.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**环境光遮蔽**（**AO**）的作用是在某些部分添加暗点以显示皱褶。即使没有特定的光源产生阴影，这也能添加一个干净、美观的阴影效果。AO是为所有角度的光设计的。这个属性期望的值在0到1之间。如果你没有为你的模型创建AO贴图，最好将其设置为1。在*第12章*，*收尾工作*中，我们将使用Myvari的材料，它将包含一个AO贴图来覆盖。'
- en: This was the master stack in summary. Each of the attributes on the stack can
    be used to provide unique shaders. Something that helps with even more customization
    is the **Blackboard** part of Shader Graph.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是总结中的主堆栈。堆栈上的每个属性都可以用来提供独特的着色器。有助于进一步定制的还有着色器图中的**黑板**部分。
- en: Blackboard
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 黑板
- en: The **Blackboard** allows the user to create properties and keywords to use
    in shaders that can be dynamically changed in various ways. Properties can be
    used within the shader or be exposed to the material in the Inspector using the
    **Exposed** checkbox.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑板**允许用户创建可以在着色器中使用的属性和关键词，这些属性和关键词可以以各种方式动态更改。属性可以在着色器内部使用，或者通过**暴露**复选框将其暴露给检视器中的材质。'
- en: You can locate the **Blackboard** button on the top right of the **Shader Graph**
    window. Once you click this button, **Blackboard** will open its own separate
    UI.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在**着色器图**窗口的右上角找到**黑板**按钮。一旦点击此按钮，**黑板**将打开其自己的独立UI。
- en: '![A picture containing text  Description automatically generated](img/B17304_09_13.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图片  自动生成的描述](img/B17304_09_13.png)'
- en: 'Figure 9.13: Variable types available in the Blackboard'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13：黑板中可用的变量类型
- en: There are 16 available data types that can be created. These data types can
    be changed through scripting during runtime as well. Keywords are designed to
    be changed per material instance during runtime. There are only a few options
    for this as the compiler needs to account for all the variations. This is handy
    for things like mobile specifications. You may make an enum (user-defined set
    of constraints) or list for different systems to change the fidelity (perceptual
    quality) of the shader to adapt to platform limitations.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有16种可创建的数据类型。这些数据类型可以在运行时通过脚本进行更改。关键词设计为在运行时按材质实例进行更改。由于编译器需要考虑所有变体，因此此选项只有少数几个。这对于像移动规格这样的东西很有用。您可以为不同的系统创建枚举（用户定义的约束集）或列表，以更改着色器的保真度（感知质量），以适应平台限制。
- en: Graph Inspector
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图检视器
- en: The **Graph Inspector** gives you the options for the shader type itself. We
    chose to start with a URP/Lit shader as our base, which sets specific settings
    in the **Graph Inspector** for us. *Figure 9.14* below shows the **Graph Inspector**.
    These are the settings that are set by default with the URP/Lit.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**图检视器**提供了对着色器类型的选项。我们选择从URP/Lit着色器作为基础开始，这会在**图检视器**中为我们设置特定的设置。下方的*图9.14*显示了**图检视器**。这些是URP/Lit默认设置的设置。'
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_09_14.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成的描述](img/B17304_09_14.png)'
- en: 'Figure 9.14: Graph Inspector'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14：图检视器
- en: Each of these properties available to the shader we are building has great use
    in certain situations. When we go over using them in*, Finishing Touches*, we
    will explain why we are making the changes to the graph settings. For now, understand
    that the material we chose was the **Lit** option and it defaults to a metallic
    opaque workflow. This means that you do not see the color from items behind it
    as it isn’t transparent.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的着色器中可用的每个属性在特定情况下都有很大的用途。当我们讨论在*完成细节*中使用它们时，我们将解释为什么我们要更改图设置。现在，了解我们选择的材质是**Lit**选项，它默认为金属不透明的工作流程。这意味着您看不到其后面的物品的颜色，因为它不透明。
- en: Main Preview
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主预览
- en: The **Main Preview** is an overall glance at what the shader would look like
    in the game. The default is a sphere.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**主预览**是对着色器在游戏中外观的整体查看。默认是一个球体。'
- en: You can right-click in the window to access multiple options, such as to include
    a custom mesh, as noted in *Figure 9.15* below.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在窗口中右键单击以访问多个选项，例如在*图9.15*中提到的包含自定义网格。
- en: '![Graphical user interface  Description automatically generated](img/B17304_09_15.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成的描述](img/B17304_09_15.png)'
- en: 'Figure 9.15: Screenshot of the main preview in Shader Graph and its options'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15：着色器图中的主预览及其选项截图
- en: Until you plug in some nodes to the Master Stack, this preview will default
    as a gray sphere. Let’s talk about nodes next!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在将节点连接到主堆栈之前，此预览将默认为灰色球体。接下来，让我们谈谈节点！
- en: Nodes
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 节点
- en: '[PRE0]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_09_16.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成的描述](img/B17304_09_16.png)'
- en: 'Figure 9.16: Node creation menu'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16：节点创建菜单
- en: If you took some time to build this out, you may have also opened some of the
    node groupings and realized that there is a very large number of nodes to choose
    from. This may cause a little bit of anxiety. Fortunately, we will go over some
    common nodes that are used in many shaders in the next section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您花了一些时间来构建这个内容，您可能也打开了一些节点分组，并意识到有非常多的节点可供选择。这可能会引起一些焦虑。幸运的是，在下一节中，我们将介绍一些在许多着色器中常用的节点。
- en: Commonly used nodes
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常用节点
- en: Below is a simple list of commonly used nodes to make shaders. We want to stress
    that this isn’t the full list of nodes. In fact, there are over 200 nodes now
    in Shader Graph 10+. Going over all of them could literally be a book or two.
    The interesting thing about these sets of nodes is that they can be built up to
    make some incredible shaders. Something to keep in mind when reading about these
    is that there may be information in the previous node that helps describe the
    current node you are reading. Read through them all even if you’re reasonably
    comfortable with, say, knowing how to add, for example.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个用于制作着色器的常用节点简单列表。我们想强调，这并不是节点的完整列表。实际上，在Shader Graph 10+中现在有超过200个节点。详细地介绍它们可能相当于一本书或两本书的内容。这些节点集的有趣之处在于，它们可以被构建起来制作一些令人难以置信的着色器。在阅读这些内容时，请注意，前一个节点中可能包含有助于描述当前您正在阅读的节点的信息。即使您对如何添加等操作相当熟悉，也请通读所有内容。
- en: Add
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加
- en: To be able to explain **Add**, we need to make sure you remember that 0 means
    absence, or the color black in this case. This means that a value of 1 is white.
    We normalize our values on a 0-1 scale across many applications. You may remember
    that UV coordinates are also between 0 and 1\. This is no mistake! So, if I had
    two scalars, or `Vector1s`, and added them, the value would be greater.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够解释**添加**，我们需要确保您记得0代表缺席，或者在这个情况下是黑色。这意味着1的值是白色。我们在许多应用中在0-1的尺度上归一化我们的值。您可能记得UV坐标也是在0和1之间。这不是错误！所以，如果我有两个标量，或者`Vector1s`，并将它们相加，值会更大。
- en: 'Let’s show a quick example: 0.4 + 0.4 = 0.8.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个快速示例来展示：0.4 + 0.4 = 0.8。
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B17304_09_17.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，自动生成描述，置信度中等](img/B17304_09_17.png)'
- en: 'Figure 9.17: Add node'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17：添加节点
- en: 0.4 is a darker-than-medium-gray value. If we add two of them together, we almost
    get white! 0.8 is 80% to pure white in value, seen in *Figure 9.17*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 0.4是一个比中等灰色更暗的值。如果我们把它们加在一起，我们几乎可以得到白色！0.8在值上是80%的纯白色，如图*图9.17*所示。
- en: Color
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 颜色
- en: This node is a Vector4 with nice visual sugar on top. Vector4 (*0*, *0*, *0*,
    *0*) represents Red, Green, Blue, and Alpha in shader values. **Color** has an
    interface for you to select the color you want, and it will set up the RGB values
    for you with an Alpha slider for that value while outputting a Vector4\.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个节点是一个带有良好视觉糖的Vector4。Vector4 (*0*, *0*, *0*, *0*) 在着色器值中代表红色、绿色、蓝色和Alpha。**颜色**提供了一个界面供您选择所需的颜色，并且它会为您设置RGB值，同时使用Alpha滑块设置该值，并输出一个Vector4\。
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B17304_09_18.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序、聊天或文本消息，自动生成描述](img/B17304_09_18.png)'
- en: 'Figure 9.18: Color node'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18：颜色节点
- en: This would be difficult with the Vector4 node as there is no color visual to
    know what your values need to be.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vector4节点来做这个可能会很困难，因为没有颜色视觉来知道您的值需要是什么。
- en: Lerp
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lerp
- en: '**Lerp** stands for **Linear Interpolation**. The Lerp node can be used in
    many applications. One instance is how we set up a gradient to be used for the
    base color in *Figure 9.6*. There are three inputs: A, B, and T. You can think
    of it as A is 0, B is 1, and T is the driver. The driver (T) is a value of 0-1\.
    However, the value will map to the value of A, B, and the values in between. If
    T is at 0, it will display an 100% value of what is in A. If T has a value of
    1, it will display an 100% value of B. Now, if T is at 0.4, then that will be
    in between the values of A and B: 40% A and 60% B.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lerp**代表**线性插值**。Lerp节点可以在许多应用中使用。一个例子是如何在*图9.6*中设置用于基础颜色的渐变。它有三个输入：A、B和T。您可以将A视为0，B视为1，T是驱动器。驱动器（T）是一个0-1之间的值。然而，这个值将映射到A、B以及它们之间的值。如果T为0，它将显示A的100%值。如果T的值为1，它将显示B的100%值。现在，如果T为0.4，那么它将在A和B的值之间：40%的A和60%的B。'
- en: '![Graphical user interface  Description automatically generated](img/B17304_09_19.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，自动生成描述](img/B17304_09_19.png)'
- en: 'Figure 9.19: Lerp node'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19：Lerp节点
- en: This is difficult to visualize with just numbers alone. Luckily, in *Figure
    9.19* we used the UV to input T as a gradient. This allows us to see the 0-1 going
    from bottom to top. You are seeing a gradient from A to B from bottom to top.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 仅用数字很难可视化这一点。幸运的是，在 *图 9.19* 中，我们使用了 UV 将 T 作为渐变输入。这使我们能够看到从底部到顶部的 0-1 渐变。你看到的是从
    A 到 B 的渐变，从底部到顶部。
- en: Multiply
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 乘法
- en: We’ve seen the **Add** and **Lerp** nodes; now we need to work through another
    operation, **Multiply**. By the nature of basic arithmetic, **Multiply** will
    make the value lower.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 **添加** 和 **线性插值** 节点；现在我们需要处理另一个操作，**乘法**。根据基本算术的性质，**乘法**会使值降低。
- en: This is happening because we are in the range of 0-1\. Let’s put together an
    example in *Figure 9.20\.*
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们处于 0-1 的范围内。让我们在 *图 9.20* 中放一个例子。
- en: '![Graphical user interface  Description automatically generated](img/B17304_09_20.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，描述自动生成](img/B17304_09_20.png)'
- en: 'Figure 9.20: Multiply node'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.20：乘法节点
- en: We have used the same example we used for the add node but we are using multiplication
    instead of using addition. Simple math states .4 * .4 = .16.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了与添加节点相同的示例，但我们使用乘法而不是加法。简单的数学运算表明 .4 * .4 = .16。
- en: Sample Texture 2D
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样本纹理 2D
- en: This node allows you to take textures you have authored in other **Digital Content
    Creation** (**DCC**) software such as Photoshop and use the color information
    to manipulate the attributes of the master stack. There are two inputs, the texture
    you want to sample and the UVs, as seen in *Figure 9.21*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个节点允许你使用在其他 **数字内容创作** （**DCC**） 软件中创建的纹理，例如 Photoshop，并使用颜色信息来操纵主堆栈的属性。有两个输入，你想要采样的纹理和
    UVs，如 *图 9.21* 所示。
- en: '![A screenshot of a video game  Description automatically generated with medium
    confidence](img/B17304_09_21.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![视频游戏截图，描述自动生成，中等置信度](img/B17304_09_21.png)'
- en: 'Figure 9.21: Sample Texture 2D'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.21：样本纹理 2D
- en: The UV node allows you to manipulate the UV coordinates of your mesh. A nice
    feature of this node is that it outputs the Vector4 as well as each float individually
    from the node itself.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: UV 节点允许你操纵网格的 UV 坐标。这个节点的优点是它不仅输出 Vector4，还从节点本身输出每个浮点数。
- en: Saturate
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 饱和
- en: There may be a time when your values go above 1\. This may happen because you
    are working with multiple nodes that push your values outside the 0-1 range.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你的值可能会超过 1。这可能是由于你正在处理多个节点，这些节点将你的值推到了 0-1 范围之外。
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_09_22.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B17304_09_22.png)'
- en: 'Figure 9.22: Saturate node'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.22：饱和节点
- en: If this happens, you can input the data into a saturate node and it will return
    all of your values within the 0-1 range. Place the float value in the **In** portion,
    and the **Out** value will be normalized to the 0-1 range.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，你可以将数据输入到一个饱和节点中，它将返回所有值在 0-1 范围内。将浮点值放在 **输入** 部分，**输出** 值将被归一化到 0-1
    范围。
- en: Split
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分割
- en: As we saw in the **Sample Texture 2D node**, the Vector4 was split into individual
    outputs. This isn’t always the case. The **Color** node only outputs a Vector4\.
    If you only want to use the Red channel value from **Color**, how could you get
    it? You guessed it, a split node. Input a Vector2, 3, or 4 and use whichever channel
    you desire as a float.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 **样本纹理 2D 节点** 中看到的，Vector4 被分割成单独的输出。这并不总是这种情况。**颜色**节点只输出 Vector4。如果你只想从
    **颜色** 中使用红色通道值，你该如何获取它？你猜对了，使用一个分割节点。输入一个 Vector2、3 或 4，并使用你想要的任何通道作为浮点数。
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_09_23.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B17304_09_23.png)'
- en: 'Figure 9.23: Split node'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.23：分割节点
- en: This is very helpful to be able to break out an image that you put four grayscale
    images onto. We call that **channel packing** so you can have three images on
    one texture lookup.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于能够从你放置了四个灰度图像的图像中提取出来非常有帮助。我们称之为 **通道打包**，这样你就可以在一个纹理查找中放置三幅图像。
- en: UV
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UV
- en: There may be a time when you need to manipulate the UVs of the object you want
    to render. A reason for this may be that you want to tile the UVs because the
    scale of the item was larger or smaller than what was intended. Another reason
    to use the UV node is that it automatically creates horizontal and vertical gradients.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要操纵你想要渲染的对象的 UVs。一个原因可能是因为你想要平铺 UVs，因为项目的比例比预期的要大或小。使用 UV 节点的另一个原因是它会自动创建水平和垂直渐变。
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_09_24.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，自动生成的描述](img/B17304_09_24.png)'
- en: 'Figure 9.24: UV node'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24：UV节点
- en: If split, the R channel is the horizontal gradient and the G channel is the
    vertical gradient.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分割，R通道是水平渐变，G通道是垂直渐变。
- en: Vectors
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向量
- en: These guys are used everywhere. You’ll notice that a Vector1 is named a **Float**.
    Another name for Vector1 is Scalar. Something else you may have noticed is that
    the outputs are all different colors. Float is cyan, Vector2 is green, Vector3
    is yellow, and Vector4 is pink. This is incredibly useful to know the colors as
    they are shown on the connection lines between the nodes. These nodes are used
    in infinite use cases. Do you need three points of data? Vector3!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些节点无处不在。你会注意到Vector1被命名为**Float**。Vector1的另一个名字是Scalar。你可能还注意到输出都是不同的颜色。Float是青色，Vector2是绿色，Vector3是黄色，而Vector4是粉色。了解这些颜色在节点之间的连接线上是如何显示的非常有用。这些节点在无限的使用案例中都有应用。你需要三个数据点吗？Vector3！
- en: '![Graphical user interface  Description automatically generated](img/B17304_09_25.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，自动生成的描述](img/B17304_09_25.png)'
- en: 'Figure 9.25: Vector nodes'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.25：向量节点
- en: With all of these basic nodes, you can make some powerful shaders to make beautiful
    materials with. In *Chapter 12*, *Finishing Touches*, we will be covering shaders
    for multiple purposes and showing how we use these nodes to create some nice visual
    candy. Now let’s move away from Shader Graph and work with Particle Systems so
    we can add nice visual effects to our experiences.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用所有这些基本节点，你可以制作一些强大的着色器，用它们来制作美丽的材质。在*第12章*，*收尾工作*中，我们将介绍用于多种目的的着色器，并展示我们如何使用这些节点来创建一些漂亮的视觉效果。现在让我们从着色器图离开，开始处理粒子系统，以便我们可以为我们的体验添加一些漂亮的视觉效果。
- en: Particle Systems
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子系统
- en: When you think of visual effects in a video game, the first thing that pops
    into your head most likely is the trails of legendary weapons in ARPGs or the
    amazing explosions from intense first-person-shooter campaigns. Whatever popped
    into your head, there are systems that allow for these effects to happen. Particle
    Systems allow for the spawning of meshes with certain rules to create these effects.
    Two of them in Unity are Shuriken and VFX Graph.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想到视频游戏中的视觉效果时，最可能首先出现在你脑海中的可能是ARPG中传奇武器的尾迹或来自紧张的第一人称射击战役中的惊人爆炸。无论你脑海中浮现的是什么，都有系统可以允许这些效果发生。粒子系统允许根据特定规则生成网格，以创建这些效果。Unity中有两个系统是Shuriken和VFX图。
- en: Shuriken
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Shuriken
- en: This system is full of features to help spawn 3D meshes (structural collection
    of vertices, edges, and faces that define a 3D object). You can create fire embers,
    trails, explosions, smoke, and everything else to help sell the experience that
    has been defined. As you can see in *Figure 9.26* there are a lot of options to
    go over. We will leave the explanation of this to the examples covered in *Chapter
    12*, *Finishing Touches* when we create Shuriken-based effects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统充满了帮助生成3D网格（定义3D对象的顶点、边和面的结构集合）的功能。你可以创建火花、尾迹、爆炸、烟雾以及所有其他有助于增强所定义体验的东西。正如你在*图9.26*中看到的，有很多选项需要探讨。我们将把这个解释留给*第12章*，*收尾工作*中创建基于Shuriken的效果时涵盖的例子。
- en: Some high-level knowledge of Shuriken to know is that it is a Particle System
    that uses the CPU to direct the particles.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关于Shuriken的高级知识是，它是一个使用CPU来引导粒子的粒子系统。
- en: This limits the amount of particles that can spawn directly on that hardware.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这限制了可以在该硬件上直接生成粒子的数量。
- en: '![A picture containing graphical user interface  Description automatically
    generated](img/B17304_09_26.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![包含图形用户界面的图片，自动生成的描述](img/B17304_09_26.png)'
- en: 'Figure 9.26: Shuriken Particle System'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.26：Shuriken粒子系统
- en: Shuriken is fantastic for particle systems on the CPU, but if you want to have
    large amounts of particles moving around, VFX Graph is the way to go. This makes
    GPU-driven particles and can handle many thousands of particles at once.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Shuriken对于CPU上的粒子系统非常出色，但如果你想要有大量粒子四处移动，VFX图就是最佳选择。这可以驱动GPU粒子，并且可以同时处理成千上万的粒子。
- en: VFX Graph
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VFX图
- en: Firstly, you will most likely need to install VFX Graph. Open the **Package
    Manager** as you have done before and find **Visual Effects Graph** from within
    **Unity Registry** and install it! After you’ve finished this, you will need to
    create a VFX Graph system. In your project window, right-click and then select
    **Create** > **Visual Effects** > **Visual Effects Graph**.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您很可能会需要安装VFX图。像之前一样打开**包管理器**，然后在**Unity注册表**中找到**视觉效果图**并安装它！完成此操作后，您需要创建一个VFX图系统。在您的项目窗口中右键单击，然后选择**创建**
    > **视觉效果** > **视觉效果图**。
- en: '![Graphical user interface  Description automatically generated](img/B17304_09_27.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，描述自动生成](img/B17304_09_27.png)'
- en: 'Figure 9.27: Installing and creating your first VFX Graph system'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.27：安装和创建您的第一个VFX图系统
- en: Opening VFX Graph will present you with a new window. This window is like the
    **Shader Graph**. You’ll notice there is a **Blackboard**, which we can use to
    create parameters that can be changed at runtime and is exposed in the inspector.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 打开VFX图将为您显示一个新窗口。这个窗口就像**着色器图**。您会注意到有一个**黑板**，我们可以用它来创建可以在运行时更改的参数，并在检查器中公开。
- en: 'There is a UI that is unique to the VFX Graph and a few specific terms: **Contexts**,
    **Blocks**, **Nodes**, and **Variables**. **Contexts** are portions of the system
    broken down, such as **Spawning**, **Initialization**, **Update**, and **Output**.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个独特的UI和几个特定术语：**上下文**、**块**、**节点**和**变量**。**上下文**是将系统分解的部分，例如**生成**、**初始化**、**更新**和**输出**。
- en: Each of these **contexts** has **blocks** inside of them and can be added to
    the **contexts** by right-clicking. The **Spawning** **context** controls how
    many instances of the system feeds into an **Initialize** **context**. **Initialize**
    **context** processes the **Spawn Event** and engages a new particle simulation.
    **Update** **context** takes in the **Initialized** particles and executes explicit
    behaviors upon certain conditions. **Output** **contexts** account for the simulation
    data and render every living particle according to the **Output** **context**
    configuration. However, **Output** **context** does not modify simulated data.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这些**上下文**中每个都包含**块**，可以通过右键单击将它们添加到**上下文**中。**生成****上下文**控制有多少个系统的实例输入到**初始化****上下文**。**初始化****上下文**处理**生成事件**并启动一个新的粒子模拟。**更新****上下文**接收**已初始化**的粒子并在某些条件下执行显式行为。**输出****上下文**负责模拟数据，并根据**输出****上下文**配置渲染每个活着的粒子。然而，**输出****上下文**不会修改模拟数据。
- en: 'The first context is spawning. This context will allow you to add blocks to
    affect the spawning logic of each system. There are some questions that should
    be considered here: How many particles should spawn from this system? How quickly
    should those particles spawn? When are they spawned?'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个上下文是生成。这个上下文将允许您添加块来影响每个系统的生成逻辑。这里有一些应该考虑的问题：从这个系统中应该生成多少个粒子？这些粒子应该多快生成？它们何时生成？
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_09_28.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，描述自动生成](img/B17304_09_28.png)'
- en: 'Figure 9.28: Spawn context'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.28：生成上下文
- en: 'After the spawning is completed, you need to have parameters to initialize
    them with. These blocks answer these types of questions: Where do the particles
    spawn? Are they spawned moving or do they have velocity? How long does each particle
    live for?'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 生成完成后，您需要有一些参数来初始化它们。这些块回答这些问题：粒子在哪里生成？它们是移动生成还是有速度？每个粒子能存活多久？
- en: '![A screenshot of a video game  Description automatically generated with medium
    confidence](img/B17304_09_29.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![视频游戏截图，描述自动生成，中等置信度](img/B17304_09_29.png)'
- en: 'Figure 9.29: Initialize context'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.29：初始化上下文
- en: 'Now that you have them spawning, it may be a good idea to add some unique behavior
    to them as they update, or they will be floating sphere gradients. You can expect
    this to answer the ultimate question: How will the particles change over time?'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经让它们开始生成，可能有必要在它们更新时添加一些独特的行为，否则它们将只是漂浮的球面渐变。您可以期待这回答一个终极问题：粒子将如何随时间变化？
- en: '![Timeline  Description automatically generated](img/B17304_09_30.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![时间轴，描述自动生成](img/B17304_09_30.png)'
- en: 'Figure 9.30: Update context'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.30：更新上下文
- en: Then finally, as you have an understanding of how many particles there are,
    where the particles are, and what the particles are doing, you can now decide
    what they will look like.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当您了解了有多少粒子，粒子在哪里，以及粒子在做什么后，您现在可以决定它们的看起来会是什么样子。
- en: 'The questions are: Which way are the particles facing? What shader is being
    used?'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是：粒子面向哪个方向？使用了哪种着色器？
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_09_31.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B17304_09_31.png)'
- en: 'Figure 9.31: Output context'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.31：输出上下文
- en: You may have noticed the left side of the blocks sometimes have circle inputs
    like the Shader Graph. If you thought that you could put some input to this, maybe
    from nodes, then you’re correct! There are nodes that you can work through to
    get the right data flowing to the blocks that are in each context.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，块状图左侧有时会有类似着色器图的圆形输入。如果你认为你可以将这些输入放入其中，也许是从节点来的，那么你是对的！有一些节点你可以通过它们来获取正确流向每个上下文块的数据。
- en: Nodes
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 节点
- en: As this was in Shader Graph, the nodes are meant to take data values and manipulate
    them in a way to get the desired outcome. In VFX Graph’s case the values are meant
    to be read into one of the blocks as opposed to one of the attributes from the
    **Master Stack**. For the most part you will utilize the **Operator** nodes and
    variables that are created in the **Blackboard** to complete the complex maths.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是在着色器图中，节点的作用是获取数据值并以某种方式操作它们，以获得期望的结果。在VFX图中，值被用来读入其中一个块，而不是从**主栈**中的一个属性。在大多数情况下，你将利用**运算符**节点和在**黑板**中创建的变量来完成复杂的数学运算。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We learned that visual effects have heavy technical implications through two
    major sources in Unity: shaders and particles. Taking our time through shaders,
    we built an example of a material on a 3D object to get the concept down so when
    we have multiple different scenarios, we can follow how the shader was created.
    This was done through Shader Graph. After that, we dove into the concept of particles.
    Shuriken was shown to get a simple understanding of CPU particles and will be
    used in later chapters to explain the finishing touches. GPU particles are created
    through VFX Graph; we went over the interface and some vocabulary of VFX Graph
    so when we use it later, there is an understanding to work off.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过Unity中的两个主要来源了解到视觉效果有重大的技术影响：着色器和粒子。我们花时间在着色器上，构建了一个3D对象上的材质示例，以便在有多种不同场景时，我们可以追踪着色器的创建过程。这是通过着色器图完成的。之后，我们深入探讨了粒子的概念。Shuriken被用来获得对CPU粒子的简单理解，将在后面的章节中用来解释细节。GPU粒子是通过VFX图创建的；我们讨论了VFX图的界面和一些词汇，以便在以后使用时，有一个理解来工作。
- en: Visual effects are a very large topic to master. Mastering these tools takes
    a long time. Take your time when working through this and fail fast. This will
    guide you through understanding visual effects.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉效果是一个非常大的主题，要掌握它需要很长时间。当你处理这个主题时，请慢慢来，快速失败。这将帮助你理解视觉效果。
- en: The next chapter covers the implementation of sound in the game. Sounds are
    generally overlooked until nearly the end of games, but they are integral to ensuring
    the product has captivating emotional tie-ins with the environment and the character.
    We will go over implementations, some sound design, and other sound-focused knowledge
    points in the next chapter.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍游戏中声音的实现。声音通常在游戏快结束时才被注意到，但它们对于确保产品与环境和角色有吸引人的情感联系是至关重要的。下一章我们将讨论实现、一些声音设计和其他与声音相关的知识点。
