- en: Chapter 5. The Secret Ingredient Is a Dash of Physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"Sprinkles may seem soft, but they are an excellent sharp weapon against sweet-tooth
    pandas, who are trying to steal your delicious cake!"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This chapter explains how Unity deals with 2D physics and provides descriptions
    for each of the components, along with useful examples of usages. Although we
    will use just a small portion of the Physics engine of Unity for our game, in
    this chapter you can find some foundations of physics to better face the topics
    covered, and a full insight of 2D physics in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: In the first part of the chapter, we will acquire some basic notions about physics
    so as to better face the topics to come. We will learn about mass, forces, and
    torques, just enough to understand physics in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Then, most of the chapter will focus on explaining, bit by bit, the 2D Physics
    engine of Unity along with all its components and functionalities. Many examples
    will be provided in order to facilitate the learning.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the last part of the chapter, we will use some of the notions learnt
    and apply them into our game. In fact, we will transform simple sprinkles into
    terrible weapons against the sweet-toothed pandas by enabling and handling collisions
    between the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we are going to learn these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic notions of physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Physics engine of Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics settings, which are general properties for the whole project/game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rigidbody components with different body types and their usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Colliders and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joints to impose constraints on rigidbodies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effectors to change physics properties in particular region of the game world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics materials to determine friction and bounciness on colliders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the physics components in our game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like all other chapters in this book, you will find the *Homework* section at
    the end. It has a range of different exercises for you to do to improve your skills
    and implement a range of different functionalities into your game.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter does not need any particular prerequisite to learn about the Physics
    engine. However, at the end of this chapter we will continue our tower defense
    game from where we left it in [Chapter 4](part0056.xhtml#aid-1LCVG1 "Chapter 4. No
    Longer Alone – Sweet-Toothed Pandas Strike"), *No Longer Alone – Sweet-Toothed
    Pandas Strike*. Therefore, if you want to keep developing the *Tower Defense*
    game, you need to have done all the other steps in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: For those of you who are newcomers to physics, a great deal of patience is required,
    but once you master these concepts, a world of new possibilities for your own
    games will open. So don't give up!
  prefs: []
  type: TYPE_NORMAL
- en: Physics in video games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From bullets flying at different speeds and trajectories to gravity playing
    a role between keeping you grounded and allowing you to float, physics in video
    games plays an essential part in making experiences realistic and definitely enjoyable
    (for the most part). Imagine if every weapon fired a bullet in the same way, regardless
    of the firepower. Then what would be the point between having a sniper rifle or
    a revolver? This is only one aspect of the role that physics plays in games. Physics
    in games does not just revolve around trajectories and force; it can include gravity,
    time travel, and fluid dynamics.
  prefs: []
  type: TYPE_NORMAL
- en: Some great examples of games that use physics include *World of Goo*, *Portal
    1* and *2*, *Mario Galaxy*, and *Kerbal Space Program.*
  prefs: []
  type: TYPE_NORMAL
- en: '![Physics in video games](img/image00512.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Image by Portal 2 - An orange liquid that reduces friction so much to give you
    a substantial boost
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, at the other end of the spectrum, games don''t always replicate
    physics in the most accurate way but rather exaggerate it or dismiss it altogether
    to allow for innovative and unique gameplay. An example of this would include
    taking a *Leap of Faith* from great heights in *Assassin''s Creed*, into conveniently
    placed stacks of hay (and even water). Some people have even studied how much
    hay that you would actually need in order to survive such jumps, which you can
    find here: [http://www.kotaku.com.au/2009/06/kotaku-bureau-of-weights-measures-studies-fallout-physics-also-beer/](http://www.kotaku.com.au/2009/06/kotaku-bureau-of-weights-measures-studies-fallout-physics-also-beer/)'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to adding physics to your own game, you must ask yourself to what
    extent you want your gaming experience to be real. If you want your game to be
    100% identical to reality, then you must also consider things like death. If a
    character can be shot by a bullet, do they bleed out or can they heal themselves?
    In some cases, your game may end up more of a simulation than a game itself if
    the interaction is too real. An example is **permadeath** (where the player must
    restart the game from the beginning after they have died), which you may or may
    not want in your game/simulation. All of these factors need to be considered when
    adding physics into games because both the cause and effect will all contribute
    to how believable the game is and ultimately how enjoyable it will be.
  prefs: []
  type: TYPE_NORMAL
- en: Physics – basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn some basic notions of physics, to better understand
    the Physics engine of Unity later on, and overall become better game developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, what is physics? Aristotle (the same guy from the previous chapter)
    wrote a treatise entitled *ta physika*, which literally means the natural things.
    From this treatise (although many before Aristotle have written about natural
    phenomena), physics has become a science. Nowadays, physics investigates matter,
    its motion both in time and space, through mathematical models. Ultimately, the
    goal of physics is to describe how the whole universe works. Physics is divided
    into four big branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Classical mechanics**: This deals with the motion of objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thermodynamics**: This deals with the temperatures of bodies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Electromagnetism**: This deals with electromagnetic waves/particles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quantum mechanics**: This deals with the study of subatomic particles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don't need to see these as separate entities but just faces of the same
    coin, which is the model of the world that physics over the centuries has tried
    to unravel. Therefore, many topics cross them all, and so the division in not
    univocal. But, it's a good way for newcomers to physics to get an overview.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will deal only with classical mechanics, and in particular
    with the motion of rigid bodies. However, other branches and sub-branches of physics
    are also really useful in game development. For instance, we can use light equations,
    which are implemented in shader, or fluid dynamics to simulate oceans and waves.
    Even when the evil wizard casts his most terrible fireball, we need to calculate
    many different physics equations to have a realistic behaviour and look. Imagine
    just simulating the fire around the ball.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, you don't want to go into that much detail, if you already
    have a game engine like Unity (or Unreal). In fact, their programmers will take
    care of this for you. However, sometimes you may have special needs, and you need
    to write your own shader or code some physics-based behaviours. As such, knowledge
    of physics is greatly and immensely helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is not a course in physics nor a book dedicated to physics programming
    (for example, algorithms that can simulate more or less approximately and efficiently
    some physical behaviours). However, in this chapter, we will consolidate the really
    basic concepts of physics so that we can have a rough idea of how it all works
    together. As such, this and the upcoming sections will be dedicated to building
    a foundational understanding of physics so that we can better grasp the Physics
    engine behind Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I know that some of you might find physics somewhat boring. This may be the
    case if it awakes some bad memory (or memories) from high school. But my personal
    opinion is that knowing physics is really important to be a good game developer,
    especially when you need to program realistic behaviours. With this said, I promise
    that in this section, I'll try to be as clear as possible and use an informal
    language instead of the strict mathematical one so that these concepts can be
    understood by anyone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Classical mechanics of rigidbodies can be divided into two sub-branches:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kinematics: Which deals with the study of the motion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dynamics: Which deals with the causes of the motion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, once again, they are faces of the same coin. In fact, dynamic equations
    need kinematic ones, so as to describe and predict the motion of rigidbodies.
    We will see them in a bit more detail soon, but first let's focus on some basic
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: World coordinates and local coordinates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have already seen in [Chapter 2](part0028.xhtml#aid-QMFO1 "Chapter 2. Baking
    Cupcake Towers"), *Baking Cupcake Towers,* there is a difference in using world
    coordinates and local coordinates. This is also an important concept in physics:
    which one is your reference frame (or coordinate system)? The question is key
    in determining also the values of the different physics quantities. Therefore,
    every time you have a physical quantity, you need to ask yourself in which reference
    frame are you working.'
  prefs: []
  type: TYPE_NORMAL
- en: In any case, there isn't a frame that is privileged with respect to another
    (although some physical systems are easier to describe within a frame instead
    of another). So, by convention, a world frame is defined when we start the description
    of a physical system. For example, if you are driving your car, what is your velocity?
    Well, the answer depends on the coordinate system, or reference frame in which
    I'm describing the car moving. In the car itself, the speed of the car is zero,
    but rather the world is coming towards the car. Whereas for a pedestrian, the
    car is moving, and the world is not. An astronaut on the moon will see both the
    pedestrian moving really fast, along with the whole Earth, and also the car, at
    two different speeds. All of these descriptions are physically correct. Therefore,
    all quantities in physics depends on the reference frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'In game engines such as Unity and/or Unreal, there is always a defined world
    frame (when you have the position with all zeros at the center of the world frame)
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![World coordinates and local coordinates](img/image00513.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows how other frames are described in terms of linear
    and angular offset from the world frame. Moreover, you can describe a frame in
    terms of another, which is not the world frame (in the preceding diagram, look
    at the angular offset of frame **#3**). In Unity, you can consider the world frame
    as the global coordinates and the different frames as the local coordinates of
    game objects in the game. Children of game objects will be expressed in terms
    of the frame of the parent.
  prefs: []
  type: TYPE_NORMAL
- en: Velocity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Velocity in physics describes a relation between the space and the time of an
    object; in other words, how the object changes position with respect to a reference
    frame as a function of time. When the object is not accelerating, velocity is
    defined as distance covered in space divided by time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For those of you who are curious, when an object changes its velocity in each
    instant, and we need to get the velocity in a specific instant, it is possible
    to retrieve it by using derivatives (this is a topic of calculus, and I won't
    adventure deeper in this book).
  prefs: []
  type: TYPE_NORMAL
- en: Velocity is a vector, and therefore it has two coordinates in the 2D world (three
    in the 3D world), which express a direction and an intensity. The intensity of
    a velocity is also called **speed**. So it's important to not get confused between
    the two. In fact, speed is a scalar, just a number, acting independently if we
    are dealing with 2D or 3D games; velocity, instead, does change (from two numbers
    to three numbers to express respectively the 2D or 3D vector).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we use the term velocity, we mean the velocity in the defined world
    frame (or coordinate). When we use the term relative velocity, we are taking the
    velocity with respect to another frame. For instance, imagine that there are two
    cars that are heading against each other, both at 50 Km/h (in the world frame,
    because when you look at your tachymeter, by convention, that is the velocity
    with respect to the Earth). For one of the two drivers, the car he is driving
    is not moving (in fact, when you drive, your steering wheel is not going 50 Km/h
    away from your hands, but it is always at the same distance from you). However,
    he will see the other car with the other driver coming at 100 Km/h towards him.
  prefs: []
  type: TYPE_NORMAL
- en: Mass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In classical mechanics, every rigid body has a mass, which you can imagine as
    the amount of matter that forms that body. Thus, it is considered a property of
    the physical body. Often in spoken language, mass is confused with weight. In
    fact, mass is measured in kg (kilograms) in the International System of Units,
    whereas weight is measured in N (newton) in the International System of Units.
    Therefore, a scale is not measuring your weight, but rather your mass. Weight
    is a force and depends on the location where you are. Your weight is different
    on the moon, but your mass is the same.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, mass is also defined as the measure of an object's resistance to
    acceleration (a change in its state of motion) when a force is applied. In fact,
    you need much more force to move a truck than your laptop.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is worthwhile paying attention that, for instance, both the laptop
    and the truck (in absence of other external forces) are attracted by the gravity
    of the Earth and that both will fall down and touch the ground at the same time.
    In fact, when the universal gravitation equation of Newton is applied, the forces
    applied are different but the resulting gravitational acceleration is the same
    for both objects (since the mass is simplified from the equations).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the more curious of you, this was discovered by the famous Italian astronomer,
    physicist, engineer, philosopher, and mathematician Galileo Galilei, much before
    Newton formalized gravitation. There is an anecdote in which Galileo had dropped
    balls of the same material but different masses from the Leaning Tower of Pisa
    to demonstrate that their time of descent was independent of their mass. In this
    way, he proved that Aristotle''s idea that heavy objects fall faster than lighter
    ones, in direct proportion to weight (at that time intended as mass) was wrong
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mass](img/image00514.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Centre of mass
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine you need to calculate or predict the trajectory of an arrow. Taking
    into consideration the whole shape of the arrow and knowing that different forces
    come into play at each point ends up in a really tricky calculation (although
    possible). Therefore, the center of mass is an approximation that works pretty
    well for rigid bodies. It consists of concentrating the whole mass of an object
    into a single point (which is an abstraction to imagine all of the mass of that
    body in that single point). Where this point is depends on the shape of the object
    (since it is weighted among all the points the object is composed of), and this
    carries enough information about the shape to do really precise calculations.
    Especially in real-time applications, this becomes critical, since calculations
    of motion are greatly simplified. In fact, Unity will only do calculations using
    the center of mass.
  prefs: []
  type: TYPE_NORMAL
- en: '![Centre of mass](img/image00515.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The center of mass is the weight average of all the points in the system, where
    the weights are the different masses. From the diagram, we can see that center
    of mass is closer to m1 and m3, since they are bigger (have more mass) than m2.
  prefs: []
  type: TYPE_NORMAL
- en: Kinematics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term kinematics was used for the first time around 1840, as the translation
    of the French term *cinématique*, which was used by *André-Marie Ampère* (the
    famous French physicist and one of the founders of classical electromagnetism
    — so famous that the electric current unit in the International System of Units,
    the ampere, was named after him). However, the origin of the term derives from
    the Greek word *kinesis*, which means movement or motion.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have a better understanding of what kinematics is in physics, let''s refer
    to Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Kinematics is the branch of classical mechanics which describes the motion
    of points (alternatively particles), bodies (objects), and systems of bodies without
    consideration of the masses of those objects nor the forces that may have caused
    the motion. Kinematics as a field of study is often referred to as the geometry
    of motion."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Kinematics takes into consideration just the motion of an object and not the
    causes of the motion. This gives us some advantages when it comes to game development.
    First of all, it is cheaper from a computational point of view to take into consideration
    just the kinematics of an object. Then, we might not want to have a fully realistic
    object in our scene, and so we can just define its kinematic properties. We will
    see this in detail later when we will deal with kinematic bodies in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, in our world, a pure kinematic body doesn't exist; all of them are
    dynamic. Yet, studying just the kinematics of an object gives us insights into
    its motion.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term dynamic was used in the 19^(th) century in the meaning of pertaining
    to the force producing motion, as opposite to static. Once again, it takes its
    origin from the French term *dynamique*, although it was introduced by the famous
    German mathematician and philosopher, Gottfried Wilhelm Leibnitz. However, the
    origin of this term is again from the Greek word *dynamikos*, which means powerful,
    and also from *dynamis* (power) and *dynasthai* (to be able to, to have power,
    and to be strong enough).
  prefs: []
  type: TYPE_NORMAL
- en: 'If not already explicitly suggested, every time we deal with something dynamic
    in physics, we are dealing with forces (which have a certain power to move objects).
    From Wikipedia we can read:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Dynamics is a branch of applied mathematics (specifically classical mechanics)
    concerned with the study of forces and torques and their effect on motion, as
    opposed to kinematics, which studies the motion of objects without reference to
    its causes. Isaac Newton defined the fundamental physical laws which govern dynamics
    in physics, especially his second law of motion."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Therefore, dynamics is built on top of kinematics and gives a better description/prediction
    of how the body will move. In fact, by taking forces into consideration, mass,
    gravity, drag, and many other things become really important and relevant.
  prefs: []
  type: TYPE_NORMAL
- en: Force and torque
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**"Forces are those things that allow motion; they are responsible for creating
    a motion*."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Every force applies an acceleration to a body, which is calculated with Newton''s
    second law. It is so simple and elegant that it''s easy to understand. We can
    see this law as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Force and torque](img/image00516.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Where *F* represents the force, which is a vector (so the arrow above the formula),
    *m* is the mass, and *a* is the acceleration, which is another vector (so the
    arrow above its symbol in the formula).
  prefs: []
  type: TYPE_NORMAL
- en: This means that if you apply a force to an object with mass *m*, you know that
    the acceleration is *F/m*. So, just divide the force by the mass of an object
    and you can calculate how much it will be accelerated. Please note that if we
    have two objects on which we apply the same force but they have two different
    masses, the one with the higher mass will have a lower acceleration, because the
    force is divided by a greater number.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of force is important because it is the cause of motion, and many
    Physics engines (including the one of Unity) allow you to specify forces.
  prefs: []
  type: TYPE_NORMAL
- en: Another important concept is torque, also called moment of force or just moment,
    which in some way expresses a force that makes an object rotate along an axis
    instead of moving it. If you think of force like a pull or push, you can imagine
    torque as a twist.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To those of you who know a bit more about the cross-product of vectors, torque
    is defined as the cross-product between the force vector and the distance vector
    from the application point of the force. As a result, it tends to produce rotational
    motion. Therefore, the formula is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Force and torque](img/image00517.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Where *τ* (read tau) is the torque, *F* is the force vector, and *r* is the
    distance vector, also called offset.
  prefs: []
  type: TYPE_NORMAL
- en: In the the International System of Units, torque is measured in *N·m* (Newton
    meter).
  prefs: []
  type: TYPE_NORMAL
- en: The formula of torque is a bit more complicated since it involves the cross-product,
    and one who has just started to deal with physics in video games and uses a graphics
    engine like Unity doesn't need to know/understand the formula straightaway. However,
    it is important to understand that this quantity deals with rotations, and applying
    a torque on a rigid body means that it will rotate along an axis depending on
    where the torque is applied. Just remember that torque is not a force, although
    it might seem so due to the way we will deal with it within Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Collisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In classical mechanics, there are different kinds of collisions between rigid
    bodies that may happen. They are divided into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Elastic collisions, in which all the kinetic energy is conserved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inelastic collisions, in which part of the kinetic energy is transformed into
    another form of energy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To go through this chapter, it''s not important to understand them well, but
    it is important to understand that the type of collision may change the behaviour
    of what happens after the collision. Imagine two balls: one rolling towards the
    second, which is not moving. At a certain point, the first one will collide with
    the second. Depending on which kind of collision happens, the result may differ.
    In one scenario, both the balls will roll in the same direction and they will
    be as if they were attached. In another scenario, the first one stops and the
    second one starts to roll. In a third scenario they roll at different velocities
    and directions after the collision.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collisions](img/image00518.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The three possible after-collision scenarios
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more, a web page that explains the basic concepts of different
    collisions in a quite simple way is [http://hyperphysics.phy-astr.gsu.edu/hbase/elacol.html](http://hyperphysics.phy-astr.gsu.edu/hbase/elacol.html).
    However, it is intended for those who already have a clear knowledge of the basic
    concepts and formulae of physics.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The website itself, [http://hyperphysics.phy-astr.gsu.edu](http://hyperphysics.phy-astr.gsu.edu),
    is a good source for quick references to the main concepts of physics. However,
    a minimum of prerequisites are needed to fully understand what's on it. The best
    way to start is always with a physics book, which may be boring, but mastering
    those concepts is a great advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Rigid body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A rigid body, as the name suggests, is a body that translates and rotates all
    together. So for instance, a Christmas ball, a television, or a flying disk are
    rigid bodies, because all their parts move together. A laptop is not, because
    its lid can rotate, as well as a door if you consider the frame too as a part
    of the whole. But, these kinds of objects can be described with two different
    rigid bodies, such as the door-frame and the door itself, which may constrain
    each other (in this case with a Hinge). Water, air, toothpaste, or a dress are
    not considered rigid bodies, because all their parts don't move together.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the objects in your game will be rigidbodies (I'm writing it attached
    because this is the way Unity will refer to them), or they can be approximated
    to rigidbodies, so knowing them well is key to learning physics in Unity. In fact,
    most of the 2D Physics engine of unity is focused on rigid bodies (as we will
    see soon), and therefore this chapter is about them.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating clothes, liquids, and other physical entities that are not rigidbodies
    is generally harder, although possible. But often they are used in 3D games, and
    we won't deal these aspects in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the most curious of you, here is a more precise definition: A **rigid body**
    is the idealization of a solid body, where deformation is neglected. Therefore,
    the distance between any two points within the rigid body remains constant over
    time, independently of the forces that will apply on the rigid body.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in our world such objects don't exist. In fact they are idealizations,
    but they approximate the behaviour of solid objects pretty well (unless the speed
    of an object is near the speed of light).
  prefs: []
  type: TYPE_NORMAL
- en: Friction – linear and angular drag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a kid were to ask me, "what is friction?" I would reply, "friction is the
    thing without which all things wouldn't stop moving". Even if this is not a formal
    definition, it helps to understand what friction is. It comes into play when you
    consider the dynamics of an object, because friction generates a force that opposes
    to the motion of the physical body. There are many types of frictions and they
    depend on different factors. For instance, air drag depends on the velocity of
    an object, whereas dry friction depends on the normal force (which depends on
    the surface, position of an object, its weight, and therefore also its mass).
  prefs: []
  type: TYPE_NORMAL
- en: In games, except for specific needs, you don't need all these kinds of frictions
    and drags. For instance, in Unity you can control just the linear and the angular
    drag. The first one opposes the motion of an object along a trajectory (or better,
    the trajectory of the center of mass of the object; otherwise it would be too
    complicated to do in real time) and the angular to the rotation of an object.
    So, in Unity, an object that has both nonzero values for linear and angular drag
    will eventually stop moving and rotating (in the absence of other forces).
  prefs: []
  type: TYPE_NORMAL
- en: The Unity Physics engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unity has a Physics engine integrated into it, which is able to handle both
    kinematic and dynamic types of rigid bodies as well as other physical entities
    such as clothes. It is divided into two parts: 2D Physics and 3D Physics. It''s
    important to understand that although they can coexist together in the same scene,
    they are two separate entities; they cannot communicate between themselves. Physical
    objects under 2D Physics will not interact with physical objects under 3D Physics.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore most of the 2D Physics engine of Unity. Although
    we will not use all the components presented here, it's important to master them
    all to become a better Unity developer.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Physics in Unity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Chapter 2, *Cooking Cupcake Towers, *we learnt about script ordering and
    how it is executed. The first question we may wonder is when does the Physics
    engine occur when a frame is rendered? The answer is not straightforward, because
    the Physics engine runs multiple times during a frame render. In any case, except
    particular cases (such as the application has paused or particular game objects
    are enabled/disabled in that frame), the Physics engine runs after the initialization
    (so all the `Awake()`, `Start()`, and `OnEnable()` functions) and before to gather
    inputs from the player and update the game logic.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, when we do a physics calculation (we will see these later in the
    chapter), we need to use the `FixedUpdate()` function, which is called more than
    once per frame, and all the times just before the Physics engine performs its
    calculation. As such, if we need to retrieve the time, we cannot use `Time.deltaTime`;
    instead we need to use `Time.fixedDeltaTime`.
  prefs: []
  type: TYPE_NORMAL
- en: Another question we may wonder is when it is appropriate to use the Physics
    engine of Unity. In theory, you don't need to use it, because you can program
    from scratch all the collisions and/or physic behaviours. In practice, it solves
    many common problems with minimum coding and it is indeed useful. These problems
    are not necessarily physics problems. In fact, some of them include certain game
    mechanics that may enhance the quality of your game when using a physics approach
    (such as the movement of the character). Others include gathering information
    from the environment for scripting other behaviours (such as a script that needs
    to know how many targets there are within a zone).
  prefs: []
  type: TYPE_NORMAL
- en: Physics settings in Unity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, the Physics engine of Unity has some general settings, which should
    be taken into account. They define global physical properties of your game, such
    as the value of gravity, what will collide with what, and how accurate the Physics
    simulation should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have access to the Physics settings in Unity by navigating through
    **Edit | Project Settings | Physics 2D** as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Physics settings in Unity](img/image00519.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similarly, you can have access to the 3D Physics setting by navigating through
    **Edit | Project Settings | Physics**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screen will appear in the **Inspector** view (the most important
    parameters are highlighted, which we will see in detail in this section):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Physics settings in Unity](img/image00520.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there are many options you can tweak. Most of the time, especially
    for simple games (like the one we are building), the default settings will be
    more than fine. But Unity offers you the chance to adapt them to your game.
  prefs: []
  type: TYPE_NORMAL
- en: Most of them deal with how accurate the Unity Physics engine is. Therefore,
    there is a trade-off between accuracy and efficiency, since more accurate means
    more expensive from a computational point of view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the main ones in detail (if you are interested in learning
    also about the others, see the optional, *Other things about Physics* section
    later in the chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gravity**: The vector that defines the gravity acceleration. By default,
    it is a negative value only along the *y-*axis. In particular, the absolute value
    of 9.81 corresponds to the one on the Earth, if we let the Unity units be meters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default Material**: The physical material used by all the colliders and rigidbodies
    that don''t have one set (we will see more about physical materials later on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time To Sleep**: The time, expressed in seconds, that needs to pass before
    a Rigidbody 2D goes to sleep, which means that it is not updated anymore by the
    Physics engine (we will see more about rigidbodies and their sleeping later on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear Sleep Tolerance**: This is the linear speed below which the rigidbody
    after **Time to Sleep** goes to sleep. Imagine you have many objects in your game
    that drag is slowing down, and now they are so slow that the player can barely
    perceive their motion. As such, it''s a waste of computational resources to keep
    them updated in the Physics engine. Therefore, this variable puts a limit to the
    lowest velocity an object can have before it goes to sleep (no more updates from
    the Physics engine). The lower this value, the more accurate the simulation will
    be, but it will also be more expensive if many objects are moving at velocities
    above that one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Sleep Tolerance**: The angular speed below which the rigidbody after
    **Time to Sleep** goes to sleep. Imagine the same situation as before, but instead
    the body is rotating really slowly. The same reasoning applies: the lower the
    value, the more accurate the simulation, but usually it is more expensive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer Collision Matrix**: This determines which kinds of objects collide
    with others. By default, everything is checked, but you may want to make two particular
    kinds of objects not collide among them. Objects are discriminated based on the
    physical layer they are in. If you remember, we talked about layers and tags in
    Chapter 1, *A Flat World in Unity*. So, through the layer menu, you can create
    new layers, and in the **Inspector**, you can assign a layer to a particular game
    object. To make things easier, the **Layer Collision Matrix** is presented in
    this screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Physics settings in Unity](img/image00521.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For our game, we can leave all the default values since they are more than fine
    for what we need.
  prefs: []
  type: TYPE_NORMAL
- en: Physics components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Physics engine of Unity works by components. Some describe properties of
    the object itself, others with respect to each other, or some even within a certain
    region of the game world.
  prefs: []
  type: TYPE_NORMAL
- en: 'They can be divided as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rigidbodies: Which define a rigidbody within the Physics engine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Colliders: Which define a physical shape for the rigidbodies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Joints: Which impose one or more constraints on the rigidbodies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effectors: Which change the physical property in some region of the game world,
    influencing all the rigidbodies within that region
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Physics components](img/image00522.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A summary diagram of the different components of the 2D Physics engine of Unity
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see them in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Rigidbodies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rigidbodies are, along with Colliders, the core of the Physics engine beneath
    Unity. When they are attached to a game object, they place it under the control
    of the Physics engine, which will take care to properly move its Transform. In
    fact, they should be moved with other functions, and scripts shouldn't touch the
    Transform. We will see this in detail later.
  prefs: []
  type: TYPE_NORMAL
- en: The exact name of the component is **Rigidbody 2D** (whereas **Rigidbody** is
    for the 3D Physics engine, but for brevity many times we will use the term rigidbody
    to specify a **Rigidbody 2D** component).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From Unity 5.4, and then again in Unity 5.5, the **Rigidbody 2D** component
    has slightly changed. In fact, many improvements have been made to the Physics
    engine of Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the component is added to a game object, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rigidbodies](img/image00523.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How a Rigidbody 2D works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every time we wanted to position an object (or its children) or move it, we
    changed its Transform, which defines where it is in the space as well as how it
    is rotated or scaled. However, the Physics engine will simulate how the object
    will interact in a world where physics is simulated. So, if the object has a collision
    with another one, it will change direction or speed. This means that the Physics
    engine has to change in some way the Transform of the object (that's why we shouldn't
    touch it with scripts for physical objects; we will see later how to deal with
    them by scripting). This way is the Rigidbody component, which is a sort of hub
    between the Physics engine and the properties of the object, including the Transform.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, after the Physics engine has made its calculation, it communicates
    with the rigidbody, which needs to be in its next position, and the Rigidbody
    component provides to change the Transform to match that new position.
  prefs: []
  type: TYPE_NORMAL
- en: The same applies to colliders (we will see them in detail soon). Each collider
    attached to the same object of the rigidbody (or to some of its children) will
    be linked to the rigidbody, and we shouldn't modify the collider or move it but
    instead move the whole rigidbody. These colliders, which are linked to the rigidbody,
    allow the rigidbody to actually collide with colliders of another rigidbody and
    give them a shape in the physics world.
  prefs: []
  type: TYPE_NORMAL
- en: Body types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most important variable in a **Rigidbody 2D** is the **Body Type**, which
    is highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Body types](img/image00524.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are using a previous version of Unity (older than 5.5), this variable
    won''t be available. However, you can still get the kinematic mode by checking
    the **Is Kinematic** parameter, which is available in older versions (from 5.4
    and below). You can see this highlighted in the following screenshot (Unity 5.4):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Body types](img/image00525.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And here in Unity 5.3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Body types](img/image00526.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Older versions, such as 5.2 and below, are similar to the 5.3.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, depending on how the **Body Type** is set, it affects the other settings
    available on the component. Moreover, it's important to remember that any **Collider
    2D** attached to a **Rigidbody 2D** inherits the **Rigidbody 2D** component's **Body
    Type**.
  prefs: []
  type: TYPE_NORMAL
- en: The **Body Type** determines how the object will move, how the colliders will
    interact, and therefore also how computationally expensive that rigidbody will
    be.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the **Body Type** of a **Rigidbody 2D** at runtime can be complicated.
    There are a few things that you need to consider; for example, when a **Body Type**
    changes, various mass-related internal properties are recalculated immediately.
    In addition, all existing contacts for the Collider 2D components attached to
    the Rigidbody 2D need to be reevaluated during the GameObject's next `FixedUpdate`.
    As a result, depending on the number of contacts and Collider 2D components that
    are attached to the body, when you change the **Body Type** of the rigidbody,
    it can cause variations in performance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's worthwhile to mention that sometimes rigidbodies are described as colliding
    with each other. Although this is true when we talk about physics (so when we
    talk of rigid bodies), it is not true in the case of Rigidbody 2D(the component
    of Unity). In fact, in terms of the Physics engine of Unity, only colliders attached
    to rigidbodies will collide. However, saying that two rigidbodies have collided
    is a short way of saying that their colliders have hit each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Body Type** can be set to be of three types. Let''s see them in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic**: This means that the rigidbody will follow all dynamic calculations,
    which means dealing with forces that cause motion. In fact, the rigidbody will
    have a mass and both linear and angular drag. Moreover, the body will be affected
    by gravity as well. In fact, this is the default body type, since it is the most
    used and collides with everything. But exactly for this reason, it is also the
    most computationally expensive body type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kinematic**: This means that the body is still able to move as a physical
    object, but there are no forces for its motion, and therefore it is not affected
    by gravity either. In fact, you need to script its motion with any formula (we
    will see this later), which may or may not be physically realistic (or maybe it
    is in your game world). However, it is still able to collide, which means the
    Physics engine will notify your script that the rigidbody has collided, and then
    it''s up to us what happens next. In the case of a collision with a dynamic body
    type, the kinematic one is considered immovable, which means with an infinite
    mass. In fact, all dynamic properties, such as mass, are not available. From a
    computational point of view, the kinematic body type is faster than the dynamic
    one, since not calculating all the dynamic forces demands less resources from
    the Physics engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static**: This means the rigidbody is not supposed to move at all under the
    Physics engine (or under simulation). This is intended for an object with infinite
    mass. Under a simulation, a static Rigidbody 2D is designed to not move. In the
    instance of something colliding with it, a static Rigidbody 2D behaves like an
    immovable object (as if it has infinite mass). It is also the least resource-intensive
    body type to use. A static body only collides with dynamic Rigidbody 2Ds. Having
    two static Rigidbody 2Ds collide is not supported. This is simply because they
    are not designed to move. As a result, there are a limited number of properties
    that are available for this body type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To better understand the differences between these body types, here is a table
    with the different features available for each one of them (we will see them in
    detail in the next section):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Body types](img/image00527.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Rigidbody properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous table, we saw many properties; they may or may not be available
    for some body types. But what do they actually do and what do they determine for
    the rigidbody? Let''s explore these properties in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Material**: A physics material that determines properties of collisions,
    such as friction and bounce (we will see more about physics materials later).
    This material will be applied to all the colliders under the control of the rigidbody
    (we will see more about colliders in the next section). This comes in handy when
    you need to have many colliders with the same physics material.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simulated**: A checkbox that enables the rigidbody to interact with the Physics
    engine. If it is unchecked, then the rigidbody and so all the colliders referring
    to it will be disabled and transparent for the Physics engine as if they don''t
    exist. This is useful to enable and disable many colliders at runtime (see the
    optional *More about physics* section to know more).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Auto Mass**: A checkbox that, if enabled, allows Unity to calculate the
    mass of the object by itself. These calculations are based on the dimension and
    density of each of the colliders that are referring to that specific rigidbody.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mass**: If the previous checkbox is disabled, we can manually specify a mass
    for our rigidbody.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear Drag**: The value of the linear drag that affects the rigidbody. If
    it is different from zero, the object will eventually stop moving.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Drag**: The value of the angular drag that affects the rigidbody.
    If it is different from zero, the object will eventually stop rotating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gravity Scale**: This is a multiplier to the gravity value for that specific
    rigidbody. This means that a value of `0.4` will reduce the gravity to 40% of
    its original value. This is useful when in your game you have objects that react
    to gravity in a different way. Imagine a fireball cast by your wizard; you may
    want it to have a rather straight trajectory (even if it is still a parabola,
    unless the trajectory is completely straight and the **Gravity Scale** is set
    to `0`, which means no gravity affects the rigidbody). Whereas you want the grenade
    of your soldier to have a clear parabolic trajectory, since it is affected by
    gravity. Values greater than `1` lead to a stronger gravity than for its original
    value as shown in the following diagram:![Rigidbody properties](img/image00528.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the left in the preceding diagram is a fireball, which is not affected by
    gravity when the gravity scale is set to zero, leading to a straight line trajectory.
    On the right is a grenade, which is affected by gravity (because the gravity scale
    is greater than zero; in this case, it is exactly `1`, which means normal gravity).
    Without other forces, rigidbodies with a linear velocity and affected by gravity
    have a parabolic trajectory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Use Full Kinematic Contacts**: A checkbox available only for kinematic body
    types. If enabled, it allows the kinematic rigidbody to collide with other kinematic
    rigidbodies. By default, it is set to false, which means that the rigidbody will
    only collide with dynamic rigidbodies (with the exception of colliders set as
    triggers).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collision Detection**: The way Unity detects collisions. It can be either
    **Discrete** or **Continuous**. In the first case, collision detection is calculated
    only on the position of the physical objects, and if they collide (which means
    that if the colliders overlap after the update of the positions of the objects,
    then Unity calculates the collision). On the contrary, continuous collision detection
    is calculated on the trajectory itself and not only on the positions of the objects.
    Imagine you have a really fast bullet, which is heading against a really thin
    wall. Since the game is discrete (the game renders frame by frame), when the bullet
    is near the wall, in the next update, it can be so fast that its new position
    is behind the wall. As such, with discrete collision detection, the bullet has
    crossed the wall without problems, because the Physics engine doesn''t detect
    any collision. With continuous collision detection instead, the Physics engine
    is aware of the trajectory that the bullet has followed and does calculations
    on it. So, even if the the final position of the bullet is behind the wall, the
    collision is detected and it is properly handled by the Physics engine, which
    recalculates the new position of the bullet taking the collision into account
    as shown in the following diagram:![Rigidbody properties](img/image00529.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the left in the preceding diagram is the discrete method, in which only the
    different positions between frames are taken into consideration. Therefore, if
    the position of the bullet in the next frame is behind the wall, the discrete
    method won't detect the collision. On the right is the continuous method, in which
    the whole trajectory of the bullet is taken into consideration. Therefore, even
    if in the next frame the bullet is behind the wall, the collision is detected
    and a new position is calculated based on the collision. This second method is
    a bit more computationally expensive.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Sleeping Mode**: This is the way Unity deals with whether a rigidbody should
    be awake or sleeping at the beginning, or whether it has the possibility to sleep
    at all. The possible choices of this variable, with self-explanatory names, are:
    **Never Sleep**, **Start Awake**, and **Start Asleep**. A rigidbody is sleeping
    when it is not taken completely into consideration by the Physics engine (it differs
    from not being simulated, and now we see why). Imagine how many objects in your
    game could be potently moving but they don''t at the moment. For example, imagine
    a ball pit with thousands of balls, but at the moment none of them are moving.
    In this scenario, it''s useless to call each one of them in the Physics engine
    for void calculations. Another example: imagine a pendulum that is stopping, and
    its oscillation arc is too small to be perceived by the player. Calculating the
    exact position of the pendulum on this arc is a waste of computational resources.
    It''s better to stop the pendulum or the balls (set them into sleeping mode) until
    an event, such as the player diving in the ball pit or pushing the pendulum. So,
    for performance reasons, not all rigidbodies are awake at any moment. However,
    they can be awoken by an event, which is usually automatic in the Physics engine.
    But it can also be controlled by you within a script (we will see more details
    about this in the next section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interpolate**: When a rigidbody is moving, maybe under a force, the Physics
    engine performs some calculations on which will be its next position. However,
    the Physics engine is not perfect and cannot replicate our physics. In fact, algorithms
    are subjected to numerical instability, which may result in a jerky motion in
    our case. Therefore, Unity offers you two ways to smooth the motion and make it
    less jerky, plus the option **None**, in which no smoothing is performed. The
    first way, called **Interpolate**, takes into consideration the previous position
    of the rigidbody. On the contrary, the second way, called **Extrapolate**, takes
    into consideration the prevision of the next position of the object. Both methods
    work well, and you can perceive the difference between them and **None**. However,
    the difference between the two could be tricky to understand, especially since
    their behaviour is really similar, and understanding which one is better for your
    game can sometimes be determined just by trial and error (unless you have really
    specific needs).![Rigidbody properties](img/image00530.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the left, the trajectory is not interpolated; it leads to a fragmented trajectory.
    On the right, the trajectory is interpolated and its curve is smoothed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Constraints**: These prevent the rigid body from moving or rotating in a
    certain way, if not at all. In the case of 2D, you can freeze the motion along
    *x* or *y* or both axes and rotation along the *z-*axis. All of them are independent
    checkboxes, which can be selected in any combination. Of course, having all of
    them selected means that the rigidbody won''t be able to move. Imagine you are
    developing a puzzle game and your main character game needs to move a box, maybe
    by pushing it. However, we don''t want the box to start to rotate on itself if
    the player doesn''t push the middle point of the box. As such, we can freeze the
    rotation of the box, still allowing the box to move and be pushed by the main
    character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Rigidbody properties](img/image00531.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: On the left, there are no constraints, and therefore when the player pushes,
    the object might rotate. On the right, the rotation is frozen, and when the player
    pushes, the object won't rotate. Which behaviour to choose depends on the design
    of your game.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Info****:** A foldout showing all the other variables of the rigidbody, which
    is very useful in debugging.'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with rigidbodies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have explored the Rigidbody 2D component in detail, let's see how
    we can deal with it within scripts. As previously explained, scripts are not supposed
    to change the Transform of a rigidbody. So how we can move them? The answer is
    that some special functions exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'These functions need to be called on the rigidbody; therefore probably you
    may want to have a reference to the Rigidbody 2D, like this fragment of script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, you can call the functions in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Where of course, instead of `NameOfTheFunction` there will be one of the functions
    listed next. However, if you remember, the Physics engine might be called more
    than once per frame, and therefore all of these functions should be called within
    `FixedUpdate()`.
  prefs: []
  type: TYPE_NORMAL
- en: So how can we actually move a rigidbody? For dynamic body types, we can either
    just leave them at the mercy of the external forces such as gravity, collisions,
    and so on, or we can apply a specific force.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to apply a force to the rigidbody, there are the following useful
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AddForce(Vector2 force, ForceMode2D mode = ForceMode2D.Force)`: Applies a
    force specified in the `force` parameter. Moreover, enum  `ForceMode2D` is an
    optional parameter that specifies whether the force should act as an impulse or
    not. By default, it is not an impulse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddForceAtPosition(Vector2 force, Vector2 position, ForceMode2D mode = ForceMode2D.Force)`:
    Behaves like the previous function, but you can also specify an application point
    for the force.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddRelativeForce(Vector2 relativeForce, ForceMode2D mode = ForceMode2D.Force)`:
    Behaves like the first function, but the force is specified in local coordinates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddTorque(float torque, ForceMode2D mode = ForceMode2D.Force)`: This applies
    a torque to the rigidbody; likewise, the first function applies instead a force.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For kinematic body types instead, we have two functions to explicitly move
    these kinds of body types and still allow the Physics engine to perform collision
    detection correctly. Inside these functions, we directly pass a position and a
    rotation, which can be calculated with any formula. Therefore they can follow
    any physics law you want (or one that is meaningful in your game):'
  prefs: []
  type: TYPE_NORMAL
- en: '`public void MovePosition(Vector2 position)`: Moves the rigidbody to the specified
    position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void MoveRotation(float angle)`: Rotates the rigidbody to the specified
    angle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The easiest example is to apply the classical kinematic law for velocity to
    make the kinematic body move in a straight line indefinitely. For the most curious
    of you, the formula is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dealing with rigidbodies](img/image00532.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The ∆ (read delta) in physics means the final minus the initialwhich can be
    rewritten (by explicitly separating the delta of the space) as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dealing with rigidbodies](img/image00533.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can translate this into Unity with the following fragment of code (instead
    of `Time.deltaTime`, we need to use `Time.deltaFixedTime`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, we have some or the other function for all kinds of body types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IsAwake()`: Returns true if the rigidbody is awake.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsSleeping()`: Returns true if the rigidbody is sleeping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsTouching(Collider2D collider)`: Returns true if the collider is touching
    the rigidbody (which means any of the colliders attached to the rigidbody)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OverlapPoint(Vector2 point)`: Returns true if the point is overlapping the
    rigidbody (which means any of the colliders attached to the rigidbody)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sleep()`: Makes the rigidbody sleep'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WakeUp()`: Disables the sleeping mode of the rigidbody'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the full list of functions and variables of a Rigidbody 2D component, you
    can consult the official documentation here: [https://docs.unity3d.com/ScriptReference/Rigidbody2D.html](https://docs.unity3d.com/ScriptReference/Rigidbody2D.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Colliders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you have the heroine of your game moving in a complex environment;
    by complex, I mean detailed, for instance, the kitchen of the king's castle. If
    the Physics engine is super realistic, it should take in consideration that the
    hand of the heroine can go over the table, as far as the body stays on its side.
    However, this is impossible (or at least out of reach for the current hardware
    of your players) to run in real time. So colliders provide an approximate shape
    for objects and characters that need to have some kind of physical interaction,
    such as a collision. For instance, characters are often approximated as a capsule-shaped
    collider and objects with a sphere-shaped or box-shaped collider. Of course, if
    a deeper level of detail is required, different colliders can act as a more complex
    one. And ultimately, all the polygons of the 3D model (or perimeter of the 2D
    Sprite) can be part of the collider, having a much better realism but at the cost
    of performance. Therefore, you'll want to be careful to always have the right
    level of detail for each situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unity, colliders can be of five types, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Appearance in the **Inspector**** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **Circle Collider 2D** | ![Colliders](img/image00534.jpeg) | The collider''s
    shape is a circle, which is defined by a position and a radius expressed in the
    local coordinate. |'
  prefs: []
  type: TYPE_TB
- en: '| **Box Collider 2D** | ![Colliders](img/image00535.jpeg) | The collider''s
    shape is a rectangle aligned to the world axis (*x* and *y*), and it is defined
    with a width and a height in the local coordinate. |'
  prefs: []
  type: TYPE_TB
- en: '| **Polygon Collider 2D** | ![Colliders](img/image00536.jpeg) | The collider''s
    shape is defined by a freeform edge made of line segments. In this way, you can
    adjust it to fit the shape of the Sprite graphic with great precision. Please
    note that this collider''s edge must completely enclose an area (unlike **Edge
    Collider 2D**). |'
  prefs: []
  type: TYPE_TB
- en: '| **Edge Collider 2D** | ![Colliders](img/image00537.jpeg) | The collider''s
    shape is defined by a freeform edge made of line segments. In this way, you can
    adjust it to fit the shape of the Sprite graphic with great precision. Unlike
    the **Polygon Collider 2D**, its edge does not necessarily enclose an area. For
    instance, it''s possible to create an *N* shape or just a straight line. |'
  prefs: []
  type: TYPE_TB
- en: '| **Capsule Collider 2D** | ![Colliders](img/image00538.jpeg) | The collider''s
    shape is a capsule without vertexes (so that it is hard it remains stuck between
    vertexes or corners of other colliders). Moreover, it''s a solid collider, so
    if an object is completely inside this collider, it is pushed out and detected
    as colliding. |'
  prefs: []
  type: TYPE_TB
- en: All of them share the same core settings, and some additional ones to customize
    the shape of the collider. For instance, for **Circle Collider 2D**, we can decide
    the center and the radius. However, Unity automatically tries to enclose/envelop
    the Sprite or 3D model within the collider, though manual tweaking may be required
    (see further for editing the collider in a visual way).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since this book focuses on the 2D world, for brevity we will refer to the colliders
    without the ending 2D, assuming we are always referring to the 2D component and
    not to the 3D one with the same name. For example, **Box Collider 2D** becomes
    **Box Collider**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the core options of each collider:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Density**: This affects the mass of the rigidbody that it is referring to.
    A value of zero means that the collider will be completely ignored in the calculation
    of the mass of the rigidbody. The higher the value, the more the collider will
    contribute to the mass of the rigidbody.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't see the **Density** option, it's normal. In fact, it will be visible
    only if the option **Auto Mass** is enabled on the rigidbody associated (so attached
    on the same game object of the collider or on some of its parents up in the hierarchy).
    In fact, when the rigidbody component automatically calculates the mass, it takes
    into consideration all the colliders linked to that rigidbody and their densities.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Material**: A physics material that determines properties of collisions,
    such as friction and bounce (we will see more about physics materials later).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Is Trigger**: Check this if you want the collider to behave as a trigger.
    This means that the collider won''t be used to do collisions but rather to trigger
    something when another collider enters within this one (see the next section for
    more details).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Used By Effector**: Check this if you want the collider to be used by an
    attached effector (we will see more about effectors later).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Offset**: This is the offset of the collider geometry expressed in local
    coordinates; in other words, how far in terms of *x* and *y* the collider should
    be from the position of the game object on which it is attached.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Info**: A foldout showing all the other variables of the collider. It is
    very useful in debugging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, there are the specific ones for each collider:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Radius**: Used only for the circle collider, and it determines the radius
    of the circle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Size**: This is used only for the box and the capsule collider. In the first
    case, it determines the size of the box, and in the second the size of the box
    that the capsule fills up (and therefore indirectly the size of the capsule) as
    shown in the following diagram:![Colliders](img/image00539.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Points**: This is non-editable information for the polygon or edge colliders
    about their complexity. It describes all the points of the collider and how they
    are connected in paths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Direction**: This is used only for capsule colliders and it can be set to
    be either **Vertical** or **Horizontal**. This controls which way round the capsule
    sets; specifically, it defines the positioning of the semi-circular end-caps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Furthermore, it is possible to visually edit the colliders by clicking on the
    following icon, available in all the colliders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Colliders](img/image00540.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As a result, you will able to modify the collider directly into the **Scene**
    view. It is quite intuitive, so I'll let you explore this feature by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can create a vertex for the edge or polygon colliders by clicking on one
    of their edges.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with colliders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, in video games, when colliders collide, we want to trigger some actions
    and run specific code. For instance, imagine a bullet that hits the surface of
    the wall, we may want to instantiate a particle effect in the point, and remove
    the bullet. The same applies for a fireball, but with a fire effect. Or imagine
    the player walks through a door and a cut-scene is triggered. In this case, there
    is a volume trigger (a collider with **is Trigger** set to true) so that when
    the player enters, the volume triggers the cut-scene. Another example, is an area
    full of toxic gasses, and the longer the player stays in that area, his health
    is gradually reducing.
  prefs: []
  type: TYPE_NORMAL
- en: All of this can be achieved by using some special functions. If you remember,
    in [Chapter 2](part0028.xhtml#aid-QMFO1 "Chapter 2. Baking Cupcake Towers"), *Baking Cupcake
    Tower*, we have seen that every script that derives from monobehaviour could have
    some functions, such as `Start()` and `Update()` that are automatically called
    by Unity. Among these functions there are some that are called by the Physics
    engine of Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'For trigger volumes, there are the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnTriggerEnter2D(Collider2D other)`: This is called on both the rigidbody
    and the volume trigger when the former enters in the latter. Information about
    the other collider is passed as a parameter in the `other` variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnTriggerStay2D(Collider2D other)`: This is called on every frame on both
    the rigidbody and the volume trigger as long as the former is within the second
    one. Information about the other collider is passed as a parameter in the `other`
    variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnTriggerExit2D(Collider2D other)`: This is called on both the rigidbody and
    the trigger volume when the former leaves/exits the second one. Information about
    the other collider is passed as a parameter in the `other` variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For colliders not set to be triggers, there are similar functions. However,
    instead of having just information about the other collider, information about
    the whole collision is available through the class `Collision2D`, which stores
    — other than the colliders — the contact points, relative velocities, and so on.
    More information about this can be found here in the official documentation at: [https://docs.unity3d.com/ScriptReference/Collision2D.html](https://docs.unity3d.com/ScriptReference/Collision2D.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the functions for colliders are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnCollisionEnter2D(Collision2D coll)`: This is called on both the rigidbodies/colliders
    that have just made contact (had a collision). Information about the collision
    can be found inside the `coll` variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnCollisionStay2D(Collision2D coll)`: This is called on both rigidbodies/colliders
    every frame as long as they are touching each other. Information about the collision
    can be found inside the `coll` variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnCollisionExit2D(Collision2D coll)`: This is called on both two rigidbodies/colliders
    when they stop making contact. Information about their collision can be found
    inside the `coll` variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our specific case, we will need these functions (the trigger ones) to detect
    when the sprinkles hit the enemies, to reduce their health, and eventually trigger
    the right animation. We will see this at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Joints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have talked about rigid bodies and colliders, but they were just
    single physical bodies. What about more complex mechanical systems? Imagine a
    rope that is holding a cage with a skeleton and a key inside. So, our protagonist
    decides to cut the rope to make the cage fall. Once the rope is broken, then the
    cage falls down. However, even before the rope is cut, the cage was under the
    effect of gravity. In fact, if our protagonist would have pushed the cage instead
    of cutting the rope, that would have started to oscillate. The reason is that
    the rope is giving a constraint to the cage — it is allowed to move only within
    a circle (or sphere if we are in 3D) that has per radius the length of the rope.
    Of course, when it oscillates, gravity makes the cage move on the border of this
    circle (or sphere). What if the rope were a rigid metal bar? Well, the cage would
    even have a harder constraint, because now it is forced to be only on the border
    of the circle (or sphere). And if the rope was a spring? Again, this is another
    kind of constraint as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Joints](img/image00541.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Although the cage is under the force of the gravity, the rope imposes a reaction
    force. As a result, the cage doesn't fall. Therefore, the rope imposes a constraint
    on the cage. In particular, it limits the cage motion to be within a circle with
    a radius equal to the rope length.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine placing many of these constraints together. For instance, you tie
    up the cage to a pending spring, and from the bottom of the cage a rope is holding
    a metal sphere. The system would start to increase in complexity. But how does
    Unity handle all of this? The answer is, using Joints components.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that all the joints that finish with 2D belong to the 2D Physics engine;
    otherwise they belong to the 3D one. So be careful to not get confused or attach
    the wrong joint. However, from now on, we will always refer to it as Joint 2D,
    even without 2D, unless otherwise specified. This decision was made to make the
    chapter clear and more fluid to read.
  prefs: []
  type: TYPE_NORMAL
- en: Main properties of Joints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using a joint component, you can attach a rigidbody to another one, in order
    to give them a specific constraint, and still leave some freedom for the motion.
    In particular, Unity provides nine Joint 2D components. But before we go through
    each one of them, let's explore some general properties of the joints in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: The other rigidbody
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we''ve already said, a joint involves two rigidbodies (with the exception
    of the **Target Joint 2D**). The first is attached to the same object of the joint.
    The other one can be chosen arbitrarily. Therefore, these two options are available
    inside the joint components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enable Collision**: Both rigidbodies will have colliders. If this toggle
    is true, it means that the two rigidbodies will collide between them according
    to the Physics engine and what we have seen so far in the previous two sections.
    Most of the times, rigidbodies with a joint belong to the same big system, and
    you don''t want it to collide with itself. As such, the default value is false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connected Rigid body**: This is the reference to the second rigidbody of
    the joint, as the name suggests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, most of the joints (with the exception for the **Relative Joint 2D**
    and the **Target Joint 2D**) needs the two points of the application of the joint.
    Imagine again the example of the cage pending from the rope. Where the rope is
    attached to the cage is an important factor, because if the rope is attached to
    one of the corners of the cage, this will be rotated, as shown in this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The other rigidbody](img/image00542.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We attached the rope on the cage which is important, because it will affect
    how it will react to forces. However, it is interesting to note that wherever
    you append a rigidbody, the line along the rope will pass always through the barycenter
    (centroid) of the rigidbody.
  prefs: []
  type: TYPE_NORMAL
- en: Plus, you need to consider the possibility that there are other forces that
    may move the cage, and again where the rope is attached is an important piece
    of information. The same applies to the other rigidbody; in the case of the cage,
    the other rigid body is the ceiling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, there are some options available to determine these two points of
    application, which are called **anchors** in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Auto Configure Connected Anchor**: If this is checked, Unity will take care
    to determine where the two anchors are. Of course, turn it off if you have a specific
    point of application of the joint in mind and you want to place an anchor there.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anchor**: The position in *x* and *y* (with respect to the rigidbody) of
    the anchor of the joint on the rigidbody where it is attached.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connected Anchor **: This is the position in *x* and *y* (with respect to
    the rigidbody of the other object) of the anchor of the joint on the rigidbody
    specified in the **Connected Rigidbody** variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking joints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Coming back to the example of the suspended cage, imagine that the hero decides
    that it is a good idea try to jump on top of the cage and then jump on another
    platform. However, he didn't consider that the rope was really old (in fact, there
    is a skeleton in the cage!), and once he landed on the cage, the rope breaks making
    both the cage and our hero fall. Therefore, it's true that joints impose a constraint,
    but they have limits too. For the same reason, if you pull both sides of a rubber
    with too much force, the rubber will eventually break.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also in Unity, Joints can be broken. In particular, in their components there
    are two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Break Force**: This is present in all the joints, and it holds the numerical
    value of the force after which the joint will break. Breaking a joint in Unity
    means to erase the Joint component from the object. By default, it is set to be
    infinity, which means that the joint is indestructible. Otherwise, the lower the
    value, the easier it is to break the joint. In the example of the cage, if we
    choose to give a very low value for the joint that simulates the rope, it will
    be likely that the rope is really old and when our hero jumps on top of the cage,
    they both will fall in the dungeon of the castle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Break Torque**: This is present in all the joints other than **Distance Joint
    2D**, **Spring Joint 2D**, and **Target Joint 2D**. It holds the numerical value
    of the torque after which the joint will break. As we already have seen, rigidbodies
    can not only move but also rotate. By default, it is set to be infinity, which
    means the joint is indestructible. Otherwise, it can be brought to a finite value,
    allowing the joint to break with torques greater than the value specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For an example of a joint that breaks under torque, you can just imagine something
    that is rotating but it''s motion is blocked by something, such as when you use
    the screwdriver and keep going until the wood (which was the constraint) is broken.
    However, here is another example that is less intuitive but more common (even
    in video games). Imagine you append yourself on the boarder/edge of a shelf. Since
    there is an offset from the center of mass of the shelf and the point where you
    have appended yourself (they are likely to be perpendicular if the shelf is flat),
    a torque is applied on the shelf. Under the effect of the torque, the shelf should
    rotate around its center of mass, but it doesn''t since the wall prevents it.
    If you are heavy enough, which means the force you apply on the shelf is greater
    (or also if in some way you are able to increase the offset), the torque increases,
    until it reaches a breaking point. Then the constraint will break, which may result
    either in a broken shelf or a broken wall depending which one has more resistance
    (most probably the shelf will break and the wall will still stand). The following
    diagram should help you to figure the example out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breaking joints](img/image00543.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Specific joints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have seen only general properties of the joints in Unity, but now
    we will take a closer look at all the nine joint 2D components available.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worthy to mention that joints are divided into two classes: spring joints
    and motor joints. The former uses a spring to impose a constraint, which may be
    completely stiff so as to simulate a rigid bar. Motor joints, instead, can actively
    apply forces onto the rigidbodies. Some joints are both, like a spring with a
    motor.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the joints in Unity have an icon (visible when, for instance, you place
    the component in the **Inspector**). In this book, you can see the icon in the
    top-left corner of the images of the joints (in the next sections). This icon
    is really useful for remembering what the joint does and also how it works. So,
    when reading the next section, or programming your game, pay attention to this
    icon, which might help you to understand the joint better.
  prefs: []
  type: TYPE_NORMAL
- en: Distance Joint 2D
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This joint keeps the two rigidbodies at a certain distance apart. The aim of
    this joint is to keep at a certain distance two rigidbodies, or a rigidbody and
    a fixed point in the game world. In fact, if you set the **Connected Rigidbody**
    variable to `None`, you can then specify the position of the fixed point in **Connected
    Anchor**.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should appear like the following in the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Distance Joint 2D](img/image00544.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This joint applies a linear force to both the rigidbodies (or just to the rigidbody
    on which it is attached if using a fixed point) with a very stiff simulated spring
    (which is not configurable) to keep the distance. The joint doesn't apply any
    torque.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the parameters that we have seen in the last section, **Distance
    Joint 2D** also has the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Auto Configure Distance**: If set to true, Unity will calculate the current
    distance between the two rigidbodies (or the rigidbody and the fixed point) and
    place its value in the **Distance** variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Distance: Specifies the distance beyond which the two rigidbodies (or the rigidbody
    and the fixed point) cannot go further.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Distance Only**: If enabled, the distance between the two rigidbodies
    (or the rigidbody and the fixed point) can be lower than the value specified in
    the Distance. If this option is disabled instead, the distance is fixed and the
    two points cannot be any further or closer than the Distance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that if the **Break Force** of the joint is a finite value, it will
    eventually break, even if the **Max Distance Only** option is set to false.
  prefs: []
  type: TYPE_NORMAL
- en: When **Max Distance Only** is false, the constraint among the two points is
    rigid, so you can imagine them connected by a metal string/bar along with a hinge
    (since they can still rotate with respect to each other). An example of how this
    is used is when you need to connect two couches of a train together, because they
    cannot get any farther or closer than a specific distance. If **Max Distance Only**
    is true, instead, they can be closer than the **Distance**, but not further. This
    is the behaviour of our rope, which holds the cage. that potentially can get closer
    to where the rope is tied but not further. Another example is a dog with a leash.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is important to keep in mind that both the rigidbodies are free
    to rotate with respect to each other. In fact, this joint imposes the constraint
    only on the relative position of the two rigid bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed Joint 2D
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The aim of this joint is to keep a certain relative offset (both linear and
    angular) between two rigidbodies or a rigidbody and a fixed point in the game
    world (you can specify it by setting **Connected Rigidbody** to `None`).
  prefs: []
  type: TYPE_NORMAL
- en: 'It should appear like the following in the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fixed Joint 2D](img/image00545.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This joints applies both a linear force to compensate the linear offset, and
    a torque to compensate the angular one. Like **Distance Joint 2D**, it uses a
    very stiff simulated spring, but you can tweak the spring values, such as the
    frequency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in addition to the parameters we have seen in the last section,
    **Fixed Joint 2D** has also the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Damping Ratio**: This defines the degree to which the oscillation of the
    spring is suppressed. Its value ranges from 0 to 1; the higher the value, the
    less motion. As you would expect from a spring, this joint will overshoot the
    desired distance and then rebound back, leading the spring to oscillate. The **Damping
    Ratio** determines how quickly the oscillation is damped (reduced) and thus how
    fast the spring comes back to its rest position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frequency**: This defines the frequency at which the spring oscillates when
    the rigidbodies are reaching the separation distance. It is measured in cycles
    per second, and its value ranges from 1 to 1 million. The higher the value, the
    stiffer the spring, which means less motion. It''s worthwhile to notice that a
    value of zero means that the spring is completely stiff.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another way to think of this joint is like parenting GameObjects within the
    **Hierarchy** so that the children are fixed with respect to their parents. However,
    the joint offers you more options than a simple parenting, including the possibility
    to break it.
  prefs: []
  type: TYPE_NORMAL
- en: An example of usage of this joint is when you have a chain of rigidbodies (such
    as a real chain that hangs from the ceiling, or you can imagine also a bridge
    made of sections), and you want to hold them rigidly together. The advantage is
    that you can allow a certain flexibility in the joint, so in the case of the bridge,
    it can still bend a little within the limits you impose.
  prefs: []
  type: TYPE_NORMAL
- en: Friction Joint 2D
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The aim of this joint is to keep to zero both the linear and angular offset,
    by slowing down the movement between the two rigidbodies or a rigidbody and a
    fixed point in the game world (you can specify it by setting **Connected Rigidbody**
    to `None`).
  prefs: []
  type: TYPE_NORMAL
- en: '**Friction Joint 2D** should appear like this in the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Friction Joint 2D](img/image00546.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to the parameters we have seen in the last section, **Friction
    Joint 2D** has the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Max Force**: This determines the linear resistance along the line that connects
    the two rigidbodies. A high value (the maximum is 1,000,000) creates a strong
    linear resistance; thus the two rigidbodies will not move along the line that
    connects them much. On the contrary, a low value allows more motion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Torque**: This determines the angular resistance between the two rididbodies.
    A high value (the maximum is 1 million) creates a strong angular resistance; thus
    the two rigidbodies will not rotate much relatively. On the contrary, a low value
    allows more motion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of the use of this joint is when there are physical objects in the
    game that need friction to be believable. So, imagine a platform that is anchored
    to a big wheel in the background. Since the game is 2D, the wheel is only an aesthetic
    element; it doesn't actually affect the platform. As such, we need to simulate
    the friction between the platform and the wheel, and we can achieve that with
    a **Friction Joint 2D**. In this way, we can have an angular resistance on the
    platform; thus it can still be rotated, but not so easily. Maybe, the player may
    drop a heavy box on the border of the platform to make it rotate enough so that
    the player can pass.
  prefs: []
  type: TYPE_NORMAL
- en: '![Friction Joint 2D](img/image00547.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: On the left is the representation of the system. On the right is what will happen
    when the box is dropped onto the platform, which will rotate slowly due its angular
    friction.
  prefs: []
  type: TYPE_NORMAL
- en: Hinge Joint 2D
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The aim of this joint is to constrain the rigidbody to rotate around another
    rigidbody or a fixed point in space (always specified by **Connected Anchor**
    if **Connected Rigid Body** is set to `None`). The rotation can either be left
    to happen passively (for example, in response to a collision, or under the effect
    of gravity) or be actively powered by a motor, which provides torque to the rigidbody.
    Furthermore, limits can be set to constrain the hinge just to rotate at certain
    angles, or to allow more than a one full rotation around its axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'It appears like the following screenshot in the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hinge Joint 2D](img/image00548.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to the parameters that we have seen in the last section, **Hinge
    Joint 2D** has the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use Motor:** If enabled, it allows the joint to actively apply a torque on
    the rigidbody, simulating a motor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Motor Speed:** This specifies at which speed the simulated motor should rotate
    in degrees per second. So a value of 30 means that the motor will do a complete
    rotation in 12 seconds (*360/30=12*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maximum Motor Force:** This specifies the maximum force that the motor can
    apply to reach the **Motor Speed**. Imagine a very heavy object requires a stronger
    force to rotate and thus reach the **Motor Speed**. If the motor is not powerful
    enough, it won''t make the rigidbody reach the **Motor Speed**. Moreover, if a
    **Break Torque** is specified, it may break the joint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Limits:** If true, the joint limits the angles to which the rigidbody
    can rotate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lower Angle:** This sets the lower end of the rotation arc allowed by the
    limit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Upper Angle:** This sets the upper end of the rotation arc allowed by the
    limit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A clear example of the usage of this joint is with doors. They can rotate around
    their hinges, which connect the door with its frame. We can limit how the door
    can rotate, so for instance, you may want it to rotate only of 90 degrees. Moreover,
    if the door is automatic, we can simulate a motor, which actively makes the door
    rotate. In fact, the motor may be triggered by a script. Finally, if the player
    wants to push the door beyond its limit (90 degrees in the example), and a **Break
    Torque** is specified, the player may break the hinge with enough force.
  prefs: []
  type: TYPE_NORMAL
- en: '![Hinge Joint 2D](img/image00549.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Top view (birds-eye view). On the left is the representation of the system.
    On the right is what will happen when the player pushes the door beyond its limits.
  prefs: []
  type: TYPE_NORMAL
- en: Relative Joint 2D
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This joint makes two rigidbodies to keep a relative position based on each other's
    position. In fact, the aim of this joint is the same as that of the **Fixed Joint
    2D**; the difference lies in how they do it. The **Fixed Joint 2D**, as we already
    have seen, is a spring kind of joint that will stop to oscillate only when the
    two rigidbodies are at the specified offset and rotation, and so the spring is
    in a rest position. Instead, the **Relative Joint 2D** is a motor kind of joint
    that applies a direct force and torque to rigidbodies so that they are at the
    same offset and rotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the **Fixed Joint 2D**, the **Relative Joint 2D** can also work with both
    of these:'
  prefs: []
  type: TYPE_NORMAL
- en: Two rigidbodies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A rigidbody and a fixed point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use the second case, set **Connected Rigidbody** to `None` and then specify
    the coordinate of the fixed point in the **Linear Offset** variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'It appears like this in the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Relative Joint 2D](img/image00550.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to the parameters we saw in the last section, the **Relative Joint
    2D** has the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Max Force**: This specifies the maximum force that the joint/motor can use
    to correct the offset between the two rigidbodies. The higher the value, the better
    the simulated motor will be able to correct the offset. By default, **Max Force**
    is set to `10000`, which means a really powerful motor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Torque**: This specifies the maximum torque that the joint/motor can
    use to correct the angular offset between the two rigidbodies. The higher the
    value, the better the simulated motor will be able to correct the angular offset.
    By default, **Max Torque** is set to `10000`, which means a really powerful motor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Correction Scale**: Tweaks the joint to make sure that it behaves as it is
    supposed to. This can be done by either increasing **Max Force** or **Max Torque**,
    which may affect behaviour (and as a result the joint may not reach its target).
    Therefore, you can use this setting to correct it. The default setting of `0.3`
    is usually appropriate (because on an average the joint behaves as you would expect;
    it''s a value that has likely been found by trial and error). But it may need
    tweaking between the range of 0 and 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto Configure Offset**: When checked, this takes the current linear and
    angular offsets of the two rigidbodies, stores them in the **Linear Offset** and
    **Angular Offset** variables, and maintains them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linear Offset**: This specifies the linear offset that the two rigidbodies
    should have, expressed in local coordinates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Offset**: This specifies the angular offset that the two rigidbodies
    should have, expressed in local coordinates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of use of this joint is between the camera and the Avatar in the
    game. In this way, the camera can follow the Avatar with a slight delay (because
    if the camera is parented, it will move instantaneously with the Avatar). But
    it won't oscillate much as with the **Fixed Joint 2D**, since it is a spring kind,
    which may cause frustration to the player (of course, this also depends on how
    the **Fixed Joint 2D** is configured, maybe with a real stiff spring; but usually
    the **Relative Joint 2D** is used for this kind of situations).
  prefs: []
  type: TYPE_NORMAL
- en: Another typical example of the use of this joint is when something should follow
    the player, such as a life counter above her head or a friendly spirit behind
    her shoulders.
  prefs: []
  type: TYPE_NORMAL
- en: Slider Joint 2D
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine you want to constrain the motion of a rigidbody just along a line, so
    that it can only slide onto that line. This is what the **Slider Joint 2D** allows
    you to do. As for the other joints, the line can be between two rigidbodies or
    a rigidbody and a fixed point in the game world.
  prefs: []
  type: TYPE_NORMAL
- en: 'It appears like this in the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Slider Joint 2D](img/image00551.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to the parameters we have seen in the last section, the **Slider
    Joint 2D** also has the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Angle**: This specifies the angle at which the rigidbody is constrained to
    remain. In the 2D world, an angle fully specifies a direction, and this angle
    specifies in which direction the motion is constrained.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to fully determine the line where motion is allowed by the joint,
    the current position the rigidbody is taken into consideration as well. Thus,
    a point (the current position of the rigidbody) and a direction (specified from
    the **Angle** variable) univocally determine a line where the motion is constrained,
    as shown in the following diagram:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Slider Joint 2D](img/image00552.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Use Motor**: If true, the joint uses a simulated motor as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Motor Speed**: This specifies the speed of the rigidbody that the motor should
    achieve.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Motor Force**: This specifies the maximum force that the motor can use/apply
    in order to achieve a Motor Speed for the rigidbody.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Limits**: If true, this allows further constraints on the rigidbody along
    a segment of the line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lower Limit**: This specifies the minimum distance the rigidbody should be
    at from the **Connected Anchor** point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Upper Translation**: This specifies the maximum distance the rigidbody should
    be at from the **Connected Anchor** point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical scenarios where you may want to use this joint are a sliding door, which
    goes up and down, and also a platform, which can go left and right, up, down,
    or even diagonally.
  prefs: []
  type: TYPE_NORMAL
- en: '![Slider Joint 2D](img/image00553.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The sliding door in the diagram is constrained along a segment
  prefs: []
  type: TYPE_NORMAL
- en: Spring Joint 2D
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name suggests, this is a pure spring joint 2D. It actually simulates
    a spring connected between the two rigidbodies, or a rigidbody and a fixed point.
    In fact, this joint gives you all the functionalities for a spring joint, and
    therefore you can simulate all the other pure (without a motor) spring-joints.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In fact, the **Distance Joint 2D** is simulated by using the **Spring Joint
    2D** with **Frequency** set to `0` and **Damping Ratio** to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It appears like the following in the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spring Joint 2D](img/image00554.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to the parameters we have seen in the last section, the **Spring
    Joint 2D** has the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distance**: This specifies the distance that the two rigidbodies (or the
    rigidbody and the fixed point) should keep. You can imagine it also like the length
    of the spring in its rest position, which means the length of the spring when
    no forces are applied on it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Damping Ratio**: This specifies how much you want to suppress the motion
    of the spring. Its value ranges from 0 to 1\. Lower values mean a movable spring,
    higher values mean a stiff spring. If it is set to 1, the spring is not movable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frequency**: This specifies the frequency at which the spring oscillates
    while the objects are approaching the separation distance (which is the length
    of the spring in the rest position) specified in the **Distance** variable (measured
    in cycles per second). It ranges from 0 to 1,000,000\. The higher the value, the
    stiffer the spring will be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whenever you need to place a spring in your game, this is the right joint.
    So, an example could be a physically realistic Launchpad, which you need to compress
    the spring, so as to let it have a boost in your jump. However, you don''t need
    necessarily to think of this joint as a normal spring. In fact, you can bring
    this joint to the limits (such as a very stiff spring). As such, you are able
    to create other behaviours that in reality don''t have a spring, but in the game
    they look nice when connected by a spring. Have you ever played *Rayman*? The
    character has its body parts separated, but they still move together in a coherent
    way in the game. If you are planning to create a similar character, the spring
    joint can be a valid solution to link the body parts in a realistic way. Here
    is an image of *Rayman*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spring Joint 2D](img/image00555.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Image of *Rayman*. As you can see, the character doesn't have legs or arms,
    but has hands and feet. In your game, you can attach them to the chest through
    a Spring Joint.
  prefs: []
  type: TYPE_NORMAL
- en: Target Joint 2D
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Target Joint 2D** is a particular spring-type joint that, instead of having
    a second rigidbody, has a target. The aim is to keep the rigidbody where the component
    is attached at a certain distance from the target. It only applies a linear force;
    thus no torque is given to the rigidbody.
  prefs: []
  type: TYPE_NORMAL
- en: 'It appears like this in the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Target Joint 2D](img/image00556.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since this component doesn''t have a second rigidbody, there are some variables
    that allow you to specify the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Anchor**: Defined in local coordinates, with respect to the rigidbody, where
    the joint is attached on the rigidbody.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target**: Defined in local coordinates, with respect to the rigidbody, where
    the other end of the joint tries to move.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto Configure Target**: When checked, it sets the **Target** to the current
    position of the rigidbody, which is useful when our rigidbody is moved around,
    maybe driven by other forces. Furthermore, when this option is selected, the **Target**
    changes as you move the rigidbody; on the contrary, it won''t if the option is
    not selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Moreover, it is possible to control the characteristic of the spring with the
    usual parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Max Force**: This specifies the maximum force that the joint can use on the
    rigidbody'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Damping Ratio**: This specifies how much the motion of the spring is suppressed
    (refer to either the *Spring 2D Joint* or *Fixed 2D Joint* section for more details)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frequency**: This specifies the frequency of the spring (refer to either
    the *Spring 2D Joint* or *Fixed 2D Joint* section for more details)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of the use of this joint is when the player needs to drag objects
    with the mouse. In this scenario, you can set the target of the object dragged
    to the cursor, so it will follow the cursor, without having a rigid movement (as
    if we would set frame after frame the position of the object to the mouse coordinates).
    Moreover, you can use the **Anchor** to specify where the object should be attached.
    For instance, if the player started to drag from a corner of the object, you can
    set the **Anchor** to be there, and as a result, the object will hang from that
    point.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find this joint in one of the exercises of the last chapter to improve
    the look of your game.
  prefs: []
  type: TYPE_NORMAL
- en: Wheel Joint 2D
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Wheel Joint 2D is a combination of a spring and motor kind of joint, and
    it has a very specific usage. As the name suggests, it simulates the constraint
    that a wheel can impose on a body. In particular, it can rotate the wheel with
    a motor (the wheel moves) and simulate suspensions with a spring.
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, the joint applies a linear force to both connected rigid
    bodies to keep them on the line, an angular motor to rotate them on the line,
    and a spring to simulate the wheel suspension.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is interesting to note that you can reconstruct a **Wheel Joint 2D** with
    the combination of a **Slider Joint 2D** (with both **Use Motor** and **Use Limits**
    off) and a **Hinge Joint 2D** (with **Use Limits** off).
  prefs: []
  type: TYPE_NORMAL
- en: 'It appears like the following in the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wheel Joint 2D](img/image00557.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding screenshot, the parameters are divided into
    **Suspension**, which defines a spring, and a motor. Both use the same parameters
    we have already seen respectively for springs (with the exception of **Angle**)
    and motors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The suspension is defined by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Angle**: This specifies the angle (in degrees in world coordinates) where
    the suspension happens. By default, it is set to `90` degrees, which means the
    suspension will happen upwards, as usually happens for a car (the body of the
    car is on top of the wheels, so the direction of the suspension is along the positive
    *y*-axis, which means 90 degrees) as shown in the following diagram:![Wheel Joint
    2D](img/image00558.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this diagram, we can see the the angle of the suspension for the wheel of
    the car is at 90 degrees, which means upwards in the game world. This is the default
    value. Imagine you want to have a car that is able to run on the ceiling thanks
    to magnetic wheels; you may consider changing the angle of the suspension. In
    the case of the ceiling, it is the opposite of the normal situation, so the angle
    will be 270 degrees.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Damping Ratio**: This specifies how much the motion of the spring is suppressed
    (refer to either the *Spring 2D Joint* or *Fixed 2D Joint* section for more details).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frequency**: This specifies the frequency of the spring (refer to either
    the *Spring 2D Joint* or *Fixed 2D Joint* section for more details).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The motor is defined by:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Motor Speed**: This specifies the speed that the motor should achieve on
    the wheel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Motor Force**: This specifies the maximum force that the motor can apply
    on the wheel in order to achieve **Motor Speed** on the wheel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Needless to tell you which is the most common usage of this joint. Every time
    in your game you have a wheel and it needs to move in a realistic manner, this
    joint is the deal for you.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to create a car controlled by the player, you can attach this joint
    to the wheels and set **Motor Speed** to `0` to control this variable through
    your script based on the player's input. Moreover, you can use **Max Motor Force**
    to simulate the different gears.
  prefs: []
  type: TYPE_NORMAL
- en: Effectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine our hero is crossing an enchanted room, so he starts to float due a
    powerful spell. In this case, while the hero is within this room, gravity should
    be contrasted by a (magical) force. As a result, we need to specify that in that
    room, there is a force that makes our hero levitate.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, imagine the hero drops a box in a lake. The box doesn't sink at the
    same velocity as it falls; moreover, it might float. Therefore, in our game, we
    need to specify that the region delimited by the lake has special physical properties.
  prefs: []
  type: TYPE_NORMAL
- en: '![Effectors](img/image00559.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There are some special regions of the game world where the physical laws could
    be different from the rest of the game world; in Unity, these regions can be specified
    with effectors
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unity, this can be achieved by using effectors. Effectors are some components
    that affect the behaviour of rigidbodies in certain region of the game world.
    They are really different from each other, because they do different things, although
    the core concept is the same: they affect one or more rigidbodies that come into
    the region that they control.'
  prefs: []
  type: TYPE_NORMAL
- en: Effectors use collision detection to know which are the rigidbodies within their
    region, and therefore, as we already mentioned before, the rigidbodies need to
    have a collider. Otherwise, they won't be affected by the effector.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the effectors themselves need their own collider to work. This, in
    order to be used by the effector they should have the **Used By Effector** property
    set to true. Otherwise, the effector will not affect any rigidbody. If the collider
    of the effector should be set to be the trigger or not depends both on the kind
    of effector and on what are you trying to achieve, although there is a default
    way to set it (in fact, Unity gives you a warning in case you are using the effector
    in an unusual way).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see this case by case, and here is a summary table with the effectors,
    saying whether the collider should use **is Trigger** or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Effector** | **Linked collider should be a trigger?** |'
  prefs: []
  type: TYPE_TB
- en: '| Constant Force 2D | This component is attached to rigidbodies, not colliders
    |'
  prefs: []
  type: TYPE_TB
- en: '| Area Effector 2D | True |'
  prefs: []
  type: TYPE_TB
- en: '| Buoyancy Effector 2D | True |'
  prefs: []
  type: TYPE_TB
- en: '| Point Effector 2D | True |'
  prefs: []
  type: TYPE_TB
- en: '| Platform Effector 2D | False |'
  prefs: []
  type: TYPE_TB
- en: '| Surface Effector 2D | False |'
  prefs: []
  type: TYPE_TB
- en: 'All of them (with the exception of Constant Force 2D) have a couple of variables
    to determine which rigidbodies are affected by the effector, and these variables
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use Collider Mask**: If enabled, this allows you to discriminate the colliders
    that enter in the area through layers specified in the next variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collider Mask**: This determines which layers are affected by the effector.
    Once again, remember that you can learn how to add layers in [Chapter 2](part0028.xhtml#aid-QMFO1
    "Chapter 2. Baking Cupcake Towers"), *Baking Cupcake Towers* . So, in this variable,
    you can specify one of them through the use of a drop-down menu.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see each one of them in detail to better understand how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Constant Force 2D
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is not a proper effector, because instead of acting in an area or region,
    it is directly applied onto a rigidbody. So it needs to be attached to the same
    game object that has the rigidbody component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how it appears in the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constant Force 2D](img/image00560.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Out of curiosity, for this component, there is a 3D counterpart: **Constant
    Force**.'
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, it applies a constant force to the rigidbody. Usually
    this is used in testing to easily apply a force from the **Inspector**, but it
    can also be used in the normal gameplay if we need an object that is always under
    the control of a constant force (so that it will keep pushing). Of course, it's
    value can be changed through script to make it a non-constant force, but in that
    case it is preferable to apply the force directly with a function in the script.
    The component should be used only for constant forces or forces that don't change
    over time (the force can change, but for long periods of time it remains constant).
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, this component also can be used to apply a torque on the rigidbody.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the three variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Force**: The constant force to apply to the rigidbody.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relative Force**: The constant force to apply to the rigidbody expressed
    with respect to the rigidbody coordinates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Torque**: The constant torque to apply to the rigidbody'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here is an example of usage that is not testing. Suppose you are doing a game
    where different objects are affected by different gravitational forces. So for
    instance, brown boxes will follow on the ground as usual, but green boxes will
    follow on the right because as per your game design they are supposed to do so.
    The reason could be an experimental serum invented to change gravity for things
    that are green. In this scenario, the green boxes cannot be affected by normal
    gravity, so you can place on them a rigidbody and set **Gravity Scale** to `0`.
    In this way, it won't be affected by normal gravity. Then, place on it the **Constant
    2D** force component and set your gravity. Moreover, if all the objects have different
    **Constant 2D** forces, you can change their gravity force in real time, maybe
    after the invention of another serum, which changes the gravity on the left instead
    of the right.
  prefs: []
  type: TYPE_NORMAL
- en: Area Effector 2D
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This component defines an area within which a force is applied to all the rigidbodies
    inside the area. You can configure the force at any angle with a specific magnitude
    and random variation on that magnitude. You can also apply both linear and angular
    drag forces to slow down rigidbody 2Ds.
  prefs: []
  type: TYPE_NORMAL
- en: This effector, in order to work, requires a collider with both **Used By Effector**
    and **is Trigger** set to true. In fact, rigidbodies should be able to enter in
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component has two foldouts (expandable menu options) for the relative options
    to set, **Force** and **Damping**, as we can see from this diagram, which shows
    the component in the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Area Effector 2D](img/image00561.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The two foldouts appear only in recent versions of Unity. So if you are using
    an old version and you don't see them, don't worry; the options have just been
    reordered, but they still work as described here.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the variables have intuitive names, but let''s go through them quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use Global Angle**: If checked, the next variable will be interpreted in
    the world coordinates, and local coordinates otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Force Angle**: This is the angle of the force to apply, and so it defines
    the direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Force Magnitude**: This is the magnitude, which means the intensity of the
    force.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Force Variation**: This is the variation of the magnitude of the force so
    as to not have always a constant force and improve realism. Be careful not to
    give too high value, which may quickly result in undesired behaviour.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Force Target**: This can be either the **Rigidbody** or **Collider**. In
    the first case, the force will always be applied to the center of the mass. In
    the second case, if the collider is not on the center of the mass, the force will
    also generate torque for the rigidbody.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Drag**: This is the linear drag to apply within the region.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Drag**: This is the angular drag to apply within the region.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here is an example of the use of this component. Suppose that there is a special
    device which is able to push the magnetic shoes of the main character to contrast
    gravity. So, in the area just above this device, you can place an area effector,
    specifying a force that goes upwards. Please note that if the intensity of the
    force is less than the gravity, then your character will have a big jump, but
    eventually she will fall down. Whereas with a greater value, even without a jump
    she starts to levitate upwards until either an obstacle or the end of the area
    effector is met.
  prefs: []
  type: TYPE_NORMAL
- en: Buoyancy Effector 2D
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This component is used to simulate a fluid, and so it can potentially make rigidbodies
    floating. It requires a collider with both **Used By Effector** and **is Trigger**
    set to true. In fact, rigidbodies should be able to enter it.
  prefs: []
  type: TYPE_NORMAL
- en: 'It appears like the following in the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Buoyancy Effector 2D](img/image00562.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we can see from this screenshot, there are two foldouts to help the logical
    order of the component. Don't worry if they aren't there. You may be using an
    older version of Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main variables are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Density**: This indicates the density of the fluid, and it affects how the
    different rigidbodies are affected by the effector depending on the rigidbody
    density as well. In fact, rigidbodies with a higher density will sink, those with
    a lower density will float, and those with the same density of the fluid will
    be suspended in the fluid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Surface Level**: This indicates where the surface of the fluid is with respect
    to the Transform (the position) of the game object where the effector is attached.
    A value of zero means that the surface will lie on the center of the object, and
    it is placed in the middle of the collider (only if the collider doesn''t have
    any offset). You can recognize it from the blue line in the **Scene** view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Drag**: This is the linear drag to apply within the region below the surface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Drag**: This is the angular drag to apply within the region below
    the surface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flow Angle**: This specifies the angle, in world coordinates, where the flow
    force of the effector is applied. Therefore, it defines the direction of the force.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flow Magnitude**: This specifies the intensity of the flow force, and therefore
    the level of buoyancy of the effector. It can assume negative values, and in this
    case, it''s as if **Flow Angle** has been rotated by 180 degrees.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flow Variation**: This indicates how much **Flow Magnitude** can vary, so
    as to not have it constant and therefore achieving a higher level of realism.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The component appears like this in the **Scene** view, to actually show where
    the surface level is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Buoyancy Effector 2D](img/image00563.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Furthermore, here is an example of its usage. Suppose that in your 2D game there
    is the sea, and the main character has to jump on some platforms in the harbor.
    Placing this effector at the level of the sea will make its behaviour more realistic.
    For instance, the main character can push a wooden box down in the sea, which
    will float, and so she can jump on top of the floating box to cross.
  prefs: []
  type: TYPE_NORMAL
- en: '![Buoyancy Effector 2D](img/image00564.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An example of use of the Buoyancy Effector 2D, which is able to simulate the
    sea and make the wooden boxes float; as a result, the player can jump on top of
    the wooden box and cross the sea
  prefs: []
  type: TYPE_NORMAL
- en: Point Effector 2D
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can imagine this component to be a magnet of rigidbodies, so it can push/repulse
    or attract them, which is concentrated at a single point, as the name of the effector
    suggests. The point can be determined by either the collider (most used) or the
    rigidbody attached to the same game object of the effector.
  prefs: []
  type: TYPE_NORMAL
- en: The component requires a collider with both **Used By Effector** and **is Trigger**
    set to true. In fact, rigidbodies should be able to enter in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'It appears like this in the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Point Effector 2D](img/image00565.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once again, the foldouts are only in recent versions of Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main variables are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Force Magnitude**: The magnitude, which means the intensity of the force.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Force Variation**: The variation of the magnitude of the force in order not
    to always have a constant force and improve realism. Be careful not to give too
    high value, which may quickly result in undesired behaviours.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distance Scale**: When the distance between the rigidbody and the attractive
    or repulsive point is calculated, it is scaled by (multiplied by) **Distance Scale**.
    As such, you are able to modify the behaviour of the effector (see **Force Mode**
    in this list).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Force Source**: This can be either a **Rigidbody** or **Collider**. In the
    first case, the point that attracts or repulses will be placed on the center of
    the rigidbody (which means at its center of the mass). In the second case, it
    will be placed in the middle of the collider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Force Target**: This can be either a **Rigidbody** or **Collider**. In the
    first case, the force will always be applied to the center of the mass of the
    rigidbody entering in the effector. In the second case, if the collider is not
    centered on the center of the mass, the force will also generate torque for the
    rigidbody.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Force Mode**: This specifies how the force is calculated, and it can be of
    three types. **Constant** is the most intuitive. The force is always constant
    regardless of the distance between the rigidbody affected by the effector and
    the point that repulses or attracts. This means that only the relative positions
    between the rigidbody and the point are taken into consideration to determine
    the direction of the force, which lies on both. Instead, in **Inverse Linear**,
    the force changes its intensity based on the distance between the rigidbody and
    the point. For double the distance, half intensity of the force. Finally, **Inverse
    Squared**, which in most cases is the most physically realistic, takes the square
    of the distance into consideration. This means, for double the distance, a quarter
    the intensity of the force.![Point Effector 2D](img/image00566.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differences between the different force modes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this diagram, on the left is a repulsive point effector. Below is a distance
    scale, all included within the range of the point effector. Suppose that at a
    distance of half alpha, three different rigidbodies have the same applied force
    from the point of effect. At a distance of alpha, the constant mode will keep
    its whole force applied on the rigidbody. The **Inverse Linear** mode will halve
    the force by doubling the distance. Finally, the **Inversed Squared** mode (which
    is the most physically realistic, since both the gravitation and the electromagnetic
    forces have this behaviour) will have a quarter of the force it would have half
    way closer to the point effector.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Drag**: This is the linear drag to apply within the region of the effector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Drag**: This is the angular drag to apply within the region of the
    effector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here is an example of its usage. Suppose the main character has a special ring
    that, when active, attracts metal (when the ring is not, it will attract the main
    character's wife). Therefore, every time that the player activates the ring, the
    game activates a point effector on the main character, and through the **Collision
    Mask** variable, only metals can be selected.
  prefs: []
  type: TYPE_NORMAL
- en: Platform Effector 2D
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This component gives the effect of a platform for 2D games. For instance, it
    implements the one-way collision. So if the character jumps from below the platform,
    he will cross it, but when he lands on top, the platform will give a collision,
    maintaining the character on top of the platform. Moreover, it can be used to
    remove side-friction/bounce.
  prefs: []
  type: TYPE_NORMAL
- en: '![Platform Effector 2D](img/image00567.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With this effector, the player is able to cross a collider in one direction
    but not the other way round. In some platform games, the player is able to jump
    on top of the platform by jumping underneath it, but he or she cannot fall back.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this is the most used component to build platform games. Think about
    games like *Braid*, where the player is able to jump on top of a platform from
    a platform that is underneath.
  prefs: []
  type: TYPE_NORMAL
- en: The component requires a collider with **Used By Effector** set to true but
    not **is Trigger**. In fact, rigidbodies should be able to collide with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how it appears in the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Platform Effector 2D](img/image00568.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once again, the foldouts are present only in recent versions of Unity. Moreover,
    the rotational offset is a parameter that has been added recently.
  prefs: []
  type: TYPE_NORMAL
- en: And here you can see one possible instance in the **Scene** view of this component.
  prefs: []
  type: TYPE_NORMAL
- en: '![Platform Effector 2D](img/image00569.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is how the effector appears in the Scene view when its gizmos are active
  prefs: []
  type: TYPE_NORMAL
- en: The big arc on top defines from which direction the platform/collider is not
    traversable, whereas the two small side arcs define which direction is considered
    the side of the platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main variables are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rotational Offset**: This indicates the angular offset in degrees of the
    whole platform effector. This has been added recently in Unity, and thanks to
    it, it is possible to rotate the platform effector so as to have platforms that
    are inclined, or walls that can be crossed one way. For instance, you can use
    it also for magical portals that can be crossed one way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use One Way**: If checked, the platform will collide only in one direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use One Way Grouping**: This ensures that all contacts disabled by the one-way
    behaviour act on all colliders. This is useful when multiple colliders are used
    on the object passing through the platform and they all need to act together as
    a group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Surface Arc**: This specifies in degrees how wide the arc on top of which
    the collision will be performed is. In all the other directions, if **Use One
    Way** is enabled, it won''t allow any collision, allowing any rigidbody to pass
    through, such as your character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Side Friction**: If true, friction is applied to the side of the platform
    effector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Side Bounce**: If true, bounce is applied to the side of the platform
    effector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Side Arc**: This specifies the degree for both the right and left side (if
    the **Rotational Offset** is set to `0`; otherwise it may indicate up and down)
    that are considered the sides of the platform effector. So, if **Use Side Friction****or**
    and **Use Side Bounce** is enabled, this will be applied along the arc specified
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides the classical use of this component to create platform games, let''s
    see another example in which we may want to use it. Imagine a puzzle game where
    some portals can be crossed only in one direction. As such, we can place a platform
    effector and set its **Rotational Offset** so as to have the colliding part only
    on one side of the portal. As a result, the character will be able to cross the
    magical portal only in one direction, and not in the other way round as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Platform Effector 2D](img/image00570.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is an example of how it is possible to use this effector in another way
    that is not the classical platform. By rotating the component through the **Rotational
    Offset**, it is possible to make a magical portal which is crossable in one way,
    but not in another. This could be an interesting game mechanic for a puzzle game.
  prefs: []
  type: TYPE_NORMAL
- en: Surface Effector 2D
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This component applies a tangential force to the surface specified by the collider
    associated with this effector. In other words, you can imagine this as a conveyor
    belt, which transports rigidbodies along the direction of the force, as far as
    they are touching the surface.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how it appears in the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Surface Effector 2D](img/image00571.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is possible to have access to the options of the **Surface Effector 2D**
    through two foldouts, and you can find the parameter that you can set here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed**: The speed that the tangential force should maintain. In other words,
    it''s the speed of the conveyor belt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed Variation**: The maximum variation of the speed, so as to not have
    always a constant speed, especially if you have many of these effectors. The random
    variation ranges from zero to the value in **Speed Variation**. Therefore, a positive
    value brings a random increment, whereas a negative value brings a random decrement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed Scale**: This allows you to scale the tangential force that is applied
    when the effector tries to accelerate the contacting rigidbodies to the specified
    speed along the surface. If it is set to `0`, then no force is actually applied,
    and it is like that the component is disabled. On the other hand, if it is set
    to `1`, means that the full force is applied. A useful way to think of this parameter
    is to think about how fast the rigidbody, which is in contact with the surface,
    is then accelerated to meet the specified speed; lower values means it will require
    more time, whereas higher values means it will reach the speed much quicker. However,
    you should be careful to use the full force, since a rigidbody might face other
    forces, leading the rigidbody to an undesired motion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Contact Force**: If true, a contact force will be used. Although it is
    more physically realistic, it may impress a torque to the rigidbody contacting
    the surface. As such, in video games where realism depends on the design, you
    can choose to enable it, since the default is disabled. An easy way to imagine
    this is that you are jumping on a real conveyor belt. The contact force along
    with the tangential force of the conveyor belt will make your legs move forward,
    but your chest will stay behind due to inertia, which may result in you falling.
    That means your body has started to rotate due a torque as shown in the following
    diagram:![Surface Effector 2D](img/image00572.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, when you jump on the conveyor belt, your legs are brought forward
    by the tangential force of the belt. Your chest, instead, stays behind due to
    inertia, leading to an applied torque on your body, and therefore you will fall.
    In Unity, it is possible to disable the contact force, so as to ensure that a
    torque is not applied to rigidbodies that enter in contact with the conveyor belt.
  prefs: []
  type: TYPE_NORMAL
- en: '**Use Friction**: If true, there will be friction on the surface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Bounce**: If true, there will be bounce on the surface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the natural example of usage is when in your game a conveyor belt
    is used. But let's try to find out another example. Suppose that the protagonist
    of your game has a special glove that when it touches a metal wall, it is able
    to contrast gravity by creating a magnetic field. You can place a surface effector
    vertically, and apply a force upwards as far as the player is touching that wall.
  prefs: []
  type: TYPE_NORMAL
- en: Physics Material 2D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity also offers the possibility to create physics materials so as to adjust
    the friction and bounciness of a physical object when it collides with another
    one. In the case of 2D, this is enabled by the **Physics Material 2D**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a **Physics Material 2D** by selecting **Assets | Create | Physics
    Material 2D** from the top-bar menu as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Physics Material 2D](img/image00573.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once selected in the project panel, we can tweak its two values in the **Inspector**,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Physics Material 2D](img/image00574.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s worthwhile mentioning that we have seen many variables during this chapter
    to assign a **Physics Material 2D**, and they are structured in a simple hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: If a **Collider** has a **Physics Material 2D**, this takes the priority and
    will be set to **Collider**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a **Collider** doesn't have a **Physics Material 2D**, then it will be assigned
    the one in the **Rigidbody2D**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If even the **Rigidbody2D** doesn't have a **Physics Material 2D**, then the
    default **Physics Material 2D** will be assigned. The default **Physics Material
    2D** can be set in **Physics Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dealing with physics in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, everything went smooth and we learned about all the single components
    of the Physics engine of Unity. However, when it comes to building your own game,
    dealing with physics might be a little bit tricky. In fact, just some wrong values
    on some forces and the whole scene can quickly mess up. The best way to solve
    this is by trial and error. The more you experiment, the more you will become
    practical with the Physics engine, and you will develop an intuition on how to
    balance all the values in your game. As a result, you will be able to make your
    scene act as described in the game design document (or almost).
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with physics isn't just about placing the different components, but
    also about how to program them. We have already seen some useful functions to
    apply on a rigidbody as well as some events when two colliders hit each other.
    But there is more. First of all, it's important to understand that all the variables
    we have seen of all the components (such as rigidbodies, colliders, joints, and
    effectors) can be assigned dynamically at runtime with a script. You just need
    to get a reference to that component, and then you will be able to change its
    internal parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more thing that can come in handy is the possibility to query the Physics
    engine through some functions in order to gather some information about the surroundings.
    These are static functions of the `Physics2D` class, and so they can be called
    with the following fragment of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you need to substitute `NameOfTheFunction` with the function. The `Physics2D`
    class exposes many of these, but let''s explore just the main ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OverlapCircleAll(Vector2 point, float radius, [*optional parameters]*)`: This
    returns the arrays of `Collider2D` which are all within the circle specified by
    the `radius` and `point` (the center of the circle) variables. In other words,
    it detects all the colliders that are within the specified circle. From the collider,
    it is possible to retrieve the game object itself as well. Our cupcake towers
    will use this function to detect how many enemies there are around. Furthermore,
    other optional parameters of the function are available to specify a mask of layers
    and the min and max values for the depth (*z*-axis) in which the function should
    search.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OverlapCircle(Vector2 point, float radius, [*optional parameters]*)`: The
    same function as before, but instead of returning the full array, it returns the
    first occurrence. It is useful when you just need to detect whether something
    is present within the circle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RaycastAll(Vector2 origin, Vector2 direction, [*optional parameters]*)`: This
    shoots a ray from an `origin` towards a `direction`, and returns all the different
    colliders that the ray hits within an array of `RayCastHit2D` (see later), which
    is a class that specifies all the details of the hit, including the collider.
    This function is useful when you need to verify if something is present somewhere
    in the space. Furthermore, other optional parameter can specify the maximum distance
    that the ray can reach, a mask of layers, and the min and max values for the depth
    (*z*-axis).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Raycast(Vector2 origin, Vector2 direction, [*optional parameters]*)`: The
    same function as the previous one, but instead of returning the full array, it
    returns only the first hit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find all the functions of the `Physics2D` class in the official documentation
    here: [https://docs.unity3d.com/ScriptReference/Physics2D.html](https://docs.unity3d.com/ScriptReference/Physics2D.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'About the `RayCastHit2D` class, here is the list of information that we can
    retrieve:'
  prefs: []
  type: TYPE_NORMAL
- en: '`centroid`: The centroid of the primitive used to perform the cast'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collider`: The collider hit by the ray'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`distance`: The distance from the origin of the ray to the impact point'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fraction`: The fraction of the distance along the ray that the hit occurred'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`normal`: The normal vector of the surface hit by the ray'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`point`: The point in the world space where the ray hit the collider''s surface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rigidbody`: The `Rigidbody2D` attached to the object that was hit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transform`: The Transform of the object that was hit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, querying the Physics engine is a common practice to gather information,
    and we will do it with our *Tower *Defense game.
  prefs: []
  type: TYPE_NORMAL
- en: Other things about Physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with other chapters, this is an optional section with some deeper insights
    into the topic covered in the chapter. So, feel free to skip this section if you
    are not interested, and jump directly onto the next section. Otherwise, just grab
    some more coffee and keep reading.
  prefs: []
  type: TYPE_NORMAL
- en: The Simulate setting on rigidbodies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This aim of this section is to explain the difference between enabling and disabling
    physical components on a rigidbody and enabling and disabling the **Simulate**
    settings on top of the rigidbody component.
  prefs: []
  type: TYPE_NORMAL
- en: Every time that a physical component is either added, enabled, removed, or disabled,
    the internal memory of the Physics engine is updated (respectively to add or remove
    the component from the memory). When the **Simulate** setting is disabled, the
    Physics engine just stops to perform calculations on it - it doesn't erase the
    object from the memory. As a result, when **Simulate** is checked back, the Physics
    engine has already all the objects/components in the memory and it doesn't' need
    to create them from scratch, thus leading to a performance improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you need to remove a rigidbody permanently from the scene, then
    just erase the component, because if you just uncheck **Simulate**, the component
    will still be in memory, leading to a poor memory management.
  prefs: []
  type: TYPE_NORMAL
- en: Physics Raycaster 2D component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in Chapter 3, *Communicating with the Player – the User Interface*, we
    have seen the Unity UI system, and in the optional section there were the different
    components of a canvas. One of them was the **Graphical Raycaster**, which is
    able to detect the input of the user on the screen. This component checks if the
    player actually went over a slider or clicked a button, and then triggers events
    by exchanging messages with the event system.
  prefs: []
  type: TYPE_NORMAL
- en: If we have physics objects and we want to exchange events about them in a similar
    way the **Graphical Raycaster** does for the UI, we can use a Physics Raycaster
    2D component on a camera to handle such events.
  prefs: []
  type: TYPE_NORMAL
- en: Once this component is added, you can implement different interfaces in the
    scripts of your physics objects. As a result, the functions that they will implement
    will be automatically called when the corresponding event is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, an event could be that a joint breaks, and you may want to run
    some code when this happens. Moreover, some information will be provided to the
    functions; in the case of the joint, the amount of force that broke the joint
    is passed as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The other Physics settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here you can find the other Physics settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Velocity Iterations**: The number of iterations that are made to determine
    the velocity of a physical body during an update. The higher is the number, the
    more accurate the simulation will be. The drawback is computational cost. The
    default value is `8`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Position Iterations**: The number of iteration made to determine the position
    of a physical body during an update. The higher is the number, the more accurate
    the simulation will be. The drawback is computational cost. The default value
    is `3`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Velocity Threshold**: Collisions with a relative velocity lower than this
    value are treated as inelastic collisions, which means that the colliding bodies
    will not bounce off each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Linear Correction**: The maximum linear position correction used when
    solving constraints. It can have any value between `0.0001` to `1000000`. It helps
    to prevent overshooting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Angular Correction**: The maximum angular correction used when solving
    constraints. It can have any value between `0.0001` to `1000000`. It helps to
    prevent overshooting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Translation Speed**: This is the maximum (translation) speed that a body
    in your game could have. This value is the upper limit, which means that every
    object that tries to reach faster velocities, will be cap to this value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Rotation Speed**: This is the maximum (rotation) speed that a body in
    your game could have. The same reasoning as before applies, just with rotations
    instead of translations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Min Penetration For Penalty**: The minimum contact penetration radius allowed
    before any separation impulse force is applied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Baumgarte Scale**: This is a scale factor that determines how fast collision
    overlaps are resolved (see the information box).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Baumgarte Time Of Impact Scale**: A scale factor that determines how fast
    time-of-impact overlaps are resolved (see the information box).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Baumgarte's constraint stabilization method (sometimes just abbreviated to Baumgarte's
    method) is an algorithm for resolving certain collision constraints, such as with
    joints, invented by J. Baumgarte in 1972\. It is fast enough so that it can be
    used in real-time applications such as video games or robotics. The trick consists
    of taking advantage of some derived analytic forms of differential equations that
    are solved numerically. This allows you to run the algorithm not only faster than
    its predecessors but also with a higher degree of accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: The **Baumgarte Scale** is the important parameter for the algorithm, which
    represents the correction ratio to apply. A common value, which is often given
    as default, is `0.2` and it is also the default value that Unity uses.
  prefs: []
  type: TYPE_NORMAL
- en: The higher the value, the more your joints will go wild. On the other hand,
    the lower the value, the less your joints will do, and it can cause sponginess.
  prefs: []
  type: TYPE_NORMAL
- en: '**Queries Hit Trigger**: This is a toggle that if true allows raycasts to hit
    also trigger volumes. By default, it is true, but can be unchecked in case you
    don''t want raycasting to hit trigger volumes, but just colliders. When to uncheck
    this box really depends on the design of your game, and what you have in mind
    to program it.![The other Physics settings](img/image00575.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Queries Hit Trigger is set to false (upper part of diagram*)*, trigger
    volumes won't be detected by raycasting. On the contrary, when Queries Hit Trigger
    is set to true (lower part of diagram), also trigger volumes will be detected
    by raycasting and returned as a hit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Queries Start In Collider**: This is a toggle that, if true, allows raycasts
    that start within a collider to what hit that collider. By default, it is true,
    but can be unchecked if many of your raycasts start within a collider and you
    don''t want them to be returned as hits. Again, when to uncheck this box really
    depends on the design of your game, and also you have in mind to program it.![The
    other Physics settings](img/image00576.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Queries Start In Collider is set to false (upper part of diagram) and the
    the source of the raycast is within a collider, this one won't be returned as
    a hit. On the contrary, when Queries Start In Collider is set to true (lower part
    of diagram), also the collider in which there is the source of the raycast is
    returned as a hit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Change Stops Playback**: This is a toggle that, if true, stops reporting
    collision callbacks immediately if any of the GameObjects involved in the collision
    are deleted or moved. By default, it is false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gizmos**: (The description of this foldout is in the next section.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gizmos for colliders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section describes the previous menu item, **Gizmos**, in the **Physics
    2D** settings.
  prefs: []
  type: TYPE_NORMAL
- en: '**Gizmos** is a foldout that shows you extra options about the visualizations
    of colliders within the editor. These options are really useful in debugging.
    This is how it appears in the **Inspector**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Gizmos for colliders](img/image00577.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is an explanation of the options displayed and their usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Always Show Colliders**: By default, you are able to see a collider only
    when a game object (or one of its children) contains such a collider. If you enable
    this option, you will always be able to see colliders (whenever **Gizmos** are
    visible).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show Collider Sleep**: When enabled, it allows you to see a collider even
    when it is in sleep mode within the Physics engine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collider Awake Color**: This specifies the color that awake (no-sleeping)
    colliders should have when shown. By default, it is a light green with the alpha
    channel (opacity) set to `192`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collider Sleep Color**: This specifies the color that sleeping colliders
    should have when shown. By default, it is the same light green as when the collider
    is awake, but with the alpha channel (opacity) set to `92`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show Collider Contacts**: When enabled, this allows you to see the contacts
    point of the colliders when they collide. They are shown as arrows (as shown in
    the next diagram).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contact Arrow Scale**: This value allows you to scale down the arrow showed
    by the contact points of the collider. By default, its value is `0.2` (as shown
    in the next diagram).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collider Contact Color**: This specifies the color of such arrows representing
    the contact points of the collider. By default, it is set to light purple (as
    shown in the next diagram):![Gizmos for colliders](img/image00578.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the left there are two colliders that are overlapping with each other. In
    the middle, the colliders are updated by the Physics engine to simulate the collisions
    (since they cannot overlap). Also shown are the points of contact between the
    two arrows. On the right, there is the same diagram that is in the middle, but
    with the **Contact Arrow Scale** set to `0.6` instead of `0.2`, and as a result
    the arrows are bigger.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Show Collider AABB**: When enabled, this allows you to see the **Axis-Aligned
    Bounding Box** (**AABB**) of the collider. As the name suggests, it is a box that
    fully contains the collider, and it is aligned with the axis of the world frame.
    For example, the bounding box of a polygonal collider is the following (on the
    left):![Gizmos for colliders](img/image00579.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the left is the polygonal collider with its AABB; on the right is the same
    diagram as the previous one, but showing its AABB.
  prefs: []
  type: TYPE_NORMAL
- en: '**Collider AABB Color**: This specifies the color of the AABB of the collider,
    when shown'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics for our game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we will apply some concepts of this chapter into our game. In
    particular, we will see how to detect when a sprinkle hits a panda and applies
    damage to it using the Physics engine.
  prefs: []
  type: TYPE_NORMAL
- en: Set up Pandas as a rigidbodies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we will take advantage of the Physics engine, we need to proper set up
    the Panda as that to be a physical object in the scene. This means giving it a
    rigidbody component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we can start by adding a **Rigidbody2D** component to the Panda
    prefab, and set its **Body Type** as **Kinematic**, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Set up Pandas as a rigidbodies](img/image00580.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In theory, we should have done, since the Panda is considered a physical object
    now. However, in the previous chapter, we have written a function that allows
    the Panda to move by assigning its new position directly on its Transform. Since
    now the Panda has a **Rigidbody2D** component, we cannot do in this way anymore
    (as we already explained previously in the *Rigidbodies* section). Therefore,
    we need to slightly modify the `PandaScript`. In particular, we need to get a
    reference to the rigidbody of the Panda, then use the `MovePosition()` function
    for Kinematic rigidbodies. Basically, we are applying what we have learnt in the
    *Dealing with rigidbodies* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, open the script, and add the following private variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `Start()` function add this line at the end of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `MoveTowards()` function, we need to use the `MovePosition()` function
    on the Panda''s rigidbody to change its position. In addition, we shouldn''t use
    `deltaTime` anymore, and substitute it with `fixedDeltaTime`. As such, here is
    highlighted what is changed from the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need to remember that the `MoveTowards()` function, now, should be called
    within a `FixedUpdate()` and not in the `Update()`. We will see this in [Chapter
    7](https://cdp.packtpub.com/b03794gettingstartedwithunity2dgamedevelopmentsecondedition/wp-admin/post.php?post=220&action=edit#post_247),
    *Trading Cupcakes and the Ultimate Battle for the Cake – Gameplay Programming*.
    But you can have an example in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can save the script, and we have done with the Panda.
  prefs: []
  type: TYPE_NORMAL
- en: Set up projectiles as rigidbodies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to what we did for the Pandas, we need to add a **Rigidbody2D** component
    to all the projectiles, and again set the **Body Type** to **Kinematic**.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, also projectiles used to move by changing directly their Transforms,
    and we need to fix this, since they have a **Rigidbody2D** component as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the script, and as we did for the Pandas, add the following private variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `Start()` function, let’s get the reference to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to replace the `Update()` function with the `FixedUpdate()` one,
    since we are dealing with the Physics engine. Moreover, we need to slightly change
    the code (note also the use of the `fixedDeltaTime`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A careful reader would notice that we are applying the equation of motion explained
    in the information box within the *Dealing with rigidbodies* section. In particular,
    here we have split the velocity into a direction and a speed (which multiplied
    them together give back the velocity).
  prefs: []
  type: TYPE_NORMAL
- en: Save the script, and let’s see how we can detect when a sprinkle hits a panda
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Detect sprinkles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to detect a collision between a sprinkle and a Panda, we need to add
    them both a **Collider2D**. You can choose the one that better suits your needs,
    I'll go for the **Box2D** collider. Then, you need to make one of them act as
    a Trigger, in our example we can take the Panda.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to implement the `OnTriggerEnter2D()` function, which is called
    from the Physics engine of Unity, on the `PandaScript`. As a result, we are able
    to detect when something hits the panda, and check if it is an actual sprinkle,
    so to apply damage to the panda with the `Hit()` function written in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, we need to be sure that every object with the Projectile tag have
    a **ProjectileScript** component attached. This check is left as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, save the script, and we have done with Physics for our game, at least
    in this chapter. In fact, in the next chapter, we will use again the Physics engine,
    but for other reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Homework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As in every chapter, here are some exercises that you can use to practice your
    skills:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The forgotten rigidbody**: Sometimes components in the **Inspector** could
    be forgotten. However, we can facilitate the process by creating warnings in the
    code. For both our Panda and the sprinkles, create within their scripts a check,
    when the game object is initialized, to add a **Rigidbody2D** component, if missing,
    and set it to be **Kinematic**. Additionally, you can print a warning message
    (See [Chapter 8](part0100.xhtml#aid-2VBO82 "Chapter 8. What Is beyond the Cake?"),
    *What Is beyond the Cake?*, for more about debugging messages).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Passion for acceleration**: In the chapter, we saw how we could implement
    motion equations for our **Kinematic** rigidbodies. In particular, the chapter
    shown an implementation of the velocity equation. Now, try to implement the acceleration
    equation for a **Kinematic** rigidbody.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Joint Master**: For each one of the joints that Unity offers, think about
    a possible usage and example (possibly different from the ones already presented
    in the chapter). Then, sketch the physical system on paper, and determine which
    are the rigidbodies and where the anchor points are. Finally, reproduce what you
    have imagined within Unity, and tweak all the settings until it works as you have
    decided.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Effector Master**: For each one of the effectors that Unity offers, think
    about a possible usage and example (possibly different from the ones already presented
    in the chapter). Then, sketch how the effector should work on paper, and determine
    how the different rigidbodies would interact with it. Finally, reproduce what
    you have imagined within Unity, and tweak all the settings until it works as you
    have decided.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A less dauntless Panda (Part III)**: If you also completed the second part
    of this exercise back in [Chapter 4](part0056.xhtml#aid-1LCVG1 "Chapter 4. No
    Longer Alone – Sweet-Toothed Pandas Strike"), *No Longer Alone - Sweet-Toothed
    Pandas Strike*, some pandas will be stunned, others not, depending on the Boolean
    value. Instead of exposing this Boolean within the **Inspector**, add this property
    to the `Projectile` class, so that if the Panda is stunned or not depends on which
    kind of projectile the Panda was hit with (we will see this later in [Chapter
    6](part0077.xhtml#aid-29DRA1 "Chapter 6. Through a Sea of Sprinkles – Navigation
    in Artificial Intelligence"), *Through a Sea of Sprinkles – Navigation in Artificial
    Intelligence*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A less dauntless Panda (Part IV)**: After you have done part three of this
    exercise, if the poor panda is under attack with too many sprinkles, it might
    not move anymore because it is always in a stunned state. As a result, it won''t
    able to avoid the sprinkles either. So as to avoid this, we need to modify the
    Panda script such that if another sprinkle hits the Panda while it is stunned,
    it detracts the health from the Panda; but doesn''t trigger from the beginning
    the hit animation and/or the stun period.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A less dauntless Panda (Part V)**: Now that you have also completed the third
    part of this exercise, let''s improve the whole system of stunning a Panda. Add
    to each projectile, a variable that indicates the chance of this projectile to
    stunning a Panda. Finally, trigger the stunning phase of the Panda probabilistically
    based on the previous variable.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, if you are into challenges, here is one for you:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The frozen conveyor belt (Part I)**: Imagine a conveyor belt that is made
    of a big piece of ice and scrolls quite fast. Think and describe what would happen
    when a box is dropped onto it. Keep in mind that the friction on the ice is really
    low, and that there is inertia to consider. What if, instead of a box, there was
    a sphere? The solution is available at the end of the book.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The frozen conveyor belt (Part II)**: Once you have done Part I, reproduce
    the frozen conveyor belt within the Physics engine of Unity, and try it out with
    boxes and spheres.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by learning some basic notions of physics so as
    to better develop our games. Then, we went through the Physics engine of Unity,
    which is divided into some components. Rigidbodies and colliders describe the
    properties of physical objects in the game, whereas joints and effectors affect
    how they react with each other in the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how to deal with physics and took what we needed for our *Tower
    Defense* game, so as to implement the collision between a sprinkle and a Panda
    (and call the right functions to update the Panda's health and animations).
  prefs: []
  type: TYPE_NORMAL
