- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Material Alchemy: Using URP and Shader Graph for Stunning Visuals'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the first chapter of *Section 3*, *Elevating Visuals, Effects, and
    Audio* Here, we will dive deep into the different graphics and audio systems of
    Unity to dramatically improve the look and feel of the game. Let’s begin our journey
    into the world of shaders, the artists behind the scenes in every Unity game,
    and learn how to craft our own from scratch. We will start by discussing what
    a shader is and how to create our own to achieve several custom effects that couldn’t
    be accomplished using the default Unity shaders. We will be creating a simple
    water animation effect using Shader Graph, a visual shader editor included in
    the Universal Render Pipeline (URP), the preferred option for creators to launch
    their games on a wide variety of devices, including web and mobile. Also known
    as URP, this is one of the different rendering pipelines available in Unity, which
    provides rendering features oriented toward performance. We will be discussing
    some of its capabilities in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will examine the following shader concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing shaders and URP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating shaders with Shader Graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing shaders and URP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember the glowing orb material we created in *Section 1*, *Getting Started
    with Unity*? Let’s explore how its shader property manipulates light to create
    that glow effect. In this first section, we will be exploring the concept of a
    shader as a way to program the video card to achieve custom visual effects. We
    will also be discussing how URP works with those shaders, and the default shaders
    it provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will cover the following concepts related to shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: Shader pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render pipeline and URP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URP built-in shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by discussing how a shader modifies the shader pipeline to achieve
    effects.
  prefs: []
  type: TYPE_NORMAL
- en: Shader pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever a video card renders a 3D model, it needs different information to
    process, such as a **mesh**, **textures**, the transformation of the object (position,
    rotation, and scale), and lights that affect the object. With that data, the video
    card must output the pixels of the object into the **back buffer**, an image where
    the video card will be drawing our objects, but the user won’t see this yet. This
    is done to prevent the user from seeing unfinished results, given we can still
    be drawing at the time the monitor refreshes. That image will be shown when Unity
    finishes rendering all objects (and some effects) to display the finished scene,
    swapping the **back buffer** with the **front buffer**, the image that the user
    actually sees. You can imagine this as having a page with an image that is being
    shown to the user while you draw a new image, and when you finish the new drawing,
    you just swap the pages and start drawing again on the page the user does not
    see, repeating this with every frame.
  prefs: []
  type: TYPE_NORMAL
- en: That’s the usual way to render an object, but what happens between the input
    of the data and the output of the pixels can be handled in a myriad of different
    ways and techniques that depend on how you want your object to look; maybe you
    want it to be realistic or look like a hologram, or maybe the object needs a disintegration
    effect or a toon effect—there are endless possibilities. The way to specify how
    our video card will handle the rendering of the object is through a shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **shader** is a program coded in specific video card languages, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HLSL**: The DirectX shading language, DirectX being a graphics library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GLSL**: The OpenGL shading language, OpenGL also being a graphics library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CG**: A language that can output either HLSL or GLSL, depending on which
    graphics library we use in our game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shader Graph**: A visual language that will be automatically converted into
    one of the previously mentioned languages according to our needs. This is the
    one we will be using given its simplicity (more on that later).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any of those languages can be used to configure different stages of the render
    process necessary to render a given object, sometimes not only configuring them
    but also replacing them with completely custom code to achieve the exact effect
    we want. All of the stages to render an object make up what we call the shader
    pipeline, a chain of modifications applied to the input data until it is transformed
    into pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each stage of the pipeline is in charge of different modifications, and depending
    on the video card shader model, this pipeline can vary a lot. In the next diagram,
    you can find a simplified shader pipeline, skipping advanced/optional stages that
    are not important right now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A blue rectangle with black text  Description automatically generated with
    low confidence](img/B21361_10_01_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Common shader pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: Think of the shader pipeline as an assembly line in a factory, where each stage
    represents a different worker specializing in a specific task, collectively contributing
    to the final product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s discuss each of the stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input Assembler**: Here is where all of the mesh data, such as vertex position,
    UVs, and normals, is assembled to be prepared for the next stage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vertex Shader**: This stage used to be limited to applying the transformation
    of the object, the position and perspective of the camera, and simple lighting
    calculations. In modern GPUs, you are in charge of doing whatever you want. This
    stage receives each of the vertices of the object to render and outputs a modified
    one. You have the chance to modify the geometry of the object here. The usual
    code here applies the transform of the object, but you can also apply several
    effects, such as inflating the object along its normals to apply the old toon
    effect technique or apply distortion, adding random offsets to each vertex to
    recreate a hologram. There’s also the opportunity to calculate data for the next
    stages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Primitive Culling**: Most of the models you are going to render have the
    particularity that you will never see the back side of a model face. With a cube,
    there’s no way to look at its inner sides. Given that, rendering both sides of
    each face of the cube makes no sense, and this stage takes care of that. Primitive
    culling will determine whether the face needs to be rendered based on the orientation
    of the face, saving lots of pixel calculation of occluded faces. You can change
    this to behave differently for specific cases; as an example, we can create a
    glass box that needs to be transparent to see all sides of the box. Don’t confuse
    this with other types of culling, like frustum culling. This other type of culling
    filters objects outside the camera view area before they are even sent to the
    shader pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rasterizer**: Now that we have the modified and visible geometry of our model
    calculated, it’s time to convert it into pixels. The rasterizer creates all pixels
    for the triangles of our mesh. Lots of things happen here, but again, we have
    very little control over that; the usual way to rasterize is just to create all
    pixels inside the edges of the mesh triangles. We have other modes that just render
    the pixels on the edges to see a wireframe effect, but this is usually used for
    debugging purposes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Image result for rasterizer](img/B21361_10_02_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Example of figures being rasterized'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fragment Shader**: This is one of the most customizable stages of all. Its
    purpose is simple: just determine the color of each of the fragments (pixels)
    that the rasterizer has generated. Here, lots of things can happen, from simply
    outputting a plain color or sampling a texture to applying complex lighting calculations
    such as normal mapping and PBR. Also, you can use this stage to create special
    effects such as water animations, holograms, distortions, disintegrations, and
    any special effects that require you to modify what the pixels look like. We will
    explore how we can use this stage in the next sections of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Depth Testing**: Before showing a pixel on the screen, we need to check whether
    it can be seen. This stage checks whether the pixel’s depth is behind or in front
    of the previous pixel rendered in the same position, guaranteeing that, regardless
    of the rendering order of the objects, the nearest pixels to the camera are always
    drawn on top of others. Again, usually, this stage is left in its default state,
    prioritizing pixels that are nearer to the camera, but some effects require different
    behavior. Also, nowadays we have **early-Z testing**, which does this same test
    but before the Fragment Shader stage. But let’s keep things simple for now. As
    an example, in the next screenshot, you can see an effect that allows you to see
    objects that are behind other objects, like the one used in *Age of Empires* when
    a unit is behind a building:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Image result for occluded effect shader](img/B21361_10_03_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Rendering the occluded parts of the character'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blending**: Once the color of the pixel is determined and we are sure the
    pixel is not occluded by a previous pixel, the final step is to put it in the
    back buffer (the frame or image you are drawing). Usually, we just override whatever
    pixel was in that position (because our pixel is nearer to the camera), but if
    you think about transparent objects, we need to combine our pixel with the previous
    one to make the transparent effect. Transparencies have other things to take into
    account aside from the blending, but the main idea is that blending controls exactly
    how the pixel will be combined with the previously rendered pixel in the back
    buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shader pipelines would require an entire book to cover, but for the scope of
    this book, the previous description will give you a good idea of what a shader
    does, and the possible effects that it can achieve. Now that we have discussed
    how a shader renders a single object, it is worth discussing how Unity renders
    all of the objects using the render pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about shaders, you can use the following link: [https://docs.unity3d.com/Manual/shader-writing.html](https://docs.unity3d.com/Manual/shader-writing.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Render pipeline and URP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have covered how the video card renders an object, but Unity is in charge
    of asking the video card to execute a shader pipeline per object. To do so, Unity
    needs to do lots of preparations and calculations to determine exactly how and
    when each shader needs to be executed. The responsibility of doing this is with
    what Unity calls the render pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Think of Unity’s render pipeline like a film director orchestrating how each
    scene (object) is presented, with URP as one of its advanced cameras, optimizing
    how each shot is captured. Also, think of the render pipeline as the stage crew
    of a theater, setting the scene and lighting for each object (actor) to ensure
    they look the best under the spotlight.
  prefs: []
  type: TYPE_NORMAL
- en: A render pipeline is a way to draw the objects of the scene. At first, it sounds
    like there should be just one simple way of doing this, for example, iterating
    over all objects in the scene and executing the shader pipeline with the shader
    specified in each object’s material, but it can be more complex than that.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the main difference between one render pipeline and another is the
    way in which lighting and some advanced effects are calculated, but they can differ
    in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: In previous Unity versions, there was just one single render pipeline, which
    is now called the **built-in renderer pipeline** (also known as **BIRP**). It
    was a pipeline that had all of the possible features you would need for all kinds
    of projects, from mobile 2D graphics and simple 3D to cutting-edge 3D graphics
    like the ones you can find in consoles or high-end PCs. This sounds ideal, but
    actually, it isn’t. Having one single giant renderer that needs to be highly customizable
    to adapt to all possible scenarios generates lots of overhead and limitations
    that cause more headaches than creating a custom render pipeline. Luckily, the
    last versions of Unity introduced the **Scriptable Render Pipeline** (**SRP**),
    a way to create a render pipeline adapted to your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, Unity doesn’t want you to create your own render pipeline for each
    project (which is a complex task), so it has created two custom pipelines for
    you that are ready to use: **URP** (formerly called LWRP, or Lightweight Render
    Pipeline), which stands for **Universal Render Pipeline**, and **HDRP**, which
    stands for **High Definition Render Pipeline**. The idea is that you must choose
    one or the other based on your project’s requirements (unless you really need
    to create your own).'
  prefs: []
  type: TYPE_NORMAL
- en: 'URP, the one we selected when creating the project for our game, is a render
    pipeline suitable for most games that don’t require lots of advanced graphics
    features, such as mobile games or simple PC games, while HDRP is packed with lots
    of advanced rendering features for high-quality games. The latter requires high-end
    hardware to run, while URP runs on almost every relevant target device. It is
    worth mentioning that you can swap between BIRP, HDRP, and URP whenever you want,
    including after creating the project (but this is not recommended):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_10_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Project wizard showing HDRP and URP templates'
  prefs: []
  type: TYPE_NORMAL
- en: We could discuss how each one is implemented and the differences between each,
    but again, this could fill entire chapters. Right now, the idea of this section
    is for you to know why we picked URP when we created our project; it has some
    restrictions we will encounter throughout this book that we will need to take
    into account, so it is good to know why we accepted those limitations. One reason
    we chose it was that it allows us to run our game on all relevant hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another reason why we have chosen URP is that it has support for Shader Graph,
    the Unity tool that we will be using in this chapter to create custom effects.
    Previous Unity built-in pipelines didn’t provide us with such a tool (aside from
    third-party plugins). Finally, another reason to introduce the concept of URP
    is that it comes with lots of built-in shaders that we will need to know about
    before creating our own to prevent reinventing the wheel. This will allow us to
    get used to those shaders, because if you came from previous versions of Unity,
    the shaders you already know won’t work here; actually, this is exactly what we
    are going to discuss in the next section of this chapter: the difference between
    the different URP built-in shaders.'
  prefs: []
  type: TYPE_NORMAL
- en: URP built-in shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know the difference between URP and other pipelines, let’s discuss
    which shaders are integrated into URP. Let’s briefly describe the three most important
    shaders in this pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lit**: This is the replacement of the old Standard Shader. This shader is
    useful for creating all kinds of realistic physics materials, such as wood, rubber,
    metal, skin, and combinations of them (such as a character with skin and metal
    armor). It supports features like normal mapping, occlusion, different lighting
    workflows like Metallic and Specular, and transparencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple Lit**: This is the replacement of the old Mobile/Diffuse Shader. As
    the name suggests, this shader is a simpler version of Lit, meaning that its lighting
    calculations are simpler approximations of how light works, with fewer features
    than its counterpart. Basically, when you have simple graphics without realistic
    lighting effects, this is the best choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unlit**: This is the replacement of the old Unlit/Texture Shader. Sometimes,
    you need objects with no lighting whatsoever, and in that case, this is the shader
    for you. No lighting doesn’t mean an absence of light or complete darkness; it
    actually means that the object has no shadows at all, and it’s fully visible without
    any shade. Some simplistic graphics can work with this, relying on shadowing being
    baked in the texture, meaning that the texture comes with the shadow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is extremely performant, especially for low-end devices such as mobile
    phones. Also, you have other cases such as light tubes or screens, objects that
    can’t receive shadows because they emit light, so they will be seen at their full
    color even in complete darkness. In the following screenshot, you can see a 3D
    model using an Unlit Shader. It looks like it’s being lit, but it’s just the texture
    of the model that applied lighter and darker colors in different parts of the
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing design  Description automatically generated](img/B21361_10_05_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Pod using an Unlit effect to simulate cheap lighting'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do an interesting disintegration effect with the Simple Lit Shader to
    demonstrate its capabilities. You must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by sourcing a **Cloud Noise** texture. You can find suitable textures
    on various free asset websites. Ensure the texture’s resolution and format are
    compatible with Unity for optimal results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Image result for cloud noise texture](img/B21361_10_06_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Noise texture'
  prefs: []
  type: TYPE_NORMAL
- en: Select the recently imported texture in the **Project** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector, set the **Alpha Source** property to **From Gray Scale**.
    This will make the alpha channel of the texture be calculated based on the grayscale
    of the image. We will use the calculated alpha value to determine which pixels
    need to be deintegrated first (the darker ones first):![A screenshot of a computer  Description
    automatically generated with medium confidence](img/B21361_10_07_PE.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.7: Applying the Alpha Source From Gray Scale texture setting'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The alpha channel of a color is often associated with transparency, but you
    will notice that our object won’t be transparent. The alpha channel is extra color
    data that can be used for several purposes when creating effects. In this case,
    we will use it to determine which pixels are being disintegrated first.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click the **+** icon in the **Project** view and select **Material.** You can
    rename it, giving it a name that makes it easier to find later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_10_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Material creation button'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a cube by going to the top menu and selecting **GameObject | 3D Object
    | Cube**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_10_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Cube primitive creation'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the material from the **Project** window to the cube in the **Scene** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click in the drop-down menu at the right of the **Shader** property in the
    Inspector and look for the **Universal Render Pipeline | Simple Lit** option.
    We could also work with the default shader (**Lit**), but **Simple Lit** is going
    to be easier on performance, and we don’t need the advanced features of **Lit**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_10_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Simple Lit Shader selection'
  prefs: []
  type: TYPE_NORMAL
- en: Next, select the newly created material in your project. Drag and drop the downloaded
    `Cloud Noise` texture into the **Base Map** section. This step visually binds
    your texture to the shader, enabling the disintegration effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the **Alpha Clipping** option and adjust the **Threshold** slider to
    `0.5`. **Alpha Clipping** plays a critical role in how the shader interprets texture
    transparency, influencing the disintegration effect’s appearance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_10_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: Alpha Clipping Threshold material slider'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you move the **Threshold** slider, the object will start to disintegrate.
    **Alpha Clipping** discards pixels that have less alpha intensity than the **Threshold**
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A black and white cube  Description automatically generated with medium confidence](img/B21361_10_12_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: Disintegration effect with Alpha Clipping'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, set **Render Face** to **Both** to see both sides of the cube’s faces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_10_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.13: Double-sided render face'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take into account that the artist that creates the texture can configure the
    **Alpha** channel manually instead of calculating it from the grayscale, just
    to control exactly how the disintegration effect must look regardless of the texture’s
    color distribution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A black and white cube  Description automatically generated with medium confidence](img/B21361_10_14_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.14: Double-sided Alpha Clipping'
  prefs: []
  type: TYPE_NORMAL
- en: The idea of this section is not to give a comprehensive guide of all of the
    properties of all URP shaders but to give you an idea of what a shader can do
    when properly configured and when to use each of the integrated shaders. Sometimes,
    you can achieve the effect you need just by using existing shaders, probably in
    99% of cases in simple games, so try to stick to them as much as you can. But
    if you really need to create a custom shader to create a very specific effect,
    the next section will teach you how to use the URP tool called Shader Graph.
  prefs: []
  type: TYPE_NORMAL
- en: Creating shaders with Shader Graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how shaders work and the existing shaders in URP, we have a
    basic notion of when it is necessary to create a custom shader and when it is
    not necessary. In case you really need to create one, this section will cover
    the basics of effects creation with Shader Graph, a tool to create effects using
    a visual node-based editor. This is an easy tool to use when you are not used
    to coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will discuss the following concepts of Shader Graph:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first Shader Graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using textures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining textures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying transparency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating vertex effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by seeing how we can create and use a Shader Graph.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first Shader Graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Shader Graph is a tool that allows us to create custom effects using a node-based
    system. An effect in Shader Graph can look like in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_10_15_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.15: Shader Graph with nodes to create a custom effect'
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss later what those nodes do and we will be creating an example
    effect step by step, but in the screenshot, you can see how we created and connected
    several nodes—the interconnected boxes—with each one executing a specific process
    to achieve the effect. The idea of creating effects with Shader Graph is to learn
    which specific nodes you need and how to connect them properly. This is similar
    to the way we code the gameplay of the game, but this Shader Graph is adapted
    and simplified just for effect purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create and edit our first Shader Graph, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Project** window, click the **+** icon and find the **Shader Graph
    | URP | Lit Shader Graph** option. This will create a Shader Graph using the PBR
    mode, meaning that this shader will support lighting effects (unlike Unlit graphs):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_10_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.16: PBR Shader Graph creation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name it `Water`. If you want the opportunity to rename the asset, remember
    that you can select the asset, right-click, and select **Rename**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing screenshot, symbol, logo, electric blue  Description
    automatically generated](img/B21361_10_17_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.17: Shader Graph asset'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new material called `WaterMaterial` and set **Shader** to **Shader
    Graphs/Water**. If for some reason Unity doesn’t allow you to do that, try right-clicking
    on the **Water** graph and clicking **Reimport**. As you can see, the created
    Shader Graph now appears as a shader in the material:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_10_18_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.18: Setting a Shader Graph as a material shader'
  prefs: []
  type: TYPE_NORMAL
- en: Create a plane with the **GameObject | 3D Object | Plane** option by right-clicking
    from the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the material to the plane to apply it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you have created your first custom shader and applied it to a material.
    So far, it doesn’t look interesting at all—it’s just a gray effect—but now it’s
    time to edit the graph to unlock its full potential. As the name of the graph
    suggests, we will be creating a water effect in this chapter to illustrate several
    nodes of the Shader Graph toolset and how to connect them. So, let’s start by
    discussing the Master Node.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you open the graph by double-clicking the shader asset, you will see the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_10_19_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.19: Master Node with all of the properties needed to calculate the
    object’s appearance'
  prefs: []
  type: TYPE_NORMAL
- en: All nodes will have input pins, the data needed to work, and output pins, the
    results of their process. As an example, in a sum operation, we will have two
    input numbers and an output number, the result of the sum. In this case, you can
    see that the Master Node only contains inputs, and that’s because all data that
    enters the Master Node will be used by Unity to calculate the rendering and lighting
    of the object, things such as the desired object color or texture (the **Base
    Color** input pin), how smooth it is (the **Smoothness** input pin), or how much
    metal it contains (the **Metallic** input pin), properties that will affect how
    the lighting will be applied to the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that the Master Node is split between a **Vertex** section and
    a **Fragment** section. The first is capable of changing the mesh of the object
    we are modifying to deform it, animate it, etc., while the latter will change
    how it will look, which textures to use, how it will be illuminated, etc. Let’s
    start exploring how we can change that data in the **Fragment** section by doing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click the **Shader Graph** asset in the **Project** view to open its
    editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click in the gray rectangle at the left of the **Base Color** input pin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, font, design  Description automatically
    generated](img/B21361_10_20_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.20: Base Color node input pin'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the color picker, select a light blue color, like water. Select the bluish
    part of the circle and then a shade of that color in the middle rectangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a phone  Description automatically generated with low confidence](img/B21361_10_21_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.21: Color picker'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set **Smoothness** to `0.9`, which will make the object almost completely smooth
    (90% of the total smoothness possible). This will make our water reflect the sky
    almost completely:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, font, design  Description automatically
    generated](img/B21361_10_22_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.22: Smoothness PBR Master Node input pin'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Save Asset** button at the top left of the window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screen shot of a computer  Description automatically generated with low
    confidence](img/B21361_10_23_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.23: Shader Graph saving options'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the **Scene** view and check that the plane is light blue with the
    sun reflected on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a video game  Description automatically generated with medium
    confidence](img/B21361_10_24_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.24: Initial Shader Graph results'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the behavior of the shader varies according to the properties
    you set in the Master Node, but so far, doing this is no different than creating
    an Unlit Shader and setting up its properties; the real power of Shader Graph
    is when you use nodes that do specific calculations as inputs of the Master Node.
    We will start looking at the texture nodes, which allow us to apply textures to
    our model.
  prefs: []
  type: TYPE_NORMAL
- en: Using textures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea of using textures is to have an image applied to the model in a way
    that we can paint different parts of the models with different colors. Remember
    that the model has a UV map, which allows Unity to know which part of the texture
    will be applied to which part of the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_10_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.25: On the left, a face texture; on the right, the same texture applied
    to a face mesh'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like in visual scripting, we will use interconnected nodes in our shader graph
    that will execute specific shader operations. We have several nodes to do this
    task, one of them being **Sample Texture 2D**, a node that has two main inputs.
    First, it asks us for the texture to sample or apply to the model, and then for
    the UV. You can see it in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_26_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.26: Sample Texture 2D node'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the default value of the **Texture** input node is **None**,
    so there’s no texture by default, and we need to manually specify that. For **UV**,
    the default value is `UV0`, meaning that, by default, the node will use the main
    UV channel of the model; and yes, a model can have several UVs set. For now, we
    will stick with the main one. If you are not sure what that means, **UV0** is
    the safest option. Let’s try this node, by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and import a tileable water texture from the internet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Image result for tileable water texture](img/B21361_10_27_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.27: Tileable water texture'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the texture and be sure that the **Wrap Mode** property of the texture
    is set to **Repeat**, which will allow us to repeat the texture as we did in the
    terrain because the idea is to use this shader to cover large water areas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing text, font, screenshot, white  Description automatically
    generated](img/B21361_10_28_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.28: Texture Repeat mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Water Shader Graph**, right-click in an empty area of the Shader Graph
    and select **Create Node**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing text, font, screenshot, graphics  Description automatically
    generated](img/B21361_10_29_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.29: Shader Graph Create Node option'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Search** box, write `Sample texture` and all of the sampler nodes
    will show up. Double-click **SampleTexture2D**. If for some reason you can’t double-click
    the option, right-click on it first and then try again. There is a known bug in
    this tool and this is the workaround:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_10_30_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.30: Sample texture node search'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click in the circle to the left of the **Texture** input pin of the **Sample
    Texture 2D** node. It will allow us to pick a texture to sample—just select the
    **water** one. You can see that the texture can be previewed in the bottom part
    of the node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_10_31_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.31: Sample texture node with a texture in its input pin'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag the **RGBA** output pin from the **Sample Texture 2D** node to the **Base
    Color** input pin of the Master Node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_32_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.32: Connecting the results of texture sampling with the Base Color
    pin of the Master Node'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Save Asset** button in the top-left part of the Shader Graph editor
    and see the changes in the **Scene** view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_10_33_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.33: Results of applying a texture in our Shader Graph'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the texture is properly applied to the model, but if you take
    into account that the default plane has a size of 10x10 meters, the ripples of
    the water seem too big. So, let’s tile the texture!
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we need to change the UVs of the model, making them bigger. You
    may imagine that bigger UVs mean the texture should also get bigger, but take
    into account that we are not making the object bigger; we are just modifying the
    UV.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same object area, we will display more of the texture area, meaning
    that in the bigger texture sample area (achieved by bigger UVs), repetitions of
    the texture may appear. To do so, follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click in any empty space and click **New Node** to search for the **UV**
    node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_34_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.34: Searching for the UV node'
  prefs: []
  type: TYPE_NORMAL
- en: Using the same method, create a **Multiply** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Out** pin of the **UV** node to the **A** pin of the **Multiply**
    node to connect them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **B** pin input value of **Multiply** to `4`,`4`,`4`,`4`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing screenshot  Description automatically generated](img/B21361_10_35_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.35: Multiplying the UVs by 4'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag the **Out** pin of the **Multiply** node to **UV** of the **Sample Texture
    2D** node to connect them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_36_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.36: Using the multiplied UVs to sample the texture'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you save the graph and go back to the **Scene** view, you can see that now
    the ripples are smaller, because we have tiled the UVs of our model. You can also
    see that in the preview of the **Sampler Texture 2D** node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing screenshot, aqua, turquoise, design  Description automatically
    generated](img/B21361_10_37_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.37: Results of the model’s UV multiplication'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting effect we can do now is to apply an offset to the texture
    to move it. The idea is that even if the plane is not actually moving, we will
    simulate the flow of the water through it, moving just the texture. Remember,
    the responsibility of determining the part of the texture to apply to each part
    of the model belongs to the UV, so if we add values to the UV coordinates, we
    will be moving them, generating a texture sliding effect. To do so, let’s do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an **Add** node to the right of the **UV** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the **Out** pin of **UV** to the **A** pin of the **Add** node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_10_38_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.38: Adding values to the UVs'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Time** node at the left of the **Add** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the **Time** node to the **B** pin of the **Add** node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_39_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.39: Adding Time to the UVs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the **Out** pin of the **Add** node to the **A** input pin of the **Multiply**
    node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer program  Description automatically generated with
    medium confidence](img/B21361_10_40_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.40: Added and multiplied UVs as an input of the sample texture'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save and see the water moving in the **Scene** view. If you don’t see it moving,
    click the layers icon in the top bar of the scene and check **Always Refresh**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_10_41_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.41: Enabling Always Refresh to preview the effect'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you feel the water is moving too fast, try using the multiplication node
    to make the time a smaller value. I recommend you try it by yourself before looking
    at the next screenshot, which has the answer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_42_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.42: Multiplication of time to move the texture more slowly'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you feel the graph is too big, try to hide some of the node previews by
    clicking on the **up** (**^**) arrow that appears on the preview when you move
    the mouse over it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_43_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.43: Hiding the preview from the graph nodes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you can hide unused pins by selecting the node and clicking the arrow
    at its top right:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing screenshot, text, font, number  Description automatically
    generated](img/B21361_10_44_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.44: Hiding unused pins from the graph nodes'
  prefs: []
  type: TYPE_NORMAL
- en: So, to recap, first we added the time to the UV to move it and then multiplied
    the result of the moved UV to make it bigger to tile the texture. It is worth
    mentioning that there’s a **Tiling and Offset** node that does all of this process
    for us, but I wanted to show you how a simple multiplication to scale the UV and
    an add operation to move it generates a nice effect; you can’t imagine all of
    the possible effects you can achieve with other simple mathematical nodes! Actually,
    let’s explore other usages of mathematical nodes to combine textures in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'When learning DirectX, making shaders was harder given you needed to learn
    a less user-friendly language called HLSL. While for most cases Shader Graph is
    all you need, I don’t regret at all learning such shader languages, as they have
    access to more advanced features that node-based shading languages usually don’t,
    and they give you a deeper understanding of the internals of the GPU. For more
    info about how to create code-based shaders in URP, you can check this: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@15.0/manual/writing-custom-shaders-urp.html](mailto:https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@15.0/manual/writing-custom-shaders-urp.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Combining textures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though we have used nodes, we haven’t created anything that can’t be created
    using regular shaders, but that’s about to change. So far, we can see the water
    moving, but it still looks static, and that’s because the ripples are always the
    same. We have several techniques to generate ripples; the simplest one would be
    to combine two water textures moving in different directions to mix their ripples.
    Actually, we can simply use the same texture, just flipped to save some memory.
    To combine the textures, we will sum them and then divide them by 2, so basically,
    we are calculating the average of the textures! Let’s do that by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select all of the nodes between **Time** and **Sampler 2D** (including them)
    by creating a selection rectangle by clicking in any empty space in the graph,
    holding and dragging the click, and then releasing when all target nodes are covered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_45_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.45: Selecting several nodes'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click and select **Copy**, and then again right-click and select **Paste**,
    or use the classic *Ctrl* + *C*, *Ctrl* + *V* commands (*Command* + *C*, *Command*
    + *V* on Mac).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Move the copied nodes below the original ones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_10_46_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.46: Duplication of nodes'
  prefs: []
  type: TYPE_NORMAL
- en: For the copied nodes, set the **B** pin of the **Multiply** node connected to
    **Sample Texture 2D** to `-4`,`-4`,`-4`,`-4`. You can see that that flipped the
    texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, set the **B** pin of the **Multiply** node connected to the **Time**
    node to `-0.1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_10_47_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.47: Multiplication of values'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an **Add** node at the right of both **Sampler Texture 2D** nodes and
    connect the outputs of those nodes to the **A** and **B** input pins of the **Add**
    node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_48_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.48: Adding two textures'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that the resulting combination is too bright because we have summed
    up the intensity of both textures, so let’s fix that by multiplying the **Out**
    of the **Add** node by `0.5,0.5,0.5,0.5`, which will divide each resulting color
    channel by 2, averaging the color. You can also experiment with what happens when
    you set different values for each channel if you want, but for our purposes, `0.5`
    is the proper value for each channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing screenshot, text, multimedia software, line  Description
    automatically generated](img/B21361_10_49_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.49: Dividing the sum of two textures to get the average'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the **Out** pin of the **Multiply** node to the **Base Color** pin of
    the **Master** Node to apply all of those calculations to the color of the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save the asset and see the results in the **Scene** view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_10_50_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.50: Results of texture blending'
  prefs: []
  type: TYPE_NORMAL
- en: You can keep adding nodes to make the effect more diverse, such as using **Sine**
    nodes (which will execute the trigonometry sine function) to apply non-linear
    movements, but I will let you learn that by experimenting with it by yourself.
    For now, we will stop here. As always, this topic deserves a full book, and the
    intention of this chapter is to give you a small taste of this powerful Unity
    tool. I recommend you look for other Shader Graph examples on the internet to
    learn other usages of the same nodes and, of course, new nodes. One thing to consider
    here is that everything we have done so far is basically applied to the Fragment
    Shader stage of the shader pipeline we discussed earlier. Now, let’s use the Blending
    shader pipeline stage to apply some transparency to the water.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more examples of shader graphs, I recommend checking out the following
    link: [https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/ShaderGraph-Samples.html](mailto:https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/ShaderGraph-Samples.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Applying transparency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before declaring our effect finished, a little addition we can do is to make
    the water a little bit transparent. Remember that the shader pipeline has a blending
    stage, which has the responsibility of blending each pixel of our model into the
    image being rendered in this frame. The idea is to make our Shader Graph modify
    that stage to apply **Alpha Blending**, a blending mode that combines our model
    and the previously rendered models based on the `Alpha` value of our model.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get that effect, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Look for the **Graph Inspector** window floating around. If you don’t see it,
    click the **Graph Inspector** button in the top-right part of the Shader Graph
    editor. Try also expanding the Shader Graph window to display it in case it’s
    hidden behind the right bound of the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Graph Settings** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Surface Type** property to **Transparent**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Blending Mode** property to **Alpha** if it isn’t already at that
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_10_51_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.51: Graph Inspector transparency settings'
  prefs: []
  type: TYPE_NORMAL
- en: Set the **Alpha** input pin of the Master Node to `0.5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_10_52_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.52: Setting Alpha of the Master Node'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the Shader Graph and see the transparency applied in the **Scene** view.
    If you can’t see the effect, just put a cube into the water to make the effect
    more evident:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A black and white cube on a tile floor  Description automatically generated
    with low confidence](img/B21361_10_53_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.53: Shadows from the water being applied to a cube'
  prefs: []
  type: TYPE_NORMAL
- en: You can see the shadows that the water is casting on our cube because Unity
    doesn’t know the object is transparent and hence casts shadows. Click on the water
    plane and look for the **Mesh Renderer** component in the Inspector. If you don’t
    see the shadow, click the lightbulb at the top of the **Scene** view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screen shot of a computer  Description automatically generated with low
    confidence](img/B21361_10_54_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.54: Enabling lights in the Scene view'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Lighting** section, set **Cast Shadows** to **Off**; this will disable
    shadow casting from the plane on the parts of the cube that are underwater:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_10_55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.55: Disabling shadow casting'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding transparency is a simple process but it has its caveats, like the shadow
    problem, and in more complex scenarios, it can have other problems, like increasing
    overdraw, meaning the same pixel needs to be drawn several times (the pixel belonging
    to the transparent object, and one of the objects behind). I would suggest you
    avoid using transparency unless it is necessary. Actually, our water can live
    without transparency, especially when we apply this water to the river basin around
    the base, because we don’t need to see the part under the water; but the idea
    is for you to know all of your options. In the next screenshot, you can see how
    we have put a giant plane with this effect below our base, big enough to cover
    the entire basin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing grass, screenshot  Description automatically generated](img/B21361_10_56_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.56: Using our water in the main scene'
  prefs: []
  type: TYPE_NORMAL
- en: 'I have a friend who always jokes about me, saying that everything can be solved
    with a shader, but jokes aside, it is an extremely useful tool if used cleverly.
    In the past, developers used shaders to do non-graphics-related processing, like
    mathematics simulations, reading the generated pixels as the needed results. That
    led to what today is known as compute shaders, which essentially refers to running
    custom programs on a GPU to do calculations, leveraging the power of the GPU.
    Of course, Unity supports compute shaders; you can learn more about them here:
    [https://docs.unity3d.com/Manual/class-ComputeShader.html](https://docs.unity3d.com/Manual/class-ComputeShader.html)'
  prefs: []
  type: TYPE_NORMAL
- en: From now on, we can do plenty of things with our shader. We can think about
    simulating water foam for the pixels that are higher than a certain height, leveraging
    the vertex animation we added. We could also change the water scrolling direction
    via scripting or using sine nodes. The sky is the limit!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have modified how the object looks through the **Fragment** node
    section, let’s discuss how to use the **Vertex** section to apply a mesh animation
    to our water.
  prefs: []
  type: TYPE_NORMAL
- en: Creating vertex effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have applied water textures to our water, but it’s still a flat plane.
    We can go further than that and make the ripples not only via textures but also
    by animating the mesh. To do so, we will apply the noise texture we used at the
    beginning of the chapter in the shader, but instead of using it as another color
    to add to the **Base Color** of the shader, we will instead use it to offset the
    **Y** position of the vertexes of our plane.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the chaotic nature of the noise texture, the idea is that we will apply
    a vertical offset to different parts of the model, so we can emulate the ripples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing line, symmetry, square, black and white  Description
    automatically generated](img/B21361_10_57_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.57: Default plane mesh subdivided into a grid of 10x10 with no offset'
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish something like this, you can modify the **Vertex** section of
    your shader to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_10_58_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.58: Ripples vertex effect'
  prefs: []
  type: TYPE_NORMAL
- en: In the graph, you can see how we are creating a vector whose *y* axis depends
    on the noise texture we downloaded at the beginning of the chapter. The idea behind
    that is to create a vector pointing upward whose length is proportional to the
    grayscale factor of the texture; the whiter the pixel of the texture, the longer
    the offset. This texture has an irregular yet smooth pattern so it can emulate
    the behavior of the tide.
  prefs: []
  type: TYPE_NORMAL
- en: Please notice that, here, we used **Sample Texture 2D LOD** instead of **Sample
    Texture 2D**; the latter does not work in the **Vertex** section, so keep that
    in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Then we multiply the result by `0.3` to reduce the height of the offset to add,
    and then we add the result to the **Position** node. See that the **Space** property
    of the **Position** node is set to **Object** mode. We need that mode to work
    with the **Vertex** section of the Shader Graph (we discussed *World* and *Local*
    spaces before in *Chapter 2*, *Crafting Scenes and Game Elements*, but you can
    also search `Object vs World Space` on the internet for more info about this).
    Finally, the result is connected to the **Position** node of the **Vertex** section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you save, you will see something like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing aqua, turquoise, pattern, teal  Description automatically
    generated](img/B21361_10_59_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.59: Ripples vertex effect applied'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, in this case, the ripples are static because we didn’t add any time
    offset to the UV as we did before. In the following screenshot, you can see how
    to add that, but before looking at it, I recommend you try to resolve it first
    by yourself as a personal challenge:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_10_60_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.60: Animated ripples vertex effect graph'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we are again taking the original UV and adding the time multiplied
    by any factor so it will slowly move, the same as we did previously with our water
    texture. You can keep playing around with this, changing how this looks with different
    textures, multiplying the offset to increase or reduce the height of the ripples,
    applying interesting math functions like sine, and so much more; but for now,
    let’s finish with this.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how a shader works in the GPU and how to create
    our first simple shader to achieve a nice water effect. Working with shaders is
    a complex and interesting job, and in a team, there is usually one or more people
    in charge of creating all of these effects, in a position called technical artist;
    so, as you can see, this topic can expand to a whole career. Remember, the intention
    of this book is to give you a small taste of all the possible roles you can take
    in the industry, so if you really liked this role, I suggest you start reading
    shader-exclusive books. You have a long but super interesting road in front of
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Enough shaders for now! In the next chapter, we will look at how to improve
    our graphics and create visual effects with particle systems!
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1498477041053909218.png)'
  prefs: []
  type: TYPE_IMG
