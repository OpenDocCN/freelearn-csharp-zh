- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Materials and Effects with URP and Shader Graph
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用URP和Shader Graph创建材料和效果
- en: Welcome to the first chapter of *Part 3*. Here, we will dive deep into the different
    graphics and audio systems of Unity to dramatically improve the look and feel
    of the game. We will start by discussing what a shader is and how to create our
    own to achieve several custom effects that couldn’t be accomplished using the
    default Unity Shaders. We will be creating a simple water animation effect using
    Shader Graph, a visual shader editor included in the Universal Render Pipeline.
    Also known as URP, this is one of the different rendering pipelines available
    in Unity, which provides rendering features oriented toward performance. We will
    be discussing some of its capabilities in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到**第三部分**的第一章。在这里，我们将深入探讨Unity的不同图形和音频系统，以显著提升游戏的外观和感觉。我们将从讨论什么是着色器以及如何创建自己的着色器以实现一些默认Unity着色器无法实现的自定义效果开始。我们将使用Shader
    Graph创建一个简单的水面动画效果，Shader Graph是包含在通用渲染管线（URP）中的可视化着色器编辑器。也称为URP，这是Unity中可用的不同渲染管线之一，它提供面向性能的渲染功能。在本章中，我们将讨论其一些功能。
- en: 'In this chapter, we will examine the following shader concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下着色器概念：
- en: Introducing shaders and URP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍着色器和URP
- en: Creating shaders with Shader Graph
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Shader Graph创建着色器
- en: Introducing shaders and URP
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍着色器和URP
- en: We created **Materials** in *Part 1* of the book, but we never discussed how
    they internally work and why their **Shader** property is important. In this first
    section of this chapter, we will be exploring the concept of a shader as a way
    to program the video card to achieve custom visual effects. We will also be discussing
    how URP works with those shaders, and the default shaders it provides.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书的**第一部分**中创建了**材料**，但我们从未讨论过它们内部是如何工作的，以及为什么它们的**着色器**属性很重要。在本章的第一部分，我们将探讨着色器的概念，作为编程显卡以实现自定义视觉效果的一种方式。我们还将讨论URP如何与这些着色器一起工作，以及它提供的默认着色器。
- en: 'In this section, we will cover the following concepts related to shaders:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖与着色器相关的以下概念：
- en: Shader Pipeline
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色器管线
- en: Render Pipeline and URP
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染管线和URP
- en: URP built-in shaders
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URP内置着色器
- en: Let’s start by discussing how a shader modifies the Shader Pipeline to achieve
    effects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论一下着色器是如何修改着色器管线以实现效果的。
- en: Shader Pipeline
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 着色器管线
- en: Whenever a video card renders a 3D model, it needs different information to
    process, such as a **Mesh**, **Textures**, the transform of the object (position,
    rotation, and scale), and lights that affect that object. With that data, the
    video card must output the pixels of the object into the **back-buffer**, an image
    where the video card will be drawing our objects, but the user won’t see this
    yet. This is done to prevent the user from seeing unfinished results, given we
    can still be drawing at the time the monitor refreshes. That image will be shown
    when Unity finishes rendering all objects (and some effects) to display the finished
    scene, swapping the **Back-buffer** with the **front-buffer**, the image that
    the user actually sees. You can imagine this as having a page with an image that
    is being shown to the user while you draw a new image, and when you finish the
    new drawing, you just swap the pages and start drawing again on the page the user
    is not seeing, repeating this with every frame.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每当显卡渲染一个3D模型时，它需要不同的信息来处理，例如**网格**、**纹理**、对象的变换（位置、旋转和缩放）以及影响该对象的光线。有了这些数据，显卡必须将对象的像素输出到**后缓冲区**，这是一个显卡将在其中绘制我们的对象的图像，但用户还看不到这个图像。这样做是为了防止用户看到未完成的结果，因为我们在显示器刷新时仍然可以绘制。当Unity完成渲染所有对象（和一些效果）并显示最终场景时，这个图像将会显示出来，将**后缓冲区**与用户实际看到的**前缓冲区**交换。你可以想象这就像有一页带有图像的页面，在向用户展示图像的同时，你正在绘制新的图像，当你完成新的绘制后，你只需交换页面，然后在用户看不到的页面上再次开始绘制，每帧重复这个过程。
- en: That’s the usual way to render an object, but what happens between the input
    of the data and the output of the pixels can be handled in a myriad of different
    ways and techniques that depend on how you want your object to look; maybe you
    want it to be realistic or look like a hologram, maybe the object needs a disintegration
    effect or a toon effect—there are endless possibilities. The way to specify how
    our video card will handle the render of the object is through a shader.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是渲染对象的方式，但数据输入和像素输出之间可以以无数种不同的方式和技巧来处理，这取决于你想要你的对象看起来如何；也许你希望它看起来很逼真或像全息图，也许对象需要分解效果或卡通效果——可能性无穷无尽。指定我们的显卡如何处理对象渲染的方式是通过着色器。
- en: 'A **shader** is a program coded in specific video card languages, such as:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**着色器**是一种用特定显卡语言编写的程序，例如：'
- en: '**HLSL**: The DirectX shading language, DirectX being a graphics library.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HLSL**：DirectX 着色语言，DirectX 是一个图形库。'
- en: '**GLSL**: The OpenGL shading language, OpenGL also being a graphics library.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GLSL**：OpenGL 着色语言，OpenGL 也是一个图形库。'
- en: '**CG**: A language that can output either HLSL or GLSL, depending on which
    graphics library we use in our game.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CG**：一种可以根据我们在游戏中使用的图形库输出 HLSL 或 GLSL 的语言。'
- en: '**Shader Graph**: A visual language that will be automatically converted into
    one of the previously mentioned languages according to our needs. This is the
    one we will be using given its simplicity (more on that later).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**着色器图**：一种将根据我们的需求自动转换为之前提到的一种语言的视觉语言。这是我们将会使用的一种，因为它简单（后面会详细说明）。'
- en: Any of those languages can be used to configure different stages of the render
    process necessary to render a given object, sometimes not only configuring them
    but also replacing them with completely custom code to achieve the exact effect
    we want. All of the stages to render an object make up what we call the Shader
    Pipeline, a chain of modifications applied to the input data until it is transformed
    into pixels.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语言中的任何一种都可以用来配置渲染给定对象所需的不同渲染过程阶段，有时不仅配置它们，还可以用完全定制的代码来替换它们，以实现我们想要的确切效果。渲染对象的各个阶段构成了我们所说的着色器管线，这是一系列应用于输入数据的修改，直到将其转换为像素。
- en: 'Each stage of the pipeline is in charge of different modifications and depending
    on the video card shader model, this pipeline can vary a lot. In the next diagram,
    you can find a simplified Render Pipeline, skipping advanced/optional stages that
    are not important right now:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 管线中的每个阶段都负责不同的修改，并且根据显卡的着色器模型，这个管线可能会有很大的变化。在下一个图中，你可以找到一个简化的渲染管线，跳过了现在不重要的高级/可选阶段：
- en: '![](img/B18585_10_01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_01.png)'
- en: 'Figure 10.1: Common Shader Pipeline'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：常见的着色器管线
- en: 'Let’s discuss each of the stages:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论每个阶段：
- en: '**Input Assembler**: Here is where all of the mesh data, such as vertex position,
    UVs, and normals, is assembled to be prepared for the next stage.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入汇编器**：在这里，所有网格数据，如顶点位置、UV 和法线，被组装起来以准备下一阶段。'
- en: '**Vertex Shader**: This stage used to be limited to applying the transformation
    of the object, the position and perspective of the camera, and simple lighting
    calculations. In modern GPUs, you are in charge of doing whatever you want. This
    stage receives each one of the vertexes of the object to render and outputs a
    modified one. You have the chance to modify the geometry of the object here. The
    usual code here is applying the transform of the object, but you can also apply
    several effects such as inflating the object along its normals to apply the old
    toon effect technique or apply distortion adding random offsets to each vertex
    to recreate a hologram. There’s also the opportunity to calculate data for the
    next stages.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点着色器**：这个阶段过去通常限于应用对象的变换、摄像机的位置和视角以及简单的光照计算。在现代 GPU 中，你可以做任何你想做的事情。这个阶段接收渲染对象的所有顶点，并输出一个修改后的顶点。你有机会在这里修改对象的几何形状。这里的常用代码是应用对象的变换，但你也可以应用多种效果，例如沿着法线膨胀对象以应用旧的卡通效果技术，或者添加随机偏移量来扭曲每个顶点以重新创建全息图。还有机会计算下一阶段所需的数据。'
- en: '**Culling**: Most of the models you are going to render have the particularity
    that you will never see the back side of a model face. In a cube, there’s no way
    to look at its inner sides. Given that, rendering both sides of each face of the
    cube makes no sense, and this stage takes care of that. Culling will determine
    whether the face needs to be rendered based on the orientation of the face, saving
    lots of pixel calculation of occluded faces. You can change this to behave differently
    for specific cases; as an example, we can create a glass box that needs to be
    transparent to see all sides of the box.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**剔除**：你将要渲染的大多数模型具有一个特性，那就是你永远不会看到模型面的背面。在一个立方体中，没有办法看到它的内部侧面。鉴于这一点，渲染立方体每个面的两侧是没有意义的，这一阶段就负责处理这个问题。剔除将根据面的方向确定是否需要渲染该面，从而节省大量遮挡面的像素计算。你可以更改这一设置，以便在特定情况下有不同的行为；例如，我们可以创建一个需要透明以看到盒子所有侧面的玻璃盒子。'
- en: '**Rasterizer**: Now that we have the modified and visible geometry of our model
    calculated, it’s time to convert it into pixels. The rasterizer creates all pixels
    for the triangles of our mesh. Lots of things happen here but again, we have very
    little control of that; the usual way to rasterize is just to create all pixels
    inside the edges of the mesh triangles. We have other modes that just render the
    pixels on the edges to see a wireframe effect, but this is usually used for debugging
    purposes:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光栅化器**：现在我们已经计算出了模型修改后的可见几何形状，是时候将其转换为像素了。光栅化器为我们的网格中的三角形创建所有像素。这里发生了很多事情，但我们对此的控制非常有限；通常的光栅化方式只是创建网格三角形内部的像素。我们还有其他模式，仅渲染边上的像素以看到线框效果，但这通常用于调试目的：'
- en: '![Image result for rasterizer](img/B18585_10_02.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Image result for rasterizer](img/B18585_10_02.png)'
- en: 'Figure 10.2: Example of figures being rasterized'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：图像光栅化的示例
- en: '**Fragment Shader**: This is one of the most customizable stages of all. Its
    purpose is simple: just determine the color of each one of the fragments (pixels)
    that the rasterizer has generated. Here, lots of things can happen, from simply
    outputting a plain color or sampling a texture to applying complex lighting calculations
    such as normal mapping and PBR. Also, you can use this stage to create special
    effects such as water animations, holograms, distortions, disintegrations, and
    any special effects that require you to modify what the pixels look like. We will
    explore how we can use this stage in the next sections of this chapter.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**片段着色器**：这是所有阶段中最可定制的之一。它的目的是简单的：只是确定光栅化器生成的每个片段（像素）的颜色。在这里，可以发生很多事情，从简单地输出纯色或采样纹理到应用复杂的照明计算，如法线贴图和PBR。此外，你可以使用这个阶段创建特殊效果，如水动画、全息图、扭曲、分解以及任何需要修改像素外观的特殊效果。我们将在本章的下一节中探讨如何使用这个阶段。'
- en: '**Depth Testing**: Before showing a pixel on the screen, we need to check whether
    it can be seen. This stage checks whether the pixel’s depth is behind or in front
    of the previous pixel rendered in the same position, guaranteeing that regardless
    of the rendering order of the objects, the nearest pixels to the camera are always
    being drawn on top of others. Again, usually, this stage is left in its default
    state, prioritizing pixels that are nearer to the camera, but some effects require
    different behavior. Also, nowadays we have **Early-Z testing**, which does this
    same test but before the Fragment shader, but let’s keep things simple for now.
    As an example, in the next screenshot, you can see an effect that allows you to
    see objects that are behind other objects, like the one used in *Age of Empires*
    when a unit is behind a building:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度测试**：在屏幕上显示像素之前，我们需要检查它是否可见。这一阶段会检查像素的深度是否在之前在同一位置渲染的像素之后或之前，确保无论对象的渲染顺序如何，离相机最近的像素总是被绘制在其他像素之上。再次强调，通常这一阶段会保留其默认状态，优先考虑离相机更近的像素，但某些效果需要不同的行为。现在我们还有**早期Z测试**，它在这个阶段之前进行相同的测试，但为了简单起见，我们先不深入讨论。例如，在下一张截图，你可以看到一个效果，它允许你看到位于其他物体后面的物体，就像在*帝国时代*中，一个单位在建筑物后面时的情况：'
- en: '![Image result for occluded effect shader](img/B18585_10_03.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Image result for occluded effect shader](img/B18585_10_03.png)'
- en: 'Figure 10.3: Rendering the occluded parts of the character'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：渲染角色的遮挡部分
- en: '**Blending**: Once the color of the pixel is determined and we are sure the
    pixel is not occluded by a previous pixel, the final step is to put it in the
    back-buffer (the frame or image you are drawing). Usually, we just override whatever
    pixel was in that position (because our pixel is nearer to the camera), but if
    you think about transparent objects, we need to combine our pixel with the previous
    one to make the transparent effect. Transparencies have other things to take into
    account aside from the blending, but the main idea is that blending controls exactly
    how the pixel will be combined with the previously rendered pixel in the back-buffer.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合**：一旦确定了像素的颜色并且我们确定该像素没有被之前的像素遮挡，最后的步骤就是将其放入后缓冲区（你正在绘制的帧或图像）。通常，我们只是覆盖掉那个位置上原本的像素（因为我们的像素更靠近相机），但是如果你考虑透明物体，我们需要将我们的像素与之前的像素结合以产生透明效果。除了混合之外，透明度还有其他需要考虑的因素，但主要思想是混合精确控制像素如何与后缓冲区中先前渲染的像素结合。'
- en: Shader Pipelines is a subject that would require an entire book, but for the
    scope of this book, the previous description will give you a good idea of what
    a shader does, and the possible effects that it can achieve. Now that we have
    discussed how a shader renders a single object, it is worth discussing how Unity
    renders all of the objects using Render Pipelines.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器管线是一个需要整本书来讨论的主题，但就本书的范围而言，前面的描述将给你一个很好的关于着色器做什么以及它能实现的可能效果的概念。现在我们已经讨论了着色器如何渲染单个对象，值得讨论的是Unity如何使用渲染管线渲染所有对象。
- en: Render Pipeline and URP
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染管线和URP
- en: We have covered how the video card renders an object, but Unity is in charge
    of asking the video card to execute its Shader Pipeline per object. To do so,
    Unity needs to do lots of preparations and calculations to determine exactly how
    and when each shader needs to be executed. The responsibility of doing this is
    with what Unity calls the Render Pipeline.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了视频卡如何渲染一个对象，但Unity负责请求视频卡为每个对象执行其着色器管线。为此，Unity需要进行大量的准备和计算来确定每个着色器确切地何时以及如何执行。执行这项任务的正是Unity所说的渲染管线。
- en: A Render Pipeline is a way to draw the objects of the scene. At first, it sounds
    like there should be just one simple way of doing this, for example, iterating
    over all objects in the scene and executing the Shader Pipeline with the shader
    specified in each object’s Material, but it can be more complex than that.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染管线是一种绘制场景中对象的方式。一开始，这听起来应该只有一个简单的方法来做这件事，例如，遍历场景中的所有对象并使用每个对象材质中指定的着色器执行着色器管线，但它可能比这更复杂。
- en: Usually, the main difference between one Render Pipeline and another is the
    way in which lighting and some advanced effects are calculated, but they can differ
    in other ways.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个渲染管线与另一个渲染管线之间的主要区别在于光照和一些高级效果的计算方式，但它们在其他方面也可能有所不同。
- en: In previous Unity versions, there was just one single Render Pipeline, which
    is now called the **Built-in Renderer Pipeline** (also known as **BIRP**). It
    was a pipeline that had all of the possible features you would need for all kinds
    of projects, from mobile 2D graphics and simple 3D to cutting-edge 3D like the
    ones you can find in consoles or high-end PCs. This sounds ideal, but actually,
    it isn’t. Having one single giant renderer that needs to be highly customizable
    to adapt to all possible scenarios generates lots of overhead and limitations
    that cause more headaches than creating a custom Render Pipeline. Luckily, the
    last versions of Unity introduced **Scriptable Render Pipeline** (**SRP**), a
    way to create Render Pipeline adapted for your project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的Unity版本中，只有一个单一的渲染管线，现在被称为**内置渲染管线**（也称为**BIRP**）。这是一个包含了你可能需要用于所有类型项目的所有可能功能的管线，从移动2D图形和简单的3D到像在游戏机或高端PC上找到的尖端3D。这听起来很理想，但实际上并非如此。拥有一个需要高度可定制以适应所有可能场景的单一大渲染器会产生大量的开销和限制，这比创建自定义渲染管线要头疼得多。幸运的是，Unity的最新版本引入了**可脚本化渲染管线**（**SRP**），这是一种为你的项目创建适配的渲染管线的方式。
- en: 'Luckily, Unity doesn’t want you to create your own Render Pipeline for each
    project (which is a complex task), so it has created two custom pipelines for
    you that are ready to use: **URP** (formerly called LWRP), which stands for **Universal
    Render Pipeline**, and **HDRP**, which stands for **High Definition Render Pipeline**.
    The idea is that you must choose one or the other based on your project’s requirements
    (unless you really need to create your own).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Unity不希望你为每个项目创建自己的渲染管线（这是一个复杂的工作），因此它为你创建了两个可用的自定义管线：**URP**（以前称为LWRP），代表**通用渲染管线**，以及**HDRP**，代表**高清渲染管线**。想法是，你必须根据项目需求选择其中一个（除非你真的需要创建自己的）。
- en: 'URP, the one we selected when creating the project for our game, is a Render
    Pipeline suitable for most games that don’t require lots of advanced graphics
    features, such as mobile games or simple PC games, while HDRP is packed with lots
    of advanced rendering features for high-quality games. The latter requires high-end
    hardware to run, while URP runs in almost every relevant target device. It is
    worth mentioning that you can swap between Built-in Renderer, HDRP, and URP whenever
    you want, including after creating the project (but this is not recommended):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: URP，我们在创建游戏项目时选择的一个渲染管线，适用于大多数不需要大量高级图形特性的游戏，如移动游戏或简单的PC游戏，而HDRP则包含许多用于高质量游戏的高级渲染特性。后者需要高端硬件才能运行，而URP几乎可以在所有相关目标设备上运行。值得一提的是，你可以随时在内置渲染器、HDRP和URP之间切换，包括在创建项目之后（但不推荐这样做）：
- en: '![](img/B18585_10_04.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_04.png)'
- en: 'Figure 10.4: Project wizard showing HDRP and URP templates'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：项目向导显示HDRP和URP模板
- en: We can discuss how each one is implemented and the differences between each,
    but again, this could fill entire chapters; right now, the idea of this section
    is for you to know why we picked URP when we created our project because it has
    some restrictions we will encounter throughout this book that we will need to
    take into account, so it is good to know why we accepted those limitations (to
    run our game on every relevant hardware).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以讨论每个着色器的实现方式和它们之间的差异，但同样，这可能会填满整个章节；目前，本节的想法是让你知道为什么我们选择URP来创建我们的项目，因为它有一些我们在本书中会遇到并需要考虑的限制，所以了解我们接受这些限制的原因（为了在所有相关硬件上运行我们的游戏）是很好的。
- en: 'Also, we need to know that we have chosen URP because it has support for Shader
    Graph, the Unity tool that we will be using in this chapter to create custom effects.
    Previous Unity built-in pipelines didn’t provide us with such a tool (aside from
    third-party plugins). Finally, another reason to introduce the concept of URP
    is that it comes with lots of built-in shaders that we will need to know about
    before creating our own to prevent reinventing the wheel. This will allow us to
    get used to those shaders, because if you came from previous versions of Unity,
    the shaders you already know won’t work here; actually, this is exactly what we
    are going to discuss in the next section of this chapter: the difference between
    the different URP built-in shaders.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要知道我们选择URP是因为它支持Shader Graph，这是我们将在本章中使用Unity工具来创建自定义效果的工具。之前的Unity内置管线没有提供这样的工具（除了第三方插件）。最后，引入URP概念的另一个原因是它附带了许多内置着色器，在创建我们自己的着色器之前，我们需要了解它们，以避免重复造轮子。这将使我们熟悉这些着色器，因为如果你来自Unity的早期版本，你已知的着色器在这里将不起作用；实际上，这正是我们将在本章下一节中讨论的内容：不同URP内置着色器之间的区别。
- en: URP built-in shaders
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URP内置着色器
- en: 'Now that we know the difference between URP and other pipelines, let’s discuss
    which shaders come integrated into URP. Let’s briefly describe the three most
    important shaders in this pipeline:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了URP与其他管线之间的区别，让我们讨论哪些着色器集成到了URP中。让我们简要描述这个管线中三个最重要的着色器：
- en: '**Lit**: This is the replacement of the old Standard Shader. This shader is
    useful for creating all kinds of realistic physics materials such as wood, rubber,
    metal, skin, and combinations of them (such as a character with skin and metal
    armor). It supports features like Normal Mapping, Occlusion, different lighting
    workflows like Metallic and Specular, and transparencies.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lit**: 这是旧标准着色器的替代品。这个着色器适用于创建各种逼真的物理材料，如木材、橡胶、金属、皮肤以及它们的组合（如皮肤和金属盔甲的角色）。它支持诸如法线贴图、遮挡、金属和镜面等不同的光照工作流程，以及透明度。'
- en: '**Simple Lit**: This is the replacement of the old Mobile/Diffuse Shader. As
    the name suggests, this shader is a simpler version of Lit, meaning that its lighting
    calculations are simpler approximations of how light works, getting fewer features
    than its counterpart. Basically, when you have simple graphics without realistic
    lighting effects, this is the best choice.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Simple Lit**：这是旧版Mobile/Diffuse Shader的替代品。正如其名所示，这个着色器是Lit的一个简化版本，意味着它的光照计算是对光照工作原理的简单近似，比其对应版本功能更少。基本上，当你有简单的图形而没有真实的光照效果时，这是最佳选择。'
- en: '**Unlit**: This is the replacement of the old Unlit/Texture Shader. Sometimes,
    you need objects with no lighting whatsoever, and in that case, this is the shader
    for you. No lighting doesn’t mean an absence of light or complete darkness; it
    actually means that the object has no shadows at all, and it’s fully visible without
    any shade. Some simplistic graphics can work with this, relying on shadowing being
    baked in the texture, meaning that the texture comes with the shadow.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unlit**：这是旧版Unlit/Texture Shader的替代品。有时，你需要完全没有光照的对象，在这种情况下，这个着色器就是为你准备的。没有光照并不意味着没有光或完全黑暗；实际上，这意味着对象完全没有阴影，并且在没有阴影的情况下完全可见。一些简单的图形可以使用这个着色器，依靠纹理中烘焙的阴影，这意味着纹理自带阴影。'
- en: 'This is extremely performant, especially for low-end devices such as mobile
    phones. Also, you have other cases such as light tubes or screens, objects that
    can’t receive shadows because they emit light, so they will be seen at their full
    color even in complete darkness. In the following screenshot, you can see a 3D
    model using an Unlit Shader. It looks like it’s being lit, but it’s just the texture
    of the model that applied lighter and darker colors in different parts of the
    object:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这在性能上非常出色，特别是对于低端设备，如手机。还有其他情况，比如光管或屏幕，这些不能接收阴影的对象因为它们会发光，所以即使在完全黑暗中，它们也会以全色显示。在下面的屏幕截图中，你可以看到一个使用Unlit
    Shader的3D模型。它看起来像是有光照，但实际上只是模型纹理在不同部分应用了浅色和深色，使其看起来像是有光照：
- en: '![](img/B18585_10_05.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_05.png)'
- en: 'Figure 10.5: Pod using an Unlit effect to simulate cheap lighting'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：使用未光照效果模拟廉价光照的Pod
- en: 'Let’s do an interesting disintegration effect with the Simple Lit Shader to
    demonstrate its capabilities. You must do the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Simple Lit Shader做一个有趣的分解效果来展示其功能。你必须做以下几步：
- en: 'Download and import a **Cloud Noise** texture from any search engine:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从任何搜索引擎下载并导入**云噪声**纹理：
- en: '![Image result for cloud noise texture](img/B18585_10_06.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Image result for cloud noise texture](img/B18585_10_06.png)'
- en: 'Figure 10.6: Noise texture'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：噪声纹理
- en: Select the recently imported texture in the **Project** panel.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中选择最近导入的纹理。
- en: 'In the Inspector, set the **Alpha Source** property to **From Gray Scale**.
    This will make the alpha channel of the texture be calculated based on the grayscale
    of the image:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，将**Alpha Source**属性设置为**从灰度**。这将使纹理的alpha通道根据图像的灰度进行计算：
- en: '![](img/B18585_10_07.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_07.png)'
- en: 'Figure 10.7: Generate Alpha From Gray Scale texture setting'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：从灰度生成Alpha纹理设置
- en: The Alpha channel of a color is often associated with transparency, but you
    will notice that our object won’t be transparent. The Alpha channel is extra color
    data that can be used for several purposes when creating effects. In this case,
    we will use it to determine which pixels are being disintegrated first.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色的Alpha通道通常与透明度相关联，但你会注意到我们的对象不会是透明的。Alpha通道是额外的颜色数据，在创建效果时可以用于多种目的。在这种情况下，我们将使用它来确定哪些像素首先被分解。
- en: 'Click the **+** icon in the Project view and select **Material**:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目视图中点击**+**图标，并选择**材质**：
- en: '![](img/B18585_10_08.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_08.png)'
- en: 'Figure 10.8: Material creation button'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：材质创建按钮
- en: 'Create a cube by going to **GameObject | 3D Object | Cube**:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问**GameObject | 3D Object | Cube**创建一个立方体：
- en: '![](img/B18585_10_09.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_09.png)'
- en: 'Figure 10.9: Cube primitive creation'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：立方体原形创建
- en: Drag the Material from the Project window to the cube in the Scene window.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将材质从项目窗口拖动到场景窗口中的立方体上。
- en: 'Click in the drop-down menu at the right of the **Shader** property in the
    Inspector and look for the **Universal Render Pipeline | Simple Lit** option.
    We could also work with the default shader (**Lit**), but **Simple Lit** is going
    to be easier on performance and we won’t use the advanced features of Lit:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中**Shader**属性右侧的下拉菜单中点击，查找**Universal Render Pipeline | Simple Lit**选项。我们也可以使用默认的着色器（**Lit**），但**Simple
    Lit**在性能上会更简单，我们也不会使用Lit的高级功能：
- en: '![](img/B18585_10_10.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_10.png)'
- en: 'Figure 10.10: Simple Lit Shader selection'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10：简单光照着色器选择
- en: Select the **Material** and drag the downloaded cloud Texture to the rectangle
    at the left of **Base Map**.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**材质**并将下载的云纹理拖到**基础贴图**左侧的矩形中。
- en: 'Check the **Alpha Clipping** checkbox and set the **Threshold** slider to `0.5`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**Alpha裁剪**复选框并将**阈值**滑块设置为`0.5`：
- en: '![](img/B18585_10_11.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_11.png)'
- en: 'Figure 10.11: Alpha Clipping Threshold Material slider'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11：Alpha裁剪阈值材质滑块
- en: 'As you move the **Threshold** slider, the object will start to disintegrate.
    **Alpha Clipping** discards pixels that have less Alpha intensity than the **Threshold**
    value:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你移动**阈值**滑块时，物体将开始分解。**Alpha裁剪**会丢弃Alpha强度低于**阈值**值的像素：
- en: '![](img/B18585_10_12.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_12.png)'
- en: 'Figure 10.12: Disintegration effect with Alpha Clipping'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12：带有Alpha裁剪的分解效果
- en: 'Finally, set **Render Face** to **Both** to see both sides of the cube’s faces:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将**渲染面**设置为**两个面**以查看立方体面的两侧：
- en: '![](img/B18585_10_13.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_13.png)'
- en: 'Figure 10.13: Double-sided render face'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13：双面渲染面
- en: 'Take into account that the artist that creates the texture can configure the
    Alpha channel manually instead of calculating it from the grayscale, just to control
    exactly how the disintegration effect must look regardless of the texture’s color
    distribution:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，创建纹理的艺术家可以手动配置Alpha通道，而不是从灰度值计算它，以便精确控制分解效果的外观，无论纹理的颜色分布如何：
- en: '![](img/B18585_10_14.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_14.png)'
- en: 'Figure 10.14: Double-sided Alpha Clipping'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14：双面Alpha裁剪
- en: The idea of this section is not to give a comprehensive guide of all of the
    properties of all URP shaders, but to give you an idea of what a shader can do
    when properly configured and when to use each one of the integrated shaders. Sometimes,
    you can achieve the effect you need just by using existing shaders, probably in
    99% of cases in simple games, so try to stick to them as much as you can. But
    if you really need to create a custom shader to create a very specific effect,
    the next section will teach you how to use the URP tool called Shader Graph.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的不是提供所有URP着色器属性的全面指南，而是给你一个概念，即当着色器配置得当以及何时使用每个集成着色器时，着色器可以做什么。有时，你只需使用现有的着色器就能达到所需的效果，在简单游戏中，这可能是99%的情况，所以尽可能坚持使用它们。但如果你真的需要创建一个自定义着色器来创建一个非常特定的效果，下一节将教你如何使用URP工具Shader
    Graph。
- en: Creating shaders with Shader Graph
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Shader Graph创建着色器
- en: Now that we know how shaders work and the existing shaders in URP, we have a
    basic notion of when it is necessary to create a custom shader and when it is
    not necessary. In case you really need to create one, this section will cover
    the basics of effects creation with Shader Graph, a tool to create effects using
    a visual node-based editor. This is an easy tool to use when you are not used
    to coding.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了着色器的工作原理和URP中现有的着色器，我们对何时需要创建自定义着色器以及何时不需要有了基本的概念。如果你真的需要创建一个，本节将涵盖使用Shader
    Graph创建效果的基础知识，Shader Graph是一个使用可视化节点编辑器创建效果的工具。当你不习惯编码时，这是一个易于使用的工具。
- en: 'In this section, we will discuss the following concepts of the Shader Graph:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论Shader Graph的以下概念：
- en: Creating our first Shader Graph
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个Shader Graph
- en: Using textures
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纹理
- en: Combining textures
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并纹理
- en: Applying transparency
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用透明度
- en: Creating Vertex effects
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建顶点效果
- en: Let’s start by seeing how we can create and use a Shader Graph.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们如何创建和使用Shader Graph。
- en: Creating our first Shader Graph
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的第一个Shader Graph
- en: 'Shader Graph is a tool that allows us to create custom effects using a node-based
    system. An effect in the Shader Graph can look like in the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Shader Graph是一个允许我们使用基于节点的系统创建自定义效果的工具。Shader Graph中的效果可以像以下截图所示：
- en: '![](img/B18585_10_15.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_15.png)'
- en: 'Figure 10.15: Shader Graph with nodes to create a custom effect'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15：带有创建自定义效果的节点的Shader Graph
- en: We will discuss later what those nodes do and we will be creating an example
    effect step by step, but in the screenshot, you can see how the author created
    and connected several nodes—the interconnected boxes—with each one executing a
    specific process to achieve the effect. The idea of creating effects with Shader
    Graph is to learn which specific nodes you need and how to connect them properly.
    This is similar to the way we code the gameplay of the game, but this Shader Graph
    is adapted and simplified just for effect purposes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论这些节点的作用，并将逐步创建一个示例效果，但在截图上，你可以看到作者如何创建和连接几个节点——相互连接的盒子——每个节点执行特定的过程以实现效果。使用
    Shader 图创建效果的想法是学习你需要哪些特定的节点以及如何正确地连接它们。这与我们编写游戏玩法代码的方式类似，但这个 Shader 图是为了效果目的而调整和简化的。
- en: 'To create and edit our first Shader Graph, do the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和编辑我们的第一个 Shader 图，请执行以下操作：
- en: 'In the Project window, click the **+** icon and find the **Shader Graph | URP
    | Lit Shader Graph** option. This will create a Shader Graph using the PBR mode,
    meaning that this shader will support lighting effects (unlike Unlit Graphs):'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目窗口中，点击 **+** 图标，找到 **Shader Graph | URP | Lit Shader Graph** 选项。这将使用 PBR
    模式创建一个 Shader 图，这意味着这个着色器将支持光照效果（与未光照图不同）：
- en: '![](img/B18585_10_16.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_16.png)'
- en: 'Figure 10.16: PBR Shader Graph creation'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16：PBR Shader 图创建
- en: 'Name it `Water`. If you want the opportunity to rename the asset, remember
    that you can select the asset, right-click, and select **Rename**:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名为 `Water`。如果你想有机会重命名资产，请记住你可以选择资产，右键单击并选择 **重命名**：
- en: '![](img/B18585_10_17.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_17.png)'
- en: 'Figure 10.17: Shader Graph Asset'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.17：Shader 图资产
- en: 'Create a new Material called `WaterMaterial` and set **Shader** to **Shader
    Graphs/Water**. If for some reason Unity doesn’t allow you to do that, try right-clicking
    on the **Water Graph** and clicking **Reimport**. As you can see, the created
    Shader Graph now appears as a shader in the Material:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的材质，命名为 `WaterMaterial`，并将 **Shader** 设置为 **Shader Graphs/Water**。如果由于某种原因
    Unity 不允许你这样做，尝试在 **Water Graph** 上右键单击并点击 **Reimport**。正如你所见，创建的 Shader 图现在在材质中显示为着色器：
- en: '![](img/B18585_10_18.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_18.png)'
- en: 'Figure 10.18: Setting a Shader Graph as a Material Shader'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.18：设置 Shader 图为材质着色器
- en: Create a plane with the **GameObject | 3D Object | Plane** option.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **GameObject | 3D Object | Plane** 选项创建一个平面。
- en: Drag the **Material** to the **Plane** to apply it.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Material** 拖到 **Plane** 上以应用它。
- en: Now, you have created your first custom shader and applied it to a Material.
    So far, it doesn’t look interesting at all—it’s just a gray effect—but now it’s
    time to edit the graph to unlock its full potential. As the name of the graph
    suggests, we will be creating a water effect in this chapter to illustrate several
    nodes of the Shader Graph toolset and how to connect them, so let’s start by discussing
    the Master node.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经创建了你第一个自定义着色器并将其应用于材质。到目前为止，它看起来一点也不有趣——它只是一个灰色效果——但现在是你编辑图以解锁其全部潜力的时候了。正如图名所暗示的，在本章中我们将创建一个水效果来展示
    Shader 图工具集的几个节点以及如何连接它们，所以让我们先从讨论主节点开始。
- en: 'When you open the graph by double-clicking the shader asset, you will see the
    following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过双击着色器资产打开图时，你会看到以下内容：
- en: '![](img/B18585_10_19.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_19.png)'
- en: 'Figure 10.19: Master node with all of the properties needed to calculate object
    appearance'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.19：包含计算对象外观所需所有属性的 Master 节点
- en: All nodes will have input pins, the data needed to work, and output pins, the
    results of its process. As an example, in a sum operation, we will have two input
    numbers and an output number, the result of the sum. In this case, you can see
    that the Master node only contains inputs, and that’s because all data that enters
    the Master node will be used by Unity to calculate the rendering and lighting
    of the object, things such as the desired object color or texture (**Base Color**
    input pin), how smooth it is (**Smoothness** input pin), or how much metal it
    contains (**Metallic** input pin), properties that will affect how the lighting
    will be applied to the object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点都将有输入引脚，工作所需的数据，以及输出引脚，其处理的结果。以加法运算为例，我们将有两个输入数字和一个输出数字，即加法的结果。在这种情况下，你可以看到主节点只包含输入，这是因为所有进入主节点的数据都将被
    Unity 用于计算对象的渲染和光照，例如所需的对象颜色或纹理（**基础颜色**输入引脚）、平滑度（**平滑度**输入引脚）或金属含量（**金属**输入引脚），这些属性将影响光照如何应用于对象。
- en: 'You can see that the Master node is split between a **Vertex** section and
    a **Fragment** section. The first is capable of changing the mesh of the object
    we are modifying to deform it, animate it, etc., while the latter will change
    how it will look, which textures to use, how it will be illuminated, etc. Let’s
    start exploring how we can change that data in the **Fragment** section by doing
    the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到主节点被分为**顶点**部分和**片段**部分。前者能够改变我们正在修改的对象的网格，以变形它、动画化它等，而后者将改变它的外观，使用的纹理，光照方式等。让我们通过以下步骤开始探索如何在**片段**部分更改这些数据：
- en: Double-click the **Shader Graph** asset in Project View to open its editor.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击项目视图中的**Shader图**资产以打开其编辑器。
- en: 'Click in the gray rectangle at the left of the **Base Color** input pin:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**基础颜色**输入插针左侧的灰色矩形中点击：
- en: '![](img/B18585_10_20.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_20.png)'
- en: 'Figure 10.20: Base Color node input pin'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.20：基础颜色节点输入插针
- en: 'In the color picker, select a light blue color, like water. Select the bluish
    part of the circle and then a shade of that color in the middle rectangle:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在颜色选择器中，选择一种浅蓝色，如水。选择圆圈的蓝色部分，然后在中间矩形中选择该颜色的一个色调：
- en: '![](img/B18585_10_21.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_21.png)'
- en: 'Figure 10.21: Color picker'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.21：颜色选择器
- en: 'Set **Smoothness** to `0.9`, which will make the object almost completely smooth
    (90% of the total smoothness possible). This will make our water reflect the sky
    almost completely:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**平滑度**设置为`0.9`，这将使对象几乎完全光滑（90%的总平滑度）。这将使我们的水几乎完全反射天空：
- en: '![](img/B18585_10_22.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_22.png)'
- en: 'Figure 10.22: Smoothness PBR Master node input pin'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.22：平滑度PBR主节点输入插针
- en: 'Click the **Save Asset** button at the top left of the window:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗口左上角的**保存资产**按钮：
- en: '![](img/B18585_10_23.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_23.png)'
- en: 'Figure 10.23: Shader Graph saving options'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.23：Shader图保存选项
- en: 'Go back to the Scene View and check the plane is light blue with the sun reflected
    on it:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回场景视图并检查平面是否是浅蓝色，并且太阳反射在其上：
- en: '![](img/B18585_10_24.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_24.png)'
- en: 'Figure 10.24: Initial Shader Graph results'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.24：初始Shader图结果
- en: As you can see, the behavior of the shader varies according to the properties
    you set in the **Master** node, but so far, doing this is no different than creating
    an Unlit Shader and setting up its properties; the real power of Shader Graph
    is when you use nodes that do specific calculations as inputs of the Master node.
    We will start looking at the texturing nodes, which allow us to apply Textures
    to our model.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，着色器的行为根据您在**主**节点中设置的属性而变化，但到目前为止，这样做与创建一个未光照着色器并设置其属性没有区别；Shader图真正的力量在于您使用节点作为主节点的输入进行特定计算时。我们将开始查看纹理节点，这些节点允许我们将纹理应用于我们的模型。
- en: Using Textures
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纹理
- en: 'The idea of using Textures is to have an image applied to the model in a way
    that we can paint different parts of the models with different colors. Remember
    that the model has a UV map, which allows Unity to know which part of the Texture
    will be applied to which part of the model:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纹理的想法是将图像应用于模型，以便我们可以用不同的颜色绘制模型的各个部分。请记住，模型有一个UV贴图，这使得Unity能够知道纹理的哪一部分将被应用于模型的哪一部分：
- en: '![](img/B18585_10_25.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_25.png)'
- en: 'Figure 10.25: On the left, a face Texture; on the right, the same texture applied
    to a face mesh'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.25：左侧是一个面纹理；右侧是将相同的纹理应用于面网格
- en: 'We have several nodes to do this task, one of them being Sample Texture 2D,
    a node that has two main inputs. First, it asks us for the texture to sample or
    apply to the model, and then for the UV. You can see it in the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几个节点来完成这个任务，其中之一是Sample Texture 2D，这是一个有两个主要输入的节点。首先，它要求我们提供要采样或应用于模型的纹理，然后是UV。您可以在以下屏幕截图中看到它：
- en: '![](img/B18585_10_26.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_26.png)'
- en: 'Figure 10.26: Sample Texture 2D node'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.26：样本纹理2D节点
- en: 'As you can see, the default value of the **Texture** input node is **None**,
    so there’s no texture by default, and we need to manually specify that. For **UV**,
    the default value is `UV0`, meaning that, by default, the node will use the main
    UV channel of the model, and yes, a model can have several UVs set. For now, we
    will stick with the main one. If you are not sure what that means, UV0 is the
    safest option. Let’s try this node, doing the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，**纹理**输入节点的默认值是**None**，因此默认情况下没有纹理，我们需要手动指定。对于**UV**，默认值是`UV0`，这意味着默认情况下，节点将使用模型的主要UV通道，而且是的，一个模型可以设置多个UV。现在，我们将坚持使用主要的一个。如果您不确定这意味着什么，UV0是最佳选择。让我们尝试这个节点，按照以下步骤操作：
- en: 'Download and import a **tileable water texture** from the internet:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从互联网下载并导入一个**可重复纹理的水纹理**：
- en: '![Image result for tileable water texture](img/B18585_10_27.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![Image result for tileable water texture](img/B18585_10_27.png)'
- en: 'Figure 10.27: Water tileable Texture'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.27：可平铺的水纹理
- en: 'Select the Texture and be sure that the **Wrap Mode** property of the Texture
    is set to **Repeat**, which will allow us to repeat the Texture as we did in the
    terrain because the idea is to use this shader to cover large water areas:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择纹理，并确保纹理的**Wrap Mode**属性设置为**Repeat**，这将允许我们像在地形中做的那样重复纹理，因为我们想使用这个着色器覆盖大面积的水域：
- en: '![](img/B18585_10_28.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_28.png)'
- en: 'Figure 10.28: Texture Repeat mode'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.28：纹理重复模式
- en: 'In the **Water Shader Graph**, right-click in an empty area of the **Shader
    Graph** and select **Create Node**:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Water Shader Graph**中，在**Shader Graph**的空白区域右键单击，然后选择**Create Node**：
- en: '![](img/B18585_10_29.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_29.png)'
- en: 'Figure 10.29: Shader Graph Create Node option'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.29：Shader Graph创建节点选项
- en: 'In the **Search** box, write `Sample texture` and all of the sampler nodes
    will show up. Double-click **Sample Texture 2D**. If for some reason you can’t
    double-click the option, right-click on it first and then try again. There is
    a known bug on this tool and this is the workaround:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**搜索**框中输入`Sample texture`，所有采样节点将显示出来。如果由于某些原因无法双击选项，请先右键单击它，然后再次尝试。这个工具存在一个已知问题，这是解决方案：
- en: '![](img/B18585_10_30.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_30.png)'
- en: 'Figure 10.30: Sample texture node search'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.30：样本纹理节点搜索
- en: 'Click in the circle to the left of the **Texture** input pin of the **Sample
    Texture 2D** node. It will allow us to pick a Texture to sample—just select the
    water one. You can see that the Texture can be previewed in the bottom part of
    the node:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Sample Texture 2D**节点**Texture**输入引脚左侧的圆圈。这将允许我们选择要采样的纹理——只需选择水纹理。您可以看到纹理可以在节点的底部部分预览：
- en: '![](img/B18585_10_31.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_31.png)'
- en: 'Figure 10.31: Sample Texture node with a Texture in its input pin'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.31：样本纹理节点，其输入引脚中有纹理
- en: 'Drag the output pin **RGBA** from the **Sample Texture 2D** node to the **Base
    Color** input pin of the Master node:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Sample Texture 2D**节点的输出引脚**RGBA**拖到主节点的**Base Color**输入引脚：
- en: '![](img/B18585_10_32.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_32.png)'
- en: 'Figure 10.32: Connecting the results of a Texture sampling with the Base Color
    pin of the Master node'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.32：将纹理采样的结果与主节点的Base Color引脚连接
- en: 'Click the **Save Asset** button at the top-left part of the Shader Graph editor
    and see the changes in the Scene view:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Shader Graph编辑器的左上角点击**Save Asset**按钮，然后在场景视图中查看更改：
- en: '![](img/B18585_10_33.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_33.png)'
- en: 'Figure 10.33: Results of applying a Texture in our Shader Graph'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.33：在Shader Graph中应用纹理的结果
- en: As you can see, the Texture is properly applied to the model, but if you take
    into account that the default plane has a size of 10x10 meters, the ripples of
    the water seem too big. So, let’s tile the Texture!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，纹理已正确应用于模型，但如果考虑到默认平面的尺寸为10x10米，水的波纹似乎太大。因此，让我们将纹理平铺！
- en: To do this, we need to change the UVs of the model, making them bigger. You
    may imagine that bigger UVs mean the Texture should also get bigger, but take
    into account that we are not making the object bigger; we are just modifying the
    UV.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要更改模型的UV，使它们更大。您可能会想象更大的UV意味着纹理也应该更大，但请记住，我们并没有使对象变大；我们只是在修改UV。
- en: 'In the same object area, we will display more of the texture area, meaning
    that in the bigger texture sample area (achieved by bigger UVs), repetitions of
    the texture may appear. To do so, follow the next steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个对象区域，我们将显示更多的纹理区域，这意味着在更大的纹理采样区域（通过更大的UV实现），纹理可能会出现重复。为此，请按照以下步骤操作：
- en: 'Right-click in any empty space and click **New Node** to search for the UV
    node:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何空白区域右键单击，然后点击**New Node**以搜索UV节点：
- en: '![](img/B18585_10_34.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_34.png)'
- en: 'Figure 10.34: Searching for the UV node'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.34：搜索UV节点
- en: Using the same method, create a **Multiply** node.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的方法，创建一个**Multiply**节点。
- en: Drag the **Out** pin of the UV node to the **A** pin of the **Multiply** node
    to connect them.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将UV节点的**Out**引脚拖到**Multiply**节点的**A**引脚上以连接它们。
- en: 'Set the **B** pin input value of **Multiply** to `4`,`4`,`4`,`4`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Multiply**的**B**引脚输入值设置为`4`,`4`,`4`,`4`：
- en: '![](img/B18585_10_35.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_35.png)'
- en: 'Figure 10.35: Multiplying the UVs by 4'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.35：将UV乘以4
- en: 'Drag the **Out** pin of the **Multiply** node to the **UV** of the **Sample
    Texture 2D** node to connect them:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Multiply**节点的**Out**引脚拖到**Sample Texture 2D**节点的**UV**上以连接它们：
- en: '![](img/B18585_10_36.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_36.png)'
- en: 'Figure 10.36: Using the multiplied UVs to sample the Texture'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.36：使用乘法UV坐标来采样纹理
- en: 'If you save the graph and go back to the Scene view, you can see that now the
    ripples are smaller, because we have tiled the UVs of our model. You can also
    see that in the preview of the **Sampler Texture 2D** node:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您保存图表并返回场景视图，您会看到现在波纹更小，因为我们已经对模型的UV坐标进行了平铺。您也可以在**2D纹理采样器**节点的预览中看到这一点：
- en: '![](img/B18585_10_37.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_37.png)'
- en: 'Figure 10.37: Results of the model’s UV multiplication'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.37：模型UV乘法的结果
- en: 'Another interesting effect we can do now is to apply an offset to the Texture
    to move it. The idea is that even if the plane is not actually moving, we will
    simulate the flow of the water through it, moving just the Texture. Remember,
    the responsibility of determining the part of the Texture to apply to each part
    of the model belongs to the UV, so if we add values to the UV coordinates, we
    will be moving them, generating a Texture sliding effect. To do so, let’s do the
    following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以实现的另一个有趣的效果是对纹理应用偏移以移动它。想法是，即使平面实际上没有移动，我们也会模拟水流通过它，只是移动纹理。记住，确定将纹理的哪一部分应用到模型的每一部分的职责属于UV，因此如果我们向UV坐标添加值，我们就会移动它们，从而生成纹理滑动效果。为了做到这一点，让我们做以下操作：
- en: Create an **Add** node to the right of the **UV** node.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**UV**节点右侧创建一个**添加**节点。
- en: 'Connect the **Out** pin of the **UV** to the **A** pin of the **Add** node:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**UV**的**输出**引脚连接到**添加**节点的**A**引脚：
- en: '![](img/B18585_10_38.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_38.png)'
- en: 'Figure 10.38: Adding values to the UVs'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.38：向UV坐标添加值
- en: Create a **Time** node at the left of the **Add** node.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**添加**节点左侧创建一个**时间**节点。
- en: 'Connect the **Time** node to the **B** pin of the **Add** node:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**时间**节点连接到**添加**节点的**B**引脚：
- en: '![](img/B18585_10_39.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_39.png)'
- en: 'Figure 10.39: Adding time to the UVs'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.39：将时间添加到UV坐标
- en: 'Connect the **Out** pin of the **Add** node to the **A** input pin of the **Multiply**
    node:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**添加**节点的**输出**引脚连接到**乘法**节点的**A**输入引脚：
- en: '![](img/B18585_10_40.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_40.png)'
- en: 'Figure 10.40: Added and multiplied UVs as an input of the sample Texture'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B18585_10_41.png)'
- en: 'Save and see the water moving in the Scene view. If you don’t see it moving,
    click the layers icon in the top bar of the scene and check **Always Refresh**:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并查看场景视图中水的移动。如果您看不到移动，请点击场景顶部栏中的图层图标并检查**始终刷新**：
- en: '![](img/B18585_10_41.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: 如果你觉得水流动得太快，尝试使用乘法节点将时间值设得更小。我建议你在查看下一张截图（其中包含答案）之前亲自尝试一下：
- en: 'Figure 10.41: Enabling Always Refresh to preview the effect'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.41：启用“始终刷新”以预览效果
- en: 'If you feel the water is moving too fast, try using the multiplication node
    to make the time a smaller value. I recommend you try it by yourself before looking
    at the next screenshot, which has the answer:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图片](img/B18585_10_44.png)'
- en: '![](img/B18585_10_42.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_42.png)'
- en: 'Figure 10.42: Multiplication of time to move the texture slower'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.42：乘以时间以减慢纹理移动速度
- en: 'If you feel the graph is too big, try to hide some of the node previews by
    clicking on the **up** (**^**) arrow that appears on the preview when you move
    the mouse over it:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你觉得图表太大，尝试通过点击鼠标悬停时出现在预览上的**向上**（**^**）箭头，隐藏一些节点预览：
- en: '![](img/B18585_10_43.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_43.png)'
- en: 'Figure 10.43: Hiding the preview from the graph nodes'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.43：隐藏图表节点预览
- en: 'Also, you can hide unused pins by selecting the node and clicking the arrow
    at its top right:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，您还可以通过选择节点并点击其右上角的箭头来隐藏未使用的引脚：
- en: '![](img/B18585_10_44.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_40.png)'
- en: 'Figure 10.44: Hiding unused pins from the graph nodes'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.44：隐藏图表节点中的未使用引脚
- en: So, to recap, first we added the time to the UV to move it and then multiplied
    the result of the moved UV to make it bigger to tile the Texture. It is worth
    mentioning that there’s a **Tiling and Offset** node that does all of this process
    for us, but I wanted to show you how a simple multiplication to scale the UV and
    an add operation to move it generates a nice effect; you can’t imagine all of
    the possible effects you can achieve with other simple mathematical nodes! Actually,
    let’s explore other usages of mathematical nodes to combine Textures in the next
    section.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，我们首先将时间添加到UV坐标以移动它，然后将移动后的UV坐标的结果进行乘法操作以使其更大，从而平铺纹理。值得一提的是，有一个**平铺和偏移**节点可以为我们完成所有这些过程，但我想要展示的是，一个简单的乘法操作可以缩放UV，一个加法操作可以移动它，从而产生一个很好的效果；您无法想象您可以用其他简单的数学节点实现多少种可能的效果！实际上，让我们在下一节中探索数学节点结合纹理的其他用法。
- en: Combining Textures
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理组合
- en: 'Even though we have used nodes, we haven’t created anything that can’t be created
    using regular shaders, but that’s about to change. So far, we can see the water
    moving but it stills look static, and that’s because the ripples are always the
    same. We have several techniques to generate ripples, and the simplest one would
    be to combine two water Textures moving in different directions to mix their ripples,
    and actually, we can simply use the same Texture just flipped to save some memory.
    To combine the Textures, we will sum them and then divide them by 2, so basically,
    we are calculating the average of the textures! Let’s do that by doing the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们使用了节点，但我们并没有创建出任何不能通过常规着色器创建的东西，但这一点即将改变。到目前为止，我们可以看到水在移动，但它仍然看起来很静止，这是因为波纹始终是相同的。我们有几种生成波纹的技术，最简单的一种是将两个在不同方向上移动的水纹理组合起来，以混合它们的波纹，实际上，我们可以简单地使用相同的纹理，只需将其翻转以节省一些内存。为了组合纹理，我们将它们相加，然后除以2，所以基本上，我们是在计算纹理的平均值！让我们通过以下步骤来实现：
- en: 'Select all of the nodes between **Time** and **Sampler 2D** (including them)
    creating a selection rectangle by clicking in any empty space in the graph, holding
    and dragging the click, and then releasing when all target nodes are covered:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Time**和**Sampler 2D**之间的所有节点（包括它们），通过在图中任何空白区域点击，按住并拖动点击，然后在所有目标节点都被覆盖时释放来创建一个选择矩形：
- en: '![](img/B18585_10_45.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_45.png)'
- en: 'Figure 10.45: Selecting several nodes'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.45：选择多个节点
- en: Right-click and select **Copy**, and then again right-click and select **Paste**,
    or use the classic *Ctrl* + *C*, *Ctrl* + *V* commands (*Command* + *C*, *Command*
    + *V* on Mac).
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并选择**复制**，然后再次右键单击并选择**粘贴**，或者使用经典的*Ctrl* + *C*，*Ctrl* + *V*命令（在Mac上为*Command*
    + *C*，*Command* + *V*）。
- en: 'Move the copied nodes below the original ones:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将复制的节点移动到原始节点下方：
- en: '![](img/B18585_10_46.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_46.png)'
- en: 'Figure 10.46: Duplication of nodes'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.46：节点的复制
- en: For the copied nodes, set the **B** pin of the **Multiply** node connected to
    **Sample Texture 2D** to `-4`,`-4`,`-4`,`-4`. You can see that that flipped the
    texture.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于复制的节点，将连接到**Sample Texture 2D**的**Multiply**节点的**B**引脚设置为`-4`,`-4`,`-4`,`-4`。你可以看到这翻转了纹理。
- en: 'Also, set the **B** pin of the **Multiply** node connected to the **Time**
    node to `-0.1`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，将连接到**Time**节点的**Multiply**节点的**B**引脚设置为`-0.1`：
- en: '![](img/B18585_10_47.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_47.png)'
- en: 'Figure 10.47: Multiplication of values'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.47：值的乘法
- en: 'Create an **Add** node at the right of both **Sampler Texture 2D** nodes and
    connect the outputs of those nodes to the **A** and **B** input pins of the **Add**
    node:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个**Sampler Texture 2D**节点的右侧创建一个**Add**节点，并将这些节点的输出连接到**Add**节点的**A**和**B**输入引脚：
- en: '![](img/B18585_10_48.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_48.png)'
- en: 'Figure 10.48: Adding two Textures'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.48：添加两个纹理
- en: 'You can see that the resulting combination is too bright because we have summed
    up the intensity of both textures, so let’s fix that by multiplying the **Out**
    of the **Add** node by `0.5,0.5,0.5,0.5`, which will divide each resulting color
    channel by 2, averaging the color. You can also experiment with what happens when
    you set different values to each channel if you want, but for our purposes, `0.5`
    is the proper value for each channel:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到，由于我们同时计算了两种纹理的强度，所以得到的结果太亮了。因此，我们可以通过将**Add**节点的**Out**乘以`0.5,0.5,0.5,0.5`来解决这个问题，这将把每个结果颜色通道除以2，实现颜色的平均。如果你愿意，也可以尝试设置每个通道的不同值来观察会发生什么，但就我们的目的而言，`0.5`是每个通道的正确值：
- en: '![](img/B18585_10_49.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_49.png)'
- en: 'Figure 10.49: Dividing the sum of two Textures to get the average'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.49：将两个纹理的和除以得到平均值
- en: Connect the **Out** pin of the **Multiply** node to the **Base Color** pin of
    the **Master** node to apply all of those calculations to the color of the object.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Multiply**节点的**Out**引脚连接到**Master**节点的**Base Color**引脚，以将所有这些计算应用于物体的颜色。
- en: 'Save the **Asset** and see the results in the Scene view:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存**Asset**并在场景视图中查看结果：
- en: '![](img/B18585_10_50.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_50.png)'
- en: 'Figure 10.50: Results of texture blending'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.50：纹理混合的结果
- en: You can keep adding nodes to make the effect more diverse, such as using **Sine**
    nodes (which will execute the trigonometry sine operation) to apply non-linear
    movements and so on, but I will let you learn that by experimenting with this
    by yourself. For now, we will stop here. As always, this topic deserves a full
    book, and the intention of this chapter is to give you a small taste of this powerful
    Unity tool. I recommend you look for other Shader Graph examples on the internet
    to learn other usages of the same nodes and, of course, new nodes. One thing to
    consider here is that everything we just did is basically applied to the Fragment
    Shader stage of the Shader Pipeline we discussed earlier. Now, let’s use the Blending
    Shader stage to apply some transparency to the water.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以继续添加节点以使效果更加多样化，例如使用**正弦**节点（这将执行三角函数正弦操作）来应用非线性运动等，但我会让您通过自己实验来学习这一点。现在，我们将在这里停止。像往常一样，这个主题值得一本完整的书，而本章的目的是给您这个强大的Unity工具的一个小尝鲜。我建议您在网上寻找其他Shader
    Graph示例，以学习相同节点的其他用法，当然，还有新节点。在这里要考虑的一点是我们刚刚所做的一切基本上都应用于我们之前讨论的Shader Pipeline的片段着色器阶段。现在，让我们使用混合着色器阶段来给水应用一些透明度。
- en: Applying transparency
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用透明度
- en: Before declaring our effect finished, a little addition we can do is to make
    the water a little bit transparent. Remember that the Shader Pipeline has a blending
    stage, which has the responsibility of blending each pixel of our model into the
    image being rendered in this frame. The idea is to make our Shader Graph modify
    that stage to apply **Alpha Blending**, a blending mode that combines our model
    and the previously rendered models based on the Alpha value of our model.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在宣布我们的效果完成之前，我们可以做的一个小补充是使水稍微透明一些。请记住，Shader Pipeline有一个混合阶段，该阶段负责将我们的模型中的每个像素混合到当前帧正在渲染的图像中。我们的想法是让我们的Shader
    Graph修改这个阶段以应用**Alpha混合**，这是一种基于我们模型Alpha值的混合模式。
- en: 'To get that effect, take the following steps:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要达到这种效果，请执行以下步骤：
- en: Look for the **Graph Inspector** window floating around. If you don’t see it,
    click the **Graph Inspector** button at the top-right part of the Shader Graph
    editor.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找漂浮的**图形检查器**窗口。如果您看不到它，请点击Shader Graph编辑器右上角的**图形检查器**按钮。
- en: Click the **Graph Settings** tab.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**图形设置**选项卡。
- en: Set the **Surface Type** property to **Transparent**.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**表面类型**属性设置为**透明**。
- en: 'Set the **Blending Mode** property to **Alpha** if it isn’t already at that
    value:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果**混合模式**属性尚未设置为该值，请将其设置为**Alpha**：
- en: '![](img/B18585_10_51.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_51.png)'
- en: 'Figure 10.51: Graph Inspector Transparency settings'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.51：图形检查器透明度设置
- en: Set the **Alpha** input pin of the **Master** to `0.5`.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**主**的**Alpha**输入引脚设置为`0.5`。
- en: '![](img/B18585_10_52.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_52.png)'
- en: 'Figure 10.52: Setting Alpha of the Master node'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.52：设置主节点的Alpha
- en: 'Save the Shader Graph and see the transparency being applied in the Scene view.
    If you can’t see the effect, just put a cube into the water to make the effect
    more evident:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存Shader Graph，并在场景视图中查看应用的透明度。如果您看不到效果，只需将一个立方体放入水中，使效果更加明显：
- en: '![](img/B18585_10_53.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_53.png)'
- en: 'Figure 10.53: Shadows from the water being applied to a cube'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.53：水产生的阴影应用到立方体上
- en: You can see the shadows that the water is casting on our cube because Unity
    doesn’t know the object is transparent and hence casts shadows. Click on the water
    plane and look for the Mesh Renderer component in the Inspector. If you don’t
    see the shadow, click the lightbulb at the top of the Scene view.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以看到水对我们的立方体投射的阴影，因为Unity不知道该对象是透明的，因此会投射阴影。点击水面，在检查器中查找Mesh Renderer组件。如果您看不到阴影，请点击场景视图顶部的灯泡图标。
- en: '![](img/B18585_10_54.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_54.png)'
- en: 'Figure 10.54: Enabling lights in the Scene View'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.54：在场景视图中启用灯光
- en: 'In the **Lighting** section, set **Cast Shadows** to **Off**; this will disable
    shadow casting from the plane on the parts of the cube that are underwater:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**照明**部分，将**投射阴影**设置为**关闭**；这将禁用从水面投射到水下立方体部分的阴影：
- en: '![](img/B18585_10_55.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_55.png)'
- en: 'Figure 10.55: Disabling shadow casting'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.55：禁用阴影投射
- en: 'Adding transparency is a simple process but it has its caveats, like the shadow
    problem, and in more complex scenarios, it can have other problems, like increasing
    overdraw, meaning the same pixel needs to be drawn several times (the pixel belonging
    to the transparent object, and one of the objects behind). I would suggest you
    avoid using transparency unless it is necessary. Actually, our water can live
    without transparency, especially when we apply this water to the river basin around
    the base because we don’t need to see the part under the water, but the idea is
    for you to know all of your options. In the next screenshot, you can see how we
    have put a giant plane with this effect below our base, big enough to cover the
    entire basin:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 添加透明度是一个简单的过程，但它有一些注意事项，比如阴影问题，在更复杂的情况下，它可能还有其他问题，比如过度绘制，这意味着同一个像素需要绘制多次（属于透明对象的像素，以及背后的一个对象）。我建议除非必要，否则避免使用透明度。实际上，我们的水可以不使用透明度，尤其是在我们将这种水应用到基础周围的河盆地时，因为我们不需要看到水下部分，但目的是让你知道所有选项。在下一张截图中，你可以看到我们如何在基础下方放置了一个带有这种效果的大平面，足够大，可以覆盖整个盆地：
- en: '![](img/B18585_10_56.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_56.png)'
- en: 'Figure 10.56: Using our water in the main scene'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.56：在主场景中使用我们的水
- en: Now that we have modified how the object looks through the **Fragment** node
    section, let’s discuss how to use the Vertex section to apply a mesh animation
    to our water.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修改了通过**片段节点**部分对象的外观，让我们讨论如何使用顶点部分来对我们的水应用网格动画。
- en: Creating Vertex Effects
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建顶点效果
- en: So far, we have applied water textures to our water, but it’s still a flat plane.
    We can go further than that and make the ripples not only via textures but also
    by animating the mesh. To do so, we will apply the noise texture we used at the
    beginning of the chapter in the shader, but instead of using it as another color
    to add to the **Base Color** of the shader, we will instead use it to offset the
    **Y** position of the vertexes of our plane.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将水纹理应用到我们的水上，但它仍然是一个平面。我们可以更进一步，不仅通过纹理，还通过动画网格来制作涟漪。为此，我们将在着色器中应用我们在本章开头使用的噪声纹理，但不是将其用作添加到着色器**基础颜色**的另一种颜色，而是用它来偏移我们平面的顶点的**Y**位置。
- en: 'Due to the chaotic nature of the noise texture, the idea is that we will apply
    a vertical offset to different parts of the model, so we can emulate the ripples:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于噪声纹理的混沌性质，我们的想法是对模型的不同部分应用垂直偏移，这样我们就可以模拟涟漪：
- en: '![](img/B18585_10_57.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_57.png)'
- en: 'Figure 10.57: Default plane mesh subdivided into a grid of 10x10 with no offset'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.57：默认平面网格细分为10x10的网格，无偏移
- en: 'To accomplish something like this, you can modify the **Vertex** section of
    your shader to look like the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现类似的效果，你可以修改你的着色器的**顶点**部分，使其看起来如下：
- en: '![](img/B18585_10_58.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_10_58.png)'
- en: 'Figure 10.58: Ripples vertex effect'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.58：涟漪顶点效果
- en: In the graph, you can see how we are creating a **Vector** whose *y* axis depends
    on the noise Texture we downloaded at the beginning of the chapter. The idea behind
    that is to create a **Vector** pointing upward whose length is proportional to
    the grayscale factor of the texture; the whiter the pixel of the texture, the
    longer the offset. This texture has an irregular yet smooth pattern so it can
    emulate the behavior of the tide.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，你可以看到我们是如何创建一个**向量**的，其**y**轴取决于我们在本章开头下载的噪声纹理。背后的想法是创建一个指向上方的**向量**，其长度与纹理的灰度因子成正比；纹理的像素越白，偏移量越长。这种纹理具有不规则但平滑的图案，可以模拟潮汐的行为。
- en: Please notice that here we used **Sample Texture 2D LOD** instead of **Sample
    Texture 2D**; the latter does not work in the **Vertex** section, so keep that
    in mind.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里我们使用了**Sample Texture 2D LOD**而不是**Sample Texture 2D**；后者在**顶点**部分不起作用，所以请记住这一点。
- en: Then we multiply the result by *0.3* to reduce the height of the offset to add,
    and then we add the result to the **Position** node.See that the **Space** property
    of the **Position** node is set to **Object** mode. We need that mode to work
    with the **Vertex** section of the Shader Graph (we discussed World and Local
    spaces before in *Chapter 2*, *Editing Scenes and GameObjects* but you can also
    search `Object vs World Space` on the internet for more info about this). Finally,
    the result is connected to the **Position** node of the **Vertex** section.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将结果乘以*0.3*以减少要添加的偏移量的高度，然后将结果添加到**位置**节点。注意**位置**节点的**空间**属性设置为**对象**模式。我们需要这种模式来与着色器图（我们在*第2章*，*编辑场景和游戏对象*中讨论了世界和本地空间，但你也可以在网上搜索`对象
    vs 世界空间`以获取更多关于此的信息）。最后，结果连接到**顶点**部分的**位置**节点。
- en: 'If you save, you will see something like the following image:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保存，你会看到以下类似图像：
- en: '![](img/B18585_10_59.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_59.png)'
- en: 'Figure 10.59: Ripples vertex effect applied'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.59：应用了涟漪顶点效果
- en: 'Of course, in this case, the ripples are static because we didn’t add any time
    offset to the UV as we did before. In the following screenshot, you can see how
    to add that, but before looking at it I recommend you try to resolve it first
    by yourself as a personal challenge:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这种情况下，涟漪是静态的，因为我们没有像之前那样给UV添加任何时间偏移。在下面的屏幕截图中，你可以看到如何添加它，但在查看它之前，我建议你先自己尝试解决它，作为一个个人挑战：
- en: '![](img/B18585_10_60.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_10_60.png)'
- en: 'Figure 10.60: Animated ripples vertex effect graph'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.60：动画涟漪顶点效果图
- en: As you can see, we are again taking the original UV and adding the time multiplied
    by any factor so it will slowly move, the same as we did previously with our water
    texture. You can keep playing around with this, changing how this looks with different
    textures, multiplying the offset to increase or reduce the height of the ripples,
    applying interesting math functions like sine, and so much more, but for now,
    let’s finish with this.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们再次使用原始UV，并添加任何因子的乘以时间，这样它会慢慢移动，就像我们之前在水面纹理中所做的那样。你可以继续尝试不同的纹理，改变其外观，乘以偏移量以增加或减少涟漪的高度，应用如正弦等有趣的数学函数，等等，但就目前而言，让我们完成这个。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed how a shader works in the GPU and how to create
    our first simple shader to achieve a nice water effect. Working with shaders is
    a complex and interesting job, and in a team, there is usually one or more people
    in charge of creating all of these effects, in a position called Technical Artist;
    so, as you can see, this topic can expand up to a whole career. Remember, the
    intention of this book is to give you a small taste of all the possible roles
    you can take in the industry, so if you really liked this role, I suggest you
    start reading shader-exclusive books. You have a long but super interesting road
    in front of you.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了着色器在GPU中的工作方式以及如何创建我们的第一个简单着色器以实现良好的水面效果。与着色器一起工作是一项复杂而有趣的工作，在一个团队中，通常有一到多个人负责创建所有这些效果，这个职位被称为技术艺术家；所以，正如你所见，这个主题可以扩展到整个职业生涯。记住，这本书的目的是给你一个行业所有可能角色的微小品尝，所以如果你真的喜欢这个角色，我建议你开始阅读专门关于着色器的书籍。你面前有一条漫长但超级有趣的道路。
- en: Enough shaders for now! In the next chapter, we will look at how to improve
    our graphics and create visual effects with particle systems!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经足够了着色器了！在下一章中，我们将探讨如何通过粒子系统来改进我们的图形并创建视觉效果！
