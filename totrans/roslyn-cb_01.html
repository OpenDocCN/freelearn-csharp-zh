<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Writing Diagnostic Analyzers</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Creating, debugging, and executing an analyzer project in Visual Studio</li>
<li>Creating a symbol analyzer to report issues about symbol declarations</li>
<li>Creating a syntax node analyzer to report issues about language syntax</li>
<li>Creating a syntax tree analyzer to analyze source file and report syntax issues</li>
<li>Creating a method body analyzer to analyze whole method and report issues</li>
<li>Creating a compilation analyzer to analyze whole compilation and report issues</li>
<li>Writing unit tests for an analyzer project</li>
<li>Publishing the NuGet package and VSIX for an analyzer project</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Diagnostic analyzers are extensions to the Roslyn C# compiler and Visual Studio IDE to analyze user code and report diagnostics. Users will see these diagnostics in the error list after building the project from Visual Studio, and even when building the project on the command line. They will also see the diagnostics live while editing the source code in the Visual Studio IDE. Analyzers can report diagnostics to enforce specific code styles, improve code quality and maintenance, recommend design guidelines, or even report very domain-specific issues which cannot be covered by the core compiler. This chapter enables C# developers to write, debug, test, and publish analyzers that perform different kinds of analyses.</p>
<div class="packt_tip">If you are not familiar with the Roslyn's architecture and API layers, it is recommended that, before reading this chapter further, you read the Preface of this book to gain a basic understanding of Roslyn APIs.</div>
<p>Diagnostic analyzers are built on top of the Roslyn's <strong>CodeAnalysis</strong>/<strong>Compiler layer</strong> API. Analyzers can analyze specific code units, <span>such as a</span> symbol, syntax node, code block, compilation, and so on, <span>by registering one or more analyzer actions. The compiler layer makes a callback into the analyzer whenever it compiles a code unit of interest. The analyzer can report diagnostics on code units, which are added to the list of the compiler diagnostics and reported back to the end user.</span></p>
<p>Analyzers can be broadly categorized into the following two buckets based on the kind of analysis performed:</p>
<ul>
<li><strong>Stateless analyzers</strong>: Analyzers that report diagnostics about a specific code unit by registering one or more analyzer actions that:
<ul>
<li>Do not require maintaining any state across analyzer actions.</li>
<li>Independent of the order of execution of individual analyzer actions.</li>
</ul>
</li>
</ul>
<p>For example, an analyzer that looks at every single class declaration independently and reports issues about the declaration is a stateless analyzer. We will show you how to write a stateless symbol, syntax node, and syntax tree analyzer, later in this chapter.</p>
<ul>
<li><strong>Stateful analyzers</strong>: Analyzers that report diagnostics about a specific code unit, but in the context of an enclosing code unit, such as a code block or a compilation. These are more complicated analyzers that require powerful and wider analysis, hence, need careful design to achieve efficient analyzer execution without memory leaks. These analyzers require at least one of the following kinds of state manipulation for analysis:
<ul>
<li>Access to immutable state objects for the enclosing code unit, such as a compilation or the code block. For example, access to certain well-known types defined in a compilation.</li>
<li>Perform analysis over the enclosing code unit, with mutable state defined and initialized in a start action for the enclosing code unit, intermediate nested actions that access and/or update this state, and an end action to report diagnostic on the individual code units.</li>
</ul>
</li>
</ul>
<p>For example, an analyzer that <span>looks at all class declarations in a compilation, gathering and updating a common state when analyzing each class declaration, and then finally, after it has analyzed all declarations, reports issues about those declarations is a stateful analyzer.</span> We will show you how to write a stateful method body and compilation analyzer in this chapter.</p>
<div class="packt_infobox">By default, analyzers can analyze and report diagnostics on source files in a project. However, we can also write an analyzer that analyzes additional files, that is, non-source text files included in the project, and also report diagnostics in additional files. Non-source files could be files, such as Web.config files in a web project, cshtml files in a Razor project, XAML files in a WPF project, and so on. You can read more about how to write and consume additional file analyzers at <a href="https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md">https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md.</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating, debugging, and executing an analyzer project in Visual Studio</h1>
                </header>
            
            <article>
                
<p>We will show you how to install the .NET Compiler Platform SDK, create an analyzer project from a template, and then debug and execute the default analyzer.</p>
<div class="packt_tip"><span>The analyzer project that you create in t</span>his recipe can be used in the subsequent recipes in this chapter to add new analyzers and write unit tests.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You will need to have Visual Studio 2017 installed on your machine to execute the recipes in this chapter. You can install a free community version of Visual Studio 2017 from <a href="https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15">https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Start Visual Studio and click on <span class="packt_screen">File</span> | <span class="packt_screen">New</span> | <span class="packt_screen">Project.</span></li>
<li>Search for <kbd>Analyzer</kbd> templates in the textbox at the top right corner of the <span class="packt_screen">New Project</span> dialog, select <span class="packt_screen">Download the .NET Compiler Platform SDK</span>, and click on <span class="packt_screen">OK:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="474" src="assets/b8e145ad-e7b0-4e57-b64f-49b179c96b71.png" width="686"/></div>
<ol start="3">
<li>The new project will have an <kbd>index.html</kbd> file opened by default. Click on <span class="packt_screen">Download .NET Compiler Platform SDK Templates &gt;&gt;</span> button to install the analyzer SDK templates.</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="193" src="assets/b7dad759-4dcc-49b0-b7ed-e4efe64b0d2d.png" width="608"/></div>
<ol start="4">
<li>In the subsequent <span class="packt_screen">File Download</span> dialog, click on <span class="packt_screen">Open</span>.</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="242" src="assets/b1755f2f-8bbc-4e5d-823c-f1334ba66654.png" width="368"/></div>
<ol start="5">
<li>Click <span class="packt_screen">Install</span> on the next <span class="packt_screen">VSIX Installer</span> dialog and <span class="packt_screen">End Tasks</span> on the subsequent prompt to install the SDK:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="265" src="assets/2d961daa-1c5a-432d-ac44-073cae33659d.png" width="353"/></div>
<ol start="6">
<li>Start a new instance of Visual Studio and click on <span class="packt_screen">File</span> | <span class="packt_screen">New</span> | <span class="packt_screen">Project...</span> to get the <span class="packt_screen">New Project</span> dialog.</li>
<li>Change the project target framework combo box to <span class="packt_screen">.NET Framework 4.6</span> (or above). Under <span class="packt_screen">Visual C#</span> | <span class="packt_screen">Extensibility</span>, choose <span class="packt_screen">Analyzer with Code Fix (NuGet + VSIX)</span>, name your project <kbd>CSharpAnalyzers</kbd>, and click on <span class="packt_screen">OK</span>.</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><strong><em><img class="image-border" height="485" src="assets/c236cecc-9323-4f98-8b76-5f4c3efe80cd.png" width="700"/><br/></em></strong></div>
<ol start="8">
<li>You should now have an analyzers solution with 3 projects: <kbd>CSharpAnalyzers (Portable)</kbd>, <kbd>CSharpAnalyzers.Test</kbd> , and <kbd>CSharpAnalyzer.Vsix</kbd><strong>:</strong></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="170" src="assets/80081d9c-64db-4850-9fa1-a91a00ef78d6.png" width="334"/></div>
<ol start="9">
<li>Open source file <kbd>DiagnosticAnalyzer.cs</kbd> in <kbd>CSharpAnalyzers</kbd> project and set breakpoints (press <em>F9</em>) at the start of the <kbd>Initialize</kbd> and <kbd>AnalyzeSymbol</kbd> methods, as shown here:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="363" src="assets/9803a238-34f8-4fe6-b161-5b3729c02efb.png" width="707"/></div>
<ol start="10">
<li>Set <kbd>CSharpAnalyzers.Vsix</kbd> as the start-up project and click on <em>F5</em> to build the analyzer and start debugging a new instance of Visual Studio with the analyzer enabled.</li>
<li>In the new Visual Studio instance, create a new C# class library project, say <kbd>ClassLibrary</kbd>.</li>
<li>Verify that we hit both the preceding breakpoints in our analyzer code in the first VS instance. You can step through the analyzer code using <em>F10</em> or click on <em>F5</em> to continue debugging.</li>
</ol>
<p> </p>
<ol start="13">
<li>We should now see the analyzer diagnostic in the error list and a squiggle in the editor:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="344" src="assets/ada9a9c5-b73c-4514-ba72-bdb5615cc51a.png" width="744"/></div>
<ol start="14">
<li>Edit the name of the class from <kbd>Class1</kbd> to <kbd>CLASS1</kbd>.</li>
<li>We should hit the breakpoint in the <kbd>AnalyzeSymbol</kbd> method again. Continue debugging with <em>F5</em> and the diagnostic and squiggle should go away immediately, demonstrating the powerful live and extensible analysis.</li>
</ol>
<ol start="19"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>.NET Compiler Platform SDK is a wrapper project that redirects us to fetch the project templates for analyzer + CodeFix projects for C# and Visual Basic. Creating a new project from these templates creates a fully functional analyzer project which has a default analyzer, unit tests, and a VSIX project:</p>
<ul>
<li><kbd>CSharpAnalyzers</kbd>: Core analyzer project that contains the default analyzer implementation that reports a diagnostic for all type names that contain any lowercase letters.</li>
<li><kbd>CSharpAnalyzers.Test</kbd>: Analyzer unit test project that contains a couple of analyzer and code fixer unit tests and test helpers.</li>
<li><kbd>CSharpAnalyzers.Vsix</kbd>: The VSIX project that packages the analyzer into a VSIX. This is the start-up project in the solution.</li>
</ul>
<p>Clicking on <em>F5</em> to start debugging the solution builds and deploys the analyzer to the Visual Studio extension hive and then starts a new Visual Studio instance from this hive. Our analyzer is enabled by default for all C# projects created in this VS instance.</p>
<p>Let's expand a bit more on the diagnostic analyzer source code defined in <kbd>DiagnosticAnalyzers.cs</kbd>. It contains a type named <kbd>CSharpAnalyzersAnalyzer</kbd>, which derives from <kbd>DiagnosticAnalyzer</kbd><span>.</span> <kbd>DiagnosticAnalyzer</kbd> is an abstract type with the following two abstract members:</p>
<ul>
<li><kbd>SupportedDiagnostics</kbd> property: Analyzer must define one or more supported diagnostic descriptors. Descriptors describe the metadata for the diagnostics that an analyzer can report in analyzer actions. It contains fields such as the diagnostic ID, message format, title, description, hyperlink to documentation for the diagnostic, and so on. Can be used to create and report diagnostics:</li>
</ul>
<pre style="padding-left: 90px">
private static DiagnosticDescriptor Rule = new DiagnosticDescriptor(DiagnosticId, Title, MessageFormat, Category, DiagnosticSeverity.Warning, isEnabledByDefault: true, description: Description);<br/><br/><strong>public override ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics</strong> { get { return ImmutableArray.Create(Rule); } }
</pre>
<ul>
<li><kbd>Initialize</kbd> method: Diagnostic analyzers must implement the <kbd>Initialize</kbd> method to register analyzer action callbacks for a specific code entity kind of interest, which is named type symbols for the default analyzer. The initialize method is invoked once for the analyzer lifetime to allow analyzer initialization and registration of actions.</li>
</ul>
<pre style="padding-left: 90px">
<strong> public override void Initialize(AnalysisContext context)</strong><br/> {<br/>  context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);<br/> }<br/><br/> private static void AnalyzeSymbol(SymbolAnalysisContext context)<br/> {<br/>   ...<br/> }
</pre>
<div class="packt_tip">Invoke <kbd>AnalysisContext.EnableConcurrentExecution()</kbd> in the <kbd>Initialize</kbd> method if your analyzer can handle action callbacks from multiple threads simultaneously -- this enables the analyzer driver to execute the analyzer more efficiently on a machine with multiple cores. Additionally, also invoke <kbd>AnalysisContext.ConfigureGeneratedCodeAnalysis()</kbd> in the<kbd>Initialize</kbd> method to configure whether or not the analyzer wants to analyze and/or report diagnostics in generated code.</div>
<p>Analyzer actions are invoked for every code entity of interest in a user s source code. Additionally, as the user edits code and a new compilation is created, action callbacks are continuously invoked for entities defined in the new compilation during code editing. The error list makes sure that it only reports the diagnostics from the active compilation.</p>
<div class="packt_tip">Use <a href="http://source.roslyn.io">http://source.roslyn.io</a> for rich semantic search and navigation of Roslyn source code, which is open sourced at <a href="https://github.com/dotnet/roslyn.git">https://github.com/dotnet/roslyn.git</a>. For example, you can look at the definition and references for <kbd>DiagnosticAnalyzer</kbd> using the query URL <a href="http://source.roslyn.io/#q=DiagnosticAnalyzer">http://source.roslyn.io/#q=DiagnosticAnalyzer</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a symbol analyzer to report issues about symbol declarations</h1>
                </header>
            
            <article>
                
<p>A symbol analyzer registers action callbacks to analyze one or more kinds of symbol declarations, such as types, methods, fields, properties, events, and so on, reports semantic issues about declarations.</p>
<p>In this section, we will create a symbol analyzer that extends the compiler diagnostic <em>CS0542</em> (member names cannot be the same as their enclosing type) to report a diagnostic if member names are the same as any of the outer parent type. For example, the analyzer will report a diagnostic for the innermost type <kbd>NestedClass</kbd> here:</p>
<pre>
public class NestedClass<br/>{<br/>  public class InnerClass<br/>  {<br/>    public class NestedClass<br/>    {<br/>    }<br/>  }<br/>}
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You will need to have created and opened an analyzer project, say <kbd>CSharpAnalyzers</kbd> in Visual Studio 2017. Refer to the first recipe in this chapter to create this project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In <span class="packt_screen">Solution Explorer</span>, double-click on <kbd>Resources.resx</kbd> file in <kbd>CSharpAnalyzers</kbd> project to open the resource file in the resource editor.</li>
<li>Replace the existing resource strings for <kbd>AnalyzerDescription</kbd>, <kbd>AnalyzerMessageFormat</kbd> and <kbd>AnalyzerTitle</kbd> with new strings:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="138" src="assets/fb520471-e9c9-4c9f-b339-2b600de5d40c.png" width="991"/></div>
<ol start="3">
<li>Replace the <kbd>Initialize</kbd> method implementation with the following:</li>
</ol>
<pre style="padding-left: 90px">
public override void Initialize(AnalysisContext context)<br/>{<br/>  context.RegisterSymbolAction(symbolContext =&gt;<br/>  {<br/>    var symbolName = symbolContext.Symbol.Name;<br/><br/>    // Skip the immediate containing type, CS0542 already covers this case.<br/>    var outerType = symbolContext.Symbol.ContainingType?.ContainingType;<br/>    while (outerType != null)<br/>    {<br/>      // Check if the current outer type has the same name as the given member.<br/>      if (symbolName.Equals(outerType.Name))<br/>      {<br/>        // For all such symbols, report a diagnostic.<br/>        var diagnostic = Diagnostic.Create(Rule, symbolContext.Symbol.Locations[0], symbolContext.Symbol.Name);<br/>        symbolContext.ReportDiagnostic(diagnostic);<br/>        return;<br/>      }<br/><br/>      outerType = outerType.ContainingType;<br/>    }<br/>  },<br/>  SymbolKind.NamedType,<br/>  SymbolKind.Method,<br/>  SymbolKind.Field,<br/>  SymbolKind.Event,<br/>  SymbolKind.Property);<br/>}
</pre>
<ol start="4">
<li>Click on <em>Ctrl</em> + <em>F5</em> to start a new Visual Studio instance with the analyzer enabled.</li>
<li>In the new Visual Studio instance, create a new C# class library with the following code:</li>
</ol>
<pre style="padding-left: 90px">
namespace ClassLibrary<br/>{<br/> public class OuterClass<br/> {<br/>  public class NestedClass<br/>  {<br/>   public class NestedClass<br/>   {<br/>   }<br/>  }<br/> }<br/>}
</pre>
<ol start="6">
<li>Verify the compiler reported diagnostic <em>CS0542</em> in the error list: <kbd>'NestedClass': member names cannot be the same as their enclosing type</kbd>.</li>
<li>Change the class library code to following:</li>
</ol>
<pre style="padding-left: 90px">
namespace ClassLibrary<br/>{<br/> public class OuterClass<br/> {<br/>  public class NestedClass<br/>  {<br/>   public class InnerClass<br/>   {<br/>    public class NestedClass<br/>    {<br/>    }<br/>   }<br/>  }<br/> }<br/>}
</pre>
<ol start="8">
<li>Verify that <em>CS0542</em> isn t reported anymore, but the error list has our analyzer diagnostic:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="381" src="assets/1d7b4dc1-787d-4528-ad6d-cf93ea8d292d.png" width="800"/></div>
<ol start="9">
<li>Replace the innermost type declaration for <kbd>NestedClass</kbd> with a field: <kbd>public int NestedClass</kbd>, and verify the same analyzer diagnostic is reported. You should get the same diagnostic for other member kinds such as method, property, and events with the same name.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Symbol analyzers register one or more symbol action callbacks to analyze symbol kinds of interest. Note that, unlike the default implementation that registered a delegate method named <kbd>AnalyzeSymbol</kbd>, we registered a lambda callback.</p>
<p>We specified interest in analyzing all the top-level symbol kinds that can have an enclosing type, namely types, methods, fields, properties, and events in the <kbd>RegisterSymbolAction</kbd> invocation:</p>
<pre>
context.RegisterSymbolAction(symbolContext =&gt;<br/>{<br/> ...<br/>},<br/>SymbolKind.NamedType,<br/>SymbolKind.Method,<br/>SymbolKind.Field,<br/>SymbolKind.Event,<br/>SymbolKind.Property);
</pre>
<p>The analyzer driver ensures that the registered lambda is invoked for all symbols of the registered interest kinds in the compilation.</p>
<p>Analysis skips the immediate enclosing type, as C# compiler already reports error <em>CS0542,</em> if a member has the same name as its enclosing type.</p>
<pre>
// Skip the immediate containing type, CS0542 already covers this case.<br/>var outerType = symbolContext.Symbol.ContainingType?.ContainingType;
</pre>
<p>Core analysis works by looping over the outer types and comparing the name of the symbol in a symbol analysis context with the relevant outer types, until it finds a match, in which case, it reports a diagnostic; if the outer type has no containing type, it doesn t report a diagnostic.</p>
<pre>
while (outerType != null)<br/>{<br/> // Check if the current outer type has the same name as the given member.<br/> if (symbolName.Equals(outerType.Name))<br/> {<br/>  // For all such symbols, report a diagnostic.<br/>  ...<br/> }<br/><br/> outerType = outerType.ContainingType;<br/>}
</pre>
<div class="packt_infobox">It is recommended that symbol actions only analyze and report diagnostics about declarations, not the executable code within it. If you need to analyze executable code within a symbol, you should try to register other action kinds discussed later in this chapter.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There s more...</h1>
                </header>
            
            <article>
                
<p><strong>Trivia</strong>: The preceding implementation of the symbol analyzer does not have optimal performance. For example, if you have <em>n</em> levels of type nesting, and <em>m</em> fields in the inner innermost nested type, the analysis we implemented will be <em>O(m*n)</em> algorithmic complexity. Can you implement an alternate implementation where the analysis can be implemented with a much superior <em>O(m + n)</em> complexity?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Our current analyzer implementation is completely stateless because it doesn t require analysis that is dependent upon more than one symbol at a time. We analyze each symbol individually and report diagnostics for it. However, if you need to do more complex analysis that requires collecting state from multiple symbols and then doing a compilation-wide analysis, you should write a stateful compilation analyzer with symbol and compilation actions. This is covered later in this chapter in the recipe <em>Creating a compilation analyzer to analyze a whole compilation and report issues.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a syntax node analyzer to report issues about language syntax</h1>
                </header>
            
            <article>
                
<p>A syntax node analyzer registers action callbacks to analyze one or more kinds of syntax nodes, such as operators, identifiers, expressions, declarations, and so on, and reports semantic issues about syntax. These analyzers generally need to fetch semantic information about different syntax nodes being analyzed and use the compiler semantic model APIs to get this information.</p>
<p>In this section, we will create a syntax analyzer that analyzes <kbd>VariableDeclarationSyntax</kbd> nodes for local declarations and reports a diagnostic recommending use of the explicit type instead of an implicitly typed declaration, that is, variables defined with the keyword <kbd>var</kbd>, such as <kbd>var i = new X();</kbd><em>.</em> Analyzer will not report diagnostics if there is a compiler syntax error (implicitly typed declarations cannot define more than one variable), or the right side of the assignment has an error type or special System type such as int, char, string, and so on. For example, the analyzer will not flag locals <kbd>local1</kbd>, <kbd>local2</kbd>, and <kbd>local3</kbd> here, but will flag <kbd>local4</kbd>.</p>
<pre>
int local1 = 0;<br/>Class1 local2 = new Class1();<br/>var local3 = 0;<br/>var local4 = new Class1();
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You will need to have created and opened an analyzer project, say <kbd>CSharpAnalyzers</kbd> in Visual Studio 2017. Refer to the first recipe in this chapter to create this project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In <span class="packt_screen">Solution Explorer</span>, double-click on <kbd>Resources.resx</kbd> file in <kbd>CSharpAnalyzers</kbd> project to open the resource file in the resource editor.</li>
<li>Replace the existing resource strings for <kbd>AnalyzerDescription</kbd>, <kbd>AnalyzerMessageFormat</kbd> and <kbd>AnalyzerTitle</kbd> with new strings:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/41de0b15-eb6f-442a-bb06-508abe40df8f.png"/></div>
<ol start="3">
<li>Replace the <kbd>Initialize</kbd> method implementation with the following:</li>
</ol>
<pre style="padding-left: 90px">
public override void Initialize(AnalysisContext context)<br/>{<br/>  context.RegisterSyntaxNodeAction(syntaxNodeContext =&gt;<br/>  {<br/>    // Find implicitly typed variable declarations.<br/>    // Do not flag implicitly typed declarations that declare more than one variables,<br/>    // as the compiler already generates error CS0819 for those cases.<br/>    var declaration = (VariableDeclarationSyntax)syntaxNodeContext.Node;<br/>    if (!declaration.Type.IsVar || declaration.Variables.Count != 1)<br/>    {<br/>      return;<br/>    }<br/><br/>    // Do not flag variable declarations with error type or special System types, such as int, char, string, and so on.<br/>    var typeInfo = syntaxNodeContext.SemanticModel.GetTypeInfo(declaration.Type, syntaxNodeContext.CancellationToken);<br/>    if (typeInfo.Type.TypeKind == TypeKind.Error || typeInfo.Type.SpecialType != SpecialType.None)<br/>    {<br/>      return;<br/>    }<br/><br/>    // Report a diagnostic.<br/>    var variable = declaration.Variables[0];<br/>    var diagnostic = Diagnostic.Create(Rule, variable.GetLocation(), variable.Identifier.ValueText);<br/>    syntaxNodeContext.ReportDiagnostic(diagnostic);<br/>  }, <br/>  SyntaxKind.VariableDeclaration);<br/>}
</pre>
<ol start="4">
<li>Click on <em>Ctrl</em> + <em>F5</em> to start a new Visual Studio instance with the analyzer enabled.</li>
<li>In the new Visual Studio instance, create a new C# class library with the following code:</li>
</ol>
<pre style="padding-left: 90px">
namespace ClassLibrary<br/>{<br/>  public class Class1<br/>  {<br/>    public void M(int param1, Class1 param2)<br/>    {<br/>      // Explicitly typed variables - do not flag.<br/>      int local1 = param1;<br/>      Class1 local2 = param2;<br/>    }<br/>  }<br/>}
</pre>
<ol start="6">
<li>Verify the analyzer diagnostic is not reported in the error list for explicitly typed variables.</li>
<li>Now, add the following implicitly typed variable declarations to the method:</li>
</ol>
<pre style="padding-left: 90px">
 // Implicitly typed variable with error type - do not flag.<br/> var local3 = UndefinedMethod();<br/><br/> // Implicitly typed variable with special type - do not flag.<br/> var local4 = param1;
</pre>
<ol start="8">
<li>Verify the analyzer diagnostic is not reported in the error list for implicitly typed variables with error type or special type.</li>
<li>Add the violating implicitly typed variable declaration to the method:</li>
</ol>
<pre style="padding-left: 90px">
 // Implicitly typed variable with user defined type - flag.<br/> var local5 = param2;
</pre>
<ol start="10">
<li>Verify the analyzer diagnostic is reported for this implicitly typed variable:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="427" src="assets/546651f4-032c-4497-ae9a-10e69500c726.png" width="802"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Syntax node analyzers register one or more syntax node action callbacks to analyse syntax kinds of interest. We specified interest in analyzing <kbd>VariableDeclaration</kbd> syntax kind in the <kbd>RegisterSyntaxNodeAction</kbd> invocation.</p>
<p> </p>
<pre>
context.RegisterSyntaxNodeAction(syntaxNodeContext =&gt;<br/>{<br/>...<br/>}, SyntaxKind.VariableDeclaration);
</pre>
<p>Analysis works by operating on the syntax node and semantic model exposed off the syntax node analysis context in the callback. We first do syntactic checks to verify that we are operating on a valid implicitly typed declaration:</p>
<p> </p>
<pre>
// Do not flag implicitly typed declarations that declare more than one variables,<br/>// as the compiler already generates error CS0819 for those cases.<br/>var declaration = (VariableDeclarationSyntax)syntaxNodeContext.Node;<br/>if (!declaration.Type.IsVar || declaration.Variables.Count != 1)<br/>{<br/> return;<br/>}
</pre>
<p>We then perform semantic checks using the semantic model APIs to get semantic type information about the type declaration syntax node and verify it is not an error type or primitive system type:</p>
<pre>
// Do not flag variable declarations with error type or special System types, such as int, char, string, and so on.<br/>var typeInfo = syntaxNodeContext.SemanticModel.GetTypeInfo(declaration.Type, syntaxNodeContext.CancellationToken);<br/>if (typeInfo.Type.TypeKind == TypeKind.Error || typeInfo.Type.SpecialType != SpecialType.None)<br/>{<br/> return;<br/>}
</pre>
<div class="packt_infobox">You can perform many powerful semantic operations on the syntax node exposed from the <kbd>SyntaxNodeAnalysisContext</kbd> using the public semantic model APIs, for reference see <a href="https://github.com/dotnet/roslyn/blob/master/src/Compilers/Core/Portable/Compilation/SemanticModel.cs">https://github.com/dotnet/roslyn/blob/master/src/Compilers/Core/Portable/Compilation/SemanticModel.cs</a>.</div>
<p>If both the syntactic and semantics check succeed, then we report a diagnostic about recommending explicit type instead of var.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a syntax tree analyzer to analyze the source file and report syntax issues</h1>
                </header>
            
            <article>
                
<p>A syntax tree analyzer registers action callbacks to analyze the syntax/grammar for the source file and reports pure syntactic issues. For example, a missing semicolon at the end of a statement is a syntactic error, while assigning an incompatible type to a symbol with no possible type conversion is a semantic error.</p>
<p>In this section, we will write a syntax tree analyzer that analyzes all the statements in a source file and generates a syntax warning for any statement that is not enclosed in a block, that is curly braces <kbd>{</kbd> and <kbd>}</kbd>. For example, the following code will generate a warning for both the <kbd>if</kbd> statement and the <kbd>System.Console.WriteLine</kbd> invocation statement, but the <kbd>while</kbd> statement is not flagged:</p>
<pre>
void Method()<br/>{<br/> while (...)<br/>  if (...)<br/>   System.Console.WriteLine(value);<br/>}
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You will need to have created and opened an analyzer project, say <kbd>CSharpAnalyzers</kbd> in Visual Studio 2017. Refer to the first recipe in this chapter to create this project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In <span class="packt_screen">Solution Explorer</span>, double-click on the <kbd>Resources.resx</kbd> file in <kbd>CSharpAnalyzers</kbd> project to open the resource file in the resource editor.</li>
<li>Replace the existing resource strings for <kbd>AnalyzerDescription</kbd>, <kbd>AnalyzerMessageFormat</kbd> and <kbd>AnalyzerTitle</kbd> with new strings.</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="120" src="assets/50ca5379-4258-4a4b-9d62-a066f1470a0b.png" width="789"/></div>
<ol start="3">
<li>Replace the <kbd>Initialize</kbd> method implementation with the following:</li>
</ol>
<pre style="padding-left: 90px">
public override void Initialize(AnalysisContext context)<br/>{<br/>   context.RegisterSyntaxTreeAction(syntaxTreeContext =&gt;<br/>   {<br/>     // Iterate through all statements in the tree.<br/>     var root = syntaxTreeContext.Tree.GetRoot(syntaxTreeContext.CancellationToken);<br/>     foreach (var statement in root.DescendantNodes().OfType&lt;StatementSyntax&gt;())<br/>     {<br/>       // Skip analyzing block statements.<br/>       if (statement is BlockSyntax)<br/>       {<br/>         continue;<br/>       }<br/><br/>       // Report issue for all statements that are nested within a statement,<br/>       // but not a block statement.<br/>       if (statement.Parent is StatementSyntax &amp;&amp; !(statement.Parent is BlockSyntax))<br/>       {<br/>         var diagnostic = Diagnostic.Create(Rule, statement.GetFirstToken().GetLocation());<br/>         syntaxTreeContext.ReportDiagnostic(diagnostic);<br/>       }<br/>     }<br/>   });<br/>}
</pre>
<ol start="4">
<li>Click on <em>Ctrl</em> + <em>F5</em> to start a new Visual Studio instance with the analyzer enabled.</li>
<li>In the new Visual Studio instance, create a new C# class library with the following code:</li>
</ol>
<pre style="padding-left: 90px">
namespace ClassLibrary<br/>{<br/>  public class Class1<br/>  {<br/>    void Method(bool flag, int value)<br/>    {<br/>      while (flag)<br/>      if (value &gt; 0)<br/>      System.Console.WriteLine(value);<br/>    }<br/>  }<br/>}
</pre>
<ol start="6">
<li>Verify the analyzer diagnostic is neither reported for the method block for <kbd>Method</kbd> nor the <kbd>while</kbd> statement, but is reported for the <kbd>if</kbd> statement and <kbd>System.Console.WriteLine</kbd> invocation statement:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="418" src="assets/19a037fe-9bdb-4204-9dcf-5b2476d657c2.png" width="803"/></div>
<ol start="7">
<li>Now, add curly braces around the <kbd>System.Console.WriteLine</kbd> <span>invocation statement and verify the only single warning is now reported for the</span> <kbd>if</kbd> <span>statement:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="418" src="assets/d48ccb86-abd2-49be-b373-b48cd26e2574.png" width="804"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Syntax tree analyzers register callbacks to analyze syntax of all source files in the compilation. Our analysis works by getting the roots of the syntax tree and then operating on all the descendant syntax nodes of the roots which are of type <kbd>StatementSyntax</kbd>. First, we note that a block statement is itself an aggregate statement, and by definition has curly braces, so we skip past these.</p>
<pre>
// Skip analyzing block statements.<br/>if (statement is BlockSyntax)<br/>{<br/>  continue;<br/>}
</pre>
<p>We then perform syntactic checks for the parent of statement syntax. If the parent of the statement is also a statement, but not a block with curly braces, then we report a diagnostic on the first syntax token of the statement recommending usage of curly braces.</p>
<pre>
// Report issue for all statements that are nested within a statement,<br/>// but not a block statement.<br/>if (statement.Parent is StatementSyntax &amp;&amp; !(statement.Parent is BlockSyntax))<br/>{<br/>  var diagnostic = Diagnostic.Create(Rule, statement.GetFirstToken().GetLocation());<br/>  syntaxTreeContext.ReportDiagnostic(diagnostic);<br/>}
</pre>
<div class="packt_infobox"><kbd>SyntaxTreeAnalysisContext</kbd> provided to syntax tree actions does not expose the semantic model for the source file, hence no semantic analysis can be performed within a syntax tree action.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a method body analyzer to analyze whole method and report issues</h1>
                </header>
            
            <article>
                
<p>A stateful method body or code block analyzer registers action callbacks that require whole method body analysis to report issues about the method declaration or executable code. These analyzers generally need to initialize some mutable state at the start of the analysis, which is updated while analyzing the method body, and the final state is used to report diagnostics.</p>
<p>In this section, we will create a code block analyzer that flags unused method parameters. For example, it will not flag <kbd>param1</kbd> and <kbd>param2</kbd> as unused, but will flag <kbd>param3</kbd> and <kbd>param4</kbd><em>.</em></p>
<pre>
void M(int param1, ref int param2, int param3, params int[] param4)<br/>{<br/> int local1 = param1;<br/> param2 = 0;<br/>}
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You will need to have created and opened an analyzer project, say <kbd>CSharpAnalyzers</kbd> in Visual Studio 2017. Refer to the first recipe in this chapter to create this project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In <span class="packt_screen">Solution Explorer</span>, double-click on <kbd>Resources.resx</kbd> file in <kbd>CSharpAnalyzers</kbd> project to open the resource file in the resource editor.</li>
<li>Replace the existing resource strings for <kbd>AnalyzerDescription</kbd>, <kbd>AnalyzerMessageFormat</kbd> and <kbd>AnalyzerTitle</kbd> with new strings.</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/8e00bba6-4e68-4384-b87c-fb70231c1fc5.png"/></div>
<ol start="3">
<li>Replace the <kbd>Initialize</kbd> method implementation with the code from <kbd>CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/DiagnosticAnalyzer.cs/</kbd> method named <kbd>Initialize</kbd><em>.</em></li>
<li>Add private class <kbd>UnusedParametersAnalyzer</kbd> from <kbd>CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/DiagnosticAnalyzer.cs/</kbd> type named <kbd>UnusedParametersAnalyzer</kbd> in your analyzer to perform the core method body analysis for a given method.</li>
<li>Click on <em>Ctrl</em> + <em>F5</em> to start a new Visual Studio instance with the analyzer enabled.</li>
</ol>
<p> </p>
<ol start="6">
<li>In the new Visual Studio instance, create a new C# class library with the following code:</li>
</ol>
<pre style="padding-left: 90px">
namespace ClassLibrary<br/>{<br/>  public class Class1<br/>  {<br/>    void M(int param1, ref int param2, int param3, params int[] param4)<br/>    {<br/>      int local1 = param1;<br/>      param2 = 0;<br/>    }<br/>  }<br/>}
</pre>
<ol start="7">
<li>Verify the analyzer diagnostic is not reported for <kbd>param1</kbd> and <kbd>param2</kbd>, but is reported for <kbd>param3</kbd> and <kbd>param4</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="399" src="assets/13cb91bb-0028-4ff8-aaf8-0d5b4031ada9.png" width="800"/></div>
<ol start="8">
<li>Now, add code to use <kbd>param3</kbd> in the local declaration statement, delete <kbd>param4</kbd>, and verify the diagnostics go away<span>:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="392" src="assets/bfac07c2-a169-420c-bf00-312f99b4b1ae.png" width="800"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Code block analyzers register code block actions to analyze executable code blocks in the compilation. You can register either a stateless <kbd>CodeBlockAction</kbd> or a stateful <kbd>CodeBlockStartAction</kbd> with nested actions to analyze syntax nodes within a code block. Our analyzer registers a <kbd>CodeBlockStartAction</kbd> to perform stateful analysis.</p>
<pre>
 context.RegisterCodeBlockStartAction&lt;SyntaxKind&gt;(startCodeBlockContext =&gt;<br/> {<br/>  ...<br/> }
</pre>
<p>Analysis begins with a couple of early bail out checks: we are only interested in analyzing executable code within a method body and methods that have at least one parameter.</p>
<pre>
  // We only care about method bodies.<br/>  if (startCodeBlockContext.OwningSymbol.Kind != SymbolKind.Method)<br/>  {<br/>    return;<br/>  }<br/><br/>  // We only care about methods with parameters.<br/>  var method = (IMethodSymbol)startCodeBlockContext.OwningSymbol;<br/>  if (method.Parameters.IsEmpty)<br/>  {<br/>    return;<br/>  }
</pre>
<p>We allocate a new <kbd>UnusedParametersAnalyzer</kbd> instance for every method to be analyzed. A constructor of this type initializes the mutable state tracked for analysis (explained later):</p>
<pre>
  // Initialize local mutable state in the start action.<br/>  var analyzer = new UnusedParametersAnalyzer(method);
</pre>
<p>We then register a nested syntax node action, <kbd>UnusedParametersAnalyzer.AnalyzeSyntaxNode</kbd><em>,</em> on the given code block context for the given method. We register interest in analyzing <kbd>IdentifierName</kbd> syntax nodes within the code block:</p>
<pre>
// Register an intermediate non-end action that accesses and modifies the state. startCodeBlockContext.RegisterSyntaxNodeAction(analyzer.AnalyzeSyntaxNode, SyntaxKind.IdentifierName);
</pre>
<p>Finally, we register a nested <kbd>CodeBlockEndAction</kbd> to be executed on the instance of <kbd>UnusedParametersAnalyzer</kbd> at the end of the code block analysis.</p>
<pre>
// Register an end action to report diagnostics based on the final state. startCodeBlockContext.RegisterCodeBlockEndAction(analyzer.CodeBlockEndAction);
</pre>
<div class="packt_infobox">Nested end actions are always guaranteed to be executed <em>after</em> all the nested non-end actions registered on the same analysis context have finished executing.</div>
<p>Let's now understand the working of the core <kbd>UnusedParametersAnalyzer</kbd> type to analyze a specific code block. This analyzer defines mutable state fields to track parameters (and their names) that are considered to be unused:</p>
<pre>
  #region Per-CodeBlock mutable state<br/>  private readonly HashSet&lt;IParameterSymbol&gt; _unusedParameters;<br/>  private readonly HashSet&lt;string&gt; _unusedParameterNames;<br/>  #endregion
</pre>
<p>We initialize this mutable state in the constructor of the analyzer. At the start of the analysis, we filter out implicitly declared parameters and parameters with no source locations - these are never considered to be redundant. We mark the remaining parameters as unused.</p>
<pre>
  #region State intialization<br/>  public UnusedParametersAnalyzer(IMethodSymbol method)<br/>  {<br/>    // Initialization: Assume all parameters are unused, except for:<br/>    //  1. Implicitly declared parameters<br/>    //  2. Parameters with no locations (example auto-generated parameters for accessors)<br/>    var parameters = method.Parameters.Where(p =&gt; !p.IsImplicitlyDeclared &amp;&amp; p.Locations.Length &gt; 0);<br/>    _unusedParameters = new HashSet&lt;IParameterSymbol&gt;(parameters);<br/>    _unusedParameterNames = new HashSet&lt;string&gt;(parameters.Select(p =&gt; p.Name));<br/>  }<br/>  #endregion
</pre>
<p><kbd>AnalyzeSyntaxNode</kbd> has been registered as a nested syntax node action to analyze all <kbd>IdentifierName</kbd> nodes within the code block. We perform a couple of quick checks at the start of the method and bail out of analysis if (a) We have no unused parameters in our current analysis state, or (b) The identifier name doesn't match any of the unused parameter names. The latter check is done to avoid the performance hit of attempting to compute symbol info for the identifier.</p>
<pre>
  #region Intermediate actions<br/>  public void AnalyzeSyntaxNode(SyntaxNodeAnalysisContext context)<br/>  {<br/>    // Check if we have any pending unreferenced parameters.<br/>    if (_unusedParameters.Count == 0)<br/>    {<br/>      return;<br/>    }<br/><br/>    // Syntactic check to avoid invoking GetSymbolInfo for every identifier.<br/>    var identifier = (IdentifierNameSyntax)context.Node;<br/>    if (!_unusedParameterNames.Contains(identifier.Identifier.ValueText))<br/>    {<br/>      return;<br/>    }
</pre>
<p>Then, we use the semantic model APIs to get semantic symbol info for the identifier name and check if it binds to one of the parameters that is currently considered unused. If so, we remove this parameter (and it's name) from the unused set.</p>
<pre>
    // Mark parameter as used.<br/>    var parmeter = context.SemanticModel.GetSymbolInfo(identifier, context.CancellationToken).Symbol as IParameterSymbol;<br/>    if (parmeter != null &amp;&amp; _unusedParameters.Contains(parmeter))<br/>    {<br/>      _unusedParameters.Remove(parmeter);<br/>      _unusedParameterNames.Remove(parmeter.Name);<br/>    }<br/>  }<br/>  #endregion
</pre>
<p>Finally, the registered code block end action walks through all the remaining parameters in the unused set and flags them as unused parameters.</p>
<pre>
  #region End action<br/>  public void CodeBlockEndAction(CodeBlockAnalysisContext context)<br/>  {<br/>    // Report diagnostics for unused parameters.<br/>    foreach (var parameter in _unusedParameters)<br/>    {<br/>      var diagnostic = Diagnostic.Create(Rule, parameter.Locations[0], parameter.Name, parameter.ContainingSymbol.Name);<br/>      context.ReportDiagnostic(diagnostic);<br/>    }<br/>  }<br/> #endregion
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a compilation analyzer to analyze whole compilation and report issues</h1>
                </header>
            
            <article>
                
<p>A stateful compilation analyzer registers action callbacks that require compilation-wide analysis of symbols and/or syntax to report issues about declarations or executable code in the compilation. These analyzers generally need to initialize some mutable state at the start of the analysis, which is updated while analyzing the compilation, and the final state is used to report diagnostics.</p>
<p>In this section, we will create an analyzer that performs compilation-wide analysis and reports. Diagnostic secure types must not implement interfaces with insecure methods for the following scenarios:</p>
<ul>
<li>Assume we have an interface, say <kbd>MyNamespace.ISecureType</kbd>, which is a well-known secure interface, i.e. it is a marker for all secure types in an assembly<em>.</em></li>
<li>Assume we have a method attribute, say <kbd>MyNamespace.InsecureMethodAttribute</kbd><em>,</em> which marks the method on which the attribute is applied as insecure. An interface which has any member with such an attribute, must be considered insecure.</li>
<li>We want to report diagnostics for types implementing the well-known secure interface that also implements any insecure interfaces.</li>
</ul>
<p>Analyzer performs compilation-wide analysis to detect such violating types and reports diagnostics for them in the compilation end action.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You will need to have created and opened an analyzer project, say <kbd>CSharpAnalyzers</kbd> in Visual Studio 2017. Refer to the first recipe in this chapter to create this project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In <span class="packt_screen">Solution Explorer</span>, double click on <kbd>Resources.resx</kbd> file in <kbd>CSharpAnalyzers</kbd> project to open the resource file in the resource editor.</li>
<li>Replace the existing resource strings for <kbd>AnalyzerDescription</kbd>, <kbd>AnalyzerMessageFormat</kbd> and <kbd>AnalyzerTitle</kbd> with new strings.</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/4fbcc7c0-2864-459d-939d-460b9fc28ae0.png"/></div>
<ol start="3">
<li>Replace the <kbd>Initialize</kbd> method implementation with the code from <kbd>CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/DiagnosticAnalyzer.cs/</kbd> method named <kbd>Initialize</kbd><em><em>.</em></em></li>
</ol>
<p> </p>
<ol start="4">
<li>Add a private class <kbd>CompilationAnalyzer</kbd> from <kbd>CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/DiagnosticAnalyzer.cs/</kbd> type named <kbd>CompilationAnalyzer</kbd> in your analyzer to perform the core method body analysis for a given method.</li>
<li>Click on <em>Ctrl</em> + <em>F5</em> to start a new Visual Studio instance with the analyzer enabled.</li>
<li>In the new Visual Studio instance, enable full solution analysis for C# projects by following the steps here: <a href="https://msdn.microsoft.com/en-us/library/mt709421.aspx">https://msdn.microsoft.com/en-us/library/mt709421.aspx</a></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="331" src="assets/ddcca190-41a4-4447-a097-de7de89802d6.png" width="567"/></div>
<ol start="7">
<li>In the new Visual Studio instance, create a new C# class library with the following code:</li>
</ol>
<pre style="padding-left: 90px">
namespace MyNamespace<br/>{<br/>  public class InsecureMethodAttribute : System.Attribute { }<br/><br/>  public interface ISecureType { }<br/><br/>  public interface IInsecureInterface<br/>  {<br/>    [InsecureMethodAttribute]<br/>    void F();<br/>  }<br/><br/>  class MyInterfaceImpl1 : IInsecureInterface<br/>  {<br/>    public void F() {}<br/>  }<br/><br/>  class MyInterfaceImpl2 : IInsecureInterface, ISecureType<br/>  {<br/>    public void F() {}<br/>  }<br/><br/>  class MyInterfaceImpl3 : ISecureType<br/>  {<br/>    public void F() {}<br/>  }<br/>}
</pre>
<ol start="8">
<li>Verify the analyzer diagnostic is not reported for <kbd>MyInterfaceImpl1</kbd> and <kbd>MyInterfaceImpl</kbd><em>3</em>, but is reported for <kbd>MyInterfaceImpl2</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="405" src="assets/532fc9dd-d8c3-4f1b-94dd-b02f5ee9170a.png" width="800"/></div>
<ol start="9">
<li>Now, change <kbd>MyInterfaceImpl2</kbd> so that it no longer implements <kbd>IInsecureInterface</kbd> and verify that the diagnostic is no longer reported.</li>
</ol>
<pre style="padding-left: 90px">
class MyInterfaceImpl2 : ISecureType<br/>{<br/>  public void F() {}<br/>}
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Compilation analyzers register compilation actions to analyze symbols and/or syntax nodes in the compilation. You can register either a stateless <kbd>CompilationAction</kbd> or a stateful <kbd>CompilationStartAction</kbd> with nested actions to analyze <span>symbols and/or</span> syntax nodes within a compilation. Our analyzer registers a <kbd>CompilationStartAction</kbd> to perform stateful analysis.</p>
<pre>
context.RegisterCompilationStartAction(compilationContext =&gt;<br/>{<br/> ...<br/>}
</pre>
<p>Analysis begins with a couple of early bail out checks: we are only interested in analyzing compilations which have source or metadata types by name <kbd>MyNamespace.ISecureType</kbd> and <kbd>MyNamespace.InsecureMethodAttribute</kbd>.</p>
<pre>
 // Check if the attribute type marking insecure methods is defined.<br/> var insecureMethodAttributeType = compilationContext.Compilation.GetTypeByMetadataName("MyNamespace.InsecureMethodAttribute");<br/> if (insecureMethodAttributeType == null)<br/> {<br/>   return;<br/> }<br/><br/> // Check if the interface type marking secure types is defined.<br/> var secureTypeInterfaceType = compilationContext.Compilation.GetTypeByMetadataName("MyNamespace.ISecureType");<br/> if (secureTypeInterfaceType == null)<br/> {<br/>   return;<br/> }
</pre>
<p>We allocate a new <kbd>CompilationAnalyzer</kbd> instance for compilations to be analyzed. A constructor of this type initializes the mutable and immutable state tracked for analysis (explained later).</p>
<pre>
// Initialize state in the start action.<br/>var analyzer = new CompilationAnalyzer(insecureMethodAttributeType, secureTypeInterfaceType);
</pre>
<p>We then register a nested symbol action, <kbd>CompilationAnalyzer.AnalyzeSymbol</kbd>, on the given compilation start context for the given compilation. We register interest in analyzing type and method symbols within the compilation.</p>
<pre>
// Register an intermediate non-end action that accesses and modifies the state. compilationContext.RegisterSymbolAction(analyzer.AnalyzeSymbol, SymbolKind.NamedType, SymbolKind.Method);
</pre>
<p>Finally, we register a nested <kbd>CompilationEndAction</kbd> to be executed on the instance of <kbd>CompilationAnalyzer</kbd> at the end of the compilation analysis.</p>
<pre>
// Register an end action to report diagnostics based on the final state. compilationContext.RegisterCompilationEndAction(analyzer.CompilationEndAction);
</pre>
<div class="packt_infobox">Nested compilation end actions are always guaranteed to be executed <em>after</em> all the nested non-end actions registered on the same analysis context have finished executing.</div>
<p>Let's now understand the working of the core <kbd>CompilationAnalyzer</kbd> type to analyze a specific compilation. This analyzer defines an immutable state for type symbols corresponding to the secure interface and insecure method attribute. It also defines mutable state fields to track the set of types defined in the compilation that implement the secure interface and a set of interfaces defined in the compilation that have methods with an insecure method attribute.</p>
<pre>
#region Per-Compilation immutable state<br/> private readonly INamedTypeSymbol _insecureMethodAttributeType;<br/> private readonly INamedTypeSymbol _secureTypeInterfaceType;<br/>#endregion<br/><br/>#region Per-Compilation mutable state<br/> /// &lt;summary&gt;<br/> /// List of secure types in the compilation implementing secure interface.<br/> /// &lt;/summary&gt;<br/> private List&lt;INamedTypeSymbol&gt; _secureTypes;<br/><br/> /// &lt;summary&gt;<br/> /// Set of insecure interface types in the compilation that have methods with an insecure method attribute.<br/> /// &lt;/summary&gt;<br/> private HashSet&lt;INamedTypeSymbol&gt; _interfacesWithInsecureMethods; <br/>#endregion
</pre>
<p>At the start of the analysis, we initialize the set of secure types and interfaces with insecure methods to be empty.</p>
<pre>
#region State intialization<br/> public CompilationAnalyzer(INamedTypeSymbol insecureMethodAttributeType, INamedTypeSymbol secureTypeInterfaceType)<br/>{<br/>  _insecureMethodAttributeType = insecureMethodAttributeType;<br/>  _secureTypeInterfaceType = secureTypeInterfaceType;<br/><br/>  _secureTypes = null;<br/>  _interfacesWithInsecureMethods = null;<br/> }<br/>#endregion
</pre>
<p><kbd>AnalyzeSymbol</kbd> is registered as a nested symbol action to analyze all types and methods within the compilation. For every type declaration in the compilation, we check whether it implements the secure interface, and if so, add it to our set of secure types. For every method declaration in the compilation, we check whether its containing type is an interface and the method has the insecure method attribute, and if so, add the containing interface type to our set of interface types with insecure methods.</p>
<pre>
  #region Intermediate actions<br/>  public void AnalyzeSymbol(SymbolAnalysisContext context)<br/>  {<br/>    switch (context.Symbol.Kind)<br/>    {<br/>      case SymbolKind.NamedType:<br/>      // Check if the symbol implements "_secureTypeInterfaceType".<br/>      var namedType = (INamedTypeSymbol)context.Symbol;<br/>      if (namedType.AllInterfaces.Contains(_secureTypeInterfaceType))<br/>      {<br/>        _secureTypes = _secureTypes ?? new List&lt;INamedTypeSymbol&gt;();<br/>        _secureTypes.Add(namedType);<br/>      }<br/><br/>      break;<br/><br/>      case SymbolKind.Method:<br/>      // Check if this is an interface method with "_insecureMethodAttributeType" attribute.<br/>      var method = (IMethodSymbol)context.Symbol;<br/>      if (method.ContainingType.TypeKind == TypeKind.Interface &amp;&amp; method.GetAttributes().Any(a =&gt; a.AttributeClass.Equals(_insecureMethodAttributeType)))<br/>      {<br/>        _interfacesWithInsecureMethods = _interfacesWithInsecureMethods ?? new HashSet&lt;INamedTypeSymbol&gt;();<br/>        _interfacesWithInsecureMethods.Add(method.ContainingType);<br/>      }<br/><br/>      break;<br/>    }<br/>  }<br/>  #endregion
</pre>
<p>Finally, the registered the compilation end action uses the final state at the end of compilation analysis to report diagnostics. Analysis in this action starts by bailing out early if we either have no secure types or no interfaces with insecure methods. Then, we walk through all secure types and all interfaces with insecure methods, and for every pair. check whether the secure type or any of its base types implements the insecure interface. If so, we report a diagnostic on the secure type.</p>
<pre>
   #region End action<br/>   public void CompilationEndAction(CompilationAnalysisContext context)<br/>   {<br/>     if (_interfacesWithInsecureMethods == null || _secureTypes == null)<br/>     {<br/>       // No violating types.<br/>       return;<br/>     }<br/><br/>     // Report diagnostic for violating named types.<br/>     foreach (var secureType in _secureTypes)<br/>     {<br/>       foreach (var insecureInterface in _interfacesWithInsecureMethods)<br/>       {<br/>         if (secureType.AllInterfaces.Contains(insecureInterface))<br/>         {<br/>           var diagnostic = Diagnostic.Create(Rule, secureType.Locations[0], secureType.Name, "MyNamespace.ISecureType", insecureInterface.Name);<br/>       context.ReportDiagnostic(diagnostic);<br/><br/>           break;<br/>         }<br/>       }<br/>     }<br/>   }<br/>   #endregion
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing unit tests for an analyzer project</h1>
                </header>
            
            <article>
                
<p>In this section, we will show you how to write and execute unit tests for an analyzer project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>You will need to have created and opened an analyzer project, say</span> <kbd>CSharpAnalyzers</kbd> <span>in Visual Studio 2017. Refer to the first recipe in this chapter to create this project.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol start="1">
<li>Open UnitTests.cs in the <kbd>CSharpAnalyzers.Test</kbd> project in the <span class="packt_screen">Solution Explorer</span> solution to view the default unit tests created for the default symbol analyzer (type names should not contain lowercase letters) for the template analyzer project.</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="276" src="assets/7968ef6e-c4f5-4f16-81ec-759165b887d2.png" width="309"/></div>
<ol start="2">
<li>Navigate to <span class="packt_screen">Test</span> | <span class="packt_screen">Windows</span> | <span class="packt_screen">Test Window</span> to open the <span class="packt_screen">Test Explorer</span> window to view the unit tests in the project. Default analyzer project has two unit tests:
<ul>
<li><kbd>TestMethod1</kbd>: This tests the scenario where analyzer diagnostic does not fire on the test code and</li>
<li><kbd>TestMethod2</kbd>: This tests the scenario where analyzer diagnostic does fire on the test code.</li>
</ul>
</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="418" src="assets/0a6370b3-cdf3-459a-b787-ca1674514e1f.png" width="732"/></div>
<div class="packt_infobox">Note that the unit test project contains unit tests for both the DiagnosticAnalyzer and CodeFixProvider. This chapter deals with analyzer testing only. We will expand on the unit tests for the CodeFixProvider later in this book.</div>
<ol start="3">
<li>Run all the unit tests for the project by right-clicking <span class="packt_screen">Not Run tests</span> node in the <span class="packt_screen">Test Explorer</span>, executing the <span class="packt_screen">Run selected tests</span> context menu command, and verify that the tests pass.</li>
</ol>
<p> </p>
<ol start="4">
<li>Edit <kbd>TestMethod1</kbd> so that the test code now has a type with lower-case letters:</li>
</ol>
<pre style="padding-left: 90px">
[TestMethod]<br/>public void TestMethod1()<br/>{<br/>  var test = @"<strong>class Class1 { }</strong>";<br/><br/>  VerifyCSharpDiagnostic(test);<br/>}
</pre>
<ol start="5">
<li>Right-click on <kbd>TestMethod1</kbd> in the editor, execute the <span class="packt_screen">Run tests</span> context menu command, and verify that the test now fails with the diagnostic mismatch assert - <kbd>expected "0" actual "1"</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="514" src="assets/b151333e-80c8-45c6-b17e-908bbcaef64e.png" width="800"/></div>
<ol start="6">
<li>Edit <kbd>TestMethod1</kbd> to now add an excepted diagnostic for the new test code:</li>
</ol>
<pre style="padding-left: 90px">
var expected = new DiagnosticResult<br/>{<br/>  Id = "CSharpAnalyzers",<br/>  Message = String.Format("Type name '{0}' contains lowercase letters", "Class1"),<br/>  Severity = DiagnosticSeverity.Warning,<br/>  Locations = new[] {<br/>    new DiagnosticResultLocation("Test0.cs", 11, 15)<br/>  }<br/>};<br/><br/>VerifyCSharpDiagnostic(test, expected);
</pre>
<ol start="7">
<li>Run the unit test again and note that the test still fails, but now it fails due to a difference in the location (column number) at which the diagnostic was reported.</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="405" src="assets/d6d79d20-cf18-40ab-9f0a-1d6dfacbac8a.png" width="800"/></div>
<ol start="8">
<li>Edit the diagnostic location to use the correct expected column number and rerun the test - verify that the test passes now.</li>
</ol>
<pre style="padding-left: 90px">
new DiagnosticResultLocation("Test0.cs", 11, <strong>7</strong>)
</pre>
<ol start="9">
<li>Edit <kbd>TestMethod1</kbd> and change the test code to rename <kbd>Class1</kbd> to <kbd>CLASS1</kbd>:</li>
</ol>
<pre style="padding-left: 90px">
var test = @"class <strong>CLASS1</strong> { }";
</pre>
<ol start="10">
<li>Run the unit test again and verify that the test fails now due to a diagnostic mismatch assert - <kbd>expected "1" actual "0"</kbd>.</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="449" src="assets/364e25f7-e9c6-4ef6-bcf3-65e7d9e6c899.png" width="801"/></div>
<ol start="11">
<li>Edit <kbd>TestMethod1</kbd> to remove the expected diagnostic and verify the test passes:</li>
</ol>
<pre style="padding-left: 90px">
 var test = @"class CLASS1 { }";<br/><br/> VerifyCSharpDiagnostic(test);
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The analyzer unit test project allows us to write unit tests for the execution of our analyzer on different code samples. Each unit test is marked with a <kbd>TestMethod</kbd> attribute and defines sample test code, expected diagnostic(s) reported by the analyzer on that code (if any), and invocation of test helper method(s), here <kbd>VerifyCSharpDiagnostic</kbd><em>,</em> to verify diagnostics.</p>
<pre style="padding-left: 30px">
//No diagnostics expected to show up<br/>[TestMethod]<br/>public void TestMethod1()<br/>{<br/>  var test = @"";<br/><br/>  VerifyCSharpDiagnostic(test);<br/>}
</pre>
<p>Unit tests can define expected diagnostics using the <kbd>DiagnosticResult</kbd> type, which must specify the diagnostic <kbd>Id</kbd>, <kbd>Message</kbd>, <kbd>Severity</kbd> and <kbd>Locations</kbd> for the diagnostic:</p>
<pre>
var expected = new DiagnosticResult<br/>{<br/>  Id = "CSharpAnalyzers",<br/>  Message = String.Format("Type name '{0}' contains lowercase letters", "Class1"),<br/>  Severity = DiagnosticSeverity.Warning,<br/>  Locations = new[] { new DiagnosticResultLocation("Test0.cs", 11, 15) }<br/>};<br/><br/>VerifyCSharpDiagnostic(test, expected);
</pre>
<div class="packt_tip">Computing the correct line number and column number for an expected diagnostic, for example (11, 15), can be a bit tricky. The approach that normally works is to start with a default location of (0, 0), execute the test once, and look at the failure text in the Test Explorer window to get the expected and actual line number. Then, replace the expected line number in the test code with the actual line number. Re-execute the test and repeat the process to get the correct column number.</div>
<p><kbd>UnitTest</kbd> type containing all the unit tests also overrides the following methods to return the <kbd>DiagnosticAnalyzer</kbd> (and optionally a <kbd>CodeFixProvider</kbd>) to be tested:</p>
<pre>
 protected override CodeFixProvider GetCSharpCodeFixProvider()<br/> {<br/>   return new CSharpAnalyzersCodeFixProvider();<br/> }<br/><br/> <strong>protected override DiagnosticAnalyzer GetCSharpDiagnosticAnalyzer()</strong><br/> {<br/>   return new CSharpAnalyzersAnalyzer();<br/> }
</pre>
<p>Now, let us expand a bit more on the test framework helpers for the unit tests. The analyzer unit test project contains two primary helper abstract types to write unit tests for analyzers and code fixes:</p>
<ul>
<li><kbd>DiagnosticVerifier</kbd><strong>:</strong> Contains helper methods to run <kbd>DiagnosticAnalyzer</kbd> unit tests that verify the analyzer diagnostics for a given set of test sources.</li>
<li><kbd>CodeFixVerifier</kbd>: Contains helper methods to run <kbd><span>DiagnosticAnalyzer</span></kbd> and <kbd>CodeFixProvider</kbd> unit tests that verify the analyzer diagnostics for a <span>given set of test sources before and after applying a code fix. This type derives from</span> <kbd>DiagnosticVerifier</kbd><span>.</span></li>
</ul>
<p>In the default analyzer project, <kbd>UnitTest</kbd> type derives from <kbd>CodeFixVerifier</kbd>, but could also be changed to derive from <kbd>DiagnosticVerifier</kbd><em>,</em> if you are only interested in writing analyzer unit tests. We will just focus on the <kbd>DiagnosticVerifier</kbd> here; <kbd>CodeFixVerifier</kbd> is covered later in chapter<em><strong>.</strong></em></p>
<p><kbd>DiagnosticVerifier</kbd> type is split into 2 source files <kbd>DiagnosticVerifier.cs</kbd> and <kbd>DiagnosticVerifier.Helper.cs</kbd><em>.</em></p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="315" src="assets/b642ab13-ec95-410a-bde9-7cc2d0cf7a52.png" width="799"/></div>
<ul>
<li><kbd>DiagnosticVerifier.Helper.cs</kbd> contains the following core functionality:
<ul>
<li>Helper methods to create a compilation with source files based on given C# or VisualBasic source code (<span class="packt_screen">Set up compilation and documents</span> region in the preceding screenshot).</li>
<li>Helper methods to invoke the preceding functionality to create a compilation with the given C# or VisualBasic <span>source code, and execute the given</span> <kbd>DiagnosticAnalyzer</kbd> <span>on the compilation to produce analyzer diagnostics and return sorted diagnostics for verification (</span><span class="packt_screen">Get Diagnostics</span> <span>region in the preceding screenshot).</span></li>
</ul>
</li>
<li><kbd>DiagnosticVerifier.cs</kbd> contains the following core functionality:
<ul>
<li>Method(s) to get the <kbd>DiagnosticAnalyzer</kbd> type to be tested (<span class="packt_screen">To be implemented by Test classes</span> <span>region</span> in the preceding screenshot).</li>
<li>Private helpers to perform actual diagnostic comparison and verification and formatting of diagnostics to get a string representation of actual/expected diagnostics when a unit test fails (<span class="packt_screen">Actual comparisons and verifications</span> <span>region and</span> <span class="packt_screen">Formatting Diagnostics</span> <span>region</span> in the preceding screenshot).</li>
<li>Diagnostic verification methods <kbd>VerifyCSharpDiagnostic</kbd> and <kbd>VerifyBasicDiagnostic</kbd> that can be invoked by the unit tests to verify analyzer diagnostics generated on the given C# or Visual Basic source code (<span class="packt_screen">Verifier wrappers</span> section in the preceding screenshot). These methods invoke the <span class="packt_screen">Get Diagnostics</span> helpers to create a compilation and get sorted analyzer diagnostics and then invoke the preceding private helpers to compare and verify diagnostics.</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Live Unit testing is a new feature in <em>Visual Studio 2017</em> Enterprise Edition, which <span>automatically runs the impacted unit tests in the background as you edit code, and visualizes the results and code coverage live, in the editor, in real-time. Refer to <a href="eb1b605b-117f-4adf-a111-cfb686799929.xhtml">Chapter 6</a><em>, Live Unit Testing in Visual Studio Enterprise</em></span>, <span>to enable live unit testing for the project and visualize unit tests automatically executing after you edit the code in the steps in this recipe.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Publishing NuGet package and VSIX for an analyzer project</h1>
                </header>
            
            <article>
                
<p>We will show you how to configure, build, and publish a NuGet package and a VSIX package for an analyzer project created in Visual Studio 2017 using the .NET Compiler platform SDK.</p>
<p>Before we start digging into these topics, let's understand the difference between NuGet-based analyzer packages and VSIX-based analyzer packages. NuGet and VSIX are basically two different packaging schemes for the Microsoft development platform to package files such as assemblies, resources, build targets, tools, and so on, into a single installable package.</p>
<ul>
<li>NuGet is a more generic packaging scheme. NuGet packages (<kbd>.nupkg</kbd> files) can be directly referenced in .NET projects and installed to a specific project or solution using the NuGet package manager in Visual Studio. Analyzer NuGet packages based on the analyzer template project get installed as AnalyzerReferences in the project file, and then get passed onto the compiler command line to be executed during build. Additionally, AnalyzerReferences are resolved at design time by the Visual Studio IDE and executed while code editing to generate live diagnostics.</li>
<li>A VSIX package is a <kbd>.vsix</kbd> file that contains one or more Visual Studio extensions, together with the metadata Visual Studio uses to classify and install the extensions. An analyzer VSIX package can be installed machine-wide or to a specific extension hive, and is enabled for all projects/solutions opened from the Visual Studio hive. Unlike a <kbd>NuGet</kbd> package, it cannot be installed specifically to a project/solution and does not travel along with the project sources.</li>
</ul>
<div class="packt_infobox">As of Visual Studio 2017, analyzers installed as <kbd>AnalyzerReferences</kbd> via NuGet packages execute during both: command line builds and live code editing in Visual Studio. Analyzers installed via Analyzer VSIX packages execute only during live code editing in Visual Studio and not during project build. Hence, only analyzer NuGet packages can be configured to execute in continuous integration (CI) build systems and break the build.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>You will need to have created and opened an analyzer project, say</span> <kbd>CSharpAnalyzers</kbd> <span>in Visual Studio 2017. Refer to the first recipe in this chapter to create this project.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol start="1">
<li>Build <kbd>CSharpAnalyzers</kbd> solution in Visual Studio by executing the <span class="packt_screen">Build</span> | <span class="packt_screen">Build Solution</span> command.</li>
<li>Open the binary output folder for the <kbd>CSharpAnalyzers</kbd> project (<kbd>&lt;%SolutionFolder%&gt;\CSharpAnalyzers\bin\debug</kbd>) in Windows Explorer and verify that the NuGet package for the analyzer named, <kbd>CSharpAnalyzers.1.0.X.Y.nupkg</kbd>, is generated in the folder.</li>
<li>Double<em>-</em>click on the <kbd>Diagnostic.nuspec</kbd> file in the <kbd>CSharpAnalyzers</kbd> project in <span class="packt_screen">Solution Explorer</span> to view and configure the properties of the nupkg.</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="395" src="assets/4e45c11e-5f9e-4379-b39a-50e9a0c0af40.png" width="801"/></div>
<ol start="4">
<li>Rebuild the project to regenerate the nupkg with new properties.</li>
<li>Publish the nupkg as a public or private package by following the steps listed here: <a href="https://docs.microsoft.com/en-us/nuget/create-packages/publish-a-package">https://docs.microsoft.com/en-us/nuget/create-packages/publish-a-package</a>.</li>
</ol>
<p> </p>
<ol start="6">
<li>Open the binary output folder for the <kbd>CSharpAnalyzers.Vsix</kbd> project (<kbd>&lt;%SolutionFolder%\CSharpAnalyzers.Vsix\bin\debug</kbd>) in Windows Explorer and verify that VSIX for the analyzer named, <kbd>CSharpAnalyzers.Vsix.vsix</kbd>, is present in the folder.</li>
<li>Double-click on the <kbd>source.extension.vsixmanifest</kbd> file in the <kbd>CSharpAnalyzers.Vsix</kbd> <span>project in the <span class="packt_screen">Solution Explorer</span> to view and configure the properties of the VSIX package.</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="395" src="assets/a078be13-99a0-4e17-ae52-6d3f77675ed4.png" width="800"/></div>
<ol start="8">
<li>Rebuild the VSIX project to regerate the VSIX.</li>
<li>Publish it to the Visual Studio Extension Gallery by following the steps listed here: <a href="https://msdn.microsoft.com/en-us/library/ff728613.aspx">https://msdn.microsoft.com/en-us/library/ff728613.aspx</a>.</li>
</ol>


            </article>

            
        </section>
    </body></html>