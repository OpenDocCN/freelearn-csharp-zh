- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Real-Time Messaging with SignalR
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SignalR 进行实时消息传递
- en: Now that we’ve created various tests, added telemetry data, monitored the solution,
    and scaled our services, starting with this chapter, we’ll continue creating services
    and using different communication technologies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了各种测试，添加了遥测数据，监控了解决方案，并扩展了我们的服务，从本章开始，我们将继续创建服务和使用不同的通信技术。
- en: In this chapter, we’ll use ASP.NET Core SignalR. SignalR is a technology that
    allows us to send real-time information from services to clients. The client initiates
    a connection to the service, which is then kept alive to send messages to the
    clients as information becomes available.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 ASP.NET Core SignalR。SignalR 是一种技术，它允许我们从服务向客户端发送实时信息。客户端向服务发起连接，然后保持连接状态，以便在信息可用时向客户端发送消息。
- en: 'In this chapter, you’ll learn how to do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Create a SignalR service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 SignalR 服务
- en: Send real-time information to clients
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向客户端发送实时信息
- en: Create a SignalR client
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 SignalR 客户端
- en: Use Azure SignalR Service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure SignalR 服务
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, like the previous chapters, you’ll need an Azure subscription
    and Docker Desktop.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，就像之前的章节一样，你需要 Azure 订阅和 Docker Desktop。
- en: 'The code for this chapter can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/)。
- en: The `ch13` folder contains this chapter’s projects, as well as their results.
    To add the functionality from this chapter, you can start with the source code
    from the previous chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`ch13` 文件夹包含本章的项目及其结果。要添加本章的功能，你可以从上一章的源代码开始。'
- en: 'The projects we’ll be considering are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑的项目如下：
- en: '`Codebreaker.AppHost`: The .NET Aspire host project. The app model has been
    enhanced by an additional project running a SignalR hub and using Azure SignalR
    Service.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.AppHost`：这是 .NET Aspire 主项目。通过运行 SignalR 中心并使用 Azure SignalR 服务，应用程序模型得到了增强。'
- en: '`Codebreaker.Live`: This is a new project that hosts minimal APIs invoked by
    the `game-apis` service and the SignalR hub.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.Live`：这是一个新项目，它托管由 `game-apis` 服务和 SignalR 中心调用的最小 API。'
- en: '`Codebreaker.GameAPIs`: This project has been enhanced and can forward completed
    games to `live-service`.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GameAPIs`：该项目已得到增强，可以将完成的游戏转发到 `live-service`。'
- en: '`LiveTestClient`: This is a new console application that registers with the
    SignalR hub to receive completed games.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LiveTestClient`：这是一个新的控制台应用程序，它注册到 SignalR 中心以接收完成的游戏。'
- en: Creating a SignalR service
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 SignalR 服务
- en: 'In this chapter, we’ll create a new service that offers real-time information
    to return games that are played to every connected client. *Figure 13**.1* shows
    how the services of the solution collaborate:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个新的服务，该服务为每个连接的客户端提供正在玩的游戏的实时信息。*图 13.1* 展示了解决方案中服务的协作方式：
- en: '![Figure 13.1 – Codebreaker services](img/B21217_13_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – Codebreaker 服务](img/B21217_13_01.jpg)'
- en: Figure 13.1 – Codebreaker services
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – Codebreaker 服务
- en: The `game-apis` service has existed since [*Chapter 2*](B21217_02.xhtml#_idTextAnchor031).
    The client of `game-apis` invokes the REST API to start games and set moves. What’s
    new is Codebreaker’s `live-service`. This service offers a simple REST API that’s
    invoked by the `game-apis` service every time a game completes. The main functionality
    of this service makes use of ASP.NET Core SignalR to offer real-time information
    to all connected clients. Clients need to subscribe before they can receive game
    completion messages.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`game-apis` 服务自[*第 2 章*](B21217_02.xhtml#_idTextAnchor031)以来就存在了。`game-apis`
    的客户端通过 REST API 启动游戏并设置移动。新的内容是 Codebreaker 的 `live-service`。该服务提供了一个简单的 REST
    API，每次游戏完成后，`game-apis` 服务都会调用它。该服务的主要功能是利用 ASP.NET Core SignalR 向所有连接的客户端提供实时信息。客户端需要在接收游戏完成消息之前进行订阅。'
- en: What’s offered by SignalR? As connections can never be started from a server
    to a client, and this is also true of SignalR, a client needs to connect to the
    SignalR service and subscribe to receive real-time information. The connection
    stays open, which allows the service to send information to the clients.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 提供了什么？由于连接永远不能从服务器开始到客户端，SignalR 也是如此，因此客户端需要连接到 SignalR 服务并订阅以接收实时信息。连接保持打开状态，这使得服务可以向客户端发送信息。
- en: ASP.NET Core SignalR makes use of **WebSockets** if this technology is available
    – but the programming model with SignalR is a lot easier than using WebSockets
    directly. Contrary to HTTP, with WebSockets, the connection that’s initiated by
    the client stays open, which allows the service to send messages when these are
    available.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core SignalR 如果这项技术可用，将使用 **WebSockets** ——但使用 SignalR 的编程模型比直接使用 WebSocket
    要简单得多。与 HTTP 相反，使用 WebSocket 时，由客户端发起的连接保持打开，这允许服务在有消息可用时发送消息。
- en: WebSockets isn’t always available and can be disabled by a proxy or a firewall
    and are not available everywhere. For example, **Azure Front Door** doesn’t support
    WebSockets at this time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 并非总是可用，可能被代理或防火墙禁用，并且并非在所有地方都可用。例如，**Azure Front Door** 目前不支持 WebSocket。
- en: 'If WebSockets isn’t available, SignalR switches to other communication techniques,
    such as `text/event-stream` data and asks the server to keep the connection alive
    (via the `Connection: keep-alive` HTTP header). All modern browsers support SSE
    nowadays. With polling, the client repeatedly asks the server if new data is available,
    opening new connections again and again. Long polling is a technique that reduces
    the number of requests from the client by the server not returning information
    immediately, stating that nothing new is available. Instead, the server waits
    for the timeout to nearly end before returning. If some new information is available
    while waiting, this new information is returned.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 WebSocket 不可用，SignalR 将切换到其他通信技术，例如 `text/event-stream` 数据，并要求服务器保持连接活跃（通过
    `Connection: keep-alive` HTTP 头）。现在所有现代浏览器都支持 SSE。使用轮询时，客户端会反复询问服务器是否有新数据可用，一次又一次地打开新的连接。长轮询是一种技术，通过服务器不立即返回信息，声称没有新信息可用来减少客户端的请求数量。相反，服务器等待超时几乎结束时才返回。如果在等待期间有新信息可用，则返回这些新信息。'
- en: 'Using SignalR, there’s no need to change programming constructs to decide between
    WebSockets, SSE, and long polling. This is done automatically by SignalR. However,
    in all these scenarios, compared to simple HTTP requests, the server has more
    overhead: connections with the clients need to stay alive and thus be kept in
    memory. To remove this overhead from our services, we’ll use Azure SignalR Service
    later in this chapter.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SignalR，无需更改编程结构来决定使用 WebSocket、SSE 或长轮询。这是由 SignalR 自动完成的。然而，在这些场景中，与简单的
    HTTP 请求相比，服务器有更多的开销：与客户端的连接需要保持活跃，因此需要保存在内存中。为了从我们的服务中移除这种开销，我们将在本章后面使用 Azure
    SignalR 服务。
- en: 'To create a SignalR service, we just need to create an empty ASP.NET Core Web
    project. Because this service also offers a REST API, let’s create a new Web API
    project:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 SignalR 服务，我们只需创建一个空的 ASP.NET Core Web 项目。因为这个服务也提供 REST API，让我们创建一个新的
    Web API 项目：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This creates a minimal API project, similar to what we have for the `game-apis`
    project. This project needs to be configured as a .NET Aspire project. With Visual
    Studio, use `Codebreaker.Live` project. Then, add a project reference to the `ServiceDefaults`
    project to the live project.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个最小化的 API 项目，类似于我们为 `game-apis` 项目所拥有的项目。这个项目需要配置为 .NET Aspire 项目。使用 Visual
    Studio，使用 `Codebreaker.Live` 项目。然后，将 `ServiceDefaults` 项目的项目引用添加到实时项目中。
- en: 'The `Codebreaker.Live` service project needs to be configured with the .NET
    Aspire app model:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Codebreaker.Live` 服务项目需要配置为 .NET Aspire 应用模型：'
- en: Codebreaker.AppHost/Program.cs
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By doing this, the project is added to the app model and referenced from the
    `game-apis` service as it needs the link from `live-service` to invoke the REST
    API on game completions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，项目被添加到应用模型中，并从 `game-apis` 服务中引用，因为它需要从 `live-service` 获取链接来调用游戏完成的 REST
    API。
- en: Next, we’ll add a SignalR hub that can be used by clients to connect.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个客户端可以使用的 SignalR 集线器。
- en: Creating a SignalR hub
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 SignalR 集线器
- en: 'SignalR is already part of ASP.NET Core, so we don’t need to add another NuGet
    package. Let’s add the SignalR hub class – that is, `LiveHub`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 已经是 ASP.NET Core 的一部分，所以我们不需要添加另一个 NuGet 包。让我们添加 SignalR 集线器类——即 `LiveHub`：
- en: Codebreaker.Live/Endpoints/LiveHub.cs
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Live/Endpoints/LiveHub.cs
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A SignalR hub derives from the `Hub` base class (the `Microsoft.AspNetCore.SignalR`
    namespace). This class defines the `OnConnectedAsync` and `OnDisconnectedAsync`
    methods, both of which can be overridden to react on client connects and disconnects.
    Here, we define the `RegisterGameCompletions` method with `gameType` as its parameter.
    This method is invoked by SignalR clients.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 中心类派生自 `Hub` 基类（`Microsoft.AspNetCore.SignalR` 命名空间）。这个类定义了 `OnConnectedAsync`
    和 `OnDisconnectedAsync` 方法，这两个方法都可以被重写以响应客户端的连接和断开。在这里，我们定义了一个带有 `gameType` 参数的
    `RegisterGameCompletions` 方法。此方法由 SignalR 客户端调用。
- en: Using SignalR, a hub can send real-time information to all clients, one client,
    or a group of clients. With this implementation, we allow clients to register
    with a group. Game types are used to differentiate different groups. The `Hub`
    class defines a `Groups` property to subscribe and unsubscribe from a group. The
    `AddToGroupAsync` method adds the client and `RemoveFromGroupAsync` removes the
    client from the group. A connected client can be identified using `ConnectionId`,
    which can be accessed using the `Context` property.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SignalR，中心可以向所有客户端、单个客户端或一组客户端发送实时信息。在这个实现中，我们允许客户端注册到一个组。游戏类型用于区分不同的组。`Hub`
    类定义了一个 `Groups` 属性来订阅和取消订阅一个组。`AddToGroupAsync` 方法将客户端添加到组中，而 `RemoveFromGroupAsync`
    方法则从组中移除客户端。可以通过 `ConnectionId` 来识别已连接的客户端，这可以通过 `Context` 属性访问。
- en: To send information to connected clients, the `Hub` class offers the `Clients`
    property, which allows you to send to all clients (`Clients.All.SendAsync`), or
    a group (`Clients.Group("group-name").SendAsync`). However, in this case, we need
    to send the information outside of the `LiveHub` class (after receiving a REST
    invocation) from the `game-apis` service. We’ll do this by implementing the `LiveGamesEndpoints`
    class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要向已连接的客户端发送信息，`Hub` 类提供了一个 `Clients` 属性，允许你向所有客户端发送（`Clients.All.SendAsync`）或一个组（`Clients.Group("group-name").SendAsync`）。然而，在这种情况下，我们需要从
    `game-apis` 服务（在接收到 REST 调用之后）将信息发送到外部 `LiveHub` 类。我们将通过实现 `LiveGamesEndpoints`
    类来完成这项工作。
- en: Returning live information to the clients
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将实时信息返回给客户端
- en: 'The `LiveGamesEndpoints` class uses minimal APIs to implement a REST endpoint.
    What’s special is that it can send information to connected clients:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiveGamesEndpoints` 类使用最小化的 API 来实现 REST 端点。特别之处在于它可以向已连接的客户端发送信息：'
- en: Codebreaker.Live/Endpoints/LiveGamesEndpoints.cs
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Live/Endpoints/LiveGamesEndpoints.cs
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `GameSummary` class that’s received by the `MapPost` method is implemented
    in the `CNinnovation.Codebreaker.BackendModels` NuGet package. This class contains
    summary information of a completed game. Along with this HTTP POST body parameter,
    the `MapPost` method receives an `IHubContext<LiveHub>` instance from the DI container.
    This interface is registered when the DI container is configured for SignalR to
    retrieve a context to the registered hub to send information to clients. Using
    the `Clients.Group` method, when passing the name of the group, an `IClientProxy`
    object is returned. This proxy is then used to send the `GameCompleted` method
    with the game summary.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `MapPost` 方法接收的 `GameSummary` 类在 `CNinnovation.Codebreaker.BackendModels`
    NuGet 包中实现。这个类包含了一个完成游戏的摘要信息。除了这个 HTTP POST 请求体参数外，`MapPost` 方法还从 DI 容器接收一个 `IHubContext<LiveHub>`
    实例。当 DI 容器配置为 SignalR 时，此接口被注册，以便检索到已注册中心以向客户端发送信息。使用 `Clients.Group` 方法，当传递组名时，会返回一个
    `IClientProxy` 对象。然后，使用这个代理来发送带有游戏摘要的 `GameCompleted` 方法。
- en: Now, all we need to do is register SignalR and the hub with the DI container
    and the middleware.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将 SignalR 和中心注册到 DI 容器和中间件中即可。
- en: Registering SignalR services and the hub
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册 SignalR 服务和中心
- en: 'To use SignalR, and to make the hub available as an endpoint, we must implement
    the `ApplicationServices` class:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 SignalR 并使中心作为端点可用，我们必须实现 `ApplicationServices` 类：
- en: Codebreaker.Live/ApplicationServices.cs
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Live/ApplicationServices.cs
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `AddApplicationServices` method extends `IHostApplicationBuilder` to register
    the service classes that are needed for SignalR by invoking the `AddSignalR` method.
    The `MapApplicationEndpoints` method registers the SignalR hub and minimal API
    endpoint. The SignalR hub is registered with the endpoints by passing the `Hub`
    class with the generic parameter of the `MapHub` method. `/livesubscribe` is the
    link that’s used by clients to connect to this service.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddApplicationServices` 方法通过调用 `AddSignalR` 方法扩展 `IHostApplicationBuilder`，以注册
    SignalR 所需的服务类。`MapApplicationEndpoints` 方法注册 SignalR 端点和最小 API 端点。通过传递具有 `MapHub`
    方法泛型参数的 `Hub` 类来注册 SignalR 端点。`/livesubscribe` 是客户端用来连接此服务的链接。'
- en: 'The methods of the `ApplicationServices` class are invoked from the top-level
    statements of the SignalR project:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationServices` 类的方法是从 SignalR 项目的顶层语句中调用的：'
- en: Codebreaker.Live/Program.cs
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Live/Program.cs
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The DI container is configured by invoking the `AddServiceDefaults` method,
    which is defined by the common `ServiceDefaults` project. This adds the DI container
    registration that’s needed by all projects of the solution. The `AddApplicationServices`
    method adds the services that are needed from `live-service`, such as SignalR.
    Using `builder.Build` concludes the information that’s needed via the DI container.
    The app instance starts configuring the middleware, which is where `MapDefaultEndpoints`
    and `MapApplicationEndpoints` are invoked. `MapDefaultEndpoints` registers links
    such as common health checks (covered in [*Chapter 12*](B21217_12.xhtml#_idTextAnchor294)).
    `MapApplicationEndpoints` registers the endpoints offered by this service project.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用由通用 `ServiceDefaults` 项目定义的 `AddServiceDefaults` 方法配置 DI 容器。这为解决方案中所有项目所需添加了
    DI 容器注册。`AddApplicationServices` 方法添加了从 `live-service` 需要的服务，例如 SignalR。使用 `builder.Build`
    通过 DI 容器得出所需的信息。应用程序实例开始配置中间件，这是 `MapDefaultEndpoints` 和 `MapApplicationEndpoints`
    被调用的地方。`MapDefaultEndpoints` 注册了如常见健康检查（在第 [*第 12 章*](B21217_12.xhtml#_idTextAnchor294)
    中介绍）之类的链接。`MapApplicationEndpoints` 注册了由此服务项目提供的端点。
- en: Now that `live-service` is ready to go, let’s call the API from the `game-apis`
    service.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `live-service` 已准备就绪，让我们从 `game-apis` 服务调用 API。
- en: Forwarding requests from the game-apis service
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从游戏-apis 服务转发请求
- en: 'Recall the sequence diagram from earlier. We’ve updated this diagram to show
    how `game-apis` and `live-service` communicate:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下之前的序列图。我们已更新此图以显示 `game-apis` 和 `live-service` 之间的通信方式：
- en: '![Figure 13.2 – REST calls to live-service](img/B21217_13_02.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – 对 live-service 的 REST 调用](img/B21217_13_02.jpg)'
- en: Figure 13.2 – REST calls to live-service
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 对 live-service 的 REST 调用
- en: 'After a game is completed, the `game-apis` service invokes `live-service` with
    game completion information. To invoke `live-service`, create the `LiveReportClient`
    class, which injects `HttpClient`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏完成后，`game-apis` 服务使用游戏完成信息调用 `live-service`。要调用 `live-service`，创建 `LiveReportClient`
    类，并注入 `HttpClient`：
- en: Codebreaker.GameAPIs/Services/LiveReportClient.cs
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Services/LiveReportClient.cs
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `ReportGameEndedAsync` method uses the `HttpClient` class to make an HTTP
    POST request to `/live/game` and send `GameSummary` information.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReportGameEndedAsync` 方法使用 `HttpClient` 类向 `/live/game` 发送 HTTP POST 请求并发送
    `GameSummary` 信息。'
- en: 'Let’s configure the `HttpClient` class by updating the `ApplicationServices`
    class:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过更新 `ApplicationServices` 类来配置 `HttpClient` 类：
- en: Codebreaker.GameAPIs/ApplicationServices.cs
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/ApplicationServices.cs
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using .NET Aspire orchestration, the URL of the live client is retrieved by
    using service discovery with the `https+http://live` expression. This expression
    prefers the `https` schema, but if it isn’t available, it uses the `http` schema.
    The name is resolved with service discovery via the app model, as explained in
    [*Chapter 1*](B21217_01.xhtml#_idTextAnchor014).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 .NET Aspire 协调，通过使用 `https+http://live` 表达式的服务发现来检索实时客户端的 URL。此表达式优先选择 `https`
    协议，如果不可用，则使用 `http` 协议。名称通过应用模型中的服务发现解析，如[*第 1 章*](B21217_01.xhtml#_idTextAnchor014)中所述。
- en: With that, `game-apis` has been configured to send game summary information.
    Now, all we need to do is create a client that receives real-time information
    from the SignalR service.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`game-apis` 已配置为发送游戏摘要信息。现在，我们只需要创建一个从 SignalR 服务接收实时信息的客户端。
- en: Creating a SignalR client
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 SignalR 客户端
- en: As a simple client receiving real-time information, all we need is a console
    application that connects to `live-service`. By doing this, it’s simple to implement
    this functionality with any other client.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作为接收实时信息的简单客户端，我们只需要一个连接到 `live-service` 的控制台应用程序。通过这样做，可以轻松地将此功能实现到任何其他客户端中。
- en: 'Start by creating a console project:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个控制台项目：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Microsoft.AspNetCore.SignalR.Client` NuGet package needs to be added to
    call a SignalR service. We must also add `Microsoft.Extensions.Hosting` for the
    DI container and `CNinnovation.Codebreaker.BackendModels` with the `GameSummary`
    type.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 需要添加 `Microsoft.AspNetCore.SignalR.Client` NuGet 包来调用 SignalR 服务。我们还必须添加 `Microsoft.Extensions.Hosting`
    用于 DI 容器，以及 `CNinnovation.Codebreaker.BackendModels` 包中的 `GameSummary` 类型。
- en: 'Create the `LiveClient` class, which will communicate with the SignalR service:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `LiveClient` 类，该类将与 SignalR 服务进行通信：
- en: LiveTestClient/LiveClient.cs
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: LiveTestClient/LiveClient.cs
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `LiveClient` class specifies a constructor with `IOptions<LiveClientOptions>`.
    This will be configured with the DI container so that it can pass the URL string
    from `live-service`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiveClient` 类指定了一个带有 `IOptions<LiveClientOptions>` 的构造函数。这将通过 DI 容器进行配置，以便它可以传递来自
    `live-service` 的 URL 字符串。'
- en: 'Add `appsettings.json` to configure the URL:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `appsettings.json` 添加到配置 URL：
- en: LiveTestClient/appsettings.json
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: LiveTestClient/appsettings.json
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For local testing, the port number needs to match the port number that’s specified
    with `launchSettings.json`. Don’t forget to configure so that `appsettings.json`
    is copied to the output directory.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地测试，端口号需要与 `launchSettings.json` 中指定的端口号相匹配。不要忘记配置，以确保 `appsettings.json`
    被复制到输出目录。
- en: 'The connection to the service is initiated by the `StartMonitorAsync` method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `StartMonitorAsync` 方法启动对服务的连接：
- en: LiveTestClient/LiveClient.cs
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: LiveTestClient/LiveClient.cs
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To connect to the SignalR hub, `HubConnectionBuilder` is used to set up a connection.
    With this builder, the connection can be configured – for example, logging, server
    timeout, and reconnect behaviors can be set up. The connection is then initiated
    by invoking the `StartAsync` method.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到 SignalR 集线器，使用 `HubConnectionBuilder` 设置连接。使用此构建器，可以配置连接 – 例如，设置日志记录、服务器超时和重连行为。然后通过调用
    `StartAsync` 方法来启动连接。
- en: 'The `On` method of `HubConnection` configures the receiving side: when a `GameCompleted`
    message is received, the `GameSummary` parameter specifies the data that’s been
    received and writes a message about the game to the console. The name `GameCompleted`
    needs to match the name that has been passed with the `SendAsync` method of the
    service.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`HubConnection` 的 `On` 方法配置接收端：当接收到 `GameCompleted` 消息时，`GameSummary` 参数指定了接收到的数据，并将关于游戏的消息写入控制台。名称
    `GameCompleted` 需要与通过服务的 `SendAsync` 方法传递的名称相匹配。'
- en: 'To subscribe to the messages from the service, implement the `SubscribeToGame`
    method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要订阅来自服务的消息，实现 `SubscribeToGame` 方法：
- en: LiveTestClient/LiveClient.cs
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: LiveTestClient/LiveClient.cs
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this implementation, the `InvokeAsync` method of `HubConnection` is used.
    `SubscribeToGameCompletions` matches the name of the hub method, which uses the
    `game-type` parameter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实现中，使用 `HubConnection` 的 `InvokeAsync` 方法。`SubscribeToGameCompletions` 与集线器方法的名称匹配，该方法使用
    `game-type` 参数。
- en: 'The top-level statements of the client application make use of the `LiveClient`
    class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序的顶级语句使用了 `LiveClient` 类：
- en: LiveTestClient/Program.cs
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: LiveTestClient/Program.cs
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After configuring the `LiveClient` class in the DI container, the `StartMonitorAsync`
    and `SubscribeToGame` methods are invoked.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DI 容器中配置 `LiveClient` 类后，调用 `StartMonitorAsync` 和 `SubscribeToGame` 方法。
- en: With this in place, you can start the AppHost so that it runs all the services
    and multiple instances of the client application. Use `bot-service` to play multiple
    games. You’ll see success messages from the bot, as shown in *Figure 13**.3*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，可以启动 AppHost，使其运行所有服务和客户端应用程序的多个实例。使用 `bot-service` 来玩多个游戏。您将看到来自机器人的成功消息，如图
    *图 13**.3* 所示。
- en: '![Figure 13.3 – Live client receiving game summaries](img/B21217_13_03.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – 接收游戏摘要的实时客户端](img/B21217_13_03.jpg)'
- en: Figure 13.3 – Live client receiving game summaries
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – 接收游戏摘要的实时客户端
- en: Using the bot, multiple games have been started with a think time of 0 and 1
    seconds between game moves. These results show game wins that occur between 0.27
    and 4.79 seconds.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用机器人，在游戏移动之间有 0 和 1 秒的思考时间，启动了多个游戏。这些结果显示了在 0.27 到 4.79 秒之间发生的游戏胜利。
- en: Changing the serialization protocol
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改序列化协议
- en: By default, SignalR serializes messages with JSON. Using the `Microsoft.AspNetCore.SignalR.Protocols.MessagePack`
    NuGet package, a binary serialization format can be used instead. This is an optimization
    that reduces the data that’s sent.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SignalR 使用 JSON 序列化消息。使用 `Microsoft.AspNetCore.SignalR.Protocols.MessagePack`
    NuGet 包，可以使用二进制序列化格式代替。这是一种优化，可以减少发送的数据量。
- en: 'To support this, all we need to do is update the DI configuration in the service,
    after adding the NuGet package:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这一点，我们只需要在添加 NuGet 包后更新服务的 DI 配置：
- en: Codebreaker.Live/ApplicationServices.cs
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Live/ApplicationServices.cs
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `AddMessagePackProtocol` method adds `MessagePack` as another option for
    serialization. JSON is still available.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddMessagePackProtocol` 方法将 `MessagePack` 添加为序列化的另一种选项。JSON 仍然可用。'
- en: 'Regarding the client, the same NuGet package is required, but this time with
    the following configuration:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 关于客户端，需要相同的 NuGet 包，但这次需要以下配置：
- en: LiveTestClient/LiveClient.cs
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: LiveTestClient/LiveClient.cs
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Like the server, the same NuGet package for the protocol is needed for the client,
    as well as the `AddMessagePackProtocol` API. With the client, logging is now turned
    on as well. Logging providers for SignalR can be configured using the `ConfigureLogging`
    method. Here, the console provider is added, and the minimum logging level is
    set to `LogLevel.Debug`. With this, we can see all communication between the client
    and the server, including the message protocols that are used and the ping messages
    that are sent.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器一样，客户端也需要相同的协议 NuGet 包，以及 `AddMessagePackProtocol` API。对于客户端，现在日志记录也已开启。可以使用
    `ConfigureLogging` 方法配置 SignalR 的日志提供程序。在此，添加了控制台提供程序，并将最小日志级别设置为 `LogLevel.Debug`。这样，我们可以看到客户端和服务器之间的所有通信，包括使用的消息协议和发送的
    ping 消息。
- en: 'When using MessagePack, you need to be aware of an important restriction: `DateTime.Kind`
    is not serialized. Thus, this type should be converted into UTC before being sent.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 MessagePack 时，需要注意一个重要的限制：`DateTime.Kind` 不会被序列化。因此，在发送之前，此类型应转换为 UTC。
- en: 'With this in place, you can start the solution again, start the bot to play
    some games, and start the SignalR client. When you look at the logging information,
    you’ll see WebSockets and MessagePack in action:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在此设置完成后，您可以再次启动解决方案，启动机器人来玩游戏，并启动 SignalR 客户端。当您查看日志信息时，您将看到 WebSockets 和 MessagePack
    在实际操作中的使用：
- en: Logging from the client application
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序的日志记录
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we’ve switched the serialization format, let’s reduce the load from
    the service when a larger number of clients is connected by using Azure SignalR
    Service.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经切换了序列化格式，让我们通过使用 Azure SignalR 服务来减少大量客户端连接时的服务负载。
- en: Using Azure SignalR Service
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure SignalR 服务
- en: There’s some overhead associated with SignalR since the server has open connections
    with all SignalR clients.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器与所有 SignalR 客户端都保持开放连接，因此 SignalR 存在一些开销。
- en: 'To remove this overhead from our services, we can use **Azure SignalR Service**.
    This service acts as an intermediary between clients and the SignalR service,
    as depicted in *Figure 11**.4*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从我们的服务中移除这种开销，我们可以使用 **Azure SignalR 服务**。此服务充当客户端和 SignalR 服务之间的中介，如图 *图
    11**.4* 所示：
- en: "![Figure 1\uFEFF3.4 – Using Azure SignalR Service](img/B21217_13_04.jpg)"
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4 – 使用 Azure SignalR 服务](img/B21217_13_04.jpg)'
- en: Figure 13.4 – Using Azure SignalR Service
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – 使用 Azure SignalR 服务
- en: The preceding figure shows multiple monitor clients that each have a connection
    open to Azure SignalR Service. `live-service` just needs to deal with a single
    connection. Azure SignalR subscribes to the events and forwards them to a single
    client, a group of clients, or all clients, as specified by `live-service`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上一图显示了多个监控客户端，每个客户端都向 Azure SignalR 服务开放一个连接。`live-service` 只需处理单个连接。Azure SignalR
    订阅事件并将它们转发到单个客户端、一组客户端或所有客户端，具体取决于 `live-service`。
- en: The load for every client connection is handled by Azure SignalR Service, while
    this service just acts as a single client to the SignalR service.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 每个客户端连接的负载由 Azure SignalR 服务处理，而此服务仅作为 SignalR 服务的单个客户端。
- en: A free version of this service without SLA that’s limited to 20 connections
    and 20,000 messages per day can be used for development purposes. Standard and
    premium SKUs can scale up to 1,000 connections per unit, 100 units, and unlimited
    messages.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务的免费版本没有 SLA，限制为每天 20 个连接和 20,000 条消息，可用于开发目的。标准和高级 SKU 可以扩展到每个单元 1,000 个连接、100
    个单元和无限消息。
- en: 'To activate Azure SignalR Service within the app model, we need to update `app-model`
    within the AppHost project:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序模型中激活 Azure SignalR 服务，我们需要更新 AppHost 项目中的 `app-model`：
- en: Codebreaker.AppHost/Program.cs
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With .NET Aspire provisioning, Azure SignalR Service is created when the application
    is started. When using the `WithReference` method, the URI is forwarded to the
    `Codebreaker.Live` service. Here, the `Microsoft.Azure.SignalR` NuGet package
    is required to connect this service:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 .NET Aspire 配置，Azure SignalR 服务在应用程序启动时创建。当使用 `WithReference` 方法时，URI 被转发到
    `Codebreaker.Live` 服务。在此处，需要 `Microsoft.Azure.SignalR` NuGet 包来连接此服务：
- en: Codebreaker.Live/ApplicationServices.cs
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Live/ApplicationServices.cs
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using `AddNamedAzureSignalR`, the connection string is retrieved via service
    discovery, and the SignalR hub is connected to this Azure service.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `AddNamedAzureSignalR`，通过服务发现检索连接字符串，并将 SignalR 网关连接到此 Azure 服务。
- en: Now, start the application again and check the Azure portal to see that the
    service has been created. Use the Aspire dashboard to see the environment variable
    that’s been assigned to the `Codebreaker.Live` service, and check the logs to
    see the connections that have been made to Azure SignalR Service. Run the bot
    so that it plays several games and then start several SignalR client (`LiveTestClient`)
    processes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新启动应用程序并检查 Azure 门户，以查看服务已创建。使用 Aspire 仪表板查看分配给 `Codebreaker.Live` 服务的环境变量，并检查日志以查看已连接到
    Azure SignalR 服务的连接。运行机器人，让它玩几场比赛，然后启动几个 SignalR 客户端 (`LiveTestClient`) 进程。
- en: 'When you open the Azure portal, open the resource group of the developer environment
    (`rg-aspire-<yourhost>-codebreaker.apphost`) and select Azure SignalR Service.
    In the **Monitoring** category in the left bar, select **Live trace settings**.
    Click the **Enable Live Trace** checkbox and choose to collect information for
    **ConnectivityLogs**, **MessagingLogs**, and **HttpRequestLogs**. Then, click
    the **Open Live Trace Tool** button. You’ll receive the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打开 Azure 门户时，打开开发环境资源组（`rg-aspire-<yourhost>-codebreaker.apphost`）并选择 Azure
    SignalR 服务。在左侧栏的 **监控** 类别中，选择 **实时跟踪设置**。点击 **启用实时跟踪** 复选框，并选择收集 **ConnectivityLogs**、**MessagingLogs**
    和 **HttpRequestLogs** 的信息。然后，点击 **打开实时跟踪工具** 按钮。您将收到以下输出：
- en: '![Figure 13.5 – Azure SignalR Service live trace. This screenshot only intends
    to show the output result page; text readability is not essential](img/B21217_13_05.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5 – Azure SignalR 服务实时跟踪。此截图仅用于显示输出结果页面；文本可读性不是关键](img/B21217_13_05.jpg)'
- en: Figure 13.5 – Azure SignalR Service live trace. This screenshot only intends
    to show the output result page; text readability is not essential
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – Azure SignalR 服务实时跟踪。此截图仅用于显示输出结果页面；文本可读性不是关键
- en: With the Azure SignalR Service live trace, you can see all the messages that
    have been sent from the Codebreaker live service, as well as the messages that
    have been sent to the subscribing clients.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Azure SignalR 服务实时跟踪，您可以查看从 Codebreaker 实时服务发送的所有消息，以及发送给订阅客户端的消息。
- en: 'To see metrics data, go back (or open a new browser window) to the **Overview**
    page of Azure SignalR Service. There, you can see the number of connections that
    have been opened, as shown in *Figure 13**.6*:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看指标数据，请返回（或打开新的浏览器窗口）到 Azure SignalR 服务的 **概览** 页面。在那里，您可以查看已打开的连接数，如图 *图
    13.6* 所示：
- en: '![Figure 13.6 – Azure SignalR Service connection metrics](img/B21217_13_06.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.6 – Azure SignalR 服务连接指标](img/B21217_13_06.jpg)'
- en: Figure 13.6 – Azure SignalR Service connection metrics
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 – Azure SignalR 服务连接指标
- en: '*Figure 13**.7* shows the number of messages that have been sent:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13.7* 显示了已发送的消息数量：'
- en: '![Figure 13.7 – Azure SignalR Sevice message metrics](img/B21217_13_07.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7 – Azure SignalR 服务消息指标](img/B21217_13_07.jpg)'
- en: Figure 13.7 – Azure SignalR Sevice message metrics
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – Azure SignalR 服务消息指标
- en: Now that everything is up and running, you’ve earned a well-deserved break so
    that you can play some games (which you can monitor as well).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切运行正常，您已经赢得了应得的休息时间，可以玩一些游戏（您也可以进行监控）。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to offer real-time data using SignalR. You
    created a live service containing a SignalR hub that offers real-time information
    about completed games. Clients can register to a subset – a group – of the information
    offered. You also created a simple console application that acts as a client.
    The same functionality can be implemented in other clients. You can check this
    out in the Blazor client application provided in this book’s GitHub repository,
    which contains the SignalR client functionality.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用SignalR提供实时数据。你创建了一个包含SignalR中心的实时服务，该中心提供有关完成游戏的实时信息。客户端可以注册到提供的信息的子集——一个组。你还创建了一个简单的控制台应用程序，作为客户端。同样的功能也可以在其他客户端中实现。你可以在本书GitHub仓库中提供的Blazor客户端应用程序中查看这些功能，该应用程序包含SignalR客户端功能。
- en: Then, you learned how to use Azure SignalR Service, which reduces the load on
    the service hosting the SignalR hub as the clients directly interact with Azure
    SignalR Service while this service acts as one client to SignalR.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学习了如何使用Azure SignalR服务，这减少了托管SignalR中心的服务的负载，因为客户端直接与Azure SignalR服务交互，而此服务作为SignalR的一个客户端。
- en: With the implementation of this chapter, we created a REST API that’s invoked
    by the `game-apis` service to send completed games. REST is great for easy communication
    with all clients, but it doesn’t offer the best performance. The only client for
    the `Codebreaker.Live` service is the `game-apis` service.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的实现中，我们创建了一个REST API，该API由`game-apis`服务调用以发送完成的游戏。REST非常适合与所有客户端进行简单通信，但它并不提供最佳性能。`Codebreaker.Live`服务的唯一客户端是`game-apis`服务。
- en: Regarding service-to-service communication, instead of using REST APIs, less
    overhead is used when binary serialization is used alongside protocols such as
    gRPC. This will be covered in the next chapter.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 关于服务间通信，在配合gRPC等协议使用二进制序列化时，与使用REST API相比，开销更小。这将在下一章中介绍。
- en: Further reading
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were discussed in this chapter, please
    refer to the following links:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章讨论的主题，请参阅以下链接：
- en: '*ASP.NET Core* *SignalR*: [https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction](https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ASP.NET Core* *SignalR*: [https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction](https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction)'
- en: '*Message Pack* *protocol*: [https://learn.microsoft.com/en-us/aspnet/core/signalr/messagepackhubprotocol](https://learn.microsoft.com/en-us/aspnet/core/signalr/messagepackhubprotocol)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Message Pack* *协议*: [https://learn.microsoft.com/en-us/aspnet/core/signalr/messagepackhubprotocol](https://learn.microsoft.com/en-us/aspnet/core/signalr/messagepackhubprotocol)'
- en: '*Azure SignalR* *Service*: [https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview](https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Azure SignalR* *服务*: [https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview](https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview)'
- en: '.*NET Aspire support for Azure SignalR* *Service*: [https://learn.microsoft.com/en-us/dotnet/aspire/real-time/azure-signalr-scenario](https://learn.microsoft.com/en-us/dotnet/aspire/real-time/azure-signalr-scenario)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .*NET Aspire对Azure SignalR* *服务*的支持：[https://learn.microsoft.com/en-us/dotnet/aspire/real-time/azure-signalr-scenario](https://learn.microsoft.com/en-us/dotnet/aspire/real-time/azure-signalr-scenario)
