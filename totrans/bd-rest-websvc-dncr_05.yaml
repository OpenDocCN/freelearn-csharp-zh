- en: Integrating External Components and Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been developing our FlixOneStore. In the previous chapter, we
    added a shopping cart and shipping facility. However, some organizations may not
    need such facilities, as some organizations have everything in the house. For
    instance, our FlixOneStore requires an external component to help us track the
    assignment and payment-management system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the external components with the help of code
    examples. We will mainly cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the middleware
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding logging to our API in the middleware
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intercepting HTTP requests and responses by building our own middleware
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON-RPC for RPC communication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the middleware
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, middleware is a piece of software that connects two different
    or similar places. In the world of software engineering, middleware is a software
    component and is assembled in an application pipeline to handle requests and responses.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: These components can also check whether a request should pass to the next components,
    or whether the request should be handled by a component before or after the next
    component is triggered/invoked. This request pipeline is built with the use of
    a request delegate. This request delegate interacts with each HTTP request.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following quote from the documentation of ASP.NET Core ([https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/)):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '"Middleware is software that''s assembled into an application pipeline to handle
    requests and responses."'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following diagram, showing an example of a simple middleware component:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bce228e-7b7b-4e9c-8088-5adfcb279a1f.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: Requesting delegates
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Requests are handled by the `Use`, `Run`, `Map`, and `MapWhen` extension methods.
    These methods configure the request delegates.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this in detail, let''s create a dummy project using `ASP.NET
    Core`. Go through the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to File | New | Project, or click *Ctrl* + *Shift* + *N*. Refer to the following
    screenshot:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c0b2f086-c173-4d34-bd96-36a9f72eb2aa.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: Creating a new project using Visual Studio 2017
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: From the New Project screen, select ASP.NET Core Web Application.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name your new project (say `Chap05_01`), select a location, and click OK, as
    shown in the following screenshot:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/230053ba-e018-446e-bc6d-e6fd627bb5b1.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: Selecting new project template
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: From the new ASP.NET Core Web Application template screen, choose the API template.
    Make sure you select .NET Core and ASP.NET Core 2.0.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click OK, as shown in the following screenshot:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f27c348c-5b5b-49e9-9f5b-149c6bae1232.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: 'Open Solution Explorer. You will see the file/folder structure, as shown in
    the following screenshot:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/59fe708a-495b-4023-b55d-7743d92329ce.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: Showing file/folder structure of Chap05_01 project
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'From the dummy project that we have just created, open the `Startup.cs` file
    and look at the `Configure` method, which contains the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code is self-explanatory: it tells the system to add `Mvc` to
    the request pipelines by initiating the `app.UseMvc()` extension method of `Microsoft.AspNetCore.Builder.IApplicationBuilder`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: You can get more information on `IApplicationBuilder` at [https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder?view=aspnetcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder?view=aspnetcore-2.0).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: It also instructs the system to use a particular exception page if the environment
    is in development. The preceding method configures the application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss four important `IApplicationBuilder` methods in
    detail.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Use
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Use` method adds a delegate to the application request pipelines. Look
    at the following screenshot for the signature of this method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/291321c1-da74-4bc7-85da-9ab284eee7ff.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: Signature of Use method
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in the previous section, the middleware methods can short circuit
    the request pipeline or pass the request to the next delegate.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Short-circuiting a request is nothing but ending a request.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following code for the `Use` method:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, I have tried to explain the dummy implementation of the
    `Use` method with the help of a local function. Here, you can see that `Middleware`
    is invoking or passing the request to the next delegate, before or after `await
    next.Invoke();`. You can write/implement other code phrases, but these phrases
    should not send responses to the client, such as those that write output, produce
    the 404 status, and so on.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '**Local functions** are the methods that are declared within a method and can
    be called within the scope of the method itself. These methods can only be used
    by another method.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Run
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Run` method adds a delegate to the request pipeline in the same way as
    the `Use` method, but this method terminates the request pipeline. Look at the
    following screenshot for the signature of this method:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a5a0166-c10b-490c-8ccc-a4454aabc2a0.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: 'Look at the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, I tried to show that `Run` terminates the request pipeline.
    Here, I used a local function, `RequestDelegate`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that I added a console logger before this and that there is scope
    to add more code phrases, but not those phrases that send responses back to the
    client. Here, `Run` terminates by returning a string. Run Visual Studio or press
    *F5*—you will get an output similar to the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47ec67d8-9b78-4440-8bb0-223ef2a17710.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: Map
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Map` method helps when you want to connect multiple instances of middleware.
    To do this, `Map` calls another request delegate. Look at the following screenshot
    for the signature of this method:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e767d6f-3229-463b-9373-8c8ec0ac298a.png)^(Signature of Map method)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: 'Look at the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this code, I added a `Map` that just maps `<url>/testroute`. Following this
    is the same `Run` method that we discussed previously. `TestRoutehandler` is a
    private method. Look at the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before `app.Run(Handler);` is a normal delegate. Now, run the code and look
    at the results. They should be similar to the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93907e52-1b91-46c5-9e62-7b3ab8e77ac8.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: 'You can see that the root of the web application is showing the string that
    is mentioned in the `Run` delegate method. You will get the output shown in the
    following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5cb5a2a-d3dd-417c-8f89-d9d3ddb0df73.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: Adding logging to our API in middleware
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In simple words, logging is nothing but the process or act of getting log files
    in one place to get the events or other actions that occur in APIs during communication.
    In this section, we will implement logging for our product APIs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Before we start looking at how to log our APIs' events, let's first take a quick
    look at our existing product APIs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Request delegates *section to refresh your memory as to how you
    can create a new ASP.NET Core project.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the project structure of our product APIs:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84ad0efb-4932-4e26-82e1-460cbc488d84.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'Here is our `Product` model:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Product` model is a class that represents a product, containing properties.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our repository interface:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `IProductRepository` interface has methods that are required for our APIs
    to start with operations for a product.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our `ProductRepository` class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `ProductRepository` class implements the `IProductRepository` interface.
    The preceding code is self-explanatory.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Startup.cs` file and add the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For Swagger support for our Product APIs, you need to add the `Swashbuckle.ASPNETCore` NuGet
    package.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `appsettings.json` file and add the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s see what our `ProductController` contains:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code is the `GET` resource of our product APIs. It calls the `GetAll()`
    method of our `ProductRepository`, transposes the response, and returns it. In
    the previous code, we have already instructed the system to resolve the `IProductRepository` interface with
    the `ProductRepository` class. Refer to the `Startup` class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the method that transposes the response:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code accepts a parameter of the `Product` type and then returns
    an object of the `ProductViewModel` type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how our controller constructor is injected:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, we injected our `ProductRepository`, and it will be automatically
    initialized whenever anyone calls any resources of the product APIs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Now, you are ready to play with the application. Run the application from the
    menu or click *F5*. In a web browser, you can use the suffix `/swagger` to the
    URL of the address.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: For the complete source code, refer to the GitHub repository link at [https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'It will show the Swagger API documentation, as shown in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81c11e65-4875-466e-a068-7a62e931b066.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: 'Click on the `GET /api/Product/productlist` resource. It will return a list
    of products, as shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d825f3e-e331-434a-8d31-ad740b96efc1.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: Let's implement logging for our API. Please note that to make our demo short
    and simple, I am not adding complex scenarios to track everything. I am adding
    simple logs to showcase the logging capabilities.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'To start implementing logging for our product APIs, add a new class called
    `LogAction` in a new folder called `Logging`. Here is the code from the `LogAction`
    class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code contains constants that are nothing but our application's
    actions, also called **events**.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Update our `ProductController`; it should now look like the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we added an `ILogger` interface, which comes from a dependency
    injection container (see [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.0 ](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.0)for
    more details).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the logging capability to the `GET` resource of the product API:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code returns the product list and logs the information.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: To test this scenario, we need a client or an API tool so we can see the output.
    To do this, we will use the `Postman` extension (see[ https://www.getpostman.com/ ](https://www.getpostman.com/)for
    more details).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to run the application. To do so, open the Visual Studio command
    prompt, move to your project folder, and then pass the command `dotnet run`. You
    will see a similar message to the one shown in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/adeff017-ecbf-4077-bd70-3c2e468bb408.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: 'Now, launch Postman and invoke the `GET /api/product/productlist` resource:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f77c310-49f6-4d9c-b833-0d264193c9bd.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: 'By clicking the Send button, you would expect a list of products to be returned,
    but this is not the case, as shown in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99026730-2294-43ba-85c6-535d9e4cac95.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: The preceding exception occurs because we are using a non-generic type in our
    `ProductController` that is not injectable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we need to make slight changes in our `ProductController`. Look at the
    following code snippet:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, I added a generic `ILogger<ProductController>` type.
    As it is injectable, it will get resolved automatically.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Logging is slightly different in .NET Core 2.0 compared to its earlier versions.
    The implementation of the nongeneric `ILogger` is not available by default, but
    it is available for `ILogger<T>`. If you want to use nongeneric implementation,
    use `ILoggerFactory` instead of `ILogger`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the constructor of our `ProductController` would look like the
    following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '`private readonly IProductRepository _productRepository;`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '`private readonly ILogger _logger;`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '`public ProductController(IProductRepository productRepository, ILoggerFactory
    logger)`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '`{`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '`_productRepository = productRepository;`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '`_logger = logger.CreateLogger("Product logger");`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Program` class and update it. It should look like the following code
    snippet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You also need to update the `appsettings.json` file and write more code for
    the logger so that your file looks like the following snippet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, once again, open the Visual Studio command prompt and write the `dotnet
    build` command. It will build the project, and you will get a message similar
    to the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/712f7568-3d05-4989-87ea-78badf111be9.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: 'From this point, if you run Postman, it will give you the results, as shown
    in the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/955ca74a-b21f-4f99-8816-ddfe33cb32e5.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: 'The preceding code adds the ability to log the actions. You will receive similar log
    actions to those shown in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f57ea89-3a05-4cc4-841f-72f8095a8bf3.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: Here, we have written some code that uses the default `ILogger`. We have used
    default methods to invoke the logger; however, there are scenarios where we need
    a customized logger. In the next section, we will discuss how to write middleware
    for a custom logger.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Intercepting HTTP requests and responses by building our own middleware
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create our own middleware for our existing application.
    In this middleware, we will log all requests and responses. Let''s go through
    the following steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open an existing project of the Product APIs by clicking File | Open | Project/Solution (or
    pressing *Ctrl* + *Shift* + *O*), as shown in the following screenshot:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c7d1d3df-b9e8-4033-b1ef-d18001ade638.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: 'Locate your solution folder and click Open, as shown in the following screenshot:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/61661159-326b-4c8a-81da-d7b943efb169.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: 'Open the solution explorer, add a new folder, and name it `Middleware` by right-clicking
    on the project name, as shown in the following screenshot:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/01dd79d4-1500-4331-a7e8-5935fb70d39d.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: Right-click on the `Middleware` folder and select Add | New Item.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the web templates, select the Middleware Class and name the new file `FlixOneStoreLoggerMiddleware`.
    Then, click Add, as shown in the following screenshot:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bbc65dd4-b76a-4fd4-9cee-0f5b13150f20.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: 'Your folder hierarchy should be like the one shown in the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da2e2fcb-191b-4c64-91ae-cf6b04d6f02d.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: Thanks to Justin Williams who provided a solution for POST resources; his solution
    is available at [https://github.com/JustinJohnWilliams/RequestLogging](https://github.com/JustinJohnWilliams/RequestLogging).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following code snippet of our `FlixOneStoreLoggerMiddleware` class:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we are simply taking advantage of the inbuilt DI using
    the `RequestDelegate` to create our custom middleware.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows us how we should be wiring up all requests and responses
    for the log:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Refer to the *Request delegate* section in this chapter, where we looked at
    middleware. In the preceding code, we are simply logging the request and response
    with the help of the `ILogger` generic type. The `await _next(httpContext);` line
    continues with the request pipeline.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Setup.cs` file and add the following code in the `Configure` method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, we take advantage of  `ILoggerFactory` and add `Console`
    and `Debug` to log the requests and responses. The `UseFlixOneLoggerMiddleware` method
    is actually an extension method. For this, add the following code to the `FlixOneStoreLoggerExtension`
    class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, whenever any request comes to our product APIs, the log should appear,
    as shown in the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7b36f72-6571-4284-860f-f2c2f0ed525b.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: In this section, we created a custom middleware and then logged all requests
    and responses.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: JSON-RPC for RPC communication
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON-RPC is a stateless, lightweight remote procedure call (RPC) protocol. The
    specification (namely, JSON-RPC 2.0 specifications (see[ http://www.jsonrpc.org/specification ](http://www.jsonrpc.org/specification)for
    more details)) defines various data structures and their processing rules.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The main objects as per the specifications are shown in the following sections.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Request object
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Request` object represents any call/request that is sent to the server.
    The `Request` object has the following members:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '**jsonrpc**: A string that indicates the version of the JSON-RPC protocol.
    It *must* be accurate (in this case, version 2.0).'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**method**: A string that has the name of the method to be adjured. Method
    names that begin with the word `rpc` and are succeeded by a period character (U+002E
    or ASCII 46) are restrained for rpc-internal methods and extensions, and *must
    not* be worn for anything else.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**params**: A structured value that dominates the parameter values. It is to
    be worn throughout the conjuration of the method. This member *may* be deleted.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**id**: An identifier fixed by the client that *must* have a string, number,
    or *null* value if constituted.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Response object
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As per the specifications, whenever a call is made to the server, there must
    be a response from the server. The `Response` is expressed as a single JSON object
    with the following members:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '**jsonrpc**: A string that is the version of the JSON-RPC protocol'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**result**: A required member, if the request succeeds'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**error**: A required member, if there was an error'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**id**: A required member'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**id**：一个必需的成员'
- en: In this section, we looked at an overview of JSON-RPC specification 2.0.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们概述了JSON-RPC规范2.0。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the integration of external APIs/components regarding
    payment gateways, order tracking, notification services, and so on. We also implemented
    their functionality by using actual code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了与支付网关、订单跟踪、通知服务等相关的外部API/组件的集成。我们还通过实际代码实现了它们的功能。
- en: Testing is the one process that helps us to make our code error free. It is
    also a practice for all developers who want to make their code clean and maintainable.
    In the next chapter, we will cover the testing paradigm in day-to-day development activities.
    We will discuss some important terms associated with the test paradigm. We will
    also cover the theory around these terms, and then we will cover code examples,
    looking at stubs and mocks, and learning about integration, security, and performance
    testing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是我们帮助代码无错误的唯一过程。它也是所有希望使代码整洁和可维护的开发者的实践。在下一章中，我们将涵盖日常开发活动中的测试范式。我们将讨论与测试范式相关的一些重要术语。我们还将涵盖这些术语的理论，然后我们将涵盖代码示例，查看存根和模拟，并了解集成、安全和性能测试。
