<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-46"><a id="_idTextAnchor045"/>3</h1>
<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Refactoring Code Flow and Iteration</h1>
<p>While other chapters in <em class="italic">Part 1</em> focus on refactorings that can be applied to entire methods or classes, this chapter focuses on improving the readability and efficiency of individual lines of code.</p>
<p>Developers spend the majority of their time reading over individual lines of code and only a fraction of that time modifying code. So, it is important to make our lines of code as maintainable as possible.</p>
<p>In this chapter, we’ll explore the following topics related to improving small pieces of code:</p>
<ul>
<li>Controlling program flow</li>
<li>Instantiating objects</li>
<li>Iterating over collections</li>
<li>Refactoring LINQ statements</li>
<li>Reviewing and testing our refactored code</li>
</ul>
<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Technical requirements</h1>
<p>The starting code for this chapter is available from GitHub at <a href="https://github.com/PacktPublishing/Refactoring-with-CSharp">https://github.com/PacktPublishing/Refactoring-with-CSharp</a> in the <code>Chapter03/Ch3BeginningCode</code> folder.</p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor048"/>Refactoring the boarding app</h1>
<p>This chapter’s code focuses on a pair of<a id="_idIndexMarker094"/> applications for Cloudy Skies Airline:</p>
<ul>
<li>A <em class="italic">Boarding Status Display</em> app that tells the user if it’s time for them to board their flight based on the current boarding group and the person’s ticket, military status, and whether or not they need assistance getting down the jetway.</li>
<li>A <em class="italic">Boarding Kiosk</em> app that allows airline employees to view the passengers scheduled to be on the flight and <a id="_idIndexMarker095"/>provides information regarding whether each passenger has boarded. <em class="italic">Figure 3</em><em class="italic">.1</em> shows the application in action:</li>
</ul>
<div><div><img alt="Figure 3.1 – The Boarding Kiosk app" src="img/B21324_03_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The Boarding Kiosk app</p>
<p>Since we’re exploring not one but two applications, we’ll meet the application code in small chunks as we progress through this chapter. However, feel free to peruse it yourself on GitHub if you’d like to orient yourself first.</p>
<p>As we go through this chapter, we’ll take its existing functioning code and see how small refactoring steps can improve the maintainability of the code using various C# language features.</p>
<p>We’ll start by looking at how refactoring can improve the overall flow of code.</p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/>Controlling program flow</h1>
<p>One of the most basic things new developers learn is how programs execute lines of code in sequence and how <strong class="bold">if statements</strong> and other<a id="_idIndexMarker096"/> language features control what statements execute <a id="_idIndexMarker097"/>next.</p>
<p>In this section, we’ll focus on the <code>BoardingProcessor</code> class's <code>CanPassengerBoard</code> method. The method starts simple enough:</p>
<pre class="source-code">
public string CanPassengerBoard(Passenger passenger) {
  bool isMilitary = passenger.IsMilitary;
  bool needsHelp = passenger.NeedsHelp;
  int group = passenger.BoardingGroup;</pre>
<p>Here, <code>CanPassengerBoard</code> takes in a <code>Passenger</code> object and returns a string. The method also declares a few local variables holding pieces of data from the object passed in.</p>
<p>These variables aren’t necessary and could be removed by performing an inline variable refactoring, which we’ll talk about later in this chapter. However, as they improve the readability of the code that follows, their existence is largely helpful. This is part of the reason why we sometimes introduce local variables, as we covered in <a href="B21324_02.xhtml#_idTextAnchor026"><em class="italic">Chapter 2</em></a>.</p>
<p>The logic that follows gets significantly harder to read, as seen here:</p>
<pre class="source-code">
 if (Status != BoardingStatus.PlaneDeparted) {
   if (isMilitary &amp;&amp; Status == BoardingStatus.Boarding) {
      return "Board Now via Priority Lane";
   } else if (needsHelp&amp;&amp;Status==BoardingStatus.Boarding) {
      return "Board Now via Priority Lane";
   } else if (Status == BoardingStatus.Boarding) {
      if (CurrentBoardingGroup &gt;= group) {
         if (_priorityLaneGroups.Contains(group)) {
            return "Board Now via Priority Lane";
         } else {
           return "Board Now";
         }
      } else {
         return "Please Wait";
      }
   } else {
      return "Boarding Not Started";
   }
 } else {
   return "Flight Departed";
 }
}</pre>
<p>This method primarily uses <code>if</code>/<code>else</code> statements with a few scattered variable declarations and periodic<a id="_idIndexMarker098"/> return statements. These are fundamental structures of computer programming, and yet it takes a moment to understand what this code truly does.</p>
<p>For those not wanting to sort through the logic, this code follows these rules:</p>
<ul>
<li>If the plane has departed, return <code>"</code><code>Flight Departed"</code></li>
<li>If the plane is not yet boarding, return <code>"Boarding </code><code>Not Started"</code></li>
<li>If the plane is boarding and the passenger needs help or is active military, return <code>"Board Now via </code><code>Priority Lane"</code></li>
<li>If the plane is boarding and the passenger’s group is not boarding yet, return <code>"</code><code>Please Wait"</code></li>
<li>If the passenger’s group can board, tell them to board either by the normal lane or via the priority lane if their boarding group is one of the priority groups</li>
</ul>
<p>However, the code is complex enough that puzzling out these rules can take a bit of time, and the complexity results in uncertainty, making it difficult for others to understand the rules in their entirety.</p>
<p>Understanding these rules is<a id="_idIndexMarker099"/> important if you’re going to maintain the code. So, improving the readability of this code is important to the code’s long-term success.</p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>Inverting if statements</h2>
<p>One of the quickest tricks to simplifying <a id="_idIndexMarker100"/>complex logic involving <a id="_idIndexMarker101"/>nested <code>if</code> statements can be to invert the <code>if</code> statement and return early.</p>
<p>Currently, our high-level logic looks like this:</p>
<pre class="source-code">
<strong class="bold">if (Status != BoardingStatus.PlaneDeparted) {</strong>
  // 17 lines of additional if statements and conditions
<strong class="bold">} else {</strong>
  return "Flight Departed";
<strong class="bold">}</strong></pre>
<p>By the time we get back to the <code>else</code> statement associated with the plane departed check, the reader has forgotten what the original <code>if</code> statement was to begin with!</p>
<p>Here, since the <code>else</code> branch is so simple and easy to understand, it’s helpful to invert the <code>if</code> statement by taking the following actions:</p>
<ol>
<li>Swap the contents of the <code>if</code> block and the <code>else</code> block.</li>
<li>Invert the boolean expression in the <code>if</code> statement. When inverting <code>==</code>, it becomes <code>!=</code> and vice versa. In cases where we do a <code>&gt;</code> or <code>&lt;</code> check, you flip the operand and toggle whether equality is included. Under these rules, <code>&gt;=</code> becomes <code>&lt;</code> and <code>&gt;=</code> becomes <code>&gt;</code>.</li>
</ol>
<p>In our case, we check that <code>Status != BoardingStatus.PlaneDeparted</code>. In this case, we’d change <code>!=</code> to <code>==</code> and wind up with this:</p>
<pre class="source-code">
Status == BoardingStatus.PlaneDeparted</pre>
<p>These steps preserve the program’s existing behavior but change the order of the statements in the code. This can increase the readability of our source code.</p>
<p>If this sounds <a id="_idIndexMarker102"/>complicated, don’t worry, because Visual Studio has a <strong class="bold">Quick Action</strong> refactoring for it <a id="_idIndexMarker103"/>called <strong class="bold">Invert if</strong>, as shown in <em class="italic">Figure 3</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 3.2 – The Invert if Quick Action refactoring" src="img/B21324_03_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – The Invert if Quick Action refactoring</p>
<p>Performing the refactoring here effectively changes our logic to the following:</p>
<pre class="source-code">
<strong class="bold">if (Status == BoardingStatus.PlaneDeparted) {</strong>
  return "Flight Departed";
<strong class="bold">} else {</strong>
  // 17 lines of additional if statements and conditions
<strong class="bold">}</strong></pre>
<p>While this is easier to read since the reader no longer must remember what the <code>if</code> statement even pertains to 17 lines later, the code can be improved further.</p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>Dropping else statements after return statements</h2>
<p>Since the <code>return</code> statement always<a id="_idIndexMarker104"/> leaves the method immediately, you never explicitly <em class="italic">need</em> an <code>else</code> statement <a id="_idIndexMarker105"/>after a <code>return</code> statement because you know that if you get to the <code>return</code> statement, logic after the <code>if</code> block won’t execute.</p>
<p>This lets us remove the <code>else</code> keyword and its curly braces. Then, we can outdent the code that was previously in the <code>else</code> block.</p>
<p>The resulting code keeps the <code>if</code> statement:</p>
<pre class="source-code">
if (Status == BoardingStatus.PlaneDeparted) {
  return "Flight Departed";
}</pre>
<p>After this statement, the code that follows is now at the same indentation level as the original <code>if</code> statement and is <a id="_idIndexMarker106"/>easier to read and<a id="_idIndexMarker107"/> understand:</p>
<pre class="source-code">
if (isMilitary &amp;&amp; Status == BoardingStatus.Boarding) {
  return "Board Now via Priority Lane";
} else if (needsHelp&amp;&amp;Status == BoardingStatus.Boarding) {
  return "Board Now via Priority Lane";
} else if (Status == BoardingStatus.Boarding) {
  if (CurrentBoardingGroup &gt;= group) {
     if (_priorityLaneGroups.Contains(group)) {
        return "Board Now via Priority Lane";
     } else {
        return "Board Now";
     }
  } else {
     return "Please Wait";
  }
} else {
  return "Boarding Not Started";
}</pre>
<p>We can repeat this refactoring a few more times if we want to since the code has a few more <code>if</code>/<code>return</code>/<code>else</code> sequences.</p>
<p>I’ll leave those for the moment<a id="_idIndexMarker108"/> since there’s another refactoring I want to show you that can help with what we’re<a id="_idIndexMarker109"/> seeing here.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>Restructuring if statements</h2>
<p>Looking at the <a id="_idIndexMarker110"/>previous code, some of the logic <a id="_idIndexMarker111"/>stands out as repetitive:</p>
<pre class="source-code">
if (isMilitary &amp;&amp; <strong class="bold">Status == BoardingStatus.Boarding</strong>) {
  return "Board Now via Priority Lane";
} else if (needsHelp&amp;&amp;<strong class="bold">Status == BoardingStatus.Boarding</strong>) {
  return "Board Now via Priority Lane";
} else if (<strong class="bold">Status == BoardingStatus.Boarding</strong>) {
  // Code omitted for brevity
} else {
  return "Boarding Not Started";
}</pre>
<p>Here, we have an <code>if</code>/<code>else</code> chain where three different things are checking whether the flight is currently boarding. Although each of these three <code>if</code> statements is different, there’s enough overlap between them that it makes me question if we could be less repetitive.</p>
<p>The first option we could consider might be a simple <em class="italic">introduce local variable</em> refactoring, as we saw in <a href="B21324_02.xhtml#_idTextAnchor026"><em class="italic">Chapter 2</em></a>:</p>
<pre class="source-code">
<strong class="bold">bool isBoarding = Status == BoardingStatus.Boarding</strong>;
if (isMilitary &amp;&amp; <strong class="bold">isBoarding</strong>) {
  return "Board Now via Priority Lane";
} else if (needsHelp &amp;&amp; <strong class="bold">isBoarding</strong>) {
  return "Board Now via Priority Lane";
} else if (<strong class="bold">isBoarding</strong>) {
  // Code omitted for brevity
} else {
  return "Boarding Not Started";
}</pre>
<p>I find this code easier to <a id="_idIndexMarker112"/>read, even though we gained <a id="_idIndexMarker113"/>an extra line from the new local variable. However, let’s take a slightly different approach.</p>
<p>Instead of introducing a variable, we can rearrange our if statements to have an additional layer of nesting:</p>
<pre class="source-code">
<strong class="bold">if (Status == BoardingStatus.Boarding) {</strong>
  if <strong class="bold">(</strong>isMilitary<strong class="bold">)</strong> {
     return "Board Now via Priority Lane";
  } else if <strong class="bold">(</strong>needsHelp<strong class="bold">)</strong> {
     return "Board Now via Priority Lane";
  } else {
     // Code omitted for brevity
  }
<strong class="bold">} else {</strong>
  return "Boarding Not Started";
<strong class="bold">}</strong></pre>
<p>Here, pulling a common condition from a set of <code>if</code> statements into an outer <code>if</code> statement helped clarify those <code>if</code> statements, although it did so at the expense of an additional degree of nesting.</p>
<p>However, this simplification helps spot a few other refactoring opportunities, such as combining the <code>isMilitary</code> and <code>needsHelp</code> checks <a id="_idIndexMarker114"/>since they return the same value if either is true:</p>
<pre class="source-code">
if <strong class="bold">(isMilitary || needsHelp)</strong> {
  return "Board Now via Priority Lane";
}</pre>
<p>We can also drop the <code>else</code> statement after the <code>if</code>/<code>return</code> code to outdent our code a bit more, leaving<a id="_idIndexMarker115"/> just the boarding group logic:</p>
<pre class="source-code">
if (CurrentBoardingGroup &gt;= group) {
  if (_priorityLaneGroups.Contains(group)) {
     return "Board Now via Priority Lane";
  } else {
     return "Board Now";
  }
} else {
  return "Please Wait";
}</pre>
<p>This looks like another place where we can invert <code>if</code> and drop the <code>else</code> statement to simplify the code even more. Remember that we must change <code>&gt;=</code> to <code>&lt;</code> to do this:</p>
<pre class="source-code">
<strong class="bold">if (CurrentBoardingGroup &lt; group) {</strong>
<strong class="bold">  return "Please Wait";</strong>
<strong class="bold">}</strong>
if (_priorityLaneGroups.Contains(group)) {
  return "Board Now via Priority Lane";
} else {
  return "Board Now";
}</pre>
<p>As you can see, the code is getting significantly easier to read as we simplify it.</p>
<p>Let’s take a step back and look at our conditional logic after these refactorings:</p>
<pre class="source-code">
if (Status == BoardingStatus.PlaneDeparted) {
  return "Flight Departed";
}
if (Status == BoardingStatus.Boarding) {
  if (isMilitary || needsHelp) {
     return "Board Now via Priority Lane";
  }
  if (CurrentBoardingGroup &lt; group) {
     return "Please Wait";
  }
  if (_priorityLaneGroups.Contains(group)) {
     return "Board Now via Priority Lane";
  } else {
     return "Board Now";
  }
} else {
  return "Boarding Not Started";
}</pre>
<p>The code is now easier to read and harder to misinterpret. We could invert the Boarding status check to return early, but we'll do something else with here later.</p>
<p>Let’s look at how we can reduce our line count even further through a more divisive language feature: the <strong class="bold">ternary operator</strong>.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Using ternary operators</h2>
<p>If you’re a fan of the ternary <a id="_idIndexMarker116"/>operator, you may have <a id="_idIndexMarker117"/>noticed an opportunity to use one in the code as we’ve been refactoring.</p>
<p>For those not familiar or not fully comfortable with the ternary conditional operator, think of it as a condensed <em class="italic">if my condition is true use this value, otherwise use this other value</em> type of an operator.</p>
<p>The syntax for ternary is <code>boolExpression ? trueValue : </code><code>falseValue;</code>.</p>
<p>In other words, you could write code without a ternary like this:</p>
<pre class="source-code">
int value;
if (<strong class="bold">someCondition</strong>) {
  value = <strong class="bold">1</strong>;
} else {
  value = <strong class="bold">2</strong>;
}</pre>
<p>However, the same code could be written using a ternary in a single line:</p>
<pre class="source-code">
int value = <strong class="bold">someCondition ? 1 : 2</strong>;</pre>
<p>As you can see, the ternary operator lets us take six lines of code and condense it down to a single line. This conciseness is a key factor for those who like using ternaries in their code.</p>
<p>Those who are less fond of ternary operators often point out that ternaries are difficult to read – particularly when trying to read through code quickly. In other words, while they make code more concise, this conciseness can slow you down in the long run by making the code less easy to maintain.</p>
<p>Let’s look at a small part of our code and see how a ternary could be applied:</p>
<pre class="source-code">
  if (CurrentBoardingGroup &lt; group) {
     return "Please Wait";
  }
<strong class="bold">  if (_priorityLaneGroups.Contains(group)) {</strong>
<strong class="bold">     return "Board Now via Priority Lane";</strong>
<strong class="bold">  } else {</strong>
<strong class="bold">     return "Board Now";</strong>
<strong class="bold">  }</strong></pre>
<p>Here, we are checking if the <a id="_idIndexMarker118"/>current boarding group is a priority group and then telling the user to board with the priority lane or to board <a id="_idIndexMarker119"/>normally based on the result of the <code>Contains</code> call.</p>
<p>Since we’re returning a single value based on the result of a boolean expression, we could rewrite the code with a ternary as follows:</p>
<pre class="source-code">
if (CurrentBoardingGroup &lt; group) {
  return "Please Wait";
}
<strong class="bold">return _priorityLaneGroups.Contains(group)</strong>
<strong class="bold">        ? "Board Now via Priority Lane"</strong>
<strong class="bold">        : "Board Now";</strong></pre>
<p>This chops five lines of code down to three lines of code or a single line of code if you want to put the <code>?</code> and <code>:</code> segments on the same line as the boolean expression.</p>
<p>You might have noticed that this refactoring now puts the whole block of code into a position where you could introduce another ternary based on the boarding group, <code>return "Please Wait"</code>, if that expression is true, and return the result of the earlier ternary expression if the expression is false:</p>
<pre class="source-code">
return <strong class="bold">(CurrentBoardingGroup &lt; group)</strong>
  <strong class="bold">?</strong> "Please Wait"
  <strong class="bold">:</strong> _priorityLaneGroups.Contains(group)
     ? "Board Now via Priority Lane"
     : "Board Now";</pre>
<p>While this is valid C#, I can attest that if a coworker showed this to me in code review, I would be tempted to utter some not-very-nice words!</p>
<p class="callout-heading">Tip</p>
<p class="callout">Remember: fewer lines of code don’t always equate to greater maintainability.</p>
<p>At a personal level, my <a id="_idIndexMarker120"/>preference is to avoid the ternary in many places and always avoid chaining ternaries together. However, I do<a id="_idIndexMarker121"/> sometimes use ternaries when I feel it is right for a piece of code.</p>
<p>For example, sometimes, a method is very simple and can be condensed to a single line of code if you use a ternary expression. This particular change lets you use the expression-bodied members feature, which we’ll talk about in <a href="B21324_04.xhtml#_idTextAnchor072"><em class="italic">Chapter 4</em></a>.</p>
<p>When I use a ternary, I format my ternary expressions on three separate lines, as shown earlier, with the first line containing the boolean expression. The second line will feature the <code>?</code> operator and the value to use if the expression was true, and the third line will feature the <code>:</code> operator and the value to use if the expression was false:</p>
<pre class="source-code">
var myVar = <strong class="bold">booleanExpression</strong>
<strong class="bold">                    ? valueIfTrue</strong>
<strong class="bold">                    : valueIfFalse</strong>;</pre>
<p>I find that this approach strikes a happy medium between the benefits of more concise code from the ternary and the penalties of code becoming more difficult to read quickly and accurately when using a ternary.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Converting if statements into switch statements</h2>
<p>The logic of this method is<a id="_idIndexMarker122"/> now a lot easier to understand, and simplifying it down to this level highlights that we’re doing one of three <a id="_idIndexMarker123"/>things, depending on the current boarding status:</p>
<ul>
<li>Notifying the user the flight has departed if its status is <code>PlaneDeparted</code></li>
<li>Checking military status, whether help boarding is needed, and the boarding group for <code>Boarding</code> status</li>
<li>Notifying the user that boarding hasn’t started yet for other statuses (<code>NotStarted</code> is the only other status at the moment)</li>
</ul>
<p>When working with enumerated<a id="_idIndexMarker124"/> values, this kind of branching logic is common.</p>
<p>In our case, our <code>enum</code> value only has<a id="_idIndexMarker125"/> three states:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">BoardingStatus.cs</p>
<pre class="source-code">
public enum BoardingStatus {
  NotStarted = 0,
  Boarding = 1,
  PlaneDeparted = 2,
}</pre>
<p>In cases where you find yourself checking the same variable for different values, you can usually rewrite them to use a <strong class="bold">switch </strong><strong class="bold">statement</strong> instead.</p>
<p><code>switch</code> statements are essentially a streamlined series of <code>if</code>/<code>else</code> <code>if</code>/<code>else</code> types of checks that all check the same value, as our code does with <code>Status</code>. We’ll see an example of a <code>switch</code> statement shortly, but if you’re not familiar with them, you can think of them as just a different way of writing a series of related <code>if</code>/<code>else</code> <code>if</code> statements.</p>
<p>This can be done manually, or you can use a specific refactoring built into Visual Studio if your code is built in an <code>if</code>/<code>else</code> <code>if</code>/<code>else</code> type of structure, as the following code illustrates:</p>
<pre class="source-code">
if (Status == BoardingStatus.PlaneDeparted) {
  return "Flight Departed";
} <strong class="bold">else</strong> if (Status == BoardingStatus.Boarding) {
  if (isMilitary || needsHelp) {
     return "Board Now via Priority Lane";
  }
  if (CurrentBoardingGroup &lt; group) {
     return "Please Wait";
  }
  return _priorityLaneGroups.Contains(group)
           ? "Board Now via Priority Lane"
           : "Board Now";
} else {
  return "Boarding Not Started";
}</pre>
<p>Note here that I did add the <code>else</code> keyword (in bold in the previous snippet) to our earlier code to get into that <code>if</code>/<code>else</code> <code>if</code>/<code>else</code> structure, which lets Visual Studio identify the refactoring <a id="_idIndexMarker126"/>we’re about to use.</p>
<p>Once we have the <a id="_idIndexMarker127"/>code in this pattern, the <code>if</code> statement selected, as shown in <em class="italic">Figure 3</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 3.3 – The Convert to “switch” statement refactoring option" src="img/B21324_03_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – The Convert to “switch” statement refactoring option</p>
<p>This refactoring makes <a id="_idIndexMarker128"/>our status-based <a id="_idIndexMarker129"/>logic much more apparent:</p>
<pre class="source-code">
<strong class="bold">switch (Status) {</strong>
  <strong class="bold">case BoardingStatus.PlaneDeparted:</strong>
     return "Flight Departed";
  <strong class="bold">case BoardingStatus.Boarding:</strong>
     if (isMilitary || needsHelp) {
        return "Board Now via Priority Lane";
     }
     if (CurrentBoardingGroup &lt; group) {
        return "Please Wait";
     }
     return _priorityLaneGroups.Contains(group)
              ? "Board Now via Priority Lane"
              : "Board Now";
  <strong class="bold">default:</strong>
     return "Boarding Not Started";
}</pre>
<p>As someone reading this code, I find this a lot easier to scan and interpret compared to an <code>if</code>/<code>else if</code>/<code>else</code> chain, even<a id="_idIndexMarker130"/> though the logic functions identically. With an <code>if</code>/<code>else</code> <code>if</code>/<code>else</code> statement, I <em class="italic">may</em> notice that logic is comparing the same value several different times, while a <code>switch</code> statement makes it explicit.</p>
<p>Another benefit you get <a id="_idIndexMarker131"/>with a <code>switch</code> statement is that it unlocks a built-in refactoring option when your switch compares an <code>enum</code> value (such as <code>BoardingStatus</code>) and you’re missing a case for one or more <code>enum</code> values.</p>
<p>This option shows up in the <strong class="bold">Quick Actions</strong> menu for the switch statement as <strong class="bold">Add missing cases</strong>, as shown in <em class="italic">Figure 3</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 3.4 – The Add missing cases refactoring option in the Quick Actions menu" src="img/B21324_03_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – The Add missing cases refactoring option in the Quick Actions menu</p>
<p class="callout-heading">Warning</p>
<p class="callout">I want to point out that the <code>NotStarted</code> status and has it break out of the switch instead of returning a value as it previously would have through the <code>default</code> keyword.</p>
<p class="callout">The C# compiler will flag this mistake for us in this case since the method won’t return a value for this path, but adding missing cases when a <code>default</code> case is present in a <code>switch</code> statement typically does introduce a change in behavior.</p>
<p>In our case, we <a id="_idIndexMarker132"/>can merge the <code>NotStarted</code> status with the default case and get a more explicit list of <a id="_idIndexMarker133"/>options:</p>
<pre class="source-code">
switch (Status) {
  case BoardingStatus.PlaneDeparted:
     return "Flight Departed";
  case BoardingStatus.Boarding:
     if (isMilitary || needsHelp) {
        return "Board Now via Priority Lane";
     }
     if (CurrentBoardingGroup &lt; group) {
        return "Please Wait";
     }
     return _priorityLaneGroups.Contains(group)
              ? "Board Now via Priority Lane"
              : "Board Now";
<strong class="bold">  case BoardingStatus.NotStarted:</strong>
<strong class="bold">  default:</strong>
<strong class="bold">     return "Boarding Not Started";</strong>
}</pre>
<p>This code is now significantly easier to read than it was before, and the flow of logic by status is now readily apparent.</p>
<p>In a real-world application, I might change the default case to throw an exception, explicitly telling me that a specific <code>Status</code> was not supported by this logic. This would look something like the following logic:</p>
<pre class="source-code">
case BoardingStatus.NotStarted:
  return "Boarding Not Started";
<strong class="bold">default:</strong>
<strong class="bold"> throw new NotSupportedException($"Unsupported: {Status}");</strong></pre>
<p>I might also be tempted to perform <em class="italic">extract method</em> refactoring – as we saw in <a href="B21324_02.xhtml#_idTextAnchor026"><em class="italic">Chapter 2</em></a> – to move the logic<a id="_idIndexMarker134"/> for handling the boarding status into its own method. However, I’ll hold off on doing that to showcase <a id="_idIndexMarker135"/>switch expressions instead.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Converting to switch expressions</h2>
<p><strong class="bold">Switch expressions</strong> are an<a id="_idIndexMarker136"/> evolution of switch statements that rely on <strong class="bold">pattern-matching</strong> expressions to simplify and expand <a id="_idIndexMarker137"/>what’s possible inside switch <a id="_idIndexMarker138"/>statements.</p>
<p><code>switch</code> expressions are a relatively new feature in C# that was released as part of C# 8 in 2019. While that’s more than a few years old at the time of writing, I still find switch expressions to be new enough that many C# developers are unfamiliar or unpracticed with them.</p>
<p>A simple <code>switch</code> expression looks a lot like a switch statement:</p>
<pre class="source-code">
return Status <strong class="bold">switch</strong> {
  BoardingStatus.PlaneDeparted =&gt; "Flight Departed",
  BoardingStatus.NotStarted =&gt; "Boarding Not Started",
  BoardingStatus.Boarding =&gt; "Board Now",
  _ =&gt; "Some other status",
};</pre>
<p>These <code>switch</code> expressions look very similar to switch statements except for the following aspects:</p>
<ul>
<li>They start with the value you want to evaluate followed by the <code>switch</code> keyword instead of starting with <code>switch (value)</code></li>
<li>We don’t use the <code>case</code> or <code>break</code> keywords</li>
<li>Individual cases have some<a id="_idIndexMarker139"/> condition that might be true on the left, an arrow notation (<code>=&gt;</code>), and then the value to use on the right if the condition on the left is true.</li>
<li>Instead of the <code>default</code> keyword, we have <code>_</code>, indicating any other match</li>
</ul>
<p>One of the nice things<a id="_idIndexMarker140"/> about <code>switch</code> expressions is that they’re extremely concise while still being somewhat readable. However, there’s more power to <code>switch</code> expressions than what I’ve shown you so far.</p>
<p>You may have noticed the sample <code>switch</code> expression I introduced a moment ago doesn’t adequately handle the logic for boarding. Specifically, we had rules for active military members, people who need assistance boarding, boarding groups, and priority lanes, and none of that is represented in the previous block of code.</p>
<p>Let’s take a look at a <code>switch</code> expression that does handle these things:</p>
<pre class="source-code">
return Status switch {
  BoardingStatus.PlaneDeparted =&gt; "Flight Departed",
  BoardingStatus.NotStarted =&gt; "Boarding Not Started",
<strong class="bold">  BoardingStatus.Boarding when isMilitary || needsHelp</strong>
<strong class="bold">     =&gt; "Board Now via Priority Lane",</strong>
<strong class="bold">  BoardingStatus.Boarding when CurrentBoardingGroup &lt; group</strong>
<strong class="bold">     =&gt; "Please Wait",</strong>
<strong class="bold">  BoardingStatus.Boarding when</strong>
<strong class="bold">   _priorityLaneGroups.Contains(group)</strong>
<strong class="bold">     =&gt; "Board Now via Priority Lane",</strong>
<strong class="bold">  BoardingStatus.Boarding =&gt; "Board Now",</strong>
  _ =&gt; "Some other status",
};</pre>
<p>This code is a bit different than the last <code>switch</code> expression we saw. Here, the <code>Boarding</code> status is repeated four times and sometimes accompanied by the <code>when</code> keyword.</p>
<p>What this code is doing is using pattern matching to check not just that <code>Status</code> is <code>Boarding</code>, but that other<a id="_idIndexMarker141"/> conditions are true as well. Effectively, we’re able to check the status and optionally another boolean <a id="_idIndexMarker142"/>expression after the <code>when</code> keyword.</p>
<p>If both things are not true, the <code>switch</code> expression evaluates the next line in sequence. This makes <code>switch</code> expressions a set of matching rules that ensure the first rule evaluates to true.</p>
<p class="callout-heading">Pattern matching</p>
<p class="callout">Pattern matching is a<a id="_idIndexMarker143"/> newer C# syntax that allows you to concisely check different properties and aspects of objects and variables. We’ll explore pattern-matching syntax more in <a href="B21324_10.xhtml#_idTextAnchor209"><em class="italic">Chapter 10</em></a>, <em class="italic">Defensive Coding Techniques</em>, but this section serves as a good introduction to some of its capabilities.</p>
<p>In other words, this <code>switch</code> expression checks the following rules and reacts to the first one that is true:</p>
<ol>
<li>The plane has departed.</li>
<li>Boarding hasn’t started yet.</li>
<li>Boarding has started and the passenger is active military or needs assistance.</li>
<li>The passenger’s boarding group hasn’t been called yet.</li>
<li>The passenger’s group is boarding and it’s a priority lane group.</li>
<li>The passenger’s group is boarding but they’re not in the priority boarding lane.</li>
<li>Any other status</li>
</ol>
<p><code>switch</code> expressions are concise and allow you to mix the structured clarity of <code>switch</code> statements with the power of pattern matching and the <code>when</code> keyword to make very readable ordered logic apparent.</p>
<p>As with any tool in your programming toolbelt, <code>switch</code> expressions won’t be the solution to every problem and <a id="_idIndexMarker144"/>you and your team may not be as fond of reading <code>switch</code> expressions as I am. However, they remain a valuable tool in your toolbox for simplifying code while keeping it easy to read, maintain, and expand.</p>
<p>We’ll revisit some of the<a id="_idIndexMarker145"/> pattern-matching syntax in <a href="B21324_10.xhtml#_idTextAnchor209"><em class="italic">Chapter 10</em></a>, but let’s move on to looking at what we can do to improve working with collections of objects.</p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/>Instantiating objects</h1>
<p>Now that we’ve sufficiently improved our <code>CanPassengerBoard</code> method, let’s look at how we can create objects and see<a id="_idIndexMarker146"/> a few simple improvements you can make that will simplify <a id="_idIndexMarker147"/>object <strong class="bold">instantiation</strong> in your code.</p>
<p class="callout-heading">Terminology notes</p>
<p class="callout">New developers are often tripped up by a handful of phrases that are commonly used by developers. For example, in this section, we will talk about instantiating objects. This is a common way of phrasing this for developers, but all it means is the process of creating a specific <em class="italic">instance</em> of a class using the <code>new</code> keyword. When you see the term instantiating, you can think of it simply as creating a specific instance of something.</p>
<p class="callout">This section’s code could come from anywhere, but we’ll focus on code found in a pair of methods in the <code>PassengerTests.cs</code> file in the test project that accompanies this chapter.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Replacing var with explicit Types</h2>
<p>The first line of code I want to focus on<a id="_idIndexMarker148"/> comes from one of our unit tests:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">PassengerTests.cs</p>
<pre class="source-code">
<strong class="bold">var p </strong>= Build(first, last);</pre>
<p>Here, I’ve deliberately omitted the context of<a id="_idIndexMarker149"/> the code from the surrounding lines to reinforce a point, and the point is this: take a moment and try to determine what data type the <code>p</code> variable is.</p>
<p><code>p</code> stores the result of <code>Build</code>, which takes in a pair of parameters named <code>first</code> and <code>last</code>, but we can’t make a confident assertion about what type of data <code>p</code> holds from this line alone.</p>
<p>This is because <code>p</code> was declared with the <code>var</code> keyword. The <code>var</code> keyword is a shorthand way of saying “Hey, compiler, when you’re compiling this code, I want you to determine what data type this is going to be and replace the <code>var</code> keyword in the compiled code with the actual type of the data.”</p>
<p>In other words, <code>var</code> is usually a shortcut for not typing out the full name of the data type in question. However, it comes with a small penalty in that it makes it harder to read what data type the variable contains.</p>
<p>This makes sense for when you have a complex data type such as <code>IDictionary&lt;Guid, HashSet&lt;string&gt;&gt;</code>, but it can get a little ridiculous for short type names such as <code>int</code>.</p>
<p class="callout-heading">Other uses of var</p>
<p class="callout">The <code>var</code> keyword does have other uses beyond what I’ve described here. For example, it can easily store <code>var</code> in most codebases.</p>
<p>Visual Studio does let you hover over the variable declaration and see the actual Type being used. In this case, <code>p</code> represents a <code>Passenger</code> object, but this still slows down your reading of the code.</p>
<p>Instead, I recommend that you take advantage of the built-in <strong class="bold">Use explicit type instead of ‘var’</strong> refactoring. See <em class="italic">Figure 3</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 3.5 – Using explicit types" src="img/B21324_03_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Using explicit types</p>
<p>This makes your code significantly easier to read:</p>
<pre class="source-code">
<strong class="bold">Passenger p</strong> = Build(first, last);</pre>
<p>Of course, <code>var</code> exists for a<a id="_idIndexMarker150"/> reason and it was introduced to <a id="_idIndexMarker151"/>solve certain problems, including redundancy in assignment statements. We’ll take a look at the <strong class="bold">target-typed new</strong> keyword next that offers a different solution to that problem.</p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Simplifying creation with target-typed new</h2>
<p>One of the<a id="_idIndexMarker152"/> things the <code>var</code> keyword was built to <a id="_idIndexMarker153"/>help with was lines such as the following variable instantiation:</p>
<pre class="source-code">
private Passenger Build(string firstName, string lastName){
     <strong class="bold">Passenger passenger = new Passenger();</strong>
     passenger.FirstName = firstName;
     passenger.LastName = lastName;
     return passenger;
}</pre>
<p>When we instantiate a new <code>Passenger</code> object and assign it to the new passenger variable, we repeat ourselves slightly on the left and right-hand sides of the assignment operator (<code>=</code>) by using the name of the <code>Passenger</code> class twice.</p>
<p>The <code>var</code> keyword allowed us to simplify the creation of this object down to the still readable syntax of <code>var passenger = new Passenger();</code>. Here, <code>var</code> allows us to simplify the left-hand <a id="_idIndexMarker154"/>side of this assignment statement<a id="_idIndexMarker155"/> by abbreviating the type that’s used for the new variable.</p>
<p>C# 9 introduced the <strong class="bold">target-typed new</strong> keyword, which lets us simplify the right-hand side of the assignment operator by effectively saying that the type of class we’re instantiating is the same as the variable that acts as the target of the assignment operator.</p>
<p>In other words, target-typed new is a way of telling C# to create the same type as the variable we’ll store the value in. This allows us to avoid <code>var</code> and not repeat ourselves:</p>
<pre class="source-code">
Passenger passenger = <strong class="bold">new();</strong></pre>
<p>I love this syntax and tend to use it in all my code. It can cause small bits of confusion for other developers the first time they see the feature, but that’s a minor one-time penalty for something that keeps your code concise and readable at the same time.</p>
<p class="callout-heading">Tip</p>
<p class="callout">Visual Studio gives you a <strong class="bold">Use ‘new(…)’</strong> option in the <strong class="bold">Quick Action</strong> menu that will let you change a traditional object instantiation to the target-typed new syntax.</p>
<p>While we’re talking about creating objects, let’s look at how <strong class="bold">object initializers</strong> can help set properties on objects as you create them.</p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Using object initializers</h2>
<p>Let’s take<a id="_idIndexMarker156"/> another look at that <code>Build</code> method from the previous example while focusing on configuring the created passenger object:</p>
<pre class="source-code">
private Passenger Build(string firstName, string lastName){
     Passenger passenger = new();
<strong class="bold">     passenger.FirstName = firstName;</strong>
<strong class="bold">     </strong><strong class="bold">passenger.LastName = lastName;</strong>
     return passenger;
}</pre>
<p>This code isn’t bad at all, but it does repeat itself a little.</p>
<p>Specifically, the code repeats the information of the object it configures each line by putting <code>passenger.</code> in front of each property before assigning a value to that property.</p>
<p>This is very minimal with <a id="_idIndexMarker157"/>only two properties. But imagine a larger object with 10 or more properties you want to configure. This code would get very repetitive and might even distract from the names of the properties that are being configured.</p>
<p>While using a constructor that takes in parameters representing property values is one solution (and one we’ll explore in the next chapter), another solution is to use an <strong class="bold">object initializer</strong>. As you’re likely guessing, Visual Studio provides a <strong class="bold">Quick Actions</strong> refactoring for this, though the name <strong class="bold">Object initialization can be simplified </strong>(shown in <em class="italic">Figure 3</em><em class="italic">.6</em>) is a bit unusual:</p>
<div><div><img alt="Figure 3.6 – Simplifying object initialization" src="img/B21324_03_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Simplifying object initialization</p>
<p>Using this refactoring transforms our code into a sparser format:</p>
<pre class="source-code">
private Passenger Build(string firstName, string lastName){
     <strong class="bold">Passenger passenger = new() {</strong>
<strong class="bold">           FirstName = firstName,</strong>
<strong class="bold">           </strong><strong class="bold">LastName = lastName</strong>
<strong class="bold">     };</strong>
     return passenger;
}</pre>
<p>I love this syntax and it plays very nicely with the <code>init</code> and <code>required</code> properties, which we’ll explore in <a href="B21324_10.xhtml#_idTextAnchor209"><em class="italic">Chapter 10</em></a>, <em class="italic">Defensive Coding Techniques</em>. However, there is a downside to using object initializers: stack traces.</p>
<p>When you have an object<a id="_idIndexMarker158"/> initializer that sets several different properties of an object and an exception occurs that calculates the value to store, the exception doesn’t indicate which line of code the error occurred on or which property was about to be updated, only that it occurred somewhere in the initializer.</p>
<p>On the other hand, if you were using multiple lines setting individual properties, the exception details would identify the line in question. Of course, this might be an argument to avoid doing calculations in initializers that might produce exceptions.</p>
<p>We’ll revisit initializers more in <a href="B21324_10.xhtml#_idTextAnchor209"><em class="italic">Chapter 10</em></a> when we discuss <code>init</code>, <code>required</code>, and <code>with</code> expressions, but for now, let’s move on to talking about collections.</p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor060"/>Iterating over collections</h1>
<p>To start exploring collections, let’s go back to the <code>BoardingProcessor</code> class and look at its <code>DisplayPassengerBoardingStatus</code> method. We’ll explore this method a bit at a time, starting<a id="_idIndexMarker159"/> with its method signature:</p>
<pre class="source-code">
public void DisplayBoardingStatus(
  List&lt;Passenger&gt; passengers, bool? hasBoarded = null) {</pre>
<p>Here, we can see that the method takes in a list of <code>Passenger</code> objects and, optionally, a nullable boolean <code>hasBoarded</code> parameter that can store <code>true</code>, <code>false</code>, or <code>null</code>. This <code>hasBoarded</code> parameter is used to optionally filter down our list of passengers based on its value:</p>
<ul>
<li><code>true</code>: Only include passengers who have boarded the plane</li>
<li><code>false</code>: Only include passengers who have not yet boarded</li>
<li><code>null</code>: Do not filter by boarded status (default option)</li>
</ul>
<p>This nullable filtering <a id="_idIndexMarker160"/>parameter is a common one I see while building search methods and we’ll explore it in more depth again in <a href="B21324_05.xhtml#_idTextAnchor101"><em class="italic">Chapter 5</em></a>, <em class="italic">Object-oriented Refactoring</em>.</p>
<p>The next portion of code in <code>DisplayBoardingStatus</code> deals with the filtering logic:</p>
<pre class="source-code">
  List&lt;Passenger&gt; filteredPassengers = new();
  for (int i = 0; i &lt; passengers.Count; i++) {
     Passenger p = passengers[i];
     if (!hasBoarded.HasValue || p.HasBoarded==hasBoarded) {
        filteredPassengers.Add(p);
     }
  }</pre>
<p>This is the portion of code we’ll be focusing on for the rest of this section. It builds a new list of passengers that matches the filtering option the user selected by iterating over the passengers in <code>passengers.</code> and conditionally adds it to our new list of passengers.</p>
<p class="callout-heading">Terminology note</p>
<p class="callout"><strong class="bold">Iterating</strong> over something is another term that confuses new developers. It just means looping through each item in a collection.</p>
<p>The remainder of the method focuses on displaying passengers to the agent at the boarding kiosk:</p>
<pre class="source-code">
  DisplayBoardingHeader();
  foreach (Passenger passenger in filteredPassengers) {
     string statusMessage = passenger.HasBoarded
        ? "Onboard"
        : CanPassengerBoard(passenger);
     Console.WriteLine($"{passenger.FullName,-23} Group         {passenger.BoardingGroup}: {statusMessage}");
  }
}</pre>
<p>Essentially, for every passenger that we want to display, we write out their name, boarding group, and the<a id="_idIndexMarker161"/> message they see on their boarding app or <code>"Onboard"</code> if they’ve already boarded the plane.</p>
<p>Overall, this method is simple and comes in at less than 20 lines of code long, which tends to lead to easy-to-maintain code.</p>
<p>That said, let’s look at a few ways we could improve this code.</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Introducing foreach</h2>
<p>Take another look at the <a id="_idIndexMarker162"/>code to filter the passenger list into a new list of passengers:</p>
<pre class="source-code">
List&lt;Passenger&gt; filteredPassengers = new();
<strong class="bold">for (int i = 0; i &lt; passengers.Count; i++) {</strong>
  <strong class="bold">Passenger p = passengers[i];</strong>
  if (!hasBoarded.HasValue || p.HasBoarded == hasBoarded) {
     filteredPassengers.Add(p);
  }
<strong class="bold">}</strong></pre>
<p>While this code isn’t very involved, one of the things that jumps out to me is that we’re using a <code>for</code> loop to enumerate through the passengers. Inside this loop, we’re not doing anything with our index variable, <code>i</code>, aside from getting a passenger out of the list by its index.</p>
<p>Whenever you have a <code>for</code> loop like this that isn’t doing anything complex (for example, starting anywhere but the beginning of the list, looping in reverse, or skipping every other item), you can usually<a id="_idIndexMarker163"/> replace the loop with a <code>foreach</code> loop.</p>
<p>To convert a <code>for</code> loop into a <code>foreach</code> loop, you can select the <code>for</code> loop and then use the <strong class="bold">Convert to ‘foreach’</strong> refactoring feature that’s built into Visual Studio (<em class="italic">Figure 3</em><em class="italic">.7</em>):</p>
<div><div><img alt="Figure 3.7 – The Convert to ‘foreach’ refactoring option in the Quick Actions menu" src="img/B21324_03_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – The Convert to ‘foreach’ refactoring option in the Quick Actions menu</p>
<p>This moves to a <code>foreach</code> loop and gets rid of the variable declaration entirely:</p>
<pre class="source-code">
List&lt;Passenger&gt; filteredPassengers = new();
<strong class="bold">foreach (Passenger p in passengers) {</strong>
  if (!hasBoarded.HasValue || p.HasBoarded == hasBoarded) {
     filteredPassengers.Add(p);
  }
<strong class="bold">}</strong></pre>
<p>I use <code>foreach</code> wherever I can because not only does it remove a variable declaration and use of the indexer, but it makes the overall code easier to read.</p>
<p><em class="italic">Almost all</em> <code>for</code> loops start at 0 and loop up to the end of the collection one item at a time, but not every <code>for</code> loop does this. As a result, whenever I read a <code>for</code> loop, I need to check if it is a standard <code>for</code> loop or if there’s something special about it. With a <code>foreach</code> loop, I don’t need to do this because the syntax doesn’t support it. This increases reading comfort and speed and improves the maintainability of your code through simplicity.</p>
<p>Additionally, a <code>foreach</code> loop can be used with anything that implements <code>IEnumerable</code>, while <code>for</code> loops require<a id="_idIndexMarker164"/> the collection they loop over to have an indexer. This means that <code>foreach</code> loops can loop over more types of collections than <code>for</code> loops can.</p>
<p class="callout-heading">Collection interfaces</p>
<p class="callout">.NET provides several collection interfaces, including <code>IEnumerable</code>, <code>ICollection</code>, <code>IList</code>, <code>IReadOnlyList</code>, and <code>IReadOnlyCollection</code>. Knowledge of these collection types is helpful but not required to read this book. See the <em class="italic">Further reading</em> section at the end of this chapter for a link to more information on these interfaces, but for now, know that an <code>IEnumerable</code> interface is just a fancy way of referring to something that can be looped over in a foreach loop.</p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Converting to for loops</h2>
<p>While <code>foreach</code> loops are fantastic and<a id="_idIndexMarker165"/> my default loop in most cases, sometimes, you want to have a <code>for</code> loop for a little bit of added control. If you ever need to loop over a collection in a non-standard way or need to use the index variable for something other than reading a variable out of the collection, you usually will want to use a <code>for</code> loop.</p>
<p>Visual Studio gives us a <code>foreach</code> loops into <code>for</code> loops for you. See <em class="italic">Figure 3</em><em class="italic">.8</em>:</p>
<div><div><img alt="Figure 3.8 – Converting a foreach loop back to a for loop" src="img/B21324_03_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Converting a foreach loop back to a for loop</p>
<p>I don’t find myself using this refactoring very much, but it’s handy when you need it.</p>
<p>For now, let’s leave the <a id="_idIndexMarker166"/>code in a <code>foreach</code> loop and look at how LINQ can help us make it better.</p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>Converting to LINQ</h2>
<p>You may have noticed that, in <em class="italic">Figure 3</em><em class="italic">.8</em>, there were a <a id="_idIndexMarker167"/>pair of suggestions to convert the <code>foreach</code> loop into LINQ.</p>
<p><code>IEnumerable</code>. This allows you to perform quick aggregation, transformation, and filtering operations on that collection using arrow functions.</p>
<p class="callout-heading">Arrow functions</p>
<p class="callout">Arrow functions (also called Lambda expressions) use “fat arrow” (<code>=&gt;</code>) syntax to represent small methods in an abbreviated format. This book assumes a basic understanding of <a id="_idIndexMarker168"/>arrow functions. See the <em class="italic">Further reading</em> section of this chapter if you need more information or want a refresher on how arrow functions work.</p>
<p>Let’s look at what happens to our <code>foreach</code> loop when we use the <code>foreach</code> loop’s <strong class="bold">Quick </strong><strong class="bold">Actions</strong> menu:</p>
<div><div><img alt="Figure 3.9 – Converting a foreach loop to use LINQ" src="img/B21324_03_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Converting a foreach loop to use LINQ</p>
<p>This refactoring transforms our <code>foreach</code> loop into just a tiny portion of code:</p>
<pre class="source-code">
List&lt;Passenger&gt; filteredPassengers = new();
<strong class="bold">filteredPassengers.AddRange(passengers.Where(p =&gt; !hasBoarded.HasValue || p.HasBoarded == hasBoarded));</strong></pre>
<p>This code takes our <code>passengers</code> collection and calls the <code>Where</code> extension method. The <code>Where</code> method will <a id="_idIndexMarker169"/>create and return a new <code>IEnumerable</code> sequence of <code>passengers</code> and only includes <code>passengers</code> where the arrow function, <code>p =&gt; !hasBoarded.HasValue || p.HasBoarded == hasBoarded</code>, returns a value of <code>true</code> for that passenger.</p>
<p class="callout-heading">Extension methods</p>
<p class="callout">Extension methods are static methods defined<a id="_idIndexMarker170"/> in static classes that allow you to build syntax that looks like it adds new methods to existing types. LINQ relies heavily on extension methods attached to various interfaces. We’ll explore creating extension methods in <a href="B21324_04.xhtml#_idTextAnchor072"><em class="italic">Chapter 4</em></a>.</p>
<p>This won’t modify our original collection, instead creating a new collection of <code>Passenger</code> objects that are then passed into the <code>filteredPassengers.AddRange</code> method.</p>
<p>While this code is already very brief, we can improve it further by taking advantage of a constructor on the generic <code>List</code> class.</p>
<p>The <code>List&lt;T&gt;</code> class has a constructor that takes in an <code>IEnumerable&lt;T&gt;</code> interface and allows you to efficiently create a new list around a sequence of elements. This will let us avoid needing the <code>AddRange</code> call and helps simplify our code down to a single statement:</p>
<pre class="source-code">
List&lt;Passenger&gt; filteredPassengers =
  <strong class="bold">new(</strong>passengers.Where(p =&gt; !hasBoarded.HasValue ||
      p.HasBoarded == hasBoarded)<strong class="bold">)</strong>;</pre>
<p>If we wanted to, we could also get rid of the <code>filteredPassengers</code> variable entirely by filtering passengers down and reassigning it back into itself:</p>
<pre class="source-code">
<strong class="bold">passengers = passengers.Where</strong>(p=&gt;!hasBoarded.HasValue ||
      p.HasBoarded==hasBoarded)<strong class="bold">.ToList()</strong>;</pre>
<p>Here, we perform the <code>Where</code> call to generate an <code>IEnumerable&lt;Passenger&gt;</code> interface containing our passengers and then call the <code>ToList</code> method on that <code>IEnumerable</code> interface to convert it back into a <code>List</code> method so that it can be stored in the <code>passengers</code> parameter.</p>
<p>Also, note that any place that<a id="_idIndexMarker171"/> was using <code>filteredPassengers</code> before will need to be updated to use <code>passengers</code> instead:</p>
<pre class="source-code">
foreach (Passenger passenger in <strong class="bold">passengers</strong>) {
  string statusMessage = passenger.HasBoarded
     ? "Onboard"
     : CanPassengerBoard(passenger);
  Console.WriteLine($"{passenger.FullName,-23} Group 
     {passenger.BoardingGroup}: {statusMessage}");
}</pre>
<p>I love LINQ and find it to be invaluable for creating simple and maintainable applications, but it does take some getting used to if you’re not familiar with LINQ or not used to reading arrow function (<code>=&gt;</code>) notation.</p>
<p>That said, I do see some common mistakes in LINQ code. So, let’s look at a few of those before we close out this chapter.</p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/>Refactoring LINQ statements</h1>
<p>In this final section of this <a id="_idIndexMarker172"/>chapter, we’ll review a few of the more common optimizations with LINQ code by focusing on some common improvements most codebases that use LINQ will benefit from.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Choosing the correct LINQ method</h2>
<p>LINQ has several different <a id="_idIndexMarker173"/>ways of finding a specific item in a collection.</p>
<p>If you had an <code>IEnumerable&lt;Passenger&gt;</code> interface named <code>people</code> and wanted to find someone by their name, you might write code like this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">LinqExamples.cs</p>
<pre class="source-code">
PassengerGenerator generator = new();
List&lt;Passenger&gt; people = generator.GeneratePassengers(50);
<strong class="bold">Passenger me =</strong>
  <strong class="bold">people.FirstOrDefault(p =&gt; p.FullName == "Matt Eland");</strong>
Console.WriteLine($"Matt is in group {<strong class="bold">me.BoardingGroup</strong>}");</pre>
<p>This code uses the LINQ <code>FirstOrDefault</code> method, which searches the collection until it finds the first value that the arrow function<a id="_idIndexMarker174"/> evaluates as true. In this example, it’d find the first person with <code>FullName</code> set to <code>"Matt Eland"</code>, return that value from the <code>FirstOrDefault</code> method, and store it in the <code>Passenger</code> variable named <code>matt</code>.</p>
<p>However, if no items returned <code>true</code> from the arrow function, <code>FirstOrDefault</code> will use the default value of the <code>Passenger</code> type, which would be null for a reference type such as a class.</p>
<p class="callout-heading">Default values</p>
<p class="callout">In .NET, the default value of <code>bool</code> is <code>false</code>, numeric types such as <code>int</code> and <code>float</code> default to <code>0</code>, and reference types including <code>string</code>, <code>List</code>, and other classes default to <code>null</code>.</p>
<p>In other words, this <code>FirstOrDefault</code> call will find Matt if he exists in passengers and return him or return <code>null</code> if he doesn’t.</p>
<p>The problem with this is that the very next line attempts to read the value of <code>matt.BoardingGroup</code>. This is fine if we found the element, but if we didn’t, this code will get a <code>NullReferenceException</code> error upon trying to access <code>BoardingGroup</code>, which is likely not what its author intended.</p>
<p>Note that how we fix this code depends on what our expectations are.</p>
<p>With LINQ, when you are looking for an element in a collection, you need to decide on two things:</p>
<ul>
<li>Am I okay with more than one item matching my arrow function or do I need to make sure that <em class="italic">at most</em> one item returns true?</li>
<li>Am I okay with the item I’m looking for not being present at all?</li>
</ul>
<p>The first decision governs whether<a id="_idIndexMarker175"/> you are making a call to <code>First</code> or <code>Single</code>. With <code>First</code>, the logic will find the first element that matches the query and return it. However, with <code>Single</code>, the logic will keep going past the first match to determine if any other element in the collection matches that expression as well. If one does match the expression, an <code>InvalidOperationException</code> error is thrown, telling you that the sequence contains more than one matching element.</p>
<p>Most developers don’t like seeing exceptions when they’re running their code. However, sometimes, you need to know if there’s more than one match to your query. In general, it’s better to fail early than fail later in a more confusing spot that hides where the program first got off track.</p>
<p>The second decision you make when finding an element in a collection involves being okay with objects not being present that match the query. If that’s fine, then you will generally want to make a call to <code>FirstOrDefault</code> or <code>SingleOrDefault</code> (depending on your decision earlier on whether multiple matches are permissible). However, if it is never acceptable to not have a match, then you’ll use <code>First</code> or <code>Single</code> instead of <code>FirstOrDefault</code> or <code>SingleOrDefault</code>.</p>
<p><code>First</code> and <code>Single</code> will both throw an <code>InvalidOperationException</code> error if the sequence contains no matching element. If you use <code>First</code> or <code>Single</code> and nothing in the collection returns <code>true</code> from the arrow function, the exception will be thrown. This makes it impossible to deal with <code>null</code> values with the result of <code>First</code> or <code>Single</code>, which can be very helpful for simplifying your code.</p>
<p class="callout-heading">Tip</p>
<p class="callout">Having an <code>InvalidOperationException</code> error thrown at the exact position your code encounters a problem can be immensely more helpful than encountering a <code>NullReferenceException</code> error 30 lines later in your code and having to figure out how a value got where it was supposed to be.</p>
<p><code>NullReferenceException</code> error<a id="_idIndexMarker176"/> from occurring. We’ll explore this in more <a id="_idIndexMarker177"/>depth in <a href="B21324_10.xhtml#_idTextAnchor209"><em class="italic">Chapter 10</em></a>.</p>
<p>Let’s move on and discuss ways of combining LINQ methods.</p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Combining LINQ methods</h2>
<p>One of the nice things<a id="_idIndexMarker178"/> about LINQ is that it lets you “chain together” different methods by calling a LINQ method on the result of another LINQ method. This lets you do things such as filter down to a subset of items using <code>Where</code>, reorder the results with <code>OrderBy</code>, and transform them into new objects via <code>Select</code>.</p>
<p>However, as .NET has evolved, LINQ has grown a few more specialized overloads of its existing methods, which makes some of these chained-together methods unnecessary or even inefficient.</p>
<p>Look at this block of code as an example:</p>
<pre class="source-code">
bool anyBoarded =
  people<strong class="bold">.Where</strong>(p =&gt; p.HasBoarded)<strong class="bold">.Any</strong>();
int numBoarded =
  people<strong class="bold">.Where</strong>(p =&gt; p.HasBoarded)<strong class="bold">.Count</strong>();
Passenger firstBoarded =
  people<strong class="bold">.Where</strong>(p =&gt; p.HasBoarded)<strong class="bold">.First</strong>();</pre>
<p>At first glance, this code looks fine. Each of these three variable assignments is filtering down and then looking at the results of that filtering option. Sure, there’s an opportunity to introduce a local variable for <code>people.Where(p =&gt; p.HasBoarded)</code>, but otherwise, the code often looks fine at a glance.</p>
<p>However, LINQ offers overloaded versions of <code>Any</code>, <code>Count</code>, <code>First</code>, and a few other methods that take in a <strong class="bold">predicate</strong> (which is just a fancy word for an arrow function).</p>
<p>These overloaded versions allow you to combine <code>Where</code> methods and other methods into a more concise format:</p>
<pre class="source-code">
bool anyBoarded = <strong class="bold">people.Any(p =&gt; p.HasBoarded);</strong>
int numBoarded = <strong class="bold">people.Count(p =&gt; p.HasBoarded);</strong>
Passenger firstBoarded = <strong class="bold">people.First(p =&gt; p.HasBoarded);</strong></pre>
<p>Not only is this way of writing things more concise, but these overloads can be more efficient in some cases.</p>
<p>For example, before, when we were doing <code>people.Where(p =&gt; p.HasBoarded).Any()</code>, this code evaluated left to right, filtering down a large list of items into a smaller list of items. Once the entire list had been filtered down, the <code>Any</code> method call occurred, which<a id="_idIndexMarker179"/> returned <code>true</code> if at least one item was found in that resulting list.</p>
<p>Contrast this to the <code>people.Any(p =&gt; p.HasBoarded)</code> version. This method loops over the items and as soon as it sees any element that returns <code>true</code> from the arrow function, it knows it can stop evaluating because its ultimate result is going to be true.</p>
<p>Always look for opportunities to use these specialized LINQ overloads as they can result in very concise and even more performant code.</p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Transforming with Select</h2>
<p>Let’s say you wanted to <a id="_idIndexMarker180"/>create a list of strings for all the <a id="_idIndexMarker181"/>passengers who hadn’t boarded the plane yet. For each name, you want it formatted with the person’s name and then their boarding group. So, a sample entry might be <code>"</code><code>Priya Gupta-7"</code>.</p>
<p>You could write this code as follows:</p>
<pre class="source-code">
List&lt;string&gt; names = new();
foreach (Passenger p in people) {
  if (!p.HasBoarded) {
     <strong class="bold">names.Add($"{p.FullName}-{p.BoardingGroup}");</strong>
  }
}</pre>
<p>However, LINQ has a method named <code>Select</code> that allows you to transform items from one form into another, which would be perfect for this case.</p>
<p class="callout-heading">Tip</p>
<p class="callout">For those of you with a JavaScript background, <code>Select</code> is similar to the <code>Map</code> function.</p>
<p>The <code>Select</code> version <a id="_idIndexMarker182"/>of this looks like this:</p>
<pre class="source-code">
List&lt;string&gt; names =
        people.Where(p =&gt; !p.HasBoarded)
                 <strong class="bold">.Select(p =&gt; $"{p.FullName}-{p.BoardingGroup}")</strong>
                 .ToList();</pre>
<p>Here, the <code>Where</code> call filtered<a id="_idIndexMarker183"/> the results down to non-boarded passengers and the <code>Select</code> call transformed those objects from <code>Passenger</code> objects into strings.</p>
<p><code>Select</code> isn’t limited to just strings. You can select whatever data type is relevant for you, including integers, other objects, lists, or even <strong class="bold">anonymous types</strong> or <strong class="bold">tuples</strong>.</p>
<p>Ultimately, whenever you have a collection of objects in one shape and you need those same objects but in a different form, <code>Select</code> is a great method to consider.</p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>Reviewing and testing our refactored code</h1>
<p>While we didn’t modify a lot of code in this chapter, the code we did change shrunk in size, thus becoming easier to read, understand, and modify in the process.</p>
<p>This is why we refactor. Refactoring<a id="_idIndexMarker184"/> should actively improve the maintainability of our applications and pay down strategic pieces of technical debt that threaten to introduce bugs and delays in the future.</p>
<p class="callout-heading">Refactored code</p>
<p class="callout">The final refactored code from this chapter is available in the <a href="https://github.com/PacktPublishing/Refactoring-with-Csharp">https://github.com/PacktPublishing/Refactoring-with-Csharp</a> repository inside the <code>Chapter03/Ch3RefactoredCode</code> folder.</p>
<p>Since the art of refactoring involves changing the form of code without changing its functionality, we must test the application before moving on.</p>
<p>We’ll talk more about manual and automated tests in <a href="B21324_06.xhtml#_idTextAnchor133"><em class="italic">Chapter 6</em></a>, but for now, run the tests by selecting <a id="_idIndexMarker185"/>the <strong class="bold">Test</strong> menu at <a id="_idIndexMarker186"/>the top of Visual Studio and then clicking <strong class="bold">Run </strong><strong class="bold">All Tests</strong>.</p>
<p>This will show <strong class="bold">Test Explorer</strong> and a sea of green check marks, as shown in <em class="italic">Figure 3</em><em class="italic">.10</em>:</p>
<div><div><img alt="Figure 3.10 – Passing tests for this chapter’s code" src="img/B21324_03_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – Passing tests for this chapter’s code</p>
<p>Now, let’s summarize what we’ve learned in this chapter.</p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Summary</h1>
<p>In this chapter, we explored refactoring techniques to help better control program flow, instantiate objects, iterate over collections, and write more efficient code through LINQ.</p>
<p>Each refactoring technique we covered is one tool in your toolbelt that might improve the readability and maintainability of your code in the right circumstances. As you practice refactoring more, you’ll learn more about when to apply which refactoring to improve the code you’re working with.</p>
<p>In the next chapter, we’ll move on from improving individual lines of code and focus on a slightly bigger picture as we work to refactor entire methods of C# code.</p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li>Is it more important to have concise code or readable code?</li>
<li>Scroll through a file of code in a project you are working on. What do you notice about the <code>if</code> statements in your code?</li>
<li>How frequently are nested <code>if</code> statements used?</li>
<li>Is any logic repeated frequently in conditions of your <code>if</code> statements?</li>
<li>Do you see any places where inverting the <code>if</code> statement or switching to a <code>switch</code> statement or <code>switch</code> expression could improve things?</li>
<li>Do you think your team has been using LINQ to its fullest potential when working with collections? What opportunities for improvement do you see?</li>
</ol>
<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/>Further reading</h1>
<p>You can find more information about the materials discussed in this chapter by reading the following resources:</p>
<ul>
<li><em class="italic">Switch </em><em class="italic">Expressions</em>: <a href="https://learn.microsoft.com/en-US/dotnet/csharp/language-reference/operators/switch-expression">https://learn.microsoft.com/en-US/dotnet/csharp/language-reference/operators/switch-expression</a></li>
<li><em class="italic">Differences between .NET Collection </em><em class="italic">Interfaces</em>: <a href="https://newdevsguide.com/2022/10/09/understanding-dotnet-collection-interfaces/">https://newdevsguide.com/2022/10/09/understanding-dotnet-collection-interfaces/</a></li>
<li><em class="italic">Query Syntax and Method Syntax in </em><em class="italic">LINQ</em>: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq">https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq</a></li>
<li><em class="italic">Explore Ranges of </em><em class="italic">Data</em>: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/ranges-indexes">https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/ranges-indexes</a></li>
<li><em class="italic">Arrow Functions and the Lambda </em><em class="italic">Operator</em>: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-operator">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-operator</a></li>
</ul>
</div>
</body></html>