<html><head></head><body>
<div><h1 class="chapterNumber">4</h1>
<h1 class="chapterTitle" id="_idParaDest-83">Best Practices in Coding C# 12</h1>
<p class="normal">When you are the software architect on a project, it is your responsibility to define and/or maintain a coding standard that will direct the team to program according to the expectations of the company. This chapter covers some of the <strong class="keyWord">best practices</strong> in coding that will help developers like you program safe, simple, and maintainable software. It also includes tips and tricks for coding in <strong class="keyWord">C#</strong>. Although coding can be considered an art, writing understandable code is closer to a philosophy. In this chapter, we also discuss practices that you, as a software architect, need to propagate to your developers, with techniques and tools for code analysis, so that you have well-written code for your projects.</p>
<p class="normal">The following topics will be covered in this chapter:</p>
<ul>
<li class="bulletList">How the complexity of your code can affect performance</li>
<li class="bulletList">The importance of using a version control system</li>
<li class="bulletList">Writing safe code in C#</li>
<li class="bulletList">.NET 8 tips and tricks for coding</li>
<li class="bulletList">Identifying well-written code</li>
</ul>
<p class="normal"><strong class="keyWord">C# 12</strong> was launched<a id="_idIndexMarker245"/> together with <strong class="keyWord">.NET 8</strong>. However, the practices presented here can be used in many versions of .NET, since they refer to the basics of programming C#. By the end of the chapter, you will be able to define which tools you are going to incorporate into your software development life cycle to facilitate code analysis.</p>
<h1 class="heading-1" id="_idParaDest-84">Technical requirements</h1>
<p class="normal">This chapter requires, at least, the Visual Studio 2022 free <em class="italic">Community Edition</em>.</p>
<h1 class="heading-1" id="_idParaDest-85">The simpler your code, the better a programmer you are</h1>
<p class="normal">For many people, a good programmer is one who writes complex code. However, the evolution of maturity in software development means there is a different way of thinking about it. Complexity does not mean a good job; it means poor code quality. Some incredible scientists and researchers have confirmed this theory and emphasized that professional code needs to be focused on time, high quality, and budget.</p>
<p class="normal">Even when you have a complex scenario on your hands, if you reduce ambiguities and clarify the process of what you are coding, especially by using good names for methods and variables, which contribute to making your code “self-documented” and respect SOLID principles (<strong class="keyWord">S</strong>ingle Responsibility, <strong class="keyWord">O</strong>pen/Close, <strong class="keyWord">L</strong>iskov Substitution, <strong class="keyWord">I</strong>nterface Segregation, and <strong class="keyWord">D</strong>ependency Inversion), you will turn complexity into simple code.</p>
<p class="normal">So, if you want to write good code, you need to keep the focus on how to do it, considering you are not the only one who will read it later. This is a good tip that changes the way you write code. This is how we will discuss each point of this chapter.</p>
<p class="normal">If your understanding of the importance of writing good code is aligned with the idea of simplicity and clarity while writing it, you should look at the Visual Studio tool known as <strong class="screenText">Code Metrics</strong>:</p>
<figure class="mediaobject"><img alt="Tela de celular com publicação numa rede social  Descrição gerada automaticamente" src="img/B19820_04_01.png"/></figure>
<p class="packt_figref">Figure 4.1: Calculating code metrics in Visual Studio</p>
<p class="normal">The <strong class="screenText">Code Metrics</strong> tool will deliver metrics<a id="_idIndexMarker246"/> that will give you insights regarding the quality of the software you are delivering. The metrics that the tool provides can be found at this link: <a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values">https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values</a>.</p>
<p class="normal">Once you have run the code metrics analysis, you will need to interpret each metric presented. The following subsections focus on describing how a <strong class="keyWord">maintainability index</strong>, <strong class="keyWord">cyclomatic complexity</strong>, <strong class="keyWord">depth of inheritance</strong>, <strong class="keyWord">class coupling</strong>, and the <strong class="keyWord">number of lines of code</strong> are useful in some real-life scenarios.</p>
<h2 class="heading-2" id="_idParaDest-86">Maintainability index</h2>
<p class="normal">The maintainability index represents<a id="_idIndexMarker247"/> a number from 0 to 100, which indicates how easy it is to maintain code – the easier the code, the higher the index. Easy maintenance is one of the key points to keeping software in good health. It is obvious that any software will require changes in the future since change is inevitable. </p>
<p class="normal">For this reason, consider refactoring your code to elevate the maintainability index if it currently has a low score. Writing classes and methods dedicated to a single responsibility, avoiding duplicate code, and limiting the number of lines of code of<a id="_idIndexMarker248"/> each method are examples of how you can improve the maintainability index.</p>
<h2 class="heading-2" id="_idParaDest-87">Cyclomatic complexity</h2>
<p class="normal">The creator of the cyclomatic complexity metric is Thomas J. McCabe. He defines the complexity of a software function<a id="_idIndexMarker249"/> according to the number of <strong class="keyWord">code paths</strong> available (<strong class="keyWord">graph nodes)</strong>. The more paths you have, the more complex your function is. McCabe<a id="_idIndexMarker250"/> considers that each function must have a complexity score of less than 10. That means that if the code has more complex methods, you must refactor it, transforming parts of the code into separate methods. There are some real scenarios where this behavior is easily detected:</p>
<ul>
<li class="bulletList">Loops inside loops</li>
<li class="bulletList">Lots of consecutive <code class="inlineCode">if-else</code> statements</li>
<li class="bulletList"><code class="inlineCode">switch</code> with code processing for each case inside the same method</li>
</ul>
<p class="normal">For instance, look at the first version of this method for processing different responses to a credit card transaction. As you can see, the cyclomatic complexity is bigger than the number considered by McCabe as a basis. The reason why this happens is because of the number of <code class="inlineCode">if-else</code> statements inside each case of the main switch:</p>
<pre class="programlisting code"><code class="hljs-code">/// &lt;summary&gt;
/// This code is being used just for explaining the concept of
/// cyclomatic complexity.
/// It makes no sense at all. Please Calculate Code Metrics for
/// understanding
/// &lt;/summary&gt;
private static void CyclomaticComplexitySample()
{
  var billingMode = GetBillingMode();
  var messageResponse = ProcessCreditCardMethod();
  switch (messageResponse)
    {
      case "A":
        if (billingMode == "M1")
          Console.WriteLine($"Billing Mode {billingMode} for " +
            $"Message Response {messageResponse}");
        else
          Console.WriteLine($"Billing Mode {billingMode} for " +
            $"Message Response {messageResponse}");
        break;
      case "B":
        if (billingMode == "M2")
          Console.WriteLine($"Billing Mode {billingMode} for " +
            $"Message Response {messageResponse}");
        else
          Console.WriteLine($"Billing Mode {billingMode} for " +
            $"Message Response {messageResponse}");
        break;
      case "C":
        if (billingMode == "M3")
          Console.WriteLine($"Billing Mode {billingMode} for " +
            $"Message Response {messageResponse}");
        else
          Console.WriteLine($"Billing Mode {billingMode} for " +
            $"Message Response {messageResponse}");
        break;
      case "D":
        if (billingMode == "M4")
          Console.WriteLine($"Billing Mode {billingMode} for " +
            $"Message Response {messageResponse}");
        else
          Console.WriteLine($"Billing Mode {billingMode} for " +
            $"Message Response {messageResponse}");
        break;
      case "E":
        if (billingMode == "M5")
          Console.WriteLine($"Billing Mode {billingMode} for " +
            $"Message Response {messageResponse}");
        else
          Console.WriteLine($"Billing Mode {billingMode} for " +
            $"Message Response {messageResponse}");
        break;
      case "F":
        if (billingMode == "M6")
          Console.WriteLine($"Billing Mode {billingMode} for " +
            $"Message Response {messageResponse}");
        else
          Console.WriteLine($"Billing Mode {billingMode} for " +
            $"Message Response {messageResponse}");
        break;
      case "G":
        if (billingMode == "M7")
          Console.WriteLine($"Billing Mode {billingMode} for " +
            $"Message Response {messageResponse}");
        else
          Console.WriteLine($"Billing Mode {billingMode} for " +
            $"Message Response {messageResponse}");
        break;
      case "H":
        if (billingMode == "M8")
          Console.WriteLine($"Billing Mode {billingMode} for " +
            $"Message Response {messageResponse}");
        else
          Console.WriteLine($"Billing Mode {billingMode} for " +
            $"Message Response {messageResponse}");
        break;
      default:
        Console.WriteLine("The result of processing is unknown");
        break;
    }
}
</code></pre>
<p class="normal">If you calculate the code metrics of this code, you will find a bad result when it comes to cyclomatic complexity, as you can see in the following screenshot. A cyclomatic complexity number above<a id="_idIndexMarker251"/> 10 indicates that the code is difficult to read, and a developer will probably have trouble maintaining it in a future code change.</p>
<figure class="mediaobject"><img alt="Interface gráfica do usuário, Aplicativo  Descrição gerada automaticamente" src="img/B19820_04_02.png"/></figure>
<p class="packt_figref">Figure 4.2: High level of cyclomatic complexity</p>
<p class="normal">It is important to reinforce that the purpose of the code from this example is not the focus here. The point here is to show you the number of improvements that can be made to write better code:</p>
<ul>
<li class="bulletList">The options from <code class="inlineCode">switch-case</code> could be written using <code class="inlineCode">Enum</code>.</li>
<li class="bulletList">Each <code class="inlineCode">case</code> processing can be done:<ul>
<li class="bulletList">In a specific method.</li>
<li class="bulletList">In a specific class, inheriting the action from the superclass, using the polymorphism concept.</li>
<li class="bulletList">In a specific class, implementing an interface to define a contract.</li>
</ul>
</li>
<li class="bulletList"><code class="inlineCode">switch-case</code> can be substituted with <code class="inlineCode">Dictionary&lt;Enum, Method&gt;</code> or by using the <code class="inlineCode">switch</code> expression.</li>
</ul>
<p class="normal">By refactoring this <a id="_idIndexMarker252"/>code with the preceding techniques, the result is a piece of code that is much easier to understand, as you can see in the following code snippet of its main method:</p>
<pre class="programlisting code"><code class="hljs-code">static void Main()
{
    var billingMode = GetBillingMode();
    var messageResponse = ProcessCreditCardMethod();
    Dictionary&lt;CreditCardProcessingResult, CheckResultMethod&gt;
        methodsForCheckingResult = GetMethodsForCheckingResult();
    if (methodsForCheckingResult.ContainsKey(messageResponse))
        methodsForCheckingResult[messageResponse](billingMode,
        messageResponse);
    else
        Console.WriteLine("The result of processing is unknown");
}
</code></pre>
<p class="normal">Using the <code class="inlineCode">switch</code> expression available since C# 8.0, the code can be even simpler!</p>
<pre class="programlisting code"><code class="hljs-code">static void Main()
{
    var billingMode = GetBillingMode();
    var messageResponse = ProcessCreditCardMethod();
    CheckResult(messageResponse, billingMode);
}
private static CreditCardProcessingResult CheckResult(CreditCardProcessingResult messageResponse, BillingMode billingMode) =&gt; messageResponse switch
{
    CreditCardProcessingResult.ResultA =&gt; CheckResultA(billingMode, messageResponse),
    CreditCardProcessingResult.ResultB =&gt; CheckResultB(billingMode, messageResponse),
    CreditCardProcessingResult.ResultC =&gt; CheckResultC(billingMode, messageResponse),
    CreditCardProcessingResult.ResultD =&gt; CheckResultD(billingMode, messageResponse),
    CreditCardProcessingResult.ResultE =&gt; CheckResultE(billingMode, messageResponse),
    CreditCardProcessingResult.ResultF =&gt; CheckResultF(billingMode, messageResponse),
    CreditCardProcessingResult.ResultG =&gt; CheckResultG(billingMode, messageResponse),
    CreditCardProcessingResult.Succeed =&gt; CheckResultSucceed(billingMode, messageResponse),
    _ =&gt; throw new ArgumentOutOfRangeException(nameof(messageResponse), $"Not expected value: {messageResponse}"),
};
</code></pre>
<p class="normal">The full code can be found in <a id="_idIndexMarker253"/>the GitHub repository of this chapter at <a href="https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E">https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E</a>/tree/main/ch04 and demonstrates how lower-complexity code can be achieved. The following screenshot shows these results according to Code Metrics:</p>
<figure class="mediaobject"><img alt="Graphical user interface, application  Description automatically generated" src="img/B19820_04_03.png"/></figure>
<p class="packt_figref">Figure 4.3: Cyclomatic complexity reduction after refactoring</p>
<p class="normal">As you can see in the preceding screenshot, there is a considerable reduction in complexity after refactoring. In <em class="chapterRef">Chapter 5</em>, <em class="italic">Implementing Code Reusability in C# 12</em>, we will discuss the importance of refactoring for code reuse. The reason we are doing this here is the same – we want to eliminate duplication. It is important to remember that when you are refactoring code, you are writing it in a better way while respecting the input and output data that this code will process.</p>
<p class="normal">The key point here is that with the applied techniques, our understanding of the code increased and the complexity index decreased, thus proving the importance of cyclomatic complexity.</p>
<h2 class="heading-2" id="_idParaDest-88">Depth of inheritance</h2>
<p class="normal">This metric represents the number of<a id="_idIndexMarker254"/> classes inherited by the one that is being analyzed. The more classes you have inherited, the worse the metric will be. This is like class coupling and indicates how difficult it is to change the code of this class without impacting other ones, which neglects the Open/Close principle stated by SOLID. For instance, the following screenshot shows four inherited classes:</p>
<figure class="mediaobject"><img alt="Diagrama  Descrição gerada automaticamente" src="img/B19820_04_04.png"/></figure>
<p class="packt_figref">Figure 4.4: Depth of inheritance sample</p>
<p class="normal">You can see in the<a id="_idIndexMarker255"/> following screenshot that the deepest class has the worst metric, considering there are three other classes that can change its behavior:</p>
<figure class="mediaobject"><img alt="Graphical user interface, application  Description automatically generated" src="img/B19820_04_05.png"/></figure>
<p class="packt_figref">Figure 4.5: Depth of inheritance metric</p>
<p class="normal">Inheritance is one of the basic object-oriented analysis principles. However, it can sometimes be bad for your code in that it can cause dependencies. So, if it makes sense to do so, consider using composition or aggregation instead of inheritance, as we will explain in the following section.</p>
<h2 class="heading-2" id="_idParaDest-89">Class coupling</h2>
<p class="normal">When you connect too many classes in a single class, obviously you will get tight coupling, and changing a participant<a id="_idIndexMarker256"/> causes unintended consequences in others. For sure, this can cause bad maintenance of your code, resulting in bugs that will make you spend more time trying to deliver a great solution. For instance, refer to <em class="italic">Figure 4.6</em>. It shows a design where aggregation has been performed a lot. There is no sense to the code itself:</p>
<figure class="mediaobject"><img alt="Diagrama  Descrição gerada automaticamente" src="img/B19820_04_06.png"/></figure>
<p class="packt_figref">Figure 4.6: Class coupling example</p>
<p class="normal">Once you have calculated the code metrics for the preceding design, you will see that the number of class coupling instances for the <code class="inlineCode">ProcessData()</code> method, which calls <code class="inlineCode">ExecuteTypeA()</code>, <code class="inlineCode">ExecuteTypeB()</code>, and <code class="inlineCode">ExecuteTypeC()</code>, equals three:</p>
<figure class="mediaobject"><img alt="A screenshot of a computer  Description automatically generated with medium confidence" src="img/B19820_04_07.png"/></figure>
<p class="packt_figref">Figure 4.7: Class coupling metric</p>
<p class="normal">Microsoft suggests <a id="_idIndexMarker257"/>that the maximum number of class coupling instances should be nine, as presented at <a href="https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-class-coupling?view=vs-2022">https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-class-coupling?view=vs-2022</a>.</p>
<p class="normal">With composition/aggregation being a better practice than inheritance, and since you will decouple code written from your class, the use of interfaces will solve class coupling problems. For instance, the same code with the following design will give you a better result. Although the interface is not strictly required for this example, its usage enables us to evolve the solution for other <strong class="keyWord">execution types</strong> without impacting the classes already written, since you are not using inheritance to solve the problem.</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_04_08.png"/></figure>
<p class="packt_figref">Figure 4.8: Reducing class coupling</p>
<p class="normal">Note that using the<a id="_idIndexMarker258"/> interface in the design will allow you to increase the number of execution types without increasing the class coupling of the solution:</p>
<p class="packt_figref"><img alt="" role="presentation" src="img/B19820_04_09.png"/></p>
<p class="packt_figref">Figure 4.9: Class coupling results after applying aggregations</p>
<p class="normal">As a software architect, you must design your solution to have more cohesion than coupling. The literature indicates that good software has low coupling and high cohesion. In software development, high cohesion indicates that each class has its methods and data, with good relationships between them. Conversely, low coupling indicates that classes are not closely and directly connected. This is a basic principle that can guide you to a better architectural model.</p>
<h2 class="heading-2" id="_idParaDest-90">Number of lines of code</h2>
<p class="normal">This metric is useful in terms of making you understand the size of the code you are dealing with. There is no way to connect the number of lines of code and complexity, since the number of lines is not indicative<a id="_idIndexMarker259"/> of that. Conversely, the number of lines of code does show the software size and software design. For instance, if you have too many lines of code in a single class (more than 1,000 lines of code – 1 KLOC), this indicates that it is a bad design. Besides, if a class has too many methods, it obviously violates the Single Responsibility principle from SOLID.</p>
<p class="normal">In Visual Studio 2022, this metric was divided into <strong class="keyWord">lines of source code</strong> and <strong class="keyWord">lines of executable code</strong>. The first indicates the exact number of source lines, including blank lines. Conversely, the second one estimates the number of executable code lines.</p>
<p class="normal">As a software architect, you have the objective of delivering to your programmers a list of best practices that will enable each of them to improve their techniques for developing good software. Make sure they know the exact impacts of not achieving good metric results in their code. The metrics presented above are certainly a great way to start to achieve this objective. But let us see how using a version control system can be the difference between amateur and professional software development.</p>
<h1 class="heading-1" id="_idParaDest-91">Using a version control system</h1>
<p class="normal">You may find this topic a bit obvious, but<a id="_idIndexMarker260"/> many people and companies still do not regard a version control system as an essential tool for software development. A common reason why version control systems are not considered a priority, particularly in some situations, is the belief that they are unnecessary for solo coding projects or for study purposes. You may think that a version control system is only needed by teams inside companies. The purpose of addressing this is to force you to understand our point. There is no architectural model or best practice that can save software development if you do not use a <strong class="keyWord">version control system</strong>.</p>
<p class="normal">In the last few years, we have been enjoying the advantages of online version control systems, such as Azure DevOps, GitHub, and Bitbucket. The fact is, you must have a version control system in your software development life cycle, and there is no reason not to have one anymore, since most providers offer free versions for small groups. Even if you develop by yourself, these tools are useful for tracking your changes, managing your software versions, and guaranteeing the consistency and integrity of your code.</p>
<h2 class="heading-2" id="_idParaDest-92">Dealing with version control systems in teams</h2>
<p class="normal">The reason for using a version control system tool when you are alone is obvious. You want to keep your code safe. However, this <a id="_idIndexMarker261"/>kind of system was developed to solve team problems while writing code. For this reason, some features, such as branching and merging, were introduced to keep code integrity even in scenarios where the number of developers is quite large.</p>
<p class="normal">As a software architect, you will have to decide which branch strategy you will conduct in your team. Microsoft and GitHub suggest different ways to deliver that, and both are useful in some scenarios.</p>
<p class="normal">Information about how the Microsoft teams deal with DevOps can be found here: <a href="https://learn.microsoft.com/en-us/devops/develop/how-microsoft-develops-devops">https://learn.microsoft.com/en-us/devops/develop/how-microsoft-develops-devops</a>. The branching strategy presented in this article describes an approach where a branch is created for each release. They<a id="_idIndexMarker262"/> call it <strong class="keyWord">the release flow</strong>. The big difference here is that the master branch is not continuously deployed to production.</p>
<p class="normal">Conversely, GitHub describes its process at <a href="https://guides.github.com/introduction/flow/">https://guides.github.com/introduction/flow/</a>. This process is called <strong class="keyWord">GitHub flow</strong> and can be defined as a lightweight, branch-based workflow, where<a id="_idIndexMarker263"/> each development is created in a specific branch that will be reviewed by collaborators as soon as a pull request is created for feedback. As soon as the pull request is approved, the new code is merged to a master branch, so you can delete the development branch created before.</p>
<p class="normal">It is your choice; decide on the one that best fits your needs, but we do want you to understand that you need to have a strategy for controlling your code. In <em class="chapterRef">Chapter 8</em>, <em class="italic">Understanding DevOps Principles and CI/CD</em>, we will discuss this in more detail. But now, let us see how to write safe code using C# so that you can develop a list of best practices to be shared with your developers.</p>
<h1 class="heading-1" id="_idParaDest-93">Writing safe code in C#</h1>
<p class="normal">C# can be considered a safe programming language by design. Unless you force it, there is no need for pointers, and <a id="_idIndexMarker264"/>memory release is, in most cases, managed by the garbage collector. Even so, some care should be taken so that you can get better and safer results from your code. Let us have a look at some common practices to ensure safe code in C#.</p>
<h2 class="heading-2" id="_idParaDest-94">try-catch</h2>
<p class="normal">Exceptions in coding are so frequent that you should have a way to manage them whenever they happen. <code class="inlineCode">try-catch</code> statements <a id="_idIndexMarker265"/>are built to manage exceptions, and they are important for keeping your <a id="_idIndexMarker266"/>code safe. Be careful when they happen, since they can cause performance issues, as we discussed in <em class="chapterRef">Chapter 2,</em> <em class="italic">Non-Functional Requirements</em>. </p>
<p class="normal">There are a lot of cases where an application crashes, and the reason for that is the lack of using <code class="inlineCode">try-catch</code>. The following code shows an example of the lack of usage of the <code class="inlineCode">try-catch</code> statement. It is worth mentioning that this is just an example of understanding the concept of an exception thrown without correct treatment. Consider using <code class="inlineCode">int.TryParse(textToConvert, out int result)</code> to handle cases where a parse is unsuccessful:</p>
<pre class="programlisting code"><code class="hljs-code">private static int CodeWithNoTryCatch(string textToConvert)
{
    return Convert.ToInt32(textToConvert);
}
</code></pre>
<p class="normal">Conversely, bad <code class="inlineCode">try-catch</code> usage can cause damage to your code too, especially because you will not see the correct behavior of that code and may misunderstand the results provided.</p>
<p class="normal">The following code shows an example of an empty <code class="inlineCode">try-catch</code> statement:</p>
<pre class="programlisting code"><code class="hljs-code">private static int CodeWithEmptyTryCatch(string textToConvert)
{
    try
    {
        return Convert.ToInt32(textToConvert);
    }
    catch
    {
        return default;
    }
}
</code></pre>
<p class="normal"><code class="inlineCode">try-catch</code> statements must be connected to logging solutions so that you can have a response from the system that will indicate the correct behavior and, at the same time, not cause application crashes. The following code shows an ideal <code class="inlineCode">try-catch</code> statement with logging management. It is<a id="_idIndexMarker267"/> worth mentioning that specific exceptions should be caught whenever possible, since catching a general exception will hide unexpected exceptions:</p>
<pre class="programlisting code"><code class="hljs-code">private static int CodeWithCorrectTryCatch(string textToConvert)
{
    try
    {
        return Convert.ToInt32(textToConvert);
    }
    catch (FormatException err)
    {
        Logger.GenerateLog(err);
        return 0;
    }
}
</code></pre>
<p class="normal">It is very important to note that exceptions are, computationally speaking, expensive. No matter whether you are throwing them to indicate an error or catching them to manage errors, it takes a lot of computational processing. So, it is common, and preferable, to rely on a higher-level exception handler instead of trying to handle everything everywhere, as the code might become hard to reason about, particularly if there is not a good action to take when an exception happens. That means you may not handle the exceptions in every method, especially if you do not know what to do with them at that part of the code and you will throw it again to a higher-level handle. You should prioritize handling<a id="_idIndexMarker268"/> exceptions where meaningful actions can be taken.</p>
<p class="normal">However, it is also worth mentioning that exception errors delivered to the end user can cause the feeling that bad software was delivered. As a software architect, you should conduct code inspections to define the best behavior for code. Instability in a system, like unexpected crashes and high-memory usage, is often connected to the lack of <code class="inlineCode">try-catch</code> statements in code.</p>
<h2 class="heading-2" id="_idParaDest-95">try-finally and using</h2>
<p class="normal"><em class="italic">Memory leaks</em> can be considered one of the <a id="_idIndexMarker269"/>worst software behaviors. They cause instability, bad usage of computer resources, and undesired application crashes. C# tries<a id="_idIndexMarker270"/> to solve this with <strong class="keyWord">Garbage Collector</strong>, which automatically releases objects from memory as soon as it realizes<a id="_idIndexMarker271"/> an object can <a id="_idIndexMarker272"/>be freed. The trigger for Garbage Collector is well explained at <a href="https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals">https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals</a>.</p>
<p class="normal">Objects that interact with I/O are the ones <a id="_idIndexMarker273"/>that generally are not managed by Garbage Collector: the filesystem, sockets, and so on. The following code is an example of the incorrect usage of a <code class="inlineCode">FileStream</code> object because it thinks Garbage Collector will release the memory used, but it will not:</p>
<pre class="programlisting code"><code class="hljs-code">private static void CodeWithIncorrectFileStreamManagement()
{
    FileStream file = new ("C:\\file.txt", FileMode.CreateNew);
    byte[] data = GetFileData();
    file.Write(data, 0, data.Length);
}
</code></pre>
<p class="normal">Besides, it takes a while for<a id="_idIndexMarker274"/> Garbage Collector to interact with objects that need to be<a id="_idIndexMarker275"/> released, and sometimes, you may want to do it yourself. For both cases, the use of <code class="inlineCode">try-finally</code> or <code class="inlineCode">using</code> statements is the best practice:</p>
<pre class="programlisting code"><code class="hljs-code">private static void CorrectFileStreamManagementFirstOption()
{
    FileStream file = new ("C:\\file.txt",FileMode.CreateNew);
    try
    {
        byte[] data = GetFileData();
        file.Write(data, 0, data.Length);
    }
    finally
    {
        file.Dispose();
    }
}
private static void CorrectFileStreamManagementSecondOption()
{
    using (FileStream file = new ("C:\\file.txt", FileMode.CreateNew))
    {
        byte[] data = GetFileData();
        file.Write(data, 0, data.Length);
    }
}
private static void CorrectFileStreamManagementThirdOption()
{
    using FileStream file = new ("C:\\file.txt", FileMode.CreateNew);
    byte[] data = GetFileData();
    file.Write(data, 0, data.Length);
}
</code></pre>
<p class="normal">The preceding code shows<a id="_idIndexMarker276"/> exactly how to deal with objects that are not managed by Garbage Collector. Both <code class="inlineCode">try-finally</code> and <code class="inlineCode">using</code> are implemented. As a software architect, you do need to pay attention to this kind of code. The lack of <code class="inlineCode">try-finally</code> or <code class="inlineCode">using</code> statements can cause <a id="_idIndexMarker277"/>huge damage to software behavior when it is running. It is worth mentioning that using<a id="_idIndexMarker278"/> code analysis tools, such as <strong class="keyWord">Sonar Lint</strong> and <strong class="keyWord">Code Analysis</strong>, will automatically alert <a id="_idIndexMarker279"/>you to these sorts of problems.</p>
<h2 class="heading-2" id="_idParaDest-96">The IDisposable interface</h2>
<p class="normal">In the same way that you will have <a id="_idIndexMarker280"/>trouble if you do not manage objects created inside a <a id="_idIndexMarker281"/>method with <code class="inlineCode">try-finally</code>/<code class="inlineCode">using</code> statements, objects created in a class that does not properly implement the <code class="inlineCode">IDisposable</code> interface may cause memory leaks in your application. For this reason, when you have a class that deals with and creates objects, you should implement the <code class="inlineCode">Disposable</code> pattern to guarantee the release of all resources created by the class:</p>
<figure class="mediaobject"><img alt="Graphical user interface, text, application, email  Description automatically generated" src="img/B19820_04_10.png"/></figure>
<p class="packt_figref">Figure 4.10: IDisposable interface implementation</p>
<pre>your code, and then you right-click on the <strong class="keyWord">Quick Actions</strong> and <strong class="keyWord">Refactoring</strong> options, as you can see in the preceding screenshot.</pre>
<p class="normal">Once you have <a id="_idIndexMarker283"/>inserted the code, you need to follow the to-do instructions so that you have the correct pattern implemented.</p>
<p class="normal">As a software architect, you will be responsible not only for the architecture defined in a system but also for how this system performs in operation. Memory leaks and bad performance, in general, are caused by errors related to the <code class="inlineCode">try-catch</code> strategy, a lack of <code class="inlineCode">try-finally/using</code>, and wrong or no implementation of <code class="inlineCode">IDisposable</code>. So be sure that your team knows how to deal with these techniques.</p>
<div><p class="normal">Since we have covered some important information about how to write safe code in C#, it would be nice to get some tips and tricks for coding in this programming language. Let us do so in the next topic of this chapter.</p>
</div>
<h1 class="heading-1" id="_idParaDest-97">.NET 8 tips and tricks for coding</h1>
<p class="normal">.NET 8 implements some good<a id="_idIndexMarker284"/> features that help us to write better code. One of the most useful things for having cleaner code is <strong class="keyWord">dependency injection</strong> (<strong class="keyWord">DI</strong>), which will be<a id="_idIndexMarker285"/> discussed in <em class="chapterRef">Chapter 6</em>, <em class="italic">Design Patterns and .NET 8 Implementation</em>. There are some good reasons for considering this. The first one is that you will only need to worry about disposing of the injected objects if you are the creator of them.</p>
<p class="normal">Besides, DI enables you to inject <code class="inlineCode">ILogger</code>, a useful tool for debugging exceptions that will need to be managed by <code class="inlineCode">try-catch</code> statements in your code. Furthermore, programming in C# with .NET 8 must follow the common good practices of any programming language. The following list shows some of these:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Classes, methods, and variables should have understandable names</strong>: The name should explain everything that the reader needs to know. There should be no need for an explanatory comment unless these declarations are public.</li>
<li class="bulletList"><strong class="keyWord">Methods should not have high complexity levels</strong>: Cyclomatic complexity should be checked so that methods do not have too many lines of code.</li>
<li class="bulletList"><strong class="keyWord">Members must have the correct visibility</strong>: As an object-oriented programming language, C# enables encapsulation with different visibility keywords. C# 9 has presented <em class="italic">init-only setters</em>, so you can create <code class="inlineCode">init</code> property/index accessors instead of <code class="inlineCode">set</code>, defining these members as read-only following the construction of the object.</li>
<li class="bulletList"><strong class="keyWord">Duplicate code should be avoided</strong>: There is no reason for having duplicate code in a high-level programming language such as C#.</li>
<li class="bulletList"><strong class="keyWord">Objects should be checked before usage</strong>: Since null objects can exist, code must have null type checking. It is worth mentioning that since C# 8, we have nullable reference types to avoid errors related to nullable objects. You can refer to <a href="https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references">https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references</a> for more information about nullable reference types.</li>
<li class="bulletList"><strong class="keyWord">Constants and enumerators should be used</strong>: A good way of avoiding magic numbers and text inside code is to transform this information into constants and enumerators, which generally are more understandable.</li>
<li class="bulletList"><strong class="keyWord">Unsafe code should be avoided</strong>: Unsafe code enables you to deal with pointers in C#. Unless there is no other way to implement the solution, unsafe code should be avoided.</li>
<li class="bulletList"><strong class="keyWord">try-catch statements cannot be empty</strong>: There is rarely a reason to use a <code class="inlineCode">try-catch</code> statement without treatment in the <code class="inlineCode">catch</code> area. Moreover, the caught exceptions should be as specific as possible, and not just an “exception,” to avoid swallowing unexpected exceptions.</li>
<li class="bulletList"><strong class="keyWord">Dispose of the objects that you have created, if they are disposable</strong>: Even for objects where Garbage Collector will take care of the disposed-of object, consider disposing <a id="_idIndexMarker286"/>of objects that you were responsible for creating yourself.</li>
<li class="bulletList"><strong class="keyWord">At least public methods should be commented</strong>: Considering that public methods are the ones used outside your library, they must be explained for their correct external usage.</li>
<li class="bulletList"><strong class="keyWord">switch-case statements must have a default treatment</strong>: Since <code class="inlineCode">switch-case</code> statements may receive an entrance variable unknown in some cases, the default treatment will guarantee that code will not break in such a situation.</li>
</ul>
<p class="normal">As a software architect, you may consider a good practice of providing a code pattern for your developers that will be used to keep the style of code consistent as a team. You can also use this code pattern as a checklist for coding inspections, which will enrich software code quality.</p>
<h1 class="heading-1" id="_idParaDest-98">Identifying well-written code</h1>
<p class="normal">It is not easy to identify whether code is well written. The best practices described so far can certainly guide you as a software architect to define a standard for your team. However, even with a standard, mistakes <a id="_idIndexMarker287"/>will happen, and you will probably find them only after code is in production. The decision to refactor code in production just because it does not follow all the standards you define is not an easy one to take, especially if the code in question works properly. Some people conclude that well-written code is simply code that works well in production. However, this can surely cause damage to the software’s life since developers might be influenced by that non-standard code.</p>
<p class="normal">For this reason, as a software architect, you need to find ways to enforce adherence to the coding standard you’ve defined. Luckily, nowadays, we have many options for tools that can help us with this task. They are called static <a id="_idIndexMarker288"/>code analysis tools, and using them provides a great opportunity to improve both the software developed and the team’s programming knowledge.</p>
<p class="normal">The reason your developers will evolve with code analysis is that you start to disseminate knowledge between them during code inspections. The tools that we have now have the same purpose. Even better, with Roslyn, they do this task while you write the code. Roslyn is the <a id="_idIndexMarker289"/>compiler platform for .NET, and it enables you to develop some tools for analyzing code. These analyzers can check style, quality, design, and other issues.</p>
<p class="normal">For instance, look at the following code. It does not make any sense, but you can still see that there are some mistakes:</p>
<pre class="programlisting code"><code class="hljs-code">using System;
static void Main(string[] args)
{
    try
    {
        int variableUnused = 10;
        int variable = 10;
        if (variable == 10)
        {
             Console.WriteLine("variable equals 10");
        }
        else
        {
            switch (variable)
            {
                case 0:
                    Console.WriteLine("variable equals 0");
                    break;
            }
        }
    }
    catch
    {
    }
}
</code></pre>
<p class="normal">The idea of this code is to show you the power of some tools to improve the code you deliver. Let us study each of<a id="_idIndexMarker290"/> them in the next section, including how to set them up.</p>
<h2 class="heading-2" id="_idParaDest-99">Understanding and applying tools that can evaluate C# code</h2>
<p class="normal">The evolution of code analysis in Visual <a id="_idIndexMarker291"/>Studio is continuous. This means that Visual Studio 2022 certainly has more tools for this purpose than Visual Studio 2019, and so on.</p>
<p class="normal">One of the issues that you (as a software architect) need to deal with is the <em class="italic">coding style of the team</em>. This certainly results in a better understanding of the code. For instance, if you go to the <strong class="screenText">Visual Studio Menu</strong>, then <strong class="screenText">Tools -&gt; Options</strong>, and then, in the left-hand menu, <strong class="screenText">Text Editor -&gt; C#</strong>, you will find ways to deal with different code style patterns, and a bad coding style is even indicated as an error in the <strong class="screenText">Code Style</strong> options, as follows:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_04_11.png"/></figure>
<p class="packt_figref">Figure 4.11: Code Style options</p>
<p class="normal">The preceding screenshot chnage that <strong class="screenText">Avoid unused parameters</strong> was considered an error.</p>
<p class="normal">After this change, the result of the compilation of the code presented at the beginning of the chapter is different, as you can see in the following screenshot:</p>
<figure class="mediaobject"><img alt="Graphical user interface, text, application  Description automatically generated" src="img/B19820_04_12.png"/></figure>
<p class="packt_figref">Figure 4.12: Code Style result</p>
<p class="normal">You can export your<a id="_idIndexMarker292"/> coding style configuration and attach it to your project so that it will follow the rules you have defined.</p>
<p class="normal">Another good tool that Visual Studio 2022 provides is <strong class="screenText">Analyze and Code Cleanup</strong>. With this tool, you can set up some code standards that can clean up your code. For instance, in the following screenshot, it was set to remove unnecessary code:</p>
<figure class="mediaobject"><img alt="Graphical user interface, text, application  Description automatically generated" src="img/B19820_04_13.png"/></figure>
<p class="packt_figref">Figure 4.13: Configure Code Cleanup</p>
<p class="normal">The way to run Code Cleanup is by selecting it with the help of a right-click in the <strong class="screenText">Solution Explorer</strong> area, over<a id="_idIndexMarker293"/> the project where you want to run it. After that, this process will run in all the code files you have:</p>
<figure class="mediaobject"><img alt="Graphical user interface, text, application  Description automatically generated" src="img/B19820_04_14.png"/></figure>
<p class="packt_figref">Figure 4.14: Run Code Cleanup</p>
<p class="normal">After solving the errors indicated by the <strong class="screenText">Code Style</strong> and <strong class="screenText">Code Cleanup</strong> tools, the sample code we are working on has some minimal simplifications, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">using System;
try
{
    int variable = 10;
    if (variable == 10)
    {
        Console.WriteLine("variable equals 10");
    }
    else
    {
        switch (variable)
        {
            case 0:
                Console.WriteLine("variable equals 0");
                break;
        }
    }
}
catch
{
}
</code></pre>
<p class="normal">It is worth mentioning that<a id="_idIndexMarker294"/> the preceding code has many improvements that still need to be addressed. Visual Studio enables you to add additional tools for the IDE by installing extensions to it. These tools can help you to improve your code quality, since some of them were built to perform code analysis. This section will list some free options so that you can decide on the one that best fits your needs. There are certainly other options and even paid ones. The idea here is not to<a id="_idIndexMarker295"/> indicate a specific tool but to give you an idea of their abilities.</p>
<p class="normal">To install these extensions, you will need to find the <strong class="screenText">Extensions</strong> menu in Visual Studio 2022. Here is a screenshot of the <strong class="screenText">Manage Extensions</strong> option:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_04_15.png"/></figure>
<p class="packt_figref">Figure 4.15: Extensions in Visual Studio 2022</p>
<p class="normal">There are many other great extensions that can improve the productivity and quality of your code and solutions. Search for them in this manager.</p>
<p class="normal">After you have selected the extension that will be installed, you will need to restart Visual Studio. Most of the extensions are easy to identify after installation, since they modify the behavior of<a id="_idIndexMarker296"/> the IDE. However, they need to be set in each developer environment. To resolve it, Visual Studio has introduced the option to include analyzers as NuGet packages, so all developers who work with the project will have their code analyzed.</p>
<h2 class="heading-2" id="_idParaDest-100">Applying extension tools to analyze code</h2>
<p class="normal">Although the sample code delivered <a id="_idIndexMarker297"/>after the Code Style and Code Cleanup tools is better than the code we presented at the beginning of the chapter, it is clearly far removed from the best practices discussed so far.</p>
<p class="normal">For this reason, Microsoft has divided analyzers into three groups:</p>
<ul>
<li class="bulletList">Code style, as mentioned before</li>
<li class="bulletList">Code quality analyzers that are already included in .NET 5+ projects</li>
<li class="bulletList">Third-party analyzers that can be installed as a NuGet package or Visual Studio extension</li>
</ul>
<p class="normal">You can find an overview of source code analysis at <a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview">https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview</a>.</p>
<p class="normal">Let us study how these third-party analyzers can be useful, using as a reference the <strong class="keyWord">SonarAnalyzer</strong> package.</p>
<h2 class="heading-2" id="_idParaDest-101">Applying SonarAnalyzer</h2>
<p class="normal">SonarAnalyzer is an <a id="_idIndexMarker298"/>open-source initiative from the Sonar Source community<a id="_idIndexMarker299"/> to detect bugs and quality issues while you code. There is support for C#, VB.NET, C, C++, and JavaScript. They also offer an extension <a id="_idIndexMarker300"/>called <strong class="keyWord">SonarLint</strong>. The great thing about this extension is that it comes with explanations for resolving detected issues, and that is why we think developers learn how to code well while using these tools.</p>
<p class="normal">This extension can point out mistakes and, even better, there is an explanation for each warning. This is useful not only for detecting problems but also for training developers in good coding practices.</p>
<p class="normal">In Visual Studio 2022, the SonarLint extension is available. Besides that, you can also use the NuGet package, as we can see in the following screenshot:</p>
<figure class="mediaobject"><img alt="Tela de computador com texto preto sobre fundo branco  Descrição gerada automaticamente" src="img/B19820_04_16.png"/></figure>
<p class="packt_figref">Figure 4.16: SonarAnalyzer.CSharp NuGet package</p>
<p class="normal">The result produced is the<a id="_idIndexMarker301"/> same as the one we <a id="_idIndexMarker302"/>got using the SonarLint extension, but the good thing about this option is that any developer who needs to code for this project will get their code analyzed.</p>
<figure class="mediaobject"><img alt="Texto  Descrição gerada automaticamente" src="img/B19820_04_17.png"/></figure>
<p class="packt_figref">Figure 4.17: SonarAnalyzer.CSharp analysis result</p>
<p class="normal">As a software architect, you<a id="_idIndexMarker303"/> will always have to pay <a id="_idIndexMarker304"/>attention and take action to get projects unified with the same code standard, so the NuGet option may be useful for achieving this goal.</p>
<h2 class="heading-2" id="_idParaDest-102">Checking the final code after analysis</h2>
<p class="normal">Following the analysis <a id="_idIndexMarker305"/>of the two options presented, we have finally solved all the issues with the original code. Here is the final code:</p>
<pre class="programlisting code"><code class="hljs-code">using System;
try
{
    int variable = 10;
    if (variable == 10)
    {
        Console.WriteLine("variable equals 10");
    }
    else
    {
        switch (variable)
        {
            case 0:
                Console.WriteLine("variable equals 0");
                break;
            default:
                Console.WriteLine("Unknown behavior");
                break;
        }
    }
}
catch (Exception err)
{
    Console.WriteLine(err);
}
</code></pre>
<p class="normal">As you can see, the preceding code is not only easier to understand but is also safer and able to consider different paths of programming, since the default for <code class="inlineCode">switch-case</code> was programmed. This pattern was discussed earlier in this chapter, which brings us to the happy conclusion that best practices can easily be followed by using one (or all) of the options discussed in this chapter.</p>
<h1 class="heading-1" id="_idParaDest-103">Summary</h1>
<p class="normal">In this chapter, we discussed some important tips for writing safe code. This chapter introduced a tool for analyzing code metrics so that you can manage the complexity and maintainability of the software you develop. To finish, we presented some good tips to guarantee that your software will not crash due to memory leaks and exceptions. In real life, a software architect will always be asked to solve this kind of problem.</p>
<p class="normal">The chapter also recommended tools that can be used to apply the best practices of the coding we discussed. We looked at the Roslyn compiler, which enables code analysis while a developer codes.</p>
<p class="normal">You will find in <em class="chapterRef">Chapter 21</em>, <em class="italic">Case Study</em>, a way to evaluate C# code prior to publishing an application, which implements code analysis during the Azure DevOps building process, using SonarCloud.</p>
<p class="normal">When you apply all the content you have learned in this chapter to your projects, you will find that code analysis will give you the opportunity to improve the quality of the code you deliver to your customers. This is a very important part of your role as a software architect.</p>
<p class="normal">In the next chapter, you will learn about code reuse, which is an incredible technique to guarantee quality and velocity for your projects!</p>
<h1 class="heading-1" id="_idParaDest-104">Questions</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Why do we need to care about maintainability?</li>
<li class="numberedList">What is cyclomatic complexity?</li>
<li class="numberedList">List the advantages of using a version control system.</li>
<li class="numberedList">What is the garbage collector?</li>
<li class="numberedList">What is the importance of implementing the <code class="inlineCode">IDisposable</code> interface?</li>
<li class="numberedList">What advantages do we gain from .NET 8 when it comes to coding?</li>
<li class="numberedList">What makes it possible for a piece of software to be described as having well-written code?</li>
<li class="numberedList">What is Roslyn?</li>
<li class="numberedList">What is code analysis?</li>
<li class="numberedList">What is the importance of code analysis?</li>
<li class="numberedList">How does Roslyn help with code analysis?</li>
<li class="numberedList">What are Visual Studio extensions?</li>
<li class="numberedList">What extension tools are available for code analysis?</li>
</ol>
<h1 class="heading-1" id="_idParaDest-105">Further reading</h1>
<p class="normal">These are some books and websites where you will find more information about the topics of this chapter:</p>
<ul>
<li class="bulletList"><em class="italic">Clean Code</em>: <em class="italic">A Handbook of Agile Software Craftmanship</em>, by Martin, Robert C. Pearson Education, 2012.</li>
<li class="bulletList"><em class="italic">The Art of Designing Embedded Systems</em>, by Jack G. Ganssle. Elsevier, 1999.</li>
<li class="bulletList"><em class="italic">Refactoring</em>, by Martin Fowler. Addison-Wesley, 2018.</li>
<li class="bulletList"><em class="italic">A Complexity Measure</em>, by Thomas J. McCabe. IEEE Trans. Software Eng. 2(4): 308–320, 1976 (<a href="https://dblp.uni-trier.de/db/journals/tse/tse2.html">https://dblp.uni-trier.de/db/journals/tse/tse2.html</a>).</li>
<li class="bulletList">Code metrics information:<ul>
<li class="bulletList"><a href="https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/">https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/</a></li>
<li class="bulletList"><a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019">https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019</a></li>
</ul>
</li>
<li class="bulletList">Version control systems:<ul>
<li class="bulletList"><a href="https://github.com/">https://github.com/</a></li>
<li class="bulletList"><a href="https://bitbucket.org/">https://bitbucket.org/</a></li>
<li class="bulletList"><a href="https://azure.microsoft.com/en-us/services/devops/">https://azure.microsoft.com/en-us/services/devops/</a></li>
</ul>
</li>
<li class="bulletList">Code branching techniques:<ul>
<li class="bulletList"><a href="https://guides.github.com/introduction/flow/">https://guides.github.com/introduction/flow/</a></li>
</ul>
</li>
<li class="bulletList">Logging fundamentals:<ul>
<li class="bulletList"><a href="https://docs.microsoft.com/aspnet/core/fundamentals/logging/">https://docs.microsoft.com/aspnet/core/fundamentals/logging/</a></li>
</ul>
</li>
<li class="bulletList">What is new in CSharp?:<ul>
<li class="bulletList"><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9">https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9</a></li>
<li class="bulletList"><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10">https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10</a></li>
<li class="bulletList"><a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-11">https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-11</a></li>
<li class="bulletList"><a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12">https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12</a></li>
</ul>
</li>
<li class="bulletList">Source code analyzers:<ul>
<li class="bulletList"><a href="https://marketplace.visualstudio.com/items?itemName=SonarSource.SonarLintforVisualStudio2019">https://marketplace.visualstudio.com/items?itemName=SonarSource.SonarLintforVisualStudio2019</a></li>
<li class="bulletList"><a href="https://marketplace.visualstudio.com/items?itemName=SonarSource.SonarLintforVisualStudio2022">https://marketplace.visualstudio.com/items?itemName=SonarSource.SonarLintforVisualStudio2022</a></li>
<li class="bulletList"><a href="https://github.com/dotnet/roslyn-analyzers">https://github.com/dotnet/roslyn-analyzers</a></li>
<li class="bulletList"><a href="https://docs.microsoft.com/en-us/visualstudio/ide/code-styles-and-code-cleanup">https://docs.microsoft.com/en-us/visualstudio/ide/code-styles-and-code-cleanup</a></li>
<li class="bulletList"><a href="https://docs.sonarcloud.io/">https://docs.sonarcloud.io/</a></li>
<li class="bulletList"><a href="https://www.guidgenerator.com/ ">https://www.guidgenerator.com/</a></li>
</ul>
</li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the authors, and learn about new releases – follow the QR code below:</p>
<p class="normal"><a href="https://packt.link/SoftwareArchitectureCSharp12Dotnet8">https://packt.link/SoftwareArchitectureCSharp12Dotnet8</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_Code175081751210902046.png"/></p>
</div>
</body></html>