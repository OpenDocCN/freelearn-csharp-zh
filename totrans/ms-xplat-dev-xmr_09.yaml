- en: Chapter 9. Reusable UI Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss strategies and patterns for reusing visual
    assets (that is, text and media resources) in cross platform projects. Furthermore,
    reusable assets will be iteratively explained from the localization perspective.
    Finally, some advanced software architectural topics about Model-View-Controller
    and Model-View-ViewModel patterns will be analyzed and demonstrated. This chapter
    is divided into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Localization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architectural patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can classify any resource included in the project at compile time and used
    by the user interface as a visual asset. Visual assets can vary from simple text
    elements to media items (for example images, animations, videos, and so on) to
    be used for creating the visual elements of the user interface. Each Xamarin target
    platform provides different mechanisms to store and dispatch these assets.
  prefs: []
  type: TYPE_NORMAL
- en: On Android and iOS, resources and their localized representations are kept in
    the designated `Resources` folder and substructures. On Windows Phone (both Silverlight
    and Windows Runtime), resources can be managed by using embedded resource files
    (that is, `resw` or `resx`).
  prefs: []
  type: TYPE_NORMAL
- en: Text resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each Xamarin target platform uses various strategies to filter out static text
    resources, such as the content of a message dialog or a label, from the **View**
    implementation. Doing this helps developers separate human readable resources
    from code base, creating a project structure in line with the separation of concerns
    principle.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Android
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the Android platform, text resources can be stored in the `strings.xml` file
    and retrieved through code or used in declarative markups (that is, AXML files).
    The XML file containing the string resources can be found or created in the `Resources\values`
    directory. There is no relevance between the filenames and how the resources are
    retrieved later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resource XML file has a simple format, where each string is defined as
    an XML node with an associated name as an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The string values can later be used in markup, and also in Android declarative
    attributes, using the `@string/<ResourceName>` notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to add an activity label for a view, the `ApplicationName` string
    can be included directly with the `@string` notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: On top of the classic string resources, a collection of string resources and
    quantity strings can also be included in the resource XML file(s). Quantity strings
    are resource strings with a definition for different countable references for
    various scenarios with the correct pluralization rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, for an application with English as the default language, the
    plural quantity strings would look similar to the following (for example, a singular
    word for one, a plural form for others):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas for the Turkish language, it would look similar to the following (the
    same rule applies to all countable words):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Examples of this usage can be extended to Slavic languages (for example Russian,
    Polish, and Czech), where languages have different use cases for a small number
    of items or for numbers ending with certain digits. Possible switch values for
    quantities are `zero`, `one`, `two`, `few`, `many`, and `other`. The application
    of these switches follows the rules defined for language plurals in the unicode
    common locale data repository (see [http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html)
    for more information). For instance, English does not require a specific handling
    for few items or zero items, so any rule defined for these cases will be ignored
    by the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Once the resource XML file(s) are modified, you can see that the `Resource.Designer.cs`
    file is (re)generated with each compilation. This file contains the associated
    ID values for different types of resources and can be used for retrieving the
    resource items with the `Resources` utility class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Xamarin.Android](img/B04693_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: Generated resource constants'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `Resources` utility, text resources can be retrieved in the following
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, other primitive data types (for example, integers, Booleans, and
    so on), as well as units or `structs` used in style definitions (for example,
    dimension and color) can be included in resource XML files.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.iOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On the iOS platform, the simplest way to separate the text resources from the
    rest of the project would be to create `.strings` files (for example, `Localizable.strings`),
    which follow a simple JSON-like pattern with key/value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'These string values, compiled into bundle resources, can, later on, be accessed
    using the `NSBundle.MainBundle.LocalizedString` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Localized string values can be used as labels for UI controls, creating a loosely-coupled
    relationship between the static text content and the actual runtime components.
    This process is referred to as internationalization in the iOS ecosystem. Internationalized
    controls and elements can easily be localized for different languages. `Strings`
    files can be created in the `Resources` folder or can be placed in the `Base.lproj`
    folder inside the `Resources` directory, which constitutes the base localization
    project folder for iOS projects (the default/fallback resources).
  prefs: []
  type: TYPE_NORMAL
- en: 'For storyboards, the internationalization process can be a little more complicated.
    Each UI element in a storyboard is assigned a unique identifier called the **Object
    ID** in Xcode, while it is referred to as the **Localization ID** in Xamarin Storyboard
    Designer. In order to assign text content to a specific item on the storyboard,
    developers are required to create string files for each storyboard (for example,
    for a storyboard called `Main.storyboard`, you will need to create a `Main.strings`
    file) and use the localization ID of the specific control and the name of the
    text attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As one can see, the attribute names and casings are clearly different from the
    actual type properties of UI controls (for example, `text` for `UILabel`, `normalTitle`
    for `UIButton`). The iOS internationalization guidelines can provide details on
    the storyboard attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to create the base internationalization file for a storyboard is
    to use Xcode to generate the `string` file. In order to modify the Xamarin.iOS
    project with Xcode, the **Open With** context menu item can be used to select
    **Xcode Interface Builder** for a storyboard and the main project window to access
    the project properties.
  prefs: []
  type: TYPE_NORMAL
- en: '![Xamarin.iOS](img/B04693_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: Xcode Interface Builder'
  prefs: []
  type: TYPE_NORMAL
- en: In the Xcode interface, the localization settings are located on the project
    settings page. If the base localization folder was created beforehand, the **Base
    Localization** option will already be checked in the project settings localization
    section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Xamarin.iOS](img/B04693_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Xcode project configuration'
  prefs: []
  type: TYPE_NORMAL
- en: Any additional language selection generates a language specific `.lproj` folder
    and the `.strings` file for the targeted storyboards and strings files. Once the
    Xcode window is closed, these changes will be reflected in the Xamarin.iOS project
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Phone
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Windows Phone (Silverlight) projects, resources are managed through traditional
    `resx` files (a legacy of the .NET framework). The default language resources
    are generated with the project template and stored in the `AppResources.resx`
    file, located under the `Resources` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Windows Phone](img/B04693_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Windows Phone resources'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional types of content that can be embedded in the resources file are
    images, icons, audio, and other types of files. These files can be accessed through
    code and also in markup, using the generated `AppResources` class. Another generated
    class, `LocalizedStrings`, provides access to the resources stored in the embedded
    resource file(s):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In Windows Phone 8.1 (that is, Windows Runtime) and Windows 10, the applications
    use a `resw` file (called `PRIResource`, referring to the compilation method).
    Even though the format of `resx` and `resw` files is identical, `resw` files can
    only contain primitive values (that is, string values or values that can be expressed
    as strings). Using `resw` files, developers can assign style or other attribute
    values directly to user controls using the `Uid` value of the controls, similar
    to the internationalization of storyboards on iOS.
  prefs: []
  type: TYPE_NORMAL
- en: '![Windows Phone](img/B04693_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Windows Runtime PRI resources'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the targeted resources, developers are still free to use simple
    resource strings. These resources can be accessed using the `ResourceLoader` class
    and the `GetString` method.
  prefs: []
  type: TYPE_NORMAL
- en: Image resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mobile application projects can contain media assets from external sources as
    well as the application bundle. In each target platform, media assets can be included
    in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: While iOS and Windows Phone do not dictate a certain location in the project
    tree for media assets, in Android projects, developers are obliged to include
    image documents in the `drawable` folder of the `Resources` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image resources](img/B04693_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: Project structures'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the text resource structure on the iOS platform, it is advisable
    to place language-neutral image elements (for the default language) in the `Base.lproj`
    location if you are planning to localize them in later iterations. Also, asset
    catalogs can be employed to simplify the management of images and their pixel-perfect
    alternatives for different resolutions (see the *Adaptive visual assets* section).
  prefs: []
  type: TYPE_NORMAL
- en: Adaptive visual assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adaptive UI patterns for applications targeting Xamarin platforms force developers,
    at times, to include variations of media assets for different resolutions and
    pixel densities. Even though the image resources are scaled according to the aforementioned
    adaptive UI metrics, the scaled images do not always result in visually pleasing
    displays (for example, an image resized to double the original size, to have the
    same physical screen dimensions on different devices, does not appear as it should).
  prefs: []
  type: TYPE_NORMAL
- en: The Android platform uses the device compatibility configuration qualifiers
    for both image and text resource folders (that is, `drawables` and `values`),
    as well as other types of resources, such as layouts. In such projects, compatibility
    qualifiers are concatenated to the resource folder as a suffix (for example, the
    `drawables-xhdpi` folder can be used to provide images specific to extra high
    density device displays of approximately 320 dpi) and various default resources
    are added to this folder. Compatibility configuration not only deals with pixel
    density, but also provides selectors for mobile network related switches (that
    is, **MCC** (**mobile country code**) and **MNC** (**mobile network code**)),
    language, and region (see the *Localization* section), layout direction (that
    is, left to right or right to left), various screen size-related options, screen
    orientation, UI mode (related to the platform displaying the application—a car,
    desk, television, appliance, or watch), night mode (that is, day or night), input
    type-related configurations, and finally the platform API level/version.
  prefs: []
  type: TYPE_NORMAL
- en: On the iOS platform, image assets can be individually suffixed to provide different
    versions of the same image for different resolutions and device idioms (that is,
    iPhone, iPod, and iPad). Device idiom values (that is, device modifiers) are used
    with the tilde (`~`) character and can identify resources for iPhone and iPod
    using the `~iphone` suffix and resources for iPad using the `~ipad` suffix. The
    `@2x` suffix, which should appear before the device modifier, is used to identify
    high resolution image variants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the introduction of Windows Phone 8.1, the Windows Phone operating system
    only supported four variations: WVGA (480 x 800, only used by WP 7.1), WXGA (768
    x 1280), 720p (720 x 1280), and 1080p (1080 x 1920). The only way to differentiate
    between these resolutions was to use the `App.Current.Host.ScaleFactor` device
    configuration property (for example, a scale factor of 100 refers to WVGA and
    150 refers to HD). Windows Store apps (including Windows Phone 8.1) provide an
    automated scaling mechanism similar to that of iOS and Android. On the Windows
    Phone 8.1 platform, each resource file and/or folder can be suffixed with various
    qualifiers to support multiple display scales, languages and regions, contrasts,
    and similar, to tailor a customized look and feel for different device configurations.
    If the qualifiers are applied to a specific file, each qualifier/value pair should
    be separated by an underscore and added between the filename and the extension
    (that is, `filename.qualifiername-value_otherqualifier-value.fileextension`).
    If the qualifiers are applied to complete folders, for each qualifier/value, a
    subfolder should be created (that is, `resourcefolder/qualifier-value/otherqualifier-value/`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, see the following project path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This can be accessed with the `Images/myImage.png` resource path.
  prefs: []
  type: TYPE_NORMAL
- en: Reusable assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Managing media assets in cross platform projects, especially if you are providing
    variations for different device configurations, can become quite a hurdle. In
    order to reuse these assets for multiple platforms, linked file references can
    be utilized (**Add** | **Existing Item** | **Add as Link**).
  prefs: []
  type: TYPE_NORMAL
- en: '![Reusable assets](img/B04693_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: Add resource as link'
  prefs: []
  type: TYPE_NORMAL
- en: Using this strategy, image documents can be included in a common location for
    all platform-specific projects (for example, the common portable library), and
    only linked file references can be added to platform-specific projects.
  prefs: []
  type: TYPE_NORMAL
- en: This way, image documents are not copied to multiple locations, but only compiled
    into different platform-specific projects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reusable assets](img/B04693_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: Linked resources for normal and high definition in Windows Phone
    and Android projects'
  prefs: []
  type: TYPE_NORMAL
- en: Text resources in a cross-platform project do not differ greatly between platforms,
    especially if the resources in question are simple string values, rather than
    targeted attributes for UI controls (for example, text content specified for a
    label or a button on a storyboard). Another observation is that most of the text
    resource values are handled as key/value pairs in XML format (for Windows Phone
    and Android) or with simple JavaScript-like notation (in iOS). Elaborating on
    these assumptions, we can create an automated process that evaluates a common
    resource file and creates/generates the resource strings for the target platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the fact that we will use either a shared project library or a portable
    class library that will contain the shared code for the platform specific projects,
    this common project would be the most appropriate location to store the common
    resource strings. We can use this project to create the common resource package
    in the `resx` format.
  prefs: []
  type: TYPE_NORMAL
- en: These embedded resource files, as previously mentioned, are simple XML files
    in which the string resources pairs are stored in `<data>` nodes with the `name`
    attribute as the key and the `<value>` text node as the value (the rest of the
    file contains the XSD schema and metadata values for code generation).
  prefs: []
  type: TYPE_NORMAL
- en: '![Reusable assets](img/B04693_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: Resx file XML structure'
  prefs: []
  type: TYPE_NORMAL
- en: Android string resources have a similar structure with less complexity and different
    node names (that is, resource values are represented with `<string>` text nodes
    with the attribute `name`). Conversion between the two XML files is fairly simple
    with an XSL transformation in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: XSL is an abbreviation for Extensible Stylesheet Language and is used for transforming
    XML documents from one format to another. XSLT files may utilize templates, XPath
    queries, and other XSL functions to process XML document content. More information
    can be found at [http://www.w3schools.com/xsl/default.asp](http://www.w3schools.com/xsl/default.asp).
  prefs: []
  type: TYPE_NORMAL
- en: 'To transform the resource file into the Android format, we will create an XSLT
    file in the same folder as the `AppResources.resx` file in the common project.
    In order to create the Android XML resource file, we need to select each `<data>`
    element from the `<root>` node and create `<string>` nodes with appropriate text
    content and attributes inside the `<resources>` root node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, after this step, we can use the XML menu to debug the XSLT file using
    the `resx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reusable assets](img/B04693_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10: XSL Transformation debug session in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: After confirming that the transformation works as expected, we can now automate
    this process to regenerate the strings file every time the common project is rebuilt.
    For this automation, we can use a third-party XML transformation command line
    application and add the console command as a pre-build event command line argument
    using the project settings. Another option would be to use the out-of-box `MSBuild`
    task `XslTransformation` to add a `BeforeBuild` target.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to add new build targets, the `csproj` file needs to be modified in
    Visual Studio. For this purpose, the common project first needs to be unloaded
    using **Unload Project** from the project context menu, and the project file can
    be edited using the **Edit <Project File Name>** option from the same context
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `XslTransformation` task is a simple build task with three basic parameters
    for the XML file that needs to be transformed (that is, `XmlInputPath`), the XSL
    file to be used for the transformation (that is, `XslInputPath`), and finally
    the output path (that is, `OutputPaths`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With this modification, every time the common project is built (with a default
    setup, the common project should be built before the Android project), the `strings.xml`
    file will be generated and placed into the values folder in the Android project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same transformation approach is applicable to the iOS localized `strings`
    files. In an iOS-specific transformation, the output should be set to text and
    the transformation style sheet should create the key/value pairs. In order to
    create the lines of text for each data element in the embedded resource file,
    the `concat` function can be utilized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this stylesheet, it is important to note that text elements (symbols), such
    as double quotes and carriage return (that is, line feed and end of line), are
    HTML encoded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the transformation result is confirmed, we can add another `XslTransformation`
    task to the project file as a `BeforeBuild` target to create the localized `strings`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using the same implementation, the translation values containing the `resx`
    files can be transformed and used to generate localized resources for the target
    platforms. In addition to XSL transformations, T4 templates can also be used to
    generate the text resource files. Since certain build tasks (including `XslTransformation`)
    are not yet supported by xBuild and Xamarin Studio, T4 templates can provide an
    alternative if your main development environment is Mac OS and main development
    IDE is Xamarin Studio. With T4 templates, it is also possible to iterate through
    each file in the common resources and generate matching localization files in
    platform-specific projects.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will summarize the localization strategies on Xamarin target
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Localization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Localization and globalization are the two fundamental concepts of mobile applications.
    In the previous sections, we discussed different ways of separating visual content
    from the rest of the application. This process, in essence, prepares the mobile
    application to be localized and is generally a part of the globalization phase.
    Globalized applications should function the same way, independent of the culture
    or locale they are being executed on. During localization, developers are supposed
    to create language-specific resources and integrate them into the globalized applications.
  prefs: []
  type: TYPE_NORMAL
- en: Locale and culture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Locale can be defined as the umbrella term that includes all regional configurations
    on a specific device (or a specific application in some cases). The locale not
    only represents the user interface language, but also the formats used to display
    dates, times, numbers, and currency values.
  prefs: []
  type: TYPE_NORMAL
- en: As part of the globalization effort, in Xamarin target platforms, developers
    first need to identify which languages are going to be supported as part of the
    localization effort. A mobile application, after it is published and installed
    by the user, should manifest the supported languages so that the user interface
    can be rendered either with the locale that is dictated by the operating system
    (if supported) or the default/fallback language of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The supported languages manifest is a calculated value according to the resources
    provided (Android) or a pre-declared manifest or project entry (iOS and Windows
    Phone).
  prefs: []
  type: TYPE_NORMAL
- en: Windows Phone
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Windows Phone Silverlight application projects, resources for different languages
    can be provided using resource packages according to the naming conventions. The
    provided packages should then be referenced in the `WMAppManifest.xml` file. The
    easiest way to include additional language support for a Windows Phone application
    is to use the project properties to identify the supported cultures.
  prefs: []
  type: TYPE_NORMAL
- en: '![Windows Phone](img/B04693_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11: Project Properties for Windows Phone Silverlight application'
  prefs: []
  type: TYPE_NORMAL
- en: Once the project configuration modifications are saved, Visual Studio automatically
    creates the associated `resx` files (for example, `AppResources.bs.resx` for Bosnian,
    `AppResources.tr-TR.resx` for Turkish) and updates the application manifest. The
    default language can be modified from the package manifest (that is, `package.appxmanifest`)
    or the application manifest (`WMAppManifest.xml`) designers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows Store applications (that is, Windows Phone 8.1) are globalized using
    folders named after the supported languages containing the `resw` resource files.
    For instance, in order to create an application that targets the same cultures
    as the previous example, we would need to create a folder structure and culture-specific
    resource files similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Windows Phone](img/B04693_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12: Windows Store apps supported cultures and app bundle'
  prefs: []
  type: TYPE_NORMAL
- en: Once the application package is created, you will notice that instead of a single
    application package, an application bundle is created and each supported culture
    has an associated store app package in the bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Application bundles are used in Windows Store applications to reduce the size
    of the application packages that users are going to download for specific CPU
    architecture (ARM, x86, or x64), display hardware (image and other media assets,
    optimized for different resolutions), or locale. The packaging strategy can be
    selected while creating application packages, but if bundling is declined, developers
    are required to create a different upload package for each CPU architecture they
    are planning to support with their applications.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.iOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As previously explained, for Xamarin.iOS, once the additional languages are
    selected for the project in the Xcode development environment, generated localization
    folders and files are automatically added to the Xamarin.iOS project. The generated
    storyboard string files initially contain the possible localizable fields and
    the assigned values from the storyboard. Other string bundle resource files are
    copied with the same values from the `Base.lproj` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Xamarin.iOS](img/B04693_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13: Localized Xamarin.iOS project'
  prefs: []
  type: TYPE_NORMAL
- en: When using text resource files for localization, the `LocalizedString` function
    for the `MainBundle` property either returns the value that matches the current
    user language selection or the default value defined in the `Base.lproj` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using Visual Studio for creating and editing the `strings` files, it is
    a good idea to map the `strings` extension to JavaScript editor using the **Options**
    dialog and the **Text Editor** | **File Extension** section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to load a language-specific resource that does not match the current
    preferred language(s) configuration, you will need to use the localization bundle
    path and retrieve the localized resources using the same function on this bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The native development language directory (that is, `Base.lproj`), as well as
    the language-specific folders, can also be used to store other types of bundle
    resources, such as image resources, storyboards, XIB files, or even language-specific
    `Info.plist` files. (The `InfoPlist.strings` file in a language directory can
    be used to override values from the application's `Info.plist` file, such as the
    application name.)
  prefs: []
  type: TYPE_NORMAL
- en: It is crucial to add the supported languages to the info manifest. For localization,
    there are two relevant keys. The first relevant item is the *Localization* native
    development region (that is, `CFBundleDevelopmentRegion`) and the second key is
    the *Localizations* (that is, `CFBundleLocalizations`). While the native development
    region defines the language associated with the `Base.lproj` location, the localizations
    entries provide information about the other supported localizations.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Localization in Xamarin.Android projects, similar to the folder structure of
    Windows Phone 8.1 projects, is achieved using a specific folder structure with
    the language code suffixed into the localized resource items (for example, `drawable-tr`
    or `values-en`).
  prefs: []
  type: TYPE_NORMAL
- en: '![Xamarin.Android](img/B04693_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14: Android localization folder structure'
  prefs: []
  type: TYPE_NORMAL
- en: An appropriate resource is selected in the runtime using a simple elimination
    algorithm that selects the correct resource file according to the locale, display
    density, display size, touch support, and other criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Xamarin.Forms portable class library project template provides the ideal
    environment for text resource sharing. In this setup, with a process similar to
    Windows Phone Silverlight projects, `resx` files can be used to create resource
    bundles that can be used to localize the cross-platform views created with Xamarin.Forms
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: '![Xamarin.Forms](img/B04693_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15: Localized Xamarin.Forms resources'
  prefs: []
  type: TYPE_NORMAL
- en: Once the embedded resource files and their translation counterparts are added
    to the common PCL project, the resource entries can be accessed using the generated
    static class. In order for the generated class to be accessible from the platform
    specific implementations, the **Custom Tool** property of the resource file must
    be set to `PublicResXFileCodeGenerator` and the **Build Action** property to `Embedded
    Resource`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With Xamarin Studio or Visual Studio, the file properties window can be used
    to set to the correct access modifier for the resource accessors. In Visual Studio,
    the resource editor can also be used to correct the access modifier of resource
    items (that is, select **Access Modifier** | **Public** using the resource designer).
  prefs: []
  type: TYPE_NORMAL
- en: In the Windows Phone runtime, the correct resource files are loaded according
    to the current thread culture, so the preceding implementation would automatically
    choose the appropriate embedded resource. However, supported languages should
    still be configured using the application manifest. In Xamarin.iOS, the correct
    resources are loaded according to the users' language preferences (not the current
    UI language) and supported languages should be included in the `Info.plist` file
    using the `CFLocalizations` entry. For the Android platform, UI language selection
    is taken as the identifier for the resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following implementation would localize the tabbed page implementation
    from the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the highlighted line of code sets the accessor properties
    to specific resource elements. When using XAML for the same implementation, we
    can resort to statically bound properties using the `TextResources` generated
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It is important to include the CLR namespace containing the generated resource
    accessor.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The user interface of an application can be described as the packaging over
    the sum of all the moving parts underneath. As applications get more complex,
    the responsibilities of the user interface increase and it gets harder to package
    the product underneath. Leaving aside the static parts of the UI (that is, assets
    described in the previous sections of this chapter), it is the most volatile part
    of an application. In order to counteract the entropy that builds up throughout
    the application's lifetime, solve recurring problem patterns, and re-use modules,
    developers often utilize certain design patterns in their development efforts.
    Especially in cross-platform projects, the importance of these architectural design
    patterns have been proven to be irrefutable.
  prefs: []
  type: TYPE_NORMAL
- en: For demonstration purposes, let's use a simple form-submit scenario. In this
    implementation, the users will be greeted with a form they will have to fill in.
    Once all the required text fields are populated by the user, he/she will submit
    the content using the submit button. The data is then validated and stored. The
    user should then be informed about the submission with a read-only screen where
    he/she can see the submitted and stored data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Architectural patterns](img/B04693_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16: The classic *n*-tier scenario'
  prefs: []
  type: TYPE_NORMAL
- en: In an *n*-tier implementation, the presentation tier would be responsible for
    visualizing the data and would hold an instance of the API façade. The API façade
    would implement the business logic to validate the information and submit it to
    the data tier instance. The data tier would be solely responsible for communicating
    with the persistence store (possibly through the service layer).
  prefs: []
  type: TYPE_NORMAL
- en: The event subscriptions (that is, text field changed or submit button clicked)
    would be implemented in the presentation layer. On successful submission, the
    presentation layer would pass on the current API object to a new presentation
    container and visualize the submitted data. Even though this approach provides
    a clear separation between the tiers, there are still strong ties between the
    layers in the hierarchy (that is, the presentation layer holds a strongly typed
    reference of the API and the API either reuses or creates a new instance of the
    data model). The application tier also creates an unnecessarily large and complex
    structure that should provide the required methods for all the containers and
    related scenarios in the presentation layer. The presentation layer still has
    the most responsibility in terms of event-driven implementation. If we transpose
    this implementation onto a Xamarin cross-platform project, we would be able to
    reuse the complete application tier and the data tier across platforms. However,
    it would still require quite a bit of re-implementation for the presentation layer
    for other platform projects, as this layer is responsible for using the API. Another
    downside of this pattern is the fact that, other than the façade, it isn't easy
    to unit test the implementation (that is, there are multiple event subscriptions
    on the presentation layer).
  prefs: []
  type: TYPE_NORMAL
- en: '**MVP** (**model-view-presenter**) and **MVVM** (**model-view-viewmodel**),
    both derivatives of **MVC** (**model-view-controller**), try to answer some of
    these issues for classic *n*-tier implementations. Both of these patterns inherently
    use a passive presentation layer and delegate the main responsibility to the supervising
    or mediating component; the main reason for this is the fact that unit testing
    the view is generally impractical, hence it should be devoid of logic as much
    as possible. The presenter communicates with the data tier actively and is responsible
    for how the view should be visualized. In this paradigm, the only way the view
    communicates with the mediator is through routed events (separation of concerns).
    It is also important to note that in these architectural implementations, the
    application is divided into self-sufficient triads (that is, model, view, and
    presenter) which make up different use-cases and views in the application. Façades
    are generally used only in the model component.'
  prefs: []
  type: TYPE_NORMAL
- en: MVC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MVC pattern was initially introduced into Smalltalk, and later on popularized
    with its (excessive) use in web applications and frameworks. In classic MVC implementation,
    the **Model** not only provides access to a data store but also implements any
    required business logic. The **Model** can be described as the core implementation
    of the problem domain, independent of the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: The **Controller** generally represents the logic stripped out of the **View**;
    it can send commands to the **Model** as well as the **View**, and receive the
    routed events from the **View**. Changes in state (that is, in the **Model**),
    are reflected on the **View** with or without the intervention of the **Controller**
    (classic MVC allows active or implicit interactions between the **Model** and
    the **View**).
  prefs: []
  type: TYPE_NORMAL
- en: iOS app architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In iOS applications, the main development language hitherto has been Objective-C.
    The Cocoa and Cocoa Touch frameworks used for Mac OS and iOS application development,
    respectively, were also developed mainly in Objective-C. Considering the strong
    ties between Objective-C and SmallTalk, it is no surprise the main development
    pattern adopted and enforced by the iOS development kit is MVC.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Cocoa version of MVC implementation, direct communication between the
    **View** and **Model** is completely abandoned (and prohibited) because of the
    technical requirements of the mobile application development environment, and
    in order to increase the reusability of model and view components. In this pattern,
    the **Controller** (also called the mediator at times) is given the main responsibility
    to control the flow of data between the **View** and the **Model**. From this
    aspect, Cocoa''s implementation of MVC undeniably resembles the MVP pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![iOS app architecture](img/B04693_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17: Cocoa MVC'
  prefs: []
  type: TYPE_NORMAL
- en: In this implementation schema, developers are encouraged to decouple the components
    of the triad from each other and implement the communication between them only
    through the defined abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: The separation between the **View** and the **Controller** is generally achieved
    with commands, outlets, and bindings. Commands provide actionable composites that
    can be passed from one layer to another, and outlets are extensions of certain
    UI elements so that the controller can subscribe to events and control how the
    UI is presented according to state.
  prefs: []
  type: TYPE_NORMAL
- en: When view elements are designed using XIBs or storyboards (that is, storyboards
    are used to generate the XIBs at compile time), the outlets are defined as access
    points for the **View**-**Controller**. **View**-**Controllers** do not have a
    direct dependency on the **View**, nor does the **View** have any knowledge of
    the **Controller**. This setup complies with the separation of concerns principle
    and provides a loosely coupled structure as advised.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to implement the scenario from the previous example, we would be
    exposing two outlets for the text input fields in the submit form and an outlet
    for the submit button. These outlets would, in return, be used by the Controller
    assigned to the **View** for subscribing to certain events, to validate and submit
    the data. The **View**-**Controller** (that is, **UIController**) is also responsible
    for changing how the controls are displayed (for example, validation can change
    the color of the text input field) and communicating user actions such as the
    submission of data to the **Model**. Navigating to another view is also the responsibility
    of the **Controller** in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '![iOS app architecture](img/B04693_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18: MVC demonstration on an iOS form'
  prefs: []
  type: TYPE_NORMAL
- en: Segue navigation between views is another possible navigation strategy when
    the Controller for the new **View** exists in the calling **Controller**, or the
    same UI controller is used for both of the views (that is, the same **Controller**
    could have been used for both submit and read-only views in the preceding example).
  prefs: []
  type: TYPE_NORMAL
- en: MVVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**MVVM** (**Model-View-ViewModel**), a derivative of the MVP pattern, provides
    well-established boundaries between the UI, business logic, and data. After its
    emergence, it almost immediately became the main implementation pattern for **WPF**
    (**Windows Presentation Foundation**) applications. The data binding features
    provided by the WPF framework make up the foundation of this mediation pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data binding is the terminology used to describe the mechanism which connects
    data visualization elements from the UI layer (that is, the controls) to other
    controls or data objects from other tiers. The synchronization between the two
    actors of the binding is maintained through various events (for example, the `INotifyPropertyChanged`
    interface is used to propagate value change events).
  prefs: []
  type: TYPE_NORMAL
- en: In this pattern, the ViewModel is the main actor, whose responsibility is to
    control the data flow between the **View** and the **Model**. The outlets, in
    this architecture, are exposed by the ViewModel and used by the View implementation
    (as opposed to the iOS MVC architecture). The ViewModel provides these outlets
    in the form of data elements that can be associated to attributes or states of
    the UI controls, and also as generic commands that can be used by the **View**
    controls to respond to user input.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Windows Phone applications, as well as Windows Store applications, natively
    support data binding for UI controls. This feature makes Windows Phone applications
    ideal candidates for this architecture. However, architectural elements should
    still be implemented by developers according to the requirements of specific projects.
    There are multiple (open-source or commercial) libraries that can be included
    as NuGet packages in development projects, including Prism (a cross-platform MVVM
    library, which was initially a pet project of the Microsoft patterns and practices
    team, but is now being maintained by the community) and MVVMCross (a cross-platform
    open source MVVM framework).
  prefs: []
  type: TYPE_NORMAL
- en: At the core of the MVVM pattern and data binding, we can locate the implementation
    of a bindable base class. A bindable base provides the implementation of the `INotifyPropertyChanged`
    interface and makes it easier to identify and implement the data elements that
    will take part in data binding. This interface is used to route value changed
    events from data items and their properties to UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple bindable base implementation would look similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of this class can be used with model data items so that
    any change can be reflected on the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `ModelData` class can already be used as the ViewModel and its bindings
    provided to `Property1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The data binding to an input control on the main page would look similar to
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this binding scenario, we set the binding mode to `TwoWay`. This binding
    type means that any change on this property value, either on the ViewModel or
    on the user interface (that is, on user input), would be propagated to the UI
    element, or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data bindings can be maintained using different modes. The **OneTime** binding
    is used to update the target property using the source property when the data
    source changes. This type of binding is generally used by read-only controls.
    The **OneWay** binding is used only to update the target property when the source
    property value changes, whereas the **TwoWay** mode is for duplex synchronization.
    Finally, **OneWayToSource** is used only to update the source property if there
    are any changes on the target property.
  prefs: []
  type: TYPE_NORMAL
- en: Data bindings are not limited to values from and to ViewModel properties. Bindable
    properties of user controls can also be bridged in this pattern. Moreover, bindable
    properties of user controls include behavioral and style attributes (for example,
    the `IsEnabled` property of a `TextBox` user controls). Additional bindable properties
    can be provided to intrinsic or derived user controls using attached and/or dependency
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Command binding is another concept which provides a decoupled way to associate
    user action controls (for example, `Button`) with executable elements on the data
    context (that is, the ViewModel). In order for a user control to be bound to a
    command, the user control should implement a bindable command attribute and the
    ViewModel should provide an `ICommand` implementation of a specific action. The
    `ICommand` interface is a simple interface containing a `CanExecute` property,
    an associated `CanExecuteChanged` event (which is generally bound to the `IsEnabled`
    property of the user control), and the `Execute` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple command implementation that will validate the data model from the
    previous example and then execute would look similar to the following implementation
    (note that MVVM frameworks generally provide a generic `Command` class, which
    accepts delegates and/or lambdas for `Execute` and `CanExecute` methods):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With this implementation (either public or a nested class of the data model
    defined previously), we can initialize and expose the command when a new `ModelData`
    class is initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the binding for this command in XAML markup would look similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If we were to use the MVVM pattern to implement the previous form submission
    scenario, we can observe the implementation of both data and command bindings.
    We could implement a ViewModel class that is responsible for loading and submitting
    a bindable data item. The view would have the bindings to the ViewModel properties
    and commands, as well as bindings to the data item itself.
  prefs: []
  type: TYPE_NORMAL
- en: '![Windows Runtime](img/B04693_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19: MVVM implementation of the form submission scenario'
  prefs: []
  type: TYPE_NORMAL
- en: In this design, `SubmitCommand` is used both to submit the user input to the
    **Model** and to validate the form itself (using the `CanExecute` method). The
    `IsReadOnly` property of the ViewModel is bound to the `IsReadOnly` properties
    of the text fields and the `Visibility` property of the submit button (in read-only
    mode, instead of the submit button, the submitted label should be displayed),
    possibly with an `IValueConverter` (an interface used in two-way conversions between
    bound properties in data-binding scenarios).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Value converters implement the `IValueConverter` interface to apply custom logic
    to the binding process. They are generally used as adapters for the CLR type of
    the target property and the source property (for example, if the data model property
    type was a `string` defining a certain color, we would need to convert/parse this
    value to `SolidColorBrush` or similar to assign it to visual elements' properties).
  prefs: []
  type: TYPE_NORMAL
- en: Besides the loose coupling and modularity achieved by using MVVM, the pseudo-finite
    automaton provided by the ViewModel allows developers to easily recreate different
    data states used by the view and implement unit tests without much hassle.
  prefs: []
  type: TYPE_NORMAL
- en: MVVM on Xamarin.iOS and Xamarin.Android
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Xamarin projects, in order to create a uniform structure between the applications
    for different platforms and maximize code sharing, it is a widely accepted implementation
    principle to use the MVVM pattern solution-wide. Since data bindings and commanding
    pattern implementations are not natively supported on iOS and Android, using an
    MVVM framework that supports cross-platform development with Xamarin can be a
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to mention that iOS and Cocoa have the concept of key-value
    observing, and a binding-like implementation can be applied to some extent.
  prefs: []
  type: TYPE_NORMAL
- en: On Xamarin.iOS and Xamarin.Android, bindings are generally provided through
    the extensions to `UIViewController` (on iOS) and `Activities` (on Android). In
    iOS, this implementation strategy transforms the **View** and **Controller** from
    MVC architecture into mere **View** implementations, while the ViewModel, conceptually,
    replaces the **Model** implementation. Bindings to the ViewModel are initialized
    in the application lifecycle events of the `UIViewControllers` and `Activities`.
  prefs: []
  type: TYPE_NORMAL
- en: MVVM with Xamarin.Forms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The data binding feature of Xamarin.Forms is an implementation/port of the WPF
    data bindings, so XAML bindings are supported for both data and commands. The
    main difference between Xamarin.Forms and Windows Runtime is that in Windows Store
    applications, binding context for a user control or a container is configured
    using the `DataContext` property, whereas in Xamarin.Forms, the `BindingContext`
    property is used for the same purpose. Xamarin.Forms additionally provides generic
    command implementation classes (namely, `Command` and `Command<T>`) which allow
    developers to expose commands without having to implement the `ICommand` interface
    in nested classes for the ViewModels.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In cross-platform projects, with or without Xamarin.Forms, it is advisable to
    maintain the View elements as thin and devoid of static and/or sharable elements
    as possible. As discussed in this chapter, each Xamarin target platform supports
    resource and asset management in particular ways. These methodologies can be expanded
    to share static resources between the platform-specific projects by using linked
    resources and/or using special build techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural patterns, imposed by the platform or otherwise, can also be employed
    either at the beginning of the project or as the project matures through iterations.
    MVC and MVVM, as well as MVP, patterns help reduce the sharable logic components
    on the View, creating a more loosely-coupled project structure (see quality identifiers
    in [Chapter 1](ch01.html "Chapter 1. Developing with Xamarin"), *Developing with
    Xamarin*).
  prefs: []
  type: TYPE_NORMAL
- en: After having covered different aspects of the Xamarin framework and UI-related
    concepts, in the next part of the book, we will discuss **Application Lifecycle
    Management** (**ALM**)-related topics to create an efficient development pipeline
    for individuals or teams dealing with Xamarin projects.
  prefs: []
  type: TYPE_NORMAL
