<html><head></head><body>
		<div><h1 id="_idParaDest-328" class="chapter-number"><a id="_idTextAnchor426"/>10</h1>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor427"/>Pipelines and Composition</h1>
			<p>In this chapter, we will combine all knowledge from previous chapters and first discuss function composition, which allows us to combine simple functions to create more complex operations. Then, we will see how to construct pipelines using the <code>Pipe</code> method. We will also recall how to create monadic pipelines that gracefully handle errors. Furthermore, the fluent interface technique, which helps to write code that can be read almost like regular text, will be presented.</p>
			<p>To sum it up, this chapter walks us through these topics:</p>
			<ul>
				<li>Function composition</li>
				<li>Building pipelines</li>
				<li>The fluent interface</li>
				<li>Advanced composition with monads</li>
			</ul>
			<p>I could not betray our tradition and, for the last time, prepared three self-check tasks for you.</p>
			<h1 id="_idParaDest-330"><a id="_idTextAnchor428"/>Task 1 – Enemy wave processing pipeline</h1>
			<p>Compose a series of functions into a pipeline that processes a list of enemy waves, applying <a id="_idIndexMarker562"/>increased difficulty (hard mode), validating the result, and transforming it into a formatted string using the following code:</p>
			<pre class="source-code">
public class EnemyWave
{
   public int WaveNumber { get; set; }
   public int EnemyCount { get; set; }
   public string Description { get; set; }
}
Func&lt;EnemyWave, bool&gt; validateWave = wave =&gt; wave.EnemyCount &gt; 0;
Func&lt;EnemyWave, EnemyWave&gt; applyHardMode = wave =&gt;
{
   wave.EnemyCount = (int)(wave.EnemyCount * 1.2); // +20% enemies
   return wave;
};
Func&lt;EnemyWave, string&gt; formatWave = wave =&gt; $"Wave {wave.WaveNumber}: {wave.Description} - {wave.EnemyCount} enemies";</pre>			<h1 id="_idParaDest-331"><a id="_idTextAnchor429"/>Task 2 – Game data file processing</h1>
			<p>Using the following code, compose a series of monadic functions into a pipeline that processes <a id="_idIndexMarker563"/>a game data file, reads its content, processes it, and writes the result to another file:</p>
			<pre class="source-code">
Func&lt;string, Result&lt;string&gt;&gt; readGameDataFile = path =&gt;
{
   try
   {
       var content = File.ReadAllText(path);
       return Result&lt;string&gt;.Success(content);
   }
   catch (Exception ex)
   {
       return Result&lt;string&gt;.Failure($"Failed to read file: {ex.Message}");
   }
};
Func&lt;string, Result&lt;string&gt;&gt; processGameData = content =&gt;
{
   // Simulate game data processing
   return Result&lt;string&gt;.Success(content.ToUpper());
};
Func&lt;string, Result&lt;bool&gt;&gt; writeGameDataFile = content =&gt;
{
   try
   {
       File.WriteAllText("processed_game_data.txt", content);
       return Result&lt;bool&gt;.Success(true);
   }
   catch (Exception ex)
   {
       return Result&lt;bool&gt;.Failure($"Failed to write file: {ex.Message}");
   }
};</pre>			<h1 id="_idParaDest-332"><a id="_idTextAnchor430"/>Task 3 – Dynamic SQL query generation using currying and partial application</h1>
			<p>Use currying <a id="_idIndexMarker564"/>to build a <a id="_idIndexMarker565"/>function for dynamic query generation for tower defense game data and partially applied functions for querying enemy types and levels. Use the following function to generate query scripts:</p>
			<pre class="source-code">
Func&lt;string, string, string, string&gt; generateSqlQuery = (table, column, value) =&gt;
     $"SELECT * FROM {table} WHERE {column} = '{value}'";</pre>			<p>These tasks should be already familiar to you since they were discussed in previous chapters. However, you still might feel that there is room for improvement in your mastery of composition, currying, or partial application. If so, you are more than welcome to proceed with reading this chapter.</p>
			<h1 id="_idParaDest-333"><a id="_idTextAnchor431"/>Function composition</h1>
			<p>Steve looked <a id="_idIndexMarker566"/>at Julia with a mix of excitement and nervousness.</p>
			<p>Steve: <em class="italic">So, we’re finally putting all the pieces together? I’m excited but a </em><em class="italic">little overwhelmed.</em></p>
			<p>Julia: <em class="italic">Don’t worry, Steve. We’ll take it step by step. Remember, these concepts build on each other. You’ve already learned </em><em class="italic">a lot!</em></p>
			<p>Steve: <em class="italic">You’re right. I’m ready to dive in. Where do </em><em class="italic">we start?</em></p>
			<p>Julia: <em class="italic">Let’s begin with function composition. It’s a great way to combine everything we’ve learned </em><em class="italic">so far...</em></p>
			<p>Function composition is the process of combining two or more functions to produce a new function. Let’s spice things up a notch and add higher-order functions to our composition example.</p>
			<p>Consider a scenario where we need to transform a list of user data. We have the following higher-order functions:</p>
			<p><strong class="bold">map</strong>: Applies a function to each element in a list</p>
			<p><strong class="bold">filter</strong>: Filters elements in a list based on a predicate</p>
			<p>We will <a id="_idIndexMarker567"/>define these functions in the following way:</p>
			<pre class="source-code">
Func&lt;IEnumerable&lt;string&gt;, Func&lt;string, string&gt;, IEnumerable&lt;string&gt;&gt; map = (list, func) =&gt; list.Select(func);
Func&lt;IEnumerable&lt;string&gt;, Func&lt;string, bool&gt;, IEnumerable&lt;string&gt;&gt; filter = (list, predicate) =&gt; list.Where(predicate);</pre>			<p>Next, let’s define our transformation and filtering functions:</p>
			<pre class="source-code">
Func&lt;string, string&gt; capitalize = input =&gt; char.ToUpper(input[0]) + input.Substring(1);
Func&lt;string, bool&gt; startsWithA = input =&gt; input.StartsWith("a");</pre>			<p>We can now compose <code>map</code> and <code>filter</code> to create a function that will do all these actions at once:</p>
			<pre class="source-code">
Func&lt;IEnumerable&lt;string&gt;, IEnumerable&lt;string&gt;&gt; processUsers = users =&gt; map(filter(users, startsWithA), capitalize);</pre>			<p>As a result, we have the <code>processUsers</code> function filter the list first to only include strings that start with “a” and then capitalize each remaining string. Of course, we could write all code using just one <code>processUsers</code> method, but the current solution allows us to reuse small functions in different places. The idea here is to start replacing big methods with compositions of smaller ones. Additional benefits are that small methods have much lower cognitive load and cyclomatic complexity, making them much easier to read and maintain.</p>
			<p>As Julia finished explaining function composition, Steve nodded thoughtfully.</p>
			<p>Steve: I think I’m starting to see how this all fits together. But how do we use this in larger applications?</p>
			<p>Julia: Great <a id="_idIndexMarker568"/>question! That’s where pipelines come in. They allow us to chain these composed functions in a more structured way. Let me show you...</p>
			<h1 id="_idParaDest-334"><a id="_idTextAnchor432"/>Building pipelines</h1>
			<p>Before constructing pipelines, let’s briefly recap two key concepts from the previous chapter: currying and partial application. These techniques are fundamental to creating flexible, reusable function components that serve as excellent pipeline building blocks.</p>
			<p>Currying, as we <a id="_idIndexMarker569"/>learned, transforms a function that takes multiple arguments into a sequence of functions, each accepting a single argument. Here’s an example:</p>
			<pre class="source-code">
Func&lt;int, int, int&gt; add = (a, b) =&gt; a + b;
Func&lt;int, Func&lt;int, int&gt;&gt; curriedAdd = a =&gt; b =&gt; a + b;</pre>			<p>Partial application, on the other hand, involves fixing a number of arguments to a function, producing another function with fewer parameters:</p>
			<pre class="source-code">
Func&lt;int, int, int&gt; multiply = (a, b) =&gt; a * b;
Func&lt;int, int&gt; triple = x =&gt; multiply(3, x);</pre>			<p>These concepts naturally lead on to pipeline construction. By currying functions or partially applying them, we create specialized, single-purpose functions that can be easily composed into pipelines. This approach allows us to do the following:</p>
			<ul>
				<li>Break down complex operations into simpler, more manageable pieces</li>
				<li>Reuse these pieces across different pipelines or contexts</li>
				<li>Create more expressive and readable code by chaining these specialized functions</li>
			</ul>
			<p>For instance, consider a pipeline for processing game data:</p>
			<pre class="source-code">
var processGameData =
     LoadData()
     .Then(ValidateData)
     .Then(TransformData)
     .Then(SaveData);</pre>			<p>Each step in this pipeline could be a curried or partially applied function, allowing for easy customization and reuse. As we explore pipeline construction further, remember how currying and partial application can be leveraged to create more flexible and powerful pipelines.</p>
			<p>Now, let’s move on to building pipelines.</p>
			<p>Pipelines process data through a sequence of processing steps, each represented by a function. This <a id="_idIndexMarker570"/>approach is particularly useful for tasks that require multiple transformations, validations, or computations. You most probably have already encountered pipelines while using LINQ to manipulate collections.</p>
			<p>Let’s consider <a id="_idIndexMarker571"/>a real-world scenario: an <strong class="bold">Extract, Transform, Load</strong> (<strong class="bold">ETL</strong>) process for publishing manuscripts. This process involves several steps:</p>
			<ol>
				<li>Extracting (querying) the manuscript from a database</li>
				<li>Validating its content</li>
				<li>Transforming it into the required format</li>
				<li>Loading (submitting) it for publication</li>
			</ol>
			<p>Each step can be represented as a function, and we can use a pipeline to streamline this process. To do this, let’s create a method that applies a sequence of functions to an initial value, passing the result of each function to the next, and name it <code>Pipe</code>:</p>
			<pre class="source-code">
public static T Pipe&lt;T&gt;(this T source, params Func&lt;T, T&gt;[] funcs)
{
     return funcs.Aggregate(source, (current, func) =&gt; func(current));
}</pre>			<p>Let’s consider book manuscript processing: querying the manuscript from a database, validating its content, transforming it into the required format, and finally submitting it for publication:</p>
			<pre class="source-code">
public class Manuscript
{
     public string Content { get; set; }
     public bool IsValid { get; set; }
     public string FormattedContent { get; set; }
}
public Manuscript Query(Manuscript manuscript)
{
     // Simulate querying the manuscript from a database
     manuscript.Content = "Original manuscript content.";
     return manuscript;
}
public Manuscript Validate(Manuscript manuscript)
{
     // Simulate validating the manuscript
     manuscript.IsValid = !string.IsNullOrWhiteSpace(manuscript.Content);
     return manuscript;
}
public Manuscript Transform(Manuscript manuscript)
{
     // Simulate transforming the manuscript content
     if (manuscript.IsValid)
     {
         manuscript.FormattedContent = manuscript.Content.ToUpper();
     }
     return manuscript;
}
public Manuscript Submit(Manuscript manuscript)
{
     // Simulate submitting the manuscript for publication
     if (manuscript.IsValid)
     {
         Console.WriteLine($"Manuscript submitted: {manuscript.FormattedContent}");
     }
     else
     {
         Console.WriteLine("Manuscript validation failed. Submission aborted.");
     }
     return manuscript;
}</pre>			<p>Here’s how <a id="_idIndexMarker572"/>we might execute this flow without using the <code>Pipe</code> method:</p>
			<pre class="source-code">
public void ExecutePublishingFlow(Manuscript manuscript)
{
     manuscript = Submit(
         Transform(
             Validate(
                 Query(
                     manuscript))));
}</pre>			<p>Now, using the <code>Pipe</code> method, our code becomes 10 times better:</p>
			<pre class="source-code">
public void ExecutePublishingFlow(Manuscript manuscript)
{
     manuscript
         .Pipe(Query)
         .Pipe(Validate)
         .Pipe(Transform)
         .Pipe(Submit);
}</pre>			<p>Of course, it adds <a id="_idIndexMarker573"/>a bit of overhead, and the program might work noticeably more slowly, but it’s so much easier and faster to read!</p>
			<h1 id="_idParaDest-335"><a id="_idTextAnchor433"/>Performance considerations</h1>
			<p>Talking about the overhead, while functional programming techniques such as composition <a id="_idIndexMarker574"/>and pipelines offer improved readability and maintainability, it’s important to understand their performance implications. When we compose functions, the compiler generates a series of nested method calls. This can lead to multiple stack frame allocations, impacting performance for deeply nested compositions.</p>
			<p>To better understand the difference, let’s benchmark different approaches:</p>
			<pre class="source-code">
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
[MemoryDiagnoser]
public class FunctionalPerformance
{
    private IEnumerable&lt;int&gt; _numbers;
    [GlobalSetup]
    public void Setup()
    {
         _numbers = Enumerable.Range(0, 1_000_000_000);
    }
    [Benchmark]
    public List&lt;int&gt; ImperativeApproach()
    {
         var result = new List&lt;int&gt;();
         foreach (var num in _numbers)
         {
              if ((num * 3) % 4 == 0)
                   result.Add(num * 3);
         }
         return result;
    }
    [Benchmark]
    public List&lt;int&gt; FunctionalApproach()
    {
         return _numbers
              .Select(x =&gt; x * 3)
              .Where(x =&gt; x % 4 == 0)
              .ToList();
    }
    [Benchmark]
    public List&lt;int&gt; FunctionalWithPipeline()
    {
         Func&lt;int, int&gt; triple = x =&gt; x * 3;
         Func&lt;int, bool&gt; isMultipleOfFour = x =&gt; x % 4 == 0;
         return _numbers
              .Pipe(list =&gt; list.Select(triple))
              .Pipe(list =&gt; list.Where(isMultipleOfFour))
              .ToList();
    }
}</pre>			<p>Running these <a id="_idIndexMarker575"/>benchmarks might yield results similar to the following:</p>
			<div><div><img src="img/B21069_10_001.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>As we can see, the imperative approach is almost twice as fast as the functional approach. However, the performance of a usual LINQ pipeline and our own is almost identical! While the imperative approach shows better performance, it’s important to note that functional approaches often provide benefits in code readability, maintainability, and composability.</p>
			<h1 id="_idParaDest-336"><a id="_idTextAnchor434"/>The fluent interface</h1>
			<p>The fluent interface <a id="_idIndexMarker576"/>is the API pattern that allows us to chain method calls in a readable and intuitive manner. This term became widely known in 2005, but some people still think of it as just method chaining. However, the main idea is to make <a id="_idIndexMarker577"/>the code look like a <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>). Let’s rework our previous example by introducing a fluent interface technique.</p>
			<p>First, let’s define a class to encapsulate the pipeline steps for processing a manuscript:</p>
			<pre class="source-code">
public class ManuscriptProcessor
{
     private Manuscript _manuscript;
     public ManuscriptProcessor(Manuscript manuscript)
     {
         _manuscript = manuscript;
     }
     public ManuscriptProcessor Query(Func&lt;Manuscript, Manuscript&gt; queryFunc)
     {
         // Simulate querying the manuscript from a database
         manuscript.Content = "Original manuscript content.";
         return this;
     }
     public ManuscriptProcessor Validate(Func&lt;Manuscript, Manuscript&gt; validateFunc)
     {
         _manuscript = validateFunc(_manuscript);
         return this;
     }
     public ManuscriptProcessor Transform(Func&lt;Manuscript, Manuscript&gt; transformFunc)
     {
         _manuscript = transformFunc(_manuscript);
         return this;
     }
     public Manuscript Submit()
     {
         // Simulate submitting the manuscript for publication
         if (manuscript.IsValid)
         {
            Console.WriteLine($"Manuscript submitted: {manuscript.FormattedContent}");
         }
         else
         {
            Console.WriteLine("Manuscript validation failed. Submission aborted.");
         }
         return _manuscript;
     }
}</pre>			<p>Using the <a id="_idIndexMarker578"/>fluent interface, we can rewrite the pipeline more expressively:</p>
			<pre class="source-code">
var manuscript = new Manuscript();
var processedManuscript = new ManuscriptProcessor(manuscript)
     .Query()
     .Validate(Validate)
     .Transform(Transform)
     .Submit();</pre>			<p>As you can see, it looks almost identical to the example with the <code>Pipe</code> method, but the <code>Query</code> and <code>Submit</code> methods differ. It is because they do not depend on external validation or transformation rules that might change the logic but are rather straightforward. It’s a good idea to use a fluent interface when there is enough logic that will probably not change in the future. But if there isn’t any, we can use the <code>Pipe</code> method.</p>
			<h1 id="_idParaDest-337"><a id="_idTextAnchor435"/>Advanced composition with monads</h1>
			<p>Steve <a id="_idIndexMarker579"/>scratched <a id="_idIndexMarker580"/>his head, looking a bit confused.</p>
			<p>Steve: <em class="italic">Julia, I thought we were done with monads. Why are we </em><em class="italic">revisiting them?</em></p>
			<p>Julia: <em class="italic">Good observation, Steve. We’re circling back to monads because they’re incredibly powerful for composing complex operations, especially when dealing with error handling and asynchronous processes. Let me show you how they fit into </em><em class="italic">our pipelines...</em></p>
			<p>Monads provide a mechanism for chaining operations as well. In previous chapters, you learned about the basic concept of monads and the <code>Bind</code> method. We will use the <code>Bind</code> method to chain operations in more complex contexts, such as error handling and asynchronous processing.</p>
			<p>In our <a id="_idIndexMarker581"/>first scenario, we need to fetch and process <a id="_idIndexMarker582"/>user data from an external API. Each step in the process might fail, and we need to handle these errors gracefully.</p>
			<p>First, let’s recall our <code>Result</code> monad definition:</p>
			<pre class="source-code">
public class Result&lt;TValue, TError&gt;
{
    private TValue _value;
    private TError _error;
    public bool IsSuccess { get; private set; }
    private Result(TValue value, TError error, bool isSuccess)
    {
         _value = value;
         _error = error;
         IsSuccess = isSuccess;
    }
    public TValue Value
    {
         get
         {
              if (!IsSuccess) throw new InvalidOperationException("Cannot fetch Value from a failed result.");
              return _value;
         }
    }
    public TError Error
    {
         get
         {
              if (IsSuccess) throw new InvalidOperationException("Cannot fetch Error from a successful result.");
              return _error;
         }
    }
    public static Result&lt;TValue, TError&gt; Success(TValue value) =&gt; new Result&lt;TValue, TError&gt;(value, default, true);
    public static Result&lt;TValue, TError&gt; Failure(TError error) =&gt; new Result&lt;TValue, TError&gt;(default, error, false);
    public Result&lt;TResult, TError&gt; Bind&lt;TResult&gt;(Func&lt;TValue, Result&lt;TResult, TError&gt;&gt; func)
    {
         return IsSuccess ? func(_value!) : Result&lt;TResult, TError&gt;.Failure(_error!);
    }
}</pre>			<p>Next, rewrite <a id="_idIndexMarker583"/>our previous <a id="_idIndexMarker584"/>example to use the <code>Result</code> type:</p>
			<pre class="source-code">
public class Manuscript
{
     public string Content { get; set; }
     public bool IsValid { get; set; }
     public string FormattedContent { get; set; }
}
Func&lt;int, Result&lt;Manuscript, string&gt;&gt; queryManuscript = manuscriptId =&gt;
{
     // Simulate querying the manuscript from a database
     if (manuscriptId &gt; 0)
     {
         var manuscript = new Manuscript { Content = "Original manuscript content." };
         return Result&lt;Manuscript, string&gt;.Success(manuscript);
     }
     else
     {
         return Result&lt;Manuscript, string&gt;.Failure("Invalid manuscript ID");
     }
};
Func&lt;Manuscript, Result&lt;Manuscript, string&gt;&gt; validateManuscript = manuscript =&gt;
{
     // Simulate validating the manuscript
     if (!string.IsNullOrWhiteSpace(manuscript.Content))
     {
         manuscript.IsValid = true;
         return Result&lt;Manuscript, string&gt;.Success(manuscript);
     }
     else
     {
         return Result&lt;Manuscript, string&gt;.Failure("Empty manuscript content");
     }
};
Func&lt;Manuscript, Result&lt;Manuscript, string&gt;&gt; transformManuscript = manuscript =&gt;
{
     // Simulate transforming the manuscript content
     if (manuscript.IsValid)
     {
         manuscript.FormattedContent = manuscript.Content.ToUpper();
         return Result&lt;Manuscript, string&gt;.Success(manuscript);
     }
     else
     {
         return Result&lt;Manuscript, string&gt;.Failure("Invalid manuscript for transformation");
     }
};
Func&lt;Manuscript, Result&lt;bool, string&gt;&gt; submitManuscript = manuscript =&gt;
{
     // Simulate submitting the manuscript for publication
     if (manuscript.IsValid)
     {
         Console.WriteLine($"Manuscript submitted: {manuscript.FormattedContent}");
         return Result&lt;bool, string&gt;.Success(true);
     }
     else
     {
         return Result&lt;bool, string&gt;.Failure("Manuscript validation failed. Submission aborted.");
     }
};</pre>			<p>We can <a id="_idIndexMarker585"/>now compose these functions using <code>Bind</code> to create <a id="_idIndexMarker586"/>a monadic pipeline:</p>
			<pre class="source-code">
Func&lt;int, Result&lt;bool, string&gt;&gt; processManuscript = manuscriptId =&gt;
     queryManuscript(manuscriptId)
     .Bind(validateManuscript)
     .Bind(transformManuscript)
     .Bind(submitManuscript);</pre>			<p>Let’s use the pipeline to process user data:</p>
			<pre class="source-code">
var result = processManuscript(129);
if (result.IsSuccess)
{
     Console.WriteLine("Manuscript processed and submitted successfully.");
}
else
{
     Console.WriteLine($"Error: {result.Error}");
}</pre>			<p>The expected console output is as follows:</p>
			<pre class="source-code">
Manuscript submitted: ORIGINAL MANUSCRIPT CONTENT.
Manuscript processed and submitted successfully.</pre>			<p>Again, the <code>processManuscript</code> method looks quite similar to the previous ones; however, this time, it includes graceful error handling.</p>
			<p>Let’s now <a id="_idIndexMarker587"/>see how we can combine currying, partial <a id="_idIndexMarker588"/>application, and monadic operations to create a robust error-handling pipeline:</p>
			<pre class="source-code">
// Curried function for Result monad
Func&lt;Func&lt;T, Result&lt;U&gt;&gt;, Func&lt;Result&lt;T&gt;, Result&lt;U&gt;&gt;&gt; curriedBind&lt;T, U&gt;() =&gt;
     f =&gt; result =&gt; result.Bind(f);
// Partially applied functions for specific operations
var parseInput = curriedBind&lt;string, int&gt;()
     (s =&gt; int.TryParse(s, out int n) ? Result&lt;int&gt;.Success(n) : Result&lt;int&gt;.Failure("Parse failed"));
var validatePositive = curriedBind&lt;int, int&gt;()
     (n =&gt; n &gt; 0 ? Result&lt;int&gt;.Success(n) : Result&lt;int&gt;.Failure("Number must be positive"));
var double = curriedBind&lt;int, int&gt;()
     (n =&gt; Result&lt;int&gt;.Success(n * 2));
// Composing a pipeline with monadic operations
Func&lt;string, Result&lt;int&gt;&gt; processInput =
     input =&gt; Result&lt;string&gt;.Success(input)
         .Pipe(parseInput)
         .Pipe(validatePositive)
         .Pipe(double);
var result = processInput("5");  // Success: 10
var error = processInput("-3");  // Failure: "Number must be positive"</pre>			<p>This example demonstrates the power of combining currying, partial application, and monadic composition. We’ve created a pipeline that parses input, validates it, and performs <a id="_idIndexMarker589"/>a transformation, all while handling potential errors in each step. The use of curried and partially applied functions makes our pipeline <a id="_idIndexMarker590"/>both flexible and easy to extend.</p>
			<p>As they wrapped up their discussion, Steve looked both tired and accomplished.</p>
			<p>Steve: <em class="italic">Wow, Julia. This has been quite a journey. I never thought I’d understand these concepts when </em><em class="italic">we started</em>.</p>
			<p>Julia: <em class="italic">You’ve come a long way, Steve. How do you feel about functional </em><em class="italic">programming now</em>?</p>
			<p>Steve: <em class="italic">I’m excited to start applying these concepts in our projects. It’s amazing how much clearer and more structured our code </em><em class="italic">can be</em>.</p>
			<p>Julia smiled, proud of Steve’s progress.</p>
			<p>Julia: <em class="italic">That’s great to hear, Steve. Remember, practice makes perfect. Keep experimenting and don’t be afraid to ask questions. Ready for some exercises to cement what </em><em class="italic">we’ve learned?</em></p>
			<p>Steve: <em class="italic">Absolutely! Bring </em><em class="italic">them on!</em></p>
			<h1 id="_idParaDest-338"><a id="_idTextAnchor436"/>Exercises</h1>
			<h2 id="_idParaDest-339"><a id="_idTextAnchor437"/>Exercise 1</h2>
			<p>Compose a series of functions into a pipeline that processes a list of enemy waves, applying increased difficulty (hard mode), validating the result, and transforming it into a formatted string using the following code:</p>
			<pre class="source-code">
public class EnemyWave
{
   public int WaveNumber { get; set; }
   public int EnemyCount { get; set; }
   public string Description { get; set; }
}
Func&lt;EnemyWave, bool&gt; validateWave = wave =&gt; wave.EnemyCount &gt; 0;
Func&lt;EnemyWave, EnemyWave&gt; applyHardMode = wave =&gt;
{
   wave.EnemyCount = (int)(wave.EnemyCount * 1.2); // +20% enemies
   return wave;
};
Func&lt;EnemyWave, string&gt; formatWave = wave =&gt; $"Wave {wave.WaveNumber}: {wave.Description} - {wave.EnemyCount} enemies";</pre>			<h2 id="_idParaDest-340"><a id="_idTextAnchor438"/>Exercise 2</h2>
			<p>Using the following code, compose a series of monadic functions into a pipeline that processes a game data file, reads its content, processes it, and writes the result to another file:</p>
			<pre class="source-code">
Func&lt;string, Result&lt;string&gt;&gt; readGameDataFile = path =&gt;
{
   try
   {
       var content = File.ReadAllText(path);
       return Result&lt;string&gt;.Success(content);
   }
   catch (Exception ex)
   {
       return Result&lt;string&gt;.Failure($"Failed to read file: {ex.Message}");
   }
};
Func&lt;string, Result&lt;string&gt;&gt; processGameData = content =&gt;
{
   // Simulate game data processing
   return Result&lt;string&gt;.Success(content.ToUpper());
};
Func&lt;string, Result&lt;bool&gt;&gt; writeGameDataFile = content =&gt;
{
   try
   {
       File.WriteAllText("processed_game_data.txt", content);
       return Result&lt;bool&gt;.Success(true);
   }
   catch (Exception ex)
   {
       return Result&lt;bool&gt;.Failure($"Failed to write file: {ex.Message}");
   }
};</pre>			<h2 id="_idParaDest-341"><a id="_idTextAnchor439"/>Exercise 3</h2>
			<p>Use currying to build a function for dynamic query generation for tower defense game data and partially applied functions for querying enemy types and levels. Use the following function to generate query scripts:</p>
			<pre class="source-code">
Func&lt;string, string, string, string&gt; generateSqlQuery = (table, column, value) =&gt;
     $"SELECT * FROM {table} WHERE {column} = '{value}'";</pre>			<h1 id="_idParaDest-342"><a id="_idTextAnchor440"/>Solutions</h1>
			<p>Here are the solutions to the exercises provided in the previous section. Use them to ensure your understanding and to correct any mistakes you might have made.</p>
			<h2 id="_idParaDest-343"><a id="_idTextAnchor441"/>Solution 1</h2>
			<p>First, we compose these functions to create a transaction processing pipeline:</p>
			<pre class="source-code">
Func&lt;IEnumerable&lt;EnemyWave&gt;, IEnumerable&lt;string&gt;&gt; processEnemyWaves = waves =&gt;
     waves
         .Where(validateWave)
         .Select(applyHardMode)
         .Select(formatWave);</pre>			<p>Then, we test it:</p>
			<pre class="source-code">
var enemyWaves = new List&lt;EnemyWave&gt;
{
     new EnemyWave { WaveNumber = 1, EnemyCount = 50, Description = "Initial wave" },
     new EnemyWave { WaveNumber = 2, EnemyCount = 0, Description = "Empty wave" },
     new EnemyWave { WaveNumber = 3, EnemyCount = 100, Description = "Boss wave" }
};
var results = processEnemyWaves(enemyWaves);
foreach (var result in results)
{
     Console.WriteLine(result);
}</pre>			<p>Here’s the expected result:</p>
			<pre class="source-code">
Wave 1: Initial wave - 60 enemies
Wave 3: Boss wave - 120 enemies</pre>			<h2 id="_idParaDest-344"><a id="_idTextAnchor442"/>Solution 2</h2>
			<p>We start by creating the monadic pipeline using the given functions:</p>
			<pre class="source-code">
Func&lt;string, Result&lt;bool&gt;&gt; processGameDataFile = path =&gt;
     readGameDataFile(path)
         .Bind(processGameData)
         .Bind(writeGameDataFile);</pre>			<p>Let’s test the pipeline:</p>
			<pre class="source-code">
var result = processGameDataFile("game.dat");
if (result.IsSuccess)
{
     Console.WriteLine("The data file was processed successfully.");
}
else
{
     Console.WriteLine($"Error: {result.Error}");
}</pre>			<p>Here’s the expected result:</p>
			<pre class="source-code">
The data file was processed successfully.</pre>			<h2 id="_idParaDest-345"><a id="_idTextAnchor443"/>Solution 3</h2>
			<p>In this solution, we create a curried version of the function first:</p>
			<pre class="source-code">
Func&lt;string, Func&lt;string, Func&lt;string, string&gt;&gt;&gt; curryGenerateSqlQuery = table =&gt; column =&gt; value =&gt; generateSqlQuery(table, column, value);</pre>			<p>Then, we use it to generate queries:</p>
			<pre class="source-code">
Func&lt;string, string&gt; typeQuery = value =&gt; generateQuery("Enemies", "Type", value);
Func&lt;string, string&gt; levelQuery = value =&gt; generateQuery("Enemies", "Level", value);</pre>			<p>We write the code to use them:</p>
			<pre class="source-code">
Console.WriteLine(typeQuery("Goblin"));
Console.WriteLine(levelQuery("5"));</pre>			<p>Here’s the expected result:</p>
			<pre class="source-code">
SELECT * FROM Enemies WHERE Type = 'Goblin'
SELECT * FROM Enemies WHERE Level = '5'</pre>			<p>After finishing these exercises, you should have a better understanding of how to use pipelines, currying, and partial applications in your code.</p>
			<h1 id="_idParaDest-346"><a id="_idTextAnchor444"/>Summary</h1>
			<p>In this chapter, we integrated knowledge from previous chapters to revisit pipelines and composition. We started with function composition, showing how to combine simple functions into complex operations using higher-order functions for mapping and filtering collections.</p>
			<p>We then introduced the <code>Pipe</code> method, which simplifies a pipeline’s function chaining. When applied to our book publishing system example, it enabled clear processing steps for querying, validating, transforming, and submitting a manuscript.</p>
			<p>Then, we examined the fluent interface pattern, which allows quite intuitive method chaining. The <code>ManuscriptProcessor</code> class demonstrated how a fluent interface can make our code more expressive and user-friendly. We also covered advanced composition with monads using the <code>Result</code> type for graceful error handling in monadic pipelines.</p>
			<p>The next chapter will be the last of our journey, and I truly hope you enjoy the process. So, finish the exercises if you haven’t yet done so, and see you in the next chapter!</p>
		</div>
	

		<div><h1 id="_idParaDest-347" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor445"/>Part 4:Conclusion and Future Directions</h1>
			<p>In the final part, we reflect on the journey we’ve taken through functional programming in C#. We’ll summarize the key concepts learned, reinforcing your understanding of how these techniques can be applied to write cleaner, more maintainable code. We’ll also look ahead to what’s next in your functional programming journey, providing guidance on how to further advance your skills and stay up-to-date with evolving best practices in the field.</p>
			<p>This part has the following chapter:</p>
			<ul>
				<li><a href="B21069_11.xhtml#_idTextAnchor446"><em class="italic">Chapter 11</em></a><em class="italic">, Reflecting and Looking Ahead</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>