- en: 16 Mediator and CQRS Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16 中介者和CQRS设计模式
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始之前：加入我们的Discord书籍社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的Discord服务器上与其他早期读者聊天（在“EARLY ACCESS SUBSCRIPTION”下找到“architecting-aspnet-core-apps-3e”频道）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file98.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![二维码描述自动生成](img/file98.png)'
- en: 'This chapter covers the building blocks of the next chapter, which is about
    **Vertical Slice Architecture**. We begin with a quick overview of Vertical Slice
    Architecture to give you an idea of the end goal. Then, we explore the **Mediator**
    design pattern, which plays the role of the middleman between the components of
    our application. That leads us to the **Command Query Responsibility Segregation**
    (**CQRS**) pattern, which describes how to divide our logic into commands and
    queries. Finally, we consolidate our learning by exploring MediatR, an open-source
    implementation of the Mediator design pattern, and send queries and commands through
    it to demonstrate how the concepts we have studied so far come to life in real-world
    application development.In this chapter, we cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了下一章的构建块，下一章将介绍**垂直切片架构**。我们首先快速概述垂直切片架构，以便您对最终目标有一个概念。然后，我们探讨**中介者**设计模式，它在我们的应用程序组件之间扮演中间人的角色。这引出了**命令查询责任分离**（**CQRS**）模式，该模式描述了如何将我们的逻辑分为命令和查询。最后，我们通过探索MediatR（中介者设计模式的开源实现）并通过它发送查询和命令来巩固我们的学习，以展示我们迄今为止所学的概念如何在现实世界的应用程序开发中得以实现。在本章中，我们将涵盖以下主题：
- en: A high-level overview of Vertical Slice Architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直切片架构的高级概述
- en: Implementing the Mediator pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现中介者模式
- en: Implementing the CQS pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现CQS模式
- en: Code smell – Marker Interfaces
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码异味 - 标记接口
- en: Using MediatR as a mediator
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MediatR作为中介者
- en: Let’s begin with the end goal.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最终目标开始。
- en: A high-level overview of Vertical Slice Architecture
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垂直切片架构的高级概述
- en: 'Before starting, let’s look at the end goal of this chapter and the next. This
    way, it should be easier to follow the progress toward that goal throughout the
    chapter.As we covered in *Chapter 14*, *Layering and Clean Architecture*, a layer
    groups classes together based on shared responsibilities. So, classes containing
    data access code are part of the data access layer (or infrastructure). People
    represent layers using horizontal slices in diagrams like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们看看本章和下一章的最终目标。这样，您应该能够更容易地跟随整个章节中向该目标迈进的过程。正如我们在*第14章*，“分层和清洁架构”中提到的，一个层根据共享责任将类分组在一起。因此，包含数据访问代码的类是数据访问层（或基础设施）的一部分。人们使用像这样的水平切片在图中表示层：
- en: '![Figure 16.1: Diagram representing layers as horizontal slices](img/file99.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图16.1：表示层为水平切片的图](img/file99.png)'
- en: 'Figure 16.1: Diagram representing layers as horizontal slices'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1：表示层为水平切片的图
- en: 'The “vertical slice” in “Vertical Slice Architecture” comes from that; a vertical
    slice represents the part of each layer that creates a specific feature. So, instead
    of dividing the application into layers, we divide it into features. A feature
    manages its data access code, domain logic, and possibly even presentation code.
    The key is to loosely couple the features from one another and keep each feature’s
    components close together. In a layered application, when we add, update, or remove
    a feature, we must change one or more layers, which too often translates to “all
    layers.”On the other hand, with vertical slices, we keep features isolated, allowing
    us to design them independently. From a layering perspective, this is like flipping
    your way of thinking about software to a 90° angle:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: “垂直切片架构”中的“垂直切片”来自这里；一个垂直切片代表每个层创建特定功能的部分。因此，我们不是将应用程序划分为层，而是将其划分为功能。一个功能管理其数据访问代码、领域逻辑，甚至可能是表示代码。关键是松散地将功能彼此耦合，并保持每个功能的组件紧密在一起。在一个分层应用程序中，当我们添加、更新或删除一个功能时，我们必须更改一个或多个层，这往往意味着“所有层”。另一方面，使用垂直切片，我们保持功能隔离，允许我们独立设计它们。从分层的角度来看，这就像将您对软件的思考方式翻转90°：
- en: '![Figure 16.2: Diagram representing a vertical slice crossing all layers](img/file100.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图16.2：表示垂直切片穿越所有层的图](img/file100.png)'
- en: 'Figure 16.2: Diagram representing a vertical slice crossing all layers'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2：表示穿越所有层的垂直切片图
- en: Vertical Slice Architecture does not dictate the use of **CQRS**, the **Mediator**
    pattern, or **MediatR**, but these tools and patterns flow very well together,
    as we see in the next chapter. Nonetheless, these are just tools and patterns
    that you can use or change in your implementation using different techniques;
    it does not matter and does not change the concept.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直切片架构不强制使用**CQRS**、**中介模式**或**MediatR**，但这些工具和模式结合得非常好，正如我们在下一章中看到的。尽管如此，这些只是你可以使用或更改实现的不同技术中的工具和模式；这并不重要，也不会改变概念。
- en: We explore additional ways of building feature-oriented applications in *Chapter
    18*, *Request-EndPoint-Response (REPR)*, and *Chapter 20*, *Modular Monolith*.
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将在第18章、*请求-端点-响应（REPR）*和第20章、*模块化单体*中探讨构建面向功能应用程序的额外方法。
- en: The goal is to encapsulate features together, use CQRS to divide the application
    into requests (commands and queries), and use MediatR as the mediator of that
    CQRS pipeline, decoupling the pieces from one another.You now know the plan. We
    explore Vertical Slice Architecture later. Meanwhile, let’s begin with the Mediator
    design pattern.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是将功能封装在一起，使用CQRS将应用程序划分为请求（命令和查询），并使用MediatR作为该CQRS管道的中介，使各个部分相互解耦。你现在知道了计划。我们将在后面探索垂直切片架构。同时，让我们从中介设计模式开始。
- en: Implementing the Mediator pattern
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现中介模式
- en: The **Mediator** pattern is another GoF design pattern that controls how objects
    interact with one another (making it a behavioral pattern).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**中介模式**是另一个GoF设计模式，它控制对象之间如何交互（使其成为行为模式）。'
- en: Goal
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: The mediator’s role is to manage the communication between objects (colleagues).
    Those colleagues should not communicate together directly but use the mediator
    instead. The mediator helps break tight coupling between these colleagues.**A
    mediator is a middleman who relays messages between colleagues**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 中介的角色是管理对象（同事）之间的通信。那些同事不应该直接相互通信，而应该使用中介。中介有助于打破这些同事之间的紧密耦合。**中介是同事之间传递消息的中间人**。
- en: Design
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: 'Let’s start with some UML diagrams. From a very high level, the Mediator pattern
    is composed of a mediator and colleagues:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些UML图开始。从非常高的层面来看，中介模式由一个中介和同事组成：
- en: '![Figure 16.3: Class diagram representing the Mediator pattern](img/file101.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图16.3：表示中介模式的类图](img/file101.png)'
- en: 'Figure 16.3: Class diagram representing the Mediator pattern'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3：表示中介模式的类图
- en: 'When an object in the system wants to send a message to one or more colleagues,
    it uses the mediator. Here is an example of how it works:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统中的某个对象想要向一个或多个同事发送消息时，它使用中介。以下是如何工作的一个示例：
- en: '![Figure 16.4: Sequence diagram of a mediator relaying messages to colleagues](img/file102.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图16.4：中介向同事传递消息的序列图](img/file102.png)'
- en: 'Figure 16.4: Sequence diagram of a mediator relaying messages to colleagues'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4：中介向同事传递消息的序列图
- en: 'That is also valid for colleagues; a colleague must also use the mediator if
    they need to talk to each other, as depicted in the following class diagram:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 同事也是如此；如果同事之间需要交流，也必须使用中介，如下面的类图所示：
- en: '![Figure 16.5: Class diagram representing the Mediator pattern including colleagues’
    collaboration](img/file103.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图16.5：表示中介模式包括同事协作的类图](img/file103.png)'
- en: 'Figure 16.5: Class diagram representing the Mediator pattern including colleagues’
    collaboration'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5：表示中介模式包括同事协作的类图
- en: 'In this diagram, `ConcreteColleague1` is a colleague but also the consumer
    of the mediator. For example, that colleague could send a message to another colleague
    using the mediator, like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，`ConcreteColleague1` 是一个同事，同时也是中介的消费者。例如，那个同事可以使用中介向另一个同事发送消息，如下所示：
- en: '![Figure 16.6: Sequence diagram representing colleague1 communicating with
    colleague2 through the mediator](img/file104.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图16.6：表示colleague1通过中介与colleague2通信的序列图](img/file104.png)'
- en: 'Figure 16.6: Sequence diagram representing colleague1 communicating with colleague2
    through the mediator'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6：表示colleague1通过中介与colleague2通信的序列图
- en: 'From a mediator standpoint, its implementation most likely contains a collection
    of colleagues to communicate with, like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从中介的角度来看，其实现很可能包含一个用于通信的同事集合，如下所示：
- en: '![Figure 16.7: Class diagram representing a simple hypothetical concrete mediator
    implementation](img/file105.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图16.7：表示简单假设的具体中介实现类的类图](img/file105.png)'
- en: 'Figure 16.7: Class diagram representing a simple hypothetical concrete mediator
    implementation'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7：表示简单假设的具体中介实现类的类图
- en: Now that we have explored some UML diagrams, let’s look at some code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了几个UML图，让我们看看一些代码。
- en: Project – Mediator (IMediator)
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 中介（IMediator）
- en: 'The Mediator project consists of a simplified chat system using the Mediator
    pattern. Let’s start with the interfaces:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Mediator项目由一个使用Mediator模式的简化聊天系统组成。让我们从接口开始：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The system is composed of the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 系统由以下部分组成：
- en: The `IMediator` interface represents a mediator that can send messages to colleagues.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMediator`接口代表一个可以向同事发送消息的中介。'
- en: The `IColleague` interface represents a colleague that can receive messages.
    It also has a `Name` property so we can output meaningful values.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IColleague`接口代表一个可以接收消息的同事。它还有一个`Name`属性，这样我们就可以输出有意义的值。'
- en: The `Message` class represents a message sent by an `IColleague` implementation.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message`类代表由`IColleague`实现发送的消息。'
- en: 'Next, we implement the `IMediator` interface in the `ConcreteMediator` class,
    which broadcasts the messages to all `IColleague` instances:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`ConcreteMediator`类中实现`IMediator`接口，将消息广播到所有`IColleague`实例：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That mediator is simple; it forwards all the messages it receives to every
    colleague it knows. The last part of the pattern is the `ConcreteColleague` class
    which lets an instance of the `IMessageWriter<TMessage>` interface output the
    messages (we explore that interface next):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个中介很简单；它将接收到的所有消息转发给它所知道的每个同事。模式的最后一部分是`ConcreteColleague`类，它允许`IMessageWriter<TMessage>`接口的实例输出消息（我们将在下一节探讨该接口）：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That class could hardly be simpler: it takes a name and an `IMessageWriter<TMessage>`
    implementation when created, then it stores a reference for future use.The `IMessageWriter<TMessage>`
    interface serves as a presenter and controls how the messages are displayed. The
    `IMessageWriter<TMessage>` interface is unrelated to the Mediator pattern. Nevertheless,
    it is a way to manage how a `ConcreteColleague` object outputs the messages without
    coupling it with a specific target. Here is the code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类几乎无法再简单了：在创建时，它接受一个名称和一个`IMessageWriter<TMessage>`实现，然后存储一个引用以供将来使用。《IMessageWriter<TMessage>`接口充当一个展示者，并控制消息的显示方式。《IMessageWriter<TMessage>`接口与中介模式无关。尽管如此，它是一种管理`ConcreteColleague`对象如何输出消息而不与特定目标耦合的方法。以下是代码：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The consumer of the system is an integration test defined in the `MediatorTest`
    class. The test uses the chat system and asserts the output using a custom implementation
    of the `IMessageWriter` interface. Let’s start by analyzing the test:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的消费者是一个在`MediatorTest`类中定义的集成测试。该测试使用聊天系统，并使用`IMessageWriter`接口的自定义实现来断言输出。让我们首先分析这个测试：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The test starts by defining three colleagues with their own `TestMessageWriter`
    implementation (names were randomly generated).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 测试首先定义了三个同事及其自己的`TestMessageWriter`实现（名称是随机生成的）。
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the second part of the preceding `Arrange` block, we create the subject
    under test (`mediator`) and register the three colleagues. At the end of that
    `Arrange` block, we also define the expected output of our test. It is important
    to note that we control the output from the `TestMessageWriter` implementation
    (defined at the end of the `MediatorTest` class). Next is the `Act` block:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个`Arrange`块的第二部分，我们创建了待测试的主题（中介）并注册了三位同事。在那个`Arrange`块结束时，我们还定义了测试的预期输出。需要注意的是，我们控制来自`TestMessageWriter`实现（在`MediatorTest`类末尾定义）的输出。接下来是`Act`块：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding `Act` block, we send three messages through the `mediator`
    instance. Next is the `Assert` block:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`Act`块中，我们通过`mediator`实例发送了三条消息。接下来是`Assert`块：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the `Assert` block, we ensure that all colleagues receive the messages.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Assert`块中，我们确保所有同事都收到了消息。
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `CreateConcreteColleague` method is a helper method that encapsulates the
    creation of the colleagues, enabling us to write the one-liner declaration used
    in the `Arrange` section of the test. Next, we look at the `IMessageWriter` implementation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateConcreteColleague`方法是一个辅助方法，它封装了同事的创建，使我们能够编写测试`Arrange`部分中的一行声明。接下来，我们看看`IMessageWriter`实现：'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, the `TestMessageWriter` class writes the messages into `StringBuilder`,
    making it easy to assert the output. If we were to build a GUI for that, we could
    write an implementation of `IMessageWriter<Message>` that writes to that GUI;
    in the case of a web UI, it could use **SignalR** or write to the response stream
    directly, for example.To summarize the sample:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`TestMessageWriter`类将消息写入`StringBuilder`，这使得断言输出变得容易。如果我们为它构建一个GUI，我们可以编写一个`IMessageWriter<Message>`的实现，将其写入该GUI；在Web
    UI的情况下，它可以使用**SignalR**或直接写入响应流，例如。总结这个示例：
- en: The consumer (the unit test) sends messages to colleagues through the mediator.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消费者（单元测试）通过中介向同事发送消息。
- en: The `TestMessageWriter` class writes those messages to a `StringBuilder` instance.
    Each colleague has its own instance of the `TestMessageWriter` class.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TestMessageWriter`类将这些消息写入一个`StringBuilder`实例。每个同事都有自己的`TestMessageWriter`类实例。'
- en: The code asserts that all colleagues received the expected messages.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码断言所有同事都收到了预期的消息。
- en: This example illustrates that the Mediator pattern allows us to break the direct
    coupling between colleagues. The messages reached colleagues without them knowing
    about each other.Colleagues should communicate through the mediator, so the Mediator
    pattern would not be complete without that. Let’s implement a more advanced chatroom
    to tackle this concept.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了中介模式允许我们打破同事之间的直接耦合。消息到达同事，而他们并不知道彼此。同事应该通过中介进行沟通，因此没有中介，中介模式就不完整。让我们实现一个更高级的聊天室来处理这个概念。
- en: Project – Mediator (IChatRoom)
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 中介（IChatRoom）
- en: 'In the previous code sample, we named the classes after the Mediator pattern
    actors, as shown in *Figure 14.7*. While this example is very similar, it uses
    domain-specific names instead and implements a few more methods to manage the
    system showing a more tangible implementation. Let’s start with the abstractions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码示例中，我们根据中介模式演员命名了类，如图14.7所示。虽然这个例子非常相似，但它使用的是领域特定的名称，并实现了一些更多的方法来管理显示更具体实现系统的系统。让我们从抽象开始：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `IChatRoom` interface is the mediator, and it defines two methods instead
    of one:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`IChatRoom`接口是中介，它定义了两个方法而不是一个：'
- en: '`Join`, which allows `IParticipant` to join `IChatRoom`.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Join`，允许`IParticipant`加入`IChatRoom`。'
- en: '`Send`, which sends a message to the others.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Send`，用于向其他人发送消息。'
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `IParticipant` interface is the colleague and also has a few more methods:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`IParticipant`接口是同事，并且还有一些其他方法：'
- en: '`Send`, to send messages.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Send`，用于发送消息。'
- en: '`ReceiveMessage`, to receive messages from the other `IParticipant` objects.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReceiveMessage`，用于接收来自其他`IParticipant`对象的消息。'
- en: '`ChatRoomJoined`, to confirm that the `IParticipant` object has successfully
    joined a chatroom.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChatRoomJoined`，用于确认`IParticipant`对象已成功加入聊天室。'
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `ChatMessage` class is the same as the previous `Message` class, but it
    references `IParticipant` instead of `IColleague`.Let’s now look at the `IParticipant`
    implementation:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatMessage`类与之前的`Message`类相同，但它引用的是`IParticipant`而不是`IColleague`。现在让我们看看`IParticipant`实现：'
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `User` class represents our default `IParticipant`. A `User` instance can
    chat in only one `IChatRoom`. THe program can set the chat room by calling the
    `ChatRoomJoined` method. When it receives a message, it delegates it to its `IMessageWriter<ChatMessage>`.
    Finally, a `User` instance can send a message through the mediator (`IChatRoom)`.
    The `Send` method throws a `ChatRoomNotJoinedException` to enforce that the `User`
    instance must join a chat room before sending messages (code-wise: the `_chatRoom`
    field must not be `null`).We could create a `Moderator`, `Administrator`, `SystemAlerts`,
    or any other `IParticipant` implementation as we see fit, but not in this sample.
    I am leaving that to you to experiment with the Mediator pattern.Now let’s look
    at the `ChatRoom` class (the mediator):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`类代表我们的默认`IParticipant`。一个`User`实例只能在`IChatRoom`中聊天。程序可以通过调用`ChatRoomJoined`方法来设置聊天室。当它收到消息时，它将其委托给它的`IMessageWriter<ChatMessage>`。最后，一个`User`实例可以通过中介（`IChatRoom`）发送消息。`Send`方法抛出`ChatRoomNotJoinedException`异常，以强制`User`实例在发送消息之前必须加入聊天室（代码上：`_chatRoom`字段不能为`null`）。我们可以根据需要创建`Moderator`、`Administrator`、`SystemAlerts`或任何其他`IParticipant`实现，但在这个示例中我们没有这样做。我将这个实验留给你。现在让我们看看`ChatRoom`类（中介）：'
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `ChatRoom` class is slimmer than the `User` class. It allows participants
    to join and sends chat messages to registered participants. When joining a `ChatRoom`,
    it keeps a reference on the `IParticipant`, tells that `IParticipant` that it
    has successfully joined then sends a `ChatMessage` to all participants announcing
    the newcomer.With those few pieces, we have a Mediator implementation. Before
    moving to the next section, let’s look at the `Consumer` instance of `IChatRoom`,
    which is another integration test. Let’s start with the skeleton of the class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatRoom` 类比 `User` 类更简洁。它允许参与者加入并发送聊天消息给已注册的参与者。当加入 `ChatRoom` 时，它保留对 `IParticipant`
    的引用，告诉 `IParticipant` 它已成功加入，然后向所有参与者发送 `ChatMessage` 宣布新来者。有了这些小块，我们就有了仲裁者的实现。在进入下一节之前，让我们看看
    `IChatRoom` 的 `Consumer` 实例，这是另一个集成测试。让我们从类的骨架开始：'
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, we have the following pieces:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有以下几部分：
- en: The test case is an empty placeholder that we are about to look into.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试用例是一个空占位符，我们即将对其进行查看。
- en: The `CreateTestUser` method helps simplify the `Arrange` section of the test
    case, similar to before.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateTestUser` 方法有助于简化测试用例的 `Arrange` 部分，与之前类似。'
- en: The `TestMessageWriter` implementation is similar to the previous example, accumulating
    messages in a `StringBuilder` instance.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestMessageWriter` 的实现与之前的例子类似，将消息累积在 `StringBuilder` 实例中。'
- en: 'As a reference, the `IMessageWriter` interface is the same as the previous
    project:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，`IMessageWriter` 接口与之前的工程相同：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let’s explore the test case, starting with the `Arrange` block, where
    we create four users with their respective `TestMessageWriter` instances (names
    were also randomly generated):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索测试用例，从 `Arrange` 块开始，我们在其中创建了四个用户及其各自的 `TestMessageWriter` 实例（名称也是随机生成的）：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, in the `Act` block, our test users join the `chatroom` instance and send
    messages:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `Act` 块中，我们的测试用户加入 `chatroom` 实例并发送消息：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then in the Assert block, Rutter did not join the chatroom, so we expect no
    message:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `Assert` 块中，鲁特没有加入聊天室，所以我们预计没有消息：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Since King is the first to join the channel, we expect him to receive all messages:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于金是第一个加入频道的，我们预计他会收到所有消息：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Kelley was the second user to join the chatroom, so the output contains almost
    all messages except the line saying `[King]: Has joined the channel`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '凯利是第二个加入聊天室的用户，所以输出包含了几乎所有消息，除了说 `[金]: 已加入频道` 的那一行：'
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Daveen joined after King and Kelley exchanged a few words, so we expect the
    conversation to be shorter:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 戴文在金和凯利交换了几句话后加入，所以我们预计对话会短一些：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To summarize the test case, we have four users. Three of them joined the same
    chatroom at a different time and chatted a little. The output is different for
    everyone since the time you join matters. All participants are loosely coupled,
    thanks to the Mediator pattern, allowing us to extend the system without impacting
    the existing pieces. Leveraging the Mediator pattern helps us create maintainable
    systems; many small pieces are easier to manage and test than a large component
    handling all the logic.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 总结测试用例，我们有四个用户。其中三个在不同时间加入了同一个聊天室并聊了一会儿。由于加入的时间不同，每个人的输出都不同。所有参与者都松散耦合，多亏了中介者模式，这使得我们可以在不影响现有部分的情况下扩展系统。利用中介者模式帮助我们创建可维护的系统；许多小块比处理所有逻辑的大型组件更容易管理和测试。
- en: Conclusion
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'As we explored in the two preceding projects, a **mediator** allows us to decouple
    the components of our system. **The mediator is the middleman between colleagues**,
    and it served us well in the small chatroom samples where each colleague can talk
    to the others without knowing how and without knowing them.Now let’s see how the
    Mediator pattern can help us follow the **SOLID** principles:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前两个项目中探讨的那样，**仲裁者**使我们能够解耦系统的组件。**仲裁者是同事之间的中间人**，它在小型聊天室样本中表现良好，其中每个同事都可以与其他人交谈，而无需知道如何以及他们是谁。现在让我们看看中介者模式如何帮助我们遵循
    **SOLID** 原则：
- en: '**S**: The mediator extracts the communication responsibility from colleagues.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**: 仲裁者从同事那里提取了沟通责任。'
- en: '**O**: With a mediator relaying the messages, we can create new colleagues
    and change the existing colleagues’ behaviors without impacting the others. If
    we need a new colleague, we can register one with the mediator.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**: 通过仲裁者传递消息，我们可以创建新的同事并改变现有同事的行为，而不会影响其他人。如果我们需要一个新同事，我们可以通过仲裁者注册一个。'
- en: '**L**: N/A'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**: 无'
- en: '**I**: The Mediator pattern divides the system into multiple small interfaces
    (`IMediator` and `IColleague`).'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：中介者模式将系统划分为多个小的接口（`IMediator`和`IColleague`）。'
- en: '**D**: All actors of the Mediator pattern solely depend on other interfaces.
    We can implement a new mediator and reuse the existing colleagues’ implementations
    if we need new mediation behavior because of the dependency inversion.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：中介者模式的所有参与者仅依赖于其他接口。如果我们因为需要新的中介行为而需要实现新的中介，我们可以重用现有同事的实现，因为它们依赖于依赖反转。'
- en: Next, we explore CQRS, which allows us to separate commands and queries, leading
    to a more maintainable application. After all, all operations are queries or commands,
    no matter how we call them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨CQRS，它允许我们将命令和查询分离，从而使得应用程序更易于维护。毕竟，所有操作都是查询或命令，无论我们如何称呼它们。
- en: Implementing the CQS pattern
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现CQS模式
- en: '**Command-Query Separation (CQS)** is a subset of the **Command Query Responsibility
    Segregation (CQRS)** pattern.Here’s the high-level difference between the two:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令-查询分离（CQS）**是**命令查询责任分离（CQRS）**模式的一个子集。以下是两者之间的高层次差异：'
- en: With CQS, we divide operations into commands and queries.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CQS，我们将操作分为命令和查询。
- en: With CQRS, we apply the concept to the system level. We separate models for
    reading and for writing, potentially leading to a distributed system.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CQRS，我们将这个概念应用到系统级别。我们分离了读取和写入的模型，这可能导致一个分布式系统。
- en: In this chapter, we stick with CQS and tackle CQRS in *Chapter 18*, *Introduction
    to Microservices Architecture*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续使用CQS，并在第18章“微服务架构简介”中处理CQRS。
- en: Goal
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: 'The goal is to divide all operations (or requests) into two categories: commands
    and queries.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是将所有操作（或请求）分为两个类别：命令和查询。
- en: '**A command mutates the state of an application.** For example, creating, updating,
    and deleting an entity are commands. In theory, a command should not return a
    value. In practice, they often do, especially for optimization purposes.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令改变应用程序的状态。**例如，创建、更新和删除实体都是命令。理论上，命令不应该返回值。在实践中，它们经常这样做，尤其是为了优化目的。'
- en: '**A query reads the state of the application but never changes it.** For example,
    reading an order, reading your order history, and retrieving your user profile
    are queries.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询读取应用程序的状态，但永远不会改变它。**例如，读取订单、读取您的订单历史记录和检索您的用户资料都是查询。'
- en: Dividing operations into mutator requests (write/command) and accessor requests
    (read/query) creates a clear separation of concerns, leading us toward the SRP.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将操作分为突变请求（写入/命令）和访问请求（读取/查询）创建了一个清晰的关注点分离，引导我们走向SRP。
- en: Design
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: 'There is no definite design for this, but for us, the flow of a command should
    look like the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个模式，没有固定的设计，但对我们来说，命令的流程应该如下所示：
- en: '![Figure 16.8: Sequence diagram representing the abstract flow of a command](img/file106.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图16.8：表示命令抽象流程的序列图](img/file106.png)'
- en: 'Figure 16.8: Sequence diagram representing the abstract flow of a command'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8：表示命令抽象流程的序列图
- en: 'The consumer creates a command object and sends it to a command handler, applying
    the mutation to the application. I called it `Entities` in this case, but it could
    have sent a SQL `UPDATE` command to a database or a web API call over HTTP; the
    implementation details do not matter.The concept is the same for a query, but
    it returns a value instead. Very importantly, the query must not change the state
    of the application. A query should only read data, like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者创建一个命令对象并将其发送到命令处理器，对应用程序应用变更。在这种情况下，我将其称为`Entities`，但它也可以发送一个SQL `UPDATE`命令到数据库或通过HTTP进行Web
    API调用；实现细节并不重要。对于查询，概念是相同的，但它返回一个值。非常重要的一点是，查询不能改变应用程序的状态。查询应该只读取数据，如下所示：
- en: '![Figure 16.9: Sequence diagram representing the abstract flow of a query](img/file107.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图16.9：表示查询抽象流程的序列图](img/file107.png)'
- en: 'Figure 16.9: Sequence diagram representing the abstract flow of a query'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9：表示查询抽象流程的序列图
- en: Like the command, the consumer creates a query object and sends it to a handler,
    which then executes some logic to retrieve and return the requested data. We can
    replace `Entities` with anything the handler needs to query the data.Enough talk—let’s
    look at the CQS project.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与命令一样，消费者创建一个查询对象并将其发送到处理器，然后处理器执行一些逻辑以检索和返回所需的数据。我们可以用处理器需要查询数据的东西来替换`Entities`。说得够多了——让我们看看CQS项目。
- en: Project – CQS
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – CQS
- en: '**Context**: We need to build an improved version of our chat system. The old
    system worked so well that we need to scale it up. The mediator was of help to
    us, so we kept that part, and we picked the CQS pattern to help us with this new,
    improved design. A participant was limited to a single chatroom in the past, but
    now a participant must be able to chat in multiple rooms simultaneously.The new
    system is composed of three commands and two queries:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文**：我们需要构建我们聊天系统的改进版本。旧系统工作得很好，我们需要将其扩展。中介者对我们有所帮助，所以我们保留了这部分，并选择了 CQS
    模式来帮助我们进行这个新的、改进的设计。过去，参与者被限制在单个聊天室中，但现在参与者必须能够同时参与多个聊天室。新系统由三个命令和两个查询组成：'
- en: A participant must be able to join a chatroom.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参与者必须能够加入聊天室。
- en: A participant must be able to leave a chatroom.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参与者必须能够离开聊天室。
- en: A participant must be able to send a message into a chatroom.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参与者必须能够向聊天室发送消息。
- en: A participant must be able to obtain the list of participants that joined a
    chatroom.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参与者必须能够获取加入聊天室的所有参与者的列表。
- en: A participant must be able to retrieve the existing messages from a chatroom.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参与者必须能够从聊天室检索现有消息。
- en: 'The first three are commands, and the last two are queries. The system is backed
    by the following mediator that makes heavy use of C# generics:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个是命令，最后两个是查询。系统由以下中介者支持，它大量使用了 C# 泛型：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you are not familiar with generics, this might look daunting, but that code
    is way simpler than it looks. Next, the `ICommand` interface is empty, which we
    could have avoided, but it helps describe our intent. The `ICommandHandler` interface
    defines the contract a class must implement to handle a command. That interface
    defines a `Handle` method that takes the command as a parameter. The generic parameter
    `TCommand` represents the type of command the class implementing the interface
    can handle. Here’s the code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉泛型，这可能会看起来令人畏惧，但那段代码实际上比看起来要简单得多。接下来，`ICommand` 接口是空的，我们本可以避免这种情况，但它有助于描述我们的意图。`ICommandHandler`
    接口定义了一个类必须实现的合同来处理命令。该接口定义了一个 `Handle` 方法，它接受命令作为参数。泛型参数 `TCommand` 表示实现该接口的类可以处理的命令类型。以下是代码：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `IQuery<TReturn>` interface is similar to the `ICommand` interface but
    has a `TReturn` generic parameter indicating the query''s return type. The IQueryHandler
    interface is also very similar, but its `Handle` method takes an object of type
    `TQuery` as a parameter and returns a `TReturn` type. Here’s the code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`IQuery<TReturn>` 接口与 `ICommand` 接口类似，但有一个表示查询返回类型的 `TReturn` 泛型参数。IQueryHandler
    接口也非常相似，但它的 `Handle` 方法接受一个类型为 `TQuery` 的对象作为参数，并返回一个 `TReturn` 类型的值。以下是代码：'
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `IMediator` interface allows registering command and query handlers using
    its `Register` methods. It also supports sending commands and queries through
    its `Send` methods. Then we have the `ChatMessage` class, which is similar to
    the last two samples (with an added creation date):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMediator` 接口允许使用其 `Register` 方法注册命令和查询处理器。它还支持通过其 `Send` 方法发送命令和查询。然后我们有
    `ChatMessage` 类，它与最后两个示例类似（增加了一个创建日期）：'
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next is the updated `IParticipant` interface:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是更新的 `IParticipant` 接口：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'All methods of the `IParticipant` interface accept an `IChatRoom` parameter
    to support multiple chatrooms. The updated `IChatRoom` interface has a name and
    a few basic operations to meet the requirement of a chatroom, like adding and
    removing participants:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`IParticipant` 接口的所有方法都接受一个 `IChatRoom` 参数，以支持多个聊天室。更新的 `IChatRoom` 接口有一个名称和一些基本操作，以满足聊天室的要求，如添加和删除参与者：'
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Before going into commands and the chat itself, let’s take a peek at the `Mediator`
    class:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入命令和聊天本身之前，让我们先看看 `Mediator` 类：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `Mediator` class supports registering commands and queries as well as sending
    a query to a handler or sending a command to zero or more handlers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mediator` 类支持注册命令和查询，以及向处理器发送查询或向零个或多个处理器发送命令。'
- en: 'I omitted the implementation of `HandlerDictionary` because it does not add
    value to the example, it is just an implementation detail, but it would have added
    unnecessary complexity. It is available on GitHub: [https://adpg.link/2Lsm](https://adpg.link/2Lsm).'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我省略了 `HandlerDictionary` 的实现，因为它并不增加示例的价值，它只是实现细节，但它可能会增加不必要的复杂性。它可在 GitHub
    上找到：[https://adpg.link/2Lsm](https://adpg.link/2Lsm)。
- en: Now to the commands. I grouped the commands and the handlers together to keep
    it organized and readable, but you could use another way to organize yours. Moreover,
    since this is a small project, all the commands are in the same file, which would
    not be viable for something bigger. Remember, we are playing LEGO blocks, this
    chapter covers the CQS pieces, but you can always use them with bigger pieces
    like Clean Architecture or other types of architecture.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看命令。我把命令和处理程序放在一起，以保持组织性和可读性，但你也可以使用其他方式来组织你的代码。此外，由于这是一个小型项目，所有命令都在同一个文件中，这对于更大的项目来说是不可行的。记住，我们正在玩乐高积木，这一章涵盖了
    CQS 零件，但你始终可以使用它们与更大的零件，如 Clean Architecture 或其他类型的架构。
- en: We cover ways to organize commands and queries in subsequent chapters.
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将在后续章节中介绍组织命令和查询的方法。
- en: 'Let’s start with the `JoinChatRoom` feature:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `JoinChatRoom` 功能开始：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `Command` class represents the command itself, a data structure that carries
    the command data. The `Handler` class handles that type of command. When executed,
    it adds the specified `IParticipant` to the specified `IChatRoom`, using the `ChatRoom`
    and `Requester` properties (highlighted line). Next feature:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Command` 类代表命令本身，一种携带命令数据的数据结构。`Handler` 类处理这种类型的命令。当执行时，它使用 `ChatRoom` 和
    `Requester` 属性将指定的 `IParticipant` 添加到指定的 `IChatRoom` 中（高亮行）。下一个功能：'
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That code represents the exact opposite of the `JoinChatRoom` command, the `LeaveChatRoom`
    handler removes an `IParticipant` from the specified `IChatRoom` (highlighted
    line).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码代表了 `JoinChatRoom` 命令的完全相反，`LeaveChatRoom` 处理器从指定的 `IChatRoom` 中移除一个 `IParticipant`（高亮行）。
- en: Nesting the classes like this allows reusing the class name `Command` and `Handler`
    for each feature.
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以这种方式嵌套类允许重用每个功能的类名 `Command` 和 `Handler`。
- en: 'To the next feature:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到下一个功能：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `SendChatMessage` feature, on the other hand, handles two things (highlighted
    lines):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，`SendChatMessage` 功能处理两件事（高亮行）：
- en: It adds the specified `Message` to `IChatRoom` (now only a data structure that
    keeps track of users and past messages).
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将指定的 `Message` 添加到 `IChatRoom`（现在仅是一个跟踪用户和过去消息的数据结构）。
- en: It also sends the specified `Message` to all `IParticipant` instances that joined
    that `IChatRoom`.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还将指定的 `Message` 发送到加入该 `IChatRoom` 的所有 `IParticipant` 实例。
- en: 'We are starting to see many smaller pieces interacting with each other to create
    a more developed system. But we are not done; let’s look at the two queries, then
    the chat implementation:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始看到许多较小的部分相互交互，以创建一个更发达的系统。但我们还没有完成；让我们看看这两个查询，然后是聊天实现：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `ListParticipants` handler uses the specified `IChatRoom` and returns its
    participants (highlighted line). Now, to the last query:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListParticipants` 处理器使用指定的 `IChatRoom` 并返回其参与者（高亮行）。现在，来看最后一个查询：'
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `ListMessages` handler uses the specified `IChatRoom` instance to return
    its messages.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListMessages` 处理器使用指定的 `IChatRoom` 实例返回其消息。'
- en: Because all commands and queries reference `IParticipant`, we could enforce
    rules such as “`IParticipant` must join a channel before sending messages,” for
    example. I decided to omit these details to keep the code simple, but feel free
    to add those features if you want to.
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于所有命令和查询都引用 `IParticipant`，我们可以强制执行诸如“`IParticipant` 必须在发送消息之前加入频道”之类的规则。我决定省略这些细节以保持代码简单，但如果你想要的话，随时可以添加这些功能。
- en: 'Next, let’s take a look at the `ChatRoom` class, which is a simple data structure
    that holds the state of a chatroom:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `ChatRoom` 类，它是一个简单的数据结构，用于存储聊天室的状态：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we take a second look at the `ChatRoom` class, it has a `Name` property.
    It contains a list of `IParticipant` instances and a list of `ChatMessage` instances.
    Both `ListMessages()` and `ListParticipants()` return the list `AsReadOnly()`,
    so a clever programmer cannot mutate the state of `ChatRoom` from the outside.
    That’s it; the new `ChatRoom` class is a façade over its underlying dependencies.Finally,
    the `Participant` class is probably the most exciting part of this system because
    it is the one that makes heavy use of our Mediator and CQS:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次看看 `ChatRoom` 类，它有一个 `Name` 属性。它包含一个 `IParticipant` 实例列表和一个 `ChatMessage`
    实例列表。`ListMessages()` 和 `ListParticipants()` 都返回 `AsReadOnly()` 列表，因此一个聪明的程序员不能从外部更改
    `ChatRoom` 的状态。就是这样；新的 `ChatRoom` 类是其底层依赖的伪装。最后，`Participant` 类可能是这个系统中最激动人心的部分，因为它大量使用了我们的中介和
    CQS：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Every method of the `Participant` class, apart from `NewMessageReceivedFrom`,
    sends a command or a query through the `IMediator` interface, breaking the tight
    coupling between the participants and the system’s operations (that is, the commands
    and queries). The `Participant` class is also a simple façade over its underlying
    dependencies, delegating most of the work to the mediator.Now that we have covered
    the numerous tiny pieces let’s look at how everything works together. I grouped
    several test cases that share the following setup code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `NewMessageReceivedFrom` 方法外，`Participant` 类的每个方法都通过 `IMediator` 接口发送命令或查询，打破了参与者与系统操作（即命令和查询）之间的紧密耦合。`Participant`
    类也是其底层依赖的简单外观，将大部分工作委托给中介。现在我们已经涵盖了众多小部件，让我们看看它们是如何协同工作的。我将几个具有以下设置代码的测试用例分组在一起：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The test program setup is composed of the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 测试程序设置由以下内容组成：
- en: One `IMediator` field initialized with a `Mediator` instance, which enables
    all colleagues to interact with each other.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个初始化为 `Mediator` 实例的 `IMediator` 字段，使所有同事能够相互交互。
- en: Two `IChatRoom` fields initialized with `ChatRoom` instances.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个初始化为 `ChatRoom` 实例的 `IChatRoom` 字段。
- en: Three `IParticipant` uninitialized fields, later initialized with `Participant`
    instances.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个未初始化的 `IParticipant` 字段，稍后用 `Participant` 实例初始化。
- en: Three `TestMessageWriter` instances, one per participant.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个 `TestMessageWriter` 实例，每个参与者一个。
- en: The constructor registers all handlers with the `Mediator` instance so it knows
    how to handle commands and queries. It also creates the participants.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数将所有处理程序注册到 `Mediator` 实例，以便它知道如何处理命令和查询。它还创建了参与者。
- en: Once again, the names of the participants are randomly generated.
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参与者的名字再次随机生成。
- en: 'The `TestMessageWriter` implementation is a little different and accumulates
    the data in a list of tuples (`List<(IChatRoom, ChatMessage)>`) to assess what
    the participants send:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestMessageWriter` 的实现略有不同，它将数据累积在元组列表 (`List<(IChatRoom, ChatMessage)>`)
    中，以评估参与者发送的内容：'
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here is the first test case:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是第一个测试用例：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the preceding test case, Reagen and Garner join Room 1, while Reagen and
    Cornelia join Room 2\. Then Reagen requests the list of participants from Room
    1, which outputs Reagen and Garner. Under the hood, it uses commands and queries
    through a mediator, breaking tight coupling between the colleagues. Here is a
    sequence diagram representing what happens when a participant joins a chatroom:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试用例中，Reagen 和 Garner 加入 Room 1，而 Reagen 和 Cornelia 加入 Room 2。然后 Reagen
    从 Room 1 请求参与者列表，输出 Reagen 和 Garner。在底层，它通过中介使用命令和查询，打破了同事之间的紧密耦合。以下是一个序列图，展示了当参与者加入聊天室时发生的情况：
- en: '![Figure 16.10: Sequence diagram representing the flow of a participant (p)
    joining a chatroom (c)](img/file108.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.10：表示参与者（p）加入聊天室（c）流程的序列图](img/file108.png)'
- en: 'Figure 16.10: Sequence diagram representing the flow of a participant (p) joining
    a chatroom (c)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.10：表示参与者（p）加入聊天室（c）流程的序列图
- en: The participant (`p`) creates a `JoinChatRoom` command (`joinCmd`).
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参与者 (`p`) 创建了一个 `JoinChatRoom` 命令 (`joinCmd`)。
- en: '`p` sends `joinCmd` through the mediator (`m`).'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`p` 通过中介 (`m`) 发送 `joinCmd`。'
- en: '`m` finds and dispatches `joinCmd` to its handler (`handler`).'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`m` 查找并将 `joinCmd` 分派给其处理程序 (`handler`)。'
- en: '`handler` executes the logic (adds `p` to the chatroom).'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`handler` 执行逻辑（将 `p` 添加到聊天室）。'
- en: '`joinCmd` ceases to exist afterward; commands are ephemeral.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`joinCmd` 之后不再存在；命令是瞬时的。'
- en: 'That means `Participant` never interacts directly with `ChatRoom` or other
    participants.Then a similar workflow happens when a participant requests the list
    of participants of a chatroom:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `Participant` 从不直接与 `ChatRoom` 或其他参与者交互。当参与者请求聊天室的参与者列表时，发生类似的流程：
- en: '![Figure 16.11: Sequence diagram representing the flow of a participant (p)
    requesting the list of participants of a chatroom (c)](img/file109.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.11：表示参与者（p）请求聊天室（c）参与者列表流程的序列图](img/file109.png)'
- en: 'Figure 16.11: Sequence diagram representing the flow of a participant (p) requesting
    the list of participants of a chatroom (c)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.11：表示参与者（p）请求聊天室（c）参与者列表流程的序列图
- en: '`Participant` (`p`) creates a `ListParticipants` query (`listQuery`).'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Participant` (`p`) 创建了一个 `ListParticipants` 查询 (`listQuery`)。'
- en: '`p` sends `listQuery` through the mediator (`m`).'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`p` 通过中介 (`m`) 发送 `listQuery`。'
- en: '`m` finds and dispatches the query to its handler (`handler`).'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`m` 查找并将查询分派给其处理程序 (`handler`)。'
- en: '`handler` executes the logic (lists the participants of the chatroom).'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`handler` 执行逻辑（列出聊天室的参与者）。'
- en: '`listQuery` ceases to exist afterward; queries are also ephemeral.'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`listQuery` 在之后不再存在；查询也是短暂的。'
- en: 'Once again, `Participant` does not interact directly with `ChatRoom`.Here is
    another test case where `Participant` sends a message to a chatroom, and another
    `Participant` receives it:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`Participant` 不直接与 `ChatRoom` 交互。这里还有一个测试用例，其中 `Participant` 向聊天室发送消息，另一个
    `Participant` 接收它：
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the preceding test case, Reagen joins Room 1 while Garner joins Rooms 1
    and 2\. Then Reagen sends a message to Room 1, and we verify that Garner received
    it once.The `SendMessageTo` workflow is very similar to the other one that we
    saw but with a more complex command handler:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试用例中，Reagen 加入房间 1，而 Garner 加入房间 1 和 2。然后 Reagen 向房间 1 发送消息，我们验证 Garner
    是否收到了它。《SendMessageTo》工作流程与我们所看到的另一个非常相似，但具有更复杂的命令处理程序：
- en: '![Figure 16.12: Sequence diagram representing the flow of a participant (p)
    sending a message (msg)to a chatroom (c)](img/file110.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.12：表示参与者（p）向聊天室（c）发送消息（msg）的流程的序列图](img/file110.png)'
- en: 'Figure 16.12: Sequence diagram representing the flow of a participant (p) sending
    a message (msg)to a chatroom (c)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.12：序列图表示参与者（p）向聊天室（c）发送消息（msg）的流程
- en: 'From that diagram, we can observe that we pushed the logic to the `Handler`
    class of the `SendChatMessage` feature. All the other actors work together with
    limited to no knowledge of each other.This demonstrates how CQS works with a mediator:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从该图中，我们可以观察到我们将逻辑推到了 `SendChatMessage` 功能的 `Handler` 类中。所有其他角色都一起工作，彼此之间了解有限或没有了解。这展示了
    CQS 与中介一起是如何工作的：
- en: A consumer (the participant in this case) creates a command (or a query).
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消费者（在本例中为参与者）创建一个命令（或一个查询）。
- en: The consumer sends that command through the mediator.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消费者通过中介发送该命令。
- en: The mediator sends that command to one or more handlers, each executing their
    piece of logic for that command.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中介将该命令发送给一个或多个处理程序，每个处理程序执行该命令的逻辑部分。
- en: You can explore the other test cases to familiarize yourself with the program
    and the concepts.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以探索其他测试用例，以便熟悉程序和概念。
- en: You can debug the tests in Visual Studio; use breakpoints combined with *Step
    Into (F11)* and *Step Over (F10)* to explore the sample.
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以在 Visual Studio 中调试测试；使用断点结合 *进入（F11）* 和 *跳过（F10）* 来探索示例。
- en: I also created a `ChatModerator` instance that sends a message in a “moderator
    chatroom” when a message contains a word from the `badWords` collection. That
    test case executes multiple handlers for each `SendChatMessage.Command`. I’ll
    leave you to explore these other test cases yourself so we don’t wander astray
    from our goal.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我还创建了一个 `ChatModerator` 实例，当消息包含 `badWords` 集合中的单词时，在“调解聊天室”中发送消息。该测试用例为每个 `SendChatMessage.Command`
    执行多个处理程序。我将留给你自己探索这些其他测试用例，以免偏离我们的目标。
- en: Conclusion
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'The CQS and CQRS patterns suggest dividing the operations of a program into
    **commands** and **queries**. A command mutates data, and a query fetches data.
    We can apply the **Mediator** pattern to break the tight coupling between the
    pieces of a program using CQS, like sending commands and queries.Dividing the
    program this way helps separate the different pieces and focus on the commands
    and queries that travel from a consumer through the mediator to one or more handlers.
    The data contract of commands and queries becomes the program’s backbone, trimming
    down the coupling between objects and tying them to those thin data structures
    instead, leaving the central piece (the mediator) to manage the links between
    them.On the other hand, you may find the codebase more intimidating when using
    CQS due to the multiple classes. It adds some complexity, especially for a small
    program like this. However, each type does less (having a single responsibility),
    making it easier to test than a more sizable class with many responsibilities.Now
    let’s see how CQRS can help us follow the **SOLID** principles:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: CQS 和 CQRS 模式建议将程序的操作分为 **命令** 和 **查询**。命令会修改数据，而查询会获取数据。我们可以应用 **中介** 模式，通过
    CQS 打破程序各部分之间的紧密耦合，例如发送命令和查询。以这种方式划分程序有助于分离不同的部分，并专注于从消费者通过中介到一个或多个处理程序的命令和查询。命令和查询的数据契约成为程序的主干，减少了对象之间的耦合，并将它们绑定到这些薄数据结构上，从而让中央部分（中介）管理它们之间的链接。另一方面，使用
    CQS 时，你可能会发现代码库更令人畏惧，因为存在多个类。它增加了一些复杂性，尤其是对于像这样的小型程序。然而，每种类型都做得更少（具有单一职责），这使得它比具有许多职责的更大规模的类更容易测试。现在让我们看看
    CQRS 如何帮助我们遵循 **SOLID** 原则：
- en: '**S**: Dividing an application into commands, queries, and handlers takes us
    toward encapsulating single responsibilities into different classes.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**: 将应用程序划分为命令、查询和处理程序，使我们朝着将单一责任封装到不同类中迈进。'
- en: '**O**: CQS helps extend the software without modifying the existing code, such
    as adding handlers and creating new commands.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**: CQS有助于在不修改现有代码的情况下扩展软件，例如添加处理程序和创建新的命令。'
- en: '**L**: N/A'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**: N/A'
- en: '**I**: CQS makes it easier to create multiple small interfaces with a clear
    distinction between commands, queries, and their respective handlers.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**: CQS使创建多个具有清晰区分的命令、查询及其相应处理程序的小接口变得更容易。'
- en: '**D**: N/A'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**: N/A'
- en: Now that we have explored CQRS, CQS, and the Mediator pattern, we explore the
    Marker Interfaces.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了CQRS、CQS和中介者模式，我们将探讨标记接口。
- en: Code smell – Marker Interfaces
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码异味 – 标记接口
- en: 'We used the empty `ICommand` and `IQuery<TReturn>` interfaces in the code samples
    to make the code more explicit and self-descriptive. Empty interfaces are a sign
    that something may be wrong: a code smell. We call those **marker interfaces**.In
    our case, they help identify commands and queries but are empty and add nothing.
    We could discard them without any impact on our system. On the other hand, we
    are not performing magic tricks or violating any principles, so they don’t harm
    but help define the intent. Moreover, we could leverage them to make the code
    more dynamic, like leveraging dependency injection to register handlers. Furthermore,
    I designed those interfaces this way as a bridge to the next project.Back to the
    marker interfaces, here are two types of marker interfaces that are code smells
    in C#:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码示例中使用了空的`ICommand`和`IQuery<TReturn>`接口，使代码更加明确和自我描述。空接口是可能存在问题的标志：一个代码异味。我们称之为**标记接口**。在我们的情况下，它们有助于识别命令和查询，但它们是空的，没有添加任何内容。我们可以丢弃它们，而不会对我们的系统产生任何影响。另一方面，我们并没有进行魔术般的操作或违反任何原则，所以它们不会造成伤害，而是有助于定义意图。此外，我们可以利用它们使代码更加动态，例如利用依赖注入来注册处理程序。此外，我就是这样设计这些接口的，作为通向下一个项目的桥梁。回到标记接口，这里有两种类型的标记接口，在C#中是代码异味：
- en: Metadata
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元数据
- en: Dependency identifier
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖标识符
- en: Metadata
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元数据
- en: Markers can be used to define metadata. A class “implements” the empty interface,
    and some consumer does something with it later. It could be an assembly scanning
    for specific types, a choice of strategy, or something else.Instead of creating
    marker interfaces to add metadata, try to use custom attributes. The idea behind
    attributes is to add metadata to classes and their members. On the other hand,
    interfaces exist to create a contract, and they should define at least one member;
    empty contracts are like a blank sheet.In a real-world scenario, you may want
    to consider the cost of one versus the other. Markers are very cheap to implement
    but can violate architectural principles. Attributes can be as cheap to implement
    if the mechanism is already implemented or supported by the framework but can
    cost much more than a marker interface, depending on the scenario. Before deciding,
    I recommend you evaluate the cost of both options.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 标记可以用来定义元数据。一个类“实现”了空接口，然后某个消费者稍后对它做了些事情。这可能是一个扫描特定类型的程序集、策略选择或其他事情。与其创建标记接口来添加元数据，不如尝试使用自定义属性。属性背后的想法是为类及其成员添加元数据。另一方面，接口的存在是为了创建一个合同，它们应该定义至少一个成员；空合同就像一张白纸。在现实世界的场景中，你可能需要考虑一种方法与另一种方法的成本。标记实现起来非常便宜，但可能会违反架构原则。如果机制已经实现或由框架支持，属性可能同样便宜实现，但根据场景，可能比标记接口的成本高得多。在做出决定之前，我建议你评估这两种选项的成本。
- en: Dependency identifier
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖标识符
- en: 'If you need markers to inject some specific dependency in a particular class,
    you are most likely cheating the **Inversion of Control** principle. Instead,
    you should find a way to achieve the same goal using dependency injection, such
    as by contextually injecting your dependencies.Let’s start with the following
    interface:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在特定类中注入一些特定的依赖项，你很可能是违反了**控制反转**原则。相反，你应该找到一种使用依赖注入实现相同目标的方法，例如通过上下文注入你的依赖项。让我们从以下接口开始：
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In our program, we have two implementations and two markers, one for each implementation:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，我们有两个实现和两个标记，每个实现一个：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The code is barebones, but all the building blocks are there:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单，但所有构建块都在那里：
- en: '`StrategyA` implements `IStrategyA`, which inherits from `IStrategy`.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StrategyA`实现了从`IStrategy`继承的`IStrategyA`。'
- en: '`StrategyB` implements `IStrategyB`, which inherits from `IStrategy`.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StrategyB`实现了继承自`IStrategy`的`IStrategyB`。'
- en: Both `IStrategyA` and `IStrategyB` are empty marker interfaces.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IStrategyA`和`IStrategyB`都是空的标记接口。'
- en: 'Now, the consumer needs to use both strategies, so instead of controlling dependencies
    from the composition root, the consumer requests the markers:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，消费者需要使用两种策略，因此，而不是从组合根控制依赖项，消费者请求标记：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `Consumer` class exposes the strategies through properties to assert its
    composition later. Let’s test that out by building a dependency tree, simulating
    the composition root, and then asserting the value of the consumer properties:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`Consumer`类通过属性公开策略，以便稍后断言其组合。让我们通过构建依赖项树，模拟组合根，然后断言消费者属性的值来测试这一点：'
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Both properties are of the expected type, but that is not the problem. The
    `Consumer` class controls what dependencies to use and when to use them by injecting
    markers A and B instead of two `IStrategy` instances. Due to that, we cannot control
    the dependency tree from the composition root. For example, we cannot change `IStrategyA`
    to `IStrategyB` and `IStrategyB` to `IStrategyA`, nor inject two `IStrategyB`
    instances or two `IStrategyA` instances, nor even create an `IStrategyC` interface
    to replace `IStrategyA` or `IStrategyB`.How do we fix this? Let’s start by deleting
    our markers and injecting two `IStrategy` instances instead (the changes are highlighted).
    After doing that, we end up with the following object structure:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 两个属性都是预期的类型，但这不是问题。`Consumer`类通过注入标记A和B来控制使用哪些依赖项以及何时使用它们，而不是使用两个`IStrategy`实例。因此，我们不能从组合根控制依赖项树。例如，我们不能将`IStrategyA`更改为`IStrategyB`，也不能将`IStrategyB`更改为`IStrategyA`，也不能注入两个`IStrategyB`实例或两个`IStrategyA`实例，甚至不能创建一个`IStrategyC`接口来替换`IStrategyA`或`IStrategyB`。我们如何解决这个问题呢？让我们从删除我们的标记并注入两个`IStrategy`实例开始（更改已突出显示）。完成此操作后，我们得到以下对象结构：
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `Consumer` class no longer controls the narrative with the new implementation,
    and the composition responsibility falls back to the composition root. Unfortunately,
    there is no way to do contextual injections using the default dependency injection
    container, and I don’t want to get into a third-party library for this. But all
    is not lost yet; we can use a factory to help ASP.NET Core build the `Consumer`
    instance, like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的实现中，`Consumer`类不再控制叙事，组合责任退回到组合根。不幸的是，没有方法可以使用默认的依赖注入容器进行上下文注入，而且我不想为此使用第三方库。但事情还没有完全失去希望；我们可以使用一个工厂来帮助ASP.NET
    Core构建`Consumer`实例，如下所示：
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: From this point forward, we control the program’s composition, and we can swap
    A with B or do anything else that we want to, as long as the implementation respects
    the `IStrategy` contract.To conclude, using markers instead of doing contextual
    injection breaks the inversion of control principle, making the consumer control
    its dependencies. That’s very close to using the `new` keyword to instantiate
    objects. Inverting the dependency control back is easy, even using the default
    container.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，我们控制程序的组合，我们可以用B替换A或做任何我们想要的事情，只要实现尊重`IStrategy`合同。为了总结，使用标记而不是进行上下文注入破坏了控制反转原则，使消费者控制其依赖项。这非常接近使用`new`关键字来实例化对象。即使使用默认容器，反转依赖项控制也很容易。
- en: If you need to inject dependencies contextually, I started an open source project
    in 2020 that does that. Multiple other third-party libraries add features or replace
    the default IoC container altogether if needed. See the *Further reading* section.
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你需要根据上下文注入依赖项，我在2020年启动了一个开源项目来实现这一点。如果需要，多个其他第三方库会添加功能或完全替换默认的IoC容器。请参阅*进一步阅读*部分。
- en: Next, we start the last part of this chapter. It showcases an open-source tool
    that can help us build CQS-oriented applications.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始本章的最后一部分。它展示了一个开源工具，可以帮助我们构建面向CQS的应用程序。
- en: Using MediatR as a mediator
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将MediatR用作中介
- en: 'In this section, we are exploring MediatR, an open-source mediator implementation.What
    is MediatR? Let’s start with its maker’s description from its GitHub repository,
    which brands it as this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们正在探讨MediatR，这是一个开源的中介实现。那么什么是MediatR呢？让我们从其GitHub仓库中制作者的描述开始，它将其定义为：
- en: '*“Simple, unambitious mediator implementation in .NET”*'
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“.NET中的简单、不雄心勃勃的中介实现”*'
- en: 'MediatR is a simple but very powerful tool doing in-process communication through
    messaging. It supports a request/response flow through commands, queries, notifications,
    and events, synchronously and asynchronously.We can install the NuGet package
    using the .NET CLI: `dotnet add package MediatR`.Now that I have quickly introduced
    the tool, we are going to explore the migration of our Clean Architecture sample
    but instead use MediatR to dispatch the `StocksController` requests to the core
    use cases. We use a similar pattern with MediatR than what we built in the CQS
    project.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: MediatR是一个简单但非常强大的工具，通过消息进行进程内通信。它支持通过命令、查询、通知和事件进行请求/响应流，同步和异步。我们可以使用.NET CLI安装NuGet包：`dotnet
    add package MediatR`。现在我已经快速介绍了这个工具，我们将探索迁移我们的清洁架构示例，但将使用MediatR来调度`StocksController`请求到核心用例。我们使用与CQS项目中构建的类似模式使用MediatR。
- en: Why migrate our Clean Architecture sample? The primary reason we are building
    the same project using different models is for ease of comparison. It is much
    easier to compare the changes of the same features than if we were building completely
    different projects.
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么迁移我们的清洁架构示例？我们使用不同的模型构建相同的项目的主要原因是便于比较。与构建完全不同的项目相比，比较相同功能的更改要容易得多。
- en: What are the advantages of using MediatR in this case? It allows us to organize
    the code around use cases (vertically) instead of services (horizontally), leading
    to more cohesive features. We remove the service layer (the `StockService` class)
    and replace it with multiple use cases (features) instead (the `AddStocks` and
    `RemoveStock` classes). MediatR also enables a pipeline we can extend by programming
    behaviors. Those extensibility points allow us to manage cross-cutting concerns,
    such as requests validation centrally, without impacting the consumers and use
    cases. We explore request validation in *Chapter 17*, *Getting Started with Vertical
    Slice Architecture*.Let’s jump into the code now to see how it works.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下使用MediatR的优势是什么？它允许我们围绕用例（垂直）而不是服务（水平）组织代码，从而产生更紧密的功能。我们移除了服务层（`StockService`类）并替换为多个用例（功能）而不是（`AddStocks`和`RemoveStock`类）。MediatR还允许我们通过编程行为扩展的管道。这些可扩展点使我们能够管理横切关注点，例如集中管理请求验证，而不会影响消费者和用例。我们将在*第17章*，*开始使用垂直切片架构*中探讨请求验证。现在让我们跳入代码，看看它是如何工作的。
- en: Project – Clean Architecture with MediatR
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 使用MediatR的清洁架构
- en: '**Context**: We want to break some more of the coupling in the Clean Architecture
    project we built in *Chapter 14*, *Understanding Layering*, by leveraging the
    **Mediator** pattern and a **CQS** approach.The clean architecture solution was
    already solid, but MediatR will pave the way to more good things later. The only
    “major” change is the replacement of the `StockService` with two feature objects,
    `AddStocks` and `RemoveStocks`, which we explore soon.First, we must install the
    `MediatR` NuGet package in the `Core` project, where the features will live. Moreover,
    it will transiently cascade to the `Web` project, allowing us to register MediatR
    with the IoC container. In the `Program.cs` file, we can register MediatR like
    this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文**：我们希望通过利用**中介者**模式和**CQS**方法，在*第14章*，*理解分层*中构建的清洁架构项目中进一步打破一些耦合。清洁架构解决方案已经足够稳固，但MediatR将为后续带来更多好处。唯一的“重大”变化是将`StockService`替换为两个功能对象，`AddStocks`和`RemoveStocks`，我们将在下面进行探讨。首先，我们必须在功能将驻留的`Core`项目中安装`MediatR`
    NuGet包。此外，它将暂时级联到`Web`项目，使我们能够将MediatR注册到IoC容器中。在`Program.cs`文件中，我们可以这样注册MediatR：'
- en: '[PRE47]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: That code scans the Core assembly for MediatR-compatible pieces and registers
    them with the IoC Container. The `NotEnoughStockException` class is part of the
    core project.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码扫描Core组件以查找与MediatR兼容的组件，并将它们注册到IoC容器中。`NotEnoughStockException`类是核心项目的一部分。
- en: I picked the `NotEnoughStockException` class but could have chosen any class
    from the `Core` assembly. There are more registration options.
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我选择了`NotEnoughStockException`类，但我可以选择`Core`组件中的任何类。有更多的注册选项。
- en: 'MediatR exposes the following types of messages (as of version 12):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: MediatR公开以下类型的消息（截至版本12）：
- en: '*Request/response* that has one handler; perfect for commands and queries.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*请求/响应*具有一个处理器；非常适合命令和查询。'
- en: '*Notifications* that support multiple handlers; perfect for an event-based
    model applying the Publish-Subscribe pattern where a notification represents an
    event.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多个处理器的*通知*；非常适合应用发布-订阅模式的基于事件的模型，其中通知表示事件。
- en: '*Request/response streams* that are similar to request/response but stream
    the response through the `IAsyncEnumerable<T>` interface.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与请求/响应类似，但通过`IAsyncEnumerable<T>`接口流式传输响应的*请求/响应流*。
- en: We cover the Publish-Subscribe pattern in *Chapter 19*, *Introduction to Microservices
    Architecture*.
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在第19章中介绍了微服务架构的*发布-订阅模式*。
- en: 'Now that everything we need related to MediatR is “magically” registered, we
    can look at the use cases that replace the `StockService`. Let’s have a look at
    the updated `AddStocks` code first:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要的所有与MediatR相关的功能都已经“神奇地”注册了，我们可以查看替换`StockService`的用例。让我们首先看看更新的`AddStocks`代码：
- en: '[PRE48]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Since we covered both use cases in the previous chapters and the changes are
    very similar, we will analyze both together, after the `RemoveStocks` use case
    code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在前几章中已经涵盖了这两个用例，并且变化非常相似，因此我们将在`RemoveStocks`用例代码之后一起分析它们：
- en: '[PRE49]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As you may have noticed in the code, I chose the same pattern to build the
    commands as I did with the CQS sample, so we have a class per use case containing
    two nested classes: `Command` and `Handler`. This structure makes for very clean
    code when you have a 1-on-1 relationship between the command class and its handler.Using
    the MediatR request/response model, the command (or query) becomes a request and
    must implement the `IRequest<TResponse>` interface. The handlers must implement
    the `IRequestHandler<TRequest, TResponse>` interface. Instead, we could implement
    the `IRequest` and `IRequestHandler<TRequest>` interfaces for a command that returns
    nothing (`void`).'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经在代码中注意到的，我选择了与CQS示例相同的模式来构建命令，因此我们有一个包含两个嵌套类的类，每个用例一个类：`Command`和`Handler`。当你有一个命令类与其处理器的一对一关系时，这种结构会使代码非常清晰。使用MediatR请求/响应模型，命令（或查询）成为一个请求，必须实现`IRequest<TResponse>`接口。处理器必须实现`IRequestHandler<TRequest,
    TResponse>`接口。相反，我们可以为返回`void`（无）的命令实现`IRequest`和`IRequestHandler<TRequest>`接口。
- en: More options are part of MediatR, and the documentation is complete enough to
    dig deeper yourself.
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MediatR还有更多选项，文档足够完整，可以让你自己深入了解。
- en: 'Let’s analyze the anatomy of the `AddStocks` use case. Here is the old code
    as a reference:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析`AddStocks`用例的结构。以下是作为参考的旧代码：
- en: '[PRE50]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The first difference is that we moved the loose parameters (highlighted) into
    the `Command` class, which encapsulates the whole request:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个区别是我们将松散的参数（突出显示）移动到了`Command`类中，它封装了整个请求：
- en: '[PRE51]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then the `Command` class specifies the handler’s expected return value by implementing
    the `IRequest<TResponse>` interface, where `TResponse` is an `int`. That gives
    us a typed response when sending the request through MediatR. This is not “pure
    CQS” because the command handler returns an integer representing the updated `QuantityInStock`.
    However, we could call that optimization since executing one command and one query
    would be overkill for this scenario (possibly leading to two database calls instead
    of one).I’ll skip the `RemoveStocks` use case to avoid repeating myself, as it
    follows the same pattern. Instead, let’s look at the consumption of those use
    cases. I omitted the exception handling to keep the code streamlined and because
    `try`/`catch` blocks would only add noise to the code in this case and hinder
    our study of the pattern:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Command`类通过实现`IRequest<TResponse>`接口来指定处理器的预期返回值，其中`TResponse`是一个`int`。这样，当我们通过MediatR发送请求时，我们就会得到一个类型化的响应。这并不是“纯CQS”，因为命令处理器返回一个整数，代表更新的`QuantityInStock`。然而，我们可以称之为优化，因为执行一个命令和一个查询对于这个场景来说可能是过度的（可能导致的数据库调用次数从一次变为两次）。我将跳过`RemoveStocks`用例，以避免重复，因为它遵循相同的模式。相反，让我们看看这些用例的消费情况。我省略了异常处理，以保持代码的简洁性，并且因为在这个情况下，`try`/`catch`块只会给代码增加噪音，并阻碍我们对模式的了解：
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In both delegates, we inject an `IMediator` and a command object (highlighted).
    We also let ASP.NET Core inject a `CancellationToken`, which we pass to MediatR.
    The model binder loads the data from the HTTP request into the objects that we
    send using the `Send` method of the `IMediator` interface (highlighted). Then
    we map the result into the `StockLevel` DTO before returning its value and an
    HTTP status code of `200` `OK`. The `StockLevel` record class is the same as before.This
    example contains almost the same code as our CQS example, but we used MediatR
    instead of manually programming the pieces.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个委托中，我们注入了一个`IMediator`和一个命令对象（突出显示）。我们还让ASP.NET Core注入了一个`CancellationToken`，并将其传递给MediatR。模型绑定器将数据从HTTP请求加载到我们使用`IMediator`接口的`Send`方法（突出显示）发送的对象中。然后我们将结果映射到`StockLevel`
    DTO中，在返回其值和HTTP状态码`200` `OK`之前。`StockLevel`记录类与之前相同。这个例子几乎包含了我们CQS示例中的相同代码，但我们使用了MediatR而不是手动编写这些部分。
- en: The default model binder cannot load data from multiple sources. Because of
    that, we must inject `productId` and assign its value to the `command.ProductId`
    property manually. Even if both values could be taken from the body, the resource
    identifier of that endpoint would become less exhaustive (no `productId` in the
    URI).
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认模型绑定器无法从多个来源加载数据。因此，我们必须手动注入`productId`并将其值分配给`command.ProductId`属性。即使这两个值都可以从主体中获取，该端点的资源标识符也会变得不那么详尽（URI中没有`productId`）。
- en: ''
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With MVC, we could create a custom model binder.
  id: totrans-288
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用MVC，我们可以创建一个自定义模型绑定器。
- en: ''
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With minimal APIs, we could create a static `BindAsync` method to manually do
    the model binding, which is not very extensible and would tightly couple the `Core`
    assembly with the `HttpContext`. I suppose we will need to wait for .NET 9+ to
    get improvements into that field.
  id: totrans-290
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用最少的API，我们可以创建一个静态的`BindAsync`方法来手动进行模型绑定，这不太灵活，并且会将`Core`程序集与`HttpContext`紧密耦合。我想我们可能需要等待.NET
    9+来获得该领域的改进。
- en: ''
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I’ve left a few links in the *further reading* section relating to this.
  id: totrans-292
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我在*进一步阅读*部分留下了一些与这个主题相关的链接。
- en: Conclusion
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: With MediatR, we packed the power of a CQS-inspired pipeline with the Mediator
    pattern into a Clean Architecture application. We broke the coupling between the
    request delegates and the use case handler (previously a service). A simple DTO,
    such as a command object, makes endpoints and controllers unaware of the handlers,
    leaving MediatR as the middleman between the commands and their handlers. Due
    to that, the handlers could change along the way without impacting the endpoint.Moreover,
    we could configure more interaction between the command and the handler with `IRequestPreProcessor`,
    `IRequestPostProcessor`, and `IRequestExceptionHandler`. These allow us to extend
    the MediatR request pipeline with cross-cutting concerns like validation and error
    handling.MediatR helps us follow the SOLID principles the same way as the Mediator
    and CQS patterns combined. The only drawback of the overall design, which has
    nothing to do with MediatR, is that we used the commands as the DTOs. We could
    create custom DTOs and map them to command objects. However, you will understand
    in the next chapter where I was heading with this transitory design.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MediatR，我们将CQS启发的管道和中介者模式的力量打包进了一个Clean Architecture应用程序中。我们打破了请求委托和使用情况处理器（之前是一个服务）之间的耦合。一个简单的DTO，如命令对象，使端点和控制器对处理器一无所知，让MediatR成为命令和它们的处理器之间的中间人。因此，处理器可以在不影响端点的情况下进行更改。此外，我们可以通过`IRequestPreProcessor`、`IRequestPostProcessor`和`IRequestExceptionHandler`配置命令和处理器之间的更多交互。这些允许我们通过验证和错误处理等跨切面关注点扩展MediatR请求管道。MediatR帮助我们以与中介者和CQS模式结合相同的方式遵循SOLID原则。整体设计的唯一缺点，这与MediatR无关，是我们使用了命令作为DTO。我们可以创建自定义DTO并将它们映射到命令对象。然而，你将在下一章中了解到，我为什么要使用这种过渡设计。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the Mediator pattern, which allows us to cut the
    ties between collaborators, mediating the communication between them. Then we
    studied the CQS pattern, which advises the division of software behaviors into
    commands and queries. Those two patterns are tools that cut tight coupling between
    components.Afterward, we updated a Clean Architecture project to use MediatR,
    an open-source generic mediator that is CQS-oriented. There are many more possible
    uses than we explored, but this is still a great start. This concludes another
    chapter exploring techniques to break tight coupling and divide systems into smaller
    parts.All those building blocks lead us to the next chapter, where we piece those
    patterns and tools together to explore the Vertical Slice Architecture.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了中介者模式，它允许我们切断协作者之间的联系，调解他们之间的通信。然后我们研究了CQS模式，它建议将软件行为划分为命令和查询。这两个模式是减少组件之间紧密耦合的工具。之后，我们将Clean
    Architecture项目更新为使用MediatR，这是一个面向CQS的开源通用中介者。还有许多其他可能的用途我们没有探讨，但这仍然是一个很好的开始。这标志着探索打破紧密耦合和将系统划分为更小部分的技术的另一章结束。所有这些构建块都引导我们进入下一章，在那里我们将这些模式和工具组合起来，以探索垂直切片架构。
- en: Questions
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s take a look at a few practice questions:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个练习题：
- en: What does the CQS stand for, and what is the purpose of this design pattern?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CQS代表什么，这个设计模式的目的何在？
- en: Can we use a mediator inside a colleague to call another colleague?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否在同事内部使用中介者来调用另一个同事？
- en: In CQS, can a command return a value?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在CQS中，命令可以返回值吗？
- en: How much does MediatR cost?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MediatR的费用是多少？
- en: Imagine a design with a marker interface to add metadata to some classes. Do
    you think you should review that design?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想象一个使用标记接口为某些类添加元数据的设计。你认为你应该审查那个设计吗？
- en: Further reading
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are a few links to build on what we have learned in the chapter:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些链接，可以帮助我们巩固本章所学的内容：
- en: 'MediatR: [https://adpg.link/ZQap](https://adpg.link/ZQap)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MediatR：[https://adpg.link/ZQap](https://adpg.link/ZQap)
- en: 'To get rid of setting `ProductId` manually in the Clean Architecture with MediatR
    project, you can use the open-source project `HybridModelBinding` or read the
    official documentation about custom model binding and implement your own:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在MediatR的Clean Architecture项目中避免手动设置`ProductId`，你可以使用开源项目`HybridModelBinding`或阅读关于自定义模型绑定的官方文档，然后实现自己的：
- en: 'Custom Model Binding in ASP.NET Core: [https://adpg.link/65pb](https://adpg.link/65pb)'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ASP.NET Core中进行自定义模型绑定：[https://adpg.link/65pb](https://adpg.link/65pb)
- en: 'Damian Edward’s MinimalApis.Extensions project on GitHub: [https://adpg.link/M6zS](https://adpg.link/M6zS)'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitHub上的Damian Edward的MinimalApis.Extensions项目：[https://adpg.link/M6zS](https://adpg.link/M6zS)
- en: '`ForEvolve.DependencyInjection` is an open-source project that adds support
    for contextual dependency injection and more: [https://adpg.link/myW8](https://adpg.link/myW8)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForEvolve.DependencyInjection`是一个开源项目，它增加了对上下文依赖注入的支持以及更多功能：[https://adpg.link/myW8](https://adpg.link/myW8)'
- en: Answers
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: CQS stands for Command-Query Separation. It's a software design principle that
    separates operations that change the state of an object (commands) from those
    that return data (queries). This helps in minimizing side effects and preventing
    unexpected changes in program behavior.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CQS代表命令-查询分离。这是一种软件设计原则，它将改变对象状态的操作（命令）与返回数据的操作（查询）分开。这有助于最小化副作用并防止程序行为的意外变化。
- en: Yes, you can. The goal of the Mediator pattern is to mediate communication between
    colleagues.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，你可以。中介者模式的目标是在同事之间进行通信的调解。
- en: 'In the original sense of CQS: no, a command can’t return a value. The idea
    is that a query reads data while commands mutate data. A command can return a
    value in a looser sense of CQS. For example, nothing stops a create command from
    returning the created entity partially or totally. You can always trade a bit
    of modularity for a bit of performance.'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在CQS的原义中：不，命令不能返回值。其理念是查询读取数据，而命令修改数据。在CQS的较宽松意义上，命令可以返回值。例如，没有任何东西阻止创建命令部分或全部返回创建的实体。你总是可以在模块化和性能之间进行权衡。
- en: MediatR is a free, open-source project licensed under Apache License 2.0.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MediatR是一个免费的开源项目，许可协议为Apache License 2.0。
- en: Yes, you should. Using Marker Interfaces to add metadata is generally wrong.
    Nevertheless, you should analyze each use case individually, considering the pros
    and cons before jumping to a conclusion.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，你应该。使用标记接口添加元数据通常是不正确的。尽管如此，你应该单独分析每个用例，在得出结论之前考虑其优缺点。
