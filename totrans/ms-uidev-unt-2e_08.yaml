- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Canvases, Panels, and Basic Layouts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 画布、面板和基本布局
- en: As discussed in the previous chapter, the majority of this text will focus on
    the Unity UI system, uGUI. Canvases are the core of all UI made with Unity UI.
    Every single uGUI element must be contained within a Canvas for it to render within
    a scene. It works similarly to a canvas on which an artist paints, but instead
    of painting on them, we lay out UI elements on them. So, we’ll start our exploration
    of the various UI elements provided in the uGUI system with Canvases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，本文的大部分内容将侧重于Unity UI系统，即uGUI。画布是所有使用Unity UI制作的UI的核心。每个uGUI元素都必须包含在一个画布中，才能在场景中进行渲染。它的工作方式类似于艺术家在上面作画的画布，但不同的是，我们在上面布局UI元素，而不是在上面作画。因此，我们将从uGUI系统提供的各种UI元素开始，以画布为起点进行探索。
- en: Canvases serve the purpose of not only holding all the UI elements within them
    but also determining how the elements will render and how they will scale. It’s
    important to start focusing on setting up a UI that will scale at multiple resolutions
    and aspect ratios early on, as trying to do so later will cause a lot of headaches
    and extra work. Therefore, we will also discuss how to make sure our UI scales
    appropriately.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 画布不仅用于包含它们内部的所有UI元素，还决定了元素如何渲染以及如何缩放。在早期就关注设置能够在多个分辨率和宽高比下缩放的UI非常重要，因为稍后尝试这样做将会带来很多麻烦和额外的工作。因此，我们还将讨论如何确保我们的UI能够适当地缩放。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Creating UI Canvases and setting their properties
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建UI画布并设置其属性
- en: Creating UI Panels and setting their properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建UI面板并设置其属性
- en: Using the Rect Tool and the Rect Transform component
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用矩形工具和矩形变换组件
- en: Properly setting anchor and pivot points
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确设置锚点和中心点
- en: How to create and lay out a basic HUD
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建和布局基本HUD
- en: How to create a background image
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建背景图片
- en: How to set up a basic pop-up menu
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置基本弹出菜单
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the relevant codes and asset files of this chapter here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到本章的相关代码和资产文件：
- en: '[https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2006](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2006)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2006](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2006)'
- en: UI Canvas
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI Canvas
- en: 'Every UI element you create must be a child of a **UI Canvas**. To see a list
    of all UI elements you can create within Unity, select **+** | **UI** from the
    **Hierarchy** window, as shown in the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的每个UI元素都必须是**UI Canvas**的子元素。要查看在Unity中可以创建的所有UI元素列表，请从**Hierarchy**窗口中选择**+**
    | **UI**，如下截图所示：
- en: '![Figure 6.1: The renderable UI elements within the Unity UI (uGUI) system](img/Figure_06.01_B18327.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：Unity UI（uGUI）系统中的可渲染UI元素](img/Figure_06.01_B18327.jpg)'
- en: 'Figure 6.1: The renderable UI elements within the Unity UI (uGUI) system'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：Unity UI（uGUI）系统中的可渲染UI元素
- en: Every one of the UI items highlighted in the preceding screenshot is a renderable
    UI item and must be contained within a Canvas to render. If you try to add any
    of those UI elements to a scene that does not contain a Canvas, a Canvas will
    automatically be added to the scene, and the item you attempted to create will
    be made a child of the newly added Canvas. To demonstrate this, try adding a new
    **UI Text** element to an empty scene. You can do so by selecting **+** | **UI**
    | **Text**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中所突出的每个UI项目都是一个可渲染的UI项目，并且必须包含在一个画布中才能进行渲染。如果你尝试将任何这些UI元素添加到一个不包含画布的场景中，系统会自动添加一个画布到场景中，并且你尝试创建的项目将成为新添加的画布的子元素。为了演示这一点，尝试向一个空场景添加一个新的**UI
    Text**元素。你可以通过选择**+** | **UI** | **Text**来实现。
- en: 'This will cause three new items to appear in the Hierarchy list: `Canvas`,
    `Text`, and `EventSystem`, where the Text is a child of the Canvas.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Hierarchy列表中产生三个新项目：`Canvas`、`Text`和`EventSystem`，其中Text是Canvas的子元素。
- en: '![Figure 6.2: The result of adding a UI Text element to the scene](img/Figure_06.02_B18327.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：将UI文本元素添加到场景后的结果](img/Figure_06.02_B18327.jpg)'
- en: 'Figure 6.2: The result of adding a UI Text element to the scene'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：将UI文本元素添加到场景后的结果
- en: Now that you have a Canvas in your scene, any new UI elements you add to the
    scene will automatically be added to this Canvas.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你场景中已经有了画布，任何添加到场景中的新UI元素都将自动添加到这个画布中。
- en: Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you try to take a renderable UI element out of a Canvas, it will not be drawn
    to the scene.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试将可渲染的UI元素从Canvas中移除，它将不会绘制到场景中。
- en: You can also create an empty Canvas by selecting `EventSystem` GameObject does
    not already exist within the scene, one will automatically be created for you
    (as you saw in the preceding screenshot). We’ll discuss the `EventSystem` GameObject
    further in [*Chapter 8*](B18327_08.xhtml#_idTextAnchor147), but for now, all you
    really need to know is the `EventSystem` allows you to interact with the UI items.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过选择`EventSystem` GameObject（场景中尚未存在）来创建一个空的Canvas，一个将自动为你创建（正如你在前面的截图中所看到的）。我们将在[*第8章*](B18327_08.xhtml#_idTextAnchor147)中进一步讨论`EventSystem`
    GameObject，但就目前而言，你真正需要知道的是`EventSystem`允许你与UI项目进行交互。
- en: Note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can have more than one Canvas in your scene, each with its own children.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在场景中拥有多个Canvas，每个都有自己的子组件。
- en: 'When you create a Canvas, it will appear as a large rectangle within your scene.
    It will be significantly larger than that rectangle representing the camera’s
    view:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个Canvas时，它将作为场景中的一个大型矩形出现。它将比代表摄像机视图的矩形大得多：
- en: '![Figure 6.3: The renderable UI elements within the Unity UI (uGUI) system](img/Figure_06.03_B18327.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3：Unity UI（uGUI）系统中的可渲染UI元素](img/Figure_06.03_B18327.jpg)'
- en: 'Figure 6.3: The renderable UI elements within the Unity UI (uGUI) system'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：Unity UI（uGUI）系统中的可渲染UI元素
- en: The Canvas is larger than the Camera because the Canvas component has a scaling
    mode on it. The scaling mode by default equates to one pixel within the UI to
    one Unity unit, so it’s a lot bigger. A nice consequence of this large size is
    that it is really easy to see your UI items as a somewhat separate entity, and
    this keeps it from cluttering up your camera view.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas比摄像机大，因为Canvas组件上有一个缩放模式。默认情况下，缩放模式将UI中的每个像素等同于一个Unity单位，所以它要大得多。这个大尺寸的一个好结果是，它真的很容易将UI项目作为一个相对独立的实体看到，这有助于避免它弄乱你的摄像机视图。
- en: 'Every newly created Canvas automatically comes with four components: **Rect
    Transform**, **Canvas**, **Canvas Scaler**, and **Graphic Raycaster**, as shown
    in the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新创建的Canvas都自动包含四个组件：**Rect Transform**、**Canvas**、**Canvas Scaler**和**Graphic
    Raycaster**，如下面的截图所示：
- en: '![Figure 6.4: The components of a Canvas GameObject](img/Figure_06.04_B18327.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4：Canvas GameObject的组件](img/Figure_06.04_B18327.jpg)'
- en: 'Figure 6.4: The components of a Canvas GameObject'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：Canvas GameObject的组件
- en: Let’s explore each of these components.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这些组件中的每一个。
- en: Rect Transform component
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rect Transform组件
- en: Every Unity UI GameObject has a **Rect Transform** component as its first component.
    This component is very similar to the **Transform** component on non-UI GameObjects
    in that it allows you to place the object within the scene.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Unity UI GameObject都包含一个作为其第一个组件的**Rect Transform**组件。这个组件与非UI GameObject上的**Transform**组件非常相似，因为它允许你在场景中放置对象。
- en: You’ll note that when you first place a Canvas in the scene, you can’t adjust
    the values within the **Rect Transform**, and there is a message stating, **“Some
    values driven by Canvas”**, as shown in the preceding screenshot. This message
    means you cannot control the position of the Canvas because the properties selected
    in the **Canvas** component determine them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当你第一次将Canvas放置在场景中时，你无法调整**Rect Transform**中的值，并且会看到一个消息，**“某些值由Canvas驱动”**，如前面的截图所示。这个消息意味着你不能控制Canvas的位置，因为**Canvas**组件中选择的属性决定了它们。
- en: When a Canvas component has its **Render Mode** set to **Screen Space-Overlay**
    or **Screen Space-Camera**, the adjustment of the **Rect Transform** component’s
    values is disabled. In these two modes, the values are determined by the resolution
    of the game display because the Canvas fills up the full-screen area. When the
    Canvas’ **Render Mode** is set to **World Space**, you can adjust the values as
    you see fit, as this component will then determine its location within the scene.
    We will discuss how to use the **Rect Transform** Component more thoroughly later
    in this chapter, but for now, let’s review the Canvas component and the various
    render modes more thoroughly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当Canvas组件的**Render Mode**设置为**Screen Space-Overlay**或**Screen Space-Camera**时，**Rect
    Transform**组件值的调整被禁用。在这两种模式下，值由游戏显示的分辨率确定，因为Canvas填充了全屏区域。当Canvas的**Render Mode**设置为**World
    Space**时，你可以根据需要调整值，因为该组件将确定其在场景中的位置。我们将在本章后面更详细地讨论如何使用**Rect Transform**组件，但就目前而言，让我们更深入地回顾Canvas组件和不同的渲染模式。
- en: Canvas component
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Canvas组件
- en: 'The **Canvas** component allows you to select the Canvas **Render Mode** from
    a dropdown. There are three render modes: **Screen Space-Overlay**, **Screen Space-Camera**,
    and **World Space**. The different render modes determine where in the scene the
    UI elements will be drawn and how the **Rect Transform** component will be used.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**画布**组件允许你从下拉菜单中选择画布**渲染模式**。有三种渲染模式：**屏幕空间叠加**、**屏幕空间-相机**和**世界空间**。不同的渲染模式决定了场景中的UI元素将在哪里绘制以及如何使用**矩形变换**组件。'
- en: When developing your UI, the first thing you should always do is appropriately
    set your Canvas’ render mode based on your needs. If you have multiple Canvases
    in your scene, they can each have a different render mode. Changing the render
    mode will change the properties available on the Canvas component. Let’s review
    the purpose of each of the render modes and the properties that come with them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发你的UI时，你应该首先始终适当地根据你的需求设置画布的渲染模式。如果你的场景中有多个画布，它们可以各自有不同的渲染模式。更改渲染模式将更改画布组件上的属性。让我们回顾每种渲染模式的目的以及与之相关的属性。
- en: Screen Space-Overlay
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕空间叠加
- en: '**Screen Space-Overlay** is the default render mode. If you are asked to think
    of a video game UI, it’s highly likely that you will envision one rendered in
    **Screen Space-Overlay**. This render mode overlays all the UI elements within
    the Canvas in front of everything in the scene as if it is drawn on top of the
    screen. So, UI items like **heads-up-displays** (**HUDs**) and pop-up windows
    that appear on the same plane as the screen will be contained within a **Screen**
    **Space-Overlay Canvas**.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**屏幕空间叠加**是默认的渲染模式。如果你被要求思考一个视频游戏UI，你很可能想象的是一个在**屏幕空间叠加**中渲染的UI。这种渲染模式将画布内的所有UI元素叠加在场景中的所有元素之前，就像它是在屏幕上绘制的一样。因此，像**抬头显示**（**HUDs**）和出现在屏幕同一平面的弹出窗口这样的UI项目将被包含在**屏幕空间叠加**画布中。'
- en: Remember, when a Canvas is using the **Screen Space-Overlay** render mode, you
    cannot adjust the **Rect Transform** component of the Canvas. This is because
    the canvas will automatically resize based on the size of the screen (not the
    camera).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当画布使用**屏幕空间叠加**渲染模式时，你无法调整画布的**矩形变换**组件。这是因为画布将根据屏幕的大小（而不是相机）自动调整大小。
- en: '![Figure 6.5: Screen Space – Overlay Render Mode properties](img/Figure_06.05_B18327.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5：屏幕空间 – 堆叠渲染模式属性](img/Figure_06.05_B18327.jpg)'
- en: 'Figure 6.5: Screen Space – Overlay Render Mode properties'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：屏幕空间 – 堆叠渲染模式属性
- en: 'When you have **Screen Space-Overlay** selected, the following properties become
    available:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择了**屏幕空间叠加**时，以下属性将变得可用：
- en: '**Pixel Perfect**: Selecting this check box will cause the elements rendered
    in the Canvas to line up with pixels. It can make the UI elements appear sharper
    and less blurry. This can cause performance issues, so only use it if absolutely
    necessary.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**像素完美**：选择此复选框将使画布中渲染的元素与像素对齐。它可以使UI元素看起来更清晰，模糊度更低。这可能会引起性能问题，因此只有在绝对必要时才使用它。'
- en: '**Sort Order**: This option will determine the order in which all the **Screen
    Space-Overlay** Canvases in your scene will render. You can think of it as a stacking
    order. The higher the number, the *closer* the items within the Canvas will appear
    to the person viewing the scene. In other words, higher sort order numbered canvases
    will appear *on top* of lower sort order numbered canvases.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序顺序**：此选项将确定场景中所有**屏幕空间叠加**画布渲染的顺序。你可以将其视为堆叠顺序。数字越高，画布内项目对观看场景的人看起来就越**靠近**。换句话说，排序顺序编号较高的画布将出现在排序顺序编号较低的画布之上。'
- en: '**Target Display**: If you are creating a PC, Mac, Linux Standalone game, you
    can have different cameras display on up to eight different monitors. You can
    also have different UI for each monitor. This is where you will tell the Canvas
    which of the displays it will render on.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标显示**：如果你正在创建PC、Mac、Linux独立游戏，你可以让不同的相机显示在多达八个不同的显示器上。你也可以为每个显示器设置不同的UI。这就是你将告诉画布它将在哪个显示上渲染的地方。'
- en: '**Additional Shader Channels**: Shaders are essentially algorithms that describe
    the color of a GameObject based on light and material. Each Canvas automatically
    includes the following shader channels: Position, Color, and Uv0\. However, this
    property lets you add additional channels. Shaders are a pretty complicated topic,
    so we won’t spend a lot of time discussing them in this text. In **Screen Space-Overlay**
    mode, not all of the channels available in the dropdown menu work, and you’ll
    see a message in the component describing which are not working.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**附加着色器通道**: 着色器本质上是一种算法，它根据光线和材质描述GameObject的颜色。每个画布自动包含以下着色器通道：位置、颜色和Uv0。然而，这个属性允许你添加额外的通道。着色器是一个相当复杂的话题，所以我们不会在本文本中花费太多时间讨论它们。在**屏幕空间-叠加**模式下，下拉菜单中并非所有可用的通道都有效，你会在组件中看到一个消息，说明哪些通道不起作用。'
- en: Next, let’s look at **Screen** **Space Camera**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看**屏幕空间相机**。
- en: Screen Space-Camera
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕空间-相机
- en: '**Screen Space-Camera** performs similarly to **Screen Space-Overlay**, but
    it renders all UI elements as if they are a specific distance away from the camera.
    As you can see from the following screenshot, if there is no **Render Camera**
    selected, this render mode works exactly like the **Screen Space-Overlay** mode
    (as indicated by the warning message):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**屏幕空间-相机**的表现与**屏幕空间-叠加**类似，但它将所有UI元素渲染成好像它们与相机有一定距离。正如你从下面的截图中所见，如果没有选择**渲染相机**，这种渲染模式的工作方式与**屏幕空间-叠加**模式完全相同（如警告信息所示）：'
- en: '![Figure 6.6: Warning message for Screen Space – Camera Render Mode](img/Figure_06.06_B18327.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6：屏幕空间 – 相机渲染模式的警告信息](img/Figure_06.06_B18327.jpg)'
- en: 'Figure 6.6: Warning message for Screen Space – Camera Render Mode'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：屏幕空间 – 相机渲染模式的警告信息
- en: 'You can assign any camera in your scene to the **Render Camera** in the **Screen
    Space-Camera** render mode. This is the camera to which the canvas will draw.
    Once you add a camera to the **Render Camera** slot, the warning message will
    disappear, and new options will be made available to you, as shown in the following
    screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将场景中的任何相机分配到**屏幕空间-相机**渲染模式中的**渲染相机**。这是画布将要绘制的相机。一旦你将一个相机添加到**渲染相机**槽中，警告信息就会消失，并且会提供新的选项，如下面的截图所示：
- en: '![Figure 6.7: Screen Space – Camera Render Mode properties](img/Figure_06.07_B18327.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7：屏幕空间 – 相机渲染模式属性](img/Figure_06.07_B18327.jpg)'
- en: 'Figure 6.7: Screen Space – Camera Render Mode properties'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7：屏幕空间 – 相机渲染模式属性
- en: 'When you have **Screen Space-Camera** selected, the following properties become
    available:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择了**屏幕空间-相机**时，以下属性将变得可用：
- en: '**Pixel Perfect**: This is the same option as with **Screen Space-Overlay**.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**像素完美**: 这与**屏幕空间-叠加**中的选项相同。'
- en: '**Render Camera**: As stated earlier, this is the camera to which the canvas
    will draw.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染相机**: 如前所述，这是画布将要绘制的相机。'
- en: '**Plane Distance**: This property tells the Canvas how far away from the camera
    it should display.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平面距离**: 这个属性告诉画布它应该显示在相机多远的位置。'
- en: '**Sorting Layer**: This property allows you to choose which **Sprite Sorting
    Layer** to display the Canvas with.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序层**: 这个属性允许你选择要使用哪个**精灵排序层**来显示画布。'
- en: '**Order in Layer**: This property determines the order in the **Sprite Sorting
    Layer** (chosen earlier) that the Canvas will display. This order works similar
    to the way **Sort Order** works, with higher numbers appearing on top of lower
    numbers.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层内顺序**: 这个属性决定了画布在之前选择的**精灵排序层**中的显示顺序。这个顺序与**排序顺序**的工作方式类似，数值较高的元素会显示在数值较低的元素之上。'
- en: '**Additional Shader Channels**: This property works as it does in **Screen
    Space-Overlay**.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**附加着色器通道**: 这个属性在**屏幕空间-叠加**中的工作方式相同。'
- en: This rendering mode is helpful if you want a Canvas to render from a different
    perspective than that of your main camera. It is also helpful for creating a static
    background that will consistently scale with the camera in a 2D game. Since you
    can use **Sprite Sorting Layer** with this rendering mode, you can make sure the
    Canvas containing the background always renders behind all other objects in the
    scene.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种渲染模式在你想要画布从与主相机不同的视角渲染时很有用。它还有助于创建一个会与相机一起一致缩放的静态背景，这在2D游戏中很有用。由于你可以使用**精灵排序层**与这种渲染模式一起使用，你可以确保包含背景的画布始终在场景中的所有其他对象之后渲染。
- en: Remember, when a Canvas is using the **Screen Space-Camera** render mode, you
    cannot adjust the **Rect Transform** component of the Canvas. This is because
    the canvas will automatically resize based on the size of the camera (not the
    screen).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当画布使用**屏幕空间-相机**渲染模式时，你不能调整画布的**矩形变换**组件。这是因为画布将根据相机的尺寸（而不是屏幕）自动调整大小。
- en: World Space
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 世界空间
- en: The last rendering mode is **World Space**. This mode allows you to render UI
    elements as if they are physically positioned within the world.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的渲染模式是**世界空间**。此模式允许你将UI元素渲染成仿佛它们在物理世界中定位。
- en: In **Screen Space-Overlay** and **Screen Space-Camera**, you cannot adjust the
    properties of the **Rect Transform** component. The positions of UI elements within
    Canvases with those two rendering modes do not translate to world space coordinates
    and are instead relative to the screen and camera. However, when a Canvas is in
    **World Space** render mode, the values of the **Rect Transform** can be adjusted
    because the coordinates of the UI elements are based on actual positions within
    the scene. These Canvases do not have to face a specified camera as the other
    two Canvas types do.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在**屏幕空间-叠加**和**屏幕空间-相机**中，你不能调整**矩形变换**组件的属性。具有这两种渲染模式的画布中UI元素的定位不转换为世界空间坐标，而是相对于屏幕和相机。然而，当画布处于**世界空间**渲染模式时，可以调整**矩形变换**的值，因为UI元素的坐标基于场景中的实际位置。这些画布不需要像其他两种画布类型那样面对指定的相机。
- en: '![Figure 6.8: Render Mode – World Space properties](img/Figure_06.08_B18327.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8：渲染模式 – 世界空间属性](img/Figure_06.08_B18327.jpg)'
- en: 'Figure 6.8: Render Mode – World Space properties'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：渲染模式 – 世界空间属性
- en: This mode requests an **Event Camera**, rather than a **Rendering Camera** as
    **Screen Space-Camera** mode requested. An **Event Camera** is different than
    a **Rendering Camera**. Since this Canvas is in the **World Space**, it will be
    rendered with the **Main Camera**, just as all the other objects that exist within
    the scene. The **Event Camera** is the camera that will receive events from the
    EventSystem. So, if items on this Canvas require interactions, you have to include
    an **Event Camera**. If the player won’t be interacting with the items on the
    Canvas, you can leave this blank.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式请求一个**事件相机**，而不是像**屏幕空间-相机**模式请求的**渲染相机**。**事件相机**与**渲染相机**不同。由于此画布位于**世界空间**，它将与**主相机**一起渲染，就像场景中存在的所有其他对象一样。**事件相机**是接收来自EventSystem事件的相机。因此，如果画布上的项目需要交互，你必须包含一个**事件相机**。如果玩家不会与画布上的项目交互，你可以将其留空。
- en: The reason you need to specify an **Event Camera** is ray casting. When the
    user clicks on or touches the screen, a ray (one-directional line) is cast infinitely
    forward from the point of click (or touch) into the scene. The direction it points
    is determined by the direction the camera is facing. Most of the time, you will
    set this as your **Main Camera** because that is the direction in which the player
    will expect the events to occur.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要指定一个**事件相机**的原因是光线投射。当用户点击或触摸屏幕时，从点击（或触摸）点向场景无限延伸一条射线（单向线）。射线的方向由相机的朝向决定。大多数情况下，你会将其设置为**主相机**，因为玩家会期望事件发生在这个方向上。
- en: 'When you have **World Space** selected, the following properties become available:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择**世界空间**时，以下属性变为可用：
- en: '**Event Camera**: As stated earlier, the camera assigned to this slot determines
    which camera will receive the events of the Canvas'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件相机**：如前所述，分配给此槽位的相机决定了哪个相机将接收画布的事件'
- en: '**Sorting Layer**: This property is the same as in **Screen Space-Camera**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序层**：此属性与**屏幕空间-相机**相同'
- en: '**Order in Layer**: This property is the same as in **Screen Space-Camera**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层顺序**：此属性与**屏幕空间-相机**相同'
- en: '**Additional Shader Channels**: This property works as it does in **Screen
    Space-Overlay**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**附加着色器通道**：此属性与**屏幕空间-叠加**中的工作方式相同'
- en: Next, let us look at the **Canvas** **Scalar** component.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看**画布** **标量**组件。
- en: Canvas Scalar component
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 画布标量组件
- en: The **Canvas Scalar** component determines how the items within the canvas will
    scale. It also determines the pixel density of the items within the UI Canvas.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**画布标量**组件决定了画布内项目如何缩放。它还决定了UI画布内项目的像素密度。'
- en: In [*Chapter 1*](B18327_01.xhtml#_idTextAnchor014), we discussed how to build
    your game at a single resolution or a single aspect ratio. However, most of the
    time, you will not have the luxury of choosing the resolution or aspect ratio
    of your game. You’ll note that I only mentioned specifying the aspect ratio and
    resolution for the PC, Mac, and Linux Standalone builds and the WebGL builds.
    When you build to something that will play on a handheld screen or a TV screen,
    you cannot guarantee how big that screen will be.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B18327_01.xhtml#_idTextAnchor014)中，我们讨论了如何在单个分辨率或单个纵横比下构建您的游戏。然而，大多数时候，您不会有选择游戏分辨率或纵横比的自由。请注意，我只提到了为PC、Mac和Linux独立构建以及WebGL构建指定纵横比和分辨率。当您构建将在手持屏幕或电视屏幕上播放的内容时，您无法保证屏幕的大小。
- en: Due to the fact that you cannot guarantee the resolution or aspect ratio of
    your game, the need for your UI to adjust to various resolutions and scaling is
    very important; that’s why this **Canvas Scalar** component exists.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您无法保证游戏的分辨率或纵横比，因此您的UI需要调整以适应各种分辨率和缩放，这一点非常重要；这就是为什么存在这个**画布标量**组件的原因。
- en: 'The **Canvas Scalar** component has four **UI** **Scale Modes**:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**画布标量**组件有四个**UI**缩放模式：'
- en: '**Constant** **Pixel Size**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固定** **像素大小**'
- en: '**Scale With** **Screen Size**'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根据屏幕大小缩放**'
- en: '**Constant** **Physical Size**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固定** **物理大小**'
- en: '**World**'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**世界**'
- en: The first three **UI Scale Modes** are available when the Canvas **Render Mode**
    is set to **Screen Space-Overlay** or **Screen Space-Camera**. The fourth **UI
    Scale Mode** is automatically assigned when the Canvas **Render Mode** is set
    to **World Space** (it cannot be changed when set).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当画布**渲染模式**设置为**屏幕空间-叠加**或**屏幕空间-相机**时，前三个**UI缩放模式**可用。当画布**渲染模式**设置为**世界空间**时，自动分配第四个**UI缩放模式**（设置后不能更改）。
- en: Constant Pixel Size
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 固定像素大小
- en: When a Canvas has the **UI Scale Mode** set to **Constant Pixel Size**, every
    item in the UI will maintain its original pixel size regardless of the size of
    the screen. You’ll note that this is the default setting, so by default UI does
    not scale; you must turn the setting on for it to scale by altering screen resolutions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当画布的**UI缩放模式**设置为**固定像素大小**时，UI中的每个项目都将保持其原始像素大小，无论屏幕大小如何。您会注意到这是默认设置，因此默认情况下UI不会缩放；您必须通过更改屏幕分辨率来启用设置才能使其缩放。
- en: '![Figure 6.9: Constant Pixel Size UI Scale Mode properties](img/Figure_06.09_B18327.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9：固定像素大小UI缩放模式属性](img/Figure_06.09_B18327.jpg)'
- en: 'Figure 6.9: Constant Pixel Size UI Scale Mode properties'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：固定像素大小UI缩放模式属性
- en: 'When you change the **UI Scale Mode** to **Constant Pixel Size**, you will
    see the following properties appear within the inspector:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将**UI缩放模式**更改为**固定像素大小**时，您将在检查器中看到以下属性：
- en: '`2`, everything within the UI will then double in size. If you set this number
    to `0.5`, all items will have their size halved.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`，UI中的所有内容将加倍。如果您将此数字设置为`0.5`，所有项目的大小将减半。'
- en: '`100`, that means two objects that are one game unit apart from each other
    will be 100 pixels apart. Put another way, if two objects are at the same *y-*coordinate,
    but one object has an *x-*coordinate of `1`, and the other has an *x-*coordinate
    of `2`, they are exactly 100 pixels apart. This property works the same way in
    all other modes, so I will not discuss it in the next sections.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`100`，这意味着两个相隔一个游戏单位的对象将相距100像素。换句话说，如果两个对象在相同的*y-*坐标上，但一个对象的*x-*坐标为`1`，另一个对象的*x-*坐标为`2`，它们正好相距100像素。这个属性在所有其他模式中都以相同的方式工作，因此我将在下一节中不讨论它。'
- en: Scale With Screen Size
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根据屏幕大小缩放
- en: When you have the **Canvas Scalar** component set to **Scale with Screen Size**,
    UI elements on the Canvas will scale based on a **Reference Resolution**. If the
    screen is larger or smaller than the **Reference Resolution** value, the items
    on the Canvas will then scale up or down accordingly. In [*Chapter 1*](B18327_01.xhtml#_idTextAnchor014),
    I told you that you should decide on a default resolution that represents the
    ideal resolution of your UI design. This default resolution will be the **Reference
    Resolution**.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将**画布标量**组件设置为**根据屏幕大小缩放**时，画布上的UI元素将根据**参考分辨率**进行缩放。如果屏幕比**参考分辨率**值大或小，画布上的项目将相应地放大或缩小。在[*第1章*](B18327_01.xhtml#_idTextAnchor014)中，我告诉您应该决定一个代表您UI设计理想分辨率的默认分辨率。这个默认分辨率将是**参考分辨率**。
- en: '![Figure 6.10: Scale With Screen Size UI Scale Mode properties](img/Figure_06.10_B18327.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图6.10：根据屏幕大小缩放的UI缩放模式属性](img/Figure_06.10_B18327.jpg)'
- en: 'Figure 6.10: Scale With Screen Size UI Scale Mode properties'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：根据屏幕尺寸缩放的UI缩放模式属性
- en: If the aspect ratio of your screen matches the **Reference Resolution** value,
    then things will scale up and down without any problems. If it does not match,
    then you need to use the **Canvas Scalar** component to define how items will
    scale if the aspect ratio changes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的屏幕纵横比与**参考分辨率**值匹配，那么事物将无问题地缩放和缩小。如果不匹配，那么你需要使用**画布缩放器**组件来定义如果纵横比发生变化，项目将如何缩放。
- en: 'This can be done by using the **Screen Match Mode** settings. In the following
    list are the three different **Screen Match Modes** that determine how the Canvas
    will scale if the game’s aspect ratio does not match the **Reference Resolution**
    aspect ratio:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用**屏幕匹配模式**设置来实现。以下列出了三种不同的**屏幕匹配模式**，它们决定了如果游戏的纵横比与**参考分辨率**的纵横比不匹配时，画布将如何缩放：
- en: '**Match Width Or Height**: This will scale the UI with respect to the reference
    height or the reference width. It can also scale based on a combination of both.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匹配宽度和高度**: 这将根据参考高度或参考宽度缩放UI。它也可以根据两者的组合进行缩放。'
- en: '**Expand**: If the screen is smaller than the **Reference Resolution**, the
    canvas will be expanded to match that of the **Reference Resolution**.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展**: 如果屏幕尺寸小于**参考分辨率**，画布将被扩展以匹配**参考分辨率**。'
- en: '**Shrink**: If the screen gets larger than the **Reference Resolution**, the
    canvas will be reduced to match that of the **Reference Resolution**.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩小**: 如果屏幕尺寸大于**参考分辨率**，画布将被缩小以匹配**参考分辨率**。'
- en: The `0` (`1` (**Height**).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`0` (`1` (**高度**).'
- en: '![Figure 6.11: Scale With Screen Size UI Scale Mode properties](img/Figure_06.11_B18327.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图6.11：根据屏幕尺寸缩放的UI缩放模式属性](img/Figure_06.11_B18327.jpg)'
- en: 'Figure 6.11: Scale With Screen Size UI Scale Mode properties'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：根据屏幕尺寸缩放的UI缩放模式属性
- en: When the value of `0`, the **Canvas Scaler** will force the Canvas to always
    have the same width specified by the **Reference Resolution**. This will maintain
    the relative scales and positions of objects along the width of the Canvas. So,
    objects will not get further away from or closer to each other in the horizontal
    direction. However, it will completely ignore the height. So, objects can get
    further from or closer to each other in the vertical direction.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当`0`的值为时，**画布缩放器**将强制画布始终具有由**参考分辨率**指定的相同宽度。这将保持画布宽度方向上对象的相对缩放和位置。因此，对象在水平方向上不会彼此远离或靠近。然而，它将完全忽略高度。因此，对象可以在垂直方向上彼此远离或靠近。
- en: Setting the `1` will accomplish the same thing but will maintain the positions
    and scales of the objects along the height, not the width.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`1`将完成相同的事情，但将保持对象沿高度而不是宽度的位置和缩放。
- en: Setting the `0.5` will compare the game’s width and height to that of **Reference
    Resolution**, and it will try to maintain the distances between objects in both
    the horizontal and vertical directions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`0.5`将比较游戏宽度和高度与**参考分辨率**，并且它将尝试保持水平和垂直方向上对象之间的距离。
- en: The `0` and `1`. If the number is closer to `1`, scaling will favor the height,
    and if it is closer to `0`, it will favor the width.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`0`和`1`。如果数字接近`1`，缩放将优先考虑高度，如果接近`0`，则优先考虑宽度。'
- en: None of these `1`). If you want the relative horizontal positions to be maintained,
    use `0`). It really just depends on which spacing you care the most about.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`1`)。如果你想保持相对水平位置不变，请使用`0`)。这实际上完全取决于你最关心的哪种间距。
- en: 'I recommend using the following settings based on the orientation of your game:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议根据你游戏的朝向使用以下设置：
- en: '| **Orientation** | **Match Value** |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **方向** | **匹配值** |'
- en: '| **Portrait** | `0` (Width) |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **肖像** | `0` (宽度) |'
- en: '| **Landscape** | `1` (Height) |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **横幅** | `1` (高度) |'
- en: '| **Varies** | `0.5` (Width and Height) |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| **变化** | `0.5` (宽度和高度) |'
- en: 'Table 6.1: Orientation and Match Value'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1：方向和匹配值
- en: I chose these settings based on whichever of the two numbers on the **Reference
    Resolution** is the smallest. In **Portrait** mode, the width will be the smallest,
    so I find it important to maintain the relative position of the items in the width.
    This is a personal preference and just a recommendation, and it will not necessarily
    make sense for all games. However, I have found it to be a good rule of thumb
    for most games.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择这些设置是基于**参考分辨率**中两个数字中较小的一个。在**肖像**模式下，宽度将是最小的，因此我认为保持项目在宽度上的相对位置很重要。这是一个个人偏好，仅作为一个建议，并且不一定适用于所有游戏。然而，我发现这对于大多数游戏来说是一个很好的经验法则。
- en: It is best to avoid making games that will vary between portrait and landscape
    mode unless you have minimal UI or are very comfortable with creating scalable
    UI.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最好避免制作在肖像模式和横幅模式之间变化的游戏，除非你有最小的UI或者非常熟悉创建可缩放UI。
- en: Constant Physical Size
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常数物理大小
- en: When a Canvas has the **UI Scale Mode** set to **Constant Physical Size**, every
    item in the UI will maintain its original physical size, regardless of the size
    of the screen. Physical size references the size that will appear to the user
    if they were to take out a ruler and measure it on their screen. Much like **Constant
    Pixel Size**, items on Canvases with this **UI Scale Mode** setting will not scale.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当画布的**UI缩放模式**设置为**常数物理大小**时，UI中的每个项目都将保持其原始的物理大小，无论屏幕的大小如何。物理大小是指用户如果拿出尺子并在屏幕上测量它时将看到的尺寸。与**常数像素大小**类似，具有此**UI缩放模式**设置的画布上的项目将不会缩放。
- en: If you had a UI item that you wanted to always be a specific width and height,
    you’d put it on a Canvas that has this **UI Scale Mode**. For example, if you
    wanted a button to always be 2 inches wide and 1 inch tall, you’d use this mode.
    This is particularly helpful in mobile games, allowing you to make sure buttons
    are sized large enough for human fingers based on the recommendations we discussed
    in [*Chapter 4*](B18327_04.xhtml#_idTextAnchor054).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个希望始终具有特定宽度和高度的UI项目，你可以在具有此**UI缩放模式**的画布上放置它。例如，如果你希望一个按钮始终宽2英寸、高1英寸，你会使用此模式。这在移动游戏中尤其有用，可以确保按钮的大小足够大，以便人类手指根据我们在[*第4章*](B18327_04.xhtml#_idTextAnchor054)中讨论的建议进行操作。
- en: '![Figure 6.12: Scale with Constant Physical Size UI Scale Mode properties](img/Figure_06.12_B18327.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12：使用常数物理大小UI缩放模式属性进行缩放](img/Figure_06.12_B18327.jpg)'
- en: 'Figure 6.12: Scale with Constant Physical Size UI Scale Mode properties'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：使用常数物理大小UI缩放模式属性进行缩放
- en: 'When you change the **UI Scale Mode** to **Constant Physical Size**, you will
    see the following properties appear within the inspector:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将**UI缩放模式**更改为**常数物理大小**时，你将在检查器中看到以下属性：
- en: '**Physical** **Unit**: The unit of measure. You can select from **Centimeters**,
    **Millimeters**, **Inches**, **Points**, and **Picas**.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理单位**：计量单位。您可以选择**厘米**、**毫米**、**英寸**、**点**和**皮卡**。'
- en: '**Fallback Screen DPI**: If the DPI is unknown, this is the assumed DPI.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回退屏幕DPI**：如果DPI未知，则假定此DPI。'
- en: '**Default Sprite DPI**: The DPI of all sprites with Pixels Per Unit that are
    equal to the **Reference Pixels Per** **Unit** value.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认精灵DPI**：所有具有与**参考每单位像素**值相等的每单位像素的精灵的DPI。'
- en: World
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 世界
- en: '**World** is the only **UI Scale Mode** available for Canvases set to **World
    Space**. You’ll see from the following screenshot that the mode cannot be changed:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**世界**是唯一适用于设置为**世界空间**的画布的**UI缩放模式**。从以下截图可以看出，模式不能更改：'
- en: '![Figure 6.13: Scale with World UI Scale Mode properties](img/Figure_06.13_B18327.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图6.13：使用世界UI缩放模式属性进行缩放](img/Figure_06.13_B18327.jpg)'
- en: 'Figure 6.13: Scale with World UI Scale Mode properties'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13：使用世界UI缩放模式属性进行缩放
- en: 'When you change the **UI Scale Mode** to **World**, you will see the following
    property appear within the inspector:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将**UI缩放模式**更改为**世界**时，你将在检查器中看到以下属性：
- en: '**Dynamic Pixels Per Unit**: This is the Pixels Per Unit setting for all dynamic
    UI items (such as text).'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态每单位像素**：这是所有动态UI项目（如文本）的每单位像素设置。'
- en: Graphic Raycaster component
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图形射线组件
- en: The **Graphic Raycaster** component allows you to check to see whether objects
    on the Canvas have been hit by a user input using the Event System. As discussed
    when looking at the **World Space** Canvas **Render Mode**, when a user touches
    the screen, a ray is cast forward from the point on the screen at which the player
    touches. The **Graphic Raycaster** checks these rays and sees if they hit something
    on the Canvas.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形射线投射器**组件允许您使用事件系统检查画布上的对象是否被用户输入击中。正如在查看**世界空间**画布**渲染模式**时讨论的那样，当用户触摸屏幕时，从玩家触摸的屏幕上的点向前发射一条射线。**图形射线投射器**检查这些射线，看它们是否击中了画布上的某个对象。'
- en: '![Figure 6.14: The Graphic Raycaster component](img/Figure_06.14_B18327.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图6.14：图形射线投射器组件](img/Figure_06.14_B18327.jpg)'
- en: 'Figure 6.14: The Graphic Raycaster component'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14：图形射线投射器组件
- en: 'You can adjust the following properties on the **Graphic** **Raycaster** component:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在**图形** **射线投射器**组件上调整以下属性：
- en: '**Ignore Reversed Graphics**: If a UI element is facing away from the player,
    having this selected will stop the hit from registering. If it is not selected,
    hits will register on back-facing UI objects.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**忽略反转图形**：如果UI元素背对玩家，选中此选项将阻止击中事件注册。如果没有选中，则击中事件将注册在背面的UI对象上。'
- en: '**Blocking Objects**: This setting specifies which types of items in front
    of it will block it from being hit. So, if you select **Two D**, any **Two D**
    object in front of the items on this Canvas will stop the items from being interacted
    with. However, 3D objects will not stop the interaction. The possible options
    are shown here:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遮挡对象**：此设置指定了哪些类型的物品在其前方会阻止它被击中。因此，如果您选择**二维**，则此画布前方任何**二维**对象都会阻止这些对象被交互。然而，3D对象不会阻止交互。可能的选项如下所示：'
- en: '![Figure 6.15: Graphics Raycaster Blocking Objects options](img/Figure_06.15_B18327.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图6.15：图形射线投射器遮挡对象选项](img/Figure_06.15_B18327.jpg)'
- en: 'Figure 6.15: Graphics Raycaster Blocking Objects options'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15：图形射线投射器遮挡对象选项
- en: '**Blocking Mask:** Selecting items on this property works similarly to the
    **Blocking Objects** property. This allows you to select items based on their
    Rendering Layer, so you can get a little more specific. The possible options are
    shown as follows:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遮挡掩码**：在此属性上选择项目的工作方式类似于**遮挡对象**属性。这允许您根据它们的渲染层选择项目，因此您可以更具体一些。可能的选项如下所示：'
- en: '![Figure 6.16: Graphics Raycaster Blocking Mask options](img/Figure_06.16_B18327.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图6.16：图形射线投射器遮挡掩码选项](img/Figure_06.16_B18327.jpg)'
- en: 'Figure 6.16: Graphics Raycaster Blocking Mask options'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16：图形射线投射器遮挡掩码选项
- en: We will discuss Raycasting and the Event System more thoroughly in [*Chapter
    8*](B18327_08.xhtml#_idTextAnchor147).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第8章*](B18327_08.xhtml#_idTextAnchor147)中更详细地讨论射线投射和事件系统。
- en: Canvas Renderer component
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 画布渲染器组件
- en: The **Canvas Renderer** component is not on a Canvas GameObject but on all renderable
    UI objects.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**画布渲染器**组件不在画布GameObject上，而是在所有可渲染UI对象上。'
- en: '![Figure 6.17: The Canvas Renderer component](img/Figure_06.17_B18327.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图6.17：画布渲染器组件](img/Figure_06.17_B18327.jpg)'
- en: 'Figure 6.17: The Canvas Renderer component'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17：画布渲染器组件
- en: 'For a UI element to render, it must have a **Canvas Renderer** component on
    it. All the renderable UI elements that you create via the **+** | **UI** menu
    will automatically have this component attached to them. If you try to remove
    this component, you will see a warning similar to the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使UI元素能够渲染，它必须在其上有一个**画布渲染器**组件。您通过**+** | **UI**菜单创建的所有可渲染UI元素都将自动附加此组件。如果您尝试移除此组件，您将看到类似于以下警告的信息：
- en: '![Figure 6.18: Warning message when you try to remove a Canvas Renderer component](img/Figure_06.18_B18327.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图6.18：尝试移除画布渲染器组件时的警告信息](img/Figure_06.18_B18327.jpg)'
- en: 'Figure 6.18: Warning message when you try to remove a Canvas Renderer component'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18：尝试移除画布渲染器组件时的警告信息
- en: In the preceding screenshot, I tried to remove the Canvas Renderer component
    from a Text UI object. As you can see, it will not let me remove the Canvas Renderer
    component because the Text component relies on it. If I return and remove the
    Text component, I would then be able to remove the Canvas Renderer component.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我尝试从一个文本UI对象中移除画布渲染器组件。如您所见，它不允许我移除画布渲染器组件，因为文本组件依赖于它。如果我返回并移除文本组件，然后我就能移除画布渲染器组件。
- en: The only property on the **Canvas Renderer** component is the **Cull Transparent
    Mesh** toggle. “To cull” means to not draw. So, this property states that the
    renderer will not draw any geometry that has its vertex color alpha at or close
    to 0.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**画布渲染器**组件上唯一的属性是**裁剪透明网格**切换。 “裁剪”意味着不绘制。因此，此属性表示渲染器将不会绘制任何顶点颜色alpha值为0或接近0的几何形状。'
- en: UI Panel
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI 面板
- en: The main function of **UI Panels** is to hold other UI elements. You can create
    a Panel by selecting **+** | **UI** | **Panel**. It’s important to note that there
    is no Panel component. Panels are really just GameObjects that have **Rect Transform**,
    **Canvas Renderer**, and **Image** components. So, really, a UI Panel is just
    a UI Image with a few properties predefined for it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**UI 面板**的主要功能是包含其他UI元素。您可以通过选择**+** | **UI** | **面板**来创建面板。需要注意的是，没有面板组件。面板实际上只是具有**矩形变换**、**画布渲染器**和**图像**组件的GameObject。因此，实际上，UI面板只是一个具有一些预定义属性的UI图像。'
- en: '![Figure 6.19: The components on a Panel GameObject](img/Figure_06.19_B18327.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.19：面板 GameObject 上的组件](img/Figure_06.19_B18327.jpg)'
- en: 'Figure 6.19: The components on a Panel GameObject'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.19：面板 GameObject 上的组件
- en: By default, Panels start with the **Background** Image (which is just a grey
    rounded rectangle) as the **Source Image** with medium opacity. You can replace
    the **Source Image** with another Image or remove the image entirely.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，面板以**背景**图像（只是一个灰色圆角矩形）作为**源图像**，具有中等不透明度。您可以替换**源图像**为另一个图像或完全删除图像。
- en: Panels are very useful when you are trying to ensure that items scale and are
    appropriately positioned relative to each other. Items that are contained within
    the same Panel will scale relative to the Panel and maintain their relative position
    to each other in the process.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当您试图确保项目按比例缩放并相对于彼此适当地定位时，面板非常有用。包含在同一个面板中的项目将相对于面板缩放，并在过程中保持彼此的相对位置。
- en: We will look at the **Image** component more thoroughly soon, but now that we
    are looking at an object that will allow us to edit its **Rect Transform** component,
    let›s explore that component.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快将更详细地查看**图像**组件，但现在我们正在查看一个允许我们编辑其**矩形变换**组件的对象，让我们来探索这个组件。
- en: Rect Transform
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩形变换
- en: Each UI element has a **Rect Transform** component. The **Rect Transform** component
    works very similarly to the **Transform** component and is used to determine the
    position of the object on which it is attached.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 每个UI元素都有一个**矩形变换**组件。**矩形变换**组件与**变换**组件非常相似，用于确定其附加对象的位置。
- en: Rect Tool
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩形工具
- en: Any of the Transform tools can be used to manipulate UI objects. However, the
    Rect Tool allows you to scale, move, and rotate any object by manipulating the
    rectangle that encompasses it. While this tool can be used with 3D objects, it
    is most useful for 2D and UI objects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用任何变换工具来操纵UI对象。然而，矩形工具允许您通过操纵包含对象的矩形来缩放、移动和旋转任何对象。虽然这个工具可以用于3D对象，但它对2D和UI对象最有用。
- en: '![Figure 6.20: The Rect Tool](img/Figure_06.20_B18327.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.20：矩形工具](img/Figure_06.20_B18327.jpg)'
- en: 'Figure 6.20: The Rect Tool'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.20：矩形工具
- en: To move an object with the Rect Tool, select the object and then click and drag
    inside the rectangle.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用矩形工具移动对象，选择对象然后点击并拖动在矩形内。
- en: To resize an object, hover over the edge or corner of an object. When the cursor
    changes to arrows, click and drag to resize the object. You can scale uniformly
    by holding down the *shift* button while dragging.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要调整对象的大小，将光标悬停在对象的边缘或角落。当光标变为箭头时，点击并拖动以调整对象的大小。在拖动时按住*shift*键可以均匀缩放。
- en: To rotate, hover at the corner of the objects--slightly outside of the rectangle
    until the cursor displays a rotating circle at its corner. You can then rotate
    by clicking and dragging.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要旋转对象，将光标悬停在对象的角落——稍微在矩形外面，直到光标在角落显示一个旋转的圆圈。然后可以通过点击和拖动来旋转。
- en: Positioning modes
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定位模式
- en: 'When using the Rect Tool, it is important that you have the correct positioning
    modes selected. You can select **Center** or **Pivot** and **Global** or **Local**.
    The modes will toggle by clicking on the buttons:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用矩形工具时，选择正确的定位模式非常重要。您可以选择**居中**或**锚点**以及**全局**或**本地**。模式可以通过点击按钮切换：
- en: '![Figure 6.21: The various positioning modes](img/Figure_06.21_B18327.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.21：各种定位模式](img/Figure_06.21_B18327.jpg)'
- en: 'Figure 6.21: The various positioning modes'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.21：各种定位模式
- en: When in **Center** mode, the object will move based on its center point and
    rotate around its center point.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处于**中心**模式时，对象将根据其中心点移动并围绕其中心点旋转。
- en: When in **Pivot** mode, the object will rotate around its pivot point rather
    than its center point. You can also alter the position of the pivot point in this
    mode by hovering over the pivot point and clicking and dragging to move.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处于**旋转**模式时，对象将围绕其旋转中心点旋转，而不是中心点。您还可以在此模式下通过悬停在旋转中心点上并点击拖动来改变旋转中心点的位置。
- en: When in **Global** mode, the Rect Transform’s bounding box will be a non-rotated
    box that encompasses the entire object.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处于**全局**模式时，矩形变换的边界框将是一个非旋转的框，包围整个对象。
- en: When in **Local** mode, the Rect Transform’s bounding box will be a rotated
    box that snuggly fits the object.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处于**本地**模式时，矩形变换的边界框将是一个旋转的框，紧密地适合对象。
- en: 'The following illustration shows the bounding boxes of the Rect Transform for
    a Panel in **Global** and **Local** modes. The empty blue circle represents the
    object’s pivot point:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图显示了**全局**和**本地**模式下面板的矩形变换的边界框。空心的蓝色圆圈代表对象的旋转中心点：
- en: '![Figure 6.22: Global mode vs. Local mode](img/Figure_06.22_B18327.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图6.22：全局模式与本地模式](img/Figure_06.22_B18327.jpg)'
- en: 'Figure 6.22: Global mode vs. Local mode'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22：全局模式与本地模式
- en: Next, let’s look at the **Rect** **Transform** component.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看**矩形** **变换**组件。
- en: Rect Transform component
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩形变换组件
- en: 'As stated earlier, UI elements do not have the standard **Transform** component;
    they have the **Rect Transform** component. If you compare it to a standard **Transform**
    component, you will see that it has quite a few more properties:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，UI元素没有标准的**变换**组件；它们有**矩形变换**组件。如果您将其与标准**变换**组件进行比较，您会发现它有相当多的属性：
- en: '![Figure 6.23: Transform vs. Rect Transform](img/Figure_06.23_B18327.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图6.23：变换与矩形变换](img/Figure_06.23_B18327.jpg)'
- en: 'Figure 6.23: Transform vs. Rect Transform'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.23：变换与矩形变换
- en: You can use it to change the position, rotation, and scale, just as you can
    with `1`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用它来改变位置、旋转和缩放，就像使用`1`一样。
- en: You may have noticed that the labels for the position and dimensional values
    are different in the preceding illustration than they are in the one provided
    in the *UI Panel Properties* section. This is because the labels that represent
    the position and dimension change depending on the Anchor Preset chosen. We’ll
    discuss how to use these Anchor Presets momentarily, but let’s look at some different
    examples of labels the position and dimensional values can hold.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，前一个插图中的位置和尺寸值的标签与*UI面板属性*部分提供的标签不同。这是因为表示位置和尺寸的标签会根据选择的锚点预设而改变。我们将稍后讨论如何使用这些锚点预设，但让我们看看位置和尺寸值可以持有的不同标签示例。
- en: '![Figure 6.24: Variation in Rect Transform properties](img/Figure_06.24_B18327.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图6.24：矩形变换属性的变化](img/Figure_06.24_B18327.jpg)'
- en: 'Figure 6.24: Variation in Rect Transform properties'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24：矩形变换属性的变化
- en: If the **Rect Transform** has its Anchor Preset set to not include stretch,
    as with the top-left example in the preceding screenshot, the values for position
    are determined by **Pos X**, **Pox Y**, **Pos Z**, and the dimensions are determined
    by **Width** and **Height**.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**矩形变换**的锚点预设设置为不包含拉伸，就像前一个屏幕截图中的左上角示例一样，位置值将由**Pos X**、**Pos Y**、**Pos Z**确定，尺寸由**宽度**和**高度**确定。
- en: If the **Rect Transform** has its Anchor Preset set to include stretch, as with
    the other three examples, the positions perpendicular to the stretch and the dimensions
    parallel to the stretch are labeled with **Left**, **Right**, **Top**, and **Bottom**.
    These values represent the offset from the border of the parent’s **Rect Transform**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**矩形变换**的锚点预设设置为包含拉伸，就像其他三个示例一样，垂直于拉伸的位置和与拉伸平行的尺寸将用**左**、**右**、**上**和**下**标记。这些值代表从父级**矩形变换**边界的偏移量。
- en: The **Anchor** point of an object determines the point from which all the relative
    positions are measured from. The **Pivot** point determines the point from which
    the scaling and rotating modifiers happen. It will rotate around this point and
    scale toward this point. We will look at Anchors and Pivots more thoroughly in
    the Anchors and Pivot section.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的**锚点**决定了所有相对位置测量的起点。**旋转中心点**决定了缩放和旋转修改发生的起点。它将围绕这个点旋转并朝向这个点缩放。我们将在“锚点和旋转中心点”部分更详细地探讨锚点和旋转中心点。
- en: Rect Transform edit modes
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩形变换编辑模式
- en: 'There are two different edit modes available to you within the **Rect Transform**
    component—Blueprint mode and Raw Edit mode—as represented by the following icons,
    respectively:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **矩形变换** 组件中，你可以使用两种不同的编辑模式——蓝图模式和原始编辑模式，分别由以下图标表示：
- en: '![Figure 6.25: Rect Transform edit modes](img/Figure_06.25_B18327.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.25：矩形变换编辑模式](img/Figure_06.25_B18327.jpg)'
- en: 'Figure 6.25: Rect Transform edit modes'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.25：矩形变换编辑模式
- en: 'The Blueprint mode will ignore any local rotation or scaling applied to it
    and will display the Rect Transform bounding box as a non-rotated, non-scaled
    box. The following screenshot shows the bounding box of a Panel that has been
    rotated and scaled with Blueprint mode turned off and turned on:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图模式将忽略对其应用的任何本地旋转或缩放，并将矩形变换边界框显示为非旋转、非缩放的框。以下截图显示了在关闭和开启蓝图模式时旋转和缩放的 Panel 的边界框：
- en: '![Figure 6.26: Blueprint mode on vs. Blueprint mode off](img/Figure_06.26_B18327.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.26：开启与关闭蓝图模式](img/Figure_06.26_B18327.jpg)'
- en: 'Figure 6.26: Blueprint mode on vs. Blueprint mode off'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.26：开启与关闭蓝图模式
- en: The Raw Edit mode will allow you to change the anchor and pivot points of a
    UI object without the object moving or scaling based on the changes you have made.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 原始编辑模式将允许你更改 UI 对象的锚点和枢轴点，而不会根据你所做的更改移动或缩放对象。
- en: Anchor and Pivot Points
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锚点和枢轴点
- en: Every UI object has Anchor Handles and a Pivot Point. When used together, they
    will help ensure that your UI is positioned appropriately and scales appropriately
    if the resolution or aspect ratio of your game changes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 UI 对象都有锚点手柄和枢轴点。当它们一起使用时，将有助于确保你的 UI 位置适当，并在游戏分辨率或纵横比发生变化时适当缩放。
- en: 'The Anchor Handles are represented by four triangles in the form of an X, as
    shown in the following diagram:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点手柄以 X 形状的四个三角形表示，如下所示：
- en: '![Figure 6.27: Anchor Handles and Pivot Points](img/Figure_06.27_B18327.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.27：锚点手柄和枢轴点](img/Figure_06.27_B18327.jpg)'
- en: 'Figure 6.27: Anchor Handles and Pivot Points'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.27：锚点手柄和枢轴点
- en: 'The Anchors can be in a group together forming a single Anchor, as shown in
    the preceding diagram, or they can be split into multiple Anchors, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点可以组合在一起形成一个单独的锚点，如图中所示，或者它们可以被分割成多个锚点，如下所示：
- en: '![Figure 6.28: Splitting Anchor Handles](img/Figure_06.28_B18327.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.28：分割锚点手柄](img/Figure_06.28_B18327.jpg)'
- en: 'Figure 6.28: Splitting Anchor Handles'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.28：分割锚点手柄
- en: The Anchors will always form a rectangle. So, the sides will always line up.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点将始终形成一个矩形。因此，边总是对齐的。
- en: 'The `0` in an *x* value moves the handles all the way to the left, and a `1`
    moves the handles all the way to the right. You can see from the following screenshots
    how adjusting the *x* value will move the anchor left and right relative to the
    parent:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *x* 值中的 `0` 将手柄移动到最左边，而 `1` 将手柄移动到最右边。你可以从以下屏幕截图看到调整 *x* 值如何相对于父元素移动锚点：
- en: '![Figure 6.29: Adjusting Anchor Min and Max](img/Figure_06.29_B18327.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.29：调整锚点最小和最大值](img/Figure_06.29_B18327.jpg)'
- en: 'Figure 6.29: Adjusting Anchor Min and Max'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.29：调整锚点最小和最大值
- en: 'The **Rect Transform** has properties for Anchor Presets and **Anchors** **Min**
    and **Max** points. The Anchor represents the point at which the UI element is
    connected to its parent’s Rect Transform:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**矩形变换**具有锚点预设和**最小**和**最大**锚点属性。锚点代表 UI 元素连接到其父矩形变换的点：'
- en: '![Figure 6.30: Accessing the Anchor Presets](img/Figure_06.30_B18327.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.30：访问锚点预设](img/Figure_06.30_B18327.jpg)'
- en: 'Figure 6.30: Accessing the Anchor Presets'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.30：访问锚点预设
- en: 'As a Canvas has no parent, you’ll see that the Anchor Preset area is empty.
    This is true regardless of the Canvas Render Mode chosen:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于画布没有父元素，你会看到锚点预设区域是空的。这无论选择哪种画布渲染模式都是正确的：
- en: '![Figure 6.31: Lack of Anchor Presets on a Canvas GameObject](img/Figure_06.31_B18327.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.31：画布游戏对象上缺少锚点预设](img/Figure_06.31_B18327.jpg)'
- en: 'Figure 6.31: Lack of Anchor Presets on a Canvas GameObject'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.31：画布游戏对象上缺少锚点预设
- en: 'Clicking on the Anchor Presets box will display a list of all the possible
    **Anchor Presets**, as shown in the following screenshot:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 点击锚点预设框将显示所有可能的 **锚点预设** 列表，如下所示截图：
- en: '![ Figure 6.32: All available Anchor Presents](img/Figure_06.32_B18327.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.32：所有可用的锚点预设](img/Figure_06.32_B18327.jpg)'
- en: 'Figure 6.32: All available Anchor Presents'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.32：所有可用的锚点预设
- en: If you click on one of the presets, it will move the anchors to the position
    displayed in the screenshot. You can also adjust the position and pivot point
    using the anchor preset.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击其中一个预设，它将移动锚点到截图显示的位置。你也可以使用锚点预设调整位置和轴心点。
- en: The images representing the presets will change if you hold down *Shift* and/or
    *Alt.* Holding *Shift* will show the positions for the pivot point represented
    by blue dots, holding *Alt* will show how the position will change, and holding
    both will show the pivot point and the position change.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按住 *Shift* 和/或 *Alt.*，表示预设的图像将改变。按住 *Shift* 将显示由蓝色点表示的轴心点的位置，按住 *Alt* 将显示位置如何变化，同时按住两者将显示轴心点和位置变化。
- en: '![Figure 6.33: Setting pivot and position](img/Figure_06.33_B18327.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.33：设置轴心和位置](img/Figure_06.33_B18327.jpg)'
- en: 'Figure 6.33: Setting pivot and position'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.33：设置轴心和位置
- en: Note
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If using a Mac, since there is no *Alt* key, you will use the *Option* key instead.
    However, the instructions will still say *Alt* in the Editor and this does not
    change for the Mac version. The previous screenshots were taken on a Mac, despite
    it having no *Alt* key.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 Mac，由于没有 *Alt* 键，你将使用 *Option* 键代替。然而，编辑器中的说明仍然会提到 *Alt*，并且这对于 Mac 版本没有变化。之前的截图是在
    Mac 上拍摄的，尽管它没有 *Alt* 键。
- en: Now, let’s look at the **Canvas** **Group** component.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 **Canvas** **组** 组件。
- en: Canvas Group component
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Canvas 组组件
- en: You can add a **Canvas Group** component to any UI object. Attaching it to a
    UI object will let you adjust the specific properties of the object as well as
    all of its children with a single component rather than having to adjust these
    properties for each of the UI elements.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 **Canvas 组** 组件添加到任何 UI 对象中。将其附加到 UI 对象将允许你使用单个组件调整对象的特定属性以及其所有子对象的属性，而不是必须为每个
    UI 元素调整这些属性。
- en: You can add a Canvas Group component to any UI object by selecting **Add Component**
    | **Layout** | **Canvas Group** (you can also just search for Canvas Group) from
    the UI object›s Inspector.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过选择 UI 对象的检查器中的 **添加组件** | **布局** | **Canvas 组**（你也可以直接搜索 Canvas 组）来将 Canvas
    组组件添加到任何 UI 对象中。
- en: '![Figure 6.34: The Canvas Group component](img/Figure_06.34_B18327.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.34：Canvas 组组件](img/Figure_06.34_B18327.jpg)'
- en: 'Figure 6.34: The Canvas Group component'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.34：Canvas 组组件
- en: 'You can adjust the following properties using a **Canvas** **Group** component:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 **Canvas** **组** 组件调整以下属性：
- en: '`0` and `1` and represents a percentage of opaqueness; `0` is completely transparent,
    while `1` is completely opaque.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 和 `1` 代表不透明度的百分比；`0` 是完全透明的，而 `1` 是完全不透明的。'
- en: '**Interactable**: This setting determines whether or not the objects within
    the group can accept input.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互性**：此设置确定组内的对象是否可以接受输入。'
- en: '**Blocks Raycasts**: This setting determines if the objects within the group
    will block raycasts from hitting things behind them.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻挡射线投射**：此设置确定组内的对象是否会阻挡射线投射到其后面的物体。'
- en: '**Ignore Parent Groups**: If this **Canvas Group** component is on a UI element
    that is a child of another UI element with a Canvas Group component, this property
    determines whether this Canvas Group will override the one above it or not. If
    it is selected, it will override the parent’s Canvas Group properties.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**忽略父组**：如果此 **Canvas 组** 组件位于具有 Canvas 组组件的另一个 UI 元素的子 UI 元素上，此属性确定此 Canvas
    组是否会覆盖上面的一个。如果选中，它将覆盖父级的 Canvas 组属性。'
- en: Introducing UI Text and Image
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 UI 文本和图像
- en: It’s kind of hard to make any UI examples without using text or images. So,
    before we cover examples of layouts, let’s first look at the basic properties
    of the UI Text and UI Image GameObjects. UI Text and UI Images are discussed more
    thoroughly in [*Chapter 11*](B18327_11.xhtml#_idTextAnchor292) and [*Chapter 12*](B18327_12.xhtml#_idTextAnchor328).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用文本或图像的情况下创建任何 UI 示例都有点困难。因此，在我们介绍布局示例之前，让我们首先看看 UI 文本和 UI 图像 GameObject
    的基本属性。UI 文本和 UI 图像在 [*第 11 章*](B18327_11.xhtml#_idTextAnchor292) 和 [*第 12 章*](B18327_12.xhtml#_idTextAnchor328)
    中有更详细的讨论。
- en: When you create a new Text object using **+** | **UI** | **Text**, you will
    see that it has a **Text** Component.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 **+** | **UI** | **文本** 创建一个新的文本对象时，你会看到它有一个 **文本** 组件。
- en: '![Figure 6.35: The Text component](img/Figure_06.35_B18327.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.35：文本组件](img/Figure_06.35_B18327.jpg)'
- en: 'Figure 6.35: The Text component'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.35：文本组件
- en: You can change the displayed text by changing the words in the **Text** box.
    In [*Chapter 11*](B18327_11.xhtml#_idTextAnchor292), we’ll take a closer look
    at the individual properties of the **Text** component, but for now, it should
    be fairly obvious what most of the properties do.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过更改**文本**框中的文字来更改显示的文本。在[*第11章*](B18327_11.xhtml#_idTextAnchor292)中，我们将更详细地查看**文本**组件的各个属性，但到目前为止，大多数属性的功能应该是相当明显的。
- en: When you create a new Image object using **+** | **UI** | **Image**, you will
    see that it has an **Image** component.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用**+** | **UI** | **图像**创建一个新的Image对象时，你会看到它有一个**图像**组件。
- en: '![Figure 6.36: The Image component](img/Figure_06.36_B18327.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图6.36：图像组件](img/Figure_06.36_B18327.jpg)'
- en: 'Figure 6.36: The Image component'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.36：图像组件
- en: Remember that a Panel is essentially an Image but with a few properties prefilled.
    When you create an Image, however, there are no prefilled properties.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，面板本质上是一个图像，但有一些预填充的属性。然而，当你创建一个图像时，没有预填充的属性。
- en: We’ll work with the **Source Image** property in this chapter, which allows
    you to change the displayed sprite. We’ll look at the other properties in [*Chapter
    11*](B18327_11.xhtml#_idTextAnchor292).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用**源图像**属性，该属性允许你更改显示的精灵。我们将在[*第11章*](B18327_11.xhtml#_idTextAnchor292)中查看其他属性。
- en: Examples
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: Now let’s jump into some examples! We’ll be creating a layout for a basic **heads-up-display**
    (**HUD**) and a background image that stretches with the screen and scales at
    multiple resolutions.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一些示例！我们将创建一个基本**抬头显示**（**HUD**）的布局以及一个随屏幕拉伸并在多个分辨率下缩放的背景图像。
- en: Before we begin building our UI, let’s set up our project and bring in the art
    assets we will need.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建UI之前，让我们设置我们的项目并引入我们将需要的艺术资产。
- en: 'We’ll begin by setting up our project:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置我们的项目：
- en: Create a new Unity Project and name it `Mastering Unity UI Project`. Create
    it in the 2D mode.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity项目，并将其命名为`Mastering Unity UI Project`。以2D模式创建它。
- en: Note
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We’re selecting 2D Mode because it will make importing our UI sprites a lot
    easier. When in 2D Mode, all images import as Sprite (2D and UI) images rather
    than Texture images, as they do in 3D Mode. You can change to 3D Mode at any time
    by navigating to **Edit** | **Project Settings** | **Editor** and changing **Mode**
    to **3D**.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择2D模式，因为它将使导入我们的UI精灵变得容易得多。在2D模式下，所有图像都导入为精灵（2D和UI）图像，而不是纹理图像，就像在3D模式中那样。你可以通过导航到**编辑**
    | **项目设置** | **编辑器**并将**模式**更改为**3D**来随时切换到3D模式。
- en: Create two new folders within the `Assets` folder named `Scripts` and `Sprites`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets`文件夹内创建两个新的文件夹，分别命名为`Scripts`和`Sprites`。
- en: Create a new scene and name it `Chapter6.unity`; ensure that you save it in
    the `Scenes` folder. You could also rename `SampleScene.unity` to `Chapter6.unity`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并将其命名为`Chapter6.unity`；确保将其保存在`Scenes`文件夹中。你也可以将`SampleScene.unity`重命名为`Chapter6.unity`。
- en: 'We’ll be using art assets that I’ve modified from free art assets found at
    the following sites:'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用我在以下网站找到的免费艺术资产修改的艺术资产：
- en: '[https://opengameart.org/content/free-game-gui](https://opengameart.org/content/free-game-gui)'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://opengameart.org/content/free-game-gui](https://opengameart.org/content/free-game-gui)'
- en: '[https://opengameart.org/content/cat-dog-free-sprites](https://opengameart.org/content/cat-dog-free-sprites)'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://opengameart.org/content/cat-dog-free-sprites](https://opengameart.org/content/cat-dog-free-sprites)'
- en: In the `Chapter2/Sprites` folder of the text’s source files, locate the `catSprites.png`,
    `pinkBackground.png`, and `uiElements.png` images and import them into your project
    by dragging them into the `Sprites` folder.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在文本源文件的`Chapter2/Sprites`文件夹中，找到`catSprites.png`、`pinkBackground.png`和`uiElements.png`图像，并将它们拖动到`Sprites`文件夹中导入到你的项目中。
- en: '![Figure 6.37: Importing the sprites](img/Figure_06.37_B18327.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图6.37：导入精灵](img/Figure_06.37_B18327.jpg)'
- en: 'Figure 6.37: Importing the sprites'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.37：导入精灵
- en: Now, we need to slice the sprite sheets into individual sprites. If you already
    know how to slice sprite sheets, do so now for the `catSprites` image and the
    `uiElements` image and proceed to the *Laying out the Basic HUD* section. If you
    are not familiar with the process, follow these steps, and continue to Step 5.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将精灵图分成单个精灵。如果你已经知道如何分割精灵图，请现在对`catSprites`图像和`uiElements`图像进行分割，然后继续到*布局基本HUD*部分。如果你不熟悉这个过程，请按照以下步骤操作，然后继续到第5步。
- en: Select the `catSprites` image, hold *Ctrl,* and click on the `uiElements` image
    so that both are selected.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`catSprites`图像，按住*Ctrl*，然后点击`uiElements`图像，以便两者都被选中。
- en: '![Figure 6.38: Selecting both sprite sheets](img/Figure_06.38_B18327.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图6.38：选择两个精灵图](img/Figure_06.38_B18327.jpg)'
- en: 'Figure 6.38: Selecting both sprite sheets'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.38：选择两个精灵表
- en: 'Now, in the `catSprites` and `uiElements` sprites to be considered sprite sheets.![Figure
    6.39: Converting the sprites to Multiple Sprite Mode](img/Figure_06.39_B18327.jpg)'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`catSprites`和`uiElements`精灵中，将它们视为精灵表。![图6.39：将精灵转换为多精灵模式](img/Figure_06.39_B18327.jpg)
- en: 'Figure 6.39: Converting the sprites to Multiple Sprite Mode'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.39：将精灵转换为多精灵模式
- en: Note that the **Inspector** says **2 Texture 2Ds Import Settings** because we
    have selected two images.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，**检查器**显示**2 Texture 2Ds导入设置**，因为我们选择了两个图像。
- en: Now select the `catSprites` image and open the **Sprite Editor** with the button
    in the **Import** **Settings** Panel.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在选择`catSprites`图像，并使用**导入** **设置**面板中的按钮打开**精灵编辑器**。
- en: With the **Sprite Editor** open, select **Slice**.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**精灵编辑器**打开的情况下，选择**切片**。
- en: Now change the slice properties so that the **Slice Type** is **Automatic**
    and the sprite **Pivot** is applied to the **Bottom**. Once done, hit **Slice**.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更改切片属性，使**切片类型**为**自动**，并将精灵**支点**应用到**底部**。完成后，点击**切片**。
- en: You should now see the sprite broken into three separate regions. Hit **Apply**
    to save the changes.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该看到精灵被分割成三个独立的区域。点击**应用**以保存更改。
- en: 'Now, if you click on the arrow on the `catSprites` image in the project folder
    view, you should see the individual images:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你在项目文件夹视图中点击`catSprites`图像上的箭头，你应该能看到单个图像：
- en: '![Figure 6.40: The split sprite sheet](img/Figure_06.40_B18327.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图6.40：分割精灵表](img/Figure_06.40_B18327.jpg)'
- en: 'Figure 6.40: The split sprite sheet'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.40：分割精灵表
- en: Complete Steps 8 through 12 for the `uiElements` image, but set the pivot point
    to the **Center**.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成8到12步的`uiElements`图像，但将支点设置为**中心**。
- en: Now that we have our project and sprites set up, we can begin with the UI examples.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了项目和精灵，我们可以开始UI示例。
- en: Laying out a basic HUD
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局基本HUD
- en: 'We will make a HUD that will look like the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将制作一个看起来像以下的HUD：
- en: '![Figure 6.41: The HUD we will develop](img/Figure_06.41_B18327.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图6.41：我们将开发的HUD](img/Figure_06.41_B18327.jpg)'
- en: 'Figure 6.41: The HUD we will develop'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.41：我们将开发的HUD
- en: It will be expanded upon in the upcoming chapters, but for now, it’ll have a
    pretty simple layout that will focus on parent–child relationships and anchor/pivot
    point placement.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在接下来的章节中进一步说明，但到目前为止，它将有一个相当简单的布局，重点关注父子关系和锚点/支点位置。
- en: 'To create the HUD shown in the preceding image, complete the following steps:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建前面图像中显示的HUD，请完成以下步骤：
- en: Create a new Canvas using **+** | **UI** | **Canvas**.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**+** | **UI** | **Canvas**创建一个新的Canvas。
- en: In the Canvas `HUD Canvas`.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Canvas HUD Canvas`中。
- en: 'It is best to set up all of your `1024` x `768`. If you look at the `pinkBackground`
    image (that we’ll apply in the next example), it has a resolution of `2048` x
    `1536`; `1024` x `768` has the same aspect ratio as the background image. So,
    set your **Canvas Scaler** component to the following settings:![Figure 6.42:
    The Canvas Scaler properties](img/Figure_06.42_B18327.jpg)'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最好设置所有`1024` x `768`。如果你看`pinkBackground`图像（我们将在下一个示例中应用），它的分辨率为`2048` x `1536`；`1024`
    x `768`与背景图像具有相同的宽高比。因此，将你的**Canvas缩放器**组件设置为以下设置：![图6.42：Canvas缩放器属性](img/Figure_06.42_B18327.jpg)
- en: 'Figure 6.42: The Canvas Scaler properties'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.42：Canvas缩放器属性
- en: We have set the `1` so that it maintains the ratios in the vertical direction.
    If you remember from the *Scale with Screen Size* section, I find that this works
    best for most games made with a landscape resolution.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将`1`设置为保持垂直方向上的比例。如果你还记得*根据屏幕大小缩放*部分，我发现这对于大多数使用横向分辨率制作的游戏来说效果最好。
- en: Set your Game view to `1024` x `768` so that you will see everything scaled
    appropriately (refer to the *Changing the Aspect Ratio and Resolution of the Game
    View* section of [*Chapter 1*](B18327_01.xhtml#_idTextAnchor014) for directions
    on adding your own Game view resolution.)
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的游戏视图设置为`1024` x `768`，这样你将看到所有内容都适当缩放（有关添加自己的游戏视图分辨率的说明，请参阅[*第1章*](B18327_01.xhtml#_idTextAnchor014)中的*更改游戏视图的宽高比和分辨率*部分）。
- en: '![Figure 6.43: 1024 x 768 Game view resolution](img/Figure_06.43_B18327.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图6.43：1024 x 768游戏视图分辨率](img/Figure_06.43_B18327.jpg)'
- en: 'Figure 6.43: 1024 x 768 Game view resolution'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.43：1024 x 768游戏视图分辨率
- en: Since we only have one Canvas, when we add any new UI elements to our scene,
    they will automatically be made children of our `HUD Canvas`. Create a new Panel
    using `HUD` `Panel`. You will see that it is a child of the `HUD Canvas`. This
    Panel will represent the rectangle that holds all the HUD elements.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们只有一个画布，当我们向场景添加任何新的 UI 元素时，它们将自动成为我们的 `HUD Canvas` 的子元素。使用 `HUD` `Panel`
    创建一个新的面板。你会看到它是一个 `HUD Canvas` 的子元素。这个面板将代表包含所有 HUD 元素的矩形。
- en: Click on the Anchor Presets icon to open the **Anchor Presets**. Select the
    top-left Anchor Preset while holding down *Shift* + *Alt*.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击锚点预设图标以打开 **锚点预设**。在按住 *Shift* + *Alt* 的同时选择左上角的锚点预设。
- en: '![Figure 6.44: Set the Anchor Preset of the HUD Panel](img/Figure_06.44_B18327.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.44：设置 HUD 面板的锚点预设](img/Figure_06.44_B18327.jpg)'
- en: 'Figure 6.44: Set the Anchor Preset of the HUD Panel'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.44：设置 HUD 面板的锚点预设
- en: 'Expand the `uiElements` image by selecting the arrow on its right. Locate the
    `uiElements_1` sub-image:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择其右侧的箭头来展开 `uiElements` 图像。定位 `uiElements_1` 子图像：
- en: '![Figure 6.45: Set the Anchor Preset of the HUD Panel](img/Figure_06.45_B18327.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.45：设置 HUD 面板的锚点预设](img/Figure_06.45_B18327.jpg)'
- en: 'Figure 6.45: Set the Anchor Preset of the HUD Panel'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.45：设置 HUD 面板的锚点预设
- en: 'Drag `uiElements_1` to the `HUD Panel`:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `uiElements_1` 拖动到 `HUD 面板`：
- en: '![Figure 6.46: The Image component with uiElements_1 assigned](img/Figure_06.46_B18327.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.46：已分配 uiElements_1 的 Image 组件](img/Figure_06.46_B18327.jpg)'
- en: 'Figure 6.46: The Image component with uiElements_1 assigned'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.46：已分配 uiElements_1 的 Image 组件
- en: 'Currently, the Panel is very faint and stretches across the whole screen. Let’s
    make it easier to see by increasing the opacity. Click on the white rectangle
    in the `Alpha` slider all the way to the right or input the value `255` in the
    alpha value slot:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，面板非常淡，横跨整个屏幕。让我们通过增加不透明度使其更容易看到。点击 `Alpha` 滑块中的白色矩形，将其完全滑到最右边，或者在 alpha 值槽中输入值
    `255`：
- en: '![Figure 6.47: Adjusting the alpha value on the color picker to full alpha](img/Figure_06.47_B18327.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.47：在颜色选择器上调整 alpha 值至全透明](img/Figure_06.47_B18327.jpg)'
- en: 'Figure 6.47: Adjusting the alpha value on the color picker to full alpha'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.47：在颜色选择器上调整 alpha 值至全透明
- en: Click on the checkbox next to the **Preserve Aspect** setting in the **Image**
    component. This property will make the image always maintain the aspect ratio
    of the original image, even if you set the width and height of the Image to something
    that does not have the same aspect ratio.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Image** 组件旁边 **Preserve Aspect** 设置旁边的复选框。此属性将使图像始终保持原始图像的纵横比，即使你将图像的宽度和高度设置为不具有相同纵横比的大小。
- en: 'The Panel will now take up only the top portion of the scene:'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 面板现在将仅占用场景的顶部部分：
- en: '![Figure 6.48: The Panel after preserving the aspect ratio](img/Figure_06.48_B18327.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.48：保持纵横比后的面板](img/Figure_06.48_B18327.jpg)'
- en: 'Figure 6.48: The Panel after preserving the aspect ratio'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.48：保持纵横比后的面板
- en: From the `HUD Panel`, you’ll note that the `1024` and `768`, respectively. You
    can also see more easily from the **Scene** view that the Rect Transform expands
    past the viewable region of the sprite. So, the object is much larger than it
    appears to be.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `HUD 面板`，你会注意到 `1024` 和 `768`，分别。你也可以从 **场景** 视图中更容易地看到矩形变换超出了精灵的可视区域。因此，对象的实际大小远大于其看起来的大小。
- en: '![Figure 6.49: The Rect Transform exceeding the visible image area](img/Figure_06.49_B18327.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.49：矩形变换超出可见图像区域](img/Figure_06.49_B18327.jpg)'
- en: 'Figure 6.49: The Rect Transform exceeding the visible image area'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.49：矩形变换超出可见图像区域
- en: Let’s rescale the Rect Transform of the Panel so that it matches the size we
    are looking for and hugs the viewable image better. Change the `300` and the `102`.
    The Rect Transform won’t be a perfectly snug fit in the vertical direction, but
    it will be pretty close.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们调整面板的矩形变换大小，使其与我们要找的大小相匹配，并更好地贴合可视图像。更改 `300` 和 `102`。在垂直方向上，矩形变换可能不会完全贴合，但会非常接近。
- en: '![Figure 6.50: Rescaling the Rect Transform of the HUD Panel](img/Figure_06.50_B18327.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.50：调整 HUD 面板的矩形变换大小](img/Figure_06.50_B18327.jpg)'
- en: 'Figure 6.50: Rescaling the Rect Transform of the HUD Panel'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.50：调整 HUD 面板的矩形变换大小
- en: We now have the main Panel set up. Since all other images will be contained
    within the `HUD Panel`, we want to make them children of the `HUD` `Panel`. That
    way, when the screen rescales, the other images will remain “inside” the `HUD`
    `Panel` and will maintain their size relative to the `HUD` `Panel`.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经设置了主要面板。由于所有其他图像都将包含在`HUD 面板`中，我们希望将它们设置为`HUD` `面板`的子项。这样，当屏幕缩放时，其他图像将保持在“内部”`HUD`
    `面板`中，并保持相对于`HUD` `面板`的大小。
- en: Let’s start with the Image that holds the cat character’s head. Right-click
    on the `HUD Panel` and select `HUD Panel`. Rename it `Character Holder`.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们从包含猫角色头部的图像开始。在`HUD 面板`上右键单击并选择`HUD 面板`。将其重命名为`角色容器`。
- en: Place the `uiElement_6` sprite in the **Source Image** slot and select **Preserve
    Aspect**.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`uiElement_6`精灵放入**源图像**槽中，并选择**保持纵横比**。
- en: 'Since the `Character` `Holder` image is a child of the `HUD` `Panel`, any anchoring
    we set will be relative to the `HUD` `Panel`. Choose the **left-stretch** Anchor
    Preset while holding *Shift* + *Alt*. Additionally, set the position and dimension
    variables as shown:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`角色` `容器`图像是`HUD` `面板`的子项，我们设置的任何锚定都将相对于`HUD` `面板`。在按住 *Shift* + *Alt* 的同时选择**左拉伸**锚定预设。此外，设置位置和尺寸变量，如下所示：
- en: '![Figure 6.51: Rescaling the Rect Transform of the Character Holder](img/Figure_06.51_B18327.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.51：调整角色容器的矩形变换](img/Figure_06.51_B18327.jpg)'
- en: 'Figure 6.51: Rescaling the Rect Transform of the Character Holder'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.51：调整角色容器的矩形变换
- en: Let’s add the Image for the cat head. We want it to fully fill out the slot
    represented by the `Character Holder` image. So, we will make it a child of the
    `Character` `Holder` image. Right-click on `Character Holder` and select `Character
    Image`.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加猫头部的图像。我们希望它完全填充由`角色容器`图像表示的槽。因此，我们将使其成为`角色` `容器`图像的子项。在`角色容器`上右键单击并选择`角色图像`。
- en: Now add the `catSprites_0` subimage to the **Source Image** of the **Image**
    component and select **Preserve Aspect**.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将`catSprites_0`子图像添加到**图像组件的源图像**中，并选择**保持纵横比**。
- en: 'Set the **Anchor Preset** to **stretch-stretch** while holding *Shift* + *Alt*:![Figure
    6.52: Rescaling the Rect Transform of the Character Image](img/Figure_06.52_B18327.jpg)'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按住 *Shift* + *Alt* 的同时将**锚定预设**设置为**拉伸-拉伸**：![图 6.52：调整角色图像的矩形变换](img/Figure_06.52_B18327.jpg)
- en: 'Figure 6.52: Rescaling the Rect Transform of the Character Image'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.52：调整角色图像的矩形变换
- en: Since we ensured that we have the `Character Holder` fit snuggly around the
    holder›s image, it should make the cat›s head fit perfectly within the holder
    image without having to adjust any settings!
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们确保`角色容器`图像紧密围绕容器图像，因此它应该使猫头完美地适应容器图像，而无需调整任何设置！
- en: '![Figure 6.53: The Character Image fitting within the Character Holder](img/Figure_06.53_B18327.jpg)'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 6.53：角色图像在角色容器内适配](img/Figure_06.53_B18327.jpg)'
- en: 'Figure 6.53: The Character Image fitting within the Character Holder'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.53：角色图像在角色容器内适配
- en: Now, we are ready to start making the health bar. We will create it similarly
    to the way we made the `Character Holder` and `Character`. Right-click on the
    `HUD Panel` and select `Health Holder`.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始制作生命值条。我们将以创建`角色容器`和`角色`相同的方式创建它。在`HUD 面板`上右键单击并选择`生命值容器`。
- en: Place the `uiElement_20` sprite in the **Source Image** slot and select **Preserve
    Aspect**.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`uiElement_20`精灵放入**源图像**槽中，并选择**保持纵横比**。
- en: 'Set the **Rect Transform** properties as shown in the following image, and
    ensure that you hold *Shift + Alt* when selecting the **Anchor Preset**:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置**矩形变换**属性，如下面的图像所示，并确保在选择**锚定预设**时按住 *Shift + Alt*：
- en: '![Figure 6.54: The properties of the Health Holder](img/Figure_06.54_B18327.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.54：生命值容器的属性](img/Figure_06.54_B18327.jpg)'
- en: 'Figure 6.54: The properties of the Health Holder'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.54：生命值容器的属性
- en: Now, all we have left is the health bar! Just as we made the cat head Image
    a child of the `Character Holder`, we will need to make the health bar’s Image
    a child of `Health Holder`. Right-click on `Health Holder` and select `Health
    Bar`.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只剩下生命值条了！就像我们将猫头图像设置为`角色容器`的子项一样，我们还需要将生命值条的图像设置为`生命值容器`的子项。在`生命值容器`上右键单击并选择`生命值条`。
- en: Place the `uiElement_23` image in the **Source Image** slot. This time, we will
    not be selecting **Preserve Aspect** because we want the image to scale this image
    horizontally.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`uiElement_23`图像放入**源图像**槽中。这次，我们不会选择**保持纵横比**，因为我们希望图像水平缩放此图像。
- en: 'Set the **Rect Transform** properties as shown in the following screenshot,
    and ensure that you hold *Shift + Alt* when selecting the **Anchor Presets**:![Figure
    6.55: The properties of Health Holder](img/Figure_06.55_B18327.jpg)'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**矩形变换**属性设置为以下截图所示，并在选择**锚点预设**时确保按住*Shift + Alt*：![图6.55：健康持有者的属性](img/Figure_06.55_B18327.jpg)
- en: 'Figure 6.55: The properties of Health Holder'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.55：健康持有者的属性
- en: Note that a little padding was added so that you can see the edges of `Health
    Holder`.
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，增加了一些填充，以便你可以看到`Health Holder`的边缘。
- en: Before proceeding, it is important that your Rect Transform Positioning mode
    is set to **Pivot**. Otherwise, you will not be able to move the pivot in the
    next step.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，确保你的矩形变换定位模式设置为**中心点**。否则，你将无法在下一步中移动中心点。
- en: '![Figure 6.56: The Rect Transform Positioning mode](img/Figure_06.56_B18327.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图6.56：矩形变换定位模式](img/Figure_06.56_B18327.jpg)'
- en: 'Figure 6.56: The Rect Transform Positioning mode'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.56：矩形变换定位模式
- en: We’re almost done! Right now, the pivot point of the image is right at the center.
    This means if we try to scale it, it will scale toward the center. However, we
    want it to be able to scale toward the left. So, open the **Anchor Presets**,
    and while holding *Shift* only, select **middle-left**. This will cause only the
    pivot point to move.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎完成了！目前，图像的中心点正好位于中心。这意味着如果我们尝试缩放它，它将向中心缩放。然而，我们希望它能够向左缩放。因此，打开**锚点预设**，并且只按住*Shift*，选择**中左**。这将只移动中心点。
- en: '![Figure 6.57: Moving the pivot point](img/Figure_06.57_B18327.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图6.57：移动中心点](img/Figure_06.57_B18327.jpg)'
- en: 'Figure 6.57: Moving the pivot point'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.57：移动中心点
- en: 'Now, when we adjust the **Scale X** value on the **Rect Transform**, the health
    bar will scale toward the left:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当我们调整**矩形变换**中的**X轴缩放**值时，生命值条将向左缩放：
- en: '![Figure 6.58: Adjusting the scale of the health bar](img/Figure_06.58_B18327.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图6.58：调整生命值条的比例](img/Figure_06.58_B18327.jpg)'
- en: 'Figure 6.58: Adjusting the scale of the health bar'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.58：调整生命值条的比例
- en: That’s it for our HUD example! Try changing your Game view’s aspect ratio to
    different settings so that you can see the Panel scale appropriately and see all
    the object-relative positions maintained.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的HUD示例就到这里！尝试更改你的游戏视图的纵横比到不同的设置，这样你可以看到面板适当地缩放，并看到所有对象相对位置保持不变。
- en: 'If your HUD is doing some wonky stuff when you change the Game’s aspect ratio,
    ensure that your objects have the correct parent–child relationship. Your parent–child
    relationships should be as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更改游戏的纵横比时，你的HUD出现了一些奇怪的问题，确保你的对象具有正确的父子关系。你的父子关系应该是这样的：
- en: '![Figure 6.59: The Hierarchy’s parent–child relationship](img/Figure_06.59_B18327.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![图6.59：层级结构的父子关系](img/Figure_06.59_B18327.jpg)'
- en: 'Figure 6.59: The Hierarchy’s parent–child relationship'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.59：层级结构的父子关系
- en: Also, check to ensure that the anchor and pivot points are set correctly.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，检查以确保锚点和中心点设置正确。
- en: Placing a 2D game background image
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 放置2D游戏背景图像
- en: Placing a background image that scales with the screen is not too difficult
    as long as you use the appropriate Canvas properties. We will expand upon our
    HUD example and place a background image in the scene.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 只要使用适当的画布属性，放置一个随屏幕缩放的背景图像并不太难。我们将扩展我们的HUD示例，并在场景中放置一个背景图像。
- en: '![Figure 6.60: The result of the background image](img/Figure_06.60_B18327.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图6.60：背景图像的结果](img/Figure_06.60_B18327.jpg)'
- en: 'Figure 6.60: The result of the background image'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.60：背景图像的结果
- en: We’ll need to ensure that this background image doesn’t just display behind
    other UI elements but also displays behind any game objects we may put in our
    scene.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保这个背景图像不仅显示在其他UI元素之后，还显示在我们场景中可能放置的任何游戏对象之后。
- en: 'To make a background image that displays behind all UI elements as well as
    all game elements, complete the following steps:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个显示在所有UI元素和所有游戏元素之后的背景图像，请完成以下步骤：
- en: Create a new Canvas using **+** | **UI** | **Canvas.** I like to use different
    Canvases to sort my different UI elements, but the need for a new Canvas stems
    from more than personal preference in this case. We need a new Canvas because
    we need a Canvas with a different Render Mode. This Canvas will use the **Screen
    Space-Camera** Render Mode.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**+** | **UI** | **画布**创建一个新的画布。我喜欢使用不同的画布来整理我的不同UI元素，但在这个案例中，需要一个新的画布不仅仅是因为个人偏好。我们需要一个新的画布，因为我们需要一个具有不同渲染模式的画布。这个画布将使用**屏幕空间-相机**渲染模式。
- en: In the Canvas `Background Canvas`.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在画布`背景画布`中。
- en: 'Change the `Main Camera` into the **Render** **Camera** slot:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`主摄像机`切换到**渲染** **摄像机**槽：
- en: '![Figure 6.61: The Canvas component of the Background Canvas](img/Figure_06.61_B18327.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![图6.61：背景画布的Canvas组件](img/Figure_06.61_B18327.jpg)'
- en: 'Figure 6.61: The Canvas component of the Background Canvas'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.61：背景画布的Canvas组件
- en: 'To ensure that this Canvas appears behind all other UI elements and all the
    2D sprites in the game, we will need to use Sorting Layers. In the top-right corner
    of the Unity Editor, you will see a dropdown menu labeled **Layers**. Select it
    and select **Edit Layers**:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保这个Canvas出现在所有其他UI元素和游戏中的所有2D精灵之后，我们需要使用排序层。在Unity编辑器的右上角，你会看到一个标签为**层**的下拉菜单。选择它并选择**编辑层**：
- en: '![Figure 6.62: Editing Layers](img/Figure_06.62_B18327.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![图6.62：编辑层](img/Figure_06.62_B18327.jpg)'
- en: 'Figure 6.62: Editing Layers'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.62：编辑层
- en: 'Expand `Background`.![Figure 6.63: Adding the Background Sorting Layer](img/Figure_06.63_B18327.jpg)'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开`背景`。[图6.63：添加背景排序层](img/Figure_06.63_B18327.jpg)
- en: 'Figure 6.63: Adding the Background Sorting Layer'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.63：添加背景排序层
- en: Sorting layers work so that whichever is on the top of this list will render
    the furthest back in the scene. So, if you wanted to add a foreground layer, you’d
    add it below `Background` layer will be behind any new sprite you create. If you
    do create new layers, ensure that the `Background` layers stay on the top of this
    list.
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 排序层的工作原理是，列表顶部的任何内容都将渲染在场景中最后。所以，如果你想添加一个前景层，你需要在`背景`层之下添加它，这样新创建的精灵就会在背景层之后。如果你创建了新层，确保`背景`层保持在列表的顶部。
- en: 'Reselect `Background Canvas` and now change the **Sorting Layer** to **Background**:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新选择`背景画布`，现在将**排序层**更改为**背景**：
- en: '![Figure 6.64: Setting the Background Sorting Layer](img/Figure_06.64_B18327.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图6.64：设置背景排序层](img/Figure_06.64_B18327.jpg)'
- en: 'Figure 6.64: Setting the Background Sorting Layer'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.64：设置背景排序层
- en: Now, all we need to do is add the background image. Right-click on the `Background
    Canvas` and select `Background Image`.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要添加背景图像。在`背景画布`上右键单击并选择`背景图像`。
- en: Place the `pinkBackground` sprite in the **Source Image** slot. This time, we
    will not be selecting **Preserve Aspect** because we want the image to be able
    to squash and stretch as the game screen resizes and always fills the scene.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`pinkBackground`精灵放入**源图像**槽中。这次，我们不会选择**保留宽高比**，因为我们希望图像能够在游戏屏幕调整大小时能够挤压和拉伸，并且始终充满场景。
- en: 'Set the **Rect Transform** properties as shown and ensure that you hold *Shift*
    + *Alt* when selecting the **Anchor Presets**:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**矩形变换**属性设置为所示，并确保在选择**锚点预设**时按住*Shift* + *Alt*：
- en: '![Figure 6.65: The Background Image settings](img/Figure_06.65_B18327.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![图6.65：背景图像设置](img/Figure_06.65_B18327.jpg)'
- en: 'Figure 6.65: The Background Image settings'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.65：背景图像设置
- en: Because the `Background Canvas` is set to **Screen Space – Camera**, you may
    have to change your view so that you can see it. It will be where the Main Camera
    view is.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`背景画布`设置为**屏幕空间 - 摄像机**，你可能需要更改视图以便可以看到它。它将在主摄像机视图的位置。
- en: That’s it! Try changing the Game view’s aspect ratio around and resizing the
    screen in **Free Aspect** mode so that you can see the background image always
    filling the screen. Also, try adding some non-UI 2D sprites to the scene and see
    how they render on top of the background.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！尝试调整游戏视图的宽高比，并在**自由宽高比**模式下调整屏幕大小，以便你可以看到背景图像总是充满屏幕。此外，尝试向场景中添加一些非UI 2D精灵，看看它们是如何在背景之上渲染的。
- en: 'One thing that is not ideal about this example is that the background image
    is being allowed to change its aspect ratio. You’ll see that the image looks pretty
    bad at some aspect ratios because of this. This background image will not be a
    good choice for a game that would be released on multiple aspect ratios. I chose
    this image for two reasons:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中不理想的一点是，背景图像被允许改变其宽高比。你会看到由于这个原因，在某些宽高比下图像看起来相当糟糕。这个背景图像不适合在多个宽高比上发布的游戏。我选择这个图像有两个原因：
- en: You can see how it’s important to pick an image that doesn’t depend so highly
    on aspect ratio.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以看到选择一个不高度依赖宽高比的图片是多么重要。
- en: It was free!
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是免费的！
- en: I highly recommend that if you use this method to create a background image,
    you use one with a pattern that doesn’t so obviously display distortion.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议如果你使用这种方法创建背景图像，使用一个图案不那么明显显示扭曲的图像。
- en: Setting up a basic pop-up menu
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置基本弹出菜单
- en: The last example we will cover in this chapter will utilize the **Canvas Group**
    component. We won›t be able to really see this component in action until we start
    programming in [*Chapter 8*](B18327_08.xhtml#_idTextAnchor147), but we can lay
    the groundwork now. We’ll also get a bit more practice with laying out UI with
    this example.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将要讨论的最后一个例子将使用**画布组**组件。我们直到开始编程在第[*第8章*](B18327_08.xhtml#_idTextAnchor147)中才能真正看到这个组件的作用，但现在我们可以打下基础。我们也将通过这个例子获得更多关于布局UI的实践。
- en: '![Figure 6.66: The pop-up Panel we will lay out](img/Figure_06.66_B18327.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![图6.66：我们将布局的弹出面板](img/Figure_06.66_B18327.jpg)'
- en: 'Figure 6.66: The pop-up Panel we will lay out'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.66：我们将布局的弹出面板
- en: 'To create the pop-up menu shown in the preceding image, complete the following
    steps:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建前面图像中显示的弹出菜单，请完成以下步骤：
- en: Create a new Canvas using **+** | **UI** | **Canvas**.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**+** | **UI** | **画布**创建一个新的画布。
- en: In the `Popup Canvas`.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`弹出画布`中。
- en: I want to use the same properties for the `HUD Canvas`. Instead of setting up
    all that again, I’ll use a shortcut and copy the `HUD Canvas`. To do so, select
    the three dots (the “kabob” menu) in the right-hand corner of the `HUD Canvas`
    and select **Copy Component**.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我想为`HUD画布`使用相同的属性。而不是再次设置所有这些，我将使用快捷键并复制`HUD画布`。要做到这一点，请选择`HUD画布`右上角的三个点（“串烧”菜单）并选择**复制组件**。
- en: Now select the “kabob” menu in the right-hand corner of the `Popup Canvas` and
    select **Paste** **Component Values**.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在请选择`弹出画布`右上角的“串烧”菜单并选择**粘贴** **组件值**。
- en: We will add a Panel that will hold all the items, similarly to the way we did
    with the HUD. This will ensure that everything stays together as it should. Right-click
    on `Popup Canvas` and select `Pause Panel`.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加一个面板来存放所有项目，类似于我们处理HUD的方式。这将确保所有项目都保持在一起。在`弹出画布`上右键单击并选择`暂停面板`。
- en: Place the `uiElement_32` image in the **Source Image** slot, give it a full
    alpha value, and select **Preserve Aspect**.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`uiElement_32`图像放入**源图像**槽中，赋予它全透明度，并选择**保持纵横比**。
- en: 'Set the **Rect Transform** properties as shown in the following screenshot,
    and ensure that you hold *Shift* + *Alt* when selecting the **Anchor Preset**:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置**矩形变换**属性，如以下截图所示，并确保在选择**锚点预设**时按住*Shift* + *Alt*：
- en: '![Figure 6.67: The properties of Pause Panel](img/Figure_06.67_B18327.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![图6.67：暂停面板的属性](img/Figure_06.67_B18327.jpg)'
- en: 'Figure 6.67: The properties of Pause Panel'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.67：暂停面板的属性
- en: Now, let’s give the Panel a nice banner at the top. Right-click on `Popup Panel`
    and select `Pause Banner`.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们给面板顶部添加一个漂亮的横幅。在`弹出面板`上右键单击并选择`暂停横幅`。
- en: Place the `uiElement_27` image in the **Source Image** slot and select **Preserve
    Aspect**.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`uiElement_27`图像放入**源图像**槽中并选择**保持纵横比**。
- en: 'Set the **Rect Transform** properties as shown in the following screenshot,
    and ensure that you hold *Shift* + *Alt* when selecting the **Anchor Presets**:![Figure
    6.68: The properties of Pause Banner](img/Figure_06.68_B18327.jpg)'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置**矩形变换**属性，如以下截图所示，并确保在选择**锚点预设**时按住*Shift* + *Alt*：![图6.68：暂停横幅的属性](img/Figure_06.68_B18327.jpg)
- en: 'Figure 6.68: The properties of Pause Banner'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.68：暂停横幅的属性
- en: We’ll add the text to this banner in a later chapter.
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中添加文本到这个横幅。
- en: The main point of this example was to demonstrate the use of the `Pause Panel`.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本例的主要目的是演示`暂停面板`的使用。
- en: Select `Pause Panel`, and then select **Add Component** | **Layout** | **Canvas
    Group** (you can also just search for Canvas Group).
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择`暂停面板`，然后选择**添加组件** | **布局** | **画布组**（你也可以直接搜索画布组）。
- en: That’s it for now! Change the values of `Pause Panel` `Pause Panel` and the
    `Pause Banner` alpha values change. This is great for pop-up menus you want to
    hide and show without having to program each item individually. Once we spend
    more time with `Pause Panel`, it will have a lot more items on it, and we will
    be happy that we don’t have to program each piece individually.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止！更改`暂停面板`和`暂停横幅`的透明度值。这对于想要隐藏和显示弹出菜单而不必为每个项目单独编程非常有用。一旦我们花更多时间与`暂停面板`打交道，它上面将会有更多项目，我们也会很高兴我们不必为每个部分单独编程。
- en: Summary
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Wow! This chapter was intense! There was a lot to cover, as this chapter set
    the groundwork that will be used throughout the rest of this book. We discussed
    the concept of a Canvas and how to correctly position it within your scene. Additionally,
    we discussed the basic UI Panel to allow us to explore the concept of positioning
    UI elements within a scene. Correctly setting up Canvases and their scalars is
    an important first step in developing UI.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这一章内容丰富！有很多内容需要涵盖，因为这一章为本书剩余部分奠定了基础。我们讨论了画布的概念以及如何在场景中正确放置它。此外，我们还讨论了基本的UI面板，以便我们探索在场景中定位UI元素的概念。正确设置画布及其标量是开发UI的重要第一步。
- en: The next chapter will cover how to create different automatic layouts that will
    let us line up our UI in grids.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍如何创建不同的自动布局，这将使我们能够以网格的形式排列我们的用户界面。
