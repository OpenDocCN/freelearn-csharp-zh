<html><head></head><body>
<div><h1 class="chapterNumber">8</h1>
<h1 class="chapterTitle" id="_idParaDest-161">Authentication and Authorization</h1>
<p class="normal">In this chapter, we will learn <a id="_idIndexMarker374"/>how to add <strong class="keyWord">authentication</strong> and <strong class="keyWord">authorization</strong> to our<a id="_idIndexMarker375"/> blog because we don’t want just anyone to be able to create or edit blog posts.</p>
<p class="normal">Covering authentication and authorization could take a whole book, so we will keep things simple here. This chapter aims to get the built-in authentication and authorization functionalities working, building on the already existing functionality that’s built into ASP.NET. That means that there is not a lot of Blazor magic involved here; many resources already exist that we can take advantage of.</p>
<p class="normal">Almost every system today has some way to log in, whether it is an admin interface (like ours) or a member login portal. There are many different login providers, such as Google, Twitter, and Microsoft. We can use all of these providers since we will just be building on existing architecture.</p>
<p class="normal">Some sites might already have a database for storing login credentials, but for our blog, we will use a service called Auth0 to manage our users. It is a very powerful way to add many different social providers (if we want to), and we don’t have to manage the users ourselves.</p>
<p class="normal">We can check the option to add authentication when creating our project. The authentication works differently when it comes to Blazor Server, Blazor WebAssembly, and the API, which we will look at in more detail in this chapter.</p>
<p class="normal">We will cover the following topics in this chapter:</p>
<ul>
<li class="bulletList">Setting up authentication</li>
<li class="bulletList">Securing Blazor Server</li>
<li class="bulletList">Securing Blazor WebAssembly</li>
<li class="bulletList">Securing the API</li>
<li class="bulletList">Adding authorization</li>
</ul>
<h1 class="heading-1" id="_idParaDest-162">Technical requirements</h1>
<p class="normal">Make sure you have followed the previous chapters or use the <code class="inlineCode">Chapter07</code> folder as a starting point.</p>
<p class="normal">You can find the source code for this chapter’s end result at <a href="https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter08">https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter08</a>.</p>
<h1 class="heading-1" id="_idParaDest-163">Setting up authentication</h1>
<p class="normal">There are a lot of built-in functionalities<a id="_idIndexMarker376"/> when it comes to authentication. The easiest way to add authentication is to select an authentication option when creating a project.</p>
<p class="normal">We need to implement authentication separately for the Blazor Server project and the Blazor WebAssembly project because they work differently.</p>
<p class="normal">But there are still things we can share between these two projects. First, we need to set up Auth0.</p>
<p class="normal"><strong class="keyWord">Auth0</strong> is a <a id="_idIndexMarker377"/>service that can help us with handling our users. There are many different services like this, but Auth0 is a good fit for us. We can connect one or more social connectors, which will allow our users to log in with Facebook, Twitter, Twitch, or whatever we add to our site.</p>
<p class="normal">Even though all of this can be achieved by writing code ourselves, integration like this is a great way to add authentication quickly and also get a very powerful solution. Also, authentication is complex, so don’t write this unless you are sure of what you are doing. Auth0 is free for up to 7,000 users (which our blog probably won’t reach, especially not the admin interface).</p>
<p class="normal">It also has great functionality to add data to our users that we have access to. We will do that later in the chapter when we add roles to our users. You’ll need to take the following steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Head over to <a href="https://auth0.com">https://auth0.com</a> and create an account.</li>
<li class="numberedList">Click the <strong class="screenText">Create Application</strong> button.</li>
<li class="numberedList">Now, it’s time to name our application. Use <code class="inlineCode">MyBlog</code>, for example. Then, it’s time to select what kind of application type we are using. Is it a native app? Is it a <strong class="keyWord">single-page web application</strong>, <strong class="keyWord">regular web application</strong>, or <strong class="keyWord">machine-to-machine application</strong>?</li>
</ol>
<p class="normal">This depends <a id="_idIndexMarker378"/>on what hosting model we are going to run.</p>
<p class="normal">The beautiful thing with how we have the project set up right now is that the server is going to handle all the authentication and hand that over to WebAssembly (if we have a component that is running in InteractiveAuto or InteractiveWebAssembly). But it won’t limit the functionality, only what we need to configure when setting up our application.</p>
<p class="normal">If we intend to only run as Blazor Server (InteractiveServer), we should use a regular web application. But we might want to change to running everything in InteractiveWebAssembly, so let’s not limit ourselves here. </p>
<p class="normal">Select <strong class="screenText">Single Page Application</strong>, that way we get the option to use our authentication in any hosting model.</p>
<p class="normal">Next, we will choose what technology we are using for our project. We have Apache, .NET, Django, Go, and many other choices, but we don’t have a choice for Blazor specifically, at least not at the time of writing.</p>
<p class="normal">Just skip this and click the <strong class="screenText">Setting</strong> tab.</p>
<p class="normal">Now, we will set up our application. There are a couple of values we need to save and use later. You need to make sure that you write down the <code class="inlineCode">Domain</code>, <code class="inlineCode">Client ID</code>, and <code class="inlineCode">Client Secret</code>, as we will use those in a bit.</p>
<p class="normal">If we scroll down, we can change the logo, but we will skip that.</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4">Leave <code class="inlineCode">Application Login URI</code> empty. Starting with .NET 6, the port numbers are random, so make sure you add your application’s port number:<ol class="alphabeticList" style="list-style-type: lower-alpha;">
<li class="alphabeticList" value="1"><code class="inlineCode">Allowed callback URLs</code>: <code class="inlineCode">https://localhost:PORTNUMBER/callback</code></li>
<li class="alphabeticList"><code class="inlineCode">Allowed logout URLs</code>: <code class="inlineCode">https://localhost:PORTNUMBER/</code></li>
</ol>
</li>
</ol>
<p class="normal">Allowed callback<a id="_idIndexMarker379"/> URLs are the URLs <code class="inlineCode">Auth0</code> will make a call to after the user authentication and allowed logout URLs are where the user should be redirected after logging out.</p>
<p class="normal">Now, press <strong class="screenText">Save Changes</strong> at the bottom of the page.</p>
<h2 class="heading-2" id="_idParaDest-164">Configuring our Blazor app</h2>
<p class="normal">We are done with configuring <a id="_idIndexMarker380"/>Auth0. Next, we will configure our Blazor application.</p>
<p class="normal">There are many ways to store secrets in .NET (a file that is not checked in, Azure Key Vault, etc.). You can use the one that you are most familiar with.</p>
<p class="normal">We will keep it very simple and store secrets in our <code class="inlineCode">appsettings.json</code>. Make sure to remember to exclude the file when you check in. You don’t check the secrets in source control. You can right-click on the file and select <strong class="screenText">Git</strong>,<strong class="screenText"> Ignore and Untrack Item</strong>.</p>
<p class="normal">To configure our Blazor project, follow these steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">BlazorWebApp.Client</code> project, in the root, add a new class called <code class="inlineCode">UserInfo.cs</code>, and add the following content:
        <pre class="programlisting code"><code class="hljs-code">namespace BlazorWebApp.Client;
public class UserInfo
{
    public required string UserId { get; set; }
    public required string Email { get; set; }    public required string[] Roles { get; set; }
}
</code></pre>
</li>
</ol>
<p class="normal">This is taken from the Blazor template.</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="2">In the <code class="inlineCode">BlazorWebApp</code> project, open <code class="inlineCode">appsettings.json</code> and add the following code to the root of the existing app settings object:
        <pre class="programlisting code"><code class="hljs-code">  "Auth0": {
    "Authority": "Get this from the domain for your application at Auth0",
    "ClientId": "Get this from Auth0 setting"
  }
</code></pre>
</li>
</ol>
<p class="normal">These are the values we made a note of in the previous section. Replace the values with our own values from <code class="inlineCode">Auth0</code>.</p>
<p class="normal">Since our site is an ASP.NET site with some added Blazor functionality, this means we can use a NuGet package to get some of the functionality out of the box.</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="3">In the <code class="inlineCode">BlazorWebApp</code> project, add<a id="_idIndexMarker381"/> a reference to the <code class="inlineCode">Auth0.AspNetCore.Authentication NuGet</code> package.</li>
<li class="numberedList">In the root of the project, create a new class named <code class="inlineCode">PersistingServerAuthenticationStateProvider.cs</code>, and add the following code:
        <pre class="programlisting code"><code class="hljs-code">using BlazorWebApp.Client;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Authorization;
using Microsoft.AspNetCore.Components.Server;
using Microsoft.AspNetCore.Components.Web;
using Microsoft.AspNetCore.Identity;
using Microsoft.Extensions.Options;
using System.Diagnostics;
namespace BlazorWebApp;
internal sealed class PersistingServerAuthenticationStateProvider : ServerAuthenticationStateProvider, IDisposable
{
    private readonly PersistentComponentState state;
    private readonly IdentityOptions options;
    private readonly PersistingComponentStateSubscription subscription;
    private Task&lt;AuthenticationState&gt;? authenticationStateTask;
    public PersistingServerAuthenticationStateProvider(
        PersistentComponentState persistentComponentState,
        IOptions&lt;IdentityOptions&gt; optionsAccessor)
    {
        state = persistentComponentState;
        options = optionsAccessor.Value;
        AuthenticationStateChanged += OnAuthenticationStateChanged;
        subscription = state.RegisterOnPersisting(OnPersistingAsync, RenderMode.InteractiveWebAssembly);
    }
    private void OnAuthenticationStateChanged(Task&lt;AuthenticationState&gt; task)
    {
        authenticationStateTask = task;
    }
    private async Task OnPersistingAsync()
    {
        if (authenticationStateTask is null)
        {
            throw new UnreachableException($"Authentication state not set in {nameof(OnPersistingAsync)}().");
        }
        var authenticationState = await authenticationStateTask;
        var principal = authenticationState.User;
        if (principal.Identity?.IsAuthenticated == true)
        {
            var userId = principal.FindFirst(options.ClaimsIdentity.UserIdClaimType)?.Value;
            var email = principal.FindFirst(options.ClaimsIdentity.EmailClaimType)?.Value;
            var roles = principal.FindAll(options.ClaimsIdentity.RoleClaimType);
            
            if (userId != null)
            {
                state.PersistAsJson(nameof(UserInfo), new UserInfo
                {
                    UserId = userId,
                    Email = email,
                    Roles=roles.Select(r=&gt;r.Value).ToArray()
                });
            }
        }
    }
    public void Dispose()
    {
        subscription.Dispose();
        AuthenticationStateChanged -= OnAuthenticationStateChanged;
    }
}
</code></pre>
</li>
<li class="numberedList">I have taken this file from the Blazor template (when we choose to add authentication right away). I added roles to it so if <code class="inlineCode">Auth0</code> delivers any roles, they will be stored in the state as well. Right now, <code class="inlineCode">Auth0</code> won’t give us any roles, so we will get back to roles in a bit. What is happening is when we log in, it will save the logged-in user in the <code class="inlineCode">PersistentComponentState</code> so that we can easily transfer the user over to WebAssembly. The server will render the data on the DOM, and WebAssembly will then pick that up. </li>
<li class="numberedList">Open <code class="inlineCode">Program.cs</code> and add the following at the top of the file:
        <pre class="programlisting code"><code class="hljs-code">using BlazorWebApp;
using Auth0.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authentication.Cookies;
</code></pre>
</li>
<li class="numberedList">Add the following code just before <code class="inlineCode">WebApplication app = builder.Build();</code>:
        <pre class="programlisting code"><code class="hljs-code">builder.Services.AddScoped&lt;AuthenticationStateProvider, PersistingServerAuthenticationStateProvider&gt;();
builder.Services.AddCascadingAuthenticationState();
builder.Services
    .AddAuth0WebAppAuthentication(options =&gt;
    {
        options.Domain = builder.Configuration["Auth0:Authority"]??"";;
        options.ClientId = builder.Configuration["Auth0:ClientId"]??"";;
    });
</code></pre>
</li>
<li class="numberedList">In previous versions of Blazor, we had to first make sure that when our components asked for <code class="inlineCode">AuthenticationStateProvider</code>, we sent back an instance of our <code class="inlineCode">PersistingServerAuthenticationStateProvider</code>. We also add a call to <code class="inlineCode">AddCascadingAuthenticationState</code>, which will make sure to always send an <code class="inlineCode">AuthenticationState</code> to all our components regardless of hosting method.</li>
<li class="numberedList">Also, add the <a id="_idIndexMarker382"/>following code just after <code class="inlineCode">app.UseAntiforgery();</code>. This code will allow us to secure our site:
        <pre class="programlisting code"><code class="hljs-code">app.UseAuthentication();
app.UseAuthorization();
</code></pre>
</li>
<li class="numberedList">In <code class="inlineCode">Program.cs</code>, add the following code just before <code class="inlineCode">app.Run()</code>:
        <pre class="programlisting code"><code class="hljs-code">app.MapGet("account/login", async (string redirectUri, HttpContext
 context) =&gt;
{
    var authenticationProperties = new LoginAuthenticationPropertiesBuilder()
         .WithRedirectUri(redirectUri)
         .Build();
    await context.ChallengeAsync(Auth0Constants.AuthenticationScheme, authenticationProperties);
});
</code></pre>
</li>
</ol>
<p class="normal">When our site redirects to <code class="inlineCode">authentication/login</code>, the Minimal API endpoint will kick off the login functionality.</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="11">We need to add a similar functionality for logging out. Add the following code below the previous endpoint from <em class="italic">Step 7</em>:
        <pre class="programlisting code"><code class="hljs-code">app.MapGet("authentication/logout", async (HttpContext context) =&gt;
{
    var authenticationProperties = new LogoutAuthenticationPropertiesBuilder()
         .WithRedirectUri("/")
         .Build();
    await context.SignOutAsync(Auth0Constants.AuthenticationScheme, authenticationProperties);
    await context.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme);
});
</code></pre>
</li>
</ol>
<p class="normal">It needs to sign out<a id="_idIndexMarker383"/> twice, once for the <code class="inlineCode">Auth0</code> authentication scheme and once for the cookie authentication scheme. The configuration is all set. Now, we need something to secure.</p>
<h1 class="heading-1" id="_idParaDest-165">Securing our Blazor app</h1>
<p class="normal">Blazor <a id="_idIndexMarker384"/>uses <code class="inlineCode">App.razor</code> for routing. To enable securing Blazor, we need to add a couple of components in the app component.</p>
<p class="normal">We need to add <code class="inlineCode">CascadingAuthenticationState</code>, which will send the authentication state to all the components that are listening for it. We also need to change the route view to <code class="inlineCode">AuthorizeRouteView</code>, which can have different views depending on whether or not you are authenticated:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">BlazorWebApp</code> project, open <code class="inlineCode">Components/_Imports.razor</code> and add the namespaces:
        <pre class="programlisting code"><code class="hljs-code">@using Microsoft.AspNetCore.Components.Authorization
@using BlazorWebApp.Components.Layout
@using BlazorWebApp.Components
</code></pre>
</li>
<li class="numberedList">Open the <code class="inlineCode">Components/Routes.razor</code> component and replace everything inside the <code class="inlineCode">Router</code> component with the following:
        <pre class="programlisting code"><code class="hljs-code">&lt;Found Context="routeData"&gt;
     &lt;AuthorizeRouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)"&gt;
         &lt;Authorizing&gt;
             &lt;p&gt;Determining session state, please wait...&lt;/p&gt;
         &lt;/Authorizing&gt;
         &lt;NotAuthorized&gt;
             &lt;h1&gt;Sorry&lt;/h1&gt;
             &lt;p&gt;You're not authorized to reach this page. You need to log in.&lt;/p&gt;
         &lt;/NotAuthorized&gt;
     &lt;/AuthorizeRouteView&gt;
     &lt;FocusOnNavigate RouteData="@routeData" Selector="h1" /&gt;
 &lt;/Found&gt;
 &lt;NotFound&gt;
     &lt;PageTitle&gt;Not found&lt;/PageTitle&gt;
     &lt;LayoutView Layout="@typeof(MainLayout)"&gt;
         &lt;p role="alert"&gt;Sorry, there's nothing at this address.&lt;/p&gt;
     &lt;/LayoutView&gt;
 &lt;/NotFound&gt;
</code></pre>
</li>
</ol>
<p class="normal">In previous versions of Blazor, we had to surround the code with <code class="inlineCode">&lt;CascadingAuthenticationState&gt;</code>, but with .NET 8, that is handled automatically by adding the call to <code class="inlineCode">AddCascadingAuthenticationState</code>.</p>
<p class="normal">Now, only two things remain: a page that we can secure and a login link display.</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="3">In<a id="_idIndexMarker385"/> the <code class="inlineCode">Components</code> folder, add a new Razor component called <code class="inlineCode">LoginStatus.razor</code>.</li>
</ol>
<p class="normal">Replace the content with the following:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;AuthorizeView&gt;
    &lt;Authorized&gt;
        &lt;a href="authentication/logout"&gt;Log out&lt;/a&gt;
    &lt;/Authorized&gt;
    &lt;NotAuthorized&gt;
        &lt;a href="account/login?returnUrl=/"&gt;Log in&lt;/a&gt;
    &lt;/NotAuthorized&gt;
&lt;/AuthorizeView&gt;
</code></pre>
<p class="normal"><code class="inlineCode">LoginStatus</code> is a component that will show a login link if we are not authenticated and a logout link if we are authenticated.</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4">Open <code class="inlineCode">Components/Layout/MainLayout.razor</code>:
        <pre class="programlisting code"><code class="hljs-code">&lt;AuthorizeView Roles="Administrator"&gt;
        &lt;div class="sidebar"&gt;
            &lt;NavMenu /&gt;
        &lt;/div&gt;
&lt;/AuthorizeView&gt;
</code></pre>
</li>
</ol>
<p class="normal">Replace the about link with the following:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;LoginStatus /&gt;
</code></pre>
<p class="normal">Now, our layout page will show us whether or not we’re logged in and give us the opportunity to log in or log out.</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">In <code class="inlineCode">SharedComponents</code> and the <code class="inlineCode">BlazorWebApp.Client</code> project, in the <code class="inlineCode">_Imports</code> file of each project, add the following:
        <pre class="programlisting code"><code class="hljs-code">@using Microsoft.AspNetCore.Authorization
</code></pre>
</li>
<li class="numberedList">Add the <code class="inlineCode">authorize</code> attribute to the component we wish to secure.</li>
<li class="numberedList">We have the following components in the <code class="inlineCode">SharedComponents</code> project:</li>
</ol>
<p class="normal"><code class="inlineCode">Pages/Admin/BlogPostEdit.razor</code></p>
<p class="normal"><code class="inlineCode">Pages/Admin/BlogPostList.razor</code></p>
<p class="normal"><code class="inlineCode">Pages/Admin/CategoryList.razor</code></p>
<p class="normal"><code class="inlineCode">Pages/Admin/TagList.razor (in the BlazorWebApp.Client project)</code></p>
<p class="normal">In each of the preceding components, add the following attribute:</p>
<pre class="programlisting code"><code class="hljs-code">@attribute [Authorize]
</code></pre>
<p class="normal">This is all it takes, some configuration, and then we are all set.</p>
<p class="normal">Now, start our <code class="inlineCode">BlazorWebApp</code> and see if you can access the <code class="inlineCode">/admin/blogposts</code> page (spoiler: you shouldn’t be able to); log in (create a user) and see if you can access the page now.</p>
<p class="normal">Our<a id="_idIndexMarker386"/> admin interface is secured.</p>
<p class="normal">In the next section, we will secure the Blazor WebAssembly version of our blog and the API.</p>
<h1 class="heading-1" id="_idParaDest-166">Securing Blazor WebAssembly</h1>
<p class="normal">In the previous editions<a id="_idIndexMarker387"/> of this book, we built two versions of the blog, one for Blazor Server and one for Blazor WebAssembly. In this edition, the whole point is that we don’t have to choose one over the other. As previously mentioned, there are two projects, <code class="inlineCode">BlazorWebApp</code> and <code class="inlineCode">BlazorWebApp.Client</code>. In the client project, we add all the components we want to be able to run as WebAssembly. Here is the really cool part. We have our <code class="inlineCode">TagList</code> component in the client project. If we are running it as InteractiveAuto, it will first render on the server using SignalR using the configuration found in the <code class="inlineCode">BlazorWebApp</code> project. But the next time the site runs, it will load the WebAssembly version and use the configuration in the <code class="inlineCode">BlazorWebApp.Client</code> project. So, the same component can use a different dependency injection. In one case, it will use direct data access, and in the other, it will use the API client we created in the previous chapter.</p>
<p class="normal">For us to <a id="_idIndexMarker388"/>be able to access our API, we need to set up <code class="inlineCode">HttpClient</code>:</p>
<p class="normal">But first, we need to get authentication information from the server. WebAssembly doesn’t really log in; it gets the information from the server and uses the authentication cookie for additional calls to the server.</p>
<p class="normal">In the server project, we added a <code class="inlineCode">PersistingServerAuthenticationStateProvider</code> to store information about the logged-in user. On the client, we need to get that information.</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">BlazorWebApp.Client</code> project, add a new class in the root called <code class="inlineCode">PersistentAuthenticationStateProvider.cs</code>.</li>
<li class="numberedList">Replace the code with the following:
        <pre class="programlisting code"><code class="hljs-code">using BlazorWebApp.Client;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Authorization;
using System.Security.Claims;
namespace BlazorApp1.Client;
internal class PersistentAuthenticationStateProvider : AuthenticationStateProvider
{
    private static readonly Task&lt;AuthenticationState&gt; defaultUnauthenticatedTask =
        Task.FromResult(new AuthenticationState(new ClaimsPrincipal(new ClaimsIdentity())));
    private readonly Task&lt;AuthenticationState&gt; authenticationStateTask = defaultUnauthenticatedTask;
    public PersistentAuthenticationStateProvider(PersistentComponentState state)
    {
        if (!state.TryTakeFromJson&lt;UserInfo&gt;(nameof(UserInfo), out var userInfo) || userInfo is null)
        {
            return;
        }
        List&lt;Claim&gt; claims = new();
        claims.Add(new Claim(ClaimTypes.NameIdentifier, userInfo.UserId));
        claims.Add(new Claim(ClaimTypes.Name, userInfo.Email??""));
        claims.Add(new Claim(ClaimTypes.Email, userInfo.Email??""));
        foreach (var role in userInfo.Roles)
        {
            claims.Add(new Claim(ClaimTypes.Role, role));
        }
        authenticationStateTask = Task.FromResult(
            new AuthenticationState(new ClaimsPrincipal(new ClaimsIdentity(claims,
                authenticationType: nameof(PersistentAuthenticationStateProvider)))));
    }
    public override Task&lt;AuthenticationState&gt; GetAuthenticationStateAsync() =&gt; authenticationStateTask;
}
</code></pre>
</li>
<li class="numberedList">This is also<a id="_idIndexMarker389"/> taken from the Blazor template (with authentication). Only minor modifications appear here, like adding roles.</li>
<li class="numberedList">In the <code class="inlineCode">BlazorWebApp.Client</code> project, in <code class="inlineCode">Program.cs</code>, add the following lines just above <code class="inlineCode">builder.Build().RunAsync()</code>;:
        <pre class="programlisting code"><code class="hljs-code">builder.Services.AddAuthorizationCore();
builder.Services.AddCascadingAuthenticationState();
builder.Services.AddSingleton&lt;AuthenticationStateProvider, PersistentAuthenticationStateProvider&gt;();
builder.Services.AddHttpClient("Api",client =&gt; client.BaseAddress = new Uri(builder.HostEnvironment.BaseAddress)); 
</code></pre>
</li>
</ol>
<p class="normal">This will enable authentication, add cascading <code class="inlineCode">authentication state</code> to our components, and get the logged-in user from the <code class="inlineCode">Persistent Component State</code>. The name of the <code class="inlineCode">HttpClient</code> is “<code class="inlineCode">Api"</code>; this is the name we used in <em class="chapterRef">Chapter 7</em>, <em class="italic">Creating an API</em>.</p>
<p class="normal">We also need <a id="_idIndexMarker390"/>to set up dependency injection so that when we ask for an <code class="inlineCode">IBlogAPI</code>, we will get the <code class="inlineCode">BlogApiWebClient</code> that we created in <em class="chapterRef">Chapter 7</em>, <em class="italic">Creating an API</em>.</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">In <code class="inlineCode">Program.cs</code>, add the following code below the <code class="inlineCode">builder.Services.AddSingleton&lt;AuthenticationStateProvider, PersistentAuthenticationStateProvider&gt;();</code> line:
        <pre class="programlisting code"><code class="hljs-code">builder.Services.AddTransient&lt;IBlogApi, BlogApiWebClient&gt;();
</code></pre>
</li>
</ol>
<p class="normal">Now, when we ask for an <code class="inlineCode">IBlogApi</code>, we will get the API web client that accesses the data through an API. The really cool thing here is that, depending on whether the component is rendered on the server (Static, InteractiveServer), the client (InteractiveWebAssembly), or a combination (InteractiveAuto), it will choose the right client for that scenario. We have the ability to choose the one that is best suited.</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="6">Make sure to add the required namespaces as well.</li>
</ol>
<p class="normal">Now, everything is prepared for us to secure when running in WebAssembly mode.</p>
<p class="normal">This sample is about securing WebAssembly when running with an ASP.NET backend. In <em class="chapterRef">Chapter 16</em>, <em class="italic">Going Deeper into WebAssembly</em>, we will take a look at how to secure a Blazor WebAssembly app.</p>
<p class="normal">Let’s give it a try:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">BlazorWebApp.Client</code> project, open the <code class="inlineCode">Pages/Admin/TagList.razor</code>. We have been running our component with the InteractiveServer render mode up to this point. Now, let’s change that and run it as InteractiveWebAssembly instead.</li>
</ol>
<p class="normal">Change <code class="inlineCode">@rendermode InteractiveServer</code> to <code class="inlineCode">@rendermode InteractiveWebAssembly</code>. That’s it! Now, our component will first render on the server (since we are running server pre-rendering), and then WebAssembly will take over and render the component again. It will pick up the authentication information stored in the component state and use our web API to retrieve the data from our API. This is because the WebAssembly application is configured to use <code class="inlineCode">BlogApiWebClient</code> when we ask for an instance of <code class="inlineCode">IBlogApi</code>. So, the same component is first prerendered on the server using direct data access, then again using the web API. Pretty cool!</p>
<p class="normal">Now, run the project, navigate to <code class="inlineCode">/Admin/Tags</code>, and try to edit some tags. This component is now running on WebAssembly. You can try to change it to <code class="inlineCode">@rendermode InteractiveAuto</code>. To see the behavior, this will first hook up SignalR and then, on the next load, switch to WebAssembly.</p>
<p class="normal">But what if <a id="_idIndexMarker391"/>different users have different permissions?</p>
<p class="normal">That is where roles come in.</p>
<h1 class="heading-1" id="_idParaDest-167">Adding roles</h1>
<p class="normal">Blazor Server and Blazor WebAssembly handle roles a bit differently; it’s nothing major, but we need to do different implementations. In this chapter, we will take a look at implementing it for our current project (per component) and return to roles in <em class="chapterRef">Chapter 16</em>, <em class="italic">Going Deeper into WebAssembly</em>.</p>
<h2 class="heading-2" id="_idParaDest-168">Configuring Auth0 by adding roles</h2>
<p class="normal">Let’s <a id="_idIndexMarker392"/>start by adding<a id="_idIndexMarker393"/> roles in Auth0:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Log in to <code class="inlineCode">Auth0</code>, navigate to <strong class="screenText">User Management</strong> | <strong class="screenText">Roles</strong>, and click <strong class="screenText">Create Role</strong>.</li>
<li class="numberedList">Enter the name <code class="inlineCode">Administrator</code> and the description <code class="inlineCode">Can do anything</code> and press <strong class="screenText">Create</strong>.</li>
<li class="numberedList">Go to the <strong class="screenText">Users</strong> tab, click <strong class="screenText">Add Users</strong>, search for your user, and then click <strong class="screenText">Assign</strong>. You can also manage roles from the <strong class="screenText">Users</strong> menu on the left.</li>
<li class="numberedList">By default, roles won’t be sent to the client, so we need to enrich the data to include roles.</li>
</ol>
<p class="normal">We do that by adding an action.</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">Go to <strong class="screenText">Actions</strong>, and then <strong class="screenText">Flows</strong>.</li>
</ol>
<p class="normal">Flows are a way to execute code in a particular flow.</p>
<p class="normal">We want <code class="inlineCode">Auth0</code> to add our roles when we log in.</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="6">Select <strong class="screenText">Login</strong>, and <a id="_idIndexMarker394"/>there we will see the flow; in our case, we don’t <a id="_idIndexMarker395"/>have anything yet.</li>
<li class="numberedList">On the right-hand side, click <strong class="screenText">Custom</strong> and the plus sign. As a small pop-up menu appears, select <strong class="screenText">Build from scratch</strong>.</li>
<li class="numberedList">Name the action <code class="inlineCode">Add Roles</code>, leave <strong class="screenText">Trigger</strong><strong class="keyWord"> </strong>and <strong class="screenText">Runtime</strong> as is, and press <strong class="screenText">Create</strong>.</li>
</ol>
<p class="normal">We will see a window where we can write our action.</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="9">Replace all the code with the following:
        <pre class="programlisting code"><code class="hljs-code">/**
 * @param {Event} event - Details about the user and the context in which they are logging in.
 * @param {PostLoginAPI} api - Interface whose methods can be used to change the behavior of the login.
 */
exports.onExecutePostLogin = async (event, api) =&gt; {
  const claimName  = 'http://schemas.microsoft.com/ws/2008/06/identity/claims/role'
  if (event.authorization) {
    api.idToken.setCustomClaim(claimName, event.authorization.roles);
    api.accessToken.setCustomClaim(claimName, event.authorization.roles);
  }
}
</code></pre>
</li>
<li class="numberedList">Click <strong class="screenText">Deploy</strong> and then <strong class="screenText">Back to flow</strong>.</li>
<li class="numberedList">Click <strong class="screenText">Custom</strong> again, and we will see our newly created action.</li>
<li class="numberedList">Drag the <strong class="screenText">Add Roles</strong> action to the arrow between <strong class="screenText">Start</strong> and <strong class="screenText">Complete</strong>.</li>
<li class="numberedList">Click <strong class="screenText">Apply</strong>.</li>
</ol>
<p class="normal">Now, we have an action that will add the roles to our login token.</p>
<p class="normal">Our user is now an administrator. It’s worth noting that roles are a paid feature in Auth0 and will only be free during the trial.</p>
<p class="normal">Now, let’s set up Blazor to use this new role.</p>
<h2 class="heading-2" id="_idParaDest-169">Adding roles to Blazor</h2>
<p class="normal">Since we are<a id="_idIndexMarker396"/> using the <a id="_idIndexMarker397"/>Auth0 library, the setup is almost done for Blazor.</p>
<p class="normal">Let’s modify a component to show whether the user is an administrator:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">Components</code> project, open <code class="inlineCode">Shared/NavMenu.razor</code>.</li>
<li class="numberedList">At the top of the component, add the following:
        <pre class="programlisting code"><code class="hljs-code">&lt;AuthorizeView Roles="Administrator"&gt;
    &lt;Authorized&gt;
        Hi admin!
    &lt;/Authorized&gt;
    &lt;NotAuthorized&gt;
        You are not an admin =(
    &lt;/NotAuthorized&gt;
&lt;/AuthorizeView&gt;
</code></pre>
</li>
<li class="numberedList">Now, run our BlazorWebApp project.</li>
</ol>
<p class="normal">If we log in, we should be able to see text to the left saying <strong class="screenText">Hi Admin!</strong> in black text on top of dark blue, so it might not be very visible. We will take care of this in <em class="chapterRef">Chapter 9</em>, <em class="italic">Sharing Code and Resources</em>.</p>
<h1 class="heading-1" id="_idParaDest-170">Summary</h1>
<p class="normal">In this chapter, we learned how to add authentication to our existing site. It is easier to add authentication when creating a project. Still, now we have a better understanding of what is going on under the hood and how to handle adding an external source for authentication.</p>
<p class="normal">Throughout the book, we have shared components between the different hosting models.</p>
<p class="normal">In the next chapter, we will look at sharing even more things, like static files and CSS, and try to make everything look nice.</p>
</div>
</body></html>