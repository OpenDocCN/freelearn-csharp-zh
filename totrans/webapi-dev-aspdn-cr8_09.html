<html><head></head><body>
<div id="_idContainer079">
<h1 class="chapter-number" id="_idParaDest-192"><a id="_idTextAnchor371"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-193"><a id="_idTextAnchor372"/><span class="koboSpan" id="kobo.2.1">Testing in ASP.NET Core (Part 1 – Unit Testing)</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Testing is an essential part of any software development process, including ASP.NET Core web API development. </span><span class="koboSpan" id="kobo.3.2">Testing helps to ensure that the application works as expected and meets the requirements. </span><span class="koboSpan" id="kobo.3.3">It also helps to ensure that any changes made to the code don’t break </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">existing functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we’ll look at the different types of testing that are available in ASP.NET Core and how to implement unit tests in ASP.NET Core web </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">API applications.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">We will cover the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Introduction to testing in </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">ASP.NET Core</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Writing </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">unit tests</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Testing the database </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">access layer</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.15.1">By the end of this chapter, you will be able to write unit tests for your ASP.NET Core web API application to ensure that the code unit is functioning correctly. </span><span class="koboSpan" id="kobo.15.2">You will also learn how to use some libraries, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.16.1">Moq</span></strong><span class="koboSpan" id="kobo.17.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.18.1">FluentAssertions</span></strong><span class="koboSpan" id="kobo.19.1">, to make your tests more readable </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">and maintainable.</span></span></p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor373"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">The code examples in this chapter can be found at </span><a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter9"><span class="koboSpan" id="kobo.23.1">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter9</span></a><span class="koboSpan" id="kobo.24.1">. </span><span class="koboSpan" id="kobo.24.2">You can use VS Code or VS 2022 to open </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">the solutions.</span></span></p>
<h1 id="_idParaDest-195"><a id="_idTextAnchor374"/><span class="koboSpan" id="kobo.26.1">Introduction to testing in ASP.NET Core</span></h1>
<p><span class="koboSpan" id="kobo.27.1">Different types of testing can be performed on an ASP.NET Core web API application, </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.29.1">Unit testing</span></strong><span class="koboSpan" id="kobo.30.1">: This is the</span><a id="_idIndexMarker921"/><span class="koboSpan" id="kobo.31.1"> process of testing individual units of code, such as methods and </span><a id="_idIndexMarker922"/><span class="koboSpan" id="kobo.32.1">classes, to ensure that they work as expected. </span><span class="koboSpan" id="kobo.32.2">Unit tests should be small, fast, and isolated from other units of code. </span><span class="koboSpan" id="kobo.32.3">Mocking frameworks can be used to isolate units of code from their dependencies, such as databases and </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">external services.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.34.1">Integration testing</span></strong><span class="koboSpan" id="kobo.35.1">: This</span><a id="_idIndexMarker923"/><span class="koboSpan" id="kobo.36.1"> involves testing the integration between</span><a id="_idIndexMarker924"/><span class="koboSpan" id="kobo.37.1"> different components of the application to ensure that they work together as expected. </span><span class="koboSpan" id="kobo.37.2">This type of testing helps to identify issues that may arise when the application is deployed to a production environment. </span><span class="koboSpan" id="kobo.37.3">Generally, integration tests are slower than unit tests. </span><span class="koboSpan" id="kobo.37.4">Integration tests may use mock objects or real objects, depending on the scenario. </span><span class="koboSpan" id="kobo.37.5">For example, if the integration test is to test the integration between the application and a database, then a real database instance should be used. </span><span class="koboSpan" id="kobo.37.6">But if the integration test is to test the application’s integration with an external service, such as a payment service, then we should use a mock object to simulate the external service. </span><span class="koboSpan" id="kobo.37.7">In the microservices architecture, integration tests are more complicated, as they may involve multiple services. </span><span class="koboSpan" id="kobo.37.8">Besides the integration tests for each service, there should also be integration tests for the </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">entire system.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.39.1">End-to-end testing</span></strong><span class="koboSpan" id="kobo.40.1">: This is </span><a id="_idIndexMarker925"/><span class="koboSpan" id="kobo.41.1">the process of testing the application from the user’s </span><a id="_idIndexMarker926"/><span class="koboSpan" id="kobo.42.1">perspective to ensure that the entire system from start to finish, including the user interface, the web API, the database, and more, is working as expected. </span><span class="koboSpan" id="kobo.42.2">End-to-end testing typically involves simulating user interactions with the application, such as clicking buttons and entering data </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">into forms.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.44.1">Regression testing</span></strong><span class="koboSpan" id="kobo.45.1">: This </span><a id="_idIndexMarker927"/><span class="koboSpan" id="kobo.46.1">involves testing whether the application still works as</span><a id="_idIndexMarker928"/><span class="koboSpan" id="kobo.47.1"> expected after new features are added or bugs are fixed. </span><span class="koboSpan" id="kobo.47.2">Regression testing is usually performed after the application is deployed to a production environment. </span><span class="koboSpan" id="kobo.47.3">It helps to ensure that the </span><a id="_idIndexMarker929"/><span class="koboSpan" id="kobo.48.1">new features </span><a id="_idIndexMarker930"/><span class="koboSpan" id="kobo.49.1">or bug fixes don’t break </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">existing functionality.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.51.1">Load testing</span></strong><span class="koboSpan" id="kobo.52.1">: This </span><a id="_idIndexMarker931"/><span class="koboSpan" id="kobo.53.1">involves testing whether the application can handle a normal </span><a id="_idIndexMarker932"/><span class="koboSpan" id="kobo.54.1">load of users and requests. </span><span class="koboSpan" id="kobo.54.2">It helps to set the baseline for the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">the application.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.56.1">Stress testing</span></strong><span class="koboSpan" id="kobo.57.1">: This</span><a id="_idIndexMarker933"/><span class="koboSpan" id="kobo.58.1"> involves testing whether the application can handle </span><a id="_idIndexMarker934"/><span class="koboSpan" id="kobo.59.1">extreme conditions, such as a sudden spike in the number of users and requests, or gradually increasing the load over a long period. </span><span class="koboSpan" id="kobo.59.2">It also determines whether the application can recover from failures and how long it takes </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">to recover.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.61.1">Performance testing</span></strong><span class="koboSpan" id="kobo.62.1">: This is a </span><a id="_idIndexMarker935"/><span class="koboSpan" id="kobo.63.1">type of testing that evaluates the performance</span><a id="_idIndexMarker936"/><span class="koboSpan" id="kobo.64.1"> of the application under different workloads, including response time, throughput, resource usage, and more. </span><span class="koboSpan" id="kobo.64.2">Performance testing is a superset of load testing and stress testing. </span><span class="koboSpan" id="kobo.64.3">Generally, unit testing and integration testing are performed in the development environment and the staging environment, while performance testing is performed in a production-like environment, such as</span><a id="_idIndexMarker937"/><span class="koboSpan" id="kobo.65.1"> a </span><strong class="bold"><span class="koboSpan" id="kobo.66.1">user acceptance testing</span></strong><span class="koboSpan" id="kobo.67.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.68.1">UAT</span></strong><span class="koboSpan" id="kobo.69.1">) environment, which closely mirrors the production environment in terms of infrastructure and configuration. </span><span class="koboSpan" id="kobo.69.2">This ensures that the performance tests are accurate and reliable. </span><span class="koboSpan" id="kobo.69.3">In some cases, limited performance testing can be performed in a development environment during scheduled maintenance windows to validate real-world </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">performance scenarios.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.71.1">Unit testing and integration testing are the most common types of testing that are written in .NET by developers. </span><span class="koboSpan" id="kobo.71.2">In this chapter, we will focus on unit testing; we will discuss integration testing</span><a id="_idTextAnchor375"/><span class="koboSpan" id="kobo.72.1"> in </span><a href="B18971_10.xhtml#_idTextAnchor404"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.73.1">Chapter 10</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.74.1">.</span></span></p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor376"/><span class="koboSpan" id="kobo.75.1">Writing unit tests</span></h1>
<p><span class="koboSpan" id="kobo.76.1">Unit tests are </span><a id="_idIndexMarker938"/><span class="koboSpan" id="kobo.77.1">written to test individual units of code, such as methods and classes. </span><span class="koboSpan" id="kobo.77.2">Unit tests are typically written by developers who are familiar with the code. </span><span class="koboSpan" id="kobo.77.3">When developers develop new features or fix bugs, they should also write unit tests to ensure that the code works as expected. </span><span class="koboSpan" id="kobo.77.4">There are many unit testing frameworks available for .NET, including NUnit, xUnit, and MSTest. </span><span class="koboSpan" id="kobo.77.5">In this chapter, we will use xUnit to </span><a id="_idIndexMarker939"/><span class="koboSpan" id="kobo.78.1">write unit tests since it is one of the most popular unit testing frameworks for modern .NET applic</span><a id="_idTextAnchor377"/><span class="koboSpan" id="kobo.79.1">ations </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">at present.</span></span></p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor378"/><span class="koboSpan" id="kobo.81.1">Preparing the sample application</span></h2>
<p><span class="koboSpan" id="kobo.82.1">The sample </span><a id="_idIndexMarker940"/><span class="koboSpan" id="kobo.83.1">application, </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">InvoiceApp</span></strong><span class="koboSpan" id="kobo.85.1">, is a simple ASP.NET Core web API application that exposes a set of RESTful APIs for managing invoices. </span><span class="koboSpan" id="kobo.85.2">The sample application uses EF Core to store and retrieve data from a SQL Server database. </span><span class="koboSpan" id="kobo.85.3">It has the </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">following endpoints:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.87.1">Invoices API</span></strong><span class="koboSpan" id="kobo.88.1">: This </span><a id="_idIndexMarker941"/><span class="koboSpan" id="kobo.89.1">endpoint is used to manage invoices. </span><span class="koboSpan" id="kobo.89.2">It supports the </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">following operations:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">GET /api/invoices</span></strong><span class="koboSpan" id="kobo.92.1">: Retrieves a list </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">of invoices</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">GET /api/invoices/{id}</span></strong><span class="koboSpan" id="kobo.95.1">: Retrieves an invoice </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">by ID</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">POST /api/invoices</span></strong><span class="koboSpan" id="kobo.98.1">: Creates a </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">new invoice</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">PUT /api/invoices/{id}</span></strong><span class="koboSpan" id="kobo.101.1">: Updates an </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">existing invoice</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">DELETE /api/invoices/{id}</span></strong><span class="koboSpan" id="kobo.104.1">: Deletes </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">an invoice</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">PATCH /api/invoices/{id}/status</span></strong><span class="koboSpan" id="kobo.107.1">: Updates the status of </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">an invoice</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">POST /api/invoices/{id}/send</span></strong><span class="koboSpan" id="kobo.110.1">: Sends an invoice email to </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">the contact</span></span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.112.1">Contacts API</span></strong><span class="koboSpan" id="kobo.113.1">: This</span><a id="_idIndexMarker942"/><span class="koboSpan" id="kobo.114.1"> endpoint is used to manage contacts. </span><span class="koboSpan" id="kobo.114.2">Each invoice is associated with a contact. </span><span class="koboSpan" id="kobo.114.3">It supports the </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">following operations:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">GET /api/contacts</span></strong><span class="koboSpan" id="kobo.117.1">: Retrieves a list </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">of contacts</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">GET /api/contacts/{id}</span></strong><span class="koboSpan" id="kobo.120.1">: Retrieves a contact </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">by ID</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">POST /api/contacts</span></strong><span class="koboSpan" id="kobo.123.1">: Creates a </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">new contact</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">PUT /api/contacts/{id}</span></strong><span class="koboSpan" id="kobo.126.1">: Updates an </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">existing contact</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">DELETE /api/contacts/{id}</span></strong><span class="koboSpan" id="kobo.129.1">: Deletes </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">a contact</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">GET /api/contacts/{id}/invoices</span></strong><span class="koboSpan" id="kobo.132.1">: Retrieves a list of invoices for </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">a contact</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.134.1">Note that the preceding endpoints are not enough to build a complete invoice management application. </span><span class="koboSpan" id="kobo.134.2">It is just a sample application to demonstrate how to write unit tests and integration tests for ASP.NET Core web </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">API applications.</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">In addition, the</span><a id="_idIndexMarker943"/><span class="koboSpan" id="kobo.137.1"> sample application has a Swagger UI that can be used to test the APIs. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.138.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.139.1">.1</span></em><span class="koboSpan" id="kobo.140.1"> shows the Swagger UI for the </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">sample application:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<span class="koboSpan" id="kobo.142.1"><img alt="Figure 9.1 – The sample application API endpoints" src="image/B18971_09_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.143.1">Figure 9.1 – The sample application API endpoints</span></p>
<p><span class="koboSpan" id="kobo.144.1">After you </span><a id="_idIndexMarker944"/><span class="koboSpan" id="kobo.145.1">run the sample application using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">dotnet run</span></strong><span class="koboSpan" id="kobo.147.1"> command, you can access the Swagger UI </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">at </span></span><a href="http://localhost:5087/swagger/index.html"><span class="No-Break"><span class="koboSpan" id="kobo.149.1">http://localhost:5087/swagger/index.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.150.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">Now, we will use this sample application to demonstrate how to write unit tests for ASP.NET Core</span><a id="_idTextAnchor379"/><span class="koboSpan" id="kobo.152.1"> web </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">API applications.</span></span></p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor380"/><span class="koboSpan" id="kobo.154.1">Setting up the unit tests project</span></h2>
<p><span class="koboSpan" id="kobo.155.1">We will use xUnit to write</span><a id="_idIndexMarker945"/><span class="koboSpan" id="kobo.156.1"> unit tests for the sample application. </span><span class="koboSpan" id="kobo.156.2">xUnit is a popular unit testing framework for .NET applications. </span><span class="koboSpan" id="kobo.156.3">It is a free, open-source project that has been around for many years. </span><span class="koboSpan" id="kobo.156.4">It is also the default unit testing framework for .NET Core and .NET 5+ applications. </span><span class="koboSpan" id="kobo.156.5">You can find more information about xUnit </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">at </span></span><a href="https://xunit.net/"><span class="No-Break"><span class="koboSpan" id="kobo.158.1">https://xunit.net/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.159.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">To set up the test project, you can use VS 2022 or the .NET CLI. </span><span class="koboSpan" id="kobo.160.2">If you use VS 2022, you can create a new xUnit test project by right-clicking on the solution and selecting </span><strong class="bold"><span class="koboSpan" id="kobo.161.1">Add</span></strong><span class="koboSpan" id="kobo.162.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.163.1">New Project</span></strong><span class="koboSpan" id="kobo.164.1">. </span><span class="koboSpan" id="kobo.164.2">Then, select </span><strong class="bold"><span class="koboSpan" id="kobo.165.1">xUnit Test Project</span></strong><span class="koboSpan" id="kobo.166.1"> from the list of project templates. </span><span class="koboSpan" id="kobo.166.2">You can name the project </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">InvoiceApp.UnitTests</span></strong><span class="koboSpan" id="kobo.168.1"> and click </span><strong class="bold"><span class="koboSpan" id="kobo.169.1">Create</span></strong><span class="koboSpan" id="kobo.170.1"> to create </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">the project:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.172.1"><img alt="Figure 9.2 – Creating a new xUnit test project in VS 2022" src="image/B18971_09_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.173.1">Figure 9.2 – Creating a new xUnit test project in VS 2022</span></p>
<p><span class="koboSpan" id="kobo.174.1">After you create the project, add a project reference to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">InvoiceApp.WebApi</span></strong><span class="koboSpan" id="kobo.176.1"> project so that the test project can access the classes in the main web API project. </span><span class="koboSpan" id="kobo.176.2">You can do this by right-clicking on the </span><strong class="bold"><span class="koboSpan" id="kobo.177.1">Dependencies</span></strong><span class="koboSpan" id="kobo.178.1"> node in the test project and selecting </span><strong class="bold"><span class="koboSpan" id="kobo.179.1">Add Project Reference</span></strong><span class="koboSpan" id="kobo.180.1">. </span><span class="koboSpan" id="kobo.180.2">Then, select the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">InvoiceApp.WebApi</span></strong><span class="koboSpan" id="kobo.182.1"> project from the list of</span><a id="_idIndexMarker946"/><span class="koboSpan" id="kobo.183.1"> projects and click </span><strong class="bold"><span class="koboSpan" id="kobo.184.1">OK</span></strong><span class="koboSpan" id="kobo.185.1"> to add the </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">project reference:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<span class="koboSpan" id="kobo.187.1"><img alt="Figure 9.3 – Adding a project reference to the test project in VS 2022" src="image/B18971_09_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.188.1">Figure 9.3 – Adding a project reference to the test project in VS 2022</span></p>
<p><span class="koboSpan" id="kobo.189.1">If you use the .NET CLI, you can create a new xUnit test project by running the following commands in </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">the terminal:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.191.1">
dotnet new xunit -n InvoiceApp.UnitTests</span></pre> <p><span class="koboSpan" id="kobo.192.1">Then, you can add the test project to the solution by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">following commands:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.194.1">
dotnet sln InvoiceApp.sln add InvoiceApp.UnitTests/InvoiceApp.UnitTests.csproj</span></pre> <p><span class="koboSpan" id="kobo.195.1">You also need to add the reference to the main project by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.197.1">
dotnet add InvoiceApp.UnitTests/InvoiceApp.UnitTests.csproj reference InvoiceApp.WebApi/InvoiceApp.WebApi.csproj</span></pre> <p><span class="koboSpan" id="kobo.198.1">The default xUnit </span><a id="_idIndexMarker947"/><span class="koboSpan" id="kobo.199.1">test project template contains a sample unit test. </span><span class="koboSpan" id="kobo.199.2">You can delete the sample unit test named </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">UnitTest1.cs</span></strong><span class="koboSpan" id="kobo.201.1">; we will write our own unit tests in the </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">If you create the test project starting from a blank .NET library project, you need to add the following packages to the </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">test project:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">Microsoft.NET.Test.Sdk</span></strong><span class="koboSpan" id="kobo.206.1">: This is required for running </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">unit tests</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">xunit</span></strong><span class="koboSpan" id="kobo.209.1">: This is the xUnit framework that we will use to write </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">unit tests</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">xunit.runner.visualstudio</span></strong><span class="koboSpan" id="kobo.212.1">: This is required for running unit tests in </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">Visual Studio</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">coverlet.collector</span></strong><span class="koboSpan" id="kobo.215.1">: This is an open-source project that provides code coverage analysis for .</span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">NET applications</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.217.1">When we write unit </span><a id="_idIndexMarker948"/><span class="koboSpan" id="kobo.218.1">tests, keep in mind that one unit test should test one unit of code, such as a method or a class. </span><span class="koboSpan" id="kobo.218.2">The unit test should be isolated from other units of code. </span><span class="koboSpan" id="kobo.218.3">If one method depends on another method, we should mock the other method to isolate the unit of code to ensure that we focus on the behavior of the unit of c</span><a id="_idTextAnchor381"/><span class="koboSpan" id="kobo.219.1">ode that we </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">are testing.</span></span></p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor382"/><span class="koboSpan" id="kobo.221.1">Writing unit tests without dependencies</span></h2>
<p><span class="koboSpan" id="kobo.222.1">Let’s see the </span><a id="_idIndexMarker949"/><span class="koboSpan" id="kobo.223.1">first example. </span><span class="koboSpan" id="kobo.223.2">In the sample application, you can find a </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">Services</span></strong><span class="koboSpan" id="kobo.225.1"> folder, which includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">IEmailService</span></strong><span class="koboSpan" id="kobo.227.1"> interface and its implementation, </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">EmailService</span></strong><span class="koboSpan" id="kobo.229.1">. </span><span class="koboSpan" id="kobo.229.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">EmailService</span></strong><span class="koboSpan" id="kobo.231.1"> class has a method named </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">GenerateInvoiceEmail()</span></strong><span class="koboSpan" id="kobo.233.1">. </span><span class="koboSpan" id="kobo.233.2">This method is a simple function that generates an email according to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">Invoice</span></strong><span class="koboSpan" id="kobo.235.1"> entity. </span><span class="koboSpan" id="kobo.235.2">The following code shows the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">GenerateInvoiceEmail()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.237.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.238.1">
public (string to, string subject, string body) GenerateInvoiceEmail(Invoice invoice){
    var to = invoice.Contact.Email;
    var subject = $"Invoice {invoice.InvoiceNumber} for {invoice.Contact.FirstName} {invoice.Contact.LastName}";
    var body = $"""
        Dear {invoice.Contact.FirstName} {invoice.Contact.LastName},
        Thank you for your business. </span><span class="koboSpan" id="kobo.238.2">Here are your invoice details:
        Invoice Number: {invoice.InvoiceNumber}
        Invoice Date: {invoice.InvoiceDate.LocalDateTime.ToShortDateString()}
        Invoice Amount: {invoice.Amount.ToString("C")}
        Invoice Items:
        {string.Join(Environment.NewLine, invoice.InvoiceItems.Select(i =&gt; $"{i.Description} - {i.Quantity} x {i.UnitPrice.ToString("C")}"))}
        Please pay by {invoice.DueDate.LocalDateTime.ToShortDateString()}. </span><span class="koboSpan" id="kobo.238.3">Thank you!
</span><span class="koboSpan" id="kobo.238.4">        Regards,
        InvoiceApp
        """;
    return (to, subject, body);
}</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.239.1">Raw string literal</span></p>
<p class="callout"><span class="koboSpan" id="kobo.240.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">body</span></strong><span class="koboSpan" id="kobo.242.1"> variable is a </span><a id="_idIndexMarker950"/><span class="koboSpan" id="kobo.243.1">raw string literal, which is a new feature that was introduced in C# 11. </span><span class="koboSpan" id="kobo.243.2">Raw string literals are </span><a id="_idIndexMarker951"/><span class="koboSpan" id="kobo.244.1">enclosed in triple quotes (</span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">"""</span></strong><span class="koboSpan" id="kobo.246.1">). </span><span class="koboSpan" id="kobo.246.2">They can span multiple lines and can contain double quotes without escaping them. </span><span class="koboSpan" id="kobo.246.3">You can find more information about raw string</span><a id="_idIndexMarker952"/><span class="koboSpan" id="kobo.247.1"> literals at </span><a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/raw-string"><span class="koboSpan" id="kobo.248.1">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/raw-string</span></a><span class="koboSpan" id="kobo.249.1">. </span><span class="koboSpan" id="kobo.249.2">Raw strings can also be used with interpolated strings, which is convenient for generating strings </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">with variables.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">There is no</span><a id="_idIndexMarker953"/><span class="koboSpan" id="kobo.252.1"> dependency in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">GenerateInvoiceEmail()</span></strong><span class="koboSpan" id="kobo.254.1"> method, so we can write a unit test for this method without mocking any other methods. </span><span class="koboSpan" id="kobo.254.2">Create a class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">EmailServiceTests</span></strong><span class="koboSpan" id="kobo.256.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">InvoiceApp.UnitTests</span></strong><span class="koboSpan" id="kobo.258.1"> project. </span><span class="koboSpan" id="kobo.258.2">Then, add the following code to </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">the class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.260.1">
[Fact]public void GenerateInvoiceEmail_Should_Return_Email()
{
    var invoiceDate = DateTimeOffset.Now;
    var dueDate = invoiceDate.AddDays(30);
    // Arrange
    var invoice = new Invoice
    {
        Id = Guid.NewGuid(),
        InvoiceNumber = "INV-001",
        Amount = 500,
        DueDate = dueDate,
        // Omit other properties for brevity
    };
    // Act
    var (to, subject, body) = new EmailService().GenerateInvoiceEmail(invoice);
    // Assert
    Assert.Equal(invoice.Contact.Email, to);
    Assert.Equal($"Invoice INV-001 for John Doe", subject);
    Assert.Equal($"""
        Dear John Doe,
        Thank you for your business. </span><span class="koboSpan" id="kobo.260.2">Here are your invoice details:
        Invoice Number: INV-001
        Invoice Date: {invoiceDate.LocalDateTime.ToShortDateString()}
        Invoice Amount: {invoice.Amount.ToString("C")}
        Invoice Items:
        Item 1 - 1 x $100.00
        Item 2 - 2 x $200.00
        Please pay by {invoice.DueDate.LocalDateTime.ToShortDateString()}. </span><span class="koboSpan" id="kobo.260.3">Thank you!
</span><span class="koboSpan" id="kobo.260.4">        Regards,
        InvoiceApp
        """, body);
}</span></pre>
<p><span class="koboSpan" id="kobo.261.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">Fact</span></strong><span class="koboSpan" id="kobo.263.1"> attribute</span><a id="_idIndexMarker954"/><span class="koboSpan" id="kobo.264.1"> indicates that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">GenerateInvoiceEmail_Should_Return_Email()</span></strong><span class="koboSpan" id="kobo.266.1"> method is a unit test so that xUnit can discover and run this method as a unit test. </span><span class="koboSpan" id="kobo.266.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">GenerateInvoiceEmail_Should_Return_Email()</span></strong><span class="koboSpan" id="kobo.268.1"> method, we created an </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">Invoice</span></strong><span class="koboSpan" id="kobo.270.1"> object and passed it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">GenerateInvoiceEmail()</span></strong><span class="koboSpan" id="kobo.272.1"> method. </span><span class="koboSpan" id="kobo.272.2">Then, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">Assert</span></strong><span class="koboSpan" id="kobo.274.1"> class to verify that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">GenerateInvoiceEmail()</span></strong><span class="koboSpan" id="kobo.276.1"> method returns the </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">expected email.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">When writing </span><a id="_idIndexMarker955"/><span class="koboSpan" id="kobo.279.1">unit tests, we follow the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.280.1">Arrange-Act-Assert</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.281.1"> pattern:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.282.1">Arrange</span></strong><span class="koboSpan" id="kobo.283.1">: This is where </span><a id="_idIndexMarker956"/><span class="koboSpan" id="kobo.284.1">we prepare the data and set up the environment for the </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">unit test</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.286.1">Act</span></strong><span class="koboSpan" id="kobo.287.1">: This is where we call the method that we want </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">to test</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.289.1">Assert</span></strong><span class="koboSpan" id="kobo.290.1">: This is where we verify that the method returns the expected result or that the method behaves </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">as expected</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.292.1">To run the unit test in VS 2022, you can right-click on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">InvoiceApp.UnitTests</span></strong><span class="koboSpan" id="kobo.294.1"> project or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">EmailServiceTest.cs</span></strong><span class="koboSpan" id="kobo.296.1"> file and select </span><strong class="bold"><span class="koboSpan" id="kobo.297.1">Run Tests</span></strong><span class="koboSpan" id="kobo.298.1">. </span><span class="koboSpan" id="kobo.298.2">You can also use the </span><strong class="bold"><span class="koboSpan" id="kobo.299.1">Test Explorer</span></strong><span class="koboSpan" id="kobo.300.1"> window to run the unit test by clicking the </span><strong class="bold"><span class="koboSpan" id="kobo.301.1">Test</span></strong><span class="koboSpan" id="kobo.302.1"> menu and selecting </span><strong class="bold"><span class="koboSpan" id="kobo.303.1">Run </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.304.1">all tests</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<span class="koboSpan" id="kobo.306.1"><img alt="Figure 9.4 – Running unit tests in VS 2022" src="image/B18971_09_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.307.1">Figure 9.4 – Running unit tests in VS 2022</span></p>
<p><span class="koboSpan" id="kobo.308.1">VS Code supports running unit tests as well. </span><span class="koboSpan" id="kobo.308.2">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.309.1">Testing</span></strong><span class="koboSpan" id="kobo.310.1"> icon on the left-hand side of the VS Code window to open the </span><strong class="bold"><span class="koboSpan" id="kobo.311.1">Test</span></strong><span class="koboSpan" id="kobo.312.1"> view; you will see the unit tests, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.313.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.314.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<span class="koboSpan" id="kobo.316.1"><img alt="Figure 9.5 – Running unit tests in VS Code" src="image/B18971_09_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.317.1">Figure 9.5 – Running unit tests in VS Code</span></p>
<p><span class="koboSpan" id="kobo.318.1">If you use the .NET CLI, you can run the unit tests by running the following command in </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">the terminal:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.320.1">
dotnet test</span></pre> <p><span class="koboSpan" id="kobo.321.1">You will see the</span><a id="_idIndexMarker957"/> <span class="No-Break"><span class="koboSpan" id="kobo.322.1">following output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.323.1">
Starting test execution, please wait...A total of 1 test files matched the specified pattern.
</span><span class="koboSpan" id="kobo.323.2">Passed!  - Failed:     0, Passed:     1, Skipped:     0, Total:     1, Duration: &lt; 1 ms - InvoiceApp.UnitTests.dll (net8.0)</span></pre>
<p><span class="koboSpan" id="kobo.324.1">The output shows that the unit test passed. </span><span class="koboSpan" id="kobo.324.2">If you want to see the detailed test results, you can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.326.1">
dotnet test --verbosity normal</span></pre> <p><span class="koboSpan" id="kobo.327.1">You will see</span><a id="_idIndexMarker958"/><span class="koboSpan" id="kobo.328.1"> detailed test results that show the test name, the resul</span><a id="_idTextAnchor383"/><span class="koboSpan" id="kobo.329.1">t, the duration, and </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">the output.</span></span></p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor384"/><span class="koboSpan" id="kobo.331.1">Writing unit tests with dependencies</span></h2>
<p><span class="koboSpan" id="kobo.332.1">Let’s look at </span><a id="_idIndexMarker959"/><span class="koboSpan" id="kobo.333.1">another example. </span><span class="koboSpan" id="kobo.333.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">EmailService</span></strong><span class="koboSpan" id="kobo.335.1"> class, there is a method named </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">SendEmailAsync()</span></strong><span class="koboSpan" id="kobo.337.1">, which sends an email to the recipient. </span><span class="koboSpan" id="kobo.337.2">In real-world applications, we usually use a third-party email service to send emails. </span><span class="koboSpan" id="kobo.337.3">To make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">EmailService</span></strong><span class="koboSpan" id="kobo.339.1"> class testable, we can create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">IEmailSender</span></strong><span class="koboSpan" id="kobo.341.1"> interface and its implementation, </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">EmailSender</span></strong><span class="koboSpan" id="kobo.343.1">. </span><span class="koboSpan" id="kobo.343.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">EmailSender</span></strong><span class="koboSpan" id="kobo.345.1"> class is a wrapper of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">SmtpClient</span></strong><span class="koboSpan" id="kobo.347.1"> class, which is used to send emails. </span><span class="koboSpan" id="kobo.347.2">The following code shows the updated </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">EmailService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.349.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.350.1">
public async Task SendEmailAsync(string to, string subject, string body){
    // Mock the email sending process
    // In real world, you may use a third-party email service, such as SendGrid, MailChimp, Azure Logic Apps, etc.
</span><span class="koboSpan" id="kobo.350.2">    logger.LogInformation($"Sending email to {to} with subject {subject} and body {body}");
    try
    {
        await emailSender.SendEmailAsync(to, subject, body);
        logger.LogInformation($"Email sent to {to} with subject {subject}");
    }
    catch (SmtpException e)
    {
        logger.LogError(e, $"SmtpClient error occurs. </span><span class="koboSpan" id="kobo.350.3">Failed to send email to {to} with subject {subject}.");
    }
    catch (Exception e)
    {
        logger.LogError(e, $"Failed to send email to {to} with subject {subject}.");
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.351.1">So, now, </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">EmailService</span></strong><span class="koboSpan" id="kobo.353.1"> has a dependency on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">IEmailSender</span></strong><span class="koboSpan" id="kobo.355.1"> interface. </span><span class="koboSpan" id="kobo.355.2">To test the behavior of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">SendEmailAsync()</span></strong><span class="koboSpan" id="kobo.357.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">EmailService</span></strong><span class="koboSpan" id="kobo.359.1"> class, we need to mock the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">IEmailSender</span></strong><span class="koboSpan" id="kobo.361.1"> interface to isolate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">EmailService</span></strong><span class="koboSpan" id="kobo.363.1"> class from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">EmailSender</span></strong><span class="koboSpan" id="kobo.365.1"> class. </span><span class="koboSpan" id="kobo.365.2">Otherwise, if any error occurs in the unit test, we cannot say for sure whether the error is caused by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">EmailService</span></strong><span class="koboSpan" id="kobo.367.1"> class or the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">EmailSender</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.369.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.370.1">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">Moq</span></strong><span class="koboSpan" id="kobo.372.1"> library</span><a id="_idIndexMarker960"/><span class="koboSpan" id="kobo.373.1"> to mock the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">IEmailSender</span></strong><span class="koboSpan" id="kobo.375.1"> interface. </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">Moq</span></strong><span class="koboSpan" id="kobo.377.1"> is a popular mocking library for .NET. </span><span class="koboSpan" id="kobo.377.2">It is available as a NuGet package. </span><span class="koboSpan" id="kobo.377.3">To install </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">Moq</span></strong><span class="koboSpan" id="kobo.379.1">, you can use </span><strong class="bold"><span class="koboSpan" id="kobo.380.1">NuGet Package Manager</span></strong><span class="koboSpan" id="kobo.381.1"> in VS 2022 or run the </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.383.1">
dotnet add package Moq</span></pre> <p><span class="koboSpan" id="kobo.384.1">Then, we can create the unit tests for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">SendEmailAsync()</span></strong><span class="koboSpan" id="kobo.386.1"> method. </span><span class="koboSpan" id="kobo.386.2">Because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">SendEmailAsync()</span></strong><span class="koboSpan" id="kobo.388.1"> method may throw an exception if the email-sending process fails, we need to write two unit tests to test the success and failure scenarios. </span><span class="koboSpan" id="kobo.388.2">The following code shows the unit test for the </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">success scenario:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.390.1">
[Fact]public async Task SendEmailAsync_Should_Send_Email()
{
    // Arrange
    var to = "user@example.com";
    var subject = "Test Email";
    var body = "Hello, this is a test email";
    var emailSenderMock = new Mock&lt;IEmailSender&gt;();
    emailSenderMock.Setup(m =&gt; m.SendEmailAsync(It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;()))
        .Returns(Task.CompletedTask);
    var loggerMock = new Mock&lt;ILogger&lt;IEmailService&gt;&gt;();
    loggerMock.Setup(l =&gt; l.Log(It.IsAny&lt;LogLevel&gt;(), It.IsAny&lt;EventId&gt;(), It.IsAny&lt;It.IsAnyType&gt;(),
        It.IsAny&lt;Exception&gt;(), (Func&lt;It.IsAnyType, Exception?, string&gt;)It.IsAny&lt;object&gt;())).Verifiable();
    var emailService = new EmailService(loggerMock.Object, emailSenderMock.Object);
    // Act
    await emailService.SendEmailAsync(to, subject, body);
    // Assert
    emailSenderMock.Verify(m =&gt; m.SendEmailAsync(It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;()), Times.Once);
    loggerMock.Verify(
        l =&gt; l.Log(
            It.IsAny&lt;LogLevel&gt;(),
            It.IsAny&lt;EventId&gt;(),
            It.Is&lt;It.IsAnyType&gt;((v, t) =&gt; v.ToString().Contains($"Sending email to {to} with subject {subject} and body {body}")),
            It.IsAny&lt;Exception&gt;(),
            (Func&lt;It.IsAnyType, Exception?, string&gt;)It.IsAny&lt;object&gt;()
        ),
        Times.Once
    );
    loggerMock.Verify(
        l =&gt; l.Log(
            It.IsAny&lt;LogLevel&gt;(),
            It.IsAny&lt;EventId&gt;(),
            It.Is&lt;It.IsAnyType&gt;((v, t) =&gt; v.ToString().Contains($"Email sent to {to} with subject {subject}")),
            It.IsAny&lt;Exception&gt;(),
            (Func&lt;It.IsAnyType, Exception?, string&gt;)It.IsAny&lt;object&gt;()
        ),
        Times.Once
    );
}</span></pre>
<p><span class="koboSpan" id="kobo.391.1">In the</span><a id="_idIndexMarker961"/><span class="koboSpan" id="kobo.392.1"> preceding code, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">Mock</span></strong><span class="koboSpan" id="kobo.394.1"> class to create mock objects of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">IEmailSender</span></strong><span class="koboSpan" id="kobo.396.1"> interface and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">ILogger</span></strong><span class="koboSpan" id="kobo.398.1"> interface. </span><span class="koboSpan" id="kobo.398.2">We need to set up the behavior of the methods for the mock objects. </span><span class="koboSpan" id="kobo.398.3">If the methods used in the unit test are not set up, the unit test will fail. </span><span class="koboSpan" id="kobo.398.4">For example, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">SetUp()</span></strong><span class="koboSpan" id="kobo.400.1"> method to mock the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">SendEmailAsync</span></strong><span class="koboSpan" id="kobo.402.1"> method of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">IEmailSender</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.404.1"> interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.405.1">
emailSenderMock.Setup(m =&gt; m.SendEmailAsync(It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;()))    .Returns(Task.CompletedTask);</span></pre>
<p><span class="koboSpan" id="kobo.406.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">SetUp()</span></strong><span class="koboSpan" id="kobo.408.1"> method takes a lambda expression as the parameter, which is used to configure the behavior of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">SendEmailAsync()</span></strong><span class="koboSpan" id="kobo.410.1"> method. </span><span class="koboSpan" id="kobo.410.2">In the preceding code, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">It.IsAny&lt;string&gt;()</span></strong><span class="koboSpan" id="kobo.412.1"> method to specify that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">SendEmailAsync()</span></strong><span class="koboSpan" id="kobo.414.1"> method can accept any string value as the parameter. </span><span class="koboSpan" id="kobo.414.2">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">Returns()</span></strong><span class="koboSpan" id="kobo.416.1"> method to specify the return value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">SendEmailAsync()</span></strong><span class="koboSpan" id="kobo.418.1"> method. </span><span class="koboSpan" id="kobo.418.2">In this case, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">Task.CompletedTask</span></strong><span class="koboSpan" id="kobo.420.1"> property to specify that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">SendEmailAsync()</span></strong><span class="koboSpan" id="kobo.422.1"> method will return a completed task. </span><span class="koboSpan" id="kobo.422.2">If you need to return a specific value, you can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">Returns()</span></strong><span class="koboSpan" id="kobo.424.1"> method to return a specific value. </span><span class="koboSpan" id="kobo.424.2">For example, if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">SendEmailAsync()</span></strong><span class="koboSpan" id="kobo.426.1"> method returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">bool</span></strong><span class="koboSpan" id="kobo.428.1"> value, you can use the following code to return a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.430.1"> value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.431.1">
emailSenderMock.Setup(m =&gt; m.SendEmailAsync(It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;()))    .ReturnsAsync(true);</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.432.1">Mocking the ILogger interface</span></p>
<p class="callout"><span class="koboSpan" id="kobo.433.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">EmailService</span></strong><span class="koboSpan" id="kobo.435.1"> class uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">ILogger</span></strong><span class="koboSpan" id="kobo.437.1"> interface to log the information and errors. </span><span class="koboSpan" id="kobo.437.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">LogInformation()</span></strong><span class="koboSpan" id="kobo.439.1"> method to log the information and </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">LogError()</span></strong><span class="koboSpan" id="kobo.441.1"> method to log the errors. </span><span class="koboSpan" id="kobo.441.2">However, we cannot mock the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">LogInformation()</span></strong><span class="koboSpan" id="kobo.443.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">LogError()</span></strong><span class="koboSpan" id="kobo.445.1"> method directly because they are extension methods on top of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">ILogger</span></strong><span class="koboSpan" id="kobo.447.1"> interface. </span><span class="koboSpan" id="kobo.447.2">These extension methods, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">LogInformation()</span></strong><span class="koboSpan" id="kobo.449.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">LogError()</span></strong><span class="koboSpan" id="kobo.451.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">LogDebug()</span></strong><span class="koboSpan" id="kobo.453.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">LogWarning()</span></strong><span class="koboSpan" id="kobo.455.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">LogCritical()</span></strong><span class="koboSpan" id="kobo.457.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">LogTrace()</span></strong><span class="koboSpan" id="kobo.459.1">, and others, all call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">Log()</span></strong><span class="koboSpan" id="kobo.461.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">ILogger</span></strong><span class="koboSpan" id="kobo.463.1"> interface. </span><span class="koboSpan" id="kobo.463.2">Therefore, to verify that a given log message is logged, it is necessary to mock only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">Log()</span></strong><span class="koboSpan" id="kobo.465.1"> method of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">ILogger</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.467.1"> interface.</span></span></p>
<p><span class="koboSpan" id="kobo.468.1">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">SendEmailAsync()</span></strong><span class="koboSpan" id="kobo.470.1"> method throws an exception, we need to ensure the logger will log the </span><a id="_idIndexMarker962"/><span class="koboSpan" id="kobo.471.1">exception when the exception occurs. </span><span class="koboSpan" id="kobo.471.2">To test the failure scenario, we need to mock the </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">SendEmailAsync()</span></strong><span class="koboSpan" id="kobo.473.1"> method so that it throws an exception. </span><span class="koboSpan" id="kobo.473.2">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">ThrowsAsync()</span></strong><span class="koboSpan" id="kobo.475.1"> method to mock the </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">SendEmailAsync()</span></strong><span class="koboSpan" id="kobo.477.1"> method to throw an exception explicitly. </span><span class="koboSpan" id="kobo.477.2">The following code shows how to mock the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">SendEmailAsync()</span></strong><span class="koboSpan" id="kobo.479.1"> method to throw </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">an exception:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.481.1">
emailSenderMock.Setup(m =&gt; m.SendEmailAsync(It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;()))  .ThrowsAsync(new SmtpException("Test SmtpException"));</span></pre>
<p><span class="koboSpan" id="kobo.482.1">Then, we can verify whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">LogError()</span></strong><span class="koboSpan" id="kobo.484.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">ILogger</span></strong><span class="koboSpan" id="kobo.486.1"> interface is called when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">SendEmailAsync()</span></strong><span class="koboSpan" id="kobo.488.1"> method throws an exception, as </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.490.1">
// Act + Assertawait Assert.ThrowsAsync&lt;SmtpException&gt;(() =&gt; emailService.SendEmailAsync(to, subject, body));
loggerMock.Verify(
    l =&gt; l.Log(
        It.IsAny&lt;LogLevel&gt;(),
        It.IsAny&lt;EventId&gt;(),
        It.Is&lt;It.IsAnyType&gt;((v, t) =&gt;
            v.ToString().Contains($"Failed to send email to {to} with subject {subject}")),
        It.IsAny&lt;SmtpException&gt;(),
        (Func&lt;It.IsAnyType, Exception?, string&gt;)It.IsAny&lt;object&gt;()
    ),
    Times.Once
);</span></pre>
<p><span class="koboSpan" id="kobo.491.1">In this way, we can ensure that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">SendEmailAsync()</span></strong><span class="koboSpan" id="kobo.493.1"> method will log the exception when the </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">exception occurs.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">When we write</span><a id="_idIndexMarker963"/><span class="koboSpan" id="kobo.496.1"> unit tests, note that the test method name should be descriptive and should indicate the purpose of the test. </span><span class="koboSpan" id="kobo.496.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">SendEmailAsync_ShouldLogError_WhenEmailSendingFails()</span></strong><span class="koboSpan" id="kobo.498.1"> is a good name because it indicates that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">SendEmailAsync</span></strong><span class="koboSpan" id="kobo.500.1"> method should log an error when the email sending fails. </span><span class="koboSpan" id="kobo.500.2">However, </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">SendEmailAsyncTest()</span></strong><span class="koboSpan" id="kobo.502.1"> is not a good name because it does not indicate the purpose of </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">the test.</span></span></p>
<p><span class="koboSpan" id="kobo.504.1">For more information about how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">Mock</span></strong><span class="koboSpan" id="kobo.506.1"> library to create mock obj</span><a id="_idTextAnchor385"/><span class="koboSpan" id="kobo.507.1">ects, </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">see </span></span><a href="https://github.com/moq/moq"><span class="No-Break"><span class="koboSpan" id="kobo.509.1">https://github.com/moq/moq</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.510.1">.</span></span></p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor386"/><span class="koboSpan" id="kobo.511.1">Using FluentAssertions to verify the test results</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">xUnit</span></strong><span class="koboSpan" id="kobo.513.1"> provides a set </span><a id="_idIndexMarker964"/><span class="koboSpan" id="kobo.514.1">of static assertion methods to verify the test results. </span><span class="koboSpan" id="kobo.514.2">For example, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">Assert.Equal()</span></strong><span class="koboSpan" id="kobo.516.1"> method to verify if two objects are equal. </span><span class="koboSpan" id="kobo.516.2">These methods cover most of the scenarios, such as verifying objects, collections, exceptions, events, equality, types, and more. </span><span class="koboSpan" id="kobo.516.3">Here is a list of the assertion methods provided </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">by xUnit:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-7">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.518.1">xUnit </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.519.1">Assertion Methods</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.520.1">Explanation</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">Assert.Equal(expected, actual)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.522.1">Verifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">expected</span></strong><span class="koboSpan" id="kobo.524.1"> value is equal to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">actual</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.526.1"> value</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">Assert.NotEqual(expected, actual)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.528.1">Verifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">expected</span></strong><span class="koboSpan" id="kobo.530.1"> value is not equal to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">actual</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.532.1"> value</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">Assert.StrictEqual(expected, actual)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.534.1">Verifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">expected</span></strong><span class="koboSpan" id="kobo.536.1"> value is strictly equal to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">actual</span></strong><span class="koboSpan" id="kobo.538.1"> value, using the type’s </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">default comparer</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">Assert.NotStrictEqual(expected, actual)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.541.1">Verifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">expected</span></strong><span class="koboSpan" id="kobo.543.1"> value is strictly not equal to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">actual</span></strong><span class="koboSpan" id="kobo.545.1"> value, using the type’s </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">default comparer</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">Assert.Same(expected, actual)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.548.1">Verifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">expected</span></strong><span class="koboSpan" id="kobo.550.1"> object is the same instance as the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">actual</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.552.1"> object</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">Assert.NotSame(expected, actual)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.554.1">Verifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">expected</span></strong><span class="koboSpan" id="kobo.556.1"> object is not the same instance as the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">actual</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.558.1"> object</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">Assert.True(condition)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.560.1">Verifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">condition</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.562.1">is true</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">Assert.False(condition)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.564.1">Verifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">condition</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.566.1">is false</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">Assert.Null(object)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.568.1">Verifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">object</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.570.1">is null</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">Assert.NotNull(object)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.572.1">Verifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">object</span></strong><span class="koboSpan" id="kobo.574.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">not null</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">Assert.IsType(expectedType, object)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.577.1">Verifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">object</span></strong><span class="koboSpan" id="kobo.579.1"> is exactly </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">expectedType</span></strong><span class="koboSpan" id="kobo.581.1">, and not a </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">derived type</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">Assert.IsNotType(unexpectedType, object)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.584.1">Verifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">object</span></strong><span class="koboSpan" id="kobo.586.1"> is not </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">exactly </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">unexpectedType</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">Assert.IsAssignableFrom(expectedType, object)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.590.1">Verifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">object</span></strong><span class="koboSpan" id="kobo.592.1"> is assignable to </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">expectedType</span></strong><span class="koboSpan" id="kobo.594.1">, which means that </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">object</span></strong><span class="koboSpan" id="kobo.596.1"> is the given type or a </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">derived type</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">Assert.Contains(expected, collection)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.599.1">Verifies that </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">collection</span></strong><span class="koboSpan" id="kobo.601.1"> contains the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">expected</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.603.1"> object</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">Assert.DoesNotContain(expected, collection)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.605.1">Verifies that </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">collection</span></strong><span class="koboSpan" id="kobo.607.1"> does not contain the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">expected</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.609.1"> object</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">Assert.Empty(collection)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.611.1">Verifies that </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">collection</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.613.1">is empty</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">Assert.NotEmpty(collection)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.615.1">Verifies that </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">collection</span></strong><span class="koboSpan" id="kobo.617.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">not empty</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">Assert.Single(collection)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.620.1">Verifies that </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">collection</span></strong><span class="koboSpan" id="kobo.622.1"> contains exactly one element of the </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">given type</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">Assert.InRange(actual, </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">low, high)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.626.1">Verifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">actual</span></strong><span class="koboSpan" id="kobo.628.1"> value is within the range of </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">low</span></strong><span class="koboSpan" id="kobo.630.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">high</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.632.1"> (inclusive)</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">Assert.NotInRange(actual, </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">low, high)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.635.1">Verifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">actual</span></strong><span class="koboSpan" id="kobo.637.1"> value is not within the range of </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">low</span></strong><span class="koboSpan" id="kobo.639.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">high</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.641.1"> (inclusive)</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">Assert.Throws&lt;exceptionType&gt;(action)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.643.1">Verifies that </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">action</span></strong><span class="koboSpan" id="kobo.645.1"> throws an exception of the specified </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">exceptionType</span></strong><span class="koboSpan" id="kobo.647.1">, and not a derived </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">exception type</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">Assert.ThrowsAny&lt;exceptionType&gt;(action)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.650.1">Verifies that </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">action</span></strong><span class="koboSpan" id="kobo.652.1"> throws an exception of the specified </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">exceptionType</span></strong><span class="koboSpan" id="kobo.654.1"> or a derived </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">exception type</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.656.1">Table 9.1 – List of assertion methods provided by xUnit</span></p>
<p><span class="koboSpan" id="kobo.657.1">Note this </span><a id="_idIndexMarker965"/><span class="koboSpan" id="kobo.658.1">list is not complete. </span><span class="koboSpan" id="kobo.658.2">You can find more assertion methods in xUnit’s GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">repository: </span></span><a href="https://github.com/xunit/assert.xunit"><span class="No-Break"><span class="koboSpan" id="kobo.660.1">https://github.com/xunit/assert.xunit</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.661.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.662.1">Although the assertion methods provided by xUnit are enough for most scenarios, they are not very readable. </span><span class="koboSpan" id="kobo.662.2">A good way to make the unit tests more natural and readable is to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">FluentAssertions</span></strong><span class="koboSpan" id="kobo.664.1">, an open-source assertion library for .NET. </span><span class="koboSpan" id="kobo.664.2">It provides a set of extension methods that allow us to write </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">assertions fluently.</span></span></p>
<p><span class="koboSpan" id="kobo.666.1">To install </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">FluentAssertions</span></strong><span class="koboSpan" id="kobo.668.1">, we can use the following .NET </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">CLI command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.670.1">
dotnet add package FluentAssertions</span></pre> <p><span class="koboSpan" id="kobo.671.1">You can also use NuGet Package Manager to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">FluentAssertions</span></strong><span class="koboSpan" id="kobo.673.1"> package if you use </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">VS 2022.</span></span></p>
<p><span class="koboSpan" id="kobo.675.1">Then, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">Should()</span></strong><span class="koboSpan" id="kobo.677.1"> method to verify the test results. </span><span class="koboSpan" id="kobo.677.2">For example, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">Should().Be()</span></strong><span class="koboSpan" id="kobo.679.1"> method to verify whether two objects </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">are equal.</span></span></p>
<p><span class="koboSpan" id="kobo.681.1">The following code shows how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">Should().Be()</span></strong><span class="koboSpan" id="kobo.683.1"> method to verify whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">GetInvoicesAsync()</span></strong><span class="koboSpan" id="kobo.685.1"> method returns a list </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">of invoices:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.687.1">
// Omitted code for brevityreturnResult.Should().NotBeNull();
returnResult.Should().HaveCount(2);
// Or use returnResult.Count.Should().Be(2);
returnResult.Should().Contain(i =&gt; i.InvoiceNumber == "INV-001");
returnResult.Should().Contain(i =&gt; i.InvoiceNumber == "INV-002");</span></pre>
<p><span class="koboSpan" id="kobo.688.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">FluentAssertions</span></strong><span class="koboSpan" id="kobo.690.1"> method is</span><a id="_idIndexMarker966"/><span class="koboSpan" id="kobo.691.1"> more intuitive and readable than the </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">Assert.Equal()</span></strong><span class="koboSpan" id="kobo.693.1"> method. </span><span class="koboSpan" id="kobo.693.2">For most scenarios, you can easily replace the assertion methods provided by xUnit with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">FluentAssertions</span></strong><span class="koboSpan" id="kobo.695.1"> methods without searching </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">the documentation.</span></span></p>
<p><span class="koboSpan" id="kobo.697.1">Let’s see how to verify the exception using </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">FluentAssertions</span></strong><span class="koboSpan" id="kobo.699.1">. </span><span class="koboSpan" id="kobo.699.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">EmailServiceTests</span></strong><span class="koboSpan" id="kobo.701.1"> class, there is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">SendEmailAsync_Should_Log_SmtpException()</span></strong><span class="koboSpan" id="kobo.703.1"> method. </span><span class="koboSpan" id="kobo.703.2">This method verifies whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">SendEmailAsync()</span></strong><span class="koboSpan" id="kobo.705.1"> method will log the exception when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">SendEmailAsync()</span></strong><span class="koboSpan" id="kobo.707.1"> method throws an exception. </span><span class="koboSpan" id="kobo.707.2">The following code shows how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">xUnit</span></strong><span class="koboSpan" id="kobo.709.1"> to verify </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">the exception:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.711.1">
await Assert.ThrowsAsync&lt;SmtpException&gt;(() =&gt; emailService.SendEmailAsync(to, subject, body));</span></pre> <p><span class="koboSpan" id="kobo.712.1">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">Should().ThrowAsync&lt;&gt;()</span></strong><span class="koboSpan" id="kobo.714.1"> method of </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">FluentAssertions</span></strong><span class="koboSpan" id="kobo.716.1"> to verify the exception, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.718.1">
var act = () =&gt; emailService.SendEmailAsync(to, subject, body);await act.Should().ThrowAsync&lt;SmtpException&gt;().WithMessage("Test SmtpException");</span></pre>
<p><span class="koboSpan" id="kobo.719.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">FluentAssertions</span></strong><span class="koboSpan" id="kobo.721.1"> is more readable and intuitive than the xUnit way. </span><span class="koboSpan" id="kobo.721.2">Here is a table comparing some common assertion methods provided by xUnit </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">FluentAssertions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-6">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.725.1">xUnit </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.726.1">Assertion Method</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.727.1">FluentAssertions </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.728.1">Assertion Method</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">Assert.Equal(expected, actual)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">Should().Be(expected)</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">Assert.NotEqual(expected, actual)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">Should().NotBe(expected)</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">Assert.True(condition)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">Should().BeTrue()</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">Assert.False(condition)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">Should().BeFalse()</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">Assert.Null(object)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">Should().BeNull()</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">Assert.NotNull(object)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">Should().NotBeNull()</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">Assert.Contains(expected, collection)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">Should().Contain(expected)</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">Assert.DoesNotContain(expected, collection)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">Should().NotContain(expected)</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">Assert.Empty(collection)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">Should().BeEmpty()</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">Assert.NotEmpty(collection)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">Should().NotBeEmpty()</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">Assert.Throws&lt;TException&gt;(action)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">Should().Throw&lt;TException&gt;()</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">Assert.DoesNotThrow(action)</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">Should().NotThrow()</span></strong></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.765.1">Table 9.2 – Comparison of common assertion methods provided by xUnit and FluentAssertions</span></p>
<p><span class="koboSpan" id="kobo.766.1">Note that the </span><a id="_idIndexMarker967"/><span class="koboSpan" id="kobo.767.1">preceding table is not an exhaustive list. </span><span class="koboSpan" id="kobo.767.2">You can find more extension methods in the official documentation </span><a id="_idIndexMarker968"/><span class="koboSpan" id="kobo.768.1">of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">FluentAssertions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">: </span></span><a href="https://fluentassertions.com/introduction"><span class="No-Break"><span class="koboSpan" id="kobo.771.1">https://fluentassertions.com/introduction</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.772.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.773.1">Besides the fluent assertion methods, </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">FluentAssertions</span></strong><span class="koboSpan" id="kobo.775.1"> also provides better error messages if the test fails. </span><span class="koboSpan" id="kobo.775.2">For example, if we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">Assert.Equal()</span></strong><span class="koboSpan" id="kobo.777.1"> method to verify whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">returnResult</span></strong><span class="koboSpan" id="kobo.779.1"> contains two invoices, the code will look </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.781.1">
Assert.Equal(3, returnResult.Count);</span></pre> <p><span class="koboSpan" id="kobo.782.1">If the </span><a id="_idIndexMarker969"/><span class="koboSpan" id="kobo.783.1">test fails, the error message will be </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">as follows:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.785.1">InvoiceApp.UnitTests.InvoiceControllerTests.GetInvoices_ShouldReturnInvoices</span></strong><strong class="bold"><span class="koboSpan" id="kobo.786.1">  </span></strong> <strong class="bold"><span class="koboSpan" id="kobo.787.1">Source:</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.788.1">InvoiceControllerTests.cs</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.789.1">line</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.790.1">21</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.791.1">  </span></strong> <strong class="bold"><span class="koboSpan" id="kobo.792.1">Duration:</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.793.1">372 ms</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.794.1">  Message:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.795.1">Assert.Equal() Failure</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.796.1">Expected: 3</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.797.1">Actual:   2</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.798.1">  Stack Trace:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.799.1">InvoiceControllerTests.GetInvoices_ShouldReturnInvoices()</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.800.1">line</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.801.1">34</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.802.1">InvoiceControllerTests.GetInvoices_ShouldReturnInvoices()</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.803.1">line</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.804.1">41</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.805.1">--- End of stack trace from previous location ---</span></strong></pre>
<p><span class="koboSpan" id="kobo.806.1">If we have multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">Assert.Equal()</span></strong><span class="koboSpan" id="kobo.808.1"> methods in the test method, which is not recommended but something we have to do occasionally, we cannot immediately know which </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">Assert.Equal()</span></strong><span class="koboSpan" id="kobo.810.1"> method fails. </span><span class="koboSpan" id="kobo.810.2">We need to check the line number of the error message to find the failing assertion. </span><span class="koboSpan" id="kobo.810.3">This is not </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">very convenient.</span></span></p>
<p><span class="koboSpan" id="kobo.812.1">If we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">FluentAssertions</span></strong><span class="koboSpan" id="kobo.814.1">, the assertion code will look </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.816.1">
returnResult.Count.Should().Be(3);</span></pre> <p><span class="koboSpan" id="kobo.817.1">If the test fails with the same reason, the error message will be </span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">as follows:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.819.1">InvoiceApp.UnitTests.InvoiceControllerTests.GetInvoices_ShouldReturnInvoices</span></strong><strong class="bold"><span class="koboSpan" id="kobo.820.1">  </span></strong> <strong class="bold"><span class="koboSpan" id="kobo.821.1">Source:</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.822.1">InvoiceControllerTests.cs line 21</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.823.1">  </span></strong> <strong class="bold"><span class="koboSpan" id="kobo.824.1">Duration:</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.825.1">408 ms</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.826.1">  Message:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.827.1">Expected returnResult.Count to be 3, but found 2.</span></strong></pre>
<p><span class="koboSpan" id="kobo.828.1">Now, the error message is more detailed and intuitive and tells us which assertion fails. </span><span class="koboSpan" id="kobo.828.2">This is very helpful when we have multiple assertions in the </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">test method.</span></span></p>
<p><span class="koboSpan" id="kobo.830.1">You can even enrich the error message by adding a custom message to the assertion method. </span><span class="koboSpan" id="kobo.830.2">For example, we can add a custom message to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">Should().Be()</span></strong><span class="koboSpan" id="kobo.832.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.834.1">
returnResult.Count.Should().Be(3, "The number of invoices should be 3");</span></pre> <p><span class="koboSpan" id="kobo.835.1">Now, the</span><a id="_idIndexMarker970"/><span class="koboSpan" id="kobo.836.1"> error message will be </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.838.1">
Expected returnResult.Count to be 3 because The number of invoices should be 3, but found 2.</span></pre> <p><span class="koboSpan" id="kobo.839.1">Therefore, it is highly recommended to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">FluentAssertions</span></strong><span class="koboSpan" id="kobo.841.1"> in your tests. </span><span class="koboSpan" id="kobo.841.2">It makes your tests more readable </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">and maintainab</span><a id="_idTextAnchor387"/><span class="koboSpan" id="kobo.843.1">le.</span></span></p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor388"/><span class="koboSpan" id="kobo.844.1">Testing the database access layer</span></h1>
<p><span class="koboSpan" id="kobo.845.1">In many web API applications, we</span><a id="_idIndexMarker971"/><span class="koboSpan" id="kobo.846.1"> need to access the database to perform CRUD operations. </span><span class="koboSpan" id="kobo.846.2">In this section, we will learn how to test the database access layer in </span><span class="No-Break"><span class="koboSpan" id="kobo.847.1">unit te</span><a id="_idTextAnchor389"/><span class="koboSpan" id="kobo.848.1">sts.</span></span></p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor390"/><span class="koboSpan" id="kobo.849.1">How can we test the database access layer?</span></h2>
<p><span class="koboSpan" id="kobo.850.1">Currently, we inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.852.1"> into controllers to access the database. </span><span class="koboSpan" id="kobo.852.2">This approach is easy for</span><a id="_idIndexMarker972"/><span class="koboSpan" id="kobo.853.1"> development, but it tightly couples the controllers with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.855.1"> class. </span><span class="koboSpan" id="kobo.855.2">When we test the controllers, we need to create a real </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.857.1"> object and use it to test the controllers, which means controllers are not tested in isolation. </span><span class="koboSpan" id="kobo.857.2">This problem can be addressed in a variety </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">of ways:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.859.1">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">InMemoryDatabase</span></strong><span class="koboSpan" id="kobo.861.1"> provider of EF Core to create an in-memory database as the </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">fake database</span></span></li>
<li><span class="koboSpan" id="kobo.863.1">Use the SQLite in-memory database as the </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">fake database</span></span></li>
<li><span class="koboSpan" id="kobo.865.1">Create a separate repository layer to encapsulate the database access code, inject the repository layer into controllers (or services that need to access databases), and then use </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">Mock </span></strong><span class="koboSpan" id="kobo.867.1">objects to mock the </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">repository layer</span></span></li>
<li><span class="koboSpan" id="kobo.869.1">Use the real database </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">for testing</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.871.1">Each approach has its pros </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">and cons:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.873.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">InMemoryDatabase</span></strong><span class="koboSpan" id="kobo.875.1"> provider was originally designed for internal testing of EF Core. </span><span class="koboSpan" id="kobo.875.2">However, it is not a good choice for testing other applications because it does not behave like a real database. </span><span class="koboSpan" id="kobo.875.3">For example, it does not support transactions and raw SQL queries. </span><span class="koboSpan" id="kobo.875.4">So, it is not a good choice for testing the database </span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">access code.</span></span></li>
<li><span class="koboSpan" id="kobo.877.1">SQLite also provides an in-memory database feature that can be used for testing. </span><span class="koboSpan" id="kobo.877.2">However, it has similar limitations to EF Core’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">InMemoryDatabase</span></strong><span class="koboSpan" id="kobo.879.1"> provider. </span><span class="koboSpan" id="kobo.879.2">If the production database is SQL Server, EF Core cannot guarantee that the database access code will work correctly on SQL Server if we use SQLite </span><span class="No-Break"><span class="koboSpan" id="kobo.880.1">for testing.</span></span></li>
<li><span class="koboSpan" id="kobo.881.1">Creating a </span><a id="_idIndexMarker973"/><span class="koboSpan" id="kobo.882.1">separate repository layer is to decouple the controllers from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">DbContext</span></strong><span class="koboSpan" id="kobo.884.1"> class. </span><span class="koboSpan" id="kobo.884.2">In this pattern, a separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">IRepository</span></strong><span class="koboSpan" id="kobo.886.1"> interface is created between the application code and </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">DbContext</span></strong><span class="koboSpan" id="kobo.888.1">, and the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">IRepository</span></strong><span class="koboSpan" id="kobo.890.1"> interface is injected into controllers or services. </span><span class="koboSpan" id="kobo.890.2">In this way, we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">Mock</span></strong><span class="koboSpan" id="kobo.892.1"> objects to mock the </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">IRepository</span></strong><span class="koboSpan" id="kobo.894.1"> interface to test controllers or services, which means controllers or services can be tested in isolation. </span><span class="koboSpan" id="kobo.894.2">However, this approach requires a lot of work to create the repository layer. </span><span class="koboSpan" id="kobo.894.3">Also, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">DbContext</span></strong><span class="koboSpan" id="kobo.896.1"> class is already a repository pattern, so creating another repository layer is redundant if you do not need to change the database provider. </span><span class="koboSpan" id="kobo.896.2">But this pattern still has its advantages. </span><span class="koboSpan" id="kobo.896.3">Tests can focus on the application logic without worrying about the database access code. </span><span class="koboSpan" id="kobo.896.4">Also, if you need to change the database provider, you only need to change the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">IRepository</span></strong><span class="koboSpan" id="kobo.898.1"> interface, and there is no need to change the controllers </span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">or services.</span></span></li>
<li><span class="koboSpan" id="kobo.900.1">Testing against a real database provides more benefits. </span><span class="koboSpan" id="kobo.900.2">One of the most important benefits is that it can ensure that the database access code works correctly on the database in production. </span><span class="koboSpan" id="kobo.900.3">Using a real database is also fast and reliable. </span><span class="koboSpan" id="kobo.900.4">However, one challenge is that we need to ensure the isolation for tests because some of them may change the data in the database. </span><span class="koboSpan" id="kobo.900.5">So, we need to make sure the </span><a id="_idIndexMarker974"/><span class="koboSpan" id="kobo.901.1">data can be restored or recreated after the tests </span><span class="No-Break"><span class="koboSpan" id="kobo.902.1">are completed.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.903.1">In this section, we will use a separate local database for testing, such as a LocalDB database. </span><span class="koboSpan" id="kobo.903.2">If your application will run on SQL Server, you can use another SQL Server for testing rather than LocalDB since LocalDB does not behave the same as SQL Server. </span><span class="koboSpan" id="kobo.903.3">If your application will run in the cloud, such as Azure, you may use an Azure SQL database. </span><span class="koboSpan" id="kobo.903.4">You can use another Azure SQL database for testing but you will need to allocate a small amount of resources for it to save the cost. </span><span class="koboSpan" id="kobo.903.5">Keep in mind that the database for testing should keep the same environment as much as possible to avoid unexpected behaviors </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">in production.</span></span></p>
<p><span class="koboSpan" id="kobo.905.1">Regarding the controllers, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.907.1"> class directly for simplicity; we will learn the repository pattern in </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">future ch</span><a id="_idTextAnchor391"/><span class="koboSpan" id="kobo.909.1">apters.</span></span></p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor392"/><span class="koboSpan" id="kobo.910.1">Creating a test fixture</span></h2>
<p><span class="koboSpan" id="kobo.911.1">When we test the </span><a id="_idIndexMarker975"/><span class="koboSpan" id="kobo.912.1">CRUD methods against the database, we need to prepare the database before the tests are executed, and then clean up the database after the tests are completed so that the changes made by the tests will not affect other tests. </span><span class="koboSpan" id="kobo.912.2">xUnit provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">IClassFixture&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.914.1"> interface to create a test fixture, which can be used to prepare and clean up the database for each </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">test class.</span></span></p>
<p><span class="koboSpan" id="kobo.916.1">First, we need to create a test fixture class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">InvoiceApp.UnitTests</span></strong><span class="koboSpan" id="kobo.918.1"> project, </span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.920.1">
public class TestDatabaseFixture{
    private const string ConnectionString = @"Server=(localdb)\mssqllocaldb;Database=InvoiceTestDb;Trusted_Connection=True";
}</span></pre>
<p><span class="koboSpan" id="kobo.921.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">TestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.923.1"> class, we define a connection string to the local database. </span><span class="koboSpan" id="kobo.923.2">Using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">const</span></strong><span class="koboSpan" id="kobo.925.1"> string is for simplicity only. </span><span class="koboSpan" id="kobo.925.2">In a real application, you may want to use the configuration system to</span><a id="_idIndexMarker976"/><span class="koboSpan" id="kobo.926.1"> read the connection string from other sources, such as the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">appsettings.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.928.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.929.1">Then, we add a method to create the database context object, </span><span class="No-Break"><span class="koboSpan" id="kobo.930.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.931.1">
public InvoiceDbContext CreateDbContext()    =&gt; new(new DbContextOptionsBuilder&lt;InvoiceDbContext&gt;()
            .UseSqlServer(ConnectionString)
            .Options, null);</span></pre>
<p><span class="koboSpan" id="kobo.932.1">We also need a method to initialize the database, </span><span class="No-Break"><span class="koboSpan" id="kobo.933.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.934.1">
public void InitializeDatabase(){
    using var context = CreateDbContext();
    context.Database.EnsureDeleted();
    context.Database.EnsureCreated();
    // Create a few Contacts
    var contacts = new List&lt;Contact&gt;
    {
        // Omitted the code for brevity
    };
    context.Contacts.AddRange(contacts);
    // Create a few Invoices
    var invoices = new List&lt;Invoice&gt;
    {
        // Omitted the code for brevity
    };
    context.Invoices.AddRange(invoices);
    context.SaveChanges();
}</span></pre>
<p><span class="koboSpan" id="kobo.935.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">InitializeDatabase()</span></strong><span class="koboSpan" id="kobo.937.1"> method, we create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.939.1"> object and then use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">EnsureDeleted()</span></strong><span class="koboSpan" id="kobo.941.1"> method to delete the database if it exists. </span><span class="koboSpan" id="kobo.941.2">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">EnsureCreated()</span></strong><span class="koboSpan" id="kobo.943.1"> method to create the database. </span><span class="koboSpan" id="kobo.943.2">After that, we seed some data into the database. </span><span class="koboSpan" id="kobo.943.3">In this example, we create a few </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">Contact</span></strong><span class="koboSpan" id="kobo.945.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">Invoice</span></strong><span class="koboSpan" id="kobo.947.1"> objects and add them to the database. </span><span class="koboSpan" id="kobo.947.2">Finally, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">SaveChanges()</span></strong><span class="koboSpan" id="kobo.949.1"> method</span><a id="_idIndexMarker977"/><span class="koboSpan" id="kobo.950.1"> to save the changes to </span><span class="No-Break"><span class="koboSpan" id="kobo.951.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.952.1">Now, we need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">InitializeDatabase()</span></strong><span class="koboSpan" id="kobo.954.1"> method to initialize the database in the constructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">TestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.956.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.958.1">
private static readonly object Lock = new();private static bool _databaseInitialized;
public TestDatabaseFixture()
{
    // This code comes from Mirosoft Docs: https://github.com/dotnet/EntityFramework.Docs/blob/main/samples/core/Testing/TestingWithTheDatabase/TestDatabaseFixture.cs
    lock (Lock)
    {
        if (!_databaseInitialized!)
        {
            InitializeDatabase();
            databaseInitialized = true;
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.959.1">To avoid initializing the database multiple times, we use a static field, </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">_databaseInitialized</span></strong><span class="koboSpan" id="kobo.961.1">, to indicate whether the database has been initialized. </span><span class="koboSpan" id="kobo.961.2">We also define a static object, </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">Lock</span></strong><span class="koboSpan" id="kobo.963.1">, to ensure that the database is initialized only once. </span><span class="koboSpan" id="kobo.963.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">InitializeDatabase()</span></strong><span class="koboSpan" id="kobo.965.1"> method is used to initialize the database. </span><span class="koboSpan" id="kobo.965.2">It will only be called once before the tests </span><span class="No-Break"><span class="koboSpan" id="kobo.966.1">are executed.</span></span></p>
<p><span class="koboSpan" id="kobo.967.1">There are several</span><a id="_idIndexMarker978"/><span class="koboSpan" id="kobo.968.1"> important things </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">to note:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.970.1">xUnit creates a new instance of the test class for every test. </span><span class="koboSpan" id="kobo.970.2">So, the constructor of the test class is called for </span><span class="No-Break"><span class="koboSpan" id="kobo.971.1">every test.</span></span></li>
<li><span class="koboSpan" id="kobo.972.1">Deleting and recreating the database for each test run may slow down the tests and may not be necessary. </span><span class="koboSpan" id="kobo.972.2">If you do not want to delete and recreate the database for each test run, you can comment out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">EnsureDeleted()</span></strong><span class="koboSpan" id="kobo.974.1"> method to allow the database to be reused. </span><span class="koboSpan" id="kobo.974.2">However, if you need to frequently change the database schema in the development phase, you may need to delete and recreate the database for each test run to ensure the database schema is up </span><span class="No-Break"><span class="koboSpan" id="kobo.975.1">to date.</span></span></li>
<li><span class="koboSpan" id="kobo.976.1">We use a lock object to ensure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">InitializeDatabase()</span></strong><span class="koboSpan" id="kobo.978.1"> method is only called once for each test run. </span><span class="koboSpan" id="kobo.978.2">The reason is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">TextDatabaseFixture</span></strong><span class="koboSpan" id="kobo.980.1"> class can be used in multiple test classes, and xUnit can run multiple test classes in parallel. </span><span class="koboSpan" id="kobo.980.2">Using a lock can help us ensure the seed method is only called once. </span><span class="koboSpan" id="kobo.980.3">We will learn </span><a id="_idIndexMarker979"/><span class="koboSpan" id="kobo.981.1">more about parallel test execution in the </span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">next section.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.983.1">Now that the test fixture is ready, we can use it in the </span><span class="No-Break"><span class="koboSpan" id="kobo.984.1">t</span><a id="_idTextAnchor393"/><span class="koboSpan" id="kobo.985.1">est classes.</span></span></p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor394"/><span class="koboSpan" id="kobo.986.1">Using the test fixture</span></h2>
<p><span class="koboSpan" id="kobo.987.1">Next, we will use the test fixture </span><a id="_idIndexMarker980"/><span class="koboSpan" id="kobo.988.1">in the test classes. </span><span class="koboSpan" id="kobo.988.2">First, let’s test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">GetAll()</span></strong><span class="koboSpan" id="kobo.990.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.991.1">InvoiceController</span></strong><span class="koboSpan" id="kobo.992.1"> class. </span><span class="koboSpan" id="kobo.992.2">Create a new test class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">InvoiceControllerTests</span></strong><span class="koboSpan" id="kobo.994.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">InvoiceApp.UnitTests</span></strong><span class="koboSpan" id="kobo.996.1"> project, </span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.998.1">
public class InvoiceControllerTests(TestFixture fixture) : IClassFixture&lt;TestFixture&gt;{
}</span></pre>
<p><span class="koboSpan" id="kobo.999.1">We use dependency injection to inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">TestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1001.1"> object into the test class. </span><span class="koboSpan" id="kobo.1001.2">Then, we can use the text fixture to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.1003.1"> object in the test methods, </span><span class="No-Break"><span class="koboSpan" id="kobo.1004.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1005.1">
[Fact]public async Task GetInvoices_ShouldReturnInvoices()
{
    // Arrange
    await using var dbContext = fixture.CreateDbContext();
    var emailServiceMock = new Mock&lt;IEmailService&gt;();
    var controller = new InvoiceController(dbContext, emailServiceMock.Object);
    // Act
    var actionResult = await controller.GetInvoicesAsync();
    // Assert
    var result = actionResult.Result as OkObjectResult;
    Assert.NotNull(result);
    var returnResult = Assert.IsAssignableFrom&lt;List&lt;Invoice&gt;&gt;(result.Value);
    Assert.NotNull(returnResult);
    Assert.Equal(2, returnResult.Count);
    Assert.Contains(returnResult, i =&gt; i.InvoiceNumber =="INV-001");
    Assert.Contains(returnResult, i =&gt; i.InvoiceNumber =="INV-002");
}</span></pre>
<p><span class="koboSpan" id="kobo.1006.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">GetInvoices_ShouldReturnInvoices()</span></strong><span class="koboSpan" id="kobo.1008.1"> method, we use the fixture to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.1010.1"> object, and then create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">InvoiceController</span></strong><span class="koboSpan" id="kobo.1012.1"> object with some mocked dependencies. </span><span class="koboSpan" id="kobo.1012.2">Then, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1013.1">GetInvoicesAsync()</span></strong><span class="koboSpan" id="kobo.1014.1"> method to get the invoices from the database. </span><span class="koboSpan" id="kobo.1014.2">Finally, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">Assert</span></strong><span class="koboSpan" id="kobo.1016.1"> class to verify </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">the result.</span></span></p>
<p><span class="koboSpan" id="kobo.1018.1">The data we use to verify</span><a id="_idIndexMarker981"/><span class="koboSpan" id="kobo.1019.1"> the controller is the data we seed into the database in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">TestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1021.1"> class. </span><span class="koboSpan" id="kobo.1021.2">If you change the data in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">TestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1023.1"> class, you also need to change the expected data in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1024.1">test class.</span></span></p>
<p><span class="koboSpan" id="kobo.1025.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">GetInvoices_ShouldReturnInvoices()</span></strong><span class="koboSpan" id="kobo.1027.1"> method is a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">Fact</span></strong><span class="koboSpan" id="kobo.1029.1"> test method. </span><span class="koboSpan" id="kobo.1029.2">We can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">Theory</span></strong><span class="koboSpan" id="kobo.1031.1"> test method to test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">GetInvoicesAsync()</span></strong><span class="koboSpan" id="kobo.1033.1"> method with different parameters. </span><span class="koboSpan" id="kobo.1033.2">For example, we can test whether the controller can return correct invoices when we pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">status</span></strong><span class="koboSpan" id="kobo.1035.1"> parameter. </span><span class="koboSpan" id="kobo.1035.2">The test method is </span><span class="No-Break"><span class="koboSpan" id="kobo.1036.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1037.1">
[Theory][InlineData(InvoiceStatus.AwaitPayment)]
[InlineData(InvoiceStatus.Draft)]
public async Task GetInvoicesByStatus_ShouldReturnInvoices(InvoiceStatus status)
{
    // Arrange
    await using var dbContext = _fixture.CreateDbContext();
    var emailServiceMock = new Mock&lt;IEmailService&gt;();
    var controller = new InvoiceController(dbContext, emailServiceMock.Object);
    // Act
    var actionResult = await controller.GetInvoicesAsync(status: status);
    // Assert
    var result = actionResult.Result as OkObjectResult;
    Assert.NotNull(result);
    var returnResult = Assert.IsAssignableFrom&lt;List&lt;Invoice&gt;&gt;(result.Value);
    Assert.NotNull(returnResult);
    Assert.Single(returnResult);
    Assert.Equal(status, returnResult.First().Status);
}</span></pre>
<p><span class="koboSpan" id="kobo.1038.1">In the preceding </span><a id="_idIndexMarker982"/><span class="koboSpan" id="kobo.1039.1">example, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">Theory</span></strong><span class="koboSpan" id="kobo.1041.1"> attribute to indicate that the test method is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">Theory</span></strong><span class="koboSpan" id="kobo.1043.1"> test method. </span><span class="koboSpan" id="kobo.1043.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.1044.1">Theory</span></strong><span class="koboSpan" id="kobo.1045.1"> test method can have one or more </span><strong class="source-inline"><span class="koboSpan" id="kobo.1046.1">InlineData</span></strong><span class="koboSpan" id="kobo.1047.1"> attributes. </span><span class="koboSpan" id="kobo.1047.2">Each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">InlineData</span></strong><span class="koboSpan" id="kobo.1049.1"> attribute can pass one value or multiple values to the test method. </span><span class="koboSpan" id="kobo.1049.2">In this case, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1050.1">InlineData</span></strong><span class="koboSpan" id="kobo.1051.1"> attribute to pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1052.1">InvoiceStatus</span></strong><span class="koboSpan" id="kobo.1053.1"> value to the test method. </span><span class="koboSpan" id="kobo.1053.2">You can use multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.1054.1">InlineData</span></strong><span class="koboSpan" id="kobo.1055.1"> attributes to pass multiple values to the test method. </span><span class="koboSpan" id="kobo.1055.2">The</span><a id="_idIndexMarker983"/><span class="koboSpan" id="kobo.1056.1"> test method will be executed multiple times with </span><span class="No-Break"><span class="koboSpan" id="kobo.1057.1">different values.</span></span></p>
<p><span class="koboSpan" id="kobo.1058.1">The tests we introduced in this chapter are used to test read-only methods. </span><span class="koboSpan" id="kobo.1058.2">They do not change the database, so we do not need to worry about the database state. </span><span class="koboSpan" id="kobo.1058.3">In the next section, we will introduce how to write tests for methods that chan</span><a id="_idTextAnchor395"/><span class="koboSpan" id="kobo.1059.1">ge </span><span class="No-Break"><span class="koboSpan" id="kobo.1060.1">the database.</span></span></p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor396"/><span class="koboSpan" id="kobo.1061.1">Writing tests for methods that change the database</span></h2>
<p><span class="koboSpan" id="kobo.1062.1">If a method </span><a id="_idIndexMarker984"/><span class="koboSpan" id="kobo.1063.1">changes the database, we need to ensure that the database is in a known state before we run the test, and also ensure that the database is restored to its original state so that the change will not affect </span><span class="No-Break"><span class="koboSpan" id="kobo.1064.1">other tests.</span></span></p>
<p><span class="koboSpan" id="kobo.1065.1">For example, a method may delete a record from the database. </span><span class="koboSpan" id="kobo.1065.2">If the test method deletes a record from the database but does not restore the database after the test, the next test method may fail because the record </span><span class="No-Break"><span class="koboSpan" id="kobo.1066.1">is missing.</span></span></p>
<p><span class="koboSpan" id="kobo.1067.1">Let’s create a test method for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1068.1">CreateInvoiceAsync()</span></strong><span class="koboSpan" id="kobo.1069.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1070.1">InvoiceController</span></strong><span class="koboSpan" id="kobo.1071.1"> class. </span><span class="koboSpan" id="kobo.1071.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1072.1">CreateInvoiceAsync()</span></strong><span class="koboSpan" id="kobo.1073.1"> method creates a new invoice in the database. </span><span class="koboSpan" id="kobo.1073.2">The test method is </span><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1075.1">
[Fact]public async Task CreateInvoice_ShouldCreateInvoice()
{
    // Arrange
    await using var dbContext = fixture.CreateDbContext();
    var emailServiceMock = new Mock&lt;IEmailService&gt;();
    var controller = new InvoiceController(dbContext, emailServiceMock.Object);
    // Act
    var contactId = dbContext.Contacts.First().Id;
    var invoice = new Invoice
    {
        DueDate = DateTimeOffset.Now.AddDays(30),
        ContactId = contactId,
        Status = InvoiceStatus.Draft,
        InvoiceDate = DateTimeOffset.Now,
        InvoiceItems = new List&lt;InvoiceItem&gt;
        {
            // Omitted for brevity
        }
    };
    var actionResult = await controller.CreateInvoiceAsync(invoice);
    // Assert
    var result = actionResult.Result as CreatedAtActionResult;
    Assert.NotNull(result);
    var returnResult = Assert.IsAssignableFrom&lt;Invoice&gt;(result.Value);
    var invoiceCreated = await dbContext.Invoices.FindAsync(returnResult.Id);
    Assert.NotNull(invoiceCreated);
    Assert.Equal(InvoiceStatus.Draft, invoiceCreated.Status);
    Assert.Equal(500, invoiceCreated.Amount);
    Assert.Equal(3, dbContext.Invoices.Count());
    Assert.Equal(contactId, invoiceCreated.ContactId);
    // Clean up
    dbContext.Invoices.Remove(invoiceCreated);
    await dbContext.SaveChangesAsync();
}</span></pre>
<p><span class="koboSpan" id="kobo.1076.1">In this test </span><a id="_idIndexMarker985"/><span class="koboSpan" id="kobo.1077.1">method, we create a new invoice and pass it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">CreateInvoiceAsync()</span></strong><span class="koboSpan" id="kobo.1079.1"> method. </span><span class="koboSpan" id="kobo.1079.2">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1080.1">Assert</span></strong><span class="koboSpan" id="kobo.1081.1"> class to verify the result. </span><span class="koboSpan" id="kobo.1081.2">Finally, we remove the invoice from the database and save the changes. </span><span class="koboSpan" id="kobo.1081.3">Note that the result of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">CreateInvoiceAsync()</span></strong><span class="koboSpan" id="kobo.1083.1"> method is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">CreatedActionResult</span></strong><span class="koboSpan" id="kobo.1085.1"> object, which contains the created invoice. </span><span class="koboSpan" id="kobo.1085.2">So, we should convert the result into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">CreatedAtActionResult</span></strong><span class="koboSpan" id="kobo.1087.1"> object, and then get the created invoice from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">Value</span></strong><span class="koboSpan" id="kobo.1089.1"> property. </span><span class="koboSpan" id="kobo.1089.2">Also, in this test method, we have asserted that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1090.1">Amount</span></strong><span class="koboSpan" id="kobo.1091.1"> property of the created invoice is correct based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1092.1">invoice items.</span></span></p>
<p><span class="koboSpan" id="kobo.1093.1">When we run the test, an error may occur because the contact ID is incorrect, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1094.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1095.1">
Assert.Equal() FailureExpected: ae29a8ef-5e32-4707-8783-b6bc098c0ccb
Actual:   275de2a8-5e0f-420d-c68a-08db59a2942f</span></pre>
<p><span class="koboSpan" id="kobo.1096.1">The error says that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">CreateInvoiceAsync()</span></strong><span class="koboSpan" id="kobo.1098.1"> method does not behave as expected. </span><span class="koboSpan" id="kobo.1098.2">We can debug the application to find out why the contact ID is not saved correctly. </span><span class="koboSpan" id="kobo.1098.3">The reason is that when we created </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">Invoice</span></strong><span class="koboSpan" id="kobo.1100.1">, we only specified the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">ContactId</span></strong><span class="koboSpan" id="kobo.1102.1"> property, not the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1103.1">Contact</span></strong><span class="koboSpan" id="kobo.1104.1"> property. </span><span class="koboSpan" id="kobo.1104.2">So, EF Core could not find the contact with the specified ID, and then it created a new contact with a new ID. </span><span class="koboSpan" id="kobo.1104.3">To fix this issue, we need to specify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">Contact</span></strong><span class="koboSpan" id="kobo.1106.1"> property when we create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1107.1">Invoice</span></strong><span class="koboSpan" id="kobo.1108.1"> object. </span><span class="koboSpan" id="kobo.1108.2">Add the following code before calling the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">dbContext.Invoices.AddAsync()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1110.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1111.1">
var contact = await dbContext.Contacts.FindAsync(invoice.ContactId);if (contact == null)
{
    return BadRequest("Contact not found.");
}
invoice.Contact = contact;</span></pre>
<p><span class="koboSpan" id="kobo.1112.1">Now, we can run the test again. </span><span class="koboSpan" id="kobo.1112.2">This time, the test should pass. </span><span class="koboSpan" id="kobo.1112.3">That is why unit tests are so important. </span><span class="koboSpan" id="kobo.1112.4">They can help us find bugs early and fix them before we deploy the application </span><span class="No-Break"><span class="koboSpan" id="kobo.1113.1">to production.</span></span></p>
<p><span class="koboSpan" id="kobo.1114.1">In the preceding</span><a id="_idIndexMarker986"/><span class="koboSpan" id="kobo.1115.1"> example, the data was created in the test method and then removed from the database after the test. </span><span class="koboSpan" id="kobo.1115.2">There is another way to manage this scenario: using a transaction. </span><span class="koboSpan" id="kobo.1115.3">We can use a transaction to wrap the test method, and then roll back the transaction after the test. </span><span class="koboSpan" id="kobo.1115.4">So, the data created in the test method will not be saved to the database. </span><span class="koboSpan" id="kobo.1115.5">In this way, we do not need to manually remove the data from </span><span class="No-Break"><span class="koboSpan" id="kobo.1116.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.1117.1">Let’s create a test for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1118.1">UpdateInvoiceAsync()</span></strong><span class="koboSpan" id="kobo.1119.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">InvoiceController</span></strong><span class="koboSpan" id="kobo.1121.1"> class. </span><span class="koboSpan" id="kobo.1121.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">UpdateInvoiceAsync()</span></strong><span class="koboSpan" id="kobo.1123.1"> method updates an invoice in the database. </span><span class="koboSpan" id="kobo.1123.2">The test method is </span><span class="No-Break"><span class="koboSpan" id="kobo.1124.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1125.1">
[Fact]public async Task  UpdateInvoice_ShouldUpdateInvoice()
{
    // Arrange
    await using var dbContext = fixture.CreateDbContext();
    var emailServiceMock = new Mock&lt;IEmailService&gt;();
    var controller = new InvoiceController(dbContext, emailServiceMock.Object);
    // Act
    // Start a transaction to prevent the changes from being saved to the database
    await dbContext.Database.BeginTransactionAsync();
    var invoice = dbContext.Invoices.First();
    invoice.Status = InvoiceStatus.Paid;
    invoice.Description = "Updated description";
    invoice.InvoiceItems.ForEach(x =&gt;
    {
        x.Description = "Updated description";
        x.UnitPrice += 100;
    });
    var expectedAmount = invoice.InvoiceItems.Sum(x =&gt; x.UnitPrice * x.Quantity);
    await controller.UpdateInvoiceAsync(invoice.Id, invoice);
    // Assert
    dbContext.ChangeTracker.Clear();
    var invoiceUpdated = await dbContext.Invoices.SingleAsync(x =&gt; x.Id == invoice.Id);
    Assert.Equal(InvoiceStatus.Paid, invoiceUpdated.Status);
    Assert.Equal("Updated description", invoiceUpdated.Description);
    Assert.Equal(expectedAmount, invoiceUpdated.Amount);
    Assert.Equal(2, dbContext.Invoices.Count());
}</span></pre>
<p><span class="koboSpan" id="kobo.1126.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">UpdateInvoice_ShouldUpdateInvoice()</span></strong><span class="koboSpan" id="kobo.1128.1"> method, before we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">UpdateInvoiceAsync()</span></strong><span class="koboSpan" id="kobo.1130.1"> method, we start a transaction. </span><span class="koboSpan" id="kobo.1130.2">After the test method is executed, we do not</span><a id="_idIndexMarker987"/><span class="koboSpan" id="kobo.1131.1"> commit the transaction, so the transaction will roll back. </span><span class="koboSpan" id="kobo.1131.2">The changes that are made in the test method will not be saved to the database. </span><span class="koboSpan" id="kobo.1131.3">In this way, we do not need to manually remove the data from </span><span class="No-Break"><span class="koboSpan" id="kobo.1132.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.1133.1">We also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1134.1">ChangeTracker.Clear()</span></strong><span class="koboSpan" id="kobo.1135.1"> method to clear the change tracker. </span><span class="koboSpan" id="kobo.1135.2">The change tracker is used to track the changes made to the entities. </span><span class="koboSpan" id="kobo.1135.3">If we do not clear the change tracker, we will get the tracked entities instead of querying the database. </span><span class="koboSpan" id="kobo.1135.4">So, we need to explicitly clear the change tracker before we query </span><span class="No-Break"><span class="koboSpan" id="kobo.1136.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.1137.1">This approach is convenient when we test the methods that change the database. </span><span class="koboSpan" id="kobo.1137.2">However, it can lead to a problem: what if the controller (or the service) method already starts a transaction? </span><span class="koboSpan" id="kobo.1137.3">We cannot wrap a transaction in another transaction. </span><span class="koboSpan" id="kobo.1137.4">In this case, we must explicitly clean up any changes made to the database after the test method </span><span class="No-Break"><span class="koboSpan" id="kobo.1138.1">is executed.</span></span></p>
<p><span class="koboSpan" id="kobo.1139.1">We </span><a id="_idIndexMarker988"/><span class="koboSpan" id="kobo.1140.1">can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1141.1">IDisposable</span></strong><span class="koboSpan" id="kobo.1142.1"> interface to clean up the database in our tests. </span><span class="koboSpan" id="kobo.1142.2">To do this, we can create a test class that implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1143.1">IDisposable</span></strong><span class="koboSpan" id="kobo.1144.1"> interface, and then clean up the database in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1145.1">Dispose()</span></strong><span class="koboSpan" id="kobo.1146.1"> method. </span><span class="koboSpan" id="kobo.1146.2">To set up the test context, let’s create a class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1147.1">TransactionalTestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1148.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1149.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1150.1">
public class TransactionalTestDatabaseFixture{
    private const string ConnectionString = @"Server=(localdb)\mssqllocaldb;Database=InvoiceTransactionalTestDb;Trusted_Connection=True";
    public TransactionalTestDatabaseFixture()
    {
        // This code comes from Microsoft Docs: https://github.com/dotnet/EntityFramework.Docs/blob/main/samples/core/Testing/TestingWithTheDatabase/TransactionalTestDatabaseFixture.cs
        using var context = CreateDbContext();
        context.Database.EnsureDeleted();
        context.Database.EnsureCreated();
        InitializeDatabase();
    }
    public InvoiceDbContext CreateDbContext()
        =&gt; new(new DbContextOptionsBuilder&lt;InvoiceDbContext&gt;()
            .UseSqlServer(ConnectionString)
            .Options, null);
    public void InitializeDatabase()
    {
        using var context = CreateDbContext();
        // Create a few Contacts and Invoices
        // Omitted for brevity
        context.SaveChanges();
    }
    public void Cleanup()
    {
        using var context = CreateDbContext();
        context.Contacts.ExecuteDelete();
        context.Invoices.ExecuteDelete();
        context.SaveChanges();
        InitializeDatabase();
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1151.1">In the</span><a id="_idIndexMarker989"/><span class="koboSpan" id="kobo.1152.1"> preceding code, we create a database called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1153.1">InvoiceTransactionalTestDb</span></strong><span class="koboSpan" id="kobo.1154.1"> and initialize it. </span><span class="koboSpan" id="kobo.1154.2">This file is similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">InvoiceTestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1156.1"> class, except that it has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">Cleanup</span></strong><span class="koboSpan" id="kobo.1158.1"> method, which is used to clean up the database. </span><span class="koboSpan" id="kobo.1158.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1159.1">Cleanup</span></strong><span class="koboSpan" id="kobo.1160.1"> method, we delete all the contacts and invoices from the database and then initialize the database to restore </span><span class="No-Break"><span class="koboSpan" id="kobo.1161.1">the data.</span></span></p>
<p><span class="koboSpan" id="kobo.1162.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1163.1">InvoiceController.cs</span></strong><span class="koboSpan" id="kobo.1164.1"> file, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">UpdateInvoiceStatusAsync</span></strong><span class="koboSpan" id="kobo.1166.1"> method uses a transaction to update the status of an invoice. </span><span class="koboSpan" id="kobo.1166.2">It is not required; this is purely for demonstration purposes. </span><span class="koboSpan" id="kobo.1166.3">Let’s create a test class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1167.1">TransactionalInvoiceControllerTests</span></strong><span class="koboSpan" id="kobo.1168.1"> to test this method, </span><span class="No-Break"><span class="koboSpan" id="kobo.1169.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1170.1">
public class TransactionalInvoiceControllerTests(TransactionalTestDatabaseFixture fixture) : IClassFixture&lt;TransactionalTestDatabaseFixture&gt;, IDisposable{
    [Fact]
    public async Task UpdateInvoiceStatusAsync_ShouldUpdateStatus()
    {
        // Arrange
        await using var dbContext = _fixture.CreateDbContext();
        var emailServiceMock = new Mock&lt;IEmailService&gt;();
        var controller = new InvoiceController(dbContext, emailServiceMock.Object);
        // Act
        var invoice = await dbContext.Invoices.FirstAsync(x =&gt; x.Status == InvoiceStatus.AwaitPayment);
        await controller.UpdateInvoiceStatusAsync(invoice.Id, InvoiceStatus.Paid);
        // Assert
        dbContext.ChangeTracker.Clear();
        var updatedInvoice = await dbContext.Invoices.FindAsync(invoice.Id);
        Assert.NotNull(updatedInvoice);
        Assert.Equal(InvoiceStatus.Paid, updatedInvoice.Status);
    }
    public void Dispose()
    {
        _fixture.Cleanup();
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1171.1">In the</span><a id="_idIndexMarker990"/><span class="koboSpan" id="kobo.1172.1"> preceding code, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">TransactionalTestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1174.1"> class to create the database context. </span><span class="koboSpan" id="kobo.1174.2">This class implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1175.1">IDisposable</span></strong><span class="koboSpan" id="kobo.1176.1"> interface and calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1177.1">Cleanup()</span></strong><span class="koboSpan" id="kobo.1178.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1179.1">Dispose()</span></strong><span class="koboSpan" id="kobo.1180.1"> method. </span><span class="koboSpan" id="kobo.1180.2">If we have multiple test methods in one test class, xUnit will create a new instance of the test class for each test method and run them in sequence. </span><span class="koboSpan" id="kobo.1180.3">Therefore, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">Dispose()</span></strong><span class="koboSpan" id="kobo.1182.1"> method will be called after each test method is executed to clean up the database, which will ensure that the changes made in the test methods will not affect other </span><span class="No-Break"><span class="koboSpan" id="kobo.1183.1">test methods.</span></span></p>
<p><span class="koboSpan" id="kobo.1184.1">What if we</span><a id="_idIndexMarker991"/><span class="koboSpan" id="kobo.1185.1"> want to share </span><strong class="source-inline"><span class="koboSpan" id="kobo.1186.1">TransactionalTestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1187.1"> in multiple test classes? </span><span class="koboSpan" id="kobo.1187.2">By default, xUnit will run the test classes in parallel. </span><span class="koboSpan" id="kobo.1187.3">If other test classes also need to use this fixture to clean up the database, it may cause a concurrency issue when xUnit initializes the test context. </span><span class="koboSpan" id="kobo.1187.4">To avoid this problem, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1188.1">Collection</span></strong><span class="koboSpan" id="kobo.1189.1"> attribute to specify that the test classes that use this fixture belong to the same test collection so that xUnit will not run them in parallel. </span><span class="koboSpan" id="kobo.1189.2">We’ll discuss the parallelism of xUn</span><a id="_idTextAnchor397"/><span class="koboSpan" id="kobo.1190.1">it in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1191.1">next section.</span></span></p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor398"/><span class="koboSpan" id="kobo.1192.1">Parallelism of xUnit</span></h2>
<p><span class="koboSpan" id="kobo.1193.1">By default, the</span><a id="_idIndexMarker992"/><span class="koboSpan" id="kobo.1194.1"> latest version of xUnit (v2+) runs tests in parallel. </span><span class="koboSpan" id="kobo.1194.2">This is because parallelism can improve the performance of the test. </span><span class="koboSpan" id="kobo.1194.3">If we have a lot of tests, running them in parallel can save a lot of time. </span><span class="koboSpan" id="kobo.1194.4">Also, it can leverage the multi-core CPU to run the tests. </span><span class="koboSpan" id="kobo.1194.5">However, we need to understand how xUnit runs tests in parallel, just in case it </span><span class="No-Break"><span class="koboSpan" id="kobo.1195.1">causes problems.</span></span></p>
<p><span class="koboSpan" id="kobo.1196.1">xUnit </span><a id="_idIndexMarker993"/><span class="koboSpan" id="kobo.1197.1">uses a concept called </span><strong class="bold"><span class="koboSpan" id="kobo.1198.1">test collection</span></strong><span class="koboSpan" id="kobo.1199.1"> to represent a group of tests. </span><span class="koboSpan" id="kobo.1199.2">By default, each test class is a unique test </span><a id="_idIndexMarker994"/><span class="koboSpan" id="kobo.1200.1">collection. </span><span class="koboSpan" id="kobo.1200.2">Note that the tests in the same test class will not run </span><span class="No-Break"><span class="koboSpan" id="kobo.1201.1">in parallel.</span></span></p>
<p><span class="koboSpan" id="kobo.1202.1">For example, in the sample project, we can find an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1203.1">InvoiceControllerTests.cs</span></strong><span class="koboSpan" id="kobo.1204.1"> file and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1205.1">ContactControllerTests.cs</span></strong><span class="koboSpan" id="kobo.1206.1"> file. </span><span class="koboSpan" id="kobo.1206.2">So, xUnit will run these two test classes in parallel, but the tests in the same test class will not run </span><span class="No-Break"><span class="koboSpan" id="kobo.1207.1">in parallel.</span></span></p>
<p><span class="koboSpan" id="kobo.1208.1">We also introduced a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1209.1">TestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1210.1"> class in the </span><em class="italic"><span class="koboSpan" id="kobo.1211.1">Creating a test fixture</span></em><span class="koboSpan" id="kobo.1212.1"> section. </span><span class="koboSpan" id="kobo.1212.2">A class fixture</span><a id="_idIndexMarker995"/><span class="koboSpan" id="kobo.1213.1"> is used to share a single test context among all the tests in the same test class. </span><span class="koboSpan" id="kobo.1213.2">So, if we use a class fixture to create a database context, the database context will be shared among all the tests in the same test class. </span><span class="koboSpan" id="kobo.1213.3">Currently, we have two test classes that use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">TestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1215.1"> class to provide the database context. </span><span class="koboSpan" id="kobo.1215.2">Will xUnit create only one instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1216.1">TestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1217.1"> class for these two </span><span class="No-Break"><span class="koboSpan" id="kobo.1218.1">test classes?</span></span></p>
<p><span class="koboSpan" id="kobo.1219.1">The answer is no. </span><span class="koboSpan" id="kobo.1219.2">We can set up a breakpoint in the constructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1220.1">TestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1221.1"> class, and then debug the tests by right-clicking </span><strong class="source-inline"><span class="koboSpan" id="kobo.1222.1">InvoiceApp.UnitTests</span></strong><span class="koboSpan" id="kobo.1223.1"> in the </span><strong class="bold"><span class="koboSpan" id="kobo.1224.1">Test Explorer</span></strong><span class="koboSpan" id="kobo.1225.1"> window of VS 2022 and then clicking </span><strong class="bold"><span class="koboSpan" id="kobo.1226.1">Debug</span></strong><span class="koboSpan" id="kobo.1227.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1228.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1229.1">.6</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1230.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<span class="koboSpan" id="kobo.1231.1"><img alt="Figure 9.6 – Debug tests in VS 2022" src="image/B18971_09_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1232.1">Figure 9.6 – Debug tests in VS 2022</span></p>
<p><span class="koboSpan" id="kobo.1233.1">You will find that the constructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1234.1">TestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1235.1"> class is called twice (or more, depending on how many tests use this text fixture). </span><span class="koboSpan" id="kobo.1235.2">So, we know that xUnit will create a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1236.1">TestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1237.1"> class for each test class as well. </span><span class="koboSpan" id="kobo.1237.2">That is why we use a lock to ensure that the database is only created once. </span><span class="koboSpan" id="kobo.1237.3">If we do not use the lock, multiple</span><a id="_idIndexMarker996"/><span class="koboSpan" id="kobo.1238.1"> test classes will try to initialize the database at the same time, which potentially </span><span class="No-Break"><span class="koboSpan" id="kobo.1239.1">causes problems.</span></span></p>
<p><span class="koboSpan" id="kobo.1240.1">In the </span><em class="italic"><span class="koboSpan" id="kobo.1241.1">Writing tests for methods that change the database</span></em><span class="koboSpan" id="kobo.1242.1"> section, we created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1243.1">TransactionalTestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1244.1"> class that can clean up the database. </span><span class="koboSpan" id="kobo.1244.2">If we apply it to one test class, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">TransactionalInvoiceControllerTests</span></strong><span class="koboSpan" id="kobo.1246.1">, it will work fine. </span><span class="koboSpan" id="kobo.1246.2">But what if we want to use it for multiple test classes? </span><span class="koboSpan" id="kobo.1246.3">By default, xUnit will run these test classes in parallel, which means that multiple test classes will try to clean up the database at the same time. </span><span class="koboSpan" id="kobo.1246.4">In this case, we do not want to run these test classes in parallel. </span><span class="koboSpan" id="kobo.1246.5">To do this, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1247.1">Collection</span></strong><span class="koboSpan" id="kobo.1248.1"> attribute to group these test classes into one collection so that xUnit will not run them in parallel. </span><span class="koboSpan" id="kobo.1248.2">This can help us avoid the </span><span class="No-Break"><span class="koboSpan" id="kobo.1249.1">concurrency issue.</span></span></p>
<p><span class="koboSpan" id="kobo.1250.1">Let’s see an example. </span><span class="koboSpan" id="kobo.1250.2">In the sample project, you will find that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1251.1">ContactController</span></strong><span class="koboSpan" id="kobo.1252.1"> file has a method named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1253.1">UpdateContactAsync()</span></strong><span class="koboSpan" id="kobo.1254.1"> that uses a transaction. </span><span class="koboSpan" id="kobo.1254.2">Again, this is not required and is just for demonstration purposes. </span><span class="koboSpan" id="kobo.1254.3">To use the collection fixture, we need to create a definition for the collection. </span><span class="koboSpan" id="kobo.1254.4">Let’s create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1255.1">TransactionalTestsCollection</span></strong><span class="koboSpan" id="kobo.1256.1"> class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1257.1">InvoiceApp.UnitTests</span></strong><span class="koboSpan" id="kobo.1258.1"> project, </span><span class="No-Break"><span class="koboSpan" id="kobo.1259.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1260.1">
[CollectionDefinition("TransactionalTests")]public class TransactionTestsCollection : ICollectionFixture&lt;TransactionalTestDatabaseFixture&gt;
{
}</span></pre>
<p><span class="koboSpan" id="kobo.1261.1">In this class, we</span><a id="_idIndexMarker997"/><span class="koboSpan" id="kobo.1262.1"> declare that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1263.1">TransactionalTestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1264.1"> class is a collection fixture that uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1265.1">CollectionDefinition</span></strong><span class="koboSpan" id="kobo.1266.1"> attribute. </span><span class="koboSpan" id="kobo.1266.2">We also specify a name for this collection, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1267.1">TransactionalTests</span></strong><span class="koboSpan" id="kobo.1268.1">. </span><span class="koboSpan" id="kobo.1268.2">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1269.1">ICollectionFixture&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1270.1"> interface to specify that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1271.1">TransactionalTestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1272.1"> class is a </span><span class="No-Break"><span class="koboSpan" id="kobo.1273.1">collection fixture.</span></span></p>
<p><span class="koboSpan" id="kobo.1274.1">After that, we add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">Collection</span></strong><span class="koboSpan" id="kobo.1276.1"> attribute to the test classes, which specifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1277.1">TransactionalInvoiceControllerTests</span></strong><span class="koboSpan" id="kobo.1278.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1279.1">TransactionalContactControllerTests</span></strong><span class="koboSpan" id="kobo.1280.1"> classes belong to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1281.1">TransactionalTests</span></strong><span class="koboSpan" id="kobo.1282.1"> collection, </span><span class="No-Break"><span class="koboSpan" id="kobo.1283.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1284.1">
[Collection("TransactionalTests")]public class TransactionalInvoiceControllerTests : IDisposable
{
    // Omitted for brevity
}
[Collection("TransactionalTests")]
public class TransactionalContactControllerTests : IDisposable
{
    // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.1285.1">Now, if we debug the tests, we will find that the constructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1286.1">TransactionalTestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1287.1"> class is only called once, which means that xUnit will only create one instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1288.1">TransactionalTestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1289.1"> class for these two test classes. </span><span class="koboSpan" id="kobo.1289.2">Also, xUnit will not run these two test classes in parallel, which means that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1290.1">Cleanup</span></strong><span class="koboSpan" id="kobo.1291.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1292.1">TransactionalTestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1293.1"> class will not be called at the same time. </span><span class="koboSpan" id="kobo.1293.2">So, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1294.1">TransactionalTestDatabaseFixture</span></strong><span class="koboSpan" id="kobo.1295.1"> class to clean up the </span><a id="_idIndexMarker998"/><span class="koboSpan" id="kobo.1296.1">database for each test method in multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.1297.1">test classes.</span></span></p>
<p><span class="koboSpan" id="kobo.1298.1">Let’s summarize the key points of </span><span class="No-Break"><span class="koboSpan" id="kobo.1299.1">this section:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1300.1">By default, each test class is a unique </span><span class="No-Break"><span class="koboSpan" id="kobo.1301.1">test collection</span></span></li>
<li><span class="koboSpan" id="kobo.1302.1">The tests in the same test class will not run </span><span class="No-Break"><span class="koboSpan" id="kobo.1303.1">in parallel</span></span></li>
<li><span class="koboSpan" id="kobo.1304.1">If we want to share a single test context among all the tests within the same test class, we can use a </span><span class="No-Break"><span class="koboSpan" id="kobo.1305.1">class fixture:</span></span><ul><li><span class="koboSpan" id="kobo.1306.1">xUnit creates a new instance of the test class for each </span><span class="No-Break"><span class="koboSpan" id="kobo.1307.1">test method</span></span></li><li><span class="koboSpan" id="kobo.1308.1">xUnit creates a new instance of the class fixture for each test class and shares the same instance among all the tests in the same </span><span class="No-Break"><span class="koboSpan" id="kobo.1309.1">test class</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.1310.1">By default, xUnit runs test classes in parallel if they are not in the same </span><span class="No-Break"><span class="koboSpan" id="kobo.1311.1">test collection</span></span></li>
<li><span class="koboSpan" id="kobo.1312.1">If we do not want to run multiple test classes in parallel, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1313.1">Collection</span></strong><span class="koboSpan" id="kobo.1314.1"> attribute to group them into one </span><span class="No-Break"><span class="koboSpan" id="kobo.1315.1">test collection</span></span></li>
<li><span class="koboSpan" id="kobo.1316.1">If we want to share a single test context among several test classes and clean up the test context after each test method, we can use a collection fixture, and implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1317.1">IDisposable</span></strong><span class="koboSpan" id="kobo.1318.1"> interface in each test class to clean up the </span><span class="No-Break"><span class="koboSpan" id="kobo.1319.1">test context:</span></span><ul><li><span class="koboSpan" id="kobo.1320.1">xUnit creates a new instance of the test class for each </span><span class="No-Break"><span class="koboSpan" id="kobo.1321.1">test method</span></span></li><li><span class="koboSpan" id="kobo.1322.1">xUnit creates only one instance of the collection fixture for the test collection and shares the same instance among all the tests in </span><span class="No-Break"><span class="koboSpan" id="kobo.1323.1">the collection</span></span></li><li><span class="koboSpan" id="kobo.1324.1">xUnit </span><a id="_idIndexMarker999"/><span class="koboSpan" id="kobo.1325.1">does not run multiple test classes in parallel if they belong to the same </span><span class="No-Break"><span class="koboSpan" id="kobo.1326.1">test collection</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.1327.1">xUnit provides a lot of features to customize the test execution. </span><span class="koboSpan" id="kobo.1327.2">If you want to learn more about xUnit, you can check out the official</span><a id="_idIndexMarker1000"/><span class="koboSpan" id="kobo.1328.1"> docu</span><a id="_idTextAnchor399"/><span class="koboSpan" id="kobo.1329.1">mentation </span><span class="No-Break"><span class="koboSpan" id="kobo.1330.1">at </span></span><a href="https://xunit.net/"><span class="No-Break"><span class="koboSpan" id="kobo.1331.1">https://xunit.net/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1332.1">.</span></span></p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor400"/><span class="koboSpan" id="kobo.1333.1">Using the repository pattern</span></h2>
<p><span class="koboSpan" id="kobo.1334.1">So far, you have </span><a id="_idIndexMarker1001"/><span class="koboSpan" id="kobo.1335.1">learned how to use a real database to test the database access layer. </span><span class="koboSpan" id="kobo.1335.2">There is another way to test the database access layer, which is to use a repository pattern to decouple the controllers from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1336.1">DbContext</span></strong><span class="koboSpan" id="kobo.1337.1"> class. </span><span class="koboSpan" id="kobo.1337.2">In this section, we will show you how to use the repository pattern to test the database </span><span class="No-Break"><span class="koboSpan" id="kobo.1338.1">access layer.</span></span></p>
<p><span class="koboSpan" id="kobo.1339.1">The repository pattern</span><a id="_idIndexMarker1002"/><span class="koboSpan" id="kobo.1340.1"> is a common pattern that’s used to separate the application and the database access layer. </span><span class="koboSpan" id="kobo.1340.2">Instead of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1341.1">DbContext</span></strong><span class="koboSpan" id="kobo.1342.1"> directly in the controllers, we can add a separate repository layer to encapsulate the database access logic. </span><span class="koboSpan" id="kobo.1342.2">The controllers will use the repository layer to access the database, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1343.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1344.1">.7</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1345.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<span class="koboSpan" id="kobo.1346.1"><img alt="Figure 9.7– Using the repository pattern" src="image/B18971_09_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1347.1">Figure 9.7– Using the repository pattern</span></p>
<p><span class="koboSpan" id="kobo.1348.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1349.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1350.1">.7</span></em><span class="koboSpan" id="kobo.1351.1">, we can see </span><a id="_idIndexMarker1003"/><span class="koboSpan" id="kobo.1352.1">that the application now has no dependency on EF Core. </span><span class="koboSpan" id="kobo.1352.2">The application (controllers) only depends on the repository layer, and the repository layer depends on EF Core. </span><span class="koboSpan" id="kobo.1352.3">Therefore, the repository layer can be mocked in the tests, and the controllers can be tested without a </span><span class="No-Break"><span class="koboSpan" id="kobo.1353.1">real database.</span></span></p>
<p><span class="koboSpan" id="kobo.1354.1">To learn how to use the</span><a id="_idIndexMarker1004"/><span class="koboSpan" id="kobo.1355.1"> repository pattern for testing, you can look at the sample project in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1356.1">UnitTestsDemo\UnitTest-v2</span></strong><span class="koboSpan" id="kobo.1357.1"> folder. </span><span class="koboSpan" id="kobo.1357.2">This project is based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1358.1">v1</span></strong><span class="koboSpan" id="kobo.1359.1"> project, and we have added a repository layer to </span><span class="No-Break"><span class="koboSpan" id="kobo.1360.1">the project.</span></span></p>
<p><span class="koboSpan" id="kobo.1361.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1362.1">IInvoiceRepository</span></strong><span class="koboSpan" id="kobo.1363.1"> interface defines the methods of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1364.1">Invoice</span></strong><span class="koboSpan" id="kobo.1365.1"> repository, </span><span class="No-Break"><span class="koboSpan" id="kobo.1366.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1367.1">
public interface IInvoiceRepository{
    Task&lt;Invoice?&gt; GetInvoiceAsync(Guid id);
    Task&lt;IEnumerable&lt;Invoice&gt;&gt; GetInvoicesAsync(int page = 1, int pageSize = 10, InvoiceStatus? </span><span class="koboSpan" id="kobo.1367.2">status = null);
    Task&lt;IEnumerable&lt;Invoice&gt;&gt; GetInvoicesByContactIdAsync(Guid contactId, int page = 1, int pageSize = 10, InvoiceStatus? </span><span class="koboSpan" id="kobo.1367.3">status = null);
    Task&lt;Invoice&gt; CreateInvoiceAsync(Invoice invoice);
    Task&lt;Invoice?&gt; UpdateInvoiceAsync(Invoice invoice);
    Task DeleteInvoiceAsync(Guid id);
}</span></pre>
<p><span class="koboSpan" id="kobo.1368.1">The implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1369.1">IInvoiceRepository</span></strong><span class="koboSpan" id="kobo.1370.1"> interface is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1371.1">InvoiceRepository</span></strong><span class="koboSpan" id="kobo.1372.1"> class; it uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1373.1">DbContext</span></strong><span class="koboSpan" id="kobo.1374.1"> class to access the database. </span><span class="koboSpan" id="kobo.1374.2">First, we inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1375.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.1376.1"> class into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1377.1">InvoiceRepository</span></strong><span class="koboSpan" id="kobo.1378.1"> class using the constructor injection, </span><span class="No-Break"><span class="koboSpan" id="kobo.1379.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1380.1">
public class InvoiceRepository(InvoiceDbContext dbContext) : IInvoiceRepository{
}</span></pre>
<p><span class="koboSpan" id="kobo.1381.1">Next, we can implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1382.1">IInvoiceRepository</span></strong><span class="koboSpan" id="kobo.1383.1"> interface in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1384.1">InvoiceRepository</span></strong><span class="koboSpan" id="kobo.1385.1"> class. </span><span class="koboSpan" id="kobo.1385.2">Here is an example of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1386.1">GetInvoicesAsync</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1387.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1388.1">
public async Task&lt;Invoice?&gt; GetInvoiceAsync(Guid id){
    return await dbContext.Invoices.Include(i =&gt; i.Contact)
        .SingleOrDefaultAsync(i =&gt; i.Id == id);
}</span></pre>
<p><span class="koboSpan" id="kobo.1389.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1390.1">GetInvoiceAsync()</span></strong><span class="koboSpan" id="kobo.1391.1"> method, we use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1392.1">LINQ</span></strong><span class="koboSpan" id="kobo.1393.1"> query to get the invoice by the specified ID. </span><span class="koboSpan" id="kobo.1393.2">Note </span><a id="_idIndexMarker1005"/><span class="koboSpan" id="kobo.1394.1">that we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1395.1">Include</span></strong><span class="koboSpan" id="kobo.1396.1"> method to include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1397.1">Contact</span></strong><span class="koboSpan" id="kobo.1398.1"> property in the query result. </span><span class="koboSpan" id="kobo.1398.2">This is because we want to get the contact information of the invoice. </span><span class="koboSpan" id="kobo.1398.3">If we do not want to include the navigation property in the query result, we can remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1399.1">Include()</span></strong><span class="koboSpan" id="kobo.1400.1"> method, or add a parameter to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1401.1">GetInvoiceAsync()</span></strong><span class="koboSpan" id="kobo.1402.1"> method to specify whether to include the navigation property. </span><span class="koboSpan" id="kobo.1402.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1403.1">Include()</span></strong><span class="koboSpan" id="kobo.1404.1"> method is defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1405.1">Microsoft.EntityFrameworkCore</span></strong><span class="koboSpan" id="kobo.1406.1"> namespace, so we need to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1407.1">using Microsoft.EntityFrameworkCore;</span></strong><span class="koboSpan" id="kobo.1408.1"> statement to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1409.1">InvoiceRepository.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1410.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.1411.1">The implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1412.1">GetInvoicesAsync()</span></strong><span class="koboSpan" id="kobo.1413.1"> method is </span><span class="No-Break"><span class="koboSpan" id="kobo.1414.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1415.1">
public async Task&lt;IEnumerable&lt;Invoice&gt;&gt; GetInvoicesAsync(int page = 1, int pageSize = 10, InvoiceStatus? </span><span class="koboSpan" id="kobo.1415.2">status = null){
    return await dbContext.Invoices
        .Include(x =&gt; x.Contact)
        .Where(x =&gt; status == null || x.Status == status)
        .OrderByDescending(x =&gt; x.InvoiceDate)
        .Skip((page - 1) * pageSize)
        .Take(pageSize)
        .ToListAsync();
}</span></pre>
<p><span class="koboSpan" id="kobo.1416.1">In the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.1417.1">GetInvoicesAsync()</span></strong><span class="koboSpan" id="kobo.1418.1"> method, we use some </span><strong class="source-inline"><span class="koboSpan" id="kobo.1419.1">LINQ</span></strong><span class="koboSpan" id="kobo.1420.1"> methods, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1421.1">Where()</span></strong><span class="koboSpan" id="kobo.1422.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1423.1">OrderByDescending()</span></strong><span class="koboSpan" id="kobo.1424.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1425.1">Skip()</span></strong><span class="koboSpan" id="kobo.1426.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1427.1">Take()</span></strong><span class="koboSpan" id="kobo.1428.1">, to implement the pagination feature. </span><span class="koboSpan" id="kobo.1428.2">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1429.1">ToListAsync()</span></strong><span class="koboSpan" id="kobo.1430.1"> method is defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1431.1">Microsoft.EntityFrameworkCore</span></strong><span class="koboSpan" id="kobo.1432.1"> namespace, so do not forget to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1433.1">using </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1434.1">Microsoft.EntityFrameworkCore;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1435.1"> statement.</span></span></p>
<p><span class="koboSpan" id="kobo.1436.1">You can find the complete implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1437.1">InvoiceRepository</span></strong><span class="koboSpan" id="kobo.1438.1"> class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1439.1">InvoiceRepository.cs</span></strong><span class="koboSpan" id="kobo.1440.1"> file in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1441.1">UnitTestsDemo\UnitTest-v2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1442.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.1443.1">The implementation of the repository interface is just a class that uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1444.1">DbContext</span></strong><span class="koboSpan" id="kobo.1445.1"> class to implement the CRUD operations. </span><span class="koboSpan" id="kobo.1445.2">Generally, this layer does not contain any business logic. </span><span class="koboSpan" id="kobo.1445.3">Also, we should note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1446.1">GetInvoicesAsync()</span></strong><span class="koboSpan" id="kobo.1447.1"> method returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1448.1">IEnumerable&lt;Invoice&gt;</span></strong><span class="koboSpan" id="kobo.1449.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1450.1">IQueryable&lt;Invoice&gt;</span></strong><span class="koboSpan" id="kobo.1451.1">. </span><span class="koboSpan" id="kobo.1451.2">This is because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1452.1">IQueryable</span></strong><span class="koboSpan" id="kobo.1453.1"> interface involves EF Core, but the purpose of using the repository pattern is to decouple the application from EF Core. </span><span class="koboSpan" id="kobo.1453.2">So, we can easily mock the repository layer in </span><span class="No-Break"><span class="koboSpan" id="kobo.1454.1">the tests.</span></span></p>
<p><span class="koboSpan" id="kobo.1455.1">The controllers now</span><a id="_idIndexMarker1006"/><span class="koboSpan" id="kobo.1456.1"> depend on the repository layer, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1457.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1458.1">
[Route("api/[controller]")][ApiController]
public class InvoiceController(IInvoiceRepository invoiceRepository, IEmailService emailService)
    : ControllerBase
    // GET: api/Invoices
    [HttpGet]
    public async Task&lt;ActionResult&lt;List&lt;Invoice&gt;&gt;&gt; GetInvoicesAsync(int page = 1, int pageSize = 10,
        InvoiceStatus? </span><span class="koboSpan" id="kobo.1458.2">status = null)
    {
        var invoices = await invoiceRepository.GetInvoicesAsync(page, pageSize, status);
        return Ok(invoices);
    }
    // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.1459.1">Now, the controller</span><a id="_idIndexMarker1007"/><span class="koboSpan" id="kobo.1460.1"> is much cleaner, and there is no dependency on EF Core. </span><span class="koboSpan" id="kobo.1460.2">We can update the tests so that they use the repository layer instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1461.1">DbContext</span></strong><span class="koboSpan" id="kobo.1462.1"> class. </span><span class="koboSpan" id="kobo.1462.2">Similar to that in the previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.1463.1">InvoiceControllerTests</span></strong><span class="koboSpan" id="kobo.1464.1">, we may need a class fixture to manage the test context, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1465.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1466.1">
public class TestFixture{
    public List&lt;Invoice&gt; Invoices { get; set; } = new();
    public List&lt;Contact&gt; Contacts { get; set; } = new();
    public TestFixture()
    {
        InitializeDatabase();
    }
    public void InitializeDatabase()
    {
        // Omited for brevity
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1467.1">In this class fixture, we </span><a id="_idIndexMarker1008"/><span class="koboSpan" id="kobo.1468.1">have added two lists to mock the database tables. </span><span class="koboSpan" id="kobo.1468.2">Next, we can mock the tests, </span><span class="No-Break"><span class="koboSpan" id="kobo.1469.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1470.1">
public class InvoiceControllerTests(TestFixture fixture) : IClassFixture&lt;TestFixture&gt;{
    [Fact]
    public async Task GetInvoices_ShouldReturnInvoices()
    {
        // Arrange
        var repositoryMock = new Mock&lt;IInvoiceRepository&gt;();
        repositoryMock.Setup(x =&gt; x.GetInvoicesAsync(It.IsAny&lt;int&gt;(), It.IsAny&lt;int&gt;(), It.IsAny&lt;InvoiceStatus?&gt;()))
            .ReturnsAsync((int page, int pageSize, InvoiceStatus? </span><span class="koboSpan" id="kobo.1470.2">status) =&gt;
                fixture.Invoices.Where(x =&gt; status == null || x.Status == status)
                    .OrderByDescending(x =&gt; x.InvoiceDate)
                    .Skip((page - 1) * pageSize)
                    .Take(pageSize)
                    .ToList());
        var emailServiceMock = new Mock&lt;IEmailService&gt;();
        var controller = new InvoiceController(repositoryMock.Object, emailServiceMock.Object);
        // Act
        var actionResult = await controller.GetInvoicesAsync();
        // Assert
        var result = actionResult.Result as OkObjectResult;
        Assert.NotNull(result);
        var returnResult = Assert.IsAssignableFrom&lt;List&lt;Invoice&gt;&gt;(result.Value);
        Assert.NotNull(returnResult);
        Assert.Equal(2, returnResult.Count);
        Assert.Contains(returnResult, i =&gt; i.InvoiceNumber == "INV-001");
        Assert.Contains(returnResult, i =&gt; i.InvoiceNumber == "INV-002");
    }
    // Omited for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.1471.1">In this test</span><a id="_idIndexMarker1009"/><span class="koboSpan" id="kobo.1472.1"> method, we mock the repository layer and pass it to the controller. </span><span class="koboSpan" id="kobo.1472.2">It follows the concept of the unit tests: focus on the unit under test and mock the dependencies. </span><span class="koboSpan" id="kobo.1472.3">You can check the other tests in the source code and try to add more tests to cover the other scenarios, such as creating invoices, updating invoices, deleting invoices, and so on. </span><span class="koboSpan" id="kobo.1472.4">Note that we use two instances of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1473.1">List&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1474.1"> to mock the database tables. </span><span class="koboSpan" id="kobo.1474.2">If the test methods change the data, do not forget to restore the data after the test methods </span><span class="No-Break"><span class="koboSpan" id="kobo.1475.1">are executed.</span></span></p>
<p><span class="koboSpan" id="kobo.1476.1">The repository pattern is a good practice for decoupling the application from the data access layer, and it also makes it possible to replace the data access layer with another one. </span><span class="koboSpan" id="kobo.1476.2">It allows us to mock the database access layer for testing purposes. </span><span class="koboSpan" id="kobo.1476.3">However, it increases the complexity of the application. </span><span class="koboSpan" id="kobo.1476.4">Also, if we use the repository pattern, we may lose some features of EF Core, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1477.1">IQueryable</span></strong><span class="koboSpan" id="kobo.1478.1">. </span><span class="koboSpan" id="kobo.1478.2">Finally, the mock behavior may be different from the real behavior. </span><span class="koboSpan" id="kobo.1478.3">So, we should </span><a id="_idTextAnchor401"/><span class="koboSpan" id="kobo.1479.1">consider the trade-offs before </span><span class="No-Break"><span class="koboSpan" id="kobo.1480.1">using it.</span></span></p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor402"/><span class="koboSpan" id="kobo.1481.1">Testing the happy path and the sad path</span></h2>
<p><span class="koboSpan" id="kobo.1482.1">So far, we have written some tests to cover the happy path. </span><span class="koboSpan" id="kobo.1482.2">However, we should also test the sad path. </span><span class="koboSpan" id="kobo.1482.3">In testing, the terms </span><strong class="bold"><span class="koboSpan" id="kobo.1483.1">happy path</span></strong><span class="koboSpan" id="kobo.1484.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1485.1">sad path</span></strong><span class="koboSpan" id="kobo.1486.1"> are </span><a id="_idIndexMarker1010"/><span class="koboSpan" id="kobo.1487.1">used to describe different scenarios or </span><span class="No-Break"><span class="koboSpan" id="kobo.1488.1">test cases:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1489.1">Happy path</span></strong><span class="koboSpan" id="kobo.1490.1">: A happy path</span><a id="_idIndexMarker1011"/><span class="koboSpan" id="kobo.1491.1"> refers to the ideal or expected scenario where the code unit being tested performs as intended. </span><span class="koboSpan" id="kobo.1491.2">The input data is valid, and the code unit produces the expected output. </span><span class="koboSpan" id="kobo.1491.3">Happy path tests are designed to validate the typical or desired behavior of the code unit. </span><span class="koboSpan" id="kobo.1491.4">These tests ensure that the code works as expected without any errors or exceptions when the input data is valid. </span><span class="koboSpan" id="kobo.1491.5">For example, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1492.1">GetInvoiceAsync(Guid id)</span></strong><span class="koboSpan" id="kobo.1493.1"> method, the happy path is that the invoice with the specified ID exists in the database, and the method returns </span><span class="No-Break"><span class="koboSpan" id="kobo.1494.1">the invoice.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1495.1">Sad path</span></strong><span class="koboSpan" id="kobo.1496.1">: A </span><a id="_idIndexMarker1012"/><span class="koboSpan" id="kobo.1497.1">sad path, also known as the unhappy path, refers to the scenario where the code unit encounters an error or exception. </span><span class="koboSpan" id="kobo.1497.2">The input data may be invalid, or the dependencies may not work as expected. </span><span class="koboSpan" id="kobo.1497.3">Sad path tests are designed to validate whether the code unit can handle errors or exceptions gracefully. </span><span class="koboSpan" id="kobo.1497.4">For example, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1498.1">GetInvoiceAsync(Guid id)</span></strong><span class="koboSpan" id="kobo.1499.1"> method, the sad path is that the invoice with the specified ID does not exist in the database, and the method returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1500.1">404 Not </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1501.1">Found</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1502.1"> error.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1503.1">By combining both happy path and sad path tests, we can ensure that the code unit works as expected in different scenarios. </span><span class="koboSpan" id="kobo.1503.2">Here is an </span><a id="_idIndexMarker1013"/><span class="koboSpan" id="kobo.1504.1">example of a happy path for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1505.1">the GetInvoiceAsync(Guid </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1506.1">id)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1507.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1508.1">
[Fact]public async Task GetInvoice_ShouldReturnInvoice()
{
    // Arrange
    var repositoryMock = new Mock&lt;IInvoiceRepository&gt;();
    repositoryMock.Setup(x =&gt; x.GetInvoiceAsync(It.IsAny&lt;Guid&gt;()))
        .ReturnsAsync((Guid id) =&gt; fixture.Invoices.FirstOrDefault(x =&gt; x.Id == id));
    var emailServiceMock = new Mock&lt;IEmailService&gt;();
    var controller = new InvoiceController(repositoryMock.Object, emailServiceMock.Object);
    // Act
    var invoice = fixture.Invoices.First();
    var actionResult = await controller.GetInvoiceAsync(invoice.Id);
    // Assert
    var result = actionResult.Result as OkObjectResult;
    Assert.NotNull(result);
    var returnResult = Assert.IsAssignableFrom&lt;Invoice&gt;(result.Value);
    Assert.NotNull(returnResult);
    Assert.Equal(invoice.Id, returnResult.Id);
    Assert.Equal(invoice.InvoiceNumber, returnResult.InvoiceNumber);
}</span></pre>
<p><span class="koboSpan" id="kobo.1509.1">In this test method, we pass the </span><a id="_idIndexMarker1014"/><span class="koboSpan" id="kobo.1510.1">ID of the first invoice in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1511.1">Invoices</span></strong><span class="koboSpan" id="kobo.1512.1"> list to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1513.1">GetInvoiceAsync(Guid id)</span></strong><span class="koboSpan" id="kobo.1514.1"> method. </span><span class="koboSpan" id="kobo.1514.2">Since the invoice with the specified ID exists in the database, the method should return </span><span class="No-Break"><span class="koboSpan" id="kobo.1515.1">the invoice.</span></span></p>
<p><span class="koboSpan" id="kobo.1516.1">Let’s create a sad path</span><a id="_idIndexMarker1015"/><span class="koboSpan" id="kobo.1517.1"> test for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1518.1">GetInvoiceAsync(Guid </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1519.1">id)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1520.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1521.1">
[Fact]public async Task GetInvoice_ShouldReturnNotFound()
{
    // Arrange
    var repositoryMock = new Mock&lt;IInvoiceRepository&gt;();
    repositoryMock.Setup(x =&gt; x.GetInvoiceAsync(It.IsAny&lt;Guid&gt;()))
        .ReturnsAsync((Guid id) =&gt; _fixture.Invoices.FirstOrDefault(x =&gt; x.Id == id));
    var emailServiceMock = new Mock&lt;IEmailService&gt;();
    var coentroller = new InvoiceController(repositoryMock.Object, emailServiceMock.Object);
    // Act
    var actionResult = await controller.GetInvoiceAsync(Guid.NewGuid());
    // Assert
    var result = actionResult.Result as NotFoundResult;
    Assert.NotNull(result);
}</span></pre>
<p><span class="koboSpan" id="kobo.1522.1">In this test method, we </span><a id="_idIndexMarker1016"/><span class="koboSpan" id="kobo.1523.1">pass a new GUID to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1524.1">GetInvoiceAsync(Guid id)</span></strong><span class="koboSpan" id="kobo.1525.1"> method. </span><span class="koboSpan" id="kobo.1525.2">Since the invoice with the specified ID does not exist in the database, the method should return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1526.1">404 Not Found</span></strong><span class="koboSpan" id="kobo.1527.1"> error. </span><span class="koboSpan" id="kobo.1527.2">We can also create sad path tests for </span><span class="No-Break"><span class="koboSpan" id="kobo.1528.1">other methods.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1529.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1530.1">What is the difference between </span><strong class="source-inline"><span class="koboSpan" id="kobo.1531.1">as</span></strong><span class="koboSpan" id="kobo.1532.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1533.1">is</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1534.1">in C#?</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.1535.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1536.1">as</span></strong><span class="koboSpan" id="kobo.1537.1"> operator</span><a id="_idIndexMarker1017"/><span class="koboSpan" id="kobo.1538.1"> is used to perform conversions between compatible types. </span><span class="koboSpan" id="kobo.1538.2">If the conversion is not possible, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1539.1">as</span></strong><span class="koboSpan" id="kobo.1540.1"> operator returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1541.1">null</span></strong><span class="koboSpan" id="kobo.1542.1"> instead of raising an exception. </span><span class="koboSpan" id="kobo.1542.2">So, in the preceding test, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.1543.1">result</span></strong><span class="koboSpan" id="kobo.1544.1"> is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.1545.1">null</span></strong><span class="koboSpan" id="kobo.1546.1">, we can see that the result from the controller is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1547.1">NotFoundResult</span></strong><span class="koboSpan" id="kobo.1548.1">, which is the </span><span class="No-Break"><span class="koboSpan" id="kobo.1549.1">expected result.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.1550.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1551.1">is</span></strong><span class="koboSpan" id="kobo.1552.1"> operator</span><a id="_idIndexMarker1018"/><span class="koboSpan" id="kobo.1553.1"> is used to determine whether an object is compatible with a given type. </span><span class="koboSpan" id="kobo.1553.2">If the object is compatible, the operator will return </span><strong class="source-inline"><span class="koboSpan" id="kobo.1554.1">true</span></strong><span class="koboSpan" id="kobo.1555.1">; otherwise, it will return </span><strong class="source-inline"><span class="koboSpan" id="kobo.1556.1">false</span></strong><span class="koboSpan" id="kobo.1557.1">. </span><span class="koboSpan" id="kobo.1557.2">This is a useful tool for verifying the type of an object before performing an operation </span><span class="No-Break"><span class="koboSpan" id="kobo.1558.1">on it.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.1559.1">From C# 7, we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1560.1">is</span></strong><span class="koboSpan" id="kobo.1561.1"> to check and convert the type at the same time. </span><span class="koboSpan" id="kobo.1561.2">For example, we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1562.1">if (result is NotFoundResult notFoundResult)</span></strong><span class="koboSpan" id="kobo.1563.1"> to check whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.1564.1">result</span></strong><span class="koboSpan" id="kobo.1565.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1566.1">NotFoundResult</span></strong><span class="koboSpan" id="kobo.1567.1">, and convert it into </span><strong class="source-inline"><span class="koboSpan" id="kobo.1568.1">NotFoundResult</span></strong><span class="koboSpan" id="kobo.1569.1"> at the </span><span class="No-Break"><span class="koboSpan" id="kobo.1570.1">same time.</span></span></p>
<p><span class="koboSpan" id="kobo.1571.1">With that, we have learned how to write unit tests for the controller. </span><span class="koboSpan" id="kobo.1571.2">You can check the other tests in the source code and try to add more tests to cover the other scenarios, such as creating invoices, updating invoices, deleting invoices, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1572.1">so on.</span></span></p>
<h1 id="_idParaDest-210"><a id="_idTextAnchor403"/><span class="koboSpan" id="kobo.1573.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1574.1">In this chapter, we explored the fundamentals of unit tests for ASP.NET web API applications. </span><span class="koboSpan" id="kobo.1574.2">We discussed the use of xUnit as the testing framework and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1575.1">Moq</span></strong><span class="koboSpan" id="kobo.1576.1"> as the mocking framework. </span><span class="koboSpan" id="kobo.1576.2">We learned how to configure test fixtures with xUnit, and how to manage the test data with the test fixture. </span><span class="koboSpan" id="kobo.1576.3">We also learned how to write unit tests to test the data access layer and </span><span class="No-Break"><span class="koboSpan" id="kobo.1577.1">the controller.</span></span></p>
<p><span class="koboSpan" id="kobo.1578.1">Unit tests are a great way to ensure that your code unit is working as expected. </span><span class="koboSpan" id="kobo.1578.2">These tests often use mock objects to isolate the code unit from its dependencies, but this cannot guarantee that the code unit works well with its dependencies. </span><span class="koboSpan" id="kobo.1578.3">Therefore, we also need to write integration tests to test if the code units can work together with their dependencies. </span><span class="koboSpan" id="kobo.1578.4">For example, can the controllers handle the </span><span class="No-Break"><span class="koboSpan" id="kobo.1579.1">requests correctly?</span></span></p>
<p><span class="koboSpan" id="kobo.1580.1">In the next chapter, we will learn how to write integration tests for ASP.NET web </span><span class="No-Break"><span class="koboSpan" id="kobo.1581.1">API applications.</span></span></p>
</div>
</body></html>