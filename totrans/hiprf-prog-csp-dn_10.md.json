["```cs\n    HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\\n    FileSystem\n    ```", "```cs\n    using BenchmarkDotNet.Attributes;\n    using BenchmarkDotNet.Order;\n    using System;\n    using System.Collections.Generic;\n    using System.IO;\n    using System.Text;\n    [MemoryDiagnoser]\n    [Orderer(SummaryOrderPolicy.Declared)]\n    [RankColumn]\n    public class MovingFiles { }\n    ```", "```cs\n    private Dictionary<string, FileInfo> _cache;\n    private const string SOURCE_DIRECTORY = \n    @\"C:\\Temp\\Source\\\";\n    private const string DESTINATION_DIRECTORY = \n    @\"C:\\Temp\\Destination\\\";\n    private const string FILENAME = \"Moonshine-3.0.0.exe\";\n    ```", "```cs\n    [GlobalSetup]\n    public void PreloadFilesAndCacheThem()\n    {\n    var files = new DirectoryInfo(SOURCE_DIRECTORY)\n        .GetFileSystemInfos();\n    _cache = new Dictionary<string, FileInfo>();\n    foreach (var f in files)\n    {\n        _cache.Add(f.FullName, f as FileInfo);\n    }\n    }\n    ```", "```cs\n    [GlobalCleanup]\n    public void PreMoveCheck()\n    {\n        if (File.Exists($\"{SOURCE_DIRECTORY}{FILENAME}\"))\n        if (\n            File.Exists(\n                $\"{DESTINATION_DIRECTORY}{FILENAME}\")\n        )\n        {\n            File.Delete(\n                $\"{DESTINATION_DIRECTORY}{FILENAME}\");\n        }\n    if (\n        !File.Exists($\"{SOURCE_DIRECTORY}{FILENAME}\")  \n        && File.Exists(\n            $\"{DESTINATION_DIRECTORY}{ FILENAME}\")\n    )\n    {\n        FileInfo fileinfo = \n            new FileInfo(\n                $\"{DESTINATION_DIRECTORY}{FILENAME}\") \n                  fileinfo.MoveTo(\n                    $\"{SOURCE_DIRECTORY}{FILENAME}\");\n    }\n    }\n    ```", "```cs\n    [Benchmark]\n    public void FileCopy()\n    {\n        PreMoveCheck();\n        File.Copy(\n        $\"{SOURCE_DIRECTORY}{FILENAME}\"\n        , $\"{DESTINATION_DIRECTORY}{FILENAME}\"\n    );\n    }\n    ```", "```cs\n    [Benchmark]\n    public void FileInfoMoveTo()\n    {\n        PreMoveCheck();\n        FileInfo fileinfo = new FileInfo(\n        $\"{SOURCE_DIRECTORY}{FILENAME}\"\n    );\n    fileinfo.MoveTo(\n        $\"{DESTINATION_DIRECTORY}{FILENAME}\"\n    );\n    }\n    ```", "```cs\n    [Benchmark]\n    public void FileInfoReadCacheAndMoveTo()\n    {\n        PreMoveCheck();\n        FileInfo fileInfo = \n        _cache[$\"{SOURCE_DIRECTORY}{FILENAME}\"];\n    if (fileInfo.Exists)\n        fileInfo.MoveTo(\n                 $\"{DESTINATION_DIRECTORY}{FILENAME}\"\n        );\n    }\n    ```", "```cs\n    BenchmarkRunner.Run<MovingFiles>();\n    ```", "```cs\n    public const string DIRECTORY = @\"C:\\Windows\\System32\\\";\n    ```", "```cs\n    [Benchmark]\n    public int GetDirectorySizeUsingGetFileSystemInfos()\n    {\n    DirectoryInfo directoryInfo = \n        new DirectoryInfo(DIRECTORY);\n    FileSystemInfo[] fileSystemInfos = \n        directoryInfo.GetFileSystemInfos();\n    int directorySize = 0;\n    for (int i = 0; i < fileSystemInfos.Length; i++)\n    {\n        FileInfo fileInfo = \n            fileSystemInfos[i] as FileInfo;\n        if (fileInfo != null)\n            directorySize += (int)fileInfo.Length;\n    }\n    return directorySize;\n    }\n    ```", "```cs\n    [Benchmark]\n    public int GetDirectorySizeUsingArrayAndFileInfo()\n    {\n        string[] files = Directory.GetFiles(DIRECTORY);\n        int directorySize = 0;\n    for (int i = 0; i < files.Length; i++)\n    {\n        directorySize += \n            (int)(new FileInfo(files[i]).Length);\n    }\n    return directorySize;\n    }\n    ```", "```cs\n    public async Task WriteTextToFileAsync(\n    string text, string path\n    )\n    {\n        byte[] encodeText = \n          Encoding.Unicode.GetBytes(text);\n        using var fileStream = new FileStream(\n            path, \n        FileMode.Create, \n        FileAccess.Write, \n        FileShare.None, \n        bufferSize: 4096, \n        useAsync: true\n    );\n    await fileStream.WriteAsync(\n        encodeText, 0, encodeText.Length\n    );\n    }\n    ```", "```cs\n    public async Task<string> ReadTextFromFileAsync(string \n        path)\n    {\n    StringBuilder sb = new StringBuilder();\n    byte[] buffer = new byte[0x1000];\n    int numberOfBytesToDecode;\n    using var fileStream = new FileStream(\n            path,\n        FileMode.Open, \n        FileAccess.Read, \n        FileShare.Read,\n        bufferSize: 4096, \n        useAsync: true\n    );\n        while (\n        (numberOfBytesToDecode = await fileStream.\n          ReadAsync(buffer, 0, buffer.Length)) != 0\n    ) \n        {\n            sb.AppendLine(Encoding.Unicode.GetString(\n            buffer, 0, numberOfBytesToDecode\n        ));\n    }\n        return sb.ToString();\n    }\n    ```", "```cs\n    public async Task DemonstrateAsyncFileOps()\n    {\n    await WriteTextToFileAsync(\n             \"Supercalifragilisticexpialidocious\",\n            @\"C:\\Temp\\File\\film.txt\"\n    );\n     string text = await ReadTextFromFileAsync(\n        @\"C:\\Temp\\File\\film.txt\"\n    );\n    Console.WriteLine($\"The Text written was: {text}\");\n    }\n    ```", "```cs\n    static async Task Main(string[] args)\n    {\n        AsyncFileAccess afa = new AsyncFileAccess();\n        await afa.DemonstrateAsyncFileOps();\n    }\n    ```", "```cs\n    The Text written was: Supercalifragilisticexpialidocious\n    ```", "```cs\n    [Benchmark]\n    public string ReturnFormattedString()\n    {\n    return string.Format(\"{0} {1} {2} {3} {4} {5} {6} \n        {7} {8} {9}\", \"The\", \"quick\", \"brown\", \"fox\", \n        \"jumped\", \"over\", \"the\", \"lazy\", \"dog\", \".\"\n    );\n    }\n    ```", "```cs\n    [Benchmark]\n    public string ReturnInterpolatedString()\n    {\n        string thep = \"The\";\n        string quick = \"quick\";\n        string brown = \"brown\";\n        string fox = \"fox\";\n        string jumped = \"jumped\";\n        string over = \"over\";\n        string thel = \"the\";\n        string lazy = \"lazy\";\n        string dog = \"dog\";\n        string period = \".\";\n    return $\"{thep} { quick } { brown } { fox } \n    {jumped} {over} {thel} {lazy} {dog} {period}\";\n    }\n    ```", "```cs\nGCSettings.LargeObjectHeapCompactionMode = \n```", "```cs\nGCLargeObjectHeapCompactionMode.CompactOnce; \n```", "```cs\nGC.Collect();\n```"]