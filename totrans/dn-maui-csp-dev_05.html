<html><head></head><body>
		<div><h1 id="_idParaDest-88" class="chapter-number"><a id="_idTextAnchor092"/>5</h1>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor093"/>Advanced Controls</h1>
			<p>In the previous chapter, we looked at a number of controls and how to handle their events and commands. In this chapter, we’ll look at moving the logic into <code>ViewModel</code> using commands and messaging. We’ll then go on to cover Styles, which let you provide a uniform appearance to your controls with little effort.</p>
			<p>One key feature of a well-designed user experience is that when something is going to take more than a second or so, you let the user know that the app is working on it so that it doesn’t look like your app froze.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Keeping the user informed of activity</li>
				<li>Moving event handling to <code>ViewModel</code></li>
				<li>Sending and receiving messages</li>
				<li>Displaying collections</li>
				<li>Styles</li>
			</ul>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor094"/>Technical requirements</h1>
			<p>For this chapter, you will need Visual Studio. You can find the source code for this chapter here: <a href="https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/MVVMAndControls">https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/MVVMAndControls</a>. If you want to follow along, continue with the project you were working on in <a href="B19723_04.xhtml#_idTextAnchor054"><em class="italic">Chapter 4</em></a>.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor095"/>Keeping the user informed of activity</h1>
			<p>There are two ways to let the user know<a id="_idIndexMarker200"/> that your application is working on something time-consuming:</p>
			<ul>
				<li><code>ActivityIndicator</code></li>
				<li><code>ProgressBar</code></li>
			</ul>
			<p><code>ActivityIndicator</code> essentially says, “I’m working on it, but I don’t know how long it will take,” whereas <code>ProgressBar</code> says, “I’m working on it, and I’m about halfway done.” Let’s explore each of these in a bit more detail.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor096"/>ActivityIndicator</h2>
			<p>We’ll start<a id="_idIndexMarker201"/> by adding <code>ActivityIndicator</code> to the login page below the Buttons:</p>
			<pre class="source-code">
&lt;ActivityIndicator
    Color="Blue"
    IsRunning="{Binding ActivityIndicatorIsRunning}" /&gt;</pre>
			<p>Notice that the <code>IsRunning</code> property is bound to the <code>ActivityIndicatorIsRunning</code> property. That property is in <code>LoginViewModel</code> (you’ll remember that we set that file as the binding context):</p>
			<pre class="source-code">
[ObservableProperty] private bool activityIndicatorIsRunning   = true;</pre>
			<p>I’ve set its default value to <code>true</code>, so the activity indicator will be running when the page comes up. Let’s shut it off after creating the account:</p>
			<pre class="source-code">
private async void OnCreate(object sender, EventArgs e)
{
  CancellationTokenSource =
    new CancellationTokenSource();
  var message = "Your account was created";
  var dismissalText = "Click Here to Close the SnackBar";
  TimeSpan duration = TimeSpan.FromSeconds(10);
  Action  = async () =&gt;
    await DisplayAlert(
      "Snackbar Dismissed!",
      "The user has dismissed the snackbar",
      "OK");
  var snackbarOptions = new SnackbarOptions
  {
    BackgroundColor = Colors.Red,
    TextColor = Colors.Yellow,
    ActionButtonTextColor = Colors.Black,
    CornerRadius = new CornerRadius(20),
    Font = Microsoft.Maui.Font.SystemFontOfSize(14),
    ActionButtonFont = Microsoft.Maui.Font
      .SystemFontOfSize(14)
  };
  var snackbar = Snackbar.Make(
    message,
    action,
    dismissalText,
    duration,
    snackbarOptions);
  await snackbar.Show(cancellationTokenSource.Token);
  vm.ActivityIndicatorIsRunning = false;
}</pre>
			<p>Nothing has changed in the create<a id="_idIndexMarker202"/> page code except the addition of the final line. Here we reach into <code>ViewModel</code> and set the <code>ActivityIndicatorIsRunning</code> property to <code>false</code>. That should stop <code>ActivityIndicator</code> whose <code>IsRunning</code> property is bound to <code>showActivityIndicator</code>.</p>
			<p>The result looks like <em class="italic">Figure 5</em><em class="italic">.1</em>:</p>
			<div><div><img src="img/Figure_5.1_B19723.jpg" alt="Figure 5.1 – ActivityIndicator&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – ActivityIndicator</p>
			<p class="callout-heading">Working or hung?</p>
			<p class="callout">Note that under some circumstances, your program<a id="_idIndexMarker203"/> might hang, yet the activity indicator will continue spinning. This can cause enormous confusion and frustration for your user. One way to escape that problem is to set a timer, and if the task doesn’t complete in <em class="italic">n</em> seconds, you stop the indicator and, for example, display an error dialog. Of course, if everything is hung, you won’t be able to do that, but typically, the indicator will have frozen as well.</p>
			<p><code>ActivityIndicator</code> is great, but it only<a id="_idIndexMarker204"/> tells the user that something is happening, not how far it has progressed in its task. That is what <code>ProgressBar</code> is for.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor097"/>ProgressBar</h2>
			<p><code>ProgressBar</code> divides a task into fractional<a id="_idIndexMarker205"/> parts (for example, percentages) and displays what part (fraction, percentage, and so on) has been completed. We’ve all seen progress bars: ideally, they move smoothly across the screen; in fact, they often move in fits and starts as the task they are tracking completes.</p>
			<p>We’re going to create a progress bar, but we are going to fake an action. That is, we’ll progress the bar based on time rather than actual progress in a task. Nonetheless, the workings of <code>ProgressBar</code> will become evident.</p>
			<p>To get started, let’s comment out <code>ActivityIndicator</code> in <code>LoginPage.xaml</code>, and replace it with <code>ProgressBar</code>:</p>
			<pre class="source-code">
&lt;!--&lt;ActivityIndicator
    Color="Blue"
    IsRunning="{Binding ActivityIndicatorIsRunning}" /&gt;--&gt;
&lt;ProgressBar
    ProgressColor="Blue"
    x:Name="LoginProgressBar" /&gt;</pre>
			<p>Here we have declared <code>ProgressBar</code> with only two properties: its color and its name. The name allows us to refer to the bar in the code-behind. We would, of course, normally update <code>ProgressBar</code> based on data in the <code>ViewModel</code>, but for now, as we have done before, we’ll do that work in the code-behind (<code>LoginPage.xaml.cs</code>).</p>
			<p>Here is the code that will start and advance the progress bar based on the user clicking the <strong class="bold">Submit</strong> button:</p>
			<pre class="source-code">
private async void OnSubmit(object sender, EventArgs e)
{
  for (double i = 0.0; i &lt; 1.0; i += 0.1)  [1]
  {
    await LoginProgressBar.ProgressTo(i, 500,
      Easing.Linear); [2]
  }
  await DisplayAlert(  [3]
    "Submit",
    $"You entered {vm.Name} and {vm.Password}",
    "OK");
}</pre>
			<p>[1] We will set the value of <code>ProgressBar</code> based on the value of the counter variable (<code>i</code>) in the <code>for</code> loop. The <code>ProgressBar</code> values range from <code>0</code> to <code>1</code>, with the percentage or fraction of progress measured as values between those two numbers. Here, we initialize the counter variable to <code>0.0</code>, and until it reaches the <code>1.0</code> value, we increment by one-tenth.</p>
			<p>[2] Within the <code>for</code> loop, we call <code>ProgressTo</code> on <code>ProgressBar</code>. That method takes three values:</p>
			<ol>
				<li>The value we want to progress to</li>
				<li>The amount of time to get there, in milliseconds</li>
				<li>The easing (see the following section)</li>
			</ol>
			<p>[3] The action we’ll take when the progress bar completes.</p>
			<p>Another related<a id="_idIndexMarker206"/> feature is <em class="italic">Easing</em>, which refers to how quickly an action goes from start to full speed. Let’s take a look at that in a bit more depth.</p>
			<h3>Easing</h3>
			<p><em class="italic">Easing</em> refers to the pattern<a id="_idIndexMarker207"/> of how an item<a id="_idIndexMarker208"/> moves. For example, a train does not go from standing still in the station to racing along at 75 miles per hour all at once; it <em class="italic">eases</em> into the final speed. If you drew a graph of the acceleration, it would look like a sine wave, and two of the enumerated values of easing are, in fact, <code>SineIn</code> (for the pattern of starting up) and <code>SineOut</code> (for the pattern of coming back into the station).</p>
			<p>In our case, however, we want the progress bar to move smoothly and at a constant speed, which is what <code>easing.Linear</code> does.</p>
			<p>The net effect is that the progress bar will be animated across its entire course. We know that we are moving from <code>0</code> to <code>1</code> in tenths, and we know that we are taking half a second (500 milliseconds) to go each one-tenth of the way; thus, we know that the entire trip from <code>0.0</code> (nothing showing on the bar) to <code>1.0</code> (the bar fully filled with color) will take five seconds.</p>
			<p>At the conclusion of our <code>for</code> loop, the dialog will pop up, giving a nice simulation of the completion of the task that the progress bar was tracking. A snapshot of that progress is shown in <em class="italic">Figure 5</em><em class="italic">.2</em>:</p>
			<div><div><img src="img/Figure_5.2_B19723.jpg" alt="Figure 5.2 – The progress bar is about 75% of the way toward completion&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – The progress bar is about 75% of the way toward completion</p>
			<p>For convenience<a id="_idIndexMarker209"/> and to keep things<a id="_idIndexMarker210"/> simple, we’ve been using the code-behind for event handling. Of course, as noted in <a href="B19723_03.xhtml#_idTextAnchor036"><em class="italic">Chapter 3</em></a>, there are good reasons to use<a id="_idIndexMarker211"/> commands rather than events and to handle<a id="_idIndexMarker212"/> them in <code>ViewModel</code>. Let’s look at that next.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor098"/>Moving event handling to ViewModel</h1>
			<p>Suppose that when<a id="_idIndexMarker213"/> a Button<a id="_idIndexMarker214"/> is pressed, we want<a id="_idIndexMarker215"/> to handle that fact in the <code>ViewModel</code>, as is preferred by the <code>ProgressBar</code>.</p>
			<p>Handling<a id="_idIndexMarker216"/> things in <code>ViewModel</code> gets tricky when we want to interact with the <code>Clicked</code> event and add a command:</p>
			<pre class="source-code">
&lt;Button
    BackgroundColor="Gray"
    Command="{Binding SubmitCommand}"
    Margin="5"
    Text="Submit" /&gt;</pre>
			<p>We’ll create <code>RelayCommand</code> in <code>ViewModel</code> to handle the <code>Submit</code> Command:</p>
			<pre class="source-code">
[RelayCommand]
private async void Submit()
{
  for (var i = 0.0; i &lt; 1.0; i += 0.1)
  {
    await LoginPage.LoginProgressBar.ProgressTo(i, 500,
      Easing.Linear); [1]
  }
  await Application.Current.MainPage.DisplayAlert(
     [2]
    "Submit",
    $"You entered {Name} and {Password}",
    "OK");
}</pre>
			<p>[1] Access <code>LoginProgressBar</code> on <code>LoginPage</code> (more later on how to do that) and call <code>ProgressTo</code> as we saw earlier.</p>
			<p>[2] Access <code>MainPage</code> through<a id="_idIndexMarker217"/> the <code>Application</code> object<a id="_idIndexMarker218"/> and call <code>DisplayAlert</code>.</p>
			<p>So, how are we going to access the <code>LoginProgressBar</code> in the UI? We need a static member of <code>LoginPage</code> to accomplish<a id="_idIndexMarker219"/> this. We’ll pull the declaration of <code>LoginProgressBar</code> out of the <strong class="bold">Extensible Application Markup Language</strong> (<strong class="bold">XAML</strong>) and move it into the code-behind:</p>
			<pre class="source-code">
public static ProgressBar LoginProgressBar;</pre>
			<p>We need to be sure to initialize this in the constructor of <code>LoginPage</code>:</p>
			<pre class="source-code">
public LoginPage()
{
  LoginProgressBar = new ProgressBar();</pre>
			<p>We’re going to need to refer to <code>StackLayout</code> if we want to add that to <code>ProgressBar</code>, so let’s name it as follows:</p>
			<pre class="source-code">
&lt;VerticalStackLayout x:Name="LoginStackLayout"&gt;</pre>
			<p>Now we’re ready to add <code>ProgressBar</code> to the children of <code>StackLayout</code>. Here’s the complete constructor:</p>
			<pre class="source-code">
public LoginPage()
{
  LoginProgressBar = new ProgressBar();
  InitializeComponent();  [1]
  LoginStackLayout.Children.Add(LoginProgressBar); [2]
  BindingContext = vm;
}</pre>
			<p>[1] Notice that <code>InitializeComponent</code> comes before adding <code>ProgressBar</code> to the children of <code>StackLayout</code>. Until this is called, <code>LoginStackLayout</code> will be null.</p>
			<p>[2] By calling <code>Add</code> here, <code>LoginProgressBar</code> is added to <code>LoginStackLayout</code> below<a id="_idIndexMarker220"/> the controls<a id="_idIndexMarker221"/> created in the XAML.</p>
			<p>Huh? Let’s take it step by step.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor099"/>Breaking it down</h2>
			<p>Here is the order of what happens when you run this, enter your username and password, and click <strong class="bold">Submit</strong>:</p>
			<ol>
				<li><code>ProgressBar</code> is added to the page in the page constructor.</li>
				<li>When you click on <code>SubmitCommand</code> is sent to <code>ViewModel</code>.</li>
				<li><code>ViewModel</code> handles that in <code>Submit</code>, <code>RelayCommand</code>.</li>
				<li>In <code>RelayCommand</code>, it updates the (static) <code>LoginProgressBar</code>.</li>
				<li>It then calls <code>DialogBox</code> through <code>MainPage</code>, which it has access to through the <code>Application</code> object.</li>
			</ol>
			<p>This works beautifully but is a bit labored. The use of <code>Application.Current.MainPage</code> is not unusual, but<a id="_idIndexMarker222"/> the hoops we jumped<a id="_idIndexMarker223"/> through to access <code>ProgressBar</code> are. The solution to that is to use <code>Messaging</code>, which is covered next.</p>
			<p class="callout-heading">Visibility</p>
			<p class="callout">It is generally considered best practice for <code>ViewModel</code> not to see aspects of the view (as it does here). In the next example, we will isolate the VM from the view.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor100"/>Sending and receiving messages</h1>
			<p>Rather than reaching<a id="_idIndexMarker224"/> into <code>View</code>, we can have <code>ViewModel</code> signal <code>View</code> when it is time<a id="_idIndexMarker225"/> to display the dialog or other <code>View</code>-dependent element.</p>
			<p>For example, suppose we want to show <code>Snackbar</code> when the user clicks on the <code>Command</code> (which is preferred because it puts the logic into <code>ViewModel</code>). <code>ViewModel</code> might then massage data or otherwise do whatever it needs to do, and then signal <code>View</code> to display <code>Snackbar</code> by sending out a message to that effect.</p>
			<p>The idea is that <code>ViewModel</code> publishes a message such as “anyone who has subscribed to this message, show a <code>Snackbar</code>” and the page subscribes to that message and so shows <code>Snackbar</code> when the message is received.</p>
			<p>In some circumstances, there may be more than one <strong class="bold">Subscriber</strong>. For that matter, in some circumstances, more than one <strong class="bold">Publisher</strong> can send the same message, as shown in <em class="italic">Figure 5</em><em class="italic">.3</em>:</p>
			<div><div><img src="img/Figure_5.3_B19723.jpg" alt="Figure 5.3 – Publish and Subscribe&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Publish and Subscribe</p>
			<p class="callout-heading">Messaging center</p>
			<p class="callout">.NET MAUI has a built-in messaging system, but it has been deprecated in favor of <code>WeakReferenceMessenger</code> provided in the .NET Community Toolkit MVVM, which we will cover next.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor101"/>Getting started with WeakReferenceMessenger</h2>
			<p>To set this up, first create<a id="_idIndexMarker226"/> a class that will serve as the message. You can create this class anywhere that both <code>View</code> and <code>ViewModel</code> can see it. For convenience, I’ll put it above the <code>LoginPage</code> class:</p>
			<pre class="source-code">
public partial class ConstructMessage {}</pre>
			<p>Next, in the <code>LoginPage</code> constructor, we need to register to receive such a message. Once you receive the message you might call a method, or alternatively, you’ll use a Lambda expression to do the work.</p>
			<p>To register to receive the message, use the <code>WeakReferenceMessenger's Register</code> method. Here is the code to do so:</p>
			<pre class="source-code">
    WeakReferenceMessenger.Default.Register
      &lt;ConstructMessage&gt; (this, async ( m,e) =&gt;
    {
             // …
     });</pre>
			<p>What goes between the opening and closing braces is whatever you want to do when you receive that message. I’ve moved the code we were using in the event handler to here:</p>
			<pre class="source-code">
    WeakReferenceMessenger.Default.Register
      &lt;ConstructMessage&gt; (this, async ( m,e) =&gt;
    {
      CancellationTokenSource =
        new CancellationTokenSource();
      var message = "Your account was created";
      var dismissalText = "Click Here to Close the
        SnackBar";
      TimeSpan duration = TimeSpan.FromSeconds(10);
      Action = async () =&gt;
        await DisplayAlert(
          "Snackbar Dismissed!",
          message,
          "OK");
      var snackbarOptions = new SnackbarOptions
      {
        BackgroundColor = Colors.Red,
        TextColor = Colors.Yellow,
        ActionButtonTextColor = Colors.Black,
        CornerRadius = new CornerRadius(20),
        Font = Microsoft.Maui.Font.SystemFontOfSize(14),
        ActionButtonFont = Microsoft.Maui.Font
          .SystemFontOfSize(14)
      };
      var snackbar = Snackbar.Make(
        message,
        action,
        dismissalText,
        duration,
        snackbarOptions);
      await snackbar.Show(cancellationTokenSource.Token);
      vm.ActivityIndicatorIsRunning = false;
    });</pre>
			<p>Now, all we need<a id="_idIndexMarker227"/> to do is revise <code>LoginPage.xaml</code> so that the <code>ViewModel</code>, rather than an event handler in the code-behind:</p>
			<pre class="source-code">
&lt;Button
    BackgroundColor="Gray"
    Command="{Binding CreateCommand}"
    Margin="5"
    Text="Create Account" /&gt;</pre>
			<p>This will invoke the Create relay method in the <strong class="bold">ViewModel</strong></p>
			<pre class="source-code">
[RelayCommand]
private void Create()
{
  WeakReferenceMessenger.Default.Send(new CreateMessage());
}</pre>
			<p><code>ViewModel</code> calls the <code>Send</code> method, sending in an instance of <code>ConstructMessage</code> as a signal to any registered listeners to take some action. The <code>Create</code> method might, before sending that message, do other work that is best done in <code>ViewModel</code> rather than code-behind.</p>
			<p>This is a much cleaner way of <em class="italic">decoupling</em> <code>ViewModel</code> and <code>View</code> when we need to have logic in <code>ViewModel</code> take an action that can only be taken by <code>View</code>.</p>
			<p><code>WeakReferenceMessenger</code> can also be used to communicate from one <code>ViewModel</code> to another.</p>
			<p>Finally, it is called <code>WeakReferenceMessenger</code> in distinction from stet <code>StrongReferenceMessenger</code>. The advantage of <code>WeakReferenceMessenger</code>, and the reason it is generally what is chosen, is that it manages<a id="_idIndexMarker228"/> its own memory and cleanup, so you don’t have to.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor102"/>Creating the page in C#</h1>
			<p>Before moving on, and to reinforce<a id="_idIndexMarker229"/> the fact that <a id="_idIndexMarker230"/>anything you can do in XAML you can do in C#, here is the version of <code>LoginPage</code> that we will be using in Forget Me Not (ForgetMeNotDemo) written in C# (in the repo, this page is called <code>LoginCS</code>):</p>
			<pre class="source-code">
using CommunityToolkit.Maui.Markup;
using static CommunityToolkit.Maui.Markup.GridRowsColumns;
namespace ForgetMeNot.View
{
    class LoginCS : ContentPage
    {
        public LoginCS(LoginViewModel viewModel)  [1]
        {
            BindingContext = viewModel;
            var activity = new ActivityIndicator() [2]
            {
                HeightRequest = 50,
                Color = Color.FromRgb(0, 0, 0xF),
            };
            activity.IsEnabled = viewModel
              .ShowActivityIndicator; [3]
            Content = new VerticalStackLayout()
            {
                Children = [4]
                {
                    activity,
                    new Grid()  [5]
                    {
                        RowDefinitions = GridRowsColumns
                          .Rows.Define(
                            (Row.Username,Auto),
                            (Row.Password,Auto),
                            (Row.Buttons, Auto)
                            ),
                        ColumnDefinitions = GridRowsColumns
                          .Columns.Define(
                            (Column.Submit,Star),
                            (Column.Create, Star),
                            (Column.Forgot, Star)
                            ),
                        Children =
                        {
                            new Label()
                                .Text("User name")
                                .Row(Row.Username)
                                   .Column(0), [6]
                            new Entry()
                                .Placeholder("User name")
                                .Bind(Entry.TextProperty,
                                   nameof(LoginViewModel
                                     .LoginName))
                                .Row(Row.Username)
                                  .Column(1)
                                .ColumnSpan(2),
                            new Label()
                                .Text("Password")
                                .Row(Row.Password)
                                  .Column(0),
                            new Entry {IsPassword = true}
                                .Placeholder("Password")
                                .Bind(Entry.TextProperty,
                                 nameof(LoginViewModel
                                 .Password))
                                .Row(Row.Password)
                                  .Column(1)
                                .ColumnSpan(2),
                            new Button()
                                .Text("Submit")
                                .Row(Row.Buttons)
                                  .Column(Column.Submit)
                                .BindCommand(nameof
                                  (LoginViewModel
                                    .DoLoginCommand)),
                            new Button()
                                .Text("Create Account")
                                .Row(Row.Buttons)
                                  .Column(Column.Create)
                                .BindCommand(nameof
                                  (LoginViewModel
                                 .DoCreateAccountCommand)),
                            new Button()
                                .Text("Forgot Password")
                                .Row(Row.Buttons)
                                   .Column(Column.Forgot)
                                .BindCommand(nameof
                                (LoginViewModel
                                .ForgotPasswordCommand))
                        }
                    }
                }
            };
        }
    }
    enum Row
    {
        Username,
        Password,
        Buttons
    }
    enum Column
    {
        Submit,
        Create,
        Forgot
    }
}</pre>
			<p>[1] We start by declaring the class and giving it <code>LoginViewModel</code>. This is done by <em class="italic">dependency injection</em>, a topic covered in detail in <a href="B19723_09.xhtml#_idTextAnchor160"><em class="italic">Chapter 9</em></a>.</p>
			<p>[2] <code>ActivityIndicator</code> is instantiated; it will be added to the page later.</p>
			<p>[3] The <code>IsEnabled</code> property of <code>ActivityIndicator</code> is bound to a property in <code>ViewModel</code>.</p>
			<p>[4] We add to <code>StackLayout</code> by adding to its <code>Children</code> collection.</p>
			<p>[5] We haven’t covered <code>Grid</code> yet, but you can see that it is a layout that has rows and columns. We’ll look at it in greater depth in the next chapter.</p>
			<p>[6] In <code>Grid</code>, each individual row and column can be given a name from <code>enumeration</code> or can<a id="_idIndexMarker231"/> be referred to by its zero-based index.</p>
			<p>The key takeaway <a id="_idIndexMarker232"/>from this section is that you can certainly create all the controls<a id="_idIndexMarker233"/> and their commands and properties in C# as well as in XAML. I will continue to dip into C#, but I’m afraid it will drive you crazy to show each type in both, so again, for layout and controls, we’ll focus predominantly on XAML – the standard approach for .NET MAUI.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor103"/>Displaying collections</h1>
			<p>It is common to have a collection<a id="_idIndexMarker234"/> of data and to want to display it in a list, allowing the user to select one or more items and then do some work with those items. There are a couple of ways to do this in .NET MAUI, but the most common (and best) is to use <code>CollectionView</code>.</p>
			<p>To see this at work, examine <code>Preferences.xaml</code> along with its code-behind <code>Preferences.xaml.cs</code> and <code>ViewModel</code>, <code>PreferencesViewModel.cs</code>. We will use this page extensively as we build Forget Me Not, but let’s start slowly.</p>
			<p>Our goal is to create<a id="_idIndexMarker235"/> a list of the user’s preferences (shirt size, music genre, and so on). For that, we’ll use <code>CollectionView</code>, and we’ll, of course, need a collection to view. The page, when completed, will look much like this:</p>
			<div><div><img src="img/Figure_5.4_B19723.jpg" alt="Figure 5.4 – The Preferences page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – The Preferences page</p>
			<p>Rather than each line being a unique<a id="_idIndexMarker236"/> object, we’ll create one type that we can show repeatedly. In the <code>Model</code> folder, create a <code>Preference</code> class:</p>
			<pre class="source-code">
namespace ForgetMeNotDemo.Model;
[ObservableObject]
public partial class Preference
{
    [ObservableProperty] private string preferencePrompt;
    [ObservableProperty] private string preferenceValue;
}</pre>
			<p class="callout-heading">Partial classes</p>
			<p class="callout">In .NET MAUI virtually all classes are <em class="italic">partial</em> to support the Community Toolkit code.</p>
			<p><code>Preference</code> has only two properties, both strings. The <code>PreferencePrompt</code> string will hold the text on the left of the page, and the <code>PreferenceValue</code> string will hold the user’s preference on the right side.</p>
			<p>The first thing we need is a collection of these <code>Preference</code> objects. To get that, we’re going to build a <code>Service</code>, whose job, eventually, will be to interact with the API and get us our list of <code>Preference</code> objects. Perform the following steps:</p>
			<ol>
				<li>Create a new folder named <code>Services</code>.</li>
				<li>In <code>Services</code>, create a <code>PreferenceService</code> class.</li>
				<li>Inside that file add a <code>GetPreferences</code> method.</li>
			</ol>
			<p>Here’s the code:</p>
			<pre class="source-code">
public class PreferenceService
{
  public async Task&lt;List&lt;Preference&gt;&gt; GetPreferences()
  {
    return await GetPreferencesMock();
  }
  private async Task&lt;List&lt;Preference&gt;&gt; GetPreferencesMock(
  {
    return null;
  }
}</pre>
			<p><code>ViewModel</code> will call <code>GetPreferences</code> on the service and get back<a id="_idIndexMarker237"/> a list of the <code>Preference</code> objects. We’ll turn to how <code>PreferenceService</code> gets those objects in just a bit.</p>
			<p>Back in <code>PreferencesViewModel</code>, do the following:</p>
			<pre class="source-code">
[ObservableObject]
public partial class PreferencesViewModel
{
  [ObservableProperty] private List&lt;Preference&gt;
    preferences;
  private readonly PreferenceService service; [1]
  public PreferencesViewModel()
  {
    service = new(); [2]
  }
  public async Task Init()
  {
    Preferences = await service.GetPreferences(); [3]
  }
}</pre>
			<p>[1] Declare an instance of <code>PreferenceService</code></p>
			<p>[2] Initialize it in the constructor</p>
			<p>[3] In the <code>Init</code> method, fill the <code>Preferences</code> collection<a id="_idIndexMarker238"/> with what you get back from the service</p>
			<p class="callout-heading">Dependency injection</p>
			<p class="callout">In <a href="B19723_09.xhtml#_idTextAnchor160"><em class="italic">Chapter 9</em></a>, we will review dependency injection. At that point, we’ll pass<a id="_idIndexMarker239"/> in a <code>PreferenceService</code> interface and let the <code>InversionOfControl</code> container supply the service for us. If that didn’t make sense to you, no problem; it will all become clear in <a href="B19723_09.xhtml#_idTextAnchor160"><em class="italic">Chapter 9</em></a>.</p>
			<p>So, who instantiates <code>ViewModel</code> and calls <code>Init</code>? For that, we turn to the code-behind of the <code>PreferencesPage</code> class:</p>
			<pre class="source-code">
public partial class PreferencesPage : ContentPage
{
  private PreferencesViewModel vm;
  public Preferences()
  {
    vm = new PreferencesViewModel();
    BindingContext = vm;
    InitializeComponent();
 }
  protected override async void OnAppearing()
  {
    base.OnAppearing();
    await vm.Init();
  }</pre>
			<p class="callout-heading">Naming the ViewModel vm</p>
			<p class="callout">I’m not big on using acronyms<a id="_idIndexMarker240"/> in code, and would normally have named the local instance of <code>ViewModel</code>. But using <em class="italic">vm</em> is such a convention in .NET MAUI (going back to <code>Xamarin.Forms</code>) that I indulge myself.</p>
			<p>In .NET MAUI, the two life cycle events<a id="_idIndexMarker241"/> you will often want control over are when the page is first being shown (<code>OnAppearing</code>) and when it is being shut down (<code>OnDisappearing</code>). Let’s explore this next.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor104"/>Overriding OnAppearing</h2>
			<p>Every time a page<a id="_idIndexMarker242"/> appears, its <code>OnAppearing</code> method is called. We override<a id="_idIndexMarker243"/> that method so that we can call <code>vm.Init()</code>. We do this because <code>Init</code> is asynchronous, and while we can make <code>OnAppearing</code> asynchronous using the <code>async</code> keyword, we can’t do that with the constructor.</p>
			<p><code>OnInit()</code>, in turn, calls <code>GetPreferences</code> on the service and gets back a collection of the <code>Preference</code> objects.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor105"/>Understanding how the service works</h2>
			<p>In time, our <code>PreferenceService's</code> <code>GetPreferences</code> method will call into our API to get the list<a id="_idIndexMarker244"/> of preferences from our database, which will be stored in the cloud. For now, it will call <code>GetPreferencesMock</code>, which will handcraft the list and return it to us.</p>
			<p>Here’s an excerpt from the file:</p>
			<pre class="source-code">
public class PreferenceService
{
  public async Task&lt;List&lt;Preference&gt;&gt; GetPreferences()
  {
    return await GetPreferencesMock();
  }
  private async Task&lt;List&lt;Preference&gt;&gt; GetPreferencesMock()
  {
    List&lt;Preference&gt; preferences = new()
    {
      new Preference()
      {
        PreferencePrompt = "Shirt Size",
        PreferenceValue = ""
      },
      new Preference()
      {
        PreferencePrompt = "Favorite Music Genre",
        PreferenceValue = ""
      },
      new Preference()
      {
        PreferencePrompt = "Favorite Color",
        PreferenceValue = ""
      },
      new Preference()
      {
        PreferencePrompt = "Favorite Food",
        PreferenceValue = ""
      },
      new Preference()
      {
        PreferencePrompt = "Favorite Movie",
        PreferenceValue = ""
      },
//…
    };
    return preferences;
  }
}</pre>
			<p>The result is a collection<a id="_idIndexMarker245"/> of <code>Preference</code> objects. Let’s look at how to display that collection.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor106"/>Displaying the collection of Preference objects</h2>
			<p>Now that we have<a id="_idIndexMarker246"/> a collection<a id="_idIndexMarker247"/> of <code>Preference</code> objects in <code>ViewModel</code>, we can create our page:</p>
			<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage xmlns="http://schemas.microsoft.com/
  dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/
                winfx/2009/xaml"
             x:Class="ForgetMeNotDemo.View.PreferencesPage"
             Title="Preferences"&gt;
    &lt;ScrollView&gt;
        &lt;VerticalStackLayout&gt;
            &lt;Label
                Margin="5"
                Padding="5"
                HorizontalOptions="Center"
                LineBreakMode="WordWrap"  [1]
                Text="Please fill in as many p<a id="_idTextAnchor107"/>references as
                you care to. &amp;#10; &amp;#10;The fields are
                'free form,' fill in anything you like.
                Remember, the more information you provide
                to your buddies the better they will be
                able to match to what you like. Each of the
                categories can be edited for your
                needs.&amp;#10; &amp;#10; Save as frequently as you
                like, and to edit, just change the value
                you entered and press save." /&gt;
            &lt;Button
                Margin="30,20,0,0"
                Clicked="SavePreferences"   [2]
                Command="{Binding SavePreferencesCommand}"
                 [3]
                Text="Save" /&gt;
            &lt;CollectionView
                Margin="20,20,10,10"
                ItemsSource="{Binding Preferences}" [4]
                SelectionMode="None"&gt;       [5]
                &lt;CollectionView.ItemTemplate&gt;  [6]
                    &lt;DataTemplate&gt;
                        &lt;Grid ColumnDefinitions="*,2*"&gt;
                            &lt;Entry  [7]
                                Grid.Column="0"
                                FontSize="10"
                                HorizontalOptions="Start"
                                HorizontalTextAlignment=
                                  "Start"
                                Text="{Binding
                                PreferencePrompt,
                                   Mode=TwoWay}" [8]
                                TextColor="{OnPlatform
                                  Black,  [9]
                                  iOS=White}" /&gt;
                            &lt;Entry
                                Grid.Column="1"
                                FontSize="10"
                                HeightRequest="32"
                                HorizontalOptions="Start"
                                HorizontalTextAlignment=
                                  "Start"
                                Text="{Binding
                                 PreferenceValue,
                                   Mode=TwoWay}"
                                TextColor="{OnPlatform
                                   Black,
                                     iOS=White}"
                                WidthRequest="350" /&gt;
                        &lt;/Grid&gt;
                    &lt;/DataTemplate&gt;
                &lt;/CollectionView.ItemTemplate&gt;
            &lt;/CollectionView&gt;
            &lt;Button
                Margin="30,20,0,0"
                Clicked="SavePreferences"
                Command="{Binding SavePreferencesCommand}"
                Text="Save" /&gt;
        &lt;/VerticalStackLayout&gt;
    &lt;/ScrollView&gt;
&lt;/ContentPage&gt;</pre>
			<p>There is much to see in this listing. Let’s take things one by one:</p>
			<p>[1] <code>Label</code> has multiple lines; we’ve seen this before. We set <code>LineBreakMode</code> to <code>WordWrap</code> so that we break the lines between words. Notice the use of <code>&amp;#10;</code>, which forces a line break.</p>
			<p>[2] The <strong class="bold">Save</strong> button is very unusual as it has a click event handler as well as a command! The click event handler will handle showing the toast.</p>
			<p>[3] The command will be handled in <code>ViewModel</code> and will call the <code>Save</code> method in the service (which we will not implement just yet).</p>
			<p>[4] The <code>ItemsSource</code> property points to the collection that <code>CollectionView</code> will display. In our case, that is the <code>Preferences</code> collection in <code>ViewModel</code>.</p>
			<p>[5] <code>SelectionMode</code> is set to <code>None</code>, as we won’t be selecting items in this display. We will be editing items and then pressing <strong class="bold">Save</strong> to save the changes.</p>
			<p>[6] An item template says, “here is how I want you to display each item in the collection, one by one.”</p>
			<p>[7] Interestingly, we are using <code>Entry</code> for the prompt. This allows the user to change the prompt, which is what we want. We can’t anticipate every category, so we create a number of them, but we let the user tweak the list as needed.</p>
			<p>[8] Not only will we be displaying<a id="_idIndexMarker248"/> the value of the prompt<a id="_idIndexMarker249"/> from the database, but we’ll want to write back whatever the user enters as well. Thus, we mark the text as two-way (that is, data &gt; View and View &gt; data)</p>
			<p>[9] We’ve not seen <code>onPlatform</code> before. This says, “always use this value except, on this platform, use this other value.” Here we are saying that the text<a id="_idIndexMarker250"/> color is <code>Black</code>, except<a id="_idIndexMarker251"/> on <code>Ios</code>, where it is <code>White</code>.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor108"/>The code-behind</h2>
			<p>You’ll remember<a id="_idIndexMarker252"/> that we are not only handling the command in <code>ViewModel</code> but we’re also handling the <code>Clicked</code> event in the code-behind. Here is the rest of <code>PreferencesPage.xaml.cs</code>:</p>
			<pre class="source-code">
    public void SavePreferences(object sender, EventArgs e)
    {
        ShowToast();
    }
    private async Task ShowToast()
    {
        var cancellationTokenSource = new
           CancellationTokenSource();
        var message = "Your preferences were saved";
        ToastDuration duration = ToastDuration.Short;
        var fontSize = 14;
        var toast = Toast.Make(message, duration,
          fontSize);
        await toast.Show(cancellationTokenSource.Token);
    }</pre>
			<p>The event handler just calls the <code>ShowToast</code> method, which then does its thing, as described earlier.</p>
			<p>This way, when the list of preferences is saved, the toast notifies the user that all went well.</p>
			<p class="callout-heading">Did it all go well?</p>
			<p class="callout">In the code shown, we just assume that it all went well. To do this properly, we’d want <code>ViewModel</code> to wait for confirmation from the API that the operation was completed successfully, and then it would send a message to the code-behind, which would then, and only then, display the toast.</p>
			<p>Before we go any<a id="_idIndexMarker253"/> further, open <code>AppShell.xaml</code> and change the startup as follows:</p>
			<pre class="source-code">
    &lt;ShellContent
        Title="Home"
        ContentTemplate="{DataTemplate
          view1:PreferencesPage}"
        Route="PreferencesPage" /&gt;</pre>
			<p>Once we get to <a href="B19723_07.xhtml#_idTextAnchor129"><em class="italic">Chapter 7</em></a>, we can stop this silliness and just navigate to the page we want.</p>
			<p>The effect of all of this is shown in <em class="italic">Figure 5</em><em class="italic">.5</em>:</p>
			<div><div><img src="img/Figure_5.5_B19723.jpg" alt="Figure 5.5 – The Preferences page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – The Preferences page</p>
			<p>A few quick things to note in <em class="italic">Figure 5</em><em class="italic">.5</em>. The fields on the left have been underlined, indicating that they are entry objects, not labels, and thus can be modified. The top arrow points to the fact that the fields are free-form, and the user can enter whatever they want, and the lower arrow points to the toast.</p>
			<p>So far, we’ve been setting<a id="_idIndexMarker254"/> numerous properties on our UI controls. Often, we’ve had to repeat the same properties on various instances of the same type of control. There is a better way: styles, which we’ll cover next.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor109"/>Styles</h1>
			<p><strong class="bold">Styles</strong> allow you to provide a uniform look to your controls<a id="_idIndexMarker255"/> by putting all the details in one place.</p>
			<p>You create a style for a control type (for example, <code>Button</code>), and that style is applied to all controls of that type (refer to the <em class="italic">Explicit versus implicit styles</em> section). You can also base a style on an existing style, extending or modifying the original.</p>
			<p>Styles can be stored on the page that uses the control, or they can be stored at the application level. In either case, they are created inside <code>ResourceDictionary</code>, typically declared at the top of the file. To make them available at the application level, just put them in <code>App.xaml</code>.</p>
			<p class="callout-heading">Where to put your styles</p>
			<p class="callout">If you are only going to use the styles on objects on a single page, it makes sense to put the styles in the resources of that page. If you want to be able to reuse these styles on multiple pages, then you will want them in <code>App.xaml</code>.</p>
			<p>As an example, let’s return to the <code>ResourceDictionary</code> and our first styles. Place this code at the very top of the file, just below the <code>ContentPage</code> element:</p>
			<pre class="source-code">
    &lt;ContentPage.Resources&gt;
        &lt;Style TargetType="Label"&gt;
            &lt;Setter Property="FontSize" Value="Medium"/&gt;
            &lt;Setter Property="HorizontalOptions"
               Value="Start"/&gt;
            &lt;Setter Property="Margin" Value="10"/&gt;
            &lt;Setter Property="VerticalOptions"
               Value="Center"/&gt;
            &lt;Setter Property="VerticalTextAlignment"
              Value="Center"/&gt;
        &lt;/Style&gt;
    &lt;/ContentPage.Resources&gt;</pre>
			<p>You can see that we have created a style for the labels on the page. In that style, we have set a number of properties with their values. This will be applied to every <code>Label</code> because this is an implicit style, as described next.</p>
			<p>The key to the use of styles is that they greatly simplify the controls they are applied to. For example, the labels now look like this:</p>
			<pre class="source-code">
&lt;Label
    Text="User Name" /&gt;</pre>
			<p>They are no longer cluttered with all the style information that has been centralized in <code>ResourceDictionary</code>. This not only makes for cleaner XAML, but if you later decide to change one of these values, you do so in one place rather than throughout the page. Thus, the same clean code guideline that applies to C# (don’t repeat yourself) applies to styles.</p>
			<p>There are two types<a id="_idIndexMarker256"/> of styles: implicit and explicit. <code>TargetType</code>, as we saw earlier. <strong class="bold">Explicit styles</strong> can be applied to controls individually. Let us explore this in more detail next.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor110"/>Explicit versus implicit styles</h2>
			<p>To make a style<a id="_idIndexMarker257"/> explicit, you<a id="_idIndexMarker258"/> give it a key, as shown<a id="_idIndexMarker259"/> here:</p>
			<pre class="source-code">
&lt;Style TargetType="Label" x:Key="LargeLabel"&gt;
    &lt;Setter Property="FontSize" Value="Large" /&gt;
    &lt;Setter Property="HorizontalOptions" Value="Start" /&gt;
    &lt;Setter Property="Margin" Value="10" /&gt;
    &lt;Setter Property="VerticalOptions" Value="Center" /&gt;
    &lt;Setter Property="VerticalTextAlignment" Value="Center"
      /&gt;
&lt;/Style&gt;
&lt;Style TargetType="Label" x:Key="SmallLabel"&gt;
    &lt;Setter Property="FontSize" Value="Small" /&gt;
    &lt;Setter Property="HorizontalOptions" Value="Start" /&gt;
    &lt;Setter Property="Margin" Value="10" /&gt;
    &lt;Setter Property="VerticalOptions" Value="Center" /&gt;
    &lt;Setter Property="VerticalTextAlignment" Value="Center"
      /&gt;
&lt;/Style&gt;</pre>
			<p>You can now pick which of these styles you want to apply to <code>Label</code> based on that key:</p>
			<pre class="source-code">
&lt;Label
    Text="User Name"
    Style="{StaticResource LargeLabel}"/&gt;
&lt;Label
    Text="Password"
    Style="{StaticResource SmallLabel}"/&gt;</pre>
			<p>The<a id="_idIndexMarker260"/> result<a id="_idIndexMarker261"/> is shown<a id="_idIndexMarker262"/> in <em class="italic">Figure 5</em><em class="italic">.6</em>:</p>
			<div><div><img src="img/Figure_5.6_B19723.jpg" alt="Figure 5.6 – Explicit styles applied&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Explicit styles applied</p>
			<p class="callout-heading">Overriding the style in the control</p>
			<p class="callout">If you have a style<a id="_idIndexMarker263"/> that you want to use on all of your (for example) labels, but you have one <code>Label</code> that needs one or two properties to be different, one way to handle that is just to make the change in that <code>Label</code>. Properties assigned directly to the control override those of the style. On the other hand, if you have sets of controls that need nearly the same properties but differ in some ways, then you want to use style inheritance, which is covered next.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor111"/>Style inheritance or BasedOn</h2>
			<p>The construct for <code>LargeLabel</code> and <code>SmallLabel</code> has a lot of duplication. You<a id="_idIndexMarker264"/> can refactor<a id="_idIndexMarker265"/> this to use a base style and then just add the changes in your explicit styles. Here’s an example:</p>
			<pre class="source-code">
&lt;Style TargetType="Label"&gt;  [1]
    &lt;Setter Property="FontSize" Value="Medium" /&gt;
    &lt;Setter Property="HorizontalOptions" Value="Start" /&gt;
    &lt;Setter Property="Margin" Value="10" /&gt;
    &lt;Setter Property="VerticalOptions" Value="Center" /&gt;
    &lt;Setter Property="VerticalTextAlignment"
      Value="Center" /&gt;
&lt;/Style&gt;
&lt;Style TargetType="Label" x:Key="BaseExplicitLabel"&gt; [2]
    &lt;Setter Property="FontSize" Value="Medium" /&gt;
    &lt;Setter Property="HorizontalOptions" Value="Start" /&gt;
    &lt;Setter Property="Margin" Value="10" /&gt;
    &lt;Setter Property="VerticalOptions" Value="Center" /&gt;
    &lt;Setter Property="VerticalTextAlignment"
      Value="Center" /&gt;
&lt;/Style&gt;
&lt;Style
    TargetType="Label"
    x:Key="LargeLabel"
    BasedOn="{StaticResource BaseExplicitLabel}"&gt; [3]
    &lt;Setter Property="FontSize" Value="Large" /&gt;
&lt;/Style&gt;
&lt;Style
    TargetType="Label"
    x:Key="SmallLabel"
    BasedOn="{StaticResource BaseExplicitLabel}"&gt;
    &lt;Setter Property="FontSize" Value="Small" /&gt;
&lt;/Style&gt;
            &lt;Label
                Style="{StaticResource LargeLabel}" [4]
                Text="User Name" /&gt;</pre>
			<p>[1] An implicit label style</p>
			<p>[2] A style created to be the base style for other styles</p>
			<p>[3] A derived style that uses properties from the base style</p>
			<p>[4] Using<a id="_idIndexMarker266"/> the derived<a id="_idIndexMarker267"/> style</p>
			<p class="callout-heading">Derived styles</p>
			<p class="callout">Note that derived styles<a id="_idIndexMarker268"/> can add new properties (as was done here), they can override values in the base style, or both. Notice also that we refactored the styles, but did not have to refactor <code>Label</code> that uses it.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor112"/>Summary</h1>
			<p>In this chapter, we dove deeper into some of the more advanced aspects of .NET MAUI controls. We looked at the <code>Activity</code> element as well as <code>ProgressBar</code>. We went on to look at moving command handling into <code>ViewModel</code> and using messages to communicate between <code>ViewModel</code> and <code>View</code>.</p>
			<p>We ended the chapter by looking at styles and how they can be used to provide a uniform appearance to the UI and how we can refactor duplication out of similar styles by using style inheritance (<code>BasedOn</code>).</p>
			<p>In the next chapter, we’ll look at how we lay out <code>controls</code> on the page, moving beyond the simple <code>StackLayouts</code> we’ve been using so far.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor113"/>Quiz</h1>
			<ol>
				<li>What is the difference between <code>ActivityIndicator</code> and <code>ProgressBar</code>?</li>
				<li>What is the difference between an event and a command?</li>
				<li>What is <code>WeakReferenceManager</code>?</li>
				<li>Why would you use a style?</li>
				<li>How do you refactor common properties in styles?</li>
			</ol>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor114"/>You try it</h1>
			<p>Create a small form that pretends to gather information on the user to create a profile (name, age, address, and so on). Add an image you can tap on and two buttons: one to accept the entered info and one to cancel it.</p>
			<p>If the user taps on the image, put up a dialog box with a message, but handle the tap itself in <code>ViewModel</code>.</p>
			<p>Handle the button clicks in <code>ViewModel</code>. On clicking <code>Snackbar</code> to show what info they have saved, nicely formatted.</p>
		</div>
	</body></html>