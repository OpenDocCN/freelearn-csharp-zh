- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s dive into something critical: **unit testing**. Think of it as your safety
    net. It’s not just about knowing your app runs smoothly now, but ensuring that
    after every tweak, update, or overhaul, your app keeps on ticking without hiccups
    or unexpected surprises. Regression bugs? We’re looking at you! With MVVM and
    the right testing practices, we can effectively guard against these potential
    issues.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to tackle the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a unit test project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating data with Bogus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking dependencies with Moq
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing MAUI-specific code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While we won’t be diving deep into the weeds (after all, the intricacies can
    vary widely depending on the tools you use), I’ll guide you using a set of tools
    I’m familiar with: **xUnit**, **Bogus**, **AutoBogus**, and **Moq**. These are
    my go-to building blocks, but let’s remember: the .NET ecosystem is vast and versatile.
    There are several other fantastic frameworks and libraries out there, such as
    **NUnit**, **AutoFixture**, **NSubstitute**, and more. The principles we cover
    will largely remain the same; it’s just a matter of which tools resonate with
    your workflow. At the end of the day, it’s all about personal preference.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be firmly convinced of the immense value
    unit tests offer. Additionally, you’ll have a clear view of how to effectively
    use tools and techniques for writing unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To ensure you’re in sync with the upcoming content, make your way to our GitHub
    repository: [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter13](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter13).
    Kick off with the materials in the `Start` folder. And remember – if you’re ever
    in need of a consolidated reference, the `Finish` folder holds the final, refined
    code at the chapter’s close.'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lesson I learned the hard way forever transformed my stance on software development:
    *never underestimate* *unit testing*.'
  prefs: []
  type: TYPE_NORMAL
- en: Years ago, I was part of a dedicated team crafting an ambitious app. Our expertise
    in C# and the platform was undeniable. Yet, we overlooked unit tests, placing
    our faith in manual testing and our **Quality Assurance** (**QA**) team. The end
    product was highly recognized and praised, but the journey was a tumultuous one.
    Feedback from QA often revealed bugs, making each code adjustment feel risky.
  prefs: []
  type: TYPE_NORMAL
- en: Nearing deadlines was synonymous with sleepless nights, hasty bug fixes, and
    a looming fear of regressions. Post-project, I collaborated with diverse developers
    and encountered a colleague profoundly devoted to **test-driven development**
    (**TDD**). It was a true eye-opener, not just for the essence of unit testing
    but also for the flaws in our previous design choices.
  prefs: []
  type: TYPE_NORMAL
- en: 'My evolving journey underscored the real benefits of unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Efficiency**: No more long-lasting deployments before manual verifications.
    Unit tests swiftly validate my code, streamlining development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quality and confidence**: With each test, the software’s quality rises, as
    does my confidence. It becomes a safety net, allowing explorative coding without
    the fear of unintended consequences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Guarding against regressions**: Unit tests ensure alterations don’t unintentionally
    break existing features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With time, I’ve also observed that unit tests serve as an evolving documentation.
    New team members can determine the expected behavior and logic from these tests,
    facilitating quicker integration and more confident code modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'My old teammates and I still meet up from time to time. We chat about the old
    days and our shared experiences. In our conversations, a shared realization stands
    out: after our time together, each of us matured in our individual projects. This
    often leads us to a mutual reflection: if we had embraced unit testing in that
    project we did years ago, our work lived might have been a lot smoother. Don’t
    get me wrong; our clients were happy with what we delivered. But for all of us,
    on a personal level, having tests from the get-go could have saved many stressful
    nights, health issues, and uncertainties.'
  prefs: []
  type: TYPE_NORMAL
- en: While unit testing enjoys acclaim in many developer circles, I still witness
    hesitancy, especially in parts of the .NET world. My advocacy isn’t about achieving
    a coverage metric or TDD fanaticism. It’s about recognizing unit tests for their
    benefits, from ensuring code reliability to uplifting team morale.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit testing is not about achieving an abstract notion of perfection. It’s
    about having a safety net, allowing for code acrobatics without fearing a misstep.
    Do I write tests for every single line of code I have? In all honesty: no. Is
    all my code easy to test? Not always. But the tests I write really do help. They
    let me know quickly if things work, if I broke something, or if I fixed a bug
    the right way. And that gives me confidence in my work. When a bug is being reported,
    the first thing I do is write a failing test, exposing this bug. I can then go
    ahead and work on this bug, and as soon as the test passes, I know I’ve fixed
    it. And not only is the bug now fixed, but with the additional test (or tests),
    the code has become even more robust and protected against future regressions.'
  prefs: []
  type: TYPE_NORMAL
- en: As software continuously evolves in our fast-paced world, unit testing is not
    just best practice; it’s a lifeline. The peace of mind it offers is unparalleled,
    ensuring that the software not only functions but is robust against inevitable
    change.
  prefs: []
  type: TYPE_NORMAL
- en: 'To those beginning their developer journey or reevaluating unit tests: don’t
    mimic my initial oversight. See tests not as a chore but as a trusty companion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having said that, it’s time to pivot from the *why* to the *how*. For those
    still with me, let’s delve into the details: setting up unit tests for ViewModels.
    Believe me, it’s simpler than it seems!'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a unit test project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be walking through the steps of setting up a unit test
    project and creating a first test. We’ll be using xUnit in this section. We’re
    not going to get all tangled up in the tiny details of this specific library because
    there are tons of other awesome ones. No matter what you choose, the big takeaways
    should stick with you. So, without further ado, let’s dive in and start setting
    the stage for effective ViewModel testing!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a unit test project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by creating an xUnit Test project. In xUnit, one of the things
    I appreciate is its simplicity. Test classes and methods are just normal classes
    and methods, without the need for special base classes or complex setups. Here’s
    how:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Solution Explorer** in **Visual Studio**, right-click **Solution ‘Recipes
    App’** and select **Add** | **New Project…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `xunit` in the search box and select **xUnit Test Project** from the
    list (*Figure 13**.1*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.1: Creating a new xUnit test project](img/B20941_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Creating a new xUnit test project'
  prefs: []
  type: TYPE_NORMAL
- en: Click the `Recipes.Client.Core.UnitTests` as the project name. Click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted, select **.NET 8.0 (Long Term Support)** from the **Framework**
    list and hit the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project is generated, right-click on it, select `Recipes.Client.Core`
    project from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the project and its reference to the `Recipes.Client.Core` project in place,
    we can start writing our unit tests. Let’s go ahead and write our first one!
  prefs: []
  type: TYPE_NORMAL
- en: Creating unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by testing something pretty straightforward: testing the initialization
    of the `RecipeListItemViewModel`. Here’s how:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the generated `UnitTest1.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new C# class called `RecipeListItemViewModelTests` to the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the class public and add a public method called `ViewModel_Initialized_PropertiesSetCorrectly`,
    as shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note how the `Fact` attribute is added to this method. This attribute signals
    that this is a test method. Without it, the method won’t be identified as a test
    and therefore won’t be executed as one during test runs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following code to this method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates and validates a `RecipeListItemViewModel` instance. This code block
    first creates an instance of the `RecipeListItemViewModel` class using sample
    data. It then calls a series of assertions to confirm that the object’s properties
    were initialized as expected.
  prefs: []
  type: TYPE_NORMAL
- en: In unit testing jargon, our instantiated object is named `sut`, which stands
    for **system under test**. This is a name commonly used in unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the role of the `Assert` statements, inherent to the xUnit framework,
    deserves special mention. `Assert` methods play a pivotal role in validating object
    states to ensure they meet our expectations. `Assert.True`, `Assert.Empty`, `Assert.Contains`,
    and many more are at our disposal. The `Assert.Equal` method, as shown in this
    example, evaluates if the expected value matches the object’s actual value. In
    this context, it ensures that properties of our `sut` object, such as `Id`, `Title`,
    `IsFavorite`, and `Image`, were initialized as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous code snippet, you may notice the clear structure, which is
    guided by comments: `//Arrange`, `//Act`, and `//Assert`. This corresponds to
    a fundamental pattern in unit testing known as **Arrange-Act-Assert** (**AAA**).
    Let’s delve briefly into what each stage signifies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Arrange`: This stage involves setting up any prerequisites for a test. We
    establish the conditions our test operates under. This might include initializing
    variables, creating mock objects, or setting up resources. In our example, this
    is where we define our sample data: `id`, `title`, `isFavorite`, and `image`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Act`: Here, we perform the action that we intend to test. This is where the
    `sut` object is invoked, and it’s typically a single action. In our context, it’s
    the instantiation of `RecipeListItemViewModel` with the sample data we arranged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assert`: This final stage is where we verify if the test has passed or failed
    by checking the outcome against the expected results. In our example, this is
    done using the `Assert.Equal` method to ensure that our `RecipeListItemViewModel`
    object’s properties match the values we initialized them with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the AAA pattern ensures that tests are organized and readable, making
    it easier for you, or anyone reviewing your code, to understand the purpose and
    behavior of each test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and run the test! This can be done by right-clicking inside the test
    method you want to test and selecting **Run Tests**. Alternatively, you can choose
    **Debug Tests**, which runs your test and breaks on any breakpoints you have added,
    allowing you to step through the unit test. Test methods are also visible in the
    **Test Explorer** in **Visual Studio**. From there, you can easily run multiple
    tests. This pane also shows the current status of your tests: which ran successfully
    and which failed, alongside other relevant info, as shown in *Figure 13**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2: Visual Studio’s Test Explorer](img/B20941_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: Visual Studio’s Test Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a couple more tests! Each instance of a `RecipeListItemViewModel`
    should listen for a `FavoriteUpdateMessage` and when such a message arrives, its
    `IsFavorite` property should be updated accordingly. So, let’s first write a test
    that validates that a newly instantiated `RecipeListItemViewModel` is registered
    as a recipient for a `FavoriteUpdateMessage` message. Secondly, in separate tests,
    we can check if the class reacts as expected to such a message:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start off by adding the following test to the `RecipeListItemViewModelTests`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `WeakReferenceMessenger.Default.IsRegistered` method allows us to check
    whether a particular object is registered for a particular message. We expect
    our `sut` to be registered for the `FavoriteUpdateMessage`, so we can call this
    method and validate the outcome to be true with `Assert.True`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We should also validate that when a `FavoriteUpdateMessage` is received by
    the `sut`, the `IsFavorite` property is updated accordingly – only, of course,
    when the id sent by the message matches the id of the `sut`. Take a look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `FavoriteUpdateMessage` sends the inverse of the `originalValue` value that
    is used to instantiate the sut. After sending the message, which contains the
    same `RecipeId` as the sut, we can check whether the value of the `IsFavorite`
    property equals the value we’ve sent.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As a last test, we might want to validate that a `RecipeListItemViewModel`
    doesn’t react to a `FavoriteMessage` with a different `RecipeId`. This is very
    similar to our previous test, as you can see here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because the message sends a different `RecipeId` than the ID on the `RecipeListItemViewModel`,
    we want to validate that the `IsFavorite` property on the sut is still the same
    as the originally set value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The “unit” in unit tests
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about *unit tests*, that *unit* part is crucial. It’s all about
    keeping things small and focused. Take a peek at the tests we just created. The
    first one ensures the ViewModel is registered for incoming `FavoriteUpdateMessage`s,
    while the other one checks how the ViewModel responds to an incoming message.
    Sure – the latter indirectly verifies the message listener too, but that doesn’t
    mean we can skip the first test. Each *unit* test should stick to checking one
    tiny piece of the puzzle to make sure every bit is working as it should.
  prefs: []
  type: TYPE_NORMAL
- en: With our first test passing, let’s see how we can make them more data-driven.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at data-driven tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`false` as the third parameter. Now, if we were to remove `IsFavorite = isFavorite;`
    from the `RecipeListItemViewModel` class’s constructor, our test would deceptively
    still pass – a classic example of a false positive in testing. This is because,
    by coincidence, the default value of `IsFavorite` is `false`, but in fact, it
    is never assigned the value we passed in as a parameter. We could create another
    test method with different values in the `Theory` and `InlineData` attributes
    to leverage data-driven tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In xUnit, while the `Fact` attribute denotes a straightforward unit test that
    runs once, there’s another powerful feature: the `Theory` attribute. Paired with
    the `InlineData` attribute, `Theory` allows us to create parameterized tests.
    This means we can run the same test logic with different input values, ensuring
    our code is robust against a variety of scenarios without duplicating our test
    methods. Let’s dive in and refactor our earlier test to take advantage of this
    capability:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `ViewModel_Initialized_PropertiesSetCorrectly` method to include
    the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: //Arrange, Act
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var sut = new RecipeListItemViewModel(id, title,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: isFavorite, image);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //Assert
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Assert.Equal(id, sut.Id);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Assert.Equal(title, sut.Title);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Assert.Equal(isFavorite, sut.IsFavorite);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Assert.Equal(image, sut.Image);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now remove the `Fact` attribute and add a `Theory` attribute and some
    `InlineData` attributes to this method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Theory` attribute is used to mark a test method as being a data-driven
    test. This means that the test method will be executed once for each set of data
    values specified using the `InlineData` attribute. Each of those runs of the test
    will have access to the data values provided by `InlineData`. When the `Theory`
    method is executed, xUnit will create a new instance of the test class for each
    set of data values specified in the `InlineData` attribute, and then execute the
    test method using those data values. The values provided in the `InlineData` attribute
    should exactly match the number and types of parameters on the method that is
    being tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can update the `FavoriteUpdateMsgReceived_SameId_FavoriteUpdated`
    method to turn it into a data-driven test method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FavoriteUpdateMsgReceived_DifferentId_FavoriteNotUpdated` can be updated
    similarly, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By adopting the `Theory` and `InlineData` attributes, we’ve enhanced our testing
    capability significantly. These updated test methods can now validate across a
    diverse set of values, ensuring that our ViewModel behaves consistently in varied
    scenarios. It’s an elegant way to increase test coverage without adding redundant
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it’s beneficial to have test data generated for us, especially when
    we’re more concerned about the logic than the specific values. That’s where tools
    such as Bogus and AutoBogus come into play, helping us effortlessly generate diverse
    test values without manual intervention. Let’s have a look!
  prefs: []
  type: TYPE_NORMAL
- en: Generating data with Bogus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While handpicked data has its place in unit tests, it often comes with inherent
    bias: because we’ve written the functionality that we want to test, we have a
    certain expectation about the format of the values being used. To combat this,
    many tests benefit from randomized or generated data, especially when the specific
    input matters less than the resulting outcome. Bogus is a powerful tool tailored
    for those moments when you need reliable, unbiased test data without the manual
    labor.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll introduce Bogus and AutoBogus and explore some of its
    basic capabilities. However, it’s worth noting that we’re merely scratching the
    surface here. These tools offer many features, but for the sake of brevity and
    focus, we’ll keep our discussion high-level, touching only upon a few fundamental
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start off by adding AutoBogus (and thus also Bogus) to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: In `Recipes.Client.Core.UnitTests` project and select **Manage** **NuGet Packages…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `autobogus` and install the **AutoBogus** package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.3: AutoBogus NuGet Package](img/B20941_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: AutoBogus NuGet Package'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have installed these packages, let’s put this library into practice
    by testing the `EmptyOrWithinRangeAttribute` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `EmptyOrWithinRangeAttributeTests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Place the following member variables into the new class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this class, we’ll be putting our `sut` object as a class member. This allows
    us to write the instantiation code of the `sut` object once in the constructor
    (or inline), preventing repeatable code in each test for setting everything up.
    As each test method runs in a separate instance of the `EmptyOrWithinRangeAttributeTests`
    class, this also has no side effects on other tests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a constructor to the class and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Instead of manually creating an instance of the `EmptyOrWithinRangeAttribute`
    class, we are delegating this to the Bogus framework. We do this by instantiating
    a new `Faker` class, passing in the type we want it to generate. With the `RuleFor`
    methods of the `Faker` class, we can configure the values for the individual properties.
  prefs: []
  type: TYPE_NORMAL
- en: In a `RuleFor` method, we first need to point to the property we want to configure.
    The next parameter of this method is a function with a `Faker` class as a parameter
    that allows us to define the value of the property. In this case, we use the `Faker`’s
    `Random.Int` method to indicate we want it to be a generated int value between
    two values.
  prefs: []
  type: TYPE_NORMAL
- en: By calling the `Generate` method, the Bogus framework will generate an instance
    of the type we want, adhering to the rules we’ve defined. This gives back the
    instance of the `EmptyOrWithinRangeAttribute` we want to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go ahead and implement a test that checks if `EmptyOrWithinRangeAttribute`
    validates input correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Value_WithinRange_IsValid` to this class, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Arrange` step, we’re using Bogus’ `Faker` class to generate a random
    string with a length that falls between the `MinLength` and `MaxLength` properties
    of the `sut`. Remember – these `MinLength` and `MaxLength` properties are values
    generated by Bogus. This generated string value can now be used to check whether
    the `IsValid` method of the `EmptyOrWithingRangeAttribute` does what we expect
    it to do. The returned value should be `true`, which we can easily check with
    the `Assert.True` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, we can add a `Value_TooShort_IsNotValid` method that checks that
    the `IsValid` method returns `false` when the provided value isn’t correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While we’re at it, let’s also add a check to see if an empty string is returned
    as being valid. This is shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how short and straightforward these test methods are! Adding extra checks
    for input values being too long or null really isn’t hard labor. And because we
    are not working with hardcoded data, we can be pretty confident the `IsValid`
    method of the `EmptyOrWithingRangeAttributes` class works as expected in many
    different scenarios. On top of that, think about the speed and efficiency with
    which we’re validating this `ValidationAttribute` class. We haven’t deployed our
    app or clicked through its interface. Still, we’re already certain about the correctness
    of our code. That’s a significant boost in development efficiency!
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the `VM_Initialized_SubscribedToFavoriteUpdateMessage` method in the
    `RecipeListItemViewModelTests` class we wrote earlier? This method checks whether
    an instance of the `RecipeListItemViewModel` is registered as a receiver for the
    `FavoriteUpdateMessage`. In this test method, we had to initialize our sut. However,
    the values that were used to create it aren’t of any value inside the test: whichever
    values are used, the instance should listen for the `FavoriteUpdateMessage`. This
    is an ideal scenario to introduce AutoBogus. Just take a look at the updated code
    of the `VM_Initialized_SubscribedToFavoriteUpdateMessage` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With the static `Generate` method of the `AutoFaker` class, we can generate
    an instance of `RecipeListItemViewModel`. The `Faker` class typically requires
    a default constructor for the object type we want to instantiate. The `RecipeListItemViewModel`
    doesn’t have a default constructor and that’s where `AutoFaker` comes into play:
    it will automatically provide fake values for the parameters. We basically don’t
    care which values are used to create this class. All that we are interested in
    in this test, is the fact the instantiated class is registered for the `FavoriteUpdateMessage`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In other test methods, such as those in `RecipeListItemViewModelTests`, we’ve
    relied on hardcoded dummy data. We can use AutoBogus to get rid of these hardcoded
    values as well. Take a look at the updated `FavoriteUpdateMsgReceived_SameId_FavoriteUpdated`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this previous code block, we’re leveraging AutoBogus’ `Generate` method to
    generate random data for us.
  prefs: []
  type: TYPE_NORMAL
- en: Bogus and AutoBogus automate .NET testing by generating unbiased, randomized
    test data, eliminating manual and potentially biased inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of merely providing fake data, we often need to mock entire components
    or behavior. This is where a dedicated mocking framework, such as Moq, becomes
    invaluable. Let’s delve into how Moq empowers us to effectively mock dependencies
    and streamline our testing process.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking dependencies with Moq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing frequently involves scenarios where our system under test interacts
    with external dependencies, whether they are databases, APIs, or other services.
    Running tests against these real dependencies can lead to slow, unpredictable
    outcomes and potentially unwanted side effects. Mocking provides a solution by
    simulating these dependencies, ensuring our tests focus purely on the component
    at hand. Through mocking, we gain control over external interactions, ensuring
    our tests are swift, reliable, and free from external influences.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs: []
  type: TYPE_NORMAL
- en: When writing unit tests, we typically want to mock external dependencies as
    much as possible. However, it is often valuable to also test the integration of
    different components to ensure they work together seamlessly. This is where integration
    tests come in. Unlike unit tests, which focus heavily on mocking to test units
    in isolation, integration tests often involve fewer mocks. This ensures that components
    interact with each other in the exact manner we expect, verifying that they behave
    correctly as a unified whole.
  prefs: []
  type: TYPE_NORMAL
- en: The principles of DI and separation of concerns accentuate this approach. When
    we design our components to be decoupled and inject their dependencies, it becomes
    seamless to replace real dependencies with mock versions during testing. Think
    of DI, SoC, and mocking as interlocking puzzle pieces, each complementing the
    other, leading to a comprehensive and maintainable testing strategy. Now, let’s
    dive into how Moq assists us in achieving this goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we inspect the `RecipeDetailViewModel`’s constructor, it’s evident that
    it depends on several services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To effectively test this ViewModel, we need to abstract away its external dependencies.
    Mocking the `recipeService` parameter can be achieved like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The mocked value can then be passed-in the `RecipeDetailViewModel` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Task<Result<RecipeDetail>> LoadRecipe(string id);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: recipeServiceMock
  prefs: []
  type: TYPE_NORMAL
- en: .Setup(m => m.LoadRecipe(It.IsAny<string>()))
  prefs: []
  type: TYPE_NORMAL
- en: .ReturnsAsync(
  prefs: []
  type: TYPE_NORMAL
- en: Result<RecipeDetail>.Success(new RecipeDetail(...));
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: readonly Mock<IRecipeService> _recipeServiceMock;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: readonly Mock<IFavoritesService>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _favoritesServiceMock;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: readonly Mock<IRatingsService> _ratingsServiceMock;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: readonly Mock<INavigationService>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _navigationServiceMock;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: readonly Mock<IDialogService> _dialogServiceMock;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: readonly RecipeDetailViewModel sut;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public RecipeDetailViewModelTests()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _recipeServiceMock = new();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _favoritesServiceMock = new();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _ratingsServiceMock = new();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _navigationServiceMock = new();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _dialogServiceMock = new();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _ratingsServiceMock
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .Setup(m =>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: m.LoadRatingsSummary(It.IsAny<string>()))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .ReturnsAsync(Result<RatingsSummary>.Success(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: AutoFaker.Generate<RatingsSummary>()));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sut = new RecipeDetailViewModel(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _recipeServiceMock.Object,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _favoritesServiceMock.Object,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _ratingsServiceMock.Object,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _navigationServiceMock.Object,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _dialogServiceMock.Object);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[Fact]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public async Task OnNavigatedTo_Should_Load_Recipe()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: //Arrange
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var recipeId = AutoFaker.Generate<string>();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var parameters = new Dictionary<string, object> {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{ "id", recipeId }'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _recipeServiceMock
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .Setup(m => m.LoadRecipe(It.IsAny<string>()))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .ReturnsAsync(Result<RecipeDetail>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .Success(AutoFaker.Generate<RecipeDetail>()));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: //Act
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: await sut.OnNavigatedTo(parameters);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: //Assert
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _recipeServiceMock.Verify(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: m => m.LoadRecipe(recipeId), Times.Once);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[Fact]'
  prefs: []
  type: TYPE_NORMAL
- en: public async Task OnNavigatedTo_Should_Map_RecipeDetail()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: //Arrange
  prefs: []
  type: TYPE_NORMAL
- en: var recipeDetail = AutoFaker.Generate<RecipeDetail>();
  prefs: []
  type: TYPE_NORMAL
- en: var parameters = new Dictionary<string, object> {
  prefs: []
  type: TYPE_NORMAL
- en: '{ "id", AutoFaker.Generate<string>() }'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: _recipeServiceMock
  prefs: []
  type: TYPE_NORMAL
- en: .Setup(m => m.LoadRecipe(It.IsAny<string>()))
  prefs: []
  type: TYPE_NORMAL
- en: .ReturnsAsync(Result<RecipeDetail>
  prefs: []
  type: TYPE_NORMAL
- en: .Success(recipeDetail));
  prefs: []
  type: TYPE_NORMAL
- en: //Act
  prefs: []
  type: TYPE_NORMAL
- en: await sut.OnNavigatedTo(parameters);
  prefs: []
  type: TYPE_NORMAL
- en: //Assert
  prefs: []
  type: TYPE_NORMAL
- en: Assert.Equal(recipeDetail.Name, sut.Title);
  prefs: []
  type: TYPE_NORMAL
- en: Assert.Equal(recipeDetail.Author, sut.Author);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[Fact]'
  prefs: []
  type: TYPE_NORMAL
- en: public async Task FailedLoad_Should_ShowDialog()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: //Arrange
  prefs: []
  type: TYPE_NORMAL
- en: var parameters = new Dictionary<string, object> {
  prefs: []
  type: TYPE_NORMAL
- en: '{ "id", AutoFaker.Generate<string>() }'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: _recipeServiceMock
  prefs: []
  type: TYPE_NORMAL
- en: .Setup(m => m.LoadRecipe(It.IsAny<string>()))
  prefs: []
  type: TYPE_NORMAL
- en: .ReturnsAsync(Result<RecipeDetail>
  prefs: []
  type: TYPE_NORMAL
- en: .Fail(AutoFaker.Generate<string>()));
  prefs: []
  type: TYPE_NORMAL
- en: _dialogServiceMock
  prefs: []
  type: TYPE_NORMAL
- en: .Setup(m => m.AskYesNo(It.IsAny<string>(), ...))
  prefs: []
  type: TYPE_NORMAL
- en: .ReturnsAsync(false);
  prefs: []
  type: TYPE_NORMAL
- en: //Act
  prefs: []
  type: TYPE_NORMAL
- en: await sut.OnNavigatedTo(parameters);
  prefs: []
  type: TYPE_NORMAL
- en: //Assert
  prefs: []
  type: TYPE_NORMAL
- en: _dialogServiceMock.Verify(m =>       m.AskYesNo (It.IsAny<string>(), ...), Times.Once);
  prefs: []
  type: TYPE_NORMAL
- en: _navigationServiceMock.Verify(m => m.GoBack(),
  prefs: []
  type: TYPE_NORMAL
- en: Times.Once);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: <TargetFrameworks>net8.0;net8.0-android;net8.0-
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ios;net8.0-maccatalyst</TargetFrameworks>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <OutputType Condition="'$(TargetFramework)' !=
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Recipes.Mobile project and select Unload Project. Once unloaded, right-click
    it again and select Reload Project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public void Convert_Should_Return_ExpectedOutput(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: object input, string expectedOutput)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //Arrange
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var sut = new Converters.RatingToStarsConverter();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //Act
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var result = sut.Convert(input,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: null, null, null);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //Assert
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Assert.Equal(expectedOutput, result);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[InlineData("foo", "")]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[InlineData(-1d, "")]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[InlineData(6d, "")]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[InlineData(1d, "\ue838")]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[InlineData(2d, "\ue838\ue838")]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[InlineData(2.2d, "\ue838\ue838")]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[InlineData(2.5d, "\ue838\ue838\ue839")]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[InlineData(2.9d, "\ue838\ue838\ue839")]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[Fact]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public void SelectTemplate_NoteVM_Should_Return
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _NoteTemplate()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //Arrange
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var template = new DataTemplate();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var sut = new InstructionsDataTemplateSelector();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sut.NoteTemplate = template;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sut.InstructionTemplate = new DataTemplate();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //Act
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var result = sut.SelectTemplate(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: AutoFaker.Generate<NoteViewModel>(), null);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //Assert
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Assert.Equal(template, result);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
