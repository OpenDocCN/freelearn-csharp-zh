<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Continuing with Intelligent Enemies"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Continuing with Intelligent Enemies</h1></div></div></div><p>This last chapter continues with the previous one and completes the AI project by focusing on the theory and related coding underpinning an intelligent enemy. The enemy will demonstrate three main behaviors: patrolling, chasing, and attacking. In this chapter, we will dive into the <a id="id463" class="indexterm"/>following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to plan and code an AI system for enemy characters</li><li class="listitem" style="list-style-type: disc">How to code Finite State Machines (FSMs)</li><li class="listitem" style="list-style-type: disc">How to create the line-of-sight functionality<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>The starting project and assets can be found in the book companion files in the <code class="literal">Chapter08/Start</code> folder. You can start here and follow along with this chapter if you don't have your own project already.</p></div></div></li></ul></div><div class="section" title="Enemy AI – range of sight"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec74"/>Enemy AI – range of sight</h1></div></div></div><p>Let's now <a id="id464" class="indexterm"/>start developing enemy AI by thinking about our functional requirements. The enemies in the scene will begin in patrol mode, wandering the level from place to place searching for the player character. If the player is spotted, the enemy will change from patrolling and begin chasing the player, attempting to move closer to them for an attack. If the enemy reaches within attacking range of the player, the enemy will change from chasing to attacking. If the player outruns the enemy and successfully loses them, the enemy should stop chasing and return to patrolling again, searching for the player as they were doing initially. This, in sum, describes our needed enemy AI behavior.</p><p>To achieve this behavior, we'll need to code the line of sight functionality for the enemy. The enemy relies on being able to see the player character or determining whether the player is visible to the enemy at any one moment. This helps the enemy decide whether they should patrol or chase the player character. To code this, refer to the following code from the source file, <code class="literal">LineSight.cs</code>. This script file should be attached to the enemy character created so far from the previous chapter.</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//------------------------------------------
public class LineSight : MonoBehaviour
{
  //------------------------------------------
  //How sensitive should we be to sight
  public enum SightSensitivity {STRICT, LOOSE};

  //Sight sensitivity
  public SightSensitivity Sensitity = SightSensitivity.STRICT;

  //Can we see target
  public bool CanSeeTarget = false;

  //FOV
  public float FieldOfView = 45f;

  //Reference to target
  private Transform Target = null;

  //Reference to eyes
  public Transform EyePoint = null;

  //Reference to transform component
  private Transform ThisTransform = null;

  //Reference to sphere collider
  private SphereCollider ThisCollider = null;

  //Reference to last know object sighting, if any
  public Vector3 LastKnowSighting = Vector3.zero;
  //------------------------------------------
  void Awake()
  {
    ThisTransform = GetComponent&lt;Transform&gt;();
    ThisCollider = GetComponent&lt;SphereCollider&gt;();
    LastKnowSighting = ThisTransform.position;
    Target = GameObject.FindGameObjectWithTag("Player").GetComponent&lt;Transform&gt;();
  }
  //------------------------------------------
  bool InFOV()
  {
    //Get direction to target
    Vector3 DirToTarget = Target.position - EyePoint.position;

    //Get angle between forward and look direction
    float Angle = Vector3.Angle(EyePoint.forward, DirToTarget);

    //Are we within field of view?
    if(Angle &lt;= FieldOfView)
      return true;

    //Not within view
    return false;
  }
  //------------------------------------------
  bool ClearLineofSight()
  {
    RaycastHit Info;
  
    if(Physics.Raycast(EyePoint.position, (Target.position - EyePoint.position).normalized, out Info, ThisCollider.radius))
    {
      //If player, then can see player
      if(Info.transform.CompareTag("Player"))
        return true;
    }

    return false;
  }
  //------------------------------------------
  void UpdateSight()
  {
    switch(Sensitity)
    {
      case SightSensitivity.STRICT:
        CanSeeTarget = InFOV() &amp;&amp; ClearLineofSight();
      break;

      case SightSensitivity.LOOSE:
        CanSeeTarget = InFOV() || ClearLineofSight();
      break;
    }
  }
  //------------------------------------------
  void OnTriggerStay(Collider Other)
  {
    UpdateSight();

    //Update last known sighting
    if(CanSeeTarget)
      LastKnowSighting =  Target.position;
  }
  //------------------------------------------
  void OnTriggerExit(Collider Other)
  {
    if(!Other.CompareTag("Player"))return;

    CanSeeTarget = false;
  }
  //------------------------------------------
}
//------------------------------------------</pre></div><div class="section" title="Code Sample 8.1"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec29"/>Code Sample 8.1</h2></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id465" class="indexterm"/><code class="literal">LineSight</code> class should be attached to any enemy character object. Its purpose is to calculate whether a direct line of sight is available between the player and enemy.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">CanSeeTarget</code> variable is a Boolean (<code class="literal">True</code>/<code class="literal">False</code>), which is updated on a per frame basis to describe whether the enemy can see the player <span class="emphasis"><em>right now</em></span> (for this frame). <code class="literal">True</code> means that the player is in sight of the enemy, and <code class="literal">false</code> means that the player is not visible.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">FieldOfView</code> variable is a floating point value that determines an angular margin on either side of the enemy eye-point, inside which objects (like the player) can be seen. The higher this value, the more chance the enemy has of seeing the player.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">InFOV</code> function returns <code class="literal">true</code> or <code class="literal">false</code> to indicate whether the player is within the enemy field of view. This ignores whether the player is occluded behind a wall or solid object (like a pillar). It simply takes the position of the enemy eyes, determines a vector to the player, and measures the angle between the forward vector and player. It compares this to the field of view, and returns <code class="literal">true</code> if the angle between enemy and player is less than the <code class="literal">FieldOfView</code> variable. In short, this function can tell you whether the enemy would see the player if there were a clear line of sight.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">ClearLineOfSight</code> function returns <code class="literal">true</code> or <code class="literal">false</code> to indicate whether there are any physical obstacles (Colliders), such as walls or props, between the enemy eye point and player. This does not consider whether the player is within the enemy field of view. This function, in combination with the <code class="literal">InFOV</code> function, can determine whether the enemy has a clear line of sight to the player and is within the field of view, and thus, whether the player is visible.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">OnTriggerStay</code> and <code class="literal">OnTriggerExit</code> functions are called when the player is within a trigger volume surrounding the enemy and when the player leaves this volume respectively. As we'll see, a sphere collider can be attached to the enemy character object to represent its horizon of view. This means the total distance, or radius, inside which the enemy could see the player, provided they were within the field of view and a clear line of sight existed.</li></ul></div><p>Now, attach <a id="id466" class="indexterm"/>the <code class="literal">LineSight.cs</code> script file to the enemy character in the scene as well as a Sphere Collider component (marked as a Trigger) to approximate the viewing horizon of the enemy. See <span class="emphasis"><em>Figure 8.1</em></span>. Leave the <span class="strong"><strong>Field of View</strong></span> setting at <code class="literal">45</code>, although this can be increased, if needed, to around <code class="literal">90</code> to tweak the effectiveness of the enemy viewing range.</p><div class="mediaobject"><img src="graphics/B05118_08_01.jpg" alt="Code Sample 8.1"/><div class="caption"><p>Figure 8.1: Adding a horizon to the NPC</p></div></div><p>The <span class="strong"><strong>Eye Point</strong></span> field is, by default, set to <span class="strong"><strong>None</strong></span>, which represents a null value. This should refer to a specific location on the enemy character that acts as the eye point—the place from which the character can see. To create this point, add a new and empty game object to the scene using the application menu, <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Create Empty</strong></span>. Name the object <code class="literal">Eye Point</code>, activate its visibility from the <span class="strong"><strong>Inspector</strong></span> using a Gizmo icon (so that it can be visible even when deselected), and then add it as a child object to the enemy. Afterward, position the object to the character eye point, making sure that the forward vector is <a id="id467" class="indexterm"/>facing in the same direction. See <span class="emphasis"><em>Figure 8.2:</em></span>
</p><div class="mediaobject"><img src="graphics/B05118_08_02.jpg" alt="Code Sample 8.1"/><div class="caption"><p>Figure 8.2:  Adding an EyePoint</p></div></div><p>Now, drag and drop the Eye Point object from the <span class="strong"><strong>Hierarchy</strong></span> panel to the <span class="strong"><strong>Eye Point</strong></span> field for the LineSight component in the <span class="strong"><strong>Inspector</strong></span>. This specifies the Eye Point object as the eye point for the enemy character. This will be used in determining whether the enemy can see the player. Having a separate eye point object like this is useful as opposed to using the character position, which is typically at the feet location and not the eye. See <span class="emphasis"><em>Figure 8.3</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_08_03.jpg" alt="Code Sample 8.1"/><div class="caption"><p>Figure 8.3: Defining the eye point for an NPC</p></div></div><p>Finally, the <code class="literal">LineSight</code> script determines the player location by first finding the player object in the scene using the <span class="strong"><strong>Player</strong></span> tag. Consequently, make sure that the <span class="strong"><strong>Player</strong></span> is tagged or <a id="id468" class="indexterm"/>labeled using the <span class="strong"><strong>Player</strong></span> tag. See <span class="emphasis"><em>Figure 8.4</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_08_04.jpg" alt="Code Sample 8.1"/><div class="caption"><p>Figure 8.4: Tagging the player object</p></div></div><p>Now take your game for a test run. When you approach the NPC object, the <span class="strong"><strong>Can See Target</strong></span> field will be enabled. See <span class="emphasis"><em>Figure 8.5</em></span>. Good work! The line of sight functionality is now completed. Let's move on!</p><div class="mediaobject"><img src="graphics/B05118_08_05.jpg" alt="Code Sample 8.1"/><div class="caption"><p>Figure 8.5: Testing the line of sight functionality</p></div></div></div></div></div>
<div class="section" title="An overview of Finite State Machines"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec75"/>An overview of Finite State Machines</h1></div></div></div><p>To create the <a id="id469" class="indexterm"/>AI for an NPC object, in addition to the line of sight code that we already have, we need to use <span class="strong"><strong>Finite State Machines</strong></span> (<span class="strong"><strong>FSMs</strong></span>). An FSM is not a <span class="emphasis"><em>thing</em></span> or feature of Unity, nor is it a tangible aspect of the C# language. Rather, an FSM is a concept, framework, or idea that we can apply in code to achieve specific AI behaviors. It comes from a specific way of thinking about intelligent characters. Specifically, we can summarize the NPC for our level as existing within one of three possible states at any one time. These are patrol (when the enemy is wandering around), chase (when the enemy is running after the player), and attack (when the enemy has reached the player and is attacking). Each of these modes is a State and requires a unique and specific behavior and the enemy can be in only one of these three states at any one time. The enemy cannot, for example, be patrolling and chasing simultaneously or patrolling and attacking, because this wouldn't make sense within the logic of the world and game.</p><p>In addition to the states themselves, there is a rule set or group of connections between the states that determines when one state should change or move into another. For example, an NPC should only move from patrolling to chasing if they can see the player and they are not already attacking. Similarly, the NPC should only move from attacking to patrolling if they cannot see the player and they are not already patrolling or chasing. Thus, the combination of the States and rules governing their connections form a Finite State Machine. Consequently, any implementation in code that represents this behavior functionally is an FSM. There is no right or wrong way to code an FSM per se. There are simply different ways, some of which are better or worse for particular ends.</p><p>In this section, we'll code the FSM using Coroutines. Let's start by creating the main structure. Refer <a id="id470" class="indexterm"/>to the following code in the file, <code class="literal">AI_Enemy.cs</code>:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//------------------------------------------
public class AI_Enemy : MonoBehaviour
{
  //------------------------------------------
  public enum ENEMY_STATE {PATROL, CHASE, ATTACK};
  //------------------------------------------
  public ENEMY_STATE CurrentState
  {
    get{return currentstate;}

    set
    {
      //Update current state
      currentstate = value;

      //Stop all running coroutines
      StopAllCoroutines();

      switch(currentstate)
      {
        case ENEMY_STATE.PATROL:
          StartCoroutine(AIPatrol());
        break;

        case ENEMY_STATE.CHASE:
          StartCoroutine(AIChase());
        break;

        case ENEMY_STATE.ATTACK:
          StartCoroutine(AIAttack());
        break;
      }
    }
  }
  //------------------------------------------
  [SerializeField]
  private ENEMY_STATE currentstate = ENEMY_STATE.PATROL;

  //Reference to line of sight component
  private LineSight ThisLineSight = null;

  //Reference to nav mesh agent
  private NavMeshAgent ThisAgent = null;

  //Reference to player transform
  private Transform PlayerTransform = null;

  //------------------------------------------
  void Awake()
  {
    ThisLineSight = GetComponent&lt;LineSight&gt;();
    ThisAgent = GetComponent&lt;NavMeshAgent&gt;();
    PlayerTransform = GameObject.FindGameObjectWithTag("Player").GetComponent&lt;Transform&gt;();
  }
  //------------------------------------------
  void Start()
  {

    //Configure starting state
    CurrentState = ENEMY_STATE.PATROL;
  }
  //------------------------------------------
  public IEnumerator AIPatrol()
  {
      yield break;

  }
  //------------------------------------------
  public IEnumerator AIChase()
  {

      yield break;
  }
  //------------------------------------------
  public IEnumerator AIAttack()
  {
    yield break;
  }
  //------------------------------------------
}
//------------------------------------------</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>More <a id="id471" class="indexterm"/>information on Coroutines can be found at the <a id="id472" class="indexterm"/>online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/Coroutines.html">http://docs.unity3d.com/Manual/Coroutines.html</a>.</p></div></div><div class="section" title="Code Sample 8.2"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec30"/>Code Sample 8.2</h2></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">AI_Enemy</code> <a id="id473" class="indexterm"/>class created so far does not represent the full and complete FSM but just the skeleton for its beginning. It illustrates the general structure. It features a single coroutine for each state.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">CurrentState</code> variable defines a property that selects the active state, terminating all existing coroutines and initiating the relevant one.</li><li class="listitem" style="list-style-type: disc">Each state coroutine will run on a frame-safe infinite loop for as long as the state is active, allowing the enemy object to update its behavior, as we'll see shortly.</li></ul></div><p>Before proceeding, make sure that the <code class="literal">AI_Enemy</code> script is attached to the NPC object. See <span class="emphasis"><em>Figure 8.6</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_08_06.jpg" alt="Code Sample 8.2"/><div class="caption"><p>Figure 8.6: Attaching the AI script to the NPC character</p></div></div></div></div>
<div class="section" title="The Patrol state"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec76"/>The Patrol state</h1></div></div></div><p>The first of the <a id="id474" class="indexterm"/>three states to implement for the NPC AI is the Patrol State. In the previous chapter, we configured an animated patrol object, which the NPC should follow continuously during this state. The patrol object moves around the level from a predefined animation asset, changing from one position to the next. However, previously, the NPC simply followed this object without end, whereas the Patrol State requires the NPC to consider whether the player can be seen on its route. If it can, the state should change. To support this functionality, the Patrol State and Start function of the <code class="literal">AI_Enemy</code> <a id="id475" class="indexterm"/>class has been coded, as featured in the following code:</p><div class="informalexample"><pre class="programlisting">  void Start()
  {
    //Get random destination
    GameObject[] Destinations = GameObject.FindGameObjectsWithTag("Dest");
    PatrolDestination = Destinations[Random.Range(0, Destinations.Length)].GetComponent&lt;Transform&gt;();

    //Configure starting state
    CurrentState = ENEMY_STATE.PATROL;
  }
  //------------------------------------------
  public IEnumerator AIPatrol()
  {
    //Loop while patrolling
    while(currentstate == ENEMY_STATE.PATROL)
    {
      //Set strict search
      ThisLineSight.Sensitity = LineSight.SightSensitivity.STRICT;

      //Chase to patrol position
      ThisAgent.Resume();
      ThisAgent.SetDestination(PatrolDestination.position);

      //Wait until path is computed
      while(ThisAgent.pathPending)
        yield return null;

      //If we can see the target then start chasing
      if(ThisLineSight.CanSeeTarget)
      {
        ThisAgent.Stop();
        CurrentState = ENEMY_STATE.CHASE;
        yield break;
      }

      //Wait until next frame
      yield return null;
    }
  }</pre></div><div class="section" title="Code Sample 8.3"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec31"/>Code Sample 8.3</h2></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">Start</code> <a id="id476" class="indexterm"/>function sets the initial state of the enemy character to Patrol. The coroutine AIPatrol handles this state.</li><li class="listitem" style="list-style-type: disc">The AIPatrol coroutine loops infinitely for as long as the <code class="literal">Patrol</code> state is active. Remember that an infinite loop is not necessarily a bad thing when used in a coroutine and in combination with a yield statement. This allows prolonged behaviors to be coded neatly and easily over time.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">SetDestination</code> function is called to send <code class="literal">NavMeshAgent</code> to the specified destination. This is followed by a <code class="literal">pathPending</code> check, which is a variable of the <code class="literal">NavMeshAgent</code>. This check waits until the <code class="literal">pathPending</code> variable is false, indicating that a full traversable path has been calculated from the source to the destination. For short and simple journeys, a path may be calculated almost immediately, but for paths that are more complex, this can take much longer.</li><li class="listitem" style="list-style-type: disc">During the Patrol state, we constantly check the <code class="literal">LineSight</code> component to determine whether the enemy has a direct line of sight to the player. If so, the enemy changes from the <code class="literal">Patrol</code> state to the <code class="literal">Chase</code> state.</li><li class="listitem" style="list-style-type: disc">Remember that the yield return null statement will pause a coroutine until the next frame.</li></ul></div><p>Now, drag and drop the <code class="literal">AIEnemy</code> script to the NPC character in the scene, if you haven't already. The <code class="literal">Patrol</code> mode is configured to track a moving object, that is, the enemy will follow a moving destination. A moving destination was created in the previous chapter using the <span class="strong"><strong>Animation</strong></span> window to move an object around the scene over time, jumping from one place to another. See <span class="emphasis"><em>Figure 8.7</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_08_07.jpg" alt="Code Sample 8.3"/><div class="caption"><p>Figure 8.7: Creating movable objects</p></div></div><p>To achieve movable objects, create one or more destination object in the scene and assign them a <span class="strong"><strong>Dest</strong></span> tag. Remember that the <code class="literal">start</code> function for <code class="literal">AIEnemy</code> searches the scene for all objects tagged as <span class="strong"><strong>Dest</strong></span> and <a id="id477" class="indexterm"/>it uses these as destination points. See <span class="emphasis"><em>Figure 8.8</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_08_08.jpg" alt="Code Sample 8.3"/><div class="caption"><p>Figure 8.8: Tagging destination objects</p></div></div></div></div>
<div class="section" title="The Chase state"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec77"/>The Chase state</h1></div></div></div><p>The Chase state is the <a id="id478" class="indexterm"/>second of the three in the enemy FSM. This state connects to both the Patrol and Attack states directly. It can be reached in one of two ways. If a patrolling NPC establishes a direct line of sight to the player, then the NPC changes from patrolling to chasing. Conversely, if an attacking NPC falls outside the reach of the player (perhaps because he is running away), the NPC resorts to chasing again. From the chasing state itself, it's possible to move either to the Patrol or Attack state, with the inverse conditions as those, which lead to chase. That is, if the NPC loses sight of the player, it returns to patrolling and, if the NPC reaches within attacking distance of the player, it switches to attacking. Consider the following code sample, which amends the <code class="literal">AIEnemy</code> class to support the chase behavior:</p><div class="informalexample"><pre class="programlisting">  public IEnumerator AIChase()
  {
    //Loop while chasing
    while(currentstate == ENEMY_STATE.CHASE)
    {
      //Set loose search
      ThisLineSight.Sensitity = LineSight.SightSensitivity.LOOSE;

      //Chase to last known position
      ThisAgent.Resume();
      ThisAgent.SetDestination(ThisLineSight.LastKnowSighting);

      //Wait until path is computed
      while(ThisAgent.pathPending)
        yield return null;

      //Have we reached destination?
      if(ThisAgent.remainingDistance &lt;= ThisAgent.stoppingDistance)
      {
        //Stop agent
        ThisAgent.Stop();

        //Reached destination but cannot see player
        if(!ThisLineSight.CanSeeTarget)
          CurrentState = ENEMY_STATE.PATROL;
        else //Reached destination and can see player. Reached attacking distance
          CurrentState = ENEMY_STATE.ATTACK;

        yield break;
      }

      //Wait until next frame
      yield return null;
    }
  }</pre></div><div class="section" title="Code Sample 8.4"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec32"/>Code Sample 8.4</h2></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">AIChase</code> <a id="id479" class="indexterm"/>coroutine is started when the Chase state is entered and, like the Patrol state, it repeats on a frame-safe infinite loop for as long as the state is active.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">remainingDistance</code> member variable of the <code class="literal">NavMeshAgent</code> is used to determine whether the NPC has reached within attacking distance of the player.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">CanSeeTarget</code> Boolean variable of the <code class="literal">LineSight</code> class indicates whether the player is visible and is influential in choosing whether the NPC should return to patrolling.</li></ul></div><p>Excellent work! Now <a id="id480" class="indexterm"/>give the code a test run in the editor and you have an enemy character than can patrol and chase. Splendid!</p></div></div>
<div class="section" title="The Attack state"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec78"/>The Attack state</h1></div></div></div><p>The third and final state <a id="id481" class="indexterm"/>for the NPC is the Attack state, during which the NPC is continually attacking the player. This state can only be reached from the Chase state. During a chase, the NPC must determine whether they have reached within attacking distance. If so, the NPC must change from chasing to attacking. If, during an attack, the player leaves the attacking distance, then the NPC must change from attacking to chasing. Consider the following code sample, which includes the complete <code class="literal">EnemyAI</code> class, with all coded and completed states:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
//------------------------------------------
public class AI_Enemy : MonoBehaviour
{
  //------------------------------------------
  public enum ENEMY_STATE {PATROL, CHASE, ATTACK};
  //------------------------------------------
  public ENEMY_STATE CurrentState
  {
    get{return currentstate;}

    set
    {
      //Update current state
      currentstate = value;

      //Stop all running coroutines
      StopAllCoroutines();

      switch(currentstate)
      {
        case ENEMY_STATE.PATROL:
          StartCoroutine(AIPatrol());
        break;

        case ENEMY_STATE.CHASE:
          StartCoroutine(AIChase());
        break;

        case ENEMY_STATE.ATTACK:
          StartCoroutine(AIAttack());
        break;
      }
    }
  }
  //------------------------------------------
  [SerializeField]
  private ENEMY_STATE currentstate = ENEMY_STATE.PATROL;

  //Reference to line of sight component
  private LineSight ThisLineSight = null;

  //Reference to nav mesh agent
  private NavMeshAgent ThisAgent = null;

  //Reference to player health
  private Health PlayerHealth = null;

  //Reference to player transform
  private Transform PlayerTransform = null;

  //Reference to patrol destination
  private Transform PatrolDestination = null;

  //Damage amount per second
  public float MaxDamage = 10f;
  //------------------------------------------
  void Awake()
  {
    ThisLineSight = GetComponent&lt;LineSight&gt;();
    ThisAgent = GetComponent&lt;NavMeshAgent&gt;();
    PlayerHealth = GameObject.FindGameObjectWithTag("Player").GetComponent&lt;Health&gt;();
    PlayerTransform = PlayerHealth.GetComponent&lt;Transform&gt;();
  }
  //------------------------------------------
  void Start()
  {
    //Get random destination
    GameObject[] Destinations = GameObject.FindGameObjectsWithTag("Dest");
    PatrolDestination = Destinations[Random.Range(0, Destinations.Length)].GetComponent&lt;Transform&gt;();

    //Configure starting state
    CurrentState = ENEMY_STATE.PATROL;
  }
  //------------------------------------------
  public IEnumerator AIPatrol()
  {
    //Loop while patrolling
    while(currentstate == ENEMY_STATE.PATROL)
    {
      //Set strict search
      ThisLineSight.Sensitity = LineSight.SightSensitivity.STRICT;

      //Chase to patrol position
      ThisAgent.Resume();
      ThisAgent.SetDestination(PatrolDestination.position);

      //Wait until path is computed
      while(ThisAgent.pathPending)
        yield return null;

      //If we can see the target then start chasing
      if(ThisLineSight.CanSeeTarget)
      {
        ThisAgent.Stop();
        CurrentState = ENEMY_STATE.CHASE;
        yield break;
      }

      //Wait until next frame
      yield return null;
    }
  }
  //------------------------------------------
  public IEnumerator AIChase()
  {
    //Loop while chasing
    while(currentstate == ENEMY_STATE.CHASE)
    {
      //Set loose search
      ThisLineSight.Sensitity = LineSight.SightSensitivity.LOOSE;

      //Chase to last known position
      ThisAgent.Resume();
      ThisAgent.SetDestination(ThisLineSight.LastKnowSighting);

      //Wait until path is computed
      while(ThisAgent.pathPending)
        yield return null;

      //Have we reached destination?
      if(ThisAgent.remainingDistance &lt;= ThisAgent.stoppingDistance)
      {
        //Stop agent
        ThisAgent.Stop();

        //Reached destination but cannot see player
        if(!ThisLineSight.CanSeeTarget)
          CurrentState = ENEMY_STATE.PATROL;
        else //Reached destination and can see player. Reached attacking distance
          CurrentState = ENEMY_STATE.ATTACK;

        yield break;
      }

      //Wait until next frame
      yield return null;
    }
  }
  //------------------------------------------
  public IEnumerator AIAttack()
  {
    //Loop while chasing and attacking
    while(currentstate == ENEMY_STATE.ATTACK)
    {
      //Chase to player position
      ThisAgent.Resume();
      ThisAgent.SetDestination(PlayerTransform.position);

      //Wait until path is computed
      while(ThisAgent.pathPending)
        yield return null;

      //Has player run away?
      if(ThisAgent.remainingDistance &gt; ThisAgent.stoppingDistance)
      {
        //Change back to chase
        CurrentState = ENEMY_STATE.CHASE;
        yield break;
      }
      else
      {
        //Attack
        PlayerHealth.HealthPoints -= MaxDamage * Time.deltaTime;
      }

      //Wait until next frame
      yield return null;
    }

    yield break;
  }
  //------------------------------------------
}
//------------------------------------------</pre></div><div class="section" title="Code Sample 8.5"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec33"/>Code Sample 8.5</h2></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">AIAttack</code> <a id="id482" class="indexterm"/>coroutine runs on a frame-safe infinite loop for as long as the Attack state is active (the enemy will be attacking during this state).</li><li class="listitem" style="list-style-type: disc">The <code class="literal">MaxDamage</code> variable specifies how much damage the enemy deals to the player per second.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">AIAttack</code> coroutine relies on the <code class="literal">Health</code> component to inflict damage. This is an additional custom component that encodes health. Both the player and enemy should have a health component to represent their health.</li></ul></div><p>The Health script (<code class="literal">Health.cs</code>) is referenced by the <code class="literal">AIEnemy</code> class (the Attack State) to inflict damage on the player. For this reason, the player character needs a <code class="literal">Health</code> component attached. The code for this component is included in the following code sample:</p><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Health : MonoBehaviour 
{
  public float HealthPoints
  {
    get{return healthPoints;}
    set
    {
      healthPoints = value;

      //If health is &lt; 0 then die
      if(healthPoints &lt;= 0)
        Destroy(gameObject);
    }
  }

  [SerializeField]
  private float healthPoints = 100f;
}</pre></div><p>The <code class="literal">Health</code> script is pretty simple. It maintains a numerical health value that, when reduced to <code class="literal">0</code> or below, will destroy the host game object. This should at least be attached to the player character, allowing the NPC to inflict damage on approach. It could, however, also be <a id="id483" class="indexterm"/>attached to the NPC objects, allowing the player to reciprocate an attack. See <span class="emphasis"><em>Figure 8.9</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_08_09.jpg" alt="Code Sample 8.5"/><div class="caption"><p>Figure 8.9: Configuring player health</p></div></div><p>Great, we're almost ready to test this project. First, make a prefab from the enemy object, if you've not already done so, by dragging and dropping the NPC game object from either the <span class="strong"><strong>Scene</strong></span> view or <span class="strong"><strong>Hierarchy</strong></span> panel to the <span class="strong"><strong>Project</strong></span> panel. Then, add as many enemies as you want to the level. See <span class="emphasis"><em>Figure 8.10</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_08_10.jpg" alt="Code Sample 8.5"/><div class="caption"><p>Figure 8.10: Creating an NPC prefab</p></div></div><p>Now, test the level by pressing the play icon on the toolbar and you should have a complete environment in which intelligent enemies can seek, chase, and attack the player with a significant degree of believability. In some cases, you may need to tweak or refine the enemy FOV to better <a id="id484" class="indexterm"/>match your surroundings and character type. Good work! See <span class="emphasis"><em>Figure 8.11</em></span>:</p><div class="mediaobject"><img src="graphics/B05118_08_11.jpg" alt="Code Sample 8.5"/><div class="caption"><p>Figure 8.11: The completed level</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec79"/>Summary</h1></div></div></div><p>Excellent! You've now reached the end of the AI project as well as the end of the book. In completing this project, you've assembled a complete terrain, an NPC prefab, and a series of scripts that work together strategically to create the appearance of intelligence, and this is <span class="emphasis"><em>good enough</em></span> for AI. For games, AI refers to nothing more than <span class="emphasis"><em>intelligent-looking</em></span> objects and the techniques that create them. Great! Furthermore, in reaching the end of this book and completing all four projects, you are now equipped with a varied and critically important skillset to develop professional-grade games in both 2D and 3D.</p></div></body></html>