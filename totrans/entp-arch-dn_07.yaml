- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C4 and Other Approaches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we provided an initial idea of the business goal of
    the sample information system (and application software modules) that we are going
    to build as a practical exercise to follow the principles outlined in this book.
    Talking about principles, while introducing the demo system, we also explained
    how the most important principles in object-oriented programming would apply to
    the design of our system.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the high-level principles have been set, it is time to go a level deeper
    in understanding our sample information system, and we will take advantage of
    this to show a few different methods professionals use. There exist many architectural
    methods and software representations, as we are going to see, and many overlap
    in lots of ways. In fact, some of them are so close that they really are a way
    for their author to mark their individual approach, rather than bringing some
    additional value to the architectural tools. This is the same situation with the
    JavaScript ecosystem, where there are way too many frameworks. Furthermore, it
    becomes even worse every day, with a new team thinking they can solve a problem
    by proposing yet another one. The same thing happens with architectural methods,
    and we have recently been overwhelmed with **clean architecture**, **hexagonal
    architecture**, **onion architecture**, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As the choice of one method over the other is really not important, we will
    only quickly show these methods so that you can choose which one adapts better
    to your way of thinking, or simply mix some interesting bits from many methods,
    as these are merely sets of long-known best practices assembled in a new package
    name. In the case of our sample information system, the **C4 approach** sounded
    interesting to provide a first approach on how it is designed, so this is the
    method that I will focus on to provide more details about. The idea behind the
    C4 architectural framework is to focus on IT systems from a context level to a
    container level, then a component level, and finally, a code level. The four levels
    will be explained as we apply them to our sample system.
  prefs: []
  type: TYPE_NORMAL
- en: Just like with **SOLID principles** in the previous chapter, my goal here is
    not to explain these methods in depth, as there would be no value in writing what
    is already available in more detail on freely available and quality resources.
    My intention is to extract how these methods can be useful to reach a business/IT
    alignment or at least help represent the questions that are related to this same
    subject.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The C4 approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hexagonal architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Onion architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C4 approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C4 approach is about designing a system (or an application) with four different
    levels of granularity, moving from the context level in which the application
    is placed, to the container level that will show the different processes composing
    the application, to the component layer showing the different parts composing
    the process, and finally, to the code level, where we will find the classes and
    interfaces used to create the application. Here is the diagram for this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The levels in the C4 approach](img/B21293_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – The levels in the C4 approach
  prefs: []
  type: TYPE_NORMAL
- en: Each level details the content of the previous level and gives a more detailed
    view of the application. The fact that units of the lower level always have to
    be related to one given unit of the upper layer also helps to correctly share
    responsibilities and maintain a low level of coupling.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will draw the four levels for our sample system
    and software modules to show the methods; at the same time, we will start designing
    our demo a bit further than the business requirements in the previous chapter
    allowed us to do. Note that the following diagrams will not necessarily be the
    exact ones that correspond to the system created at the end of the book; I really
    wanted to show the complete and realistic process of design, so I am drawing these
    at the same time as I design the sample application for the book. Drawing the
    schemas after I got a clear and complete view of the final result would – in my
    opinion – not be as pedagogical and, in some way, I would have felt like cheating.
  prefs: []
  type: TYPE_NORMAL
- en: The context level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the **context level**, our system will be used by the three user profiles
    that were detailed before, namely the editors, the salespersons, and the director
    of DemoEditor. We will consider that the list of users is already present in the
    information system as an Active Directory or something equivalent. The same goes
    for a content management system, which will be considered to already exist for
    binary document management. Finally, we will consider that a module responsible
    for the emission of electronic mail is also available in the overall system. It
    is used to send emails to actors of the system, either to validate some data or
    to inform them of something. Of course, the authors will be represented in the
    context, even if they do not use the internal information system directly. Here
    is a diagram of the context level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – A context-level diagram](img/Figure_7.2_B21293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – A context-level diagram
  prefs: []
  type: TYPE_NORMAL
- en: We could be more detailed on the content of the arrows, but for now, the diagram
    is self-explanatory, and the functions used by the different roles were explained
    in the previous chapter. Our most important center of interest in this diagram
    is the **Demo Editor System** box, and this is the one that we will detail in
    the next level of the C4 architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The container level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the **container level**, we show what the system uses in terms of building
    blocks. Most of the time, these blocks are separated processes. In our case, since
    we have decided to have completely independent services, we will have as many
    containers as API exposition servers. I anticipate a bit on the technical chapters
    of the book, but we will deploy the system as Docker containers, so there is a
    complete match between “containers” in the C4 architecture and “containers” in
    terms of the units of deployment used in Docker or other such technologies.
  prefs: []
  type: TYPE_NORMAL
- en: In the following diagram, the boxes inside the dotted rectangle represent the
    details of the higher-level box corresponding to the Demo Editor system. We can
    still represent the other parts of the Context level, but it’s best practice not
    to detail them, as they are outside the scope of our study. We can detail the
    stream that goes to them (as we did for the **Users directory** arrow, pointing
    from **Single Page Application**), but this is not mandatory, and we can also
    keep arrows that simply point from the system as a whole if we do not want to
    be precise about these streams of data yet (this is what has been done for the
    mail sender and CMS subsystems).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – The container level](img/Figure_7.3_B21293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – The container level
  prefs: []
  type: TYPE_NORMAL
- en: By the way, at this level of reflection, we start considering what the content
    of the streams of data could be, and in this particular case, I realized that
    instead of a CMS, electronic document management could possibly be more appropriate.
    If we consider that this is an external system and not part of the one we are
    designing, we would, in reality, not have the ability to change it. However, since
    there is an interoperation with it, we might be able to influence the protocol
    used to communicate with it, and this is what our analysis is about. From a practical
    point of view, I do not know yet, at the time of writing (remember, I want to
    be as realistic as possible and I have not finished the exercise before writing
    the chapters), whether there will be an Alfresco container, an Azure Storage,
    or a SharePoint 365 site to implement this subsystem. All I know is that I will
    need to pass binary documents and retrieve them, which means something such as
    **Content Management Interoperability Services** (**CMIS**) streams will certainly
    be indicated (CMIS is an interoperability standard for electronic documents).
  prefs: []
  type: TYPE_NORMAL
- en: For now, we have not expressed what is inside each of the boxes. We only know
    that each of them will have its own life cycle as a software application and represent
    a process and a Docker container (a good practice is, indeed, to have one process
    per container only so that all things align well). If we go a bit into the development
    details, it would then be in the right alignment to have a continuous integration
    pipeline for each of these containers and, logically, a git repository for each
    of them as well. But I am anticipating the “hands-on” part of the book. For now,
    let’s dive deeper into one of the boxes, namely **Books repository**, and show
    what it will be composed with, using the third level of the C4 approach, namely
    the component diagram.
  prefs: []
  type: TYPE_NORMAL
- en: The component level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the **component level**, we show the different modules and libraries that
    the executable container will use to accomplish its business requirements. As
    our books repository will expose two contract APIs, we will need a web server
    to support the controllers, a client to call the persistence system, maybe together
    with a repository pattern, a cache component to keep some data locally, and so
    on. This is what is drawn in the following diagram that corresponds to the third
    level in the C4 architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The component level](img/Figure_7.4_B21293_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – The component level
  prefs: []
  type: TYPE_NORMAL
- en: A component may correspond to different names of artifacts, depending on the
    platform that is going to be used. In .NET, components may be assemblies, while
    in Java, they will be JAR archives. Anyhow, this decomposition in components exists
    in basically all programming platforms, even if it appears in different forms.
    For example, in some platforms, components will correspond to separate files,
    while in others, they will be more abstract, through the use of namespaces, for
    example. In any case, there will be ways to group code-level content into coherent
    groups, while still with a lower granularity than the higher level of containers,
    which correspond to entire processes made with several components.
  prefs: []
  type: TYPE_NORMAL
- en: The code level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the reference documentation of the C4 method (available at [https://c4model.com/](https://c4model.com/))
    states, it is important to use diagrams only if they add value. This is something
    I also stressed when presenting the `IDbRepository` pattern will be used and maybe
    a `UnitOfWork` pattern, but the class organization is not clear yet, so there
    is no use in trying to draw the diagram yet.
  prefs: []
  type: TYPE_NORMAL
- en: Also, even if it was for pedagogical reasons, drawing such a diagram would not
    bring much value, since the fourth level of the C4 approach is simply the same
    as a class diagram from **UML** or **Unified Modeling Language**. We will use
    these detailed diagrams if we need to in the following chapters, once we progress
    into the actual making of the system. In the meantime, we are done with the C4
    method used to explain the sample system we want to create, and we will now briefly
    discuss the alternative software architectural design methods, using them to better
    express our context under analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Clean architecture, hexagonal architecture, and other frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What comes next may be a surprise for you in the context of software architecture
    – the choice of an architecture method does not matter much, as long as you have
    a method (or several methods used together, by the way, if you maintain control
    of their interactions and know when to choose one over another). Of course, that
    does not mean you do not need to apply some method when designing the architecture
    of an information system. My point of view after many years of experience in the
    field is that you should find and apply *your* method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, if you try many different existing methods such as hexagonal architecture,
    clean architecture, onion architecture, and other domain-centric approaches, you
    will quickly realize that they offer little more than a different visual approach
    to the same basic principles, which are highly related to the business/IT alignment
    we discussed at the beginning of this book and the principles that have been extracted
    from the SOLID approach, namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The business model (*data structures representing functional concepts* and *business
    rules translated into code*) should be at the core of the architecture. This way,
    it does not depend on anything, which allows easy changes, fast automated testing,
    a lack of external versioning constraints, and lots of other advantages. Most
    importantly, it enables the concentration of the team on the most important thing
    – business alignment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything surrounding this business-aligned core should use some kind of indirection
    to introduce low-coupling and make the evolution of any module of the system easier.
    Everything depends on the business core module, which itself depends on nothing
    else. In addition, these dependencies are easy to modify if necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical architecture patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One last thing before we dive into the details of the methods – here, I will
    only discuss the architectural methods that can apply to the design of an entire
    information system. There are lots of methods that deal with the technical architecture
    of a single application, how it should be structured, how its source code and
    information flow should be organized, what technical layers should be present,
    and even, in some cases, recommendations on how to name things.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the **N-tier architectures** (also called **layer-based**) will
    describe how each set of source code should call another set, from the GUI to
    the service to the application to the database. MVC, MVP, and MVVM architectures
    are slightly less linear and describe how each group of source code would talk
    to only some of them, to ease the evolution and maintenance of the application
    (with generally an emphasis on their visual part).
  prefs: []
  type: TYPE_NORMAL
- en: These architectures can, theoretically, be used at the level of the entire information
    system, but that does not mean much more than applying them to all applications
    that constitute the information system, since they do not say much about how the
    applications should work together. N-tier architecture recommends that software
    blocks should talk to each other using the application layer, but since it does
    not enforce it, lots of old applications interop at the database level, which
    is a catastrophic coupling in most cases and certainly one of the major reasons
    why a vast majority of legacy systems are nowadays unable to evolve. MVC is supposed
    to be applicable at a higher level than just the visual interface, but despite
    this, it does not reach the level of the entire information system. It may be
    just a question of semantics, but I personally tend to classify these methods
    as patterns rather than architectures, since they come from experience rather
    than pure reflection (and there is absolutely no value judgment in this – we need
    both experimental and intellectual approaches to be complete).
  prefs: []
  type: TYPE_NORMAL
- en: Since this book is about the architecture of a whole information system, I have
    focused on the purpose of architectural methods that naturally are applicable
    at such levels. It happens that domain-centric methods typically respond to this
    because they convey the very notion of a business domain, which has to be the
    very first (and unique) way to decompose an information system if you want to
    get a result that is aligned with a business. All technical approaches can work
    on the software and hardware layers, but what we need is methods that work at
    the business capability map level.
  prefs: []
  type: TYPE_NORMAL
- en: Onion architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Onion architecture** pictures a software unit as several concentric circles
    containing, right at the center, the business **domain model**! And around it,
    you will find services (persistence, etc.) and then presentation (a GUI, external
    interfaces, tests, etc.):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Onion architecture](img/Figure_7.5_B21293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Onion architecture
  prefs: []
  type: TYPE_NORMAL
- en: One of the main rules in onion architecture is that all dependencies should
    go from the outer side to the inner layers. This way, again, the core business
    model does not depend on anything, which makes it easy to evolve, while outer
    circles can be changed provided that they do not impact the business (which is
    generally much easier than the reverse – imagine basing your entire business model
    on a proprietary relational database procedures language and trying to change
    to another database engine).
  prefs: []
  type: TYPE_NORMAL
- en: While this method does not insist on levels of indirection, the principle of
    dependency inversion (see the previous chapter for an explanation), together with
    the rule just cited, makes it obvious that interfaces are necessary to implement
    functions such as persistence. And the same goes, of course, for one layer above.
  prefs: []
  type: TYPE_NORMAL
- en: Hexagonal architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Hexagonal architecture** represents a software unit in a hexagonal shape,
    hence its name, with the left part of the hexagon containing interfaces consuming
    the inside (such as a GUI or automated tests), the right part containing adapters
    to functional dependencies (such as persistence, notification service, etc.),
    and right in the middle of it, as you may have guessed, the core, containing the
    business entities and business rules!'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Hexagonal architecture](img/Figure_7.6_B21293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Hexagonal architecture
  prefs: []
  type: TYPE_NORMAL
- en: Hexagonal architecture insists on ports and adapters to organize the communication
    between the different parts of the application, but this is also a rule in the
    onion architecture even if it is not displayed in the same way. This helps us
    remember that interfaces and contracts should always be applied for the dependencies
    not to evolve into hard coupling, which makes it difficult to evolve the system.
  prefs: []
  type: TYPE_NORMAL
- en: As far as the “*hexagonal*” shape goes, it is pure clutter! I intended to draw
    three “clients” of the business domain to stress the point that there is absolutely
    no relationship between the name of the method and a given technical constraint
    or a particular advantage of the technique. In fact, it is explained in the method
    that the hexagonal shape is simply used to preserve enough space to display shapes
    around the central one. How would this be different from circles (used by the
    other approaches cited previously), ovals, or squares? If the hexagonal shape
    does not bring anything conceptually enriching, my personal opinion is that it
    should not be declared in the name of the method.
  prefs: []
  type: TYPE_NORMAL
- en: This may sound like a useless rant against methods, but this is only to make
    it clear that their value really lies in what they have in common and not their
    differences. What really matters is the centrality of the core domain, aligned
    to the business, and the control of the dependencies, but all of this is already
    there in the SOLID principles.
  prefs: []
  type: TYPE_NORMAL
- en: Clean architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Clean architecture** involves basically joining the two approaches presented
    previously while proposing some additional rules. Graphically, it appears very
    similar to the onion architecture, in concentric circles with the business entities
    in the middle, and several layers organized around in the core, evolving to the
    outside in the same direction as dependencies apply.'
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you will find almost everything that has already been explained
    previously in the two other methods, including the fact that the domain model
    must be clean of any technical dependencies, to address its utmost importance
    in the system and to bring all kinds of other benefits such as testability.
  prefs: []
  type: TYPE_NORMAL
- en: Inversion of dependency is also recommended, as the separation of concerns.
    The vocabulary slightly differs, but a quick search on the internet will show
    lots of blog articles about the extreme similarities between the three architectures.
    Clean architecture may be a bit more “guiding” than the others, but it is impossible
    – at the time of writing – to find a documented analysis proving one better, or
    even widely different in results, than the other.
  prefs: []
  type: TYPE_NORMAL
- en: My personal opinion is that these three approaches (onion, hexagonal, and clean
    architecture) are so close to each other in the way they work and in their recommendations
    that you can use one or another without making any real difference in the quality
    of the architecture produced.
  prefs: []
  type: TYPE_NORMAL
- en: What will bring quality is the profound understanding of why these methods exist
    and, in particular, the capacity to create modules that are cleanly separated
    and where you keep control of the dependencies. Cutting concerns and responsibilities
    without strict rules on their relationship will end up in a spaghetti-like system.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, following strict principles where the business domain (the most
    important part) does not have any dependencies and where everything technical
    is interfaced around it, with an indirection layer in between, is what really
    matters. And all three approaches have this in common. The rest is pure details,
    and if you consider, for example, that the hexagonal shape does not bring anything
    to the method, as explained previously, the existence of several methods really
    gives the impression that some of them are there just because their author wanted
    to have their own method.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C4 approach was used in this chapter to detail our demo application from
    four points of view, namely the context in which it is used, the containers it
    uses, and the components and code that it is made of. Diagrams following this
    approach have helped us explain what the sample information system we will create
    is about. We also learned that it is not necessary to create a diagram that completely
    covers the domain of study, but only for the bits these diagrams have value.
  prefs: []
  type: TYPE_NORMAL
- en: Also, lots of architectural methods have emerged in the past decades. Although
    they clearly have value in the design of software applications, and thus in information
    systems, they resemble very much each other in the sense that most recent methods
    are domain-centric; as such, their value can basically be summarized by the two
    principles that we already know, SOLID and business alignment principles, namely
    putting the business functions model first and applying a method to reduce the
    coupling to dependencies. Both of these make the evolution of a system easier.
    I do not have any doubt that these methods may have additional value for software
    organization, and they certainly help you to take a step further than purely technically
    oriented architecture patterns. However, as far as entire systems are concerned,
    the C4 approach explored at the beginning of the chapter should – in my opinion
    – be applied first in a top-down approach, leaving the domain-centric approaches
    as a way of organizing the third level (the components) of the C4 method.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B21293_08.xhtml#_idTextAnchor271), we will start defining more
    precisely the API on which our demonstration system will be based, as these entities
    are definitely the most important technical aspects if you want a freely evolving
    application. In the upcoming chapter, we will start by explaining the concept
    of service orientation and its relation to APIs. In [*Chapter 9*](B21293_09.xhtml#_idTextAnchor318),
    we will use a semantics-based approach to define the business domains of our sample
    application and translate them into actual API contracts. We have talked a lot
    about business domains – in the next two chapters, they will be defined, as well
    as their interactions, for our demonstration system.
  prefs: []
  type: TYPE_NORMAL
