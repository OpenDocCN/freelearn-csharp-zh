- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Hello Blazor
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你好，Blazor
- en: Thank you for picking up your copy of *Web Development with Blazor*. This book
    intends to get you started as quickly and smoothly as possible, chapter by chapter,
    without you having to read this book from cover to cover before getting your Blazor
    on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您选择阅读《使用Blazor进行Web开发》。本书旨在让您尽可能快速、顺畅地开始，逐章进行，无需在开始使用Blazor之前通读全书。
- en: This book will start by guiding you through the most common scenarios you’ll
    come across when you begin your journey with Blazor and will also dive into a
    few more advanced scenarios later on. This book aims to show you what Blazor is
    – Blazor Server, Blazor WebAssembly, Blazor Hybrid, and on top of that, the new
    **Server-Side Rendering** (**SSR**) – and how it all works practically to help
    you avoid traps.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将从引导你了解你在开始Blazor之旅时最常遇到的常见场景开始，稍后还会深入探讨一些更高级的场景。本书旨在向你展示Blazor是什么——Blazor
    Server、Blazor WebAssembly、Blazor Hybrid，以及在此基础上，新的**服务器端渲染**（**SSR**）——以及它如何在实际中工作，帮助你避免陷阱。
- en: This is the book’s third edition; much has happened since the first edition.
    .NET 6 and .NET 7 were released, and for the second edition, I updated the content
    to reflect the changes and the new functionality we got.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的第三版；自第一版以来发生了许多变化。.NET 6和.NET 7已经发布，对于第二版，我更新了内容以反映这些变化和我们所获得的新功能。
- en: This edition has been updated to include all the new things in .NET 8, and let
    me tell you, that is a lot.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本版已更新，包括.NET 8的所有新内容，让我告诉你，那可是一大堆。
- en: I do Blazor presentations all over the world, and there are common questions
    that I get asked a lot. Without going into too much detail, they are often related
    to download size or time when it comes to Blazor WebAssembly and continuous connection
    to Blazor Server. In .NET 8, we can leverage a new mode, SSR, that solves all
    of these problems in one swift blow. Okay, maybe not all problems, but we are
    well on our way to solving them. A common belief is that Blazor is WebAssembly,
    but WebAssembly is just one way of running Blazor. Many books, workshops, and
    blog posts on Blazor focus heavily on WebAssembly.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我在世界各地做Blazor演示，经常有人问我一些常见的问题。不过，我不会过多地深入细节，它们通常与Blazor WebAssembly的下载大小或与Blazor
    Server的持续连接有关。在.NET 8中，我们可以利用一种新模式，SSR，它可以一举解决所有这些问题。好吧，也许不是所有问题，但我们正在朝着解决这些问题的方向前进。一个普遍的看法是Blazor就是WebAssembly，但WebAssembly只是运行Blazor的一种方式。许多关于Blazor的书籍、研讨会和博客文章都高度关注WebAssembly。
- en: This book will cover Blazor WebAssembly, Blazor Server, Blazor Hybrid, and SSR.
    There are a few differences between the different ways of running Blazor; I will
    point them out as we go along.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将涵盖Blazor WebAssembly、Blazor Server、Blazor Hybrid和SSR。运行Blazor的不同方式之间有一些差异；我们将随着内容的展开指出这些差异。
- en: This first chapter will explore where Blazor came from, what technologies made
    Blazor possible, and the different ways of running Blazor. We will also touch
    on which type (Blazor WebAssembly, Blazor Server, or Blazor Hybrid) is best for
    you.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨Blazor的起源，是什么技术使得Blazor成为可能，以及运行Blazor的不同方式。我们还将讨论哪种类型（Blazor WebAssembly、Blazor
    Server或Blazor Hybrid）最适合您。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why Blazor?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择Blazor？
- en: Preceding Blazor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blazor之前
- en: Introducing WebAssembly
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍WebAssembly
- en: Introducing .NET 8
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍.NET 8
- en: Introducing Blazor
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Blazor
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: It is recommended that you have some knowledge of .NET before you start, as
    this book is aimed at .NET developers who want to utilize their skills to make
    interactive web applications. However, it’s more than possible that you will pick
    up a few .NET tricks if you are new to the world of .NET.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你在开始之前对.NET有一些了解，因为本书的目标是针对希望利用其技能制作交互式Web应用的.NET开发者。然而，如果你是.NET世界的初学者，你完全有可能学到一些.NET技巧。
- en: Why Blazor?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Blazor？
- en: Not that long ago, I got asked by a random person on Facebook if I work with
    Blazor.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不久前，有人在Facebook上随机问我是否使用Blazor。
- en: I said, “Yes, yes I do”.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我说：“是的，是的，我在做”。
- en: He then continued with a long remark telling me Blazor would never beat Angular,
    React, or Vue.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 他接着发表了一长串评论，告诉我Blazor永远不会打败Angular、React或Vue。
- en: I see these kinds of remarks quite often, and it’s essential to understand that
    beating other **Single-Page Application** (**SPA**) frameworks has never been
    the goal. This is not *Highlander*, and there can be more than one.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常看到这样的评论，重要的是要理解，打败其他**单页应用程序**（**SPA**）框架从未是我们的目标。这并不是《最后的武士》，可以有多个。
- en: Learning web development has previously been pretty tough. Not only do we need
    to know ASP.NET for the server but we also need to learn an SPA framework like
    React, Angular, or Vue.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 学习网页开发以前相当困难。我们不仅需要了解ASP.NET用于服务器，还需要学习像React、Angular或Vue这样的SPA框架。
- en: But it doesn’t end there. We also need to learn npm, Bower, and Parcel, as well
    as JavaScript or TypeScript.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还没有结束。我们还需要学习npm、Bower和Parcel，以及JavaScript或TypeScript。
- en: We need to understand transpiling and build that into our development pipeline.
    This is, of course, just the tip of the iceberg; depending on the technology,
    we need to explore other rabbit holes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要理解转译并将其纳入我们的开发流程中。这当然只是冰山一角；根据技术不同，我们需要探索其他兔子洞。
- en: Blazor is an excellent choice for .NET developers to write interactive web applications
    without needing to learn (or keep up with) everything we just mentioned. We can
    leverage our existing C# knowledge and the packages we use and share code between
    the server and client.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor是.NET开发者编写交互式网页应用程序的一个优秀选择，无需学习（或跟上）我们刚才提到的所有内容。我们可以利用我们现有的C#知识和我们使用的包，并在服务器和客户端之间共享代码。
- en: I usually say, “Blazor removes all the things I hate about web development.”
    I guess the saying should be, “Blazor *can* remove all the things I hate about
    web development.” With Blazor, it is still possible to do JavaScript interop and
    use JavaScript frameworks or other SPA frameworks from within Blazor, but we don’t
    have to.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常说，“Blazor消除了我对网页开发的所有厌恶。”我想这句话应该是，“Blazor*可以*消除我对网页开发的所有厌恶。”使用Blazor，仍然可以进行JavaScript互操作，并在Blazor中使用JavaScript框架或其他SPA框架，但我们不必这样做。
- en: Blazor has opened a door where I can feel productive and confident I am creating
    a great user experience for my users, with my existing C# knowledge.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor为我打开了一扇门，让我在拥有现有C#知识的基础上，能够感受到高效和自信，为我的用户创造出色的用户体验。
- en: Preceding Blazor
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Blazor之前
- en: You probably didn’t get this book to read about **JavaScript**, but it helps
    to remember that we came from a pre-Blazor time. I recall that time – the dark
    times. Many of the concepts used in Blazor are not that far from those used in
    many JavaScript frameworks, so I will start with a brief overview of where we
    came from.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不会为了阅读关于**JavaScript**的书而选择这本书，但记住我们来自Blazor之前的时代是有帮助的。我记得那个时代——黑暗的时代。Blazor中使用的许多概念与许多JavaScript框架中使用的概念并不遥远，所以我会从简要概述我们从哪里来开始。
- en: 'As developers, we have many different platforms we can develop for, including
    desktop, mobile, games, the cloud (or server side), AI, and even IoT. All these
    platforms have a lot of different languages to choose from, but there is, of course,
    one more platform: the apps that run inside the browser.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们可以为许多不同的平台进行开发，包括桌面、移动、游戏、云（或服务器端）、人工智能，甚至物联网。所有这些平台都有很多不同的语言可供选择，但当然还有一个额外的平台：运行在浏览器内的应用程序。
- en: I have been a web developer for a long time, and I’ve seen code move from the
    server to run within the browser. It has changed the way we develop our apps.
    Frameworks such as Angular, React, Aurelia, and Vue have changed the web from
    reloading the whole page to updating small parts on the fly. This *new* on-the-fly
    update method has enabled pages to load quicker, as the perceived load time has
    been lowered (not necessarily the whole page load).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经是一名网页开发者很长时间了，我见证了代码从服务器迁移到在浏览器中运行。这改变了我们开发应用程序的方式。例如Angular、React、Aurelia和Vue等框架已经将网页从重新加载整个页面转变为动态更新小部分内容。这种*新*的动态更新方法使得页面加载更快，因为感知的加载时间已经降低（不一定是整个页面的加载）。
- en: But for many developers, this is an entirely new skill set – that is, switching
    between a server (most likely C#, if you are reading this book) to a frontend
    developed in JavaScript. Data objects are written in C# in the backend and then
    serialized into JSON, sent via an API, and then deserialized into another object
    written in JavaScript in the frontend.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于许多开发者来说，这是一套全新的技能集——也就是说，从服务器（如果你在读这本书，很可能是C#）切换到用JavaScript开发的客户端。数据对象在服务器端用C#编写，然后序列化为JSON，通过API发送，然后在客户端用JavaScript反序列化为另一个对象。
- en: JavaScript used to work differently in different browsers, which jQuery tried
    to solve by having a common API that was translated into something the web browser
    could understand. Now, the differences between different web browsers are much
    more minor, which has rendered jQuery obsolete in many cases.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript在不同浏览器中的工作方式曾经不同，jQuery通过提供一个通用的API来解决这个问题，该API被转换成浏览器可以理解的东西。现在，不同浏览器之间的差异要小得多，这在许多情况下已经使jQuery变得过时。
- en: JavaScript differs slightly from other languages since it is not object-oriented
    or typed, for example. In 2010, Anders Hejlsberg (known for being C#, Delphi,
    and Turbo Pascal’s original language designer) started working on **TypeScript**.
    This object-oriented language can be compiled/transpiled into JavaScript.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 与其他语言略有不同，因为它不是面向对象或强类型的，例如。2010 年，Anders Hejlsberg（以其作为 C#、Delphi
    和 Turbo Pascal 的原始语言设计者而闻名）开始着手开发 **TypeScript**。这种面向对象的语言可以编译/转译成 JavaScript。
- en: You can use Typescript with Angular, React, Aurelia, and Vue, but in the end,
    it is JavaScript that will run the actual code. Simply put, to create interactive
    web applications today using JavaScript/TypeScript, you need to switch between
    languages and choose and keep up with different frameworks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 TypeScript 与 Angular、React、Aurelia 和 Vue 一起使用，但最终，运行实际代码的是 JavaScript。简单来说，要使用
    JavaScript/TypeScript 创建交互式 Web 应用程序，您需要在不同语言之间切换，并选择并跟上不同的框架。
- en: In this book, we will look at this in another way. Even though we will talk
    about JavaScript, our primary focus will be on developing interactive web applications
    mainly using C#.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将以另一种方式来看待这个问题。尽管我们将讨论 JavaScript，但我们的主要关注点将是使用 C# 开发交互式 Web 应用程序。
- en: Now, we know a bit about the history of JavaScript. JavaScript is no longer
    the only language that can run within a browser, thanks to WebAssembly, which
    we will cover in the next section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们了解了一些关于 JavaScript 的历史。由于 WebAssembly 的出现，JavaScript 已不再是唯一可以在浏览器中运行的编程语言，我们将在下一节中介绍
    WebAssembly。
- en: Introducing WebAssembly
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 WebAssembly
- en: In this section, we will look at how **WebAssembly** works. One way of running
    Blazor is by using WebAssembly, but for now, let’s focus on what WebAssembly is.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 **WebAssembly** 的工作原理。运行 Blazor 的一种方式是通过使用 WebAssembly，但到目前为止，让我们先关注
    WebAssembly 是什么。
- en: WebAssembly is a binary instruction format that is compiled and, therefore,
    smaller. It is designed for native speeds, which means that when it comes to speed,
    it is closer to C++ than it is to JavaScript. When loading JavaScript, the JavaScript
    files (or inline JavaScript) are downloaded, parsed, optimized, and JIT-compiled;
    most of those steps are not needed for WebAssembly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 是一种二进制指令格式，它是编译的，因此更小。它设计用于原生速度，这意味着在速度方面，它比 JavaScript 更接近 C++。当加载
    JavaScript 时，JavaScript 文件（或内联 JavaScript）会被下载、解析、优化和 JIT 编译；对于 WebAssembly，这些步骤中的大多数都不需要。
- en: WebAssembly has a very strict security model that protects users from buggy
    or malicious code. It runs within a sandbox and cannot escape that sandbox without
    going through the appropriate APIs. Suppose you want to communicate outside WebAssembly,
    for example, by changing the **Document Object Model** (**DOM**) or downloading
    a file from the web. In that case, you will need to do that with JavaScript interop
    (more on that later; don’t worry – Blazor will solve this for us).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 具有非常严格的安全模型，可以保护用户免受有缺陷或恶意代码的侵害。它在一个沙盒中运行，并且不能不通过适当的 API 就逃离沙盒。假设您想与
    WebAssembly 外部通信，例如，通过更改 **文档对象模型**（**DOM**）或从网络上下载文件。在这种情况下，您将需要使用 JavaScript
    互操作来完成这项工作（稍后我们会详细介绍；不要担心——Blazor 会为我们解决这个问题）。
- en: Let’s look at some code to get a bit more familiar with WebAssembly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些代码，以便更熟悉 WebAssembly。
- en: In this section, we will create an app that sums two numbers and returns the
    result, written in C (to be honest, this is about the level of C I’m comfortable
    with).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个应用程序，该应用程序将两个数字相加并返回结果，使用的是 C（坦白说，这是我能接受的 C 的水平）。
- en: 'We can compile C into WebAssembly but it requires the installation of some
    tooling so we will not do this all the way. The point here is just to give us
    a feeling of how WebAssembly works under the hood. Consider this code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 C 编译成 WebAssembly，但这需要安装一些工具，所以我们不会一直这样做。这里的目的是让我们对 WebAssembly 在底层的工作方式有一个感觉。考虑以下代码：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The result of this will be the number `3`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这的结果将是数字 `3`。
- en: WebAssembly is a stack machine language, which means that it uses a stack to
    perform its operations.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 是一种栈式机器语言，这意味着它使用栈来执行其操作。
- en: 'Consider this code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Most compilers will optimize the code and return `3`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编译器都会优化代码并返回 `3`。
- en: 'But let’s assume that all the instructions should be executed. This is the
    way WebAssembly would do things:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们假设所有指令都应该被执行。这是 WebAssembly 会这样做的方式：
- en: 'It will start by pushing `1` onto the stack (`instruction: i32.const 1`), followed
    by pushing `2` onto the stack (`instruction: i32.const 2`). At this point, the
    stack contains `1` and `2`.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将从将 `1` 压入栈中（`指令：i32.const 1`）开始，然后是 `2` 压入栈中（`指令：i32.const 2`）。此时，栈中包含 `1`
    和 `2`。
- en: Then, we must execute the add instruction (`i32.add`), which will pop (`get`)
    the two top values (`1` and `2`) from the stack, add them up, and push the new
    value onto the stack (`3`).
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须执行 add 指令（`i32.add`），这将弹出（获取）栈顶的两个值（`1` 和 `2`），将它们相加，并将新值推入栈中（`3`）。
- en: This demo shows that we can build WebAssembly from C code. Even though we never
    need to go to this level to understand WebAssembly (Blazor handles all of that
    for us), we will use C code and other libraries compiled into WebAssembly later
    in the book (*Chapter 16*, *Going Deeper into WebAssembly*).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示表明我们可以从 C 代码构建 WebAssembly。尽管我们不需要达到这个水平来理解 WebAssembly（Blazor 为我们处理所有这些），但我们在本书的后面部分（第
    16 章，深入 WebAssembly）将使用编译成 WebAssembly 的 C 代码和其他库。
- en: OTHER LANGUAGES
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言
- en: 'Generally, it is only low-level languages that can be compiled into WebAssembly
    (such as C or Rust). However, there are a plethora of languages that can run on
    top of WebAssembly. Here is a great collection of some of these languages: [https://github.com/appcypher/awesome-wasm-langs](https://github.com/appcypher/awesome-wasm-langs).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，只有底层语言可以被编译成 WebAssembly（例如 C 或 Rust）。然而，有许多语言可以在 WebAssembly 上运行。以下是一些这些语言的优秀集合：[https://github.com/appcypher/awesome-wasm-langs](https://github.com/appcypher/awesome-wasm-langs)。
- en: WebAssembly is super performant (near-native speeds) – so performant that game
    engines have already adopted this technology for that very reason. Unity, as well
    as Unreal Engine, can be compiled into WebAssembly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 的性能非常出色（接近原生速度）——如此出色的性能以至于游戏引擎已经采用了这项技术，正是出于这个原因。Unity 以及 Unreal
    Engine 都可以被编译成 WebAssembly。
- en: 'Here are a couple of examples of games running on top of WebAssembly:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些在 WebAssembly 上运行的游戏的例子：
- en: '**Angry Bots (Unity)**: [https://beta.unity3d.com/jonas/AngryBots/](https://beta.unity3d.com/jonas/AngryBots/)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**愤怒机器人（Unity）**：[https://beta.unity3d.com/jonas/AngryBots/](https://beta.unity3d.com/jonas/AngryBots/)'
- en: '**Doom**: [https://wasm.continuation-labs.com/d3demo/](https://wasm.continuation-labs.com/d3demo/)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Doom**：[https://wasm.continuation-labs.com/d3demo/](https://wasm.continuation-labs.com/d3demo/)'
- en: 'This is a great list of different WebAssembly projects: [https://github.com/mbasso/awesome-wasm](https://github.com/mbasso/awesome-wasm).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不同 WebAssembly 项目的优秀列表：[https://github.com/mbasso/awesome-wasm](https://github.com/mbasso/awesome-wasm)。
- en: This section touched the surface of how WebAssembly works; in most cases, you
    won’t need to know much more. We will dive into how Blazor uses this technology
    later in this chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 本节简要介绍了 WebAssembly 的工作原理；在大多数情况下，你不需要了解更多。我们将在本章的后面部分深入探讨 Blazor 如何使用这项技术。
- en: To write Blazor apps, we can leverage the power of .NET 8, which we’ll look
    at next.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写 Blazor 应用程序，我们可以利用 .NET 8 的力量，我们将在下一节中探讨。
- en: Introducing .NET 8
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 .NET 8
- en: .NET is a platform developed by Microsoft for building different types of applications,
    including web, mobile, and desktop applications. The .NET team has been working
    hard on tightening everything up for us developers for years. They have been making
    everything simpler, smaller, cross-platform, and open source – not to mention
    easier to utilize your existing knowledge of .NET development.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 是微软开发的一个平台，用于构建不同类型的应用程序，包括 Web、移动和桌面应用程序。多年来，.NET 团队一直在努力为我们开发者简化一切。他们一直在使一切变得更简单、更小、跨平台和开源——更不用说更容易利用你现有的
    .NET 开发知识了。
- en: .NET Core was a step toward a more unified .NET. It allowed Microsoft to re-envision
    the whole .NET platform, build it in a completely new way, and make it run on
    even more platforms.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 是向更统一 .NET 的一大步。它允许微软重新构想整个 .NET 平台，以全新的方式构建它，并使其能够在更多平台上运行。
- en: 'There were three different types of .NET runtimes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种不同类型的 .NET 运行时：
- en: .NET Framework (full .NET)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Framework（完整 .NET）
- en: .NET Core
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core
- en: Mono/Xamarin
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mono/Xamarin
- en: Different runtimes had different capabilities and performances. This also meant
    that creating a .NET Core app (for example) had different tooling and frameworks
    that needed to be installed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的运行时有不同的功能和性能。这也意味着创建一个 .NET Core 应用程序（例如）需要安装不同的工具和框架。
- en: .NET 5 was the start of our journey toward one single .NET. With this unified
    toolchain, the experience of creating, running, and so on became the same across
    all the different project types. “Framework” and “Core” were dropped from the
    name. .NET 5 is still modular in a similar way to what we are used to, so we do
    not have to worry that merging all the different .NET versions is going to result
    in a bloated .NET.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 5 是我们迈向单一 .NET 的旅程的开始。有了这个统一的工具链，创建、运行等体验在所有不同的项目类型之间变得相同。“框架”和“Core”已被从名称中删除。.NET
    5 仍然以我们熟悉的方式模块化，所以我们不必担心将所有不同的 .NET 版本合并会导致 .NET 变得臃肿。
- en: Thanks to the .NET platform, you will be able to reach all the platforms we
    talked about at the beginning of this chapter (web, desktop, mobile, games, the
    cloud (or server side), AI, and even IoT) using only C# and with the same tooling.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢 .NET 平台，你将能够使用 C# 和相同的工具链访问我们在本章开头提到的所有平台（Web、桌面、移动、游戏、云（或服务器端）、AI，甚至 IoT）。
- en: Blazor has been around for a while now. In .NET Core 3, the first version of
    Blazor Server was released, and at Microsoft Build in 2020, Microsoft released
    Blazor WebAssembly.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 已经存在一段时间了。在 .NET Core 3 中，Blazor Server 的第一个版本发布，而在 2020 年的 Microsoft
    Build 上，微软发布了 Blazor WebAssembly。
- en: In .NET 5, we got a lot of new components for Blazor – pre-rendering and CSS
    isolation to name a couple of things. Don’t worry; we will go through all these
    things throughout the book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 5 中，我们为 Blazor 获得了许多新组件——例如预渲染和 CSS 隔离等。不用担心；我们将在整本书中逐一介绍这些内容。
- en: In .NET 6, we got even more functionality, like Hot Reload, co-located JavaScript,
    new components, and much more, all of which we will explore throughout the book.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 6 中，我们获得了更多的功能，如热重载、本地 JavaScript、新组件等等，所有这些内容我们将在整本书中探讨。
- en: In .NET 7, we got even more enhancements for Blazor developers. We got performance
    improvements and get/set/after modifiers, among other things.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 7 中，我们为 Blazor 开发者提供了更多的增强功能。包括性能改进和 get/set/after 修饰符等。
- en: In November 2023, Microsoft released .NET 8, and with that, everything changed.
    During development, this new way of developing Blazor apps was called “Blazor
    United,” which is a name they now have updated to simply Blazor. This is the new
    way of creating Blazor applications and it is an awesome way. But let’s save something
    for later chapters as well.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '2023 年 11 月，微软发布了 .NET 8，随之而来的是一切的改变。在开发过程中，这种新的 Blazor 应用程序开发方式被称为“Blazor
    United”，现在他们已经将其更新为简单的 Blazor。这是创建 Blazor 应用程序的新方法，它是一种很棒的方法。但让我们也为后面的章节留一些内容。 '
- en: .NET 8 brought us performance improvements, native Define, better source generators,
    and so much more. It is also an LTS (Long-Term Support) version.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 8 带来了性能改进、原生 Define、更好的源生成器等等。它也是一个 LTS（长期支持）版本。
- en: Looking at the enhancements and number of features, I can only conclude that
    Microsoft believes in Blazor, and so do I.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从增强功能和数量来看，我只能得出结论，微软相信 Blazor，我也相信。
- en: 'Now that you know about some of the surrounding technologies, in the next section,
    it’s time to introduce the main character of this book: Blazor.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了周围的一些技术，在下一节中，我们将介绍这本书的主角：Blazor。
- en: Introducing Blazor
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Blazor
- en: '**Blazor** is an open-source web UI framework. That’s a lot of buzzwords in
    the same sentence, but simply put, it means that you can create interactive web
    applications using HTML, CSS, and C# with full support for bindings, events, forms
    and validation, dependency injection, debugging, and much more, with Blazor. We
    will take a look at these in this book.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**Blazor** 是一个开源的 Web UI 框架。在同一句话中包含这么多术语，简单来说，就是你可以使用 HTML、CSS 和 C# 创建交互式
    Web 应用程序，Blazor 提供了完整的支持，包括绑定、事件、表单和验证、依赖注入、调试等等，我们将在这本书中探讨这些内容。'
- en: In 2017, Steve Sanderson (well-known for creating the Knockout JavaScript framework
    and who works for the ASP.NET team at Microsoft) was about to do a session called
    *Web Apps can’t really do *that*, can they?* at the developer conference NDC Oslo.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 2017 年，Steve Sanderson（因创建 Knockout JavaScript 框架而闻名，并在微软的 ASP.NET 团队工作）在开发者大会
    NDC Oslo 上即将进行一场名为 *Web Apps can’t really do *that*, can they?* 的演讲。
- en: But Steve wanted to show a cool demo, so he thought, *Would it be possible to
    run C# in WebAssembly?* He found an old inactive project on GitHub called *Dot
    Net Anywhere*, which was written in C and used tools (similar to what we just
    did) to compile the C code into WebAssembly.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Steve 想要展示一个酷炫的演示，所以他想着，“是否可以在 WebAssembly 中运行 C#？”，他在 GitHub 上找到一个名为 *Dot
    Net Anywhere* 的旧停用项目，该项目是用 C 编写的，并使用工具（与我们刚刚做的类似）将 C 代码编译成 WebAssembly。
- en: He got a simple console app running in the browser. This would have been a fantastic
    demo for most people, but Steve wanted to take it further. He thought, *Is it
    possible to create a simple web framework on top of this?*, and went on to see
    if he could also get the tooling working.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 他让一个简单的控制台应用程序在浏览器中运行。这对大多数人来说可能是一个精彩的演示，但 Steve 想要更进一步。他想着，“是否可以在其上创建一个简单的
    Web 框架？”，并继续探索是否也可以让工具工作。
- en: When it was time for his session, he had a working sample to create a new project,
    create a to-do list with great tooling support, and run the project in the browser.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当他进行会议时，他有一个可以创建新项目、创建带有出色工具支持的待办事项列表并在浏览器中运行项目的有效示例。
- en: Damian Edwards (the .NET team) and David Fowler (the .NET team) were also at
    the NDC conference. Steve showed them what he was about to demo, and they described
    the event as their heads exploded and their jaws dropped.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Damian Edwards（.NET 团队）和 David Fowler（.NET 团队）也参加了 NDC 会议。Steve 向他们展示了即将演示的内容，他们形容说，他们的头都炸了，下巴都掉了。
- en: And that’s how the prototype of Blazor came into existence.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，Blazor 的原型诞生了。
- en: The name Blazor comes from a combination of **Browser** and **Razor** (which
    is the technology used to combine code and HTML). Adding an *L* made the name
    sound better, but other than that, it has no real meaning or acronym.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 这个名字来自 **Browser** 和 **Razor**（这是用于组合代码和 HTML 的技术）的结合。添加一个 *L* 使名字听起来更好，但除此之外，它没有真正的意义或缩写。
- en: There are a few different flavors of Blazor, including Blazor Server, Blazor
    WebAssembly, Blazor Hybrid (using .NET MAUI), and Server-Side Rendering.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 有几种不同的版本，包括 Blazor Server、Blazor WebAssembly、Blazor Hybrid（使用 .NET MAUI）和服务器端渲染。
- en: The different versions have some pros and cons, all of which I will cover in
    the upcoming sections and chapters.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的版本有一些优点和缺点，所有这些我将在接下来的章节中介绍。
- en: Blazor Server
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blazor Server
- en: 'Blazor Server uses SignalR to communicate between the client and the server,
    as shown in the following diagram:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor Server 使用 SignalR 在客户端和服务器之间进行通信，如下所示：
- en: '![](img/B21849_01_01.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21849_01_01.png)'
- en: 'Figure 1.1: Overview of Blazor Server'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：Blazor Server 概述
- en: '**SignalR** is an open-source, real-time communication library that will create
    a connection between the client and the server. SignalR can use many different
    means of transporting data and automatically selects the best transport protocol
    based on your server and client capabilities. SignalR will always try to use WebSockets,
    which is a transport protocol built into HTML5\. If WebSockets is not enabled,
    it will gracefully fall back to another protocol.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**SignalR** 是一个开源的实时通信库，它将在客户端和服务器之间建立连接。SignalR 可以使用许多不同的数据传输方式，并自动根据您的服务器和客户端能力选择最佳的传输协议。SignalR
    总是会尝试使用 WebSockets，这是一种内置在 HTML5 中的传输协议。如果 WebSockets 未启用，它将优雅地回退到另一个协议。'
- en: Blazor is built with reusable UI elements called **components** (more on components
    in *Chapter 4*, *Understanding Basic Blazor Components*). Each component contains
    C# code and markup. A component can include other components. You can use Razor
    syntax to mix markup and C# code or do everything in C# if you wish. The components
    can be updated by user interaction (pressing a button) or triggers (such as a
    timer).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 是用可重用的 UI 元素构建的，称为 **组件**（关于组件的更多内容请参阅 *第 4 章*，*理解基本 Blazor 组件*）。每个组件都包含
    C# 代码和标记。组件可以包含其他组件。您可以使用 Razor 语法混合标记和 C# 代码，或者如果您愿意，可以在 C# 中完成所有操作。组件可以通过用户交互（按按钮）或触发器（如计时器）进行更新。
- en: The components are rendered into a render tree, a binary representation of the
    DOM containing object states and any properties or values. The render tree will
    keep track of any changes compared to the previous render tree, and then send
    only the things that changed over SignalR using a binary format to update the
    DOM.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 组件被渲染成渲染树，这是 DOM 的二进制表示，包含对象状态以及任何属性或值。渲染树将跟踪与上一个渲染树的任何变化，然后仅通过 SignalR 以二进制格式发送更改的内容来更新
    DOM。
- en: JavaScript will receive the changes on the client side and update the page accordingly.
    If we compare this to traditional ASP.NET, we only render the component itself,
    not the entire page, and we only send over the actual changes to the DOM, not
    the whole page.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 将在客户端接收更改并相应地更新页面。如果我们将其与传统 ASP.NET 进行比较，我们只渲染组件本身，而不是整个页面，并且我们只发送实际更改到
    DOM，而不是整个页面。
- en: 'There are advantages to Blazor Server:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 服务器版有一些优点：
- en: It contains just enough code to establish that the connection is downloaded
    to the client, so the site has a small footprint, which makes the site startup
    really fast.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含足够的代码来确保连接被下载到客户端，因此网站占用空间小，这使得网站启动非常快。
- en: Since everything is rendered on the server, Blazor Server is more SEO-friendly.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于所有内容都在服务器上渲染，Blazor 服务器版对搜索引擎优化（SEO）更友好。
- en: Since we are running on the server, the app can fully utilize the server’s capabilities.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们是在服务器上运行，应用程序可以充分利用服务器的功能。
- en: The site will work on older web browsers that don’t support WebAssembly.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该网站将在不支持 WebAssembly 的旧版网络浏览器上运行。
- en: The code runs on the server and stays on the server; there is no way to decompile
    the code.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码在服务器上运行并停留在服务器上；无法反编译代码。
- en: Since the code is executed on your server (or in the cloud), you can make direct
    calls to services and databases within your organization.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于代码是在您的服务器（或云中）上执行的，您可以直接调用组织内的服务和数据库。
- en: 'There are, of course, some disadvantages to Blazor Server as well:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Blazor 服务器版也有一些缺点：
- en: You need to always be connected to the server since the rendering is done on
    the server. If you have a bad internet connection, the site might not work. The
    big difference compared to a non-Blazor Server site is that a non-Blazor Server
    site can deliver a page and then disconnect until it requests another page. With
    Blazor, that connection (SignalR) must always be connected (minor disconnections
    are okay).
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于渲染是在服务器上完成的，您需要始终连接到服务器。如果您有糟糕的互联网连接，网站可能无法工作。与非 Blazor 服务器网站相比，最大的区别是，非 Blazor
    服务器网站可以发送页面并断开连接，直到请求另一个页面。在 Blazor 中，该连接（SignalR）必须始终连接（轻微断开是可以接受的）。
- en: There is no offline/**PWA** (**Progressive Web App**) mode since it needs to
    be connected.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它需要连接，因此没有离线/**PWA**（**渐进式网络应用**）模式。
- en: Every click or page update must do a round trip to the server, which might result
    in higher latency. It is important to remember that Blazor Server will only send
    the changed data. I have not experienced any slow response times personally.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次点击或页面更新都必须进行往返服务器，这可能会导致更高的延迟。重要的是要记住，Blazor 服务器只会发送更改后的数据。我个人没有经历过任何缓慢的响应时间。
- en: Since we have to have a connection to the server, the load on that server increases
    and makes scaling difficult. To solve this problem, you can use the Azure SignalR
    hub to handle the constant connections and let your server concentrate on delivering
    content.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们必须与服务器建立连接，服务器的负载增加，这使得扩展变得困难。为了解决这个问题，您可以使用 Azure SignalR 集线器来处理持续连接，并让您的服务器专注于内容交付。
- en: Each connection stores the information in the server’s memory, increasing memory
    use and making load balancing more difficult.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个连接都会在服务器的内存中存储信息，这增加了内存使用，并使负载均衡更加困难。
- en: To be able to run Blazor Server, you have to host it on an ASP.NET Core-enabled
    server.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要运行 Blazor 服务器，您必须在启用了 ASP.NET Core 的服务器上托管它。
- en: At my workplace, we already had a large site, so we decided to use Blazor Server
    for our projects. We had a customer portal and an internal CRM tool, and our approach
    was to take one component at a time and convert it into a Blazor component.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的工作场所，我们已经有了一个大型网站，因此我们决定为我们的项目使用 Blazor 服务器。我们有一个客户门户和一个内部 CRM 工具，我们的方法是一次转换一个组件，将其转换为
    Blazor 组件。
- en: We quickly realized that, in most cases, it was faster to remake the component
    in Blazor rather than continue to use ASP.NET MVC and add functionality. The **User
    Experience** (**UX**) for the end-user became even better as we converted.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快意识到，在大多数情况下，重新制作组件在 Blazor 中比继续使用 ASP.NET MVC 并添加功能要快。随着转换，最终用户的**用户体验**（**UX**）甚至变得更好。
- en: The pages loaded faster. We could reload parts of the page as we needed instead
    of the whole page, and so on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载速度更快。我们可以根据需要重新加载页面的一部分，而不是整个页面，等等。
- en: 'We found that Blazor introduced a new problem: the pages became *too* fast.
    Our users didn’t understand whether data had been saved because *nothing happened*;
    things *did* happen, but too fast for the users to notice. Suddenly, we had to
    think more about UX and how to inform the user that something had changed. This
    is, of course, a very positive side effect of Blazor.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现Blazor引入了一个新问题：页面变得*太*快了。我们的用户不明白数据是否已保存，因为*什么都没发生*；事情*确实发生了*，但发生得太快，以至于用户注意不到。突然间，我们不得不更多地考虑用户体验和如何通知用户发生了变化。这当然是Blazor的一个非常积极的副作用。
- en: Blazor Server is not the only way to run Blazor – you can also run it on the
    client (in the web browser) using WebAssembly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor服务器不是运行Blazor的唯一方式——你还可以使用WebAssembly在客户端（网络浏览器）上运行它。
- en: Blazor WebAssembly
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blazor WebAssembly
- en: 'There is another option: instead of running Blazor on a server, you can run
    it inside your web browser using WebAssembly.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个选择：你可以在WebAssembly中运行Blazor，而不是在服务器上运行它。
- en: The Mono runtime is a tool that lets you run programs made with C# and other
    .NET languages on various operating systems, not just Windows.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Mono运行时是一个工具，它允许你在各种操作系统上运行用C#和其他.NET语言编写的程序，而不仅仅是Windows。
- en: Microsoft has taken the Mono runtime (which is written in C) and compiled that
    into WebAssembly.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 微软已经将Mono运行时（用C编写）编译成WebAssembly。
- en: 'The WebAssembly version of Blazor works very similarly to the server version,
    as shown in the following diagram. We have moved everything off the server, and
    it is now running within our web browser:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor的WebAssembly版本与服务器版本非常相似，如下面的图所示。我们已经将所有内容从服务器上移除，现在它正在我们的网络浏览器中运行：
- en: '![](img/B21849_01_02.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21849_01_02.png)'
- en: 'Figure 1.2: Overview of Blazor WebAssembly'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：Blazor WebAssembly概述
- en: A render tree is still created, and instead of running the Razor pages on the
    server, they are now running inside our web browser. Instead of SignalR, since
    WebAssembly doesn’t have direct DOM access, Blazor updates the DOM with direct
    JavaScript interop.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然会创建渲染树，而不是在服务器上运行Razor页面，现在它们正在我们的网络浏览器中运行。由于WebAssembly没有直接的DOM访问，所以Blazor使用直接的JavaScript互操作来更新DOM。
- en: The Mono runtime that’s compiled into WebAssembly is called **dotnet.wasm**.
    The page contains a small piece of JavaScript that will make sure to load `dotnet.wasm`.
    Then, it will download `blazor.boot.json`, a JSON file containing all the files
    the application needs to run, as well as the application’s entry point.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 编译成WebAssembly的Mono运行时称为**dotnet.wasm**。页面包含一小段JavaScript，确保加载`dotnet.wasm`。然后，它将下载`blazor.boot.json`，这是一个包含应用程序运行所需的所有文件的JSON文件，以及应用程序的入口点。
- en: If we look at the default sample site that is created when we start a new Blazor
    project in Visual Studio, the `Blazor.boot.json` file contains 63 dependencies
    that need to be downloaded. All the dependencies get downloaded and the app boots
    up.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看在Visual Studio中启动新Blazor项目时创建的默认示例网站，`Blazor.boot.json`文件包含63个需要下载的依赖项。所有依赖项都会被下载，然后应用程序启动。
- en: As we mentioned previously, `dotnet.wasm` is the mono runtime that’s compiled
    into WebAssembly. It runs .NET DLLs – the ones you have written and the ones from
    .NET Framework (which is needed to run your app) – in your browser.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，`dotnet.wasm`是编译成WebAssembly的Mono运行时。它运行.NET DLLs——你编写的和.NET Framework（运行你的应用程序所需的）——在你的浏览器中。
- en: When I first heard of this, I got a bit of a bad taste. It’s running the whole
    .NET runtime in my browser?! But then, after a while, I realized how amazing that
    is. You can run any .NET Standard DLLs in your web browser.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次听说这件事时，我有点不舒服。整个.NET运行时都在我的浏览器中运行？！但过了一会儿，我意识到这是多么令人惊叹。你可以在你的网络浏览器中运行任何.NET
    Standard DLLs。
- en: In the next chapter, we will look at exactly what happens and in what order
    code gets executed when a WebAssembly app boots up.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨当WebAssembly应用程序启动时，代码的确切执行顺序以及发生了什么。
- en: 'There are, of course, some advantages of Blazor WebAssembly:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Blazor WebAssembly有一些优势：
- en: Since the code runs in the browser, creating a **PWA** is easy.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于代码在浏览器中运行，创建**PWA**很容易。
- en: It does not require a connection to the server. Blazor WebAssembly will work
    offline.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不需要连接到服务器。Blazor WebAssembly将离线工作。
- en: Since we’re not running anything on the server, we can use any backend server
    or file share (no need for a .NET-compatible server in the backend).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们不在服务器上运行任何东西，我们可以使用任何后端服务器或文件共享（不需要后端有.NET兼容的服务器）。
- en: No round trips mean that you can update the screen faster (that is why there
    are game engines that use WebAssembly).
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有往返意味着你可以更快地更新屏幕（这就是为什么有些游戏引擎使用WebAssembly）。
- en: 'There are some disadvantages to Blazor WebAssembly as well:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor WebAssembly也有一些缺点：
- en: Even if we compare it to other large sites, the footprint of Blazor WebAssembly
    is large and there are a large number of files to download.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使与其他大型网站相比，Blazor WebAssembly的足迹也很大，并且需要下载大量文件。
- en: To access any on-site resources, you will need to create a Web API to access
    them. You cannot access the database directly.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要访问任何站内资源，你需要创建一个Web API来访问它们。你不能直接访问数据库。
- en: The code runs in the browser, meaning it can be decompiled. All app developers
    are used to this, but it is perhaps not as common for web developers.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码在浏览器中运行，这意味着它可以被反编译。所有应用开发者都习惯了这一点，但这对网络开发者来说可能并不那么常见。
- en: 'I wanted to put WebAssembly to the test! When I was seven years old, I got
    my first computer, a Sinclair ZX Spectrum. I remember that I sat down and wrote
    the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我想测试一下WebAssembly！当我七岁的时候，我得到了我的第一台电脑，一台Sinclair ZX Spectrum。我记得我坐下来编写了以下内容：
- en: '[PRE2]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That was *my* code; I made the computer write my name on the screen over and
    over!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 那是我的代码；我让电脑反复在屏幕上写我的名字！
- en: That was when I decided that I wanted to become a developer to make computers
    do stuff.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我决定我想成为一名开发者，让电脑做事情的时候。
- en: After becoming a developer, I wanted to revisit my childhood and decided I wanted
    to build a ZX Spectrum emulator. In many ways, the emulator has become my test
    project instead of a simple *Hello World* when I encounter new technology. I’ve
    had it running on a Gadgeteer, Xbox One, and even a HoloLens (to name a few platforms/devices).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 成为开发者后，我想重温我的童年，并决定我想构建一个ZX Spectrum模拟器。在许多方面，模拟器已经成为了我在遇到新技术时的测试项目，而不是一个简单的*Hello
    World*。我曾在Gadgeteer、Xbox One甚至HoloLens（仅举几个平台/设备）上运行它。
- en: But is it possible to run my emulator in Blazor?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但我的模拟器能在Blazor中运行吗？
- en: 'It took me only a couple of hours to get the emulator working with Blazor WebAssembly
    by leveraging my already built .NET Standard DLL; I only had to write the code
    specific to this implementation, such as the keyboard and graphics. This is one
    of the reasons Blazor (both Server and WebAssembly) is so powerful: it can run
    libraries that have already been made. Not only can you leverage your knowledge
    of C# but you can also take advantage of the large ecosystem and .NET community.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我只花了几个小时就通过利用已经构建的.NET Standard DLL使模拟器与Blazor WebAssembly兼容；我只需要编写特定于这个实现的代码，比如键盘和图形。这也是Blazor（无论是服务器端还是WebAssembly）如此强大的原因之一：它可以运行已经制作好的库。你不仅可以利用你的C#知识，还可以利用庞大的生态系统和.NET社区。
- en: 'You can find the emulator here: [http://zxbox.com](http://zxbox.com). This
    is one of my favorite projects to work on, as I keep finding ways to optimize
    and improve the emulator.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到模拟器：[http://zxbox.com](http://zxbox.com)。这是我最喜欢的工作项目之一，因为我一直在找到优化和改进模拟器的方法。
- en: Building interactive web applications used to only be possible with JavaScript.
    Now, we know we can use Blazor WebAssembly and Blazor Server, but which one of
    these new options is the best?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，构建交互式Web应用程序只能使用JavaScript。现在，我们知道我们可以使用Blazor WebAssembly和Blazor Server，但这两个新选项中哪一个才是最好的？
- en: Blazor WebAssembly versus Blazor Server
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blazor WebAssembly与Blazor Server的比较
- en: Which one should we choose? The answer is, as always, it depends. You have seen
    the advantages and disadvantages of both.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该选择哪一个？答案始终是，这取决于。你已经看到了两者的优缺点。
- en: If you have a current site that you want to port over to Blazor, I recommend
    going for the server side; once you have ported it, you can make a new decision
    as to whether you want to go for WebAssembly as well. This way, it is easy to
    port parts of the site, and the debugging experience is better with Blazor Server.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个想要迁移到Blazor的现有网站，我建议选择服务器端；一旦迁移完成，你就可以做出新的决定，是否也要使用WebAssembly。这样，迁移网站的部分就很容易，而且使用Blazor
    Server的调试体验更好。
- en: Suppose your site runs on a mobile browser or another unreliable internet connection.
    In that case, you might consider going for an offline-capable (PWA) scenario with
    Blazor WebAssembly since Blazor Server needs a constant connection.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的网站运行在移动浏览器或另一个不可靠的互联网连接上。在这种情况下，你可能会考虑使用具有离线功能的（PWA）场景和Blazor WebAssembly，因为Blazor
    Server需要一个持续的连接。
- en: The startup time for WebAssembly is a bit slow, but there are ways to combine
    the two hosting models to have the best of both worlds. We will cover this in
    *Chapter 16*, *Going Deeper into WebAssembly*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 的启动时间有点慢，但有一些方法可以将两种托管模型结合起来，以获得两者的最佳效果。我们将在 *第 16 章*，*深入 WebAssembly*
    中介绍这一点。
- en: There is no silver bullet when it comes to this question, but read up on the
    advantages and disadvantages and see how they affect your project and use cases.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题上，没有一劳永逸的解决方案，但请了解其优缺点，并看看它们如何影响您的项目和用例。
- en: With .NET 8, we have more opportunities to mix and match the different technologies,
    so the question becomes less relevant since we can choose to have one specific
    component running Blazor Server and another running Blazor WebAssembly (more on
    that later in this chapter).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 8 中，我们有更多机会混合和匹配不同的技术，因此这个问题变得不那么相关，因为我们可以选择让一个组件运行 Blazor 服务器，另一个运行
    Blazor WebAssembly（关于这一点将在本章后面详细说明）。
- en: We can run Blazor server-side and on the client, but what about desktop and
    mobile apps?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在服务器端和客户端运行 Blazor，但桌面和移动应用怎么办呢？
- en: Blazor Hybrid/.NET MAUI
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blazor 混合/.NET MAUI
- en: .NET MAUI is a cross-platform application framework. The name comes from **.NET
    Multi-platform App UI** and is the next version of Xamarin. We can use traditional
    XAML code to create our cross-platform application just as with Xamarin. However,
    .NET MAUI also targets desktop operating systems that will enable running our
    Blazor app on Windows and even macOS.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 是一个跨平台的应用程序框架。这个名字来源于 **.NET Multi-platform App UI**，是 Xamarin 的下一个版本。我们可以使用传统的
    XAML 代码创建我们的跨平台应用程序，就像在 Xamarin 中一样。然而，.NET MAUI 也针对桌面操作系统，这将使我们能够在 Windows 和
    macOS 上运行我们的 Blazor 应用程序。
- en: .NET MAUI has its own template that enables us to run Blazor inside of a .NET
    MAUI application using a Blazor WebView. This is called Blazor Hybrid. Blazor
    Hybrid works in a similar way to the other hosting models (Blazor Server and Blazor
    WebAssembly). It has a render tree and updates the Blazor WebView, which is a
    browser component in .NET MAUI. This is a bit oversimplified perhaps but we have
    a whole chapter on Blazor Hybrid (*Chapter 18*, *Visiting .NET MAUI*). Using Blazor
    Hybrid, we also get access to native APIs (not only Web APIs), making it possible
    to take our application to another level.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 有自己的模板，使我们能够在 .NET MAUI 应用程序中使用 Blazor WebView 运行 Blazor。这被称为 Blazor
    混合。Blazor 混合的工作方式与其他托管模型（Blazor 服务器和 Blazor WebAssembly）类似。它有一个渲染树，并更新 Blazor
    WebView，这是 .NET MAUI 中的一个浏览器组件。这可能有点过于简化，但我们有一个关于 Blazor 混合的整个章节（*第 18 章*，*访问
    .NET MAUI*）。使用 Blazor 混合，我们还可以访问原生 API（不仅仅是 Web API），使我们的应用达到另一个层次。
- en: We will take a look at .NET MAUI in *Chapter 18*, *Visiting .NET MAUI*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *第 18 章*，*访问 .NET MAUI* 中查看 .NET MAUI。
- en: Sometimes we don’t need interactive components, we just need to render some
    content and be done. In .NET 8, we have a new way of doing that.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们不需要交互式组件，我们只需要渲染一些内容然后完成。在 .NET 8 中，我们有了新的方法来做这件事。
- en: Server-Side Rendering (SSR)
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端渲染 (SSR)
- en: Server-side rendering is the new kid on the Blazor block. It makes it possible
    to use the Razor syntax to build web pages that are rendered server-side just
    like MVC or Razor Pages. This is called Static Server-side Rendering. It has some
    additional features that will keep scrolling in the previous position even though
    the whole page is reloaded, which is called enhanced form navigation. This will
    only render static pages, with no interactivity (with a few exceptions). There
    is also something called streaming rendering that will load the page even faster.
    This mode is called streaming server-side rendering. During long-running tasks,
    streaming rendering will first send the HTML it has and then update the DOM once
    the long-running task is complete, giving it a more interactive feeling.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染是 Blazor 中的新成员。它使得可以使用 Razor 语法构建服务器端渲染的网页，就像 MVC 或 Razor Pages 一样。这被称为静态服务器端渲染。它有一些额外的功能，即使在整个页面重新加载的情况下，也能保持滚动位置，这被称为增强表单导航。这将只渲染静态页面，没有交互性（有一些例外）。还有一种称为流式渲染的方式，可以更快地加载页面。这种模式称为流式服务器端渲染。在长时间运行的任务中，流式渲染会首先发送它拥有的
    HTML，然后在长时间运行的任务完成后更新 DOM，给它带来更互动的感觉。
- en: But sometimes we want interactivity, and choosing between Blazor Server or Blazor
    WebAssembly can be a bit hard. But what if I told you we don’t have to choose
    anymore? We can mix it up.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时我们想要交互性，选择 Blazor 服务器或 Blazor WebAssembly 可能有点困难。但如果我告诉你我们不再需要选择呢？我们可以混合使用。
- en: The feature formerly known as Blazor United
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 之前被称为 Blazor United 的功能
- en: This next feature was called “Blazor United” when Microsoft first spoke of it
    but is now simply part of Blazor, not an extra feature. I still want to mention
    the name because the community still uses it, and chances are you might have heard
    it and are wondering why I am not mentioning it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当微软第一次提到这个功能时，它被称为“Blazor United”，但现在它只是 Blazor 的一部分，而不是一个额外功能。我仍然想提到这个名字，因为社区仍在使用它，而且你很可能已经听说过它，想知道为什么我没有提到它。
- en: 'It is a really cool feature: we can pick and choose what components will run
    using SSR and what components will use Blazor Server, Blazor WebAssembly, or (hope
    you are sitting down for this) a mix of the two. Previously, we had to choose
    one of the two (Blazor Server or Blazor WebAssembly), but now we can combine the
    technologies to get the best of both worlds. We can now tell each component how
    we want it to render and we can mix and match throughout the site. The new “auto”
    feature means the first time our users visit the site, they will run Blazor Server.
    This is to get a quick connection and get data to the user as quickly as possible.
    In the background, the WebAssembly version is downloaded and cached so the next
    time they visit the site, it will use the cached Blazor WebAssembly version. If
    the WebAssembly version can be downloaded and started within 100 milliseconds,
    it will load only the WebAssembly version. If it takes longer, it will start up
    Blazor Server and download in the background. This is one of the ways we can speed
    up the download speed of our Blazor site. We can combine all of these technologies,
    pre-render the content on the server using Static Server-side Rendering, make
    the site interactive using Blazor Server (using SignalR), and then switch over
    to Blazor WebAssembly without the “long” download time.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常酷的功能：我们可以选择和决定哪些组件将使用 SSR 运行，哪些组件将使用 Blazor Server、Blazor WebAssembly
    或（希望你能坐下来听这个）两者的混合。以前，我们不得不在这两者（Blazor Server 或 Blazor WebAssembly）之间选择其一，但现在我们可以结合这些技术，取其精华。我们现在可以告诉每个组件我们希望它如何渲染，并且我们可以在整个网站上混合搭配。新的“自动”功能意味着当我们的用户第一次访问网站时，它将运行
    Blazor Server。这是为了快速建立连接，尽可能快地将数据传送给用户。在后台，WebAssembly 版本将被下载并缓存，以便下次他们访问网站时，它将使用缓存的
    Blazor WebAssembly 版本。如果 WebAssembly 版本可以在 100 毫秒内下载并启动，它将只加载 WebAssembly 版本。如果需要更长的时间，它将启动
    Blazor Server 并在后台下载。这是我们加快 Blazor 网站下载速度的一种方法。我们可以结合所有这些技术，在服务器端使用静态服务器端渲染预先渲染内容，使用
    Blazor Server（使用 SignalR）使网站交互，然后切换到 Blazor WebAssembly 而不花费“长时间”下载。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed how Blazor was created and its underlying technologies,
    such as SignalR and WebAssembly. You also learned about the render tree and how
    the DOM gets updated to give you an understanding of how Blazor works under the
    hood.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 Blazor 的创建及其底层技术，例如 SignalR 和 WebAssembly。你还了解了渲染树以及 DOM 如何更新，以便你了解
    Blazor 在底层是如何工作的。
- en: We got an overview of the different technologies you can use with Blazor, such
    as server-side (Blazor Server), client-side (WebAssembly), desktop, and mobile
    (Blazor Hybrid). This overview should have helped you decide what technology to
    choose for your next project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们概述了你可以与 Blazor 一起使用的不同技术，例如服务器端（Blazor Server）、客户端（WebAssembly）、桌面和移动（Blazor
    Hybrid）。这个概述应该帮助你决定为你的下一个项目选择哪种技术。
- en: We talked about why Blazor is a good choice for .NET developers.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了为什么 Blazor 是 .NET 开发者的一个不错的选择。
- en: We looked at SSR and (according to me) the most exciting feature in .NET 8 for
    Blazor, what was known as Blazor United.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了 SSR 和（据我所知）.NET 8 为 Blazor 提供的最重要的功能，即之前被称为 Blazor United 的功能。
- en: In the upcoming chapters, I will walk you through various scenarios to equip
    you with the knowledge to handle everything from upgrading an old/existing site
    and creating a new server-side site to creating a new WebAssembly site.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将带你了解各种场景，以便你掌握从升级旧/现有网站到创建新的服务器端网站，再到创建新的 WebAssembly 网站的全部知识。
- en: In the next chapter, we’ll get our hands dirty by configuring our development
    environment and creating and examining our first Blazor app.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过配置我们的开发环境并创建和检查我们的第一个 Blazor 应用程序来“动手实践”。
- en: Further reading
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: As a .NET developer, you might be interested in Uno Platform ([https://platform.uno/](https://platform.uno/)),
    which makes it possible to create a UI in XAML and deploy it to many different
    platforms, including WebAssembly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 .NET 开发者，你可能对 Uno Platform ([https://platform.uno/](https://platform.uno/))
    感兴趣，它使得在 XAML 中创建 UI 并将其部署到许多不同的平台成为可能，包括 WebAssembly。
- en: 'If you want to see how the ZX Spectrum emulator is built, you can download
    the source code here: [https://github.com/EngstromJimmy/ZXSpectrum](https://github.com/EngstromJimmy/ZXSpectrum).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解 ZX Spectrum 模拟器的构建过程，可以在此处下载源代码：[https://github.com/EngstromJimmy/ZXSpectrum](https://github.com/EngstromJimmy/ZXSpectrum).
- en: Join our community on Discord
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/WebDevBlazor3e](https://packt.link/WebDevBlazor3e)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/WebDevBlazor3e](https://packt.link/WebDevBlazor3e)'
- en: '![](img/QR_Code2668029180838459906.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2668029180838459906.png)'
