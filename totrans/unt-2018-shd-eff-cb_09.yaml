- en: Screen Effects with Unity Render Textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the screen effects script system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using brightness, saturation, and contrast with screen effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using basic Photoshop-like Blend modes with screen effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Overlay Blend mode with screen effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most impressive aspects of learning to write shaders is the process
    of creating your own screen effects, also known as post effects. With these screen
    effects, we can create stunning real-time images with Bloom, Motion Blur, HDR
    effects, and so on. Most modern games on the market today make heavy use of these
    screen effects for their depth of field effects, Bloom effects, and even color
    correction effects.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](part0026.html#OPEK0-e8c76c858d514bc3b1668fda96f8fa08), *Post
    Processing Stack*, we discussed how to use this with Unity's built-in Post Processing
    Stack, but in this chapter, you will learn how to build up the script system yourself.
    This system will give you the control to create many kinds of screen effects.
    We will cover `RenderTexture`, what the depth buffer is, and how to create effects
    that give you Photoshop-like control over the final rendered image of your game.
    By utilizing screen effects for your games, you not only round out your shader
    writing knowledge, but you will also have the power to create your own incredible
    real-time renders with Unity from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the screen effects script system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of creating screen effects is one in which we grab a full-screen
    image (or texture), use a shader to process its pixels on the GPU, and then send
    it back to Unity's renderer to apply it to the whole rendered image of the game.
    This allows us to perform per-pixel operations on the rendered image of the game
    in real time, giving us a more global artistic control.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine if you had to go through and adjust each material on each object in
    your game to just adjust the contrast of the final look of your game. While not
    impossible, this would take a bit of labor to perform. By utilizing a screen effect,
    we can adjust the screen's final look as a whole, thereby giving us more Photoshop-like
    control over our game's final appearance.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get a screen effect system up and running, we have to set up a single
    script to act as the courier of the game's current rendered image, or what Unity
    calls the `RenderTexture`. By utilizing this script to pass the `RenderTexture`
    to a shader, we can create a flexible system for establishing screen effects.
    For our first screen effect, we are going to create a very simple grayscale effect
    and make our game look black and white. Let's take a look at how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to get our screen effects system up and running, we need to create
    a few assets for our current Unity project. By doing this, we will set ourselves
    up for the steps in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: In the current project, create a new scene to work in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a simple sphere in the scene and assign it a new material (I called mine `RedMat`). This
    new material can be anything, but for our example, we will make a simple red material
    using the Standard Shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, create a new directional light and save the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to create a new C# script and call it `TestRenderImage.cs`. For organization
    purposes, create a folder called `Scripts` from the Project tab to put it in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With all of our assets ready, you should have a simple scene setup, which looks
    similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00182.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to make our grayscale screen effect work, we need a script and shader.
    So, we will complete these two new items here and fill them in with the appropriate
    code to produce our first screen effect. Our first task is to complete the C#
    script. This will get the whole system running. After this, we will complete the
    shader and see the results of our screen effect. Let''s complete our script and
    shader with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `TestRenderImage.cs` C# script and begin by entering a few variables
    that we will need to store important objects and data. Enter the following code
    at the very top of the `TestRenderImage` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for us to edit the screen effect in real time, when the Unity editor
    isn''t playing, we need to enter the following line of code just above the declaration
    of the `TestRenderImage` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As our screen effect is using a shader to perform the pixel operations on our
    screen image, we have to create a material to run the shader. Without this, we
    can''t access the properties of the shader. For this, we will create a C# property
    to check for a material, and create one if it doesn''t find one. Enter the following
    code just after the declaration of the variables from *step 1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We now want to set up some checks in our script to see if the current target
    platform that we are building the Unity game on actually supports image effects.
    If it doesn''t find anything at the start of this script, then the script will
    disable itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To actually grab the rendered image from the Unity renderer, we need to make
    use of the following built-in function that Unity provides us, called `OnRenderImage()`.
    Enter the following code so that we can have access to the current `RenderTexture`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Our screen effect has a variable called `grayScaleAmount` with which we can
    control how much grayscale we want for our final screen effect. So, in this case,
    we need to make the value go from `0` to `1`, where `0` is no grayscale effect
    and `1` is a full grayscale effect. We will perform this operation in the `Update()`
    function, which will be called every frame while the game is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we complete our script by doing a little bit of clean-up on objects
    we created when the script started:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we can now apply this script to the camera, if it compiled without
    errors, in Unity. Let's apply the `TestRenderImage.cs` script to our main camera
    in our scene. You should see the `grayScaleAmount` value and a field for a shader,
    but the script throws an error to the console window. It says that it is missing
    an instance to an object and so won't process appropriately. If you recall from
    *step 4*, we are doing some checks to see whether we have a shader and if the
    current platform supports the shader. As we haven't given the screen effect script
    a shader to work with, then the `curShader` variable is just null, which throws
    an error. Let's continue with our screen effects system by completing the shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new shader called `ScreenGrayscale`. To begin our shader, we will
    populate our `Properties` with some variables so that we can send data to this
    shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our shader is now going to utilize pure CG shader code instead of utilizing
    Unity''s built-in Surface Shader code. This will make our screen effect more optimized
    as we need to work only with the pixels of the `RenderTexture.` So, we will delete
    everything inside of the `Pass` that was there before and create a new `Pass`
    block in our shader and fill it with some new `#pragma` statements that we haven''t
    seen before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to access the data being sent to the shader from the Unity editor,
    we need to create the corresponding variables in our `CGPROGRAM`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, all we need to do is set up our pixel function, in this case called
    `frag()`. This is where the meat of the screen effect is. This function will process
    each pixel of the `RenderTexture` and return a new image to our `TestRenderImage.cs`
    script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, change the `FallBack` line to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The final shader should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the shader is complete, return to Unity and let it compile to see if any
    errors occurred. If not, assign the new shader to the `TestRenderImage.cs` script
    and change the value of the grayscale amount variable. You should see the game
    view go from a colored version of the game to a grayscale version of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00183.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot demonstrates this Screen Effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00184.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With this complete, we now have an easy way to test out new screen effect shaders
    without having to write our whole screen effect system over and over again. Let's
    dive in a little deeper and learn about what's going on with the `RenderTexture`
    and how it is processed throughout its existence.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get a screen effect up and running inside of Unity, we need to create a script
    and shader. The script drives the real-time update in the editor and is also responsible
    for capturing the `RenderTexture` from the main camera and passing it to the shader.
    Once the `RenderTexture` gets to the shader, we can use the shader to perform
    per-pixel operations.
  prefs: []
  type: TYPE_NORMAL
- en: At the start of the script, we perform a few checks to make sure that the current
    selected build platform actually supports screen effects and the shader itself.
    There are instances where a current platform will not support screen effects or
    the shader that we are using. So, the checks that we do in the `Start()` function
    ensure we don't get any errors if the platform doesn't support the screen system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the script passes these checks, we initiate the screen effects system
    by calling the built-in `OnRenderImage()` function. This function is responsible
    for grabbing the `renderTexture`, giving it to the shader using the `Graphics.Blit()`
    function, and returning the processed image to the Unity renderer. You can find
    more information on these two functions at the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnRenderImage`: [http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.OnRenderImage.html](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.OnRenderImage.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Graphics.Blit`:[http://docs.unity3d.com/Documentation/ScriptReference/Graphics.Blit.html](http://docs.unity3d.com/Documentation/ScriptReference/Graphics.Blit.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the current `RenderTexture` reaches the shader, the shader takes it, processes
    it through the `frag()` function, and returns the final color for each pixel.
  prefs: []
  type: TYPE_NORMAL
- en: You can see how powerful this becomes as it gives us Photoshop-like control
    over the final rendered image of our game. These screen effects work sequentially
    like Photoshop layers on top of what the camera sees. When you place these screen
    effects one after the other, they will be processed in that order. These are just
    the bare bones steps to get a screen effect working, but it is the core of how
    the screen effects system works.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our simple screen effect system up and running, let''s take
    a look at some of the other useful information we can obtain from Unity''s renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00185.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'We can actually get the depth of everything in our current game by turning
    on Unity''s built-in Depth mode. Once this is turned on, we can use the depth
    information for a ton of different effects. Let''s take a look at how this is
    done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Duplicate the sphere we created twice and create a plane underneath:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00186.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Create a new shader by duplicating the `ScreenGreyscale` code by selecting it
    and pressing *Ctrl *+ *D*. Once duplicated, rename the script to `SceneDepth`.
    Then double-click on this shader to open it in your script editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will create the main texture (`_MainTex`) property and a property to control
    the power of the scene depth effect. Enter the following code in your shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to create the corresponding variables in our `CGPROGRAM`. We are
    going to add one more variable called `_CameraDepthTexture`. This is a built-in
    variable that Unity has provided us with through the use of the `UnityCG.cginclude`
    file. It gives us the depth information from the camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will complete our depth shader by utilizing a couple of built-in functions
    that Unity provides us with, the `UNITY_SAMPLE_DEPTH()` and `linear01Depth()`
    functions. The first function actually gets the depth information from our `_CameraDepthTexture`
    and produces a single float value for each pixel. The `Linear01Depth()` function
    then makes sure that the values are within the `0`-`1` range by taking this final
    depth value to a power we can control, where the mid-value in the `0`-`1` range
    sits in the scene based off of the camera position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With our shader complete, let's turn our attention to the Unity editor and create
    a new script to work with. Select our `TestRenderImage` script and duplicate it.
    Name this new script `RenderDepth` and open it up in your script editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the script to have the same class name as we renamed it to in the previous
    step (`RenderDepth`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add the `depthPower` variable to the script so that we can let users
    change the value in the editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `OnRenderImage()` function then needs to be updated so that it is passing
    the right value to our shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete our depth screen effect, we need to tell Unity to turn on the depth
    rendering in the current camera. This is done by simply setting the main camera''s
    `depthTextureMode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With all the code set up, save your script and shader and return to Unity to
    let them both compile. Afterward, select the Main Camera, right-click on the TextRenderImage
    component, and select Remove Component. Afterward, attach this new component to
    the object and drag and drop our new shader inside. If no errors are encountered,
    you should see a result similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00187.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s an example of what we can get if we tweak the values even more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00188.gif)'
  prefs: []
  type: TYPE_IMG
- en: Using brightness, saturation, and contrast with screen effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our screen effects system up and running, we can explore how
    to create more involved pixel operations to perform some of the more common screen
    effects found in games today.
  prefs: []
  type: TYPE_NORMAL
- en: Using a screen effect to adjust the overall final colors of your game is crucial
    in giving artists global control over the final look of the game. Techniques such
    as color adjustment sliders allow users to adjust the intensity of the reds, blues,
    and greens of the final rendered game. This concept is also used with techniques
    such as putting a certain tone of color over the whole screen, as seen in something
    like a sepia film effect.
  prefs: []
  type: TYPE_NORMAL
- en: For this particular recipe, we are going to cover some of the more core color
    adjustment operations we can perform on an image. These are brightness, saturation,
    and contrast. Learning how to code these color adjustments gives us a nice base
    from which we can learn the art of screen effects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need to create a couple of new assets. We can utilize the same scene
    as our test scene, but we will need a new script and shader:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene by going to File | New Scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a couple of new objects to the scene, set up some different colored diffuse
    materials, and randomly assign them to the new objects in the scene. This will
    give us a good range of colors to test with our new screen effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00189.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have completed our scene setup and created our new script and shader,
    we can begin to fill in the code necessary to achieve the brightness, saturation,
    and contrast screen effects. We will be focusing on just the pixel operation and
    variable setup for our script and shader, since getting a screen effect system
    up and running is described in the *Setting up the screen effects script system*
    recipe in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shader by duplicating the `ScreenGreyscale` code by selecting it
    from the Project tab under the `Chapter 9 `| `Shaders` folder and pressing *Ctrl*
    + *D*. Once duplicated, rename the script to `ScreenBSC`. Then double-click on
    this shader to open it in your script editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Editing the shader first makes more sense so that we know what kind of variables
    we will need for our C# script. Let''s begin by entering the appropriate properties
    for our brightness, saturation, and contrast effect. Remember that we need to
    keep the `_MainTex` property in our shader as this is the property that the `RenderTexture`
    targets when creating screen effects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, in order for us to access the data coming in from our properties
    in our `CGPROGRAM`, we need to create the corresponding variables in the `CGPROGRAM`,
    replacing the previous ones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create the operations that will perform the brightness, saturation,
    and contrast effects. Enter the following new function in our shader, just above
    the `frag()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry if it doesn't make sense just yet; all the code will be explained
    in the *How it works* section of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we just need to update our `frag()` function to actually use the `ContrastSaturationBrightness()`
    function. This will process all the pixels of our `RenderTexture` and pass it
    back to our script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With the code entered in the shader, return to the Unity editor to let the
    new shader compile. If there are no errors, we can return to our code editor to
    work on our script. Let''s begin by creating a couple of new lines of code that
    will send the proper data to our shader:'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the shader is finished, let's work on the script needed to make the
    effect show up. From the Project tab, go to the `Chapter 9 `| `Scripts` folder.
    Once there, select the `TestRenderImage` script and duplicate it by pressing *Ctrl*
    + *D*. Rename the newly created script to `RenderBSC`. Once renamed, double-click
    on it to enter your IDE of choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To modify our script, we need to rename the class to match our filename, `RenderBSC`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterward, we need to add the proper variables that will drive the values of
    our screen effect. In this case, we will need a slider for brightness, a slider
    for saturation, and a slider for contrast:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With our variables set up, we now need to tell the script to send the values
    of the variables we created to the shader. We do this in the `OnRenderImage()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, all we need to do is clamp the values of the variables within a range
    that is reasonable. These clamp values are entirely preferential, so you can use
    whichever values you see fit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With the script completed and shader finished, we simply assign our script
    to our Main Camera and our shader to the script, and you should see the effects
    of brightness, saturation, and contrast by manipulating the property values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00190.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows a result you can achieve with this screen effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00191.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows another example of what can be done by adjusting
    the colors of the render image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00192.gif)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we now know how the basic screen effects system works, let's just cover
    the per-pixel operations we created in the `ContrastSaturationBrightness()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The function starts by taking a few arguments. The first and most important
    is the current `RenderTexture`. The other arguments simply adjust the overall
    effect of the screen effect and are represented by sliders in the screen effect's Inspector
    tab. Once the function receives the `RenderTexture` and the adjustment values,
    it declares a few constant values that we use to modify and compare against the
    original `RenderTexture`.
  prefs: []
  type: TYPE_NORMAL
- en: The `luminanceCoeff` variable stores the values that will give us the overall
    brightness of the current image. These coefficients are based on the CIE color
    matching functions and are pretty standard throughout the industry. We can find
    the overall brightness of the image by getting the dot product of the current
    image dotted with these luminance coefficients. Once we have the brightness, we
    simply use a couple of `lerp` functions to blend the grayscale version of the
    brightness operation and the original image, multiplied by the brightness value
    being passed into the function.
  prefs: []
  type: TYPE_NORMAL
- en: Screen effects such as this are crucial to achieving high-quality graphics for
    your games as they let you tweak the final look of your game without you having
    to edit each material in your current game scene.
  prefs: []
  type: TYPE_NORMAL
- en: Using basic Photoshop-like Blend modes with screen effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The screen effects aren't just limited to adjusting the colors of a rendered
    image from our game. We can also use them to combine other images with our `RenderTexture`.
    This technique is no different than creating a new layer in Photoshop and choosing
    a Blend mode to blend two images together or, in our case, a texture with a `RenderTexture`.
    This becomes a very powerful technique as it gives the artists in a production
    environment a way to simulate their blending modes in the game rather than just
    in Photoshop.
  prefs: []
  type: TYPE_NORMAL
- en: For this particular recipe, we are going to take a look at some of the more
    common blend modes, such as Multiply, Add, and Overlay. You will see how simple
    it is to have the power of Photoshop Blend modes in your game.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, we have to get our assets ready. So let''s follow the next few steps
    to get our screen effects system up and running for our new Blend mode screen
    effect:'
  prefs: []
  type: TYPE_NORMAL
- en: We will need another texture to perform our Blend mode effect. In this recipe,
    we will use a grunge-type texture. This will make the effect very obvious when
    we are testing it out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot is the grunge map used in the making of this effect.
    Finding a texture with enough detail and a nice range of grayscale values will
    make for a nice texture to test our new effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00193.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding texture is available in the example code for this book in `Chapter
    9 `| `Textures` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first Blend mode that we will implement is the Multiply blend mode as seen
    in Photoshop. Let''s begin by modifying the code in our shader first:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shader by duplicating the `ScreenGreyscale` code by selecting it
    from the Project tab under the `Chapter 9 `| `Shaders` folder and pressing *Ctrl *+
    *D.* Once duplicated, rename the script to `ScreenBlendMode`. Then, double-click
    on this shader to open it in your script editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to add some new properties so that we have a texture to blend with
    and a slider for an opacity value. Enter the following code in your new shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the corresponding variables in our `CGPROGRAM` so that we can access
    the data from our `Properties` block, replacing the previously created variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We modify our `frag()` function so that it performs the multiply operation
    on our two textures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Save the shader and return to the Unity editor to let the new shader code compile
    and check for errors. If no errors occurred, then we can move on to creating our
    script file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the shader is finished, let's work on the script needed to make the
    effect show up. From the Project tab, go to the `Chapter 09 `| `Scripts` folder.
    Once there, select the `TestRenderImage` script and duplicate it by pressing *Ctrl*
    + *D*. Rename the newly created script to `RenderBlendMode`. Once renamed, double-click
    on it to enter your IDE of choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our first step in modifying our script is to rename the class to match our
    filename, `RenderBlendMode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In our script file, we need to create the corresponding variables. We will
    need a texture so that we can assign one to the shader and a slider to adjust
    the final amount of the Blend mode we want to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to send our variable data to the shader through the `OnRenderImage()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete the script, we simply fill in our `Update()` function so that we
    can clamp the value of the `blendOpacity` variable between a value of `0.0` and
    `1.0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With this complete, we assign the screen effect script to our Main Camera (remove
    the previous `Render BSC` script if it is attached) and add our screen effect
    shader to our script so that it has a shader to use for the per-pixel operations.
    In order for the effect to be fully functional, the script and shader look for
    a texture. You can assign any texture to the Texture field in the Inspector for
    the screen effect script. Once this texture is in place, you will see the effect
    of multiplying this texture over the game''s rendered screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00194.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot demonstrates the screen effect with a smaller `Blend
    Opacity` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00195.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With our first blend mode set up, we can begin to add a couple of simpler blend
    modes to get a better understanding of how easy it is to add more effects and
    really fine-tune the final result in your game. However, first let's break down
    what is happening here.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are starting to gain a ton of power and flexibility in our screen effects
    programming. I am sure that you are now starting to understand how much you can
    do with this simple system in Unity. We can literally replicate the effects of
    Photoshop layer blending modes in our game to give artists the flexibility they
    need to achieve high-quality graphics in a short amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: With this particular recipe, we look at how to multiply two images together,
    add two images together, and perform a screen blending mode, using just a little
    bit of mathematics. When working with Blend modes, you have to think on a per-pixel
    level. For instance, when we are using the multiply blend mode, we literally take
    each pixel from the original `RenderTexture` and multiply it by each pixel of
    the Blend texture. The same goes for the add Blend mode. It is just a simple mathematical
    operation of adding each pixel from the source texture, or `RenderTexture`, to
    the Blend texture.
  prefs: []
  type: TYPE_NORMAL
- en: The screen Blend mode is definitely a bit more involved, but it is actually
    doing the same thing. It takes each image, `RenderTexture`, and Blend texture,
    inverts them, then multiplies them together, and inverts them again to achieve
    the final look. Just as Photoshop blends its textures together using blend modes,
    we can do the same with screen effects.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s continue this recipe by adding a couple more blend modes to our screen
    effect:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the screen effect shader, let''s add the following code to our `frag()`
    function and change the value we are returning to our script. We will also need
    to comment out the multiply blend so that we don''t return that as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the shader file in your IDE of choice and `MonoDevelop` and return to
    the Unity editor to let the shader compile. If no errors occurred, you should
    see a result similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00196.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a simple add blending mode with a figure of `0.5` set for the `Blend
    Opacity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00197.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, this has the opposite effect of multiply because we are adding
    the two images together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s add one more blend mode called a screen blend. This one is
    a little bit more involved, from a mathematical standpoint, but still simple to
    implement. Enter the following code in the `frag()` function of our shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot demonstrates the results of using a screen type Blend
    mode to blend two images together in a screen effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00198.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a screenshot displaying the effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00199.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the Overlay Blend mode with screen effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our final recipe, we are going to take a look at another type of blend mode,
    the Overlay Blend mode. This blend mode actually makes use of some conditional
    statements that determine the final color of each pixel in each channel. So, the
    process of using this type of blend mode requires a bit more coding to work. Let's
    take a look at how this is done in the next few recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin our Overlay Screen effect, we will need to get the code of our shader
    up and running without errors. We can then modify our script file to feed the
    correct data to the shader:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shader by duplicating the `ScreenGreyscale` code and selecting
    it from the Project tab under the `Chapter 9 `| `Shaders` folder and pressing
    *Ctrl* + *D*. Once duplicated, rename the script to `ScreenOverlay`. Then, double-click
    on this shader to open it in your script editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We first need to set up the properties in our `Properties` block. We will use
    the same properties from the previous few recipes in this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to create the corresponding variables in our `CGPROGRAM`, removing
    the previously created ones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for the Overlay Blend effect to work, we will have to process each
    pixel from each channel individually. To do this in a shader, we have to write
    a custom function that will take in a single channel, for instance, the red channel,
    and perform the overlay operation. Enter the following code in the shader just
    below the variable declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to update our `frag()` function to process each channel of our textures
    in order to perform the blending:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'With the code completed in the shader, our effect should be working. Save the
    shader and return to the Unity editor to let the shader compile. Our script is
    already set up; select the Main Camera object. From the Project tab, drag and
    drop the ScreenOverlay shader onto the `Cur Shader` property from the Render Blend
    Mode component in the Inspector tab. Once the shader compiles, you should see
    a result similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00200.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a screenshot using a Blend Opacity of `0.5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00201.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our overlay blend mode is definitely a lot more involved, but if you really
    break down the function, you will notice that it is simply a multiply blend mode
    and screen blend mode. In this case, we are doing a conditional check to apply
    one or the other blend mode to a pixel.
  prefs: []
  type: TYPE_NORMAL
- en: With this particular screen effect, when the overlay function receives a pixel,
    it checks to see whether it is less than `0.5`. If it is, then we apply a modified
    multiply blend mode to that pixel; if it's not, then we apply a modified screen
    blend mode to the pixel. We do this for each pixel for each channel, giving us
    the final RGB pixel values for our screen effect.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are many things that can be done with screen effects.
    It really just depends on the platform and amount of memory you have allocated
    for screen effects. Usually, this is determined throughout the course of a game
    project, so have fun and get creative with your screen effects.
  prefs: []
  type: TYPE_NORMAL
