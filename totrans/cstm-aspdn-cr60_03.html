<html><head></head><body>
		<div><h1 id="_idParaDest-33"><em class="italic"><a id="_idTextAnchor049"/>Chapter 3</em>: Customizing Dependency Injection</h1>
			<p>In this third chapter, we'll take a look at ASP.NET Core <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) and how to customize it to use a different DI container, if needed.</p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li>Using a different DI container</li>
				<li>Exploring the <code>ConfigureServices</code> method</li>
				<li>Using a different <code>ServiceProvider</code></li>
				<li>Introducing Scrutor</li>
			</ul>
			<p>The topics in this chapter refer to the hosting layer of the ASP.NET Core architecture:</p>
			<div><div><img src="img/Figure_2.1_B17996.jpg" alt="Figure 3.1 – ASP.NET Core architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – ASP.NET Core architecture</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor050"/>Technical requirements</h1>
			<p>To follow the descriptions in this chapter, you will need to create an ASP.NET Core MVC application. Open your console, shell, or Bash terminal and change to your working directory. Use the following command to create a new MVC application:</p>
			<pre>dotnet new mvc -n DiSample -o DiSample</pre>
			<p>Now, open the project in Visual Studio by double-clicking the project file, or in Visual Studio Code by typing the following command in the already-open console:</p>
			<pre>cd DiSample
code .</pre>
			<p>All of the code samples in this chapter can be found in the GitHub repository for this book at <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter03">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter03</a>.</p>
			<h1 id="_idParaDest-35">U<a id="_idTextAnchor051"/><a id="_idTextAnchor052"/>sing a different DI container</h1>
			<p>In most projects, you don't really need to use a different DI container. The existing DI implementation in ASP.NET Core supports the main basic features and works both effectively and quickly. However, some other DI containers<a id="_idIndexMarker034"/> support a number of interesting features<a id="_idIndexMarker035"/> you might want to use in your application:</p>
			<ul>
				<li>Create an application<a id="_idIndexMarker036"/> that supports modules as lightweight dependencies using Ninject, for example, modules you might want to put into a specific directory and have them be automatically registered in your application.</li>
				<li>Configure the services in a configuration file outside the application, in an XML or JSON file instead of in C# only. This is a common feature in various DI containers, but not yet supported in ASP.NET Core.</li>
				<li>Add services at runtime, probably because you don't want to have an immutable DI container. This is also a common feature in some DI containers.</li>
			</ul>
			<p>Let's now see how the <code>ConfigureServices</code> method enables you to use alternative DI containers<a id="_idTextAnchor053"/><a id="_idTextAnchor054"/>.</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor055"/>Exploring the ConfigureServices method</h1>
			<p>Let's compare the current <code>ConfigureServices</code> method with a previous long-term support version to see what<a id="_idIndexMarker037"/> has changed. If you created a new ASP.NET Core project using version 3.1 and open <code>Startup.cs</code>, you will find the method to configure the services, which looks like this:</p>
			<pre>public void ConfigureServices(IServiceCollection services)
{
    services.Configure&lt;CookiePolicyOptions&gt;(options =&gt;
    {
        // This lambda determines whether user
        // consent for non-essential cookies is
        // needed for a given request.
         options.CheckConsentNeeded = context =&gt; true;
    });
    services.AddControllersWithViews();
    services.AddRazorPages();
}</pre>
			<p>In contrast, in ASP.NET Core 6.0, there is no <code>Startup.cs</code> anymore, and the configuring of the services is done in <code>Program.cs</code>, which looks like this:</p>
			<pre>var builder = WebApplication.CreateBuilder(args);
// Add services to the container.
builder.Services.AddControllersWithViews();
var app = builder.Build();
// The rest of the file isn't relevant for this chapter</pre>
			<p>In both cases, the method gets <code>IServiceCollection</code>, which is already filled with a bunch of services that are required by ASP.NET Core. This service was added by the hosting services and parts of ASP.NET Core that are executed before the <code>ConfigureServices</code> method was called.</p>
			<p>Inside the method, some more services are added. First, a configuration class that contains cookie policy options is added to <code>ServiceCollection</code>. After that, the <code>AddMvc()</code> method adds another bunch of services required by the MVC framework. So far, we have around 140 services registered to <code>IServiceCollection</code>. However, the service collection isn't the actual DI container.</p>
			<p>The actual DI container is wrapped in the so-called <code>IServiceCollection</code> has an extension method registered to create an <code>IServiceProvider</code> out of the service collection, which you can see in the following code snippet:</p>
			<pre>IServiceProvider provider = services.BuildServiceProvider()</pre>
			<p><code>ServiceProvider</code> contains the immutable container that cannot be changed at runtime. With the default <code>ConfigureServices</code> method, <code>IServiceProvider</code> is created in the background<a id="_idIndexMarker039"/> after this method is called.</p>
			<p>Next, we'll learn more about applying an alternative <code>ServiceProvider</code> as part of the DI customization proc<a id="_idTextAnchor056"/><a id="_idTextAnchor057"/>ess.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor058"/>Using a different ServiceProvider</h1>
			<p>Changing to a different or custom DI container<a id="_idIndexMarker040"/> is relatively easy if the other container already supports ASP.NET Core. Usually, the other container will use <code>IServiceCollection</code> to feed its own container. The third-party DI containers move the already-registered services to the other container by looping over the collection:</p>
			<ol>
				<li>Let's start by using <code>Autofac</code> as a third-party container. Type the following command into your command line to load the NuGet package:<pre><code>Autofac</code> is good for this because you are easily able to see what is happening here.</p></li>
				<li>To register a custom<a id="_idIndexMarker041"/> IoC container, you need to register a different <code>IServiceProviderFactory</code>. In that case, you'll want to use <code>AutofacServiceProviderFactory</code> if you use <code>Autofac</code>. <code>IServiceProviderFactory</code> will create a <code>ServiceProvider</code> instance. The third-party container should provide one, if it supports ASP.NET Core.<p>You should place this small extension method in <code>Program.cs</code> to register <code>AutofacServiceProviderFactory</code> with <code>IHostBuilder</code>:</p><pre>using Autofac;
using Autofac.Extensions.DependencyInjection;
 
namespace DiSample;
public static class IHostBuilderExtension
{
    public static IHostBuilder 
      UseAutofacServiceProviderFactory(
        this IHostBuilder hostbuilder)
    {
        hostbuilder.UseServiceProviderFactory
          &lt;ContainerBuilder&gt;(
        new AutofacServiceProviderFactory());
        return hostbuilder;
    }
}</pre><p>Don't forget to add using statements to <code>Autofac</code> and <code>Autofac.Extensions.DependencyInjection</code>.</p></li>
				<li>To use this extension method, you can use <code>AutofacServiceProvider</code> in <code>Program.cs</code>:<pre>var builder = WebApplication.CreateBuilder(args);
builder.Host.UseAutofacServiceProviderFactory();
// Add services to the container.
builder.Services.AddControllersWithViews();</pre></li>
			</ol>
			<p>This adds the <code>AutofacServiceProviderFactory</code> function to <code>IHostBuilder</code> and enables the <code>Autofac</code> IoC container. If you have<a id="_idIndexMarker042"/> this in place, you will use <code>Autofac</code> if you add services to <code>IServiceCollection</code> using the defau<a id="_idTextAnchor059"/><a id="_idTextAnchor060"/>lt way.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor061"/>Introducing Scrutor</h1>
			<p>You don't always need to replace the existing .NET Core DI container to get and use some cool features. At the beginning<a id="_idIndexMarker043"/> of this chapter, I mentioned the autoregistration of services, which can be done with other DI containers. This can also be done with a nice NuGet package called <code>IServiceCollection</code> to automatically register services with the .NET Core DI contain<a id="_idTextAnchor062"/>er.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Andrew Lock has published a pretty detailed blog post relating to Scrutor. Rather than just repeating<a id="_idIndexMarker044"/> what he said, I suggest that you just go ahead and read that post to learn more about it: <em class="italic">Using Scrutor to automatically register your services with the ASP.NET Core DI container</em>, available at <a href="https://andrewlock.net/using-scrutor-to-automatically-register-your-services-with-the-asp-net-core-di-container/">https://andrewlock.net/using-scrutor-to-automatically-register-your-services-with-the-asp-net-core-di-container/</a>.</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor065"/>Summary</h1>
			<p>Using the approaches we have demonstrated in this chapter, you will be able to use any .NET Standard-compatible DI container to replace the existing one. If the container of your choice doesn't include <code>ServiceProvider</code>, create your own that implements <code>IServiceProvider</code> and uses the DI container inside. If the container of your choice doesn't provide a method to populate the registered services in the container, create your own method. Loop over the registered services and add them to the other container.</p>
			<p>Actually, the last step sounds easy but can be a hard task, because you need to translate all the possible <code>IServiceCollection</code> registrations into registrations of the other container. The complexity of that task depends on the implementation details of the other DI container.</p>
			<p>Anyway, you have the choice to use any DI container that is compatible with .NET Standard. You can change a lot of the default implementations in ASP.NET Core.</p>
			<p>This is also something you can do with the default HTTPS behavior on Windows, which we will learn more about in the next chapter.</p>
		</div>
	</body></html>