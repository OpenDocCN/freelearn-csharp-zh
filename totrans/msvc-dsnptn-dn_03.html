<html><head></head><body>
<div id="_idContainer017">
<h1 class="chapter-number" id="_idParaDest-47"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.2.1">Synchronous Communication between Microservices</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we learned about aggregator patterns and how they help us scope our storage considerations for our microservices. </span><span class="koboSpan" id="kobo.3.2">Now, we will focus on how our services communicate with each other during the application’s runtime. </span></p>
<p><span class="koboSpan" id="kobo.4.1">We have already established that microservices should be autonomous and should handle all operations relating to tranches of the domain operations that are to be completed. </span><span class="koboSpan" id="kobo.4.2">Even though they are autonomous by design, the reality is that some operations require input from multiple services before an end result can be produced. </span></p>
<p><span class="koboSpan" id="kobo.5.1">At that point, we need to consider facilitating communication, where one service will make a call to another, wait on a response, and then take some action based on that said response. </span></p>
<p><span class="koboSpan" id="kobo.6.1">After reading this chapter, we will be able to do the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Understand why microservices need to communicate</span></li>
<li><span class="koboSpan" id="kobo.8.1">Understand synchronous communication with HTTP and gRPC </span></li>
<li><span class="koboSpan" id="kobo.9.1">Understand the disadvantages of microservice communication</span></li>
</ul>
<h1 id="_idParaDest-49"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.10.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.11.1">The code references used in this chapter can be found in the project repository, which is hosted on GitHub at </span><a href="https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch03"><span class="koboSpan" id="kobo.12.1">https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch03</span></a><span class="koboSpan" id="kobo.13.1">.</span></p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.14.1">Use cases for synchronous communication</span></h1>
<p><span class="koboSpan" id="kobo.15.1">Considering </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.16.1">everything that we have covered so far regarding service independence and isolation, you are probably wondering why we need to cover this topic. </span><span class="koboSpan" id="kobo.16.2">The reality is that each service covers a specific tranche of our application’s procedures and operations. </span><span class="koboSpan" id="kobo.16.3">Some operations have multiple steps and parts that need to be completed by different services, and for this reason, it is important to properly scope which service might be needed, when it will be needed, and how to best implement communication between the services. </span></p>
<p><span class="koboSpan" id="kobo.17.1">Interservice communication needs to be efficient. </span><span class="koboSpan" id="kobo.17.2">Given that we are talking about a number of small services interacting to complete an activity, we need to ensure that the implementation is also robust, fault-tolerant, and generally effective. </span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.18.1">Figure 3.1</span></em><span class="koboSpan" id="kobo.19.1"> gives an overview of synchronous communication between microservices:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.20.1"><img alt="Figure 3.1 – One request might require several follow-up calls to additional services " src="image/Figure_3.1_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.21.1">Figure 3.1 – One request might require several follow-up calls to additional services </span></p>
<p><span class="koboSpan" id="kobo.22.1">Now that we </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.23.1">understand why services need to communicate, let us discuss the different challenges that surround interservice communication.</span></p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.24.1">Challenges of microservice communication</span></h2>
<p><span class="koboSpan" id="kobo.25.1">At this </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.26.1">point, we need to accept that we are building a far more complex and distributed system than a monolith would permit. </span><span class="koboSpan" id="kobo.26.2">This comes with its own challenges when navigating the general request-response cycle of a web service call, the appropriate protocols to be used, and how we handle failures or long-running processes. </span><span class="koboSpan" id="kobo.26.3">Generally speaking, we have two broad categories of communication in </span><em class="italic"><span class="koboSpan" id="kobo.27.1">synchronous</span></em><span class="koboSpan" id="kobo.28.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.29.1">asynchronous</span></em><span class="koboSpan" id="kobo.30.1"> communication. </span><span class="koboSpan" id="kobo.30.2">Beyond that, we need to </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.31.1">scope</span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.32.1"> the nature of the operation and make a call accordingly. </span><span class="koboSpan" id="kobo.32.2">If the operation requires an immediate response, then we use synchronous techniques, and for long-running processes that don’t necessarily need a response immediately, we make it asynchronous.</span></p>
<p><span class="koboSpan" id="kobo.33.1">As mentioned before, we need to ensure that our interservice operations boast of the following:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.34.1">Performance</span></strong><span class="koboSpan" id="kobo.35.1">: Performance is always something we have in the back of our minds while developing a solution. </span><span class="koboSpan" id="kobo.35.2">Individually, we need each service to be as performant as possible, but this requirement extends to communication scenarios, too. </span><span class="koboSpan" id="kobo.35.3">We need to ensure that when one service calls another, the call is done using the most efficient method possible. </span><span class="koboSpan" id="kobo.35.4">Since we are predominantly using </span><em class="italic"><span class="koboSpan" id="kobo.36.1">REST APIs</span></em><span class="koboSpan" id="kobo.37.1">, </span><em class="italic"><span class="koboSpan" id="kobo.38.1">HTTP</span></em><span class="koboSpan" id="kobo.39.1"> communication will be the go-to method. </span><span class="koboSpan" id="kobo.39.2">Additionally, we can consider using </span><em class="italic"><span class="koboSpan" id="kobo.40.1">gPRC</span></em><span class="koboSpan" id="kobo.41.1">, which allows us to call a REST API with the benefit</span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.42.1"> of higher throughput and less latency. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.43.1">Resilient</span></strong><span class="koboSpan" id="kobo.44.1">: We need to ensure that our service calls are done via durable channels. </span><span class="koboSpan" id="kobo.44.2">Remember that hardware can fail, or there can be a network outage at the same time as the service call is being executed. </span><span class="koboSpan" id="kobo.44.3">So, we need to consider two patterns that will make our services resilient, </span><em class="italic"><span class="koboSpan" id="kobo.45.1">Retry</span></em><span class="koboSpan" id="kobo.46.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.47.1">Circuit Breaker</span></em><span class="koboSpan" id="kobo.48.1">:</span><em class="italic"> </em><ul><li><strong class="bold"><span class="koboSpan" id="kobo.49.1">Retry pattern</span></strong><span class="koboSpan" id="kobo.50.1">: Transient failures are common and temporary failures can derail an operation’s completion. </span><span class="koboSpan" id="kobo.50.2">However, they tend to go away by themselves, and we would prefer to retry the operation a few times, as opposed to failing the application’s operation completely. </span><span class="koboSpan" id="kobo.50.3">Using this pattern, we retry our service call a few times, based on a configuration, and should we not have any success, trigger a timeout. </span><span class="koboSpan" id="kobo.50.4">For operations that augment the data, we will need to be a bit more careful since the request might get sent and a transient failure might prevent a response from being sent. </span><span class="koboSpan" id="kobo.50.5">This doesn’t mean that the operation wasn’t actually completed, and retrying might lead to unwanted outcomes.</span></li><li><strong class="bold"><span class="koboSpan" id="kobo.51.1">Circuit breaker pattern</span></strong><span class="koboSpan" id="kobo.52.1">: This pattern is used to limit the number of times that we try to make the service call. </span><span class="koboSpan" id="kobo.52.2">Multiple calls might fail because of how long a transient failure takes to resolve itself, or the number of requests going to the service might cause a bottleneck in the available system resources and allocations. </span><span class="koboSpan" id="kobo.52.3">So, with this pattern, we could configure it to limit the amount of time we spend trying to call one service. </span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.53.1">Traced and monitored</span></strong><span class="koboSpan" id="kobo.54.1">: We have established that a single operation can span multiple services. </span><span class="koboSpan" id="kobo.54.2">This brings another challenge in monitoring and tracing activities through all the services, from one originating point. </span><span class="koboSpan" id="kobo.54.3">At this point, we need to ensure that we are using an appropriate tool that can handle distributed logging and aggregate them all into a central place for easier perusal and issue tracking. </span></li>
</ul>
<p><span class="koboSpan" id="kobo.55.1">Now that we </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.56.1">have a clearer picture of why we need to communicate and what challenges we might face, we will look at practical situations for synchronous communication. </span></p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.57.1">Implementing synchronous communication</span></h1>
<p><span class="koboSpan" id="kobo.58.1">Synchronous</span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.59.1"> communication means that we make a direct call from one service to another and wait for a response. </span><span class="koboSpan" id="kobo.59.2">Given all the fail-safes and retry policies that we could implement, we still evaluate the success of the call based on us receiving a response to our call. </span></p>
<p><span class="koboSpan" id="kobo.60.1">In the context of our hospital management system, a simple query from the frontend will need to be done synchronously. </span><span class="koboSpan" id="kobo.60.2">If we need to see all the doctors in the system to present a list to the user, then we need to invoke a direct call to the doctors’ API microservice, which fetches the records from the database and returns the data with, more than likely, a 200 response that depicts success. </span><span class="koboSpan" id="kobo.60.3">Of course, this needs to happen as quickly and efficiently as possible, as we want to reduce the amount of time the user spends waiting on the results to be returned. </span></p>
<p><span class="koboSpan" id="kobo.61.1">There are several methods that we can use to make an API call, and HTTP is the most popular. </span><span class="koboSpan" id="kobo.61.2">Support for HTTP calls exists in most languages and frameworks, with C# and .NET not being exceptions. </span><span class="koboSpan" id="kobo.61.3">Some of the advantages of HTTP come through standardized approaches to reporting; the ability to cache responses or use proxies; standard request and response structures; and standards for response payloads. </span><span class="koboSpan" id="kobo.61.4">The payload of an HTTP request is, generally, in JSON. </span><span class="koboSpan" id="kobo.61.5">While other formats can be used, JSON has become a de facto standard for HTTP payloads given its universal, flexible, and easy-to-use structure for data representation. </span><span class="koboSpan" id="kobo.61.6">RESTful API services that adhere to HTTP standards will represent information available in the form of resources. </span><span class="koboSpan" id="kobo.61.7">In our hospital management system, a resource can be a </span><em class="italic"><span class="koboSpan" id="kobo.62.1">Doctor</span></em><span class="koboSpan" id="kobo.63.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.64.1">Patient</span></em><span class="koboSpan" id="kobo.65.1">, and these resources can be interacted with using standard HTTP verbs such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">GET</span></strong><span class="koboSpan" id="kobo.67.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">POST</span></strong><span class="koboSpan" id="kobo.69.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">PUT</span></strong><span class="koboSpan" id="kobo.71.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">DELETE</span></strong><span class="koboSpan" id="kobo.73.1">. </span></p>
<p><span class="koboSpan" id="kobo.74.1">Now that we can</span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.75.1"> visualize how synchronous HTTP communication happens in a microservice, let us take a look at some coding techniques that we can use in .NET to facilitate communication. </span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.76.1">Implementing HTTP synchronous communication</span></h2>
<p><span class="koboSpan" id="kobo.77.1">In this</span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.78.1"> section, we will be looking at some code examples of HTTP communication for when we want to call an API in a .NET application. </span></p>
<p><span class="koboSpan" id="kobo.79.1">The current standard for HTTP-based API communication is </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">REST</span></strong><span class="koboSpan" id="kobo.81.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.82.1">Representational State Transfer</span></strong><span class="koboSpan" id="kobo.83.1">). </span><span class="koboSpan" id="kobo.83.2">RESTful </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.84.1">APIs expose a set of methods that allow us to access underlying functionality via standard HTTP calls. </span><span class="koboSpan" id="kobo.84.2">Typically, a call or </span><em class="italic"><span class="koboSpan" id="kobo.85.1">request</span></em><span class="koboSpan" id="kobo.86.1"> consists of a URL or endpoint, a verb or method, and some data. </span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.87.1">URL or endpoint</span></strong><span class="koboSpan" id="kobo.88.1">: The </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.89.1">URL of the request is the address or the API and the resource that you are trying to interact with. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.90.1">Verb or method</span></strong><span class="koboSpan" id="kobo.91.1">: The most commonly used verbs are </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">GET</span></strong><span class="koboSpan" id="kobo.93.1"> (to retrieve data), </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">POST</span></strong><span class="koboSpan" id="kobo.95.1"> (to create a record), </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">PUT</span></strong><span class="koboSpan" id="kobo.97.1"> (to update data), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">DELETE</span></strong><span class="koboSpan" id="kobo.99.1"> (to delete data).</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.100.1">Data</span></strong><span class="koboSpan" id="kobo.101.1">: Data accompanies a call, when necessary, in order to have a complete request. </span><span class="koboSpan" id="kobo.101.2">For instance, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">POST</span></strong><span class="koboSpan" id="kobo.103.1"> request to the booking microservice would need to have the details of the booking that needs to be created.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.104.1">The next major part of this conversation comes in the form of a response or HTTP status code. </span><span class="koboSpan" id="kobo.104.2">HTTP defines standard status codes that we use to interpret the success or failure of our request. </span><span class="koboSpan" id="kobo.104.3">The categories of status codes are listed as follows:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.105.1">1xx (Informational)</span></strong><span class="koboSpan" id="kobo.106.1">: This </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.107.1">communicates protocol-level information.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.108.1">2xx (Success)</span></strong><span class="koboSpan" id="kobo.109.1">: This indicates that the request was accepted, and no errors occurred during processing.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.110.1">3xx (Redirection)</span></strong><span class="koboSpan" id="kobo.111.1">: This indicates that an alternative route needs to be taken in order to complete the original request.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.112.1">4xx (Client Error)</span></strong><span class="koboSpan" id="kobo.113.1">: This is the general range for errors that arise from the request, such as poorly formed data (400) or a bad address (404).</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.114.1">5xx (Server Error)</span></strong><span class="koboSpan" id="kobo.115.1">: These are errors that indicate that the server failed to complete the task for some unforeseen reason. </span><span class="koboSpan" id="kobo.115.2">When constructing our services, it is important that we properly document how requests should be formed, as well as ensure that our responses are in keeping with the actual outcomes.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.116.1">In </span><strong class="bold"><span class="koboSpan" id="kobo.117.1">C#</span></strong><span class="koboSpan" id="kobo.118.1">, we have</span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.119.1"> access to a library </span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.120.1">called </span><em class="italic"><span class="koboSpan" id="kobo.121.1">HttpClient</span></em><span class="koboSpan" id="kobo.122.1">, which provides methods that map to each HTTP verb, allowing us to bootstrap our calls and pass in the data that we require for the</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.123.1"> operation. </span><span class="koboSpan" id="kobo.123.2">It is also a good idea to have a list or directory of endpoints to be used. </span><span class="koboSpan" id="kobo.123.3">This can be accomplished through a combination of listing addresses in </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.125.1">, and then we can have a class of constants, where we define the behaviors or resources for the service. </span></p>
<p><span class="koboSpan" id="kobo.126.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.128.1"> file would be decorated with the following block, which allows us to access the service address values from anywhere in our app:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.129.1">
"ApiEndpoints": {
    "DoctorsApi": "DOCTORS_API_ENDPOINT",
    "PatientsApi": "PATIENTS_API_ENDPOINT",
    "DocumentsApi": "DOCUMENTS_API_ENDPOINT"
  }</span></pre>
<p><span class="koboSpan" id="kobo.130.1">The values per service configuration will be relative to the published address of the corresponding web service. </span><span class="koboSpan" id="kobo.130.2">This could be a localhost address for development, a published address on a server, or a container instance. </span><span class="koboSpan" id="kobo.130.3">We will use that base address along with our endpoint, which we can define in our static class. </span></p>
<p><span class="koboSpan" id="kobo.131.1">In order to have consistency in our code, we can implement baseline code for making and handling HTTP requests and responses. </span><span class="koboSpan" id="kobo.131.2">By making the code generic, we pass in our expected class type, the URL, and whatever additional data might be needed. </span><span class="koboSpan" id="kobo.131.3">This code looks</span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.132.1"> something like this: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.133.1">
    public class HttpRepository&lt;T&gt; : IHttpRepository&lt;T&gt; where T : class
    {
        private readonly HttpClient _client;
        public HttpRepository(HttpClient client)
        {
            _client = client;
        }
        public async Task Create(string url, T obj)
        {
            await _client.PostAsJsonAsync(url, obj);
        }
        public async Task Delete(string url, int id)
        {
            await _client.DeleteAsync($"{url}/{id}");
        }
        public async Task&lt;T&gt; Get(string url, int id)
        {
            return await _client.GetFromJsonAsync&lt;T&gt;($"{url}/
              {id}");
        }
        public async Task&lt;T&gt; GetDetails(string url, int id)
        {
            return await _client.GetFromJsonAsync&lt;T&gt;($"{url}/
              {id}/details");
        }
        public async Task&lt;List&lt;T&gt;&gt; GetAll(string url)
        {
            return await _client.
</span><span class="koboSpan" id="kobo.133.2">              GetFromJsonAsync&lt;List&lt;T&gt;&gt;($"{url}");
        }
        public async Task Update(string url, T obj, int id)
        {
            await _client.PutAsJsonAsync($"{url}/{id}", obj);
        }
    }</span></pre>
<p><span class="koboSpan" id="kobo.134.1">The HttpClient </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.135.1">class can be injected into any class and used on the fly, in any ASP.NET Core application. </span><span class="koboSpan" id="kobo.135.2">We create a generic HTTP API client factory class as a wrapper around the </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">HttpClient</span></strong><span class="koboSpan" id="kobo.137.1"> class in order to standardize all RESTful API calls that will originate from the application or microservice. </span><span class="koboSpan" id="kobo.137.2">Any microservice that will need to facilitate RESTful communication with another service, can implement this code and use it accordingly. </span></p>
<p><span class="koboSpan" id="kobo.138.1">Now that we have an idea of how we handle calls through HTTP methods, we can review how we set up gRPC communication between our services. </span></p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.139.1">Implementing gRPC synchronous communication</span></h2>
<p><span class="koboSpan" id="kobo.140.1">At this point, we</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.141.1"> should be comfortable with REST and the HTTP methods of communicating with and between our microservices. </span><span class="koboSpan" id="kobo.141.2">Now, we will pivot into exploring gRPC in a bit more detail. </span></p>
<p><span class="koboSpan" id="kobo.142.1">RPC is short for </span><strong class="bold"><span class="koboSpan" id="kobo.143.1">Remote Procedure Call</span></strong><span class="koboSpan" id="kobo.144.1">, and it allows us to call another service in a manner</span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.145.1"> that resembles making a method call in code. </span><span class="koboSpan" id="kobo.145.2">For this reason, using gRPC in a distributed system works well. </span><span class="koboSpan" id="kobo.145.3">Communications can happen much quicker, and the entire framework is lightweight and performant from the jump. </span><span class="koboSpan" id="kobo.145.4">This is not to say that we should wholly swap all REST methods for gRPC. </span><span class="koboSpan" id="kobo.145.5">We know by now that we simply choose the best tool for our context and make it work accordingly, but it is good to know that gRPC is best used for scenarios where efficiency is paramount. </span></p>
<p><span class="koboSpan" id="kobo.146.1">Indeed, gRPC is fully supported by ASP.NET Core, and this makes it a great candidate for use in our .NET Core-based microservices solution. </span><span class="koboSpan" id="kobo.146.2">Given its contract-based nature, it naturally enforces certain standards and expectations that we try to emulate when creating our own REST API service classes with interfaces. </span><span class="koboSpan" id="kobo.146.3">It starts with a file called a </span><strong class="bold"><span class="koboSpan" id="kobo.147.1">proto</span></strong><span class="koboSpan" id="kobo.148.1">, which</span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.149.1"> is the contract file. </span><span class="koboSpan" id="kobo.149.2">This contract outlines the properties and behaviors that are available and is exposed by the server (or broadcasting microservice).</span></p>
<p><span class="koboSpan" id="kobo.150.1">The code snippets are as follows (parts have been omitted for brevity): </span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.151.1">// Protos/document-search-service.proto</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.152.1">
syntax = "proto3";
option csharp_namespace = "HealthCare.Documents.Api.Protos";
package DocumentSearch;
service DocumentService {
  rpc GetAll (Empty) returns (DocumentList);
  rpc Get (DocumentId) returns (Document);
}
message Empty{}
message Document {
  string patientId = 1;
  string name = 2;
}
message DocumentList{
    repeated Document documents = 1; 
}
message DocumentId {
  string Id = 1;
}</span></pre>
<p><span class="koboSpan" id="kobo.153.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">proto</span></strong><span class="koboSpan" id="kobo.155.1"> class </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.156.1">defines some methods that we want to allow for the document management </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.157.1">service. </span><span class="koboSpan" id="kobo.157.2">We have defined a method to retrieve all documents, and another that will retrieve a document based on the provided ID value. </span><span class="koboSpan" id="kobo.157.3">Now that we have our </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">proto</span></strong><span class="koboSpan" id="kobo.159.1"> defined, we will need to implement our methods in an actual service class: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.160.1">
public class DocumentsService : DocumentService.
</span><span class="koboSpan" id="kobo.160.2">    DocumentServiceBase
    {
        public override Task&lt;Document&gt; Get(DocumentId request, 
              ServerCallContext context)
        {
            return base.Get(request, context);
        }
        public override Task&lt;DocumentList&gt; GetAll(Empty 
              request, ServerCallContext context)
        {
            return base.GetAll(request, context);
        }
    }</span></pre>
<p><span class="koboSpan" id="kobo.161.1">In each method, we can carry out the actions needed to complete the operation, which, in this context, will be our database query and potential data transformation. </span></p>
<p><span class="koboSpan" id="kobo.162.1">Next, we need to ensure that the calling service has a representation of the contract and that it knows how to make the calls. </span><span class="koboSpan" id="kobo.162.2">The following is a sample of how we would connect to the gRPC service at its address, create a client, and make a request for information: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.163.1">
// The port number must match the port of the gRPC server.
</span><span class="koboSpan" id="kobo.163.2">using var channel = GrpcChannel.ForAddress("ADDRESS_OF_
    SERVICE");
var client = new DocumentService. </span><span class="koboSpan" id="kobo.163.3">DocumentService 
    Client(channel);
var document = await client.Get(
                  new DocumentId { Id = "DOCUMENT_ID" });</span></pre>
<p><span class="koboSpan" id="kobo.164.1">Now that we </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.165.1">have seen some code examples of gRPC, let us look at a head-to-head comparison of HTTP REST and gRPC.</span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.166.1">HTTP versus gRPC communication</span></h2>
<p><span class="koboSpan" id="kobo.167.1">We have</span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.168.1"> seen examples of how we can </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.169.1">interact with our services via the HTTP or RESTful methods and the gRPC protocol. </span><span class="koboSpan" id="kobo.169.2">Now, we need to have a clearer picture of when we would choose one method over the other. </span></p>
<p><span class="koboSpan" id="kobo.170.1">The benefits of using REST include the following:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.171.1">Uniformity</span></strong><span class="koboSpan" id="kobo.172.1">: REST </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.173.1">provides a uniform and standard interface for exposing functionality to subscribers. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.174.1">Client-server independence</span></strong><span class="koboSpan" id="kobo.175.1">: There is clear independence between the client and the server applications. </span><span class="koboSpan" id="kobo.175.2">The client only interacts with URIs that have been exposed or are needed for functionality. </span><span class="koboSpan" id="kobo.175.3">The server is oblivious to which clients might be subscribing. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.176.1">Stateless</span></strong><span class="koboSpan" id="kobo.177.1">: The server does not retain information about the requests being made. </span><span class="koboSpan" id="kobo.177.2">It just gets a request and produces a response. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.178.1">Cacheable</span></strong><span class="koboSpan" id="kobo.179.1">: API resources can be cached to allow for faster storage and retrieval of</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.180.1"> information per request. </span></li>
</ul>
<p><span class="koboSpan" id="kobo.181.1">Note that gRPC does have its merits as to why it is being touted as a viable alternative to REST communication. </span><span class="koboSpan" id="kobo.181.2">Some of these merits include the following:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.182.1">Protocol buffers</span></strong><span class="koboSpan" id="kobo.183.1">: Protocol </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.184.1">buffers (or protobufs for short) serialize and deserialize data as binary, leading to higher data transmission speeds and smaller message sizes, given the much higher compression rate.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.185.1">HTTP2</span></strong><span class="koboSpan" id="kobo.186.1">: HTTP2, unlike HTTP 1.1, supports the expected request-response flow, as well as bidirectional communication. </span><span class="koboSpan" id="kobo.186.2">So, if a service receives multiple requests from multiple clients, it can achieve multiplexing by serving many requests and responses simultaneously. </span></li>
</ul>
<p><span class="koboSpan" id="kobo.187.1">You can see </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.188.1">the </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.189.1">obvious and not-so-obvious advantages of using either method for web service creation and communication. </span><span class="koboSpan" id="kobo.189.2">Some developers have deemed gRPC the future, given its lighter weight and more efficient nature. </span><span class="koboSpan" id="kobo.189.3">However, REST APIs remain far more popular, are easier to implement, and have more third-party tool support for code generation and documentation. </span><span class="koboSpan" id="kobo.189.4">Most microservice architecture-based projects are built using REST APIs, and quite frankly, unless you have specific requirements that lead to a gRPC implementation, it might be a risk to adopt gRPC at a larger scale at this stage.</span></p>
<p><span class="koboSpan" id="kobo.190.1">Given that we have explored so much about synchronous communication and the most common methods that are used to facilitate it, let us look at some of the disadvantages that surround having our microservices talk to each other. </span></p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.191.1">Disadvantages of synchronous communication between microservices</span></h1>
<p><span class="koboSpan" id="kobo.192.1">While it is the </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.193.1">go-to method</span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.194.1"> for service-to-service communication, it might not always be the best option at that moment. </span><span class="koboSpan" id="kobo.194.2">Most cases might even prove that it is not the best idea to begin with. </span></p>
<p><span class="koboSpan" id="kobo.195.1">Do remember that our users will be waiting on the result of a service-to-service call to manifest itself to them on the user interface. </span><span class="koboSpan" id="kobo.195.2">That means, for however long this communication is occurring, we have a user or users sitting and waiting on the interface to continue loading and furnish a result. </span></p>
<p><span class="koboSpan" id="kobo.196.1">From an architectural point of view, we are violating one of the key principles of microservice design, which is having services that stand on their own, without knowing much, or preferably, anything, about each other. </span><span class="koboSpan" id="kobo.196.2">By having two services speak, there is knowledge about another service and implementation details being defined, which have very little to do with the service’s core functionality. </span><span class="koboSpan" id="kobo.196.3">Also, this introduces an undesirable level of tight coupling between services, which increases exponentially for each service that needs to speak to another service. </span><span class="koboSpan" id="kobo.196.4">Now a change to one service can have undesired functionality and maintenance effects on the others. </span></p>
<p><span class="koboSpan" id="kobo.197.1">Finally, if we end up with a chain of service calls, this will make it more difficult to track and catch any errors that occur along the calls. </span><span class="koboSpan" id="kobo.197.2">Imagine that we implement a form of </span><em class="italic"><span class="koboSpan" id="kobo.198.1">Chain of Responsibility</span></em><span class="koboSpan" id="kobo.199.1"> with our service calls where one service calls another, and the result is used to call another, and so on. </span><span class="koboSpan" id="kobo.199.2">If we have three service calls happening back-to-back and the first one fails, we will get back an error and won't be able to determine at which point this error occurred. </span><span class="koboSpan" id="kobo.199.3">Another issue could be that we had successful calls, and the first error breaks the chain, thus wasting the usefulness of what has transpired in the chain before that. </span></p>
<p><span class="koboSpan" id="kobo.200.1">It is always good to understand the pros and cons of the techniques that we employ. </span><span class="koboSpan" id="kobo.200.2">I do agree that synchronous communication is sometimes necessary, but we must also be aware of the additional development effort, in both the short and long term, that will be needed as a result of its employment. </span><span class="koboSpan" id="kobo.200.3">At this point, we begin to think of alternatives such as asynchronous communication and event-driven programming. </span></p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.201.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.202.1">In this chapter, we explored quite a few things. </span><span class="koboSpan" id="kobo.202.2">We sought to understand what synchronous communication between web resources is, the protocols that are most commonly used, and the potential pros and cons of these techniques. </span><span class="koboSpan" id="kobo.202.3">We looked, in detail, at how HTTP communication occurs and can be implemented using C# and compared that with gRPC techniques. </span><span class="koboSpan" id="kobo.202.4">Additionally, we compared the two to ensure that we know when the best time would be to use either. </span></p>
<p><span class="koboSpan" id="kobo.203.1">In the next chapter, we will explore asynchronous communication between services, the best practices, and what problems could be solved through this service-to-service communication method. </span></p>
</div>
</body></html>