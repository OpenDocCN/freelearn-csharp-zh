<html><head></head><body>
		<div><h1 id="_idParaDest-235" class="chapter-number"><a id="_idTextAnchor332"/>7</h1>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor333"/>Functors and Monads</h1>
			<p>Moving from higher-order functions and delegates, we step into the world of functors, key players in functional programming. They allow us to work with wrapped values, such as lists or computational outcomes, in a structured way. This chapter explores the following:</p>
			<ul>
				<li>Functors</li>
				<li>Functor laws</li>
				<li>Applicative functors and laws</li>
				<li>Monads and monad laws</li>
			</ul>
			<p>As always, the following are three self-check tasks to help you understand the existing knowledge of functors and monads.</p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor334"/>Task 1 – Functor usage</h1>
			<p>Given a <code>Result&lt;List&lt;Tower&gt;, string&gt;</code> type that represents a list of towers, where <code>Tower</code> is a class containing properties such as <code>Id</code>, <code>Name</code>, and <code>Damage</code>, the task is to use the <a id="_idIndexMarker387"/>functor concept to apply a function to each tower that appends “(Upgraded)” to the end of its name to indicate that the tower has been upgraded:</p>
			<pre class="source-code">
public class Tower
{
    public int Id { get; set; }
    public string Name { get; set; }
    public int Damage { get; set; }
}
public Result&lt;List&lt;Tower&gt;, string&gt; UpgradeTowers(List&lt;Tower&gt; towers)
{
    // Write your code here
}</pre>			<h1 id="_idParaDest-238"><a id="_idTextAnchor335"/>Task 2 – Applicative functor</h1>
			<p>Imagine you have two functions wrapped in the <code>Result</code> type: <code>Result&lt;Func&lt;Tower, bool&gt;, string&gt; ValidateDamage</code> checks whether a tower’s <a id="_idIndexMarker388"/>damage is within acceptable limits, and <code>Result&lt;Func&lt;Tower, bool&gt;, string&gt; ValidateName</code> checks whether the tower’s name meets certain criteria. Given a <code>Result&lt;Tower, string&gt;</code> representing a single tower, use applicative functors to apply both validation functions to the tower, ensuring both validations pass:</p>
			<pre class="source-code">
public Result&lt;Func&lt;Tower, bool&gt;, string&gt; ValidateDamage = new Result&lt;Func&lt;Tower, bool&gt;, string&gt;(tower =&gt; tower.Damage &lt; 100);
public Result&lt;Func&lt;Tower, bool&gt;, string&gt; ValidateName = new Result&lt;Func&lt;Tower, bool&gt;, string&gt;(tower =&gt; tower.Name.Length &gt; 5 &amp;&amp; !tower.Name.Contains("BannedWord"));</pre>			<h1 id="_idParaDest-239"><a id="_idTextAnchor336"/>Task 3 – Monad usage</h1>
			<p>Given a <a id="_idIndexMarker389"/>sequence of operations needed to upgrade a tower—<code>FetchTower</code>, <code>UpgradeTower</code>, and <code>DeployTower</code>—with each potentially failing and returning <code>Result&lt;Tower, string&gt;</code>, use the monad concept to chain these operations together for a given tower ID. Ensure that if any step fails, the entire operation short-circuits and returns the error:</p>
			<pre class="source-code">
public Result&lt;Tower, string&gt; FetchTower(int towerId) { /* Fetches tower based on ID */ }
public Result&lt;Tower, string&gt; UpgradeTower(Tower tower) { /* Upgrades the tower and can fail */ }
public Result&lt;Tower, string&gt; DeployTower(Tower tower) { /* Attempts to deploy the tower */ }</pre>			<p>If you successfully <a id="_idIndexMarker390"/>wrote the solutions for all three tasks, you are awesome! If you struggle or don’t know how to solve the tasks now, don’t worry, you will be awesome after completing this chapter and solving them.</p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor337"/>What’s a functor?</h1>
			<p>Julia decided <a id="_idIndexMarker391"/>to use an analogy from Steve’s game to explain the concept of functors.</p>
			<p>Julia: <em class="italic">Imagine a functor as a special upgrade station in your tower defense game. This station can take any tower and enhance it, but it always outputs a tower - just an </em><em class="italic">improved version.</em></p>
			<p>Steve: <em class="italic">That makes sense. So it’s like a consistent way to transform things without changing their </em><em class="italic">core nature?</em></p>
			<p>The term <strong class="bold">functor</strong> originates from category theory, a field of mathematics that deals with complex structures and mappings. In the world of programming, we adopt a simplified version of this concept to make it practical for data manipulation. In simple terms, functors are specialized containers that can hold data and have the ability to apply a function to every piece of data they hold, while keeping the overall structure intact. Imagine them as magic boxes that transform whatever is inside without altering the box itself.</p>
			<p>However, not every data container that can apply functions to its elements is a functor. There are two laws that a container needs to abide by in order to be counted as a functor:</p>
			<p><code>identity</code> function to a functor should yield <a id="_idIndexMarker393"/>the same functor. In other words, if you map the <code>identity</code> function over a functor, the functor should remain unchanged.</p>
			<p><strong class="bold">Composition law</strong>: Composing <a id="_idIndexMarker394"/>two functions and then mapping <a id="_idIndexMarker395"/>the resulting function over a functor should be the same as first mapping one function over the functor and then mapping the other. This means that functor mappings should be composable in a way that doesn’t depend on the order in which they’re applied.</p>
			<p>I know it may sound a bit complicated, so let’s discuss these laws in detail.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor338"/>Identity law</h2>
			<p>The Identity <a id="_idIndexMarker396"/>law states that the application of the <code>identity</code> function to <a id="_idIndexMarker397"/>our container returns the same container. The “identity function” here is a function that always returns its input. In code, we can represent it with the help of <code>Func&lt;T, T&gt;</code>:</p>
			<pre class="source-code">
Func&lt;T, T&gt; identity = x =&gt; x;</pre>			<p>And the usage of this function can be shown like this:</p>
			<pre class="source-code">
int number = 29;
int result = identity(number);
Console.WriteLine(result);
  // Output: 29
string text = "Hello Functional programming in C# readers!";
string resultText = identity(text);
Console.WriteLine(resultText);
  // Output: Hello Functional programming in C# readers!</pre>			<p>At first glance, the identity function seems useless, but it plays a big role in mathematical proofs in functional programming. Returning to functors, the Identity law means that if we map the identity function to our container, we should return the same result. Let’s move on to the second law.</p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor339"/>Composition law</h2>
			<p>This law <a id="_idIndexMarker398"/>states that either we compose two functions and then <a id="_idIndexMarker399"/>map the result over our container or map these functions consequently; the result will be the same. To understand how it can be applied to our code, let’s first create two functions:</p>
			<pre class="source-code">
Book AddPages(Book book, int pages) =&gt; new Book { Title = book.Title, Pages = book.Pages + pages };
Book AppendSubtitle(Book book, string subtitle) =&gt; new Book { Title = $"{book.Title}: {subtitle}", Pages = book.Pages };</pre>			<p>One function adds pages to the book and returns it; another appends a subtitle to the book’s title <a id="_idIndexMarker400"/>and returns the result. Quite simple, right? Now, with the <a id="_idIndexMarker401"/>help of these functions, we can express our Composition law in code:</p>
			<pre class="source-code">
List&lt;Book&gt; books = new()
{
    new Book { Title = "C# Basics", Pages = 100 },
    new Book { Title = "Advanced C#", Pages = 200 }
};
// Apply AddPages to each book and then apply AppendSubtitle
var sequentialApplicationResult = books.Select(book =&gt; AddPages(book, 50)).Select(book =&gt; AppendSubtitle(book, "Updated Edition"));
// Apply AddPages then AppendSubtitle to each book
var combinedApplicationResult = books.Select(book =&gt; AppendSubtitle(AddPages(book, 50), "Updated Edition"));
// Print the results
Console.WriteLine("books.Select(AddPages).Select(AppendSubtitle): " + string.Join(", ", sequentialApplicationResult.Select(b =&gt; b.Title)));
Console.WriteLine("books.Select(book =&gt; AppendSubtitle(AddPages(book, 50))): " + string.Join(", ", combinedApplicationResult.Select(b =&gt; b.Title)));
// Output:
// books.Select(AddPages).Select(AppendSubtitle): C# Basics: Updated Edition, Advanced C#: Updated Edition
// books.Select(book =&gt; AppendSubtitle(AddPages(book, 50))): C# Basics: Updated Edition, Advanced C#: Updated Edition</pre>			<p>As we can <a id="_idIndexMarker402"/>understand from the output, the resulting collections are equal, thus <a id="_idIndexMarker403"/>our <code>List&lt;Book&gt;</code> container abides by the Composition law.</p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor340"/>Creating our own functor</h2>
			<p>Note that a container doesn’t need to contain a set of elements to be considered a functor. Let’s <a id="_idIndexMarker404"/>recall the <code>Result</code> type we used in <a href="B21069_05.xhtml#_idTextAnchor221"><em class="italic">Chapter 5</em></a> and make an enhanced version of it by adding the <code>Map</code> method to be able to apply functions to the inner value:</p>
			<pre class="source-code">
public class Result&lt;TValue, TError&gt;
{
    private TValue _value;
    private TError _error;
    public bool IsSuccess { get; private set; }
    private Result(TValue value, TError error, bool isSuccess)
    {
        _value = value;
        _error = error;
        IsSuccess = isSuccess;
    }
    public TValue Value
    {
        get
        {
            if (!IsSuccess) throw new InvalidOperationException("Cannot fetch Value from a failed result.");
            return _value;
        }
    }
    public TError Error
    {
        get
        {
            if (IsSuccess) throw new InvalidOperationException("Cannot fetch Error from a successful result.");
            return _error;
        }
    }
    public static Result&lt;TValue, TError&gt; Success(TValue value) =&gt; new Result&lt;TValue, TError&gt;(value, default, true);
    public static Result&lt;TValue, TError&gt; Failure(TError error) =&gt; new Result&lt;TValue, TError&gt;(default, error, false);
    public Result&lt;TResult, TError&gt; Map&lt;TResult&gt;(Func&lt;TValue, TResult&gt; mapper)
    {
        return IsSuccess
            ? Result&lt;TResult, TError&gt;.Success(mapper(_value!))
            : Result&lt;TResult, TError&gt;.Failure(_error!);
    }
}</pre>			<p>The <code>Map</code> method applies <a id="_idIndexMarker405"/>the incoming function to the value if the container <a id="_idIndexMarker406"/>holds a value; otherwise, no function is called and the error result is returned. And as the <code>Result</code> type now can apply functions to the underlying value, it starts to obey the two functor laws. Let’s see that with the following example:</p>
			<pre class="source-code">
Book AddPages(Book book, int pages) =&gt; new Book { Title = book.Title, Pages = book.Pages + pages };
Book AppendSubtitle(Book book, string subtitle) =&gt; new Book { Title = $"{book.Title}: {subtitle}", Pages = book.Pages };
Func&lt;Book, Book&gt; identity = book =&gt; book;
var success = Result&lt;Book, string&gt;.Success(new Book { Title = "C# Basics", Pages = 100 });
var error = Result&lt;Book, string&gt;.Failure("Error message");
// Identity law
var successAfterIdentity = success.Map(identity);
// successAfterIdentity should have value "C# Basics", 100 pages
var errorAfterIdentity = error.Map(identity);
// errorAfterIdentity should have the "Error message" error
// Composition law
Func&lt;Book, Book&gt; composedFunction = book =&gt; AppendSubtitle(AddPages(book, 50), "Updated Edition");
var success = Result&lt;Book, string&gt;.Success(new Book { Title = "C# Basics", Pages = 100 });
// Applying composed function directly
var directComposition = success.Map(composedFunction);
// directComposition should hold value "C# Basics: Updated Edition", 150 pages
// Applying functions one after the other
var stepwiseComposition = success.Map(book =&gt; AddPages(book, 50)).Map(book =&gt; AppendSubtitle(book, "Updated Edition"));
// stepwiseComposition should also hold value "C# Basics: Updated Edition", 150 pages</pre>			<p>Although we <a id="_idIndexMarker407"/>cannot directly retrieve the inner value for now, it can be seen using the debugger or the <code>Dump()</code> extension method in <code>LinqPad</code>. And as we can see, our <code>Result</code> type became a functor.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor341"/>Functor benefits</h2>
			<p>Transforming our <code>Result&lt;TValue, TError&gt;</code> type into a functor offers several concise <a id="_idIndexMarker408"/>advantages, enhancing error handling and operational outcomes in functional programming:</p>
			<ul>
				<li><strong class="bold">Streamlined error handling</strong>: Integrates both success and error outcomes in one structure, simplifying error management</li>
				<li><strong class="bold">Composable operations</strong>: Facilitates chaining operations on successful results, with automatic error propagation, improving code reusability</li>
				<li><code>Map</code> function’s intent is clear—transform the value on success, or bypass an error, making the code more understandable</li>
				<li><strong class="bold">Type safety and clarity</strong>: The explicit success and error states in the type signature enhance predictability and safety, ensuring comprehensive outcome handling</li>
			</ul>
			<p>Sounds exciting, right? And we can make our class even better by making it an applicative functor.</p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor342"/>Applicative functors</h1>
			<p>An <strong class="bold">applicative functor</strong> is a type <a id="_idIndexMarker409"/>of functor that allows for the application of a function encapsulated within a functor to a value that is also wrapped within a functor. This concept translates into enabling operations that can gracefully handle multiple layers of computational contexts, such as error handling or asynchronous operations.</p>
			<p>While functors allow us to apply a function to a wrapped value, applicative functors extend this capability by enabling the application of functions that are themselves wrapped in a context. This distinction is crucial for operations where the function application itself may result in a computational context, such as failure, delay, or uncertainty. Let’s look at the difference using the book publishing system example.</p>
			<p>Consider a function that calculates royalties based on book sales and another function that adjusts these royalties based on market conditions. Both functions might fail due to various reasons, and their outputs might be wrapped in <code>Result</code> types to signify success or failure. Applicative functors allow us to apply these potentially failing functions to potentially failing inputs, orchestrating complex operations that gracefully handle multiple layers <a id="_idIndexMarker410"/>of potential failures.</p>
			<pre class="source-code">
Result&lt;Func&lt;int, decimal&gt;, string&gt; CalculateRoyaltiesFunc = new Result&lt;Func&lt;int, decimal&gt;, string&gt;(sales =&gt; sales * 0.1m);
Result&lt;Func&lt;decimal, decimal&gt;, string&gt; AdjustRoyaltiesFunc = new Result&lt;Func&lt;decimal, decimal&gt;, string&gt;(royalties =&gt; royalties * 1.05m);</pre>			<p>In this example, <code>CalculateRoyaltiesFunc</code> is a function that takes the number of sales and calculates the royalties as 10% of the sales. <code>AdjustRoyaltiesFunc</code> is a function that takes an initial royalty amount and adjusts it by a factor of <code>1.05</code> to account for market conditions.</p>
			<p>Now, let’s assume we have a <code>Result&lt;int, string&gt;</code> representing the number of book sales, which could also fail:</p>
			<pre class="source-code">
Result&lt;int, string&gt; salesResult = new Result&lt;int, string&gt;(150);</pre>			<p>To calculate the adjusted royalties, we first apply <code>CalculateRoyaltiesFunc</code> to <code>salesResult</code>, and then apply <code>AdjustRoyaltiesFunc</code> to the result:</p>
			<pre class="source-code">
var royaltiesResult = salesResult
    .Apply(CalculateRoyaltiesFunc)
    .Apply(AdjustRoyaltiesFunc);
// the royaltiesResult holds the value 15.75</pre>			<p>For the sake of better understanding, let’s pretend that our first function returns an error:</p>
			<pre class="source-code">
Result&lt;Func&lt;int, decimal&gt;, string&gt; CalculateRoyaltiesFunc = Result&lt;Func&lt;int, decimal&gt;, string&gt;.Failure("Can't calculate royalties");</pre>			<p>If we try to calculate <code>royaltiesResult</code> again, <code>IsSuccess</code> will be <code>false</code> and the <code>Error</code> property will contain the string <code>"Can't calculate royalties"</code>. The same situation <a id="_idIndexMarker411"/>will happen if the <code>AdjustRoyaltiesFunc</code> call results in an error. Both methods can fail; however, thanks to the <code>Apply</code> method, we can call them both in a safe manner. Sounds great, but what does this <code>Apply</code> method look like?</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor343"/>The Apply method implementation</h2>
			<p>To implement <a id="_idIndexMarker412"/>the applicative functor <a id="_idIndexMarker413"/>pattern, we introduced the <code>Apply</code> method. This method takes <code>Result</code> that contains a function and applies it to the value inside the current <code>Result</code> instance if both are successful. If either the function or the value is wrapped in a failed <code>Result</code>, the <code>Apply</code> method propagates the error:</p>
			<pre class="source-code">
public Result&lt;TResult, TError&gt; Apply&lt;TResult&gt;(Result&lt;Func&lt;TValue, TResult&gt;, TError&gt; resultFunc)
{
    if (resultFunc.IsSuccess &amp;&amp; this.IsSuccess)
    {
        return Result&lt;TResult, TError&gt;.Success(resultFunc.Value(this.Value));
    }
    else
    {
        var error = resultFunc.IsSuccess ? this._error! : resultFunc.Error;
        return Result&lt;TResult, TError&gt;.Failure(error);
    }
}</pre>			<p>As you can see, nothing special here. First, we ensure that both the current container state and the incoming <code>Result&lt;Func&lt;TValue, TResult&gt;, TError&gt;</code> state are successful. Then, we return a new <code>Result&lt;TResult, TError&gt;</code>. If either of the <code>IsSuccess</code> properties is <code>false</code>, a corresponding error is returned. However, an <code>Apply</code> method is <a id="_idIndexMarker414"/>not enough for a class to be considered <a id="_idIndexMarker415"/>an applicative functor; it must abide by applicative functor laws.</p>
			<p>As Steve was grasping the concept of functors, Julia introduced a new challenge.</p>
			<p>Julia: <em class="italic">Now, what if you wanted to apply multiple upgrades to a tower at once, but some upgrades might fail? This is where applicative functors come </em><em class="italic">in handy.</em></p>
			<p>Steve: <em class="italic">Multiple upgrades at once? That could really streamline my </em><em class="italic">upgrade system!</em></p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor344"/>Applicative functor laws</h2>
			<p>There are <a id="_idIndexMarker416"/>four applicative functor laws: Identity, Homomorphism, Interchange, and Composition. Let’s go through each of them.</p>
			<h3>Identity law</h3>
			<p>The Identity <a id="_idIndexMarker417"/>law states that applying the identity <a id="_idIndexMarker418"/>function to a <code>Result</code>-wrapped value should yield the original <code>Result</code> without any change:</p>
			<pre class="source-code">
// Identity function
Func&lt;int, int&gt; identity = x =&gt; x;
// Result-wrapped value, representing, for example, a count of books
var bookCount = Result&lt;int, string&gt;.Success(10);
// Applying the identity function to the bookCount
var identityApplied = bookCount.Map(identity);
// The identity operation should not alter the original Result
Console.WriteLine(identityApplied.IsSuccess &amp;&amp; identityApplied.Value == 10);  // Output: True</pre>			<h3>Homomorphism law</h3>
			<p>This law <a id="_idIndexMarker419"/>demonstrates that applying a <a id="_idIndexMarker420"/>function to a value and then wrapping it is equivalent to wrapping the value and then applying the function within the <code>Result</code>:</p>
			<pre class="source-code">
Func&lt;int, double&gt; calculateRoyalties = sales =&gt; sales * 0.15;
int bookSales = 100;
// Applying function then wrapping
var directApplication = Result&lt;double, string&gt;.Success(calculateRoyalties(bookSales));
// Wrapping then applying function
var wrappedApplication = Result&lt;int, string&gt;.Success(bookSales).Map(calculateRoyalties);
// Both operations should yield the same result
Console.WriteLine(directApplication.IsSuccess &amp;&amp; wrappedApplication.IsSuccess &amp;&amp; directApplication.Value == wrappedApplication.Value);  // Output: True</pre>			<h3>Interchange law</h3>
			<p>This law <a id="_idIndexMarker421"/>indicates that applying a wrapped function <a id="_idIndexMarker422"/>to a wrapped value should be equivalent to applying a function that applies its argument to the wrapped value.</p>
			<p>For this law, we would need to extend our <code>Result</code> type to support applying a <code>Result</code>-wrapped function to a <code>Result</code>-wrapped value, which is not directly supported by the provided <code>Result</code> type structure. However, the conceptual application would look something like this in a system that supports it:</p>
			<pre class="source-code">
Result&lt;Func&lt;int, double&gt;, string&gt; wrappedCalculateRoyalties = new Result&lt;Func&lt;int, double&gt;, string&gt;(calculateRoyalties);
Result&lt;int, string&gt; salesResult = Result&lt;int, string&gt;.Success(bookSales);
// Wrapped function applied to wrapped value
var applied = salesResult.Apply(wrappedCalculateRoyalties);
// Equivalent to applying a function that takes a function and applies it to the value
Func&lt;Func&lt;int, double&gt;, Result&lt;double, string&gt;&gt; applyFuncToValue = func =&gt; Result&lt;double, string&gt;.Success(func(bookSales));
var interchangeResult = wrappedCalculateRoyalties.Map(applyFuncToValue);
// The results of applied and interchangeResult should be equivalent</pre>			<h3>Composition law</h3>
			<p>The Composition law ensures that when we compose two or more functions and apply them to <a id="_idIndexMarker423"/>a functor, the order of function application <a id="_idIndexMarker424"/>does not affect the outcome. This property, known as associativity, is central to the Composition law. It ensures that if we have functions f, g, and h, composing them and then applying them to a functor F yields the same result regardless of how the functions are grouped during composition.</p>
			<p>For instance, consider two functions, f(x) = x + 1 and g(x) = x * 3. According to the Composition law, composing f and g and then applying them to a value inside a functor should yield the same result as applying f to the functor and then g. Expressed mathematically, F.map(g(f(x))) is equivalent to F.map(f).map(g).</p>
			<p>This associative property allows us to reason about composed functions confidently, knowing that the grouping of function applications does not impact the final outcome when applied to a functor. This principle enhances the predictability and reliability of functional programming, allowing developers to compose complex transformations succinctly and safely.</p>
			<p>For this law, similar to the Interchange law, we need a mechanism to compose functions within the <code>Result</code> context, which our current <code>Result</code> type definition does not directly support. Conceptually, it would look like this:</p>
			<pre class="source-code">
Func&lt;int, double&gt; calculateRoyalties = sales =&gt; sales * 0.15;
Func&lt;double, double&gt; adjustForMarket = royalties =&gt; royalties * 1.05;
// Composition of functions outside the Result context
Func&lt;int, double&gt; composed = sales =&gt; adjustForMarket(calculateRoyalties(sales));
// Applying composed function to a Result-wrapped value
var composedApplication = Result&lt;int, string&gt;.Success(bookSales).Map(composed);
// The result of composedApplication should be equivalent to applying each function within the Result context in sequence</pre>			<p>As you can see our <code>Result</code> type abides by all these laws and can be counted as an applicative functor. From here, we need to take one more step to make it a monad.</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor345"/>Monads</h1>
			<p>Steve was excited about functors but still struggled to see their full potential in his game logic. Julia knew it was time to introduce monads.</p>
			<p>Julia: <em class="italic">Let’s take your game’s upgrade system a step further. Imagine a series of operations: checking the player’s gold, deducting the cost, and applying the upgrade. Each step depends on the previous one succeeding. This is where </em><em class="italic">monads shine.</em></p>
			<p>Steve: <em class="italic">That sounds exactly like what I need for my upgrade system. How do monads </em><em class="italic">handle this?</em></p>
			<p>A <strong class="bold">monad</strong> represents an <a id="_idIndexMarker425"/>evolution of the concepts we explored with functors and applicative functors. While a functor allows us to map a function over a wrapped value and an applicative functor enables applying wrapped functions to wrapped values, monads introduce the ability to chain operations in a way that handles the context of those operations—be it errors, lists, options, or other computational contexts. Thus, we can say that a monad is an applicative functor that adheres to some additional laws.</p>
			<p>The essence of a monad is its ability to flatten layers of wrapping caused by applying functions that return wrapped values. This is crucial in avoiding deeply nested structures when performing multiple operations in sequence. Let’s break down this concept with an example from our book publishing system.</p>
			<p>Imagine a scenario where we need to fetch a manuscript, edit it, and then format it for publishing. Each of these operations might fail and return <code>Result&lt;TValue, TError&gt;</code>, leading to nested <code>Result&lt;Result&lt;...&gt;&gt;</code> types. Monads allow us to perform these operations sequentially in a cleaner way.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor346"/>The Bind method</h2>
			<p>The key <a id="_idIndexMarker426"/>to monads is the <code>Bind</code> method (often called <code>flatMap</code> or <code>SelectMany</code> in different <a id="_idIndexMarker427"/>languages and frameworks). This method <a id="_idIndexMarker428"/>applies a <a id="_idIndexMarker429"/>function to the wrapped value, which returns the same kind of wrapper, and then flattens the result:</p>
			<pre class="source-code">
public Result&lt;TResult, TError&gt; Bind&lt;TResult&gt;(Func&lt;TValue, Result&lt;TResult, TError&gt;&gt; func)
    {
        return IsSuccess ? func(_value!) : Result&lt;TResult, TError&gt;.Failure(_error!);
    }</pre>			<p>With <code>Bind</code>, we can chain operations without nesting. Let’s apply this to our publishing system:</p>
			<pre class="source-code">
Result&lt;Manuscript, string&gt; FetchManuscript(int manuscriptId) { ... }
Result&lt;EditedManuscript, string&gt; EditManuscript(Manuscript manuscript) { ... }
Result&lt;FormattedManuscript, string&gt; FormatManuscript(EditedManuscript edited) { ... }
var manuscriptId = 101;
var publishingPipeline = FetchManuscript(manuscriptId)
    .Bind(EditManuscript)
    .Bind(FormatManuscript);</pre>			<p>In this pipeline, each step is applied only if the previous one succeeds, with any failure immediately short-circuiting the chain.</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor347"/>Monad laws</h2>
			<p>As well as <a id="_idIndexMarker430"/>functors, monads must satisfy their laws to ensure consistency and predictability and there are three of them: Left Identity, Right Identity, and Associativity.</p>
			<h3>Left Identity</h3>
			<p>Wrapping a <a id="_idIndexMarker431"/>value and then binding with a function is the same as <a id="_idIndexMarker432"/>just applying the function to the value:</p>
			<pre class="source-code">
Func&lt;int, Result&lt;double, string&gt;&gt; calculateRoyalties = sales =&gt; new Result&lt;double, string&gt;(sales * 0.15);
int bookSales = 100;
var leftIdentity = Result&lt;int, string&gt;.Success(bookSales).Bind(calculateRoyalties);
var directApplication = calculateRoyalties(bookSales);
// leftIdentity should be equivalent to directApplication</pre>			<h3>Right Identity</h3>
			<p>Binding a <a id="_idIndexMarker433"/>wrapped value with a function that simply re-wraps <a id="_idIndexMarker434"/>the value should yield the original wrapped value:</p>
			<pre class="source-code">
var manuscriptResult = Result&lt;Manuscript, string&gt;.Success(new Manuscript());
var rightIdentity = manuscriptResult.Bind(manuscript =&gt; Result&lt;Manuscript, string&gt;.Success(manuscript));
// rightIdentity should be equivalent to manuscriptResult</pre>			<h3>Associativity</h3>
			<p>The order <a id="_idIndexMarker435"/>of binding <a id="_idIndexMarker436"/>operations should not matter:</p>
			<pre class="source-code">
var associativity1 = FetchManuscript(manuscriptId).Bind(EditManuscript).Bind(FormatManuscript);
var associativity2 = FetchManuscript(manuscriptId).Bind(manuscript =&gt; EditManuscript(manuscript).Bind(FormatManuscript));
// associativity1 should be equivalent to associativity2</pre>			<h2 id="_idParaDest-251"><a id="_idTextAnchor348"/>Utilizing monads</h2>
			<p>Monads shine in operations that involve sequences of computations where each step might fail <a id="_idIndexMarker437"/>or produce a new context. In our book publishing system, we can extend this pattern to handle user input validation, database transactions, or network calls, ensuring our code remains clean, readable, and maintainable:</p>
			<pre class="source-code">
Result&lt;Publication, string&gt; PublishManuscript(FormattedManuscript formatted) { ... }
var finalResult = FetchManuscript(manuscriptId)
    .Bind(EditManuscript)
    .Bind(FormatManuscript)
    .Bind(PublishManuscript);</pre>			<p>This approach not only simplifies error handling by propagating errors automatically but also keeps the happy path code clear and straightforward, without the need for manual checks or nested conditionals.</p>
			<p>Monads are like smart containers that help manage a series of steps, particularly when you’re dealing with tricky situations such as errors or tasks that take time to complete. By getting a handle on functors and then leveling up to monads, you can make your code not only more expressive but also easier to maintain and more reliable. Think about how we simplified tasks in our book publishing examples; monads and their friends can really untangle complicated logic and make dealing with mistakes a lot smoother, making your whole code base friendlier and less daunting to work with.</p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor349"/>Key takeaways</h1>
			<p>As we conclude this chapter on functors and monads, let’s take a moment to summarize what we’ve learned:</p>
			<ul>
				<li><strong class="bold">Fundamental concept of functors</strong>: Functors are integral to functional programming for data manipulation. They act as “magic boxes” that allow us to apply a function to the data they hold, transforming the contents while maintaining the original structure.</li>
				<li><strong class="bold">Not all containers are functors</strong>: For a data container to be considered a functor, it must adhere to two critical laws: the Identity law and the Composition law. These laws ensure that functors operate predictably and consistently within their intended paradigms.</li>
				<li><strong class="bold">Identity law</strong>: The Identity law emphasizes that mapping an identity function (a function that returns its input) over a functor should leave the functor unchanged. This law underscores the non-intrusive nature of functor transformations.</li>
				<li><strong class="bold">Composition law</strong>: The Composition law asserts that the order in which functions are composed and applied to a functor does not affect the final outcome. This law highlights the composability and flexibility of functors in functional programming.</li>
				<li><code>Result&lt;TValue, TError&gt;</code> type example, we explored how functors can be practically implemented to enhance error handling and operational outcomes. The <code>Map</code> method demonstrated the application of functions to the encapsulated value within the functor, adhering to the functor laws.</li>
				<li><strong class="bold">Applicative functors</strong>: The chapter also introduced the concept of applicative functors, which build upon basic functors by allowing the application of functions wrapped within a functor to values also wrapped within a functor. This capability enables handling multiple layers of computational contexts gracefully.</li>
				<li><strong class="bold">Applicative functor laws</strong>: Applicative functors are governed by additional laws, including Identity, Homomorphism, Interchange, and Composition. These laws further ensure the reliable and predictable behavior of applicative functors in complex operations.</li>
				<li><strong class="bold">Monads</strong>: The discussion set the stage for the evolution into monads, which extend the concepts of functors and applicative functors by enabling the chaining of operations that handle the context of those operations, such as errors or asynchronous computations.</li>
			</ul>
			<p>In closing, functors and monads are not just theoretical constructs; they are pragmatic tools that can transform your code from ordinary to exceptional. Embrace the opportunities they offer, and watch as your programming skills reach new heights of expressiveness and efficiency. Happy coding!</p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor350"/>Exercises</h1>
			<p>After explaining the concepts, Julia challenged Steve to apply what he’d learned.</p>
			<p>Julia: <em class="italic">Now that you understand the basics, why don’t you try refactoring your game’s upgrade system using monads? It should make your code more robust and easier to </em><em class="italic">reason about.</em></p>
			<p>Steve: <em class="italic">That’s a great idea! I can already see how this could simplify some of my more complex </em><em class="italic">game logic.</em></p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor351"/>Exercise 1</h2>
			<p>Given a <code>Result&lt;List&lt;Tower&gt;, string&gt;</code> type that represents a list of towers, where <code>Tower</code> is a class containing properties such as <code>Id</code>, <code>Name</code>, and <code>Damage</code>, the task is to use the functor concept to apply a function to each tower that appends “(Upgraded)” to the end of its name to indicate that the tower has been upgraded:</p>
			<pre class="source-code">
public class Tower
{
    public int Id { get; set; }
    public string Name { get; set; }
    public int Damage { get; set; }
}
public Result&lt;List&lt;Tower&gt;, string&gt; UpgradeTowers(List&lt;Tower&gt; towers)
{
    // Write your code here
}</pre>			<h2 id="_idParaDest-255"><a id="_idTextAnchor352"/>Exercise 2</h2>
			<p>Imagine you have two functions wrapped in the <code>Result</code> type: <code>Result&lt;Func&lt;Tower, bool&gt;, string&gt; ValidateDamage</code> checks whether a tower’s damage is within acceptable limits, and <code>Result&lt;Func&lt;Tower, bool&gt;, string&gt; ValidateName</code> checks whether the tower’s name meets certain criteria. Given a <code>Result&lt;Tower, string&gt;</code> representing a single tower, use applicative functors to apply both validation functions to the tower, ensuring both validations pass:</p>
			<pre class="source-code">
public Result&lt;Func&lt;Tower, bool&gt;, string&gt; ValidateDamage = new Result&lt;Func&lt;Tower, bool&gt;, string&gt;(tower =&gt; tower.Damage &lt; 100);
public Result&lt;Func&lt;Tower, bool&gt;, string&gt; ValidateName = new Result&lt;Func&lt;Tower, bool&gt;, string&gt;(tower =&gt; tower.Name.Length &gt; 5 &amp;&amp; !tower.Name.Contains("BannedWord"));</pre>			<h2 id="_idParaDest-256"><a id="_idTextAnchor353"/>Exercise 3</h2>
			<p>Given a sequence of operations needed to upgrade a tower—<code>FetchTower</code>, <code>UpgradeTower</code>, and <code>DeployTower</code>—with each potentially failing and returning <code>Result&lt;Tower, string&gt;</code>, use the monad concept to chain these operations together for a given tower ID. Ensure that if any step fails, the entire operation short-circuits and returns the error:</p>
			<pre class="source-code">
public Result&lt;Tower, string&gt; FetchTower(int towerId) { /* Fetches tower based on ID */ }
public Result&lt;Tower, string&gt; UpgradeTower(Tower tower) { /* Upgrades the tower and can fail */ }
public Result&lt;Tower, string&gt; DeployTower(Tower tower) { /* Attempts to deploy the tower */ }</pre>			<p>These exercises aim to help you reinforce the concepts learned throughout this chapter and understand how to apply them in different scenarios.</p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor354"/>Solutions</h1>
			<p>I hope you did all the exercises and just want to check out my solutions. If not, don’t worry, everything comes with experience. Now, let’s look at the solutions.</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor355"/>Exercise 1</h2>
			<p>Use the <code>Map</code> method to apply a function to each tower in the list that appends “(Upgraded)” to its name:</p>
			<pre class="source-code">
public Result&lt;List&lt;Tower&gt;, string&gt; UpgradeTowers(Result&lt;List&lt;Tower&gt;, string&gt; towersResult)
{
    return towersResult.Map(towers =&gt;
        towers.Select(tower =&gt;
        {
            tower.Name += " (Upgraded)";
            return tower;
        }).ToList());}</pre>			<p>This solution demonstrates how functors can encapsulate data and behavior, allowing for operations on contained data while preserving the context (success or failure) of the entire operation:</p>
			<ul>
				<li><code>towersResult.Map(...)</code>: This line uses the <code>Map</code> function, which is fundamental to the functor pattern. It applies a given function to the contained value if the <code>Result</code> is successful, without affecting the outer <code>Result</code> structure.</li>
				<li><code>towers.Select(tower =&gt; ...)</code>: Inside <code>Map</code>, a <code>Select</code> LINQ method iterates over each <code>Tower</code> object in the list, applying a lambda function that modifies the <code>Name</code> property.</li>
				<li><code>tower.Name += " (Upgraded)"</code>: This operation appends <code>"(Upgraded)"</code> to the name of each tower, indicating that it has been upgraded.</li>
			</ul>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor356"/>Exercise 2</h2>
			<p>The applicative functor pattern extends the functor’s capabilities by allowing functions themselves to be wrapped in a context (such as <code>Result</code>). This solution uses this capability to apply multiple validation functions, wrapped in <code>Result</code> types, to a single video also wrapped in <code>Result</code>:</p>
			<pre class="source-code">
public Result&lt;bool, string&gt; ValidateTower(Result&lt;Tower, string&gt; towerResult)
{
    var damageValidated = towerResult.Apply(ValidateDamage);
    var nameValidated = towerResult.Apply(ValidateName);
    return damageValidated.Bind(damageResult =&gt;
        nameValidated.Map(nameResult =&gt; damageResult &amp;&amp; nameResult));
}</pre>			<p>Here, we handle multiple potential failure points in a composable manner, showcasing the power of applicative functors in functional error handling:</p>
			<ul>
				<li><code>towerResult.Apply(ValidateDamage)</code> and <code>towerResult.Apply</code><strong class="source-inline">
(ValidateName)</strong>: These lines demonstrate the applicative functor’s <code>Apply</code> method. It takes <code>Result</code> containing a function and applies it to another <code>Result</code> containing a value, effectively unwrapping both and applying the function to the value.</li>
				<li>The chaining of <code>Bind</code> and <code>Map</code> ensures that if any validation fails, the entire validation process short-circuits and returns the failure. Otherwise, it combines the results of both validations into a single Boolean value.</li>
			</ul>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor357"/>Exercise 3</h2>
			<p>Monads extend the concept of applicative functors by allowing the chaining of operations that return a wrapped type, such as <code>Result&lt;Tower, string&gt;</code>, enabling a seamless and error-propagating sequence of operations:</p>
			<pre class="source-code">
public Result&lt;Tower, string&gt; ProcessAndDeployTower(int towerId)
{
    return FetchTower(towerId)
        .Bind(UpgradeTower)
        .Bind(DeployTower);
}</pre>			<p>This solution shows monads’ ability to manage sequences of dependent operations within a context, making error handling more intuitive and linear, and thus significantly simplifying complex business logic:</p>
			<ul>
				<li><code>FetchTower(towerId).Bind(UpgradeTower).Bind(DeployTower)</code>: This line illustrates the essence of monads through the <code>Bind</code> method. Each function in the chain (<code>FetchTower</code>, <code>UpgradeTower</code>, and <code>DeployTower</code>) potentially returns a <code>Result&lt;Tower, string&gt;</code>, and <code>Bind</code> ensures that each subsequent function is only executed if the previous one succeeded.</li>
				<li>The monadic pattern here guarantees that if any step in the process fails, the error is immediately propagated through the chain, bypassing subsequent steps and returning the failure result.</li>
			</ul>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor358"/>Summary</h1>
			<p>In this chapter, we discussed functors and their role in functional programming. We started with the basics, explaining that functors are like smart containers. They can hold data and also apply a function to that data while keeping their original shape.</p>
			<p>We looked at how functors work, showing how they let us run functions on the data they hold without needing to unpack and repack the container. We also covered the two main rules that functors follow: the Identity and Composition laws.</p>
			<p>Through examples, we saw how functors can be used in different situations, such as working with lists or handling errors more smoothly. We explored creating our own functors, which opens up new ways to tailor our code to fit exactly what we need. We made the full journey from functors to applicative functors and monads, learned about the laws that each of these “containers” adhere to, and saw them in some practical scenarios.</p>
			<p>As we wrap up this chapter, you should have a solid foundation in using functors and monads in your projects. They’re a simple yet powerful tool that can make a big difference in how you approach coding. Next up, in <a href="B21069_08.xhtml#_idTextAnchor360"><em class="italic">Chapter 8</em></a>, <em class="italic">Recursion and Tail Calls</em>, we’ll dive into the recursion domain, where functions call themselves, and look at how tail calls can make recursion more efficient.</p>
		</div>
	

		<div><h1 id="_idParaDest-262" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor359"/>Part 3:Practical Functional Programming</h1>
			<p>In this part, we move from theory to practice, exploring how to apply functional programming concepts to real-world scenarios. We’ll start with recursion and tail calls, learning how to write efficient recursive functions. Then, we’ll explore currying and partial application, techniques that allow you to create more flexible and reusable functions. Finally, we’ll look at how to combine functions to create powerful data processing pipelines, bringing together many of the concepts learned throughout the book.</p>
			<p>This part has the following chapters:</p>
			<ul>
				<li><a href="B21069_08.xhtml#_idTextAnchor360"><em class="italic">Chapter 8</em></a><em class="italic">, Recursion and Tail Calls</em></li>
				<li><a href="B21069_09.xhtml#_idTextAnchor397"><em class="italic">Chapter 9</em></a><em class="italic">, Currying and Partial Application</em></li>
				<li><a href="B21069_10.xhtml#_idTextAnchor426"><em class="italic">Chapter 10</em></a><em class="italic">, Pipelines and Composition</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>