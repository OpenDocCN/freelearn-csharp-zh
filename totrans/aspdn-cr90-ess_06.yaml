- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enhancing Security and Quality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the rapidly evolving digital world, where new cyber threats emerge with alarming
    frequency, web-based application security is not just a feature but a fundamental
    necessity. So that applications are prepared for various existing vulnerabilities,
    software engineers must consider security as part of the entire development flow
    of web-based solutions so that they can protect data, guarantee integrity and
    availability, and minimize threats that can compromise an organization.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll learn about basic security principles that every web
    developer should master, especially regarding how ASP.NET Core 9, as a powerful
    platform, can help us create secure, high-level applications.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll explore the essential principles of web security, understanding
    that security must be taken into consideration in all phases of developing a web
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll address the concepts of authentication and authorization, both of
    which are commonly used when users and applications, as well as applications and
    external applications, interact with each other. Once we have a better understanding
    of authorization and authentication flows, we’ll use the ASP.NET Core Identity
    framework to add security to an API project and learn about some important approaches
    that are available in ASP.NET Core 9 that allow us to strengthen security mechanisms
    in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the security principles of web-based applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing authorization and authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the ASP.NET Core Identity framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strengthening application security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For us to have a great learning experience in this chapter, we must prepare
    our environment with some tools that will be essential for us to fully utilize
    the concepts that will be introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, the following tools must be present in your development
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker** : Docker Engine must be installed on your operating system and have
    a SQL Server container running. You can find more details about Docker and SQL
    Server in [*Chapter 4*](B21788_04.xhtml#_idTextAnchor061) .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Postman** : We’ll use this tool to execute requests that are sent to the
    APIs of the developed application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Data Studio** : We’ll use this tool to connect to a SQL Server database
    so that we can execute SQL scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code examples for this chapter can be found in this book’s GitHub repository:
    [https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter06](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter06)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the security principles of web-based applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every year, new approaches to developing solutions emerge for the most diverse
    types of environments and devices. With this comes various challenges. Developing
    web applications that previously focused on technologies such as HTML, CSS, JavaScript,
    and a programming language of choice is no longer a reality.
  prefs: []
  type: TYPE_NORMAL
- en: Software engineers began to serve other contexts outside the environment of
    a programming IDE, often working with iInfrastructure, adding to a multitude of
    frameworks and tools that emerged along with the DevOps cCulture approach, and
    constant value delivery.
  prefs: []
  type: TYPE_NORMAL
- en: The DevOps culture has brought a new working model where teams avoid silos and
    work together while exchanging knowledge and, consequently, learning. Therefore,
    a subject that is becoming increasingly present in the lives of solution developers
    is **security** . The term security has long ceased to be an isolated subject
    directed only at a cybersecurity team. It is now essential from the first stages
    of design and must be considered in all aspects of a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Paying attention to threats in applications and data control and management
    has become paramount and is even a strategic factor for companies and customers
    that use applications. There are many security standards and policies from a data
    processing perspective, such as the **General Data Protection Regulation** ( **GDPR**
    ) in Europe.
  prefs: []
  type: TYPE_NORMAL
- en: Security is very important and ASP.NET Core 9 offers several mechanisms that
    we can use to deal with the challenges proposed by avoiding threats and maintaining
    secure and reliable applications.
  prefs: []
  type: TYPE_NORMAL
- en: However, we must understand how security aspects are applied to web applications
    and common vulnerabilities, as well as how ASP.NET Core 9 works to prevent threats
    from occurring in applications.
  prefs: []
  type: TYPE_NORMAL
- en: Security topics in web applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we’ve already learned in previous chapters, in general, a web application
    has two main components: the frontend, which is responsible for interacting with
    the user, and the backend, which is responsible for processing the application’s
    business rules, providing control, and interacting with the data layer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most web applications, whether they’re client-server ones or **single-page
    applications** ( **SPAs** ), use the aforementioned approach in some way. As shown
    in *Figure 6* *.1* , several components are part of how the frontend and backend
    interact, such as the communication protocol, requests, responses, HTTP headers,
    the browser, the application server, the database, the TCP protocol, credentials,
    cookies, and local storage (browser), among others:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Components of a SPA](img/B21788_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Components of a SPA
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, several components communicate with each other. Similarly, several
    vulnerabilities can compromise the integrity of your application. In some cases,
    an information leak can have serious consequences for an organization.
  prefs: []
  type: TYPE_NORMAL
- en: As a premise, software engineers must have a security aspect set out from the
    initial design stage that can often be associated not only with communication
    protocols and interactions between systems but also with code development.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say that, during the development process, a software engineer made a very
    important change that was supposed to fix a critical problem in the application.
    To quickly perform the correction, the software engineer created communication
    with the database using SQL commands and string concatenation. After carrying
    out the tests, the engineer submitted the code to the Git repository so that the
    system could be updated. There was no code review and within a few minutes, the
    fix was in the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: So, what’s wrong in this scenario? Initially, the software engineer acted correctly
    in providing a quick response to the problem that was found in the application
    and corrected it, and everything returned to normal. However, the approach they
    used to communicate with the database contained a vulnerability that could be
    exploited by malicious users by utilizing what’s known as **SQL** **injection
    attacks** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of some code that’s vulnerable to SQL injection attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the SQL query has been constructed by directly concatenating
    a user’s input (username) into the SQL string. This is a dangerous practice because
    it allows an attacker to alter the intended SQL query by injecting SQL code into
    the **username** variable. For example, if a user enters something like **'';
    DROP TABLE users; --** , the resulting SQL query would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This would execute the **DROP TABLE** statement, potentially destroying data.
  prefs: []
  type: TYPE_NORMAL
- en: So, a simple change such as this, even with great intentions, could have a big
    impact. Likewise, simple processes can avoid this situation by implementing a
    code review, a practice where members of the engineering team analyze the code
    that should be incorporated into the main code to search for any flaws, evaluate
    code patterns and complexity, and more. The code can only be incorporated into
    the main code if it meets the quality and security criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, while integrating the new code into the main code, automated processes
    can be executed, where it would be possible to add **static code analysis** mechanisms.
    If there are any invalid security and quality criteria, the application can’t
    be delivered to the productive environment. We’ll learn more about automated processes
    in [*Chapter 10*](B21788_10.xhtml#_idTextAnchor162) .
  prefs: []
  type: TYPE_NORMAL
- en: Static code analysis
  prefs: []
  type: TYPE_NORMAL
- en: Static code analysis acts on security checks, coding standards, and cyclomatic
    complexity analysis, among other aspects, adding value to the application development
    process associated with automation techniques that involve **continuous integration**
    ( **CI** ) and **continuous delivery** ( **CD** ). There are several tools available
    in the market for static code analysis, with the most famous being **SonarQube**
    ( [https://hub.docker.com/_/sonarqube](https://hub.docker.com/_/sonarqube) ).
    It has a community version and can be hosted in any environment. However, it does
    have some limitations regarding how many lines of code can be analyzed. Alternatively,
    there’s a version that’s delivered as a **Software-as-a-Service** ( **SaaS** )
    offering called **Sonar** **Cloud** ( [https://www.sonarsource.com/products/sonarcloud/](https://www.sonarsource.com/products/sonarcloud/)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Adding static analysis to the development flow is an excellent practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll explore other ways we can make our applications more
    secure and talk about various vulnerabilities. But first, let’s understand a common
    security model that’s used by most applications that’s based on two basic processes:
    authentication and authorization.'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing authorization and authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we’ve been learning, the security aspect is important throughout the application
    development flow. Despite having good intentions, we can include vulnerabilities
    in our code that directly affect our users, applications, and companies.
  prefs: []
  type: TYPE_NORMAL
- en: However, in addition to the code, some features require security processes.
    For example, this is the case for some service platforms, such as email managers,
    which allow users to access their messages privately once they’ve gained access
    by logging in.
  prefs: []
  type: TYPE_NORMAL
- en: The login functionality is very important and, although it seems like a simple
    process, it requires a lot of attention. Otherwise, depending on the application,
    there may be consequences.
  prefs: []
  type: TYPE_NORMAL
- en: What would happen if there was a vulnerability upon logging into an online banking
    platform? It would probably be a big problem for the users of this bank (and also
    for the bank).
  prefs: []
  type: TYPE_NORMAL
- en: Modern systems work with identity management for different aspects. As discussed
    in previous chapters, web applications can make requests to different APIs. APIs
    allow companies to provide business as services, which allows for diverse integrations
    between different applications. With this, it’s possible to have applications
    with different types of functionalities that add value to the user, such as map
    APIs, payment gateways, and even APIs that provide AI functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: For applications and APIs to communicate securely, an identity-based security
    mechanism is necessary. With this, we can find out who is demanding some type
    of information and why.
  prefs: []
  type: TYPE_NORMAL
- en: 'This security mechanism is divided into two concepts: **authentication** and
    **authorization** .'
  prefs: []
  type: TYPE_NORMAL
- en: In general, we know that this approach involves a login flow. However, it’s
    essential to understand the difference between authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Authentication aims to answer the question, *Who* *are you?* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The authentication flow](img/B21788_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – The authentication flow
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6* *.2* shows an authentication flow where, through a login form, a
    user’s credentials are provided, such as their email and password.'
  prefs: []
  type: TYPE_NORMAL
- en: By posting this information to the server by clicking the **log in** button,
    the application starts identifying this user by using the credentials provided.
  prefs: []
  type: TYPE_NORMAL
- en: If the user is found according to these credentials, then the application is
    aware of who wants to access the system.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is just one part of the process. Now that the application has
    identified the user, it’s important to understand what this user can do. This
    is done during the authorization process.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Authorization aims to answer the question, *What can this* *user do?* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Checking permissions with the authorization flow](img/B21788_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Checking permissions with the authorization flow
  prefs: []
  type: TYPE_NORMAL
- en: After identifying the user, the application starts identifying the user’s permissions,
    as shown in *Figure 6* *.3* .
  prefs: []
  type: TYPE_NORMAL
- en: Authorization defines the scope in which this user can act, whether in managing
    some information or accessing a certain type of data, among other aspects. The
    authorization flow often identifies the user through roles, where it’s possible
    to group access levels within the scope of the application.
  prefs: []
  type: TYPE_NORMAL
- en: It’s very common to use roles because it’s possible to group the different permissions
    that a user can have within an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the authentication and authorization processes are simple. However,
    to be able to implement them securely, there are some standards that we must be
    aware of: the **OAuth 2.0** and **Open ID Connect** ( **OIDC** ) protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding OAuth 2.0 and OIDC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a high-security building. Here, authorization can be thought of as acquiring
    permission to enter, while authentication verifies your identity.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2.0 focuses on authorization, allowing users to grant access to their
    data on one platform (such as a social media account) to another, without the
    need for them to share their actual passwords. In other words, we allow other
    applications to access a certain scope of our information without us having to
    provide certain credentials, such as what happens when we log in to some platform
    using credentials from Microsoft, Google, Facebook, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic OAuth 2.0 flow can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user logs in to a new application using their social media account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application redirects the user to the social media platform (the authorization
    server).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After logging into the social media account, the user grants the application
    permission to use their data (such as their name, email, profile photo, and more).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The authorization server generates special tokens for the application. Tokens
    are used to gain access to user data (access tokens). In some cases, refresh tokens
    are used to provide access to new tokens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application uses the access token to retrieve your data from the social
    media platform securely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This process involves negotiating two different applications that share user
    information, without the need to enter their credentials for each new application,
    increasing security and convenience.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, OIDC builds on OAuth 2.0, adding an authentication layer.
    It leverages the OAuth authorization framework to verify a user’s identity through
    trusted providers such as Google or Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how OIDC complements OAuth 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: Some applications provide the ability to log in using other social media platforms.
    In this case, during the OAuth 2.0 flow, instead of logging into the new application,
    you’re redirected to your social media login page (the OpenID provider).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user authenticates with their social media credentials, proving their identity
    to the OpenID provider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the user’s consent, the OpenID provider shares their basic profile information
    (such as name and email) with the new application via an ID token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: OIDC enables features such as **single sign-on** ( **SSO** ), allowing you to
    access multiple applications using the same login credentials (think of logging
    into multiple websites with your Google account).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although OAuth 2.0 and OIDC flows are similar and interconnected, they serve
    different purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Focus** : OAuth 2.0 acts on authorization (granting access to data), while
    OIDC acts on the authentication layer (verifying user identity).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sharing information** : OAuth 2.0 mainly deals with access tokens, while
    OIDC introduces ID tokens containing user profile information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can think of OAuth 2.0 as a key that opens the door to a house, while OIDC
    provides identity verification so that this key can be received.
  prefs: []
  type: TYPE_NORMAL
- en: 'This flow is quite common in several applications we use, as shown in *Figure
    6* *.4* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Basic OAuth 2.0 flow](img/B21788_06_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Basic OAuth 2.0 flow
  prefs: []
  type: TYPE_NORMAL
- en: The authorization and authentication flows are constantly used by applications,
    allowing both to identify who the users are and define the type of permissions
    that these users can execute in a web system or API.
  prefs: []
  type: TYPE_NORMAL
- en: Despite this straightforward explanation of the OAuth 2.0 and OIDC protocols,
    as well as concepts of authorization and authentication, the task of implementing
    this approach isn’t simple and depends on some important mechanisms to ensure
    these functionalities are running correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Due to this, ASP.NET Core 9 has abstractions that support the development of
    identity management while following the standards outlined so far. The abstraction
    that implements these resources is known as ASP.NET Core Identity. It has been
    evolving with each new version of the framework and allows teams to use security
    best practices in their authorization and authentication flows, as well as integrate
    with other identity providers while allowing customizations to be made. We’ll
    learn more about this approach in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the ASP.NET Core Identity framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern applications interact with different types of technologies, protocols,
    and standards. As we’ve been learning, security is extremely important at any
    level of a solution’s implementation flow. A book could easily be dedicated to
    the subject of authorization and authentication.
  prefs: []
  type: TYPE_NORMAL
- en: However, the ASP.NET Core 9 platform has been evolving every year and as a result,
    the identity management model has undergone several improvements, in addition
    to some dependencies being eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to implement authorization and authentication in our applications,
    we have ASP.NET Core Identity. It’s a membership system that adds capabilities
    to web-based applications developed in ASP.NET Core 9 and operates in both authentication
    and authorization flows.
  prefs: []
  type: TYPE_NORMAL
- en: The set of features available in ASP.NET Core Identity includes APIs, a UI,
    databases between user identity management and credentials, and the ability to
    grant and revoke permissions. This is in addition to features such as integration
    with external logins, **two-factor authentication** ( **2FA** ), password management,
    being able to block and activate accounts, and providing authentication in applications.
  prefs: []
  type: TYPE_NORMAL
- en: Before we learn how to integrate an application with ASP.NET Core identity,
    let’s learn more about its structure.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the ASP.NET Core Identity architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASP.NET Core Identity has an architectural structure that’s divided into the
    following layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identity manager** : These are service classes that are responsible for implementing
    the business logic that involves identities. We can find classes such as **UserManager**
    for user management and **RoleManager** for role management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identity store** : The identity store is the domain entity that represents
    each piece of data in a database. We can see the identity store as a table in
    the database that’s mapped to a class such as **UserStore** or **RoleStore** ,
    among others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data access layer** : These are classes that have the necessary logic to
    interact with the database so that they can persist and retrieve identity-related
    information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data source** : The data source is the data mechanism that will be used for
    persistence. By default, ASP.NET Core Identity uses **SQL Server** . However,
    there are other databases available, and there’s the possibility of customizing
    other data sources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These four layers have well-defined responsibilities and are fully extensible,
    bringing flexibility to development and allowing the identity mechanism to be
    customized according to the context required in an organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core Identity manages both authentication and authorization and works
    with the following types of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Users** : These represent users in the application. This entity has some
    basic attributes implemented, but they can easily be extended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User claims** : These are a set of statements (claims) about a user. Claims
    add information to the user’s identity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User logins** : These provide information about authentication with external
    providers such as Facebook, Google, Microsoft, and others, if your application
    has any integration with these providers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Roles** : These are authorization groups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the information that’s managed by the ASP.NET Core Identity platform,
    we have what we need to implement authorization and authentication flows in our
    applications. However, this is a robust and highly customizable framework that
    allows various customizations to be implemented across identity types.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Identity
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to customize Identity, please consult the official documentation:
    [https://learn.microsoft.com/en-us/aspnet/core/security/authentication/customize-identity-model?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/customize-identity-model?view=aspnetcore-9.0)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know more about the architectural structure of ASP.NET Core Identity,
    it’s time to add it to an application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with integrating ASP.NET Core Identity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have greater knowledge about some of the security perspectives that
    are part of the context of an application, it’s time to use ASP.NET Core Identity
    to add authorization and authentication flows.
  prefs: []
  type: TYPE_NORMAL
- en: As a basis, we’ll use the source code available in this book’s GitHub repository,
    as mentioned in the *Technical requirements* section, where you’ll be able to
    download the complete solution. The project we’ll be using is a version of the
    API project that we created in [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078)
    since all assumptions related to database configurations have been created. Therefore,
    we’ll leverage the API structure and database structure created earlier. The objective
    is to implement Identity.
  prefs: []
  type: TYPE_NORMAL
- en: Database settings
  prefs: []
  type: TYPE_NORMAL
- en: When starting a new project, you’ll need to configure **EntityFrameworkCore**
    and connect the application to a database, as we learned in [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078)
    . This way, you’ll be able to follow along and configure ASP.NET Core Identity
    with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this application, which is a web API that connects to a SQL Server database,
    we’ll use the same model we learned about in [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078)
    and use **EntityFrameworkCore** . To do so, we’ll need to add one more library:
    **Microsoft.AspNetCore.Identity.EntityFrameworkCore** . This library allows Identity
    to work with Entity Framework Core.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure this library has been added to your project by opening the **WorkingWithIdentity.csproj**
    file or running the following command in your terminal, inside the application
    directory, to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating the WorkingWithIdentity.csproj project
  prefs: []
  type: TYPE_NORMAL
- en: 'The **WorkingWithIdentity.csproj** project is a web API that will be protected
    with ASP.NET Core Identity and is available in this book’s GitHub repository,
    as described in the *Technical requirements* section. However, if you want to
    create the project for yourself, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1. Open your operating system’s terminal and access the folder where the project
    should be created.
  prefs: []
  type: TYPE_NORMAL
- en: '2. Run the following command to create the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dotnet new webapi -** **n WorkingWithIdentity**'
  prefs: []
  type: TYPE_NORMAL
- en: '3. Access the new project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '**cd WorkingWithIdentity**'
  prefs: []
  type: TYPE_NORMAL
- en: '4. Add the following NuGet packages, all of which are necessary for using the
    SQL Server database:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dotnet add** **package Microsoft.EntityFrameworkCore**'
  prefs: []
  type: TYPE_NORMAL
- en: '**dotnet add** **package Microsoft.EntityFrameworkCore.SqlServer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**dotnet add** **package Microsoft.EntityFrameworkCore.Design**'
  prefs: []
  type: TYPE_NORMAL
- en: '5. Make sure you have the **dotnet-ef** tool installed. To do so, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dotnet tool install** **--** **global** **dotnet-ef**'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the project already contains the **Microsoft.AspNetCore.Identity**
    library since we added it when we created the project. However, we still need
    to follow a few more steps to configure the project. Let’s start by configuring
    the database context so that the stores and Identity models can be mapped by **EntityFramework**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the database context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For ASP.NET Core Identity to be able to manage **users** , **roles** , **claims**
    , and **tokens** , we must configure the application by adding this capability
    to the **DbContext** class, which is responsible for interacting with the SQL
    Server database.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we must change the **BankingDbContext** class, available in the
    **Context** directory of the reference project in this chapter’s repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to change the inheritance class to **IdentityDbContext<IdentityUser>**
    , which is located in the **Microsoft.AspNetCore.Identity.EntityFrameworkCore**
    namespace. Once we’ve done this, we’ll have the following updated class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we learned in [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078) , the **DbContext**
    class is an abstraction of **Entity Framework Core** that allows the application
    to interact with the database, where each entity in the database is represented
    by properties of the **DbSet** type. This allows classes to be mapped to entities
    and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: By changing the inheritance of the **BankingDbContext** class to **IdentityDb**
    **Context<IdentityUser>** , we’re reusing the default **DbContext** implementation
    from ASP.NET Identity Core. This contains the **DbSet** type for mapping the Identity
    tables that will be part of the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that all the database settings are available in the application,
    open the **Program.cs** file and make sure that the following line of code exists
    in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It’s very important to configure the **DbContext** class in the ASP.NET Core
    dependency injection container. In this case, we added the **BankingDbContext**
    class to the dependency injection context while also configuring the use of SQL
    Server, whose connection will be based on the **ConnectionString** value, which
    is passed as a parameter to the **UseSqlServer** method. This **ConnectionString**
    is obtained through the application settings, which in this case can be found
    in the **appsettings.json** file.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have all the necessary configurations so that ASP.NET Core
    Identity is configured in the data layer. In the next section, we’ll update the
    database so that we can add the necessary tables for identity management.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078) , we created an API that
    simulates digital bank operations and connected it to a database using Entity
    Framework Core. For this example, we’ll use the same database – that is, **dbBanking**
    . Currently, it has the following data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The structure of the dbBanking database](img/B21788_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – The structure of the dbBanking database
  prefs: []
  type: TYPE_NORMAL
- en: The **dbBanking** database consists of four tables, three of which are part
    of the application context – that is, **dbo.Accounts** , **dbo.Customers** , and
    **dbo.Movements** . The fourth table, **dbo.EFMigrationsHistory** , is responsible
    for managing the status of changes that are made to the database using migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Database migrations
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078) , we explored how migrations
    work, their importance during application development, and changes that can be
    made dynamically to the database. If you want to learn more about how ASP.NET
    Core 9 migrations works, please refer to [https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli](https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The **dbo.EFMigrationsHistory** table contains the history of the first entities
    that were created for the bank API. You can check the history that’s been generated
    through the code in the application’s directory structure, in the **Migrations**
    folder, as shown in *Figure 6* *.6* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Migrations classes for the API](img/B21788_06_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Migrations classes for the API
  prefs: []
  type: TYPE_NORMAL
- en: These classes are automatically generated by the Entity Framework Core command-line
    tool and should not be changed manually.
  prefs: []
  type: TYPE_NORMAL
- en: After making changes to the **DbContext** class and adding the ASP.NET Core
    Identity models, we must change the database. To do so, we’ll create a new migration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, open a terminal of your choice, access the root directory of the
    **WorkingWithIdentity** application, and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command uses Entity Framework Core’s **ef** tool and adds a migration
    named **IdentityModels** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, when opening the project’s **Migrations** folder, we can analyze which
    new classes were created, as shown in *Figure 6* *.7* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Migration classes for the Identity model](img/B21788_06_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Migration classes for the Identity model
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the migration structure for the database, we must update **dbBanking**
    so that it includes the Identity tables. To do this, in your preferred terminal,
    run the following command in the project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command reads the migrations available in the project, analyzes
    the migration history in the **dbo.EFMigrationsHistory** table in the database,
    and applies the updates, which in this case involve creating the tables necessary
    for ASP.NET Core Identity to work correctly. We’ll see the new tables that have
    been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – The database now contains ASP.NET Core Identity tables](img/B21788_06_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – The database now contains ASP.NET Core Identity tables
  prefs: []
  type: TYPE_NORMAL
- en: With that, all basic ASP.NET Core Identity settings related to the data model
    have been added successfully. However, we still need to add some other configurations
    to the project so that the application is capable of handling authorization and
    authentication. So, in the next section, we’ll add ASP.NET Core Identity services
    to the application’s dependency injection context.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ASP.NET Core Identity services and routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asp.Net Core Identity contains the necessary abstractions to deal with authorization
    and authentication mechanisms using the services available in the dependency injection
    container, in addition to wheels for authentication and token generation.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it’s necessary to activate these abstractions explicitly. To do so,
    we must add a few lines of code to the application. Open the **Program.cs** file
    so that we can edit them. At this point, we must follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the required Identity namespace – that is, **using Microsoft.AspNetCore.identity;**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the authentication services that are responsible for determining the identity
    of users to the dependency injection container, as well as the authentication
    method. In this case, we’ll be using a bearer token: **builder.Services.AddAuthentication().AddBearerToken();**
    .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the authorization services to the dependency injection container by running
    **builder.Services.AddAuthorization();** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the Identity APIs and configure data access through Entity Framework Core
    by running **builder.Services.AddIdentityApiEndpoints<IdentityUser>().AddEntityFrameworkStores<BankingDbContext>();**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map the Identity endpoints using **app.MapIdentityApi<IdentityUser>();** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add each request authentication middleware to the application’s request processing
    pipeline, using the settings defined by **AddAuthentication()** to validate and
    define the user’s identity: **app.UseAuthentication();** .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add middleware that checks authorization policies against the identity of the
    authenticated user to determine whether the user is allowed to proceed with the
    current request: **app.UseAuthorization();** .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By making these changes, we’ll have the following complete code in the **Program.cs**
    file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Register account and customer routes
  prefs: []
  type: TYPE_NORMAL
- en: The routes that are responsible for processing requests for the Account and
    Customers APIs were registered through the **app.RegisterAccountRoutes** and **app.RegisterCustomerRoutes**
    extension methods, as highlighted in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: This is a good practice for correctly separating responsibilities, as well as
    improving the maintainability of the **Program.cs** file code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create these extension methods, two classes were created, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**public static** **class AccountRoutes**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**public static** **void RegisterAccountRoutes(this**'
  prefs: []
  type: TYPE_NORMAL
- en: '**IEndpointRouteBuilder routes)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**var group =** **routes.MapGroup("/accounts");**'
  prefs: []
  type: TYPE_NORMAL
- en: '**//** **GET: /accounts**'
  prefs: []
  type: TYPE_NORMAL
- en: '**group.MapGet("/", async (BankingDbContext** **dbContext) =>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**return await** **dbContext.Accounts.Include(a =>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**a.Customer)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**.Include(a =>** **a.Movements)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**.** **ToListAsync();**'
  prefs: []
  type: TYPE_NORMAL
- en: '**});**'
  prefs: []
  type: TYPE_NORMAL
- en: '**//** **other methods**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**public static** **class CustomerRoutes**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**public static** **void RegisterCustomerRoutes(this**'
  prefs: []
  type: TYPE_NORMAL
- en: '**IEndpointRouteBuilder routes)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**var group =** **routes.MapGroup("/customers");**'
  prefs: []
  type: TYPE_NORMAL
- en: '**//** **GET: /customers**'
  prefs: []
  type: TYPE_NORMAL
- en: '**group.MapGet("/", async (BankingDbContext** **dbContext) =>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**return** **await dbContext.Customers.ToListAsync();**'
  prefs: []
  type: TYPE_NORMAL
- en: '**});**'
  prefs: []
  type: TYPE_NORMAL
- en: '**//** **other methods**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: The extension classes that were created here have a static method that’s responsible
    for registering the routes of the respective entities. This is a practice that
    makes code more organized and easier to read and maintain. To learn more about
    creating extension methods, go to [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method)
    .
  prefs: []
  type: TYPE_NORMAL
- en: When analyzing the preceding code, it’s very important to consider the order
    of the highlighted lines of code; otherwise, the objects and route mappings won’t
    work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: So far, the solution code presents a configuration model that already allows
    us to benefit from the authorization and authentication features of ASP.NET Core
    Identity. However, there are some cases where there’s a need to customize access
    types based on user roles. Fortunately, ASP.NET Core 9 offers a powerful feature
    that allows us to segregate the type of access to application resources, as we
    will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based authorization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To have greater control over the user authorization flow in the application,
    we can implement **role-based authorization** . This role-based control allows
    you to segregate the type of access to parts of your application based on the
    roles that have been assigned to users. Imagine a scenario where there are two
    roles: **Administrator** and **Reader** . By using the role-based authorization
    approach, you can ensure that only users authorized to certain areas of the application
    can access specific resources or perform specific actions in an application.'
  prefs: []
  type: TYPE_NORMAL
- en: In ASP.NET Core 9, the role-based authorization approach can be implemented
    by defining policies, which extend role-based authorization with more complex
    logic, offering fine-grained control over user permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Once a policy has been defined, it can be applied to controllers, actions, or
    even Razor Pages to enforce the desired authorization behavior. Policies make
    your authorization logic more modular and reusable. This is especially useful
    in larger applications, where access control can become complex.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider a scenario where you want to create a policy that only
    allows users with the **Admin** role to access certain administrative resources.
    Also, you might want to create another policy that only allows users with the
    **Manager** role to be employed for over 1 year so that they can access specific
    reports. These policies can be defined in the **Program.cs** file and then applied
    to controllers or actions using the **[** **Authorize]** attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a simple example of a policy that could be added to a **Program.cs**
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we configured a policy called **AdminOnly** that sets
    a rule where the user has the **Admin** role. The **[Authorize]** attribute is
    then applied to an endpoint and uses the policy we created earlier, restricting
    access to users who meet the policy criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at a more complex example. Here, a custom policy has been defined
    that checks the user’s role and provides an additional claim that requires the
    user’s employment duration to be 1 year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the **EmployeeWithExperience** policy requires that the user
    has the **Manager** role and owns a claim named **EmploymentDuration** with a
    value of **1Year** . This policy applies to the **/reports** endpoint, restricting
    access to managers only.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based authorization and policies give you a powerful way to manage access
    to your application’s resources, allowing you to build complex authorization logic
    that goes beyond simple role checks and incorporate additional conditions and
    claims as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know more about ASP.NET Core Identity, have integrated it into our
    application, and know how to segregate access to application resources by implementing
    authorization policies, it’s time to add restrictions to the application’s routes.
  prefs: []
  type: TYPE_NORMAL
- en: Securing APIs with ASP.NET Core Identity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, the application has been fully integrated with ASP.NET Core
    Identity. Now, we’ll run it so that we can analyze the results. Open a terminal
    of your choice and access the application directory. Then, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'An address in **http://localhost:<port>** format will be provided. The port
    number may be different from the one shown in this example, but the execution
    will be the same. Access the **http://localhost:<port>/swagger/index.html** address;
    you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Banking API integrated with ASP.NET Core Identity](img/B21788_06_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Banking API integrated with ASP.NET Core Identity
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, new routes were added to the API. These routes are the APIs that
    are provided by ASP.NET Core Identity. Each API allows us to manage the application’s
    users and add different capabilities, such as password recovery, user creation,
    or password reset.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, upon attempting to execute an endpoint, such as performing a **GET**
    request on the **/accounts** API, we realized that we were able to obtain a valid
    response. To perform the test, simply open the **GET** method of the **/accounts**
    API, click the **Try Out** button, and then the **Execute** button. We should
    get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Requesting an API without authentication and authorization](img/B21788_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Requesting an API without authentication and authorization
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, we have an HTTP status code of **200** , which means that the
    request was successful, even if the result didn’t return any existing account
    records in the database. If you have any records registered in this table in your
    local database, the result will be an array of account objects serialized in JSON
    format.
  prefs: []
  type: TYPE_NORMAL
- en: However, we want to add authentication and authorization processes to the application’s
    APIs. To do so, we must make some changes to the source code.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, each API has its routes registered in the **Program.cs** file. These
    routes act as entry points for requests. Since we want to protect each route so
    that only known and authorized users can consume the API, we must add a configuration
    to the routes so that when someone attempts to request the API without being authenticated,
    the request must return an HTTP **401** status code, informing the API consumer
    that there’s a need for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll learn how to protect routes and prevent unauthorized
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: Securing application routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even if all authentication and authorization settings are present in the application,
    it’s necessary to determine what should be protected and what shouldn’t.
  prefs: []
  type: TYPE_NORMAL
- en: One of the ways we can ensure that a given API method is protected by authentication
    and authorization middleware is by adding an explicit configuration to the routes.
  prefs: []
  type: TYPE_NORMAL
- en: In the application that we’re working on, the API routes were implemented in
    separate files as **extension methods** , as a good practice. So, let’s make the
    necessary change in the **AccountHandler.cs** file, located in the application’s
    **RouteHandler** directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we’ll configure the **/accounts** route so that it only accepts
    requests if the user is authenticated. Let’s look at the changed code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we added the **RequireAuthorization()** method call. We’ve already learned
    that authorization is a process that validates a user’s permissions, while authentication
    involves identifying the user. In this case, if the user isn’t authenticated,
    they can’t be authorized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, in a terminal of your choice, inside the application directory, execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll request the **/accounts** route. However, let’s execute the **Postman**
    application first. Follow the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **File** | **New** | **HTTP** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new tab will open where you can make a request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the URL of the running application – that is, **http://localhost:<port>/accounts**
    – and check whether the selected method is **GET** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, click on the **Send** button. We’ll get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Requesting the protected route](img/B21788_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Requesting the protected route
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6* *.11* highlights the return of the request with an HTTP status code
    of 401, which means that the request wasn’t authorized.'
  prefs: []
  type: TYPE_NORMAL
- en: For a successful request for this route to be made, we must log in and configure
    the request with the authenticated user’s information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before logging in, we must create a user in the application. To do this, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new HTTP request in Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the request type to **POST** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add **http://localhost:<port>/register** as the route. This is the default route
    for creating ASP.NET Core Identity users that will be added to the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, we need to define the body of the request. To do this, click
    on the **Body** tab, select the **raw** option, and add the JSON shown in *Figure
    6* *.12* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Configuring the body of the register user request](img/B21788_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Configuring the body of the register user request
  prefs: []
  type: TYPE_NORMAL
- en: You can change the properties of the JSON object to your liking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click the **Send** button to make the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upon being executed, we should get a response similar to the one shown in *Figure
    6* *.13* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13: Registering a new user using ASP.NET Core Identity](img/B21788_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: Registering a new user using ASP.NET Core Identity'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6* *.13* displays an HTTP status code of 200, informing us that the
    request was successful and that a new user has been registered in the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we must log in. We’ll do so using Postman. Create a new HTTP
    request and perform the following steps to configure the request:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the request type to **POST** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the URL to **http://localhost:<port>/login** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Body** tab, then the **raw** option, and add the following JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click the **Send** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you’ve added the JSON parameters according to the user data you created
    in your environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upon performing the request, you should see the following response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Getting a login response](img/B21788_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – Getting a login response
  prefs: []
  type: TYPE_NORMAL
- en: 'In response to the login request, we can see that a JSON object with some important
    properties has been returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '**tokenType** : This value will always be **Bearer** , which indicates that
    this response provides a **Bearer** token in the form of an opaque **accessToken**
    , as we configured in the **Program.cs** file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**accessToken** : This is the token that’s generated for the authenticated
    user. It must be sent as part of the authorization request header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**expiresIn** : A value in seconds that represents the expiration time of **accessToken**
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**refreshToken** : If set, we can obtain a new **access_token** value upon
    expiration by using a refresh endpoint without having to re-enter user credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values displayed in *Figure 6* *.14* will be different for each request
    and don’t represent a **JWT** . The **access token** is generated and encrypted
    in a proprietary way in this version of ASP.NET Core Identity and doesn’t follow
    a known convention. However, it’s possible to change to a **JWT** if you wish,
    as well as other configuration parameters of the token generation process.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core Identity configurations
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core Identity offers different authentication options, including JWT
    ( [https://jwt.io/introduction](https://jwt.io/introduction) ), cookies, and other
    settings. To learn more about the different configuration options, go to [https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.identity.identityoptions?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.identity.identityoptions?view=aspnetcore-9.0)
    .
  prefs: []
  type: TYPE_NORMAL
- en: However, the token-based approach we’re using, even though it doesn’t involve
    a JWT, uses the same configuration process as a request being made with the authenticated
    user’s credentials. In the next section, we’ll use the **access token** value
    to make a request on the **/accounts** route and obtain a valid response.
  prefs: []
  type: TYPE_NORMAL
- en: Requesting an API with the access token
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The access token contains the authenticated user’s information in encrypted
    form.
  prefs: []
  type: TYPE_NORMAL
- en: 'For us to make a valid request on the **/accounts** route, we’ll need to pass
    the token as a parameter in the request header. So, copy the access token value
    and, in Postman, open the tab that contains the request, as shown in *Figure 6*
    *.11* , for the **/accounts** route. Then, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **GET** request tab for the **/accounts** route, click on the **Authorization**
    tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Type** , select the **Bearer** **Token** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Token** field, paste the value of the access token that you obtained
    via the login request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Send** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As shown in *Figure 6* *.15* , an empty array is returned since no accounts
    have been registered in the database. Note that the HTTP status code is **200**
    , which means that it was a successful request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Successful accounts request](img/B21788_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – Successful accounts request
  prefs: []
  type: TYPE_NORMAL
- en: So far, the application is working as expected. However, it’s important to understand
    how this authorization process works.
  prefs: []
  type: TYPE_NORMAL
- en: When requesting the account route again, we inform the access token, as configured
    previously. Despite Postman having a user-friendly UI, when selecting the authentication
    type and entering the access token, Postman automatically adds an HTTP header.
    HTTP headers are key/value pairs that are part of requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this request, the header was created with the authorization key and the
    access token value. You can check this header by clicking on the **Headers** tab
    and viewing the hidden headers, as shown in *Figure 6* *.16* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – The authorization HTTP header](img/B21788_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – The authorization HTTP header
  prefs: []
  type: TYPE_NORMAL
- en: When making the request, the authentication and authorization **middleware**
    comes into action. The authentication middleware reads the token that was informed
    in the authorization header and fills in the user credentials for the request
    in the **HttpContext.User** object, which is part of the request. This object
    allows us to access information such as **claims** , which contain data such as
    the user’s name and email, and **roles** , which allow us to determine the user’s
    access type, such as admin, member, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The ASP.NET Core 9 HttpContext object
  prefs: []
  type: TYPE_NORMAL
- en: In ASP.NET Core, **HttpContext.User** is a core property that represents the
    user security context associated with an HTTP request. This property is an instance
    of **ClaimsPrincipal** , a .NET class that contains the user’s identity in the
    form of claims. **HttpContext.User** is a key element in handling user authentication
    and authorization in an ASP.NET Core application.
  prefs: []
  type: TYPE_NORMAL
- en: During the authentication process, when a request arrives at the application,
    the authentication middleware reads the authentication tokens or cookies attached
    to the request, validates them, and constructs a **ClaimsPrincipal** object. The
    **ClaimsPrincipal** object can contain one or more instances of **ClaimsIdentity**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Each **ClaimsIdentity** instance can contain multiple claims. A claim is a statement
    about a subject that’s been made by an issuer and can represent the user’s identity
    attributes, such as name, role, email, and more.
  prefs: []
  type: TYPE_NORMAL
- en: This process allows the use of **HttpContext.User** in application-wide authorization
    checks to determine whether the current user has permission to perform certain
    operations to ensure that only properly authenticated and authorized users can
    access certain resources or perform specific actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the use of **HttpContext.User** when executing an
    action. This object is automatically populated by the execution pipeline through
    middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '**public** **IActionResult ExampleAction(){**'
  prefs: []
  type: TYPE_NORMAL
- en: '**var user =** **HttpContext.User;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**if (user.Identity.IsAuthenticated)     {**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// Do something for** **authenticated users**'
  prefs: []
  type: TYPE_NORMAL
- en: '**var userName =** **user.Identity.Name;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// Get the** **user''s name**'
  prefs: []
  type: TYPE_NORMAL
- en: '**return** **Content($"Welcome, {userName}");**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**else**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// Handle** **non-authenticated users**'
  prefs: []
  type: TYPE_NORMAL
- en: '**return Unauthorized("You must be logged in to** **access this.");**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about **HttpContext** at [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-context?view=aspnetcore-8.0#httpcontext-user](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-context?view=aspnetcore-8.0#httpcontext-user)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Authorization middleware analyzes whether the requested route requires authorization.
    If so, it decrypts the token, analyzes whether it’s a valid token, and allows
    the request on the route to be made correctly.
  prefs: []
  type: TYPE_NORMAL
- en: What is middleware?
  prefs: []
  type: TYPE_NORMAL
- en: During the execution flow of a request in ASP.NET Core 9, several types of processes
    are carried out, such as identifying the route to be executed, among other functionalities.
    This flow is called a pipeline. In some cases, there’s a need to add functionality
    to the execution pipeline. This is done through middleware, something we implemented
    by adding the **app.UseAuthtentication()** and **app.UseAuthorization()** method
    calls to the **Program.cs** file, which allows us to pre-process the request for
    authentication and authorization requirements. Through middleware, it’s possible
    to add functionality to both requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll learn more about middleware in [*Chapter 8*](B21788_08.xhtml#_idTextAnchor132)
    .
  prefs: []
  type: TYPE_NORMAL
- en: With each API request, the token is sent so that the user information and their
    respective accesses are loaded during the request execution flow. This is a characteristic
    of cloud-native applications. The stateless approach allows applications to be
    scalable and resilient and ensures the server doesn’t retain any information about
    a client’s state between requests, eliminating the need to manage session state.
    This leads to easier scaling and load balancing, makes it easier to scale servers
    when the need arises to handle high user demand, and allows each server instance
    to be able to handle any request without needing to know the context of previous
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: By not relying on server-side state, developers can avoid issues related to
    session management, such as session persistence, synchronization across distributed
    systems, and resource locking.
  prefs: []
  type: TYPE_NORMAL
- en: Modern applications must have security as a premise by design, and the implementation
    of authentication and authorization has several advantages within the context
    of applications. However, other aspects related to security are linked not only
    to the functionalities available to users but also to the application’s source
    code. In the next section, we’ll learn how to reinforce security in applications.
  prefs: []
  type: TYPE_NORMAL
- en: Strengthening application security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For us to be able to create secure web-based applications, we must go beyond
    implementing the use of a security layer based on authentication and authorization,
    something we implemented when using ASP.NET Core Identity.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 9 allows us to deal with security as a premise when developing
    applications, providing tools and mechanisms that facilitate the implementation
    of features that minimize possible loopholes, something that can generate attacks
    from malicious users.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s learn about some good security practices that should be part of every
    software engineer’s toolbox. We’ll start by understanding how we can improve the
    process of managing sensitive configurations in our development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Managing secrets properly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every application has configurations and some of these can be sensitive, such
    as database connections, encryption keys, and even security keys for accessing
    external resources.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve learned that it’s good practice to keep such settings separate
    from the C# source code and that we can manage settings through files such as
    **appsettings.json** and even environment variables. ASP.NET Core 9 allows us
    to handle external configuration management.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the settings hard-coded is a bad practice since to change any hard-coded
    parameter, we must recompile the application. In addition, there’s the possibility
    of malicious users decompiling the application if they have access to the binaries,
    and then obtaining sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: Obfuscator
  prefs: []
  type: TYPE_NORMAL
- en: Code obfuscation refers to the process of transforming application source code
    into a form that’s difficult for humans to understand but can still be executed
    by a computer. This technique is primarily used to protect intellectual property
    by making it difficult for attackers or unauthorized users to reverse engineer
    the code and understand its logic.
  prefs: []
  type: TYPE_NORMAL
- en: The process of obfuscation involves several techniques, such as renaming variables
    and methods to meaningless symbols, removing metadata, encrypting strings, and
    altering the control flow to make the code more complex. For more information,
    go to [https://learn.microsoft.com/en-us/visualstudio/ide/dotfuscator/?view=vs-2022](https://learn.microsoft.com/en-us/visualstudio/ide/dotfuscator/?view=vs-2022)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a situation where our application uses an API key to connect to a payment
    gateway to process transactions from an online store, or even the database connection
    string. If this key is exposed, malicious users can potentially manipulate transaction
    data, access sensitive information, and even delete your database.
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking that since your code is in a private repository, and all
    settings are being kept in **appsettings.json** files, this problem is solved.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, since it’s a private repository, the chances of an attacker gaining
    access to the data aren’t very high. However, consider that your company may work
    with employees and third-party companies that can access the data in your repository.
  prefs: []
  type: TYPE_NORMAL
- en: While it’s good practice to manage settings in **appsettings.json** files, this
    isn’t a good approach for sensitive information. With this, we avoid synchronizing
    the source code of applications with external repositories containing information
    that shouldn’t be shared.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, ASP.NET Core 9 implements the best development practices and provides
    secret management in your local environment. Proper secret management ensures
    that sensitive data, such as API keys, isn’t hard-coded into your application’s
    source code but is stored and accessed securely, protecting your infrastructure
    and data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: The Secret Manager tool is included in the .NET Core SDK, so you typically don’t
    need to install anything else if you have the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using Secret Manager, you need to initialize it for your project.
    Navigate to the project’s **WorkingWithIdentity** directory, which we worked on
    previously, in the Command Prompt or terminal where your **.csproj** file is located.
    Then, run the following command to initialize secret storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command adds a **UserSecretsId** element within a **PropertyGroup**
    value to your **.csproj** (project file). This ID uniquely identifies your project’s
    secrets.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify the addition of the **UserSecretsId** element by opening the
    **.csproj** file in your code editor, as shown in *Figure 6* *.17* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – The UserSecretsId element configured in the .csproj file](img/B21788_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – The UserSecretsId element configured in the .csproj file
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll configure the connection string with the SQL Server database. To
    do this, we must add some new code by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Secrets naming convention
  prefs: []
  type: TYPE_NORMAL
- en: The notation commonly uses colons ( **:** ) to separate different levels of
    a hierarchy in the key names of secrets. This structure not only helps in organizing
    the keys logically but also aligns with how the ASP.NET Core 9 configuration system
    retrieves values from various configuration sources, such as **appsettings.json**
    , environment variables, and Secret Manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **WorkingWithIdentity** application, we have the following configuration
    in the **appsettings.json** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**"** **ConnectionStrings" {**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"** **BankingDbContext": "..."**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding JSON represents a property of the **object** type called **ConnectionStrings**
    that has a string property called **BankingDbContext** .
  prefs: []
  type: TYPE_NORMAL
- en: Based on this, the secret is called **ConnectionStrings:BankingDbContext** .
    Here, **ConnectionStrings** is the top-level category and **BankingDbContext**
    is the actual key containing the respective secret – in this case, the SQL Server
    database connection string. This notation helps to logically group related settings.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a convention used by ASP.NET Core 9, there’s no need to change
    the application’s source code to obtain the database connection string.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using environment variables (which don’t allow colons in variable names
    on some operating systems), colon separators are typically replaced with double
    underscores ( **__** ). So, if you were defining these secrets via environment
    variables in a production environment, you would define them like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ConnectionStrings__BankingDbContext**'
  prefs: []
  type: TYPE_NORMAL
- en: This naming convention ensures that when the ASP.NET Core configuration system
    reads the environment variables, it can reconstruct the hierarchy and treat them
    equivalently to secrets defined in **appsettings.json** or Secret Manager.
  prefs: []
  type: TYPE_NORMAL
- en: There’s no need to change the application code to obtain the secret since this
    is a feature of ASP.NET Core 9 and works in the same way if you want to use environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The secret that’s created is kept in the operating system; its location may
    vary from environment to environment. However, you can manage secrets using the
    **user-secrets** tool. For example, you can use it to list the secrets that exist
    on your local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the following command to remove a specific secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even clear all secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: All secrets information is kept in your operating system. When integrating the
    source code with your remote code repository, the secrets won’t be shared.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the Secret Manager tool is intended for development purposes
    only. For production environments, you should use a secure vault such as **Azure
    Key Vault** , **AWS Secrets Manager** , or another secure means of managing sensitive
    configuration data. We’ll learn more about configuration management in [*Chapter
    9*](B21788_09.xhtml#_idTextAnchor146) .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to better manage application secrets, let’s learn about
    other good security practices, including the use of **Hypertext Transfer Protocol
    Secure** ( **HTTPS** ) and **Cross-Origin Resource** **Sharing** ( **CORS** ).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing HTTPS and working with CORS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTPS enforcement is important for ensuring secure communication between clients
    and servers by encrypting data transmitted over the network. As we’ve already
    learned, ASP.NET Core 9 provides us with integrated middleware to enforce HTTPS,
    which can be configured to redirect all HTTP requests to HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enforce HTTPS in an ASP.NET Core 9 application, simply add the following
    line of code to the **Program.cs** file to add a middleware to the application’s
    execution pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to know that adding the middleware that enforces the use of HTTPS
    is a configuration step for the application. Likewise, you must also configure
    your web server (for example, IIS, NGINX, Azure App Services, and so on) to enforce
    HTTPS and obtain a valid SSL/TLS certificate from a trusted certificate authority.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to enforcing HTTPS, you can configure **CORS** , a feature that’s
    implemented by browsers to restrict web applications running on one origin from
    accessing resources on a different origin without explicit permission. It’s more
    common to see this type of behavior in SPA applications that use technologies
    such as **Angular** , **React** , or even pure **JavaScript** . When making an
    HTTP request through JavaScript, it’s executed in the browser, which, through
    the security mechanism, doesn’t allow a request on one origin server to be made
    to another server where the resource is hosted. Fortunately, ASP.NET Core 9 provides
    middleware to configure and manage CORS policies, allowing you to specify which
    origins, headers, and methods are allowed. This feature is interesting because
    we can only respond to certain requests based on a specific origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable and configure CORS in an ASP.NET Core 9 application, you can add
    the following code to the **Program.cs** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s understand the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**builder.Services.AddCors(options => { ... })** : This line adds CORS services
    to the application’s dependency injection container. The **options** parameter,
    which is of the **Action<CorsOptions>** type, allows you to configure CORS policies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**options.AddPolicy** : In this line, we’re adding a new policy named **AllowSpecificOrigin**
    . The **builder** parameter in the Lambda expression is an instance of the **CorsPolicyBuilder**
    class, which provides methods to configure the policy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**builder.WithOrigins("https://myapp.com")** : The **WithOrigins** method defines
    the origins that are allowed to access the application’s resources. In this case,
    any requests coming from **https://myapp.com** will be allowed by this CORS policy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AllowAnyHeader()** : The **AllowAnyHeader** method allows any HTTP headers
    in the request, allowing the specified origin to include any headers without being
    blocked by the CORS policy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AllowAnyMethod()** : This method defines that any HTTP methods ( **GET**
    , **POST** , **PUT** , **DELETE** , and others) can be used in the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**app.UseCors("AllowSpecificOrigin")** : This triggers the CORS middleware
    in the request pipeline, referencing the previously created policy globally to
    all HTTP requests of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more about CORS
  prefs: []
  type: TYPE_NORMAL
- en: As defined earlier, CORS is an HTTP header-based mechanism that lets you tell
    the browser which origins can load resources. ASP.NET Core 9 has an excellent
    framework for implementing CORS in your applications. To learn more, go to [https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-9.0)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example illustrates the use of CORS in an ASP.NET Core 9 application.
    However, apart from the origin, it doesn’t have restrictions on the use of HTTP
    headers or methods. In some cases, it will be necessary to explicitly define the
    HTTP headers and methods that an origin can access.
  prefs: []
  type: TYPE_NORMAL
- en: However, the features available in ASP.NET Core 9 give us great flexibility
    in defining different policies for different origins, creating more restricted
    and specific rules for CORS. This is an important mechanism since the browser
    uses it to allow SPAs or other applications running on the client to be able to
    consume external resources appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: CORS is not a security mechanism, but its use is recommended. In the next section,
    we’ll talk about some security mechanisms we can use to prevent vulnerabilities
    in applications.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing common vulnerabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we talk about vulnerabilities in applications, several topics can be taken
    into consideration, such as source code, servers, credential management, protocols
    used, and encryption, among others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common vulnerabilities are already well known, but if they aren’t addressed
    in applications, they can cause some problems for organizations. ASP.NET Core
    9 offers mechanisms for dealing with several common threats in web applications:'
  prefs: []
  type: TYPE_NORMAL
- en: SQL injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-site** **scripting** ( **XSS** )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-site request** **forgery** ( **CSRF** )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s learn how to prevent each of these vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: SQL injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQL injection is a common attack where an attacker inserts malicious SQL code
    into an SQL query.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent SQL injection, always use parameterized queries or ORM frameworks
    such as Entity Framework, which handle query parameters safely and help us avoid
    string concatenation. We learned about this in the *Security topics in web* *applications*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: XSS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'XSS attacks occur when an attacker injects malicious scripts into a web page.
    To prevent XSS, always encode or escape user input before rendering it in the
    browser. This way, if there’s any code injection in an input, for example, it
    will be encoded with special characters. ASP.NET Core 9 provides built-in helpers
    to sanitize the output, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the JavaScript code was encoded, preventing the injected
    code from being sent and executed since, after encoding, it becomes just a string.
    To learn more about the vulnerabilities associated with XSS, go to [https://learn.microsoft.com/en-us/aspnet/core/security/cross-site-scripting?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/security/cross-site-scripting?view=aspnetcore-9.0)
    .
  prefs: []
  type: TYPE_NORMAL
- en: CSRF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CSRF is a type of security attack in which a malicious website tricks a user’s
    browser into performing actions on another website where the user is authenticated,
    without the user’s knowledge. This can lead to unauthorized actions such as changing
    settings, transferring funds, or making purchases. ASP.NET Core provides built-in
    anti-forgery tokens to prevent CSRF attacks. These tokens are automatically included
    in forms and validated on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use anti-forgery tokens in a simplified way in Razor Pages or MVC, add the
    following code to your form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we must add the **ValidateAntiForgeryToken** attribute to the
    action that will process the form request, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: ASP.NET Core 9 also ¢provides other mechanisms for dealing with this vulnerability.
    You can learn more at [https://learn.microsoft.com/en-us/aspnet/core/security/anti-request-forgery?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/security/anti-request-forgery?view=aspnetcore-9.0)
    .
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve learned, applications can contain several vulnerabilities that aren’t
    only associated with the source code but also with the hosting server, communication
    protocol, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, the ASP.NET Core 9 platform provides several mechanisms and best
    practices that, combined and related to the requirements of the applications,
    allow us to minimize risks and keep our solutions robust, secure, and reliable
    while following the best practices of modern applications. As we progress through
    this book, we’ll learn about more mechanisms and approaches we can use to create
    increasingly robust applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the principles of web application security
    and how they influence the development model and the interaction with users and
    other applications. In addition, we learned about the authorization and authentication
    processes, comparing the flows of these processes and getting to know standards
    such as OAuth 2.0 and OIDC. To reinforce our knowledge about authentication and
    authorization, we worked with ASP.NET Core Identity, which provides all the mechanisms
    that support user authentication and authorization in an application, integrated
    with a database for managing identities securely. To do so, we consumed information
    securely by providing tokens provided by ASP.NET Core Identity. Finally, we discussed
    how to strengthen the security of applications, understood secret management,
    and learned about techniques such as the use of CORS to prevent common vulnerabilities
    in web applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll learn how to add more capabilities to applications,
    understand how to implement best practices, and learn how to use caching and monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Applying Best Practices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we assume that you are more familiar with the ASP.NET Core
    9 platform and most of the powerful features available in this technology. As
    we advance in the knowledge of the platform and the need to develop increasingly
    rich solutions, we must stick to best practices. Therefore, we will cover topics
    related to the addition of features that interact with the application, including
    the challenge strategy, resilience, and best practices. We will also learn how
    to implement monitoring (Logging and Tracing), allowing software engineers the
    ability to deal with bug fixes, optimizations, and proactive actions. We will
    also explore the use of Middleware to customize the interaction flow in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B21788_07.xhtml#_idTextAnchor117) , *Adding Capabilities to Applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21788_08.xhtml#_idTextAnchor132) , *Enhancing Applications with
    Middleware in ASP.NET Core 9*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B21788_09.xhtml#_idTextAnchor146) , *Managing Application Settings*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
