["```cs\npublic App()\n{\n    InitializeComponent();\n    MainPage = new AppShell();\n}\n```", "```cs\n<Shell.FlyoutHeader>\n    ...\n</Shell.FlyoutHeader>\n<FlyoutItem Title=\"Quotes\" Icon=\"badge.png\">\n    <Tab Title=\"MVVM\">\n        <ShellContent\n            Title=\"Quote of the Day\"\n            ContentTemplate=\"{DataTemplate\n              local:MainPage_MVVM}\"\n            Icon=\"badge.png\" />\n    </Tab>\n    <Tab Title=\"Not MVVM\">\n        <ShellContent\n            Title=\"Quote of the Day\"\n            ContentTemplate=\"{DataTemplate local:MainPage}\"\n            Icon=\"badge.png\" />\n    </Tab>\n</FlyoutItem>\n<FlyoutItem Title=\"Settings\" Icon=\"settings.png\">\n    <ShellContent Title=\"Settings\"\n                  ContentTemplate=\"{DataTemplate\n                    local:SettingsPage}\" />\n</FlyoutItem>\n```", "```cs\nRouting.RegisterRoute(\"about\", typeof(AboutPage));\n```", "```cs\nawait Shell.Current.GoToAsync(\"about\");\n```", "```cs\nawait Shell.Current.GoToAsync(\"aboutIDictionary<string, object>:\n\n```", "```cs\n\n The reason I prefer this approach is the fact that this allows for passing complex objects, whereas the query string approach only allows for primitive types. And because I like consistency, I prefer to always use the dictionary.\nThese parameters, which we pass from one page to another, can be retrieved in different ways. One of them is to let the target page inherit the `Microsoft.Maui.Controls.IQueryAttributable` interface. As shown here, this interface defines just one method, `ApplyQueryAttributes`, that needs to be implemented:\n\n```", "```cs\n\n Moreover, if an instance of a class that implements the `IQueryAttributable` interface is assigned as the target page’s `BindingContext` (such as a ViewModel), that `ApplyQueryAttributes` method would also be invoked.\nAdhering to MVVM best practices\nI’ve often seen ViewModels inheriting the `IQueryAttributable` interface to receive navigation parameters. Although that works perfectly well, it goes against one of MVVM’s best practices, which says that ViewModels should be framework agnostic. This interface is .NET MAUI and Shell-specific, so it requires a dependency on these frameworks. Later in this chapter, I’ll show you how to not rely on the `IQueryAttributable` interface and still be able to receive navigation parameters.\nAs we mentioned previously, there are also other ways to receive parameters on the navigation target. I’m not going to dive deeper into that as we won’t be relying on that when we implement navigation in MVVM.\nLet’s have a look at one final aspect I want to highlight about Shell before we go further: Shell’s support for DI.\nSupporting Dependency Injection\nIn the previous chapter, we discussed DI and briefly touched on the fact that Shell allows pages to be resolved dynamically. This allowed us to define the ViewModel as a dependency of a page, which gets injected through the page’s constructor, as shown here:\n\n```", "```cs\n\n The only caveat here is that the page itself needs to be registered in the `IServiceCollection`, alongside its dependencies of course. With the following in place, we can navigate to `\"about\"` and Shell will resolve `AboutPage` and its dependencies – in this case, `AboutPageViewModel` – and inject them:\n\n```", "```cs\n\n There is even a convenient extension method in the .NET MAUI Community Toolkit that does all of this at once. Take a look:\n\n```", "```cs\n\n The same method also exists for adding the types as scoped or singleton, of course.\nIn this section, we merely scratched the surface of .NET MAUI Shell, exploring its routing system and support for DI. We saw how it provides a robust, flexible, and intuitive approach to structuring your application and managing navigation.\nHowever, remember that .NET MAUI Shell has a lot more to offer, including advanced features such as flyout customization, search handling, and life cycle events, among others. For deeper insights into these aspects of .NET MAUI Shell, be sure to visit the *Further reading* section at the end of this chapter.\nNow that we’ve established a solid understanding of .NET MAUI Shell, it’s time to see how we can leverage it within MVVM. In the next section, we’ll focus on setting up navigation in our *Recipes!* app while adhering to the MVVM pattern. So, let’s dive right in!\nSetting up navigation in a .NET MAUI Shell app\nEffective navigation within the MVVM pattern begins with an integral component: a `NavigationService`. This service is the driving force behind MVVM navigation. In essence, a `NavigationService` is a class that implements an `INavigationService` interface. The `INavigationService` interface provides the contract for navigating between pages, defining the various methods needed for such operations. These methods could include operations such as `GoToDetailPage()`, `GoBack()`, and others, depending on your specific requirements.\nHere’s the beauty of this setup: during the app’s startup, we register a framework-specific implementation of the `INavigationService` interface with the DI container. It’s a perfect illustration of the power of DI, where we program to an interface, not an implementation. This allows our ViewModels to be completely platform-agnostic. This not only promotes code flexibility and testability but also allows us to replace or modify our `NavigationService` implementation without affecting the rest of our app.\nBefore we dive deeper into the setup of an `INavigationService` and explore how it operates within our *Recipes!* app, notice that the UI of the app has changed a little bit. The main UI now shows two tabs: `RecipesOverviewPage`, and `SettingsPage`. Let’s have a look at implementing a `NavigationService` interface that leverages .NET MAUI Shell.\nCreating an INavigationService interface\nIt all starts with this interface, which will get injected into the ViewModels that want to navigate. And this is where developers tend to have different opinions. Some developers prefer to have a very slimmed-down interface only containing methods such as `GoTo(string name)`, `GoTo(string name, IDictionary<string, object> parameters)`, and `GoBack()`. This allows for a very generic interface and implementation that can easily be reused. I prefer a more per-app approach where I have methods such as `GoToOverview()`, `GoToDetail(string id)`, and others. The big advantage I find in this approach is the fact that when I want to navigate to a certain page, I know exactly what parameters are required to navigate to that page. I also find it easier to unit test and it makes it easier to implement app-specific edge cases. I’ve also seen and used generic implementations over the years, containing methods such as `GoTo<TViewModel>()` for example. It pretty much comes down to personal preference, use case requirements, and the specific needs of the project. I’ll be demonstrating the approach I typically use and have used successfully over the years. Once you understand the main concept of a `NavigationService`, please use whatever approach you prefer! Let’s create the `INavigationService` interface for our *Recipes!* app:\n\n1.  In the `Recipes.Client.Core` project, add a new folder by right-clicking the project in the `Navigation`.\n2.  Next, right-click the newly created folder and select `INavigationService` as the name for the new interface.\n3.  As the *Recipes!* app doesn’t have a lot of navigation going on, we can keep the interface pretty simple, as shown here:\n\n    ```", "```cs\n\n    The interface currently holds three methods. The `GoToRecipeDetail` method should navigate to the detail page. It accepts a string parameter representing the ID of the recipe we want to load on that page. The `GoToRecipeRatingDetail` method should load the ratings overview page of the given `RecipeDetailDto` object. Finally, there is the `GoBack` method, which should allow us to programmatically navigate back into the app.\n\nNote\nThis `INavigationService` interface holds no reference to .NET MAUI or Shell. It’s just a contract for triggering navigations. The fact the interface is part of the `Recipes.Client.Core` project already gives away that it is framework agnostic. So, whether you want to leverage Shell or not, this interface probably won’t change.\nNow that we have this interface in place, let’s see how we can implement a `NavigationService` interface that leverages Shell.\nCreating and using a NavigationService\nBecause the implementation of `NavigationService` is specific to a framework, we are going to add it to the `Recipes.Mobile` project:\n\n1.  Let’s add a `Navigation` folder to the **Recipes.Mobile** project by right-clicking the project in the **Solution Explorer** and selecting **Add** | **New Folder**.\n2.  Now, right-click the `NavigationService`.\n3.  This class needs to implement `INavigationService`, as shown here:\n\n    ```", "```cs\n\n     4.  Now, this is where Shell comes in! Earlier in this chapter, we saw how easy it is to use Shell for navigation: just call `Shell.Current.GoToAsync` and pass in the name of the page you want to navigate to. Let’s add the following method, which wraps around this `GoToAsync` method, to our new `NavigationService` class:\n\n    ```", "```cs\n\n    This `Navigate` method just calls the `GoToAsync` method of `Shell`, passing in the given `pageName` parameter. We’ll look at the `parameters` parameter later.\n\n     5.  What remains for `NavigationService` is implementing the `INavigationService` interface’s methods, which is now pretty easy to do, as shown here:\n\n    ```", "```cs\n\n    The first two methods call the `Navigate` method we created earlier, passing in the name of the page that needs to be loaded, as well as a dictionary containing the `recipeId` parameter. The `GoBack` method calls the `GoToAsync` method of `Shell`, passing in \"..\", signaling we want to navigate up the navigation stack.\n\n     6.  Next, we can go ahead and register this `NavigationService` in the DI container. Open `MauiProgram.cs` and add the following:\n\n    ```", "```cs\n\nAnd with that in place, it’s time to update our ViewModels and add `INavigationService` as a dependency:\n\n1.  Head over to `RecipesOverviewViewModel` and update its constructor so that it accepts an `INavigationService`. As before, we should also create a `readonly` field to hold the injected value:\n\n    ```", "```cs\n\n     2.  Further down this class, we can now update the `NavigateToSelectedDetail` method to the following:\n\n    ```", "```cs\n\n     3.  In `RecipesOverviewPage.xaml`, the following can be removed:\n\n    ```", "```cs\n\n    In the `RecipesOverviewPage.xaml.cs` file, the `CollectionView_SelectionChanged` method can be removed as well. Up until now, this is what triggered the navigation from the overview page to the detail page.\n\nNow, we need to give `RecipeDetailViewModel` the same treatment: inject `INavigationService` and use it to execute navigation to the `RecipeRatingsDetailPage`:\n\n1.  As before, add an additional parameter to the class’s constructor and keep a reference to it in a `readonly` field:\n\n    ```", "```cs\n\n     2.  The following snippet shows how we can update the `NavigateToRatings` method:\n\n    ```", "```cs\n\n    This method gets called when `NavigateToRatingsCommand` is invoked.\n\n     3.  Finally, we need to head over to the `RecipeDetailPage.xaml` file and update the `TapGestureRecognizer` on the `HorizontalStackLayout`, which shows the rating, to the following:\n\n    ```", "```cs\n\n    Tapping this control will now trigger `NavigateToRatingsCommand`, which we just created, which will call the `NavigationService` to initiate navigation to the `RatingsDetailPage`.\n\n     4.  The `Ratings_Tapped` method in the code-behind of `RecipeDetailPage` can be deleted as it is no longer of any use.\n\nThe pages, their ViewModels, and their routes, are already registered in `MauiProgram`’s `CreateMauiApp` method, as shown here:\n\n```", "```cs\n\n With all of these changes in place, we can now effectively navigate from one page to another. The injected instance of `NavigationService` in the ViewModels leverages Shell to navigate between pages. But there is still one thing missing: passing parameters from one page to another. Let’s see how to add this!\nPassing parameters\nAs mentioned earlier, although .NET MAUI Shell has a baked-in way of passing parameters, I’m not fond of using that in my ViewModels as it would require my ViewModels to depend on MAUI and Shell. Luckily, a solution to that is not that complex. Moreover, it fits nicely in the broader setup of our `NavigationService`, as we will discuss later in this chapter.\nLet’s introduce a new interface: `INavigationParameterReceiver`. This interface exposes one method called `OnNavigatedTo` that receives a dictionary of type `Dictionary<string, object>` as a single parameter. This interface can be implemented by ViewModels that want to accept navigation parameters. When navigated to a page, the `NavigationService` can check whether the `BindingContext` of the new page implements this interface and then call the `OnNavigatedTo` method, passing in the parameters. Let’s see how we can implement this:\n\n1.  First, let’s add the `INavigationParameterReceiver` interface. Right-click the `Navigation` folder in the `Recipes.Client.Core` project and select `INavigationParameterReceiver` as the name of the interface.\n2.  As we mentioned previously, this interface should expose the `OnNavigatedTo` method. Let’s add this:\n\n    ```", "```cs\n\n     3.  Head over to the `Navigate` method of the `NavigationService` class and update it to the following:\n\n    ```", "```cs\n\n    The preceding code will pass the provided parameters to the ViewModel once Shell has navigated to the new page. We can retrieve the current page by calling `Shell.Current.CurrentPage`. Once we have the current page, we can check whether the page’s `BindingContext` implements the `INavigationParameterReceiver` interface. If it does, we can call the `OnNavigatedTo` method to pass the provided parameters.\n\n     4.  `RecipeDetailViewModel` can now implement the `INavigationParameterReceiver` interface, as shown here:\n\n    ```", "```cs\n\n     5.  Up until now, the constructor of `RecipeDetailViewModel` called the `LoadRecipe` method with a hard-coded ID. This call can now be removed.\n6.  `RecipeRatingsDetailViewModel` also needs to be updated for it to be able to receive parameters. The following code block shows how it can implement `INavigationParameterReceiver`:\n\n    ```", "```cs\n\n    Please note that there has been a slight change in the `LoadData` method signature since the previous chapter. Rather than accepting a string, it now takes a `RecipeDetailDto` object as its parameter. This is an optimization strategy that aims to avoid over-fetching. When we navigate from `RecipeDetailPage`, we have already loaded the details of a recipe. Therefore, it’s not needed to reload these same details when we move to `RecipeRatingDetailPage`. By passing in a `RecipeDetailDto`, we effectively utilize the data we’ve already fetched.\n\nWith `INavigationParameterReceiver` in place, we can effectively pass navigation parameters from one page to another. Let’s see how we can extend our navigation infrastructure even more to allow us to hook into and manage important parts of the ViewModel’s life cycle: specifically, the moments of navigation to and from a ViewModel.\nAvoid “magic strings”\nThe code samples in this chapter use a lot of “magic strings\": specific routes are registered for pages, parameters are passed using exact keys, and navigation requires correct input of these routes and keys. While this makes the code samples simple and clear, it’s risky in practice. A single spelling error can lead to runtime errors that aren’t immediately apparent. To prevent such issues, it’s advisable to use string constants for route names and parameters stored in designated classes. We didn’t follow this best practice here for the sake of simplicity, but keep it in mind when you’re writing your code.\nHooking into navigation\nOften, we want to hook into the navigation process to effectively manage ViewModel states during transitions. This allows us to handle setup and cleanup operations, as well as manage state changes when a ViewModel becomes active or inactive in the application. This strategy is particularly useful for tasks such as subscribing to or unsubscribing from services, loading or saving states, and initiating or canceling network requests.\nFor that purpose, let’s introduce two new interfaces: `INavigatedFrom` and `INavigatedTo`. Just like `INavigationParameterReceiver`, ViewModels can choose to implement these interfaces if they want to react to certain navigation events. Let’s see what they look like:\n\n```", "```cs\n\n Both the `OnNavigatedFrom` and `OnNavigatedTo` methods accept one parameter of type `NavigationType`, which is an enum. This enum has the following implementation:\n\n```", "```cs\n\n With this `enum` type, we want to give context to the type of navigation that occurred. The `SectionChanged` value can be used when the user opens another tab for example or selects another item from `FlyoutMenu`. As you might expect, the `Forward` and `Back` values are used when navigating hierarchically from one page to another.\nThese methods and values of the `NavigationType` enum enable nuanced reactions to a wide variety of navigation scenarios. Let’s consider some examples:\n\n*   When the `OnNavigatedFrom` method of a ViewModel is called with `Back` as the parameter, we can infer that we’re navigating backward away from this ViewModel. In this context, you should consider stopping any ongoing tasks or network requests related to that ViewModel. The page no longer exists on the `NavigationStack`, so unsubscribing from messages or events may be wise, allowing any unneeded resources to be reclaimed via garbage collection.\n*   If the `OnNavigatedFrom` method is invoked with `Forward` as the parameter, we know the page and its ViewModel remain on the `NavigationStack`. Therefore, the user can easily navigate back to this page. In this situation, we may also want to clean up specific processes or running tasks, but it’s important to ensure they can be quickly reinstated. When the user navigates back to the ViewModel, the `OnNavigatedTo` method will be triggered with `Back` as the parameter, signaling a need to restart previously paused processes.\n\nLet’s see how we can add these additional interfaces to our ViewModels and hook up the necessary code to call the methods these interfaces expose:\n\n1.  Add the interfaces (`INavigatedFrom` and `INavigatedTo`) and the `NavigationType` enum, as shown in the earlier code blocks, to the `Navigation` folder of the `Recipes.Client.Core` project.\n2.  When inheriting from the `AppShell` class, we can override the `OnNavigated` method. This method is invoked when a navigation is executed by the Shell framework. This is the ideal place to call into the methods of the interfaces that we’ve introduced. Go ahead to the `AppShell` class and override this method, as shown here:\n\n    ```", "```cs\n\n    The `ShellNavigatedEventArgs` parameter that’s passed into this method has a `Source` property. This `Source` property is of type `ShellNavigationSource` and indicates how the navigation occurred: `Push`, `Pop`, `PopToRoot`, and so on. We want to translate this to the `NavigationType` enum we introduced earlier, allowing it to be framework-independent from here on.\n\n     3.  To translate `ShellNavigationSource` to `NavigationType`, create the following `GetNavigationType` method in the `AppShell` class:\n\n    ```", "```cs\n\n     4.  Now, we need to find a way to access the ViewModels of the current and previous page, from within the overridden `OnNavigated` method. Once we get a hold of them, we can call `OnNavigatedFrom` and `OnNavigatedTo` when the ViewModel implements the corresponding interfaces. For that purpose, let’s introduce a new interface: `INavigationInterceptor`. Here’s what it looks like:\n\n    ```", "```cs\n\n    For now, this interface only exposes one method: `OnNavigatedTo`. It accepts a parameter of the `object` type that represents the `BindingContext` of the current page. It also accepts a parameter of type `NavigationType`.\n\n     5.  Add this interface as a constructor parameter to `AppShell` and call its `OnNavigatedTo` method from the `OnNavigated` method of Shell, which we’ve just overridden. The following code block shows how to add this:\n\n    ```", "```cs\n\n     6.  Because the `AppShell` class now lacks its default constructor and requires a parameter of type `INavigationInterceptor`, we need to update our code in the `App.xaml.cs` file, as shown here:\n\n    ```", "```cs\n\n    The constructor of the `App` class has been updated so that it accepts a parameter of the `INavigationInterceptor` type.\n\n     7.  What remains is implementing `INavigationInterceptor` and registering it in the DI container. This interface can be implemented by our existing `NavigationService`. Let’s see how:\n\n    ```", "```cs\n\n    A lot is going on here, so let’s discuss what happens. Remember that the `OnNavigatedTo` method is called when we have already navigated. So, we must keep a reference to the previous page’s `BindingContext` if we want to call a method on that later on. This reference is kept as `WeakReference` because we don’t want this reference to cause the object not to be garbage collected and causing memory leaks. First, we check whether the `previousFrom` field is not null and whether it still holds a reference to a value that implements the `INavigatedFrom` interface. If we get back a value, the `OnNavigatedFrom` method is called on the `BindingContext` of the page we’ve navigated from.\n\n    Next, we check whether the passed-in `bindingContext` parameter implements the `INavigatedTo` interface. If that’s the case, the `OnNavigatedTo` method is called.\n\n    In the end, we check whether the given `bindingContext` implements the `INavigatedFrom` interface. If so, we store it in the `previousFrom` field. If not, the `previousFrom` field is assigned null.\n\n     8.  It’s important to notice that we’ve introduced state to our `NavigationService` by keeping track of the `BindingContext` of the previous page through the `previousFrom` field. As a result, `NavigationService` should be registered as Singleton so that throughout the app, the same instance of `NavigationService` is being used. Moreover, the `NavigationService` should be resolvable as `INavigationService` in the ViewModels and as `INavigationInterceptor` for instantiating the `AppShell` class. To accommodate this, we can update the registration, as follows:\n\n    ```", "```cs\n\n`NavigationService` itself is registered as a singleton. We also added singleton registrations for `INavigationService` and `INavigationIntercepter`, both returning the registration of `NavigationService`. This allows us to register one type for multiple interfaces, all pointing to the same instance.\nGo ahead and implement the `INavigatedTo` and `INavigatedFrom` interfaces in some ViewModels. Add a breakpoint to the implemented methods, run the app, and see what happens by inspecting the parameter values. For our little *Recipes!* app, there is no need to add an implementation to said methods, but as managing ViewModel states during transitions is something developers tend to struggle with in larger apps, I wanted to share how I handle these kinds of scenarios.\nSetting up navigation without .NET MAUI Shell\nAs I mentioned earlier, Shell is an opinionated way to create the structure of a .NET MAUI app. This might not work for you or your particular project. Not using Shell complicates the implementation of a `NavigationService` a lot, especially when your app has a complex structure such as tabs or a flyout menu. Let’s focus on a simple hierarchical navigation and see what is needed to implement a `NavigationService` without relying on another framework.\nLuckily, the interfaces we created earlier (`INavigationService`, `INavigatedTo`, `INavigatedFrom`, and `INavigationParameterReceiver`) are framework-independent and can still be used as the backbone of this implementation:\n\n1.  No Shell means no routing. However, I do like the concept of having keys associated with a particular view as it allows for a loosely coupled way of navigating. That’s why we’re creating a static `Routes` class in the `Navigation` folder of the `Recipes.Mobile` project, as shown here:\n\n    ```", "```cs\n\n    This class allows us to map keys to types that inherit from `Page`.\n\n     2.  Next, instead of using the static `Routing.RegisterRoute` method to register routes in the `MauiProgram` class, we can now use our own `Routes` class, like this:\n\n    ```", "```cs\n\n    The `Routes.GetType` method will allow us to retrieve a key’s `Type` later.\n\n     3.  Before diving into the implementation of the non-Shell `NavigationService`, let’s add the following code to the `INavigationService` interface:\n\n    ```", "```cs\n\n     4.  In `App.xaml.cs`, update the `App`’s constructor as shown here:\n\n    ```", "```cs\n\n    With the updated code, a class implementing the `INavigationService` interface will be injected. After assigning a new `NavigationPage` to the `MainPage` property, we can call the newly added `GoToOverview` method on the injected `INavigationService` for it to navigate to the `OverviewPage`.\n\n     5.  Now, we can go and start implementing the non-Shell `NavigationService`. Create a new class called `NonShellNavigationService` in the `Navigation` folder of the `Recipes.Mobile` project. As you might expect, this class needs to implement the `INavigationService` interface, as shown here:\n\n    ```", "```cs\n\n     6.  The first thing we want to add is the `Navigation` property, which is of type `Microsoft.Maui.Controls.INavigation`. Through this property, we want to effectively route our navigation. The `INavigation` interface defines navigation-related methods and properties. Let’s see what that property looks like:\n\n    ```", "```cs\n\n    Through the static `Current` property of the `Application` class, we can get to the instance of the application, allowing us to access its `MainPage` property. The `MainPage` property, which is of type `Page`, has a `Navigation` property of type `INavigation`, which is exactly what we need.\n\n     7.  Like on `NavigationService`, which used `Shell`, we also want to add a private `Navigate` method that other methods in this class can use. Here’s what this looks like:\n\n    ```", "```cs\n\n    With the given key, we can resolve the type we want to navigate to. Using the `ServiceProvider`, we can retrieve an instance of the given type, satisfying all of its dependencies. Next, an event handler for the resolved page’s `NavigatedFrom` event is added before we access our `Navigation` property and push this page onto the navigation stack with the `PushAsync` method. This is what executes the effective navigation to the requested page. After the page is pushed, its `BindingContext` is checked to see whether it implements the `INavigationParameterReceiver` interface. If that’s the case, its `OnNavigatedTo` method is called, passing in the navigation parameters. The final thing that happens in this method is that it checks whether the size of `NavigationStack` is `1`. This means that we navigated to a page and that there’s only one item on the stack, or in other words, this is the first page we’re navigating to. If that is the case, we want to call the `OnNavigatedTo` method on the page’s `BindingContext` if said `BindingContext` implements the `INavigatedTo` interface and pass in `NavigationType.SectionChange`. With this in place, the `OnNavigatedTo` method is called on initial navigation.\n\n     8.  In the previous method, we added a handler to the page’s `NavigatedFrom` event. The following code block shows its implementation:\n\n    ```", "```cs\n\n    As we are focusing on hierarchical navigation, navigation from a page can happen for two reasons: we’re navigating forward to another page or we’re navigating back to the previous page. This is what is determined at the beginning of this method. As this event is handled after the navigation occurred, we can determine forward navigation by looking at the second-to-last item on the `NavigationStack`: if that entry equals the sender, it means we navigated forward from the sender to another page. If it wasn’t forward navigation, meaning we’ve navigated back from the page to the previous page, we need to remove the event handler from the page’s `NavigateFrom` event. We need to do this so that the page has no references and can be garbage collected, avoiding potential memory leaks. Finally, we call the `OnNavigated` method, passing in the `BindingContext` of the current page (which is the last item in `NavigationStack`). Depending on whether it is forward navigation or not, we pass in `NavigationType.Forward` or `NavigationType.Backward`.\n\n     9.  The `OnNavigatedTo` method that is being called in the previous code block might look familiar. That’s because it is completely identical to the `OnNavigatedTo` method we had in our previous implementation of the `NavigationService`:\n\n    ```", "```cs\n\n     10.  Finally, let’s have a look at the implemented methods of the `INavigationService` interface:\n\n    ```", "```cs\n\n    They also look very much like they did in the previous implementation because the `Navigate` method accepts the same parameters as in the previous sample.\n\n     11.  The only thing that’s left to do is register this `NonShellNavigationService`:\n\n    ```", "```cs\n\n    In this setup, we’re not using `INavigationInterceptor`, so there’s no need to register that.\n\nWith that in place, we’ve successfully created a simple `NavigationService` that does not leverage .NET MAUI Shell. Many of the core concepts were reused in this example, demonstrating that they are a good level of abstraction. That said, this implementation is very simple and naïve. It lacks the support for modal navigation and navigation inside tabs and doesn’t have anything for handling a flyout menu. This example might give you some ideas and insights, but building a `NavigationService` from scratch, without leveraging Shell, is quite daunting. In many cases, when Shell is not an option for you or your specific project, I think relying on other third-party frameworks might be the way to go. Libraries such as *FreshMvvm* and especially *Prism Library* are worth checking out!\nBefore concluding this chapter, it’s important to address a potentially unclear aspect: how can we effectively return a result from a child page to its parent?\nPassing results back\nIn this chapter, we’ve explored passing parameters from one page to another during forward navigation. But what if we need to take an object, use it as a parameter to navigate to another page, manipulate it there, and then retrieve the updated result?\nThere are various approaches to achieve this, but the most straightforward method is to add a little extension to our navigation framework and allow parameters to be passed when navigating back. For example, on the `SettingsPage` of the *Recipes!* app, we show the user’s current language. There’s a button that navigates to the `PickLanguagePage`, where the user can select a different language. The current language needs to be passed from the `SettingsPage` to the `PickLanguage` page so that the latter can show the current value. When the user selects a new language, the `PickLanguagePage` should navigate back to the `SettingsPage` and pass the selected language as a parameter. *Figure 8**.2* shows how this looks schematically:\n![Figure 8.2: Passing values back](img/B20941_08_02.jpg)\n\nFigure 8.2: Passing values back\nLet’s explore how to implement this scenario:\n\n1.  First, add the `GoBackAndReturn` method to `INavigationService`:\n\n    ```", "```cs\n\n    By introducing this method, we want to allow a ViewModel to trigger back navigation and pass parameters to the ViewModel of the previous page.\n\n     2.  This method is very easy to implement in both `NavigationService` and `NonShellNavigationService`. First, let’s take a look at the implementation in `NavigationService`:\n\n    ```", "```cs\n\n    In this method, we first call the `GoBack` method. Once the back navigation is executed, we check whether `BindingContext` of the current page implements the `INavigationParameterReceiver` interface. If that’s the case, we call its `OnNavigatedTo` method, passing in the parameters.\n\n     3.  On `NonShellNavigationService`, this method looks very similar:\n\n    ```", "```cs\n\n    We are doing the same thing here as in the `NavigationService`, except we’re not using the Shell APIs to retrieve the current page. Instead, we’re getting the current page from `NavigationStack`.\n\n     4.  Next, let’s add the method that should navigate to `PickLanguagePage`. Add the `GoToChooseLanguage` method to the `INavigationService` interface:\n\n    ```", "```cs\n\n     5.  In both `ShellNavigationService` and `NonShellNavigationService`, implement the `GoToChooseLanguage` method, like this:\n\n    ```", "```cs\n\n    The registration of `PickLanguagePage`, its route, and its ViewModel is already done in the `CreateMauiApp` method of the `MauiProgram` class, as shown here:\n\n    ```", "```cs\n\n     6.  Update `PickLanguageViewModel` as it needs to implement the `INavigationParameterReceiver` interface and needs to get a dependency on the `INavigationService` interface. Here’s how it looks:\n\n    ```", "```cs\n\n    Note that in the `OnNavigatedTo` method, we’re assigning the _`selectedLanguage` field rather than the `SelectedLanguage` property. This is intentional because updating the property will immediately invoke the `LanguagePicked` method. We don’t want to trigger this when we set the initial value of this property. Because of that, we need to call `OnPropertyChanged` manually, passing the name of the `SelectedLanguage` property.\n\n     7.  The `LanguagePicked` method is called when the user selects a new language from the dropdown. This should be where we utilize our new `GoBackAndReturn` method to navigate back and return the selected language. Let’s take a look:\n\n    ```", "```cs\n\n     8.  Go to `SettingsViewModel` and make it implement the `INavigationParameterReceiver` interface:\n\n    ```", "```cs\n\n    Here’s what the implemented `OnNavigatedTo` method looks like:\n\n    ```", "```cs\n\n    This `OnNavigatedTo` method will be called both when navigating “forward” to this ViewModel as well as when navigating “back” to it. The `SelectedLanguage` parameter that’s sent by `PickLanguageViewModel` can be picked up here.\n\n     9.  `SettingsPageViewModel` also needs to get the `INavigationService` interface injected. Here’s how:\n\n    ```", "```cs\n\n     10.  Finally, the `ChooseLanguage` method, which gets triggered when the user taps `PickLanguagePage`, as shown here:\n\n    ```", "```cs\n\nWith this update, moving data between pages is easier and more flexible. Our app now offers smoother user experiences, all thanks to our navigation framework.\nSummary\nThe fundamental picture of navigation is quite straightforward: a navigation service, which is injected into ViewModels, is utilized to handle navigation. ViewModels can implement specific interfaces, enabling them to receive parameters or be notified about navigation activities, be it from or to them.\nWhile the overall idea seems simple, the implementation can be complex, and this is where developers often become puzzled. Fortunately, .NET MAUI Shell streamlines the navigation process in complex UIs, providing a level of ease in the implementation. But as with anything, Shell’s opinionated nature may not suit every application or developer’s preferences. Therefore, we didn’t stop at exploring Shell navigation but also dove into building a navigation service that is not reliant on Shell.\nToward the end of this chapter, we looked a bit deeper into passing parameters and results between pages. We demonstrated that by efficiently combining navigation services and ViewModel coordination, we can create a seamless user experience.\nNavigating through the complexities of .NET MAUI navigation can be a challenge, but with a good understanding of the underlying principles and implementation details, we’re better equipped to handle it. As we move forward, we’ll explore handling user input and validation, diving into how to make our applications more interactive.\nFurther reading\nTo learn more about the topics that were covered in this chapter, take a look at the following resources:\n\n*   *.NET MAUI* *Shell*: [https://learn.microsoft.com/dotnet/maui/fundamentals/shell/](https://learn.microsoft.com/dotnet/maui/fundamentals/shell/)\n*   *Prism* *Library*: [https://prismlibrary.com/](https://prismlibrary.com/)\n*   *FreshMvvm*: [https://github.com/XAM-Consulting/FreshMvvm.Maui](https://github.com/XAM-Consulting/FreshMvvm.Maui)\n\n```"]