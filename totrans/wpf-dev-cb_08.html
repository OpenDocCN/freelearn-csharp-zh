<html><head></head><body>
        

                            
                    Working with Animations
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Scaling an element while rendering</li>
<li>Rotating an element while rendering</li>
<li>Skewing an element while rendering</li>
<li>Moving an element while rendering</li>
<li>Grouping multiple transforms</li>
<li>Creating property-based animations</li>
<li>Creating path-based animations</li>
<li>Creating key-frame-based animations</li>
<li>Adding easing effects to animations</li>
</ul>
<h1 id="uuid-980c7da1-344a-4417-ab40-261252629693" class="">Introduction</h1>
<p><strong>Windows Presentation Foundation</strong> (<strong>WPF</strong>) is well-known for its rich <strong>graphical user interface</strong> (<strong>GUI</strong>) and layout features, which enables you to create stunning desktop applications. Animations can be used to create an attractive <strong>user interface</strong> (<strong>UI</strong>) by just animating UI elements, transformations, screen transitions, and more.</p>
<p>In this chapter, we will learn how to create animations using <strong>storyboards</strong>. We will first start with recipes that will help you to understand various transformations, such as <kbd>ScaleTransform</kbd>, <kbd>RotateTransform</kbd>, <kbd>SkewTransform</kbd>, and <kbd>TranslateTransform</kbd>. Then we will proceed towards recipes to learn various kinds of animations, such as property-based animations, path-based animations, and key-frame-based animations.</p>
<p>At the end, we will learn various easing functions introduced in WPF 4, which can be used to create easing effects on your linear animations to give them a non-linear look.</p>
<h1 id="uuid-b899557b-fd0c-4b0c-818b-539876498726">Scaling an element while rendering</h1>
<p>The <kbd>ScaleTransform</kbd> is used to scale (stretch or shrink) an object horizontally or vertically. The <kbd>ScaleX</kbd> property is used to specify how much to stretch or shrink the object along the <em>X</em> axis, whereas the <kbd>ScaleY</kbd> property is used to specify how much to stretch or shrink the object along the <em>Y</em> axis. Using the <kbd>CenterX</kbd> and <kbd>CenterY</kbd> properties, the operations are performed based on the center pointing at certain coordinate points.</p>
<p>In this recipe, we will learn how to stretch or shrink an element using the scale transform.</p>
<h2 id="uuid-ada72b9c-8782-4844-ab34-e79b22dc736a">Getting ready</h2>
<p>First, open your Visual Studio instance and create a new WPF App project named <kbd>CH08.ScaleTransformDemo</kbd>.</p>
<h2 id="uuid-b1b1e8d9-012a-4864-9cc0-942e215e3a30">How to do it...</h2>
<p>Follow these steps to add <kbd>Image</kbd> controls to the application UI, and apply <kbd>ScaleTransform</kbd> to scale the image:</p>
<ol>
<li>From the Solution Explorer, right-click on the project node and create a new folder. Name it as <kbd>Images</kbd>.</li>
<li>Now, right-click on the <kbd>Images</kbd> folder and add an existing image from your system. Name it as <kbd>image1.png</kbd>:</li>
</ol>
<div><img src="img/367d1722-3e93-4762-a52a-2986094fb139.png" style=""/></div>
<ol start="3">
<li>Navigate to the <kbd>MainWindow.xaml</kbd> page and replace the default <kbd>Grid</kbd> with a horizontal <kbd>StackPanel</kbd>.</li>
<li>Inside the <kbd>StackPanel</kbd>, add the following <kbd>Grid</kbd> with two image controls. Both, the image controls should be pointing to the <kbd>Images/image1.png</kbd> image file. The second image will have a transform set to it to scale the image to 80%, as shown in the following code snippet:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;Image Height="300" Width="260" 
           Margin="4" Opacity="0.2" 
           Source="Images/image1.png"/&gt; 
    &lt;Image Height="300" Width="260" 
           Margin="4" 
           Source="Images/image1.png"&gt; 
        &lt;Image.RenderTransform&gt; 
            &lt;ScaleTransform ScaleX="0.8" 
                            ScaleY="0.8"/&gt; 
        &lt;/Image.RenderTransform&gt; 
    &lt;/Image&gt; 
&lt;/Grid&gt; </pre>
<ol start="5">
<li>Let's add one more <kbd>Grid</kbd> inside the <kbd>StackPanel</kbd> with the following XAML mark-up, where the two images are scaled to 50% and mark the scaling center position to (<kbd>0</kbd>,<kbd>0</kbd>) and (<kbd>100</kbd>,<kbd>100</kbd>), respectively:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid Margin="110 0 0 0"&gt; 
    &lt;Image Height="300" Width="260" 
           Margin="4" Opacity="0.2" 
           Source="Images/image1.png"&gt; 
        &lt;Image.RenderTransform&gt; 
            &lt;ScaleTransform ScaleX="0.5" 
                            ScaleY="0.5" 
                            CenterX="0" 
                            CenterY="0"/&gt; 
        &lt;/Image.RenderTransform&gt; 
    &lt;/Image&gt; 
    &lt;Image Height="300" Width="260" 
           Margin="4" 
           Source="Images/image1.png"&gt; 
        &lt;Image.RenderTransform&gt; 
            &lt;ScaleTransform ScaleX="0.5" 
                            ScaleY="0.5" 
                            CenterX="100" 
                            CenterY="100"/&gt; 
        &lt;/Image.RenderTransform&gt; 
    &lt;/Image&gt; 
&lt;/Grid&gt; </pre>
<ol start="6">
<li>Let's run the application now and check the scaling behavior of the various images on the screen.</li>
</ol>
<h2 id="uuid-3ef99989-674e-4048-878c-ae43fdeb3986">How it works...</h2>
<p>The <kbd>RenderTransform</kbd> attribute helps you to set runtime transformation to any UI Element. In this example, we used <kbd>ScaleTransform</kbd> to scale the image on the application window.</p>
<p>When you run the application, the first one is the default image with an opacity set to 20%, whereas the second one is scaled to 80% with an opacity of 100%. The <kbd>ScaleX</kbd> and <kbd>ScaleY</kbd> properties are used to scale an element, which takes a decimal value to represent the ratio. For example, 0.8 denotes 80%, whereas 1.2 denotes 120% of the scaling:</p>
<div><img src="img/4e7f79b7-1bf8-4871-9477-bed7ebb260c5.png" style=""/></div>
<p>For the third and fourth images, both are scaled to 50%. But, as you see on the UI, the positions of the said images are different. The properties <kbd>CenterX</kbd> and <kbd>CenterY</kbd> are used to set the scaling center position. The third image has the scaling center set at (<kbd>0</kbd>,<kbd>0</kbd>), whereas the fourth one has its center position set at (<kbd>100</kbd>,<kbd>100</kbd>):</p>
<pre style="padding-left: 60px">&lt;ScaleTransform ScaleX="0.5" 
                ScaleY="0.5" 
                CenterX="100" 
                CenterY="100"/&gt; </pre>
<h1 id="uuid-f0755083-a71e-48ab-ab82-464889f10d59">Rotating an element while rendering</h1>
<p>When you want to rotate an element at runtime, the <kbd>RotateTransform</kbd> is used. It rotates the element around a center position denoted by <kbd>CenterX</kbd> and <kbd>CenterY</kbd>, at an angle in degrees specified by the <kbd>Angle</kbd> property.</p>
<p>Let's learn how to use <kbd>RotateTransform</kbd> to rotate a UI element at a specified angle. In this recipe, we are going to discuss this.</p>
<h2 id="uuid-931e4ec6-3ceb-40cb-ab4e-0ef22a4ea461">Getting ready</h2>
<p>Open Visual Studio and create a new project named <kbd>CH08.RotateTransformDemo</kbd>. Make sure to select the WPF App template while creating the project.</p>
<h2 id="uuid-25e36493-db44-4c55-8486-9cfefc74de37">How to do it...</h2>
<p>Follow the steps mentioned here to apply rotation to an <kbd>Image</kbd> control:</p>
<ol>
<li>From Solution Explorer, right-click on the project node and create a new folder. Name it as <kbd>Images</kbd>.</li>
<li>Now right-click on the Images folder and add an existing image from your system. Name it <kbd>image1.png</kbd>.</li>
<li>Open the <kbd>MainWindow.xaml</kbd> file and replace the existing <kbd>Grid</kbd> with a horizontal <kbd>StackPanel</kbd>.</li>
<li>Insert the following XAML mark-up inside the <kbd>StackPanel</kbd> to add two images the application window. The first image will have an opacity set to 20%, and the second image will have a <kbd>RotateTransform</kbd> set at an angle of 45 degrees:</li>
</ol>
<pre style="padding-left: 90px">&lt;Image Height="300" Width="260" 
       Margin="4" Opacity="0.2" 
       Source="Images/image1.png"/&gt; 
&lt;Image Height="300" Width="260" 
       Margin="4" 
       Source="Images/image1.png"&gt; 
    &lt;Image.RenderTransform&gt; 
        &lt;RotateTransform Angle="45"/&gt; 
    &lt;/Image.RenderTransform&gt; 
&lt;/Image&gt; </pre>
<ol start="5">
<li>Let's add one more <kbd>Grid</kbd> inside the <kbd>StackPanel</kbd>.</li>
<li>Add two more images into the new <kbd>Grid</kbd> panel. Set the <kbd>RenderTransform</kbd> attribute of both the images to have a <kbd>RotateTransform</kbd> set to it at an angle of <kbd>45</kbd> degrees.</li>
<li>As shown in the following XAML snippet, set the center position of the rotation of the images using the <kbd>CenterX</kbd> and <kbd>CenterY</kbd> properties. In this demonstration, we will set (<kbd>0</kbd>,<kbd>0</kbd>) and (<kbd>30</kbd>,<kbd>30</kbd>) as the rotation center of the respective images:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid Margin="80 0 0 0"&gt; 
    &lt;Image Height="300" Width="260" 
           Margin="4" Opacity="0.2" 
           Source="Images/image1.png"&gt; 
        &lt;Image.RenderTransform&gt; 
            &lt;RotateTransform Angle="45" 
                             CenterX="0" 
                             CenterY="0"/&gt; 
        &lt;/Image.RenderTransform&gt; 
    &lt;/Image&gt; 
    &lt;Image Height="300" Width="260" 
           Margin="4"  
           Source="Images/image1.png"&gt; 
        &lt;Image.RenderTransform&gt; 
            &lt;RotateTransform Angle="45" 
                             CenterX="30" 
                             CenterY="30"/&gt; 
        &lt;/Image.RenderTransform&gt; 
    &lt;/Image&gt; 
&lt;/Grid&gt; </pre>
<ol start="8">
<li>Once this is done, build the project and run it. You will see four images on the screen, which will look like the following screenshot:</li>
</ol>
<div><img src="img/9d35d641-4068-452c-9c5c-ae8c2572d7ad.png" style=""/></div>
<h2 id="uuid-2b84992b-eab8-47a1-a956-e7018963fbdf">How it works...</h2>
<p><kbd>RotateTransform</kbd> allows you to rotate an element at a certain degree specified by the <kbd>Angle</kbd> property. In the first image, no transformation was applied and thus it will look as default. If you compare this with the other images on the screen, the second image is rotated clockwise at an angle of <kbd>45</kbd> degrees. The third and fourth images are also rotated at an angle of <kbd>45</kbd> degrees, but with a small difference.</p>
<p>For the third image, the rotation was done at the center position (<kbd>0</kbd>,<kbd>0</kbd>). For the fourth image, it was done at the center position (<kbd>30</kbd>,<kbd>30</kbd>). Here's how the difference will look:</p>
<div><img src="img/18936217-fe66-4463-a564-32de3e08e231.png" style=""/></div>
<h1 id="uuid-959bd62a-c675-43ab-8cb9-936d17918856">Skewing an element while rendering</h1>
<p><kbd>SkewTransform</kbd> is used in a WPF platform to shear an element so that it has a 3D look in a 2D plate by adding depth to it. The <kbd>AngleX</kbd> and <kbd>AngleY</kbd> properties are used to specify the skew angle of the <em>X</em> axis and the <em>Y</em> axis, while the <kbd>CenterX</kbd> and <kbd>CenterY</kbd> properties are used to specify the <em>X</em> and <em>Y</em> coordinates of the center point.</p>
<p>In this recipe, we will learn how to apply skew transform to an image.</p>
<h2 id="uuid-7d6d438c-0b18-4fca-9350-9ceab614d845">Getting ready</h2>
<p>To get started, open your Visual Studio IDE and create a new project named <kbd>CH08.SkewTransformDemo</kbd>, based on the WPF application template.</p>
<h2 id="uuid-4a210b3d-f3c3-46dd-bfdd-2b11002e094d">How to do it...</h2>
<p>Let's add some images to the application window and apply skew to those at a certain angle and certain center positions. Follow these steps:</p>
<ol>
<li>From Solution Explorer, right-click on the project node and create a new folder. Name it <kbd>Images</kbd>.</li>
<li>Now right-click on the <kbd>Images</kbd> folder and add an existing image from your system. Name it as <kbd>image1.png</kbd>.</li>
<li>Open the <kbd>MainWindow.xaml</kbd> file and replace the existing <kbd>Grid</kbd> with a horizontal <kbd>StackPanel</kbd>.</li>
<li>Insert the following <kbd>Grid</kbd> inside the <kbd>StackPanel</kbd> to have two images. The first one will have opacity set to 20%, whereas the other will have a Skew applied to it at an angle of <kbd>50</kbd> degrees and <kbd>5</kbd> degrees on the <em>X</em> and <em>Y</em> axes. To set these, use the <kbd>AngleX</kbd> and <kbd>AngleY</kbd> properties, as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;Image Height="300" Width="260" 
           Margin="4" Opacity="0.2" 
           Source="Images/image1.png"/&gt; 
    &lt;Image Height="300" Width="260" 
           Margin="4" 
           Source="Images/image1.png"&gt; 
        &lt;Image.RenderTransform&gt; 
            &lt;SkewTransform AngleX="50" 
                           AngleY="5"/&gt; 
        &lt;/Image.RenderTransform&gt; 
    &lt;/Image&gt; 
&lt;/Grid&gt; </pre>
<ol start="5">
<li>Add one more <kbd>Grid</kbd> inside the <kbd>StackPanel</kbd> and insert two images inside the new <kbd>Grid</kbd>. Set <kbd>SkewTransform</kbd> to both of the images at the <em>X</em> and <em>Y</em> axes as <kbd>30</kbd> degrees and <kbd>5</kbd> degrees, respectively. For one of the images, set the skew center position at (<kbd>0</kbd>,<kbd>0</kbd>), and for the other image, set the skew center position at (<kbd>200</kbd>,<kbd>-100</kbd>) by specifying the <kbd>CenterX</kbd> and <kbd>CenterY</kbd> properties as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid Margin="200 0 0 0"&gt; 
    &lt;Image Height="300" Width="260" 
           Margin="4" Opacity="0.2" 
           Source="Images/image1.png"&gt; 
        &lt;Image.RenderTransform&gt; 
            &lt;SkewTransform AngleX="30" 
                           AngleY="5" 
                           CenterX="0" 
                           CenterY="0"/&gt; 
        &lt;/Image.RenderTransform&gt; 
    &lt;/Image&gt; 
    &lt;Image Height="300" Width="260" 
           Margin="4" Opacity="1.0" 
           Source="Images/image1.png"&gt; 
        &lt;Image.RenderTransform&gt; 
            &lt;SkewTransform AngleX="30" 
                           AngleY="5" 
                           CenterX="200" 
                           CenterY="-100"/&gt; 
        &lt;/Image.RenderTransform&gt; 
    &lt;/Image&gt; 
&lt;/Grid&gt; </pre>
<ol start="6">
<li>Let's run the application. You will see images on the screen, such as the following ones:</li>
</ol>
<div><img src="img/c9ed747f-bf86-4bf2-bd2a-67cb8927f455.png" style=""/></div>
<h2 id="uuid-0c8d1bb6-ebf9-48c4-a1dd-c459ed59bd2e">How it works...</h2>
<p>When you set <kbd>AngleX</kbd> and <kbd>AngleY</kbd> to a <kbd>SkewTransform</kbd>, the associated element skews/shears counterclockwise from the <em>Y</em> axis and the <em>X</em> axis, respectively, at an angle specified, which is measured in degrees.</p>
<p>The <kbd>CenterX</kbd> property is used to set the <em>X </em>coordinate of the transform center, whereas the <kbd>CenterY</kbd> property is used to set the <em>Y </em>coordinate of the transform center. In the preceding example, when we specified <kbd>CenterX</kbd> and <kbd>CenterY</kbd> to the image, it changed the skew position centered at (<kbd>200</kbd>,<kbd>-100</kbd>) coordinate point, as shown in the following screenshot:</p>
<div><img src="img/242686f9-efae-441c-9d4c-c33dbfd458f4.png" style=""/></div>
<h1 id="uuid-ea9ea063-a7a6-4ea5-959f-d9cf3b12400b">Moving an element while rendering</h1>
<p><kbd>TranslateTransform</kbd> is used to move an element from one position to another in the 2D interface. The <kbd>X</kbd> and <kbd>Y</kbd> properties are used to move an element towards the <em>X</em> and <em>Y</em> axes. In this recipe, we will learn how to apply this transforming to an element.</p>
<h2 id="uuid-10d23a11-f128-4eb7-9ca0-cc58d9b2bdb6">Getting ready</h2>
<p>Open Visual Studio and create a project named <kbd>CH08.TranslateTransformDemo</kbd> based on the WPF application template.</p>
<h2 id="uuid-a7bc787b-c744-4b02-a9d2-dd98381ef2f6">How to do it...</h2>
<p>Follow these simple steps to move an image from a certain coordinate location specified by the <kbd>X</kbd> and <kbd>Y</kbd> properties:</p>
<ol>
<li>Before working on this, we need to add an image file to the project. From Solution Explorer, right-click on the project node and create a new folder. Name it <kbd>Images</kbd>.</li>
<li>Now right-click on the <kbd>Images</kbd> folder and add an existing image from your system. Name it <kbd>image1.png</kbd>.</li>
<li>Open the <kbd>MainWindow.xaml</kbd> file and add two images inside the <kbd>Grid</kbd> panel. Set the first one with a transparency of 30%. For the second image, add a <kbd>TranslateTransform</kbd> to it at a (<kbd>300</kbd>,<kbd>80</kbd>) location specified by the <kbd>X</kbd> and <kbd>Y</kbd> properties, as shared in the following screenshot:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid VerticalAlignment="Top" 
      HorizontalAlignment="Left"&gt; 
    &lt;Image Height="300" Width="260" 
           Margin="4" Opacity="0.3" 
           Source="Images/image1.png"/&gt; 
    &lt;Image Height="300" Width="260" 
           Margin="4" 
           Source="Images/image1.png"&gt; 
        &lt;Image.RenderTransform&gt; 
            &lt;TranslateTransform X="300" 
                                Y="80"/&gt; 
        &lt;/Image.RenderTransform&gt; 
    &lt;/Image&gt; 
&lt;/Grid&gt; </pre>
<ol start="4">
<li>That's it! Let's build and run the application.</li>
</ol>
<h2 id="uuid-65d515cd-152c-494a-b82e-cc53e3d4efd3">How it works...</h2>
<p>When you run the application, you will see two images on the screen. The first one, which has a 20% opacity level, is placed at the far left of the window. The second image, which was placed on top of it, has been moved to a coordinate point (<kbd>300</kbd>, <kbd>80</kbd>), as shown in the following screenshot:</p>
<div><img src="img/adc4c088-b021-40ed-86fa-0e5408a390f5.png" style=""/></div>
<p>To set the distance to translate along the <em>X</em> axis, the <kbd>X</kbd> property of the <kbd>TranslateTransform</kbd> is used, which is <kbd>300</kbd> here. Similarly, to set the distance to translate along the <em>Y</em> axis, the <kbd>Y</kbd> property of the <kbd>TranslateTransform</kbd> is used. It is <kbd>80</kbd> in our case.</p>
<h1 id="uuid-b496358c-ee40-4e0b-b616-7f7036b4be39">Grouping multiple transforms</h1>
<p>It is not mandatory to have a single transform to a single element. You can group multiple transforms to it, by using the <kbd>&lt;TransformGroup&gt;&lt;/TransformGroup&gt;</kbd> tag. In this recipe, we will learn how to group multiple transforms.</p>
<h2 id="uuid-60b0f106-0f0c-403d-85f5-934537d4c2e0">Getting ready</h2>
<p>To get started, open Visual Studio and create a new project named <kbd>CH08.GroupedTransformsDemo</kbd> based on the WPF application template.</p>
<h2 id="uuid-41cea957-7277-4631-a8b8-cc1cac98d8ad">How to do it...</h2>
<p>Let's follow these steps to add two images to the application window and flip the second image to give a reflection effect. This will be done by grouping multiple transforms to that image:</p>
<ol>
<li>First, we need to add an image to the project. To do this, create a folder named <kbd>Images</kbd> in the project root directory.</li>
<li>Right-click on the <kbd>Images</kbd> folder and add an existing image to it. Name it <kbd>image1.png</kbd>, which will be accessible from XAML as <kbd>Images/image1.png</kbd>.</li>
<li>From the Solution Explorer, navigate to the <kbd>MainWindow.xaml</kbd> file.</li>
<li>Replace the existing <kbd>Grid</kbd> panel with a horizontal <kbd>StackPanel</kbd>.</li>
<li>Insert two <kbd>Image</kbd> controls inside it and set their names as <kbd>originalImage</kbd> and <kbd>flippedImage</kbd>.</li>
<li>Now set the image source of both the controls to <kbd>Images/image1.png</kbd> and then set their size. This is how the XAML will look:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Horizontal" 
            Margin="10"&gt; 
    &lt;Image x:Name="originalImage" 
           Source="Images/image1.png" 
           Height="200" Width="250"/&gt; 
    &lt;Image x:Name="flippedImage" 
           Source="Images/image1.png" 
           Height="200" Width="250"/&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="7">
<li>Run the application, which will give the following output:</li>
</ol>
<div><img src="img/d48f1a02-d776-4077-b41b-f86478da9ba7.png" style=""/></div>
<ol start="8">
<li>Close the application and return to the <kbd>MainWindow.xaml</kbd> file.</li>
<li>Now we will flip the second image (<kbd>flippedImage</kbd>) to give a reflection effect. To do so, first set the <kbd>RenderTransformOrigin</kbd> of the <kbd>Image</kbd> control to <kbd>0.5,0.5</kbd>.</li>
<li>Now add <kbd>&lt;Image.RenderTransform&gt;</kbd> to add the transforms mark-up. In this case, as we are going to add multiple transforms, add a <kbd>&lt;TransformGroup&gt;</kbd> tag inside it.</li>
<li>Let's add <kbd>ScaleTransform</kbd>, <kbd>SkewTransform</kbd>, <kbd>RotateTransform</kbd>, and <kbd>TranslateTransform</kbd> inside the <kbd>&lt;TransformGroup&gt;</kbd> tag to flip the image. This is how the <kbd>RenderTransform</kbd> of the <kbd>Image</kbd> will look:</li>
</ol>
<pre style="padding-left: 90px">&lt;Image x:Name="flippedImage" 
       Source="Images/image1.png" 
       Height="200" Width="250"  
       RenderTransformOrigin="0.5,0.5"&gt; 
    &lt;Image.RenderTransform&gt; 
        &lt;TransformGroup&gt; 
            &lt;ScaleTransform ScaleY="1" ScaleX="-1"/&gt; 
            &lt;SkewTransform AngleY="0" AngleX="0"/&gt; 
            &lt;RotateTransform Angle="0"/&gt; 
            &lt;TranslateTransform/&gt; 
        &lt;/TransformGroup&gt; 
    &lt;/Image.RenderTransform&gt; 
&lt;/Image&gt; </pre>
<p style="padding-left: 30px">Once done with the changes, your XAML will look as the following code:</p>
<pre style="padding-left: 90px">&lt;StackPanel Orientation="Horizontal" <br/> Margin="10"&gt; <br/> &lt;Image x:Name="originalImage" <br/> Source="Images/image1.png" <br/> Height="200" Width="250"/&gt; <br/> &lt;Image x:Name="flippedImage" <br/> Source="Images/image1.png" <br/> Height="200" Width="250" <br/> RenderTransformOrigin="0.5,0.5"&gt; <br/> &lt;Image.RenderTransform&gt; <br/> &lt;TransformGroup&gt; <br/> &lt;ScaleTransform ScaleY="1" ScaleX="-1"/&gt; <br/> &lt;SkewTransform AngleY="0" AngleX="0"/&gt; <br/> &lt;RotateTransform Angle="0"/&gt; <br/> &lt;TranslateTransform/&gt; <br/> &lt;/TransformGroup&gt; <br/> &lt;/Image.RenderTransform&gt; <br/> &lt;/Image&gt; <br/>&lt;/StackPanel&gt;</pre>
<ol start="12">
<li>Let's build the project and run the application again. What did you see? There's a reflection of the first image created by flipping the second image. Here's a screenshot of the output:</li>
</ol>
<div><img src="img/7f95dc29-e35d-445c-a828-3f1403d9df41.png" style=""/></div>
<h2 id="uuid-6b487c83-513d-44cf-8e5f-2ca6394f5fdb">How it works...</h2>
<p>It works by defining the transformation mark-up inside the <kbd>&lt;TransformGroup&gt;</kbd> tag. In our example, we applied the <kbd>ScaleTransform</kbd>, which created a flip effect. The rest of the other transforms that we applied here use default values. You can modify their values and check how this works in the UI.</p>
<h2 id="uuid-cb74646d-98e5-4c0b-8e1a-10c5acc99bcc">There's more...</h2>
<p>Visual Studio provides you with a straightforward way to add transforms to any UI element. From the designer view, select the element for which you want to apply the transform and navigate to its Properties pane. Here, you can find an expander pane with the title Transform. This is used to set various values to different transforms available in XAML.</p>
<p>As shown in the following screenshot, you can define <kbd>TranslateTransform</kbd>, <kbd>RotateTransform</kbd>, <kbd>ScaleTransform</kbd>, <kbd>SkewTransform</kbd>, and <kbd>Flip</kbd>. Each tab/section consists of different values that it can accept:</p>
<div><img src="img/4e62bc3c-c59d-4ab4-99b5-02dfb56950cb.png" style=""/></div>
<h1 id="uuid-44e71be2-f3a8-4a76-90f1-643486bcdc23">Creating property-based animations</h1>
<p><strong>Property-based animations</strong> are used to change a dependency property from one value to another in a duration specified. There exists various animation classes under the namespace <kbd>System.Windows.Media.Animation</kbd>, which includes <kbd>DoubleAnimation</kbd>, <kbd>ColorAnimation</kbd>, and <kbd>PointAnimation</kbd>. These are used to create animation based on the type of property being animated.</p>
<p>In this recipe, we will learn how to create property-based animations. Keep in mind that only Dependency Properties can be modifiable during an animation.</p>
<h2 id="uuid-af92323d-b006-4e4b-b2f1-7257a8b05b1e">Getting ready</h2>
<p>To get started with this recipe, let's first create a project. Open Visual Studio IDE and create a project named <kbd>CH08.PropertyBasedAnimationDemo</kbd>, based on the WPF application template.</p>
<h2 id="uuid-045c250b-a284-4ce6-8670-d50c561213f7">How to do it...</h2>
<p>In this demonstration, we will add a square box to the application window. On mouse hover, we will run a storyboard to change the size and color of the box and then reset it to the initial value on mouse leave. Follow these steps:</p>
<ol>
<li>From Solution Explorer, navigate to the <kbd>MainWindow.xaml</kbd> file.</li>
<li>Inside the XAML file, you will find a <kbd>Grid</kbd> panel placed by default. Let's add a <kbd>Rectangle</kbd> control inside it and set its <kbd>Height</kbd> and <kbd>Width</kbd> properties to <kbd>100</kbd> to give it a square look.</li>
<li>Give the rectangle the name <kbd>squareBox</kbd> so that we can identify it from our <kbd>Storyboard</kbd>.</li>
<li>Add a <kbd>SolidColorBrush</kbd> to fill the background of the <kbd>Rectangle</kbd>. Set a color to the brush and name it <kbd>squareBoxFillBrush</kbd>. Here's the XAML snippet:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;Rectangle x:Name="squareBox" 
               Height="100" 
               Width="100"&gt; 
        &lt;Rectangle.Fill&gt; 
            &lt;SolidColorBrush x:Name="squareBoxFillBrush"  
                             Color="Black"/&gt; 
        &lt;/Rectangle.Fill&gt; 
 
    &lt;/Rectangle&gt; 
&lt;/Grid&gt; </pre>
<ol start="5">
<li>As we need to add a <kbd>Storyboard</kbd> animation to the <kbd>MouseEnter</kbd> and <kbd>MouseLeave</kbd> events of the <kbd>Rectangle</kbd>, let's control these using triggers. As shown, add a <kbd>&lt;Rectangle.Triggers&gt;&lt;/Rectangle.Triggers&gt;</kbd> element to our <kbd>Rectangle</kbd> control:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;Rectangle x:Name="squareBox" 
               Height="100" 
               Width="100"&gt; 
        &lt;Rectangle.Fill&gt; 
            &lt;SolidColorBrush x:Name="squareBoxFillBrush"  
                             Color="Black"/&gt; 
        &lt;/Rectangle.Fill&gt; 
        &lt;Rectangle.Triggers&gt;</pre>
<pre style="padding-left: 90px">        &lt;/Rectangle.Triggers&gt; 
    &lt;/Rectangle&gt; 
&lt;/Grid&gt; </pre>
<ol start="6">
<li>As we will be triggering the animation on <kbd>MouseEnter</kbd> and <kbd>MouseLeave</kbd> events, add an <kbd>EventTrigger</kbd> inside the <kbd>&lt;Rectangle.Triggers&gt;&lt;/Rectangle.Triggers&gt;</kbd> element that we have added.</li>
<li>Now expand the trigger to have <kbd>Actions</kbd> to begin a <kbd>Storyboard</kbd> animation. Modify your XAML mark-up as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;Rectangle.Triggers&gt; 
    &lt;EventTrigger RoutedEvent="MouseEnter"&gt; 
        &lt;EventTrigger.Actions&gt; 
            &lt;BeginStoryboard&gt; 
                &lt;Storyboard&gt; 
 
                &lt;/Storyboard&gt; 
            &lt;/BeginStoryboard&gt; 
        &lt;/EventTrigger.Actions&gt; 
    &lt;/EventTrigger&gt; 
&lt;/Rectangle.Triggers&gt; </pre>
<ol start="8">
<li>Inside the <kbd>Storyboard</kbd> animation for the <kbd>MouseEnter</kbd> event, we will be changing the size and color of the <kbd>squareBox</kbd> rectangle control. By using <kbd>DoubleAnimation</kbd>, we will be changing the <kbd>Height</kbd> and <kbd>Width</kbd> properties of the rectangle, and by using the <kbd>ColorAnimation</kbd> we will be changing the <kbd>Fill</kbd> color. Update the <kbd>Storyboard</kbd> as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;Storyboard&gt; 
    &lt;DoubleAnimation Storyboard.TargetName="squareBox" 
                     Storyboard.TargetProperty="Height" 
                     To="200"/&gt; 
    &lt;DoubleAnimation Storyboard.TargetName="squareBox" 
                     Storyboard.TargetProperty="Width" 
                     To="400"/&gt; 
    &lt;ColorAnimation  
             Storyboard.TargetName="squareBoxFillBrush" 
             Storyboard.TargetProperty="Color" 
             To="OrangeRed" 
             Duration="0:0:1"/&gt; 
&lt;/Storyboard&gt;</pre>
<ol start="9">
<li>Similarly, add another <kbd>EventTrigger</kbd> to the <kbd>Rectangle</kbd> control to trigger another <kbd>Storyboard</kbd> on the <kbd>MouseLeave</kbd> event to reset the size and the color. This new mark-up will look as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;EventTrigger RoutedEvent="MouseLeave"&gt; 
    &lt;EventTrigger.Actions&gt; 
        &lt;BeginStoryboard&gt; 
            &lt;Storyboard&gt; 
                &lt;DoubleAnimation  
                       Storyboard.TargetName="squareBox" 
                       Storyboard.TargetProperty="Height" 
                       To="100"/&gt; 
                &lt;DoubleAnimation  
                       Storyboard.TargetName="squareBox" 
                       Storyboard.TargetProperty="Width" 
                       To="100"/&gt; 
                &lt;ColorAnimation  
              Storyboard.TargetName="squareBoxFillBrush" 
              Storyboard.TargetProperty="Color" 
              To="Black" 
              Duration="0:0:1"/&gt; 
            &lt;/Storyboard&gt; 
        &lt;/BeginStoryboard&gt; 
    &lt;/EventTrigger.Actions&gt; 
&lt;/EventTrigger&gt; </pre>
<ol start="10">
<li>Run the application now. You will see a square with a <kbd>Black</kbd> background, as shown in the following screenshot:</li>
</ol>
<div><img src="img/1935020f-19bc-470c-9d93-ccaeccc31b9e.png" style=""/></div>
<ol start="11">
<li>Mouse hover on the square. This will resize the square to a rectangle and change the color to <kbd>OrangeRed</kbd>. Check the transition of the size and color, which will have a nice animation:</li>
</ol>
<div><img src="img/533e41c5-8a5c-4f35-8622-64d4079933af.png" style=""/></div>
<ol start="12">
<li>Now hover out your mouse cursor from the rectangle. What happens now? With a nice animation, the rectangle will reset back to a square. Also, the background color will change from <kbd>OrangeRed</kbd> to <kbd>Black</kbd>.</li>
</ol>
<h2 id="uuid-fa0a44bf-401e-417b-a743-bd7657885e33">How it works...</h2>
<p>Animations may be created manually by constructing the appropriate animation type, specifying properties, and then calling <kbd>BeginStoryboard</kbd> on the element to animate. The properties must be of type dependency property, which you want to animate on the animation object.</p>
<p>In this example, when the <kbd>MouseEnter</kbd> event triggers, the following <kbd>Storyboard</kbd> animation runs. <kbd>DoubleAnimation</kbd> and <kbd>ColorAnimation</kbd> accepts the attached properties, <kbd>Storyboard.TargetName</kbd> and <kbd>Storyboard.TargetProperty</kbd>, which allows the <kbd>Storyboard</kbd> to change the said property of the targeted element at runtime:</p>
<pre style="padding-left: 60px">&lt;Storyboard&gt; 
    &lt;DoubleAnimation Storyboard.TargetName="squareBox" 
                     Storyboard.TargetProperty="Height" 
                     To="200"/&gt; 
    &lt;DoubleAnimation Storyboard.TargetName="squareBox" 
                     Storyboard.TargetProperty="Width" 
                     To="400"/&gt; 
    &lt;ColorAnimation Storyboard.TargetName="squareBoxFillBrush" 
                    Storyboard.TargetProperty="Color" 
                    To="OrangeRed" 
                    Duration="0:0:1"/&gt; 
&lt;/Storyboard&gt; </pre>
<p><kbd>From</kbd> and <kbd>To</kbd> properties are used to change the property from a specified value to another. Though it is optional to set the <kbd>From</kbd> field, you need to specify the <kbd>To</kbd> field in order to have the change in effect for the <kbd>Storyboard</kbd>. In the preceding example, the animation will change the <kbd>Height</kbd>, <kbd>Width</kbd>, and <kbd>Color</kbd> from its initial value.</p>
<p>You can also set a <kbd>TimeSpan</kbd> to the animation to set the time for the transition to occur. You can use the <kbd>Duration</kbd> property to set the value. In the preceding example, it will take <kbd>1</kbd> second for the transition to happen from a <kbd>Black</kbd> color to an <kbd>OrangeRed</kbd> color.</p>
<p>Similarly, when the <kbd>MouseLeave</kbd> event triggers, the following <kbd>Storyboard</kbd> responsible for resetting the value will trigger, which will set the <kbd>To</kbd> field to its initial value. When the <kbd>Storyboard</kbd> runs, you will see a nice transitional animation on the screen:</p>
<pre style="padding-left: 60px">&lt;Storyboard&gt; 
    &lt;DoubleAnimation Storyboard.TargetName="squareBox" 
                     Storyboard.TargetProperty="Height" 
                     To="100"/&gt; 
    &lt;DoubleAnimation Storyboard.TargetName="squareBox" 
                     Storyboard.TargetProperty="Width" 
                     To="100"/&gt; 
    &lt;ColorAnimation Storyboard.TargetName="squareBoxFillBrush" 
                    Storyboard.TargetProperty="Color" 
                    To="Black" 
                    Duration="0:0:1"/&gt; 
&lt;/Storyboard&gt; </pre>
<p>These are some common properties that you will find in most of the animation types:</p>
<ul>
<li><kbd>From</kbd>: It is used to indicate the starting value of the animation. If you omit the <kbd>From</kbd> field, it will use the current value of the dependency property.</li>
<li><kbd>To</kbd>: It is the target value of the animation, which you should fill. If you omit it or put the current value, the said animation will have no effect.</li>
<li><kbd>Duration</kbd>: It is the duration of the animation. Apart from a <kbd>TimeSpan</kbd> type value in <kbd>hh:mm:ss.ms</kbd> format, it can also contain two special values—<kbd>Duration.Automatic</kbd> (default value) and <kbd>Duration.Forever</kbd>. When you specify <kbd>Duration.Forever</kbd>, it will run for an infinite length. In XAML, <kbd>hh:mm:ss.ms</kbd> format is mostly used.</li>
<li><kbd>FillBehavior</kbd>: It indicates the animation's behavior when it ends. The default value <kbd>FillEnd</kbd> asks to keep the last animation value; the previous value, which was used before the animation, will have no effect. The other value, <kbd>Stop</kbd>, destroys the animation and reverts the property to its value without the animation.</li>
<li><kbd>BeginTime</kbd>: When you want to set a delay before the animation begins, you can use this attribute to define the delay time.</li>
<li><kbd>AutoReverse</kbd>: If you want to automatically reverse the animation, after it ends, you can set it to <kbd>true</kbd>. The total animation duration will be effectively doubled when enabled.</li>
<li><kbd>SpeedRatio</kbd>: It allows you to speed up or slow down the animation duration.</li>
<li><kbd>RepeatBehavior</kbd>: This attribute specifies the count or the time you want to repeat the animation, after it ends. This is often useful when you set <kbd>AutoReverse</kbd> to <kbd>true</kbd>.</li>
</ul>
<h1 id="uuid-9ad920f0-7c9d-4bf2-9f91-c418a093b2ac">Creating path-based animations</h1>
<p>Along with property-based animations, which we learned about in the previous recipe, WPF also supports <strong>path-based animations</strong> that run along a path specified by the <kbd>PathGeometry</kbd>.</p>
<p>In this recipe, we will learn how to use a <kbd>PathGeometry</kbd> to animate an element along its way.</p>
<h2 id="uuid-4109eb29-d339-45c1-8df5-1cf54cbca6a6">Getting ready</h2>
<p>Let's begin with creating a new WPF application project. Name it <kbd>CH08.PathBasedAnimationDemo</kbd>.</p>
<h2 id="uuid-d4d92c42-be92-437e-994b-18e4385fb726">How to do it...</h2>
<p>In this demonstration, we will use a circle to animate it on the click of a button. The animation will be performed based on a path specified by a set of geometry coordinates. Let's build this by following the steps mentioned here:</p>
<ol>
<li>From Solution Explorer, navigate to the <kbd>MainWindow.xaml</kbd> file.</li>
</ol>
<p> </p>
<ol start="2">
<li>A default <kbd>Grid</kbd> panel will be present inside the file. Let's divide it into two rows by specifying the row definition as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid.RowDefinitions&gt; 
    &lt;RowDefinition Height="*"/&gt; 
    &lt;RowDefinition Height="Auto"/&gt; 
&lt;/Grid.RowDefinitions&gt; </pre>
<ol start="3">
<li>Let's place a <kbd>Canvas</kbd> panel inside the first row. Add an <kbd>Ellipse</kbd> of <kbd>Height="30"</kbd> and <kbd>Width="30"</kbd> to form the circle. Give it a name <kbd>circle</kbd>.</li>
<li>Set the fill color of the <kbd>Ellipse</kbd> and position it at the (<kbd>100</kbd>, <kbd>100</kbd>) coordinate location of the canvas. Here's the complete mark-up for your reference:</li>
</ol>
<pre style="padding-left: 90px">&lt;Canvas Grid.Row="0"&gt; 
    &lt;Ellipse x:Name="circle" 
             Height="30" 
             Width="30" 
             Canvas.Left="100" 
             Canvas.Top="100" 
             Fill="OrangeRed"/&gt; 
&lt;/Canvas&gt; </pre>
<ol start="5">
<li>We will be using this <kbd>Ellipse</kbd> to animate inside the canvas along a path. For this, we will need a <kbd>PathGeometry</kbd> defined. To do so, add the following inside the <kbd>Window</kbd> tag as <kbd>Resources</kbd> to define the <kbd>PolyLineSegment</kbd> points as a collection of coordinates:</li>
</ol>
<pre style="padding-left: 90px">&lt;Window.Resources&gt; 
    &lt;PathGeometry x:Key="animationPath"&gt; 
        &lt;PathFigure IsClosed="True"  
                    StartPoint="100,100"&gt; 
            &lt;PolyLineSegment Points="150,150 400,200 300,50 200,200 100,100 400,100 50,50 400,150 100,250, 100,50" /&gt; 
        &lt;/PathFigure&gt; 
    &lt;/PathGeometry&gt; 
&lt;/Window.Resources&gt;</pre>
<ol start="6">
<li>Let's add a <kbd>Button</kbd> control inside the <kbd>Window</kbd>, which will be used to trigger the animation. Surround the button with a horizontal <kbd>StackPanel</kbd> and place it inside the second row of the <kbd>Grid</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Grid.Row="1" 
            Orientation="Horizontal" 
            HorizontalAlignment="Center" 
            Margin="10"&gt; 
    &lt;Button Content="Animate" 
            Width="100"&gt; 
 
    &lt;/Button&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="7">
<li>Now we need to catch the <kbd>Button.Click</kbd> event. For this, we will need an <kbd>EventTrigger</kbd> to define against the <kbd>Button</kbd> control. And, once the trigger fires, the action is to begin a <kbd>Storyboard</kbd> to perform an animation. Let's modify the <kbd>Button</kbd> control to have this trigger set to start a storyboard. Here's the code to refer to:</li>
</ol>
<pre style="padding-left: 90px">&lt;Button Content="Animate" 
        Width="100"&gt; 
    &lt;Button.Triggers&gt; 
        &lt;EventTrigger RoutedEvent="Button.Click"&gt; 
            &lt;EventTrigger.Actions&gt; 
                &lt;BeginStoryboard&gt; 
                    &lt;Storyboard x:Name="Animate" 
                                AutoReverse="True"&gt; 
 
                    &lt;/Storyboard&gt; 
                &lt;/BeginStoryboard&gt; 
            &lt;/EventTrigger.Actions&gt; 
        &lt;/EventTrigger&gt; 
    &lt;/Button.Triggers&gt; 
&lt;/Button&gt; </pre>
<ol start="8">
<li>Now it's time to add some path animations to the <kbd>Storyboard</kbd> that we have added inside the <kbd>Button.Click</kbd> event handler. Let's use <kbd>DoubleAnimationUsingPath</kbd> to bind the <kbd>PathGeometry</kbd> that we added to the <kbd>Window.Resources</kbd> tag.</li>
</ol>
<p> </p>
<ol start="9">
<li>Set the <kbd>Storyboard.TargetName</kbd> to <kbd>circle</kbd> and the <kbd>Storyboard.TargetProperty</kbd> to <kbd>(Canvas.Left)</kbd> and <kbd>(Canvas.Top)</kbd> to create an animation in both the <em>X</em> and <em>Y</em> axes. Here's the code:</li>
</ol>
<pre style="padding-left: 90px">&lt;DoubleAnimationUsingPath Duration="0:0:5" 
       Storyboard.TargetName="circle"         
       Storyboard.TargetProperty="(Canvas.Left)" 
       PathGeometry="{StaticResource animationPath}" 
       Source="X"/&gt; 
&lt;DoubleAnimationUsingPath Duration="0:0:5" 
       Storyboard.TargetName="circle" 
       Storyboard.TargetProperty="(Canvas.Top)" 
       PathGeometry="{StaticResource animationPath}" 
       Source="Y"/&gt; </pre>
<ol start="10">
<li>Let's build the application and run it. You will see the following UI with a circle and a button:</li>
</ol>
<div><img src="img/fb9dc284-e516-4edc-b560-75406166e27c.png" style=""/></div>
<ol start="11">
<li>Click on the Animate button and observe the positions of the circle. You will see a nice animated flow on the screen:</li>
</ol>
<div><img src="img/1f8d3070-7d43-4f4c-bdba-70e7129a234a.png" style=""/></div>
<h2 id="uuid-0763c066-3363-437d-a07a-e1f4ef93d69a">How it works...</h2>
<p>The path-based animations use a <kbd>PathGeometry</kbd> as a path to create the animation. In our example, we defined it under the <kbd>Window.Resources</kbd> tag as an <kbd>animationPath</kbd>, which represents the path in a 2D interface as a collection of coordinate points. See the following code snippet:</p>
<pre style="padding-left: 60px">&lt;PathGeometry x:Key="animationPath"&gt; 
    &lt;PathFigure IsClosed="True"  
                StartPoint="100,100"&gt; 
        &lt;PolyLineSegment Points="150,150 400,200 300,50 200,200 100,100 400,100 50,50 400,150 100,250, 100,50" /&gt; 
    &lt;/PathFigure&gt; 
&lt;/PathGeometry&gt; </pre>
<p>The <kbd>DoubleAnimationUsingPath</kbd> that we used in our storyboard animation uses <kbd>Canvas.Left</kbd> and <kbd>Canvas.Top</kbd> as the target properties to animate along the <em>X</em> and <em>Y</em> axes. When the <kbd>Storyboard</kbd> plays, the target element moves from one coordinate point to another, having a smooth animation between the two points.</p>
<h1 id="uuid-015892b7-2d4c-4df2-be00-6cd5a2da8ecc">Creating key-frame-based animations</h1>
<p>Key frame animations in WPF enable you to animate an element using more than two target-values and control an animation's interpolation method. A key frame animation has no <kbd>From</kbd>/<kbd>To</kbd> properties with which we can set its target values.</p>
<p>The animation's target values are described using key frame objects, which you need to add to the animation's <kbd>KeyFrames</kbd> collection. When the animation runs, it transitions between the key frames that you specified.</p>
<p>In this recipe, we will learn how to create a key-frame-based animation and use it in our application.</p>
<h2 id="uuid-9f99a2c9-54ea-4955-95c1-591d61c10e4f">Getting ready</h2>
<p>We need to create a project first. Open Visual Studio IDE and create a new project named <kbd>CH08.KeyFrameBasedAnimationDemo</kbd>, based on the WPF application template.</p>
<h2 id="uuid-328ba0df-2f15-4f6f-be9b-5d45bbd309af">How to do it...</h2>
<p>Let's follow these steps to create a key-frame-based animation:</p>
<ol>
<li>Open the <kbd>MainWindow.xaml</kbd> file.</li>
<li>Add two rows inside the <kbd>Grid</kbd>, by specifying <kbd>RowDefinitions</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid.RowDefinitions&gt; 
    &lt;RowDefinition Height="*"/&gt; 
    &lt;RowDefinition Height="Auto"/&gt; 
&lt;/Grid.RowDefinitions&gt; </pre>
<ol start="3">
<li>Add a <kbd>Canvas</kbd> panel at 0<sup>th</sup> row of the <kbd>Grid</kbd>.</li>
<li>Insert an <kbd>Ellipse</kbd> inside the canvas and set its <kbd>Height</kbd> and <kbd>Width</kbd> properties to <kbd>30</kbd>, so that it displays as a circle.</li>
<li>Provide a name to the <kbd>Ellipse</kbd>, and position it to the (<kbd>50</kbd>,<kbd>100</kbd>) coordinate position on the <kbd>Canvas</kbd> panel, and fill the background with an <kbd>OrangeRed</kbd> color.</li>
</ol>
<p> </p>
<ol start="6">
<li>Insert a <kbd>Button</kbd> control inside a horizontal <kbd>StackPanel</kbd>, and place the panel inside the second row. Here's the complete XAML of the UI that we have generated for this demonstration:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;Grid.RowDefinitions&gt; 
        &lt;RowDefinition Height="*"/&gt; 
        &lt;RowDefinition Height="Auto"/&gt; 
    &lt;/Grid.RowDefinitions&gt; 
    &lt;Canvas Grid.Row="0"&gt; 
        &lt;Ellipse x:Name="circle" 
                 Height="30" 
                 Width="30" 
                 Canvas.Left="50" 
                 Canvas.Top="100" 
                 Fill="OrangeRed"/&gt; 
    &lt;/Canvas&gt; 
    &lt;StackPanel Grid.Row="1" 
                Orientation="Horizontal" 
                HorizontalAlignment="Center" 
                Margin="10"&gt; 
        &lt;Button Content="Animate" 
                Width="100"&gt; 
 
        &lt;/Button&gt; 
    &lt;/StackPanel&gt; 
&lt;/Grid&gt; </pre>
<ol start="7">
<li>On pressing the button, we need to animate the circle around the application window. To do this, we will be using an <kbd>EventTrigger</kbd>. Define the trigger for a <kbd>Button.Click</kbd> event and set its action to begin a storyboard.</li>
<li>Set the <kbd>AutoReverse</kbd> property of the <kbd>Storyboard</kbd> to <kbd>True</kbd>. Here's the code for launching the storyboard when a user triggers the button click event:</li>
</ol>
<pre style="padding-left: 90px">&lt;Button Content="Animate" 
        Width="100"&gt; 
    &lt;Button.Triggers&gt; 
        &lt;EventTrigger RoutedEvent="Button.Click"&gt; 
            &lt;EventTrigger.Actions&gt; 
                &lt;BeginStoryboard&gt; 
                    &lt;Storyboard x:Name="Animate" 
                                AutoReverse="True"&gt; 
 
                    &lt;/Storyboard&gt; 
                &lt;/BeginStoryboard&gt; 
            &lt;/EventTrigger.Actions&gt; 
        &lt;/EventTrigger&gt; 
    &lt;/Button.Triggers&gt; 
&lt;/Button&gt; </pre>
<ol start="9">
<li>Inside the storyboard, we need to define an animation that will run based on the key frame specified. This is done by adding one or more <kbd>LinearDoubleKeyFrame</kbd>(s) inside a <kbd>DoubleAnimationUsingKeyFrames</kbd> element. Insert two instances of <kbd>DoubleAnimationUsingKeyFrames</kbd> inside the <kbd>Storyboard</kbd> definition.</li>
<li>Set the <kbd>Storyboard.TargetName</kbd> property of <kbd>DoubleAnimationUsingKeyFrames</kbd> to <kbd>circle</kbd>.</li>
<li>Set <kbd>AutoReverse</kbd> to <kbd>True</kbd> and <kbd>RepeatBehavior</kbd> to <kbd>Forever</kbd>.</li>
<li>For the first <kbd>DoubleAnimationUsingKeyFrames</kbd>, set the <kbd>Storyboard.TargetProperty</kbd> to <kbd>(Canvas.Left)</kbd>. For the other one, set it to <kbd>(Canvas.Top)</kbd>.</li>
<li>Define key frames by adding one or more <kbd>LinearDoubleKeyFrame</kbd> instances to the <kbd>DoubleAnimationUsingKeyFrames</kbd>. Set their <kbd>KeyTime</kbd> and <kbd>Value</kbd>. Here's the complete code:</li>
</ol>
<pre style="padding-left: 90px">&lt;DoubleAnimationUsingKeyFrames  
       Storyboard.TargetName="circle"  
       Storyboard.TargetProperty="(Canvas.Left)"  
       AutoReverse="True"          
       RepeatBehavior="Forever"&gt; 
    &lt;LinearDoubleKeyFrame Value="50"  
                          KeyTime="0:0:0" /&gt; 
    &lt;LinearDoubleKeyFrame Value="450" 
                          KeyTime="0:0:1" /&gt; 
    &lt;LinearDoubleKeyFrame Value="450" 
                          KeyTime="0:0:3" /&gt; 
    &lt;LinearDoubleKeyFrame Value="250" 
                          KeyTime="0:0:5" /&gt; 
&lt;/DoubleAnimationUsingKeyFrames&gt; 
&lt;DoubleAnimationUsingKeyFrames  
       Storyboard.TargetName="circle"  
       Storyboard.TargetProperty="(Canvas.Top)"  
       AutoReverse="True"          
       RepeatBehavior="Forever"&gt; 
    &lt;LinearDoubleKeyFrame Value="100"  
                          KeyTime="0:0:0" /&gt; 
    &lt;LinearDoubleKeyFrame Value="200" 
                          KeyTime="0:0:1" /&gt; 
    &lt;LinearDoubleKeyFrame Value="50" 
                          KeyTime="0:0:3" /&gt; 
    &lt;LinearDoubleKeyFrame Value="150" 
                          KeyTime="0:0:5" /&gt; 
&lt;/DoubleAnimationUsingKeyFrames&gt; </pre>
<ol start="14">
<li>Once done, let's run the application. You will see a circle on the screen at the (<kbd>50</kbd>, <kbd>100</kbd>) coordinate point. There also exists a button labeled Animate, as shown in the following screenshot:</li>
</ol>
<div><img src="img/080c21ef-7ee7-4a5a-8bc3-946293c5a839.png" style=""/></div>
<ol start="15">
<li>Click on the Animate button to start the defined storyboard. See the movement and the speed of the circle:</li>
</ol>
<div><img src="img/ffa3ac35-4712-45d0-b494-5264fee82e63.png" style=""/></div>
<h2 id="uuid-21ceb5cf-82c1-4a79-a941-5a219898eb3c">How it works...</h2>
<p>When a key frame animation begins, it iterates through the specified key frames in the order they were defined by their <kbd>KeyTime</kbd> properties. If there exists no key frame at time <kbd>0</kbd> (initial point), the animation creates a transition between the target property's current value and the <kbd>Value</kbd> of the first key frame defined in the collection.</p>
<p>If the animation's <kbd>Duration</kbd> is <kbd>Automatic</kbd> or set to the time of the last key frame, the animation ends.</p>
<p>In the preceding demonstration, the first key frame (at time <kbd>0</kbd>) sets the animation's output value to <kbd>Canvas.Left="50"</kbd> and <kbd>Canvas.Top="100"</kbd>. In the next key frame (at time <kbd>1 sec</kbd>), the output value sets to the (<kbd>450</kbd>,<kbd>200</kbd>) coordinate point, and you will see a smooth transition between the (<kbd>50</kbd>,<kbd>100</kbd>) and the (<kbd>450</kbd>,<kbd>200</kbd>) points. Similarly, in the third and fourth seconds, the circle transitions from (<kbd>450</kbd>,<kbd>200</kbd>) to (<kbd>450</kbd>,<kbd>50</kbd>) and then to the (<kbd>250</kbd>,<kbd>150</kbd>) coordinate points.</p>
<p>As the defined <kbd>Storyboard</kbd> has an <kbd>AutoReverse</kbd> property set to <kbd>True</kbd>, the animation will have a reverse transition to move the circle from the end point (<kbd>250</kbd>,<kbd>150</kbd>) to the initial start point (<kbd>50</kbd>,<kbd>100</kbd>) via the (<kbd>450</kbd>,<kbd>50</kbd>) and the (<kbd>450</kbd>,<kbd>200</kbd>) coordinate points.</p>
<h2 id="uuid-9389994b-2548-43ae-a0e7-12a698a4c4d9">There's more...</h2>
<p>The key-frame-based animation class type is not limited to only <kbd>DoubleAnimationUsingKeyFrames</kbd>. You can use any of the following key frame animation classes to construct your storyboard:</p>
<ul>
<li>Boolean: <kbd>BooleanAnimationUsingKeyFrames</kbd></li>
<li>Byte: <kbd>ByteAnimationUsingKeyFrames</kbd></li>
<li>Color: <kbd>ColorAnimationUsingKeyFrames</kbd></li>
<li>Decimal: <kbd>DecimalAnimationUsingKeyFrames</kbd></li>
<li>Double: <kbd>DoubleAnimationUsingKeyFrames</kbd></li>
<li>Int16: <kbd>Int16AnimationUsingKeyFrames</kbd></li>
<li>Int32: <kbd>Int32AnimationUsingKeyFrames</kbd></li>
<li>Int64: <kbd>Int64AnimationUsingKeyFrames</kbd></li>
<li>Matrix: <kbd>MatrixAnimationUsingKeyFrames</kbd></li>
<li>Object: <kbd>ObjectAnimationUsingKeyFrames</kbd></li>
<li>Point: <kbd>PointAnimationUsingKeyFrames</kbd></li>
<li>Quaternion: <kbd>QuaternionAnimationUsingKeyFrames</kbd></li>
<li>Rect: <kbd>RectAnimationUsingKeyFrames</kbd></li>
<li>Rotation3D: <kbd>Rotation3DAnimationUsingKeyFrames</kbd></li>
<li>Single: <kbd>SingleAnimationUsingKeyFrames</kbd></li>
<li>String: <kbd>StringAnimationUsingKeyFrames</kbd></li>
<li>Size: <kbd>SizeAnimationUsingKeyFrames</kbd></li>
<li>Thickness: <kbd>ThicknessAnimationUsingKeyFrames</kbd></li>
<li>Vector3D: <kbd>Vector3DAnimationUsingKeyFrames</kbd></li>
<li>Vector: <kbd>VectorAnimationUsingKeyFrames</kbd></li>
</ul>
<h1 id="uuid-95f5ad48-f0fb-4ff0-9a1b-e7b2c019f48d">Adding easing effects to animations</h1>
<p>Property-based animations are linear, whereas the key-frame-based animations are non-linear and are used to create <strong>Beizer</strong>-based interpolations. But creation of such effects is not so easy. To overcome this, WPF 4 introduces <strong>easing functions</strong> to turn a linear animation into a non-linear one and add some easing effects to those animation objects.</p>
<p>In this recipe, we will learn how to do this with a suitable example.</p>
<h2 id="uuid-f5537267-e3dc-4fea-8208-9113f08c5909">Getting ready</h2>
<p>To get started with adding easing effects to an animation, let's open Visual Studio and create a new project named <kbd>CH08.EasingEffectDemo</kbd>. Select a WPF application template while creating the project.</p>
<h2 id="uuid-3bfae414-adad-4216-b7a5-b198887f0273">How to do it...</h2>
<p>Let's follow these steps to create an animation with various kinds of easing effects:</p>
<ol>
<li>From Solution Explorer, open the <kbd>MainWindow.xaml</kbd> file.</li>
<li>Divide the existing <kbd>Grid</kbd> panel into two columns, by applying <kbd>ColumnDefinition</kbd> to it:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid.ColumnDefinitions&gt; 
    &lt;ColumnDefinition Width="*"/&gt; 
    &lt;ColumnDefinition Width="Auto"/&gt; 
&lt;/Grid.ColumnDefinitions&gt; </pre>
<ol start="3">
<li>Now, inside the <kbd>Grid</kbd>, place a <kbd>Canvas</kbd> panel, and set its <kbd>Grid.Column</kbd> attribute to <kbd>0</kbd> (zero).</li>
</ol>
<p> </p>
<ol start="4">
<li>Inside the canvas, add an <kbd>Ellipse</kbd> (name it as <kbd>circle</kbd>) and set its <kbd>Height</kbd> and <kbd>Width</kbd> properties to <kbd>80</kbd> to give it a circular look. Set its <kbd>Fill</kbd> color property, and position it to a (<kbd>150</kbd>,<kbd>80</kbd>) location. Here's the code snippet:</li>
</ol>
<pre style="padding-left: 90px">&lt;Canvas Grid.Column="0"&gt; 
    &lt;Ellipse x:Name="circle" 
             Height="80" 
             Width="80" 
             Fill="OrangeRed" 
             Canvas.Left="150" 
             Canvas.Top="80"/&gt; 
&lt;/Canvas&gt; </pre>
<ol start="5">
<li>Now add a vertical <kbd>StackPanel</kbd> inside the <kbd>Grid</kbd> and set its <kbd>Grid.Column</kbd> attribute to <kbd>1</kbd>.</li>
<li>Add three radio buttons (<kbd>GroupName="AnimationSelector"</kbd>) inside the <kbd>StackPanel</kbd>, and add a <kbd>Storyboard</kbd> animation to fire when the <kbd>RadioButton.Checked</kbd> event is triggered.</li>
<li>Add a simple <kbd>DoubleAnimation</kbd> to move the circle horizontally by setting its <kbd>Storyboard.TargetProperty</kbd> to <kbd>(Canvas.Left)</kbd>.</li>
<li>Now expand the animation to add an easing effect to it. Insert a <kbd>&lt;DoubleAnimation.EasingFunction&gt;&lt;/DoubleAnimation.EasingFunction&gt;</kbd> attribute to hold the effect that we are going to add.</li>
<li>Let's add a <kbd>BackEase</kbd> effect to the three radio buttons. This type of effect represents an easing function that retracts the motion of an animation slightly before it begins to animate in the path indicated, and is denoted by the following function—<kbd>f(t) = t3 - t * a * sin(t * pi)</kbd>. Set the <kbd>Amplitude</kbd> property of the function to <kbd>0.3</kbd> and the <kbd>EasingMode</kbd> property to <kbd>EaseIn</kbd>, <kbd>EaseOut</kbd>, and <kbd>EaseInOut</kbd>, respectively. The complete code will look as follows:</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Grid.Column="1" 
            Margin="10"&gt; 
    &lt;RadioButton GroupName="AnimationSelector" 
                 Content="BackEase - EaseIn" 
                 Margin="4"&gt; 
        &lt;RadioButton.Triggers&gt; 
            &lt;EventTrigger  
                  RoutedEvent="RadioButton.Checked"&gt; 
                &lt;BeginStoryboard&gt; 
                    &lt;Storyboard AutoReverse="True"&gt; 
                        &lt;DoubleAnimation  
             Storyboard.TargetName="circle"                             
             Storyboard.TargetProperty="(Canvas.Left)" 
             To="350"&gt; 
      &lt;DoubleAnimation.EasingFunction&gt; 
             &lt;BackEase EasingMode="EaseIn" 
                       Amplitude="0.3"/&gt; 
      &lt;/DoubleAnimation.EasingFunction&gt; 
                        &lt;/DoubleAnimation&gt; 
                    &lt;/Storyboard&gt; 
                &lt;/BeginStoryboard&gt; 
            &lt;/EventTrigger&gt; 
        &lt;/RadioButton.Triggers&gt; 
    &lt;/RadioButton&gt; 
 
    &lt;RadioButton GroupName="AnimationSelector" 
                 Content="BackEase - EaseInOut" 
                 Margin="4"&gt; 
        &lt;RadioButton.Triggers&gt; 
            &lt;EventTrigger  
                  RoutedEvent="RadioButton.Checked"&gt; 
                &lt;BeginStoryboard&gt; 
                    &lt;Storyboard AutoReverse="True"&gt; 
                        &lt;DoubleAnimation  
             Storyboard.TargetName="circle" 
             Storyboard.TargetProperty="(Canvas.Left)" 
             To="350"&gt; 
      &lt;DoubleAnimation.EasingFunction&gt; 
             &lt;BackEase EasingMode="EaseInOut" 
                       Amplitude="0.3"/&gt; 
      &lt;/DoubleAnimation.EasingFunction&gt; 
                        &lt;/DoubleAnimation&gt; 
                    &lt;/Storyboard&gt; 
                &lt;/BeginStoryboard&gt; 
            &lt;/EventTrigger&gt; 
        &lt;/RadioButton.Triggers&gt; 
    &lt;/RadioButton&gt; 
 
    &lt;RadioButton GroupName="AnimationSelector" 
                 Content="BackEase - EaseOut" 
                 Margin="4"&gt; 
        &lt;RadioButton.Triggers&gt; 
            &lt;EventTrigger  
                  RoutedEvent="RadioButton.Checked"&gt; 
                &lt;BeginStoryboard&gt; 
                    &lt;Storyboard AutoReverse="True"&gt; 
                        &lt;DoubleAnimation  
             Storyboard.TargetName="circle" 
             Storyboard.TargetProperty="(Canvas.Left)" 
             To="350"&gt; 
      &lt;DoubleAnimation.EasingFunction&gt; 
             &lt;BackEase EasingMode="EaseOut" 
                       Amplitude="0.3"/&gt; 
      &lt;/DoubleAnimation.EasingFunction&gt; 
                        &lt;/DoubleAnimation&gt; 
                    &lt;/Storyboard&gt; 
                &lt;/BeginStoryboard&gt; 
            &lt;/EventTrigger&gt; 
        &lt;/RadioButton.Triggers&gt; 
    &lt;/RadioButton&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="10">
<li>Let's run the application. You will see the following UI on the screen:</li>
</ol>
<div><img src="img/bd5160b5-c666-4043-814f-550ce423786f.png" style=""/></div>
<ol start="11">
<li>Now change the selection of the radios and observe the effects added to the animation of the circular object.</li>
</ol>
<h2 id="uuid-af4200d8-aaee-4f8b-9a00-c6fb66f2e0d8">How it works...</h2>
<p>Animation easing applies a function to the animation value to alter a linear animation to form a non-linear one. A mode option, defined by the <kbd>EasingMode</kbd> property, allows you to set when to apply the easing function. This could be at the beginning (<kbd>EaseIn</kbd>), at the end (<kbd>EaseOut</kbd>), or both (<kbd>EaseInOut</kbd>).</p>
<p>In the preceding example, we defined a <kbd>BackEase</kbd> function to the animation with different easing modes, which will animate when the <kbd>Checked</kbd> event of the radio buttons trigger.</p>
<p>The following graph demonstrates different values of <kbd>EasingMode</kbd>, for the <kbd>BackEase</kbd> effect:</p>
<div><img src="img/a5bad042-6e0a-4aef-af32-0a1e75a7eac8.png" style=""/></div>
<h2 id="uuid-c3fa13c0-e6d2-45f6-8b1c-540ec3fb22b7">There's more...</h2>
<p>It's not limited to only the <kbd>BackEase</kbd> function, but it can have any of the 11 built-in easing functions defined in WPF. The complete list is as follows:</p>
<ul>
<li><kbd>BackEase</kbd></li>
<li><kbd>BounceEase</kbd></li>
<li><kbd>CircleEase</kbd></li>
<li><kbd>CubicEase</kbd></li>
<li><kbd>ElasticEase</kbd></li>
<li><kbd>ExponentialEase</kbd></li>
<li><kbd>PowerEase</kbd></li>
<li><kbd>QuadraticEase</kbd></li>
<li><kbd>QuarticEase</kbd></li>
<li><kbd>QuinticEase</kbd></li>
<li><kbd>SineEase</kbd></li>
</ul>
<p>All these listed easing functions derive from the abstract class <kbd>EasingFunctionBase</kbd>, which implements the <kbd>IEasingFunction</kbd> interface. It contains an <kbd>Ease</kbd> method and adds the <kbd>EasingMode</kbd> property, which indicates whether the function should be applied at the start of the animation (<kbd>EaseIn</kbd>), the end of the animation (<kbd>EaseOut</kbd>), or both ways (<kbd>EaseInOut</kbd>).</p>
<p>Let's modify our existing UI to have some more built-in easing functions added to the animation. To demonstrate this, we are going to add 10 more radio buttons inside the <kbd>StackPanel</kbd> and apply the easing functions to each one of them, as discussed in the following section.</p>
<h3 id="uuid-150c72c3-80b8-47fd-b1e4-3ad9e19c088b">BounceEase</h3>
<p>This type of function creates an animated bouncing effect to the target. The <kbd>Bounces</kbd> and <kbd>Bounciness</kbd> properties can be used to control the bounces. The <kbd>Bounces</kbd> property denotes the number of bounces and the <kbd>Bounciness</kbd> property defines how bouncy the bounce animation is. The lower the value of <kbd>Bounciness</kbd>, the higher the bouncing animation; the higher the value of <kbd>Bounciness</kbd>, the lower the bounces of the animation.</p>
<p>In the following example, let's apply a <kbd>BounceEase</kbd> function to the <kbd>DoubleAnimation</kbd> to create a bouncing effect. Let's add the following <kbd>RadioButton</kbd> inside the <kbd>StackPanel</kbd>:</p>
<pre style="padding-left: 60px">&lt;RadioButton GroupName="AnimationSelector" 
             Content="BounceEase - EaseInOut" 
             Margin="4"&gt; 
    &lt;RadioButton.Triggers&gt; 
        &lt;EventTrigger RoutedEvent="RadioButton.Checked"&gt; 
            &lt;BeginStoryboard&gt; 
                &lt;Storyboard AutoReverse="True"&gt; 
                    &lt;DoubleAnimation  
                     Storyboard.TargetName="circle" 
                     Storyboard.TargetProperty="(Canvas.Left)" 
                     To="350"&gt; 
                        &lt;DoubleAnimation.EasingFunction&gt; 
                            &lt;BounceEase EasingMode="EaseInOut" 
                                        Bounces="2" 
                                        Bounciness="2"/&gt; 
                        &lt;/DoubleAnimation.EasingFunction&gt; 
                    &lt;/DoubleAnimation&gt; 
                &lt;/Storyboard&gt; 
            &lt;/BeginStoryboard&gt; 
        &lt;/EventTrigger&gt; 
    &lt;/RadioButton.Triggers&gt; 
&lt;/RadioButton&gt; </pre>
<p>The following graph demonstrates different values of <kbd>EasingMode</kbd>, for the <kbd>BounceEase</kbd> effect:</p>
<div><img src="img/3fec5c15-2d6f-47d1-9b46-2d261965ab46.png" style=""/></div>
<h3 id="uuid-b01b147d-d370-49c5-ad0d-85b7b8bbbbdd">CircleEase</h3>
<p>This represents an easing function that creates an animation that accelerates/decelerates using a <kbd>circular</kbd> function, and is denoted by the following function <kbd>f(t) = 1 - sqrt(1 - t2)</kbd>.</p>
<p>Let's add the following <kbd>RadioButton</kbd> inside the <kbd>StackPanel</kbd> to create an animation with a circular easing effect:</p>
<pre style="padding-left: 60px">&lt;RadioButton GroupName="AnimationSelector" 
             Content="CircleEase - EaseInOut" 
             Margin="4"&gt; 
    &lt;RadioButton.Triggers&gt; 
        &lt;EventTrigger RoutedEvent="RadioButton.Checked"&gt; 
            &lt;BeginStoryboard&gt; 
                &lt;Storyboard AutoReverse="True"&gt; 
                    &lt;DoubleAnimation  
                     Storyboard.TargetName="circle" 
                     Storyboard.TargetProperty="(Canvas.Left)" 
                     To="350"&gt; 
                        &lt;DoubleAnimation.EasingFunction&gt; 
                            &lt;CircleEase EasingMode="EaseInOut"/&gt; 
                        &lt;/DoubleAnimation.EasingFunction&gt; 
                    &lt;/DoubleAnimation&gt; 
                &lt;/Storyboard&gt; 
            &lt;/BeginStoryboard&gt; 
        &lt;/EventTrigger&gt; 
    &lt;/RadioButton.Triggers&gt; 
&lt;/RadioButton&gt; </pre>
<p>The following graph demonstrates different values of <kbd>EasingMode</kbd>, for the <kbd>CircleEase</kbd> effect:</p>
<div><img src="img/10c4a73e-008e-492b-b48d-53f56249901a.png" style=""/></div>
<h3 id="uuid-20a56b66-0bf8-4cc0-9b48-b178cafc685d">CubicEase</h3>
<p>This creates an animation that accelerates/decelerates using the formula <kbd>f(t) = t3</kbd>, where <kbd>EasingMode</kbd> can be applied to control acceleration, deceleration, or both, by setting the value <kbd>EaseIn</kbd>, <kbd>EaseOut</kbd>, or <kbd>EasInOut</kbd>.</p>
<p>Let's add the following <kbd>RadioButton</kbd> inside the <kbd>StackPanel</kbd> to create an animation with an accelerating <kbd>CubicEase</kbd> function:</p>
<pre style="padding-left: 60px">&lt;RadioButton GroupName="AnimationSelector" 
             Content="CubicEase - EaseIn" 
             Margin="4"&gt; 
    &lt;RadioButton.Triggers&gt; 
        &lt;EventTrigger RoutedEvent="RadioButton.Checked"&gt; 
            &lt;BeginStoryboard&gt; 
                &lt;Storyboard AutoReverse="True"&gt; 
                    &lt;DoubleAnimation  
                     Storyboard.TargetName="circle" 
                     Storyboard.TargetProperty="(Canvas.Left)" 
                     To="350"&gt; 
                        &lt;DoubleAnimation.EasingFunction&gt; 
                            &lt;CubicEase EasingMode="EaseIn"/&gt; 
                        &lt;/DoubleAnimation.EasingFunction&gt; 
                    &lt;/DoubleAnimation&gt; 
                &lt;/Storyboard&gt; 
            &lt;/BeginStoryboard&gt; 
        &lt;/EventTrigger&gt; 
    &lt;/RadioButton.Triggers&gt; 
&lt;/RadioButton&gt; </pre>
<p>The following graph demonstrates different values of <kbd>EasingMode</kbd>, for the <kbd>CubicEase</kbd> effect:</p>
<div><img src="img/64bcf1a9-75cd-42d1-89d8-d0ef79f52800.png" style=""/></div>
<h3 id="uuid-3945c95d-b0e1-409b-96f5-5b5ab826bfaf">ElasticEase</h3>
<p>As the name says, it represents an easing function that creates an animation that resembles a spring oscillating back and forth until it comes to rest. The <kbd>Oscillations</kbd> property can be used to get/set the number of times the target slides back and forth over the animation destination. The <kbd>Springiness</kbd> property can be used to define the stiffness of the spring. The smaller the value of <kbd>Springiness</kbd>, means a stiffer spring in action.</p>
<p>To demonstrate, let's add the following <kbd>RadioButton</kbd> inside the <kbd>StackPanel</kbd> to create an animation with <kbd>ElasticEase</kbd>, having <kbd>Oscillations="3"</kbd> and <kbd>Springiness="1"</kbd>:</p>
<pre style="padding-left: 60px">&lt;RadioButton GroupName="AnimationSelector" 
             Content="ElasticEase - EaseInOut" 
             Margin="4"&gt; 
    &lt;RadioButton.Triggers&gt; 
        &lt;EventTrigger RoutedEvent="RadioButton.Checked"&gt; 
            &lt;BeginStoryboard&gt; 
                &lt;Storyboard AutoReverse="True"&gt; 
                    &lt;DoubleAnimation  
                     Storyboard.TargetName="circle" 
                     Storyboard.TargetProperty="(Canvas.Left)" 
                     To="350"&gt; 
                        &lt;DoubleAnimation.EasingFunction&gt; 
                            &lt;ElasticEase EasingMode="EaseInOut" 
                                         Oscillations="3" 
                                         Springiness="1"/&gt; 
                        &lt;/DoubleAnimation.EasingFunction&gt; 
                    &lt;/DoubleAnimation&gt; 
                &lt;/Storyboard&gt; 
            &lt;/BeginStoryboard&gt; 
        &lt;/EventTrigger&gt; 
    &lt;/RadioButton.Triggers&gt; 
&lt;/RadioButton&gt; </pre>
<p>The following graph demonstrates different values of <kbd>EasingMode</kbd>, for the <kbd>ElasticEase</kbd> effect:</p>
<div><img src="img/a0c8a3a2-0b6c-4b86-8e56-8aa247bebfac.png" style=""/></div>
<h3 id="uuid-1f59b3a8-ee5d-45ef-827f-045bad5f2dd5">ExponentialEase</h3>
<p>This type of easing function creates an animation that accelerates/decelerates using an exponential formula <kbd>f(t) = [[e(at) - 1] / [e(a) - 1]]</kbd>. The <kbd>Exponent</kbd> property is used to determine the interpolation of the animation; whereas the <kbd>EasingMode</kbd> property is used to accelerate and decelerate the animation of the target control.</p>
<p>To demonstrate this, add the following <kbd>RadioButton</kbd> control inside the <kbd>StackPanel</kbd>, which will create a decelerate exponential easing effect with the interpolation value <kbd>5</kbd>:</p>
<pre style="padding-left: 60px">&lt;RadioButton GroupName="AnimationSelector" 
             Content="ExponentialEase - EaseOut" 
             Margin="4"&gt; 
    &lt;RadioButton.Triggers&gt; 
        &lt;EventTrigger RoutedEvent="RadioButton.Checked"&gt; 
            &lt;BeginStoryboard&gt; 
                &lt;Storyboard AutoReverse="True"&gt; 
                    &lt;DoubleAnimation  
                     Storyboard.TargetName="circle" 
                     Storyboard.TargetProperty="(Canvas.Left)" 
                     To="350"&gt; 
                        &lt;DoubleAnimation.EasingFunction&gt; 
                            &lt;ExponentialEase EasingMode="EaseOut" 
                                             Exponent="5"/&gt; 
                        &lt;/DoubleAnimation.EasingFunction&gt; 
                    &lt;/DoubleAnimation&gt; 
                &lt;/Storyboard&gt; 
            &lt;/BeginStoryboard&gt; 
        &lt;/EventTrigger&gt; 
    &lt;/RadioButton.Triggers&gt; 
&lt;/RadioButton&gt; </pre>
<p>The following graph demonstrates different values of <kbd>EasingMode</kbd>, for the <kbd>ExponentialEase</kbd> effect:</p>
<div><img src="img/5141208a-c2db-4f71-a24a-7440aab2ec36.png" style=""/></div>
<h3 id="uuid-f1459072-61c0-496e-9ddc-bdedfd3d92e5">PowerEase</h3>
<p>It defines an easing function that creates an animation that accelerates/decelerates using the formula <kbd>f(t) = tp</kbd>, where <kbd>p</kbd> is equal to the value of the <kbd>Power</kbd> property. As with other easing functions, you can add an easing mode to specify whether the animation will accelerate or decelerate.</p>
<p>In this demonstration, add the following <kbd>RadioButton</kbd> that defines the <kbd>PowerEase</kbd> easing function to the <kbd>DoubleAnimation</kbd> specified:</p>
<pre style="padding-left: 60px">&lt;RadioButton GroupName="AnimationSelector" 
             Content="PowerEase - EaseInOut" 
             Margin="4"&gt; 
    &lt;RadioButton.Triggers&gt; 
        &lt;EventTrigger RoutedEvent="RadioButton.Checked"&gt; 
            &lt;BeginStoryboard&gt; 
                &lt;Storyboard AutoReverse="True"&gt; 
                    &lt;DoubleAnimation  
                     Storyboard.TargetName="circle" 
                     Storyboard.TargetProperty="(Canvas.Left)" 
                     To="350"&gt; 
                        &lt;DoubleAnimation.EasingFunction&gt; 
                            &lt;PowerEase EasingMode="EaseInOut" 
                                       Power="12"/&gt; 
                        &lt;/DoubleAnimation.EasingFunction&gt; 
                    &lt;/DoubleAnimation&gt; 
                &lt;/Storyboard&gt; 
            &lt;/BeginStoryboard&gt; 
        &lt;/EventTrigger&gt; 
    &lt;/RadioButton.Triggers&gt; 
&lt;/RadioButton&gt; </pre>
<p>You can use <kbd>PowerEase</kbd> to substitute <kbd>QuadraticEase</kbd> [<kbd>f(t) = t2</kbd>], <kbd>CubicEase</kbd> [<kbd>f(t) = t3</kbd>], <kbd>QuarticEase</kbd> [<kbd>f(t) = t4</kbd>], and <kbd>QuinticEase</kbd> [<kbd>f(t) = t5</kbd>] type of easing functions.</p>
<p>The following graph demonstrates different values of <kbd>EasingMode</kbd>, for the <kbd>PowerEase</kbd> effect:</p>
<div><img src="img/3fffc620-49dc-4af9-995f-d601a9051ed0.png" style=""/></div>
<h3 id="uuid-0642938c-ebb2-45d5-b40b-bd90adacab11">QuadraticEase</h3>
<p>It creates an animation that accelerates/decelerates using the formula <kbd>f(t) = t2</kbd>. You can use <kbd>PowerEase</kbd> to create the same behavior by specifying <kbd>Power="2"</kbd>. In this example, we will learn how to add the <kbd>QuadraticEase</kbd> function to an animation. Add the following mark-up inside the <kbd>StackPanel</kbd> that we have defined:</p>
<pre style="padding-left: 60px">&lt;RadioButton GroupName="AnimationSelector" 
             Content="QuadraticEase - EaseInOut" 
             Margin="4"&gt; 
    &lt;RadioButton.Triggers&gt; 
        &lt;EventTrigger RoutedEvent="RadioButton.Checked"&gt; 
            &lt;BeginStoryboard&gt; 
                &lt;Storyboard AutoReverse="True"&gt; 
                    &lt;DoubleAnimation  
                    Storyboard.TargetName="circle" 
                    Storyboard.TargetProperty="(Canvas.Left)" 
                    To="350"&gt; 
                        &lt;DoubleAnimation.EasingFunction&gt; 
                            &lt;QuadraticEase  
                                      EasingMode="EaseInOut"/&gt; 
                        &lt;/DoubleAnimation.EasingFunction&gt; 
                    &lt;/DoubleAnimation&gt; 
                &lt;/Storyboard&gt; 
            &lt;/BeginStoryboard&gt; 
        &lt;/EventTrigger&gt; 
    &lt;/RadioButton.Triggers&gt; 
&lt;/RadioButton&gt; </pre>
<p>The following graph demonstrates different values of <kbd>EasingMode</kbd>, for the <kbd>QuadraticEase</kbd> effect:</p>
<div><img src="img/ea56386b-65d1-4321-8184-7c5a77f1e7b3.png" style=""/></div>
<h3 id="uuid-3a769802-3bfa-4e20-ab80-a80d6fda9c3d">QuarticEase</h3>
<p>Like <kbd>QuadraticEase</kbd>, you can also define <kbd>QuarticEase</kbd> to create an animation that accelerates/decelerates using the formula <kbd>f(t) = t4</kbd>. You can use <kbd>PowerEase</kbd> to create the same behavior by specifying <kbd>Power="4"</kbd>. Let's add the following mark-up inside our <kbd>StackPanel</kbd> to define the animation with the said easing function:</p>
<pre style="padding-left: 60px">&lt;RadioButton GroupName="AnimationSelector" 
             Content="QuarticEase - EaseInOut" 
             Margin="4"&gt; 
    &lt;RadioButton.Triggers&gt; 
        &lt;EventTrigger RoutedEvent="RadioButton.Checked"&gt; 
            &lt;BeginStoryboard&gt; 
                &lt;Storyboard AutoReverse="True"&gt; 
                    &lt;DoubleAnimation  
                     Storyboard.TargetName="circle" 
                     Storyboard.TargetProperty="(Canvas.Left)" 
                     To="350"&gt; 
                        &lt;DoubleAnimation.EasingFunction&gt; 
                            &lt;QuarticEase EasingMode="EaseInOut"/&gt; 
                        &lt;/DoubleAnimation.EasingFunction&gt; 
                    &lt;/DoubleAnimation&gt; 
                &lt;/Storyboard&gt; 
            &lt;/BeginStoryboard&gt; 
        &lt;/EventTrigger&gt; 
    &lt;/RadioButton.Triggers&gt; 
&lt;/RadioButton&gt; </pre>
<p>The following graph demonstrates different values of <kbd>EasingMode</kbd>, for the <kbd>QuarticEase</kbd> effect:</p>
<div><img src="img/c39fa632-f23d-44ab-af62-35b387bfcea7.png" style=""/></div>
<h3 id="uuid-b037a4da-b5f1-4b0b-8435-780d60436555">QuinticEase</h3>
<p>If you want to add the <kbd>QuinticEase</kbd> effect to your easing function, add it to your animation. It accelerates/decelerates using the formula <kbd>f(t) = t5</kbd>. You can use <kbd>PowerEase</kbd> to create the same by specifying <kbd>Power="5"</kbd>. Add the following <kbd>RadioButton</kbd> to define an animation with the <kbd>QuinticEase</kbd> easing function in our <kbd>StackPanel</kbd>:</p>
<pre style="padding-left: 60px">&lt;RadioButton GroupName="AnimationSelector" 
             Content="QuinticEase - EaseInOut" 
             Margin="4"&gt; 
    &lt;RadioButton.Triggers&gt; 
        &lt;EventTrigger RoutedEvent="RadioButton.Checked"&gt; 
            &lt;BeginStoryboard&gt; 
                &lt;Storyboard AutoReverse="True"&gt; 
                    &lt;DoubleAnimation  
                     Storyboard.TargetName="circle" 
                     Storyboard.TargetProperty="(Canvas.Left)" 
                     To="350"&gt; 
                        &lt;DoubleAnimation.EasingFunction&gt; 
                            &lt;QuinticEase EasingMode="EaseInOut"/&gt; 
                        &lt;/DoubleAnimation.EasingFunction&gt; 
                    &lt;/DoubleAnimation&gt; 
                &lt;/Storyboard&gt; 
            &lt;/BeginStoryboard&gt; 
        &lt;/EventTrigger&gt; 
    &lt;/RadioButton.Triggers&gt; 
&lt;/RadioButton&gt; </pre>
<p>The following graph demonstrates different values of <kbd>EasingMode</kbd>, for the <kbd>QuinticEase</kbd> effect:</p>
<div><img src="img/3027a6c0-de5b-4766-9371-06db49cfde58.png" style=""/></div>
<h3 id="uuid-e5de8698-7409-4eb6-a412-b62a4af62303">SineEase</h3>
<p>This represents an easing function that creates an animation that accelerates and/or decelerates using a sine formula <kbd>f(t) = [1 - [sin(1 - t) * [pi / 2]]]</kbd>. Add the <kbd>EasingMode</kbd> property to accelerate and/or decelerate the effect. Let's add the following code inside the <kbd>StackPanel</kbd>:</p>
<pre style="padding-left: 60px">&lt;RadioButton GroupName="AnimationSelector" 
             Content="SineEase - EaseInOut" 
             Margin="4"&gt; 
    &lt;RadioButton.Triggers&gt; 
        &lt;EventTrigger RoutedEvent="RadioButton.Checked"&gt; 
            &lt;BeginStoryboard&gt; 
                &lt;Storyboard AutoReverse="True"&gt; 
                    &lt;DoubleAnimation  
                     Storyboard.TargetName="circle" 
                     Storyboard.TargetProperty="(Canvas.Left)" 
                     To="350"&gt; 
                        &lt;DoubleAnimation.EasingFunction&gt; 
                            &lt;SineEase EasingMode="EaseInOut"/&gt; 
                        &lt;/DoubleAnimation.EasingFunction&gt; 
                    &lt;/DoubleAnimation&gt; 
                &lt;/Storyboard&gt; 
            &lt;/BeginStoryboard&gt; 
        &lt;/EventTrigger&gt; 
    &lt;/RadioButton.Triggers&gt; 
&lt;/RadioButton&gt; </pre>
<p>The following graph demonstrates different values of <kbd>EasingMode</kbd>, for the <kbd>SineEase</kbd> effect:</p>
<div><img src="img/490dbba7-b709-4781-8889-df4cddf4139a.png" style=""/></div>
<p>Once you are ready, let's build the project and run it. You will now see the following UI, which contains additional radio buttons inside the right-hand panel:</p>
<div><img src="img/99b9771d-cb86-4ccb-9f91-f4957d54ec4e.png" style=""/></div>
<p>Change the selection of the radios to see the animations for each easing function associated with them.</p>


            

            
        
    </body></html>