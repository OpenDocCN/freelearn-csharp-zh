- en: Chapter 8. Sharing with Xamarin.Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss Xamarin.Forms, a cross-platform development
    framework. With this in mind, we will cover the following areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Pages, Views (Controls), and Layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigation in Xamarin.Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XAML and code-behind classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renderers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DependencyService` API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App startup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting the `NationalParks` app to use Xamarin.Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An insight into the Xamarin.Forms framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Xamarin.Forms framework can be used to develop mobile apps for Android,
    iOS, and Windows Phone. It uses virtually the same source code base for each platform
    while still providing a platform-specific look and feel. Xamarin.Forms is available
    for use from any of the paid licenses available at Xamarin or from the 30-day
    evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we mention that Xamarin.Forms apps can run on Windows Phone, the licensing,
    configuration, and development details for Windows Phone are beyond the scope
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the approaches described previously in this book, Xamarin.Forms provides
    you with a set of abstractions that cover the entire user interface, thus allowing
    the UI code and specification to be reused across multiple platforms. At runtime,
    Xamarin.Forms renders user interfaces using Controls that are native to each platform,
    which allows apps to retain a native look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is divided into two main sections: in the first section, we cover
    the core concepts that need to be understood prior to using Xamarin.Forms, and
    in the second section, we will convert our `NationalParks` app to use the Xamarin.Forms
    framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **Page** is a visual element that organizes the content a user sees on the
    screen at a single time. A Xamarin.Forms Page is essentially similar to an Android
    activity or an iOS View controller. Xamarin.Forms provides the following base
    Pages for use in your apps, where you can find a description accompanied with
    each type:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ContentPage` | This allows you to organize a set of Controls, or Views,
    into a Layout for display and interaction with the user |'
  prefs: []
  type: TYPE_TB
- en: '| `MasterDetailPage` | This manages two pages—a master and a detail page—and
    the navigation between them |'
  prefs: []
  type: TYPE_TB
- en: '| `NavigationPage` | This manages navigation over a set of other pages |'
  prefs: []
  type: TYPE_TB
- en: '| `TabbedPage` | This manages a set of child pages and allows you to navigate
    via tabs |'
  prefs: []
  type: TYPE_TB
- en: '| `CarouselPage` | This manages a set of child pages and allows you to navigate
    via swipe |'
  prefs: []
  type: TYPE_TB
- en: Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **View** is a visual control (or widget) that presents information and allows
    the user to interact with your app (things such as buttons, labels, and edit boxes).
    These controls generally inherit properties from the `View` class. The following
    table represents the list of Views provided by Xamarin.Forms at the time of writing
    this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `ActivityIndicator` | `BoxView` | `Button` | `DatePicker` |'
  prefs: []
  type: TYPE_TB
- en: '| `Editor` | `Entry` | `Image` | `Label` |'
  prefs: []
  type: TYPE_TB
- en: '| `ListView` | `OpenGLView` | `Picker` | `ProgressBar` |'
  prefs: []
  type: TYPE_TB
- en: '| `SearchBar` | `Slider` | `Stepper` | `Switch` |'
  prefs: []
  type: TYPE_TB
- en: '| `TableView` | `TimePicker` | `WebView` |   |'
  prefs: []
  type: TYPE_TB
- en: Layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Controls are hosted within a special type of View called a **Layout**. There
    are two different types of Layouts: managed and unmanaged. Managed Layouts are
    responsible for arranging their hosted Controls, and unmanaged Layouts require
    the developer to specify how controls should be arranged. Xamarin.Forms provides
    the following Layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Layout | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ContentView` | This is a Layout that can contain child views. Generally,
    `ContentView` is not used directly, but is used as a base for other layouts. |'
  prefs: []
  type: TYPE_TB
- en: '| `Frame` | This is a Layout that can contain a single child view and provide
    framing options such as padding. |'
  prefs: []
  type: TYPE_TB
- en: '| `ScrollView` | This Layout is capable of scrolling its child views. |'
  prefs: []
  type: TYPE_TB
- en: '| `AbsoluteLayout` | This Layout allows it''s child views to be positioned
    by absolute positions as requested by the app. |'
  prefs: []
  type: TYPE_TB
- en: '| `Grid` | This Layout allows content to be displayed in rows and columns.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `RelativeLayout` | This Layout positions views relative to other views it
    owns by use of constraints. |'
  prefs: []
  type: TYPE_TB
- en: '| `StackLayout` | This Layout positions views horizontally or vertically in
    a single line. |'
  prefs: []
  type: TYPE_TB
- en: Cells
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Cell** is a special type of Control used to arrange information in a list;
    specifically, `ListView` or `TableView`. Cells derive from the `Element` class
    rather than the `VisualElement` class and act as a template to create `VisualElements`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Xamarin.Forms provides the following types of Cells:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Cell type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `EntryCell` | This is a Cell with a label and single text entry field. |'
  prefs: []
  type: TYPE_TB
- en: '| `SwitchCell` | This is a Cell with a label and switch view (on/off). |'
  prefs: []
  type: TYPE_TB
- en: '| `TextCell` | This is a Cell with primary and secondary text. Generally, the
    primary text is used as a title and the secondary text as a subtitle. |'
  prefs: []
  type: TYPE_TB
- en: '| `ImageCell` | This is a `TextCell` that also includes an image. |'
  prefs: []
  type: TYPE_TB
- en: Navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Navigation** in a Xamarin.Forms app is accomplished with the use of the navigation
    property of `VisualElement`. This is generally accessed via a Page. The navigation
    property is typed as the `INavigation` interface, which provides the following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `PushAsync()` | This method pushes a Page on the navigation stack |'
  prefs: []
  type: TYPE_TB
- en: '| `PushModalAsync()` | This method pushes a Page on the navigation stack as
    a modal dialog |'
  prefs: []
  type: TYPE_TB
- en: '| `PopAsync()` | This method pops the current Page off the navigation stack
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PopModalAsync()` | This method pops the current modal Page off the navigation
    stack |'
  prefs: []
  type: TYPE_TB
- en: '| `PopToRootAsync()` | This method pops all the Pages off the navigation stack,
    except the root Page |'
  prefs: []
  type: TYPE_TB
- en: 'The beauty of navigation in Xamarin.Forms lies in its simplicity. To navigate
    to a new Page and pass data into the new Page, all you need to do is create an
    instance of the new Page passing the data in the constructor and then push this
    Page on the navigation stack, as demonstrated by the following sample code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Defining Xamarin.Forms user interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like many UI frameworks, Xamarin.Forms allows two different approaches to create
    user interfaces: declarative and programmatic:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Programmatic approach**: When using this approach, the developers embed API
    calls to construct a UI, and control the size and placement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Declarative approach**: When using this approach, the developers create XAML
    files that define the content and layout for a user interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensible Application Markup Language (XAML)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Extensible Application Markup Language** (**XAML**) is an XML-based language
    developed by Microsoft. XAML allows developers to use XML to specify a hierarchy
    of objects to instantiate. It can be used in a number of ways, but most successfully
    as a means to specify user''s interfaces in **Windows Presentation Foundation**
    (**WPF**), Silverlight, Windows Runtime, and now Xamarin.Forms.'
  prefs: []
  type: TYPE_NORMAL
- en: XAML files are parsed at build time to verify objects that have been specified
    and at runtime to instantiate the hierarchy of objects.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to specifying a hierarchy of objects, XAML also allows developers
    to specify property values and assign event handlers. However, it does not allow
    you to embed code or logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following XAML file defines the content for a `ContentPage` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the previous XAML specification:'
  prefs: []
  type: TYPE_NORMAL
- en: The class name is `ParkEditPage` and is specified in the `ContentPage` element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Grid` Layout is used to organize the content in the Page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two components are assigned property names, `nameEntry` and `doneButton`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `doneButton` component is assigned a `Clicked` event handler named `DoneClicked`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code-behind classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you create a Page in a Xamarin.Forms app, two files are actually created:
    an XAML file and a class file. Xamarin Studio nests the class files under the
    XAML files in the **Solution** pad, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code-behind classes](img/0838OT_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `.xaml.cs` files are sometimes referred to as code-behind classes. They
    are created to contain all the app logic in event handlers that go hand in hand
    with the Page definition. The following example shows the code-behind class for
    `ParkEditPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should take note of the following aspects of the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ParkEditPage` is a partial class definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DoneClicked()` event handler is defined within this class file. This is
    the event handler that was assigned to the `Done` button in XAML.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no property definitions defined in the earlier file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, where are the property definitions? Xamarin Studio generates a second code
    file each time the app is built. For our example, the file will be named `ParkEditPage.xaml.g.cs`
    and will contain the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should take note of the following points here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two properties defined on the `ParkEditPage` file: `nameEntry` and
    `doneButton`. These are generated directly from the names found in the XAML file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method named `InitializeComponent()` is generated. This method must be called
    from any constructors defined in `ParkEditPage.xaml.cs`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `InitializeComponent()` method calls `LoadFromXaml()` to instantiate all
    the objects defined by `ParkEditPage.xaml`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `InitializeComponent()` method calls `FindByName()` to bind each property
    to its corresponding instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concepts behind data binding are covered in detail in [Chapter 7](ch07.html
    "Chapter 7. Sharing with MvvmCross"), *Sharing with MvvmCross*, under the section
    titled *Data binding*. Xamarin.Forms provides a data binding capability that follows
    the same architecture as MvvmCross, **Windows** **Presentation Foundation** (**WPF**),
    Silverlight, and Windows Runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within a Xamarin.Forms app, binding specifications are generally specified
    in XAML. The following XAML specification demonstrates binding the `Text` property
    of an `Entry` control to the `Name` property of a `NationalPark` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Generally, the binding context is set with code. The following example demonstrates
    how to programmatically set the binding context at a Page level to a `NationalPark`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, the binding context was set for an entire Page. Sometimes,
    Controls provide a binding context that needs to be set to accomplish data binding.
    The following example demonstrates setting the binding context for a `ListView`
    control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the binding context for the `ListView` control is a property named
    `ItemsSource`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Renderers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Xamarin.Forms uses platform-native controls to render user interfaces that allow
    apps to maintain a look and feel that the users would expect for each platform.
    This is accomplished with the use of Renderers. Pages, Layouts, and Controls represent
    the set of abstractions used to describe a user interface. Each of these elements
    is rendered using a `Renderer` class, which in turn creates a native control based
    on the platform the app is running on.
  prefs: []
  type: TYPE_NORMAL
- en: Developers can create their own Renderers in order to customize the way a particular
    Control is rendered on a platform.
  prefs: []
  type: TYPE_NORMAL
- en: Native features and the DependencyService API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, we have primarily focused on working with abstractions that can be
    reused across all platforms. What if you need access to platform-specific capabilities?
    That's where the `DependencyService` API comes in. The `DependencyService` API
    is an API that allows each platform to register a platform-specific service that
    can be called by shared code through a common interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `DependencyService` API involves the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, you need to create an interface that exposes the platform-specific
    methods that must be implemented for each platform the app will run on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this step, create an implementation of the interface for each platform
    and register the implementation using an `assembly` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To conclude, call `DependencyService.Get<MyInterface>` from the shared code
    to look up the appropriate implementation and invoke services on the returned
    instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will demonstrate the use of the `DependencyService` API later in this chapter
    in the section titled *Adding calls to DependencyService*.
  prefs: []
  type: TYPE_NORMAL
- en: App startup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Xamarin.Forms apps start up as native apps, meaning the traditional startup
    sequence is followed. During the startup sequence, an app performs the following
    two tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a call to initialize the Xamarin.Forms runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the first Page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Shared App classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, Xamarin.Forms apps have a shared `App` class created, which contains
    a single static method that returns the first Page that should be presented when
    an app starts up. The following code demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This simple approach allows the platform-specific startup code in each app to
    call the `GetMainPage()` method in order to determine which Page to start with.
    Therefore, it is only specified at one place.
  prefs: []
  type: TYPE_NORMAL
- en: iOS apps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a Xamarin.Forms iOS app, initialization is performed in the `FinishedLaunching()`
    method of the `AppDelegate` class, as shown in the following sample demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Android apps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a Xamarin.Forms Android app, initialization is done in the `Activity` instance
    marked with the `MainLauncher=true` attribute. This is shown in the following
    sample code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Project organization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Xamarin.Forms projects are generally created using one of the following two
    project templates, which can be found by navigating to **C#** | **Mobile Apps**
    of the **New Solution** dialog box:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blank App (Xamarin.Forms Potable)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blank App (Xamarin.Forms Shared)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between these two templates is the type of project created to
    house the shared code. Using the first template, shared code is housed in a Portable
    Class Library, and using the second template, shared code is housed in a shared
    project. Shared projects allow all referencing projects to reuse the code it contains,
    but the code is compiled specifically for each referencing project.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you plan to add a Windows Phone project to the solution at some point, you
    will be well versed to go with the PCL solution. It will require you to work within
    the restrictions of a PCL, but will ensure your code is compatible with more platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating a Xamarin.Forms solution, you will see that three actual projects
    were created. The first project contains the shared code, the second project contains
    the iOS code, and the third project contains the Android code. If we are successful
    with Xamarin.Forms, the bulk of the code will end up in the shared project. The
    following screenshot shows an example of a project created with the PCL template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project organization](img/0838OT_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the NationalParks Xamarin.Forms app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a solid understanding of Xamarin.Forms, let's convert our `NationalParks`
    app to use the new framework. For this exercise, we will follow the same app flow
    that we have used in the iOS app so far, meaning that we will have a list page,
    a detail page to view, and an edit page to add and update.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by creating an entirely new project by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To start with, access the **File** menu and navigate to **New** | **New Solution**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **New Solution** dialog box, navigate to **C#** | **Mobile Apps**, select
    the **Blank App (Xamarin.Forms Portable)** template, enter `NationalParks` in
    the **Name** field, choose the appropriate **Location** value, and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the project structure. You will see the following pointers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `AppDelegate.cs` in the `NationalParks.iOS` project. Note the calls to
    `Forms.Init()` and `App.GetMainPage()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Open `MainActivity.cs` in the `NationalParks.Android` project. Note the calls
    to `Forms.Init()` and `App.GetMainPage()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Open `App.cs` in the `NationalParks` project. Note the static method, `GetMainPage()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To finish, run the `NationalParks.Android` and `NationalParks.iOS` projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding NationalParks.PortableData
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our next step is to bring in the storage solution from [Chapter 7](ch07.html
    "Chapter 7. Sharing with MvvmCross"), *Sharing with MvvmCross*. Perform the following
    steps to add the storage solution to our new Xamarin.Forms solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, you need to copy the `NationalParks.PortableData` and `NationalParks.IO`
    projects from the solution folder of [Chapter 7](ch07.html "Chapter 7. Sharing
    with MvvmCross"), *Sharing with MvvmCross*, to the new solution folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add each project to the new solution folder by selecting the solution, right-clicking
    on it, navigating to **Add** | **Add Existing Project**, and selecting the project
    file, for example, `NationalParks.IO.csproj`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `NationalParks.PortableData` project to the new `NationalParks`, `NationalParks.Android`,
    and `NationalParks.iOS` projects as a reference by selecting the `References`
    folder in each of the projects, right-clicking on them, choosing **Edit References**,
    and selecting `NationalParks.PortableData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now need to add a link to the `FileHandler.cs` file to both the `NationalParks.Android`
    and `NationalParks.iOS` projects. For each project, create a new folder named
    `NationalParks.IO` and add a link to `FileHandler.cs` by selecting the new folder,
    right-clicking on it, navigating to **Add** | **Add Files**, selecting `FileHandler`,
    choosing **Open**, selecting **Add a link to the file**, and clicking on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To verify all of the previous steps, you should compile the new solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing ParksListPage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now begin work on the user interface starting with a list view to display
    the parks by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `NationalParks` project, right-click on it, and navigate to **Add**
    | **New File**. From the **New File** dialog box, navigate to **Forms** | **Forms
    ContentPage Xaml**, enter `ParksListPage` for the **Name** field, and choose **New**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should now open `ParkListPage.xaml`. You will see an empty `ContentPage`
    element. Add `StackLayout`, which is vertically oriented, with a child `ListView`
    and `Button` instances, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Take note of the `ParkSelected` event handler for `parkListView` and the `NewClicked`
    event handler for the `New` button.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s add the row definitions for `ListView`. The `ListView` element
    has a `DataTemplate` property that defines a layout for each row. The following
    Layout should define a label for the name and description of the park. This should
    be placed within the `ListView` element of the XAML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the binding specifications for the two Label views.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `App.cs` in the `NationalParks` project and change the main page to `ParksListPage`.
    We also need to create `NavigationPage` as the owner of `ParksListPage` to support
    push and pop navigation. The `GetMainPage()` method should contain the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `AppDelegate.cs` in the `NationalParks.iOS` project. You should then add
    the following initialization of code to the `FinishedLaunching()` method just
    before the `Forms.Init()` call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `MainActivity.cs` in the `NationalParks.Android` project. Once you''re
    in, add the following initialization code to the `OnCreate()` method just before
    the call to `Forms.Init()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `ParksListPage.xaml.cs`, add a method to load the parks data, and set
    the binding context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a call to `LoadData()` from the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You will not be able to use `await` on the `LoadData()` method because it's
    being called from a constructor. In this case, there is actually no need to await
    the call.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The last step is to create two stub event handlers for `NewClicked` and `ParkSelected`,
    which we will fill in later as we complete the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now ready to test our work. Compile and run both the `NationalParks.iOS`
    and `NationalParks.Android` apps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing ParkDetailPage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we need a page to display the details of a Park. To create `ParkDetailPage`,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new `ContentPage` instance named `ParkDetailPage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `ParkDetailPage`, we will display a series of `Label` views in `Grid` and
    a set of `Buttons` below `Grid` to initiate actions. All this content will be
    hosted within `StackLayout`, which is vertically oriented. Start by adding `StackLayout`
    like we did in the previous section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `Grid` layout with a series of the `Label` view to display the properties
    of `NationalPark`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the `Grid.Row` and `Grid.Column` specifications, which control how the
    `Label` and `Entry` views are positioned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, add three `Button` definitions for the actions that can be taken from
    the Page, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a constructor that accepts a `NationalPark` instance to be displayed. The
    following code sample demonstrates what is needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the last line in the constructor sets `BindingContext`. This tells
    the Page how to resolve the binding specifications declared in XAML.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add stub event handlers for `EditClicked`, `DirectionsClicked`, and `PhotosClicked`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we need to return to the `ParksListPage` class and add the navigation
    logic. Open `ParksListPage.xaml.cs` and update the `ParkSelected()` event handler
    to make a call to `PushAsync()` for `ParkDetailPage`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run both the `NationalParks.iOS` and `NationalParks.Android` apps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using DependencyService to show directions and photos
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we discussed earlier, the `DependencyService` API allows apps to take advantage
    of platform-specific features. We will demonstrate the use of `DependencyService`
    to implement the ability to show directions and photos for a park.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the interface
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first step is to create an interface in the shared project that describes
    the methods that need to be supported. To create the `IParkInfoServices` interface,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, select the `NationalParks` project, right-click on it, and navigate
    to **Add** | **New File**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **General** | **Empty Interface**, enter `IParkInfoServices` in
    the **Name** field, and choose **New**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You now need to create two methods on the interface, one to show directions
    and one to show photos; each should accept `NationalPark` as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating the iOS implementation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, let''s create an iOS implementation by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `NationalParks.iOS` project, right-click on it, and navigate to **Add**
    | **New File**. In this dialog box, navigate to **General** | **Empty Class**
    in the **New File** dialog box, enter `iOSParkInfoServices` in the **Name** field,
    and choose **New**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `using` clauses for the namespaces, Xamarin.Forms, `NationalParks`, `NationalParks.PortableData`,
    and `NationalParks.iOS`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `iOSParkInfoServices` class specification so that it implements `IParkInfoServices`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `IParkInfoService`, right-click on it, navigate to **Refactor** | **Implement
    interface**, and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should then provide implementations for the two methods calls, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the following `Dependency` attribute to the `class` file outside
    the `namespace` definition, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Dependency` attribute registers the class with `DependencyService` so that
    when `Get()` is called, a platform-specific implementation can be located.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating the Android implementation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, let''s create an Android implementation by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `NationalParks.Android` project, right-click on it, and navigate
    to **Add** | **New File**. You should then navigate to **General** | **Empty Class**
    in the **New File** dialog box, enter `AndroidParkInfoServices` in the **Name**
    field, and choose **New**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `using` clauses for the namespaces, Xamarin.Forms, `NationalParks`, `NationalParks.PortableData`,
    and `NationalParks.Droid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `AndroidParkInfoServices` class specification so that it implements
    `IParkInfoServices`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, select `IParkInfoService`, right-click on it, navigate to **Refactor**
    | **Implement interface**, and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provide implementations for the two method calls, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the use of `Forms.Context`. In the case of Android, this contains the currently
    executing `Activity`; in our case, `MainActivity`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following `Dependency` attribute to the `class` file outside the `namespace`
    definition, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Adding calls to DependencyService
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, we need to add code to the shared project in order to actually invoke
    `ShowDirections()` and `ShowPhotos()`. All you need to do is open `ParkDetailPage.xaml.cs`
    and fill in the stub implementations for `DirectionsClicked()` and `PhotosClicked()`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Running the app
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We are finally ready to run the app. While there were several steps, the `DependencyService`
    API provided a very clean approach to separate shared and platform-specific code.
    Run both the `NationalParks.iOS` and `NationalParks.Android` apps.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing ParkEditPage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we need a Page to update the park information. To implement `ParkEditPage`,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, add a new `ContentPage` named `ParkDetailsPage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will use a similar Layout for `ParkEditPage` as we did for `ParkDetailPage`
    with the exception that we will use `Entry` views to allow editing of the properties
    of `NationalPark`. Add a `StackLayout` and `Grid` instance to `ParkEditPage`,
    and add a series of `Label` and `Entry` views for each property of `NationalPark`,
    as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then add a `Done` button to complete the editing process, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create two constructors, one that accepts a `NationalPark` instance and will
    be used to edit existing parks, and one that does not accept a `NationalPark`
    instance and will be used to create a new park, as shown in the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `DoneClicked()` event handler with a call to save the updated park,
    and a navigation call to `PopAsync()` to return to the Page that displayed `ParkEditPage`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to add navigation logic to both `ParkListPage` and `ParkDetailPage`.
    Open `ParkDetailPage.xaml.cs` and fill in the `EditClicked()` event handler with
    a call to `PushAsync()` in order to display `ParkEditPage`. Pass the park that
    is being viewed to the `ParkEditPage` constructor, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `ParkListPage.xaml.cs` and fill in the `NewClicked()` event handler with
    a call to `PushAsync()` in order to display `ParkEditPage`. Call the empty `ParkEditPage`
    constructor so that a new park will be created, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are now ready with our app; compile and run both the `NationalParks.iOS`
    and `NationalParks.Android` apps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Considering the pros and cons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen from the exercise, Xamarin.Forms provides a solid approach
    to dramatically increase the amount of code reused across your mobile apps; it
    has many great features:'
  prefs: []
  type: TYPE_NORMAL
- en: XAML is a great way to define user interfaces and allows you to create properties
    and assign event handlers in a convenient, concise way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data binding capabilities are great and eliminate a lot of tedious mind-numbing
    code from being written
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DependencyService` API provides a great way to access platform-specific
    capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Renderer` architecture provides for ultimate customizability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, at the time of writing this book, Xamarin.Forms is still somewhat
    immature, and there are some weaknesses:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no visual designer for the XAML code, so you have to construct your
    UI and run the app to see it visually rendered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to the newness of the framework, there is a limited number of examples available
    for reference, and many of the examples use code to construct the UI rather than
    XAML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation capabilities seem pretty weak
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These criticisms should not be taken too strongly; cross-platform UI frameworks
    are tough to build, and I feel confident that Xamarin is on the right track and
    will evolve the framework rapidly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the capabilities of Xamarin.Forms and converted
    our existing `NationalParks` app to use the framework. In the next chapter, we
    will look at the process of preparing an iOS app for distribution.
  prefs: []
  type: TYPE_NORMAL
