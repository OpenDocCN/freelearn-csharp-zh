- en: Chapter 9. Working with Textures, Models, and 2D
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 使用纹理、模型和2D
- en: 'Most game engines today orient their feature set towards the creation of 3D
    games rather than 2D in a general sense. This often, ironically, makes 3D tasks
    and workflows simpler than 2D ones, at least to pick up and get started with initially.
    In this chapter, we''ll explore a variety of 2D issues with some provisos. Since
    the release of Unity 4.3, a wide range of 2D features have been added to the editor:
    initially, a native sprite system and then, a new GUI system. While these are
    both useful in their respective ways, the main focus of this chapter will not
    be on these features specifically. The first reason is that a lot of tutorials
    already explain them in considerable detail, but the second and most important
    reason is that even with the added 2D features, there are still more fundamental
    questions that arise about working in 2D, in a looser sense. These include questions
    such as how to manipulate geometry such as the vertices and edges of 2D planes,
    how to adjust and animate texture coordinates, how to edit textures and also how
    to texture paint onto textures in real time using a brush-like system to create
    decals and blood splats, and so on. These questions are more 2D than 3D insofar
    as they pertain to geometry and textures in the 2D plane, but their relevance
    is to both 2D and 3D games generally. Their importance is highly significant today,
    though their coverage is somewhat under-represented in the tutorials available,
    so I have covered them here. Consequently, I''ll restrict this chapter mostly
    to the unconventional side of 2D.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的大多数游戏引擎都将它们的功能集定位为3D游戏而不是广义上的2D。这往往具有讽刺意味，使得3D任务和工作流程比2D任务和工作流程更简单，至少在最初开始时是这样。在本章中，我们将探讨一些2D问题，但有一些限制。自从Unity
    4.3发布以来，编辑器中已经添加了许多2D功能：最初是一个本机精灵系统，然后是一个新的GUI系统。虽然这两个系统在它们各自的方式中都很有用，但本章的主要焦点不会特别关注这些功能。第一个原因是许多教程已经相当详细地解释了它们，但第二个也是最重要的原因是，即使在添加了2D功能之后，关于在更宽松的2D中工作的基本问题仍然存在。这些问题包括如何操纵2D平面的几何形状，如顶点和边，如何调整和动画纹理坐标，如何编辑纹理，以及如何使用类似画笔的系统实时在纹理上绘制纹理，以创建贴图和血迹等。这些问题在涉及2D平面的几何和纹理方面比3D更相关，但它们对2D和3D游戏都具有相关性。它们的重要性非常显著，尽管在可用的教程中它们的覆盖范围有些不足，所以我在这里进行了覆盖。因此，我将主要限制本章的内容在2D的非传统方面。
- en: Skybox
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 天空盒
- en: 'The Skybox might seem a strange place to begin an analysis of 2D, but it demonstrates
    an important feature set for cameras, specifically layering. The Skybox is essentially
    a cube-based background that''s attached to a camera to show clouds, skies, and
    other distant details that should always act as the backdrop to a scene, but it
    never represents anything that the player can move close to. It is always distant,
    as shown here:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 天空盒可能看起来不是开始分析2D的好地方，但它展示了相机的重要功能集，特别是分层。天空盒本质上是一个基于立方体的背景，它附着在相机上以显示云彩、天空和其他应始终作为场景背景的遥远细节，但它永远不会代表玩家可以靠近的任何东西。它始终是遥远的，如图所示：
- en: '![Skybox](img/0655OT_09_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![天空盒](img/0655OT_09_01.jpg)'
- en: Skybox assets display a sky background for cameras
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 天空盒资源用于为相机显示天空背景
- en: The main problem with the default Skyboxes native to Unity is that they remain
    static and motionless by default. Most developers, however, want their skies and
    clouds to gently rotate, even when the camera is standing motionless, to portray
    the procession of a day or of time passing. Now, let's create an improved Skybox
    prefab using the Unity Skybox assets, two layered cameras, and a C# script file.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Unity默认天空盒的主要问题是它们默认是静态和不动的。然而，大多数开发者希望他们的天空和云彩能够轻轻旋转，即使相机静止不动，以描绘一天或时间流逝的过程。现在，让我们使用Unity天空盒资源、两个分层相机和一个C#脚本文件来创建一个改进的天空盒预制体。
- en: Tip
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The final project for a rotating Skybox can be found in the book's companion
    files.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转天空盒的最终项目可以在本书的配套文件中找到。
- en: For the sample project created here, let's import the **Character Controllers**
    package for a first-person controller asset, the **Terrain Assets** package for
    terrain textures that we can paint onto a sample terrain, and the **Skyboxes**
    package for the Skybox textures, as shown in the following screenshot.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在此处创建的示例项目，让我们导入**角色控制器**包以获取第一人称控制器资源，导入**地形资源**包以获取可以绘制到示例地形上的地形纹理，以及导入**天空盒**包以获取天空盒纹理，如图下所示。
- en: All these will be useful in building a sample project with a rotating Skybox.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都将有助于构建一个带有旋转Skybox的示例项目。
- en: '![Skybox](img/0655OT_09_02.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Skybox](img/0655OT_09_02.jpg)'
- en: Importing Character Controllers, Skyboxes, and Terrain Assets
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 导入角色控制器、Skybox和地形资产
- en: 'Next, let''s begin by creating the rotating Skybox prefab to make a reusable
    object. This object consists of three main parts or subobjects: a first-person
    controller that allows player movement and renders most scene objects, a second
    camera (the Skybox camera) that is rendered below the first-person camera and
    shows only the Skybox, and a cube object with inverted normals that surrounds
    the Skybox camera and shows each Skybox texture on each face.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们开始创建旋转的Skybox预制件，以创建一个可重复使用的对象。该对象由三个主要部分或子对象组成：一个允许玩家移动并渲染大多数场景对象的第一人称控制器，一个位于第一人称相机下方并仅显示Skybox的第二相机，以及一个具有反转法线的立方体对象，它包围Skybox相机并在每个面上显示每个Skybox纹理。
- en: To start, create a new empty object at the scene origin (named `SkyBoxCamera`)
    and add a first-person controller object as a child. Then, create six **Quad**
    objects from the main menu (by navigating to **GameObject** | **3D Object** |
    **Quad**), aligning each object to the corners of the other, with the vertex snapping
    to form an inverted cube, that is, a cube whose faces are turned inwards, as shown
    in the following screenshot. This represents the mesh for the manual Skybox.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在场景原点创建一个新的空对象（命名为`SkyBoxCamera`），并将一个第一人称控制器对象作为子对象添加。然后，从主菜单创建六个**四边形**对象（通过导航到**GameObject**
    | **3D Object** | **Quad**），将每个对象对齐到另一个对象的角落，使顶点吸附以形成一个倒置的立方体，即面朝内的立方体，如下面的截图所示。这代表了手动Skybox的网格。
- en: '![Skybox](img/0655OT_09_03.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Skybox](img/0655OT_09_03.jpg)'
- en: Create a manual Skybox from six Quad objects
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从六个四边形对象创建手动Skybox
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Scale the Quads if required and make sure that they contain and enclose the
    first-person controller, which should be at the center of the Skybox.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如有必要，缩放四边形，并确保它们包含并包围第一人称控制器，该控制器应位于Skybox的中心。
- en: Assign the Skybox faces to a new layer, `SkyBoxLayer`, select the first-person
    controller camera, and then change the **Culling Mask** field to exclude the `SkyBoxLayer`
    layer. The first-person camera should render only foreground objects and not background
    ones. To achieve this, change the **Clear Flags** field to **Depth only** in the
    Object Inspector, as shown in the following screenshot. This renders the camera
    background to transparent, which allows lower-order cameras to show through, if
    any.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将Skybox面分配到新的层`SkyBoxLayer`，选择第一人称控制器相机，然后更改**剔除遮罩**字段以排除`SkyBoxLayer`层。第一人称相机应仅渲染前景对象，而不是背景对象。为了实现这一点，在对象检查器中将**清除标志**字段更改为**仅深度**，如下面的截图所示。这使相机背景变为透明，允许低级相机显示出来，如果有的话。
- en: '![Skybox](img/0655OT_09_04.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![Skybox](img/0655OT_09_04.jpg)'
- en: Making the camera background transparent
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使相机背景透明
- en: Now, create a new and additional `Camera` object as a direct child object of
    the first-person camera and match its position, rotation, and scale. This allows
    the camera to inherit all the transformations from the first-person camera. The
    purpose of the secondary camera is to render only the Skybox object as a layer
    beneath the first-person camera while matching the first-person position and rotation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个新的`Camera`对象，并将其作为第一人称相机的直接子对象，并匹配其位置、旋转和缩放。这允许相机继承第一人称相机所有的变换。次要相机的目的是在匹配第一人称位置和旋转的同时，仅作为层在第一人称相机下方渲染Skybox对象。
- en: To this end, change the **Depth** value of the new camera to any value less
    than the depth of the first-person camera; such as `-1`. Remove any audio listener
    components where required.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，将新相机的**深度**值更改为任何小于第一人称相机深度的值；例如`-1`。如有必要，移除任何音频监听器组件。
- en: '![Skybox](img/0655OT_09_05.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![Skybox](img/0655OT_09_05.jpg)'
- en: Creating a second camera for Skybox rendering
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为Skybox渲染创建第二个相机
- en: 'Assign a unique Skybox texture to each cube face and take care to align them
    seamlessly by rotating or adjusting the Quad alignment as needed. Then, change
    the material **Shader** type for the Skybox textures to **Unlit/Texture**, making
    the Skybox immune to scene lighting. The Skybox mesh should start taking shape,
    as shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个立方体面分配一个独特的Skybox纹理，并注意通过旋转或调整四边形的对齐方式来无缝地对齐它们。然后，将Skybox纹理的材质**着色器**类型更改为**未光照/纹理**，使Skybox不受场景光照的影响。Skybox网格应该开始成形，如下所示：
- en: '![Skybox](img/0655OT_09_06.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Skybox](img/0655OT_09_06.jpg)'
- en: Adding Skybox textures to the Quads
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将Skybox纹理添加到四边形
- en: 'Finally, apply the following code sample 9-1 to the Skybox parent object to
    create its rotation behavior and to align it continuously to the camera position.
    This ensures that the Skybox is always centered on the camera wherever it travels
    in the scene:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将以下代码示例9-1应用到Skybox父对象上，以创建其旋转行为并将其持续对齐到相机位置。这确保了Skybox无论在场景中移动到何处，始终位于相机中心：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'From this, you now have a completed and enhanced Skybox, one that surrounds
    the camera and rotates to produce greater realism and life in your scenes. You
    can even go further by adding multiple stacked skyboxes within each other, each
    with transparency, to create additional effects such as fog, mist, and so on:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你现在拥有了一个完整且增强的Skybox，它围绕着相机旋转，以产生更真实和生动的场景。你甚至可以通过在每个Skybox内部添加多个堆叠的Skybox来更进一步，每个Skybox都具有透明度，以创建额外的效果，例如雾、薄雾等：
- en: '![Skybox](img/0655OT_09_07.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Skybox](img/0655OT_09_07.jpg)'
- en: Completing a manual Skybox prefab
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 完成手动Skybox预制件
- en: Procedural meshes
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序化网格
- en: 'Although Unity now offers a Quad primitive from the application menu, which
    you can access by navigating to **GameObject** | **3D Object** | **Quad**, it''s
    still useful to know how to create geometry manually, such as Quads. There are
    several reasons for this. First, you''ll frequently need to edit vertices in the
    script to move, animate, or distort meshes for various effects to create, for
    example, a jelly-like surface in a platform game that bends and wobbles whenever
    characters step on it. Second, you''ll need to edit the UV coordinates of a mesh,
    perhaps, to create animated or scrolling-texture effects, as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Unity现在从应用程序菜单提供了一个Quad原语，您可以通过导航到**GameObject** | **3D Object** | **Quad**来访问它，但了解如何手动创建几何形状，如Quads，仍然很有用。这里有几个原因。首先，你将经常需要在脚本中编辑顶点以移动、动画或扭曲网格以创建各种效果，例如，在平台游戏中创建一个类似果冻的表面，当角色踩在上面时弯曲和摇晃。其次，你可能需要编辑网格的UV坐标，例如，以创建动画或滚动的纹理效果，如下所示：
- en: '![Procedural meshes](img/0655OT_09_08.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![程序化网格](img/0655OT_09_08.jpg)'
- en: Generating meshes from script
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从脚本生成网格
- en: 'Consider the following code sample 9-2, which should be included inside the
    `Editor` folder of a project. It creates an editor add-on that generates a Quad
    in script with full customization over the location of the mesh pivot point. As
    we''ll see in the code comments, this sample features many useful tips:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码示例9-2，它应包含在项目中的`Editor`文件夹内。它创建了一个编辑器插件，该插件在脚本中生成一个具有对网格枢轴点位置完全定制的Quad。正如我们将在代码注释中看到的，这个示例包含了许多有用的提示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following are the comments for code sample 9-2:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例9-2的注释：
- en: '**Line 004**: This sample is coded as an editor plugin. As a result, the `UnityEditor`
    namespace is included. For more information on creating editor plugins, refer
    to [Chapter 8](ch08.html "Chapter 8. Customizing the Unity Editor"), *Customizing
    the Unity Editor*.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第004行**：此示例被编码为一个编辑器插件。因此，包含了`UnityEditor`命名空间。有关创建编辑器插件的更多信息，请参阅第8章，*自定义Unity编辑器*。'
- en: '**Line 135**: The `OnSelectionChanged` event is called when the user changes
    their selection, with the mouse or keyboard, in the Unity Editor. Here, the `GetAssetPath`
    method is called to retrieve the currently open folder in the **Project** panel.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第135行**：当用户在Unity编辑器中通过鼠标或键盘更改选择时，会调用`OnSelectionChanged`事件。在这里，调用`GetAssetPath`方法来检索当前在**项目**面板中打开的文件夹。'
- en: '**Line 140**: The `OnWizardCreate` function is called to generate a Quad mesh
    in script. This is created by filling a vertex and UV array and then populating
    that inside a `Mesh` object created in line 196.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第140行**：调用`OnWizardCreate`函数在脚本中生成一个Quad网格。这是通过填充顶点和UV数组，然后在第196行创建的`Mesh`对象内部填充来实现的。'
- en: '**Line 204**: Critically, the mesh itself is saved, not as an object in a specific
    scene, but as a general asset of the project from which many instances can be
    made as prefab objects. This is achieved with the `AssetDatabase` class. This
    is important to allow the mesh to be reusable across multiple scenes, if required,
    and also to allow its changes and details to be persistent across scenes.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第204行**：关键的是，网格本身被保存，不是作为特定场景中的对象，而是作为项目的一般资产。这样可以通过`AssetDatabase`类实现。这对于允许网格在需要时跨多个场景重用，以及允许其更改和细节在场景间持久化非常重要。'
- en: Tip
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on the `AssetDatabase` class can be found online in the Unity
    documentation at [http://docs.unity3d.com/ScriptReference/AssetDatabase.html](http://docs.unity3d.com/ScriptReference/AssetDatabase.html).
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多关于`AssetDatabase`类的信息可以在Unity文档中在线找到，链接为[http://docs.unity3d.com/ScriptReference/AssetDatabase.html](http://docs.unity3d.com/ScriptReference/AssetDatabase.html)。
- en: Animating UVs – scrolling textures
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画UVs – 滚动纹理
- en: 'Scrolling textures are a general purpose requirement for lots of games, and
    yet, they are not natively supported by Unity; that is, they require you to "get
    coding" for their implementation. Scrolling textures are useful for parallax effects;
    to move clouds, surfaces, and water; or to express motion or movement in the game.
    Typically, scrolling textures are seamless images whose pixels tile vertically
    and horizontally. This allows infinite scrolling and repetition, as shown here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动纹理是许多游戏的一般性需求，然而，Unity本身并不原生支持滚动纹理；也就是说，你需要“动手编码”来实现它们。滚动纹理对于创建视差效果很有用；用于移动云彩、表面和水；或者表达游戏中的运动或移动。通常，滚动纹理是无缝图像，其像素在垂直和水平方向上平铺。这允许无限滚动和重复，如下所示：
- en: '![Animating UVs – scrolling textures](img/0655OT_09_09.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![动画UVs – 滚动纹理](img/0655OT_09_09.jpg)'
- en: Scrolling texture on a Quad
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在四边形上的滚动纹理
- en: 'When attached to a Quad, the following code sample 9-3 will animate its texture
    according to the horizontal and vertical speed:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当附加到四边形时，以下代码示例9-3将根据水平和垂直速度动画化其纹理：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `MatScroller` class works with any `MeshRenderer` component and Quad object.
    A complete scrolling-texture project can be found in the book's companion files
    (code bundle).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`MatScroller`类与任何`MeshRenderer`组件和四边形对象一起工作。一个完整的滚动纹理项目可以在本书的配套文件（代码包）中找到。'
- en: Attach this script to your Quad object and tweak its scrolling speed to produce
    the results you need, as shown in the following screenshot. This will be useful
    to create animated sky backgrounds and backgrounds for side-scrolling shooter
    or platform games. It can also be useful to create flowing waterfalls and volumetric
    lighting when combined with transparency!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本附加到你的四边形对象上，并调整其滚动速度以产生所需的结果，如下面的截图所示。这将有助于创建动画天空背景和侧滚动射击或平台游戏的背景。它还可以与透明度结合使用来创建流动的瀑布和体积光照！
- en: '![Animating UVs – scrolling textures](img/0655OT_09_10.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![动画UVs – 滚动纹理](img/0655OT_09_10.jpg)'
- en: Tweaking texture-scrolling fields from the Object Inspector
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从对象检查器调整纹理滚动字段
- en: Texture painting
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理绘制
- en: There are many practical scenarios where it's necessary to paint pixels onto
    textures at runtime. Sometimes, the need itself will be trivial, such as displaying
    a decal texture (such as a foot print or written message) in front of another
    surface using alpha transparency. In these cases, you can simply workaround the
    issue with an alpha cut out plane positioned in front of another plane as the
    background. However, there are times when your needs are more complex, and you
    actually need to resort to true texture painting. For example, in a street-fighting
    game, blood splatters from punches and other attacks will fall to the ground and
    surrounding scenery, and you want to it remain as part of the environment texture.
    Another example might be a casual make-up artist game where the gamer must paint
    blusher or eye shadow onto a face mesh.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多实际场景中，需要在运行时将像素绘制到纹理上。有时，这种需求本身可能很简单，例如，使用alpha透明度在另一个表面前显示贴图纹理（如脚印或文字信息）。在这种情况下，你可以简单地通过在另一个平面前放置一个alpha裁剪平面来解决这个问题，作为背景。然而，有时你的需求更为复杂，实际上你需要求助于真正的纹理绘制。例如，在街头打斗游戏中，拳头和其他攻击造成的血迹会落在地面和周围景观上，你希望它成为环境纹理的一部分。另一个例子可能是一个休闲化妆艺术家游戏，玩家必须将腮红或眼影绘制到面部网格上。
- en: Here, you don't simply want to paint textured quads in front of the mesh as
    separate objects to create the appearance of textured decals. Instead, you really
    need to paint a source texture (such as a brush) onto a destination texture as
    applied to a mesh. Here, the painting does not just happen between two independent
    textures but with a mesh and its UV mapping intervening between them. In other
    words, a source texture must be applied or projected onto a mesh surface in the
    scene, and then, the brush pixels must be unprojected back onto the destination
    texture through the mesh UV mapping. This ensures that the brush pixels are painted
    to the correct place within the destination texture, as shown in the following
    screenshot. This method, therefore, allows any source texture of any size to be
    painted onto any 3D surface and its destination texture of any size via UV mapping.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你并不想在网格前面单独作为对象绘制纹理四边形来创建纹理贴图的视觉效果。相反，你真正需要将源纹理（如笔刷）绘制到应用于网格的目标纹理上。在这里，绘制不仅仅发生在两个独立的纹理之间，而是在网格及其UV映射之间进行。换句话说，源纹理必须应用于场景中网格表面，然后，笔刷像素必须通过网格UV映射重新投影回目标纹理。这确保了笔刷像素被绘制到目标纹理的正确位置，如图下所示。因此，这种方法允许任何大小的源纹理通过UV映射绘制到任何3D表面及其任何大小的目标纹理上。
- en: In this section, we'll explore how this is achieved practically and effectively.
    Before getting started, however, it should be mentioned that texture painting
    in this way should be pursued as a last resort when alternative methods (such
    as cut out quads) are not adequate. This is because true texture painting is computationally
    expensive.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何实际有效地实现这一点。然而，在开始之前，应该指出，以这种方式进行纹理绘制应作为最后手段，当其他方法（如裁剪四边形）不足够时。这是因为真正的纹理绘制在计算上非常昂贵。
- en: '![Texture painting](img/0655OT_09_11.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![纹理绘制](img/0655OT_09_11.jpg)'
- en: Real-time painting of textured brushes onto other textures via a mesh and its
    UV mapping
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网格及其UV映射实时绘制纹理笔刷到其他纹理上
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A complete texture painting project can be found in the book's companion files
    (code bundle).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的纹理绘制项目可以在本书的配套文件（代码包）中找到。
- en: Step 1 – creating a texture blending shader
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一步 – 创建纹理混合着色器
- en: 'First, let''s recognize the two-layer approach that''s ideal here. First, we
    have the brush source texture itself, which will be painted onto a destination
    texture when the user clicks on a mesh in the scene, as shown here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们认识到这里理想的两种层叠方法。首先，我们有笔刷源纹理本身，当用户在场景中点击网格时，它将被绘制到目标纹理上，如图所示：
- en: '![Step 1 – creating a texture blending shader](img/0655OT_09_12.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![第一步 – 创建纹理混合着色器](img/0655OT_09_12.jpg)'
- en: The brush texture, where black is transparent (alpha)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 笔刷纹理，其中黑色是透明的（alpha）
- en: 'Then, we have the destination texture applied to the mesh onto which the brush
    strokes should be overlaid when painted, as shown in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有应用于网格的目标纹理，当绘制时，笔刷笔触应该叠加到其上，如图下所示：
- en: '![Step 1 – creating a texture blending shader](img/0655OT_09_13.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![第一步 – 创建纹理混合着色器](img/0655OT_09_13.jpg)'
- en: Destination texture onto which brushes should be painted
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 应该绘制笔刷的目标纹理
- en: However, we don't usually want the painted brush strokes overwriting or changing
    the original destination texture during the paint operation. This is because the
    destination texture could be applied to multiple objects in the scene (at least
    in theory), and overwriting or changing the pixels of the original will result
    in its effects being propagated to all objects using the texture.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们通常不希望在绘制操作期间绘制的笔刷笔触覆盖或更改原始目标纹理。这是因为目标纹理可能应用于场景中的多个对象（至少在理论上是这样），覆盖或更改原始像素将导致其效果传播到使用该纹理的所有对象。
- en: 'Instead, it''d be better to separate the paint effects onto a separate texture
    with a transparent background, which is layered over the destination texture via
    a custom material. This creates a true separation between the destination texture
    and the paint effects, even though in appearance, it appears as one consolidated
    texture. To achieve this effect, a custom shader must be written, as shown in
    the following code sample 9-4\. This shader blends a top texture (with alpha transparency)
    on top of a background texture:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，最好将绘制效果分离到具有透明背景的单独纹理上，并通过自定义材质将其层叠到目标纹理上。这会在目标纹理和绘制效果之间创建真正的分离，尽管外观上看起来像是一个统一的纹理。为了实现这种效果，必须编写自定义着色器，如下面的代码示例9-4所示。这个着色器在背景纹理上混合一个顶部纹理（具有alpha透明度）：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once the shader is coded and saved, it appears as a selectable shader type for
    any material you create via the **Material** panel in the Object Inspector. This
    shader should be used for any object onto which details must be painted, as shown
    in the following screenshot. The `_MainTex` slot refers to the background texture
    onto which details must be overlaid but which must also be preserved from any
    true edits. The `_BlendTex` slot refers to the texture to be overlaid onto `_MainTex`,
    which preserves its alpha transparency. Typically, this slot will be populated
    at runtime from script by generating an alpha transparent texture to receive brush
    strokes, as we'll soon see.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦着色器编写并保存，它就会作为对象检查器中**材质**面板创建的任何材质的可选择着色器类型出现。这个着色器应该用于任何需要绘制细节的对象，如图所示。`_MainTex`插槽指的是需要叠加细节但必须保留的背景纹理。`_BlendTex`插槽指的是要叠加到`_MainTex`上的纹理，它保留了其alpha透明度。通常，这个插槽将在运行时由脚本通过生成一个alpha透明纹理来填充，以接收画笔笔触，正如我们很快将看到的。
- en: '![Step 1 – creating a texture blending shader](img/0655OT_09_14.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![第一步 – 创建纹理混合着色器](img/0655OT_09_14.jpg)'
- en: A custom shader is created to blend the top-most texture onto the bottom-most
    texture
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个自定义着色器以混合最顶部的纹理到最底部的纹理
- en: Step 2 – creating a texture painting script
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二步 – 创建纹理绘制脚本
- en: 'We''ve now created a shader that accepts two textures as input (the top and
    bottom textures) and blends the top over the bottom; this allows alpha transparency.
    This results in a Photoshop-layer style effect. This allows us to separate texture
    painting onto a top texture while preserving the pixels of the original background
    below it, as shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个着色器，它接受两个纹理作为输入（顶部和底部纹理）并将顶部纹理混合到底部；这允许使用alpha透明度。这会产生类似于Photoshop图层效果。这允许我们将纹理绘制分离到顶部纹理上，同时保留其下原始背景的像素，如图所示：
- en: '![Step 2 – creating a texture painting script](img/0655OT_09_15.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![第二步 – 创建纹理绘制脚本](img/0655OT_09_15.jpg)'
- en: Creating a texture painting script
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 创建纹理绘制脚本
- en: Before moving further, however, we must first edit the brush texture asset we
    plan on using via Object Inspector. Specifically, select the brush texture from
    the **Project** panel in the Unity Editor and change **Texture Type** to **Advanced**.
    Enable the checkbox for **Read/Write Enabled**; this allows the texture to be
    accessed using texture-editing functions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在继续之前，我们必须首先通过对象检查器编辑我们计划使用的画笔纹理资产。具体来说，从Unity编辑器的**项目**面板中选择画笔纹理，并将**纹理类型**更改为**高级**。启用**可读写**复选框；这允许使用纹理编辑功能访问纹理。
- en: 'In addition, enable **Alpha is Transparency** and disable **Generate Mip Maps**,
    as shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，启用**Alpha是透明度**并禁用**生成Mip贴图**，如图所示：
- en: '![Step 2 – creating a texture painting script](img/0655OT_09_16.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![第二步 – 创建纹理绘制脚本](img/0655OT_09_16.jpg)'
- en: Configuring textures for texture painting
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 配置纹理以进行纹理绘制
- en: 'Now, we''ll need to create a texture-painting script that allows us to paint
    the brush texture, using the mouse, onto a 3D object in the scene via its UV coordinates.
    The script is shown in the following code sample 9-5:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个纹理绘制脚本，允许我们使用鼠标通过其UV坐标在场景中的3D对象上绘制画笔纹理。该脚本如下代码示例9-5所示：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following are the comments for code sample 9-5:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例9-5的注释：
- en: '**Line 008**: The public variable in this line maintains a reference to a valid
    texture asset to be used as the brush graphic during paint operations. For each
    mouse click, this texture will be "laid down" or painted onto the variable `SurfaceTexture`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第008行**：此行中的公共变量维护了对一个有效纹理资产的引用，该纹理资产在绘制操作期间用作画笔图形。对于每个鼠标点击，这个纹理将被“放置”或绘制到变量`SurfaceTexture`上。'
- en: '**Line 015**: `SurfaceTexture` will reference a dynamically generated texture
    filled, by default, with transparent pixels, which will reveal any texture layered
    beneath. This texture will accept all brush strokes during a paint operation.
    In short, this texture will be fed into the `TextureBlender` shader as the `_BlendTex`
    variable.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 015**: `SurfaceTexture` 将引用一个动态生成的纹理，默认情况下填充透明像素，这将揭示任何在其下层的纹理。此纹理将接受绘画操作期间的所有画笔笔触。简而言之，此纹理将被输入到
    `TextureBlender` 着色器中的 `_BlendTex` 变量。'
- en: '**Lines 026-031**: A new texture is generated during the `Start` function.
    The texture is in the RGBA32 format, which supports an alpha channel. The `SetPixels`
    function is used to batch fill (flood fill) the texture with pixels of the same
    color. More information on the `GetPixels` and `SetPixels` functions are considered
    later.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 026-031**: 在 `Start` 函数期间生成一个新纹理。该纹理为 RGBA32 格式，支持 alpha 通道。使用 `SetPixels`
    函数批量填充（洪水填充）纹理为相同颜色的像素。有关 `GetPixels` 和 `SetPixels` 函数的更多信息将在稍后考虑。'
- en: '**Line 046**: In the `Update` function, mouse clicks are detected to initiate
    the texture-painting functionality.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 046**: 在 `Update` 函数中，检测鼠标点击以启动纹理绘制功能。'
- en: '**Lines 048-059**: If a mouse button is pressed, the function should paint
    the brush texture onto the destination. `Physics.Raycast` is called in line 52
    to determine several things, such as to see whether a mesh object in the scene
    was hit by the ray. For this to work properly, the object should feature a `Collider`
    component.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 048-059**: 如果按下鼠标按钮，函数应在目标上绘制画笔纹理。在第 52 行调用 `Physics.Raycast` 以确定一些事情，例如查看场景中的网格对象是否被射线击中。为了正常工作，该对象应具有
    `Collider` 组件。'
- en: '**Lines 062-072**: If a collision was detected, the UV coordinates of the hit
    location should be retrieved through the `textureCoord` variable of the `RaycastHit`
    structure. More information on this variable can be found online in the Unity
    documentation at [http://docs.unity3d.com/ScriptReference/RaycastHit-textureCoord.html](http://docs.unity3d.com/ScriptReference/RaycastHit-textureCoord.html).
    This member, is only valid if the intersected mesh has `MeshCollider`, as opposed
    to other collider types, such as `BoxCollider` or `CapsuleCollider`. However,
    this means that any object used as a texture-painting destination should feature
    a `MeshCollider` component, since it contains UV data. Lines 63–72 then convert
    the UV coordinates into absolute pixel positions, centering the brush source texture
    at the position of the cursor. The result of this code is to clearly identify
    a position on the source brush texture that should be the pivot or origin point,
    and to establish a pixel *x*, *y* coordinate location at which the source texture
    should be painted into the destination texture.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 062-072**: 如果检测到碰撞，应通过 `RaycastHit` 结构的 `textureCoord` 变量检索被击中位置的 UV 坐标。有关此变量的更多信息，可以在
    Unity 文档的在线文档中找到，网址为 [http://docs.unity3d.com/ScriptReference/RaycastHit-textureCoord.html](http://docs.unity3d.com/ScriptReference/RaycastHit-textureCoord.html)。此成员仅在相交的网格具有
    `MeshCollider` 时有效，而不是其他碰撞器类型，如 `BoxCollider` 或 `CapsuleCollider`。然而，这意味着任何用作纹理绘制目标的对象应具有
    `MeshCollider` 组件，因为它包含 UV 数据。第 63-72 行将 UV 坐标转换为绝对像素位置，将画笔源纹理中心对准光标位置。此代码的结果是在源画笔纹理上清楚地标识一个应作为支点或原点的位置，并在源纹理应绘制到目标纹理中的像素
    *x*、*y* 坐标位置处建立。'
- en: '**Line 075**: Finally, the `PaintSourceToDestTexture` function is called to
    perform the paint operation itself.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 075**: 最后，调用 `PaintSourceToDestTexture` 函数本身执行绘画操作。'
- en: '**Line 081**: The `PaintSourceToDestTexture` function accepts four arguments:
    `Source`, `Dest`, `Left`, and `Top`. On the basis of these, the `Source` texture
    is painted onto the `Dest` at the positions `Left` and `Top`. This function is
    declared as static, which means that no instance of this class needs to be declared.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 081**: `PaintSourceToDestTexture` 函数接受四个参数：`Source`、`Dest`、`Left` 和 `Top`。基于这些参数，`Source`
    纹理被绘制到 `Dest` 的 `Left` 和 `Top` 位置。此函数被声明为静态的，这意味着不需要声明此类的任何实例。'
- en: '**Lines 084-087**: The first step in the texture-painting process is to retrieve
    all pixels in both the `Source` and `Dest` textures. This is achieved using the
    `GetPixels` function. More information on `GetPixels` can be found online in the
    Unity documentation at [http://docs.unity3d.com/ScriptReference/Texture2D.GetPixels.html](http://docs.unity3d.com/ScriptReference/Texture2D.GetPixels.html).
    Now, although each image is visually a two-dimensional array of pixels, the returned
    array from `GetPixels` is in fact linear (one-dimensional). This is the reason
    for both the `GetPixelFromArray` and `SetPixelFromArray` functions, which convert
    pixel *x* and *y* positions into linear array indices.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 084-087**：纹理绘制过程的第一步是检索 `Source` 和 `Dest` 纹理中的所有像素。这是通过使用 `GetPixels` 函数实现的。有关
    `GetPixels` 的更多信息，可以在 Unity 文档中找到，网址为 [http://docs.unity3d.com/ScriptReference/Texture2D.GetPixels.html](http://docs.unity3d.com/ScriptReference/Texture2D.GetPixels.html)。现在，尽管每个图像在视觉上都是一个像素的二维数组，但
    `GetPixels` 返回的数组实际上是线性的（一维的）。这就是为什么有 `GetPixelFromArray` 和 `SetPixelFromArray`
    函数，它们将像素的 *x* 和 *y* 位置转换为线性数组索引的原因。'
- en: '**Lines 89-101**: Here, each pixel is retrieved from the `Source` texture and
    painted onto the destination. This checks to ensure that the brush texture is
    painted with the destination bounds and allows clipping, if required. This is
    necessary because a brush mark could, in principle, be made close to the texture
    edge; in this case, only a part of the brush would actually be painted onto the
    destination, as some pixels would be "cut off". Pixels are retrieved from the
    `Source` texture with `GetPixelFromArray`, and destination pixels are set with
    `SetPixelInArray`.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 89-101**：在这里，每个像素从 `Source` 纹理中检索出来并绘制到目标上。这检查确保画笔纹理以目标边界绘制，并允许所需的裁剪。这是必要的，因为画笔标记原则上可以靠近纹理边缘；在这种情况下，实际上只有画笔的一部分会被绘制到目标上，因为一些像素会被“剪掉”。像素是通过
    `GetPixelFromArray` 从 `Source` 纹理中检索的，而目标像素是通过 `SetPixelInArray` 设置的。'
- en: '**Lines 106-107**: Finally, the destination pixels are pushed back to the destination
    texture buffer, and the `Apply` function is called to confirm the operation. Unity
    also supports a `SetPixel` function (singular) as opposed to `SetPixels` (plural).
    However, `SetPixels` results in better performance as it repeats the calling of
    `SetPixel`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 106-107**：最后，目标像素被推回到目标纹理缓冲区，并调用 `Apply` 函数以确认操作。Unity 还支持一个 `SetPixel`
    函数（单数）而不是 `SetPixels`（复数）。然而，`SetPixels` 由于重复调用 `SetPixel` 而能带来更好的性能。'
- en: '**Lines 111-114**: The `GetPixelFromArray` function accepts an array of pixel
    data as well as the *x* and *y* coordinates of a pixel and the pixel width of
    the texture data. On the basis of this, it returns a linear index into the pixel
    array where you can find the pixel color value.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 111-114**：`GetPixelFromArray` 函数接受一个像素数据数组以及一个像素的 *x* 和 *y* 坐标以及纹理数据的像素宽度。基于此，它返回一个线性索引到像素数组中，在那里你可以找到像素颜色值。'
- en: '**Lines 117-131**: The `SetPixelInArray` function changes the color of a pixel
    in a linear array. The method of change is determined by the argument `Blending`.
    If `Blending` is set to `false`, the source pixel would simply replace the destination
    pixel. If `Blending` is `true`, the source pixel would be blended or layered onto
    the destination pixel that preserves the alpha transparency. `Blending` should
    be set to `true` when painting alpha-transparent brushes onto the target texture
    to allow for the accumulation and blending of color values.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 117-131**：`SetPixelInArray` 函数改变线性数组中像素的颜色。改变的方法由参数 `Blending` 决定。如果 `Blending`
    设置为 `false`，则源像素将简单地替换目标像素。如果 `Blending` 为 `true`，则源像素将与目标像素混合或分层，以保留 alpha 透明度。在将
    alpha 透明度画笔绘制到目标纹理时，应将 `Blending` 设置为 `true`，以允许颜色值的累积和混合。'
- en: Step 3 – setting up texture painting
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 3 – 设置纹理绘制
- en: 'Now that we have a working shader, texture-painting script, and configured
    textures, we''ll take a step-by-step run-through of configuring texture painting
    in Unity. Start from an empty project, including only our shader, texture painting
    script, and two configured textures: a background texture and a brush texture,
    as shown here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个工作的着色器、纹理绘制脚本和配置好的纹理，我们将逐步运行配置 Unity 中纹理绘制的过程。从一个空项目开始，只包括我们的着色器、纹理绘制脚本和两个配置好的纹理：一个背景纹理和一个画笔纹理，如图所示：
- en: '![Step 3 – setting up texture painting](img/0655OT_09_17.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 3 – 设置纹理绘制](img/0655OT_09_17.jpg)'
- en: Starting a texture-painting project
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 开始纹理绘制项目
- en: 'Configure the brush texture from the **Project** panel to a small size (such
    as `32 x 32`) and set its **Format** to **RGBA 32 bit** for alpha transparency,
    as shown in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从 **Project** 面板配置画笔纹理为小尺寸（例如 `32 x 32`），并将其 **格式** 设置为 **RGBA 32 位** 以实现透明度，如图所示：
- en: '![Step 3 – setting up texture painting](img/0655OT_09_18.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 3 – 设置纹理绘制](img/0655OT_09_18.jpg)'
- en: Configuring a brush texture
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 配置画笔纹理
- en: 'Create a new material using the **TextureBlender** shader and assign the background
    texture to the `MainTexture` slot, as shown here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **TextureBlender** 着色器创建一个新的材质，并将背景纹理分配给 `MainTexture` 插槽，如图所示：
- en: '![Step 3 – setting up texture painting](img/0655OT_09_19.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 3 – 设置纹理绘制](img/0655OT_09_19.jpg)'
- en: Creating a new material from our TextureBlender shader
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的 TextureBlender 着色器创建一个新的材质
- en: Add a new **Quad**, **Plane**, or **Mesh** to the scene and remove its collider,
    if any. This object will receive the final painted output, although the click
    detection will occur on a duplicate mesh. I am keeping the final output mesh and
    the click-detection mesh separate to allow the destination mesh to have other
    collider types or components if required.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中添加一个新的 **Quad**、**Plane** 或 **Mesh**，如果有的话，移除其碰撞器。这个对象将接收最终的绘制输出，尽管点击检测将在一个副本网格上发生。我保持最终输出网格和点击检测网格分开，以便目标网格在需要时可以具有其他碰撞器类型或组件。
- en: 'Once the Quad has been added, assign the custom material to it with the **TextureBlender**
    shader, as shown here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了 Quad，使用 **TextureBlender** 着色器将其分配给该 Quad，如图所示：
- en: '![Step 3 – setting up texture painting](img/0655OT_09_20.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 3 – 设置纹理绘制](img/0655OT_09_20.jpg)'
- en: Adding a new Quad
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新的 Quad
- en: Duplicate **Quad**, add **Mesh Collider**, disable **Mesh Renderer**, and assign
    an empty diffuse material to it. This mesh will not render, but will detect mouse
    clicks and perform the paint operation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 复制 **Quad**，添加 **Mesh Collider**，禁用 **Mesh Renderer**，并为其分配一个空的漫反射材质。这个网格将不会渲染，但会检测鼠标点击并执行绘制操作。
- en: 'In addition, add the `TexturePainter` script to the object and assign the **Brush
    Texture** field to the brush texture itself and the **Dest Mat** field to the
    **Custom_Mat** material from the **Project** panel, as shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将 `TexturePainter` 脚本添加到对象中，并将 **Brush Texture** 字段分配给画笔纹理本身，将 **Dest Mat**
    字段分配给来自 **Project** 面板的 **Custom_Mat** 材质，如图所示：
- en: '![Step 3 – setting up texture painting](img/0655OT_09_21.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 3 – 设置纹理绘制](img/0655OT_09_21.jpg)'
- en: Creating a click detection quad
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 创建点击检测 Quad
- en: 'Now, run the application and start clicking on your mesh. When you do, paint
    strokes will be applied to the texture and display on the viewport, as shown in
    the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行应用程序并开始点击你的网格。当你这样做时，绘制笔触将被应用到纹理上并在视口中显示，如图所示：
- en: '![Step 3 – setting up texture painting](img/0655OT_09_22.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 3 – 设置纹理绘制](img/0655OT_09_22.jpg)'
- en: Texture painting completed
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理绘制完成
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered extensive ground under a general remit of "2D-ness". 2D
    was defined here not so much in the conventional sense of 2D games, but with a
    texture-based understanding that's critical to both 2D and 3D games more generally.
    The topics included the operations and ideas that pertain to the 2D plane and
    within the 2D space. Specifically, it explored how to create rotating Skybox backgrounds
    by building a manual Skybox, combined with the camera depth settings to create
    a layered render. Then, it explored how to generate procedural geometry such as
    planes. With the addition of Unity Quads as primitives, the generation of planes
    is more limited when taken alone, but the methods and concepts deployed to generate
    the Quad are more useful, allowing us to edit and tweak any mesh, whether it is
    a Quad or not. The real-time editing of meshes is important to create a wide range
    of effects, from shockwave explosions to jelly-based trampolines. Moving forward,
    we examined the animation of mesh UVs. They allowed us to scroll indefinitely
    across a 2D background Quad, with a tile-able texture, which is useful for parallax
    effects as well as for water and other motion-based illusions. Finally, we considered
    dynamic texture painting on a mesh, where, using the mouse, we can click on a
    mesh to paint a source texture onto the mesh texture that allows its UV coordinates
    and the alpha transparency to blend. This feature set is especially powerful and
    has wide applicability to create real-time decals, such as bullet holes, blood
    splatters, and player-based drawing. In the next chapter, we will consider a range
    of tips and techniques to work better with Unity projects.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本章在“二维性”的广义范畴下涵盖了广泛的内容。在这里，二维的定义并不仅仅是在传统意义上的二维游戏，而是基于纹理的理解，这对于二维和三维游戏都具有关键意义。所涉及的主题包括与二维平面及其内部空间相关的操作和思想。具体来说，它探讨了如何通过构建手动Skybox来创建旋转的Skybox背景，结合相机深度设置以创建分层渲染。然后，它探讨了如何生成诸如平面之类的程序化几何形状。随着Unity四边形作为原型的加入，单独考虑时平面的生成更为有限，但用于生成四边形的方法和概念更为有用，使我们能够编辑和调整任何网格，无论它是否是四边形。实时编辑网格对于创建各种效果至关重要，从冲击波爆炸到基于果冻的蹦床。向前推进，我们考察了网格UV的动画。它们允许我们在可平铺的纹理上无限滚动2D背景四边形，这对于视差效果以及水和其他基于运动的幻觉都很有用。最后，我们考虑了在网格上进行动态纹理绘制，使用鼠标点击网格可以在网格纹理上绘制源纹理，允许其UV坐标和alpha透明度混合。这个功能集特别强大，具有广泛的应用性，可以创建实时贴图，如弹孔、血迹和基于玩家的绘制。在下一章中，我们将考虑一系列提示和技术，以更好地与Unity项目合作。
