<html><head></head><body>
        

                            
                    <h1 class="header-title">Logging and Health Checking</h1>
                
            
            
                
<p class="gmail-mce-root">One of the essential aspects of building web services is logging and health checks. Nowadays, it is preferred to have services with a small scope. This kind of approach provides enormous benefits, but it makes it hard for us to verify whether a service behaves in the right way. Logging helps us to track the actions and the information processed by the web service on the other side, the health check mechanisms provide a way to verify that the service is healthy and all the required dependencies are satisfied. The chapter goes through some of the logging parts of ASP.NET Core, and it shows how to implement health checks using the tools provided by the framework.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Logging in ASP.NET Core</li>
<li>Implementing logging</li>
<li>Implementing logging providers</li>
<li>Implementing custom logging in tests</li>
<li>Web service health check</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Logging in ASP.NET Core</h1>
                
            
            
                
<p>We will start this chapter by providing an overview of the different logging components of ASP.NET Core. The framework provides different interfaces that support logging:</p>
<ul>
<li><kbd>ILoggerProvider</kbd> is used to define a specific type of logging bind with an output channel</li>
<li><kbd>ILoggerFactory</kbd> takes an <kbd>ILoggerProvider</kbd> interface and initializes it</li>
<li>The <kbd>ILogger</kbd> interface is a particular instance of the logging component</li>
</ul>
<p>The logging interface structure of ASP.NET Core can be described using the following schema:</p>
<div><img src="img/86e0d6bc-3ac4-474f-bda7-eb95785ea19f.png" style=""/></div>
<p>In short, the <kbd>ILoggerProvider</kbd> interface represents the output of the logs, <kbd>ILoggerFactory</kbd> creates the right type of instance, and <kbd>ILogger</kbd> is the actual instance of the logger.</p>
<p>This kind of approach guarantees secure isolation between the <kbd>ILogger</kbd> interface consumer and the logging provider part. Furthermore, we may choose to add the calls to the <kbd>ILogger</kbd> interface in the development phase; then, during the release phase, we can decide which provider to use to output our logging data. Moreover, our logging code becomes very flexible, and we can change the output based on the type of environment our service runs in. Let's proceed by learning about the different characteristics of the logging system of ASP.NET Core.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The key characteristics of logging</h1>
                
            
            
                
<p>The ASP.NET Core logging system is characterized by some key attributes that are always present in each log record. Furthermore, it is essential to keep logs as coherent as possible. The crucial components of the ASP.NET Core logging system are the <em>log category</em>, the <em>log level</em>, the <em>log event id</em>, and the <em>log message</em>.</p>
<p>The <em>log category</em> is specified when the <kbd>ILogger&lt;T&gt;</kbd> interface is initialized. It is an essential part of the logging process because it identifies the component that is emitting the log record. The <em>log category</em> usually corresponds to the type or class that's firing the log records. Let's use the <kbd>ItemController</kbd> class of the catalog service as an example. The <em>log category</em> is defined during the <kbd>ILogger</kbd> interface injection process:</p>
<pre>namespace Catalog.API.Controllers<br/>{<br/>    [Route("api/items")]<br/>    [ApiController]<br/>    [JsonException]<br/>    [Authorize]<br/>    public class ItemController : ControllerBase<br/>    {<br/>        private readonly IItemService _itemService;<br/>        private readonly IEndpointInstance _messageEndpoint;<br/>        <strong>private readonly ILogger&lt;ItemController&gt; _logger;</strong><br/><br/>        public ItemController(IItemService itemService, <br/>        IEndpointInstance messageEndpoint,<br/>            IDistributedCache distributedCache, <br/><strong>            ILogger&lt;ItemController&gt; logger</strong>)<br/>        {<br/>            _itemService = itemService;<br/>            _messageEndpoint = messageEndpoint;<br/>            <strong>_logger = logger;</strong><br/>        }<br/>...<br/></pre>
<p>The <kbd>ItemController</kbd> class uses the widespread technique of constructor injection to initialize the <kbd>ILogger&lt;ItemController&gt;</kbd> type. Therefore, the log category is implicitly defined in the signature of the <kbd>_logger</kbd> property. Although the <em>log category</em> helps us identify which component is firing that specific log message, we also need to define the importance of that message.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <em>log level</em> provides information that indicates the severity or importance of the log record. ASP.NET Core provides a helpful extension method that offers some abstraction over the log level:</p>
<pre>_logger.LogInformation, _logger.LogWarning, _logger.LogError, _logger.LogCritical</pre>
<p>Each of these methods is an abstraction that's provided by the <kbd>Microsoft.Extensions.Logging</kbd> namespace. For example, if we examine the <kbd>_logger.LogInformation</kbd> method implementation, under the hood, it merely calls the generic <kbd>logger.Log</kbd> method:</p>
<pre>public static void LogInformation(<br/>  this ILogger logger,<br/>  EventId eventId,<br/>  Exception exception,<br/>  string message,<br/>  params object[] args)<br/>{<br/>  logger.Log(<strong>LogLevel.Information</strong>, eventId, exception, message, args);<br/>}</pre>
<p>The <kbd>LogInformation</kbd> extension method wraps the <kbd>logger.Log</kbd> method calls by implicitly defining the level of information provided by the framework. The <kbd>LogLevel</kbd> attribute is an <kbd>enum</kbd> structure that's exposed by the <kbd>Microsoft.Extension.Logging</kbd> namespace, which provides the following out of the box logging levels:</p>
<pre>namespace Microsoft.Extensions.Logging<br/>{<br/>  public enum LogLevel<br/>  {<br/>    Debug,<br/>    Warning,<br/>    Error,<br/>    Critical,<br/>    None,<br/>  }<br/>}</pre>
<p>The preceding code describes the different log levels that are provided by the <kbd>LogLevel</kbd> enumerator. The log levels go from <kbd>Trace</kbd>, which describes detailed information about the system, to the <kbd>Critical</kbd> level, which means that the service is unable to work correctly and is shutting down. The <kbd>LogLevel</kbd> attribute is essential because it is usually used to filter the log messages which tells us of the priority of a logging message.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Once we've identified the level of severity of a specific log message, we need to provide the <em>log event id</em>, which helps us identify a specific event in the logging output. While the <em>log category</em> usually represents the full path of the class, the <em>log event id</em> is useful if we wish to express the method that is currently generating the logging output. Let's use the action methods contained in the <kbd>ItemController</kbd> class as an example (<kbd>Get</kbd>, <kbd>GetById</kbd>, <kbd>Create</kbd>, <kbd>Update</kbd>, and <kbd>Delete</kbd>). It is possible to create a log event class that maps each action method to a specific event id:</p>
<pre>namespace Catalog.API<br/>{<br/>    public class LoggingEvents<br/>    {<br/>            public const int Get = 1000;<br/>            public const int GetById = 1001;<br/>            public const int Create = 1002;<br/>            public const int Update = 1003;<br/>            public const int Delete = 1004;<br/>    }<br/>}</pre>
<p>Therefore, we can pass the corresponding log event id when we call the <kbd>ILogger</kbd> interface in an action method of the <kbd>ItemController</kbd> class. By doing this, it is possible to identify and group events:</p>
<pre> _logger.LogInformation(LoggingEvents.GetById, "Getting item");</pre>
<p>Finally, another essential part of logging records is the message associated with the log record. The logging system of ASP.NET Core also provides a templating system that's analogous to the C# string interpolation feature. Therefore, it is possible to use the templating system in the following way:</p>
<pre> _logger.LogInformation(LoggingEvents.GetById, "GetById {id} ", id);</pre>
<p>The preceding code logs a message about <em>information</em> severity using the <kbd>LoggingEvents.GetById</kbd> event id and adds the message <kbd>"GetById {id} "</kbd>. Now that we have looked at the different logging characteristics provided by ASP.NET Core, we will look at a concrete implementation that's been applied to the <em>catalog service</em> project.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the logging part</h1>
                
            
            
                
<p>In this section, we will learn how to perform logging in the <em>catalog web service</em>. Let's start by choosing a layer where we'll execute the logging statements. Since the logic is encapsulated in the <kbd>Catalog.Domain</kbd> layer project, we will continue by implementing the logging part on the service classes defined in the project. First of all, let's start by defining a new logging class, which contains the corresponding <em>event id</em> for each operation:</p>
<pre>namespace Catalog.Domain.Logging<br/>{<br/>    public class Events<br/>    {<br/>        public const int Get = 1000;<br/>        public const int GetById = 1001;<br/>        public const int Add = 1002;<br/>        public const int Edit = 1003;<br/>        public const int Delete = 1004;<br/>    }<br/>}</pre>
<p>Once we have established a corresponding <em>log event id</em> for each activity, we need to define the logging messages that will be used by the <kbd>ILogger</kbd> interface. For now, we can determine the following messages:</p>
<pre>namespace Catalog.Domain.Logging<br/>{<br/>    public class Messages<br/>    {<br/>        public const string NumberOfRecordAffected_modifiedRecords = <br/>            "Number of record affected {records}";<br/>        public const string ChangesApplied_id = "Changes applied to the <br/>            following entity id ({id})";<br/>        public const string TargetEntityChanged_id = "Target entity id <br/>            ({id})";<br/>    }<br/>}</pre>
<p>The first one refers to the number of records affected by a change, while the second is the entity that's been changed. Finally, the third one provides a message for the target entity of the handler. It is essential to note that both constants follow a naming convention: the first part of their name refers to the content of the message; after the first underscore, we have the parameters that will be replaced by values when we use the logging templating system.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Furthermore, we can proceed by changing the <kbd>IItemService</kbd> methods by implementing logging. Let's start with the <kbd>AddItemAsync</kbd> method:</p>
<pre><strong>using Microsoft.Extensions.Logging;<br/></strong><strong>using Catalog.Domain.Logging;</strong><br/>...<br/><br/>namespace Catalog.Domain.Services<br/>{<br/>    public class ItemService : IItemService<br/>    {<br/>        private readonly IItemMapper _itemMapper;<br/>        private readonly IItemRepository _itemRepository;<br/>       <strong> private readonly ILogger&lt;IItemService&gt; _logger;</strong><br/><br/>        public ItemService(IItemRepository itemRepository, <br/>        IItemMapper itemMapper, <strong>ILogger&lt;IItemService&gt; logger</strong>)<br/>        {<br/>            _itemRepository = itemRepository;<br/>            _itemMapper = itemMapper;<br/>           <strong> _logger = logger;</strong><br/>        }<br/>        <br/>        ...<br/><br/>        public async Task&lt;ItemResponse&gt; AddItemAsync(AddItemRequest <br/>            request)<br/>        {<br/>            var item = _itemMapper.Map(request);<br/>            var result = _itemRepository.Add(item);<br/><br/>            var <strong>modifiedRecords</strong> = await _itemRepository. <br/>                UnitOfWork.SaveChangesAsync();<br/>     <br/>           <strong> _logger.LogInformation(Events.Add, Messages.<br/>            NumberOfRecordAffected_modifiedRecords, modifiedRecords);</strong><br/><strong>            _logger.LogInformation(Events.Add, Messages.<br/>            ChangesApplied_id, result?.Id);</strong><br/><br/>            return _itemMapper.Map(result);<br/>        }<br/><br/>        ...<br/>    } <br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The preceding code tracks the information about the number of affected records and the id of the added record. We can do the same with the other methods of the <kbd>ItemService</kbd> class. In the case of read-only operations, we can add the id of the target record; for example, in the case of the <kbd>GetItemAsync</kbd> method:</p>
<pre>public class ItemService : IItemService<br/>{<br/>    ...<br/><br/>    public async Task&lt;ItemResponse&gt; GetItemAsync(GetItemRequest <br/>        request)<br/>    {<br/>        if (request?.Id == null) throw new ArgumentNullException();<br/>        var entity = await _itemRepository.GetAsync(request.Id);<br/>        <br/>       <strong> _logger.LogInformation(Events.GetById, <br/>            Messages.TargetEntityChanged_id, entity?.Id);</strong><br/>        <br/>        return _itemMapper.Map(entity);<br/>    }</pre>
<p>The preceding code logs the information related to the id that was retrieved by the service by using the <kbd>Event.GetById</kbd> field. It uses the <kbd>Messages</kbd> type to specify the event message. In the next section, we will learn how to log exceptions by enhancing the exception handling implementation of logs.  </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exception logging</h1>
                
            
            
                
<p>What if part of the service throws an exception? Handling exceptions is a crucial part of the development process of services. As we saw in <a href="13fd7d18-3ebe-4f60-89ff-4666d1c9671a.xhtml">Chapter 7</a>, <em>Filter Pipeline</em>, it is possible to use them to catch exceptions using a filter. Filters are one of the crucial parts of the MVC stack: they act before and after action methods, and they can be used to log exceptions in a single implementation. Let's have a look at <kbd>JsonExceptionAttribute</kbd> in <kbd>Catalog.API</kbd><em> </em>again<em>:</em></p>
<pre>using System.Net;<br/>using Microsoft.AspNetCore.Hosting;<br/>using Microsoft.AspNetCore.Mvc;<br/>using Microsoft.AspNetCore.Mvc.Filters;<br/>using Microsoft.Extensions.Logging;<br/>using Catalog.API.Exceptions;<br/><br/>namespace Catalog.API.Filters<br/>{<br/>    public class JsonExceptionAttribute : TypeFilterAttribute<br/>    {<br/>        public JsonExceptionAttribute() : base(typeof(HttpCustomExceptionFilterImpl))<br/>        {<br/>        }<br/><br/>        public class HttpCustomExceptionFilterImpl : IExceptionFilter<br/>        {<br/>            private readonly IHostingEnvironment _env;<br/>           <strong> private readonly ILogger _logger;</strong><br/><br/>            public HttpCustomExceptionFilterImpl(IHostingEnvironment <br/>                env,<br/>               <strong> ILogger&lt;HttpCustomExceptionFilterImpl&gt; logger</strong>)<br/>            {<br/>                _env = env;<br/>                _logger = logger;<br/>            }<br/><br/>            public void OnException(ExceptionContext context)<br/>            {<br/>                var eventId = new EventId(context.Exception.HResult);<br/><br/>                <strong>_logger.LogError(eventId, </strong><strong>context.Exception, <br/>                    </strong><strong>context.Exception.Message);</strong><br/><br/>                var json = new JsonErrorPayload<br/>                {<br/>                    EventId = eventId.Id<br/>                };<br/><br/>                json.DetailedMessage = context.Exception;<br/><br/>                var exceptionObject = new ObjectResult(json) { <br/>                    StatusCode = 500 };<br/><br/>                context.Result = exceptionObject;<br/>                context.HttpContext.Response.StatusCode = (int) <br/>                HttpStatusCode.InternalServerError;<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>The class tracks and returns exceptions using the analog pattern, which can be seen in the implementation of the handler: the <kbd>ILogger&lt;T&gt;</kbd> interface is injected into the constructor using dependency injection and the <kbd>_logger.LogError</kbd> method. </p>
<p>In the next section, we will learn how to verify logging in our test using <kbd>Moq</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Verifying logging using Moq</h1>
                
            
            
                
<p>Let's learn how to verify our implemented logging. The dependency injection system of the <kbd>ILogger</kbd> interface helps us to mock the logging mechanism and validate the resulting implementation. It is essential to note that our handlers are using the extension methods of the <kbd>ILogger</kbd> interface. Let's use the ASP.NET Core implementation of the <kbd>LogInformation</kbd> extension method in the <kbd>Microsoft.Extensions.Logging</kbd> namespace as an example:</p>
<pre>using Microsoft.Extensions.Logging.Internal;<br/>using System;<br/><br/>namespace <strong>Microsoft.Extensions.Logging</strong><br/>{<br/>  /// &lt;summary&gt;ILogger extension methods for common scenarios.&lt;/summary&gt;<br/>  public static class LoggerExtensions<br/>  {<br/>        <strong>public static void LogInformation</strong>(this ILogger logger, <br/>           Exception exception, string message, params object[] args)<br/>        {<br/>              logger.Log(LogLevel.Information, exception, message, <br/>                   args);<br/>        }<br/>}</pre>
<p class="mce-root">Extension methods are <em>not</em> a mock-oriented construct. They are static methods and, by definition, it is not possible to mock a static construct in C#'s runtime. Thus, we need to provide an <em>abstraction</em> over the <kbd>ILogger</kbd> factory that allows us to inject and mock the interface that's used in our tests.</p>
<p>In general, it isn't possible to test static methods. Moreover, mock libraries typically create mocks by dynamically creating classes at runtime. Typically, they override the behavior of types by extending them. Since the static methods cannot be overridden, it isn't possible to mock them. Therefore, when we need to mock a static element, it is suggested that we abstract them and encapsulate them into classes.</p>
<p class="mce-root">Let's look at the declaration of the <kbd>LoggerAbstraction</kbd> class in the <kbd>Catalog.Fixture</kbd> project:</p>
<pre>using System;<br/>using Microsoft.Extensions.Logging;<br/><br/>namespace Catalog.Fixtures<br/>{<br/>    <strong>public abstract class LoggerAbstraction&lt;T&gt;</strong> : ILogger&lt;T&gt;<br/>    {<br/>        public IDisposable BeginScope&lt;TState&gt;(TState state) =&gt; throw <br/>            new NotImplementedException();<br/><br/>        public bool IsEnabled(LogLevel logLevel) =&gt; true;<br/><br/>        public void Log&lt;TState&gt;(LogLevel logLevel, EventId eventId, <br/>            TState state, Exception exception, Func&lt;TState, Exception,<br/>             string&gt; formatter)<br/>            =&gt; Log(logLevel, exception, formatter(state, exception));<br/><br/>       <strong> </strong><strong>public abstract void Log(LogLevel logLevel, Exception ex, <br/>            string information);</strong><br/>    }<br/>}</pre>
<p><kbd>LoggerAbstraction</kbd> is a generic class that implements the <kbd>ILogger&lt;T&gt;</kbd> interface. More specifically, the abstract class defines the <kbd>Log&lt;TState&gt;</kbd> method by executing an overloaded version of the <kbd>void Log</kbd> method. Both the <kbd>Log</kbd> method and the <kbd>LoggerAbstraction</kbd> class are abstract, which means we can mock their behavior. Thus, it is possible to mock the behavior of the logging class, as shown in the following modified version of the <kbd>ItemServiceTests</kbd> class:</p>
<pre>namespace Catalog.Domain.Tests.Services<br/>{<br/>    public class ItemServiceTests : IClassFixture&lt;CatalogContextFactory&gt;<br/>    {<br/>        private readonly ItemRepository _itemRepository;<br/>        private readonly IItemMapper _mapper;<br/>       <strong> private readonly Mock&lt;LoggerAbstraction&lt;IItemService&gt;&gt; _logger;</strong><br/>        <br/>              public ItemServiceTests(CatalogContextFactory <br/>                catalogContextFactory, <strong>ITestOutputHelper outputHelper</strong>)<br/>        {<br/>            _itemRepository = new ItemRepository<br/>    <br/>            (catalogContextFactory.ContextInstance);<br/>            _mapper = catalogContextFactory.ItemMapper;<br/>            _logger = new Mock&lt;LoggerAbstraction&lt;IItemService&gt;&gt;();<br/>           <br/>           <strong> _logger.Setup(x =&gt; x.Log(It.IsAny&lt;LogLevel&gt;(),It.IsAny      <br/>                &lt;Exception&gt;(), It.IsAny&lt;string&gt;()))</strong><br/><strong>                   .Callback((LogLevel logLevel, Exception exception, <br/>                        string information) =&gt; </strong><br/><strong>                       outputHelper.WriteLine($"{logLevel}:<br/>                            {information}"));</strong><br/>        }<br/><br/>        ...<br/>        <br/>        [Theory]<br/>        [LoadData("item")]<br/>        public async Task additem_should_log_information(AddItemRequest <br/>            request)<br/>        {<br/>            var sut = new ItemService(_itemRepository, _mapper, <br/>                _logger.Object);<br/><br/>            await sut.AddItemAsync(request);<br/><br/>           <strong> _logger</strong><br/><strong>             .Verify(x =&gt; x.Log(It.IsAny&lt;LogLevel&gt;(), It.IsAny<br/>                &lt;Exception&gt;(), It.IsAny&lt;string&gt;()), Times.AtMost(2));</strong><br/>        }<br/>        ...<br/>    }<br/>}</pre>
<p>The <kbd>ItemServiceTests</kbd> class initializes the <kbd>LoggerAbstraction&lt;IItemService&gt;</kbd> type as a class attribute. The constructor of the class uses <kbd>ITestOutputHelper</kbd> to mock the logging system that's used by the service layer:</p>
<pre> _logger.Setup(x =&gt; x.Log(It.IsAny&lt;LogLevel&gt;(),It.IsAny&lt;Exception&gt;(), <br/>    It.IsAny&lt;string&gt;()))<br/>        .Callback((LogLevel logLevel, Exception exception, string <br/>            information) =&gt; <br/>                       outputHelper.WriteLine($"{logLevel}:<br/>                          {information}"));</pre>
<p class="mce-root"><kbd>ITestOutputHelper</kbd> is an interface that's exposed by the <kbd>Xunit.Abstractions</kbd> namespace and resolved by the <kbd>Xunit</kbd> runtime. It allows us to write in the test console of the test runner. Finally, the test class implements the <kbd>additem_should_log_information</kbd> test method. The test method calls the <kbd>AddItemAsync</kbd> method that we implemented in the <kbd>ItemService</kbd> class. Finally, it is possible to verify the <kbd>ILogger</kbd> interface using the following snippet:</p>
<pre>    _logger<br/>     .Verify(x =&gt; x.Log(It.IsAny&lt;LogLevel&gt;(),It.IsAny&lt;Exception&gt;(), <br/>        It.IsAny&lt;string&gt;()), Times.AtMost(2));</pre>
<p>The preceding snippet verifies that the <kbd>Log</kbd> method is called two times. It also outputs the resulting log as part of the logging system that's defined by the <kbd>ITestOutputHelper</kbd> interface. Now that we have implemented the logging mechanism in the service layer of the <kbd>Catalog.Domain</kbd> project, we will examine and implement the necessary logging providers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing logging providers</h1>
                
            
            
                
<p>So far, we have defined <em>what</em> to log in our application; in this section, we will illustrate <em>how</em> to do this. In ASP.NET Core, the logging provider is initialized using dependency injection. Moreover, it is possible to conditionally initialize it, depending on the environment or other startup options.</p>
<p>ASP.NET Core provides some <em>built-in</em> logging providers, as shown in the following table:</p>
<table border="1" style="border-collapse: collapse;width: 90%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" style="width: 16%"><strong>Providers</strong></td>
<td class="CDPAlignCenter CDPAlign" style="width: 29.0302%"><strong>Namespace</strong></td>
<td class="CDPAlignCenter CDPAlign" style="width: 51.9698%"><strong>Description</strong></td>
</tr>
<tr>
<td style="width: 16%"><kbd>Console</kbd> </td>
<td style="width: 29.0302%"><kbd>Microsoft.Extensions.Logging.Console</kbd></td>
<td style="width: 51.9698%">
<p>Sets the console of the running application as the output of the logs.</p>
</td>
</tr>
<tr>
<td style="width: 16%"><kbd>Debug</kbd> </td>
<td style="width: 29.0302%"><kbd>Microsoft.Extensions.Logging.Debug</kbd></td>
<td style="width: 51.9698%">
<p>Writes messages in the debug output window when a debugger is attached.</p>
</td>
</tr>
<tr>
<td style="width: 16%"><kbd>EventSource</kbd> </td>
<td style="width: 29.0302%"><kbd>Microsoft.Extensions.Logging.EventSource</kbd></td>
<td style="width: 51.9698%">
<p>Sets the Windows ETW as the main log's output.</p>
</td>
</tr>
<tr>
<td style="width: 16%"><kbd>EventLog</kbd></td>
<td style="width: 29.0302%"><kbd>Microsoft.Extensions.Logging.EventLog</kbd></td>
<td>
<p>Sets the Windows event log as the main log's output.</p>
</td>
</tr>
<tr>
<td style="width: 16%"><kbd>TraceSource</kbd></td>
<td style="width: 29.0302%"><kbd>Microsoft.Extensions.Logging.TraceSource</kbd></td>
<td style="width: 51.9698%">
<p>To use this provider, ASP.NET Core needs to run on the .NET Framework. The application will use the listeners that are provided by the trace source.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>It is crucial to note that all the logging providers are complementary. Furthermore, it is possible to add many of them so that we can perform trace logging in more sources. We can configure the provider in the <kbd>Startup</kbd> class and in the <kbd>Program</kbd> class. Let's take a look at the <kbd>Program</kbd> class of <kbd>Catalog.API</kbd>:</p>
<pre>using Microsoft.AspNetCore;<br/>using Microsoft.AspNetCore.Hosting;<br/><br/>namespace Catalog.API<br/>{<br/>    public class Program<br/>    {<br/>        public static void Main(string[] args)<br/>        {<br/>            CreateWebHostBuilder(args).Build().Run();<br/>        }<br/><br/>        public static IWebHostBuilder CreateWebHostBuilder(string[] <br/>            args)<br/>        {<br/>            return <strong>WebHost.CreateDefaultBuilder(args)</strong><br/>                .UseStartup&lt;Startup&gt;();<br/>        }<br/>    }<br/>}<br/></pre>
<p>Here, the <kbd>Program</kbd> class uses <kbd>WebHost.CreateDefaultBuilder</kbd> to create the <kbd>WebHostBuilder</kbd> instance of the service. If we go further into the method, we will see that it uses the following syntax to define the log's provider:</p>
<pre>...<br/>.ConfigureLogging((Action&lt;WebHostBuilderContext, ILoggingBuilder&gt;) ((hostingContext, logging) =&gt;<br/>{<br/>  logging.AddConfiguration((IConfiguration) <br/>  hostingContext.Configuration.GetSection("Logging"));<br/>  logging.AddConsole();<br/>  logging.AddDebug();<br/>  logging.AddEventSourceLogger();<br/>}))</pre>
<p>As you can see, the <kbd>Program</kbd> class defines three built-in providers by default. Also, it uses the <kbd>Configuration</kbd> instance to pass the configurations that are described in the <kbd>appsettings.json</kbd> file.</p>
<p>Moreover, it is possible to override the default provider by explicitly calling the <kbd>ConfigureLogging</kbd> extension method in the <kbd>Program</kbd> class:</p>
<pre>...<br/>    public class Program<br/>    {<br/>          ...<br/>        public static IWebHostBuilder CreateWebHostBuilder(string[] <br/>            args)<br/>        {<br/>            return WebHost.CreateDefaultBuilder(args)<br/>              <strong>  .ConfigureLogging(builder =&gt;</strong><br/><strong>                {</strong><br/><strong>                    builder.[...]</strong><br/><strong>                })</strong><br/>                .UseStartup&lt;Startup&gt;();<br/>        }<br/>    }</pre>
<p>The preceding snippet is useful if we want to add a custom logging provider to our application. ASP.NET Core also provides us with a convenient way to configure the logging provider in the <kbd>Startup</kbd> class: it is possible to use the <kbd>AddLogging</kbd> extension method in <kbd>ConfigureServices</kbd>:</p>
<pre><br/>    public class Startup<br/>    {<br/>       ...<br/>        public void ConfigureServices(IServiceCollection services)<br/>        {<br/>            ...<br/>            <strong>services.AddLogging(builder =&gt; builder.AddConsole());</strong><br/>        }<br/><br/>       ...<br/>    }<br/>}</pre>
<p>The preceding snippet initializes the logging services on the execution of <kbd>ConfigureServices</kbd> in the <kbd>Startup</kbd> class. The initialization of the logging provider at the <kbd>Startup</kbd> level is useful when we want to initialize the log provider in terms of the environment or a specific configuration flag. Let's proceed by learning how to implement a custom logging provider.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing a custom log provider in tests</h1>
                
            
            
                
<p>As we already have seen, the logging system of ASP.NET Core is designed for maximum extensibility. In this section, we will learn how to implement a custom logging provider that we can use in our tests. All the test classes that are present in the <kbd>Catalog.API.Tests</kbd> project use <kbd>InMemoryApplicationFactory&lt;T&gt;</kbd> to run a web server and provide <kbd>HttpClient</kbd> to call the API. As you may have noticed, the tests don't return an explicit error when one of the tests fails. For example, let's examine the following test method in the  <kbd>ItemControllerTests</kbd> class:</p>
<pre>public class ItemController : IClassFixture&lt;InMemoryApplicationFactory&lt;Startup&gt;&gt;<br/>    {<br/>        ...<br/>    <br/>        [Fact]<br/>        public async Task update_should_returns_not_found<br/>            _when_item_is_not_present()<br/>        {<br/>            var client = _factory.CreateClient();<br/><br/>            var httpContent = new StringContent(jsonPayload.ToString(), <br/>            Encoding.UTF8, "application/json");<br/>            var response = await client.PutAsync($"/api/items/<br/>              {Guid.NewGuid()}", httpContent);<br/><br/>            <strong>response.StatusCode.ShouldBe(HttpStatusCode.NotFound);</strong><br/>        }<br/>        ..<br/>    }</pre>
<p>If for any reason, the call returns an error, we will receive the following message on the test side:</p>
<pre>...<br/>Shouldly.ShouldAssertException : response.StatusCode<br/> should be<br/><strong>HttpStatusCode.NotFound</strong><br/> but was<br/><strong>HttpStatusCode.InternalServerError<br/></strong>...</pre>
<p>Here, we don't know <em>why</em> the API has returned an <kbd>InternalServerError</kbd>. Here, we can use the <kbd>ITestOutputHelper</kbd> interface provided by <kbd>Xunit</kbd> to create a new logger provider and use it in our tests. To declare a logger in ASP.NET Core, we need the following structure and components:</p>
<div><img src="img/5dfecc86-0882-4390-82df-2e36edc66afb.png" style=""/></div>
<p>The preceding schema describes two main components: the <kbd>TestOutputLoggerProvider</kbd> type and the <kbd>TestOutputLogger</kbd> type. The <kbd>TestOutputLoggerProvider</kbd> type's purpose is to manage a list of logger instances. The <kbd>TestOutputLogger</kbd> class describes the actual implementation of the logging mechanism. Let's start by defining the custom <kbd>ILogger</kbd> component:</p>
<pre>using System;<br/>using Microsoft.Extensions.Logging;<br/>using Xunit.Abstractions;<br/><br/>namespace Catalog.Fixtures<br/>{<br/>    public class TestOutputLogger : ILogger<br/>    {<br/>        private readonly ITestOutputHelper _output;<br/><br/>        public TestOutputLogger(ITestOutputHelper output) =&gt;<br/>            _output = output;<br/><br/>        public IDisposable BeginScope&lt;TState&gt;(TState state) =&gt; null;<br/><br/>        public bool IsEnabled(LogLevel logLevel) =&gt;<br/>             logLevel == LogLevel.Error;<br/><br/>        public void Log&lt;TState&gt;(LogLevel logLevel, EventId eventId, <br/>             TState state, Exception exception, Func&lt;TState,<br/>             Exception, string&gt; formatter)<br/>        {<br/>            if (!IsEnabled(logLevel))<br/>                return;<br/><br/>           <strong> _output.WriteLine($"{logLevel.ToString()} - <br/>                {exception.Message} - {exception.StackTrace}");</strong><br/>        }<br/>    }<br/>}</pre>
<p><kbd>ITestOutputClass</kbd> implements the methods provided by the <kbd>ILogger</kbd> interface. First of all, it declares an <kbd>ITestOutputHelper</kbd> field in the constructor. Then, it uses the <kbd>_output</kbd> attribute inside the concrete implementation of the <kbd>Log</kbd> method by calling the <kbd>_output.WriteLine</kbd> method. The class also implements the <kbd>IsEnabled</kbd> method to check whether the log level corresponds to the <kbd>LogLevel.Error</kbd> field. If the log record doesn't do this, <kbd>LogLevel.Error</kbd> is written in the console's output. To finalize this implementation, we need a logger provider to initialize the custom logger. Let's continue by creating another class called <kbd>TestOutputLoggerProvider</kbd>, which extends the <kbd>ILoggerProvider</kbd> interface:</p>
<pre>using System.Collections.Concurrent;<br/>using Microsoft.Extensions.Logging;<br/>using Xunit.Abstractions;<br/>namespace Catalog.Fixtures<br/>{<br/>    public class TestOutputLoggerProvider : ILoggerProvider<br/>    {<br/>        private readonly ConcurrentDictionary&lt;string, TestOutputLogger&gt; <br/>            _loggers = new ConcurrentDictionary<br/>            &lt;string, TestOutputLogger&gt;();<br/>        <br/>       <strong> private readonly ITestOutputHelper _testOutputHelper;</strong><br/>        <br/>        public TestOutputLoggerProvider(ITestOutputHelper <br/>            testOutputHelper) =&gt; _testOutputHelper = testOutputHelper;<br/><br/>        public ILogger CreateLogger(string categoryName) =&gt; <br/>            _loggers.GetOrAdd(categoryName, name =&gt;  new <br/>            TestOutputLogger(_testOutputHelper));<br/><br/>        public void Dispose() =&gt; _loggers.Clear();<br/>    }<br/>}</pre>
<p><kbd>TestOutputLoggerProvider</kbd> defines a <kbd>ConcurrentDictionary</kbd>, which contains a pair of <kbd>string</kbd> and <kbd>TestOutputLogger</kbd>; it also accepts the <kbd>ITestOutputHelper</kbd> interface as an interface, which is used in the <kbd>CreateLogger</kbd> method to add the logger to the logging pipeline. By doing this, we can integrate the custom logger into our tests. We will use the <kbd>InMemoryApplicationFactory&lt;T&gt;</kbd> class, which is implemented in the <kbd>Catalog.Fixtures</kbd> project, to add the custom logger, as follows:</p>
<pre><strong>using Xunit.Abstractions;<br/></strong>...<br/><br/>namespace Catalog.Fixtures<br/>{<br/>    public class InMemoryApplicationFactory&lt;TStartup&gt;<br/>        : WebApplicationFactory&lt;TStartup&gt; where TStartup : class<br/>    {<br/>        <strong>private ITestOutputHelper _testOutputHelper;</strong><br/><strong>        public void SetTestOutputHelper(ITestOutputHelper <br/>            testOutputHelper)</strong><br/><strong>        {</strong><br/><strong>            _testOutputHelper = testOutputHelper;</strong><br/><strong>        }</strong><br/>        protected override void ConfigureWebHost(IWebHostBuilder <br/>            builder)<br/>        {<br/>            builder<br/>                .UseEnvironment("Testing")<br/>                .ConfigureTestServices(services =&gt;<br/>                {<br/>                    ...<br/>                <strong>    if (_testOutputHelper != null)</strong><br/><strong>                    {</strong><br/><strong>                        services.AddLogging(cfg =&gt; cfg.AddProvider(new <br/>                        TestOutputLoggerProvider(_testOutputHelper)));</strong><br/><strong>                    }</strong><br/>                   ...<br/>                });<br/>        }<br/>    }<br/>}</pre>
<p>The preceding class declares a new <kbd>ITestOutputHelper</kbd> attribute type and defines a setter. It is possible to add our custom logger by calling the <kbd>AddProvider</kbd> extension method inside the <kbd>ConfigureTestService</kbd> class by creating a new instance of <kbd>TestOutputLoggerProvider</kbd>. After making these changes, we can proceed by integrating the custom logger into the <kbd>ItemControllerTests</kbd> class:</p>
<pre>...<br/>namespace Catalog.API.Tests.Controllers<br/>{<br/>    public class ItemControllerTests : <br/>        IClassFixture&lt;InMemoryApplicationFactory&lt;Startup&gt;&gt;<br/>    {<br/>        <strong>private readonly InMemoryApplicationFactory&lt;Startup&gt; _factory;</strong>   <br/>      <strong>  public ItemControllerTests(InMemoryApplicationFactory&lt;Startup&gt; <br/>        factory, ITestOutputHelper outputHelper)</strong><br/><strong>        {</strong><br/><strong>            _factory = factory;</strong><br/><strong>            _factory.SetTestOutputHelper(outputHelper);</strong><br/><strong>        }<br/></strong>...</pre>
<p>As you can see, <kbd>ItemControllerTests</kbd> calls <kbd>_factory.SetTestOutputHelper</kbd> in the constructor by setting the injected <kbd>ITestOutputHelper</kbd> interface. Now, we'll get detailed error messages every time a test throws an error. It is essential to note that the <kbd>ITestOutputHelper</kbd> interface is assigned in the test class, which means this is the only point where it is possible to obtain the interface using dependency injection. In the next section, we will learn how to implement health checks related to web service dependencies.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Web service health check </h1>
                
            
            
                
<p class="mce-root">Another essential feature that's always present in web services is the <em>health checking process</em> for dependencies. In general, the health check processes are used by the CI/CD pipeline to check whether a service is healthy after its deployment or to perform the feature check-in a monitoring dashboard. Health checks are usually performed by calling HTTP routes to detect whether there are any ongoing issues in the web service.</p>
<p>Note that these services expose the health check routes. The monitoring of these health checks is implemented in an independent and separate application. Furthermore, this practice allows us to keep the services independent from the monitoring logic.</p>
<p>ASP.NET Core provides some out-of-the-box implementations to help developers add health check processes to their services. These features are implemented using a <em>middleware-oriented approach.</em> Furthermore, the health checks are exposed as HTTP endpoints, and they can be used to check the status of third-party services, databases, and data storage systems. Thus, we can test the dependencies of the service to confirm their availability and functionality.</p>
<p>The health checks feature was introduced with the <em>ASP.NET Core 2.2.0-preview1</em> version in August 2018. This feature introduced the <kbd>IHealthCheck</kbd> interface<em>.</em> In the future, it will be integrated with the <kbd>Polly</kbd> library to provide better resilience when users perform logging checks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing health checks on databases</h1>
                
            
            
                
<p>Databases are usually one of the main dependencies of a web service. Therefore, it is always essential to check the connection between the service and the database. Let's start by learning how to implement health checks using the <kbd>AspNetCore.HealthChecks.SqlServer</kbd> (<a href="https://www.nuget.org/packages/AspNetCore.HealthChecks.SqlServer/">https://www.nuget.org/packages/AspNetCore.HealthChecks.SqlServer/</a>) and <kbd>Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore</kbd> (<a href="https://www.nuget.org/packages/Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore/">https://www.nuget.org/packages/Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore/</a>) packages. We are going to apply these changes to the <em>catalog service</em> project. Let's start by adding this package to the <kbd>Catalog.API</kbd><em> </em>project:</p>
<pre><strong>dotnet add package AspNetCore.HealthChecks.SqlServer</strong></pre>
<p>The <kbd>AspNetCore.HealthChecks.SqlServer</kbd> package allows us to perform health checks on SQL Server instances. Let's proceed by registering the following services in the <kbd>Startup</kbd> class: </p>
<pre>namespace Catalog.API<br/>{<br/>    public class Startup<br/>    {<br/>        ...<br/><br/>        public void ConfigureServices(IServiceCollection services)<br/>        {<br/>            ...<br/>           <strong> services</strong><br/><strong>                .AddHealthChecks()</strong><br/><strong>                .AddSqlServer(Configuration.GetSection<br/>                ("DataSource:ConnectionString").Value);</strong><br/>            ...<br/>        }<br/><br/>        public void Configure(IApplicationBuilder app, <br/>            IWebHostEnvironment env)<br/>        {<br/>            if (!env.IsTesting())<br/>                app.ApplicationServices.GetService&lt;CatalogContext&gt;()<br/>                .Database.Migrate();<br/><br/>            app.UseAuthentication();<br/>            app.UseAuthorization();<br/>            app.UseResponseCaching();<br/>           <strong> app.UseHealthChecks("/health");</strong><br/>            ...<br/>        }<br/>    }<br/>}</pre>
<p>As you can see, the code configures the <em>health check middleware</em> using the <kbd>AddHealthChecks</kbd> extension method, which returns an <kbd>IHealthChecksBuilder</kbd> interface; it calls the <kbd>AddSqlServer</kbd> extension method provided by the builder to bind the health check with the SQL Server database. Finally, the code adds the middleware by calling the <kbd>UseHealthChecks</kbd> method and passing in the health check route. If we can call our service at the <kbd>https://&lt;hostname&gt;:&lt;port&gt;/health</kbd> route, we will receive the <kbd>Healthy</kbd>/<kbd>Unhealthy</kbd> response, depending on the connection to our data source.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing custom health checks</h1>
                
            
            
                
<p>ASP.NET Core's health check feature is not only suitable for the data source of our service; it can also be used to perform sophisticated and custom health checks. The framework provides the <kbd>IHealthCheck</kbd> interface so that we can implement our health check. Let's create a new class called <kbd>RedisCacheHealthCheck</kbd> in the <kbd>HealthCheck</kbd> folder, inside the <kbd>Catalog.API</kbd> project:</p>
<pre>using System;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Microsoft.Extensions.Diagnostics.HealthChecks;<br/>using Microsoft.Extensions.Options;<br/>using StackExchange.Redis;<br/>using Catalog.Domain.Settings;<br/><br/>namespace Catalog.API.HealthChecks<br/>{<br/>    public class RedisCacheHealthCheck : <strong>IHealthCheck</strong><br/>    {<br/>    <strong>    private readonly CacheSettings _settings;</strong><br/>        <br/>      <strong>  public RedisCacheHealthCheck(IOptions&lt;CacheSettings&gt; settings)</strong><br/><strong>        {</strong><br/><strong>            _settings = settings.Value;</strong><br/><strong>        }</strong><br/><br/>        public async Task&lt;HealthCheckResult&gt; <br/>        CheckHealthAsync(HealthCheckContext context, <br/>            CancellationToken cancellationToken = default)<br/>        {<br/>            try<br/>            {<br/>                var redis = ConnectionMultiplexer.Connect<br/>                (_settings.ConnectionString);<br/>                var db = redis.GetDatabase();<br/><br/>                var result =  await db.PingAsync();<br/>                if (result &lt; TimeSpan.FromSeconds(5))<br/>                {<br/>                    return await Task.FromResult(<br/>                        HealthCheckResult.Healthy());<br/>                }<br/>                <br/>                return await Task.FromResult(<br/>                    HealthCheckResult.Unhealthy());<br/>            }<br/>            catch (Exception e)<br/>            {<br/>                return await Task.FromResult(<br/>                    HealthCheckResult.Unhealthy(e.Message));<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>RedisCacheHealthCheck</kbd> class uses the <kbd>StackExchange.Redis</kbd> package to create a connection with the Redis instance specified in the setting's connection string. The core part of this class is the <kbd>CheckHealthAsync</kbd> method; it returns <kbd>HealthCheckResult.Healthy</kbd> or <kbd>HealthCheckResult.Unhealthy</kbd>, depending on the response time of the Redis instance. If a ping takes less than five seconds to come back, it means that the instance is healthy; otherwise, it isn't. The class is part of the ASP.NET Core stack, and it can use the dependency injection engine of the framework to solve dependencies.</p>
<p>Therefore, it is possible to add the class to the health check stack by adding the following snippet to the <kbd>ConfigureServices</kbd> method of the <kbd>Startup</kbd> class:</p>
<pre>...<br/>            services<br/>                .AddHealthChecks()<br/>               <strong> .AddCheck&lt;RedisCacheHealthCheck&gt;("cache_health_check")</strong><br/>                .AddSqlServer(Configuration.GetSection<br/>                ("DataSource:ConnectionString").Value);<br/>..</pre>
<p>This approach will add the check for the SQL Server connection and the custom check we implemented in the <kbd>RedisCacheHealthCheck</kbd> class to the middleware pipeline. If both of them succeed, the service will be classed as healthy. Futhermore it will be possible to run the catalog containers using the <kbd>docker-compose up --build</kbd> command and verify the status of the dependencies of the catalog web service by calling the <kbd>http://&lt;hostname:port&gt;/health</kbd> route.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="mce-root">In this chapter, we learned how to track the state of our services using logging. We also learned how to customize a logger provider and how to integrate it with an ASP.NET Core application. Furthermore, we dealt with the new health checking feature of ASP.NET Core and learned how to build a custom health check.</p>
<p class="mce-root">Now, you know how to implement logging in an ASP.NET Core application and create a custom logger provider. You will be able to use these skills to keep track of the data that's exposed by your services and monitor the status of your web service instance. </p>
<p class="mce-root">In the next chapter, we will learn how to bring our web service to the cloud using Azure.</p>


            

            
        
    </body></html>