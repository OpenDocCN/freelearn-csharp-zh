- en: '*Chapter 15*: Working with Modularity'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let me state at the beginning of this chapter â€“ modular application development
    is hard work! We want to split a large system into smaller modules and isolate
    them from each other. However, then we will have difficulties when integrating
    these modules and making them communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: One of the fundamental design goals of ABP Framework is modularity. It provides
    the necessary infrastructure to build truly modular systems.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will start with what modularity means and the levels of modularity
    in the .NET platform. In the largest part of the chapter, we will explore the
    Payment module that I've built for the EventHub reference solution. We will learn
    how the module is structured, the key points of application module development,
    and how to install the module into the main application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter consists of the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding modularity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the Payment module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the Payment module into EventHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can clone or download the source code of the EventHub project from GitHub:
    [https://github.com/volosoft/eventhub](https://github.com/volosoft/eventhub).'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to follow the examples in this chapter, you need to have an IDE/editor
    that supports ASP.NET Core development.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you want to create modules with the ABP CLI, you should install
    it on your computer, as explained in the *Installing the ABP CLI* section of [*Chapter
    2*](B17287_02_Epub_AM.xhtml#_idTextAnchor026), *Getting Started with ABP Framework*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding modularity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **module** is one of the most overused and overloaded concepts in the
    software industry. In this section, I want to explain what I mean by modularity
    in .NET and ABP Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modularity is a software design technique to separate a large solution''s code
    base into smaller, isolated modules that can then be developed independently.
    There are two main reasons behind modular application development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reducing complexity**: Splitting a large code base into a smaller and isolated
    set of modules makes it easy to develop and maintain the solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability**: Building a module and reusing it across multiple applications
    reduces code duplication and saves time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next sections, I will discuss two different modularity levels from technical
    and design perspectives: class libraries (NuGet packages) and application modules.
    Let''s begin with class libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: Class libraries and NuGet packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most programming languages and frameworks have the concept of a module. In general,
    a module is a set of code files (classes and other resources) developed and shipped
    (deployed) together.
  prefs: []
  type: TYPE_NORMAL
- en: A module provides some components and services for a larger application. A module
    may depend on other modules and can use the components and services provided by
    the dependent modules.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET, an assembly is a typical way to create a module. We can create a **class
    library project** and then use it within other libraries and applications. We
    can create NuGet packages for the class libraries and publish them on [NuGet.org](http://NuGet.org)
    publicly. If the library is not public, we can host a private NuGet server in
    our own company. A NuGet package system makes it extremely easy to add a library
    to a project. There are thousands of packages already published on [NuGet.org](http://NuGet.org).
  prefs: []
  type: TYPE_NORMAL
- en: ABP Framework itself is designed to be modular. It consists of hundreds of NuGet
    packages; each provides different infrastructure features for your applications.
    Some example packages are `Volo.Abp.Validation`, `Volo.Abp.Authorization`, `Volo.Abp.Caching`,
    `Volo.Abp.EntityFrameworkCore`, `Volo.Abp.BlobStoring`, `Volo.Abp.Auditing`, and
    `Volo.Abp.Emailing`. You can use any package you need in your application.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to the *Understanding modularity* section of [*Chapter 5*](B17287_05_Epub_AM.xhtml#_idTextAnchor146),
    *Exploring the ASP.NET Core and ABP Infrastructure* to learn about package-based
    ABP modules. The next section will discuss application modules, which typically
    consist of multiple packages (class library projects).
  prefs: []
  type: TYPE_NORMAL
- en: Application modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can think of an application module as a vertical slice of an application.
    An application module has the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Defines some business objects (for example, aggregates, entities, and value
    objects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements business logic for the business objects it defines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides database integration and mappings for the business objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contains application services, data transfer objects, and HTTP APIs (controllers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can have user interface components and pages related to the functionality it
    provides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: May need to add new items to the application menu, layout, or toolbars on the
    UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishes and consumes distributed events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: May have more features and other details you expect from a regular application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several *isolation levels* for an application module based on your
    requirements and goals. Four common examples are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tightly coupled modules**: A module can be a part of a large monolith application
    with a single database. You can use that module''s entities and services in other
    modules and perform database queries by joining the tables of that module. In
    this way, your modules become tightly coupled to each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bounded contexts**: A module can be a part of a large monolith application,
    but it hides its internal domain objects and database tables from other modules.
    Other modules can only use its integration services and subscribe to the events
    published by that module. They can''t use the database tables of the module in
    SQL queries. The module may even use a different kind of DBMS for its specific
    requirements. That is the bounded context pattern in domain-driven design. Such
    a module is a good candidate to convert to a microservice if you want to convert
    your monolith application to a microservice solution in the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generic modules**: Generic modules are designed to be application-independent.
    They can be integrated into different kinds of applications. The application that
    uses the generic module can have some functionalities depending on that module,
    and it may need some integration code. A generic module may provide some options
    and customization points but doesn''t make assumptions about the final application.
    Infrastructure modules, such as identity management and multi-language modules,
    fall into this category. Also, the Payment module, which is explained in the *Building
    the Payment module* section, is a generic module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plugin modules**: A plugin module is a completely isolated and reusable application
    module. Other modules have no direct dependency on that module. You can easily
    add this module to or remove it from an existing solution without affecting the
    other modules and your application. If other modules need to use that module,
    they use some standard abstractions provided in a shared library. In this case,
    the module implements the abstractions and can be replaced by another module that
    implements the same abstractions. Even if the other modules use that module somehow,
    they can continue to work as expected when removing that module. That means the
    module should be optional and removable for the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One of ABP Framework''s main goals is to provide a convenient infrastructure
    to develop any kind of application module. It provides the necessary infrastructure
    details to build a truly modular system. It also provides some pre-built application
    modules you can directly reuse in your applications. Some examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An **account module** provides authentication features, such as login, register,
    forgot password, and social login integrations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **identity module** manages users, roles, and their permissions in your system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **tenant management** module allows you to create and manage tenants in an
    SaaS/multi-tenant system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **CMS Kit** module can be used to add fundamental **Content Management System**
    (**CMS**) features into your application, such as pages, tags, comments, and blogs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Account, identity, tenant management, and some other modules are pre-installed
    (as NuGet packages) when creating a new ABP solution.
  prefs: []
  type: TYPE_NORMAL
- en: All pre-built modules are designed to be extensible and customizable. However,
    if you need to fully change a module based on your requirements, it is always
    possible to download the module's source code and include it in your solution.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to build a new application module with
    its own entities, services, and pages.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Payment module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can already investigate the source code of the pre-built ABP modules to
    see how they are built and used in your application. I suggest it because you
    can see different implementation details of modular development. However, this
    section will explore the Payment module, which has been created as a simple yet
    real-world example for this book. It is used by the EventHub solution to receive
    payment when an organization wants to upgrade to a premium account. It is not
    possible to show the step-by-step development of that module in a book. We will
    investigate the fundamental points so that you can understand the module structure
    and build your own modules. Let's start with creating a new application module.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new application module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ABP CLI''s `new` command provides an option to create a new solution to
    build a reusable application module. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve specified to use the module template (`-t module`) with the module name
    as `Payment`. If you open the solution, you will see the solution structure, as
    shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 â€“ A fresh application module created by the ABP CLI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.1_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.1 â€“ A fresh application module created by the ABP CLI
  prefs: []
  type: TYPE_NORMAL
- en: 'The module startup template has too many projects because it supports multiple
    UI and database options and contains some test/demo projects. Let''s eliminate
    some of the projects:'
  prefs: []
  type: TYPE_NORMAL
- en: The projects in the `host` folder are some demo applications to run the module
    in different architecture options. These projects are not parts of the module
    and are just for manual testing. We will install this module into the EventHub
    solution and test it there, so I deleted all host projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I deleted the `Blazor.*` projects since my main UI will be MVC/Razor Pages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I deleted the MongoDB-related projects since I only want to support EF Core
    with my module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, I deleted the `angular` folder (not shown in *Figure 15.1*) since I
    don't want an Angular UI for this module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the cleanup, there are 12 projects in the module solution. Four of them
    are for unit and integration testing, so the module consists of eight projects
    that will be deployed. These eight projects are class library projects, so they
    can''t be run individually. They need to be used by an executable application,
    such as EventHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 â€“ The Payment module after the cleanup'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.2_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.2 â€“ The Payment module after the cleanup
  prefs: []
  type: TYPE_NORMAL
- en: This solution structure and layers were already explained in the *Structuring
    a .NET solution based on DDD* section of [*Chapter 9*](B17287_09_Epub_AM.xhtml#_idTextAnchor300),
    *Understanding Domain-Driven Design*. So, I won't repeat it all here. However,
    we will change this structure because we want to provide multiple application
    layers for the Payment module.
  prefs: []
  type: TYPE_NORMAL
- en: Restructuring the Payment module solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will install this Payment module to the EventHub solution. Remember from
    [*Chapter 4*](B17287_04_Epub_AM.xhtml#_idTextAnchor130), *Understanding the Reference
    Solution*, that the EventHub solution has two UI applications:'
  prefs: []
  type: TYPE_NORMAL
- en: A public website that the end users of the system use to create and attend events.
    This application has an MVC/Razor Pages UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An admin web application that is used by the administrative users of the EventHub
    system. This application is a Blazor WebAssembly application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To support the same architecture, we will provide two UI application layers
    for the Payment module:'
  prefs: []
  type: TYPE_NORMAL
- en: An application layer with the MVC/Razor Pages UI that is used by the EventHub
    public website. End users will make payments with that UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An application layer with the Blazor WebAssembly UI that is used by the EventHub
    admin application. Administrative users will see the payment reports with that
    UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows the final Payment solution structure after I added
    the admin-side layers and organized the solution folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3 â€“ The Payment module solution with admin-side'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.3_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.3 â€“ The Payment module solution with admin-side
  prefs: []
  type: TYPE_NORMAL
- en: I added the `Payment.Admin.Application`, `Payment.Admin.Application.Contracts`,
    `Payment.Admin.Blazor`, `Payment.Admin.HttpApi`, and `Payment.Admin.HttpApi.Client`
    projects. I also added the `Payment.BackgroundServices` project to perform some
    periodic background workers.
  prefs: []
  type: TYPE_NORMAL
- en: The solution folders reflect the overall structure â€“ the `admin` application
    (with Blazor UI) and `www` (public) application (with MVC/Razor Pages UI). The
    `common` folder is used in both applications, so we share the same domain layer
    and database integration code.
  prefs: []
  type: TYPE_NORMAL
- en: We've learned about the overall structure of the Payment solution. In the next
    section, you will learn the details of the payment process.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the payment process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The only responsibility of the Payment module is to take a payment from the
    user. It internally uses PayPal as the payment gateway. The Payment module is
    generic and can be used by any kind of application. The application that uses
    the Payment module should include some integration logic that starts the payment
    process and handles the payment result. In this section, I will explain the process
    based on the EventHub integration.
  prefs: []
  type: TYPE_NORMAL
- en: The EventHub application uses the Payment module to get a payment from a user
    to upgrade a free organization account to a premium organization account. As you
    can guess, premium organizations have more rights in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are the owner of an organization and visit the organization details
    page, you will see an **Upgrade to Premium** button on the page, as shown in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 â€“ The EventHub organization details page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.4_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.4 â€“ The EventHub organization details page
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on the **Upgrade to Premium** button, you are redirected to
    the pricing page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5 â€“ The EventHub pricing page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.5_B17287.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.5 â€“ The EventHub pricing page
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see the account types and their differences. When we click the
    **Upgrade to Premium** button here, we are redirected to the pre-checkout page,
    which is defined by the Payment module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6 â€“ The pre-checkout page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.6_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.6 â€“ The pre-checkout page
  prefs: []
  type: TYPE_NORMAL
- en: The pre-checkout page is normally located inside the Payment module and is developed
    to be application-independent. We can redirect the user to the pre-checkout page
    with a URL such as `/Payment/PreCheckout?paymentRequestId=3a002186-cb04-eb46-7310-251e45fc6aed`.
    However, we should first obtain a payment request ID using the `CreateAsync` method
    of the `IPaymentRequestAppService` service. This is done in the `Pages/Pricing.cshtml.cs`
    file of the `EventHub.Web` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The EventHub application overrides the view (UI) part to make it fit better
    into EventHub''s UI design. This is an example of customizing a module in a final
    application. The EventHub application defines `PreCheckout.cshtml` and `PostCheckout.cshtml`
    files under the `Pages/Payment` folder, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7 â€“ Overriding the Payment module''s checkout views'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.7_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.7 â€“ Overriding the Payment module's checkout views
  prefs: []
  type: TYPE_NORMAL
- en: They automatically override the corresponding Payment pages (because they are
    located exactly within the same path defined by the Payment module). These pages
    have no `.cshtml.cs` files here because we don't want to change the behavior of
    the page; we just want to change the view side.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the main components and the flow used for the payment
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8 â€“ The payment flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.8_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.8 â€“ The payment flow
  prefs: []
  type: TYPE_NORMAL
- en: When we click the **Upgrade to Premium** button on the Pricing page (in *Figure
    15.5*), it redirects to the Checkout page of the Payment module. When we click
    the **Checkout** button (in *Figure 15.6*) on that page, we are redirected to
    PayPal, the payment system used and integrated by the Payment module. Once we
    complete the payment on PayPal, we are redirected back to the post-checkout page
    of the application, which shows a thank you message to the user.
  prefs: []
  type: TYPE_NORMAL
- en: When a payment process succeeds, the Payment module publishes a distributed
    event named `PaymentRequestCompletedEto` (defined in the `Payment.Domain.Shared`
    project). The EventHub application subscribes to this event (with the `PaymentRequestEventHandler`
    class inside the `EventHub.Domain` project). It finds the user and organization
    related to the completed payment, upgrades the organization, and sends an email
    to thank the user for upgrading the account.
  prefs: []
  type: TYPE_NORMAL
- en: There can be an error when returning from PayPal to our application in some
    rare cases, where we cannot know whether the payment process has succeeded. For
    such cases, the Payment module provides a `PaymentRequestController` (in the `Payment.HttpApi`
    project). If the operation succeeds, the same `PaymentRequestCompletedEto` event
    is published so that the EventHub application can upgrade the organization account
    asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how the Payment module provides options to
    configure it.
  prefs: []
  type: TYPE_NORMAL
- en: Providing configuration options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Payment module uses PayPal, so it needs the PayPal account information
    that the application must configure. It follows the options pattern (see the *Implementing
    the options pattern* section of [*Chapter 5*](B17287_05_Epub_AM.xhtml#_idTextAnchor146),
    *Exploring the ASP.NET Core and ABP Infrastructure*) and provides the `PayPalOptions`
    class that can be configured by the application, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We generally get the values from the configuration (the `appsettings.json`
    file). The Payment module can get the option values from the `Payment:PayPal`
    key if you''ve defined it, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is made possible with the following code, located in the `PaymentDomainModule`
    class of the `Payment.Domain` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Getting the values from the configuration by default is a good practice.
  prefs: []
  type: TYPE_NORMAL
- en: I've introduced the main points of the Payment module's structure. Its code
    base is not so different from a typical ABP application. You can explore its source
    code to understand how it internally works. In the next section, we will see how
    it is installed in the EventHub application.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Payment module into EventHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A module itself is not a runnable project. It should be installed into a larger
    application and work as part of it. In this section, we will see how the Payment
    module is installed in the EventHub solution.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the project dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Payment module consists of more than 10 projects in its solution (see *Figure
    15.3*). Similarly, the EventHub solution has a lot of projects with three applications
    â€“ the admin-side, the public, and the account (`IdentityServer`) applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'I want to integrate the Payment module into the EventHub solution in all layers.
    Typically, each layer of the EventHub solution should depend on (use) the corresponding
    layer of the Payment module. The following table shows all the dependencies of
    the EventHub projects to the Payment module projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9 â€“ EventHub and Payment module project dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.9_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.9 â€“ EventHub and Payment module project dependencies
  prefs: []
  type: TYPE_NORMAL
- en: So, we should add project references one by one. For example, we add the `Payment.Domain`
    project dependency to the `EventHub.Domain` project. This way, we can use Payment
    module entities in our application's domain layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio doesn''t properly support adding a local project dependency to
    a project from outside of a solution (I call it an external project dependency).
    However, we can manually add `ProjectReference` elements into the `csproj` file
    of the target project. So, we can add the following line into the `EventHub.Domain.csproj`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When we add such an external project dependency, Visual Studio cannot automatically
    resolve it. We should open a command-line terminal and run the `dotnet restore`
    command. This command is only required when you add a new dependency or remove
    an existing dependency. In addition, if you want to build the EventHub solution
    with the Payment module, you can use the `dotnet build /graphBuild` command. While
    this is rarely needed, it can save the day when Visual Studio cannot resolve some
    types in the dependent module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we add a project reference, we should also add the ABP module dependency.
    The following code block shows the `PaymentDomainModule` dependency of the `EventHubDomainModule`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We should manually set up all the project dependencies, as explained here. The
    next step is to configure the database tables for the Payment module.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the database integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Payment module needs some database tables to work properly. We can use the
    main EventHub database to store the Payment module's tables. With this approach,
    we will have a single database for the system. Alternatively, we can create a
    separate database for the Payment module so that we have two databases. The EventHub
    solution prefers the first approach since it is simpler to implement and manage.
    However, I will also show how we would implement the separate database approach.
    Let's begin with the single database approach.
  prefs: []
  type: TYPE_NORMAL
- en: Using a single database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, I will show you how we create the Payment tables in the main
    database of the EventHub application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The EventHub solution has an `EventHubDbContext` class inside the `EventHub.EntityFrameworkCore`
    project, which is the main class that maps the entities to the database tables.
    The Payment module defines a `ConfigurePayment` extension method that we call
    from the `OnModelCreating` method of our `DbContext` class to include the Payment
    database mapping model in our main database model (see the `EventHubDbContext`
    class in the `EventHub.EntityFrameworkCore` project):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `builder.ConfigurePayment()` is defined by the Payment module (in the
    `PaymentDbContextModelCreatingExtensions` class of the `Payment.EntityFrameworkCore`
    project). After adding this line inside the `OnModelCreating` method, we can add
    a new database migration to the EventHub solution using the following command
    in a command-line terminal (we run this command in the `root` folder of the `EventHub.EntityFrameworkCore`
    project):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates a new migration file. Then, we can apply the new migration
    against the database using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That's all. The Payment module will use the main EventHub database to store
    its data. This way, we will have a single database that contains all the tables
    of the application. In the next section, we will discuss the separate database
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Using a separate database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will see how to change the EventHub solution to use a separate
    database for the Payment module. The EventHub solution uses PostgreSQL as the
    database provider. We will use Microsoft's SQL Server for the Payment module.
    This way, you will learn how to work with multiple database providers in a single
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'I made the changes in a separate branch and created a draft **Pull Request**
    (**PR**) on GitHub so that you can see all the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub branch URL: [https://github.com/volosoft/eventhub/tree/payment-sepr-db](https://github.com/volosoft/eventhub/tree/payment-sepr-db)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PR URL: [https://github.com/volosoft/eventhub/pull/74](https://github.com/volosoft/eventhub/pull/74)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, I will point out the fundamental changes I've made. You can see the PR
    on GitHub for all the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, I''ve created a second `DbContext` class, named `EventHubPaymentDbContext`,
    in the `EventHub.EntityFrameworkCore` project to manage the database migrations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This class replaces `IPaymentDbContext` (defined by the Payment module) using
    the `[ReplaceDbContext]` attribute and implementing the `IPaymentDbContext` interface.
    It also declares the `[ConnectionStringName]` attribute to use the `Payment` connection
    string name instead of `Default` in the `appsettings.json` files. Finally, it
    calls the `modelBuilder.ConfigurePayment()` extension method of the Payment module
    to configure the database mappings.
  prefs: []
  type: TYPE_NORMAL
- en: The Payment module was designed to be independent of any specific `Volo.Abp.EntityFrameworkCore`
    package, which is DBMS-agnostic. Since I wanted to use a SQL Server database,
    I've added the `Volo.Abp.EntityFrameworkCore.SqlServer` package dependency to
    the `EventHub.EntityFrameworkCore` project. I also added `AbpEntityFrameworkCoreSqlServerModule`
    to the `DependsOn` attribute of the `EventHubEntityFrameworkCoreModule` class
    since ABP requires it.
  prefs: []
  type: TYPE_NORMAL
- en: 'EF Core''s command-line tool requires creating a `DbContext` factory class
    to create an instance of the related `DbContext` class when we run its commands.
    You can see the `EventHubPaymentDbContextFactory` class in the source code. It
    uses the `Payment` connection string and the `UseSqlServer` extension method to
    configure SQL Server as the database provider. With this change, we should add
    the `Payment` connection string in the `EventHub.DbMigrator` project''s `appsettings.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: ABP will automatically obtain the `Payment` connection string for the new `DbContext`
    class because it has the `ConnectionStringName` attribute (the value of `PaymentDbProperties.ConnectionStringName`
    is `Payment`). I also need to add the `Payment` connection string to all the `appsettings.json`
    files in which I have defined the `Default` connection string.
  prefs: []
  type: TYPE_NORMAL
- en: 'I should register the new `EventHubPaymentDbContext` class to the dependency
    injection system and configure it. To do that, I''ve changed the `ConfigureServices`
    method of the `EventHubEntityFrameworkCoreModule` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `AddAbpDbContext<EventHubPaymentDbContext>()` call registers the new `DbContext`
    class. I also added the `Configure<EventHubPaymentDbContext>(â€¦)` block to use
    SQL Server for this `DbContext` class. Other `DbContext` classes will continue
    to use PostgreSQL (the `UseNpgsql()` call globally configures all `DbContext`
    classes).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EventHub.DbMigrator` application executes database migrations for the
    main database. Now, we''ve got a second database and we want to change the `EventHub.DbMigrator`
    application so that it also executes database migrations for the Payment module''s
    database. The change is simple; I''ve added the following code block inside the
    `EntityFrameworkCoreEventHubDbSchemaMigrator` class''s `MigrateAsync` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This class is used by the `EventHub.DbMigrator` application while migrating
    the databases. So, by adding this code block, the new database is also migrated
    when I run the `EventHub.DbMigrator` application.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final change, I will remove the Payment tables from the main EventHub
    database and the following line from the `EventHubDbContext` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, I can use EF Core''s command-line tool to create a database migration
    (in the `root` folder of the `EventHub.EntityFrameworkCore` project):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Differing from standard usage, I added the `--context EventHubDbContext` parameter.
    I specify the `DbContext` type because there are two `DbContext` classes in the
    `EventHub.EntityFrameworkCore` project. Once it creates the migration (which drops
    the Payment tables), I can apply changes to the database using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the main database has no Payment tables. But we haven''t created the payment
    database yet. To do that, I can use EF Core''s command-line tool to create a database
    migration for the payment database (in the `root` folder of the `EventHub.EntityFrameworkCore`
    project):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, in addition to the `context` parameter that specifies the `EventHubPaymentDbContext`
    type, I set the `output-dir` parameter to specify the folder to create the migrations
    classes in it. The default folder name is `Migrations`, but this is used by the
    `EventHubDbContext` class, so I can''t use it. I specify `MigrationsPayment` as
    the folder name. The following figure shows the new migration folder in the `EventHub.EntityFrameworkCore`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10 â€“ The migration folder for the Payment module'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.10_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.10 â€“ The migration folder for the Payment module
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I can use the following command (in the `root` folder of the `EventHub.EntityFrameworkCore`
    project):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If I check the database, I can see the Payment module''s table (it has a single
    database table):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11 â€“ The Payment module''s table in its own database'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.11_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.11 â€“ The Payment module's table in its own database
  prefs: []
  type: TYPE_NORMAL
- en: The separate database configuration is done. Now, the Payment module will use
    the new SQL Server database while the rest of the application will continue to
    work with the main PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Using DbMigrator
  prefs: []
  type: TYPE_NORMAL
- en: I've used the `dotnet ef` command-line tool to update the database schema. However,
    we can also run the `DbMigrator` application to apply the changes to the databases.
    Since we've also changed the `EntityFrameworkCoreEventHubDbSchemaMigrator` class
    to support the second database, `DbMigrator` can migrate the database schemas
    for both databases.
  prefs: []
  type: TYPE_NORMAL
- en: By creating new migration `DbContext` classes, as explained here, you can set
    up other modules to use their own databases. I added the new `DbContext` class
    in the same `EventHub.EntityFrameworkCore` project; however, we could create a
    new project for the new `DbContext` class and manage the migrations inside it.
    In that case, we don't need to specify the context and the `output-dir` parameters
    for the EF Core commands. However, I suggest going with a single project to minimize
    the projects within the solution, as it already has a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I started by explaining what modularity means and what bounded
    context, tightly coupled, generic, and plugin modules are. We've learned how to
    create a new module using the ABP CLI.
  prefs: []
  type: TYPE_NORMAL
- en: We then explored the structure of the Payment module and understood how it is
    integrated into the EventHub solution. We've learned the steps of manually installing
    the Payment module to the EventHub solution by setting up the project dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we've seen two approaches to using the payment database tables. The
    single database approach is simple and shares the same database between the EventHub
    application and the Payment module. On the other hand, the separate database approach
    allows us to use a dedicated database for the payment tables, making it possible
    to use a different DBMS for the Payment module than the main application.
  prefs: []
  type: TYPE_NORMAL
- en: 'I suggest checking the source code of the Payment module and the EventHub solutions
    to understand all the details of their structure. I also suggest you check the
    ABP documentation to understand modularity better and learn the best practices
    to build reusable, generic application modules: [https://docs.abp.io/en/abp/latest/Best-Practices/Index](https://docs.abp.io/en/abp/latest/Best-Practices/Index).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore multi-tenancy, which is used to build SaaS
    applications.
  prefs: []
  type: TYPE_NORMAL
