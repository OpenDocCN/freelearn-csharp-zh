<html><head></head><body>
        

                            
                    <h1 class="header-title">Playing with Physics and Fire</h1>
                
            
            
                
<p class="calibre3">In this chapter, we will use physics and other Unity features to build variations of an interactive ball game. Along the way, we explore managing objects, Rigidbody physics, and adding more interactivity to the virtual experience. You will see how properties and materials based on physics can be added to objects, as well as more on C# scripting, particle effects, and music.</p>
<p class="calibre3">In this chapter, you will learn about the following topics:</p>
<ul class="calibre11">
<li class="calibre12">The Unity physics engine, the Unity Rigidbody component, and Physic Materials</li>
<li class="calibre12">Using velocity and gravity</li>
<li class="calibre12">Managing object lifetime and object pooling</li>
<li class="calibre12">Interacting with objects in VR using your head and hands</li>
<li class="calibre12">Building a fireball using particle effects</li>
<li class="calibre12">Synchronizing with music </li>
</ul>
<p>Note that the projects in this chapter are separate and are not directly required by the other chapters in this book. If you decided to skip any of it or not save your work, that's OK.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unity physics</h1>
                
            
            
                
<p class="calibre3">In Unity, the behavior of an object that is based on physics is defined separately from its mesh (shape), materials (UV texture), and the renderer properties. The items that play into physics include the following:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Rigidbody</strong>: Enables the object to act under the control of the physics engine, receive forces and torque to move in a realistic way</li>
<li class="calibre12"><strong class="calibre1">Collider</strong>: Defines a simplified, approximated shape of the object used for calculating collisions with other objects</li>
<li class="calibre12"><strong class="calibre1">Physic Material</strong>: Defines friction and bounce effects of colliding objects</li>
<li class="calibre12"><strong class="calibre1">Physics Manager</strong>: Applies global settings for 3D physics for your project</li>
</ul>
<p class="calibre3">Basically, physics (in this context) is defined by the positional and rotational forces that affect the transform of an object, such as gravity, friction, momentum, and collisions with other objects. It is not necessarily a perfect simulation of physics in the real world because it's optimized for performance and separation of concerns to facilitate animation. Besides, virtual worlds might just need their own laws of physics that aren't found in our God-given universe!</p>
<p class="calibre3">Unity integrates the <strong class="calibre5">NVIDIA PhysX</strong> engine, a real-time physics calculation middleware, which implements classical Newtonian mechanics for games and 3D applications. This multiplatform software is optimized to utilize fast hardware processors when present. It is accessible via the Unity scripting API.</p>
<p class="calibre3">A key to physics is the Rigidbody component that you add to objects. Rigidbodies have parameters for gravity, mass, and drag, among others. Rigidbodies can automatically react to gravity and collisions with other objects. No extra scripting is needed for this. During gameplay, the engine calculates each rigid object's momentum and updates its transform position and rotation.</p>
<p>Details on Rigidbodies can be found at <a href="http://docs.unity3d.com/ScriptReference/Rigidbody.html" class="calibre20">http://docs.unity3d.com/ScriptReference/Rigidbody.html</a>.</p>
<p class="calibre3">Unity projects have a global gravity setting, found in the project's Physics Manager by navigating to Edit | Project Settings | Physics. As you might expect, the default gravity setting is a Vector3 with values (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">-9.81</kbd>, <kbd class="calibre13">0</kbd>) that apply a downward force to all Rigidbodies. Gravity is in meters per second squared.</p>
<p>Rigidbodies can automatically react to gravity and collisions with other objects. Extra scripting is not needed for this.</p>
<p class="calibre3">In order to detect a collision, both the colliding objects must have a <kbd class="calibre13">Collider</kbd> component. There are built-in colliders with basic geometric shapes such as a cube, sphere, cylinder, and a capsule. A mesh collider can assume an arbitrary shape. If you can, it's best to use one or more basic collider shapes that approximately fit the actual object, rather than a mesh collider to reduce the expense of calculating the actual collisions during gameplay. Unity requires that if your object will be used in physics and has a Rigidbody, then its mesh collider must be marked as convex and be limited to 255 triangles.</p>
<p class="calibre3">When rigid objects collide, the forces pertinent to each object in the collision are applied to the others. The values of the resulting forces are calculated based on the objects' current velocity and body mass. Other factors are also taken into consideration, such as gravity and drag (that is, resistance). Furthermore, you have options to add constraints to freeze the position or rotation of a given object in any of its <em class="calibre14">x</em>, <em class="calibre14">y</em>, and <em class="calibre14">z</em> axes.</p>
<p class="calibre3">The calculations can be further affected when a Physic Material is assigned to the object's collider, which adjusts the friction and the bounciness effects of the colliding objects. These properties will be applied only to the object that owns the Physic Material. (Note that it's really spelled <em class="calibre14">Physic Material</em> rather than <em class="calibre14">Physics Material</em> for historical reasons.)</p>
<p class="calibre3">So, let's say that Object A (Ball) hits Object B (Brick). If Object A has bounciness and Object B does not, Object A will have an impulse applied in the collision, but Object B will not. However, you have options to determine how their friction and bounciness combine, as we'll see next. It's not necessarily an accurate simulation of real-world physics. It's a game engine, not a computer-aided engineering modeler.</p>
<p class="calibre3">From a scripting point of view, Unity will trigger events when objects collide (<kbd class="calibre13">OnTriggerEnter</kbd>), each frame while objects are colliding (<kbd class="calibre13">OnTriggerStay</kbd>), and when they've stopped colliding (<kbd class="calibre13">OnTriggerExit</kbd>).</p>
<p class="calibre3">If this sounds daunting, read on. The rest of this chapter breaks it down into understandable bits and pieces.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bouncy balls</h1>
                
            
            
                
<p class="calibre3">The feature we'll implement here is, when a ball drops from mid-air and hits the ground, it bounces back up and down, and up again, diminished over time.</p>
<p class="calibre3">We are going to start simply with a new scene that consists of a ground plane and a sphere. Then, we'll add physics to it, a bit at a time, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Create a new scene by navigating to File | New Scene.</li>
<li class="calibre12">Then, navigate to File | Save Scene As... and name it <kbd class="calibre13">BallsFromHeaven</kbd>.</li>
<li class="calibre12">Create a new plane by navigating to GameObject | 3D Object | Plane and reset its transform using the <kbd class="calibre13">Transform</kbd> component's <em class="calibre2">gear</em> icon | Reset.</li>
<li class="calibre12">Create a new sphere by navigating to GameObject | 3D Object | Sphere and rename it <kbd class="calibre13">BouncyBall</kbd>.</li>
<li class="calibre12">Set its Scale to (<kbd class="calibre13">0.5</kbd>, <kbd class="calibre13">0.5</kbd>, <kbd class="calibre13">0.5</kbd>) and Position to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">5</kbd>,<kbd class="calibre13">0</kbd>) so that it's above the center of the plane.</li>
<li class="calibre12">Drag the Red material from Project Assets (created in <a href="b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml" target="_blank" class="calibre10">Chapter 2</a>, <em class="calibre2">Content, Objects and Scale</em>) onto it so that it looks like a bouncy ball.</li>
</ol>
<p class="calibre3">The new Unity scene defaults come with Directional Light and Main Camera. It's OK to use this Main Camera for the time being.</p>
<p class="calibre3">Click on the <em class="calibre14">Play</em> button. Nothing happens. The ball just sits in mid-air and doesn't move.</p>
<p class="calibre3">Now, let's give it a Rigidbody, as follows:</p>
<ol class="calibre15">
<li class="calibre12">With <kbd class="calibre13">BouncyBall</kbd> selected, in Inspector, navigate to Add Component | Physics | Rigidbody.</li>
<li class="calibre12">Click on the <em class="calibre2">Play</em> button. It drops like a lead balloon.</li>
</ol>
<p class="calibre3">Let's make it bounce, as follows:</p>
<ol class="calibre15">
<li class="calibre12">In the Project panel, select the top-level Assets folder, navigate to Create | Folder, and rename it to <kbd class="calibre13">Physics</kbd></li>
<li class="calibre12">With the <kbd class="calibre13">Physics</kbd> folder selected, create a material by navigating to Assets | Create | Physic Material (or right-click within the folder)</li>
<li class="calibre12">Name it <kbd class="calibre13">Bouncy</kbd></li>
<li class="calibre12">Set its Bounciness value to <kbd class="calibre13">1</kbd></li>
<li class="calibre12">With the <kbd class="calibre13">BouncyBall</kbd> sphere selected in Hierarchy, drag the <kbd class="calibre13">Bouncy</kbd> asset from Project onto the sphere's Collider material field in Inspector</li>
</ol>
<p class="calibre3">Click on the <em class="calibre14">Play</em> button. It bounces, but it does not go very high. We used the maximum value for Bounciness as <kbd class="calibre13">1.0</kbd>. What's slowing it down? It's not the Friction settings. Rather, the Bounce Combine is set to Average, which determines how much of the bounciness of the ball (1) is mixed with that of the plane (0). So, it diminishes rapidly over time. We want the ball to retain all its bounciness. We will accomplish this, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Change the <kbd class="calibre13">Bouncy</kbd> object's Bounce Combine to Maximum.</li>
<li class="calibre12">Click on the <em class="calibre2">Play</em> button.</li>
</ol>
<p class="calibre3">Much better. Actually, too much better. The ball keeps bouncing back up to its original height, ignoring gravity. Now, change the Bounciness to <kbd class="calibre13">0.8</kbd>. The bounces diminish, and the ball will eventually come to a stop.</p>
<p class="calibre3">Let's check it out in VR, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Delete the default Main Camera from the Hierarchy root.</li>
<li class="calibre12">Drag the <kbd class="calibre13">MeMyselfEye</kbd> prefab from Project Assets into the scene. Set its Position to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">-4</kbd>).</li>
</ol>
<p class="calibre3">Run it in VR. Pretty neat! Even the simplest things look impressive in VR.</p>
<p>Unity's Standard Assets package includes a handful of example physic materials, including Bouncy, Ice, Meta, Rubber, and Wood.</p>
<p class="calibre3">OK, let's have some fun. Make it rain bouncy balls! To do this, we'll make the ball a prefab and write a script that instantiates new balls, dropping them from random positions, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Drag the <kbd class="calibre13">BouncyBall</kbd> object from Hierarchy into the <kbd class="calibre13">Project Assets/Prefabs</kbd> folder, making it a prefab.</li>
<li class="calibre12">Delete the <kbd class="calibre13">BouncyBall</kbd> object from the Hierarchy, since we'll be instantiating it with a script.</li>
<li class="calibre12">Create an empty game controller object to attach the script to by navigating to GameObject | Create Empty. Rename it <kbd class="calibre13">GameController</kbd>.</li>
<li class="calibre12">In Inspector, navigate to Add Component | New Script, name it <kbd class="calibre13">BallsFromHeaven</kbd>, and open the script for editing.</li>
</ol>
<p class="calibre3">Edit the script so that it looks like this:</p>
<pre class="calibre18">using UnityEngine; 
 
public class BallsFromHeaven : MonoBehaviour <br class="title-page-name"/>{ 
  public GameObject ballPrefab; 
  public float startHeight = 10f; 
  public float interval = 0.5f; 
 
  private float nextBallTime = 0f; 
 
  void Update () <br class="title-page-name"/>  { 
    if (Time.time &gt; nextBallTime) <br class="title-page-name"/>    { 
      nextBallTime = Time.time + interval; 
      Vector3 position = new Vector3( Random.Range (-4f, 4f), <br class="title-page-name"/>         startHeight, Random.Range (-4f, 4f) ); 
      Instantiate( ballPrefab, position, Quaternion.identity ); 
    } 
  } 
} </pre>
<p class="calibre3">The script drops a new ball from <kbd class="calibre13">startHeight</kbd> at the rate of every <kbd class="calibre13">interval</kbd> seconds (an interval of 0.5 means that a new ball is dropped every half second). The new ball position is at a random X-Z coordinate between <kbd class="calibre13">-4</kbd> and <kbd class="calibre13">4</kbd>. The <kbd class="calibre13">Instantiate()</kbd> function adds a new ball into the scene Hierarchy.</p>
<p class="calibre3">Save the script. We now need to populate the Ball field with the <kbd class="calibre13">BouncyBall</kbd> prefab, as follows:</p>
<ol class="calibre15">
<li class="calibre12">With <kbd class="calibre13">GameController</kbd> selected in Hierarchy, drag the <kbd class="calibre13">BouncyBall</kbd> prefab from the <kbd class="calibre13">Project Assets/Prefabs</kbd> folder onto the Ball Prefab slot in the Balls From Heaven (Script) panel in Inspector.</li>
<li class="calibre12">Be sure to use the <kbd class="calibre13">BouncyBall</kbd> prefab from Project Assets so that can be instantiated.</li>
<li class="calibre12">Save the scene. Run it in VR. Fun!</li>
</ol>
<p class="calibre3">This is what I get:</p>
<div><img class="calibre24" src="img/e7f360b3-958d-4b64-9112-97115152fc74.png"/></div>
<div><p class="calibre3">In summary, we created a sphere with a Rigidbody and added a Physic Material with a Bounciness property of <kbd class="calibre13">0.8</kbd> and Bounce Combine to Maximum. Then, we saved the <kbd class="calibre13">BouncyBall</kbd> as a prefab and wrote a script to instantiate new balls that drop from above.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Managing game objects</h1>
                
            
            
                
<p class="calibre3">Whenever you have a script that instantiates objects, you must be aware of the life cycle of the object and possibly arrange to destroy it when it is no longer needed. You can destroy game objects, for example, after it is no longer visible in the scene, or after a specific life duration, or limit the scene to a maximum number of balls. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Destroying fallen objects</h1>
                
            
            
                
<p class="calibre3">In our scene, we have a limited size ground plane and as balls hit one another, some will fall off the plane into oblivion. At that point, we can remove the fallen ball from the scene. Watch the Hierarchy panel as new balls are instantiated. Note that some balls end up bouncing off the plane platform but remain in the Hierarchy panel. We need to clean this up by adding a script that destroys the balls that are out of play, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Select the <kbd class="calibre13">BouncyBall</kbd> prefab in <kbd class="calibre13">Project Assets/Prefabs</kbd></li>
<li class="calibre12">Navigate to Add Component | New Script and name it <kbd class="calibre13">DestroyBall</kbd></li>
</ol>
<p class="calibre3">Here's a <kbd class="calibre13">DestroyBall.cs</kbd> script, which will destroy the object if its Y position is well below the ground plane (Y = <kbd class="calibre13">0</kbd>):</p>
<pre class="calibre18">using UnityEngine; 
using System.Collections; 
 
public class DestroyBall : MonoBehaviour <br class="title-page-name"/>{ 
  void Update () <br class="title-page-name"/>  { 
    if (transform.position.y &lt; -5f) <br class="title-page-name"/>    {
      Destroy (gameObject);  <br class="title-page-name"/>    }  
  } 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting a limited lifetime</h1>
                
            
            
                
<p class="calibre3">Another strategy for managing object life cycle is to limit their duration. This is especially effective for things like projectiles (bullets, arrows, bouncyballs) or other objects that the player cares about most when its instantiated and then isn't paying attention to as gameplay moves on.</p>
<p class="calibre3">To implement, you could put a timer on the object prefab itself to destroy itself when time runs out.</p>
<p class="calibre3">Modify the <kbd class="calibre13">DestroyBall.cs</kbd> script to destroy the object after <kbd class="calibre13">delay</kbd> seconds:</p>
<pre class="calibre18">  public float timer = 15f; 
 
  void Start () <br class="title-page-name"/>  { 
    Destroy (gameObject, timer); 
  } </pre>
<p class="calibre3">When you play, notice that the ground plane remains substantially less crowded than before. Each BouncyBall will be destroyed after 15 seconds or when it has fallen off the plane, whichever comes first. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing an object pool</h1>
                
            
            
                
<p class="calibre3"> If your <kbd class="calibre13">GameController</kbd> Interval is 0.5 seconds and the destroy timer is 15, then (do the math) there will be at most 30 balls in play at a time. Or less, if some have fallen over the edge. In that case, we do not need to make our app continuously allocate new memory for a new instance of BouncyBall, only to delete that object up to 15 seconds later. Too much instantiation and destroying of objects results in fragmented memory. Unity will periodically go through and clean this up, a computationally expensive process called <strong class="calibre5">garbage collection</strong> (<strong class="calibre5">GC</strong>) that is best to be avoided whenever possible.</p>
<p class="calibre3">Object pooling is when you create a list of reusable objects to be used in your game, rather than continuously instantiating new ones. You will activate/deactivate the objects instead of instantiate/destroy.</p>
<p class="calibre3">To implement this, we will write a generic object pooler and add it to the <kbd class="calibre13">GameController</kbd> in the scene.</p>
<p class="calibre3">For this, we are also introducing you to the concept of lists in C#. As the name indicates, a list is an ordered collection of objects, like an array. Lists can be searched, sorted, and otherwise manipulated (see the documentation here: <a href="https://msdn.microsoft.com/en-us/library/6sh2ey19.aspx" class="calibre10">https://msdn.microsoft.com/en-us/library/6sh2ey19.aspx</a>). We will use them simply to hold our pre-instantiated objects. Let's name the script <kbd class="calibre13">ObjectPooler</kbd>:</p>
<ol class="calibre15">
<li class="calibre12">Select the <kbd class="calibre13">GameController</kbd> in Hierarchy</li>
<li class="calibre12">Navigate to Add Component | New Script and name it <kbd class="calibre13">ObjectPooler</kbd></li>
</ol>
<p class="calibre3">Open for editing. Let's start by declaring several variables at the top:</p>
<pre class="calibre18">using System.Collections.Generic;<br class="title-page-name"/>using UnityEngine;<br class="title-page-name"/><br class="title-page-name"/>public class ObjectPooler : MonoBehaviour <br class="title-page-name"/>{<br class="title-page-name"/>    public GameObject prefab;<br class="title-page-name"/>    public int pooledAmount = 20;<br class="title-page-name"/><br class="title-page-name"/>    private List&lt;GameObject&gt; pooledObjects;<br class="title-page-name"/><br class="title-page-name"/>}</pre>
<p class="calibre3">The public <kbd class="calibre13">prefab</kbd> will get the prefab object we want to instantiate, namely <kbd class="calibre13">BouncyBall</kbd>. And <kbd class="calibre13">pooledAmount</kbd> says how many objects to initially instantiate. The actual list is held in <kbd class="calibre13">pooledObjects</kbd>.</p>
<p class="calibre3">Now, when the scene starts, we initialize the list as follows:</p>
<pre class="calibre18">    void Start () {<br class="title-page-name"/>        pooledObjects = new List&lt;GameObject&gt;();<br class="title-page-name"/>        for (int i = 0; i &lt; pooledAmount; i++)<br class="title-page-name"/>        {<br class="title-page-name"/>            GameObject obj = (GameObject)Instantiate(prefab);<br class="title-page-name"/>            obj.SetActive(false);<br class="title-page-name"/>            pooledObjects.Add(obj);<br class="title-page-name"/>        }<br class="title-page-name"/>  }</pre>
<p class="calibre3">We allocate a new list and populate it in the <kbd class="calibre13">for</kbd> loop, by instantiating our prefab, initially making it inactive, and adding it to the list.</p>
<p class="calibre3">Now when we want a new object, we'll call <kbd class="calibre13">GetPooledObject</kbd>, which looks for one in the list that is presently not active. If all of them are active and none is available for reuse, we return <kbd class="calibre13">null</kbd>:</p>
<pre class="calibre18">    public GameObject GetPooledObject()<br class="title-page-name"/>    {<br class="title-page-name"/>        for (int i = 0; i &lt; pooledObjects.Count; i++)<br class="title-page-name"/>        {<br class="title-page-name"/>            if (!pooledObjects[i].activeInHierarchy)<br class="title-page-name"/>            {<br class="title-page-name"/>                return pooledObjects[i];<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        return null;<br class="title-page-name"/>    }</pre>
<p class="calibre3">That's it.</p>
<p class="calibre3">We can also enhance the script to optionally grow the list so it never returns null. Add the option at the top:</p>
<pre class="calibre18">    public bool willGrow = true;</pre>
<p class="calibre3">And add the following statements to <kbd class="calibre13">GetPooledObject</kbd> after the <kbd class="calibre13">for</kbd> loop:</p>
<pre class="calibre18">        ...<br class="title-page-name"/>        if (willGrow)<br class="title-page-name"/>        {<br class="title-page-name"/>            GameObject obj = (GameObject)Instantiate(prefab);<br class="title-page-name"/>            pooledObjects.Add(obj);<br class="title-page-name"/>            return obj;<br class="title-page-name"/>        }<br class="title-page-name"/><br class="title-page-name"/>        return null;<br class="title-page-name"/>    }</pre>
<p class="calibre3">Save the script, attach it to <kbd class="calibre13">GameController</kbd>, and drag the <kbd class="calibre13">BouncyBall</kbd> prefab onto the Prefab slot for the component.</p>
<p class="calibre3">Now we need to modify our <kbd class="calibre13">BallsFromHeaven</kbd> script to call <kbd class="calibre13">GetPooledObject</kbd> from <kbd class="calibre13">ObjectPooler</kbd> instead of <kbd class="calibre13">Instantiate</kbd>. The updated <kbd class="calibre13">BallsFromHeaven</kbd> script is as follows:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/><br class="title-page-name"/>[RequireComponent(typeof(ObjectPooler))]<br class="title-page-name"/>public class BallsFromHeaven : MonoBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>    public float startHeight = 10f;<br class="title-page-name"/>    public float interval = 0.5f;<br class="title-page-name"/><br class="title-page-name"/>    private float nextBallTime = 0f;<br class="title-page-name"/>    private ObjectPooler pool;<br class="title-page-name"/><br class="title-page-name"/>    void Start()<br class="title-page-name"/>    {<br class="title-page-name"/>        pool = GetComponent&lt;ObjectPooler&gt;();<br class="title-page-name"/>        if (pool == null) <br class="title-page-name"/>        {<br class="title-page-name"/>            Debug.LogError("BallsFromHeaven requires ObjectPooler component");<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void Update()<br class="title-page-name"/>    {<br class="title-page-name"/>        if (Time.time &gt; nextBallTime)<br class="title-page-name"/>        {<br class="title-page-name"/>            nextBallTime = Time.time + interval;<br class="title-page-name"/>            Vector3 position = new Vector3(Random.Range(-4f, 4f), startHeight, Random.Range(-4f, 4f));<br class="title-page-name"/>            GameObject ball = pool.GetPooledObject();<br class="title-page-name"/>            ball.transform.position = position;<br class="title-page-name"/>            ball.transform.rotation = Quaternion.identity;<br class="title-page-name"/>            ball.GetComponent&lt;RigidBody&gt;().velocity = Vector3.zero;<br class="title-page-name"/>            ball.SetActive(true);<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre3">Note that we added a directive, <kbd class="calibre13">[RequireComponent(typeof(ObjectPooler)]</kbd>, to ensure the object has an <kbd class="calibre13">ObjectPooler</kbd> component (and we also double-check in the <kbd class="calibre13">Start</kbd> function).</p>
<p class="calibre3">It's important to note that since we're not instantiating new objects but reusing them, you may need to reset any object properties to their starting values. In this case, we reset not just the transform but the RigidBody's velocity to zero.</p>
<p class="calibre3">The last part is we modify <kbd class="calibre13">DestroyBall</kbd> to just disable (deactivate) the object rather than literally destroying it. Initially, handle the <em class="calibre14">fallen off the ground plane</em> case as follows:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/><br class="title-page-name"/>public class DestroyBall : MonoBehaviour {<br class="title-page-name"/><br class="title-page-name"/>    void Update () {<br class="title-page-name"/>        if (transform.position.y &lt; -5f)<br class="title-page-name"/>        {<br class="title-page-name"/>            DisableMe();<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    private void DisableMe()<br class="title-page-name"/>    {<br class="title-page-name"/>        gameObject.SetActive(false);<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre3">Instead of calling <kbd class="calibre13">Destroy</kbd>, we changed <kbd class="calibre13">Update</kbd> to call a new function, <kbd class="calibre13">DisableMe</kbd>, which simply deactivates the object, returning it to the pool of available objects.</p>
<p class="calibre3">For the timed destroy, there's a number of different ways to implement this. Earlier, we called <kbd class="calibre13">Destroy(gameObject, timer)</kbd> from <kbd class="calibre13">Start()</kbd>. We can do something similar, using <kbd class="calibre13">OnEnable</kbd> instead of <kbd class="calibre13">Start</kbd>, since that's when this instance starts. And it calls  <kbd class="calibre13">Invoke()</kbd>, instead of destroy directly:</p>
<pre class="calibre18">    void OnEnable()<br class="title-page-name"/>    {<br class="title-page-name"/>        Invoke("DisableMe", timer);<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void OnDisable()<br class="title-page-name"/>    {<br class="title-page-name"/>        CancelInvoke();<br class="title-page-name"/>    }</pre>
<p class="calibre3">We also provide an <kbd class="calibre13">OnDisable</kbd> to cancel the <kbd class="calibre13">Invoke</kbd>, since the object could be disabled should the ball fall over the edge before the timer is done and potentially re-enabled, we should make sure it's not being invoked twice at the same time. </p>
<p class="calibre3">Now when you press Play, you can see in Inspector that new BouncyBalls are instantiated at the start to initialize the list, and then as it plays the objects are disabled and reactivated as they are returned to the pool and reused, as shown here (deactivated BouncyBall(Clone) objects are dimmer than the activated ones):</p>
<div><img src="img/5d35d2d7-88a8-45a7-baa1-6506d9bd3ac9.png" class="calibre24"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Headshot game</h1>
                
            
            
                
<p class="calibre3">Wouldn't it be fun to actually play with these bouncy balls? Let's make a game where you aim the ball at a target using headshots. For this game, balls drop one at a time from above and bounce off your forehead (face), aiming for a target.</p>
<p class="calibre3">The feature we'll implement here is, when a ball drops from above your head, you bounce it off your face and aim for a target.</p>
<p class="calibre3">To implement this, create a cube as a child of the camera object (much like we did for the reticle cursor in <a href="36d3f24b-8acf-42df-92cc-abb5147d4a1f.xhtml" target="_blank" class="calibre10">Chapter 6</a>, <em class="calibre14">World Space UI</em>).  This provides a collider parented by the VR camera, so our head pose will move the face of the cube. I decided a cube-shaped collider will be better for this game than a sphere or capsule because it provides a flat face that will make the bounce direction more predictable. Balls will drop out of the sky. For a target, we'll use a flattened cylinder. We'll add audio cues to indicate when a new ball has been released and when a ball hits the target.</p>
<p class="calibre3">Create a new scene or, more simple, start here by doing a Save As, and implement the head as follows:</p>
<ol class="calibre15">
<li class="calibre12">Navigate to File | Save Scene As and name it <kbd class="calibre13">BallGame</kbd></li>
<li class="calibre12">Delete the <kbd class="calibre13">BallsFromHeaven</kbd> script component attached to <kbd class="calibre13">GameController</kbd> using the <em class="calibre2">gear</em> icon Remove Component. We won't need it</li>
<li class="calibre12">In Hierarchy, unfold <kbd class="calibre13">MeMyselfEye</kbd>, drilling down to the <kbd class="calibre13">Camera</kbd> object and selecting it (for OpenVR that might be  <kbd class="calibre13">[CameraRig]/Camera (head)</kbd>; for Daydream, it may be  <kbd class="calibre13">Player/Main Camera/</kbd>)</li>
<li class="calibre12">Create a new 3D Object | Cube</li>
<li class="calibre12">With <kbd class="calibre13">GameController</kbd> selected, navigate to Add Component | Audio | Audio Source</li>
<li class="calibre12">Click on the small <em class="calibre2">circle-shaped</em> icon on the far right of the AudioClip field of Audio Source to open the Select AudioClip dialog box and choose the clip named <kbd class="calibre13">Jump</kbd></li>
<li class="calibre12">With <kbd class="calibre13">GameController</kbd> selected, navigate to Add Component | New Script, name it <kbd class="calibre13">BallGame</kbd>, and open it for editing</li>
</ol>
<p class="calibre3">You can decide to disable the cube's Mesh Renderer, but I think it's cool to watch it in the Scene window as you play. Since the camera is inside the cube, the player will not see it (since only the outward facing surfaces are rendered in the game view).</p>
<p class="calibre3">We'll play the <kbd class="calibre13">Jump</kbd> sound clip (provided with the <kbd class="calibre13">Characters</kbd> package of Unity's Standard Assets) to indicate when a new ball is dropped. You might try another, perhaps more interesting, effect.</p>
<p class="calibre3">Here's the <kbd class="calibre13">BallGame.cs</kbd> script. It looks a lot like the <kbd class="calibre13">BallsFromHeaven</kbd> one with just a few differences:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/><br class="title-page-name"/>public class BallGame : MonoBehaviour <br class="title-page-name"/>{<br class="title-page-name"/>    public Transform dropPoint;<br class="title-page-name"/>    public float startHeight = 10f;<br class="title-page-name"/>    public float interval = 3f;<br class="title-page-name"/><br class="title-page-name"/>    private float nextBallTime = 0f;<br class="title-page-name"/>    private ObjectPooler pool;<br class="title-page-name"/>    private GameObject activeBall;<br class="title-page-name"/>    private AudioSource soundEffect;<br class="title-page-name"/><br class="title-page-name"/>    void Start()<br class="title-page-name"/>    {<br class="title-page-name"/>        if (dropPoint == null)<br class="title-page-name"/>        {<br class="title-page-name"/>            dropPoint = Camera.main.transform;<br class="title-page-name"/>        }<br class="title-page-name"/>        soundEffect = GetComponent&lt;AudioSource&gt;();<br class="title-page-name"/>        pool = GetComponent&lt;ObjectPooler&gt;();<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void Update()<br class="title-page-name"/>    {<br class="title-page-name"/>        if (Time.time &gt; nextBallTime)<br class="title-page-name"/>        {<br class="title-page-name"/>            nextBallTime = Time.time + interval;<br class="title-page-name"/>            soundEffect.Play();<br class="title-page-name"/>            Vector3 position = new Vector3(<br class="title-page-name"/>                dropPoint.position.x, <br class="title-page-name"/>                startHeight, <br class="title-page-name"/>                dropPoint.position.z);<br class="title-page-name"/><br class="title-page-name"/>            activeBall = pool.GetPooledObject();<br class="title-page-name"/>            activeBall.transform.position = position;<br class="title-page-name"/>            activeBall.transform.rotation = Quaternion.identity;<br class="title-page-name"/>            activeBall.GetComponent&lt;RigidBody&gt;().velocity = Vector3.zero;<br class="title-page-name"/>            activeBall.SetActive(true);<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>} </pre>
<p class="calibre3">We instantiate a new ball every 3 seconds ( <kbd class="calibre13">interval</kbd> ) from a <kbd class="calibre13">startHeight</kbd> position above the current head position. </p>
<p class="calibre3">The drop point defaults to directly above the player's head position, as defined by the VR camera. That may feel uncomfortable on your neck, so let's extent it in front a little, 0.2 units:</p>
<ol class="calibre15">
<li class="calibre12">As a child of <kbd class="calibre13">MeMyselfEye</kbd> (or as a child of your head or main camera object), create an empty game object and name it <kbd class="calibre13">Drop Point</kbd></li>
<li class="calibre12">Set its Position to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">0.2</kbd>)</li>
<li class="calibre12">Drag this <kbd class="calibre13">Drop Point</kbd> onto the <kbd class="calibre13">GameController</kbd>'s Ball Game Drop Point slot</li>
</ol>
<p class="calibre3">On positionally tracked VR rigs, if your drop point is relative to the camera, it will follow the player around. If it's relative to <kbd class="calibre13">MeMyselfEye</kbd>, it will be relative to your play space while the player can move around.</p>
<p class="calibre3">Try it in VR.</p>
<p class="calibre3">When you hear the ball, look up and aim the angle of your face to direct the bounce of the ball. <em class="calibre14">COOOL!</em></p>
<p class="calibre3">Now, we need the target. Perform the following steps:</p>
<ol class="calibre15">
<li class="calibre12">Create a flat cylinder for the target, navigate to Game Object | 3D Object | Cylinder, and name it <kbd class="calibre13">Target</kbd>.</li>
<li class="calibre12">Set its Scale to (<kbd class="calibre13">3</kbd>, <kbd class="calibre13">0.1</kbd>, <kbd class="calibre13">3</kbd>) and Position to (<kbd class="calibre13">1</kbd>, <kbd class="calibre13">0.2</kbd>, <kbd class="calibre13">2.5</kbd>) so that it's out in front of you on the ground.</li>
<li class="calibre12">Drag the <kbd class="calibre13">Blue</kbd> material from the <kbd class="calibre13">Project Assets/Materials</kbd> folder (created in <a href="b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml" target="_blank" class="calibre10">Chapter 2</a>, <em class="calibre2">Content, Objects and Scale</em>) onto it, or make a new one.</li>
<li class="calibre12">Note that its default Capsule Collider is domed, and it really won't do. On the Capsule Collider, select its <em class="calibre2">gear</em> icon | Remove Component.</li>
</ol>
<ol start="5" class="calibre15">
<li class="calibre12">Then, navigate to Add Component | Physics | Mesh Collider.</li>
<li class="calibre12">In the new Mesh Collider, enable the Convex checkbox and the Is Trigger checkbox too.</li>
<li class="calibre12">Add an audio source by navigating to Add Component | Audio | Audio Source.</li>
<li class="calibre12">With the <kbd class="calibre13">Target</kbd> selected, click on the small <em class="calibre2">circle</em> icon on the far right of the AudioClip field to open the Select AudioClip dialog box, and choose the clip named <kbd class="calibre13">Land</kbd> (found in Standard Assets).</li>
<li class="calibre12">Uncheck the Play On Awake checkbox.</li>
<li class="calibre12">And a new script, navigate to Add Component | New Script, name it <kbd class="calibre13">TriggerSound</kbd>, and open it in MonoDevelop.</li>
</ol>
<p class="calibre3">Since we enabled Is Trigger, when something hits the collider, the <kbd class="calibre13">OnTriggerEnter</kbd> and other event handlers will get a call when present on the target object. The following <kbd class="calibre13">TriggerSound.cs</kbd> script will play a sound clip when you hit the target with a ball:</p>
<pre class="calibre18">using UnityEngine; 
using System.Collections; 
 
public class TriggerSound : MonoBehaviour { 
  public AudioSource hitSound; 
 
  void Start() { 
    hitSound = GetComponent&lt;AudioSource&gt; (); 
  } 
 
  void OnTriggerEnter(Collider other) { 
    hitSound.Play (); 
  } 
} </pre>
<p class="calibre3">The ball enters the target's collider and the physics engine invokes a trigger enter event. The script uses the <kbd class="calibre13">OnTriggerEnter()</kbd> handler to play the audio clip. </p>
<p>For a full list of the collider properties and trigger events, including <kbd class="calibre26">OnTrggerEnter</kbd> and <kbd class="calibre26">OnTriggerExit</kbd>, see the documentation at <a href="https://docs.unity3d.com/ScriptReference/Collider.html" class="calibre20">https://docs.unity3d.com/ScriptReference/Collider.html</a>.</p>
<p class="calibre3">Try it in VR. It's a VR game! The following image shows the scene with the first person's colliders and a ball bouncing off the cube collider towards the target:</p>
<div><img src="img/491546fa-fc3c-4d53-a7f8-179256fdd125.png" class="calibre62"/></div>
<div><strong class="calibre1">Extra challenge</strong>: Keep score. Provide an aiming reticle. Add a backboard. Add other features to make the game more challenging. For instance, you can vary the fire interval or increase the initial ball velocity.</div>
<p class="calibre3">Up to this point, we assigned Bounciness through a Physic Material attached to a sphere object. When the ball collides with another object, the Unity physics engine considers this bounciness to determine the ball's new velocity and direction. In the following section, we'll look at how one can transfer a bounce force from one object to another.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Paddle ball game</h1>
                
            
            
                
<p class="calibre3">Next, we'll add hand controlled paddles to hit the ball. To keep things somewhat generic, our game paddles will be simple objects parented by the hand controllers in your camera rig. We'll move the target to be on a wall instead of the floor, and serve the balls a little further out in front of you so they're reachable</p>
<p class="calibre3">To set up the scene, you can Save As a new name and we'll work from here. I'll name my <kbd class="calibre13">PaddleBallGame</kbd>.</p>
<ol class="calibre15">
<li class="calibre12">Select File | Save Scene As and name it <kbd class="calibre13">PaddleBallGame</kbd></li>
<li class="calibre12">Disable the head Cube we previously added as child of the camera, if present</li>
</ol>
<p class="calibre3">First, let's create a paddle. We'll construct a very simple model using cylinders. You can find better ones, shaped and textured, online. </p>
<ol class="calibre15">
<li class="calibre12">In the Hierarchy root, Create | Create Empty, name it <kbd class="calibre13">Paddle</kbd>, and reset its Transform</li>
<li class="calibre12">Add a child cylinder object (Create | 3D Object | Cylinder) and name it <kbd class="calibre13">Handle</kbd></li>
<li class="calibre12">Set the Handle's Scale to (<kbd class="calibre13">0.02</kbd>, <kbd class="calibre13">0.1</kbd>, <kbd class="calibre13">0.02</kbd>)</li>
<li class="calibre12">Add another Cylinder as a sibling of Handle and name it <kbd class="calibre13">Pad</kbd></li>
<li class="calibre12">Set the pad's Scale to (<kbd class="calibre13">0.2</kbd>, <kbd class="calibre13">0.005</kbd>, <kbd class="calibre13">0.2</kbd>), Rotation (<kbd class="calibre13">90</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>), and Position (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0.2</kbd>, <kbd class="calibre13">0</kbd>)</li>
<li class="calibre12">In your Project Materials folder, create a new material (Create | Material) and name it <kbd class="calibre13">Paddle</kbd> <kbd class="calibre13">Material</kbd></li>
<li class="calibre12">Give the material Albedo a wooden color, such as (<kbd class="calibre13">107</kbd>, <kbd class="calibre13">79</kbd>, <kbd class="calibre13">54</kbd>, <kbd class="calibre13">255</kbd>), then drag the material onto the Handle and Pad objects</li>
</ol>
<p class="calibre3">Now, modify the colliders:</p>
<ol class="calibre15">
<li class="calibre12">Select the Handle, and delete its Capsule Collider</li>
<li class="calibre12">Select the Pad, and delete its Capsule Collider</li>
<li class="calibre12">With Pad selected, add a Mesh Collider (Add Component | Physics | Mesh Collider)</li>
<li class="calibre12">Check the Convex checkbox</li>
</ol>
<p class="calibre3">Save the paddle as a prefab:</p>
<ol class="calibre15">
<li class="calibre12">Drag the Paddle into your Project Prefabs folder</li>
<li class="calibre12">Delete the Paddle from your Hierarchy</li>
</ol>
<p class="calibre3">We want to parent the Paddle to your hands. This is platform-specific. If you are using OpenVR, for example, that may be <kbd class="calibre13">MeMyselfEye / [CameraRig] / Controller</kbd> <em class="calibre14">(right)</em>. On Daydream, that might be <kbd class="calibre13">MeMyselfEye / Player / GvrControllerPointer.</kbd></p>
<ol class="calibre15">
<li class="calibre12">In Hierarchy, select the hand controller within <kbd class="calibre13">MeMyselfEye</kbd> (such as Controller (right). or <kbd class="calibre13">GvrControllerPointer</kbd>)</li>
<li class="calibre12">Create Empty child game object and name it <kbd class="calibre13">Hand</kbd> (reset its Transform if needed)</li>
<li class="calibre12">Create another Empty child beneath Hand and name it <kbd class="calibre13">Attach Point</kbd> (and reset its Transform if needed)</li>
<li class="calibre12">Drag the Paddle prefab from Project into Hierarchy as a child of Attach Point</li>
</ol>
<p class="calibre3">Now, we can adjust the paddle's relative position and rotation so its grip feels natural within your hand. The follow values seem to work for me:</p>
<ul class="calibre11">
<li class="calibre12">In OpenVR, use the attach point Rotation (<kbd class="calibre13">20</kbd>, <kbd class="calibre13">90</kbd>, <kbd class="calibre13">90</kbd>)</li>
<li class="calibre12">In Daydream, use Position (<kbd class="calibre13">0</kbd>,  <kbd class="calibre13">0</kbd>,  <kbd class="calibre13">0</kbd>, <kbd class="calibre13">05)</kbd> and Rotation (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">90</kbd>, <kbd class="calibre13">90</kbd>)</li>
</ul>
<p class="calibre3">On Daydream, the <kbd class="calibre13">GvrControllerPointer</kbd> includes a <kbd class="calibre13">GvrArmModel</kbd> component that can be configured for simulating arm, elbow, and wrist movement with the simple 3DOF controller. Setting this up yourself can be confusing. Fortunately, a bunch of examples are provided in the ArmModelDemo scene the Daydream Elements package (in the <kbd class="calibre13">DaydreamElements/Elements/ArmModels/D<em class="calibre2">emo/</em></kbd> folder) including prefabs with some preconfigured arm models. Let's add one. If you are on Daydream:</p>
<ol class="calibre15">
<li class="calibre12">Find the <kbd class="calibre13">Elements/ArmModels/Prefabs</kbd> folder in Project Assets</li>
<li class="calibre12">Drag the <kbd class="calibre13">SwingArm</kbd> prefab into <kbd class="calibre13">MeMyselfEye / Player</kbd> as a sibling of <kbd class="calibre13">GvrControllerPointer</kbd></li>
<li class="calibre12">Move <kbd class="calibre13">GvrControllerPointer</kbd> as a child of SwingArm</li>
</ol>
<p class="calibre3">This will give more arm extension for using the paddle. You can further adjust the settings as needed, including try moving the SwingArm transform Position further in front (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">0.3</kbd>). </p>
<p class="calibre3">Lastly, you might want to extend the ball drop location a little further out in front of you so it's more readily within hand reach. In the earlier version of the project, we defined a Drop Point; modify its position as desired (for example, z = <kbd class="calibre13">0.6</kbd>).</p>
<p class="calibre3">The paddle in play using HTC Vive is shown here:</p>
<div><img src="img/c6906466-5459-4ca2-8771-c2f6d179bedf.png" class="calibre63"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Deflector versus paddle</h1>
                
            
            
                
<p class="calibre3">As implemented, our paddle acts more like a deflector shield than a paddle. The ball will bounce off the paddle's Pad in a direction based on the Pad's surface normal orientation. But if you whack the ball, that doesn't transfer any physics. We can change this by adding a RigidBody to the Pad, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Select the Pad of your Paddle</li>
<li class="calibre12">Add Component | Physics | RigidBody</li>
<li class="calibre12">Uncheck Use Gravity checkbox</li>
<li class="calibre12">Check the Is Kinematic checkbox</li>
<li class="calibre12">Click the Apply button at top of Inspector to save your changes in the prefab</li>
</ol>
<p class="calibre3">By making it kinematic, our Pad will apply physics to objects colliding with it, but will not react to collisions itself. This is good, otherwise, the paddle would shatter when hit by a ball. </p>
<p class="calibre3">One important lesson in this project is the use of attach points for defining relative positions for specific behaviors. We used a Drop Point to mark the X, Z position where balls are dropped from. We used an Attach Point to mark the relative position and rotation of the paddle in your hand. We could have added a Grip Point to the paddle itself to specify its relative origin. And so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Shooter ball game</h1>
                
            
            
                
<p class="calibre3">For the next iteration of this project, we'll shoot balls at the player and you have to hit them at a target on a wall. There's not a lot of innovation in this version, but it shows how you can take an existing mechanic and turn it on its side (both literally and figuratively).</p>
<p class="calibre3">To begin, lets make a wall and put the target on it:</p>
<ol class="calibre15">
<li class="calibre12">In the Hierarchy root, create an Empty game object named <kbd class="calibre13">TargetWall</kbd> and </li>
<li class="calibre12">Position it at (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">5</kbd>)</li>
<li class="calibre12">Create a child Cube and name it <kbd class="calibre13">Wall</kbd></li>
<li class="calibre12">Set the Wall Scale to (<kbd class="calibre13">10</kbd>, <kbd class="calibre13">5</kbd>, <kbd class="calibre13">0.1</kbd>) and Position (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">2.5</kbd>, <kbd class="calibre13">0</kbd>)</li>
<li class="calibre12">Create a new Material named <kbd class="calibre13">Wall Material</kbd></li>
<li class="calibre12">Set its Rendering Mode to Transparent, and its Albedo color to (<kbd class="calibre13">85</kbd>, <kbd class="calibre13">60</kbd>, <kbd class="calibre13">20</kbd>, <kbd class="calibre13">75</kbd>) so it's a translucent glassy color</li>
<li class="calibre12">Move the Target to a child of <kbd class="calibre13">TargetWall</kbd></li>
<li class="calibre12">Modify the Target Transform Scale to (<kbd class="calibre13">1.5</kbd>, <kbd class="calibre13">0.1</kbd>, <kbd class="calibre13">1.5</kbd>), Rotation (<kbd class="calibre13">90</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>), and Position (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">2.5</kbd>, <kbd class="calibre13">-0.25</kbd>) so it's smaller and just in front of the wall itself</li>
</ol>
<p class="calibre3">Next, instead of serving balls by dropping them out of the sky and relying on gravity, we'll shoot balls at you from a source on the wall:</p>
<ol class="calibre15">
<li class="calibre12">Create a Sphere game object as a child of <kbd class="calibre13">TargetWall</kbd>, named <kbd class="calibre13">Shooter</kbd></li>
<li class="calibre12">Set its Scale to (<kbd class="calibre13">0.5</kbd>, <kbd class="calibre13">0.5</kbd>, <kbd class="calibre13">0.5</kbd>) and Position (<kbd class="calibre13">4</kbd>, <kbd class="calibre13">2.5</kbd>, <kbd class="calibre13">-0.25</kbd>)</li>
<li class="calibre12">Disable or remove its Sphere Collider component</li>
<li class="calibre12">Create a new Material named <kbd class="calibre13">Shooter Material</kbd>, with Albedo color (<kbd class="calibre13">45</kbd>, <kbd class="calibre13">22</kbd>, <kbd class="calibre13">12</kbd>, <kbd class="calibre13">255</kbd>)</li>
</ol>
<p class="calibre3">We'll add a gun barrel to the shooter:</p>
<ol class="calibre15">
<li class="calibre12">Create another Sphere object as a child of Shooter, named <kbd class="calibre13">Barrel</kbd></li>
<li class="calibre12">Set its Scale (<kbd class="calibre13">0.1</kbd>, <kbd class="calibre13">0.1</kbd>, <kbd class="calibre13">0.1</kbd>), Rotation (<kbd class="calibre13">90</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>), and Position (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">-0.25</kbd>)</li>
</ol>
<p class="calibre3">Duplicate the Shooter and set the second one's Position to (<kbd class="calibre13">-4</kbd>, <kbd class="calibre13">2.5</kbd>, <kbd class="calibre13">-0.25</kbd>) so there's one on either side of the Target. Here is a capture of the Scene view of the <kbd class="calibre13">TargetWall</kbd> with its sexy shooters:</p>
<div><img src="img/e290e704-61dc-4e23-8b3d-5290aa045ee6.png" class="calibre64"/></div>
<p class="calibre3">The game controller script is similar to the BallGame one we have, but sufficiently different we should create a new one:</p>
<ol class="calibre15">
<li class="calibre12">In Hierarchy, select <kbd class="calibre13">GameController</kbd> and disable or remove the <kbd class="calibre13">BallGame</kbd> component</li>
<li class="calibre12">Create a new C# script named <kbd class="calibre13">ShooterBallGame</kbd> and open it for editing</li>
</ol>
<p class="calibre3">Write the <kbd class="calibre13">ShooterBallGame</kbd> script as follows. We give it two shooters and the script alternates between them to shoot balls in the direction of a <kbd class="calibre13">shootAt</kbd> location. We play a sound effect each time a ball is shot. First, let's define the public and private variable we will need:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/><br class="title-page-name"/>[RequireComponent(typeof(ObjectPooler))]<br class="title-page-name"/>public class ShooterBallGame : MonoBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>    public Transform shootAt;<br class="title-page-name"/>    public Transform shooter0;<br class="title-page-name"/>    public Transform shooter1;<br class="title-page-name"/>    public float speed = 5.0f;<br class="title-page-name"/>    public float interval = 3f;<br class="title-page-name"/><br class="title-page-name"/>    private float nextBallTime = 0f;<br class="title-page-name"/>    private ObjectPooler pool;<br class="title-page-name"/>    private GameObject activeBall;<br class="title-page-name"/>    private int shooterId = 0;<br class="title-page-name"/>    private Transform shooter;<br class="title-page-name"/><br class="title-page-name"/>    private AudioSource soundEffect;<br class="title-page-name"/>}</pre>
<p class="calibre3">The <kbd class="calibre13">Start</kbd> function initializes the variable we get at runtime:</p>
<pre class="calibre18">   void Start()<br class="title-page-name"/>    {<br class="title-page-name"/>        if (shootAt == null)<br class="title-page-name"/>        {<br class="title-page-name"/>            shootAt = Camera.main.transform;<br class="title-page-name"/>        }<br class="title-page-name"/>        soundEffect = GetComponent&lt;AudioSource&gt;();<br class="title-page-name"/>        pool = GetComponent&lt;ObjectPooler&gt;();<br class="title-page-name"/>        if (pool == null)<br class="title-page-name"/>        {<br class="title-page-name"/>            Debug.LogError("BallGame requires ObjectPooler component");<br class="title-page-name"/>        }<br class="title-page-name"/>    }</pre>
<p class="calibre3">And the <kbd class="calibre13">Update</kbd> function shoots the balls at specified intervals, alternating between the two shooter locations:</p>
<pre class="calibre18">    void Update()<br class="title-page-name"/>    {<br class="title-page-name"/>        if (Time.time &gt; nextBallTime)<br class="title-page-name"/>        {<br class="title-page-name"/>            if (shooterId == 0)<br class="title-page-name"/>            {<br class="title-page-name"/>                shooterId = 1;<br class="title-page-name"/>                shooter = shooter1;<br class="title-page-name"/>            }<br class="title-page-name"/>            else<br class="title-page-name"/>            {<br class="title-page-name"/>                shooterId = 0;<br class="title-page-name"/>                shooter = shooter0;<br class="title-page-name"/>            }<br class="title-page-name"/><br class="title-page-name"/>            nextBallTime = Time.time + interval;<br class="title-page-name"/>            ShootBall();<br class="title-page-name"/>        } <br class="title-page-name"/>    }</pre>
<p class="calibre3">Finally, here's the <kbd class="calibre13">ShootBall()</kbd> code we extracted into its own function:</p>
<pre class="calibre18">    private void ShootBall()<br class="title-page-name"/>    {<br class="title-page-name"/>        soundEffect.Play();<br class="title-page-name"/>        activeBall = pool.GetPooledObject();<br class="title-page-name"/>        activeBall.transform.position = shooter.position;<br class="title-page-name"/>        activeBall.transform.rotation = Quaternion.identity;<br class="title-page-name"/>        shooter.transform.LookAt(shootAt);<br class="title-page-name"/>        activeBall.GetComponent&lt;Rigidbody&gt;().velocity = shooter.forward * speed;<br class="title-page-name"/>        activeBall.GetComponent&lt;Rigidbody&gt;().angularVelocity = Vector3.zero;<br class="title-page-name"/>        activeBall.SetActive(true);<br class="title-page-name"/>    }</pre>
<p class="calibre3"><kbd class="calibre13">ShootBall</kbd> grabs a new ball from the object pool and initializes its position based on the shooter position. It then rotates the shooter to be pointing at the <kbd class="calibre13">shootAt</kbd> position (using <kbd class="calibre13">transform.LookAt</kbd>) and uses its forward vector to define the ball's RigidBody velocity vector.</p>
<p class="calibre3">Back in Unity, we need to populate the public variable slots:</p>
<ol class="calibre15">
<li class="calibre12">Drag the <kbd class="calibre13">Shooter</kbd> object (child of <kbd class="calibre13">TargetWall</kbd>) on to the Shooter 0 slot</li>
<li class="calibre12">Drag the other <kbd class="calibre13">Shooter</kbd> object on to the Shooter 1 slot</li>
</ol>
<p class="calibre3">Leave the Shoot At slot empty for now, so it will default to the player's live head position.</p>
<p class="calibre3">Press Play. <em class="calibre14">Not bad</em>. The balls are too big and heavy. Let's create new ball prefabs with different properties:</p>
<ol class="calibre15">
<li class="calibre12">Drag the <kbd class="calibre13">BouncyBall</kbd> prefab from <kbd class="calibre13">Project</kbd> folder into the Hierarchy</li>
<li class="calibre12">Rename it <kbd class="calibre13">ShooterBall</kbd></li>
<li class="calibre12">Set its Scale to (<kbd class="calibre13">0.25</kbd>, <kbd class="calibre13">0.25</kbd>, <kbd class="calibre13">0.25</kbd>)</li>
<li class="calibre12">Uncheck the Use Gravity checkbox (alternatively, you could play with its RigidBody Mass property)</li>
<li class="calibre12">Drag the ShooterBall from Hierarchy into your <kbd class="calibre13">Prefabs</kbd> folder, creating a new prefab for it</li>
<li class="calibre12">Delete the ShooterBall from the Hierarchy</li>
<li class="calibre12">Select <kbd class="calibre13">GameController</kbd> in Hierarchy, and drag the ShooterBall onto its Object Pooler Prefab slot</li>
</ol>
<p class="calibre3">Now, the object pool will instantiate a collection of the new prefab objects.</p>
<p class="calibre3">Press Play. <em class="calibre14">Oh yeah!</em> The game is now much more challenging. Also, try modifying the Interval and Speed settings.</p>
<p class="calibre3">It may be awkward that the ball is always shooting towards your head, especially on Daydream where you have limited hand control. You can adjust the scene, for example, positioning the ShootAt empty game object, as child of <kbd class="calibre13">MeMyselfEye</kbd>, at Position (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0.9</kbd>, <kbd class="calibre13">0.6</kbd>), and setting it into the <kbd class="calibre13">GameController</kbd>'s ShootAt slot.</p>
<p class="calibre3">Some obvious gameplay improvement ideas should come to mind. You could make a moving target, perhaps in a predictable oscillating motion, or completely random. You could introduce some random variation in the ball velocity direction and speed or the intervals between shots. You could keep score, using <kbd class="calibre13">OnTriggerEnter</kbd> on the Target. You could disqualify bank shots that bounce first on the floor (using <kbd class="calibre13">OnTriggerEnter</kbd> on the ground plane). </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Juicing the scene</h1>
                
            
            
                
<p class="calibre3">Having the basic mechanics implemented, we can now <em class="calibre14">juice it</em>! One of my favorite VR games is the popular Audio Shield (<a href="http://audio-shield.com/" class="calibre10">http://audio-shield.com/</a>). We're almost there building our own, we just need to add fireballs, a compelling environment scene, and synchronizing the fireball shots with music! </p>
<p>The term <em class="calibre2">juice it</em> for game design was popularized by Jonasson and Purho in their presentation talk from 2012,  <em class="calibre2">Juice it or lose it - a talk by Martin Jonasson &amp; Petri Purho</em> (<a href="https://www.youtube.com/watch?v=Fy0aCDmgnxg" class="calibre20">https://www.youtube.com/watch?v=Fy0aCDmgnxg</a>). <q class="calibre65">A juicy game feels alive and responds to everything you do, tons of cascading action and response for minimal user input.</q></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Great balls of fire</h1>
                
            
            
                
<p class="calibre3">In the previous section, we disabled Use Gravity on the shooting balls. We did this in anticipation of changing the balls from being bouncy balls to balls of fire. Let's make that magic happen now. We will use the Particle System to render it instead of mesh geometry.</p>
<p class="calibre3">There are a lot of ways to get particle effects into your Unity project. If you recall, in <a href="b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml" target="_blank" class="calibre10">Chapter 4</a>, <em class="calibre14">Gaze-Based Control</em>, we added a water hose, spark emitter, and explosion effects from the <kbd class="calibre13">Unity Standard Assets</kbd> package. Here, we'll build our own, but use one of the materials, <kbd class="calibre13">ParticleFireCloud</kbd>, provided with the package. In the Unity Asset Store, you can find many offerings of particle effects and system enhancements too.</p>
<p class="calibre3">First, make a new prefab derived from ShooterBall, named <kbd class="calibre13">FireBall</kbd>, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Drag a copy of <kbd class="calibre13">ShooterBall</kbd> prefab from the <kbd class="calibre13">Project</kbd> folder into Hierarchy</li>
<li class="calibre12">Rename it FireBall</li>
<li class="calibre12">Drag FireBall into the <kbd class="calibre13">Project</kbd> <em class="calibre2">Prefabs</em> folder to create a new prefab</li>
<li class="calibre12">Select the <kbd class="calibre13">GameController</kbd> from Hierarchy</li>
<li class="calibre12">Drag the <kbd class="calibre13">FireBall</kbd> prefab from <kbd class="calibre13">Project</kbd> <em class="calibre2">Prefabs</em> folder onto the Object Pooler Prefab slot</li>
</ol>
<p class="calibre3">OK, now we can add the particle system:</p>
<ol class="calibre15">
<li class="calibre12">Select the FireBall from Hierarchy</li>
<li class="calibre12">Disable its Mesh Renderer, as we will render it with particles instead</li>
<li class="calibre12">Right-click FireBall and select Create | Effects | Particle System</li>
<li class="calibre12">Rename it Fireball Particle System</li>
</ol>
<p class="calibre3">There are a lot of details in working with particles, many options and configuration parameters. As we step through this quick implementation of fireballs, observe the effects of each change as we make them one at a time. Note that you can preview the particle effects in the Scene window. Feel free to experiment on your own.</p>
<ol class="calibre15">
<li class="calibre12">First, at the bottom of the Particle System Inspector, find the Renderer panel. In its Material slot, click the doughnut icon and choose the ParticleFireCloud material (located in <kbd class="calibre13">Standard Assets/Particle Systems/Materials</kbd>. If not present, you may need to import it using Assets | Import Package | ParticleSystems).</li>
<li class="calibre12">Near the top of the Particle System inspector, find the Shape panel. Select Shape: Sphere, and set its Radius to <kbd class="calibre13">0.1</kbd>.</li>
<li class="calibre12">Find the Emission panel, and set Rate of Time to <kbd class="calibre13">15</kbd>.</li>
<li class="calibre12">At the top of the inspector, set Duration: <kbd class="calibre13">2.00</kbd>.</li>
<li class="calibre12">Start Lifetime: <kbd class="calibre13">1</kbd>.</li>
<li class="calibre12">Start Speed: <kbd class="calibre13">0</kbd>.</li>
<li class="calibre12">Start Size: <kbd class="calibre13">0.5</kbd>.</li>
</ol>
<p class="calibre3"> </p>
<ol start="8" class="calibre15">
<li class="calibre12">For Start Rotation, click the selector icon on the right and choose Random Between Two Curves. Then click the slot and scroll to the Curve Editor at the bottom of the Inspector. If you're not familiar, the editor can take some getting used to. Choose a full range of values from <kbd class="calibre13">180</kbd> (at top of graph) to <kbd class="calibre13">-180</kbd> (bottom of graph), as shown:</li>
</ol>
<div><img src="img/fe543e26-4c2e-4f6f-9d52-b08c61e2317c.png" class="calibre24"/></div>
<ol start="9" class="calibre15">
<li class="calibre12">Enable Color Over Lifetime and click the slot to open its Gradient Editor. We want to adjust the Alpha curve so it starts at Alpha <kbd class="calibre13">0</kbd> at Location <kbd class="calibre13">0%</kbd>, then becomes Alpha <kbd class="calibre13">255</kbd> at <kbd class="calibre13">10%</kbd>, then fades out over time back to Alpha <kbd class="calibre13">0</kbd> at <kbd class="calibre13">100%</kbd>. The editor is shown here:</li>
</ol>
<div><img src="img/c43d9d6a-184a-4caf-8fed-69ba777f9a68.png" class="calibre24"/></div>
<ol start="10" class="calibre15">
<li class="calibre12">Set the Start Color, as Gradient (right-side selector) and then pick a range of colors such as yellow to red, as shown here:</li>
</ol>
<div><img src="img/c67f1214-4127-43fd-9b2f-6c17a6d9b4f4.png" class="calibre24"/></div>
<ol start="11" class="calibre15">
<li class="calibre12">Next, set the Velocity Over Lifetime, using Random Between Two Curves. For each X, Y, Z, use the Curve Editor to set max and min values of <kbd class="calibre13">0.05</kbd> and <kbd class="calibre13">-0.05</kbd> respectively. (You can modify the vertical axis of the graph by clicking the axis label and typing a number; you can copy curves, for example, by right-clicking the Z slot, choosing Copy, then right-clicking the Y slot and choosing Paste.)</li>
</ol>
<p class="calibre3">At this point, we should adjust the fireball so it's about the same size as our original BouncyBall. To check:</p>
<ol class="calibre15">
<li class="calibre12">Re-enable the FireBall's Mesh Renderer. Adjust the particle system by changing the Renderer's Max Particle Size to <kbd class="calibre13">0.1</kbd>, or using the Transform Scale </li>
<li class="calibre12">Save your work by selecting Apply at the top of Inspector, to update your prefab</li>
</ol>
<p class="calibre3">Now when you press Play, the Shooters will fire FireBalls. <em class="calibre14">Oh wow!</em></p>
<p class="calibre3">If you'd like to add some sparkle effect to the fireball, we can do that with the Trail panel:</p>
<ol class="calibre15">
<li class="calibre12">Enable the Trail panel</li>
<li class="calibre12">A warning may pop up tell you to add a trails material to the Renderer</li>
<li class="calibre12">In the Renderer panel, select the doughnut icon on the Trail Material slot, and choose ParticleFireCloud as we use for the main fireball</li>
</ol>
<p class="calibre3">Speaking of trails, if you'd like to also implement trail effects on the fireball, there are several ways to do this too.  A quick solution is to duplicate our fireball particle system and modify it to use a Cone shape instead of Sphere, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Select the Fireball Particle System in Hierarchy.</li>
<li class="calibre12">Right-click to Duplicate, move the duplicate as a child of Fireball Particle System and name it Trail Particle System.</li>
<li class="calibre12">Change its Shape to Cone.</li>
<li class="calibre12">Change its Velocity Over Lifetime. The Z curve needs a higher value range, such as <kbd class="calibre13">0.75</kbd> to <kbd class="calibre13">0.25</kbd>. </li>
<li class="calibre12">The X and Y velocity curves should be smaller for some variation, such as <kbd class="calibre13">0.2</kbd> to <kbd class="calibre13">-0.2</kbd>.</li>
<li class="calibre12">Set the Size Over Lifetime range to <kbd class="calibre13">1.0</kbd> to <kbd class="calibre13">0.5</kbd>.</li>
<li class="calibre12">In its Transform, set Position to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">0.5</kbd>) to give it an extra tail.</li>
</ol>
<p class="calibre3">Here is a screenshot of the gameplay window paddling an incoming fireball!</p>
<div><img src="img/c52a7b5d-8b8d-4cc0-88ca-fe7b40ea2df9.png" class="calibre66"/> </div>
<p>Special thanks to Tyler Wissler for his instructional video <em class="calibre2">How To: Basic Fireballs in Unity</em> (June 2014), which was very helpful is developing this topic (<a href="https://www.youtube.com/watch?v=OWShSR6Tr50" class="calibre20">https://www.youtube.com/watch?v=OWShSR6Tr50</a>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Skull environment</h1>
                
            
            
                
<p class="calibre3">To spice up our game, even more, we should find an exciting environment and scene. Searching the Asset Store, I found the <em class="calibre14">Skull Platform</em> free asset (<a href="https://assetstore.unity.com/packages/3d/props/skull-platform-105664" class="calibre10">https://assetstore.unity.com/packages/3d/props/skull-platform-105664</a>). You can use it too, or find something different.</p>
<p class="calibre3">Assuming you've found and installed the Skull Platform asset, we'll add it to our scene. First, let's render our target as a skull:</p>
<ol class="calibre15">
<li class="calibre12">Drag Platform_Skull_o1 as a child of Target (under <kbd class="calibre13">TargetWall</kbd>).</li>
<li class="calibre12">Set its Transform Rotation (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">180</kbd>) and Scale (<kbd class="calibre13">0.3</kbd>, <kbd class="calibre13">0.3</kbd>, <kbd class="calibre13">0.3</kbd>).</li>
<li class="calibre12">Select the Target and disable its Mesh Renderer.</li>
<li class="calibre12">Also, create a new Spotlight (Create | Light | Spotlight) to shine on the skull. As a child of Target, I used the following settings: Position (<kbd class="calibre13">-1</kbd>, <kbd class="calibre13">-30</kbd>, <kbd class="calibre13">-0.6</kbd>), Rotation (<kbd class="calibre13">-60</kbd>, <kbd class="calibre13">60</kbd>, <kbd class="calibre13">0</kbd>), Range: <kbd class="calibre13">10</kbd>, Spot Angle: <kbd class="calibre13">30</kbd>, Color: <kbd class="calibre13">#FFE5D4FF</kbd>, Intensity: <kbd class="calibre13">3</kbd>.</li>
</ol>
<p class="calibre3">Next, let's add the big platform as a backdrop behind the wall. The quickest way is to merge in the Demoscene they provide:</p>
<ol class="calibre15">
<li class="calibre12">Create an Empty game object in the Hierarchy root, name it SkullPlatform, reset its transform.</li>
<li class="calibre12">Drag a copy of the Skull Platform's demo scene named Platform (<kbd class="calibre13">Assets/Skull Platform/Demo/</kbd> folder) into the Hierarchy.</li>
<li class="calibre12">Select the Demo's Scene, Lighting, and Particles objects and drag them as children of SkullPlatform.</li>
<li class="calibre12">Now that we have the assets we want, right-click the Platform scene in Hierarchy and choose Remove Scene. When prompted, choose Don't Save.</li>
<li class="calibre12">Set the SkullPlatform Position to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">-1.5</kbd>, <kbd class="calibre13">0</kbd>) so it's just below the ground plane.</li>
<li class="calibre12">Select the GroundPlane and disable its Mesh Renderer.</li>
</ol>
<p class="calibre3"> </p>
<p class="calibre3">Now, we'll set up the scene environment lighting:</p>
<ol class="calibre15">
<li class="calibre12">Delete the Directional Light from the scene Hierarchy.</li>
<li class="calibre12">Open the Lighting window. If its not already a tab in your editor, use Window | Lighting | Settings and dock it next to the Inspector.</li>
<li class="calibre12">Set its Skybox Material to Sky (provided in the Skull Platform package).</li>
<li class="calibre12">In the Environmental Lighting section, set Source: Color to <kbd class="calibre13">#141415</kbd>.</li>
<li class="calibre12">Check the Fog checkbox (in Other Settings), Color to <kbd class="calibre13">#8194A1FF</kbd>, Mode: Exponential, and Density to 0.<kbd class="calibre13">03</kbd>.</li>
</ol>
<p class="calibre3">Here is a screen capture of the scene with the skull platform environment and lighting. <em class="calibre14">Sweet!</em></p>
<div><img src="img/eaf4de82-7717-4dd4-995f-811d6347dab9.png" class="calibre67"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Audio synchronization</h1>
                
            
            
                
<p class="calibre3">We're almost there building our own version of Audio Shield, we just need to add synchronizing the fireball shots with music! </p>
<p class="calibre3">Unity provides an API for sampling audio source data, including <kbd class="calibre13">AudioSource.GetSpectrumData</kbd> and <kbd class="calibre13">GetOutputData</kbd>. Extracting actual beats in the music from this data is not trivial and requires a lot of math and some understanding of how music encoding works.</p>
<p class="calibre3">Fortunately, we found an open source script that does this for us, called Unity-Beat-Detection (<a href="https://github.com/allanpichardo/Unity-Beat-Detection" class="calibre10">https://github.com/allanpichardo/Unity-Beat-Detection</a>). It conveniently provides Unity Events for <kbd class="calibre13">onBeat</kbd>, which we'll use. (It also provides  <kbd class="calibre13">onSpectrum</kbd> events, with music frequency bands per frame, which you could use too, for example, to change the color of the fireball or other things based on frequency bands.)</p>
<ol class="calibre15">
<li class="calibre12">Download the <kbd class="calibre13">AudioProcessor.cs</kbd> script from GitHub (we've provided a copy with the files for this book for your convenience)</li>
<li class="calibre12">Drag the file into your <kbd class="calibre13">Scripts</kbd> folder (or use Assets | Import New Asset)</li>
</ol>
<p class="calibre3">For your music, find any MP3 or WAV file that has a nice beat, and import it into your project. We looked on SoundCloud NoCopyrightSounds track (<a href="https://soundcloud.com/nocopyrightsounds/tracks" class="calibre10">https://soundcloud.com/nocopyrightsounds/tracks</a>) to find one named <em class="calibre14">Third Prototype - Dancefloor</em> (<a href="http://ncs.io/DancefloorNS" class="calibre10">http://ncs.io/DancefloorNS</a>).</p>
<ol class="calibre15">
<li class="calibre12">In Project window, create a folder named Audio</li>
<li class="calibre12">Drag your music file into the Audio folder (or use Assets | Import New Asset)</li>
</ol>
<p class="calibre3">To implement this feature, we'll make a MusicController and then modify the <kbd class="calibre13">ShooterBallGame</kbd> script to use its beats to fireballs. In Unity, do the following:</p>
<ol class="calibre15">
<li class="calibre12">In Hierarchy, create an Empty game object and name it MusicController</li>
<li class="calibre12">Add the AudioProcessor script as a component</li>
<li class="calibre12">Note that it automatically adds an Audio Source component too</li>
<li class="calibre12">Drag your imported music file onto AudioClip slot</li>
<li class="calibre12">Drag MusicController itself onto Audio Source slot</li>
</ol>
<p>Note the G Threshold parameter on Audio Process. You can use this to adjust the sensitivity of the beat recognition algorithm.</p>
<p class="calibre3">Now, update the <kbd class="calibre13">ShooterBallGame</kbd> script on <kbd class="calibre13">GameController</kbd> as follows:</p>
<pre class="calibre18">    void Start()<br class="title-page-name"/>    {<br class="title-page-name"/>        if (shootAt == null)<br class="title-page-name"/>            shootAt = Camera.main.transform;<br class="title-page-name"/>        pool = GetComponent&lt;ObjectPooler&gt;();<br class="title-page-name"/><br class="title-page-name"/>        AudioProcessor processor = FindObjectOfType&lt;AudioProcessor&gt;();<br class="title-page-name"/>        processor.onBeat.AddListener(onBeatDetected);<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    void onBeatDetected()<br class="title-page-name"/>    {<br class="title-page-name"/>        if (Random.value &gt; 0.5f)<br class="title-page-name"/>        {<br class="title-page-name"/>            shooterId = 1;<br class="title-page-name"/>            shooter = shooter1;<br class="title-page-name"/>        } else<br class="title-page-name"/>        {<br class="title-page-name"/>            shooterId = 0;<br class="title-page-name"/>            shooter = shooter0;<br class="title-page-name"/>        }<br class="title-page-name"/>        ShootBall();<br class="title-page-name"/>    }</pre>
<p class="calibre3">It's very similar to the previous version, but instead of calling <kbd class="calibre13">ShootBall</kbd> from <kbd class="calibre13">Update</kbd>, based on the time interval, we call it from <kbd class="calibre13">onBeatDetected</kbd>. In <kbd class="calibre13">Start</kbd>, we add <kbd class="calibre13">onBeatDetected</kbd> as an <kbd class="calibre13">onBeat</kbd> event listener.</p>
<p class="calibre3">Also, we've decided to randomly decide which shooter to use rather than just alternating back and forth.</p>
<p class="calibre3">Press Play and go at it! <em class="calibre14">Whoohoo,</em> we have our own version of Audio Shield! A screenshot of active gameplay is shown here:</p>
<div><img src="img/9c0c2270-17b5-46db-bebf-6ec52f55ca40.png" class="calibre68"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="calibre3">In this chapter, we built a game that uses Unity's Physics Engine and a number of other features. First, we explained in layman's terms the relationship between Rigidbody, Colliders, and Physic Materials, and explored how the physics engine uses these to determine the velocity and collision of objects in the scene.</p>
<p class="calibre3">Then, we considered the life cycle of game objects and implemented an object pooler that helps avoid memory fragmentation and garbage collection, which can lead to performance problems and VR discomfort.</p>
<p class="calibre3">Using what we learned, we implemented several variations of a ball game, first aiming for a target with your head, then using hand paddles. We modified the game so that, instead of serving balls from above-using gravity, we shoot them from in front and apply a velocity vector. Lastly, we juiced up our game, changing the bouncy balls into fireballs, adding a cool level environment, and synchronizing the fireballs to music beats. In the end, we have a good start to making our own version of the Audio Shield VR game.</p>
<p class="calibre3">In the next chapter, we will see another more practical example of a virtual interactive space. We are going to build an interactive art gallery space that you can move through and query the artwork for information and details.</p>


            

            
        
    </body></html>