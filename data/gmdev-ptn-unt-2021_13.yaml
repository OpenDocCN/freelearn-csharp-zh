- en: Implementing a Drone with the Strategy Pattern
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用策略模式实现无人机
- en: In this chapter, we are going to implement enemy drones that fly around the
    race track and attack the player by shooting laser beams. They are little annoying
    robotic pests that will test the player's reflexes. Our drones will have a single
    attack that consists of firing a continuous laser beam at a 45-degree angle. To
    create the illusion of autonomous intelligence, the drones can be assigned three
    distinct attack maneuvers at runtime. Each maneuver is a repetitive series of
    predictable movements. Individually, the drone's behavior may look robotic, but
    when they are placed in a formation at specific positions on the race track, it
    could look like they are forming a strategy to outmaneuver the player.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现绕着赛道飞行并射击激光束攻击玩家的敌机无人机。它们是小小的讨厌的机器人害虫，将测试玩家的反应能力。我们的无人机将有一种单一的攻击方式，即以
    45 度角发射连续的激光束。为了创造自主智能的错觉，无人机可以在运行时分配三种不同的攻击动作。每个动作都是一个可预测运动的重复序列。单独来看，无人机的行为可能看起来很机械，但当我们把它们放在赛道特定位置上时，它们可能看起来像是在制定策略以战胜玩家。
- en: And so, I'm proposing that we use the Strategy pattern to implement the various
    drone behaviors. The main reason for this choice is that this pattern allows us
    to assign specific behavior to an object at runtime. But first, let's break down
    the specifications of the pattern and the design intentions of our enemy drone.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我建议我们使用策略模式来实现各种无人机行为。选择这个模式的主要原因是因为它允许我们在运行时为对象分配特定的行为。但首先，让我们分析一下模式的规范和我们的敌机无人机的设计意图。
- en: This chapter includes simplified skeleton code examples for the sake of brevity
    and clarity. If you wish to review a complete implementation of the pattern in
    the context of an actual game project, open the `FPP` folder in the GitHub project.
    You can find the link in the *Technical requirements* section.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁和清晰，本章包括简化的代码示例。如果你希望在一个实际游戏项目中查看模式的完整实现，请打开 GitHub 项目中的 `FPP` 文件夹。你可以在
    *技术要求* 部分找到链接。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An overview of the Strategy pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式的概述
- en: Implementing enemy drone attack behaviors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现敌机无人机攻击行为
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is hands-on, so you will need to have a basic understanding of
    Unity and C#.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是实践性的，因此你需要对 Unity 和 C# 有基本的了解。
- en: The code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter11](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter11).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 GitHub 上找到，地址为 [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter11](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter11)。
- en: Check out the following video to see the code in action: [https://bit.ly/2TdeoL4](https://bit.ly/2TdeoL4)[.](https://bit.ly/2TdeoL4)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际效果：[https://bit.ly/2TdeoL4](https://bit.ly/2TdeoL4)[.](https://bit.ly/2TdeoL4)
- en: Understanding the Strategy pattern
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解策略模式
- en: The primary goal of the Strategy pattern is to defer the decision of which behavior
    to use at runtime. This is made possible because the Strategy pattern lets us
    define a family of behaviors that are encapsulated in individual classes that
    we call strategies. Each strategy is interchangeable and can be assigned to a
    target context object to change its behavior.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式的主要目标是推迟在运行时决定使用哪种行为的决策。这是因为策略模式允许我们定义一组封装在称为策略的单独类中的行为。每个策略都是可互换的，并且可以被分配给目标上下文对象以改变其行为。
- en: 'Let''s visualize the key elements of the pattern with this UML diagram:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这个 UML 图来可视化模式的关键元素：
- en: '![](img/75e1b61e-a602-4cc7-bdf4-166eeb5a4d7d.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/75e1b61e-a602-4cc7-bdf4-166eeb5a4d7d.png)'
- en: Figure 11.1 – UML diagram of the Strategy pattern
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 策略模式的 UML 图
- en: 'Here''s a breakdown of the key players of the pattern:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个模式的关键角色的分解：
- en: '**Context** is the class that uses the various concrete strategy classes and
    interacts with them through the Strategy interface.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文** 是使用各种具体策略类并通过策略接口与它们交互的类。'
- en: The **Strategy** interface is common to all concrete strategy classes. It exposes
    a method that the `Context` class can use to execute a strategy.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略** 接口对所有具体策略类都是通用的。它公开了一个方法，`上下文` 类可以使用它来执行策略。'
- en: '**Concrete Strategy **classes, also known as **strategies**, are concrete implementations
    of variants of algorithms/behaviors that can be applied to a `Context` object
    at runtime.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体策略**类，也称为**策略**，是算法/行为变体的具体实现，这些变体可以在运行时应用于`上下文`对象。'
- en: At the moment, these concepts might sound very abstract, but in practice, they
    are quite easy to understand, as we are going to see later in this book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这些概念可能听起来非常抽象，但在实践中，它们很容易理解，正如我们将在本书后面看到的。
- en: The Strategy pattern is a behavioral software design pattern; its closest cousin
    is the State pattern. We can use both to encapsulate a set of behaviors in individual
    classes. You should use the Strategy pattern when you want to select a behavior
    at runtime and apply it to an object. You can also use the State pattern when
    you want an object to change its behavior when its internal state changes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式是一种行为软件设计模式；其最接近的亲戚是状态模式。我们可以使用两者来封装一组行为在单独的类中。当你想在运行时选择一个行为并将其应用于对象时，你应该使用策略模式。你还可以在想要对象在内部状态改变时改变其行为时使用状态模式。
- en: Benefits and drawbacks of the Strategy pattern
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略模式的优缺点
- en: 'These are some of the benefits of the Strategy pattern:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式的一些优点如下：
- en: '**Encapsulation**: A clear benefit of this pattern is that it enforces variations
    of algorithms to be encapsulated in individual classes. Hence, this helps us avoid
    using long conditional statements while keeping our code structured.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**: 这种模式的一个明显优点是它强制算法的变体被封装在单独的类中。因此，这有助于我们避免使用长条件语句，同时保持代码结构化。'
- en: '**Runtime**: The main benefit of this pattern is that it implements a mechanism
    that permits us to swap algorithms that an object is using at runtime. This approach
    makes our objects more dynamic and open for extension.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时**: 这种模式的主要优点是实现了一种机制，允许我们在运行时交换对象使用的算法。这种方法使我们的对象更加动态和易于扩展。'
- en: 'The following are some potential drawbacks of the Strategy pattern:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些策略模式的潜在缺点：
- en: '**Client**: The client class must be aware of the individual strategies and
    the variations in the algorithm they implement so as to know which one to select.
    Therefore, the client becomes responsible for making sure that an object is behaving
    as expected during its lifespan.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户**: 客户类必须了解它们所实现的算法的个体策略和变体，以便知道选择哪一个。因此，客户负责确保对象在其生命周期内表现如预期。'
- en: '**Confusion**: Because the Strategy and State patterns are so similar in structure
    but have different intents, confusion could arise when you''re choosing which
    one to use and in what context. In most cases, it''s not an issue, but if you
    are working with a team of programmers, depending on the various levels of knowledge
    of the subject matter, some colleagues might not understand your choice of pattern.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混淆**: 由于策略模式和状态模式在结构上非常相似，但意图不同，因此在选择使用哪一个以及在使用上下文时可能会产生混淆。在大多数情况下，这不是问题，但如果你在与程序员团队合作，根据对主题知识的不同了解水平，一些同事可能不理解你选择的模式。'
- en: I believe it's essential to have regular open discussions about architecture,
    patterns, and best practices with your colleagues. If you can agree as a team
    on common approaches when using a specific set of design patterns, you will end
    up with a more consistent overall architecture and cleaner code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为与同事定期就架构、模式和最佳实践进行开放讨论是至关重要的。如果你能作为一个团队就使用特定设计模式时的共同方法达成一致，你最终将拥有更一致的整体架构和更干净的代码。
- en: When to use the Strategy pattern
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用策略模式
- en: When I get tasked with implementing behaviors for an enemy character, the first
    options I consider are the State pattern or a **finite state machine** (**FSM**)
    since most of the time, characters are stateful.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我被分配实现敌人角色的行为时，我首先考虑的选项是状态模式或**有限状态机**（**FSM**），因为大多数情况下，角色是有状态的。
- en: 'But sometimes, I might use the Strategy pattern if the following conditions
    are met:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，如果满足以下条件，我可能会使用策略模式：
- en: I have an entity with several variants of the same behavior, and I want to encapsulate
    them in individual classes.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我有一个具有相同行为多个变体的实体，并且我希望将它们封装在单独的类中。
- en: I want to assign specific behavior variants to an entity at runtime, without
    the need to take its current internal state into consideration.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我希望在运行时为实体分配特定的行为变体，而无需考虑其当前内部状态。
- en: I need to apply a behavior to an entity so that it can accomplish a specific
    task based on selection criteria that are defined at runtime.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我需要将一种行为应用到实体上，以便它可以根据在运行时定义的选择标准完成特定的任务。
- en: 'The third point is probably the main reason I chose to use the Strategy pattern
    over the State pattern to implement the enemy drone presented in this chapter.
    The behavior of the drone is robotic; it has a singular task: attack the player.
    It doesn''t make any alterations to its actions based on internal state changes.
    It only needs to be assigned an attack behavior at runtime to accomplish its task
    of attacking the player, which makes it the right candidate for the Strategy pattern
    in its current design.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个点可能是我选择使用策略模式而不是状态模式来实现本章中介绍的敌方无人机的主要原因。无人机的行为是机械的；它有一个单一的任务：攻击玩家。它不会根据内部状态的变化对其动作进行任何修改。它只需要在运行时分配攻击行为，以完成攻击玩家的任务，这使得它成为当前设计中策略模式的合适候选者。
- en: It's important to note that potential use cases of the Strategy pattern are
    not limited to implementing enemy characters. For example, we could use it to
    encapsulate various encryption algorithms to apply to a saved file, depending
    on the target platform. Or, if we are working on a fantasy game, we could use
    it to encapsulate the individual behaviors of a family of spells that players
    can apply to a target entity. Therefore, the potential use cases for this pattern
    are broad and can be applied to various contexts, ranging from core systems to
    gameplay mechanics.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，策略模式的潜在用例不仅限于实现敌方角色。例如，我们可以用它来封装各种加密算法，以便根据目标平台应用保存的文件。或者，如果我们正在制作一款幻想游戏，我们可以用它来封装玩家可以应用于目标实体的魔法家族的各个行为。因此，这种模式的潜在用例很广泛，可以应用于各种上下文，从核心系统到游戏玩法机制。
- en: In the next section, we are going to review the design intentions of our enemy
    drone.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾敌方无人机的设计意图。
- en: Designing an enemy drone
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计敌方无人机
- en: The enemy drones in our game are not very smart; there is no artificial intelligence
    running behind the scene. These are robots with robotic behaviors, and it's common
    in video games to have enemies with predictable automated behaviors running in
    a loop. For instance, the Goombas in the original Super Mario Bros just walk in
    one direction; they are not aware of the presence of Mario or react to him. They
    are simply running an algorithm to make them wander in a path until they collide
    with an obstacle. Alone, they are not a threat, but if they are put in a formation
    or positioned at a point in the map in which navigation is difficult, they can
    become challenging to avoid.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的敌方无人机并不非常聪明；背后没有运行人工智能。这些是具有机器人行为的机器人，在视频游戏中，敌人具有可预测的自动化行为并在循环中运行是很常见的。例如，在原始《超级马里奥兄弟》中的Goombas只是朝一个方向走；他们没有意识到马里奥的存在，也不会对他做出反应。他们只是在运行一个算法，使他们沿着路径徘徊，直到撞到障碍物。单独来看，他们并不构成威胁，但如果将它们编队或定位在地图上导航困难的位置，它们就会变得难以躲避。
- en: We will be using the same approach for our enemy drones. Individually, they
    are easy to defeat because they can't change their behaviors based on the player's
    movements, but in a squad, they can be challenging to avoid.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的方法来设计我们的敌方无人机。单独来看，它们很容易被打败，因为它们不能根据玩家的动作改变行为，但在编队中，它们可能很难躲避。
- en: Our drone has three distinct attack maneuvers; each revolves around a specific
    set of movements that are predictable but still challenging to counter when the
    drones are in a squad formation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的无人机有三种不同的攻击动作；每个动作都围绕一组特定的动作进行，这些动作是可预测的，但在无人机编队时仍然难以反击。
- en: 'Let''s look at each maneuver:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看每个动作：
- en: '**Bobbing Maneuver**: In a bobbing maneuver, the drone moves up and down at
    high speed while shooting a laser beam.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下摆动动作**：在上下摆动动作中，无人机以高速上下移动，同时发射激光束。'
- en: '**Weaving Maneuver**: For the weaving maneuver, the drone moves horizontally
    at high speed, while shooting. The weaving maneuver is limited to the distance
    between the two rails of a track.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**穿梭动作**：对于穿梭动作，无人机以高速水平移动，同时射击。穿梭动作限制在轨道两条轨道之间的距离内。'
- en: '**Fallback Maneuver**: For the fallback maneuver, the drone moves backward
    while shooting. The top speed of the drone can match that of the player''s bike,
    but can only move back for a limited amount of time.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回退动作**：对于回退动作，无人机在射击的同时向后移动。无人机的最高速度可以与玩家的自行车相匹配，但只能向后移动有限的时间。'
- en: 'The following diagram illustrates the preceding maneuvers:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了前面的机动：
- en: '![](img/a2c7f88d-444e-47d8-880b-a01102961ed3.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a2c7f88d-444e-47d8-880b-a01102961ed3.png)'
- en: Figure 11.2 – Illustration of the drone's attack maneuvers
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 无人机攻击机动的示意图
- en: 'The enemy drone has a single weapon: a front-facing laser beam that''s fired
    at a 45-degree angle toward the ground. The following diagram illustrates the
    laser weapon of the drone:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人无人机有一件武器：一个向前发射的45度角激光束。以下图示展示了无人机的激光武器：
- en: '![](img/d26c7ff3-661e-4fa1-8faf-a428685bd87e.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d26c7ff3-661e-4fa1-8faf-a428685bd87e.png)'
- en: Figure 11.3 – Illustration of the drone's weapon attack
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 无人机武器攻击的示意图
- en: As we can see, the player must avoid the attack by navigating around the drone
    at high speed. If hit by the beam, the bike's front-facing shield will lose a
    certain amount of power. If the shield becomes depleted, the vehicle will explode
    on the next hit, and it will be game over.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，玩家必须通过高速绕过无人机来避免攻击。如果被光束击中，自行车的正面护盾将损失一定量的能量。如果护盾耗尽，车辆将在下一次被击中时爆炸，游戏结束。
- en: In the next section, we are going to translate this design into code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将把这个设计转换成代码。
- en: Implementing an enemy drone
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现敌人无人机
- en: In this section, we will write a skeleton implementation of the Strategy pattern
    and the individual attack behaviors of the drone enemy. The code in this section
    may seem oversimplified in certain aspects. Still, the end goal is not to have
    a complete implementation of the enemy drone but to understand the basics of the
    Strategy pattern.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写策略模式的基本实现和无人机敌人的单个攻击行为。本节中的代码在某些方面可能看起来过于简化。然而，最终目标不是实现完整的敌人无人机，而是理解策略模式的基本原理。
- en: Steps to implementing an enemy drone
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现敌人无人机的步骤
- en: 'Let''s start by implementing the main ingredients of the Strategy pattern:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先实现策略模式的主要组成部分：
- en: 'Our first element is the Strategy interface; all our concrete strategies will
    use it:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一个元素是策略接口；我们所有的具体策略都将使用它：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that we are passing a parameter of the `Drone` type to the `Maneuver()`
    method. This is an important detail we will review later.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在将`Drone`类型的参数传递给`Maneuver()`方法。这是一个我们稍后会回顾的重要细节。
- en: 'Next up is our `Drone` class; it''s going to use our concrete strategies, so
    in the overall structure of the Strategy pattern, we will consider it to be our
    `Context` class:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是我们的`Drone`类；它将使用我们的具体策略，因此在策略模式的整体结构中，我们将将其视为我们的`Context`类：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Most of the lines of code in this class are for raycasting debugging information;
    we can safely ignore them. However, the following section is essential to understand:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中的大多数代码行都是用于射线投射调试信息；我们可以安全地忽略它们。然而，以下部分是理解的关键：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `ApplyStrategy()` method contains the core mechanism of the Strategy pattern.
    If we look closely, we can see that the method in question accepts a concrete
    strategy of the `IManeuverBehaviour` type as a parameter. And this is where things
    get very interesting. A `Drone` object can communicate with the concrete strategies
    it received through the `IManeuverBehaviour` interface. Thus, it only needs to
    call `Maneuver()` to execute a strategy at runtime. Hence, a `Drone` object doesn't
    need to know how a strategy's behavior/algorithm is executed – it just needs to
    be aware of its interface.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplyStrategy()`方法包含了策略模式的核心机制。如果我们仔细观察，我们可以看到，相关的方法接受一个`IManeuverBehaviour`类型的具体策略作为参数。这里事情变得非常有趣。一个`Drone`对象可以通过`IManeuverBehaviour`接口与其接收到的具体策略进行通信。因此，它只需要调用`Maneuver()`在运行时执行策略。因此，一个`Drone`对象不需要知道策略的行为/算法是如何执行的——它只需要了解其接口。'
- en: 'Now, let''s implement the concrete strategy classes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现具体策略类：
- en: 'The following class implements the bopping maneuver:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下类实现了弹跳机动：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following class implements the weaving maneuver:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下类实现了编织机动：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, let''s implement the fallback maneuver:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们实现回退机动：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You may have noticed that the code of each class is quite similar, even repetitive
    in certain parts. This accounts for one of the reasons we are using the Strategy
    pattern – we want to encapsulate variations of similar behaviors so that they
    are easier to maintain individually. But also, imagine how messy our `Drone` class
    would be if we tried to implement the bopping, weaving, and fallback behaviors
    in a single class. We would find ourselves in a bloated `Drone` class that's potentially
    filled to the brim with conditional statements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，每个类的代码相当相似，甚至在某些部分重复。这就是我们使用策略模式的原因之一——我们希望封装类似行为的变体，以便更容易单独维护。但同样，想象一下，如果我们试图在一个类中实现跳跃、穿梭和回退行为，我们的`Drone`类会多么混乱。我们可能会发现自己在一个充满条件语句的膨胀的`Drone`类中。
- en: I would not recommend using coroutines to animate non-humanoid entities. Instead,
    I suggest using a Tween engine such as DOTween since you can animate objects with
    less code while getting better results. We are using coroutines in this chapter
    to avoid external dependencies and make our code easy to port. To learn more about
    DOTween, go to [http://dotween.demigiant.com](http://dotween.demigiant.com/).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我不建议使用协程来动画化非人类实体。相反，我建议使用如DOTween之类的Tween引擎，因为你可以用更少的代码来动画化对象，并获得更好的效果。我们在这章中使用协程是为了避免外部依赖，并使我们的代码易于移植。要了解更多关于DOTween的信息，请访问 [http://dotween.demigiant.com](http://dotween.demigiant.com/)。
- en: Testing the enemy drone implementation
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试敌方无人机实现
- en: 'And now for the fun part – testing our implementation. It''s going to be an
    easy one since all we need to do is attach the following client class to an empty
    `GameObject` in a Unity scene:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候进行有趣的部分了——测试我们的实现。这将会很容易，因为我们需要做的只是将以下客户端类附加到Unity场景中的一个空`GameObject`上：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In your instance of Unity, if you included all the scripts we wrote in the
    preceding sections in your project, you should see a single button on the screen
    when you start it called Spawn Drone, as shown in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Unity实例中，如果你在项目中包含了前面几节中编写的所有脚本，当你启动它时，你应该在屏幕上看到一个名为“Spawn Drone”的单个按钮，如下面的截图所示：
- en: '![](img/75f67a2a-f8c9-4b8b-a0c3-0f07bd89a6b2.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75f67a2a-f8c9-4b8b-a0c3-0f07bd89a6b2.png)'
- en: Figure 11.4 – The code example in action inside Unity
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 在Unity中运行的代码示例
- en: If you click on the scene's primary button, a new cube representing a Drone
    entity should appear at a random position while executing a randomly selected
    attack maneuver.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击场景的主按钮，一个代表无人机实体的新立方体应该出现在一个随机位置，同时执行一个随机选择的攻击机动。
- en: Reviewing the enemy drone implementation
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查敌方无人机实现
- en: In the preceding code example, the client class acts like a spawner that randomly
    assigns a strategy to a new drone instance. This could be an interesting approach
    for a real-world use case. But there are many other approaches we could have used
    to choose which strategy to assign to a drone. It could be based on specific rules
    and factors that are only known at runtime. Therefore, it's not limited to randomness
    but can also be deterministic and rule-based.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，客户端类充当一个生成器，随机分配一个策略给一个新的无人机实例。这对于现实世界的用例来说可能是一个有趣的方法。但是，我们还可以使用许多其他方法来选择分配给无人机的策略。这可以基于仅在运行时才知道的特定规则和因素。因此，它不仅限于随机性，还可以是确定性和基于规则的。
- en: Reviewing alternative solutions
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查替代解决方案
- en: There's one glaring issue with the code examples presented in this chapter.
    We encapsulated attack maneuver behaviors into distinct strategy classes, but
    each maneuver is nothing more than a single animation running on a loop. So, in
    an actual game project that's been built by a production team that includes animators,
    I would not have animated the enemy drones in code by using coroutines or even
    a Tween animation engine. Instead, I would ask an animator to author some detailed
    attack maneuver animations in an external authoring tool and then import them
    into Unity as animation clips. I would then have used Unity's native animation
    system and its state machine feature to assign attack maneuver animations to a
    drone dynamically.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的代码示例有一个明显的问题。我们将攻击机动行为封装到不同的策略类中，但每个机动不过是一个在循环中运行的单一动画。因此，在一个由包括动画师在内的制作团队构建的实际游戏项目中，我不会通过使用协程或甚至一个Tween动画引擎在代码中动画化敌方无人机。相反，我会要求一个动画师在一个外部创作工具中创作一些详细的攻击机动动画，然后将它们作为动画剪辑导入Unity。然后我会使用Unity的本地动画系统和其状态机功能来动态地将攻击机动动画分配给无人机。
- en: Using this approach, I would have gained quality in the animations and the flexibility
    of transitioning smoothly from one attack behavior to another, if I decide that
    the drones can switch attacks when an internal state changes. Therefore, I would
    have moved away from the idea of encapsulating each attack behavior into a strategy
    class and instead defined them as finite states. This switch would not be a dramatic
    change in design as the concepts that drive the FSM, State, and Strategy patterns
    are closely related.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我决定无人机可以在内部状态改变时切换攻击，那么使用这种方法，我将在动画质量和从一种攻击行为平滑过渡到另一种攻击行为之间的灵活性方面获得提升。因此，我会放弃将每个攻击行为封装到策略类中的想法，而是将它们定义为有限状态。这种切换不会在设计中引起重大变化，因为驱动有限状态机（FSM）、状态和策略模式的概念是紧密相关的。
- en: Even though the Strategy pattern's implementation in the example presented in
    this chapter is valid, it's wise to consider what can be achieved natively with
    Unity's animation system first when you're managing an entity's animation set.
    But imagine another use case in which we need to implement variations of a motion
    detection algorithm and assign them to a drone at runtime. In that context, the
    Strategy pattern would be an excellent choice to build that system.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章中展示的策略模式实现是有效的，但在管理实体的动画集时，首先考虑使用Unity的动画系统原生的功能是明智的。但想象另一种用例，其中我们需要实现运动检测算法的变体，并在运行时将它们分配给无人机。在这种情况下，策略模式将是构建该系统的绝佳选择。
- en: You can read the official documentation on Unity's native animation system at [https://docs.unity3d.com/2021.2/Documentation/Manual/AnimationOverview.html](https://docs.unity3d.com/2021.2/Documentation/Manual/AnimationOverview.html).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.unity3d.com/2021.2/Documentation/Manual/AnimationOverview.html](https://docs.unity3d.com/2021.2/Documentation/Manual/AnimationOverview.html)上阅读Unity原生动画系统的官方文档。
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we used the Strategy pattern to implement our game's first
    enemy ingredient, a flying, laser-shooting drone. By using this pattern, we encapsulated
    each variant of the drone's attack maneuvers in individual classes. This approach
    made our code easier to maintain by avoiding having bloated classes filled with
    lengthy conditional statements. Now, we can quickly write new attack maneuver
    variations or adjust existing ones. Hence, we have given ourselves the flexibility
    to be creative and test out new ideas quickly, which is a vital part of game development.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了策略模式来实现游戏中的第一个敌人成分，一个会飞的、激光射击的无人机。通过使用这种模式，我们将无人机攻击动作的每个变体封装在单独的类中。这种方法通过避免拥有充满冗长条件语句的臃肿类，使我们的代码更容易维护。现在，我们可以快速编写新的攻击动作变体或调整现有的动作。因此，我们为自己提供了创造性和快速测试新想法的灵活性，这是游戏开发的重要部分。
- en: In the next chapter, we will start working on a weapon system and explore the
    Decorator pattern.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始着手构建武器系统，并探索装饰者模式。
