- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Running Applications On-Premises and in the Cloud
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地和云中运行应用程序
- en: Up to the last chapter, we added additional functionality to the Codebreaker
    application; in [*Chapter 15*](B21217_15.xhtml#_idTextAnchor349), we added services
    communicating with asynchronous communication. We used Azure Storage queues and
    Azure Event Hubs with the Azure Codebreaker variant; with the on-premises version,
    we added a Kafka container.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到上一章为止，我们在Codebreaker应用程序中添加了额外的功能；在第[*15章*](B21217_15.xhtml#_idTextAnchor349)中，我们添加了使用异步通信进行通信的服务。我们使用了Azure
    Storage队列和Azure Event Hubs与Azure Codebreaker变体；在本地版本中，我们添加了一个Kafka容器。
- en: In this chapter, we look at what needs to be known when deploying the solution
    to Microsoft Azure and to on-premises environments. Using Azure, we deployed the
    solution to an Azure Container Apps environment from [*Chapter 5*](B21217_05.xhtml#_idTextAnchor110)
    onward. The Azure Container Apps environment uses Kubernetes behind the scenes.
    In this chapter, we directly deploy to a Kubernetes cluster, which can easily
    be used in on-premises environments and in any cloud.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨将解决方案部署到微软Azure和本地环境时需要了解的内容。使用Azure，我们从[*第5章*](B21217_05.xhtml#_idTextAnchor110)开始部署解决方案到Azure
    Container Apps环境。Azure Container Apps环境在幕后使用Kubernetes。在本章中，我们直接部署到一个Kubernetes集群，它很容易在本地环境和任何云中使用。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Customizing deployment with C# and Aspire
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C#和Aspire自定义部署
- en: Creating a Kubernetes cluster with Azure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Azure创建Kubernetes集群
- en: Deploying the application to Kubernetes with Aspir8
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Aspir8将应用程序部署到Kubernetes
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: With this chapter, like the previous chapters, you need an Azure subscription,
    .NET 8 with .NET Aspire, and Docker Desktop. In this chapter, we’ll use a new
    tool, Aspir8, to deploy the application to a Kubernetes cluster.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，你需要一个Azure订阅、.NET 8以及.NET Aspire，以及Docker Desktop。在本章中，我们将使用一个新的工具，Aspir8，将应用程序部署到Kubernetes集群。
- en: 'The code for this chapter can be found in this GitHub repository: [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下GitHub仓库中找到：[https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/)。
- en: In the `ch16` folder, you’ll see the projects that can be deployed. The most
    important project for this chapter is `Codebreaker.AppHost`, which defines the
    app model using Azure native cloud services, as well as a configuration that can
    be used with an on-premises environment. This configuration is also used to deploy
    the solution to a Kubernetes cluster.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ch16`文件夹中，你会看到可以部署的项目。本章最重要的项目是`Codebreaker.AppHost`，它使用Azure原生云服务定义了应用程序模型，以及可以与本地环境一起使用的配置。此配置还用于将解决方案部署到Kubernetes集群。
- en: Thinking about deployment in production
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑生产环境中的部署
- en: The Codebreaker solution uses several different native Azure cloud services.
    In [*Chapter 8*](B21217_08.xhtml#_idTextAnchor183), you saw how we can use **GitHub
    Actions** to deploy to different environments, such as development, testing, staging,
    and production environments using approvals. As more and more services have been
    added in the last chapters, the deployments need to be updated as well.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker解决方案使用了几种不同的原生Azure云服务。在第[*8章*](B21217_08.xhtml#_idTextAnchor183)中，你看到了我们如何使用**GitHub
    Actions**通过批准来部署到不同的环境，如开发、测试、预生产和生产环境。随着上一章中添加了越来越多的服务，部署也需要相应更新。
- en: With many organizations, deployments to production environments are somewhat
    disconnected from the development environment. Often, a different team from the
    development organization manages these deployments using different tools.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多组织中，生产环境部署与开发环境有些脱节。通常，来自开发组织的不同团队使用不同的工具来管理这些部署。
- en: '**Continuous Integration** (**CI**) and **Continuous Development** (**CD**)
    are often used in repositories separated from the source code. Different products
    such as GitHub Actions, Azure DevOps pipelines, and many third-party offerings
    are used.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）和**持续部署**（**CD**）通常用于与源代码分离的仓库中。不同的产品，如GitHub Actions、Azure
    DevOps管道以及许多第三方提供的产品，都被使用。'
- en: From the pipelines, it’s possible to trigger the Azure Developer CLI (azd),
    use Bicep scripts, directly use the Azure CLI or PowerShell scripts, or use third-party
    offerings such as Terraform, Ansible, Chef, and Puppet.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从管道中，可以触发Azure Developer CLI（azd），使用Bicep脚本，直接使用Azure CLI或PowerShell脚本，或者使用Terraform、Ansible、Chef和Puppet等第三方产品。
- en: When deciding between the different products, it’s also necessary to think about
    the requirements for the production environment, and what’s different from the
    development environment. With the production environment, different loads are
    expected. For a load test, it’s useful to run the same infrastructure as used
    with the production environment. With this, it’s important that the complete infrastructure
    for an environment needs to be easily creatable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定不同产品之间时，也需要考虑生产环境的要求，以及与开发环境的不同之处。在生产环境中，预计会有不同的负载。对于负载测试，使用与生产环境相同的基础设施是有用的。因此，对于环境的完整基础设施，需要能够轻松创建。
- en: 'The infrastructure needs to map the needs of the business – what income is
    lost if things are not working as expected? We need to think about these topics:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施需要映射业务需求——如果事情没有按预期工作，会损失多少收入？我们需要考虑以下这些话题：
- en: '**Scalability**: Adapting to changing demands. Demand might increase slightly
    over time, or there might also be spikes in demand.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：适应不断变化的需求。需求可能会随着时间的推移略有增加，或者也可能有需求激增。'
- en: '**Reliability**: Making sure that the services work as expected.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性**：确保服务按预期工作。'
- en: '**Availability**: Making sure that the services are available from where the
    customers are. Availability metrics are **Mean Time Between Failures** (**MTBF**)
    – how long until a failure happens – and **Mean Time To Repair** (**MTTR**) –
    how long it takes until it’s running again.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：确保服务在客户所在的位置可用。可用性指标是**平均故障间隔时间**（**MTBF**）——故障发生前的平均时间——和**平均修复时间**（**MTTR**）——服务再次运行所需的时间。'
- en: '**Recovery**: If there’s an outage, recovery metrics that can be used are **Recovery
    Point Time** (**RTO**) – the acceptable time for apps to be unavailable – and
    **Recovery Point Objective** (**RPO**) – the maximum allowed time for a data loss.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恢复**：如果发生中断，可以使用的恢复指标是**恢复点时间**（**RTO**）——应用程序不可用的可接受时间——和**恢复点目标**（**RPO**）——数据损失的最大允许时间。'
- en: These requirements need to be compared to the business needs. With **redundancy**,
    resources are replicated, and multiple services are running. There’s not a single
    point of failure. Data can be replicated within one data center in an Azure region,
    between different data centers in an Azure region (Azure **availability zones**),
    and across different Azure regions (using a **multi-region** architecture).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求需要与业务需求进行比较。通过**冗余**，资源被复制，并且多个服务正在运行。没有单点故障。数据可以在Azure区域内的一个数据中心内复制，在Azure区域的不同数据中心之间（Azure
    **可用区**），以及在不同Azure区域之间（使用**多区域**架构）复制。
- en: Another requirement for the production environment is to enhance security. Data
    protection needs to make sure personal user data is safe. With **encryption at
    rest**, data is stored encrypted in the database. Instead of a service-managed
    key, customer-managed keys can be used. Using customer-managed keys is possible
    with many Azure services, but usually, different (more expensive) SKUs are required
    to enable customer-managed keys. Virtual networks are another option to enhance
    security. With subnets, it’s possible to restrict access to the database server.
    **Private endpoints** can be used to restrict access only to a specific service
    and prevent data exfiltration. IP firewall rules can be configured.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境的一个要求是增强安全性。数据保护需要确保个人用户数据安全。通过**静态加密**，数据在数据库中存储时被加密。而不是使用服务管理的密钥，可以使用客户管理的密钥。使用客户管理的密钥在许多Azure服务中是可能的，但通常需要不同的（更昂贵的）SKU来启用客户管理的密钥。虚拟网络是另一个增强安全性的选项。使用子网，可以限制对数据库服务器的访问。**私有端点**可以用来限制仅对特定服务的访问，防止数据泄露。可以配置IP防火墙规则。
- en: We can’t discuss all the different requirements here, but an important takeaway
    is that with production environments, we might need some additional Azure resources
    (such as virtual networks), different configurations, and other SKUs. See *Figure
    16**.1* for the Codebreaker application making use of multiple Azure regions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在这里讨论所有不同的要求，但一个重要的启示是，在生产环境中，我们可能需要一些额外的Azure资源（如虚拟网络），不同的配置和其他SKU。参见*图16*。1，了解Codebreaker应用程序如何利用多个Azure区域。
- en: '![Figure 16.1 – Codebreaker with virtual networks](img/B21217_16_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图16.1 – 带虚拟网络的Codebreaker](img/B21217_16_01.jpg)'
- en: Figure 16.1 – Codebreaker with virtual networks
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 – 带虚拟网络的Codebreaker
- en: This figure shows Azure regions in the US, Europe, and Asia, and Azure Cosmos
    DB replicated across the regions. The database is accessed from Container Apps
    running in the same region of the database. The frontends (Blazor) and backends
    (Game APIs) in one region can run in one Azure Container Apps environment, with
    the Game APIs service only accessible internally. Azure Application Gateway with
    a firewall configured is used to access the Blazor web application. Azure Traffic
    Manager can route across different regions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了美国、欧洲和亚洲的Azure区域，以及跨区域复制的Azure Cosmos DB。数据库由运行在数据库同一区域的Container Apps访问。同一区域的前端（Blazor）和后端（游戏API）可以在一个Azure
    Container Apps环境中运行，而游戏API服务仅限内部访问。使用配置了防火墙的Azure Application Gateway来访问Blazor
    Web应用程序。Azure Traffic Manager可以在不同区域之间进行路由。
- en: How does the Codebreaker solution fulfill all the requirements? With scalability,
    reliability, and security, all the resources used by the application need to be
    verified. In [*Chapter 12*](B21217_12.xhtml#_idTextAnchor294), we added a huge
    load on the Codebreaker services to test scaling up and scaling out. Due to the
    stateless nature of the developed services, the resources used also scale accordingly,
    and we anticipate no issues in meeting all the requirements. The Azure Cosmos
    DB database can replicate worldwide, even with multi-region writes to store games
    near the user for the best performance. We paid attention to the partition key,
    which doesn’t block other gamers’ writes to the database. Azure Event Hubs (added
    in [*Chapter 15*](B21217_15.xhtml#_idTextAnchor349)) offers a lot more performance
    than needed. The Standard SKU supports 1,000 events per second with one throughput
    unit. Additional throughput units can be added, and a switch to the Premium tier,
    which offers even more, could be done. An important aspect is to see what’s going
    on to react early, which was covered in [*Chapter 11*](B21217_11.xhtml#_idTextAnchor263).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker解决方案是如何满足所有要求的？具有可扩展性、可靠性和安全性，应用程序使用的所有资源都需要经过验证。在[*第12章*](B21217_12.xhtml#_idTextAnchor294)中，我们向Codebreaker服务添加了巨大的负载以测试扩展和扩展。由于开发服务的无状态特性，使用的资源也相应地扩展，我们预计在满足所有要求方面不会有问题。Azure
    Cosmos DB数据库可以全球复制，即使进行多区域写入以将游戏存储在用户附近，也能提供最佳性能。我们关注了分区键，它不会阻止其他游戏玩家对数据库的写入。Azure
    Event Hubs（在[*第15章*](B21217_15.xhtml#_idTextAnchor349)中添加）提供了比所需更多的性能。标准SKU支持每个吞吐量单位每秒1,000个事件。可以添加额外的吞吐量单位，并且可以切换到提供更多资源的Premium层级。一个重要的方面是看到正在发生什么，以便能够及时反应，这在[*第11章*](B21217_11.xhtml#_idTextAnchor263)中有所涉及。
- en: While many organizations have separate teams for development and infrastructure,
    this has some disadvantages.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多组织有独立负责开发和基础设施的团队，但这也有一些缺点。
- en: Using the .NET Aspire manifest created from the app model, we covered creating
    Bicep scripts in [*Chapter 6*](B21217_06.xhtml#_idTextAnchor137). These Bicep
    scripts can be customized to fulfill the requirements of the production environment.
    Using customized Bicep scripts has the disadvantage that changes on the app model
    don’t automatically reflect with the Bicep script. The Bicep script needs to be
    manually updated again.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B21217_06.xhtml#_idTextAnchor137)中，我们介绍了如何使用从应用模型创建的.NET Aspire清单来创建Bicep脚本。这些Bicep脚本可以根据生产环境的要求进行定制。使用定制Bicep脚本的不利之处在于，应用模型上的更改不会自动反映到Bicep脚本中。Bicep脚本需要手动再次更新。
- en: It would be great to use C# code to completely define the Azure infrastructure
    configuration with all the different aspects needed. When the app model is updated
    with this, the infrastructure configuration is changed at the same time.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果能够使用C#代码完全定义Azure基础设施配置，包括所有需要的不同方面，那将非常棒。当应用模型更新时，基础设施配置也会同时改变。
- en: Customizing deployments with C# and .NET Aspire
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用C#和.NET Aspire定制部署
- en: At the time of this writing, enhancements are in progress to make this happen.
    Currently, it’s just in experimental mode, and the APIs available are likely to
    change, thus we will only look briefly into this.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，正在进行增强以实现这一功能。目前，它仅处于实验模式，可用的API可能会发生变化，因此我们只会简要地探讨这一点。
- en: 'To define the .NET Aspire app model, APIs have an overload with a delegate
    parameter. For example, the `AddAzureKeyVault` method we used so far is an extension
    method for the `IDistributedApplicationBuilder` interface and uses a `name` parameter.
    A second overload specifies an additional `Action` delegate parameter. This overload
    has the `Experimental` attribute applied to mark that the API may change. The
    parameters used with this delegate are `IResourceBuilder<AzureKeyVaultResource>`,
    `ResourceModuleConstruct`, and `KeyVault`. This allows us to configure a secret
    retrieved from a parameter when creating Azure Key Vault:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义 .NET Aspire 应用程序模型，API 有一个带有委托参数的重载。例如，我们迄今为止使用的 `AddAzureKeyVault` 方法是
    `IDistributedApplicationBuilder` 接口的扩展方法，并使用一个 `name` 参数。第二个重载指定了一个额外的 `Action`
    委托参数。这个重载应用了 `Experimental` 属性来标记该 API 可能会更改。与这个委托一起使用的参数是 `IResourceBuilder<AzureKeyVaultResource>`、`ResourceModuleConstruct`
    和 `KeyVault`。这允许我们在创建 Azure Key Vault 时配置从参数检索到的秘密：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With the method used here, the first and third parameters of the delegate are
    ignored. The second parameter of the `ResourceModuleConstruct` type specifies
    the scope of creating `KeyVaultSecret` – it’s created for this Azure Key Vault.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这里的方法，委托的第一个和第三个参数被忽略。`ResourceModuleConstruct` 类型的第二个参数指定了创建 `KeyVaultSecret`
    的范围——它是为这个 Azure Key Vault 创建的。
- en: 'Another sample shows configuring properties and invoking method of a builder
    with an Azure Storage Account:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个示例展示了如何使用 Azure 存储帐户配置属性和调用构建器的方法：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When creating the Azure Storage account, the `IResourceBuilder<AzureStorageAccount>`
    and `StorageAccount` parameters are used with the `Action` delegate, and the second
    parameter is ignored. `IResourceBuilder` is used to create a queue and a blob
    container with the storage account. We used these `AddQueues` and `AddBlobs` methods
    already without the experimental API invoking these methods with the return of
    `AddStorageAccount`. The `AddAzureStorage` method returns a builder. This is just
    for convenience defining this within this code block. The `StorageAccount` parameter
    is used to specify properties, setting the SKU to local redundancy, and the access
    tier to hot, which is cheaper for operations but more expensive for the storage.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Azure 存储帐户时，使用 `IResourceBuilder<AzureStorageAccount>` 和 `StorageAccount`
    参数与 `Action` 委托，第二个参数被忽略。`IResourceBuilder` 用于使用存储帐户创建队列和 blob 容器。我们之前已经使用这些 `AddQueues`
    和 `AddBlobs` 方法，而不需要通过实验性 API 使用 `AddStorageAccount` 的返回值来调用这些方法。`AddAzureStorage`
    方法返回一个构建器。这只是为了方便，在这个代码块中定义它。`StorageAccount` 参数用于指定属性，将 SKU 设置为本地冗余，并将访问层设置为热，这对于操作来说更便宜，但对于存储来说更昂贵。
- en: Many organizations are in the process of changing the way to deploy and manage
    their infrastructure. Knowing about these developments can be useful to decide
    what direction should be taken, and what tools best fit the needs of the organization.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织正在改变他们部署和管理基础设施的方式。了解这些发展情况对于决定应该采取什么方向以及哪些工具最适合组织的需求非常有用。
- en: For now, it’s very likely that the API will change – so use it with care. With
    the fast development pace of .NET Aspire, new features can improve fast, and this
    feature might be released not too far away (at the time of this writing). Check
    the README file of this chapter for updates.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，API 很可能将发生变化——所以请谨慎使用。随着 .NET Aspire 的快速发展，新功能可以快速改进，这个功能可能不会太远（在撰写本文时）发布。请查看本章的
    README 文件以获取更新。
- en: Next, we’ll look into easy deployment to Kubernetes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何轻松部署到 Kubernetes。
- en: Creating a Kubernetes cluster with Microsoft Azure
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Microsoft Azure 创建 Kubernetes 集群
- en: While the Azure Container Apps environment is based on Kubernetes, the Kubernetes
    tool (**kubectl**) cannot be used; the Kubernetes functionality is abstracted
    for simplification. Kubernetes is an open source system to scale and manage containerized
    applications and is used by many companies in their on-premises environment. With
    this, for many companies, it’s important to have the possibility to run services
    on-premises and in any cloud environment. See the *Further reading* section for
    links to learn more about Kubernetes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Azure Container Apps 环境基于 Kubernetes，但不能使用 Kubernetes 工具（**kubectl**）；Kubernetes
    功能被抽象化以简化。Kubernetes 是一个开源系统，用于扩展和管理容器化应用程序，并被许多公司在其本地环境中使用。有了这个，对于许多公司来说，能够在本地和任何云环境中运行服务非常重要。请参阅
    *进一步阅读* 部分，以获取有关 Kubernetes 的更多信息。
- en: The Codebreaker application has been built with two launch profiles. We’ll publish
    the `OnPremises` launch profile to a Kubernetes cluster. With this launch profile,
    for example, Kafka is used instead of Azure Event Hubs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker应用程序已构建了两个启动配置文件。我们将`OnPremises`启动配置文件发布到Kubernetes集群。例如，使用此启动配置文件时，Kafka代替了Azure事件中心。
- en: 'By having Docker Desktop installed, you can enable Kubernetes. This single-node
    cluster is just for a small test scenario. Instead, we’ll use a managed version
    of Kubernetes: The **Azure Kubernetes Service** (**AKS**). Compared to a self-installed
    cluster, installation and management are a lot easier.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过安装Docker Desktop，您可以启用Kubernetes。这个单节点集群仅用于小型测试场景。相反，我们将使用Kubernetes的托管版本：**Azure
    Kubernetes服务**（**AKS**）。与自行安装的集群相比，安装和管理要容易得多。
- en: Before creating the cluster, we need a new resource group, and an **Azure Container**
    **Registry** (**ACR**).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建集群之前，我们需要一个新的资源组和一个**Azure容器注册库**（**ACR**）。
- en: 'Using the Azure CLI, create a new resource group:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Azure CLI创建一个新的资源组：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Specify an Azure region of your choice and specify a resource group name. Then,
    create a new ACR using `az` `acr create`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 指定您选择的Azure区域并指定资源组名称。然后，使用`az` `acr create`创建一个新的ACR：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Use the previously created resource group, specify an SKU (the cheapest version,
    `Basic`, fits the purpose), and use a unique name for the registry.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前创建的资源组，指定SKU（最便宜版本，`Basic`适合此用途），并为注册库使用一个唯一名称。
- en: With this, create a new AKS in the Azure portal ([https://portal.azure.com](https://portal.azure.com))
    – see *Figure 16**.2*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，在Azure门户中创建一个新的AKS（[https://portal.azure.com](https://portal.azure.com)）——见*图16.2*。
- en: '![Figure 16.2 – Basic AKS configuration](img/B21217_16_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图16.2 – 基本AKS配置](img/B21217_16_02.jpg)'
- en: Figure 16.2 – Basic AKS configuration
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 – 基本AKS配置
- en: Select the resource group just created with the first dialog. With **Cluster
    details**, you can choose a preset configuration of either **Production Standard**,
    **Dev/Test**, **Production Economy**, and **Production Enterprise**. The virtual
    machine sizes are different based on the presets, and some features are differently
    configured. For example, **Production Enterprise** has a **private cluster** where
    the API server is only accessible from an internal network. Select the **Dev/Test**
    preset for our test environment. Enter a cluster name and select the region of
    the cluster. All the other **Basics** settings can stay as their defaults – including
    the AKS pricing tier, **Free**. With the **Free** offering, a cost only applies
    for the nodes where our built Docker images are running and other services configured,
    such as managed Prometheus and Grafana. Be aware that every node instance you
    configure is a virtual machine that needs to be paid for. The **Dev/Test** preset
    setting is best for experimenting and testing with fewer than 10 nodes. With the
    **Standard** pricing tier, you can run up to 5,000 nodes in a cluster.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第一个对话框选择刚刚创建的资源组。在**集群详情**中，您可以选择以下预设配置之一：**生产标准**、**开发/测试**、**生产经济**和**生产企业**。虚拟机的大小根据预设而有所不同，并且某些功能配置不同。例如，**生产企业**有一个**私有集群**，其中API服务器仅可通过内部网络访问。为我们的测试环境选择**开发/测试**预设。输入集群名称并选择集群所在的区域。所有其他**基本**设置都可以保持默认设置——包括AKS定价层**免费**。使用**免费**提供的服务，只有在运行我们的构建Docker镜像的节点和其他配置的服务（如托管Prometheus和Grafana）上才会产生费用。请注意，您配置的每个节点实例都是一个需要付费的虚拟机。**开发/测试**预设设置最适合进行少于10个节点的实验和测试。在**标准**定价层，您可以在集群中运行多达5,000个节点。
- en: After the configuration of the **Basics** settings, click **Next** to configure
    the node pools (*Figure 16**.3*).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置**基本**设置后，点击**下一步**以配置节点池（*图16.3*）。
- en: '![Figure 16.3 – AKS node pools](img/B21217_16_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图16.3 – AKS节点池](img/B21217_16_03.jpg)'
- en: Figure 16.3 – AKS node pools
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 – AKS节点池
- en: The default configuration for the node pool is `1`. System node pools need Linux
    for the operating system. These node pools run system pods. To run the applications,
    user node pools are preferred. For a cheaper test, we just use one node pool –
    a system node pool.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 节点池的默认配置为`1`。系统节点池需要Linux作为操作系统。这些节点池运行系统Pod。要运行应用程序，首选用户节点池。为了更便宜的测试，我们只使用一个节点池——系统节点池。
- en: When selecting the configuration of the pool, you can select the OS, the VM
    size, auto or manual scaling, the minimum and maximum node count, and the maximum
    pods per node. The allowed range is from 30–250 pods per node. One pod can run
    one or more containers. In most Kubernetes configurations, a pod runs one container.
    If the pod or the node where the pod runs fails, Kubernetes creates a replica.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择池的配置时，您可以选择操作系统、虚拟机大小、自动或手动扩展、最小和最大节点数量以及每个节点的最大 Pod 数量。允许的范围是每个节点 30-250
    个 Pod。一个 Pod 可以运行一个或多个容器。在大多数 Kubernetes 配置中，一个 Pod 运行一个容器。如果 Pod 或运行 Pod 的节点失败，Kubernetes
    将创建一个副本。
- en: With the **Node pools** configuration, you can also enable virtual nodes. Virtual
    nodes make use of Azure Container Instances, which allow the fast startup of containers
    if more load is needed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **节点池** 配置中，您还可以启用虚拟节点。虚拟节点利用 Azure 容器实例，如果需要更多负载，可以快速启动容器。
- en: Note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Creating user node pools allows you to select Windows for a node pool. This
    allows running legacy applications on Kubernetes. This is a difference AKS has
    to offer that’s not available with Azure Container Apps.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户节点池允许您为节点池选择 Windows。这允许在 Kubernetes 上运行旧版应用程序。这是 AKS 提供的与 Azure 容器应用不同的功能。
- en: After the **Node pools** configuration, clicking **Next** leads to the **Networking**
    configuration. Leave this with the default settings. Clicking **Next** again opens
    the **Integrations** settings (see *Figure 16**.4*).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **节点池** 配置之后，点击 **下一步** 将引导到 **网络** 配置。保留默认设置。再次点击 **下一步** 将打开 **集成** 设置（见
    *图 16.4*）。
- en: '![Figure 16.4 – AKS Integrations settings](img/B21217_16_04.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.4 – AKS 集成设置](img/B21217_16_04.jpg)'
- en: Figure 16.4 – AKS Integrations settings
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.4 – AKS 集成设置
- en: With the **Integrations** settings, select the previously created ACR. With
    AKS, a direct integration with the registry is offered.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **集成** 设置中，选择之前创建的 ACR。使用 AKS，提供了与注册表的直接集成。
- en: Clicking `OnPremises` launch profile, Docker containers for Grafana and Prometheus
    are configured. Alternatively, the Azure services Managed Prometheus and Managed
    Grafana could be used.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 `OnPremises` 启动配置文件，将配置 Grafana 和 Prometheus 的 Docker 容器。或者，可以使用 Azure 服务管理的
    Prometheus 和管理的 Grafana。
- en: Leave the remaining settings as default. By clicking on **Review + create**,
    the final checks are done. If this succeeds, click the **Create** button. Creating
    an AKS takes several minutes – but it’s a lot faster than creating a Kubernetes
    cluster manually.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将剩余的设置保留为默认值。通过点击 **审查 + 创建**，进行最终检查。如果成功，点击 **创建** 按钮。创建 AKS 需要几分钟时间——但比手动创建
    Kubernetes 集群快得多。
- en: 'After deployment to the Kubernetes cluster succeeds, connect the Kubernetes
    command-line client, `kubectl`, to AKS. With Docker Desktop, this tool is installed
    with it. To connect `kubectl` to this AKS installation, use the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功部署到 Kubernetes 集群后，将 Kubernetes 命令行客户端 `kubectl` 连接到 AKS。使用 Docker Desktop，此工具与其一起安装。要将
    `kubectl` 连接到此 AKS 安装，请使用以下命令：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This adds the connection to AKS to the `%HOMEPATH%/.kube/config` configuration
    file. Now, you can use the `kubectl` tool:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 AKS 的连接添加到 `%HOMEPATH%/.kube/config` 配置文件中。现在，您可以使用 `kubectl` 工具：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This returns the running nodes from the AKS service.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回 AKS 服务中的运行节点。
- en: Next, let’s publish our application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们发布我们的应用程序。
- en: Using Aspir8 to deploy to Kubernetes
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Aspir8 部署到 Kubernetes
- en: With .NET Aspire, we created the app model to define all the dependencies between
    the different resources that are used. First, in [*Chapter 1*](B21217_01.xhtml#_idTextAnchor014),
    you saw the Aspire manifest that’s created from an app model. This manifest file
    is independent of any technology where to deploy it. The Azure Developer CLI creates
    Bicep scripts for deploying the solution (see [*Chapter 6*](B21217_06.xhtml#_idTextAnchor137)
    and [*Chapter 8*](B21217_08.xhtml#_idTextAnchor183)). The open source tool **Aspirate**
    (**Aspir8**) (see [https://github.com/prom3theu5/aspirational-manifests](https://github.com/prom3theu5/aspirational-manifests))
    converts the Aspire manifest file to Docker Compose or Kubernetes with **Helm**
    charts or **kustomize** manifests.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 .NET Aspire，我们创建了应用程序模型来定义使用不同资源之间的所有依赖关系。首先，在 [*第 1 章*](B21217_01.xhtml#_idTextAnchor014)
    中，您看到了从应用程序模型创建的 Aspire 清单。此清单文件与其部署的技术无关。Azure 开发者 CLI 为部署解决方案创建 Bicep 脚本（见 [*第
    6 章*](B21217_06.xhtml#_idTextAnchor137) 和 [*第 8 章*](B21217_08.xhtml#_idTextAnchor183)）。开源工具
    **Aspirate**（**Aspir8**）（见 [https://github.com/prom3theu5/aspirational-manifests](https://github.com/prom3theu5/aspirational-manifests)）将
    Aspire 清单文件转换为 Docker Compose 或 Kubernetes 的 Helm 图表或 kustomize 清单。
- en: 'You can create an Aspire manifest for every launch profile, like so:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为每个启动配置创建一个 Aspire 清单，如下所示：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our app model is defined with two different versions. One version uses cloud-native
    Azure services, while the other option is independent of any cloud environment.
    The second one is configured by starting the application with the `OnPremises`
    launch profile.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 app 模型定义了两个不同的版本。一个版本使用云原生 Azure 服务，而另一个选项则独立于任何云环境。第二个选项是通过使用 `OnPremises`
    启动配置启动应用程序来配置的。
- en: With `dotnet run`, we pass the `--launch-profile OnPremises` option to start
    the application using the profile as specified with the `launchprofiles.json`
    file. The `--` option is a separator to specify arguments to the running application.
    The `--publisher manifest` option creates the Aspire manifest file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dotnet run`，我们通过传递 `--launch-profile OnPremises` 选项来启动应用程序，使用 `launchprofiles.json`
    文件中指定的配置文件。`--` 选项是一个分隔符，用于指定运行应用程序的参数。`--publisher manifest` 选项创建 Aspire 清单文件。
- en: Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We have a strict separation with the Codebreaker app model definition. It’s
    also possible in a somehow mixed mode. For example, you can use a solution running
    on-premises to use Azure Application Insights running within Azure to get the
    advantages of this cloud service offering. You can also use Azure Functions to
    run on an on-premises Kubernetes cluster. Many options are available to choose
    the service that best fits your needs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与 Codebreaker 应用模型定义有严格的分离。在某种混合模式下也是可能的。例如，您可以使用在本地运行的解决方案，同时使用在 Azure 内运行的
    Azure Application Insights 来获得此云服务提供的优势。您还可以使用 Azure Functions 在本地 Kubernetes
    集群上运行。有许多选项可供选择最适合您需求的服务。
- en: 'Before using the `aspirate` tool, it needs to be installed:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `aspirate` 工具之前，需要安装它：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At the time of this writing, this tool is not released, thus it’s necessary
    to set the `--prerelease` option. The `-g` option installs this tool as a global
    tool.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，此工具尚未发布，因此需要设置 `--prerelease` 选项。`-g` 选项将此工具安装为全局工具。
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of this writing, the `aspirate` tool is in a prerelease state, and
    changes are expected. Check the README file of [*Chapter 16*](B21217_16.xhtml#_idTextAnchor373)
    from the book’s repository for the latest updates deploying the Codebreaker application
    to Kubernetes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`aspirate` 工具处于预发布状态，预计会有所变化。请检查书籍仓库中 [*第16章*](B21217_16.xhtml#_idTextAnchor373)
    的 README 文件以获取部署 Codebreaker 应用到 Kubernetes 的最新更新。
- en: 'Optionally, you can specify an initial configuration with Aspir8:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，您可以使用 Aspir8 指定初始配置。
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `aspirate` tool allows specifying a launch profile similar to the .NET CLI
    to customize the configuration accordingly. By using `aspirate init`, you can
    specify a container builder and select between Docker Desktop and Podman. The
    default setting is Docker Desktop. With a fallback value for the container registry,
    enter the URL of the ACR you created. `aspirate init` creates the `aspirate-state.json`
    file with the configuration specified. You can rerun `aspirate init`, which overwrites
    this configuration file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`aspirate` 工具允许指定一个类似于 .NET CLI 的启动配置，以便相应地自定义配置。通过使用 `aspirate init`，您可以指定容器构建器并在
    Docker Desktop 和 Podman 之间进行选择。默认设置是 Docker Desktop。对于容器注册表的回退值，输入您创建的 ACR 的 URL。`aspirate
    init` 会创建一个包含指定配置的 `aspirate-state.json` 文件。您可以重新运行 `aspirate init`，这将覆盖此配置文件。'
- en: Creating Kubernetes manifests
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Kubernetes 清单
- en: 'Let’s now use the app model with the launch profile to generate manifests for
    publishing to Kubernetes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用带有启动配置的应用模型来生成发布到 Kubernetes 的清单：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`aspirate generate` can create Kubernetes manifests for deployment, as well
    as build and publish Docker images. Here, we don’t build Docker images by using
    the `--skip-build` option. With the `--launch-profile` option, the `AppHost` project
    with the app model is directly used. `aspirate generate` can also reference the
    previously generated .NET Aspire manifest with the `--aspirate-manifest` option
    instead. By setting `--output-path`, a different folder is specified to create
    the output result. The `--namespace` option is Kubernetes-related to define a
    namespace for the services deployed. This makes it easier to differentiate between
    the different services running on the cluster.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`aspirate generate` 可以创建用于部署的 Kubernetes 清单，以及构建和发布 Docker 镜像。在这里，我们不使用 `--skip-build`
    选项来构建 Docker 镜像。使用 `--launch-profile` 选项，直接使用具有应用模型的 `AppHost` 项目。`aspirate generate`
    还可以使用 `--aspirate-manifest` 选项引用之前生成的 .NET Aspire 清单。通过设置 `--output-path`，指定一个不同的文件夹来创建输出结果。`--namespace`
    选项与 Kubernetes 相关，用于为部署的服务定义命名空间。这使得在集群上区分不同的服务变得更加容易。'
- en: Note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`aspirate` supports generating manifests using Helm and `kustomize`. Helm is
    a package manager that uses a packaging format named `kustomize` is a configuration
    manager natively built into `kubectl` with a template-free approach to patch and
    merge YAML files.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`aspirate` 支持使用 Helm 和 `kustomize` 生成清单。Helm 是一个使用名为 `kustomize` 的打包格式的打包管理器，而
    `kustomize` 是一个配置管理器，它是 `kubectl` 内置的，采用无模板的方式来修补和合并 YAML 文件。'
- en: Check the result of the `kustomize-output` folder. For every project specified,
    a folder is created (e.g., `gameapis`, `bot`, and `redis`) that contains `deployment.yaml`,
    `service.yaml`, and `kustomization.yaml`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `kustomize-output` 文件夹的结果。对于指定的每个项目，都会创建一个文件夹（例如，`gameapis`、`bot` 和 `redis`），其中包含
    `deployment.yaml`、`service.yaml` 和 `kustomization.yaml`。
- en: A deployment defines a declarative configuration for a pod and a replica set.
    The “desired state” of a pod is described by the deployment. In this file, you
    can read and change the number of replicas used, and the containers running in
    a pod.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 部署定义了一个 pod 和副本集的声明性配置。pod 的“期望状态”由部署描述。在这个文件中，你可以读取和更改使用的副本数量，以及 pod 中运行的容器。
- en: A service defines a network application. This specifies the ports used with
    the application. A service runs in one or more pods.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定义了一个网络应用程序。这指定了应用程序使用的端口。服务在一个或多个 pod 中运行。
- en: The `kustomization.yaml` file references both `deployment.yaml` and `service.yaml`,
    and specifies configuration values such as the environment variables you’ve seen
    with the .NET Aspire dashboard.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`kustomization.yaml` 文件引用了 `deployment.yaml` 和 `service.yaml`，并指定了配置值，例如你已经在
    .NET Aspire 仪表板中看到的环境变量。'
- en: Having the manifest files ready, we can create Docker images and push them to
    the ACR.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好清单文件后，我们可以创建 Docker 镜像并将它们推送到 ACR。
- en: Creating and pushing Docker images
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和推送 Docker 镜像
- en: 'Using `aspirate build`, we can build and publish Docker images to the registry.
    With the `aspirate` tool, it’s possible to specify username and password values
    to push images to private registries. When using ACR, this is not necessary because
    Aspir8 makes use of `dotnet publish`. Just make sure to log in to the ACR using
    the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `aspirate build`，我们可以构建并将 Docker 镜像发布到注册表。使用 `aspirate` 工具，可以指定用户名和密码值以将镜像推送到私有注册表。当使用
    ACR 时，这并不是必需的，因为 Aspir8 使用 `dotnet publish`。只需确保使用以下方式登录到 ACR：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, you can use `aspirate build`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用 `aspirate build`：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Starting this command, specify the name of your registry. Specifying multiple
    tags will add them to the repository as shown in *Figure 16**.5*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从此命令开始，指定你的注册表名称。指定多个标签将它们添加到仓库中，如 *图 16.5* 所示。
- en: '![Figure 16.5 – AKS repository](img/B21217_16_05.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.5 – AKS 仓库](img/B21217_16_05.jpg)'
- en: Figure 16.5 – AKS repository
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.5 – AKS 仓库
- en: The images are pushed to the ACR and show the `latest` and `3.8` tags, as specified
    with `aspirate build`. Next, deploy the images with the Kubernetes manifests to
    the cluster.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像被推送到 ACR，并显示 `latest` 和 `3.8` 标签，如 `aspirate build` 中指定的。接下来，使用 Kubernetes
    清单将镜像部署到集群。
- en: Deploying to Kubernetes
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署到 Kubernetes
- en: 'Now, we can apply the manifests to the Kubernetes cluster:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将清单应用到 Kubernetes 集群：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `aspirate apply` command uses the previously created manifest files to
    apply the services and deployments to the Kubernetes cluster by using the `kubectl
    apply` command. Just make sure to have AKS configured as the default Kubernetes
    environment (using the previously used command after creating AKS: `az` `aks get-credentials`).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`aspirate apply` 命令使用之前创建的清单文件，通过使用 `kubectl apply` 命令将服务和部署应用到 Kubernetes
    集群。只需确保 AKS 已配置为默认的 Kubernetes 环境（在创建 AKS 后使用之前使用的命令：`az aks get-credentials`）。'
- en: 'Now, you can use the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用以下命令：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This command shows the deployments from the `codebreakerns` namespace. You can
    see the deployments that are available and ready.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令显示了 `codebreakerns` 命名空间中的部署。你可以看到可用的和准备就绪的部署。
- en: 'Similarly, use this command to see the services:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，使用此命令查看服务：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, you see the services with the IP addresses running, and the ports registered.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到正在运行的服务的 IP 地址和注册的端口。
- en: Now, you can configure an `aspirate`. For now, check the *Further reading* section
    to see how this can be done.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以配置一个 `aspirate`。目前，请查看“进一步阅读”部分以了解如何完成此操作。
- en: Note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Aspir8 also supports Docker Compose besides Kubernetes with `kustomize` and
    Helm. By using `aspirate generate`, you can supply `compose` with the `--output-format`
    option. This creates a simple Docker Compose file that you can start with the
    Docker CLI.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Aspir8 除了支持 Kubernetes，还支持 Docker Compose，以及使用 `kustomize` 和 Helm。通过使用 `aspirate
    generate`，你可以为 `compose` 提供带有 `--output-format` 选项的参数。这将创建一个简单的 Docker Compose
    文件，你可以使用 Docker CLI 启动它。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about some final considerations for deploying applications
    using a microservices architecture in a production environment. You now have awareness
    of running the solution in multiple regions and using availability zones and can
    discuss the impact in your organization.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了在生产环境中使用微服务架构部署应用程序的一些最终考虑因素。您现在对在多个区域运行解决方案以及使用可用性区域有了认识，并且可以讨论这对您组织的影响。
- en: You learned about AKS as a managed option to host a Kubernetes cluster and deploy
    the solution by using the .NET Aspire manifest to create deployments with Aspir8.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您学习了 AKS 作为托管选项来托管 Kubernetes 集群，并使用 .NET Aspire 清单通过 Aspir8 创建部署。
- en: By reaching [*Chapter 16*](B21217_16.xhtml#_idTextAnchor373) of this book, you’ve
    done an impressive tour, starting with minimal APIs, and adding more services
    from chapter to chapter using different technologies.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过达到本书的 *第16章*，您完成了一次令人印象深刻的巡游，从最小的 API 开始，并在每一章中添加更多服务，使用不同的技术。
- en: With the book’s repository, the solution is planned to be updated to newer .NET
    and .NET Aspire versions. As newer versions become available, the book version
    will stay available in the `dotnet8` branch.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本书的存储库，解决方案计划更新到更新的 .NET 和 .NET Aspire 版本。随着新版本的可用，本书版本将保持在 `dotnet8` 分支中。
- en: To see more developments with Codebreaker, check the [https://github.com/codebreakerapp](https://github.com/codebreakerapp)
    organization. There, you can see further developments of the solution, as well
    as a list of client applications. Also, check [https://codebreaker.app](https://codebreaker.app)
    to play a few games – of course, now you can also use a version running in your
    (hosted) Kubernetes cluster.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Codebreaker 的更多开发情况，请查看 [https://github.com/codebreakerapp](https://github.com/codebreakerapp)
    组织。在那里，你可以看到解决方案的进一步开发，以及客户端应用程序的列表。此外，请访问 [https://codebreaker.app](https://codebreaker.app)
    玩一些游戏——当然，现在你也可以使用在您的（托管）Kubernetes 集群中运行的版本。
- en: Further reading
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following links:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解本章讨论的主题的更多信息，您可以参考以下链接：
- en: '*Business continuity and disaster* *recovery*: [https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ready/landing-zone/design-area/management-business-continuity-disaster-recovery](https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ready/landing-zone/design-area/management-business-continuity-disaster-recovery)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*业务连续性和灾难恢复*：[https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ready/landing-zone/design-area/management-business-continuity-disaster-recovery](https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ready/landing-zone/design-area/management-business-continuity-disaster-recovery)'
- en: '*Azure load-balancing* *options*: [https://learn.microsoft.com/en-us/azure/architecture/guide/technology-choices/load-balancing-overview](https://learn.microsoft.com/en-us/azure/architecture/guide/technology-choices/load-balancing-overview)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Azure 负载均衡* 选项：[https://learn.microsoft.com/en-us/azure/architecture/guide/technology-choices/load-balancing-overview](https://learn.microsoft.com/en-us/azure/architecture/guide/technology-choices/load-balancing-overview)'
- en: 'Kubernetes: [https://kubernetes.io/](https://kubernetes.io/)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes：[https://kubernetes.io/](https://kubernetes.io/)
- en: 'Learn Kubernetes basics: [https://kubernetes.io/docs/tutorials/kubernetes-basics/](https://kubernetes.io/docs/tutorials/kubernetes-basics/)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 Kubernetes 基础知识：[https://kubernetes.io/docs/tutorials/kubernetes-basics/](https://kubernetes.io/docs/tutorials/kubernetes-basics/)
- en: 'Helm – the package manager for Kubernetes: [https://helm.sh](https://helm.sh)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm - Kubernetes 的包管理器：[https://helm.sh](https://helm.sh)
- en: 'The `kubectl` command-line tool: [https://kubernetes.io/docs/reference/kubectl/](https://kubernetes.io/docs/reference/kubectl/)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl` 命令行工具：[https://kubernetes.io/docs/reference/kubectl/](https://kubernetes.io/docs/reference/kubectl/)'
- en: 'Aspirate GitHub repository: [https://github.com/prom3theu5/aspirational-manifests](https://github.com/prom3theu5/aspirational-manifests)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 吸取 GitHub 仓库：[https://github.com/prom3theu5/aspirational-manifests](https://github.com/prom3theu5/aspirational-manifests)
- en: '*aspir8 from* *scratch*: [https://github.com/devkimchi/aspir8-from-scratch](https://github.com/devkimchi/aspir8-from-scratch)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从头开始aspir8*：[https://github.com/devkimchi/aspir8-from-scratch](https://github.com/devkimchi/aspir8-from-scratch)'
- en: '*Configure ingress with Azure Kubernetes* *Services*: [https://learn.microsoft.com/en-us/azure/aks/app-routing](https://learn.microsoft.com/en-us/azure/aks/app-routing)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Azure Kubernetes 服务配置入口*：[https://learn.microsoft.com/en-us/azure/aks/app-routing](https://learn.microsoft.com/en-us/azure/aks/app-routing)'
- en: '*Deploy a .NET microservice to Kubernetes* *manually*: [https://learn.microsoft.com/en-us/training/modules/dotnet-deploy-microservices-kubernetes/](https://learn.microsoft.com/en-us/training/modules/dotnet-deploy-microservices-kubernetes/)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*手动将 .NET 微服务部署到 Kubernetes*：[https://learn.microsoft.com/en-us/training/modules/dotnet-deploy-microservices-kubernetes/](https://learn.microsoft.com/en-us/training/modules/dotnet-deploy-microservices-kubernetes/)'
- en: '`kubectl` – the definitive pronunciation guide: [https://www.youtube.com/watch?v=2wgAIvXpJqU](https://www.youtube.com/watch?v=2wgAIvXpJqU)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl` – 官方发音指南：[https://www.youtube.com/watch?v=2wgAIvXpJqU](https://www.youtube.com/watch?v=2wgAIvXpJqU)'
