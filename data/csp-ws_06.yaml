- en: 6\. Entity Framework with SQL Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 使用SQL Server的Entity Framework
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to the basics of database design, storage, and processing
    using SQL and C#. You will learn about the Entity Framework (EF), and Object-Relational
    Mapper (ORM) and use them to convert database results into C# objects. You will
    then learn about the main performance pitfalls of SQL and EF and how to find and
    fix them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍使用SQL和C#进行数据库设计、存储和处理的基础知识。您将了解实体框架（EF）和对象关系映射器（ORM），并使用它们将数据库结果转换为C#对象。然后，您将了解SQL和EF的主要性能陷阱以及如何查找和修复它们。
- en: Finally, you will delve into enterprise practices of working with databases
    by looking at Repository and Command Query Responsibility Segregation (CQRS) patterns
    and also by setting up a local database for development and testing. By the end
    of this chapter, you will be able to create and design your own database using
    PostgreSQL Server and use EF to hook a C# backend to it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将通过查看存储库和命令查询责任分离（CQRS）模式以及设置用于开发和测试的本地数据库来深入了解与数据库的企业级实践。到本章结束时，您将能够使用PostgreSQL服务器创建和设计自己的数据库，并使用EF将其与C#后端连接。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: There are multiple types of databases, but the most common one is relational,
    and the language for managing relational databases is SQL. SQL is optimized for
    data persistence. However, executing business rules in it is inefficient. Therefore,
    before consumption, data is often fetched in application memory and transformed
    into objects. This transformation is called object-relational mapping.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库有多种类型，但最常见的一种是关系型数据库，管理关系型数据库的语言是SQL。SQL针对数据持久性进行了优化。然而，在其中执行业务规则效率低下。因此，在消费之前，数据通常在应用程序内存中检索并转换为对象。这种转换称为对象关系映射。
- en: 'There is a lot of complexity in mapping database records to objects. However,
    this complexity is mitigated by Object-Relational Mapper (ORM). Some ORMs only
    do mapping (called micro-ORMs), but many popular ORMs also abstract away database
    language and allow you to use the same language to execute business rules and
    process data:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据库记录映射到对象中存在很多复杂性。然而，这种复杂性通过对象关系映射器（ORM）得到了缓解。一些ORM仅执行映射（称为微ORM），但许多流行的ORM还抽象了数据库语言，允许您使用相同的语言来执行业务规则和处理数据：
- en: '![Figure 6.1: How an ORM works in translating C# to SQL and back ](img/B16835_06_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：ORM在将C#转换为SQL以及反向转换中的工作方式](img/B16835_06_01.jpg)'
- en: 'Figure 6.1: How an ORM works in translating C# to SQL and back'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：ORM在将C#转换为SQL以及反向转换中的工作方式
- en: The focus of this chapter will be on Entity Framework (EF)—the most popular
    ORM in .NET. In the practical sections of this chapter, you will use it to rapidly
    prototype relational databases, and then make queries against them. It's worth
    mentioning that internally, whenever databases are involved, you are interacting
    with the ADO.NET part of .NET.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点将是实体框架（EF）——.NET中最受欢迎的ORM。在本章的实践部分，您将使用它来快速原型化关系型数据库，并对它们进行查询。值得一提的是，在涉及数据库的情况下，您实际上是在与.NET的ADO.NET部分进行交互。
- en: 'Before proceeding, however, it''s recommended that you install the latest version
    of PostgreSQL with PostgreSQL Server found here: [https://www.enterprisedb.com/downloads/postgres-postgresql-downloads](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads).
    You can find the installation instructions for this in the *Preface*.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，建议您安装最新版本的PostgreSQL，以及在此处找到的PostgreSQL服务器：[https://www.enterprisedb.com/downloads/postgres-postgresql-downloads](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads)。您可以在*前言*中找到此安装说明。
- en: This chapter will use the `AdventureWorks` database, which is an adaptation
    of a popular example database that Microsoft often uses; it will be defined in
    detail in the following section.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用`AdventureWorks`数据库，这是一个微软经常使用的流行示例数据库的改编版本；它将在下一节中详细定义。
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For those who are interested in learning the basics of databases and how to
    work with PostgreSQL, a reference chapter has been included in the GitHub repository
    of this book. You can access it at [https://packt.link/sezEm](https://packt.link/sezEm).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些对学习数据库基础知识以及如何使用PostgreSQL感兴趣的人来说，本书的GitHub仓库中包含了一个参考章节。您可以通过[https://packt.link/sezEm](https://packt.link/sezEm)访问它。
- en: Creating a Demo Database Before You Start
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在开始之前创建一个演示数据库
- en: You will use `Adventureworks` as an example because it is a common database
    used by Microsoft and has just enough complexity to learn about databases topic.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用`Adventureworks`作为示例，因为它是由微软常用的一个常见数据库，并且具有足够的复杂性来学习数据库主题。
- en: 'Perform the following steps to do so:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Open the command line and make a directory where you will call `AdventureWorks`
    database and move to that directory:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行，创建一个名为`AdventureWorks`数据库的目录，并移动到该目录：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Replace `<change-with-your-download-path-to-The-C-Sharp-Workshop>` with a directory
    where you downloaded the The-C-Sharp-Workshop repository.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`<change-with-your-download-path-to-The-C-Sharp-Workshop>`替换为您下载The-C-Sharp-Workshop存储库的目录。
- en: 'Create an empty `Adventureworks` database by running the following command
    in the console:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中运行以下命令以创建一个空的`Adventureworks`数据库：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Create tables and populate them with data using the installation script.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用安装脚本创建表格并填充数据。
- en: Note
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The installation script is found at [https://packt.link/0SHd5](https://packt.link/0SHd5).
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装脚本位于[https://packt.link/0SHd5](https://packt.link/0SHd5)。
- en: 'Run the following command pointing to the installation script:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令指向安装脚本：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Modeling Databases Using EF
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用EF建模数据库
- en: Working with a database from any other language comes with an interesting problem
    and that is, how do you convert table rows into C# objects? In C#, communicating
    with a database requires a database connection and SQL statements. Executing the
    statements will bring up a results reader, which is very similar to a table. Using
    the results reader dictionary, you can go through the results and map them into
    a new object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其他语言与数据库交互会带来一个有趣的问题，那就是如何将表行转换为C#对象？在C#中，与数据库通信需要数据库连接和SQL语句。执行这些语句将弹出一个结果读取器，它与表格非常相似。使用结果读取器字典，您可以遍历结果并将它们映射到一个新的对象中。
- en: 'The code for this would look like the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码可能看起来如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Don't worry about the details of this code yet; it will be broken down soon.
    For now, it is enough to know that the preceding snippet returns all rows from
    the `factory.product` table and maps the results to a list named `products`. Using
    this approach may be okay when working with a single table, but when joins are
    involved, it becomes tricky. Mapping from one type to another, as has been done
    here, is very granular and can become tedious. In order to run this example, go
    to [https://packt.link/2oxXn](https://packt.link/2oxXn) and comment all lines
    within `static void Main(string[] args)` body except `Examples.TalkingWithDb.Raw.Demo.Run();`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心此代码的细节；它很快就会被分解。现在，只需知道前面的代码片段返回了`factory.product`表的所有行，并将结果映射到名为`products`的列表中。当处理单个表时，这种方法可能是可以的，但当涉及到连接时，它就会变得复杂。从一种类型到另一种类型的映射，如这里所做的那样，非常细粒度，可能会变得繁琐。为了运行此示例，请访问[https://packt.link/2oxXn](https://packt.link/2oxXn)，并在`static
    void Main(string[] args)`体中注释掉所有行，除了`Examples.TalkingWithDb.Raw.Demo.Run();`。
- en: Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/7uIJq](https://packt.link/7uIJq).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/7uIJq](https://packt.link/7uIJq)找到用于此示例的代码。
- en: 'Another factor to consider is that when you deal with SQL from the client side,
    you should be careful. You should not assume that a user will use your program
    as intended. So, you should therefore add validation on both the client and server
    sides. For example, if a textbox requires a user ID to be entered, the client
    could enter `105` and get the details of the user of that ID. The query for this
    would be as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的因素是，当您从客户端处理SQL时，您应该小心。您不应该假设用户会像预期的那样使用您的程序。因此，您应该在客户端和服务器端都添加验证。例如，如果文本框需要输入用户ID，客户端可以输入`105`并获取该ID的用户详细信息。此查询如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A user could also enter `105 or 1 = 1`, which is always true and thus this
    query returns all users:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 用户还可以输入`105 or 1 = 1`，这始终为真，因此此查询返回所有用户：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At best, this breaks your application. At worst, it leaks all the data. This
    kind of exploit is called SQL injection.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏的情况下，这会破坏您的应用程序。最坏的情况下，它会泄露所有数据。这种攻击被称为SQL注入。
- en: A simple yet effective way to solve the problem of accepting any kind of user
    input is to use an ORM as it allows you to convert database tables into C# objects
    and vice versa. In the .NET ecosystem, the three ORMs most commonly used are EF,
    Dapper, and NHibernate. Dapper is effective when top performance is needed because
    working with it involves executing raw SQL statements. Such ORMs are called micro-ORMs
    because they just do the mapping and nothing else.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 解决接受任何类型用户输入的问题的一个简单而有效的方法是使用ORM，因为它允许您将数据库表转换为C#对象，反之亦然。在.NET生态系统中，最常用的三个ORM是EF、Dapper和NHibernate。当需要高性能时，Dapper非常有效，因为它涉及执行原始SQL语句。这种ORM被称为micro-ORM，因为它们只做映射，不做其他任何事情。
- en: NHibernate originated with the Java ecosystem and was one of the first ORMs
    in .NET. NHibernate, just like EF, solves a bigger problem than micro-ORMs by
    trying to abstract away SQL and database-related low-level details. Using a full-fledged
    ORM, such as EF or Nhibernate, often means that you don't need to write SQL to
    communicate with a database. In fact, the two ORMs allow you to generate complex
    databases out of the objects you have. The opposite is also possible (that is,
    you can generate objects out of databases you already have).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: NHibernate起源于Java生态系统，是.NET中第一个ORM之一。NHibernate，就像EF一样，通过尝试抽象SQL和数据库相关的低级细节，解决了一个比微ORM更大的问题。使用完整的ORM，如EF或Nhibernate，通常意味着你不需要编写SQL来与数据库通信。实际上，这两个ORM允许你从你拥有的对象中生成复杂的数据库。反之亦然（即，你可以从你已有的数据库中生成对象）。
- en: In the next sections, the focus will be on EF. Why not Dapper? Because Dapper
    requires knowledge of SQL and you want to make use of a simplified syntax. Why
    not NHibernate? Because NHibernate is old, it has too many configuration options,
    none of which are useful for getting started with ORMs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将重点关注EF。为什么不选择Dapper？因为Dapper需要了解SQL，而你希望使用简化的语法。为什么不选择NHibernate？因为NHibernate已经过时，它有太多的配置选项，其中没有一个对ORM的入门有用。
- en: Before delving into EF, you first need to connect to a database. So, proceed
    to learn about connection string and security.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究EF之前，你首先需要连接到数据库。因此，继续学习关于连接字符串和安全的知识。
- en: Connection String and Security
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接字符串和安全
- en: 'No matter what language you use, connecting to a database will always involve
    using a connection string. It contains three important parts:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么语言，连接到数据库都将涉及使用连接字符串。它包含三个重要部分：
- en: IP or a server name.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP或服务器名称。
- en: The name of the database you would like to connect to.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要连接到的数据库的名称。
- en: Some sort of security credentials (or none, if using a trusted connection only
    used for databases on the same network).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些安全凭证（或者如果没有使用仅用于同一网络上的数据库的受信任连接，则不需要）。
- en: 'To connect to the local database you were previously working on in the *Modeling
    Databases Using EF* section (`new NpgsqlConnection(ConnectionString))`, you could
    use the following connection string (the password has been obfuscated for security
    reasons):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到你在“使用EF建模数据库”部分之前正在工作的本地数据库（`new NpgsqlConnection(ConnectionString)`），你可以使用以下连接字符串（出于安全原因，密码已被模糊处理）：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The connection string will be used when you will add the environment variables
    in your OS. This is detailed ahead. Different databases use different connections.
    For example, the following databases use these connections:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在操作系统中添加环境变量时，将使用连接字符串。这将在后面详细说明。不同的数据库使用不同的连接。例如，以下数据库使用这些连接：
- en: 'SQL Server: `SqlConnection`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SQL Server: `SqlConnection`'
- en: 'PostgreSQL: `NpgsqlConnection`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PostgreSQL: `NpgsqlConnection`'
- en: 'MySql: `MySqlConnection`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MySql: `MySqlConnection`'
- en: 'SQLite: `SqliteConnection`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SQLite: `SqliteConnection`'
- en: The connection object is the touching point between .NET and SQL database because
    it is only through it that you can communicate with a database.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 连接对象是.NET和SQL数据库之间的接触点，因为只有通过它你才能与数据库进行通信。
- en: 'Hardcoding a **connection string** comes with a few problems:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将**连接字符串**硬编码会带来一些问题：
- en: To change a connection string, the program must be recompiled.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要更改连接字符串，程序必须重新编译。
- en: It's not secure. The connection string can be viewed by everyone who knows how
    to decompile code (or worse, is publicly visible if it's an open-source project).
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这不安全。连接字符串可以被任何知道如何反编译代码的人查看（或者更糟糕的是，如果是一个开源项目，它可能是公开可见的）。
- en: 'Therefore, a connection string is usually stored in a configuration file. This
    does not solve the problem of sensitive parts of a connection string being stored.
    To fix that, often, either the whole string or a part of it is replaced during
    the application''s deployment. There are three main ways to securely store and
    retrieve application secrets:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，连接字符串通常存储在配置文件中。但这并没有解决连接字符串敏感部分存储的问题。为了解决这个问题，通常在应用程序部署期间会替换整个字符串或其一部分。有三种主要方式来安全地存储和检索应用程序的秘密：
- en: 'Environment variables: These are variables unique to a system and can be accessed
    by any application on the same machine. This is the simplest secure approach and
    might not be safe in a production environment.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量：这些是系统特有的变量，可以被同一台机器上的任何应用程序访问。这是最简单的安全方法，但在生产环境中可能不安全。
- en: 'Secret Manager tool (available in both .NET and .NET Core applications): Similar
    to environment variables but more .NET specific, it will store all secrets on
    the local machine as well but in a file called `secrets.json`. This option, too,
    might not be safe in a production environment.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密管理器工具（可在.NET和.NET Core应用程序中使用）：类似于环境变量，但更适用于.NET，它将在本地机器上存储所有秘密，但存储在一个名为`secrets.json`的文件中。这个选项在生产环境中也可能不安全。
- en: 'Key vault: This is the most secure approach because, unlike the other two,
    it is not coupled with a specific environment. Key vaults store secrets in one
    centralized place; usually remotely. This approach is most commonly used for enterprise
    applications. In the context of Azure, Azure Key Vault is the best choice and
    is perfect for a production environment.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥保管库：这是最安全的方法，因为它与其他两种方法不同，它不与特定环境耦合。密钥保管库将秘密存储在一个集中的位置；通常是在远程位置。这种方法最常用于企业应用程序。在Azure的上下文中，Azure密钥保管库是最好的选择，并且非常适合生产环境。
- en: In the following example, you'll try to securely store the connection string
    you made previously. You will use the simplest secure approach that is suitable
    for a development environment—that is, environment variables. This approach fits
    local development the best because the other two require third-party tools to
    set up and take much longer.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，您将尝试安全地存储之前创建的连接字符串。您将使用最适合开发环境的简单安全方法——即环境变量。这种方法最适合本地开发，因为其他两种方法需要第三方工具进行设置，并且需要更长的时间。
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before you continue, make sure to go through *Exercise 1* of the *Reference
    Chapter*, *A Primer for Simple Databases and SQL*. It has the steps needed to
    create a new database with the needed tables.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保阅读*参考章节*中的*练习1*，*简单数据库和SQL入门*。它包含了创建所需表的新数据库所需的步骤。
- en: 'Adding an environment variable in your OS is just a matter of performing some
    simple steps. Perform the following steps in Windows to set the environment variables:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的操作系统中添加环境变量只是执行一些简单步骤的问题。在Windows中执行以下步骤来设置环境变量：
- en: Go to `Control Panel`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`控制面板`。
- en: Click `System & Security` and choose `System`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`系统与安全`并选择`系统`。
- en: Type `Environmental Variables` in the search box.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入`环境变量`。
- en: Then choose `Edit Environment Variables for your account` from the list displayed.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后从显示的列表中选择`编辑您的账户的环境变量`。
- en: Inside the `Environment Variables` window, click `New` under the `System Variables`
    window.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`环境变量`窗口中，点击`系统变量`窗口下的`新建`。
- en: Inside the New System variable window, type `GlobalFactory` beside the `Variable
    name`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新建系统变量窗口中，在`变量名`旁边输入`GlobalFactory`。
- en: 'Beside `Variable value`, paste the following:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`变量值`旁边粘贴以下内容：
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next click `OK` on all windows to set your environment variables.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在所有窗口上点击`确定`以设置您的环境变量。
- en: Note
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Here the password would carry your database superuser password which you entered
    while creating the `globalfactory2021` database in PostgreSQL.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里密码将携带您在创建`globalfactory2021`数据库时在PostgreSQL中输入的数据库超级用户密码。
- en: 'Mac: From the command line, find `bash-profile: ~/.bash-profile f`. Open it
    using any text editor, then at the end of the file, add `export GlobalFactory=''Host=localhost;Username=postgres;Password=*****;Database=globalfactory2021''`.
    Lastly, run `source ~/.bash-profile`, which will update the environment variables.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Mac：从命令行中，找到`bash-profile: ~/.bash-profile f`。使用任何文本编辑器打开它，然后在文件末尾添加`export
    GlobalFactory=''Host=localhost;Username=postgres;Password=*****;Database=globalfactory2021''`。最后，运行`source
    ~/.bash-profile`，这将更新环境变量。'
- en: 'Linux: From the command line, run this: `export GlobalFactory=''Host=localhost;Username=postgres;Password=*****;Database=globalfactory2021''`.'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux：从命令行运行以下命令：`export GlobalFactory='Host=localhost;Username=postgres;Password=*****;Database=globalfactory2021'`。
- en: 'Getting the environment variable instead of an in-memory one can now be done
    by placing a property in `Program.cs`, at the top of the class, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过在`Program.cs`文件中，类的顶部放置一个属性来获取环境变量而不是内存中的变量，如下所示：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This line returns the value of the `GlobalFactory` environment variable, configured
    for the local user. In the preceding snippet, you have added this line to `Program.cs`
    and made it static because that makes it easily accessible throughout the application.
    While in big applications, it is not a practice you would want to go for; however,
    for your purposes here, this is fine.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码返回本地用户配置的`GlobalFactory`环境变量的值。在上面的代码片段中，您已将此行添加到`Program.cs`文件中，并将其设置为静态，因为这样可以使其在整个应用程序中易于访问。虽然在大型应用程序中，这不是您希望采取的做法；然而，对于您在这里的目的来说，这是可以的。
- en: Before you grasp models—the centerpiece of a program—you need to know about
    the major versions of EF.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在你掌握模型——程序的核心之前，你需要了解 EF 的主要版本。
- en: Which One to Choose—EF or EF Core?
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择哪一个——EF 还是 EF Core？
- en: There are two major versions of EF—EF and EF Core. Both are widely used, but
    you should be aware of some factors before making the choice that fits your project's
    requirements the best. EF was first released in 2008\. At that time, there was
    no .NET Core and C# was for **Windows only** and strictly required .NET Framework.
    Currently, the latest major version of EF is 6 and it's likely that there won't
    be any other major version, because in 2016, along with .NET Core 1.0 came EF
    Core 1 (a rework of EF 6).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: EF 有两个主要版本——EF 和 EF Core。两者都广泛使用，但在做出最适合你项目需求的选择之前，你应该了解一些因素。EF 首次于 2008 年发布。当时，没有
    .NET Core，C# 仅适用于 **Windows**，并且严格需要 .NET Framework。目前，EF 的最新主要版本是 6，并且很可能不会再有其他主要版本，因为
    2016 年，随着 .NET Core 1.0 一起发布了 EF Core 1（对 EF 6 的重写）。
- en: EF Core was initially named EF 7\. However, it was a complete rewrite of EF
    6 and therefore was soon renamed EF Core 1.0\. EF works only on .NET and is for
    Windows only, whereas .NET Core works only on .NET Core and is multi-platform.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 最初被命名为 EF 7。然而，它是对 EF 6 的完全重写，因此很快被重命名为 EF Core 1.0。EF 只能在 .NET 上运行，并且仅适用于
    Windows，而 .NET Core 只能在 .NET Core 上运行，并且是多平台的。
- en: Feature-wise, both frameworks are similar and are still being developed. However,
    the focus these days is on EF Core because the future of C# is associated with
    .NET 6, which is a multi-platform framework. At the time of writing this book,
    EF 6 has a richer set of features. However, EF Core is quickly catching up and
    is likely to soon be ahead. If your project's specifications do not require working
    with .NET Framework, it is preferable to stick with EF Core.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能上，这两个框架都很相似，并且仍在不断发展。然而，现在的重点是 EF Core，因为 C# 的未来与 .NET 6 相关联，这是一个多平台框架。在撰写本书时，EF
    6 拥有一套更丰富的功能。然而，EF Core 正在迅速迎头赶上，并可能很快就会领先。如果你的项目规格不需要与 .NET Framework 一起工作，坚持使用
    EF Core 是更好的选择。
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For the latest list of differences between the two, please refer to a comparison
    by Microsoft here: [https://docs.microsoft.com/en-us/ef/efcore-and-ef6/](https://docs.microsoft.com/en-us/ef/efcore-and-ef6/).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 关于两者之间最新差异的详细列表，请参阅微软的以下比较：[https://docs.microsoft.com/en-us/ef/efcore-and-ef6/](https://docs.microsoft.com/en-us/ef/efcore-and-ef6/)。
- en: 'Before you proceed, install the EF Core NuGet package so that you get access
    to the EF Core API. With the project open in Visual Studio Code (VS Code), run
    the following line in the terminal:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续之前，安装 EF Core NuGet 包，以便你可以访问 EF Core API。在 Visual Studio Code (VS Code)
    中打开项目后，在终端中运行以下行：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'By itself, `EntityFrameworkCore` is just a tool to abstract away database structures.
    To connect it with a specific database provider, you will need another package.
    Here you are using PostgreSQL. Therefore, the package you will install is `Npgsql.EntityFrameworkCore.PostgreSQL`.
    In order to install it, from the VS Code console, run the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，`EntityFrameworkCore` 只是一个用于抽象数据库结构的工具。为了将其与特定的数据库提供程序连接，你需要另一个包。这里你使用的是
    PostgreSQL。因此，你将安装的包是 `Npgsql.EntityFrameworkCore.PostgreSQL`。为了安装它，从 VS Code
    控制台运行以下命令：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You are now aware of the two versions of EF and how they work with .NET Framework and
    .NET. The next section will delve into the models which are the heart of a program.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经了解了 EF 的两种版本以及它们如何与 .NET Framework 和 .NET 一起工作。下一节将深入探讨模型，这是程序的核心。
- en: Model
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型
- en: A class designed to represent a business object is called a model. It always
    has data managed by properties or methods. Models are the centerpiece of a program.
    They don't depend on anything; other parts of a program point to them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计用来表示业务对象的类被称为模型。它总是通过属性或方法管理数据。模型是程序的核心。它们不依赖于任何东西；程序的其它部分指向它们。
- en: An object to which an ORM maps data tables is called an entity. In simple applications,
    an entity and a model are the same class. In complex applications, a change to
    a database is a common thing. That means that entities change often, and if you
    do not have a separate class for a model, your model would be impacted as well.
    Business logic should be isolated from database changes, and it is therefore recommended
    to have two classes—one for an entity and one for a model.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将数据表映射到对象的 ORM 被称为实体。在简单应用中，实体和模型是同一个类。在复杂应用中，对数据库的更改是常见的事情。这意味着实体经常发生变化，如果你没有为模型单独创建一个类，你的模型也会受到影响。业务逻辑应该与数据库更改隔离，因此建议有两个类——一个用于实体，一个用于模型。
- en: Before you continue with the next section, have a quick look at the `factory.product`
    and `factory.manufacturer` tables. One manufacturer makes many products. The following
    Entity Relationship (ER) diagram illustrates this relationship in *Figure 6.2*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一节之前，快速查看一下 `factory.product` 和 `factory.manufacturer` 表。一个制造商生产许多产品。以下实体关系（ER）图在图6.2中展示了这种关系。
- en: '![Figure 6.2: ER diagram of products and manufacturers ](img/B16835_06_02.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：产品和制造商的ER图](img/B16835_06_02.jpg)'
- en: 'Figure 6.2: ER diagram of products and manufacturers'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：产品和制造商的ER图
- en: 'An entity, ideally, should mirror table columns. You can mirror columns through
    properties. For example, a `factory.product` table has `id`, `name`, `price`,
    and `manufacturerId`. An object that maps to that would look like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实体，理想情况下，应该与表列相对应。您可以通过属性来映射列。例如，`factory.product` 表有 `id`、`name`、`price` 和
    `manufacturerId`。映射到该表的对象可能看起来像这样：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You know that only the price of a product can change; the rest of the properties
    would not. However, in the preceding snippet, a setter has still been written
    for every property. This is because entities created through an ORM always need
    to have all properties with setters, or else it might not set the value.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道只有产品的价格可以改变；其余属性不会变。然而，在前面的代码片段中，每个属性都仍然编写了一个设置器。这是因为通过ORM创建的实体始终需要所有属性都有设置器，否则可能无法设置值。
- en: 'An entity should be designed to match a table structure, but it does not always
    have to be that way. For example, if the `Id` property were renamed to `PrimaryKey`,
    you could still use EF the same way by using a special data annotation `[Key]`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实体应该设计成与表结构相匹配，但并不总是必须这样。例如，如果 `Id` 属性被重命名为 `PrimaryKey`，您仍然可以使用EF以相同的方式使用，通过使用特殊的数据注释
    `[Key]`：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Data Annotation is an attribute that adds metadata to a property. You can use
    it to provide a different name, have a constraint column as a key, add the minimum
    and maximum lengths for fields, add precision, declare a field as mandatory, and
    more. On their own, data annotations don't do anything. They don't add logic to
    a model. Some other components will consume annotated objects, which will involve
    reading their attributes and performing actions based on that.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 数据注释是一个属性，它向属性添加元数据。您可以使用它来提供不同的名称，将约束列作为键，为字段添加最小和最大长度，添加精度，声明字段为必填项，等等。单独使用数据注释不会做任何事情。它们不会向模型添加逻辑。其他一些组件将消费注释对象，这将涉及读取它们的属性并根据这些属性执行操作。
- en: 'Your model (illustrating the ER diagram from *Figure 6.2*) is almost complete,
    but there are a few problems to be addressed:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您的模型（展示图6.2中的ER图）几乎完成了，但还有一些问题需要解决：
- en: First, the table-model mapping is missing a schema (`factory`, in this case),
    and so you need to specify it explicitly using a `Table` attribute.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，表格模型映射缺少一个模式（`factory`，在这种情况下），因此您需要使用 `Table` 属性显式指定它。
- en: Second, by default if you wanted to also retrieve a `manufacturer`, you would
    need another query. You can fix this by adding a navigational property that refers
    to the manufacturer. But why should you use a navigational property? If there
    were only an ID, you would need a separate query to get the related entity. However,
    using navigational properties, you can use eager loading and get two or more entities
    at once.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，默认情况下，如果您还想检索一个 `manufacturer`，您将需要一个额外的查询。您可以通过添加一个指向制造商的导航属性来修复这个问题。但为什么您应该使用导航属性呢？如果只有一个ID，您将需要一个单独的查询来获取相关实体。然而，使用导航属性，您可以使用预加载一次获取两个或更多实体。
- en: 'The following code snippet will show you how to create a `Manufacturer` class
    and fix these issues for both models:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段将向您展示如何创建 `Manufacturer` 类并修复这两个模型的问题：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note the new `List<Product>();` part. It is needed so that if a table does not
    yet have products, the code would still function when you try to add a new product
    without throwing `NullReferenceException`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意新的 `List<Product>();` 部分。这是必需的，以便在尝试添加新产品而表格中尚未有产品时，代码仍然可以正常工作，而不会抛出 `NullReferenceException`。
- en: 'In the following snippet of code, a model is created for a product table:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，为产品表创建了一个模型：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The two models are complete for mapping to tables from your database. You did
    not replace an ID property with a navigational property; both are present. If
    you did not do this, it would require the parent entity (`Manufacturer`) to be
    fetched before you could do anything with a product. With this approach, you can
    work with a product in isolation from the manufacturer. All you need is an ID
    link.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个模型已经完整，可以映射到你的数据库表。你没有用导航属性替换 ID 属性；两者都存在。如果你没有这样做，那么在你可以对产品进行任何操作之前，需要先获取父实体（`Manufacturer`）。使用这种方法，你可以独立于制造商处理产品。你所需要的就是一个
    ID 链接。
- en: On top of the mentioned fixes, you made your navigational properties (`Manufacturer`
    and `Products`) virtual. This is needed to enable lazy loading for EF. Lazy loading
    means that there is no data loaded in a property until that property is referenced.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述修复的基础上，你还使你的导航属性（`Manufacturer` 和 `Products`）虚拟。这对于启用 EF 的懒加载是必要的。懒加载意味着直到引用该属性时，该属性中才没有加载数据。
- en: Finally, it is worth mentioning that for manufacturer products, you used `ICollection`
    and not `IEnumerable` or other collections. This makes sense because EF will need
    to populate the collection when it retrieves and map the items. `List` or even
    `Set` could work, but when designing object-oriented code, you should focus on
    the highest abstraction you can depend on, in this case it is `ICollection`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得提到的是，对于制造商产品，你使用了 `ICollection` 而不是 `IEnumerable` 或其他集合。这很有意义，因为 EF 在检索和映射项目时需要填充集合。`List`
    或甚至 `Set` 都可以工作，但在设计面向对象的代码时，你应该专注于你可以依赖的最高抽象，在这种情况下是 `ICollection`。
- en: Note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/gfgB1](https://packt.link/gfgB1).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/gfgB1](https://packt.link/gfgB1) 找到用于此示例的代码。
- en: In order to run this example, go to [https://packt.link/2oxXn](https://packt.link/2oxXn)
    and comment all lines within the `static void` `Main(string[] args)` body, except
    `Examples.TalkingWithDb.Orm.Demo.Run();`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行此示例，请访问 [https://packt.link/2oxXn](https://packt.link/2oxXn) 并注释掉 `static
    void Main(string[] args)` 体内的所有行，除了 `Examples.TalkingWithDb.Orm.Demo.Run();`。
- en: You are now clear about the entity, models, entity relationship, data annotation,
    eager loading, and lazy loading. The next section will show you how to combine
    everything and communicate with a database through EF Core.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在对实体、模型、实体关系、数据注释、预加载和懒加载有了清晰的认识。下一节将展示如何结合所有这些内容，并通过 EF Core 与数据库进行通信。
- en: DbContext and DbSet
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DbContext 和 DbSet
- en: '`DbContext` is what EF uses as an abstraction to a database. A new database
    abstraction must be derived from the `DbContext` class and provide a way of connecting
    to a database. Just like a database contains one or more tables, `DbContext` contains
    one or more `DbSet` entities. For example, consider the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`DbContext` 是 EF 用于数据库抽象的类。一个新的数据库抽象必须从 `DbContext` 类派生，并提供连接到数据库的方式。就像数据库包含一个或多个表一样，`DbContext`
    包含一个或多个 `DbSet` 实体。例如，考虑以下代码：'
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, `FactoryDbContext` is an abstraction of the database that you created
    before, with two tables: `Products` and `Manufacturers`. The `OnConfiguring` method
    takes `DbContextOptionsBuilder`, which allows you to specify what database you
    want to connect to and how that connection is made. In this case, you are using
    PostgreSQL Server and specifying a database to connect to. Please note that in
    case there is an already configured database provider then you will not use `Npgsql`
    in the `if` statement i.e., the `if (!optionsBuilder.IsConfigured)` statement.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`FactoryDbContext` 是你之前创建的数据库抽象，包含两个表：`Products` 和 `Manufacturers`。`OnConfiguring`
    方法接受 `DbContextOptionsBuilder`，这允许你指定要连接的数据库以及如何建立连接。在这种情况下，你正在使用 PostgreSQL Server
    并指定要连接的数据库。请注意，如果已经配置了数据库提供程序，则你将不会在 `if` 语句中使用 `Npgsql`，即 `if (!optionsBuilder.IsConfigured)`
    语句。
- en: 'It is important to note that you should not completely depend on a specific
    database provider for two reasons:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，你应该不依赖于特定的数据库提供程序，原因有两个：
- en: Firstly, changing a database provider is easy; it is just a matter of using
    a different extension method on a builder.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，更改数据库提供程序很容易；这只是一个在构建器上使用不同扩展方法的问题。
- en: Secondly, EF has an in-memory database provider, which is effective for testing.
    Alternatively, you could use SQLite as well as a lightweight database meant just
    for testing.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，EF 有一个内存数据库提供程序，这对于测试非常有效。或者，你也可以使用 SQLite，它是一个轻量级的数据库，仅用于测试。
- en: 'Currently, your database abstraction needs improvement because it only lets
    you communicate with the SQL Server database. Instead of hardcoding the options,
    you will inject them. Injecting allows you to configure an existing class differently,
    without modifying it. You do not need to change the models to be able to choose
    the database you want to connect to. You can specify which database you want to
    connect to by passing an `options` object through the `FactoryDbContext` constructor:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你的数据库抽象需要改进，因为它只允许你与 SQL Server 数据库通信。而不是硬编码选项，你将注入它们。注入允许你配置现有的类，而无需修改它。你不需要更改模型就能选择你想要连接到的数据库。你可以通过将
    `options` 对象传递给 `FactoryDbContext` 构造函数来指定你想要连接到的数据库：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The default constructor is for the default provider, which will be used when
    no options are supplied. In this case, the context was designed to use PostgreSQL;
    therefore, you would add the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数用于默认提供程序，当没有提供选项时将使用它。在这种情况下，上下文被设计为使用 PostgreSQL；因此，你需要添加以下代码：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`DbContext` can be configured using `DbContextOptions`. In this example, you
    need to configure a database provider (PostgreSQL) and a connection string. Choose
    the provider using `DbContextOptionsBuilder`. The `UseNpgsql` is how you hook
    the PostgreSQL provider with your database context, as shown here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `DbContextOptions` 来配置 `DbContext`。在这个例子中，你需要配置一个数据库提供程序（PostgreSQL）和一个连接字符串。使用
    `DbContextOptionsBuilder` 来选择提供程序。`UseNpgsql` 是将 PostgreSQL 提供程序与数据库上下文连接起来的方式，如下所示：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The full `DbContext` now looks like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 `DbContext` 现在看起来是这样的：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In order to run this example, go to [https://packt.link/2oxXn](https://packt.link/2oxXn)
    and comment all lines within the `static void` `Main(string[] args)` body, except
    `Examples.TalkingWithDb.Orm.Demo.Run();`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行此示例，请访问 [https://packt.link/2oxXn](https://packt.link/2oxXn) 并在 `static
    void Main(string[] args)` 主体中注释掉所有行，除了 `Examples.TalkingWithDb.Orm.Demo.Run();`。
- en: 'To get the products from the database you have made, you first connect to a
    database by initializing an instance of your `DbContext`. You then call a wanted
    `DbSet` from that context and send a call to a database by calling `ToList()`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数据库中获取产品，你首先通过初始化你的 `DbContext` 实例来连接到数据库。然后，从该上下文中调用一个想要的 `DbSet`，并通过调用 `ToList()`
    发送对数据库的调用：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this case, you create a `FactoryDbContext` (which creates a connection to
    the `GlobalFactory` database) and the `context.Products.ToList()` equates to a
    `SELECT * FROM Products` SQL statement.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你创建了一个 `FactoryDbContext`（它连接到 `GlobalFactory` 数据库），而 `context.Products.ToList()`
    等同于一个 `SELECT * FROM Products` SQL 语句。
- en: Note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The two lines mentioned are not included within GitHub. They are trivial and
    are here only for illustrative purposes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 提到的两行不包括在 GitHub 中。它们很简单，这里只是为了说明目的。
- en: 'When you initialize a `DbContext`, you almost always create a connection to
    a database, and if not managed, you might eventually run out of connections inside
    a connection pool (a collection of available connections). `DbContext` is an unmanaged
    resource; it implements the `IDisposable` interface, and so it needs explicit
    cleanup. Here, you applied a C# feature—inline using—which disposes of the object
    after it leaves the scope it is at:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你初始化一个 `DbContext` 时，你几乎总是创建一个数据库连接，如果没有管理好，你最终可能会在连接池（一组可用连接）中耗尽连接。`DbContext`
    是一个未管理资源；它实现了 `IDisposable` 接口，因此需要显式清理。在这里，你应用了一个 C# 功能——内联使用，它在对象离开其作用域后销毁对象：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When you have a `DbContext`, getting data from it is trivial:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拥有一个 `DbContext` 时，从中获取数据是微不足道的：
- en: Access a `DbSet`.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 `DbSet`。
- en: Convert it into a list.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其转换为列表。
- en: Why do you need to make any conversions, though? That is because `DbSet`, much
    like `IEnumerable`, is lazy-loaded. It encapsulates the SQL needed to execute.
    So, unless you explicitly demand it (for example, by calling `ToList`), there
    won't be any data queried. Calling `ToList` does the actual call to a database
    and retrieves all the products.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为什么你需要进行任何转换呢？那是因为 `DbSet` 与 `IEnumerable` 类似，是懒加载的。它封装了执行所需的 SQL。所以，除非你明确要求（例如，通过调用
    `ToList`），否则不会查询任何数据。调用 `ToList` 会实际调用数据库并检索所有产品。
- en: You now know all about databases. The next section will touch on the `AdventureWorks`
    database which is a common database for teaching SQL to beginners.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经了解了所有关于数据库的知识。下一节将涉及 `AdventureWorks` 数据库，这是一个常用于教授初学者 SQL 的数据库。
- en: AdventureWorks Database
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AdventureWorks 数据库
- en: '`AdventureWorks` is a database used for learning purposes. It contains dozens
    of tables and has hundreds of records in each table. The tables are focused on
    wholesale, which is a common scenario in enterprise applications. In other words,
    the `AdventureWorks` database provides examples for learning with closeness to
    real-world problems.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`AdventureWorks` 是一个用于学习目的的数据库。它包含数十个表，每个表中都有数百条记录。这些表专注于批发，这是企业应用中的常见场景。换句话说，`AdventureWorks`
    数据库提供了与真实世界问题接近的学习示例。'
- en: Note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You must first create the `AdventureWorks` database in PostgreSQL. You can find
    the steps to create this database in the reference chapter placed on GitHub.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须首先在 PostgreSQL 中创建 `AdventureWorks` 数据库。你可以在 GitHub 上找到创建此数据库的步骤，位于参考章节中。
- en: The previous sections covered entity, models, and how to combine everything
    and communicate with a database. You also learned about `DbContext` and `DbSet`.
    This concludes the theoretical portion of this section. In the following section,
    you will put this into practice with an exercise.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前几节介绍了实体、模型以及如何组合一切并与数据库通信。你还学习了 `DbContext` 和 `DbSet`。这完成了本节的理论部分。在下一节中，你将通过练习将其付诸实践。
- en: 'Exercise 6.01: Reading Stock Locations from AdventureWorks Database'
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.01：从 AdventureWorks 数据库读取库存位置
- en: 'The simplest use case of EF is to read data tables into C# objects. This exercise
    will teach you how to create a data entity class and add correct attributes to
    it. For this, you will create an inventory `location` table within the example
    `AdventureWorks` database. Perform the following steps to do so:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: EF 的最简单用法是将数据表读入 C# 对象。本练习将教会你如何创建数据实体类并将其添加正确的属性。为此，你将在示例 `AdventureWorks`
    数据库中创建一个库存 `location` 表。执行以下步骤来完成此操作：
- en: 'Create a `Location` entity. It should have `LocationId`, `Name`, `Costrate`,
    `Availability`, and `ModifiedDate` properties, as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Location` 实体。它应该有 `LocationId`、`Name`、`Costrate`、`Availability` 和 `ModifiedDate`
    属性，如下所示：
- en: '[PRE22]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A `[Table]` attribute has been applied because you need to specify a schema
    as well as a properly capitalized table name. On top of that, every column name
    needs to be explicitly specified using the `[Column]` attribute since the capitalization
    does not match.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要指定模式和正确大写的表名，已应用 `[Table]` 属性。此外，每个列名都需要使用 `[Column]` 属性显式指定，因为大小写不匹配。
- en: 'Create a class named `AdventureWorksContext`, which inherits the `DbContext`,
    as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `AdventureWorksContext` 的类，它继承自 `DbContext`，如下所示：
- en: '[PRE23]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Inheriting `DbContext` is necessary if you want to reuse the base functionality
    of database abstraction such as connecting to a database. The use of base functionality
    is visible in the two base constructors. In the parameterized constructor, you
    use PostgreSQL; in non-parameterized you can supply whatever database provider
    you choose.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想重用数据库抽象的基础功能，如连接到数据库，则必须继承 `DbContext`。基础功能的用法在两个基础构造函数中可见。在参数化构造函数中，你使用
    PostgreSQL；在非参数化构造函数中，你可以提供你选择的任何数据库提供程序。
- en: 'Now use the `Program.AdventureWorksConnectionString` connection string as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在按照以下方式使用 `Program.AdventureWorksConnectionString` 连接字符串：
- en: '[PRE24]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This represents the needed `location` table.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表所需的 `location` 表。
- en: Note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please keep your PostgreSQL passwords safe. Don't write them in code in plaintext,
    instead use environment variables or secrets.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保您的 PostgreSQL 密码安全。不要在代码中以明文形式写入它们，而是使用环境变量或密钥。
- en: 'Connect to a database:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到数据库：
- en: '[PRE25]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is as simple as creating a new `DbContext`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像创建一个新的 `DbContext` 一样简单。
- en: 'Get all products by adding the following code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下代码来获取所有产品：
- en: '[PRE26]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that you have queried the locations and no longer need to keep the connection
    open, it is better to disconnect from the database. In order to disconnect from
    the database, call the `Dispose` method as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经查询了位置并且不再需要保持连接打开，最好是断开与数据库的连接。为了断开与数据库的连接，请按照以下方式调用 `Dispose` 方法：
- en: '[PRE27]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Print the results by adding the following code:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下代码来打印结果：
- en: '[PRE28]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The code itself is run from [https://packt.link/2oxXn](https://packt.link/2oxXn).
    Make sure to comment all lines within `static void` `Main(string[] args)` body,
    except `Exercises.Exercise03.Demo.Run()`. When you run the code, the following
    output gets displayed:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 代码本身在 [https://packt.link/2oxXn](https://packt.link/2oxXn) 运行。请确保在 `static void
    Main(string[] args)` 方法体内注释掉所有 `static void` 的行，除了 `Exercises.Exercise03.Demo.Run()`。当你运行代码时，以下输出将显示：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Working with EF is simple. As you can see from this exercise, it is intuitive
    and feels like a natural extension to C#.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用EF很简单。正如你可以从这个练习中看到的那样，它直观，感觉像是C#的自然扩展。
- en: Note
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/9Weup](https://packt.link/9Weup).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/9Weup](https://packt.link/9Weup)找到用于此练习的代码。
- en: Querying a Database—LINQ to SQL
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询数据库——LINQ to SQL
- en: 'One of the more interesting features of EF is that running SQL statements is
    very much like working with a collection. For example, say you want to retrieve
    a product by its name. You can get a product by name the same way you would be
    using LINQ:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: EF（Entity Framework）的一个更有趣的特性是执行SQL语句非常类似于操作一个集合。例如，假设你想通过名称检索一个产品。你可以通过名称获取产品，就像使用LINQ一样：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, `FirstOrDefault` returns the first matching product by its name. If no
    product by that name exists, then it returns a `null`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`FirstOrDefault`通过名称返回第一个匹配的产品。如果不存在具有该名称的产品，则返回`null`。
- en: 'What about finding a unique element by its ID? In that case, you would use
    a special method (`Find`), which either gets an entity from a database or, if
    one with the same ID has been retrieved recently, returns it from memory:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何通过ID查找唯一元素呢？在这种情况下，你会使用一个特殊的方法（`Find`），它要么从数据库中获取一个实体，要么如果最近已经检索了具有相同ID的实体，则从内存中返回它：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When using a primary key, it is better to use `Find` instead of `Where` because
    it has a slightly different meaning in the context of EF. Instead of trying to
    create a SQL query and execute it, `Find` will check whether this item has already
    been accessed and will retrieve it from a cache, rather than going through a database.
    This makes for more efficient operations.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用主键时，最好使用`Find`而不是`Where`，因为在EF的上下文中，它们具有略微不同的含义。`Find`不会尝试创建SQL查询并执行它，而是会检查此项目是否已经被访问，并从缓存中检索它，而不是通过数据库。这使得操作更加高效。
- en: 'What about finding all products by the related manufacturer ID? You can create
    a method that returns an `IEnumerable<Product>` for this purpose, named `GetByManufacturer`,
    as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 关于通过相关制造商ID查找所有产品，你可以创建一个返回`IEnumerable<Product>`的方法来实现此目的，命名为`GetByManufacturer`，如下所示：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You might be wondering why you should choose to use `Where` instead of `Find`
    here. That is because you are getting many products by their foreign key `manufacturerId`.
    Be careful not to mix foreign and primary keys; `Find` is used only for primary
    keys.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么你应该选择在这里使用`Where`而不是`Find`。那是因为你正在通过外键`manufacturerId`获取许多产品。请注意不要混淆外键和主键；`Find`仅用于主键。
- en: In order to run this example, go to [https://packt.link/2oxXn](https://packt.link/2oxXn)
    and comment all lines within `static void Main(string[] args)` body except `Examples.Crud.Demo.Run();`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行此示例，请访问[https://packt.link/2oxXn](https://packt.link/2oxXn)，并在`static void
    Main(string[] args)`体中注释掉所有行，除了`Examples.Crud.Demo.Run();`。
- en: Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/pwcwx](https://packt.link/pwcwx).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/pwcwx](https://packt.link/pwcwx)找到用于此示例的代码。
- en: Now, how about retrieving related entities? If you simply call `db.Manufacturers.ToList()`,
    you will have null products. This is because the products will not be retrieved
    automatically unless explicitly specified. If you didn't call `ToList()`, you
    could make use of lazy-loading (that is, loading the required entities on demand),
    but that would result in a very suboptimal solution as you would always be querying
    child entities for every parent.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于检索相关实体，如果你简单地调用`db.Manufacturers.ToList()`，你将得到null产品。这是因为除非明确指定，否则产品不会自动检索。如果你没有调用`ToList()`，你可以利用延迟加载（即按需加载所需的实体），但这将导致一个非常低效的解决方案，因为你将始终查询每个父实体的子实体。
- en: 'A proper solution is to call `Include(parent => parent.ChildToInclude)`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合适的解决方案是调用`Include(parent => parent.ChildToInclude)`：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This approach is called eager loading. With this approach, you specify which
    child entities should be retrieved immediately. There will be scenarios where
    child entities will have their child entities; there, you could call `ThenInclude`.
    In order to run this example, comment all lines within `static void Main(string[]
    args)` body except `Examples.Crud.Demo.Run();` in `Program.cs`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法被称为预加载。使用这种方法，你指定哪些子实体应该立即检索。在子实体还有其子实体的情况下，你可以调用`ThenInclude`。为了运行此示例，请在`Program.cs`中注释掉`static
    void Main(string[] args)`体中的所有行，除了`Examples.Crud.Demo.Run();`。
- en: Note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/c82nA](https://packt.link/c82nA).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/c82nA](https://packt.link/c82nA)找到用于此示例的代码。
- en: Remember when it was established that trying to get everything from a table
    is not the right thing to do in most cases? Eager loading has the same problem.
    So, what should you do if you only want some properties? It's time to learn about
    the other side of LINQ.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 记得当提到尝试从表中获取所有内容在大多数情况下不是正确做法时吗？贪婪加载也有同样的问题。那么，如果你只想获取一些属性，你应该学习LINQ的另一面。
- en: Query Syntax
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询语法
- en: 'Query syntax is an alternative syntax to LINQ lambdas. It is very similar to
    SQL. The main advantage of query syntax over lambdas is that it feels more natural
    to write queries when you have complex joins and want only some of the data back.
    Imagine you wanted to get all product-manufacturer name pairs. You cannot simply
    get manufacturers and include products; you only want two products. If you tried
    using LINQ, the code would like the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 查询语法是LINQ lambdas的另一种语法。它与SQL非常相似。查询语法相对于lambda的主要优势是，当你有复杂的连接并且只想获取一些数据时，写查询会感觉更自然。想象一下，如果你想获取所有产品-制造商名称对。你不能简单地获取制造商并包含产品；你只想获取两个产品。如果你尝试使用LINQ，代码将类似于以下：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The same operation using query syntax looks like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用查询语法执行相同操作的样子如下：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Break the code down:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 分解代码：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now select all products and their columns:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在选中所有产品和它们的列：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For every product, add manufacturer columns like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个产品，添加制造商列如下：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Manufacturer columns are added only for products which have `ManufacturerId`
    equal to the `Id` of the manufacturer (`INNER JOIN`).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当产品的`ManufacturerId`等于制造商的`Id`时，才会添加制造商列（`INNER JOIN`）。
- en: Note
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Why can't you write `==` instead of `equals`? That is because, in LINQ query
    syntax, `equals` completes a join; it is not just a comparison of two values.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不能写`==`而不是`equals`？这是因为，在LINQ查询语法中，`equals`完成了一个连接；它不仅仅是两个值的比较。
- en: The `select` part is the same in both lambda and query syntax; however, it's
    worth mentioning what you selected. The `select new {...}` means that you create
    a new anonymous object to have all the things you want to select. The idea is
    to later use this to return a strongly typed object that you need. Therefore,
    after a `ToList` method, you are likely to perform another `select` operation
    to map the results for the final return. You cannot do the mapping right away
    because before you do `ToList`, you are still working with an expression that
    is yet to be converted into SQL. Only after `ToList` is called can you be sure
    that you are working with C# objects.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`部分在lambda和查询语法中都是相同的；然而，提一下你选择了什么是有意义的。`select new {...}`意味着你创建了一个新的匿名对象，包含你想要选择的所有内容。这个想法是稍后使用它来返回一个你需要的有强类型的对象。因此，在调用`ToList`方法之后，你很可能会执行另一个`select`操作来映射最终返回的结果。你不能立即进行映射，因为在调用`ToList`之前，你仍在处理一个尚未转换为SQL的表达式。只有调用`ToList`之后，你才能确定你正在处理C#对象。'
- en: Finally, you may be wondering why the join is surrounded by brackets before
    calling `ToList`. That's because you were still in query syntax mode and the only
    way to escape it and go back to normal LINQ is by surrounding it with brackets.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能想知道为什么在调用`ToList`之前，连接操作被括号包围。这是因为你仍然处于查询语法模式，而唯一摆脱它并回到正常LINQ的方式就是用括号包围它。
- en: 'If you struggle to remember LINQ query syntax, remember a `foreach` loop:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你难以记住LINQ查询语法，记住一个`foreach`循环：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The query syntax of `from` is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`from`的查询语法如下：'
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The highlighted part in the preceding code snippet is the syntax parts that
    overlap on both. This also applies to join. The two make the most of query syntax.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中突出显示的部分是两个语法重叠的部分。这也适用于连接。这两个部分充分利用了查询语法。
- en: Both lambda and query syntax has the same performance metrics because, in the
    end, the query syntax will be compiled into the lambda equivalent. When making
    complex joins, it might make more sense to use a query syntax because it will
    look closer to SQL and therefore might be easier to grasp.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: lambda和查询语法都有相同的性能指标，因为最终，查询语法将被编译成lambda等价物。当进行复杂的连接时，使用查询语法可能更有意义，因为它看起来更接近SQL，因此可能更容易理解。
- en: 'Now run the code. In order to run this example, comment all lines within `static
    void Main(string[] args)` body except `Examples.Crud.Demo.Run();` in `Program.cs`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行代码。为了运行此示例，在`Program.cs`中的`static void Main(string[] args)`体内部除`Examples.Crud.Demo.Run();`之外的所有行进行注释：
- en: Note
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/c82nA](https://packt.link/c82nA).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/c82nA](https://packt.link/c82nA)找到用于此示例的代码。
- en: You now know that query syntax is an alternative syntax to LINQ lambdas. But
    how you can perform the remaining operations with rows that are, create, update,
    and delete, using query syntax? The next section details how that can be done.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道查询语法是LINQ lambda的另一种语法。但你是如何使用查询语法来执行剩余的操作，比如创建、更新和删除行呢？下一节将详细说明如何做到这一点。
- en: The Rest of CRUD
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CRUD的其余部分
- en: 'Adding, updating, and removing data using query syntax is also similar to basic
    LINQ. However, similar to executing the queries by calling `ToList`, it involves
    one extra step that is, committing the changes. Consider the following code where
    you are creating a new product:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用查询语法添加、更新和删除数据与基本的LINQ也类似。然而，与通过调用`ToList`执行查询类似，它涉及一个额外的步骤，即提交更改。考虑以下代码，其中你正在创建一个新的产品：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This code should look almost completely familiar, except for the last line.
    The `SaveChanges` method is used to run the actual SQL. If you don't call it,
    nothing will happen, and the changes will be gone after disconnecting from the
    database. Also, when adding a child entity (`product`), you don't have to get
    a parent entity (`manufacturer`). All you have to do is to provide a link between
    the two via the foreign key (`ManufacturerId`).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来几乎完全熟悉，除了最后一行。`SaveChanges`方法用于运行实际的SQL。如果你不调用它，什么都不会发生，更改在断开数据库连接后将会消失。此外，当添加子实体（`product`）时，你不需要获取父实体（`manufacturer`）。你只需要通过外键（`ManufacturerId`）在两者之间提供链接。
- en: Why do you need an extra method to apply your changes? Wouldn't it be simpler
    to call `Add` and immediately have a new product row created? In practice, it
    is not that simple. What happens if multiple `Add` methods of different entities
    need to be performed, and what if one of them fails? Should you allow some of
    them to succeed, while others fail? The worst thing you can do is to put your
    database in an invalid state, or, in other words, break data integrity. You need
    a mechanism to either complete fully or fail without affecting anything.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你需要一个额外的方法来应用你的更改？直接调用`Add`并立即创建一个新的产品行不是更简单吗？在实践中，事情并不那么简单。如果有多个不同实体的`Add`方法需要执行，并且其中一个失败了怎么办？你应该允许其中一些成功，而其他失败吗？最糟糕的事情是你可以将数据库置于无效状态，换句话说，破坏数据完整性。你需要一个机制来完全完成或失败，而不影响任何东西。
- en: In the SQL context, such commands that are run together are called a transaction.
    You can do two things with transactions—either commit or roll them back. In EF,
    every action, other than a query, results in a transaction. The `SaveChanges`
    completes the transaction, whereas a command failing rolls the transaction back.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL上下文中，这些一起运行的命令被称为事务。你可以对事务做两件事——要么提交，要么回滚。在EF中，除了查询之外，每个操作都会导致一个事务。`SaveChanges`方法完成事务，而命令失败则会回滚事务。
- en: 'If you were to call plain SQL commands in C#, you would need to create a parameterized
    SQL command, provide each argument separately, and concatenate SQL for multi-query
    updates. For a small entity it may be easy; however, as the size grows the complexity
    increases as well. Using EF, you don''t need to care about low-level details,
    such as passing arguments to a command. For example, with EF, adding a `manufacturer`
    with a few products is as simple as adding a `manufacturer` to a `Manufacturers`
    list:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在C#中调用纯SQL命令，你需要创建一个参数化的SQL命令，分别提供每个参数，并拼接SQL以进行多查询更新。对于小型实体来说可能很简单；然而，随着规模的增大，复杂性也会增加。使用EF，你不需要关心低级细节，例如向命令传递参数。例如，使用EF，添加一个包含几个产品的`manufacturer`就像向`Manufacturers`列表添加一个`manufacturer`一样简单：
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, creating manufacturers is nearly the same as adding an element
    to a list. The major difference is the need to complete the changes using `db.SaveChanges()`
    method.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，创建制造商几乎与向列表添加元素相同。主要区别在于需要使用`db.SaveChanges()`方法来完成更改。
- en: 'What about updating an existing product? Set the price of a product to `45.99`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 关于更新现有产品？将产品的价格设置为`45.99`：
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you look carefully at this code, you are provided with not only the updated
    `Price` and an existing item `Id` but also all other fields. This is because there
    is no way for EF to know whether you want to set existing values to null or only
    set the new values. But don't worry; logically, there is rarely a case when you
    update something out of nowhere. You should have a set of items loaded somewhere.
    Therefore, updating an existing object would simply be a matter of setting a new
    value of a property of that object.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看此代码，你不仅提供了更新的`Price`和现有的`Id`项，还提供了所有其他字段。这是因为EF无法知道你是否想将现有值设置为null，或者只设置新值。但别担心；从逻辑上讲，更新某物而没有任何依据的情况很少见。你应该在某处加载一组项目。因此，更新现有对象只是设置该对象属性的新值的问题。
- en: 'Of course, there are exceptions when you want to update just one thing. In
    that case, you can have a dedicated method and be completely in control. In the
    following snippet, you will update product values, but only when they are not
    null:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当你只想更新一项内容时，会有例外。在这种情况下，你可以有一个专门的方法，并完全控制。在下面的代码片段中，你将更新产品值，但仅当它们不为空时：
- en: '[PRE44]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, you would only update the values if they were not the default ones. Ideally,
    when working in situations like this (in which you only want to update some of
    the fields), you should have a dedicated model for the updated fields, send those
    fields, and map them using libraries such as AutoMapper.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你只会更新那些不是默认值的值。理想情况下，在类似这种情况（你只想更新一些字段）的情况下工作，你应该有一个专门用于更新字段的模型，发送这些字段，并使用如AutoMapper之类的库进行映射。
- en: Note
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about AutoMapper, refer to their official documentation at [https://docs.automapper.org/en/stable/Getting-started.xhtml](https://docs.automapper.org/en/stable/Getting-started.xhtml).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于AutoMapper的信息，请参阅他们的官方文档：[https://docs.automapper.org/en/stable/Getting-started.xhtml](https://docs.automapper.org/en/stable/Getting-started.xhtml)。
- en: 'What about deleting existing rows from a database? This involves first getting
    the object you want to remove and only then remove it. For example, say you want
    to remove a product with a particular ID:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 关于从数据库中删除现有行呢？这涉及到首先获取你想要删除的对象，然后才能删除它。例如，假设你想删除具有特定ID的产品：
- en: '[PRE45]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Once again, removing something from a database is nearly the same as removing
    an element from a list with a small difference that `db.SaveChanges()` is used
    to confirm the changes. In order to run this example, comment all lines within
    `static void Main(string[] args)` body except `Examples.Crud.Demo.Run();` in `Program.cs`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，从数据库中删除某项内容几乎与从列表中删除一个元素相同，唯一的区别是使用`db.SaveChanges()`来确认更改。为了运行此示例，请在`Program.cs`中注释掉`static
    void Main(string[] args)`体内的所有行，除了`Examples.Crud.Demo.Run();`。
- en: Note
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/bH5c4](https://packt.link/bH5c4).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此示例中找到使用的代码：[https://packt.link/bH5c4](https://packt.link/bH5c4)。
- en: You have grasped that the basic concept of CRUD is a combination of four functions—create,
    read, update, and delete. Now it is time to put this into practice in the following
    exercise.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经掌握了CRUD的基本概念是四个函数的组合——创建、读取、更新和删除。现在，是时候在以下练习中将其付诸实践了。
- en: 'Exercise 6.02: Updating Products and Manufacturers Table'
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.02：更新产品和制造商表
- en: 'You have already created a `GlobalFactory` database with `Products` and `Manufacturers`
    tables, and you now have enough components to perform full Create, Read, Update
    and Delete (CRUD) on the database. In this exercise, you will use `FactoryDbContext`
    to create methods inside a new class called `GlobalFactoryService`, which can
    accomplish the following tasks:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了一个包含`Products`和`Manufacturers`表的`GlobalFactory`数据库，你现在有足够的组件来执行数据库的完整创建、读取、更新和删除（CRUD）操作。在这个练习中，你将使用`FactoryDbContext`在名为`GlobalFactoryService`的新类中创建方法，以完成以下任务：
- en: Add a list of manufacturers in the US.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加美国地区的制造商列表。
- en: Add a list of products to all manufacturers in the US.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将产品列表添加到美国的所有制造商中。
- en: Update any one product in the US with a given discount price.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在美国更新任何一种产品，并给出一个折扣价格。
- en: Remove any one product from the US region.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从美国地区删除任何一种产品。
- en: Get all manufacturers from the US and their products.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取美国的所有制造商及其产品。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: First, create a `GlobalFactoryService` class.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个`GlobalFactoryService`类。
- en: Create `FactoryDbContext` inside a constructor and inject the context. Injecting
    the context means that you have a choice of setting it up in any way you want
    (for example, using different providers).
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中创建 `FactoryDbContext` 并注入上下文。注入上下文意味着您可以选择以任何您想要的方式设置它（例如，使用不同的提供者）。
- en: 'Create a constructor that accepts `FactoryDbContext` as an argument, as follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个接受 `FactoryDbContext` 作为参数的构造函数，如下所示：
- en: '[PRE46]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a `public void CreateManufacturersInUsa(IEnumerable<string> names)`
    method, as follows:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `public void CreateManufacturersInUsa(IEnumerable<string> names)` 方法，如下所示：
- en: '[PRE47]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: A manufacturer has only two custom fields—`Name` and `Country`. In this case,
    the value of the `Country` is known to be `"USA"`. All you have to do is to pass
    a list of manufacturer `names` and build `Manufacturers` by combining the value
    of the `Country` with their name.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 制造商只有两个字段——`Name` 和 `Country`。在这种情况下，`Country` 的值已知为 `"USA"`。您只需传递一个制造商 `names`
    列表，并通过将 `Country` 的值与它们的名称组合来构建 `Manufacturers`。
- en: To create the products, create a `public void CreateUsaProducts(IEnumerable<Product>
    products)` method.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建产品，创建一个 `public void CreateUsaProducts(IEnumerable<Product> products)` 方法。
- en: Then get all the manufacturers in the US.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后获取所有美国制造商。
- en: 'Finally, iterate each manufacturer and add all the products to each of them:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，遍历每个制造商并将所有产品添加到每个制造商中：
- en: '[PRE48]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that in this example, you have recreated a new product every time that
    you add the same product to a manufacturer. This is done because even though the
    product has the same properties, it belongs to a different manufacturer. In order
    for that distinction to be set, you need to pass different objects. If you do
    not do that, the products will be assigned to the same (last referenced) manufacturer.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，每次您将相同的产品添加到制造商时，都会创建一个新的产品。这样做是因为尽管产品具有相同的属性，但它属于不同的制造商。为了设置这种区别，您需要传递不同的对象。如果您不这样做，产品将被分配给相同的（最后引用的）制造商。
- en: Create a `public void SetAnyUsaProductOnDiscount(decimal discountedPrice)` method.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `public void SetAnyUsaProductOnDiscount(decimal discountedPrice)` 方法。
- en: To set any USA product on discount, first get all the products from the US region
    and then select the first of them (order doesn't matter).
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置任何美国产品的折扣，首先获取所有来自美国地区的商品，然后选择其中的第一个（顺序不重要）。
- en: 'Next set a new `Price` for that product, and call `SaveChanges()` to confirm
    it:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来为该产品设置一个新的 `Price`，并调用 `SaveChanges()` 以确认：
- en: '[PRE49]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Create a `public void RemoveAnyProductInUsa()` method.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `public void RemoveAnyProductInUsa()` 方法。
- en: 'To delete an item, simply select the first product in the `"USA"` group and
    remove it:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除一个项目，只需选择 `"USA"` 组中的第一个产品并将其删除：
- en: '[PRE50]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Observe that the `SaveChanges` has been called after every step.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到在每一步之后都调用了 `SaveChanges`。
- en: In order to get a manufacturers from USA, create a `public IEnumerable<Manufacturer>
    GetManufacturersInUsa()` method.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了获取来自美国的制造商，创建一个 `public IEnumerable<Manufacturer> GetManufacturersInUsa()`
    方法。
- en: 'Call the `ToList()` at the end of a query so that the SQL gets executed:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查询的末尾调用 `ToList()` 以执行 SQL：
- en: '[PRE51]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create a `Demo` class where you call all functions:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Demo` 类，在其中调用所有函数：
- en: '[PRE52]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In order to run this exercise, comment all lines within `static void Main(string[]
    args)` body except `Exercises.Exercise02.Demo.Run();` in `Program.cs`. The output
    of the preceding code will be as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行此练习，在 `Program.cs` 中的 `static void Main(string[] args)` 体内部除 `Exercises.Exercise02.Demo.Run();`
    之外的所有行进行注释。前面代码的输出将如下所示：
- en: '[PRE54]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This output shows exactly what you wanted to achieve. You created two manufacturers:
    `Best Buy` and `Iron Retail`. Each of them had two products, but from the first
    manufacturer, `Best Buy`, you removed one. Therefore, only a single product appears
    under it, as opposed to two products under `Iron Retail`.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示了您想要实现的确切内容。您创建了两个制造商：`Best Buy` 和 `Iron Retail`。每个制造商都有两个产品，但从第一个制造商 `Best
    Buy` 中移除了一个。因此，只有单个产品出现在其下，而 `Iron Retail` 下有产品。
- en: Note
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/uq97N](https://packt.link/uq97N).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://packt.link/uq97N](https://packt.link/uq97N) 找到用于此练习的代码。
- en: At this point, you know how to interact with an existing database. However,
    what you have done so far is manually written models to fit the `GlobalFactory`
    database you have created. Using EF, you only need one side—either a database
    or a `DbContext` schema. In the next sections, you will learn how to work with
    either approach.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经知道如何与现有数据库交互。然而，您到目前为止所做的是手动编写模型以适应您创建的 `GlobalFactory` 数据库。使用 EF，您只需要一边——要么是数据库，要么是
    `DbContext` 架构。在下一节中，您将学习如何使用这两种方法之一。
- en: Database First
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库优先
- en: In some cases, you won't have to design a database yourself. Often, an architect
    will do that for you and then a database administrator will handle further changes.
    In other cases, you may get to work with some really old projects and a legacy
    database. Both scenarios are perfect for a database first approach because you
    can generate a `DbContext` schema with all the needed models using an existing
    database.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能不需要自己设计数据库。通常，一个架构师会为您做这件事，然后数据库管理员会处理进一步的更改。在其他情况下，您可能需要与一些非常旧的项目和遗留数据库一起工作。这两种情况都适合数据库-first方法，因为您可以使用现有数据库生成包含所有所需模型的`DbContext`模式。
- en: 'The project selected must be an executable project. For example, `WebApi` and
    `ConsoleApp` are okay; however, a class library is not (you cannot run a class
    library; you can only reference it from other applications). So, install EF tools
    by running this in the console:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 选择的必须是一个可执行项目。例如，`WebApi`和`ConsoleApp`是可以的；然而，一个类库不行（您不能运行类库；您只能从其他应用程序中引用它）。因此，在控制台中运行以下命令来安装EF工具：
- en: '[PRE55]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, run the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行以下命令：
- en: '[PRE56]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This command reads the database schema (you specified to generate the database
    from all the schemas rather than just one production schema) and generates models
    out of it. You used the `AdventureWorks` database. Using the `-o` flag, you select
    the output directory, and using the `–schema` flag, you specify the schemas you
    would like to generate the database from.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令读取数据库模式（您指定从所有模式而不是仅一个生产模式生成数据库）并从中生成模型。您使用了`AdventureWorks`数据库。使用`-o`标志，您选择输出目录，使用`–schema`标志，您指定要从中生成数据库的模式。
- en: Note
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The generated models from an existing database can be found at [https://packt.link/8KIOK](https://packt.link/8KIOK).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 从现有数据库生成的模型可以在[https://packt.link/8KIOK](https://packt.link/8KIOK)找到。
- en: The models generated are quite interesting. They reveal two things that have
    not yet been talked about. When you created a `Manufacturer` class (read the *Modeling
    Databases Using EF* section), you did not initialize a collection of products
    from a constructor. This is not a big issue, but instead of not returning data,
    you get a null reference exception, which might not be what you want. None of
    the models, no matter how simple or complex they are, have attributes.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的模型非常有趣。它们揭示了两个尚未讨论过的事情。当您创建`Manufacturer`类（阅读*使用EF建模数据库*部分）时，您没有从构造函数中初始化产品集合。这不是一个大问题，但您不会返回数据，而是得到一个空引用异常，这可能不是您想要的。无论模型多么简单或复杂，都没有属性。
- en: You are almost done with the db-first approach. The next section will revisit
    `DbContext` and inspect how EF does it so you can then apply what you learned
    in a code-first approach.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 您几乎完成了db-first方法。下一节将回顾`DbContext`并检查EF是如何做的，这样您就可以将您在代码-first方法中学到的知识应用到实践中。
- en: Revisiting DbContext
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回顾DbContext
- en: 'By logically grasping the following snippet, `AdventureWorksContext`, you will
    notice that the default configuration is passed slightly differently from the
    one created in the *DbContext and DbSet* section. Instead of directly using a
    connection string for SQL Server, the generated context uses the `OnConfiguring`
    method to double-check the given context options and if they are unconfigured,
    set one. This is a cleaner approach because you don''t have to manually initialize
    the builder yourself and prevent unconfigured options:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逻辑理解以下片段`AdventureWorksContext`，您会注意到默认配置与*DbContext和DbSet*部分中创建的配置略有不同。不是直接使用SQL
    Server的连接字符串，生成的上下文使用`OnConfiguring`方法来双重检查给定的上下文选项，如果它们未配置，则设置一个。这是一个更干净的方法，因为您不必手动初始化构建器自己，并防止未配置的选项：
- en: '[PRE57]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Next, there is a method named `OnModelCreating`. It is a method that takes `ModelBuilder`
    that is used to dynamically build models for your database. `ModelBuilder` directly
    replaces the attribute-based approach because it allows you to keep the models
    attribute-free and add whatever constraints or mappings are needed when the context
    is initialized. It includes column names, constraints, keys, and indexes.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，有一个名为`OnModelCreating`的方法。这是一个接受`ModelBuilder`的方法，用于动态构建数据库模型。`ModelBuilder`直接替换了基于属性的方案，因为它允许您保持模型无属性，并在上下文初始化时添加所需的约束或映射。它包括列名、约束、键和索引。
- en: '`ModelBuilder` allows you to use Fluent API (that is, method chaining), which
    in turn allows you to add extra configurations to models. Consider the following
    single, fully configured model:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModelBuilder`允许您使用Fluent API（即方法链），这反过来又允许您向模型添加额外配置。考虑以下单个、完全配置的模型：'
- en: '[PRE58]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Looking at this part of `ModelBuilder` will give you a full picture of how
    the model maps to a table and its columns, keys, indexes, and relations. The generated
    code is broken down for you. To begin configuring an entity, you need to call
    the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 查看此部分的`ModelBuilder`将向您展示模型如何映射到表及其列、键、索引和关系。生成的代码已为您分解。要开始配置实体，您需要调用以下代码：
- en: '[PRE59]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Mapping to the table and schema looks like this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 映射到表和模式如下所示：
- en: '[PRE60]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You can also add constraints (for example, to make sure that a field is not
    null) and set the character limit and name of a column the property maps to. In
    the following code, you''re doing so for `Name`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以添加约束（例如，确保字段不为空）并设置映射到列的字符限制和名称。在以下代码中，您正在对`Name`执行此操作：
- en: '[PRE61]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Lastly, some entities have multiple navigational properties associated with
    them. When multiple navigational properties are involved, EF may not be able to
    clearly interpret what the relationship should be. In those cases, you will need
    to configure it manually, as shown in the following code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些实体与多个导航属性相关联。当涉及多个导航属性时，EF可能无法清楚地解释应该是什么关系。在这些情况下，您需要手动配置，如下面的代码所示：
- en: '[PRE62]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The preceding code maps the `Manufacturer` entity to `Product` with a 1:n relationship
    and sets the foreign key column to `product_manufacturerid_id`. Spotting those
    cases might be tricky; therefore, you should only add manual configurations when
    an error informs you about such an ambiguity:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将`Manufacturer`实体映射到`Product`，并设置外键列名为`product_manufacturerid_id`。发现这些情况可能很棘手；因此，只有在错误通知您存在这种歧义时，才应添加手动配置：
- en: '[PRE63]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is no runnable code here; this is just a scaffold of a database.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有可运行的代码；这只是一个数据库的框架。
- en: Now you know what a generated `DbContext` looks like and how to customize models
    yourself. Without touching model classes, and instead using `ModelBuidler`, it
    is time to get familiar with doing the opposite, which is generating a database
    out of the context.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道了生成的`DbContext`的样子以及如何自己自定义模型。在不接触模型类的情况下，而是使用`ModelBuidler`，现在是时候熟悉如何从上下文中生成数据库了。
- en: Generating DbContext from an Existing Database
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从现有数据库生成DbContext
- en: For subsequent examples, you will be using the `GlobalFactory2021` database.
    Just to be sure that what you have made is the same as what the database contains,
    you'll perform database scaffolding one more time. Scaffolding is an operation
    that takes a database schema (or `DbContext`, in this case) and generates a physical
    database out of it.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后续示例，您将使用`GlobalFactory2021`数据库。为了确保您所做的是与数据库内容相同的，您将再次执行数据库框架操作。框架操作是一个操作，它从数据库模式（或`DbContext`）生成物理数据库。
- en: 'Open the console and run the following:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 打开控制台并运行以下命令：
- en: '[PRE64]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'For security, do not forget to replace the hardcoded connection string in `DbContext`
    with the one from the environment variable. The resulting `DbContext` should look
    like this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，不要忘记将`DbContext`中的硬编码连接字符串替换为环境变量中的连接字符串。生成的`DbContext`应如下所示：
- en: '![Figure 6.3: DbContext generated after applying the scaffold command ](img/B16835_06_03.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3：应用框架命令后生成的DbContext](img/B16835_06_03.jpg)'
- en: 'Figure 6.3: DbContext generated after applying the scaffold command'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：应用框架命令后生成的DbContext
- en: One of the main advantages of EF is that you can quickly define entities and
    then create a database out of them. But first, you'll need to learn the code first
    approach.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: EF的主要优势之一是您可以快速定义实体，然后从它们创建数据库。但首先，您需要先学习代码优先的方法。
- en: Code First and Migrations
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码优先和迁移
- en: Usually, when you need to create a proof of concept, you will create a `DbContext`
    schema with the models and then generate a database out of that. Such an approach
    is called code first.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当您需要创建一个概念验证时，您将创建一个包含模型和数据库的`DbContext`模式，然后从该模式生成数据库。这种方法称为代码优先。
- en: 'In this example, you will use the context you have generated from the `GlobalFactory2021`
    database and then generate a new database out of it. This approach requires an
    extra package named `Design`, so make sure it is installed by running the following
    command:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将使用从 `GlobalFactory2021` 数据库生成的上下文，然后基于它生成一个新的数据库。这种方法需要一个名为 `Design`
    的额外包，所以请确保通过运行以下命令安装它：
- en: '[PRE65]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'EF is able to generate a database and have different versioning for it. In
    fact, it can move from one database version to another. A single database version
    at any given time is called migration. Migrations are needed to ensure that you
    do not just always recreate databases (after all, you don''t want to lose the
    existing data), but instead, apply them neatly in a secure and trusted way. To
    add the first migration, from the VS Code terminal, run the following:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: EF 能够生成数据库，并且可以为它提供不同的版本控制。实际上，它可以从一个数据库版本迁移到另一个版本。在任何给定时间的一个单独的数据库版本被称为迁移。迁移是必要的，以确保你不仅仅总是重新创建数据库（毕竟，你不想丢失现有数据），而是以整洁、安全和可信的方式应用它们。要添加第一个迁移，从
    VS Code 终端运行以下命令：
- en: '[PRE66]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This will generate a migration file:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个迁移文件：
- en: '![Figure 6.4: New migration with defaults placed under the project Migrations
    folder  in the project root ](img/B16835_06_04.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4：新迁移默认放置在项目根目录下的 Migrations 文件夹中](img/B16835_06_04.jpg)'
- en: 'Figure 6.4: New migration with defaults placed under the project Migrations
    folder in the project root'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：新迁移默认放置在项目根目录下的 Migrations 文件夹中
- en: The migration provides EF with information about the next database schema version
    and can therefore be used to generate a database from (or apply new changes to
    an existing database). Note that since you have multiple `DbContext` schemas and
    EF cannot tell you which context to use, you have to provide one explicitly. It
    is also worth mentioning that running this command requires selecting a default
    project, which includes the required context. and placing the migrations in that
    project's directory.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移为 EF 提供有关下一个数据库架构版本的信息，因此可以用来从（或应用新更改到现有数据库）。请注意，由于你有多个 `DbContext` 架构，EF
    无法告诉你使用哪个上下文，你必须明确提供。还值得一提的是，运行此命令需要选择默认项目，该项目包括所需的上下文，并将迁移放置在该项目的目录中。
- en: 'Why can''t you just generate a database right away? When working with data,
    capturing a change at any given time and being able to go back to a previous version
    is very important. Even though directly generating a database might sound easy,
    it is not a viable approach because changes happen all the time. You want to be
    in control and have a choice to switch between versions at will. The migrations
    approach also works with code versioning systems, such as Git, because you can
    see the changes made to your database through a migration file. You will learn
    more about version control in *Chapter 11*, *Production-Ready C#: from Development
    to Deployment*.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不能立即生成数据库呢？当处理数据时，捕捉任何给定时间的变更并能够回到之前的版本非常重要。尽管直接生成数据库听起来很简单，但这不是一个可行的方案，因为变更一直在发生。你希望保持控制，并能够随意在版本之间切换。迁移方法也与代码版本控制系统（如
    Git）兼容，因为你可以通过迁移文件查看对数据库所做的更改。你将在 *第 11 章*，*生产就绪的 C#：从开发到部署* 中了解更多关于版本控制的内容。
- en: 'Before creating a database, make sure you change the database name inside the
    connection string so that a new database can be created and not overwritten. Creating
    a new database from a migration you have can be done by running this command:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建数据库之前，请确保更改连接字符串中的数据库名称，以便可以创建新的数据库而不会覆盖现有数据库。可以从迁移运行以下命令来创建新的数据库：
- en: '[PRE67]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If you open `pgAdmin`, you will see a very familiar view with the `manufacturer`
    and `product`. However, there is one new table for the migration history:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开 `pgAdmin`，你会看到一个非常熟悉的视图，包括 `manufacturer` 和 `product`。然而，有一个新的表格用于迁移历史：
- en: '![Figure 6.5: Generated database inside pgAdmin browser (simplified view for
    brevity) ](img/B16835_06_05.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5：pgAdmin 浏览器内生成的数据库（为了简洁，此处为简化视图）](img/B16835_06_05.jpg)'
- en: 'Figure 6.5: Generated database inside pgAdmin browser (simplified view for
    brevity)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5：pgAdmin 浏览器内生成的数据库（为了简洁，此处为简化视图）
- en: 'The `__EFMigrationsHistory` table lays out all the migrations performed, when
    they were performed, and the EF version with which they were executed. In the
    following screenshot, you can see the first migration created as `MyfirstMigration`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`__EFMigrationsHistory` 表列出了所有已执行的迁移，执行时间以及执行迁移时使用的 EF 版本。在下面的屏幕截图中，你可以看到创建的第一个迁移名为
    `MyfirstMigration`：'
- en: '![Figure 6.6: EFMigrationsHistory table rows ](img/B16835_06_06.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6：EFMigrationsHistory 表的行](img/B16835_06_06.jpg)'
- en: 'Figure 6.6: EFMigrationsHistory table rows'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：EFMigrationsHistory 表的行
- en: You might find it strange that a migrations table has only two columns. However,
    those two columns have all the needed information, such as when, what, and how.
    Under `MigrationId`, the digits before `_` refer to the date and time the migration
    was run. This is followed by the migration name. The `ProductVersion` refers to
    the EF Core version with which the command was executed.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会觉得迁移表只有两列很奇怪。然而，这两列包含了所有需要的信息，例如何时、何事以及如何。在 `MigrationId` 下，下划线前的数字指的是迁移运行的时间和日期。这后面跟着迁移名称。`ProductVersion`
    指的是执行命令时使用的 EF Core 版本。
- en: What if you wanted to make changes in your data models? What if you would like
    the `manufacturer` table to also have a date for the foundation? You would need
    to go through the same flow—add a migration and update the database.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在您的数据模型中进行更改怎么办？如果您希望 `manufacturer` 表也有一个成立日期怎么办？您将需要通过相同的流程——添加迁移并更新数据库。
- en: 'So first, you would add a new property inside a `Manufacturer` class:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，您会在 `Manufacturer` 类内部添加一个新属性：
- en: '[PRE68]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here `FoundedAt` is a date. It does not need time associated with it, so you
    should specify an appropriate SQL Server type that maps to it. You would do this
    in `GlobalFactory2021Context` inside the `OnModelCreating` method:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`FoundedAt` 是一个日期。它不需要与它相关联的时间，因此您应该指定一个适当的 SQL Server 类型，该类型映射到它。您将在 `GlobalFactory2021Context`
    中的 `OnModelCreating` 方法中这样做：
- en: '[PRE69]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now you can add that to a new migration:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以将它添加到一个新的迁移中：
- en: '[PRE70]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Apply the new migration to the database:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 将新迁移应用到数据库中：
- en: '[PRE71]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This will add a new entry to the migration history:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在迁移历史中添加一个新条目：
- en: '![Figure 6.7: Migration 2 as the new migration created in the migrations table
    ](img/B16835_06_07.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7：作为在迁移表中创建的新迁移的迁移 2](img/B16835_06_07.jpg)'
- en: 'Figure 6.7: Migration 2 as the new migration created in the migrations table'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7：作为在迁移表中创建的新迁移的迁移 2
- en: 'You should see the new column in the `manufacturer` table as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到 `manufacturer` 表中的新列如下：
- en: '![Figure 6.8: The manufacturer table with the new column named as foundedat
    ](img/B16835_06_08.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8：名为 foundedat 的新列的制造商表](img/B16835_06_08.jpg)'
- en: 'Figure 6.8: The manufacturer table with the new column named as foundedat'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8：名为 foundedat 的新列的制造商表
- en: 'Now you know how to apply your models, change them, and generate a database
    out of the models. So far, you have made the following changes:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道了如何应用您的模型，更改它们，并从模型生成数据库。到目前为止，您已经做出了以下更改：
- en: Added the `FoundedAt` property and model builder changes.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了 `FoundedAt` 属性和模型构建器更改。
- en: Created a migration file.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了迁移文件。
- en: Updated a database with that migration file.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用该迁移文件更新了数据库。
- en: 'Undoing those changes will involve doing the opposite, in this sequence:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 取消这些更改将涉及以下顺序的相反操作：
- en: Rolling back database changes (updating the database to the last successful migration).
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回滚数据库更改（将数据库更新到最后一次成功的迁移）。
- en: Removing the migration file.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除迁移文件。
- en: Removing model builder changes.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除模型构建器更改。
- en: 'EF migrations allow you to selectively apply any migration you want. Here,
    you will be applying the previous migration:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: EF 迁移允许您选择性地应用任何您想要的迁移。在这里，您将应用之前的迁移：
- en: '[PRE72]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You will delete the migration file using the following command:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用以下命令删除迁移文件：
- en: '[PRE73]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'When working with big and complex databases, especially when they are already
    in production, performing migration using EF tools may become too complex. After
    all, you do not have full control of the exact script EF will generate for a migration.
    If you ever need a custom migration script, EF will no longer fit your bill. However,
    you can always convert whatever EF would do into SQL. You can do this by running
    the following command:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理大型且复杂的数据库时，尤其是在它们已经处于生产状态时，使用 EF 工具进行迁移可能会变得过于复杂。毕竟，您无法完全控制 EF 为迁移生成的确切脚本。如果您需要自定义迁移脚本，EF
    将不再适合您的需求。然而，您始终可以将 EF 要执行的操作转换为 SQL。您可以通过运行以下命令来完成此操作：
- en: '[PRE74]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This command produces, instead of a C# migration class, a SQL script. Executing
    a SQL script (often modified) is the preferred way of performing migrations in
    a production environment.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令生成的是 SQL 脚本，而不是 C# 迁移类。在生产环境中，执行 SQL 脚本（通常是经过修改的）是执行迁移的首选方式。
- en: Those are just some basic yet common scenarios that you will be dealing with
    when working with databases. Change almost always happens; therefore, you should
    expect it and be prepared, as you will see in the following exercise.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是你在与数据库工作时可能会遇到的一些基本但常见的场景。变化几乎总是发生的；因此，你应该预料到它并做好准备，就像你将在以下练习中看到的那样。
- en: 'Exercise 6.03: Managing Product Price Changes'
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.03：管理产品价格变动
- en: Once again, your manager is impressed with your results. This time, they have
    asked you to keep track of product price changes. They would like a new table,
    `ProductPriceHistory`, that holds a record of the changes in the price of a product.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你的经理对你的结果印象深刻。这次，他们要求你跟踪产品价格变动。他们希望有一个新的表，`产品价格历史`，记录产品价格的变化。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个练习：
- en: 'To track price changes, add a new model, `ProductPriceHistory` with the following
    fields:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了跟踪价格变动，添加一个新的模型`产品价格历史`，包含以下字段：
- en: '`Id`'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ID`'
- en: '`Price`'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`价格`'
- en: '`DateOfPrrice`'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`价格日期`'
- en: '`ProductId`'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`产品ID`'
- en: '`Product`'
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`产品`'
- en: 'The code for the new model will be as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 新模型代码如下：
- en: '[PRE75]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, update the `Product` model so that it includes the historical price changes.
    So, add a new collection property, `ProductPriceHistory`:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新`产品`模型，使其包括历史价格变动。因此，添加一个新的集合属性`产品价格历史`：
- en: '[PRE76]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Change the `Price` column. `Price` should now be a method that gets the latest
    price of a product and the full model now looks like this:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`价格`列。`价格`现在应该是一个获取产品最新价格的方法，完整的模型现在看起来如下：
- en: '[PRE77]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Update `DbContext` to include a new `DbSet` and add the `ProductPriceHistory`
    configuration to the `OnModelCreating` method, as follows:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`DbContext`以包含一个新的`DbSet`，并将`产品价格历史`配置添加到`OnModelCreating`方法中，如下所示：
- en: '[PRE78]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The preceding code provides mappings to a table and column property types. A
    `Product` has many historical price changes, therefore it forms a 1:n relation
    with a `PriceHistory`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码提供了到表和列属性类型的映射。一个`产品`有许多历史价格变动，因此它与`价格历史`形成一个1:n的关系。
- en: 'Just after the preceding code, create a 1:n relation between `Product` and `PriceHistory`:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上述代码之后，在`产品`和`价格历史`之间创建一个1:n的关系：
- en: '[PRE79]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'For the database change to be captured (so that you can apply the change from
    code to database or roll back), add the `migration` as follows:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了捕获数据库更改（以便你可以将更改从代码应用到数据库或回滚），添加以下`迁移`：
- en: '[PRE80]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The following will be generated:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成以下内容：
- en: '![Figure 6.9: The generated database migrations and extra files ](img/B16835_06_09.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9：生成的数据库迁移和额外文件](img/B16835_06_09.jpg)'
- en: 'Figure 6.9: The generated database migrations and extra files'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：生成的数据库迁移和额外文件
- en: 'In order to apply the migration, run the following command:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了应用迁移，运行以下命令：
- en: '[PRE81]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Create a `Demo` by adding some dummy data:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加一些虚拟数据创建一个`演示`：
- en: '[PRE82]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Here, you first created a `manufacturer` and its `product` and then added a
    few price changes. Once the changes were saved, you disconnected from the database
    (so that you don't work with cached entities). In order to test whether it works,
    you queried all `"Fake Toys"` manufacturer with their products and their price
    history.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你首先创建了一个`制造商`及其`产品`，然后添加了一些价格变动。一旦变动被保存，你就从数据库断开连接（这样你就不与缓存的实体一起工作）。为了测试它是否工作，你查询了所有`假玩具`制造商及其产品及其价格历史。
- en: Note
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When working with dates, especially in the context of databases or environments
    that may be shared beyond your local, prefer to use dates without your locale
    by calling `DateTime.UtcNow`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理日期时，特别是在数据库或可能超出你本地环境的共享环境中，最好使用不带你本地化的日期，通过调用`DateTime.UtcNow`。
- en: 'In order to run this exercise, comment all lines within `static void Main(string[]
    args)` body except `Exercises.Exercise03.Demo.Run();` in `Program.cs`. You will
    see the following output:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了运行这个练习，在`Program.cs`中的`static void Main(string[] args)`方法体内注释掉所有行，除了`Exercises.Exercise03.Demo.Run();`。你将看到以下输出：
- en: '[PRE84]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In the `Demo`, you created a `manufacturer` with one product which is a toy
    (`Rubber Sweater`). The toy has two prices: `15.11` and `15.50` (the latest).
    You then saved that toy in the database, disconnected, and reconnected from that
    database (making sure that the toy is not cached, but rather fetched), and executed
    an eager loading-based join.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在`演示`中，你创建了一个包含一个产品（玩具`橡胶毛衣`）的`制造商`。这个玩具有两个价格：`15.11`和`15.50`（最新的）。然后你将这个玩具保存到数据库中，断开连接，并重新连接到该数据库（确保玩具没有被缓存，而是被检索），并执行了一个基于懒加载的连接。
- en: Note
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for his exercise at [https://packt.link/viVZW](https://packt.link/viVZW).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/viVZW](https://packt.link/viVZW)找到他练习所用的代码。
- en: EF is effective for rapid database development, but for that same reason, it
    is also very dangerous. Inexperienced developers often rely on the magic that
    happens behind the scenes and therefore forget that EF cannot magically optimize
    data models to fit your specific scenario or guess that the intended query should
    perform better. The following sections will review the main mistakes that people
    make while working with EF.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: EF（Entity Framework）对于快速数据库开发非常有效，但正因为如此，它也非常危险。缺乏经验的开发者往往依赖于幕后发生的魔法，因此忘记了EF不能神奇地优化数据模型以适应您的特定场景，或者猜测预期的查询应该表现得更好。以下部分将回顾人们在使用EF时犯的主要错误。
- en: Pitfalls of EF
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EF的陷阱
- en: EF abstracts a lot of details from you, significantly simplifying your work.
    However, it also introduces the risk of not being aware of what is actually happening.
    Sometimes, you might achieve what you want, but there may be a chance that you
    are not optimally achieving your goal. The following are some of the most common
    mistakes made in EF.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: EF从你那里抽象了很多细节，显著简化了你的工作。然而，它也引入了不了解实际发生情况的风险。有时，你可能会达到你想要的结果，但可能存在你并没有最优地实现目标的机会。以下是在EF中犯的一些最常见的错误。
- en: Examples Setup
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例设置
- en: 'For all the following examples, assume that you will have this line initialized
    at the start:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下所有示例，假设你将在开始时初始化以下行：
- en: '[PRE85]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Assume, too, that every example will finish with this:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，每个示例都将以以下内容结束：
- en: '[PRE86]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Also, the data itself will be seeded (pre-generated) using the following code:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数据本身将使用以下代码进行（预先生成）：
- en: '[PRE87]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The preceding code creates a `manufacturer` with `10,000` products, but only
    if that `manufacturer` does not already exist. The `ManufacturerName` will be
    exactly 13 characters long, and their prices will be random, but no bigger than
    the maximum price. All of this information is saved to a database before you disconnect
    from it.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码创建了一个`manufacturer`，它有`10,000`个产品，但前提是那个`manufacturer`之前不存在。`ManufacturerName`的长度将正好是13个字符，它们的价格将是随机的，但不会超过最大价格。所有这些信息在您断开连接之前都将保存到数据库中。
- en: Note
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This is no runnable code and will be used in all the performance comparison examples.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是可运行的代码，它将被用于所有性能比较示例。
- en: 'All the examples will compare two functions achieving the same output. A summary
    of all the comparisons is done by executing this demo code:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 所有示例都将比较两个产生相同输出的函数。所有比较的摘要通过执行此演示代码来完成：
- en: '[PRE88]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Here, you compare in-memory and SQL filtering, lazy and eager loading, tracked
    and untracked entities, and adding entities one by one as opposed to adding them
    in bulk. In the paragraphs that follow, you will find the functions being compared,
    but every comparison will show the following:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将比较内存和SQL过滤、懒加载和急加载、跟踪和非跟踪实体，以及逐个添加实体而不是批量添加。在接下来的段落中，你将找到被比较的函数，但每个比较都将显示以下内容：
- en: Names of a scenario
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景名称
- en: Slow and fast versions for doing the same thing
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 做同样事情的速度快和慢版本
- en: You will be using a stopwatch to measure execution time and print a formatted
    comparison after each run. In order to run this example, comment all lines within
    `static void Main(string[] args)` body except `Examples.PerformanceTraps.Demo.Run();`
    in `Program.cs`. You can refer to the *Summary of Results* section for the output.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用秒表来测量执行时间，并在每次运行后打印格式化的比较。为了运行此示例，请在`Program.cs`中的`static void Main(string[]
    args)`主体内注释掉所有行，除了`Examples.PerformanceTraps.Demo.Run();`。你可以参考*结果摘要*部分以获取输出。
- en: The idea behind these examples is to compare an efficient way of working with
    EF with a direct equivalent inefficient way. The slow scenario is the inefficient
    way and the fast (which is the efficient one) is the way it should be done. The
    next section will detail the efficient way of using EF.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例背后的想法是将EF的有效工作方式与直接等效的低效方式进行比较。慢速场景是低效的方式，而快速（即有效的方式）是应该这样做的方式。下一节将详细说明使用EF的有效方式。
- en: Multiple Adds
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多次添加
- en: 'Sometimes, without realizing it at the time, you''ll find that you tend to
    use the most straightforward route while writing programs. For example, to add
    100 items, you may use 100 individual addition operations. However, this isn''t
    always the optimal approach and is especially inefficient when you''re using EF.
    Instead of one query for a bulk of 100, you might run a single insert 100 times.
    As an example, see the following code:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能没有意识到，在编写程序时，你倾向于使用最直接的方法。例如，要添加 100 个项目，你可能使用 100 个单独的添加操作。然而，这并不总是最佳方法，尤其是在使用
    EF 时。你可能会选择一次性插入 100 次，而不是对一个包含 100 个项目的批量进行单个查询。以下是一个示例代码：
- en: '[PRE89]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This code creates `1,000` products and attaches them to `DbContext`. What happens
    is that those `1,000` entities inside a `DbContext` schema are tracked. Instead
    of tracking them all as a single batch, you track each individually.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建 `1,000` 个产品并将它们附加到 `DbContext`。发生的情况是，`DbContext` 模式中的 `1,000` 个实体被跟踪。你想要的不是将它们作为一个单独的批次跟踪，而是逐个跟踪。
- en: 'What you want to do, though, is to work with range operations:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要做的是进行范围操作：
- en: '`AddRange` or'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddRange` 或'
- en: '`UpdateRange`, or'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateRange`，或者'
- en: '`RemoveRange`'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveRange`'
- en: 'A better version of the preceding code, designed to work in an optimal way
    with batches, looks like this:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的一个更好的版本，旨在以最佳方式与批量操作一起工作，如下所示：
- en: '[PRE90]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: When creating multiple items with the intention to add them to the database,
    you should first add them to a list. After your list is complete, you can add
    the items as a batch to `DbSet<Product>`. You still have the problem of multiple
    adds, but the benefit of it over directly calling a `DbSet<Product>` add is that
    you no longer hit the change tracker with every add. In order to run this example,
    comment all lines within `static void` `Main(string[] args)` body except `Examples.PerformanceTraps.Demo.Run();`
    in `Program.cs`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建多个项目并打算将它们添加到数据库时，你应该首先将它们添加到一个列表中。当你的列表完成后，你可以将项目作为批量添加到 `DbSet<Product>`
    中。你仍然会遇到多次添加的问题，但与直接调用 `DbSet<Product>` 添加相比，它的好处是，你不再需要在每次添加时都触发更改跟踪器。为了运行此示例，请在
    `Program.cs` 中的 `static void Main(string[] args)` 方法体中注释掉所有 `Examples.PerformanceTraps.Demo.Run();`
    之外的行。
- en: Note
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/wPLyB](https://packt.link/wPLyB).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/wPLyB](https://packt.link/wPLyB) 找到用于此示例的代码。
- en: The next section will take a look at another pitfall—how to query properly based
    on equality of properties.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将探讨另一个陷阱——如何根据属性的相等性正确查询。
- en: Equals over ==
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用等于（Equals）而不是相等运算符（==）
- en: 'The devil lies in the details. C# developers usually do not make this mistake,
    but if you are moving between languages (especially from Java), you might be doing
    this when filtering:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 魔鬼在于细节。C# 开发者通常不会犯这个错误，但如果你在语言之间转换（尤其是从 Java 转换过来），你可能在过滤时这样做：
- en: '[PRE91]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'For LINQ, it is harmless. However, while using EF, this approach is not recommended.
    The problem is that EF can convert only some expressions to SQL. Usually, a complex
    method, such as equals, cannot be converted because it comes from a base object
    class, which can have multiple implementations. Instead, use a simple equality operator:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 LINQ 来说，这是无害的。然而，在使用 EF 时，这种方法并不推荐。问题是 EF 只能将一些表达式转换为 SQL。通常，一个复杂的方法，如等于，无法转换，因为它来自基对象类，该类可以有多个实现。相反，使用简单的相等运算符：
- en: '[PRE92]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The problem with the first attempt was that it would first get all products
    (that is, execute a `get` statement in SQL) and only then the filter would be
    applied (in memory, in C#). Once again, this is problematic because getting with
    a filter applied in a database-native language is optimal but getting products
    in SQL and then filtering in C# is suboptimal. The problem is solved in the second
    attempt by replacing `Equals` with the equality operator, `==`. In order to run
    this example, comment all lines within `static void Main(string[] args)` body
    except `Examples.PerformanceTraps.Demo.Run();` in `Program.cs`.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次尝试的问题在于，它会首先获取所有产品（即执行 SQL 中的 `get` 语句），然后才会应用过滤条件（在内存中，在 C# 中）。再次强调，这是有问题的，因为使用数据库原生语言应用过滤条件获取数据是最佳的，但在
    SQL 中获取产品然后在 C# 中过滤是不太理想的。在第二次尝试中，通过将 `Equals` 替换为相等运算符 `==` 来解决这个问题。为了运行此示例，请在
    `Program.cs` 中的 `static void Main(string[] args)` 方法体中注释掉所有 `Examples.PerformanceTraps.Demo.Run();`
    之外的行。
- en: Note
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/js2es](https://packt.link/js2es).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/js2es](https://packt.link/js2es) 找到用于此示例的代码。
- en: Using IEnumerable over IQueryable
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 IEnumerable 而不是 IQueryable
- en: 'Another example involves misunderstanding the concept of `IEnumerable<Product>`:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子涉及对 `IEnumerable<Product>` 概念的误解：
- en: '[PRE93]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Here, you are getting products by a specific product name. But what happens
    when you assign a `DbSet<Product>` object to `Ienumerable<Product>` is that the
    `SELECT *` statement is executed. Therefore, instead of getting only the filtered
    products that you need, you will first get everything and then manually filter
    it.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你通过特定的产品名称获取产品。但是，当你将`DbSet<Product>`对象分配给`Ienumerable<Product>`时会发生什么，那就是执行`SELECT
    *`语句。因此，你不会只获取你需要的筛选后的产品，而是首先获取所有产品，然后手动筛选。
- en: 'You might wonder why you couldn''t filter right away. In some cases, it makes
    sense to build queries and pass them across methods. But when doing so, you should
    not execute them until they are completely built. Therefore, instead of `Ienumerable<Product>`,
    you should use `Iqueryable<Product>`, which is an abstraction of queried entities—an
    expression that will be converted to SQL after calling `ToList<Product>` or similar.
    An efficient version of the preceding code would look like this:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么不能立即进行筛选。在某些情况下，构建查询并在方法间传递是有意义的。但是，在这样做的时候，你应该在它们完全构建之前不要执行它们。因此，你应该使用`Iqueryable<Product>`而不是`Ienumerable<Product>`，它是查询实体的抽象——一个在调用`ToList<Product>`或类似方法后将被转换为SQL的表达式。前面代码的高效版本看起来如下：
- en: '[PRE94]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The latter works faster because you apply a filter in SQL and not in memory.
    In order to run this example, comment all lines within `static void Main(string[]
    args)` body except `Examples.PerformanceTraps.Demo.Run();` in `Program.cs`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 后者运行更快，因为你在SQL中而不是在内存中应用筛选。为了运行此示例，请在`Program.cs`中注释掉`static void Main(string[]
    args)`体内的所有行，除了`Examples.PerformanceTraps.Demo.Run();`。
- en: Note
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/ehq6C](https://packt.link/ehq6C).
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/ehq6C](https://packt.link/ehq6C)找到用于此示例的代码。
- en: Eager and lazy loading has already been mentioned, but there is still another
    complexity that is significant enough and should be covered. The next section
    details them.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 急加载和懒加载已经提到，但还有一个重要的复杂性，应该被涵盖。下一节将详细说明。
- en: Lazy over Eager Loading
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒加载与急加载
- en: In EF, you have an interesting n+1 queries problem. For example, if you get
    a list of items, then getting the list of their respective manufacturers afterward
    would result in a SQL query being executed; this would be lazy-loaded. Fortunately,
    from EF 2.1, this no longer happens by default, and it needs to be enabled explicitly.
    Assume that in the following examples, you have already enabled it.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在EF中，你有一个有趣的n+1查询问题。例如，如果你获取一个项目列表，然后随后获取它们各自制造商的列表会导致执行一个SQL查询；这将导致延迟加载。幸运的是，从EF
    2.1开始，这不再是默认行为，并且需要显式启用。假设在以下示例中，你已经启用了它。
- en: 'Here is a query to get any first item and its manufacturer:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个获取任何第一项及其制造商的查询：
- en: '[PRE95]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Initially, upon looking at this code, you might think that there is no issue,
    but this small chunk of code executes two SQL queries:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，查看此代码时，你可能认为没有问题，但这段小代码执行了两个SQL查询：
- en: First, it selects the top product.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它选择最上面的产品。
- en: Then it selects the associated manufacturer, along with the manufacturer ID.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后它选择关联的制造商，以及制造商ID。
- en: 'To make the code more efficient, you need to explicitly specify that you do
    want the `Manufacturer` to be included with a product. A better, more efficient
    version of the code is as follows:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码更高效，你需要明确指定你确实想要将`Manufacturer`包含在产品中。代码的更好、更高效的版本如下：
- en: '[PRE96]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The latter translates to a single query where a join between two tables is made
    and the first item from one of them is returned. In order to run this example,
    comment all lines within `static void Main(string[] args)` body except `Examples.PerformanceTraps.Demo.Run();`
    in `Program.cs`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 后者转换为一个查询，其中两个表之间进行连接，并返回其中一个表的第一项。为了运行此示例，请在`Program.cs`中注释掉`static void Main(string[]
    args)`体内的所有行，除了`Examples.PerformanceTraps.Demo.Run();`。
- en: Note
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/osrEM](https://packt.link/osrEM).
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/osrEM](https://packt.link/osrEM)找到用于此示例的代码。
- en: Read-Only Queries
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只读查询
- en: 'EF assumes many things when running your queries. In most cases, it gets it
    right, but there are many cases when you should be explicit and order it not to
    assume. For example, you could get all the products like this:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: EF在运行你的查询时假设了很多事情。在大多数情况下，它做得很好，但有许多情况下你应该明确指出，并指示它不要假设。例如，你可以这样获取所有产品：
- en: '[PRE97]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'By default, EF will track all retrieved and changed entities. This is useful
    in some cases, but not always. When you have read-only queries, to just get and
    not modify entities, you would explicitly tell EF to not track any of them. An
    optimal way of getting products is as follows:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，EF将跟踪所有检索和更改的实体。在某些情况下这很有用，但并不总是如此。当你有只读查询，只是获取而不修改实体时，你会明确告诉EF不要跟踪任何实体。获取产品的最佳方式如下：
- en: '[PRE98]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: All this code does is run a query against the database and map the results.
    EF keeps the context clean. In order to run this example, comment all lines within
    `static void Main(string[] args)` body except `Examples.PerformanceTraps.Demo.Run();`
    in `Program.cs`.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些代码所做的只是对数据库运行查询并将结果映射。EF保持上下文清洁。为了运行此示例，请在`Program.cs`中的`static void Main(string[]
    args)`方法体内注释掉除`Examples.PerformanceTraps.Demo.Run();`之外的所有行。
- en: Note
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/rSW1k](https://packt.link/rSW1k).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/rSW1k](https://packt.link/rSW1k)找到用于此示例的代码。
- en: Summary of Results
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果摘要
- en: 'The following snippet shows all results from the previous sections, in a tabulated form:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了前几节的所有结果，以表格形式呈现：
- en: '[PRE99]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Note that the output depends on the machine you are running the database, the
    data, and more. The point of this comparison is not to give you hard rules of
    what should be chosen, but rather to show how different approaches might save
    a lot of computing time.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输出取决于你运行数据库的机器、数据等。这个比较的目的不是给你提供应该选择什么的具体规则，而是展示不同的方法可能如何节省大量的计算时间。
- en: EF is a powerful tool that allows rapid work with databases; however, you should
    be careful with how you use it. Do not worry, even if you think you are not sure
    how the queries work internally, there is still a way to see what happens underneath.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: EF是一个强大的工具，它允许你快速与数据库工作；然而，你应该小心地使用它。不用担心，即使你认为你对查询的内部工作方式不确定，仍然有方法可以看到下面发生了什么。
- en: Tools to Help You Spot Problems Early On
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帮助你早期发现问题的工具
- en: 'EF is a toolbox in itself; it allows you to easily hook into it and track what
    is happening without any external tools. You can enable logging all the EF actions
    by adding this to the `OnConfiguring` method:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: EF本身就是一个工具箱；它允许你轻松地将其钩入并跟踪所发生的事情，而无需任何外部工具。你可以通过将以下内容添加到`OnConfiguring`方法来启用记录所有EF操作：
- en: '[PRE100]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'If you run any of the example''s code, this will log the trace inside an `output`
    window, as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行示例代码，这将记录在`output`窗口内的跟踪信息，如下所示：
- en: '![Figure 6.10: Debugging output after running the performance pitfalls demo
    ](img/B16835_06_10.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
  zh: '![图6.10：运行性能陷阱演示后的调试输出](img/B16835_06_10.jpg)'
- en: 'Figure 6.10: Debugging output after running the performance pitfalls demo'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：运行性能陷阱演示后的调试输出
- en: The image shows what SQL is generated when EF executes the code—specifically
    selecting all products.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 该图像显示了EF执行代码时生成的SQL——特别是选择所有产品。
- en: This approach is useful when you want to both fully debug your application and
    know every step EF makes. It is efficient for spotting queries that you expect
    to execute as SQL but execute in memory.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想完全调试你的应用程序并了解EF的每一步时，这种方法很有用。它对于发现你预期以SQL执行但实际上在内存中执行的查询非常有效。
- en: In the next section, you will learn about patterns that will help you organize
    database communication code.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解有助于组织数据库通信代码的模式。
- en: Working with a Database in Enterprise
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在企业中与数据库一起工作
- en: When talking about databases, you usually imagine SQL or another language to
    talk with them. On top of that, another language (C#, in this case) is most often
    used to connect to a database to execute SQL queries. If not controlled, C# gets
    mixed with SQL, and it causes a mess of your code. Over the years, there have
    been a few patterns refined to implement the communication with a database in
    a clean way. Two such patterns, namely, Repository and CQRS, are commonly used
    to this day.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到数据库时，你通常会想象使用SQL或其他语言与之通信。在此基础上，另一种语言（在这个例子中是C#）通常被用来连接数据库并执行SQL查询。如果不加控制，C#会与SQL混合，这会导致你的代码变得混乱。多年来，已经有一些模式被精炼出来，以干净的方式实现与数据库的通信。其中两种模式，即仓储和CQRS，至今仍被广泛使用。
- en: Repository Pattern
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仓储模式
- en: 'The Repository is a pattern that targets a model and defines all (if needed)
    possible CRUD operations. For example, if you take a `Product` model, you could
    have a repository with this interface:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 仓储是一个针对模型的目标模式，并定义了所有（如果需要）可能的CRUD操作。例如，如果你有一个`Product`模型，你可以有一个具有以下接口的仓储：
- en: '[PRE101]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This is a classical repository pattern where every database operation is abstracted
    away. This allows you to do pretty much anything you want in a database without
    worrying about the underlying database or even the technology you use to communicate
    with the database.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个经典的存储库模式，其中每个数据库操作都被抽象化。这允许你在数据库中做几乎所有你想做的事情，而不用担心底层数据库或你用来与数据库通信的技术。
- en: Note that a `Create` method in this case returns an integer. Usually, when writing
    code, you would segregate methods that change a state from those that query something.
    In other words, do not try to both get something and change something. However,
    in this case, it is difficult to achieve because the ID of an entity will be generated
    by the database. Therefore, if you want to do something with the entity, you will
    need to get that ID. You could instead return the whole entity, but that is like
    getting a house when all you need is an address.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，`Create`方法返回一个整数。通常，在编写代码时，你会将改变状态的方法与查询方法分开。换句话说，不要试图同时获取和更改某个东西。然而，在这种情况下，这是很难实现的，因为实体的ID将由数据库生成。因此，如果你想对实体进行操作，你需要获取那个ID。你也可以返回整个实体，但这就像你需要的是一个地址，而你却得到了一栋房子。
- en: 'Given you want to do the same four operations (create, delete, update, and
    get), the pattern would look like this:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想执行相同的四个操作（创建、删除、更新和获取），该模式看起来像这样：
- en: '[PRE102]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'It looks almost the same; the only difference is the targeted entity. Given
    that you had a very simple application that just does data processing in a very
    simple way, it would make sense to make these repositories generic:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来几乎一样；唯一的区别是目标实体。鉴于你有一个非常简单的应用程序，它只是以非常简单的方式处理数据，使这些存储库通用是有意义的：
- en: '[PRE103]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Here, instead of `Product` or `Manufacturer`, the interface takes a generic
    `TEntity` that must be a class. You have also inherited an `IDisposable` interface
    to clean up all the resources that a repository used. This repository is still
    flawed. So, should you be able to persist any class? In that case, it would be
    nice to mark the classes that you could persist in.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，而不是`Product`或`Manufacturer`，接口接受一个通用的`TEntity`，它必须是一个类。你还有一个继承的`IDisposable`接口，用于清理存储库使用的所有资源。这个存储库仍然有缺陷。那么，你应该能够持久化任何类吗？如果是这样，标记你可以持久化的类会很好。
- en: Yes, you can do that. When talking about a repository, you should realize that
    even if something is supposed to be saved in a database, that does not mean that
    it will be saved separately. For example, contact information will always be saved
    with a person. A person can exist without contact information but contact information
    cannot exist without a person. Both person and contact information are entities.
    However, a person is also an aggregate (that is the entity that you will be targeting
    when adding data to a database), and it can exist by itself. This means that it
    makes no sense to have a repository for contact information if storing it would
    violate data integrity. Therefore, you should create a repository not per entity,
    but per aggregate.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你可以这样做。当谈论存储库时，你应该意识到，即使某物应该保存在数据库中，这并不意味着它会被单独保存。例如，联系信息总是与一个人一起保存。一个人可以没有联系信息存在，但联系信息不能没有一个人存在。人和联系信息都是实体。然而，一个人也是一个聚合（即，当你向数据库添加数据时，你将针对的实体），它可以独立存在。这意味着，如果存储联系信息会违反数据完整性，那么为联系信息创建存储库就没有意义。因此，你应该按聚合而不是按实体创建存储库。
- en: 'What should every row in a database have? It should have an ID. An entity is
    a model that you can persist (that is, have an ID); therefore, you can define
    an interface for it:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中的每一行应该有什么？它应该有一个ID。实体是一个你可以持久化的模型（即，有一个ID）；因此，你可以为它定义一个接口：
- en: '[PRE104]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Please note that here you are using a `get`-only property because it does not
    make sense to set an ID in all cases. However, being able to identify an object
    (by getting the ID) is critical. Also note that the ID, in this case, is an integer
    because it is just a simple example and there will not be much data; but in real
    applications, it is usually either an integer or a GUID. Sometimes, an ID could
    even be both. In those cases, a consideration to make an entity interface generic
    (that is, taking generic `TId`) could be made.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这里你正在使用一个只读的`get`属性，因为在所有情况下设置ID都没有意义。然而，能够通过获取ID来识别一个对象是至关重要的。此外，请注意，在这种情况下，ID是一个整数，因为这只是一个简单的示例，并且不会有太多数据；但在实际应用中，它通常是整数或GUID。有时，ID甚至可以是两者之一。在这些情况下，可以考虑使实体接口通用（即，使用通用的`TId`）。
- en: 'What about an aggregate? An aggregate is an entity; you would therefore write
    the following:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，聚合体是什么？聚合体是一个实体；因此，你会写出以下内容：
- en: '[PRE105]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'In this scenario, you would then just write `Person: IAggregate, ContactInfo:
    IEntity`. If you apply the same principles to the two tables you had, you will
    get `Product: IAggregate, Manufacturer: IAggregate` because the two can be saved
    separately.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，你将只写 `Person: IAggregate, ContactInfo: IEntity`。如果你将相同的原理应用到两个表上，你会得到
    `Product: IAggregate, Manufacturer: IAggregate`，因为这两个可以单独保存。'
- en: Note
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is no runnable code here; however, you will be using it in the upcoming
    exercise. You can find the code used for this example at [https://packt.link/JDLAo](https://packt.link/JDLAo).
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有可运行的代码；然而，你将在接下来的练习中使用它。你可以在这个示例中找到用于此示例的代码：[https://packt.link/JDLAo](https://packt.link/JDLAo)。
- en: Writing a repository for every aggregate might become a tedious job, especially
    if there is no special logic to the way persistence is done. In the upcoming exercise,
    you will learn how to generalize and reuse repositories.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个聚合体编写仓库可能会变得是一项繁琐的工作，特别是如果没有特殊的持久性逻辑。在接下来的练习中，你将学习如何泛化和重用仓库。
- en: 'Exercise 6.04: Creating a Generic Repository'
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.04：创建一个泛型仓库
- en: Being coupled to an ORM may make your business logic harder to test. Also, due
    to persistence being so rooted at the core of most applications, it might be a
    hassle to change an ORM. For those reasons, you may want to put an abstraction
    layer in between business logic and a database. If you use `DbContext` as is,
    you couple yourself to `EntityFramework`.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 与 ORM 的耦合可能会使你的业务逻辑更难测试。此外，由于持久性在大多数应用程序的核心中根深蒂固，更改 ORM 可能会变得麻烦。出于这些原因，你可能在业务逻辑和数据库之间放置一个抽象层。如果你直接使用
    `DbContext`，你将耦合到 `EntityFramework`。
- en: 'In this exercise, you will learn how to create a database operations abstraction—a
    generic repository—that will work on any entity and support create, delete, update,
    and get operations. Implement those methods one by one:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将学习如何创建一个数据库操作抽象——一个泛型仓库，它可以在任何实体上工作并支持创建、删除、更新和获取操作。逐个实现这些方法：
- en: 'First, create a generic repository class that takes `DbContext` in the constructor:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个通用的仓库类，该类在构造函数中接受 `DbContext`：
- en: '[PRE106]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The `context.Set<TEntity>()` allows getting a table-model binding and then using
    it throughout the repository. Another interesting point is that you didn't have
    to supply a concrete `DbContext` as it uses generic entities, and a generic repository
    is applicable to every kind of context.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`context.Set<TEntity>()` 允许获取一个表模型绑定，然后在整个仓库中使用它。另一个有趣的点是，你不必提供具体的 `DbContext`，因为它使用泛型实体，并且泛型仓库适用于任何类型的上下文。'
- en: 'To implement a `Create` operation, add a method to insert a single aggregate:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现 `Create` 操作，添加一个方法插入单个聚合：
- en: '[PRE107]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'To implement a `Delete` operation, add a method to delete an aggregate by ID:'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现 `Delete` 操作，添加一个方法通过 ID 删除一个聚合：
- en: '[PRE108]'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'To implement an `Update` operation, add a method to update an entity by overriding
    the old values with the values of a new entity:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现 `Update` 操作，添加一个方法通过用新实体的值覆盖旧值来更新一个实体：
- en: '[PRE109]'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'To implement a `Read` operation, add a method to get a single entity by ID:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现 `Read` 操作，添加一个方法通过 ID 获取单个实体：
- en: '[PRE110]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'A `Read` operation should also support getting all the entities. So, add a
    method to get all entities:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Read` 操作也应该支持获取所有实体。因此，添加一个获取所有实体的方法：'
- en: '[PRE111]'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Passing a `DbContext` to a constructor will open a database connection. As
    soon as you are done using a database, you should disconnect. In order to support
    a conventional disconnect, implement an `IDisposable` pattern:'
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `DbContext` 传递给构造函数将打开数据库连接。一旦你完成数据库的使用，你应该断开连接。为了支持传统的断开连接，实现 `IDisposable`
    模式：
- en: '[PRE112]'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'To test whether the generic repository works, create a new `Run()` method:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试通用仓库是否工作正常，创建一个新的 `Run()` 方法：
- en: '[PRE113]'
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Inside the `Run()` method, initialize a new repository for the `Manufacturer` entity:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Run()` 方法内部，为 `Manufacturer` 实体初始化一个新的仓库：
- en: '[PRE114]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Test whether the `Create` operation works, by inserting a new `manufacturer`
    as shown in the following code:'
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下代码插入一个新的 `manufacturer` 来测试 `Create` 操作是否正常工作：
- en: '[PRE115]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Test whether the `Update` operation works, by updating the manufacturer''s
    name as follows:'
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下方式更新制造商的名称来测试 `Update` 操作是否正常工作：
- en: '[PRE116]'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Test whether the `Read` operation works on a single entity, by retrieving the
    new manufacturer from a database and print it:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从数据库检索新的制造商并打印它来测试 `Read` 操作在单个实体上的工作情况：
- en: '[PRE117]'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'You should see the following output:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE118]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Test whether the `Read` operation works on all entities by getting the count
    of all manufacturers with the following code:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下代码获取所有制造商的计数来测试`Read`操作是否对所有实体都有效：
- en: '[PRE119]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'You can test whether the `Delete` operation works by deleting the new manufacturer
    as follows:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过以下方式删除新制造商来测试`Delete`操作是否正常工作：
- en: '[PRE120]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'In order to see the impact of delete (one less manufacturer is expected), compare
    the counts as follows:'
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了看到删除（预期减少一个制造商）的影响，按照以下方式比较计数：
- en: '[PRE121]'
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'In order to run this exercise, comment all lines within `static void Main(string[]
    args)` body except `Exercises.Exercise04.Demo.Run();` in `Program.cs`. You should
    see the following output upon running the `dotnet run` command:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了运行此练习，请在`Program.cs`中的`static void Main(string[] args)`方法体内注释掉除`Exercises.Exercise04.Demo.Run();`之外的所有行。运行`dotnet
    run`命令后，您应该看到以下输出：
- en: '[PRE122]'
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Repositories used to be the way to go (maybe 10-20 years ago) for implementing
    interactions with a database because these were a well-abstracted way to make
    calls against a database. An abstraction from a database would enable people to
    change the underlying database provider if needed. If a database changes, only
    the class that implements the interface will change but whatever consumes the
    interface will remain unaffected.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，使用存储库来实现与数据库的交互是（可能是在10-20年前）一种流行的方法，因为这些方法是对数据库调用的一种很好的抽象方式。从数据库中抽象出来将使人们能够在需要时更改底层数据库提供程序。如果数据库发生变化，只有实现该接口的类会发生变化，而使用该接口的任何内容都不会受到影响。
- en: Looking back at `DbContext` and `DbSet`, you might ask why those can't be used
    directly. The answer is that you can, and it serves a similar purpose as repositories
    do. That is why the repository pattern should only be used if your queries are
    sufficiently complex (meaning it's several lines long).
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾`DbContext`和`DbSet`，您可能会问为什么不能直接使用它们。答案是您可以使用，并且它具有与存储库类似的作用。这就是为什么存储库模式只有在您的查询足够复杂（意味着它有几行长）时才应该使用。
- en: Note
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/jDR0C](https://packt.link/jDR0C).
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/jDR0C](https://packt.link/jDR0C)找到此练习使用的代码。
- en: The next section will explore another benefit of EF that is, local database
    testing.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将探讨EF的另一个好处，即本地数据库测试。
- en: Testing Data Persistence Logic Locally
  id: totrans-571
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地测试数据持久性逻辑
- en: When developing software, you should always have quality and testability in
    mind. The problem with database testability is that it often requires a physical
    machine to host a database somewhere. However, you do not always have access to
    such a setup, especially at the start of a project.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发软件时，您应该始终考虑质量和可测试性。数据库可测试性的问题在于它通常需要一个物理机器来托管数据库。然而，您并不总是能够访问这样的设置，尤其是在项目开始时。
- en: 'Thankfully, EF is very flexible and offers a few packages to help out here.
    There are three main ways of testing with EF—`InMemory`, using SQLite, and calling
    an actual database. You have already seen plenty of demos calling a physical database.
    Next, you''ll explore the other two: In-Memory and SQLite.'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，EF非常灵活，并提供了一些包来帮助您在这里。使用EF进行测试主要有三种方式——`InMemory`、使用SQLite和调用实际数据库。您已经看到了许多调用物理数据库的演示。接下来，您将探索另外两种：内存和SQLite。
- en: In-Memory Database Provider
  id: totrans-574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存数据库提供程序
- en: An in-memory database provider is just a bunch of in-memory lists available
    internally that make no queries whatsoever to a database. Usually, even garbage
    collection eliminates its state. Before you can continue, just like all other
    database providers, you will need to add one to your project.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 内存数据库提供程序只是内部可用的一组内存列表，它根本不对数据库进行任何查询。通常，甚至垃圾回收也会消除其状态。在您继续之前，就像所有其他数据库提供程序一样，您需要将其添加到您的项目中。
- en: 'Run the following command:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE123]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'This command enables you to use an in-memory database when supplying `DbContextOptionsBuilder`
    with the `UseInMemoryDatabase` option, as done in the following snippet:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令允许您在向`DbContextOptionsBuilder`提供`UseInMemoryDatabase`选项时使用内存数据库，如下面的代码片段所示：
- en: '[PRE124]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: In this snippet, you've used an options builder and created a new, isolated,
    in-memory database. The most important part here is the `builder.UseInMemoryDatabase();`
    method, which specifies that an in-memory database should be created. Also, note
    the `Guid.NewGuid().ToString()` argument. This argument is for a database name.
    In this case, it means that every time you call that line you will generate a
    unique database name, thus ensuring isolation between the new test databases.
    If you don't use this argument, you risk affecting a context under the test state.
    You want to avoid that for testing scenarios. When it comes to testing, starting
    with a fresh state is the right way to go.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，你使用了选项构建器并创建了一个新的、独立的内存数据库。这里最重要的部分是 `builder.UseInMemoryDatabase();`
    方法，它指定了应该创建内存数据库。此外，请注意 `Guid.NewGuid().ToString()` 参数。这个参数是数据库名称。在这种情况下，这意味着每次调用该行时，你将生成一个唯一的数据库名称，从而确保新测试数据库之间的隔离。如果你不使用此参数，你可能会影响测试状态下的上下文。你想要避免这种情况，因为测试场景需要从全新状态开始。
- en: In order to run this example, comment all lines within `static void Main(string[]
    args)` body except `Examples.TestingDb.Demo.Run();` in `Program.cs`.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行此示例，在 `Program.cs` 中的 `static void Main(string[] args)` 方法体内注释掉所有除 `Examples.TestingDb.Demo.Run();`
    之外的所有行。
- en: Note
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/mOodJ](https://packt.link/mOodJ).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/mOodJ](https://packt.link/mOodJ) 找到用于此示例的代码。
- en: 'To test whether a generic repository for manufacturers works (assume that the
    preceding code will be reused), first create a new repository:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试制造商的通用存储库是否工作（假设前面的代码将被重用），首先创建一个新的存储库：
- en: '[PRE125]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The power of this pattern is that a new entity repository is simply specified
    as a different generic argument. If you wanted to test a manufacturer, you would
    not need to design a repository class for it. All you would have to do is to initialize
    a repository with `Manufacturer` passed as a generic argument, for example `new
    Repository<Manfacturer>(db)`.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的强大之处在于，新的实体存储库只需指定为不同的泛型参数。如果你想测试制造商，你不需要为它设计存储库类。你所要做的就是用 `Manufacturer`
    作为泛型参数初始化存储库，例如 `new Repository<Manfacturer>(db)`。
- en: 'Now, create a test `product` and save it:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个测试 `product` 并保存它：
- en: '[PRE126]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'To test the price update method, update `product.Price` and call the `Update` method:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试价格更新方法，更新 `product.Price` 并调用 `Update` 方法：
- en: '[PRE127]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'In order to check whether a product was created successfully, call a `Get`
    method and pass the new product `id`:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查产品是否成功创建，调用一个 `Get` 方法并传递新的产品 `id`：
- en: '[PRE128]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Type the following to print the product to the console:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下内容以将产品打印到控制台：
- en: '[PRE129]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The output will get displayed as follows:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下显示：
- en: '[PRE130]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Now you need to check whether delete works. So, create a new product:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要检查删除是否生效。因此，创建一个新的产品：
- en: '[PRE131]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Check the current count of products in a repository:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 检查存储库中产品的当前数量：
- en: '[PRE132]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Now delete the product:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 现在删除产品：
- en: '[PRE133]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Check the count once again, comparing it with the previous one:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查数量，与之前的一个进行比较：
- en: '[PRE134]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'In order to run this example, comment all lines within `static void Main(string[]
    args)` body except `Examples.TestingDb.Demo.Run();` in `Program.cs`. The following
    output will get displayed:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行此示例，在 `Program.cs` 中的 `static void Main(string[] args)` 方法体内注释掉所有除 `Examples.TestingDb.Demo.Run();`
    之外的所有行。以下输出将显示：
- en: '[PRE135]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Note
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/DGjf2](https://packt.link/DGjf2).
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/DGjf2](https://packt.link/DGjf2) 找到用于此示例的代码。
- en: Using an In-Memory provider has its limitations. Up next, you will learn another
    alternative to testing code depending on the `DbContext` with fewer limitations.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内存提供程序有其局限性。接下来，你将学习另一个替代方案，用于测试依赖于 `DbContext` 的代码，它具有更少的局限性。
- en: SQLite Database Provider
  id: totrans-610
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLite 数据库提供程序
- en: The problem with in-memory providers is that you cannot run any SQL statements
    on them. If you do, the code fails. Also, an in-memory provider is all about in-memory
    data structures and has nothing to do with SQL. SQLite database provider is free
    from those problems. The only issue it has is that SQLite is a dialect of SQL,
    so some raw SQL queries of other providers might not work.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 内存提供程序的问题在于你无法在它们上运行任何 SQL 语句。如果你这样做，代码会失败。此外，内存提供程序完全是关于内存数据结构，与 SQL 没有任何关系。SQLite
    数据库提供程序免除了这些问题。它唯一的问题是 SQLite 是 SQL 的方言，因此其他提供程序的某些原始 SQL 查询可能不会工作。
- en: 'To try out SQLite, run the following command in the VS Code terminal:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试 SQLite，请在 VS Code 终端中运行以下命令：
- en: '[PRE136]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The installed NuGet allows you to use SQLite provider when creating a `DbContext`
    schema, like this:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 安装的NuGet允许您在创建`DbContext`架构时使用SQLite提供者，如下所示：
- en: '[PRE137]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: In the preceding snippet, you have created a SQL connection, specifying that
    an in-memory SQLite database will be used. The `Db.Database.EnsureCreated()` was
    needed because the database would not always be created using that connection
    string. In order to run this example, comment all lines within `static void` `Main(string[]
    args)` body except `Examples.TestingDb.Demo.Run();` in `Program.cs`.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您创建了一个SQL连接，指定将使用内存中的SQLite数据库。`Db.Database.EnsureCreated()`是必需的，因为数据库不会总是使用该连接字符串创建。为了运行此示例，请在`Program.cs`中的`static
    void Main(string[] args)`主体中注释掉除`Examples.TestingDb.Demo.Run();`之外的所有行。
- en: Note
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/rW3JS](https://packt.link/rW3JS).
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/rW3JS](https://packt.link/rW3JS)找到用于此示例的代码。
- en: 'If you were to create `ProductsRepository` and run the same code from the `InMemory`
    database example, you would get an error: `SQLite Error 19: ''FOREIGN KEY constraint
    failed''`. This is due to a missing manufacturer with an ID of 1 to which you
    are trying to link the new test products. This is a prime example of why the EF
    in-memory provider is not that reliable.'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您创建`ProductsRepository`并从`InMemory`数据库示例中运行相同的代码，您将得到一个错误：`SQLite Error 19:
    ''FOREIGN KEY constraint failed''`。这是由于缺少一个ID为1的制造商，您正在尝试将其与新测试产品关联。这是一个EF内存提供者不可靠的典型例子。'
- en: 'In order to fix this, add the following just before creating a test product:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个问题，在创建测试产品之前添加以下内容：
- en: '[PRE138]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The only thing to remember is to clean up. After you are done using a database
    context that was created using a SQL connection, do not forget to dispose of that
    connection this way:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一要记住的是清理。在您使用完使用SQL连接创建的数据库上下文之后，不要忘记以这种方式销毁该连接：
- en: '[PRE139]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: At this point, you already know how to use `DbContext` in many different ways
    in order to communicate with a database. However, a dependency on a third-party
    library (EF Core) and unit testing maybe be tricky if all depends on a specific
    ORM. In the next paragraph, you will learn how to escape such a dependency.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经知道如何以许多不同的方式使用`DbContext`与数据库进行通信。然而，如果所有这些都依赖于特定的ORM，那么对第三方库（EF Core）和单元测试的依赖可能会很棘手。在下一段中，您将学习如何避免这种依赖。
- en: A Few Words on Repository
  id: totrans-625
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于仓库的一些话
- en: The Repository pattern works for simple CRUD applications because it can further
    simplify database interactions. However, given you are using EF, it is already
    simple enough to interact with a database and another layer of abstraction is
    not always justified. After all, one of the key reasons why the Repository pattern
    caught so much attention is that it allows you to escape database interactions.
    However, the EF in-memory provider allows that too, so there is even less of a
    reason to use a repository.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库模式适用于简单的CRUD应用程序，因为它可以进一步简化数据库交互。然而，鉴于您正在使用EF，与数据库的交互已经足够简单，额外的抽象层并不总是有必要的。毕竟，仓库模式之所以受到如此多的关注，其中一个关键原因就是它允许您避免数据库交互。然而，EF内存提供者也允许这样做，因此使用仓库的理由就更少了。
- en: The generic repository pattern is a useful abstraction. It abstracts away database
    interaction under a simple interface. However, for non-trivial scenarios, you
    are likely to need your custom CRUD operations and then you would create a non-generic
    repository. In fact, non-generic repositories are the recommended approach (given
    you want to implement the pattern) because you rarely want all the CRUD methods
    for all the entities. It is not rare to end up with as little as a single method
    on a repository. If you use a generic repository, you could still make all methods
    virtual and override them, but then you will end up overriding all the time or
    having methods that you don't use. It is less than ideal.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 通用仓库模式是一个有用的抽象。它通过一个简单的接口抽象出数据库交互。然而，对于非平凡场景，您可能需要自定义CRUD操作，然后您将创建一个非通用仓库。实际上，非通用仓库是推荐的方法（如果您想实现该模式），因为您很少希望所有实体都具有所有CRUD方法。在仓库上只有一个方法的情况并不少见。如果您使用通用仓库，您仍然可以使得所有方法都是虚拟的并覆盖它们，但这样您将不断覆盖或拥有不使用的方法。这并不理想。
- en: The following section will explore a different pattern that strives to make
    simple, optimal interactions per database operation—CQRS.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将探讨一种不同的模式，该模式力求使每个数据库操作都进行简单、最优的交互——CQRS。
- en: Query and Command Handlers Patterns
  id: totrans-629
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询和命令处理器模式
- en: 'Command Query Responsibility Segregation (CQRS) is a pattern that aims to separate
    reads from writes. Instead of one class for all CRUD operations, you will have
    one class per CRUD method. On top of that, instead of one entity that fits all,
    you will have request and query object models dedicated to those specific scenarios.
    In CQRS, all database operations can be classified into two:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 命令查询责任分离（CQRS）是一种旨在将读取和写入分离的模式。而不是一个类用于所有CRUD操作，你将有一个类用于每个CRUD方法。在此基础上，而不是一个适合所有情况的实体，你将有一个针对特定场景的请求和查询对象模型。在CQRS中，所有数据库操作可以分为两类：
- en: 'Command: An operation that changes state (create, update, delete).'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令：一种改变状态的运算（创建、更新、删除）。
- en: 'Query: An operation that gets something, without affecting the state.'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询：一种获取某些内容但不影响状态的运算。
- en: '![Figure 6.11: CQRS pattern as used by Martin Fowler ](img/B16835_06_11.jpg)'
  id: totrans-633
  prefs: []
  type: TYPE_IMG
  zh: '![图6.11：马丁·福勒使用的CQRS模式](img/B16835_06_11.jpg)'
- en: 'Figure 6.11: CQRS pattern as used by Martin Fowler'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：马丁·福勒使用的CQRS模式
- en: Note
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The original source for this diagram can be found at [https://www.martinfowler.com/bliki/CQRS.xhtml](https://www.martinfowler.com/bliki/CQRS.xhtml).
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表的原始来源可在[https://www.martinfowler.com/bliki/CQRS.xhtml](https://www.martinfowler.com/bliki/CQRS.xhtml)找到。
- en: 'In order to implement a command handler for creating a product, you would start
    by defining the command. What does the product need? It needs a name and a price,
    as well as a manufacturer. The ID for the create command is not needed (because
    the database generates it) and the manufacturer property can be removed as well
    because you will not make use of navigational properties. The name of a CQRS operation
    is made up of three parts—operation name, entity name, and `command` or `query`
    suffix. You are creating a product; therefore, the model will be called `CreateProductCommand`:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现创建产品的命令处理程序，你将首先定义命令。产品需要什么？它需要一个名称、一个价格以及一个制造商。创建命令的ID不需要（因为数据库会生成它），制造商属性也可以删除，因为你将不会使用导航属性。CQRS操作的名字由三个部分组成——操作名称、实体名称以及`command`或`query`后缀。你正在创建一个产品；因此，模型将被称为`CreateProductCommand`：
- en: '[PRE140]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Next, you will create a handler of this command. In the constructor, pass the
    database context. In the `Handle` method, pass `CreateProductCommand`:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建此命令的处理程序。在构造函数中，传递数据库上下文。在`Handle`方法中，传递`CreateProductCommand`：
- en: '[PRE141]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Handlers are simple, single-method objects that implement all that is needed
    to process a command or a query. In order to test things, you''ll also create
    a `GetProductQueryHandler` class:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序是简单的、单方法对象，实现了处理命令或查询所需的所有内容。为了测试，你还将创建一个`GetProductQueryHandler`类：
- en: '[PRE142]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The idea is almost the same, except that, in this case, querying is so simple
    that the optimal model for it is a simple integer. In some scenarios, if you can
    predict the complexity growing and the query becoming more complex, then even
    such an integer could go to a model (in order to avoid a breaking change of query
    format changing completely—from a primitive integer to an object).
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 理念几乎相同，只是在这种情况下，查询变得如此简单，其最优模型是一个简单的整数。在某些场景中，如果你能预测复杂性增长和查询变得更加复杂，那么甚至这样的整数也可能转变为一个模型（为了避免查询格式完全改变——从原始整数到对象）。
- en: 'In order to see whether the command and query work, you will be using an in-memory
    database context once again. So, create a command to create a new product, a handler
    to handle it, execute it, and print the results as follows:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看命令和查询是否工作，你将再次使用内存数据库上下文。因此，创建一个创建新产品的命令，一个处理它的处理程序，执行它，并按如下方式打印结果：
- en: '[PRE143]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Create a query to get the created product and a handler to execute the query:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个查询以获取创建的产品和一个处理查询的处理程序：
- en: '[PRE144]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'In order to run this example, comment all lines within `static void Main(string[]
    args)` body except `Examples.Cqrs.Demo.Test();` in `Program.cs`. The output will
    be displayed as follows:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行此示例，请在`Program.cs`中的`static void Main(string[] args)`体中注释掉除`Examples.Cqrs.Demo.Test();`之外的所有行。输出将如下所示：
- en: '[PRE145]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Note
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/Ij6J8](https://packt.link/Ij6J8).
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/Ij6J8](https://packt.link/Ij6J8)找到用于此示例的代码。
- en: You might have wondered why, after so many demos, the `ProductId` is still `1`.
    That's because it is an in-memory database—one that you create fresh for a new
    test every time. Since you are starting with an empty database every time, the
    first addition of a new entity to a database results in a new item with an ID
    of 1.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，在演示了这么多之后，`ProductId`为什么仍然是`1`。那是因为它是一个内存数据库——每次测试时都会创建一个新的。由于你每次都是从空数据库开始的，所以向数据库添加新实体时，结果是一个ID为1的新条目。
- en: You might wonder if you made some changes to a database or added a column to
    it, and how it would impact the rest of the codebase and the business logic. The
    next section will detail these scenarios.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，如果你对数据库进行了某些更改或向其中添加了列，这将对代码库和业务逻辑产生什么影响。下一节将详细说明这些场景。
- en: Separating the Database Model from the Business Logic (Domain) Model
  id: totrans-654
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据库模型从业务逻辑（领域）模型中分离出来
- en: Databases often change. However, should that impact the rest of the codebase?
    Should the fact that a column type changed, or another column was added affect
    the business logic? There is no straight answer to that. It all depends on the
    project scope, the resources, and the team's maturity. However, if you are working
    on a medium or a big project, you should consider segregating the database and
    domain completely. This does not only mean that different logic should be placed
    in different projects, but it also means that those projects should be decoupled
    from one another.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库经常发生变化。然而，这会影响代码库的其他部分吗？一列数据类型改变或添加另一列是否会影响到业务逻辑？对此并没有直接的答案。这完全取决于项目范围、资源和团队的成熟度。然而，如果你正在从事一个中等或大型项目，你应该考虑将数据库和领域模型完全分离。这不仅意味着不同的逻辑应该放在不同的项目中，还意味着这些项目应该相互解耦。
- en: It is okay for a database layer to consume a domain layer, but it is not okay
    for the domain layer to do the same. If you want a complete separation between
    the two, you will have to introduce an anti-corruption layer. It is a concept
    that says not to consume foreign models and instead map them as soon as they hit
    the public component of that layer. The idea is that all interfaces should be
    domain-specific (that is, work with domain models). However, for a database communication
    implementation, internally, you will be working with database entities instead
    of domain models. This requires mapping one to another (when taking input or returning
    output).
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库层消费领域层是可以的，但领域层消费数据库层是不可以的。如果你想在这两者之间实现完全分离，你将不得不引入一个反腐败层。这是一个概念，表示不要消费外部模型，而是在它们到达该层的公共组件时立即将它们映射。这个想法是，所有接口都应该特定于领域（即与领域模型一起工作）。然而，对于数据库通信实现，内部你将使用数据库实体而不是领域模型。这需要将它们映射到对方（在接收输入或返回输出时）。
- en: In cases where database entities change completely, the domain-specific interface
    will remain the same. Only the mapping will change, which will prevent the database
    from impacting anything else. It is not an easy thing to grasp and implement for
    a beginner. It is recommended that you ignore that for now; your personal project
    scope is not worth the effort and you might not see any benefit.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库实体完全改变的情况下，领域特定的接口将保持不变。只有映射会改变，这将防止数据库影响其他任何东西。对于初学者来说，这并不是一件容易理解或实现的事情。建议你现在忽略这一点；你的个人项目范围不值得付出这样的努力，你可能看不到任何好处。
- en: This concludes the theoretical portion of this section. In the following section,
    you will put this into practice with an activity.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本节的理论部分。在接下来的部分，你将通过一个活动来将其付诸实践。
- en: 'Activity 6.01: Tracking System for Trucks Dispatched'
  id: totrans-659
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动六点零一：卡车派发跟踪系统
- en: A logistics company has hired you to keep track of dispatched trucks. A single
    dispatch includes the current location of a truck, the truck's ID, and the driver's
    ID. In this activity, you will create a database for dispatched trucks, seed it
    with a few dispatches, and prove it works by getting all possible data from it.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 一家物流公司雇佣你来跟踪派发的卡车。单次派发包括卡车的当前位置、卡车ID和驾驶员ID。在这个活动中，你将创建一个派发卡车的数据库，用几个派发数据初始化它，并通过从中获取所有可能的数据来证明其工作正常。
- en: 'You will create two classes (`Truck` and `Person`), which consist of the following objects:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建两个类（`Truck`和`Person`），它们包含以下对象：
- en: '`Truck`: `Id`, `Brand`, `Model`, `YearOfMaking`'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Truck`: `Id`, `Brand`, `Model`, `YearOfMaking`'
- en: '`Person`: `Id`, `Name`, `DoB`'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Person`: `Id`, `Name`, `DoB`'
- en: All tables are stored in the `TruckLogistics` database, in the `TruckLogistics` schema.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 所有表都存储在`TruckLogistics`数据库的`TruckLogistics`模式中。
- en: 'Perform the following steps to complete this activity:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此活动：
- en: Create a `Person` class.
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Person`类。
- en: Create a `Truck` class.
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Truck`类。
- en: Create a `TruckDispatch` class.
  id: totrans-668
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`TruckDispatch`类。
- en: Create a `TruckDispatchDbContext` schema with three tables.
  id: totrans-669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含三个表的`TruckDispatchDbContext`架构。
- en: Create a connection string (ideally from environment variables).
  id: totrans-670
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个连接字符串（理想情况下从环境变量中获取）。
- en: Add a database migration.
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个数据库迁移。
- en: Generate a database from the migration.
  id: totrans-672
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从迁移中生成数据库。
- en: Connect to a database.
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到数据库。
- en: Seed the database with the initial data.
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用初始数据填充数据库。
- en: Get all data from the database.
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库中获取所有数据。
- en: Print the results.
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印结果。
- en: Dispose of the `TruckDispatchesDbContext` schema (that is, disconnect).
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理`TruckDispatchesDbContext`架构（即断开连接）。
- en: 'After completing these steps correctly, you should see the following output:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，你应该看到以下输出：
- en: '[PRE146]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Note
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In order to run this activity, comment all lines within `static void Main(string[]
    args)` body except `Activities.Activity01.Demo.Run()`; in `Program.cs`.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行此活动，请在`Program.cs`中的`static void Main(string[] args)`体内部除`Activities.Activity01.Demo.Run()`外的所有行进行注释；。
- en: 'The database should look like this:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库应该看起来像这样：
- en: '![Figure 6.12: Generated TruckLogistics database (simplified for brevity) ](img/B16835_06_12.jpg)'
  id: totrans-683
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12：生成的TruckLogistics数据库（为了简洁而简化）](img/B16835_06_12.jpg)'
- en: 'Figure 6.12: Generated TruckLogistics database (simplified for brevity)'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：生成的TruckLogistics数据库（为了简洁而简化）
- en: 'And the following migration files (similar, not exact) will be created:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 并且将创建以下迁移文件（类似但不完全相同）：
- en: '![Figure 6.13: Migration files created for the solution ](img/B16835_06_13.jpg)'
  id: totrans-686
  prefs: []
  type: TYPE_IMG
  zh: '![图6.13：为解决方案创建的迁移文件](img/B16835_06_13.jpg)'
- en: 'Figure 6.13: Migration files created for the solution'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13：为解决方案创建的迁移文件
- en: Note
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在[https://packt.link/qclbF](https://packt.link/qclbF)找到。
- en: With the successful execution of this activity, you should now have solid know-how
    of how EF is used for rapidly developing solutions integrated with a database.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 通过成功执行此活动，你现在应该对EF如何用于快速开发与数据库集成的解决方案有了坚实的了解。
- en: Summary
  id: totrans-691
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you covered the benefits of an ORM and how to talk with a database
    from C# using the EF Core 6\. EF allowed you to abstract a database using `DbContext`
    and include abstractions to tables, `DbSet`.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了ORM的好处以及如何使用EF Core 6从C#与数据库进行交互。EF允许你使用`DbContext`抽象数据库，并包括对表和`DbSet`的抽象。
- en: You experienced the simplicity of consuming a database using EF, which felt
    almost the same as writing LINQ queries. The only difference was the initial setup
    of a connection using a database context. You learned the client input should
    not be trusted, but ORMs allow you to consume queries with confidence because
    they take security into consideration and protect you from SQL injection. However,
    the way you connect to a database (that is, the connection string) has to be secured,
    and for that reason, you must store it just like any other secret and not hardcode
    it. You also studied the most common pitfalls when working with EF and tools that
    could help avoid those pitfalls. This chapter has given you enough skills to create
    and consume databases using EF.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 你体验了使用EF消费数据库的简单性，这几乎感觉就像编写LINQ查询一样。唯一的区别是使用数据库上下文设置连接的初始设置。你了解到客户端输入不应被信任，但ORM允许你自信地消费查询，因为它们考虑了安全性并保护你免受SQL注入的侵害。然而，你连接到数据库的方式（即连接字符串）必须得到保护，因此你必须像存储任何其他秘密一样存储它。你还研究了使用EF时最常见的问题以及可以帮助避免这些问题的工具。本章已经为你提供了足够的技能来使用EF创建和消费数据库。
- en: In the next chapter, you will be focusing more on web applications—what they
    are, and how to build them.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将更多地关注Web应用程序——它们是什么，以及如何构建它们。
