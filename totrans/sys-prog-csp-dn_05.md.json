["```cs\nvar path = System.IO.Path.GetTempPath();\nvar fileName = \"WriteLines.txt\";\nvar fullPath = Path.Combine(path, fileName);\nFile.WriteAllText(fullPath, \"Hello, System Programmers\");\n```", "```cs\nvar path = System.IO.Path.GetTempFileName();\nFile.WriteAllText(path, \"Hello, System Programmers\");\n```", "```cs\nvar path = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);\nvar fileName = \"WriteLines.txt\";\nvar fullPath = Path.Combine(path, fileName);\nFile.WriteAllText(fullPath, \"Hello, System Programmers\");\n```", "```cs\nvar fileName = Path.GetTempFileName();\nvar info = new UTF8Encoding(true).GetBytes(\"Hello, System Developers!\");\nusing FileStream? fs = File.Create(fileName, info.Length);\ntry\n{\n    fs.Write(info, 0, info.Length);\n}\nfinally\n{\n    fs.Close();\n}\n```", "```cs\nusing var fs = new FileStream(\n    path: fileName,\n    mode: FileMode.Create,\n    access: FileAccess.Write,\n    share: FileShare.None,\n    bufferSize:0x1000,\n    options: FileOptions.Asynchronous);\n```", "```cs\nusing System.Text;\nvar fileName = Path.GetTempFileName();\nvar info = new UTF8Encoding(true).GetBytes(\"Hello fellow System Developers!\");\nusing (var fs = new FileStream(\n    path: fileName,\n    mode: FileMode.Create,\n    access: FileAccess.Write,\n    share: FileShare.Delete, // We allow other processes to delete the                               //file.\n    bufferSize: 0x1000,\n    options: FileOptions.Asynchronous))\n{\n    try\n    {\n        fs.Write(info, 0, info.Length);\n        Console.WriteLine($\"Wrote to the file. Now try to delete it.             You can find it here:\\n{fileName}\");\n        Console.ReadKey();\n        fs.Write(info);\n        Console.WriteLine(\"Done with all the writing\");\n        Console.ReadKey();\n    }\n    finally\n    {\n        fs.Close();\n    }\n}\nConsole.WriteLine(\"Done.\");\nConsole.ReadKey();\n```", "```cs\nprivate const uint GENERIC_WRITE = 0x40000000;\nprivate const uint CREATE_ALWAYS = 0x00000002;\nprivate const uint FILE_APPEND_DATA = 0x00000004;\n```", "```cs\n[DllImport(\"kernel32.dll\", SetLastError = true)]\nprivate static extern SafeFileHandle CreateFile(\n    string lpFileName,\n    uint dwDesiredAccess,\n    uint dwShareMode,\n    IntPtr lpSecurityAttributes,\n    uint dwCreationDisposition,\n    uint dwFlagsAndAttributes,\n    IntPtr hTemplateFile);\n[DllImport(\"kernel32.dll\", SetLastError = true)]\n[return: MarshalAs(UnmanagedType.Bool)]\nprivate static extern bool WriteFile(\n    SafeFileHandle hFile,\n    byte[] lpBuffer,\n    uint nNumberOfBytesToWrite,\n    out uint lpNumberOfBytesWritten,\n    IntPtr lpOverlapped);\n[DllImport(\"kernel32.dll\", SetLastError = true)]\n[return: MarshalAs(UnmanagedType.Bool)]\nprivate static extern bool CloseHandle(SafeFileHandle hObject);\n```", "```cs\npublic void WriteToFile(string fileName, string textToWrite)\n{\n    var fileHandle = CreateFile(\n        fileName,\n        GENERIC_WRITE,\n        0,\n        IntPtr.Zero,\n        CREATE_ALWAYS,\n        FILE_APPEND_DATA,\n        IntPtr.Zero);\n    if (!fileHandle.IsInvalid)\n        try\n        {\n            var bytes = Encoding.ASCII.GetBytes(textToWrite);\n            var writeResult = WriteFile(\n                fileHandle,\n                bytes,\n                (uint)bytes.Length,\n                out var bytesWritten,\n                IntPtr.Zero);\n        }\n        finally\n        {\n            // Always close the handle once you are done\n            CloseHandle(fileHandle);\n        }\n    else\n        Console.WriteLine(\"Failed to open file.\");\n}\n```", "```cs\npublic string ReadFromFile(string fileName)\n{\n    var text = File.ReadAllText(fileName);\n    return text;\n}\n```", "```cs\npublic string ReadWithStream(string fileName)\n{\n    byte[] fileContent;\n    using (FileStream fs = File.OpenRead(fileName))\n    {\n        fileContent = new byte[fs.Length];\n        fs.Read(fileContent, 0, (int)fs.Length);\n        fs.Close();\n    }\n    return Encoding.ASCII.GetString(fileContent);\n}\n```", "```cs\nfileContent = new byte[fs.Length];\nint i = 0;\nint bytesRead=0;\ndo\n{\n    var myBuffer = new byte[1];\n    bytesRead = fs.Read(myBuffer, 0, 1);\n    if(bytesRead > 0)\n        fileContent[i++] = myBuffer[0];\n}while(bytesRead > 0);\nfs.Close();\n```", "```cs\nclass MyData\n{\n    public int Id { get; set; }\n    public double SomeMagicNumber { get; set; }\n    public bool IsThisAGoodDataSet { get; set; }\n    public MyFlags SomeFlags { get; set; }\n    public string? SomeText { get; set; }\n}\n[Flags]\npublic enum MyFlags\n{\n    FlagOne,\n    FlagTwo,\n    FlagThree\n}\n```", "```cs\npublic MyData Read(string fileName)\n{\n    var myData = new MyData();\n    using var fs = File.OpenRead(fileName);\n    try\n    {\n        using BinaryReader br = new(fs);\n        myData.Id = br.ReadInt32();\n        myData.IsThisAGoodDataSet = br.ReadBoolean();\n        myData.SomeMagicNumber = br.ReadDouble();\n        myData.SomeFlags = (MyFlags)br.ReadInt32();\n        myData.SomeText = br.ReadString();\n    }\n    finally\n    {\n        fs.Close();\n    }\n    return myData;\n}\n```", "```cs\nvar imagesPath =\nEnvironment.GetFolderPath(Environment.SpecialFolder.MyPictures);\nstring[] allFiles =\n    Directory.GetFiles(\n        path: imagesPath,\n        searchPattern: \"*.jPg\",\n        searchOption: SearchOption.AllDirectories);\nforeach (string file in allFiles)\n{\n    Console.WriteLine(file);\n}\n```", "```cs\nvar regex = new Regex(@\"\\.jpe?g$\", RegexOptions.IgnoreCase);\nvar allFiles =\n    Directory.EnumerateFiles(imagesPath)\n        .Where(file => regex.IsMatch(file));\n```", "```cs\nvar files = Directory.EnumerateFiles(imagesPath)\n    .Where(file => file.EndsWith(\".jpg\",\nStringComparison.OrdinalIgnoreCase) ||\n                   file.EndsWith(\".jpeg\",\nStringComparison.OrdinalIgnoreCase));\n```", "```cs\nvar imagesPath = Environment.GetFolderPath(\n    Environment.SpecialFolder.MyPictures);\nvar directoryInfo = new DirectoryInfo(imagesPath);\nConsole.WriteLine(directoryInfo.FullName);\nConsole.WriteLine(directoryInfo.CreationTime);\nConsole.WriteLine(directoryInfo.Attributes);\n```", "```cs\ninternal class MyFolderWatcher : Idisposable\n{\n    protected virtual void Dispose(bool disposing)\n    {\n        if (disposing)\n        {\n            // Dispose managed state (managed objects).\n        }\n    }\n     ~MyFolderWatcher()\n    {\n        Dispose(false);\n    }\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n}\n```", "```cs\nprivate FileSystemWatcher? _watcher;\n```", "```cs\npublic void SetupWatcher(string pathToWatch)\n{\n    if(_watcher != null)\n        throw new InvalidOperationException(\n            \"The watcher has already been set up\");\n    if(!Path.Exists(pathToWatch))\n        throw new ArgumentOutOfRangeException(\n            nameof(pathToWatch),\n            \"The path does not exist\");\n    // Set the folder to keep an eye on\n    _watcher = new FileSystemWatcher(pathToWatch);\n    // We only want notifications when a file is created or\n    // when it has changed.\n    _watcher.NotifyFilter =\n        NotifyFilters.FileName |\n        NotifyFilters.LastWrite;\n    // Set the callbacks\n    _watcher.Created += WatcherCallback;\n    _watcher.Changed += WatcherCallback;\n    // Start watching\n    _watcher.EnableRaisingEvents = true;\n}\n```", "```cs\nprivate void WatcherCallback(object sender, FileSystemEventArgs e)\n{\n    switch (e.ChangeType)\n    {\n        case WatcherChangeTypes.Created:\n            FileAdded?.Invoke(this, new FileCreatedEventArgs                 (e.FullPath));\n            break;\n        case WatcherChangeTypes.Changed:\n            FileChanged?.Invoke(this, new\n                FileChangedEventArgs(e.FullPath));\n            break;\n    }\n}\n```", "```cs\npublic event EventHandler<FileCreatedEventArgs>? FileAdded;\npublic event EventHandler<FileChangedEventArgs>? FileChanged;\n```", "```cs\npublic class FileCreatedEventArgs : EventArgs\n{\n    public FileCreatedEventArgs(string filePath)\n    {\n        FilePath = filePath;\n    }\n    public string FilePath { get; }\n}\npublic class FileChangedEventArgs : EventArgs\n{\n    public FileChangedEventArgs(string filePath)\n    {\n        FilePath = filePath;\n    }\n    public string FilePath { get; }\n}\n```", "```cs\nprotected virtual void Dispose(bool disposing)\n{\n    if (!disposing) return;\n    if (_watcher == null)\n        return;\n    // Stop raising events\n    _watcher.EnableRaisingEvents = false;\n    // Clean whoever has subscribed to us\n    // to prevent memory leaks\n    FileAdded = null;\n    FileChanged = null;\n    _watcher.Dispose();\n    _watcher = null;\n}\n```", "```cs\npublic async Task CreateBigFileNaively(string fileName)\n{\n    var stream = File.CreateText(fileName);\n    for (int i = 0; i < Int32.MaxValue; i++)\n    {\n            var value = $\"This is line {i}\";\n            Console.Writeline(value);\n            await stream.WriteLineAsync(value);\n                await Task.Delay(10);\n    }\n    Console.WriteLine(\"Closing the stream\");\n    stream.Close();\n    await stream.DisposeAsync();\n}\n```", "```cs\nvar asyncSample = new AsyncSample();\nawait asyncSample.CreateBigFileNaively(@\"c:\\temp\\bigFile.txt\");\n```", "```cs\npublic async Task CreateBigFile(string fileName, CancellationToken cancellationToken)\n{\n    var stream = File.CreateText(fileName);\n    for (int i = 0; i < Int32.MaxValue; i++)\n    {\n        if (cancellationToken.IsCancellationRequested)\n        {\n            Console.WriteLine(\"We are being cancelled\");\n            break;\n        }\n        else\n        {\n            var value = $\"This is line {i}\";\n            Console.WriteLine(value);\n            await stream.WriteLineAsync(value);\n            try\n            {\n                await Task.Delay(10, cancellationToken);\n            }\n            catch (TaskCanceledException)\n            {\n                Console.WriteLine(\"We are being cancelled\");\n                break;\n            }\n        }\n    }\n    Console.WriteLine(\"Closing the stream\");\n    stream.Close();\n    await stream.DisposeAsync();\n}\n```", "```cs\nvar cancellationTokenSource = new\nCancellationTokenSource();\nThreadPool.QueueUserWorkItem((_) =>\n{\n    Thread.Sleep(10000);\n    Console.WriteLine(\"About to cancel the operation\");\n    cancellationTokenSource.Cancel();\n});\nvar asyncSample = new AsyncSample();\nawait asyncSample.CreateBigFile(\n    @\"c:\\temp\\bigFile.txt\",\n    cancellationTokenSource.Token);\n```", "```cs\ninternal readonly record struct DataRecord\n{\n    public int Id { get; init; }\n    public DateTime LogDate { get; init; }\n    public double Price { get; init; }\n}\n```", "```cs\npublic async Task WriteBufferedData(string fileName)\n{\n    var data = new DataRecord\n    {\n        Id = 42,\n        LogDate = DateTime.UtcNow,\n        Price = 12.34\n    };\n    await using FileStream stream = new(fileName, FileMode.CreateNew,     FileAccess.Write);\n    await using BufferedStream bufferedStream = new(stream,\n    Marshal.SizeOf<DataRecord>());\n    await using BinaryWriter writer = new(bufferedStream);\n    writer.Write(data.Id);\n    writer.Write(data.LogDate.ToBinary());\n    writer.Write(data.Price);\n}\n```", "```cs\npublic static void EncryptFileSymmetric(string inputFile, string outputFile, string key)\n{\n    using (FileStream inputFileStream = new\n    FileStream(inputFile, FileMode.Open, FileAccess.Read))\n    using (FileStream outputFileStream = new FileStream(outputFile,     FileMode.Create, FileAccess.Write))\n    {\n        byte[] keyBytes = Encoding.UTF8.GetBytes(key);\n        using (Aes aesAlg = Aes.Create())\n        {\n            aesAlg.Key = keyBytes;\n            aesAlg.GenerateIV();\n            byte[] ivBytes = aesAlg.IV;\n            outputFileStream.Write(ivBytes, 0, ivBytes.Length);\n            using (CryptoStream csEncrypt = new\n               CryptoStream(outputFileStream,                aesAlg.CreateEncryptor(),\n                       CryptoStreamMode.Write))\n            {\n                byte[] buffer = new byte[4096];\n                int bytesRead;\n                while ((bytesRead =\n                   inputFileStream.Read(buffer,                    0, buffer.Length)) > 0)\n                {\n                    csEncrypt.Write(buffer, 0, bytesRead);\n                }\n            }\n        }\n    }\n}\n```", "```cs\npublic static void DecryptFileSymmetric(string inputFile, string outputFile, string key)\n{\n    using (FileStream inputFileStream = new FileStream(inputFile,     FileMode.Open, FileAccess.Read))\n    using (FileStream outputFileStream = new FileStream(outputFile,     FileMode.Create, FileAccess.Write))\n    {\n        byte[] keyBytes = Encoding.UTF8.GetBytes(key);\n        using (Aes aesAlg = Aes.Create())\n        {\n            byte[] ivBytes = new byte[aesAlg.BlockSize / 8];\n            inputFileStream.Read(ivBytes, 0,\n               ivBytes.Length);\n            aesAlg.Key = keyBytes;\n            aesAlg.IV = ivBytes;\n            using (CryptoStream csDecrypt =\n                   new CryptoStream(outputFileStream,\n                   aesAlg.CreateDecryptor(), CryptoStreamMode.Write))\n            {\n                byte[] buffer = new byte[4096];\n                int bytesRead;\n                while ((bytesRead =\n                inputFileStream.Read(buffer, 0, buffer.Length)) > 0)\n                {\n                    csDecrypt.Write(buffer, 0, bytesRead);\n                }\n            }\n        }\n    }\n}\n```", "```cs\npublic static (string, string) GenerateKeyPair()\n{\n    using RSA rsa = RSA.Create();\n    byte[] publicKeyBytes = rsa.ExportRSAPublicKey();\n    byte[] privateKeyBytes = rsa.ExportRSAPrivateKey();\n    string publicKeyBase64 = Convert.ToBase64String(publicKeyBytes);\n    string privateKeyBase64 = Convert.ToBase64String(privateKeyBytes);\n    return (publicKeyBase64, privateKeyBase64);\n}\n```", "```cs\npublic static byte[] EncryptWithPublicKey(\n    byte[] data,\n    byte[] publicKeyBytes)\n{\n    using RSA rsa = RSA.Create();\n    rsa.ImportRSAPublicKey(publicKeyBytes, out _);\n    return rsa.Encrypt(data, RSAEncryptionPadding.OaepSHA256);\n}\npublic static byte[] DecryptWithPrivateKey(\n    byte[] encryptedData,\n    byte[] privateKeyBytes)\n{\n    using RSA rsa = RSA.Create();\n    rsa.ImportRSAPrivateKey(privateKeyBytes, out _);\n    return rsa.Decrypt(encryptedData, RSAEncryptionPadding.    OaepSHA256);\n}\n```", "```cs\n(string, string) keyPair = Encryption.GenerateKeyPair();\nkeyPair.Item1.Dump();\nkeyPair.Item2.Dump();\nvar publicKey = Convert.FromBase64String(keyPair.Item1);\nvar privateKey = Convert.FromBase64String(keyPair.Item2);\nstring message = \"This is the text that we, as System Programmers,     want to secure.\";\nbyte[] messageBytes = Encoding.UTF8.GetBytes(message);\nbyte[] encryptedBytes = Encryption.EncryptWithPublicKey(messageBytes,     publicKey);\nstring encrypted = Encoding.UTF8.GetString(encryptedBytes);\nencrypted.Dump(ConsoleColor.DarkYellow);\nbyte[] decryptedBytes = Encryption.    DecryptWithPrivateKey(encryptedBytes, privateKey);\nstring decrypted = Encoding.UTF8.GetString(decryptedBytes);\ndecrypted.Dump(ConsoleColor.DarkYellow);\n```", "```cs\npublic async Task<byte[]> CompressString(string input,\n    CancellationToken cancellationToken)\n{\n    // Get the payload as bytes\n    byte[] data =\n    System.Text.Encoding.UTF8.GetBytes(input);\n    // Compress to a MemoryStream\n    await using var ms = new MemoryStream();\n    await using var compressionStream = new GZipStream(ms,\n    CompressionMode.Compress);\n    await compressionStream.WriteAsync(data, 0,\n    data.Length, cancellationToken);\n    await compressionStream.FlushAsync(cancellationToken);\n    // Get the compressed data.\n    byte[] compressedData = ms.ToArray();\n    return compressedData;\n}\n```", "```cs\npublic async Task<string> DecompressString(byte[] input,\n    CancellationToken cancellationToken)\n{\n    // Write the data into a memory stream\n    await using var ms = new MemoryStream();\n    await ms.WriteAsync(input, cancellationToken);\n    await ms.FlushAsync(cancellationToken);\n    ms.Position = 0;\n    // Decompress\n    await using var decompressionStream = new GZipStream(ms,     CompressionMode.Decompress);\n    await using var resultStream = new MemoryStream();\n    await decompressionStream.CopyToAsync(resultStream,     cancellationToken);\n    // Convert to readable text.\n    byte[] decompressedData = resultStream.ToArray();\n    string decompressedString =\n    System.Text.Encoding.UTF8.GetString(decompressedData);\n    return decompressedString;\n}\n```", "```cs\nvar cts = new CancellationTokenSource();\nvar myText = \"This is some text that I want to compress.\";\nvar compression = new Compression();\nvar compressed = await compression.CompressString(myText, cts.Token);\nvar decompressed = await\n    compression.DecompressString(compressed, cts.Token);\ndecompressed.Dump(ConsoleColor.DarkYellow);\n```", "```cs\nclass MyData\n{\n    public int Id { get; set; }\n    public double SomeMagicNumber { get; set; }\n    public bool IsThisAGoodDataSet { get; set; }\n    public MyFlags SomeFlags { get; set; }\n    public string? SomeText { get; set; }\n}\n[Flags]\npublic enum MyFlags\n{\n    FlagOne,\n    FlagTwo,\n    FlagThree\n}\n```", "```cs\npublic string SerializeToJSon(MyData myData)\n{\n    var options = new JsonSerializerOptions\n    {\n        WriteIndented = true,\n        PropertyNamingPolicy = JsonNamingPolicy.CamelCase\n    };\n    var result =\n    System.Text.Json.JsonSerializer.Serialize(myData,options );\n    return result;\n}\n```", "```cs\n{\n  \"id\": 42,\n  \"someMagicNumber\": 3.1415,\n  \"isThisAGoodDataSet\": true,\n  \"someFlags\": 2,\n  \"someText\": \"This is some text that we want to serialize\"\n}\n```", "```cs\npublic MyData DeserializeFromJSon(string json)\n{\n    var options = new JsonSerializerOptions\n    {\n        WriteIndented = true,\n        PropertyNamingPolicy = JsonNamingPolicy.CamelCase\n    };\n    var result = System.Text.Json.JsonSerializer.        Deserialize<MyData>(json, options);\n    return result!;\n}\n```", "```cs\n[ProtoContract]\npublic class MyData\n{\n    [ProtoMember(1)]\n    public int Id { get; set; }\n    [ProtoMember(2)]\n    public double SomeMagicNumber { get; set; }\n    [ProtoMember(3)]\n    public bool IsThisAGoodDataSet { get; set; }\n    [ProtoMember(4)]\n    public MyFlags SomeFlags { get; set; }\n    [ProtoMember(5)]\n    public string? SomeText { get; set; }\n}\n```", "```cs\npublic async Task<byte[]> SerializeToBinary(MyData myData)\n{\n    await using var stream = new MemoryStream();\n    ProtoBuf.Serializer.Serialize(stream, myData);\n    return stream.ToArray();\n}\npublic async Task<MyData> DeserializeFromBinary(byte[] payLoad)\n{\n    await using var stream = new MemoryStream(payLoad);\n    var myData =\n        ProtoBuf.Serializer.Deserialize<MyData>(stream);\n    return myData;\n}\n```"]