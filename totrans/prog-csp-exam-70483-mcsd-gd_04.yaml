- en: Implementing Program Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on how we can manage program flow in C#. In other words,
    this chapter will help you understand how the program controls and validates input
    and output arguments and makes decisions using statements that are available in
    C#. We will cover various Boolean expressions, such as If/Else and Switch, which
    control the flow of code based on certain conditions. We will also evaluate various
    operators, such as the conditional operator and the equality operator (`<`, `>`,
    `==`), both of which govern the flow of code. We will focus on how we can iterate
    across collections (with `for` loops, `while` loops, and so on) and explicit jump
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: The following topics will be covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding conditional/selection statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iteration statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The exercises in this chapter can be practiced using Visual Studio 2012 or above
    with .NET Framework version 2.0 or above. However, any new C# features from version
    7.0 and above require you to have Visual Studio 2017.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have a license for any of these products, you can download the
    community version of Visual Studio 2017 from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: The sample code for this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter04](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dive into this topic, let''s understand what operators and operands
    are. These are two important terms we will use in this section of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: An operator is a programming element that is applied to one or more operands
    in an expression or statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An operand is an object that can be manipulated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# offers different types of operators, such as the Unary operator (`[increment
    operator] ++`, `new`) which takes one operand, Binary operators of the arithmetic
    type (`+`, `-`, `*`, `/`), relational types (`>` ,`<`, `<=`, `>=`), equality types
    (`=`, `!=`), and shift types (`>>`, `<<`), all of which are used between two operands.
    C# also offers a ternary operator that takes three operands (`?:`).
  prefs: []
  type: TYPE_NORMAL
- en: Unary operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An operator that requires only one operand is called a **Unary operator**. They
    can perform operations such as increment, decrement, negation and so on. They
    can also be applied before (prefix) or after (postfix) the operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists a few Unary operators. `x`, in the left-hand column,
    is an operand where we apply the operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `+x` | **Identity**: This operator can be used as a Unary or Binary operator.
    If it''s used on numeric values, it returns the value. If it''s applied on two
    numeric operands, it returns the sum of operands. On strings, it concatenates
    both operands. |'
  prefs: []
  type: TYPE_TB
- en: '| `-x` | **Negation**: This operator can be used as a Unary or Binary operator.
    Applying this operator on numeric types results in the numeric negation of the
    operand. |'
  prefs: []
  type: TYPE_TB
- en: '| `!x` | **Logical negation**: This operator negates the operand. It is applied
    for bool operands and returns if the operand is false. |'
  prefs: []
  type: TYPE_TB
- en: '| `~x` | **Bitwise negation**: This produces a complement of its operand by
    reversing each bit. |'
  prefs: []
  type: TYPE_TB
- en: '| `++x` | **Pre-increment**: This is an increment operator and can appear before
    or after the operand. When prefixed, the result is placed after the increment.
    If postfixed, the result is placed before the increment. |'
  prefs: []
  type: TYPE_TB
- en: '| `--x` | **Pre-decrement**: This is a decrement operator and can appear before
    or after the operand. When prefixed, the result is placed after decrement. If
    postfixed, the result is placed before the decrement. |'
  prefs: []
  type: TYPE_TB
- en: 'In the following code, we will declare a few variables and use them to showcase
    examples of the preceding operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`+` and `-` can be used with a single operand or multiple operands. When used
    with multiple operands of the integer type, they either sum the operands or get
    the difference. The `+` operator can be used with string type operands as well.
    In this case, it will concatenate both the strings. A string and an operator is
    always a Binary operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `!` operator works well with Boolean operands where it produces logical
    negation; that is, true becomes false, whereas the `~` operator works with bitwise
    operands. In the following example, a Binary digit representation and its bitwise
    negation are displayed. We are taking an integer value and converting it into
    a Binary value and then negating it using the `~` operator and displaying it in
    base 2 format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `++` and `--` operators, when applied on integer operands, perform increments
    or decrements on the operands, respectively. These can be applied pre or post
    an operand. The following example shows both the post and pre increment and decrement
    operators. Pre produces results before displaying and post produces results after
    displaying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Relational operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, relational operators test or define the relationship between
    two operands, for example, if the first operand is less than the second one, or
    greater than or equal to it. These operators are applied to numeric operands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists a few Binary operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | Defined as less than the operator. Used as `X < Y`. Returns true if
    the first operand is less than the second operand. |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | Defined as greater than an operator. Used as `X > Y`. Returns true
    if the first operand is greater than the second operand. |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | Less than Or Equal To operator. Used as `X <= Y`. |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | Greater than Or Equal To operator. Used as `X >= Y`. |'
  prefs: []
  type: TYPE_TB
- en: 'We will use the same variables we defined in the preceding example to understand
    these relational operators. Here, we are trying to find out whether `firstvalue`
    is less than `secondvalue` or whether `firstvalue` is greater than `secondvalue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Equality operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Equality operators are a type of Binary operator, where `2` operands are required.
    Because they check for the equality of the operands, these can be termed under
    relational operators as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the available equality operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `==` | This works for predefined value types. Defined as the equality operator.
    Used as `X == Y`. Returns `true` if the first operand is equal to the second operand.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `!=` | Defined as the inequality operator. Used as `X! = Y`. Returns `true`
    if the operands are not equal. |'
  prefs: []
  type: TYPE_TB
- en: 'We will use the same variables we created in the preceding examples to try
    and understand the equality operators. Here, we are trying to check if `firstvalue`
    is equal or not equal to `secondvalue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Shift operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shift operators are another type of Binary operator. They take two integer operands
    and left shift or right shift the bits by the number specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the available shift operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `<<` | This is an example of a Binary operator that allows you to shift the
    first operand left by the number of bits specified in the second operand. The
    second operator must be a type of Int. |'
  prefs: []
  type: TYPE_TB
- en: '| `>>` | This is an example of a Binary operator that allows you to shift the
    first operand right by the number of bits specified in the second operand. The
    second operator must be a type of Int. |'
  prefs: []
  type: TYPE_TB
- en: 'In the following example, the program accepts an integer operand and shifts
    left or right by 1 bit. Shift works on Binary operators, so, for our understanding,
    I wrote a method that will convert an integer into Binary format and display it.
    When we pass an integer number of `9` to the program, `i`, and use the `>>` operator,
    its Binary string is shifted by 1 and the result is displayed. When `1001` is
    right-shifted, it becomes `100`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Logical, conditional, and null operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# allows you to combine the aforementioned operators with `OR` (`||`), `AND`
    (`&&`), or `XOR` (`^`). These are applied to both operands in an expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the logical, conditional, and `null` operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Description and example** |'
  prefs: []
  type: TYPE_TB
- en: '| Logical OR (`&#124;`) | This operator computes both operands and returns
    `false` if both are `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| Logical AND (`&`) | This operator can be used in two forms: Unary address
    operator or Binary logical operator. When used as a Unary address operator, it
    returns the address of the operand. If used as a Binary, it evaluates both operands
    and returns `true` if both operands are `true`; otherwise, it will return `false`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Conditional AND (`&&`) | This conditional operator is used when two `bool`
    operands need to be evaluated. When applied, both operands are computed and returns
    `true` if both operands are `true`. If the first operand returns `false`, the
    conditional operator doesn''t evaluate the other operator. This is also known
    as the *short-circuiting* logical `AND` operator. |'
  prefs: []
  type: TYPE_TB
- en: '| Conditional OR (`&#124;&#124;`) | This is also known as the *short-circuiting*
    logical `OR` operator. The conditional `OR` operator evaluates both `bool` operands
    and returns `true` if either of them is `true`. If the first operand returns `true`,
    it won''t evaluate the second operator. |'
  prefs: []
  type: TYPE_TB
- en: '| Logical XOR (`^`) | This operator is evaluated as a bitwise exclusive `OR`
    for integral types and logical exclusive and `OR` for `bool` types. When applied,
    it computes both operands and returns `true` if one of the operands is `true`;
    otherwise, it returns `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| Null coalescing (`??`) | The null coalescing operator computes both operands
    and returns the operand that is `not null`. It''s used like so: `int y = x ??
    1;`. In this scenario, if `x` is `null`, `y` is assigned a value of `1`; otherwise,
    `y` is assigned a value of `x`. |'
  prefs: []
  type: TYPE_TB
- en: '| Ternary operator (`?:`) | The conditional operator is also known as the `Ternary`
    operator and evaluates a Boolean expression. The condition is `? true value :
    false value`. If the condition is `true`, the operator returns `true value`, but
    if the condition is `false`, the operator returns `false value`. Ternary operators
    support nested expressions or operators, which is also known as being *right-associative*.
    |'
  prefs: []
  type: TYPE_TB
- en: 'The following code will allow us to understand each of these statements in
    detail. Initially, we will define the required variables and methods and then
    proceed with each statement. The following code is available on GitHub. The link
    is provided in the *Technical requirements* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, logical `OR` (`|`) shows usage of the `|` operator.
    We have two Boolean expressions in the following code block that are evaluated
    at runtime and return either `true` or `false`. This operator always returns `true`
    except when both operands return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, logical `AND` shows how the `&` operator can be
    used. Logical `AND` evaluates both operands and returns `true` if both operands
    are evaluated as `true`; otherwise, it returns `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code clock, the conditional `AND` (`&&`) illustrates the `&&`
    operator. This operator evaluates the first operator and, if it is `true`, it
    evaluates the second operator. Otherwise, it returns `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, the conditional `OR` (`||`) illustrates the `||`
    operator. This operator returns `true` if any of the operands is `true`; otherwise,
    it returns `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, the logical `XOR` (`^`) explains the `^` operator on
    `bool` operands. This returns `true` if one of the operands is `true`. This is
    similar to the logical `OR` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we will look at null coalescing and the ternary operator. The null coalescing
    operator, `??`, is used to check if an operand is null before returning its value.
    It returns the value if the first operand is not null; otherwise, it returns the
    second operand. This can be used in a nested form as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ternary operator, (`?:`), is used to evaluate an expression. If it is `true`,
    then it returns `true-value`; otherwise, it returns `false-value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Understanding conditional/selection statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# offers multiple conditional/selection statements to help us make decisions
    throughout our programming. We can use all of the operators we learned about in
    the previous sections alongside these statements. These statements help the program
    take on a specific flow based on whether the expression is evaluated as `true`
    or `false`. These statements are the most widely used ones in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the available conditional/selection statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `If..else` | If statements evaluate the expression that''s provided. If it
    is `true`, then the statements are executed. If it is `false`, then else statements
    are executed. |'
  prefs: []
  type: TYPE_TB
- en: '| `Switch..case..default` | Switch statements evaluate a specific expression
    and execute the switch section if the pattern matches the match expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `break` | `break` allows us to terminate a control flow and move on to the
    next statement. |'
  prefs: []
  type: TYPE_TB
- en: '| `goto` | `goto` is used to transfer control to a specific label when the
    expression evaluates to `true`. |'
  prefs: []
  type: TYPE_TB
- en: In the following subsections, we will cover each of these statements in detail.
  prefs: []
  type: TYPE_NORMAL
- en: if...else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `if` statement is simple and easy in a scenario where the user wants
    to execute a specific code block when a condition is met. C# provides us with
    widely used if statements that allow us to achieve the desired functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '`If` (`true`) then-statements `Else` (`false`) `else`-statements. The following
    is the general syntax of the `If / Else` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When the Boolean expression evaluates to true, `then-statements` are executed,
    and when the Boolean expression evaluates to false, `else-statements` are executed.
    When the Boolean expression evaluates to either true or false, the program allows
    you to execute single or multiple statements. However, multiple statements need
    to be enclosed in curly braces, `{}`. This will ensure that all the statements
    are executed in one context and in sequence. This is also called a **code block**.
    For single statements, these braces are optional, but they are recommended from
    a code readability point of view. Also, we need to understand that the scope of
    the variables is limited to the code block they were defined in.
  prefs: []
  type: TYPE_NORMAL
- en: The else statement is optional. If this is not provided, the program evaluates
    the Boolean expression and executes the `then-statement`. At any given time, either
    the `then-statements` or the `else-statements` of an `if-else` statement will
    be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a few examples. In the following code block, we have already
    set the condition variable to `true`, so when the Boolean expression in the if
    statement is evaluated, it returns `true` and the code block (`then-statement`)
    is executed. `Else-statement` is ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following scenario, if the statement doesn''t include the else part,
    when the Boolean expression is evaluated to `true`, `then-statements` is executed
    by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: C# also allows nested `if` and nested `else` statements. In the following code,
    we will see how nested if statements can be used in a program.
  prefs: []
  type: TYPE_NORMAL
- en: 'When condition `1` is evaluated to `true`, by default, the then-statements
    of condition `1` are executed. Similarly, when condition `2` is evaluated to `true`,
    the then-statements of condition `2` are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define a nested if in an `Else` statement. For example, the user
    wants to find out whether the character that was entered was a vowel and, if so,
    to print it. The following code block illustrates how multiple if statements can
    be used. The program checks if the entered character is a vowel or not and prints
    the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: switch..case..default
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The switch statement evaluates an expression against a condition or multiple
    conditions and executes a labeled code block. These labeled code blocks are called
    switch labels. Each switch label is followed by a break statement which helps
    the program come out of the loop and move on to the next statement. In the preceding
    example, where we checked for vowels using the `if...else` statement, we used
    `if...else` for each vowel and a default value for any other character. This can
    be further simplified using a `switch...case...default` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we want is to have a condition expression check the character. If it matches
    any of the matching expressions, that is, a vowel, it prints the vowel; otherwise,
    it prints that it is not a vowel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: break
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C#, the `break;` statement allows us to break a loop or a block of statements
    where it is enclosed. For example, in a recursive function, you might need to
    break after n number of iterations. Alternatively, in an example where you want
    to print the first `5` numbers in a loop of `10` iterations, you will want to
    use the break statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: goto
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Goto` statements allow the program to transfer control to a specific section
    or code block. This is also called a labeled statement. The classic example is
    the `Switch..case` statement, which we discussed in the previous section. When
    an expression matches a case, the labeled criteria statements in that code block
    are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: continue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `continue;` statement allows the program to skip the execution of statements
    until the end of that code block and continues with the next iteration. For example,
    in a `for` loop of `1..10`, if the continue statement is placed within an expression,
    that is, `i <= 5`, it looks at all 10 numbers, but the action will only be performed
    on 6, 7, 8, 9, and 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Iteration statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Iteration statements help execute a loop for a specific number of times or while
    a conditional expression is met. All of the statements in a code block are executed
    in sequence when a loop initiates. If the program encounters a `jump statement`
    or `continue statement`, the execution flow is altered for that scenario. In the
    case of `go-to`, control moves to the labeled code block and, in the case of `continue
    statement`, the loop ignores all of the statements after `continue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the keywords that are used in C# when an iteration or a loop
    is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '`do`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foreach...in`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: do...while
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `do` statement is always used along with a `while` statement. The `do` statement
    executes a code block and evaluates the `while` expression. If the `while` statement
    evaluates to `true`, the code block is executed again. This continues as long
    as `while` evaluates to `true`. Because the condition expression is evaluated
    after the code block is executed, `do...while` always executes the code block
    at least once.
  prefs: []
  type: TYPE_NORMAL
- en: '`break;`, `continue;`, `return`, or `throw` can be used to come out of this
    loop any time during execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike `do..while`, `for` evaluates the condition expression first and if `true`,
    executes the code block. The code block will not be executed once unless the condition
    is true. Similar to `do..while`, we can come out of the loop using the `return`,
    `throw`, `goto`, or `continue` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following `for` statement''s structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The initializer, condition, and iterator are all optional. The body can be
    one statement or an entire code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Initializer section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section is executed only once. When the program''s control encounters
    a `for` loop, the initialization section is triggered. `#` allows one or more
    of the following statements in the initializer section of the `for` loop, separated
    by a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaration of the local loop variable. This is not available outside of the
    loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An assignment statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method invocation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pre/post increment or decrement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New object creation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Await expression. We will look at this in more detail in the upcoming chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Condition section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier, this is an optional section. If it's not provided,
    by default, it is evaluated as `true`. If it is provided, the condition expression
    is evaluated before executing every iteration. If the condition evaluates to `false`,
    the loop is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The iteration section defines what happens to the body of the loop. As detailed
    in the *Initializer section* section, it can contain one or more of the aforementioned
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of rare usage for statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an example for your reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: foreach...in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Foreach` is applicable to instances of the `IEnumerable` type or Generic collections.
    This works similar to the `for` loop. `Foreach` is not just limited to these types;
    it can also be applied to any instance that implements the `GetEnumerator` method
    without parameters and returns a class, struct, or interface type. `Foreach` can
    also be applied to types that are returned by the `Current` property of `GetEnumerator`
    and parameter less `MoveNext` methods, which return a bool value.'
  prefs: []
  type: TYPE_NORMAL
- en: From C# 7.3 onward, the `Current` property returns a reference to the return
    value (`ref T`), where `T` is of the collection element type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we declare the list of strings and would like to
    iterate through the list and display every item on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`IEnumerator` has a property called `Current` and a method called `MoveNext`.
    As the `foreach` loop works to iterate the throw collections that implement these
    two, it keeps track of which item in the collection is currently being evaluated
    and processed. This makes sure that control is not passed through the end of the
    collection. Also, the `foreach` loop doesn''t allow the user to make changes to
    the initialized loop variable but does allow them to modify the value in the object
    that''s referred to in the variable.'
  prefs: []
  type: TYPE_NORMAL
- en: while
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the `for` loop, a condition is evaluated before we execute the code
    block. This means that the code block is either executed more than once or not
    executed at all. Just like any other loop, you can come out of the loop using
    the `break`, `continue`, `return`, or `throw` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at Unary operators, relational operators, shift operators,
    and equality, conditional, and logical operators, which can be used with one or
    two operands and evaluated as boolean expressions using logical and conditional
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at conditional statements and selective statements, which help us
    make decisions. Some examples of these are the if condition, then statements,
    and else statements. Switch...case...default helps match multiple expressions
    and execute multiple switch labels.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at iteration statements, which allow users to loop through a
    collection. When they're used with jump statements such as `goto`, `continue`,
    and so on, they can exit from the loop.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into delegates and events in detail. Delegates
    and events play a major role in C# programming. Being able to call back delegates
    for the base for events allows us to decouple our program. We will also understand
    Lambda expressions, which can be used to create delegates. These are also called
    **anonymous** methods.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have a scenario where you are evaluating a lot of conditions. In one particular
    scenario, you want both operands to be evaluated and, if true, execute the code
    block. Which one of the following statements would you use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`&&`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`||`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`&`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`^`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You are using a `for` loop in your code and want to execute a specific code
    block if a condition is met. Which one of the following statements would you use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`break;`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`continue;`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`throw;`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`goto;`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In your program, there is a code block that you want to execute at least once
    and execute until the condition evaluates to true. Which of the following statements
    would you use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`While;`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Do...while;`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`For;`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`foreach;`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**c**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**d**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**b**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information on statements, expressions, and operators can be found at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/).
  prefs: []
  type: TYPE_NORMAL
- en: There is a video available on the Packt Publishing site that's helpful as well.
    It's called *Programming in C# .NET* ([https://search.packtpub.com/?query=70-483&refinementList%5Breleased%5D%5B0%5D=Available](https://search.packtpub.com/?query=70-483&refinementList%5Breleased%5D%5B0%5D=Available)).
  prefs: []
  type: TYPE_NORMAL
