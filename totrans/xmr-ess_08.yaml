- en: Chapter 8. Sharing with Xamarin.Forms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章. 使用 Xamarin.Forms 进行共享
- en: 'In this chapter, we will discuss Xamarin.Forms, a cross-platform development
    framework. With this in mind, we will cover the following areas:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 Xamarin.Forms，这是一个跨平台开发框架。考虑到这一点，我们将涵盖以下领域：
- en: Pages, Views (Controls), and Layouts
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面、视图（控件）和布局
- en: Navigation in Xamarin.Forms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Xamarin.Forms 中的导航
- en: XAML and code-behind classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XAML 和代码后置类
- en: Data binding
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据绑定
- en: Renderers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染器
- en: The `DependencyService` API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DependencyService` API'
- en: App startup
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序启动
- en: Project organization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目组织
- en: Converting the `NationalParks` app to use Xamarin.Forms
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `NationalParks` 应用程序转换为使用 Xamarin.Forms
- en: An insight into the Xamarin.Forms framework
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对 Xamarin.Forms 框架的深入了解
- en: The Xamarin.Forms framework can be used to develop mobile apps for Android,
    iOS, and Windows Phone. It uses virtually the same source code base for each platform
    while still providing a platform-specific look and feel. Xamarin.Forms is available
    for use from any of the paid licenses available at Xamarin or from the 30-day
    evaluation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms 框架可用于为 Android、iOS 和 Windows Phone 开发移动应用程序。它为每个平台使用几乎相同的源代码库，同时仍然提供特定于平台的外观和感觉。Xamarin.Forms
    可从 Xamarin 的任何付费许可证或 30 天评估版中使用。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: While we mention that Xamarin.Forms apps can run on Windows Phone, the licensing,
    configuration, and development details for Windows Phone are beyond the scope
    of this book.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们提到 Xamarin.Forms 应用程序可以在 Windows Phone 上运行，但 Windows Phone 的许可、配置和开发细节超出了本书的范围。
- en: Unlike the approaches described previously in this book, Xamarin.Forms provides
    you with a set of abstractions that cover the entire user interface, thus allowing
    the UI code and specification to be reused across multiple platforms. At runtime,
    Xamarin.Forms renders user interfaces using Controls that are native to each platform,
    which allows apps to retain a native look and feel.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书之前描述的方法不同，Xamarin.Forms 为您提供了一套抽象，涵盖了整个用户界面，从而允许 UI 代码和规范在多个平台之间重用。在运行时，Xamarin.Forms
    使用每个平台本地的控件来渲染用户界面，这使得应用程序能够保持本地的外观和感觉。
- en: 'This chapter is divided into two main sections: in the first section, we cover
    the core concepts that need to be understood prior to using Xamarin.Forms, and
    in the second section, we will convert our `NationalParks` app to use the Xamarin.Forms
    framework.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为两个主要部分：在第一部分，我们介绍在使用 Xamarin.Forms 之前需要理解的核心概念；在第二部分，我们将把我们的 `NationalParks`
    应用程序转换为使用 Xamarin.Forms 框架。
- en: Pages
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 页面
- en: 'A **Page** is a visual element that organizes the content a user sees on the
    screen at a single time. A Xamarin.Forms Page is essentially similar to an Android
    activity or an iOS View controller. Xamarin.Forms provides the following base
    Pages for use in your apps, where you can find a description accompanied with
    each type:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**页面**是一个视觉元素，用于组织用户在屏幕上一次性看到的全部内容。Xamarin.Forms 页面本质上类似于 Android 活动或 iOS 视图控制器。Xamarin.Forms
    为您的应用程序提供了以下基本页面，其中每个类型都有相应的描述：'
- en: '| Type | Description |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ContentPage` | This allows you to organize a set of Controls, or Views,
    into a Layout for display and interaction with the user |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `ContentPage` | 这允许您将一组控件或视图组织成布局以供显示和与用户交互 |'
- en: '| `MasterDetailPage` | This manages two pages—a master and a detail page—and
    the navigation between them |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `MasterDetailPage` | 这管理两个页面——主页面和详细页面——以及它们之间的导航 |'
- en: '| `NavigationPage` | This manages navigation over a set of other pages |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `NavigationPage` | 这管理一组其他页面的导航 |'
- en: '| `TabbedPage` | This manages a set of child pages and allows you to navigate
    via tabs |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `TabbedPage` | 这管理一组子页面，并允许您通过标签进行导航 |'
- en: '| `CarouselPage` | This manages a set of child pages and allows you to navigate
    via swipe |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `CarouselPage` | 这管理一组子页面，并允许您通过滑动进行导航 |'
- en: Views
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: 'A **View** is a visual control (or widget) that presents information and allows
    the user to interact with your app (things such as buttons, labels, and edit boxes).
    These controls generally inherit properties from the `View` class. The following
    table represents the list of Views provided by Xamarin.Forms at the time of writing
    this book:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图**是一个视觉控件（或小部件），用于展示信息并允许用户与您的应用程序交互（如按钮、标签和编辑框等）。这些控件通常继承自 `View` 类。以下表格表示了在撰写本书时
    Xamarin.Forms 提供的视图列表：'
- en: '| `ActivityIndicator` | `BoxView` | `Button` | `DatePicker` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `ActivityIndicator` | `BoxView` | `Button` | `DatePicker` |'
- en: '| `Editor` | `Entry` | `Image` | `Label` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `Editor` | `Entry` | `Image` | `Label` |'
- en: '| `ListView` | `OpenGLView` | `Picker` | `ProgressBar` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `ListView` | `OpenGLView` | `Picker` | `ProgressBar` |'
- en: '| `SearchBar` | `Slider` | `Stepper` | `Switch` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `SearchBar` | `Slider` | `Stepper` | `Switch` |'
- en: '| `TableView` | `TimePicker` | `WebView` |   |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `TableView` | `TimePicker` | `WebView` |   |'
- en: Layouts
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局
- en: 'Controls are hosted within a special type of View called a **Layout**. There
    are two different types of Layouts: managed and unmanaged. Managed Layouts are
    responsible for arranging their hosted Controls, and unmanaged Layouts require
    the developer to specify how controls should be arranged. Xamarin.Forms provides
    the following Layouts:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 控件托管在一种特殊类型的View中，称为**布局**。有两种不同类型的布局：托管和非托管。托管布局负责安排其托管的控件，而非托管布局需要开发者指定控件应该如何排列。Xamarin.Forms提供了以下布局：
- en: '| Layout | Description |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 布局 | 描述 |'
- en: '| --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ContentView` | This is a Layout that can contain child views. Generally,
    `ContentView` is not used directly, but is used as a base for other layouts. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `ContentView` | 这是一个可以包含子视图的布局。通常，`ContentView`不直接使用，而是用作其他布局的基础。|'
- en: '| `Frame` | This is a Layout that can contain a single child view and provide
    framing options such as padding. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `Frame` | 这是一个可以包含单个子视图并提供填充等框架选项的布局。|'
- en: '| `ScrollView` | This Layout is capable of scrolling its child views. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `ScrollView` | 这个布局能够滚动其子视图。|'
- en: '| `AbsoluteLayout` | This Layout allows it''s child views to be positioned
    by absolute positions as requested by the app. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `AbsoluteLayout` | 这个布局允许其子视图根据应用程序的要求通过绝对位置进行定位。|'
- en: '| `Grid` | This Layout allows content to be displayed in rows and columns.
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `Grid` | 这个布局允许内容在行和列中显示。|'
- en: '| `RelativeLayout` | This Layout positions views relative to other views it
    owns by use of constraints. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `RelativeLayout` | 这个布局通过使用约束将视图相对于它拥有的其他视图进行定位。|'
- en: '| `StackLayout` | This Layout positions views horizontally or vertically in
    a single line. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `StackLayout` | 这个布局将视图水平或垂直地放置在单行中。|'
- en: Cells
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元格
- en: A **Cell** is a special type of Control used to arrange information in a list;
    specifically, `ListView` or `TableView`. Cells derive from the `Element` class
    rather than the `VisualElement` class and act as a template to create `VisualElements`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元格**是一种特殊的控件，用于在列表中排列信息；具体来说，是`ListView`或`TableView`。单元格从`Element`类派生，而不是从`VisualElement`类派生，并作为模板来创建`VisualElements`。'
- en: 'Xamarin.Forms provides the following types of Cells:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms提供了以下类型的Cells：
- en: '| Cell type | Description |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 单元格类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `EntryCell` | This is a Cell with a label and single text entry field. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `EntryCell` | 这是一个带有标签和单个文本输入字段的Cell。|'
- en: '| `SwitchCell` | This is a Cell with a label and switch view (on/off). |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `SwitchCell` | 这是一个带有标签和开关视图（开/关）的Cell。|'
- en: '| `TextCell` | This is a Cell with primary and secondary text. Generally, the
    primary text is used as a title and the secondary text as a subtitle. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `TextCell` | 这是一个带有主文本和次文本的Cell。通常，主文本用作标题，次文本用作副标题。|'
- en: '| `ImageCell` | This is a `TextCell` that also includes an image. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `ImageCell` | 这是一个包含图像的`TextCell`。|'
- en: Navigation
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航
- en: '**Navigation** in a Xamarin.Forms app is accomplished with the use of the navigation
    property of `VisualElement`. This is generally accessed via a Page. The navigation
    property is typed as the `INavigation` interface, which provides the following
    methods:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin.Forms应用程序中，**导航**是通过使用`VisualElement`的导航属性来实现的。这通常通过页面访问，导航属性的类型为`INavigation`接口，它提供了以下方法：
- en: '| Type | Description |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `PushAsync()` | This method pushes a Page on the navigation stack |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `PushAsync()` | 此方法将页面推送到导航堆栈 |'
- en: '| `PushModalAsync()` | This method pushes a Page on the navigation stack as
    a modal dialog |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `PushModalAsync()` | 此方法将页面推送到导航堆栈作为模态对话框 |'
- en: '| `PopAsync()` | This method pops the current Page off the navigation stack
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `PopAsync()` | 此方法从导航堆栈中移除当前页面 |'
- en: '| `PopModalAsync()` | This method pops the current modal Page off the navigation
    stack |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `PopModalAsync()` | 此方法从导航堆栈中移除当前模态页面 |'
- en: '| `PopToRootAsync()` | This method pops all the Pages off the navigation stack,
    except the root Page |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `PopToRootAsync()` | 此方法从导航堆栈中移除所有页面，除了根页面 |'
- en: 'The beauty of navigation in Xamarin.Forms lies in its simplicity. To navigate
    to a new Page and pass data into the new Page, all you need to do is create an
    instance of the new Page passing the data in the constructor and then push this
    Page on the navigation stack, as demonstrated by the following sample code snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin.Forms中，导航的美丽之处在于其简单性。要导航到新页面并将数据传递到新页面，你只需要创建一个新页面的实例，在构造函数中传递数据，然后将此页面推送到导航堆栈，如下面的代码示例所示：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Defining Xamarin.Forms user interfaces
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义Xamarin.Forms用户界面
- en: 'Like many UI frameworks, Xamarin.Forms allows two different approaches to create
    user interfaces: declarative and programmatic:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如同许多UI框架一样，Xamarin.Forms允许两种不同的方法来创建用户界面：声明性和程序化：
- en: '**Programmatic approach**: When using this approach, the developers embed API
    calls to construct a UI, and control the size and placement'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序化方法**：当使用这种方法时，开发者将API调用嵌入到构建UI中，并控制大小和位置'
- en: '**Declarative approach**: When using this approach, the developers create XAML
    files that define the content and layout for a user interface'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明性方法**：当使用这种方法时，开发者创建XAML文件来定义用户界面的内容和布局'
- en: Extensible Application Markup Language (XAML)
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可扩展应用程序标记语言 (XAML)
- en: '**Extensible Application Markup Language** (**XAML**) is an XML-based language
    developed by Microsoft. XAML allows developers to use XML to specify a hierarchy
    of objects to instantiate. It can be used in a number of ways, but most successfully
    as a means to specify user''s interfaces in **Windows Presentation Foundation**
    (**WPF**), Silverlight, Windows Runtime, and now Xamarin.Forms.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展应用程序标记语言**（**XAML**）是由微软开发的一种基于XML的语言。XAML允许开发者使用XML来指定要实例化的对象层次结构。它可以以多种方式使用，但最成功的是作为指定**Windows
    Presentation Foundation**（**WPF**）、Silverlight、Windows Runtime和现在Xamarin.Forms用户界面的手段。'
- en: XAML files are parsed at build time to verify objects that have been specified
    and at runtime to instantiate the hierarchy of objects.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: XAML文件在构建时解析以验证指定的对象，并在运行时实例化对象层次结构。
- en: In addition to specifying a hierarchy of objects, XAML also allows developers
    to specify property values and assign event handlers. However, it does not allow
    you to embed code or logic.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指定对象层次结构外，XAML还允许开发者指定属性值和分配事件处理器。但是，它不允许你嵌入代码或逻辑。
- en: 'The following XAML file defines the content for a `ContentPage` view:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下XAML文件定义了`ContentPage`视图的内容：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Take a look at the previous XAML specification:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下之前的XAML规范：
- en: The class name is `ParkEditPage` and is specified in the `ContentPage` element
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名为`ParkEditPage`，并在`ContentPage`元素中指定
- en: A `Grid` Layout is used to organize the content in the Page
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Grid`布局来组织页面中的内容
- en: Two components are assigned property names, `nameEntry` and `doneButton`
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个组件被分配了属性名称，`nameEntry`和`doneButton`
- en: The `doneButton` component is assigned a `Clicked` event handler named `DoneClicked`
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doneButton`组件被分配了一个名为`DoneClicked`的`Clicked`事件处理器'
- en: Code-behind classes
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码后置类
- en: 'When you create a Page in a Xamarin.Forms app, two files are actually created:
    an XAML file and a class file. Xamarin Studio nests the class files under the
    XAML files in the **Solution** pad, as shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Xamarin.Forms应用程序中创建一个页面时，实际上会创建两个文件：一个XAML文件和一个类文件。Xamarin Studio将类文件嵌套在XAML文件下的**解决方案**面板中，如下面的截图所示：
- en: '![Code-behind classes](img/0838OT_08_01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![代码后置类](img/0838OT_08_01.jpg)'
- en: 'The `.xaml.cs` files are sometimes referred to as code-behind classes. They
    are created to contain all the app logic in event handlers that go hand in hand
    with the Page definition. The following example shows the code-behind class for
    `ParkEditPage`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`.xaml.cs`文件有时被称为代码后置类。它们被创建来包含所有与页面定义一起使用的应用程序逻辑的事件处理器。以下示例显示了`ParkEditPage`的代码后置类：'
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should take note of the following aspects of the class definition:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意以下类定义的方面：
- en: '`ParkEditPage` is a partial class definition.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParkEditPage`是一个部分类定义。'
- en: The `DoneClicked()` event handler is defined within this class file. This is
    the event handler that was assigned to the `Done` button in XAML.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoneClicked()`事件处理器定义在这个类文件中。这是分配给XAML中`Done`按钮的事件处理器。'
- en: There are no property definitions defined in the earlier file.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在早期文件中没有定义属性定义。
- en: 'So, where are the property definitions? Xamarin Studio generates a second code
    file each time the app is built. For our example, the file will be named `ParkEditPage.xaml.g.cs`
    and will contain the following code snippet:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，属性定义在哪里呢？每次构建应用程序时，Xamarin Studio都会生成第二个代码文件。对于我们的示例，文件将被命名为`ParkEditPage.xaml.g.cs`，并将包含以下代码片段：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should take note of the following points here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意以下几点：
- en: 'There are two properties defined on the `ParkEditPage` file: `nameEntry` and
    `doneButton`. These are generated directly from the names found in the XAML file.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ParkEditPage`文件上定义了两个属性：`nameEntry`和`doneButton`。这些属性直接从XAML文件中找到的名称生成。
- en: A method named `InitializeComponent()` is generated. This method must be called
    from any constructors defined in `ParkEditPage.xaml.cs`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成一个名为`InitializeComponent()`的方法。该方法必须从`ParkEditPage.xaml.cs`中定义的任何构造函数中调用。
- en: The `InitializeComponent()` method calls `LoadFromXaml()` to instantiate all
    the objects defined by `ParkEditPage.xaml`.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InitializeComponent()`方法调用`LoadFromXaml()`来实例化由`ParkEditPage.xaml`定义的所有对象。'
- en: The `InitializeComponent()` method calls `FindByName()` to bind each property
    to its corresponding instance.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InitializeComponent()`方法调用`FindByName()`将每个属性绑定到其对应的实例。'
- en: Data binding
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据绑定
- en: The concepts behind data binding are covered in detail in [Chapter 7](ch07.html
    "Chapter 7. Sharing with MvvmCross"), *Sharing with MvvmCross*, under the section
    titled *Data binding*. Xamarin.Forms provides a data binding capability that follows
    the same architecture as MvvmCross, **Windows** **Presentation Foundation** (**WPF**),
    Silverlight, and Windows Runtime.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定的概念在[第7章](ch07.html "第7章。与MvvmCross共享")“与MvvmCross共享”部分中详细讨论，该部分标题为“数据绑定”。Xamarin.Forms提供了一个遵循与MvvmCross、**Windows**
    **Presentation Foundation** (**WPF**)、Silverlight和Windows Runtime相同架构的数据绑定功能。
- en: 'Within a Xamarin.Forms app, binding specifications are generally specified
    in XAML. The following XAML specification demonstrates binding the `Text` property
    of an `Entry` control to the `Name` property of a `NationalPark` object:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin.Forms应用程序中，绑定规范通常在XAML中指定。以下XAML规范演示了将`Entry`控制的`Text`属性绑定到`NationalPark`对象的`Name`属性：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Generally, the binding context is set with code. The following example demonstrates
    how to programmatically set the binding context at a Page level to a `NationalPark`
    object:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，绑定上下文通过代码设置。以下示例演示了如何在页面级别通过编程方式设置绑定上下文为`NationalPark`对象：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the previous example, the binding context was set for an entire Page. Sometimes,
    Controls provide a binding context that needs to be set to accomplish data binding.
    The following example demonstrates setting the binding context for a `ListView`
    control:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，为整个页面设置了绑定上下文。有时，控件提供了需要设置的绑定上下文以完成数据绑定。以下示例演示了设置`ListView`控制的绑定上下文：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the binding context for the `ListView` control is a property named
    `ItemsSource`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ListView`控制的绑定上下文是一个名为`ItemsSource`的属性。
- en: Using Renderers
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Renderer
- en: Xamarin.Forms uses platform-native controls to render user interfaces that allow
    apps to maintain a look and feel that the users would expect for each platform.
    This is accomplished with the use of Renderers. Pages, Layouts, and Controls represent
    the set of abstractions used to describe a user interface. Each of these elements
    is rendered using a `Renderer` class, which in turn creates a native control based
    on the platform the app is running on.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms使用平台原生控件来渲染用户界面，这使得应用程序能够保持用户对每个平台预期的外观和感觉。这是通过使用Renderer实现的。页面、布局和控制代表用于描述用户界面的抽象集合。这些元素中的每一个都是使用`Renderer`类渲染的，该类根据应用程序运行的平台创建一个原生控件。
- en: Developers can create their own Renderers in order to customize the way a particular
    Control is rendered on a platform.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以创建自己的Renderer以自定义特定控件在平台上的渲染方式。
- en: Native features and the DependencyService API
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原生特性和DependencyService API
- en: Until now, we have primarily focused on working with abstractions that can be
    reused across all platforms. What if you need access to platform-specific capabilities?
    That's where the `DependencyService` API comes in. The `DependencyService` API
    is an API that allows each platform to register a platform-specific service that
    can be called by shared code through a common interface.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要关注的是使用可以在所有平台上重用的抽象。那么，如果你需要访问特定平台的特定功能呢？这就是`DependencyService` API的用武之地。`DependencyService`
    API是一个允许每个平台注册一个特定于平台的服务的API，该服务可以通过一个公共接口被共享代码调用。
- en: 'Using the `DependencyService` API involves the following three steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DependencyService` API涉及以下三个步骤：
- en: Firstly, you need to create an interface that exposes the platform-specific
    methods that must be implemented for each platform the app will run on.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要创建一个接口，该接口公开了必须为每个平台实现的平台特定方法。
- en: After this step, create an implementation of the interface for each platform
    and register the implementation using an `assembly` attribute.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此步骤之后，为每个平台创建接口的实现，并使用`assembly`属性注册实现。
- en: To conclude, call `DependencyService.Get<MyInterface>` from the shared code
    to look up the appropriate implementation and invoke services on the returned
    instance.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总结来说，从共享代码中调用`DependencyService.Get<MyInterface>`以查找适当的实现并调用返回实例上的服务。
- en: We will demonstrate the use of the `DependencyService` API later in this chapter
    in the section titled *Adding calls to DependencyService*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的*添加对DependencyService的调用*部分稍后演示`DependencyService` API的使用。
- en: App startup
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用启动
- en: 'Xamarin.Forms apps start up as native apps, meaning the traditional startup
    sequence is followed. During the startup sequence, an app performs the following
    two tasks:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms应用以原生应用的方式启动，这意味着遵循传统的启动序列。在启动序列中，应用执行以下两个任务：
- en: Make a call to initialize the Xamarin.Forms runtime.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用初始化Xamarin.Forms运行时的方法。
- en: Start the first Page.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动第一个页面。
- en: Shared App classes
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享应用类
- en: 'By default, Xamarin.Forms apps have a shared `App` class created, which contains
    a single static method that returns the first Page that should be presented when
    an app starts up. The following code demonstrates this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Xamarin.Forms应用会创建一个共享的`App`类，其中包含一个返回当应用启动时应展示的第一个页面的单个静态方法。以下代码演示了这一点：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This simple approach allows the platform-specific startup code in each app to
    call the `GetMainPage()` method in order to determine which Page to start with.
    Therefore, it is only specified at one place.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的方法允许每个应用的特定平台启动代码调用`GetMainPage()`方法以确定要启动哪个页面。因此，它只在一个地方指定。
- en: iOS apps
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: iOS应用
- en: 'In a Xamarin.Forms iOS app, initialization is performed in the `FinishedLaunching()`
    method of the `AppDelegate` class, as shown in the following sample demonstration:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个Xamarin.Forms iOS应用中，初始化是在`AppDelegate`类的`FinishedLaunching()`方法中执行的，如下所示：
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Android apps
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安卓应用
- en: 'In a Xamarin.Forms Android app, initialization is done in the `Activity` instance
    marked with the `MainLauncher=true` attribute. This is shown in the following
    sample code snippet:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个Xamarin.Forms安卓应用中，初始化是在带有`MainLauncher=true`属性的`Activity`实例中完成的。这可以在以下代码片段中看到：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Project organization
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目组织
- en: 'Xamarin.Forms projects are generally created using one of the following two
    project templates, which can be found by navigating to **C#** | **Mobile Apps**
    of the **New Solution** dialog box:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms项目通常使用以下两种项目模板之一创建，可以通过导航到“**新建解决方案**”对话框中的**C#** | **移动应用**来找到：
- en: '**Blank App (Xamarin.Forms Potable)**'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空白应用 (Xamarin.Forms 可移植)**'
- en: '**Blank App (Xamarin.Forms Shared)**'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空白应用 (Xamarin.Forms 共享)**'
- en: The difference between these two templates is the type of project created to
    house the shared code. Using the first template, shared code is housed in a Portable
    Class Library, and using the second template, shared code is housed in a shared
    project. Shared projects allow all referencing projects to reuse the code it contains,
    but the code is compiled specifically for each referencing project.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种模板之间的区别是用于存放共享代码的项目类型。使用第一个模板，共享代码存放在可移植类库中，而使用第二个模板，共享代码存放在共享项目中。共享项目允许所有引用项目重用其包含的代码，但代码是针对每个引用项目特定编译的。
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you plan to add a Windows Phone project to the solution at some point, you
    will be well versed to go with the PCL solution. It will require you to work within
    the restrictions of a PCL, but will ensure your code is compatible with more platforms.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划在某个时候将Windows Phone项目添加到解决方案中，你将熟悉使用PCL解决方案。这将要求你在PCL的限制内工作，但将确保你的代码与更多平台兼容。
- en: 'After creating a Xamarin.Forms solution, you will see that three actual projects
    were created. The first project contains the shared code, the second project contains
    the iOS code, and the third project contains the Android code. If we are successful
    with Xamarin.Forms, the bulk of the code will end up in the shared project. The
    following screenshot shows an example of a project created with the PCL template:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个Xamarin.Forms解决方案后，你会看到创建了三个实际的项目。第一个项目包含共享代码，第二个项目包含iOS代码，第三个项目包含安卓代码。如果我们成功使用Xamarin.Forms，大部分代码将最终位于共享项目中。以下截图显示了使用PCL模板创建的项目示例：
- en: '![Project organization](img/0838OT_08_02.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![项目组织](img/0838OT_08_02.jpg)'
- en: Creating the NationalParks Xamarin.Forms app
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建NationalParks的Xamarin.Forms应用
- en: Now that we have a solid understanding of Xamarin.Forms, let's convert our `NationalParks`
    app to use the new framework. For this exercise, we will follow the same app flow
    that we have used in the iOS app so far, meaning that we will have a list page,
    a detail page to view, and an edit page to add and update.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对Xamarin.Forms有了坚实的理解，让我们将`NationalParks`应用程序转换为使用新框架。在这个练习中，我们将遵循迄今为止在iOS应用程序中使用的相同应用程序流程，这意味着我们将有一个列表页面、一个用于查看的详细页面以及一个用于添加和更新的编辑页面。
- en: Creating the solution
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建解决方案
- en: 'We will start by creating an entirely new project by performing the following
    steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过以下步骤创建一个全新的项目：
- en: To start with, access the **File** menu and navigate to **New** | **New Solution**.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，访问**文件**菜单并导航到**新建** | **新建解决方案**。
- en: In the **New Solution** dialog box, navigate to **C#** | **Mobile Apps**, select
    the **Blank App (Xamarin.Forms Portable)** template, enter `NationalParks` in
    the **Name** field, choose the appropriate **Location** value, and click on **OK**.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新建解决方案**对话框中，导航到**C#** | **移动应用**，选择**空白应用（Xamarin.Forms Portable）**模板，在**名称**字段中输入`NationalParks`，选择合适的**位置**值，然后点击**确定**。
- en: 'Review the project structure. You will see the following pointers:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查项目结构。您将看到以下提示：
- en: Open `AppDelegate.cs` in the `NationalParks.iOS` project. Note the calls to
    `Forms.Init()` and `App.GetMainPage()`.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`NationalParks.iOS`项目中打开`AppDelegate.cs`。注意对`Forms.Init()`和`App.GetMainPage()`的调用。
- en: Open `MainActivity.cs` in the `NationalParks.Android` project. Note the calls
    to `Forms.Init()` and `App.GetMainPage()`.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`NationalParks.Android`项目中打开`MainActivity.cs`。注意对`Forms.Init()`和`App.GetMainPage()`的调用。
- en: Open `App.cs` in the `NationalParks` project. Note the static method, `GetMainPage()`.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`NationalParks`项目中打开`App.cs`。注意静态方法`GetMainPage()`。
- en: To finish, run the `NationalParks.Android` and `NationalParks.iOS` projects.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行`NationalParks.Android`和`NationalParks.iOS`项目。
- en: Adding NationalParks.PortableData
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加NationalParks.PortableData
- en: 'Our next step is to bring in the storage solution from [Chapter 7](ch07.html
    "Chapter 7. Sharing with MvvmCross"), *Sharing with MvvmCross*. Perform the following
    steps to add the storage solution to our new Xamarin.Forms solutions:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是将第7章中的存储解决方案[分享与MvvmCross](ch07.html "第7章。与MvvmCross分享")引入。按照以下步骤将存储解决方案添加到我们的新Xamarin.Forms解决方案中：
- en: Firstly, you need to copy the `NationalParks.PortableData` and `NationalParks.IO`
    projects from the solution folder of [Chapter 7](ch07.html "Chapter 7. Sharing
    with MvvmCross"), *Sharing with MvvmCross*, to the new solution folder.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要将[第7章](ch07.html "第7章。与MvvmCross分享")中的`NationalParks.PortableData`和`NationalParks.IO`项目从解决方案文件夹复制到新的解决方案文件夹中。
- en: Add each project to the new solution folder by selecting the solution, right-clicking
    on it, navigating to **Add** | **Add Existing Project**, and selecting the project
    file, for example, `NationalParks.IO.csproj`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个项目添加到新的解决方案文件夹中，方法是选择解决方案，右键单击它，导航到**添加** | **添加现有项目**，然后选择项目文件，例如，`NationalParks.IO.csproj`。
- en: Add the `NationalParks.PortableData` project to the new `NationalParks`, `NationalParks.Android`,
    and `NationalParks.iOS` projects as a reference by selecting the `References`
    folder in each of the projects, right-clicking on them, choosing **Edit References**,
    and selecting `NationalParks.PortableData`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择每个项目的**引用**文件夹，右键单击它们，选择**编辑引用**，并将`NationalParks.PortableData`项目作为引用添加到新的`NationalParks`、`NationalParks.Android`和`NationalParks.iOS`项目中。
- en: We now need to add a link to the `FileHandler.cs` file to both the `NationalParks.Android`
    and `NationalParks.iOS` projects. For each project, create a new folder named
    `NationalParks.IO` and add a link to `FileHandler.cs` by selecting the new folder,
    right-clicking on it, navigating to **Add** | **Add Files**, selecting `FileHandler`,
    choosing **Open**, selecting **Add a link to the file**, and clicking on **OK**.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将`FileHandler.cs`文件链接添加到`NationalParks.Android`和`NationalParks.iOS`项目中。对于每个项目，创建一个名为`NationalParks.IO`的新文件夹，并选择新文件夹，右键单击它，导航到**添加**
    | **添加文件**，选择`FileHandler`，选择**打开**，选择**添加文件链接**，然后点击**确定**。
- en: To verify all of the previous steps, you should compile the new solution.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证所有之前的步骤，您应该编译新的解决方案。
- en: Implementing ParksListPage
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现ParksListPage
- en: 'We can now begin work on the user interface starting with a list view to display
    the parks by performing the following steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始工作于用户界面，从显示公园的列表视图开始，按照以下步骤操作：
- en: Select the `NationalParks` project, right-click on it, and navigate to **Add**
    | **New File**. From the **New File** dialog box, navigate to **Forms** | **Forms
    ContentPage Xaml**, enter `ParksListPage` for the **Name** field, and choose **New**.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`NationalParks`项目，右键单击它，然后导航到**添加** | **新建文件**。从**新建文件**对话框中，导航到**表单** | **表单内容页XAML**，在**名称**字段中输入`ParksListPage`，然后选择**新建**。
- en: 'You should now open `ParkListPage.xaml`. You will see an empty `ContentPage`
    element. Add `StackLayout`, which is vertically oriented, with a child `ListView`
    and `Button` instances, as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你应该打开`ParkListPage.xaml`。你会看到一个空的`ContentPage`元素。添加一个垂直方向的`StackLayout`，其中包含一个`ListView`实例和一个`Button`实例，如下所示：
- en: '[PRE10]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Take note of the `ParkSelected` event handler for `parkListView` and the `NewClicked`
    event handler for the `New` button.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`parkListView`的`ParkSelected`事件处理程序和`New`按钮的`NewClicked`事件处理程序。
- en: 'Now, let''s add the row definitions for `ListView`. The `ListView` element
    has a `DataTemplate` property that defines a layout for each row. The following
    Layout should define a label for the name and description of the park. This should
    be placed within the `ListView` element of the XAML:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为`ListView`添加行定义。`ListView`元素有一个`DataTemplate`属性，它定义了每一行的布局。以下布局应定义一个标签，用于显示公园的名称和描述。这应该放置在XAML中的`ListView`元素内：
- en: '[PRE11]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note the binding specifications for the two Label views.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意两个`Label`视图的绑定规范。
- en: 'Open `App.cs` in the `NationalParks` project and change the main page to `ParksListPage`.
    We also need to create `NavigationPage` as the owner of `ParksListPage` to support
    push and pop navigation. The `GetMainPage()` method should contain the following
    code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NationalParks`项目中打开`App.cs`，将主页面更改为`ParksListPage`。我们还需要创建`NavigationPage`作为`ParksListPage`的所有者以支持推送和弹出导航。`GetMainPage()`方法应包含以下代码：
- en: '[PRE12]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Open `AppDelegate.cs` in the `NationalParks.iOS` project. You should then add
    the following initialization of code to the `FinishedLaunching()` method just
    before the `Forms.Init()` call:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NationalParks.iOS`项目中打开`AppDelegate.cs`。然后，在调用`Forms.Init()`之前，将以下初始化代码添加到`FinishedLaunching()`方法中：
- en: '[PRE13]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Open `MainActivity.cs` in the `NationalParks.Android` project. Once you''re
    in, add the following initialization code to the `OnCreate()` method just before
    the call to `Forms.Init()`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NationalParks.Android`项目中打开`MainActivity.cs`。一旦进入，请在调用`Forms.Init()`之前在`OnCreate()`方法中添加以下初始化代码：
- en: '[PRE14]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Open `ParksListPage.xaml.cs`, add a method to load the parks data, and set
    the binding context:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ParksListPage.xaml.cs`，添加一个用于加载公园数据的方法，并设置绑定上下文：
- en: '[PRE15]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add a call to `LoadData()` from the constructor:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中添加对`LoadData()`的调用：
- en: '[PRE16]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will not be able to use `await` on the `LoadData()` method because it's
    being called from a constructor. In this case, there is actually no need to await
    the call.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将无法在`LoadData()`方法中使用`await`，因为它是在构造函数中被调用的。在这种情况下，实际上没有必要等待调用。
- en: The last step is to create two stub event handlers for `NewClicked` and `ParkSelected`,
    which we will fill in later as we complete the app.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是创建两个用于`NewClicked`和`ParkSelected`的占位事件处理程序，我们将在完成应用程序时填充它们。
- en: We are now ready to test our work. Compile and run both the `NationalParks.iOS`
    and `NationalParks.Android` apps.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以测试我们的工作了。编译并运行`NationalParks.iOS`和`NationalParks.Android`应用程序。
- en: Implementing ParkDetailPage
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现`ParkDetailPage`
- en: 'Now, we need a page to display the details of a Park. To create `ParkDetailPage`,
    perform the following steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个页面来显示公园的详细信息。要创建`ParkDetailPage`，请执行以下步骤：
- en: Add a new `ContentPage` instance named `ParkDetailPage`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`ParkDetailPage`的新`ContentPage`实例。
- en: For `ParkDetailPage`, we will display a series of `Label` views in `Grid` and
    a set of `Buttons` below `Grid` to initiate actions. All this content will be
    hosted within `StackLayout`, which is vertically oriented. Start by adding `StackLayout`
    like we did in the previous section.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`ParkDetailPage`，我们将在`Grid`中显示一系列`Label`视图，并在`Grid`下方显示一组`Button`以启动操作。所有这些内容都将托管在垂直方向的`StackLayout`中。首先添加与上一节相同的`StackLayout`。
- en: 'Add a `Grid` layout with a series of the `Label` view to display the properties
    of `NationalPark`, as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个包含一系列`Label`视图的`Grid`布局，以显示`NationalPark`的属性，如下所示：
- en: '[PRE17]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the `Grid.Row` and `Grid.Column` specifications, which control how the
    `Label` and `Entry` views are positioned.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`Grid.Row`和`Grid.Column`的指定，它们控制`Label`和`Entry`视图的定位。
- en: 'Now, add three `Button` definitions for the actions that can be taken from
    the Page, as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加三个用于页面可执行操作的`Button`定义，如下所示：
- en: '[PRE18]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add a constructor that accepts a `NationalPark` instance to be displayed. The
    following code sample demonstrates what is needed:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个构造函数，接受要显示的`NationalPark`实例。以下代码示例演示了所需的内容：
- en: '[PRE19]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the last line in the constructor sets `BindingContext`. This tells
    the Page how to resolve the binding specifications declared in XAML.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到构造函数中的最后一行设置了`BindingContext`。这告诉页面如何解析在XAML中声明的绑定规范。
- en: Add stub event handlers for `EditClicked`, `DirectionsClicked`, and `PhotosClicked`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`EditClicked`、`DirectionsClicked`和`PhotosClicked`添加存根事件处理器。
- en: 'Now, we need to return to the `ParksListPage` class and add the navigation
    logic. Open `ParksListPage.xaml.cs` and update the `ParkSelected()` event handler
    to make a call to `PushAsync()` for `ParkDetailPage`, as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要回到`ParksListPage`类并添加导航逻辑。打开`ParksListPage.xaml.cs`并更新`ParkSelected()`事件处理器，以便对`ParkDetailPage`的`PushAsync()`进行调用，如下所示：
- en: '[PRE20]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Compile and run both the `NationalParks.iOS` and `NationalParks.Android` apps.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行`NationalParks.iOS`和`NationalParks.Android`应用程序。
- en: Using DependencyService to show directions and photos
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用DependencyService显示方向和照片
- en: As we discussed earlier, the `DependencyService` API allows apps to take advantage
    of platform-specific features. We will demonstrate the use of `DependencyService`
    to implement the ability to show directions and photos for a park.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，`DependencyService` API 允许应用程序利用平台特定的功能。我们将演示如何使用`DependencyService`来实现显示公园方向和照片的功能。
- en: Creating the interface
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建接口
- en: 'The first step is to create an interface in the shared project that describes
    the methods that need to be supported. To create the `IParkInfoServices` interface,
    perform the following steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在共享项目中创建一个接口，描述需要支持的方法。要创建`IParkInfoServices`接口，请执行以下步骤：
- en: To begin with, select the `NationalParks` project, right-click on it, and navigate
    to **Add** | **New File**.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，选择`NationalParks`项目，右键单击它，然后导航到**添加** | **新建文件**。
- en: Navigate to **General** | **Empty Interface**, enter `IParkInfoServices` in
    the **Name** field, and choose **New**.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**通用** | **空接口**，在**名称**字段中输入`IParkInfoServices`，并选择**新建**。
- en: 'You now need to create two methods on the interface, one to show directions
    and one to show photos; each should accept `NationalPark` as a parameter:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要在接口上创建两个方法，一个用于显示方向，一个用于显示照片；每个都应该接受`NationalPark`作为参数：
- en: '[PRE21]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating the iOS implementation
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建iOS实现
- en: 'Now, let''s create an iOS implementation by performing the following steps:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下步骤创建一个iOS实现：
- en: Select the `NationalParks.iOS` project, right-click on it, and navigate to **Add**
    | **New File**. In this dialog box, navigate to **General** | **Empty Class**
    in the **New File** dialog box, enter `iOSParkInfoServices` in the **Name** field,
    and choose **New**.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`NationalParks.iOS`项目，右键单击它，然后导航到**添加** | **新建文件**。在这个对话框中，导航到**通用** | **空类**，在**名称**字段中输入`iOSParkInfoServices`，并选择**新建**。
- en: Add `using` clauses for the namespaces, Xamarin.Forms, `NationalParks`, `NationalParks.PortableData`,
    and `NationalParks.iOS`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加命名空间`using`子句，Xamarin.Forms、`NationalParks`、`NationalParks.PortableData`和`NationalParks.iOS`。
- en: Change the `iOSParkInfoServices` class specification so that it implements `IParkInfoServices`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`iOSParkInfoServices`类规范更改，使其实现`IParkInfoServices`。
- en: Select `IParkInfoService`, right-click on it, navigate to **Refactor** | **Implement
    interface**, and press *Enter*.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`IParkInfoService`，右键单击它，导航到**重构** | **实现接口**，然后按*Enter*。
- en: 'You should then provide implementations for the two methods calls, as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您应该提供两个方法调用的实现，如下所示：
- en: '[PRE22]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, add the following `Dependency` attribute to the `class` file outside
    the `namespace` definition, as follows:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将以下`Dependency`属性添加到`class`文件中的`namespace`定义外部，如下所示：
- en: '[PRE23]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Dependency` attribute registers the class with `DependencyService` so that
    when `Get()` is called, a platform-specific implementation can be located.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Dependency`属性将类注册到`DependencyService`，以便当调用`Get()`时，可以找到特定平台的实现。'
- en: Creating the Android implementation
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建Android实现
- en: 'Now, let''s create an Android implementation by performing the following steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下步骤创建一个Android实现：
- en: Select the `NationalParks.Android` project, right-click on it, and navigate
    to **Add** | **New File**. You should then navigate to **General** | **Empty Class**
    in the **New File** dialog box, enter `AndroidParkInfoServices` in the **Name**
    field, and choose **New**.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`NationalParks.Android`项目，右键单击它，然后导航到**添加** | **新建文件**。然后，在**新建文件**对话框中，导航到**通用**
    | **空类**，在**名称**字段中输入`AndroidParkInfoServices`，并选择**新建**。
- en: Add `using` clauses for the namespaces, Xamarin.Forms, `NationalParks`, `NationalParks.PortableData`,
    and `NationalParks.Droid`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为命名空间添加`using`子句，Xamarin.Forms、`NationalParks`、`NationalParks.PortableData`和`NationalParks.Droid`。
- en: Change the `AndroidParkInfoServices` class specification so that it implements
    `IParkInfoServices`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AndroidParkInfoServices`类的规范更改，使其实现`IParkInfoServices`。
- en: After this, select `IParkInfoService`, right-click on it, navigate to **Refactor**
    | **Implement interface**, and press *Enter*.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择`IParkInfoService`，右键单击它，导航到**重构** | **实现接口**，并按*Enter*。
- en: 'Provide implementations for the two method calls, as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为以下两个方法调用提供实现，如下所示：
- en: '[PRE24]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the use of `Forms.Context`. In the case of Android, this contains the currently
    executing `Activity`; in our case, `MainActivity`.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`Forms.Context`的使用。在Android的情况下，它包含当前正在执行的`Activity`；在我们的情况下，是`MainActivity`。
- en: 'Add the following `Dependency` attribute to the `class` file outside the `namespace`
    definition, as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`Dependency`属性添加到`class`文件中`namespace`定义之外，如下所示：
- en: '[PRE25]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Adding calls to DependencyService
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加对DependencyService的调用
- en: 'Now, we need to add code to the shared project in order to actually invoke
    `ShowDirections()` and `ShowPhotos()`. All you need to do is open `ParkDetailPage.xaml.cs`
    and fill in the stub implementations for `DirectionsClicked()` and `PhotosClicked()`,
    as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要向共享项目添加代码，以便实际调用`ShowDirections()`和`ShowPhotos()`。您需要做的就是打开`ParkDetailPage.xaml.cs`，并填写`DirectionsClicked()`和`PhotosClicked()`的占位符实现，如下所示：
- en: '[PRE26]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Running the app
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: We are finally ready to run the app. While there were several steps, the `DependencyService`
    API provided a very clean approach to separate shared and platform-specific code.
    Run both the `NationalParks.iOS` and `NationalParks.Android` apps.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好运行应用程序了。虽然有几个步骤，但`DependencyService` API提供了一个非常干净的方法来分离共享和平台特定的代码。运行`NationalParks.iOS`和`NationalParks.Android`应用程序。
- en: Implementing ParkEditPage
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现`ParkEditPage`
- en: 'Now, we need a Page to update the park information. To implement `ParkEditPage`,
    perform the following steps:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个页面来更新公园信息。要实现`ParkEditPage`，执行以下步骤：
- en: To begin with, add a new `ContentPage` named `ParkDetailsPage`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，添加一个名为`ParkDetailsPage`的新`ContentPage`。
- en: 'We will use a similar Layout for `ParkEditPage` as we did for `ParkDetailPage`
    with the exception that we will use `Entry` views to allow editing of the properties
    of `NationalPark`. Add a `StackLayout` and `Grid` instance to `ParkEditPage`,
    and add a series of `Label` and `Entry` views for each property of `NationalPark`,
    as shown in the following code snippet:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用与`ParkDetailPage`相似的布局来实现`ParkEditPage`，除了我们将使用`Entry`视图来允许编辑`NationalPark`的属性。向`ParkEditPage`添加一个`StackLayout`和`Grid`实例，并为`NationalPark`的每个属性添加一系列`Label`和`Entry`视图，如下面的代码片段所示：
- en: '[PRE27]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can then add a `Done` button to complete the editing process, as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以在编辑过程中添加一个`Done`按钮，如下所示：
- en: '[PRE28]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create two constructors, one that accepts a `NationalPark` instance and will
    be used to edit existing parks, and one that does not accept a `NationalPark`
    instance and will be used to create a new park, as shown in the following code
    snippet:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个构造函数，一个接受`NationalPark`实例并将用于编辑现有公园，另一个不接受`NationalPark`实例并将用于创建新公园，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create the `DoneClicked()` event handler with a call to save the updated park,
    and a navigation call to `PopAsync()` to return to the Page that displayed `ParkEditPage`,
    as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`DoneClicked()`的事件处理程序，其中包含保存更新后的公园的调用，以及导航调用`PopAsync()`以返回显示`ParkEditPage`的页面，如下所示：
- en: '[PRE30]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We now need to add navigation logic to both `ParkListPage` and `ParkDetailPage`.
    Open `ParkDetailPage.xaml.cs` and fill in the `EditClicked()` event handler with
    a call to `PushAsync()` in order to display `ParkEditPage`. Pass the park that
    is being viewed to the `ParkEditPage` constructor, as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要向`ParkListPage`和`ParkDetailPage`添加导航逻辑。打开`ParkDetailPage.xaml.cs`，并填写`EditClicked()`事件处理程序，其中包含调用`PushAsync()`以显示`ParkEditPage`。将正在查看的公园传递给`ParkEditPage`构造函数，如下所示：
- en: '[PRE31]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Open `ParkListPage.xaml.cs` and fill in the `NewClicked()` event handler with
    a call to `PushAsync()` in order to display `ParkEditPage`. Call the empty `ParkEditPage`
    constructor so that a new park will be created, as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ParkListPage.xaml.cs`，并填写`NewClicked()`事件处理程序，其中包含调用`PushAsync()`以显示`ParkEditPage`。调用空的`ParkEditPage`构造函数，以便创建一个新的公园，如下所示：
- en: '[PRE32]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We are now ready with our app; compile and run both the `NationalParks.iOS`
    and `NationalParks.Android` apps.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序已经准备好了；编译并运行`NationalParks.iOS`和`NationalParks.Android`应用程序。
- en: Considering the pros and cons
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑利弊
- en: 'As we have seen from the exercise, Xamarin.Forms provides a solid approach
    to dramatically increase the amount of code reused across your mobile apps; it
    has many great features:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Xamarin.Forms 提供了一种稳健的方法来显著增加在您的移动应用程序中重用的代码量；它具有许多优秀功能：
- en: XAML is a great way to define user interfaces and allows you to create properties
    and assign event handlers in a convenient, concise way
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XAML 是定义用户界面的好方法，并允许您以方便、简洁的方式创建属性和分配事件处理器
- en: The data binding capabilities are great and eliminate a lot of tedious mind-numbing
    code from being written
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据绑定功能非常出色，消除了编写大量繁琐、令人厌烦的代码
- en: The `DependencyService` API provides a great way to access platform-specific
    capabilities
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DependencyService` API 提供了一种访问特定平台功能的好方法'
- en: The `Renderer` architecture provides for ultimate customizability
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Renderer` 架构提供了极致的可定制性'
- en: 'However, at the time of writing this book, Xamarin.Forms is still somewhat
    immature, and there are some weaknesses:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在撰写本书时，Xamarin.Forms 仍然有些不成熟，存在一些弱点：
- en: There is no visual designer for the XAML code, so you have to construct your
    UI and run the app to see it visually rendered
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有可视设计器用于 XAML 代码，因此您必须构建您的 UI 并运行应用程序以查看其视觉渲染效果
- en: Due to the newness of the framework, there is a limited number of examples available
    for reference, and many of the examples use code to construct the UI rather than
    XAML
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于框架的新颖性，可用的示例数量有限，并且许多示例使用代码构建用户界面，而不是 XAML
- en: Validation capabilities seem pretty weak
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证功能似乎相当薄弱
- en: These criticisms should not be taken too strongly; cross-platform UI frameworks
    are tough to build, and I feel confident that Xamarin is on the right track and
    will evolve the framework rapidly.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些批评不应过于严重；跨平台 UI 框架很难构建，我坚信 Xamarin 正在正确的轨道上，并将迅速发展该框架。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the capabilities of Xamarin.Forms and converted
    our existing `NationalParks` app to use the framework. In the next chapter, we
    will look at the process of preparing an iOS app for distribution.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了 Xamarin.Forms 的功能，并将我们的现有 `NationalParks` 应用程序转换为使用该框架。在下一章中，我们将探讨为
    iOS 应用程序准备分发的过程。
