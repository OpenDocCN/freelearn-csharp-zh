- en: Chapter 5. Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 网络通信
- en: 'In this chapter, we will take a detailed look at the networking capabilities
    of Xamarin applications and various service integration scenarios. The chapter
    also includes real-world examples on how to use local storage for data caching
    on connected app scenarios. It is divided into the following sections:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细探讨Xamarin应用程序的网络功能以及各种服务集成场景。本章还包括了在连接应用程序场景中如何使用本地存储进行数据缓存的实际示例。它分为以下部分：
- en: Connected apps
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已连接的应用
- en: Web services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络服务
- en: Push notifications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送通知
- en: SignalR
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SignalR
- en: Patterns and best practices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式和最佳实践
- en: Platform-specific concepts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台特定概念
- en: Cloud integration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云集成
- en: Connected apps
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 已连接的应用
- en: Mobile applications by definition should be as lightweight and resource-efficient
    as possible. You cannot expect to package media and other content into the application
    and then distribute the app or create an extravagant size of storage for user
    data, especially with applications whose main purpose is to provide user access
    to related content or store and manipulate the data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，移动应用程序应该尽可能轻量级和资源高效。你不能期望将媒体和其他内容打包到应用程序中，然后分发应用程序或为用户数据创建过大的存储空间，尤其是对于那些主要目的是提供用户访问相关内容或存储和操作数据的程序。
- en: For instance, while dealing with cross-platform projects, one of the easiest
    ways to create unified business logic and storage is to create a web service layer
    and delegate the responsibility and logic to this layer. In this scenario, the
    application(s) would be simply responsible for serving the content provided by
    the service layer or communicating the user input to the service layer.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在处理跨平台项目时，创建统一业务逻辑和存储的最简单方法之一是创建一个网络服务层，并将责任和逻辑委托给这一层。在这种情况下，应用程序（s）将仅负责提供由服务层提供的内容，或将用户输入传达给服务层。
- en: This approach not only increases the efficiency of the application(s) but also
    creates an abstraction between the logic implementation and the presentation.
    This allows the developers to be free from the platform constraints on technology
    choices for storage and execution.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不仅提高了应用程序的效率，还在逻辑实现和表示之间创建了一个抽象层。这允许开发者从存储和执行的技术选择上摆脱平台限制。
- en: It is also important to mention that applications' dependency on external resources
    is not a matter of choice but has rather become a necessity, since applications
    are more and more dependent on third-party web service APIs and social media networks.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要提到的是，应用程序对外部资源的依赖不是一个选择问题，而已经变成了一个必要性，因为应用程序越来越依赖于第三方网络服务API和社交媒体网络。
- en: Web services
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络服务
- en: A web service is generally defined as an interoperable machine-to-machine communication
    over the wire (network). In the context of cross-platform application, the most
    important term in this definition would be "interoperable". Web services written
    in different frameworks or languages and running on different type of runtimes
    and hardware conform to the same standards, most of which can be consumed by applications
    running on a variety of platforms, including Xamarin target platforms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务通常定义为通过网络（网络）进行的可互操作机器到机器通信。在跨平台应用程序的上下文中，这个定义中最重要的术语将是“可互操作”。使用不同框架或语言编写的网络服务，在运行于不同类型的运行时和硬件上，符合相同的标准，其中大部分可以被运行在各种平台上的应用程序消费，包括Xamarin目标平台。
- en: Xamarin target platforms, namely iOS and Android, and Windows Runtime, can access
    stateless web services using the TCP/IP (short for Transmission Control Protocol
    / Internet Protocol) stack over a secure or non-secure HTTP (short for Hypertext
    Transfer Protocol) transport layer. Even though various data representations can
    be consumed via web services, JSON and XML are the most common text-based notations
    used.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin目标平台，即iOS和Android，以及Windows Runtime，可以使用TCP/IP（传输控制协议/互联网协议的简称）堆栈通过安全或非安全的HTTP（超文本传输协议的简称）传输层访问无状态网络服务。尽管可以通过网络服务消费各种数据表示，但JSON和XML是最常见的基于文本的表示法。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'While defining or accessing a web service, there are three basic elements that
    need to be taken into consideration. We can call these the A-B-C of a web service:
    Address, Binding, and Contract. The address is the remote access location to the
    service, binding defines the transport and security protocols, and contract defines
    the data types and the methods used by the service.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义或访问网络服务时，有三个基本元素需要考虑。我们可以将这些称为网络服务的 A-B-C：地址、绑定和合约。地址是远程访问服务的位置，绑定定义了传输和安全协议，合约定义了服务使用的数据类型和方法。
- en: While the methods and data types defined in the web service contract are very
    case-specific, transport and serialization protocols that can be used by Xamarin
    applications can be generalized.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 Web 服务合约中定义的方法和数据类型非常特定于情况，但 Xamarin 应用程序可以通用的传输和序列化协议。
- en: In web service scenarios, if the consumer is a Xamarin target platform, you
    should always be persistent about using asynchronous implementation for the client
    implementation. Asynchronous implementation for the web service clients decreases
    the chance of blocking the main thread, as discussed previously, and protects
    the application from network shortage related errors and crashes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 服务场景中，如果消费者是 Xamarin 目标平台，您应该始终坚持使用异步实现进行客户端实现。如前所述，Web 服务客户端的异步实现可以减少阻塞主线程的机会，并保护应用程序免受网络短缺相关错误和崩溃的影响。
- en: Transport
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**运输**'
- en: For Xamarin applications on both iOS and Android platforms, the main communication
    protocol is HTTP. HTTP transport can be secured on the client and/or message level
    using a certificate or credentials.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 iOS 和 Android 平台上的 Xamarin 应用程序，主要的通信协议是 HTTP。HTTP 传输可以通过证书或凭据在客户端和/或消息级别进行加密。
- en: The message-level security is optional in other versions of iOS and Xamarin.Android
    applications. In iOS 9, the **App Transport Security** (**ATS**) feature enforces
    secure connections to network resources. Even though it is possible to add certain
    domains to the exclusion list, or to turn off the ATS altogether for the target
    applications, it is strongly advised that you use secure transport over HTTP (or
    HTTPS) for Xamarin.iOS applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 和 Xamarin.Android 应用程序的其他版本中，消息级别的安全是可选的。在 iOS 9 中，**应用传输安全**（**ATS**）功能强制执行对网络资源的加密连接。尽管可以将某些域添加到排除列表中，或者完全关闭目标应用程序的
    ATS，但强烈建议您为 Xamarin.iOS 应用程序使用安全的 HTTP（或 HTTPS）传输。
- en: Even though communication protocols for TCP, UDP, or web sockets over HTTP are
    fully or partially supported on Xamarin platforms, with the current service infrastructure
    implementation, these communication channels cannot be used with web services.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 Xamarin 平台上完全或部分支持 TCP、UDP 或 HTTP 上的 WebSocket 通信协议，但根据当前的服务基础设施实现，这些通信通道不能与网络服务一起使用。
- en: Messaging
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**消息**'
- en: Messaging specifications of a service define which format should be used while
    communicating data over the HTTP transport layer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的消息规范定义了在 HTTP 传输层传输数据时应使用哪种格式。
- en: In Xamarin applications dealing with web services, messages should be constructed
    either according to the SOAP (Simple Object Access Protocol) or using POX (short
    for Plain Old XML) or JSON, depending on the service requirements.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理网络服务的 Xamarin 应用程序中，消息应根据服务要求构建为 SOAP（简单对象访问协议）、POX（代表纯文本 XML）或 JSON。
- en: '![Messaging](img/B04693_05_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![消息](img/B04693_05_01.jpg)'
- en: Simple SOAP Communication Example
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单 SOAP 消息示例**'
- en: The messaging structure is mainly important for the serialization and deserialization
    of request and response pairs between the client and server implementations. Hence,
    it is possible to employ other types of data communication models, which would
    require additional custom implementation for the client and the server.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 消息结构对于客户端和服务器实现之间请求和响应对的序列化和反序列化非常重要。因此，可以采用其他类型的数据通信模型，这将需要客户端和服务器进行额外的自定义实现。
- en: SOAP/XML services
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**SOAP/XML 服务**'
- en: SOAP web services use XML data objects enveloped in SOAP-defined schemas. **Windows
    Communication Foundation** (**WCF**) services and ASP.Net Legacy Services (ASMX)
    are both SOAP services and conform to the SOAP protocol.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP 网络服务使用 SOAP 定义的架构封装的 XML 数据对象。**Windows Communication Foundation**（**WCF**）服务和
    ASP.Net 旧版服务（ASMX）都是 SOAP 服务，并符合 SOAP 协议。
- en: SOAP web service contracts are defined in **Web Service Description Language**
    (**WSDL**) and the WSDL document, together with other XML data schemas (for example,
    XSD files), are generally accessible through the web service URL. Using this document,
    web services can be defined in a consistent manner, irrespective of the underlying
    language, and can be interfaced with and consumed by various clients.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP Web 服务合约是在 **Web 服务描述语言**（**WSDL**）中定义的，WSDL 文档，连同其他 XML 数据模式（例如，XSD 文件），通常可以通过
    Web 服务 URL 访问。使用此文档，无论底层语言如何，都可以以一致的方式定义 Web 服务，并且可以被各种客户端接口和消费。
- en: '![SOAP/XML services](img/B04693_05_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![SOAP/XML 服务](img/B04693_05_02.jpg)'
- en: Service WSDL for a SOAP 1.1 Service
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP 1.1 服务的服务 WSDL
- en: In Xamarin applications, one of the possible ways to create a so-called proxy
    (service consumer) is to use the Silverlight SDK to generate the access code.
    The main reason for using the Silverlight SDK is the fact that the Windows Communication
    Foundation client infrastructure is not fully included in the Xamarin core and
    only a subset of client features, very similar to the Silverlight framework, can
    be used to access web services.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin 应用程序中，创建所谓的代理（服务消费者）的一种可能方式是使用 Silverlight SDK 生成访问代码。使用 Silverlight
    SDK 的主要原因在于 Windows Communication Foundation 客户端基础设施并未完全包含在 Xamarin 核心中，只能使用与
    Silverlight 框架非常相似的客户端功能子集来访问 Web 服务。
- en: 'In order to generate the client, you can simply use the command-line tool to
    execute the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成客户端，您只需使用命令行工具执行以下命令：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'SLSvcUtil can be found in various SDKs including Windows Phone 7, Windows Phone
    8, Windows Phone 8.1 (Silverlight), as well as the actual Silverlight SDK directories:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SLSvcUtil 可在各种 SDK 中找到，包括 Windows Phone 7、Windows Phone 8、Windows Phone 8.1（Silverlight）以及实际的
    Silverlight SDK 目录：
- en: '`C:\Program Files (x86)\Microsoft SDKs\Windows Phone\v7.0\Tools\SlSvcUtil.exe`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C:\Program Files (x86)\Microsoft SDKs\Windows Phone\v7.0\Tools\SlSvcUtil.exe`'
- en: '`C:\Program Files (x86)\Microsoft SDKs\Windows Phone\v8.0\Tools\SlSvcUtil.exe`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C:\Program Files (x86)\Microsoft SDKs\Windows Phone\v8.0\Tools\SlSvcUtil.exe`'
- en: '`C:\Program Files (x86)\Microsoft SDKs\Windows Phone\v8.1\Tools\SlSvcUtil.exe`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C:\Program Files (x86)\Microsoft SDKs\Windows Phone\v8.1\Tools\SlSvcUtil.exe`'
- en: '`C:\Program Files (x86)\Microsoft SDKs\Silverlight\v5.0\Tools\SlSvcUtil.exe`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C:\Program Files (x86)\Microsoft SDKs\Silverlight\v5.0\Tools\SlSvcUtil.exe`'
- en: The preceding command would generate a WCF client that can communicate with
    any web service that supports the SOAP 1.1 profile. If we were to consume a WCF
    service, the supported binding configurations would be `BasicHttpBinding` and
    `WebHttpBinding` (essentially a REST binding). `WSHttpBinding` and similar configurations
    use other SOAP profiles to envelope the data requests and responses.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将生成一个可以与支持 SOAP 1.1 配置的任何 Web 服务通信的 WCF 客户端。如果我们想要消费 WCF 服务，支持的绑定配置将是 `BasicHttpBinding`
    和 `WebHttpBinding`（本质上是一个 REST 绑定）。`WSHttpBinding` 和类似配置使用其他 SOAP 配置来封装数据请求和响应。
- en: '![SOAP/XML services](img/B04693_05_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![SOAP/XML 服务](img/B04693_05_03.jpg)'
- en: Generating Silverlight Proxy
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 生成 Silverlight 代理
- en: The generated client would have both the Event-Based and Asynchronous Programming
    Model (APM) asynchronous methods for accessing the client.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的客户端将具有基于事件和异步编程模型（APM）的异步方法来访问客户端。
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Another approach would be to create a web reference in Visual Studio or Xamarin
    Studio. A web reference can only be used to communicate with services that implement
    the WS-I Basic Profile 1.1 (in other words, SOAP 1.1). Web reference generated
    clients use the ASMX communication stack (.NET 2.0 Services Technology) as opposed
    to the WCF client infrastructure used by service references.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在 Visual Studio 或 Xamarin Studio 中创建 Web 引用。Web 引用只能用于与实现 WS-I Basic Profile
    1.1（换句话说，SOAP 1.1）的服务进行通信。由 Web 引用生成的客户端使用 ASMX 通信堆栈（.NET 2.0 服务技术），而不是服务引用所使用的
    WCF 客户端基础设施。
- en: '![SOAP/XML services](img/B04693_05_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![SOAP/XML 服务](img/B04693_05_04.jpg)'
- en: Add Web Reference Dialog (Visual Studio)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 Web 引用对话框（Visual Studio）
- en: If we were to compare the generated clients from the web reference and the Silverlight
    SDK, we could easily identify the underlying technologies.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要比较由 Web 引用和 Silverlight SDK 生成的客户端，我们可以轻松地识别出底层技术。
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Looking at the class diagram for both of the generated proxies, we can get
    some more insight into the method execution strategies:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看生成的两个代理的类图，我们可以对方法执行策略有更多的了解：
- en: '![SOAP/XML services](img/B04693_05_05.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![SOAP/XML 服务](img/B04693_05_05.jpg)'
- en: Generated Proxy Comparison
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代理比较
- en: The ideal way to integrate the generated proxy in a cross-platform project would
    be to add the service reference in a portable class library to be used by platform-specific
    projects. In order to be able to add a service reference in a PCL project in Visual
    Studio, you must remove Windows Phone 8.1 as one of the targets and/or add a reference
    to the `System.ServiceModel` namespace (Visual Studio will automatically remove
    Windows Phone 8.1 from the targets list). The Windows Phone 8.1 platform does
    not include the Windows Communication Foundation client assemblies. After this
    step, the **Add Service Reference** option will appear under the project context
    menu.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在跨平台项目中集成生成的代理的理想方式是将服务引用添加到可移植类库中，以便用于特定平台的项目。为了在Visual Studio中向PCL项目添加服务引用，您必须将Windows
    Phone 8.1作为目标之一删除，或者添加对`System.ServiceModel`命名空间的引用（Visual Studio将自动从目标列表中删除Windows
    Phone 8.1）。Windows Phone 8.1平台不包含Windows Communication Foundation客户端程序集。完成此步骤后，**添加服务引用**选项将出现在项目上下文菜单中。
- en: For scenarios involving Windows Phone 8.1, the more appropriate solution would
    be to use a RESTful service and a client.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及Windows Phone 8.1的场景，更合适的解决方案是使用RESTful服务和客户端。
- en: RESTful services
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RESTful服务
- en: RESTful services are one of the most common distributed system implementations
    involving mobile applications. Compared to SOAP services, they don't have the
    overhead of SOAP protocols or the enveloping of the request/response pairs. In
    essence, network traffic caused by a SOAP method call is the same as the request/response
    pair of a REST call. The simplicity of the **Representational State Transfer**
    (**REST**) model increases the performance and maintainability. Stateless and
    cacheable approaches of RESTful services makes them an optimal solution for Xamarin
    target platforms.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与SOAP服务相比，RESTful服务没有SOAP协议的额外开销或请求/响应对的封装。本质上，SOAP方法调用引起的网络流量与REST调用的请求/响应对相同。**表示状态转移**（**REST**）模型的简单性提高了性能和可维护性。RESTful服务的无状态和可缓存方法使它们成为Xamarin目标平台的最佳解决方案。
- en: REST services can essentially be described as static HTTP endpoints. The HTTP
    verbs (GET, PUT, POST, and DELETE) used to access these endpoints define the type
    of method to be invoked on the service layer (PUT for update, POST for create,
    and DELETE for delete actions). The messaging structure can vary from JSON to
    XML, even to ATOM.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务本质上可以描述为静态HTTP端点。用于访问这些端点的HTTP动词（GET、PUT、POST和DELETE）定义了在服务层上要调用的方法类型（PUT用于更新，POST用于创建，DELETE用于删除操作）。消息结构可以从JSON到XML，甚至到ATOM。
- en: On Xamarin target platforms, there are various out-of-the-box options and additional
    components available for REST-based web services. Any of these options can be
    used to execute web requests and request/response pairs can be serialized/deserialized
    according to the requirements and chosen messaging media-type.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin目标平台上，有各种现成的选项和附加组件可用于基于REST的Web服务。这些选项中的任何一个都可以用来执行Web请求，并且请求/响应对可以根据要求和选择的消息媒体类型进行序列化/反序列化。
- en: Since we are making ordinary web requests to the REST endpoints, the simplest
    implementation would involve the `HttpClient`, which is included in the `System.Net.Http`
    namespace.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在对REST端点进行常规的Web请求，最简单的实现将涉及`HttpClient`，它包含在`System.Net.Http`命名空间中。
- en: For instance, if we were to implement a base class that will handle the CRUD
    (create, read, update, and delete) methods on the RESTful version of the web service
    used in the previous section (`TravelTrace.ReferenceDataService`), we could implement
    a per-call wrapper around the inner HTTP client layer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要实现一个基类来处理上一节中使用的RESTful Web服务的CRUD（创建、读取、更新和删除）方法（`TravelTrace.ReferenceDataService`），我们可以在内部HTTP客户端层周围实现一个针对每个调用的包装器。
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will notice that we are using the base address as the server address and,
    if any, using the security token to initialize our client. In this implementation,
    the create method will simply create the HTTP client and use the authentication
    token as a default header. Another important requirement is to set the "Accept"
    header to announce which type of content the client is expecting from the server
    (JSON in this example).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们正在使用基础地址作为服务器地址，并且如果有的话，使用安全令牌来初始化我们的客户端。在这个实现中，创建方法将简单地创建HTTP客户端，并使用身份验证令牌作为默认头。另一个重要要求是将“Accept”头设置为通知客户端期望从服务器接收哪种类型的内容（在这个例子中是JSON）。
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After the HTTP pipeline is ready to execute the requests, we can start implementing
    the base methods for the REST service.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 管道准备好执行请求后，我们可以开始实现 REST 服务的基方法。
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, the `GetRegions` method looks like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`GetRegions` 方法看起来是这样的：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result of this request can be visualized in the debug screen:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求的结果可以在调试屏幕中可视化：
- en: '![RESTful services](img/B04693_05_06.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![RESTful services](img/B04693_05_06.jpg)'
- en: JSON data returned from Web API
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 Web API 的 JSON 数据
- en: 'However, this is only the string representation of the service data, and we
    would need to extend our implementation to include a JSON serializer. There are
    multiple options available for serialization, including the standard libraries
    available through the *Microsoft BCL* package: `System.Xml` and `System.Json`
    namespaces. *NewtonSoft Json.NET* is still one of the most popular JSON libraries
    and available through NuGet.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仅仅是服务数据的字符串表示，我们需要扩展我们的实现以包括一个 JSON 序列化器。有多个序列化选项可用，包括通过 *Microsoft BCL*
    包提供的标准库：`System.Xml` 和 `System.Json` 命名空间。*NewtonSoft Json.NET* 仍然是最受欢迎的 JSON
    库之一，并且可以通过 NuGet 获取。
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using this implementation, we can create generic methods in the base class implementation
    and push the serialization responsibility to this layer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个实现，我们可以在基类实现中创建通用方法，并将序列化责任推到这一层。
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can extend this generic implementation for other web methods and create the
    basis for our RESTful client. The authentication scenario will be discussed further
    in the following section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展这个通用实现以用于其他 Web 方法，并为我们的 RESTful 客户端创建基础。认证场景将在下一节中进一步讨论。
- en: There are many more REST consumer implementations available for the Xamarin
    developer and these modules can be included in cross-platform projects via components
    and NuGet packages (RestSharp, Hammock, and so on).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Xamarin 开发者来说，还有许多更多的 REST 消费者实现可用，这些模块可以通过组件和 NuGet 包（如 RestSharp、Hammock
    等）包含到跨平台项目中。
- en: OData and OAuth
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OData 和 OAuth
- en: OData and OAuth are two widely accepted standards/protocols for RESTful communication
    scenarios. Xamarin mobile applications that deal with external resources, and
    especially third-party web service APIs, are generally implementing these protocols.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: OData 和 OAuth 是两种广泛接受的用于 RESTful 通信场景的标准/协议。Xamarin 移动应用程序处理外部资源，尤其是第三方 Web
    服务 API 时，通常实现这些协议。
- en: OData
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OData
- en: Unlike SOAP, which is a communication protocol, REST is simply an architectural
    approach to web service implementations. RESTful services do not need to conform
    to certain specifications and may vary greatly. In order to identify the requirements
    for RESTful services and create a uniform structure for data being exchanged between
    the client applications and the server, OData was initiated by Microsoft in 2007\.
    OData is now an internationally accepted protocol that is maintained by OASIS
    and supported/used by various applications, platforms, and companies (for example,
    Microsoft Azure Mobile Services, Microsoft Office 365 Web Access, Salesforce,
    SAP Netweaver Gateway Solution, IBM WebSphere, and so on).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与作为通信协议的 SOAP 不同，REST 只是一种针对 Web 服务实现的架构方法。RESTful 服务不需要符合某些规范，可能差异很大。为了识别 RESTful
    服务的需求并为客户端应用程序和服务器之间交换的数据创建统一的结构，微软在 2007 年启动了 OData。OData 现在是一个国际上认可的协议，由 OASIS
    维护，并被各种应用程序、平台和公司（例如，微软 Azure 移动服务、微软 Office 365 Web 访问、Salesforce、SAP Netweaver
    Gateway Solution、IBM WebSphere 等）支持/使用。
- en: In OData protocol, each object set is defined by an endpoint in line with REST
    principles. For GET requests, these entity set endpoints can either accept object
    identifiers, which results in the details of that specific entity instance, or
    entities in the list can be queried with OData filter and other query options.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OData 协议中，每个对象集都由一个符合 REST 原则的端点定义。对于 GET 请求，这些实体集端点可以接受对象标识符，从而得到该特定实体实例的详细信息，或者可以使用
    OData 过滤器和其他查询选项查询列表中的实体。
- en: Similar to the WSDL in SOAP/XML services, accessible endpoints (entity sets
    and functions) and types used in the service contracts are generally served through
    the metadata endpoint with a CSDL (OData Common Schema Definition Language) file
    in OData.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SOAP/XML 服务中的 WSDL 类似，可访问的端点（实体集和函数）以及服务合同中使用的类型通常通过带有 CSDL（OData 公共架构定义语言）文件的元数据端点提供服务。
- en: To access the whole list of elements, visit `http://localhost/Xamarin.Master.TravelTrace.Service.Api/odata/regions`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问整个元素列表，请访问 `http://localhost/Xamarin.Master.TravelTrace.Service.Api/odata/regions`。
- en: To access a single element in the entity set endpoint, visit `http://localhost/Xamarin.Master.TravelTrace.Service.Api/odata/regions(guid'90222c18-66fa-441a-b069-0115faa1e0f1')`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问实体集端点中的单个元素，请访问 `http://localhost/Xamarin.Master.TravelTrace.Service.Api/odata/regions(guid'90222c18-66fa-441a-b069-0115faa1e0f1')`。
- en: To query the list of elements with a filter, visit `http://localhost/Xamarin.Master.TravelTrace.Service.Api/odata/regions?$filter=Continent
    eq 'Europe'`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询具有筛选条件的元素列表，请访问 `http://localhost/Xamarin.Master.TravelTrace.Service.Api/odata/regions?$filter=Continent
    eq 'Europe'`。
- en: Advanced OData queries involving additional property expansions, lambda operators,
    and functions are also possible with the OData protocol; however, these topics
    are beyond the scope of this book.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OData 协议，也可以进行涉及额外属性展开、lambda 操作符和函数的高级 OData 查询；然而，这些主题超出了本书的范围。
- en: There are multiple NuGet packages and components available both as open source
    and/or free to download that help with the client generation for OData services.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 可以下载的 NuGet 包和组件有多种，这些组件作为开源和/或免费软件，有助于为 OData 服务生成客户端。
- en: OAuth
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OAuth
- en: OAuth is an open standard used generally by service providers for authorization.
    A general use case for OAuth would be to use third-party identity providers such
    as Live ID (Microsoft), Google, Facebook, or Twitter for authentication and authorization
    in a mobile or web application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 是一个开放标准，通常由服务提供商用于授权。OAuth 的一般用例可能是使用第三方身份提供者，如 Live ID（微软）、Google、Facebook
    或 Twitter，在移动或网络应用程序中进行身份验证和授权。
- en: A classic OAuth 2.0 implementation scenario is generally a two-step process.
    The first step involves the user granting access to the client application through
    the provider web interface. The second step is using the authorization code received
    from the provider's web interface to get an access token to access the provider's
    resources.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的 OAuth 2.0 实现场景通常是一个两步过程。第一步涉及用户通过提供者的网络界面授予客户端应用程序访问权限。第二步是使用从提供者网络界面接收到的授权代码来获取访问令牌，以访问提供者的资源。
- en: '![OAuth](img/B04693_05_07.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![OAuth](img/B04693_05_07.jpg)'
- en: Facebook as Auth Provider
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook 作为身份验证提供者
- en: The first step of the authorization process on a web application is generally
    an `iframe` displaying the provider's authorization page. In a Xamarin application,
    this step is executed using a web view control or a more specialized implementation
    (`WebAuthenticationBroker` is an out-of-box control on Windows Phone 8.1). Implementing
    the two-step authentication process can become quite cumbersome considering the
    fact that the provider's page makes a callback request to the client application
    page with the authorization token and the client app is responsible for parsing
    and extracting this token either from the callback URL or the body of the content.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络应用程序上的授权过程的第一步通常是显示提供者授权页面的 `iframe`。在 Xamarin 应用程序中，这一步是通过使用网页视图控件或更专业的实现（`WebAuthenticationBroker`
    是 Windows Phone 8.1 上的现成控件）来执行的。考虑到提供者页面会向客户端应用程序页面发出带有授权令牌的回调请求，而客户端应用程序负责从回调
    URL 或内容体中解析和提取此令牌，实现两步验证过程可能会变得相当繁琐。
- en: '![OAuth](img/B04693_05_08.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![OAuth](img/B04693_05_08.jpg)'
- en: Xamarin.Auth Components
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Auth 组件
- en: 'To provide access to OAuth APIs and simplify the implementation, developers
    can make use of the available Xamarin OAuth component: Xamarin.Auth (available
    on Xamarin.iOS and Xamarin.Android platforms). There is also an accompanying component
    for social media provider APIs: Xamarin.Social.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供对 OAuth API 的访问并简化实现，开发者可以利用可用的 Xamarin OAuth 组件：Xamarin.Auth（可在 Xamarin.iOS
    和 Xamarin.Android 平台上使用）。还有一个配套的组件用于社交媒体提供者 API：Xamarin.Social。
- en: Using the Xamarin.Auth implementation, authenticating with the Facebook API
    can become as simple as a few lines of code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Xamarin.Auth 实现，使用 Facebook API 进行身份验证可以简单到只需几行代码。
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: SignalR
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SignalR
- en: ASP.NET SignalR is a web server-side technology that allows developers to pass
    real-time updates to their applications. SignalR works in a similar way to WCF
    duplex channels where the server side is accessible through the main service contract
    and the server-to-client communication occurs through the callback contract. While
    WCF duplex channels provide support for the same scenarios as SignalR, duplex
    channel implementation is currently not supported in any of the Xamarin target
    platforms. On the other hand, there is a component available for use on all Xamarin
    target platforms for SignalR.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET SignalR 是一种网络服务器端技术，允许开发者为他们的应用程序传递实时更新。SignalR 的工作方式与 WCF 双向通道类似，其中服务器端通过主要服务合同访问，服务器到客户端的通信通过回调合同进行。虽然
    WCF 双向通道提供与 SignalR 相同的场景支持，但双向通道实现目前在任何 Xamarin 目标平台上都不受支持。另一方面，所有 Xamarin 目标平台都可用
    SignalR 组件。
- en: '![SignalR](img/B04693_05_09.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![SignalR](img/B04693_05_09.jpg)'
- en: SignalR Component
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 组件
- en: SignalR takes advantage of `WebSockets`, which enables bidirectional communication
    over the HTTP transport. In essence, `WebSockets` works almost in the same way
    as TCP Sockets; however, the connection is established over the HTTP transport
    layer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 利用 `WebSockets`，这使得在 HTTP 传输上实现双向通信。本质上，`WebSockets` 几乎以与 TCP Sockets
    相同的方式工作；然而，连接是在 HTTP 传输层上建立的。
- en: Using SignalR, applications requiring real-time data can be implemented without
    resorting to polling or listener channel implementations, which is neither scalable
    nor efficient on mobile platforms.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SignalR，需要实时数据的应用程序可以实现，无需求助于轮询或监听通道实现，这在移动平台上既不可扩展也不高效。
- en: SignalR is generally implemented with a Hub application on the server-side,
    which creates different event sinks to be subscribed by different applications.
    Each client that subscribes to a certain channel gets event notifications and
    data over these channels in a normal broadcast scenario in a string format or
    already deserialized as a complex type.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 通常在服务器端实现为一个 Hub 应用程序，它创建不同的事件接收器供不同的应用程序订阅。每个订阅特定频道的客户端在这些频道上以字符串格式或已反序列化为复杂类型的方式接收事件通知和数据，在正常广播场景下。
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: SignalR server implementations can, generally speaking, replace RESTful service
    actions. These duplex hubs can provide functions to be called by the consumers
    as well as update calls from the server to listening clients.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，SignalR 服务器实现可以替换 RESTful 服务操作。这些双向 Hub 可以提供由消费者调用的功能，以及从服务器到监听客户端的更新调用。
- en: While different message formats can be used to exchange data, most implementations
    employ the JSON format to serialize and deserialize data, and Json.NET is the
    default serialization library used by the SignalR component.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用不同的消息格式来交换数据，但大多数实现使用 JSON 格式来序列化和反序列化数据，并且 Json.NET 是 SignalR 组件使用的默认序列化库。
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On top of the server invoked events, SignalR channels also offer lifetime events:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端调用的事件之上，SignalR 频道还提供生命周期事件：
- en: '**Received**: Raised when any data is received on the connection. Provides
    the received data.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收**: 当连接上接收到任何数据时触发。提供接收到的数据。'
- en: '**ConnectionSlow**: Raised when the client detects a slow or frequently dropping
    connection.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接缓慢**: 当客户端检测到缓慢或频繁断开连接时触发。'
- en: '**Reconnecting**: Raised when the underlying transport begins reconnecting.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重新连接**: 当底层传输开始重新连接时触发。'
- en: '**Reconnected**: Raised when the underlying transport has reconnected.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重新连接**: 当底层传输重新连接时触发。'
- en: '**StateChanged**: Raised when the connection state changes. Provides the old
    state and the new state.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态改变**: 当连接状态改变时触发。提供旧状态和新状态。'
- en: '**Closed**: Raised when the connection has disconnected.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭**: 当连接断开时触发。'
- en: SignalR supports SSL transport security as well as having the ability to integrate
    with the existing authentication and authorization providers already being used
    by the web server and mobile applications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR 支持使用 SSL 传输安全，并且能够与网络服务器和移动应用程序已经使用的现有身份验证和授权提供者集成。
- en: Patterns and best practices
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式和最佳实践
- en: In mobile applications, developers often use certain reusable design patterns
    while using web services and other communication channels in development projects.
    These patterns aim to increase the efficiency and increase the code sharing not
    only between platforms but also among various execution domains of cross-platform
    mobile applications.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动应用程序中，开发者在开发项目中使用网络服务和其它通信渠道时，通常会使用某些可重用的设计模式。这些模式旨在提高效率，并增加代码在不同平台以及跨平台移动应用程序的各个执行域之间的共享。
- en: Async conversions
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步转换
- en: The generated proxies for WCF and/or SOAP/XML services generally include either
    an event-based async implementation or an asynchronous invoke pattern with begin
    and end methods. Both of these implementations can be converted to a task-based
    async pattern.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为 WCF 和/或 SOAP/XML 服务生成的代理通常包括基于事件的异步实现或带有 begin 和 end 方法的异步调用模式。这两种实现都可以转换为基于任务的异步模式。
- en: In order to convert the event-based async service method to a task-based one,
    we can use `TaskCompletionSource<T>` and return the task that is produced (refer
    to [Chapter 3](ch03.html "Chapter 3. Asynchronous Programming"), *Asynchronous
    Programming*).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将基于事件的异步服务方法转换为基于任务的，我们可以使用 `TaskCompletionSource<T>` 并返回产生的任务（参考[第 3 章](ch03.html
    "第 3 章。异步编程")，*异步编程*）。
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For the async invoke pattern, we can use the designated methods from the `TaskFactory`.
    The `FromAsync` method of the `TaskFactory` uses the begin and end methods together
    with the async state object (which can, for example, be used for cancellation
    token or progress callback) and creates an awaitable task.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异步调用模式，我们可以使用 `TaskFactory` 的指定方法。`TaskFactory` 的 `FromAsync` 方法使用 begin 和
    end 方法以及异步状态对象（例如，可以用于取消令牌或进度回调）来创建一个可等待的任务。
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Data model abstraction
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据模型抽象
- en: Following the quality identifiers that were put forward previously, in service-related
    scenarios, it is important to create a data model abstraction layer which can
    be used by different branches of a cross-platform application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循之前提出的质量标识符，在服务相关场景中，创建一个可以被跨平台应用程序的不同分支使用的数据库模型抽象层非常重要。
- en: 'Using the travelers'' guide application example from previous sections, we
    can analyze the sharing strategy. In this example, as a development team or a
    single developer, we are responsible for:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前几节中的旅行者指南应用程序示例，我们可以分析共享策略。在这个例子中，作为一个开发团队或单个开发者，我们负责：
- en: Implementing the service layer responsible for accessing the database and connecting
    to external APIs, if necessary
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现负责访问数据库和连接外部 API 的服务层，如果需要的话
- en: Implementing the shared common logic which will be used by Xamarin applications
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现将被 Xamarin 应用程序使用的共享通用逻辑
- en: Implementing the Xamarin.iOS and Xamarin.Android applications
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 Xamarin.iOS 和 Xamarin.Android 应用程序
- en: Implementing the Windows Phone 8.1 application
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 Windows Phone 8.1 应用程序
- en: Implementing the web interface which will employ a Silverlight component (optional)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现将使用 Silverlight 组件（可选）的 Web 界面
- en: For simplicity, we will be implementing only a single data type and a single
    GET method.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将只实现一个数据类型和一个 GET 方法。
- en: For the contracts and the data objects, we can create a portable library that
    will be targeting Xamarin platforms together with .NET 4.5\. The reason we are
    including the .NET profile is because we will be using the data model in the service
    layer implementation as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于合约和数据对象，我们可以创建一个针对 Xamarin 平台以及 .NET 4.5 的可移植库。我们包括 .NET 配置文件的原因是因为我们将在服务层实现中使用数据模型。
- en: The implementation starts by creating the Data Transfer Model objects. These
    objects are generally the reflection of the database tables used on the service
    layer. However, one-to-one mapping between DTOs and DBOs (Entity Framework items)
    is not absolutely necessary since the DTO abstraction layer's sole purpose is
    to create an abstraction layer over the actual data repository that we will be
    dealing with.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 实现开始于创建数据传输模型对象。这些对象通常是服务层上使用的数据库表的反映。然而，DTO（数据传输对象）和 DBO（数据访问对象，Entity Framework
    项目）之间的一对一映射并不是绝对必要的，因为 DTO 抽象层的唯一目的是在我们将要处理的实际数据存储之上创建一个抽象层。
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that we are including Json.NET attributes to define class properties.
    They are used to format the JSON object attributes during serialization/deserialization
    to camel-case (for example, camelCase), which is the JavaScript convention, rather
    than the .NET convention of pascal-case (for example, PascalCase) for property
    names. These property definitions can be used with RESTful clients and web service
    implementations. This will not interfere with other service or client layer use
    cases.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们包括Json.NET属性来定义类属性。它们用于在序列化/反序列化期间格式化JSON对象属性为驼峰式（例如，camelCase），这是JavaScript约定，而不是属性名称的.NET约定大驼峰式（例如，PascalCase）。这些属性定义可以与RESTful客户端和Web服务实现一起使用。这不会干扰其他服务或客户端层用例。
- en: After we create the model, we can define the interface(s) that will be used
    by the web service and associated clients. We will define two interfaces for synchronous
    implementation on the service layer and asynchronous consumption on the client
    side.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建模型之后，我们可以定义将被Web服务和相关客户端使用的接口。我们将在服务层定义两个接口用于同步实现，并在客户端侧进行异步消费。
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The service implementation strategy would normally be to use a RESTful layer.
    For demonstration purposes, let's implement the WCF service in a separate project,
    reusing the data model defined and the interface previously created.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 服务实现策略通常是使用RESTful层。为了演示目的，让我们在一个单独的项目中实现WCF服务，重用之前定义的数据模型和接口。
- en: '![Data model abstraction](img/B04693_05_10.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![数据模型抽象](img/B04693_05_10.jpg)'
- en: Solution Structure
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案结构
- en: In this implementation, each service method will be calling a data repository
    (Entity Framework/MSSQL) and the repository will be returning the DTO objects
    by converting the database layer entities.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，每个服务方法都将调用数据存储库（Entity Framework/MSSQL），并且存储库将通过转换数据库层实体来返回DTO对象。
- en: The next section of the project that we need to implement would be the service
    data consumer layer. We will create a new portable library for this layer and
    use a generated WCF client. After creating the project and adding the reference
    to the `System.ServiceModel` namespace and the common portable library that contains
    the DTO model, an important detail to remember is to make sure that the generated
    proxy reuses the referenced libraries.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的项目下一个部分是服务数据消费者层。我们将为此层创建一个新的可移植库，并使用生成的WCF客户端。在创建项目并添加对`System.ServiceModel`命名空间和包含DTO模型的通用可移植库的引用后，一个重要的细节是要确保生成的代理重用引用的库。
- en: '![Data model abstraction](img/B04693_05_11.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![数据模型抽象](img/B04693_05_11.jpg)'
- en: Service Reference Properties
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 服务引用属性
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are using the Silverlight SDK to generate the client, it is a little
    more complicated to include the existing libraries so that the types are reused.
    In order to do this, you can use the "reference" switch (or simply, `/r`: ) and
    point the utility to the assemblies that contain the implemented types.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Silverlight SDK生成客户端，包含现有库以重用类型会稍微复杂一些。为了做到这一点，你可以使用“引用”开关（或者简单地说，`/r`：）并将实用程序指向包含已实现类型的程序集。
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After creating the proxy, we have a structure in which the data model and the
    contracts are shared by different layers of the application including the service,
    data access layer, service proxy, and finally, the applications.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建代理之后，我们有一个结构，其中数据模型和合约被应用程序的不同层共享，包括服务、数据访问层、服务代理，最后是应用程序。
- en: '![Data model abstraction](img/B04693_05_12.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![数据模型抽象](img/B04693_05_12.jpg)'
- en: Shared service structure
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 共享服务结构
- en: The implementation, however, should be further extended with conversions to
    task-based async implementation on the service proxy. Another useful improvement
    would be to implement local DB caching and offline storage. For this caching layer,
    the same DTO implementation can be reused.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实现应该进一步扩展，将服务代理转换为基于任务的异步实现。另一个有用的改进是实现本地数据库缓存和离线存储。对于这个缓存层，可以重用相同的DTO实现。
- en: If we were to include a Windows Phone 8.1 client in this cross-platform project,
    the only solution to the lack of WCF infrastructure would be to exchange the WCF
    service with a RESTful implementation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要在这个跨平台项目中包含一个Windows Phone 8.1客户端，解决WCF基础设施不足的唯一方法就是用RESTful实现来替换WCF服务。
- en: Service cache
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务缓存
- en: When dealing with network scenarios, it is important to keep in mind that mobile
    devices do not always have a good network connectivity or network at all. In order
    to make the Xamarin connected app usable even in offline scenarios, a caching
    layer can be implemented to store and return data items that do not often change.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理网络场景时，重要的是要记住，移动设备并不总是拥有良好的网络连接或根本就没有网络。为了使 Xamarin 连接应用程序即使在离线场景中也可用，可以实现一个缓存层来存储和返回不经常更改的数据项。
- en: For instance, in travel guide applications, users will want to access guides,
    and possibly maps, even when they are with a roaming connection or, even worse,
    without any connection at all. To facilitate offline storage, we can implement
    a SQLite database that uses the existing data transfer objects as storage items
    and updates the data on certain intervals when there is Internet connectivity.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在旅行指南应用程序中，用户将想要访问指南，甚至可能需要地图，即使他们处于漫游连接中，或者更糟糕的是，没有任何连接。为了便于离线存储，我们可以实现一个
    SQLite 数据库，该数据库使用现有的数据传输对象作为存储项，并在有互联网连接时在特定间隔更新数据。
- en: The first step of the implementation would be to revise our DTO layer classes
    and add SQLite attributes if needed. This will create a dependency on the service
    layer for SQLite assemblies; the other option is either to use linked code files
    between the service layer and the client libraries or to recreate the DTO objects
    specifically for the SQLite data store.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的第一步将是修订我们的 DTO 层类，并在需要时添加 SQLite 属性。这将创建对服务层 SQLite 程序集的依赖；另一种选择是使用服务层和客户端库之间的链接代码文件，或者为
    SQLite 数据存储重新创建 DTO 对象。
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this scenario, in order to create a data context that will use the online
    storage if available and use the local data storage if Internet connectivity is
    limited, we can implement the same data interface that we created for the service
    proxy in the previous examples for the SQLite data source and create one parent
    handler for the data sync context.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在此场景中，为了创建一个数据上下文，如果可用则使用在线存储，如果互联网连接有限则使用本地数据存储，我们可以实现与之前示例中为服务代理创建的相同数据接口，并为数据同步上下文创建一个父处理程序。
- en: '![Service cache](img/B04693_05_13.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![服务缓存](img/B04693_05_13.jpg)'
- en: Data Abstraction on App Tiers
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层的数据抽象
- en: In the sync context, for GET methods, the service calls will be used only for
    updating the local storage and actual results will be returned from the local
    storage. For PATCH, POST, and PUT calls, depending on the online connectivity,
    we will be either saving the data locally or pushing the deltas and new object
    instances to the service and updating the local data with the updates.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步上下文中，对于 GET 方法，服务调用将仅用于更新本地存储，实际结果将从本地存储返回。对于 PATCH、POST 和 PUT 调用，根据在线连接性，我们将要么在本地保存数据，要么将增量和新对象实例推送到服务，并使用更新来更新本地数据。
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For performance improvement in this implementation, when we are loading data
    for certain visualizations, we can first call the local data provider and continue
    with UI updates and then call the web service method and the same continuation
    delegate.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高此实现的性能，当我们为某些可视化加载数据时，我们可以首先调用本地数据提供程序，然后继续进行 UI 更新，接着调用 Web 服务方法以及相同的延续委托。
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Platform-specific concepts
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台特定概念
- en: There are other concepts and network communication methods on Xamarin platforms
    that are provided by the native runtime and supported by Xamarin.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin 平台上，还有其他由原生运行时提供并由 Xamarin 支持的概念和网络通信方法。
- en: Permissions
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 权限
- en: In order for an Android or Windows Phone application to access Internet, the
    application manifest should declare that the application will need to use the
    network to access resources.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Android 或 Windows Phone 应用程序访问互联网，应用程序清单应该声明该应用程序将需要使用网络来访问资源。
- en: 'The permission on Android system is declared using the `uses-permission` tag
    in the manifest node of the XML file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 系统中，权限声明使用 XML 文件的清单节点中的 `uses-permission` 标签：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'While this declaration will suffice in most use case scenarios, in order to
    access the current network status or the Wi-Fi status, you must also declare the
    network state permissions:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种声明在大多数使用场景中足够使用，但为了访问当前的网络状态或 Wi-Fi 状态，还必须声明网络状态权限：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For a Windows phone, the app capability to declare would be `ID_CAP_NETWORKING`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows Phone，可声明的应用程序能力为 `ID_CAP_NETWORKING`。
- en: Application manifests for both platforms can be edited through the application
    project properties in the designated configuration section.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 两个平台的应用程序清单都可以通过应用程序项目属性中的指定配置部分进行编辑。
- en: '![Permissions](img/B04693_05_14.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![权限](img/B04693_05_14.jpg)'
- en: Android Manifest
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Android Manifest
- en: iOS, other than the App Transport Security (ATS) that was mentioned previously,
    does not enforce any manifest setup or permissions for applications to use network
    connection.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前提到的App Transport Security (ATS)之外，iOS不强制执行任何清单设置或权限，以允许应用程序使用网络连接。
- en: NSUrlConnection/NSUrlSession (iOS Only)
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NSUrlConnection/NSUrlSession（仅限iOS）
- en: Apart from the different client libraries available for use with Xamarin target
    platforms, some native implementations can also be used to call and receive external
    web data. One of these available options for Xamarin.iOS platform is `NSUrlConnection`.
    With the help of `NSUrlConnection`, developers can make web requests and use the
    response.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可用于Xamarin目标平台的不同的客户端库之外，还可以使用一些原生实现来调用和接收外部网络数据。Xamarin.iOS平台上的一个可用选项是`NSUrlConnection`。借助`NSUrlConnection`，开发者可以发出网络请求并使用响应。
- en: 'A simple web request to retrieve the data from the previously demonstrated
    static data endpoint on iOS would look similar to this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的网络请求，用于从之前在iOS上演示的静态数据端点检索数据，看起来可能如下所示：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The implementation for the connection delegate would involve the deserialization
    of the data and assigning the result to the `TaskCompletionSource` so the method
    execution can be finalized.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 连接委托的实现将涉及数据的反序列化并将结果分配给`TaskCompletionSource`，以便完成方法执行。
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Even though this implementation is possible on the iOS platform, considering
    the cost of passing the mono to iOS bridge (likewise on Android and JNC Bridge),
    this type of implementation should be avoided, and either only native or mono
    runtime code should be used to communicate over the network.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此实现在iOS平台上是可能的，但考虑到将Mono传递到iOS桥接器（同样适用于Android和JNC桥接器）的成本，应避免此类实现，并且应仅使用原生或Mono运行时代码通过网络进行通信。
- en: In a similar manner, we can implement the usage scenario for the new `NSUrlSession`
    class in iOS. However, `NSUrlSession` can also be used in background download
    scenarios. Therefore, we will discuss it in the next section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以实现iOS中新的`NSUrlSession`类的使用场景。然而，`NSUrlSession`也可以用于后台下载场景。因此，我们将在下一节中讨论它。
- en: Background downloads
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景下载
- en: When the application requires larger network resources than the client UI can
    wait for, in Xamarin mobile applications we can resort to background downloads.
    Both iOS and Android platforms offer implementations for background downloads
    and these strategies can be executed on Xamarin runtime.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序需要的网络资源比客户端UI可以等待的更多时，在Xamarin移动应用程序中，我们可以求助于后台下载。iOS和Android平台都提供了后台下载的实现，这些策略可以在Xamarin运行时执行。
- en: For Xamarin.Android application developers, the easiest way to execute a background
    download is to use the Download Manager API service/application provided since
    API level 9\. The download manager can be initialized with a request and the application
    can subscribe to event notification(s) regarding the download status.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Xamarin.Android应用程序开发者来说，执行后台下载的最简单方法是从API级别9开始提供的下载管理器API服务/应用程序。下载管理器可以用请求初始化，并且应用程序可以订阅有关下载状态的事件通知。
- en: 'First, we need to create a request to pass onto the `DownloadManager`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个请求并将其传递给`DownloadManager`：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the request is ready to be executed, we can get the `DownloadManager`
    instance and queue the download request:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦请求准备就绪可以执行，我们可以获取`DownloadManager`实例并将下载请求排队：
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The download reference can be used to get the current status information about
    the queued download or cancel the ongoing background download.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用下载引用来获取排队下载的当前状态信息或取消正在进行的后台下载。
- en: To get the current status of the download or cancel it, we can use the respective
    methods on the `DownloadManager` instance.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取下载的当前状态或取消它，我们可以使用`DownloadManager`实例上的相应方法。
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This implementation can be extended with the notification(s) that are received
    from the `DownloadManager` application using a `BroadcastReceiver` class.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现可以通过使用`BroadcastReceiver`类从`DownloadManager`应用程序接收到的通知（复数）进行扩展。
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can now register the broadcast receiver with the `DownloadManager` instance
    and update the UI with a possible delegated implementation for updating it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将广播接收器注册到`DownloadManager`实例，并使用可能的委托实现来更新UI。
- en: '[PRE28]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: On top of the broadcasts mechanism, the Download Manager App UI can also be
    invoked within the Xamarin applications to give a uniform UI about on-going or
    completed transfers.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在广播机制之上，下载管理器应用 UI 也可以在 Xamarin 应用程序中调用，以提供关于正在进行或已完成传输的统一 UI。
- en: On the iOS platform (at least post iOS 7), background transfers (both download
    and upload operations) are made possible with `NSUrlSession`. `NSUrlSession` provides
    an easy to implement interface that lets developers create an efficient and reliable
    transfer processes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 平台（至少是 iOS 7 之后），后台传输（包括下载和上传操作）可以通过 `NSUrlSession` 实现。`NSUrlSession`
    提供了一个易于实现的接口，允许开发者创建高效且可靠的传输过程。
- en: The implementation strategy for `NSUrlSession` initially involves the implementation
    of an `NSUrlSessionDelegate`, which will be the responsible "handler" for the
    transfer process. Basic methods related to the health and status of the transfer
    are exposed through this delegate and can be implemented to provide required information
    for the transfer or give real-time updates to the application user.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSUrlSession` 的实现策略最初涉及实现一个 `NSUrlSessionDelegate`，它将成为传输过程的负责“处理程序”。与传输的健康和状态相关的基方法通过此代理公开，可以实施以提供传输所需的信息或向应用程序用户提供实时更新。'
- en: '`DidFinishEventsForBackgroundSession` is called when the background session
    is complete'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当后台会话完成时，会调用 `DidFinishEventsForBackgroundSession`。
- en: '`DidReceiveChallenge` is invoked when the server requests credentials'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当服务器请求凭证时，会调用 `DidReceiveChallenge`。
- en: '`DidBecomeInvalid` is invoked when there is a problem with the session'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当会话出现问题时，会调用 `DidBecomeInvalid`。
- en: '`NSUrlSessionDelegate` provides the base implementation for more specialized
    transfer delegates: `NSUrlSessionDownloadDelegate` for download operations and
    `NSUrlSessionTaskDelegate` for upload operations. These delegate classes expose
    additional status methods related to the transfer tasks (for example, download
    delegate provides methods to retrieve notifications about the download progress).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSUrlSessionDelegate` 为更专业的传输代理提供了基实现：`NSUrlSessionDownloadDelegate` 用于下载操作，`NSUrlSessionTaskDelegate`
    用于上传操作。这些代理类公开了与传输任务相关的附加状态方法（例如，下载代理提供了检索下载进度通知的方法）。'
- en: For instance, if we were to use the same example as on Xamarin.Android with
    the `BroadcastReceiver` implementation, the `NSUrlSessionDownloadDelegate` implementation
    would require three basic methods for completion, error, and progress.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们使用与 Xamarin.Android 中相同的示例，并且实现 `BroadcastReceiver`，则 `NSUrlSessionDownloadDelegate`
    的实现需要三个基本方法来完成、错误和进度。
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After the delegate implementation is complete, we can create the session and
    start the download operation using the `NSUrlSession`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在代表实现完成后，我们可以使用 `NSUrlSession` 创建会话并开始下载操作。
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: On top of the handler implementation, the iOS app can be woken to execute certain
    code, such as a local mobile notification to inform the user about the completed
    sessions. For the task complete event, one needs to use the iOS application delegate
    (refer to [Chapter 2](ch02.html "Chapter 2. Memory Management"), *Memory Management*)
    for `DidFinishEventsForBackgroundSession`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理程序实现的基础上，iOS 应用可以被唤醒以执行某些代码，例如本地移动通知，通知用户会话已完成。对于任务完成事件，需要使用 iOS 应用程序代理（参考[第
    2 章](ch02.html "第 2 章。内存管理")，*内存管理*），以 `DidFinishEventsForBackgroundSession`。
- en: Mobile notifications (also called pushed notifications for remote scenarios)
    are user notifications that are executed on the OS level to inform the user about
    application-related updates. They can be triggered both locally or by using a
    remote server.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 移动通知（也称为远程场景中的推送通知）是在操作系统级别执行的用户通知，用于通知用户有关应用程序相关的更新。它们可以通过本地触发或使用远程服务器触发。
- en: Push notifications
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推送通知
- en: Push notifications are subtle UI messages that can help an application to provide
    the user information about an asynchronous task being executed by the service
    layer or about an external event that is related to the application instance itself
    (for example, messages from social networks, approval for a travel reservation,
    and so on).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 推送通知是微妙的 UI 消息，可以帮助应用程序向用户提供有关服务层正在执行的非同步任务的信息，或者有关与应用程序实例本身相关的外部事件（例如，来自社交网络的消息、旅行预订的批准等）。
- en: It is possible to create and receive push notifications on both Xamarin platforms
    and Windows Phone. These notifications are triggered by a secondary server/application
    (for example, service layer), brokered by the corresponding messaging infrastructure
    provider for the platform and displayed by the application on the target client.
    For the Android platform, the messaging provider is **Google Cloud Messaging**
    (**GCM**) and it is the **Apple Notification Push Service** (**APNS**) for iOS.
    Both of these service providers require your application to be registered to receive
    push notifications and the server application to have the credentials to be able
    to authenticate with the notification services. Similarly, **Windows Notification
    Services** (**WNS**) adopts a federated authentication mechanism.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin 平台和 Windows Phone 上都可以创建和接收推送通知。这些通知由一个二级服务器/应用程序（例如，服务层）触发，由平台相应的消息基础设施提供商进行代理，并在目标客户端的应用程序中显示。对于
    Android 平台，消息提供者是 **Google Cloud Messaging** (**GCM**)，而对于 iOS，则是 **Apple Notification
    Push Service** (**APNS**)。这两个服务提供商都要求您的应用程序注册以接收推送通知，并且服务器应用程序需要有凭证以便能够与通知服务进行身份验证。同样，**Windows
    Notification Services** (**WNS**) 采用联合身份验证机制。
- en: Both GCM and APNS use a subscription model in which the client app on a specific
    device subscribes/registers for the push notifications and an addressing token
    is created. The addressing token is used, later on, by the server to send push
    notifications to the message broker service (for example, GCM) and the queued
    messages are delivered to the specific client.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: GCM 和 APNS 都使用订阅模型，其中特定设备上的客户端应用程序订阅/注册推送通知，并创建一个地址令牌。该地址令牌随后被服务器用于向消息代理服务（例如，GCM）发送推送通知，并将队列中的消息递送到特定的客户端。
- en: '![Push notifications](img/B04693_05_15.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![推送通知](img/B04693_05_15.jpg)'
- en: Push Notifications
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 推送通知
- en: On top of the classic messaging model, GCM also supports topic-based and group-based
    messages where the receivers are not limited to a single device/application pair.
    It is also possible with GCM to create a duplex channel where the client is able
    to send messages back to the server layer.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典的短信模型之上，GCM 还支持基于主题和基于群组的消息，接收者不限于单一设备/应用程序对。使用 GCM 还可以创建一个双向通道，客户端能够将消息发送回服务器层。
- en: Push notifications on these platforms can be used to trigger various tasks,
    the most common of which is to navigate to a certain view and continue the business
    process flow initialized by the notification.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些平台上，推送通知可以用来触发各种任务，其中最常见的是导航到某个视图并继续由通知初始化的业务流程。
- en: Although it is relatively elementary on the client side to subscribe to push
    notifications, cross-platform scenarios require complex implementation to introduce
    a single server environment to provide messages to both GCM and APNS. However,
    there are platform-agnostic implementations available for both of these platforms.
    The Microsoft Azure platform and the notification hub is one of these solutions,
    where communication with GCM and APNS are both supported through usage of the
    same business logic implementation.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在客户端订阅推送通知相对简单，但在跨平台场景中，需要复杂的实现来引入一个单一的服务器环境，为 GCM 和 APNS 提供消息。然而，这两个平台都有平台无关的实现。Microsoft
    Azure 平台和通知中心就是这些解决方案之一，其中与 GCM 和 APNS 的通信都是通过使用相同的业务逻辑实现来支持的。
- en: Cloud integration
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云集成
- en: Even though there are multiple cloud service providers as development platforms
    for creating the backend for mobile applications, Microsoft Azure stands out among
    the competitors with its inherent natural bond to the .NET platform and subsequently
    Xamarin, considering its evolution. Most of the features supported by Azure have
    a specific implementation for Xamarin target platforms.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有多个云服务提供商作为移动应用程序后端开发平台，但考虑到其与 .NET 平台以及随后的 Xamarin 的固有自然联系，Microsoft Azure
    在竞争对手中脱颖而出。Azure 支持的大多数功能都有针对 Xamarin 目标平台的特定实现。
- en: Azure Mobile Services
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure 移动服务
- en: Azure Mobile Services is a scalable cloud development platform that helps developers
    add functionality to their mobile applications with ease. The patterns and features
    described in this chapter related to network services such as OData services,
    offline data storage, push notifications, and OAuth authentication providers are
    already included in the mobile services SDK and can be configured through the
    Azure management console.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 移动服务是一个可扩展的云开发平台，它帮助开发者轻松地将功能添加到他们的移动应用程序中。本章中描述的与网络服务相关的模式和功能，如 OData
    服务、离线数据存储、推送通知和 OAuth 认证提供者，已经包含在移动服务 SDK 中，并且可以通过 Azure 管理控制台进行配置。
- en: In order to demonstrate aforementioned features, we can incorporate them into
    our demo application.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示上述功能，我们可以将它们集成到我们的演示应用程序中。
- en: The initial step would be to create a mobile service on the Azure management
    console. For this purpose, we will select a compute service and create the mobile
    service.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首步是在 Azure 管理控制台中创建一个移动服务。为此，我们将选择一个计算服务并创建移动服务。
- en: '![Azure Mobile Services](img/B04693_05_16.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![Azure 移动服务](img/B04693_05_16.jpg)'
- en: Create Compute Service
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 创建计算服务
- en: Then, we will set up the mobile service endpoint and create the SQL database
    to store the online data.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将设置移动服务端点并创建 SQL 数据库以存储在线数据。
- en: '![Azure Mobile Services](img/B04693_05_17.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![Azure 移动服务](img/B04693_05_17.jpg)'
- en: Mobile Service Setup
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 移动服务设置
- en: Once the setup is complete, the "personalized" service layer project can be
    downloaded in order to integrate the mobile services into the application project.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置完成，就可以下载“个性化”的服务层项目，以便将移动服务集成到应用程序项目中。
- en: '![Azure Mobile Services](img/B04693_05_18.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![Azure 移动服务](img/B04693_05_18.jpg)'
- en: Connect Mobile Services to an existing Xamarin app
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 将移动服务连接到现有的 Xamarin 应用
- en: In the service layer project, you will notice that there is only a single controller
    created for your convenience. We will be extending the project with additional
    controllers and adding a reference to our own DTO data model. In order to reuse
    the types created in the previous sections, instead of referencing the common
    data model project directly, we add the data type files as a reference to the
    new service project that we downloaded from the Azure portal. The reason for the
    referenced files is that the data objects in the service project have to derive
    from `EntityData` class. Another change we need to make is to convert the class
    definitions to partial and remove the SQLite references, for example, you can
    comment out the SQLite property descriptors or use conditional compilation.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务层项目中，您会注意到只创建了一个控制器以方便您使用。我们将通过添加额外的控制器并将对自定义 DTO 数据模型的引用添加到我们从 Azure 门户下载的新服务项目中来扩展项目。之所以添加引用的文件，是因为服务项目中的数据对象必须从
    `EntityData` 类派生。我们需要进行的另一个更改是将类定义转换为部分并移除 SQLite 引用，例如，您可以注释掉 SQLite 属性描述符或使用条件编译。
- en: In this example, we are using `AZURE` as the build constant for the Azure web
    service.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用 `AZURE` 作为 Azure 服务的构建常量。
- en: '[PRE31]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, create a data object definition using a `partial` declaration for
    the `Region` class:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `partial` 声明为 `Region` 类创建数据对象定义：
- en: '[PRE32]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After this step, you can simply use the existing project item template for the
    controller to add the specialized data endpoint (Microsoft Azure Mobile Services
    Table Controller).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在此步骤之后，您可以直接使用现有的控制器项目模板来添加专门的数据端点（Microsoft Azure 移动服务表控制器）。
- en: '![Azure Mobile Services](img/B04693_05_19.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![Azure 移动服务](img/B04693_05_19.jpg)'
- en: Microsoft Azure Mobile Services Table Controller
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Azure 移动服务表控制器
- en: This will create a controller for the data object and insert the type into the
    data context.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为数据对象创建一个控制器并将类型插入到数据上下文中。
- en: Once the project is published and the mobile services are running, SQL database
    tables are going to be migrated automatically. This migration also applies to
    data table column changes or future additions to the DTO model.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目发布并且移动服务正在运行，SQL 数据库表将自动迁移。此迁移也适用于数据表列更改或 DTO 模型未来的添加。
- en: Now we can add the NuGet package or the component to our client application
    and add the necessary initialization code, as described in the start page of mobile
    services section on the Azure management console.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在客户端应用程序中添加 NuGet 包或组件，并添加必要的初始化代码，如 Azure 管理控制台移动服务部分起始页面所述。
- en: 'In the main activity, we create the following mobile service instance:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在主活动中，我们创建了以下移动服务实例：
- en: '[PRE33]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following to an event handler or the `OnCreate` function:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到事件处理程序或 `OnCreate` 函数中：
- en: '[PRE34]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After the code is successfully executed, the data on the Azure database can
    be observed using SQL Management Studio or the Visual Studio SQL Server tools.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 代码成功执行后，可以使用 SQL Management Studio 或 Visual Studio SQL Server 工具观察 Azure 数据库中的数据。
- en: '![Azure Mobile Services](img/B04693_05_20.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![Azure 移动服务](img/B04693_05_20.jpg)'
- en: Azure Data Sample
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 数据示例
- en: Now that we have a working service layer and a client that can communicate with
    it, we can have a look at the local synchronization.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个可以与之通信的工作服务层和客户端，我们可以看看本地同步。
- en: Azure offline data
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure 离线数据
- en: For local data caching and offline scenarios, Azure Mobile Services SDK already
    implements a synchronization framework where the local data is stored in SQLite
    database and the synchronization is handled by pull and push commands (push requests
    upload local changes to the cloud store whereas pull requests download the latest
    changes from the server) using a default conflict handler. Each pull request automatically
    issues a push request where the local data is pushed to the cloud storage. Conflicts
    are resolved according to the created and updated fields, which are members of
    each object type defined using the `EntityData` base class.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地数据缓存和离线场景，Azure Mobile Services SDK 已经实现了一个同步框架，其中本地数据存储在 SQLite 数据库中，同步由拉取和推送命令（推送请求将本地更改上传到云存储，而拉取请求从服务器下载最新更改）处理，使用默认的冲突处理器。每个拉取请求都会自动发出一个推送请求，其中本地数据被推送到云存储。冲突根据创建和更新的字段解决，这些字段是使用
    `EntityData` 基类定义的每个对象类型的成员。
- en: Note
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before starting the implementation, we need to download and install the Azure
    Mobile Services SQLiteStore NuGet package.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现之前，我们需要下载并安装 Azure Mobile Services SQLiteStore NuGet 包。
- en: In order to initialize the default local data store, we will use the `MobileServicesSQLiteStore`
    implementation. Custom local store implementation can be incorporated using the
    `IMobileServiceLocalStore` interface.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化默认的本地数据存储，我们将使用 `MobileServicesSQLiteStore` 实现。可以通过 `IMobileServiceLocalStore`
    接口集成自定义本地存储实现。
- en: '[PRE35]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After the local store is initialized and the synchronization context is created,
    we can implement the synchronization method that can be called every time the
    application starts.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地存储初始化和同步上下文创建之后，我们可以实现每次应用程序启动时都可以调用的同步方法。
- en: '[PRE36]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Both the `PushAsync` and `PullAsync` methods additionally accept filter expressions
    so one can limit the synchronization to certain entities.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`PushAsync` 和 `PullAsync` 方法还接受过滤表达式，因此可以限制同步到某些实体。'
- en: In this implementation, once the synchronization context is in place, if the
    service connection is not available, the `IMobileServiceSyncTable<T>` interface
    implementations handle the offline data and the data is kept in the local store
    until the next push operation.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实现中，一旦同步上下文就绪，如果服务连接不可用，`IMobileServiceSyncTable<T>` 接口实现将处理离线数据，并且数据将保存在本地存储中，直到下一次推送操作。
- en: Azure authentication
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure 身份验证
- en: The Azure platform provides various authentication mechanisms for Xamarin mobile
    applications. Each authentication mechanism can be integrated into existing mobile
    applications with a service backend through NuGet packages and/or components.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 平台为 Xamarin 移动应用程序提供各种身份验证机制。每种身份验证机制都可以通过 NuGet 包和/或组件集成到现有的具有服务后端的移动应用程序中。
- en: Being a multi-tenant, cloud-based directory and identity management service,
    Azure Active Directory (Azure AD) provides application developers an easy way
    to create single sign-on experience on a large number of cloud SaaS applications.
    It is also possible to incorporate an existing Windows Server Active Directory
    into applications and leverage the existing on-premise identity stores. These
    features make the Azure AD an ideal candidate for LOB applications.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 作为多租户、基于云的目录和身份管理服务，Azure Active Directory (Azure AD) 为应用程序开发者提供了一种简单的方法，在大量云
    SaaS 应用程序上创建单点登录体验。还可以将现有的 Windows Server Active Directory 集成到应用程序中，并利用现有的本地身份存储。这些功能使
    Azure AD 成为 LOB 应用程序的理想候选者。
- en: Another authentication strategy for Azure Mobile Services is to configure an
    existing authentication provider such as Facebook, Google, Twitter, or Microsoft
    and secure the service requests using the Azure Mobile SDK. In order to register
    an authentication provider, the first step would be to create a consumer app on
    the target platform.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Azure移动服务的另一种身份验证策略是配置现有的身份验证提供者，如Facebook、Google、Twitter或Microsoft，并使用Azure移动SDK来保护服务请求。为了注册身份验证提供者，第一步是在目标平台上创建一个消费者应用程序。
- en: For instance, if we were to use Live ID for our authentication scenarios, we
    would need to use the Live Connect App management site ([https://account.live.com/developers/applications/index](https://account.live.com/developers/applications/index)).
    Similarly, for Twitter, we would need to create a Twitter consumer application
    on the Twitter application management console ([https://apps.twitter.com/](https://apps.twitter.com/)).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们要在我们的身份验证场景中使用Live ID，我们需要使用Live Connect应用程序管理网站([https://account.live.com/developers/applications/index](https://account.live.com/developers/applications/index))。同样，对于Twitter，我们需要在Twitter应用程序管理控制台([https://apps.twitter.com/](https://apps.twitter.com/))上创建一个Twitter消费者应用程序。
- en: '![Azure authentication](img/B04693_05_21.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![Azure身份验证](img/B04693_05_21.jpg)'
- en: Live Connect app management site
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Live Connect应用程序管理网站
- en: Once the application setup is in place, the Azure management console can be
    used to update the mobile services configuration.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好应用程序，就可以使用Azure管理控制台来更新移动服务配置。
- en: '![Azure authentication](img/B04693_05_22.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![Azure身份验证](img/B04693_05_22.jpg)'
- en: Mobile Services Identity Configuration
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 移动服务身份验证配置
- en: After the identity provider for the mobile services has been set up, the web
    service project can be easily protected simply by adding the Authorize attribute.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好移动服务的身份提供者之后，只需通过添加Authorize属性，就可以轻松保护Web服务项目。
- en: '[PRE37]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: On the client apps, the authentication is handled by simply using the `LoginAsync`
    method on the Azure Mobile Services SDK client with the correct authentication
    provider.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端应用程序中，通过在Azure移动服务SDK客户端上使用正确的身份验证提供者的`LoginAsync`方法，可以简单地处理身份验证。
- en: '[PRE38]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The result is the same authentication screen received using the Xamarin.Auth
    component.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是使用Xamarin.Auth组件接收到的相同的身份验证屏幕。
- en: '![Azure authentication](img/B04693_05_23-1.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![Azure身份验证](img/B04693_05_23-1.jpg)'
- en: Brokered Authentication
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 代理身份验证
- en: Azure Cloud integration scenarios extend far beyond the ones described here.
    The features that are included in this cloud-based development platform can help
    developers enhance their Xamarin apps with ease and scalability.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Azure云集成场景远不止这里所描述的。这个基于云的开发平台所包含的功能可以帮助开发者轻松且可扩展地增强他们的Xamarin应用程序。
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided an overview of various network channels that can be used
    in Xamarin applications to create connected applications.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了在Xamarin应用程序中创建连接应用程序时可以使用的各种网络通道。
- en: Web services are definitely on the essentials list for modern mobile applications
    because of the interoperability of the protocols in place for web services (both
    SOAP/XML and REST/JSON). Unfortunately, XML services are a little harder to integrate
    with Windows Phone 8.1 runtime (even though they are still supported by Windows
    Phone Silverlight runtime) because the Windows Communication Foundation client
    infrastructure is not included in Windows Phone runtime. However, the same RESTful
    service proxies can be used by applications on each Xamarin target platform and
    Windows Phone.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现有Web服务协议的互操作性（无论是SOAP/XML还是REST/JSON），Web服务无疑是现代移动应用程序的基本列表之一。不幸的是，由于Windows
    Communication Foundation客户端基础设施不包括在Windows Phone运行时中，XML服务与Windows Phone 8.1运行时的集成稍微困难一些（尽管它们仍然由Windows
    Phone Silverlight运行时支持）。然而，相同的RESTful服务代理可以在每个Xamarin目标平台和Windows Phone上使用。
- en: Cloud integration options such as mobile services and Azure Active Directory
    were discussed with demonstration samples. Each of these technologies provides
    additional connectivity and integration opportunities for Xamarin mobile apps.
    SignalR is another web technology that grants additional communication capabilities
    to mobile applications by means of bidirectional communication between the client
    apps and the server.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论了如移动服务和Azure Active Directory之类的云集成选项，并提供了演示示例。这些技术中的每一个都为Xamarin移动应用程序提供了额外的连接性和集成机会。SignalR是另一种网络技术，通过客户端应用程序和服务器之间的双向通信，为移动应用程序提供了额外的通信能力。
- en: Several common service and web implementation patterns were demonstrated using
    the TravelTrace application scope that we will be using for various scenarios
    in the remainder of this book. Each pattern described targets different quality
    identifiers initially mentioned.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TravelTrace应用程序范围演示了几个常见的服务和Web实现模式，这些模式将在本书剩余部分的各种场景中使用。每个模式最初都针对不同的质量标识符。
- en: Finally, we discussed some of the platform-specific network options.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了一些特定平台的网络选项。
