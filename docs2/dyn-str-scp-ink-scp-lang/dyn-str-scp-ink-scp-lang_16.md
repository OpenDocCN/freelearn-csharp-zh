# 第十三章：评估

本节包含所有章节的问题答案。

# 第一章 – 文本、流程、选择和编织

1.  故事是内容，叙述是体验。在非线性叙事中，故事可能以不同的顺序体验，每次重新排序都会为读者创造一个新的叙述。

1.  ink 将流程理解为作为类似叙述体验的故事中的移动。在 ink 中，当没有通往故事结尾的路径时，这可能会“耗尽”。

1.  可以使用粘合剂将多行组合在一起，粘合剂是小于和大于符号的组合。

1.  编织是一系列选择的集合。

1.  不同的选择类型有基本型、通常称为消失型选择和粘性选择。第一种只能使用一次，第二种可以多次使用，因为它们“粘附”在编织使用中。

1.  选择性输出允许作者根据 ink 中选择的文本选择在塑造选项时要使用的内容。可以根据使用开闭方括号和选择文本的文本显示给读者的不同数量的文本。

1.  粘性选择保持选项打开以供以后使用。在更复杂的故事中，读者可能返回到编织并选择不同的或相同的选项。

# 第二章 – 节点、引导和循环模式

1.  节点是故事的一个部分，有一个名字，可以被引导到墨迹中。

1.  `DONE` 结束当前流程，`END` 完全停止故事。

1.  缝是故事的一个子部分，只能出现在节点内。

1.  `INCLUDE` 关键字将其他文件拉入，允许项目使用具有自己节点和缝的多个文件，这些节点和缝对整个项目都是可用的。

1.  标记的选项在每次显示时都会创建一个增加的值。另一方面，条件值允许比较变量和值。如果使用选项时条件为真，它将被显示。否则，它将被隐藏。

# 第三章 – 序列、循环和文本洗牌

1.  三种替代类型是序列、循环和洗牌。

1.  序列、循环和洗牌的单行形式都使用元素之间的垂直线 `|`。

1.  在第一个元素之前使用 `&` 符号作为创建循环的替代。

1.  序列将显示每个元素直到最后一个。循环将在最后一个元素之后返回到第一个元素。

1.  洗牌在每次运行时都会从其集合中随机选择一个元素。

1.  多行序列使用 `stopping` 关键字。这与循环和洗牌不同，它们各自使用替代类型的名称作为关键字来创建它们的多行形式。

# 第四章 – 变量、列表和函数

1.  赋值发生在变量被赋予新值时。这发生在变量在墨迹中首次创建时，也可能发生在单行代码中。

1.  基于两个字符串相加或字符串与数值之间创建的新字符串称为连接。

1.  波浪号定义了 ink 中的一行代码。它通常与赋值、调用函数或执行其他单行操作一起使用。

1.  列表中的值是布尔集的一部分。这意味着它们是`true`或`false`。在 ink 中，默认情况下，列表中的所有值都设置为`false`。要更改为`true`，它们必须被括号包围。

1.  将作为函数或结的一部分定义的变量称为参数。它影响计算或函数如何处理内容。

# 第五章 – 地道和线程

1.  要创建地道，必须在结或缝合的名称前后使用转向。在结或缝合内部，必须一起使用两个转向以从地道返回。

1.  地道连接墨水中的两个不同位置。它们可以在故事中的结、缝合或其他位置之间使用。地道将流动移动到某个位置，然后在遇到两个转向时返回。

1.  转向将流动移动到另一个结或缝合。地道使用两个转向移动到结或缝合，然后返回到起始位置。线程是转向的逆。它将结或缝合移动到当前流动位置，而不是将流动移动到结或缝合。

1.  通常，同一行上不能使用多个线程。然而，当使用替代方案时，可以将多个线程作为同一结构的一部分包含在内。它们仍然逐个访问，但可以在同一行上分组。

# 第六章 – 添加和使用 ink-Unity 集成插件

1.  不，Inkle，ink-Unity 集成插件的维护者，不建议使用在 Unity Asset Store 中找到的版本。这个版本通常过时。

1.  当在项目中安装 ink-Unity 集成插件时，可以使用创建菜单创建新的 ink 文件。这可以通过**项目**窗口工具栏、在**项目**窗口中右键单击或通过**资产**菜单选择**创建**来访问。

1.  Inky 是编辑 ink 源文件的不错选择。然而，它需要与 ink 源文件关联，这些文件可以通过在**项目**窗口中双击文件来打开。

1.  是的，可以通过打开**项目**设置、选择**ink**然后更改**自动编译所有 ink**选项来调整自动编译过程。

# 第七章 – Unity API – 制作选择和故事进展

1.  `Continue()`方法仅在每次调用时加载一行 ink 文本内容和遇到的下一个编织。`ContinueMaximally()`方法加载所有文本内容，直到遇到编织或故事的结尾。

1.  `ChooseChoiceIndex()`方法期望在`Story`类中`currentChoices`属性的条目总数范围内的`int`值。

1.  `canContinue` 属性是一个布尔值。如果有更多的剧情内容，它将是 `true`。否则，它将是 `false`。在使用 `Continue()` 或 `ContinueMaximally()` 方法之前，应始终将 `canContinue` 属性作为条件语句的一部分进行检查，以防止任一方法抛出错误。

1.  Prefab 是在 Unity 中保存为资产的 `GameObject` 实例。任何用作 **Hierarchy** 视图一部分的游戏对象都可以通过将其拖入 **Project** 窗口来保存为资产。在 Unity 中，可以通过称为 *实例化* 的过程在运行时创建 prefab 的副本。

1.  对于在运行的 ink 剧情中遇到的编织内容，`currentChoices` 属性将包含一个 `List<Choice>` 实例，其中每个条目都是基于 `Choice` 类的对象，具有 `text` 和 `index` 属性。

# 第八章 – Story API – 访问 ink 变量和函数

1.  是的，一旦在 ink 中创建了一个变量，就可以在任何剧情点访问它。通过使用 Story API 的一部分 `variablesState` 属性，也可以访问和更改变量的值。

1.  由于函数在 ink 中是全局的，这意味着可以从 ink 剧情的任何点访问它们。当使用 ink-Unity Integration 插件时，Story API 中的 `HasFunction()` 和 `EvaluateFunction()` 方法提供了在 ink 剧情中测试全局函数并评估它的能力。`EvaluateFunction()` 方法调用 ink 函数，并可以使用 `out` C# 关键字将数据传递给 ink 或检索函数的文本输出。

1.  与文本内容不同，ink 中变量的值存在于由 `Continue()` 方法或 `ContinueMaximally()` 方法控制的剧情进展之外。然而，由于变量是全局的，它们在加载一行或更大块的故事内容时可以被更改。变量的值可能会因为使用 `Continue()` 方法或 `ContinueMaximally()` 方法而改变，但它们在技术上并不是处理 ink 中的变量所必需的。

1.  在使用 Story API 中的 `variablesState` 属性时，可以通过在方括号内使用引号包裹的变量名来访问任何变量。虽然相同的 API 提供了在 ink 中处理变量的方法，但简写语法通常是访问和更改变量值的首选方式。

1.  是的。在尝试更改变量值或评估函数之前，建议使用 `HasFunction()` 方法来处理函数。这将有助于防止可能的游戏崩溃问题。

1.  `out` C# 关键字提供了一种通过引用传递变量而不是仅传递其值的方法。这是将 ink 函数的文本输出作为 Story API 的 `EvaluateFunction()` 方法的参数检索的一种简单方式。

# 第九章 – Story API – 观察和响应剧情事件

1.  `ObserveVariable()`和`ObserveVariables()`方法基于对变量观察动作的使用。这使 Unity 的反应与 ink 中的动作分离。观察动作允许 Unity 以任何它想要的方式做出反应。这些方法只提供变量的名称及其新值。

1.  委托函数是`ObserveVariable()`和`ObserveVariables()`方法的第二个参数。使用`delegate` C#关键字将函数的运行委托给另一个函数或方法。`ObserveVariable()`和`ObserveVariables()`方法用于回调方法。

1.  第一个方法是`ObserveVariable()`，它接受一个变量的名称和一个在变量变化时被调用的委托函数。第二个方法是`ObserveVariables()`，它接受一个要监视的变量`List<string>`实例和一个委托函数。在这两种情况下，委托函数都会被调用，并传入变化变量的名称及其新值。

1.  `variablesState`属性通过名称直接访问 ink 变量及其当前值。然而，必须使用 ink 变量的名称来访问其值，作为重复代码的一部分，例如在 Unity 中的`Update()`或`FixedUpdate()`方法中。`ObserveVariable()`和`ObserveVariables()`方法允许开发者编写只有在一个或多个 ink 变量发生变化时才运行的代码，并且仅在那时运行。这可以在每个周期中节省时间，只运行必要的代码，然后在 ink 本身更新某些值时更新 Unity。

# 第十章 – 使用 ink 的对话系统

1.  当在墨迹中单行上使用哈希（`#`）来创建标签时，会创建一个哈希标签。哈希标签用于在每行添加额外数据。

1.  哈希标签只能用于行尾，但说话标签通常用于行首。说话标签总是用来标记谁在进行交流，但哈希标签传达任何形式的其他信息。

1.  对话的分支模式通常看起来像树，初始的选项集合看起来像“树干”，每个分支向外扩展到它自己的集合中。

1.  列表模式以垂直排列的方式呈现选项。它可以显示每个选项的多个句子，但通常需要滚动条来呈现集合中的所有选项。当有更多视觉空间用于对话选项时，它最好使用。

1.  径向菜单模式以顺时针方向在屏幕上呈现选项。它通常与视频游戏控制台或其他有限视觉空间环境一起使用。由于空间减少，选项通常以单个单词、图标或其结果的简短描述的形式出现。

# 第十一章 – 任务跟踪和分支叙事

1.  任务是一系列与故事中角色相关的事件。

1.  用于推进任务的 ink 节点名称是`progress`。

1.  `ChoosePathString()`方法会突然将当前位置从一个部分移动到另一个部分。

1.  Unity 中的全局属性命名为`Application.dataPath`。

1.  投票需要检查一个系统中的值与另一个系统中的值。基于事件的方法允许一个系统观察另一个系统，并在事件发生时对其做出响应。

# 第十二章 – 使用 ink 进行程序化叙事

1.  **程序化叙事**发生在项目的叙事是通过程序或规则生成的，这些程序或规则动态地规划或塑造为玩家提供的内容时。

1.  **随机表**是一组条目，其中个别值是随机选择的。最初作为使用骰子选择行的表格创建，这个概念可以在 ink 中使用洗牌来实现。

1.  可以使用`RANDOM()`函数来决定条目的概率，而不是在启用洗牌功能时使用默认的等量分配。

1.  **语法**是一套语言的规则。替换语法根据一套规则决定单词或短语的替换。通常，替换语法会与随机条目或根据条件规则一起使用。

1.  **故事规划**是基于规则对故事内容进行排序。故事规划基于使用替换语法来决定玩家可能会体验项目中的哪些部分，无论是在游戏开始之前还是由于某些玩家行为。
