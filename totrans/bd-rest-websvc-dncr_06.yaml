- en: Testing RESTful Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A system cannot mature until it is tested in various scenarios. These scenarios
    are usually based on the experience of domain experts or existing production environments.
    There is always a chance that a system can crash in a production environment,
    even when the system is called a perfect system. For web applications, the conditions
    are even more critical due to performance glitches, bad user experience, and so
    on. A system should be put through a process or series of development principles
    to tackle these kinds of issues. Simply put, we must test the system. Testing
    is a process that ensures the quality of a system.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, quality assurance, or testing, is a way to assess a system from
    different aspects. This process is also useful when a system requires testing
    to identify erroneous code, or if we want to assess its business compliance.
  prefs: []
  type: TYPE_NORMAL
- en: Quality assurance is a process that assesses a system and ensures its quality.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is entirely dependent on the architectural style of the system and it
    varies from system to system; everything depends on how we strategize our testing
    approach or plan.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will mainly focus on testing RESTful services and making
    our code better by following the test-driven development approach. At the end
    of this chapter, you will be able to use the testing paradigm in day-to-day development
    activities with knowledge of stubs, mocks an understanding of integration and
    security, and performance testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Test paradigms (the basics of quality assurance, including test case creation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the ASP.NET core controller (unit testing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stubs and mocking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fake objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing service calls using Postman, Advanced RESTClient, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User acceptance testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance or load testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test paradigms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw that testing and quality assurance is one of
    the most important parts of the software development cycle. We should take steps
    to design a framework that tests the software, which is called a **test paradigm**.
  prefs: []
  type: TYPE_NORMAL
- en: A test paradigm is a framework of testing. It is based on the way one plans
    on implementing testing. In short, a test paradigm is a testing methodology.
  prefs: []
  type: TYPE_NORMAL
- en: A test method is where you decide how to create test cases, including what its
    language will be, how you will document the test cases, and so on. This also tells
    you how you are going to execute the test methods (for example, with black box
    testing).
  prefs: []
  type: TYPE_NORMAL
- en: A test method is an approach that tests or verifies the specific output on the
    basis of specific inputs, without knowing the internal functionality of a system.
  prefs: []
  type: TYPE_NORMAL
- en: Before we create test cases or develop a test paradigm or framework for testing,
    we need to get to grips with some important terminology.
  prefs: []
  type: TYPE_NORMAL
- en: Test coverage and code coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general terms, coverage is what is covered and how you measure that coverage.
    From a developer's point of view, writing a unit test in test-driven development
    tells us how and what area of code is covered.
  prefs: []
  type: TYPE_NORMAL
- en: A measurement of code executed during testing is code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: A measurement of test cases executed during testing is test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: The code is unit tested and it is proven that covered code is tested. In this
    code coverage, there would be many things that have been covered, namely, lines
    of code, functions, conditions, expressions, API resources, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: For software testing terms, refer to [http://castb.org/wp-content/uploads/2014/05/istqb_glossary_of_testing_terms_v2.3.pdf](http://castb.org/wp-content/uploads/2014/05/istqb_glossary_of_testing_terms_v2.3.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'Test coverage and code coverage can also cover any of the following testing
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the upcoming sections, we will look at these tests in detail using code examples.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks, scenarios, and use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When someone is working with a test paradigm, they should know the terms task,
    scenario, and use case. In this section, we will discuss these terms in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task**: A task is a generic word not only relevant to the software industry
    but to many others, too. This is an act or piece of work that needs to be completed.
    There will be different ways to complete the task, but the overall intention with
    a task is that it should be completed. In different areas, tasks have different
    purposes. In scrum development ([https://whatis.techtarget.com/definition/storyboard](https://whatis.techtarget.com/definition/storyboard)),
    a storyboard or task board helps developers understand the work that needs to
    be completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates what we mean by a task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fc656b2-600e-46d8-91ce-87c5ca35cf67.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram is that of a story or task board; it displays the various
    tasks needed to finish a book, from data collection to the technical review. There
    are a lot of free or paid tools available on the market to manage these types
    of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario**: Typically, a scenario is nothing but a situation where a system
    has failed after interaction with a customer. In other words, a scenario is a
    way of understanding and writing steps in detail. For example, there are a few
    situations that can cause a system''s login functionality to fail, and these will
    be documented as a scenario. In software testing, scenarios are also known as
    test scenarios. A scenario usually leads to one or more tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use case**: A use case is a set of possible sequences of interactions between
    a system and a user. It can also be a collection of possible scenarios that should
    be assessed when a system is implemented. These use cases are more detailed and
    documented, and are divided into various steps, as shown in the following flowchart:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/b2948f3e-a32d-4cd8-9be3-b9fdefae3de7.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, it is clear that **TEST CASE** is the sub-set of **TEST
    SCENARIOS**, and that **USE CASE** is the superset of **TEST SCENARIOS**. Whenever
    you create a test case, it comes down from a test scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Checklist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, a checklist is nothing but a list of items, where an action is required
    in order to achieve a goal. A checklist could be a to-do list, a list of your
    day-to-day activities, or a list of a developer's tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of testing, a list could contain test cases to verify, a list of
    tests that need to be executed, and so on. A checklist varies from person to person,
    developer to developer, or even from organization to organization, but the purpose
    of a checklist is always to limit the very human behavior of forgetting something.
  prefs: []
  type: TYPE_NORMAL
- en: Bugs and defects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The terms bug and defect are the some of the most frequently used terms in the
    industry. In some organizations, these terms are used interchangeably. In general,
    however, a bug is related to something that is done correctly but executes an
    unexpected output, for example, 2 + 3 = 6\. On the other hand, a defect is something
    that has been missed during planning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some things to note about bugs and defects:'
  prefs: []
  type: TYPE_NORMAL
- en: A bug is almost always due to the impure implementation of a requirement, for
    example, code that incorrectly fulfills a basic requirement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bugs are normally identified during development or in the testing phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A defect is related to a design or requirements gap that has slipped past a
    client or customer during production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A defect often indicates human error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bugs can be fixed when caught during testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defects can lead to a faulty system, which can lead to design issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, a testing approach is an execution path illustrating how testing
    will be carried out. These approaches vary system to system; if one system requires
    a consultative approach, it does not mean that another system does. Different
    systems need different testing approaches.
  prefs: []
  type: TYPE_NORMAL
- en: A testing approach is a test strategy that is nothing but an implementation
    of a system or project.
  prefs: []
  type: TYPE_NORMAL
- en: Testing strategies should be clear to everyone so that the created tests can
    help non-technical members of the team (such as stakeholders) understand how the
    system is working. Such tests can be automated, such as testing the business flow,
    or they can be manual tests that can be performed by a user working on the User
    Acceptance Testing system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing strategies or approaches have the following techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Proactive**: This is a kind of early approach and tries to fix defects before
    the build is created from initial test designs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reactive**: In this approach, testing is started once coding is complete'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test pyramid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The testing pyramid is a strategy or a way of defining what you should test
    in RESTful services. In other words, we can say a test pyramid helps us to define
    the testing scope of RESTful services.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of the testing pyramid was developed by Mike Cohn ([http://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid](http://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid))
    in 2009.
  prefs: []
  type: TYPE_NORMAL
- en: There are various flavors of the testing pyramid; different authors have described
    this by indicating how they placed or prioritized their testing scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the same concept as defined by Mike Cohn:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1feb9ca-0354-4166-aa4d-0919ac8ed78c.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's talk about these layers in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests**: These are tests that test small functionalities in units of
    an application of RESTful services developed in ASP.NET Core'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RESTful service tests (Acceptance tests)**: These are tests that test an
    independent service or a service that communicates with another, often external,
    service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GUI tests (REST Client Tests)**: These tests belong to the client or consumer
    who will consume RESTful services; they help in testing an entire system with
    an aspect of the user interface and are end-to-end tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be discussing testing in respect to an application of a RESTful service
    developed in ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Types of tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we discussed test approaches or testing strategies.
    These strategies decide how we will proceed with the testing of a system. In this
    section, we will discuss the various types of tests used in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the ASP.NET Core controller (unit testing)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests are tests that typically test a single function call to ensure that
    the smallest piece of the program is tested. So, these tests are meant to verify
    specific functionality without considering other components. Here, testing strategies
    come in handy and ensure that the best quality assurance of a system will be performed.
    It adds more power when it comes with the **test-driven development** (**TDD**)
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn and practice TDD with the help of Katas at [https://github.com/garora/TDD-Katas](https://github.com/garora/TDD-Katas).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss this with the help of a code example. Before we proceed further,
    please take a look at the following prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2017 Update 3 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core 2.0 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# 7.0 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASP.NET Core 2.0 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entity Framework Core 2.0 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: xUnit and MS tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The moq framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready for the tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create an ASP.NET Core API and then unit test it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete the following steps to create your application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to File | New | Project or press *Ctrl* + *Shift* + *F5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c8aa8911-2719-4598-8e60-d91b0d2ec725.png)'
  prefs: []
  type: TYPE_IMG
- en: Select ASP.NET Core Web Application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the template window, select ASP.NET Core API—make sure you select .NET
    Core 2.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the project, choose the path for the solution, and click OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Core` folder—in Solution Explore, right-click and select Add New Folder,
    and name it `Model`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Interfaces` and `Model` folders under the `Core` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class under the `Model` folder—right-click on the `Model` folder in
    Solution Explorer and select Add New Item. Then, select **Class** or click *Shift*
    + *Alt* + *C.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please note that the shortcut key varies as per your settings for Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Name it`Product.cs` and add the following code to this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Repeat *steps 7* and* 8* to add `Category.cs` and `ProductViewModel.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *step 6* and add the `Infrastructure` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class under the `Infrastructure` folder—right-click on the `Infrastructure`
    folder in Solution Explorer, select Add New Item, and in that, select Class or
    click *Shift* + *Alt* + *C.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it as `ProductContext.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this demo project, we are not following the test-driven development approach;
    we will unit test our application just for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `appsettings.json` file and add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Right-click on Project in Solution Explorer and select Manage Nuget Package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the Nuget Package Manager screen, search `Swashbuckle.AspNetCore` and
    install it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Swagger** is open source and adheres to open specifications ([https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md)).
    Swagger allows you to describe an API''s structure. Swagger provides documentation
    to users (devs who are going to use APIs). There are a lot of open source and
    commercial tools available that can integrate with Swagger.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Swagger CodeGen** ([https://swagger.io/swagger-codegen/](https://swagger.io/swagger-codegen/))
    helps to generate client libraries for an API.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Swagger UI** ([https://swagger.io/swagger-ui/](https://swagger.io/swagger-ui/))
    helps to generate an API''s documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Swashbuckle.AspNetCore** ([https://github.com/domaindrivendev/Swashbuckle.AspNetCore](https://github.com/domaindrivendev/Swashbuckle.AspNetCore))
    is a tool that helps document APIs built on ASP.NET Core.'
  prefs: []
  type: TYPE_NORMAL
- en: Add `interface IProductRepository` under `Core/Interfaces`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `IProductRepository` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Please note that for the complete source code, refer to the GitHub repository
    at [https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core).
  prefs: []
  type: TYPE_NORMAL
- en: Add the `ProductRepository` class under the `Infrastructure` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to `ProductRepository`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `Startup.cs` file and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Your project hierarchy should now look like the following screenshot of Solution
    Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5070b6c-5e6f-4ccb-b42e-a388e9bdb319.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, you are ready to play with the application! Run the application from Menu
    or press *F5*. In a web browser, add the suffix `/swagger` to the URL in the address
    bar, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96471cff-b54d-45c4-a2f2-90ea4dadb59b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This URL should show the swagger API documentation, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74fc5f0e-76a7-4926-9bf0-83d9bf381747.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on GET /api/Product/productlist, it should return a list of products,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0408d5e3-949b-49f2-9e3b-2c09732aaf6a.png)'
  prefs: []
  type: TYPE_IMG
- en: Writing unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will add a test project using ASP.NET Core 2.0 and write
    unit tests using xUnit. Before we start writing tests, we should set up a test
    project in our existing application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few simple steps needed for our test project setup:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From Solution Explorer in Visual Studio, right-click on Solution ''Chap06_01''
    (1 project) and click on Add | New Project... , as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f253fcb9-d4a8-4094-a762-4a95b2126c47.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the Add New Project template, select .NET Core and xUnit Test Project
    (.NET Core) and provide a meaningful name, for example, `Chap06_01_Test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cb6caf7c-c5a4-4216-96f5-424f1be5f6eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add folders named `Fake` and `Services`. (Refer to the previous section to
    see how to add a new folder from the solution explorer.) Your project structure
    should now look like the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0f2450f7-127e-429e-b405-f9db08517906.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `ProductData.cs` class should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we created fake data for `Products` and `ProductsViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: The full code is available to download from [https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core).
  prefs: []
  type: TYPE_NORMAL
- en: '`ProductTest.cs`, our unit testing class, looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Important terms for xUnit:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fact** is an attribute and is used for a normal test method that is without
    parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Theory** is an attribute and is used for a parameterized test method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we are simply testing our `ProductController`,
    which is a `Get` resource, `GetList`. In this code, we are mocking the list; we
    are not actually hitting the database but instead testing our `Controller` methods
    using fake data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run tests from Test Explorer; if your test passes, you should see something
    like the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/134b6fd3-8ba7-4ed5-8c7d-aec0215473b8.png)'
  prefs:
  - PREF_OL
  type: TYPE_IMG
- en: Stubs and mocking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stubs are canned responses to calls made during a test, whereas mocks are meant
    to set expectations. They can be further explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stubs**: In the `stubs` object, we always get a valid stubbed response. The
    response doesn''t care what input you provided. In any circumstance, the output
    will be the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mocks**: In the `mock` object, we can test or validate methods that can be
    called on mocked objects. This is a fake object that validates whether a unit
    test failed or passed. In other words, we can say that mock objects are just replicas
    of our actual object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous section, *Writing unit tests*, we used the moq framework to
    implement the mocked objects.
  prefs: []
  type: TYPE_NORMAL
- en: Security testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is a very wide-reaching term and can't be explained in a few lines.
    In general, security testing is a way of testing whether an application is secure
    or if there is any chance of leaking someone's data.
  prefs: []
  type: TYPE_NORMAL
- en: Security and secure systems will be discussed in [Chapter 8](18479f1e-2030-404b-b016-1764984f46ed.xhtml),
    *Securing RESTful Web Services*.
  prefs: []
  type: TYPE_NORMAL
- en: Security testing is very important, especially when we working in web-based
    applications. Web applications are publicly available and vulnerable to attack,
    so authentication and authorization are the most important factors here.
  prefs: []
  type: TYPE_NORMAL
- en: FxCop ([https://en.wikipedia.org/wiki/FxCop](https://en.wikipedia.org/wiki/FxCop)),
    which is shipped with Visual Studio and VeraCode ([https://www.veracode.com/](https://www.veracode.com/)),
    is one of the most popular tools used in security testing.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In unit testing, we test a single unit of code, whereas, in integration testing
    in a Web API, we test all services that work together (internal and external,
    including third-party components). Service calls should be made to ensured integration
    with external services.
  prefs: []
  type: TYPE_NORMAL
- en: Run tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take the same application we created in the previous section for unit
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new project for integration tests, and make sure the project structure
    looks like the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4c85e8fd-558e-4a73-bc28-f2800cfcb41b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Write the following code in the constructor of `ProductTest.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we initialized `TestServer` , where we used `TestStartup`
    as our startup entry file. Finally, we created a `private readonly HttpClient
    _client;` of our `WebHostBuilder()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, write a simple method that calls the productlist resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are consuming our resource `GET api/product/productlist`
    and testing it to see if it returns the expected output.
  prefs: []
  type: TYPE_NORMAL
- en: To run the code smoothly, you need to add the `Microsoft.AspNetCore.Hosting;`
    and `Microsoft.AspNetCore.TestHost;` namespaces in the code.
  prefs: []
  type: TYPE_NORMAL
- en: This test also makes sure that the internal component, or any external service
    call made by this method, is working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete the code for `ProductTes.cs`  as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the code for the `TestStartup` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, our `TestStartup` class inherited the `Startup` class,
    meaning we are now using its members and methods.
  prefs: []
  type: TYPE_NORMAL
- en: You need to make the methods `ConfigureServices` and `Configure` virtual to
    override these in the `TestStartup` class.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look into our `InitConfiguration()` method; this method adds your test
    configuration file so that you can use test config values in any other environment.
  prefs: []
  type: TYPE_NORMAL
- en: In our `TestStartup` class, we overrode the `ConfigureServices` and `Configure`
    methods so that we could configure test services or any utilities class that was
    created specifically for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are all set to run our tests, open Test Explorer and run a selected test.
    You can also run tests from the `ProductTest.cs` file (just right-click and select
    Run tests).
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you need to debug the code, you can debug tests as well. If you do,
    you should get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6e3e6d4-a9c7-4a62-9d6b-2558c762313a.png)'
  prefs: []
  type: TYPE_IMG
- en: You can write as many tests as you want. Tests also depend on what code you
    want to test.
  prefs: []
  type: TYPE_NORMAL
- en: Fake objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, fake objects are objects that are not real. Fake objects
    are for testing purposes and contain actual code, but not with all of the genuine
    functionality. For instance, we can create a fake object to fetch data records
    using Entity Framework Core; in this case, we prefer to use InMemory ([https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/in-memory](https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/in-memory))
    instead of a direct DB connection.
  prefs: []
  type: TYPE_NORMAL
- en: Run tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take the application we developed in the previous section on unit testing.
    Follow the steps mentioned in the preceding section and add a new xUnit test project.
  prefs: []
  type: TYPE_NORMAL
- en: We are looking for fake objects or data for testing purposes, so we will not
    be hitting our actual database server. Instead, here we will use the InMemory
    database.
  prefs: []
  type: TYPE_NORMAL
- en: You need to add the `Microsoft.EntityFrameworkCore.InMemory` NuGet package to
    start the InMemory database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not going to change anything here, but we will create fake data and
    records to test. To proceed, add the following code to the `TestStartup.cs` file
    in the `ConfigureServices` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The InMemory database, used only for testing purposes, by adding  `.UseInMemoryDatabase`
    to the `TestStartup` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our actual code, our database server will remain unchanged in the `Startup.cs`
    class, that is, `.UseSqlServer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we need fake data and records, so add the following method in the `TestStartup` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, call the `FakeData(context)` method from the `Configure(IApplicationBuilder
    app, IHostingEnvironment env)` method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to run tests, so open Test Explorer and hit Run All. If the
    tests pass, you should see something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5129795f-ced5-473e-a3d8-30e15138ddb3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To double-check that the tests are not hitting the actual database, let''s
    debug the test code. Open the `ProductTest.cs` class and set a breakpoint for
    the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now right-click on Debug Test, use step-into (the *F11* key) to go into the
    controller and the repository, and check to see what the actual list of products
    is. You can see that our test is returning fake data, which means they are not
    hitting the actual database. The following is a screenshot of the debugged code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ed6222f-bd5a-4546-9fd8-3f1cd16100e3.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot is from a small application that we used to demonstrate
    testing with fake objects. With this testing approach, our fake objects were always
    hit instead of any actual code.
  prefs: []
  type: TYPE_NORMAL
- en: Testing service calls using Postman, Advanced REST Client, and more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of tools available for testing RESTful web services and APIs.
    These tools provide the actual output.
  prefs: []
  type: TYPE_NORMAL
- en: Web service testing tools are very useful when you have only API resources and
    want to test the expected output in different scenarios but do not have actual
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: We will test our product APIs with the following two tools.
  prefs: []
  type: TYPE_NORMAL
- en: Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Postman** ([https://www.getpostman.com/](https://www.getpostman.com/)) is
    one of the most popular tools when testing web service output. It also comes with
    a Google Chrome extension:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch Postman. If you don't have it, install it from the preceding link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Resource type as GET and enter the URL of the API; in our case, it
    is `http://localhost:60431/api/Product/productlist`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Send (alternatively, you can click on Send and Download, if you need
    data in the file).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the test passes, you should see something like the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/194c48ce-b5ca-4707-9973-14ec1c106d6e.png)'
  prefs: []
  type: TYPE_IMG
- en: Advanced Rest Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Advanced rest client** (**ARC**) is another popular tool and also comes as
    a Chrome extension. You can either install it from the Chrome Extension store
    or directly from [https://install.advancedrestclient.com/](https://install.advancedrestclient.com/):'
  prefs: []
  type: TYPE_NORMAL
- en: Install the Chrome extension for ARC, if not yet installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch ARC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the GET resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the test passes, you should see something like the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8c2d00ed-feed-489d-b4e5-956405437e09.png)'
  prefs: []
  type: TYPE_IMG
- en: User acceptance testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, **user acceptance testing** (**UAT**) is testing that
    is done by users or accepted by users. In this testing methodology, users who
    might be an application's end user are involved directly with testing. There might
    be scenarios that users test in the production environment, or they may have access
    to the pre-tested results that they can accept or reject.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of testing depends on the actual user who would be using the application
    in a production environment. This testing usually happens in a UAT or pre-production
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: The typical environments in the industry are known as development, staging,
    QA, UAT, pre-production, and production. In your organization, you might not have
    all the environments as per your project requirements; if so, refer to [https://www.guru99.com/user-acceptance-testing.html](https://www.guru99.com/user-acceptance-testing.html).
  prefs: []
  type: TYPE_NORMAL
- en: UAT testing is also seen as final testing, and its acceptance or rejection tells
    us whether a current release will be deployed to production or not. The main focus
    of this testing is business-related. This testing does not deal with test code
    or the implementation of various patterns; it simply makes sure that all the business
    rules and requirements have been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Performance or load testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a web application's performance, scalability is very important. An application
    can be very secure, well tested, and created with good code but still be avoided
    by the user if it's not scalable.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss scaling RESTful web services in detail in [Chapter 9](dfa68fd5-a510-4446-be5c-fe23d0ca08cd.xhtml), *Scaling
    RESTful Services (Performance of Web Services)*.
  prefs: []
  type: TYPE_NORMAL
- en: Performance is very important for a good API, so we need to test and make sure
    that our application is able to load or stress large requests. Load testing is
    a non-functional type of testing ([https://www.guru99.com/non-functional-testing.html](https://www.guru99.com/non-functional-testing.html)) and
    the main aim of load testing is not to verify the code or test the code's health.
  prefs: []
  type: TYPE_NORMAL
- en: The main purpose of this testing is to ensure that the web API is performing
    well based on various measures such as scalability, reliability, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are techniques or types of performance testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Load testing**: This tests the behavior of the system under various circumstances
    of specific load. This also covers critical transactions, database load, application
    servers, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stress testing**: This is an approach where a system goes under regress testing
    and finds the upper-limit of a system''s capacity. It is also determined by how
    a system behaves in a critical situation where the current load goes above the
    expected maximum load.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Soak testing**: This is also known as endurance testing. In this test, the
    main purpose is to monitor memory utilization, memory leaks, or various factors
    which affect system performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spike testing**: This is an approach where we make sure that the system is
    able to sustain the workload. One of the best tasks for determining performance
    is suddenly increasing the user loads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In ASP.NET Core, we can perform load testing with the help of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visual Studio**: If you have Visual Studio Enterprise Edition, you can easily
    create a load testing project; visit the following link for more information:
    [https://docs.microsoft.com/en-us/vsts/load-test](https://docs.microsoft.com/en-us/vsts/load-test).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WebSurge**: This is a load testing use for APIs. You can use it in the cloud
    or for free for learning purposes. For more information, visit [http://websurge.west-wind.com/](http://websurge.west-wind.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BenchmarkDotNet**: This tool tells us how much of our code is performant.
    It tests different blocks of codes that give the same result to see which performs
    best. For more information, visit [https://github.com/dotnet/BenchmarkDotNet](https://github.com/dotnet/BenchmarkDotNet).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Netling**: This is a load testing tool for web applications. With Netling,
    you can make changes and retest your code to meet your performance scale. For
    more information, visit [https://github.com/hallatore/Netling](https://github.com/hallatore/Netling).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explanations, along with working examples, of these tools and Visual Studio
    Load Testing is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will simply test our product APIs to check how much time
    it takes them to list the products we request.
  prefs: []
  type: TYPE_NORMAL
- en: You can also test the request time of APIs using a simple web client. In [Chapter
    10](9fcac4d2-710a-48a2-98be-ed0034525cee.xhtml), *Building a Web Client (Consuming
    Web Services)*, we will discuss how to build a web client in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the code of our `ProductTest` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is self-explanatory. We are simply calculating the time taken
    by single and multiple requests, and checking whether this reaches our benchmark.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code is available to download from [https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core).
  prefs: []
  type: TYPE_NORMAL
- en: Run tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run tests, you need to make sure that your APIs are running and accessible
    using the URL. To do so, use the CLI to complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Visual Studio command prompt
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the folder of your API project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fire the command `dotnet run`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should now a screen similar to the one in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5007496a-c067-4591-9173-ea6772db3043.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Follow these steps to run tests using Visual Studio Test Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ProductTest.cs` file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Test Explorer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Run
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will run all the tests; you should see an output similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d18d7381-017c-40f6-aef6-76afa017f194.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also check the exact time taken for a request to be completed by individual
    APIs. To do this, click on **Output** in the test explorer of a particular `TestCase`
    result, and you should see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ea433e9-9ccf-4342-b233-a5c7f6e69fee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also run these tests using the CLI, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Visual Studio command prompt
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the folder of your API project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fire the command `dotnet test`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The preceding command will run all the tests; if they pass, you should see
    the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48deb5d8-fe65-4a84-8ff8-769f704632c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Visit [https://docs.microsoft.com/en-us/dotnet/core/tools/?tabs=netcore2x](https://docs.microsoft.com/en-us/dotnet/core/tools/?tabs=netcore2x)
    to check all the available CLI commands.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we tried a simple load test that was based on request times.
    We tried a single call and multiple calls.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing helps to ensure our code is error-free. Testing is also a practice for
    all developers who want to make their code clean and maintainable. In this chapter,
    we covered testing paradigms in the day-to-day activities of a development team,
    with the knowledge of stubs and mocks, as well as the importance of understanding
    integration, security, and performance testing.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming chapters, we will discuss security, including following the OWASP
    security standard and JWT authentication. We will cover more complex scenarios
    with the use of custom filters and input validations. Data protection is always
    a high priority for any web application, so we will also take a look at sensitive
    data persistence and storage.
  prefs: []
  type: TYPE_NORMAL
