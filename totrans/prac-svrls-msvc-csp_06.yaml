- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IoT Functions in Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation of the Internet of Things certainly is changing the way we
    interact with the world. Although we have a lot of solutions delivered, IoT is
    still challenging to deliver, especially if you want to focus on a scalable solution.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of this chapter is to present Event Grid, Event Hubs, and IoT Hub triggers
    that will be good options to start a microservice connected to devices. Besides
    that, we will discuss how to enable IoT using Azure.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will help you to create an IoT environment using Azure. Besides
    that, it will guide you on connecting this environment through Azure IoT Function
    triggers. To finish, it will present the car-sharing example case for IoT. Let’s
    check how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires Visual Studio 2022 free *community edition* or Visual
    Studio Code. You will also need an Azure account to create the sample environment.
    You can find the sample code for this chapter at [https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp](https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp).
  prefs: []
  type: TYPE_NORMAL
- en: Enabling IoT in Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we think about IoT, one of the greatest worries is the scalability of the
    solution. Considering that we are designing a solution to facilitate connection
    with a great number of devices, the best way to enable IoT in Azure is by using
    IoT Hub. IoT Hub creates a great environment for connecting, monitoring, and managing
    your IoT devices, offering a Platform as a Service (PaaS) solution that will make
    you focus on the application you are working on.
  prefs: []
  type: TYPE_NORMAL
- en: There are two tiers of pricing for IoT Hub in Azure and the Free Edition of
    it. The Free Edition enables up to 8,000 messages of 0.5KB a day and it has the
    same features we have in the Standard tier. If you go for the Basic or Standard
    tiers, this can be increased to up to 3 billion messages of 4KB a day! The standard
    tier also offers device management, cloud-to-device messaging, and IoT Edge. Besides
    that, the Standard tier has a layer of security managed by Defender, called Defender
    for IoT. This information gives us an idea of how scalable the platform is.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes in this book and to help you understand the following examples,
    we suggest that you create a free tier IoT Hub component. The next topics will
    discuss how to get messages from this IoT Hub so you can create a microservice
    based on it.
  prefs: []
  type: TYPE_NORMAL
- en: The process of doing so is quite simple. You must go to **Create Resource**
    in Azure and type IoT Hub in Azure Marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Creating an IoT Hub using Azure Marketplace](img/B31916_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Creating an IoT Hub using Azure Marketplace'
  prefs: []
  type: TYPE_NORMAL
- en: For **Free Tier**, you only need to fill in the information related to the **Basics**
    tab, so after this, you can move on to the **Review + create** tab.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Azure IoT Hub Free Tier setup](img/B31916_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Azure IoT Hub Free Tier setup'
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the resource is created, you will be able to create devices in the
    Azure IoT Hub **Device management** area.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: Azure IoT Hub Device management](img/B31916_06_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Azure IoT Hub Device management'
  prefs: []
  type: TYPE_NORMAL
- en: First, the device will only need **Device ID** information, which represents
    the uniqueness of the device that will be handled.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Creating a device in IoT Hub](img/B31916_06_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Creating a device in IoT Hub'
  prefs: []
  type: TYPE_NORMAL
- en: IoT Hub also provides the possibility to connect devices on the edge, by using
    IoT Edge devices. This is not the focus of this book, but you will find information
    about it in the *Further reading* section. For the book’s purpose, devices created
    in Azure are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering we have the devices created, we need to understand how to simulate
    them. The code below shows how we can do it using the .NET `Microsoft.Azure.Devices.Client`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The connectionString argument in the method above is specific to each IoT device.
    You can get it using the Azure portal, but it is great to mention that there is
    a very useful tool for Azure IoT Hub called **Azure IoT Explorer**.
  prefs: []
  type: TYPE_NORMAL
- en: With Azure IoT Explorer, we can manage devices connected to IoT Hub in a graphical
    tool that facilitates diagnosing and testing. For instance, to get the **connection
    string** of a specific device, you can check the **Device identity** information
    available.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: Getting device connection string](img/B31916_06_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Getting device connection string'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have understood how to simulate devices, let’s learn how to receive
    data from these devices using Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting IoT Hub with Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, IoT Hub offers a built-in service that delivers device-to-cloud
    messages to a compatible EventHubs endpoint at messages/events. This means that
    you can easily connect IoT Hub device messages to an Event Hubs trigger function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This option is certainly very useful since you can develop a solution very fast
    where you connect different devices using IoT Hub and Azure Functions. So, this
    can be considered the simplest way to directly integrate message processing.
  prefs: []
  type: TYPE_NORMAL
- en: In the code above, we are just defining the default endpoint messages/events
    and defining the variable that will give us the connection string for the Event
    Hub. The EventHubConnection variable can be found in **Built-in endpoints** in
    IoT Hub. There will be only shared access policies that enable us to receive data
    from devices (**ServiceConnect** permissions). It is recommended that you share
    the policy with the least access, considering the purpose of this connection is
    just reading the information.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: Obtaining Event Hubs connection string to receive data from IoT
    Hub](img/B31916_06_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Obtaining Event Hubs connection string to receive data from IoT
    Hub'
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth noting that these messages can be retained for a maximum of
    seven days, according to the tier you have selected in Azure IoT Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Although the built-in option is very easy and fast to implement, you may want
    to apply different IoT scenarios where other alternatives can be applied. There
    are several ways to trigger data coming from devices using **Events** in Azure
    IoT Hub, as we can see in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7: Azure IoT Hub Events alternatives to receive data from devices](img/B31916_06_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Azure IoT Hub Events alternatives to receive data from devices'
  prefs: []
  type: TYPE_NORMAL
- en: Each approach certainly will give you the versatility to implement event driven
    and scalable solutions. Besides that, you need to analyze exactly the data you
    are going to send from devices to the cloud to define the best alternative. It
    is worth noting that only IoT Hub triggers aims at direct integration between
    IoT Hub and Azure Functions. The other triggers are visible under the **Events**
    blade.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Approach** | **When to use** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| IoT Hub Trigger | Simplest, direct integration for message processing. |'
  prefs: []
  type: TYPE_TB
- en: '| Event Grid Trigger | Best for event-driven systems and scalable architecture.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Service Bus Trigger | When you need intermediate buffering or message priority
    handling. |'
  prefs: []
  type: TYPE_TB
- en: '| Blob Storage Trigger | When you want to store and process telemetry data
    as files. |'
  prefs: []
  type: TYPE_TB
- en: '| HTTP Trigger (Direct) | When you need fine-grained control over function
    invocation. |'
  prefs: []
  type: TYPE_TB
- en: '| Logic Apps | For no-code/low-code integration with IoT Hub and Functions.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Stream Analytics Output | When you need to perform real-time analytics before
    invoking the function. |'
  prefs: []
  type: TYPE_TB
- en: '| Queue Trigger | For lightweight, simple queue-based message processing. |'
  prefs: []
  type: TYPE_TB
- en: We have already covered how to implement some of these alternatives in the last
    three chapters, so we will not explore them again.
  prefs: []
  type: TYPE_NORMAL
- en: Car-sharing IoT example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The car-sharing example that we are covering in the book enables interaction
    between car-seeking and car-holding users. But let’s suppose we have the possibility
    to deliver a special plan for car-holders who apply for a specific IoT device
    from the platform we are designing. Another option would be to integrate the car-sharing
    app in the central car cockpit. In this scenario, users could track the location,
    speed, and status of the available vehicles. It would also be possible to monitor
    vehicle health parameters such as battery life, tire pressure, and fuel levels.
  prefs: []
  type: TYPE_NORMAL
- en: In the alternatives presented before, a new vehicle-tracking microservice could
    be implemented and its data would probably be shared with the existing **Routes-Listing**
    and **Routes-Planner** microservices. For the first one, it would be possible
    to provide up-to-date information on car availability and estimated arrival times.
    For the planner, it would facilitate the decision of the best car to suggest a
    new hide.
  prefs: []
  type: TYPE_NORMAL
- en: But considering the scenario above, which would be a great architectural approach?
    In [*Chapter 7*](Chapter_7.xhtml#_idTextAnchor151), *Microservices in Practice*,
    we will present the RabbitMQ message broker, which will be very useful for this
    scenario, and the complete example of Routes-Planner microservices. The diagram
    below shows how the IoT solution and the Vehicle-Tracking microservice will be
    connected to the main solution.
  prefs: []
  type: TYPE_NORMAL
- en: Azure IoT Hub is the component responsible for managing multiple cars (devices)
    and it will send tracking data received from each car to the Vehicle-Tracking
    microservice using Azure Event Hubs messages. This microservice will be responsible
    for processing vehicle health parameters, as presented above, and this information
    will be stored in the Cosmos DB database, considering the volume of data received.
    To finish, it will publish only the data needed for the RoutesPlanning microservice
    using a RabbitMQ principal bus.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8: IoT solution connected to a microservice solution](img/B31916_06_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: IoT solution connected to a microservice solution'
  prefs: []
  type: TYPE_NORMAL
- en: 'The tracking data that is sent from the car could have a structure like the
    one below. It is also great to mention that, if you are running .NET from a device
    to the cloud, this structure can be reused if you work in a class library dedicated
    to defining SharedMessages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth noting that the Location property is defined by another shared
    class, called GeoLocalizationMessage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Considering this scenario, the following code is an emulation of a car collecting
    data and sending data using IoT Hub as the front door:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting that we are just creating data here with random information.
    However, the process itself exactly represents the output of data from a device
    to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the device you have, you may need to change the protocol used with
    Azure IoT Hub. You may check https://learn.microsoft.com/en-us/azure/iot-hub/iot-hub-devguide-protocols
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the following code represents the function that will process
    the vehicle tracking message, storing its data in Cosmos DB and, at the same time,
    alerting all the microservices via RabbitMQ that there is a new message from a
    car, so other microservices, like RoutesPlanning, can make use of it to run their
    business rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Some great things about this approach justify why microservices are a good way
    to work with big products. First, the implementation of the IoT solution is totally
    decoupled from the implementation of the rest of the application, which enables
    developers to define the technology used and the deployment pipeline. Second,
    the usage of the information provided by the IoT solution is optional and can
    be spread to each microservice that is required. Besides that, one point of attention
    is the contract defined in the Shared Messages. You must be careful not to create
    an incompatibility between the systems. A good approach to avoid this is to version
    the message content.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discussed how Internet of Things solutions can be handled in Azure,
    especially with the help of Azure IoT Hub and Azure Functions. It also presented
    an extension of the car-sharing example using an IoT service, which demonstrates
    how useful microservices architecture can be.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices offer several strategic advantages in the development of large-scale
    applications, especially when it comes to implementing IoT solutions. By decoupling
    the IoT solution from the rest of the application, developers have the flexibility
    to choose the appropriate technologies and pipelines for deployment independently.
    This modular approach not only enhances scalability and maintainability but also
    allows different teams to work on various parts of the application without interference.
  prefs: []
  type: TYPE_NORMAL
- en: Another significant benefit of microservices is their optional and distributed
    usage of information. The data provided by the IoT solution can be utilized by
    any microservice that requires it, ensuring efficient data handling and processing.
    However, it is crucial to maintain compatibility across different systems by carefully
    managing contracts. Versioning message content is an effective strategy to avoid
    incompatibility issues, ensuring smooth communication between microservices. In
    the next chapter, we will start discussing the usage of microservices in practice
    with more emphasis.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the purpose of reading device-to-cloud messages from the built-in endpoint
    in IoT applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The built-in endpoint in IoT Hub allows you to read device-to-cloud messages
    easily and directly, making it ideal for quick integration between devices and
    backend applications. It simplifies the process of connecting IoT devices to services
    like Azure Functions using standard Event Hub-compatible endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is useful for scenarios where rapid prototyping or lightweight
    integration is needed, as it requires minimal configuration and supports scalable,
    event-driven solutions.
  prefs: []
  type: TYPE_NORMAL
- en: How can you read device-to-cloud messages from the built-in endpoint?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To read messages from the built-in endpoint, you can create an Azure function
    using an Event Hub trigger and point it to the default messages/events endpoint
    of IoT Hub. The connection string with read permissions (typically from the service
    policy) is used to access the messages.
  prefs: []
  type: TYPE_NORMAL
- en: This method enables a fast and straightforward implementation of serverless
    message processing, allowing the Azure Function to automatically execute whenever
    a device sends data to IoT Hub.
  prefs: []
  type: TYPE_NORMAL
- en: What are the advantages of using the Azure IoT explorer for managing IoT devices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Azure IoT explorer is a graphical tool that simplifies device management
    in IoT Hub. It allows you to register new devices, view connection strings, send
    test messages, and monitor device status without writing any code.
  prefs: []
  type: TYPE_NORMAL
- en: This tool is especially helpful during the development and testing phases, as
    it accelerates diagnostics and gives developers a user-friendly interface to interact
    with and configure IoT devices.
  prefs: []
  type: TYPE_NORMAL
- en: How does Queue Trigger facilitate lightweight, simple queue-based message processing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Queue triggers enable Azure Functions to respond to messages placed in Azure
    Storage Queues. This pattern provides a lightweight and decoupled way to process
    tasks asynchronously, making it easy to implement background job handling or message
    workflows.
  prefs: []
  type: TYPE_NORMAL
- en: It is particularly effective in scenarios where simplicity, scalability, and
    fault tolerance are desired without the need for complex messaging infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: What are the key differences between IoT Hub and Event Hubs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IoT Hub is specifically designed for secure and scalable communication with
    IoT devices, offering device management, bidirectional messaging, and integration
    with IoT Edge. Event Hubs, on the other hand, is a high-throughput, general-purpose
    event ingestion service mainly used for telemetry and logging.
  prefs: []
  type: TYPE_NORMAL
- en: While both support massive data ingestion, IoT Hub provides device-centric features
    like twin properties, direct methods, and security credentials per device, whereas
    Event Hubs focuses on data streaming and integration into analytics pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: What are the benefits of decoupling the IoT solution from the rest of the application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decoupling the IoT solution allows independent development, scaling, and deployment
    of the device communication layer. Each microservice can process only the data
    it needs, leading to better performance, flexibility, and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, this separation enables teams to adopt different technologies
    or deployment strategies as needed, while keeping the core application architecture
    clean and modular.
  prefs: []
  type: TYPE_NORMAL
- en: How can versioning message content help prevent incompatibility issues in shared
    messages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Versioning message content ensures that changes to data structures don’t break
    functionality in microservices that consume these messages. Each service can process
    the version it understands, allowing smooth evolution of the system.
  prefs: []
  type: TYPE_NORMAL
- en: By maintaining compatibility across versions, developers can update and deploy
    components independently without risking integration failures or data misinterpretation
    between services.
  prefs: []
  type: TYPE_NORMAL
- en: What role does the pipeline of deployment play in the implementation of microservices
    in IoT solutions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A well-defined deployment pipeline allows each microservice, including those
    related to IoT, to be built, tested, and deployed independently. This supports
    continuous integration and delivery, reducing time to market and minimizing risks
    during updates.
  prefs: []
  type: TYPE_NORMAL
- en: For IoT scenarios, where data ingestion and processing are critical, automated
    pipelines ensure reliability, version control, and traceability across the distributed
    system—enhancing overall application robustness.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Azurite: [https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azurite](https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azurite)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft Azure Storage Explorer: [https://learn.microsoft.com/en-us/azure/storage/storage-explorer/vs-azure-tools-storage-manage-with-storage-explorer](https://learn.microsoft.com/en-us/azure/storage/storage-explorer/vs-azure-tools-storage-manage-with-storage-explorer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure IoT Edge Documentation: [https://learn.microsoft.com/en-us/azure/iot-edge](https://learn.microsoft.com/en-us/azure/iot-edge)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Read device-to-cloud messages from the built-in endpoint: [https://learn.microsoft.com/en-us/azure/iot-hub/iot-hub-devguide-messages-read-builtin](https://learn.microsoft.com/en-us/azure/iot-hub/iot-hub-devguide-messages-read-builtin)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure IoT explorer: [https://learn.microsoft.com/en-us/azure/iot/howto-use-iot-explorer](https://learn.microsoft.com/en-us/azure/iot/howto-use-iot-explorer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Comparison between IoT Hub and Event Hubs: [https://learn.microsoft.com/en-us/azure/iot-hub/iot-hub-compare-event-hubs](https://learn.microsoft.com/en-us/azure/iot-hub/iot-hub-compare-event-hubs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Functions Event Triggers: https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-event-iot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Functions IoT Triggers: https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-event-iot-trigger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Stream Analytics: https://azure.microsoft.com/en-us/products/stream-analytics/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/PSMCSharp](https://packt.link/PSMCSharp)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/B31916_Discord-QR-Code.png)'
  prefs: []
  type: TYPE_IMG
