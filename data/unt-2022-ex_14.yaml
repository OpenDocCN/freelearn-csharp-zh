- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Creating a 3D First Person Shooter (FPS)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个3D第一人称射击（FPS）游戏
- en: In [*Chapter 9*](B18347_09.xhtml#_idTextAnchor169), we created a global event
    system, a quest system, and components that were all loosely coupled and worked
    together to provide versatile quests for the player to complete. With the systems
    in place, we made quick work of being able to implement collecting items to notify,
    update, and satisfy a specific quest requirement. The components created are extensible
    and reusable for creating any number of quests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B18347_09.xhtml#_idTextAnchor169)中，我们创建了一个全局事件系统、一个任务系统以及一些松散耦合的组件，它们共同协作，为玩家提供多样化的任务。有了这些系统，我们迅速实现了收集物品以通知、更新和满足特定任务要求的功能。创建的组件是可扩展和可重用的，可以用于创建任意数量的任务。
- en: We then imported and fixed the rendering for the **Universal Render Pipeline**
    (**URP**), and refactored the code of a third-party sliding puzzle asset as an
    example of how to leverage the Unity Asset Store for our games. We finished by
    setting up the puzzle in the scene with new artwork and triggering an event when
    the puzzle was solved that ended the level with a fade-to-black sequence.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后导入并修复了**通用渲染管线**（**URP**）的渲染，并将第三方滑动拼图资产的重构代码作为一个示例，展示了如何利用Unity Asset Store为我们的游戏服务。我们通过在场景中设置拼图并使用新艺术作品，在拼图解决时触发事件，以淡入黑色序列结束关卡来完成。
- en: This chapter will pick up right where the previous 2D adventure game left off
    by introducing a 3D FPS game for the habitat interior we just entered.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从上一章的2D冒险游戏结束的地方继续，通过引入我们刚刚进入的栖息地内部的3D FPS游戏。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Designing for 3D while continuing the GDD
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在继续GDD的同时进行3D设计
- en: Greyboxing a 3D environment with ProBuilder and Prefabs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ProBuilder和预制件灰盒化3D环境
- en: Creating an FPS player character with the Unity Starter Asset
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unity Starter Asset创建FPS玩家角色
- en: Refactoring environment interactions to 3D API methods
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将环境交互重构为3D API方法
- en: Code reuse in practice – Adding premade components to the player
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实践中的代码重用——向玩家添加预制组件
- en: By the end of this chapter, you’ll be able to design and build a greybox 3D
    environment from a set of modular parts we’ll make right within the Unity Editor,
    quickly add an FPS character controller, and reuse and refactor 2D code for a
    3D project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够设计并构建一个由我们在Unity编辑器中制作的模块化部件组成的灰盒3D环境，快速添加FPS角色控制器，并重用和重构2D代码以用于3D项目。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can download the complete project on GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上下载完整项目：[https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)。
- en: Designing for 3D while continuing the GDD
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在继续GDD的同时进行3D设计
- en: Level design for a 2D game is more straightforward because players navigate
    in only two dimensions. In contrast, 3D games involve that extra dimension – depth
    – in gameplay, contributing to more complex level design. In 2D, the screen space
    is represented by the **X** and **Y** coordinates. In 3D, the floor plane is represented
    by **X** and **Z** (depth), with **Y** still being used for the vertical axis
    – Unity’s 3D coordinate system is defined as a **Y-up environment**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 2D游戏的关卡设计更为直接，因为玩家只在两个维度中导航。相比之下，3D游戏在游戏玩法中涉及额外的维度——深度，这导致了更复杂的关卡设计。在2D中，屏幕空间由**X**和**Y**坐标表示。在3D中，地面平面由**X**和**Z**（深度）表示，而**Y**仍然用于垂直轴——Unity的3D坐标系统被定义为**Y-up环境**。
- en: '![Figure 10.1 – 2D versus 3D coordinates](img/B18347_10_1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 2D与3D坐标](img/B18347_10_1.jpg)'
- en: Figure 10.1 – 2D versus 3D coordinates
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 2D与3D坐标
- en: As we already know from our previous 2D work, the Z axis still exists but is
    represented straight on with the camera – either in the front or in the back –
    and only applies in some cases when layering objects in the scene.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从之前的2D工作中所知，Z轴仍然存在，但通过相机直接表示——要么在前方，要么在后方——并且仅在场景中分层对象时适用某些情况。
- en: Moving on, we’ll attempt to simplify the 3D design process using a modular approach,
    but it all starts with the game design again. Let’s review some gameplay changes
    to the GDD for a new 3D FPS project introduced in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试使用模块化方法简化3D设计过程，但一切又从游戏设计开始。让我们回顾一下本章中引入的新3D FPS项目对GDD的游戏玩法变化。
- en: Now is our chance to update our blueprint of gameplay mechanics to reflect our
    evolved vision of the *Outer World* 3D FPS game. We can then ensure that all aspects
    of the production of the habitat’s interior-level design will align with this
    new experience.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们更新游戏玩法机制蓝图以反映我们对 *外世界* 3D FPS 游戏的演变愿景的机会。然后我们可以确保栖息地内部设计生产的各个方面都将与这一新体验保持一致。
- en: 'In *Table 10.1*, you can see that I have updated the relevant gameplay sections:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *表10.1* 中，你可以看到我已经更新了相关的游戏玩法部分：
- en: '| **Describe the gameplay, the core loop, and** **the progression** | Make
    your way to the central control system, peeking around corners and down long corridors
    to restore operations while dealing with a damaged power suit that must be recharged
    along the way. Beware of lingering infected maintenance robots! |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **描述游戏玩法、核心循环和** **进展** | 沿着中央控制系统前进，在角落和长长的走廊中窥视，同时处理需要沿途充电的损坏动力装甲，以恢复操作。小心那些徘徊的感染维护机器人！|'
- en: '| **What is the core game mechanic for the** **collection game?** | With a
    first-person perspective, the player will navigate the environment, recharge their
    power suit (health), and shoot the infected maintenance robots. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **什么是收集游戏的核心理念？** | 以第一人称视角，玩家将在环境中导航，为他们的动力装甲（健康）充电，并射击感染了维护机器人的目标。|'
- en: '| **What systems need to be implemented to support the** **game mechanics?**
    | The player movement, a weapon with ammo reloading and shooting capabilities,
    and a health system with pickup (recharging) and damage capabilities. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **需要实现哪些系统来支持** **游戏机制**？ | 玩家移动、具有弹药装填和射击能力的武器，以及具有收集（充电）和伤害能力的健康系统。|'
- en: Table 10.1 – Updated relevant gameplay sections
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1 – 更新的相关游戏玩法部分
- en: 'Next, we’ll need to update the player character and enemy backstories to be
    relevant, as described in *Table 10.2*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新玩家角色和敌人的背景故事，使其相关，如 *表10.2* 所述：
- en: '| **What is the main character’s** **challenge structure?** | The habitat station’s
    environmental controls are offline, and the player character’s power suit has
    lost the ability to sustain the player due to damage.The player must seek *recharges*
    in the station to survive the journey to the central system while battling infected
    maintenance robots.The player will confront the evil plant entity boss. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **主要角色的** **挑战结构是什么？** | 居住站的环保控制系统已关闭，玩家角色的动力装甲由于损坏而失去了维持玩家的能力。玩家必须在战斗感染维护机器人的同时，在站内寻找
    *充电* 来生存，直到到达中央系统。玩家将面对邪恶的植物实体Boss。|'
- en: '| **Enemy B:****Describe the second enemy in the game and how they drive the
    story. Who is** **this enemy?** | Type: Maintenance Robot WheeledBackstory: Robot
    deployed on pre-colonization missions for habitat maintenance and support.Goals:
    Maintenance, personnel supportSkills: Quick chargingWeaknesses: Limited mobility
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **敌人B：****描述游戏中的第二个敌人及其如何推动故事。这位敌人是谁？** | 类型：维护机器人轮式背景：在殖民化前部署在栖息地维护和支持任务中的机器人。目标：维护、人员支持技能：快速充电弱点：移动性有限
    |'
- en: '| **Boss:** **Viridian Overmind****Describe the level boss and how they drive**
    **the story****Who is** **this boss?** | A sentient plant entity infecting the
    central control system of the habitat station compels the player to confront the
    evil alien. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **Boss:** **Viridian Overmind****描述关卡Boss及其如何推动** **故事****这位Boss是谁？** | 一个有感知的植物实体感染了栖息站中央控制系统的中枢，迫使玩家面对邪恶的外星生物。|'
- en: Table 10.2 – Updated character and enemy bios
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.2 – 更新的角色和敌人背景
- en: 'This is a new game level, so it will also need to be defined:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个新的游戏关卡，因此也需要定义：
- en: '| **Describe the environment the game takes place in. What does it look like,
    who inhabits it, and what are the points** **of interest?** | The game occurs
    within a habitation station on a remote planet’s surface. The habitat is deceptively
    large with its many small connecting corridors. There are maintenance robots that
    roam the station carrying out their autonomous duties. Recharge pickups are conveniently
    placed throughout the station at the corridor intersections. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **描述游戏发生的环境。它看起来如何，谁居住在那里，以及** **哪些是兴趣点**？ | 游戏发生在一个遥远星球表面的居住站内。栖息地欺骗性地很大，有许多小连接走廊。有维护机器人四处游荡，执行他们的自主任务。充电收集点方便地放置在整个站点的走廊交叉口。|'
- en: '| **Describe the** **game level(s)** | The game level is a modular constructed
    habitat station interior with many corridors and rooms serving different purposes
    and a central control system room. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **描述游戏关卡** | 游戏关卡是一个模块化构建的栖息地站内部，有许多走廊和房间服务于不同的目的，以及一个中央控制系统房间。|'
- en: Table 10.3 – Environment and level definitions
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.3 – 环境和关卡定义
- en: 'And lastly, we’ll need to update the input control scheme so that it’s relevant
    for functioning in a 3D space:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新输入控制方案，使其在3D空间中有效：
- en: '| **Define the input/control** **methods actions** | Keyboard: *W*, *A*, *S*,
    *D* keys to move, mouse to aim, the left mouse button to shoot the primary weapon,
    and the *E* key to interact.Game controller: Left-stick/D-pad to move, right-stick
    to aim, right-trigger or *Y* to shoot, and button *A* to interact. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **定义输入/控制** **方法动作** | 键盘：*W*，*A*，*S*，*D*键用于移动，鼠标用于瞄准，左鼠标按钮用于射击主要武器，*E*键用于交互。游戏手柄：左摇杆/方向键用于移动，右摇杆用于瞄准，右扳机或*Y*键用于射击，按钮*A*用于交互。|'
- en: Table 10.4 – Updated input/control methods actions
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.4 – 更新的输入/控制方法动作
- en: With these GDD revisions to the *Outer World* game’s conceptual design and gameplay
    mechanics for 3D, we have a foundation for transitioning into the level design
    phase – ensuring that the level will align with our overall concept and provide
    the intended player experience.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对*外部世界*游戏3D概念设计和游戏玩法机制的GDD修订，我们为过渡到关卡设计阶段奠定了基础 – 确保关卡将与我们的整体概念保持一致，并提供预期的玩家体验。
- en: Greyboxing a 3D environment with ProBuilder and Prefabs
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ProBuilder和预制件进行灰色盒3D环境设计
- en: Creating a 3D environment is similar to creating a 2D environment in some ways
    since you still need to place things meaningfully for the gameplay. Of course,
    we must consider the additional dimension and use 3D models instead of 2D image
    assets.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，创建3D环境与创建2D环境相似，因为您仍然需要有意义地放置事物以供游戏使用。当然，我们必须考虑额外的维度，并使用3D模型而不是2D图像资源。
- en: In Unity Hub, please create a new `Unity 2022` project and use the **3D (URP)
    Core** template as our starting point. We’ll continue to use the URP renderer
    from the previous 2D projects. This is still an excellent choice for 3D since
    it will be performant on the broadest range of devices, including mobile platforms.
    With that, even though it sounds like we may be robbing ourselves of some capability,
    we’re not, since URP is also very capable of producing beautiful 3D visuals.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity Hub中，请创建一个新的`Unity 2022`项目，并使用**3D (URP) 核心**模板作为我们的起点。我们将继续使用来自先前2D项目的URP渲染器。这对于3D来说仍然是一个很好的选择，因为它将在最广泛的设备上表现出色，包括移动平台。有了这个，尽管听起来我们可能正在剥夺自己一些能力，但我们并没有，因为URP也非常擅长制作美丽的3D视觉效果。
- en: Additional reading | Unity documentation
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: 'URP overview: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/index.xhtml)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: URP概述：[https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/index.xhtml)
- en: We will speed up the design process by using a technique called **greyboxing**
    (which may also be referred to as **blockout**) – this will allow us to rough
    in the level design using simple geometry without getting distracted by details.
    We’ll also be able to playtest the level early on and identify any potential issues
    with the player navigating the environment and working out general playability
    issues.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用称为**灰色盒**（也可能被称为**屏蔽**）的技术来加快设计过程 – 这将使我们能够使用简单的几何形状来大致绘制关卡设计，而不会被细节所分散。我们还将能够早期进行关卡测试，并识别玩家在环境中导航和解决一般可玩性问题的任何潜在问题。
- en: Let’s start by looking at what we’ll be making.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们将要制作的内容。
- en: Habitat interior level
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栖息地内部关卡
- en: Like in earlier chapters, I’ll provide an example-level design (subjecting you
    again to one of my sketches, although a bit more refined this time) that you can
    follow along with. The level map includes an entry point – where we entered the
    habitat station at the end of the previous 2D adventure game – and leads to a
    central control system where we’ll confront the evil plant entity!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 像在早期章节中一样，我将提供一个示例关卡设计（再次让你承受我的草图，尽管这次更加精细），你可以跟随。关卡地图包括一个入口点 – 我们在上一款2D冒险游戏结束时进入的栖息地站
    – 并通往一个中央控制系统，我们将面对邪恶的植物实体！
- en: '![Figure 10.2 – Habitat interior level map sketch](img/B18347_10_2.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 栖息地内部关卡地图草图](img/B18347_10_2.jpg)'
- en: Figure 10.2 – Habitat interior level map sketch
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 生态室内关卡地图草图
- en: We’ll be using a modular approach to designing the level, so following this
    setup, we’ll be able to adapt quickly to different layouts. As you can see, I’ve
    added a legend that identifies modules intended to be used – these will be our
    reusable components serving as the broad strokes to construct and build the level
    out with. Locations for *recharge* pickups (green), the starting position for
    the player (**P**), and the location of the boss character are also defined.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用模块化的方法来设计关卡，因此按照这个设置，我们将能够快速适应不同的布局。正如您所看到的，我已经添加了一个图例，用于标识打算使用的模块——这些将成为我们的可重复使用的组件，作为构建和构建关卡的大致框架。*充电*拾取点（绿色）、玩家的起始位置（**P**）以及Boss角色的位置也已被定义。
- en: Great! Now we have an actionable plan. Next, we can start creating the required
    3D modules for our greyboxing kit. If you’re thinking, but I have no 3D modeler/artist
    skills! Don’t worry, as this will be a basic introduction – I also believe a game
    developer should have this as the minimum amount of 3D knowledge.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们有一个可执行的计划。接下来，我们可以开始创建我们灰盒套件所需的 3D 模块。如果您在想，但我没有 3D 模型师/艺术家技能！不用担心，因为这将是一个基本的介绍——我也相信游戏开发者应该至少具备这些
    3D 知识。
- en: Installing ProBuilder
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 ProBuilder
- en: Unity provides more built-in tooling that we can use for our greyboxing process
    in the form of a simple 3D modeling feature called ProBuilder. Like most of Unity’s
    features, we’ll install ProBuilder from **Package Manager**. In Unity 2022, tooling
    is collected into feature sets, so open **Window** | **Package Manager**, select
    the **3D World Building** feature (including ProBuilder and related tooling),
    and install it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 提供了更多内置工具，我们可以将其用于我们的灰盒过程，形式是一个简单的 3D 建模功能，称为 ProBuilder。像 Unity 的许多功能一样，我们将从
    **包管理器** 安装 ProBuilder。在 Unity 2022 中，工具被收集到功能集中，因此打开 **窗口** | **包管理器**，选择 **3D
    世界构建** 功能（包括 ProBuilder 和相关工具），然后安装它。
- en: 'After installing the features, we have one additional step to complete the
    ProBuilder setup. We’re using the URP renderer, which requires the supporting
    Shaders and Materials to be installed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完功能后，我们还需要一个额外的步骤来完成 ProBuilder 的设置。我们使用的是 URP 渲染器，这需要安装支持用的着色器和材质：
- en: While still in **Package Manager**, find and select **ProBuilder** in the list
    on the left.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **包管理器** 中，找到并选择左侧列表中的 **ProBuilder**。
- en: On the right side, select **Samples** and click the **Import** button for the
    **Universal Render Pipeline** **Support** item.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧，选择 **示例**，然后点击 **通用渲染管线** **支持** 项的 **导入** 按钮。
- en: Once the import is complete, go to **Edit** | **Preferences…** | **ProBuilder**
    and ensure that under **Mesh Settings**, **Material** is set to **ProBuilder**
    **Default URP**.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入完成后，转到 **编辑** | **首选项…** | **ProBuilder**，确保在 **网格设置** 下，**材质** 设置为 **ProBuilder
    默认 URP**。
- en: Installing ProBuilder adds a new top menu item named **Tools** that allows opening
    the **ProBuilder** window and accessing additional functions, exporting, and debugging
    logging preferences. For our greyboxing, we’re going to focus on the object creation
    process within the **ProBuilder** window, but that’s not to say ProBuilder is
    limited to just creating simple greyboxing objects; it has grown into a full-fledged
    3D modeling and texturing product that, depending on the style of your game, could
    be used for final asset creation too.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 ProBuilder 添加了一个新的顶部菜单项，名为 **工具**，允许打开 **ProBuilder** 窗口并访问其他功能，导出和调试日志首选项。对于我们的灰盒过程，我们将专注于
    **ProBuilder** 窗口内的对象创建过程，但这并不意味着 ProBuilder 只限于创建简单的灰盒对象；它已经发展成为一个完整的 3D 建模和纹理产品，根据您游戏的风格，也可以用于最终资产创建。
- en: Additional reading | Unity documentation
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: 'ProBuilder: [https://docs.unity3d.com/Packages/com.unity.probuilder@5.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.probuilder@5.0/manual/index.xhtml)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 'ProBuilder: [https://docs.unity3d.com/Packages/com.unity.probuilder@5.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.probuilder@5.0/manual/index.xhtml)'
- en: Let’s open the **ProBuilder** window now by going to **Tools** | **ProBuilder**
    | **ProBuilder**, and we’ll get set up to make the modular building blocks from
    our sketch’s legend.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过转到 **工具** | **ProBuilder** | **ProBuilder** 来打开 **ProBuilder** 窗口，我们将设置好从草图图例创建模块化构建块。
- en: Modular parts, Prefabs, and Variants
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化部件、预制件和变体
- en: Unlike an exterior environment’s level design, where shapes are organic in nature
    regarding their placement and position in the world, we’re making an interior
    environment for a controlled space. So, we’ll be building with modules that will
    need to *snap* to one another as they are laid out (you know, with the precision
    an airtight habitat requires). This is generally the approach you’d use for any
    manufactured structural spaces not found in nature.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与室外环境的关卡设计不同，室外环境的形状在放置和位置上具有有机性质，我们正在制作一个受控空间的室内环境。因此，我们将使用需要相互**吸附**的模块来构建（你知道，需要一个气密栖息地所需的精度）。这通常是用于任何在自然界中找不到的制造结构空间的通用方法。
- en: Unity handles modular design well by providing some supporting construction
    options.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 通过提供一些辅助构建选项很好地处理了模块化设计。
- en: Grid snapping
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网格吸附
- en: Unity provides a **grid snapping** system that works wonderfully with ProBuilder
    to simplify our lives for such a task as snapping modules together. Grid snapping
    allows for precisely positioning a GameObject on X, Y, or Z axis planes, and applies
    to move, rotate, or scale operations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 提供了一个**网格吸附**系统，它与 ProBuilder 配合得非常好，可以简化我们进行模块吸附等任务的生活。网格吸附允许在 X、Y 或
    Z 轴平面上精确定位 GameObject，并适用于移动、旋转或缩放操作。
- en: Transforming a GameObject – that is, realizing the move, rotate, and scale operations
    – can also be performed in increments without aligning to predefined gridline
    snap spacing. Incremental snapping can be performed by holding down the *Ctrl*/*Cmd*
    key while using the object transform gizmo in the scene view (**Snap Increment**
    settings are found on the button to the right of the **Grid Snapping** settings,
    as seen in *Figure 10**.3*).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 转换 GameObject – 即实现移动、旋转和缩放操作 – 也可以在不与预定义的网格线吸附间距对齐的情况下以增量方式执行。可以通过在场景视图中使用对象变换
    Gizmo 时按住 *Ctrl*/*Cmd* 键来执行增量吸附（**吸附增量**设置位于**网格吸附**设置右侧的按钮上，如*图 10.3*所示）。
- en: Additional reading | Unity documentation
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: 'Grid snapping: [https://docs.unity3d.com/2022.3/Documentation/Manual/GridSnapping.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/GridSnapping.xhtml).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 网格吸附：[https://docs.unity3d.com/2022.3/Documentation/Manual/GridSnapping.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/GridSnapping.xhtml)。
- en: Our level sketch is free of any dimensions (I just used a grid for roughly sizing
    things consistently), so we aren’t limited in letting the creativity flow; now
    that we’re making the *precise* modular parts, we need to introduce some unit
    of measurement to allow for the snapping together of parts. Building modules that
    need to connect to create our enclosed interior-level design will be pretty tricky
    if we don’t control the size of the details.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的关卡草图没有任何尺寸（我只是用网格来大致确定事物的一致大小），因此我们不受创意流动的限制；现在我们正在制作**精确**的模块化部件，我们需要引入一些计量单位来允许部件的吸附。如果我们不控制细节的大小，那么需要连接以创建封闭内部关卡设计的模块将会相当棘手。
- en: 'To get set up for grid snapping, we first need to activate the **Move** tool
    and ensure that the handle orientation in the **Tool Settings** overlay is set
    to **Global** (this is a requirement for the snapping to be enabled in the scene
    view), as seen in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置网格吸附，我们首先需要激活**移动**工具，并确保在**工具设置**覆盖层中将句柄方向设置为**全局**（这是在场景视图中启用吸附的必要条件），如下面的截图所示：
- en: '![Figure 10.3 – Grid Snapping toolbar](img/B18347_10_3.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 网格吸附工具栏](img/B18347_10_3.jpg)'
- en: Figure 10.3 – Grid Snapping toolbar
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 网格吸附工具栏
- en: Note that the **Transform** tool snaps the selected GameObject(s) to the grid
    along the active gizmo axis – using the **Grid Visual** button to the left of
    the **Grid Snapping** settings, which, as seen in *Figure 10**.3*, is currently
    set to the **Grid** **Plane** Y-axis.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**变换**工具将选定的 GameObject(s) 沿着活动 Gizmo 轴吸附到网格上 – 使用**网格视觉**按钮，该按钮位于**网格吸附**设置左侧，如*图
    10.3*所示，目前设置为**网格** **平面** Y 轴。
- en: 'Let’s ensure that the grid snap settings are set up for us to start creating
    the modular parts for the habitat interior. Referring to *Figure 10**.3*, set
    up the snapping grid with the following steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保网格吸附设置已设置好，以便我们开始创建栖息室内部的模块化部件。参照*图 10.3*，按照以下步骤设置吸附网格：
- en: Select the **Move** tool from the **Toolbar** overlay in the scene view.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从场景视图中的**工具栏**覆盖层中选择**移动**工具。
- en: Set the handle orientation on the **Tool Settings** overlay to **Global**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**工具设置**覆盖层中将句柄方向设置为**全局**。
- en: Verify **Grid Visual** | **Grid Plane** = **Y**.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证**网格视觉** | **网格平面** = **Y**。
- en: Verify **Grid snapping** = **enabled**.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证**网格吸附** = **启用**。
- en: Set **Grid snapping** | **Grid size** = **2** (default value is **1**).
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置**网格吸附** | **网格大小** = **2**（默认值为**1**）。
- en: Set **Increment snapping** = **0.25**.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置**增量吸附** = **0.25**。
- en: I have experience with mechanical drawing and CAD, so I like knowing what dimensions
    I’m working with – even though, yes, we’ll be snapping to the grid units we just
    defined. ProBuilder’s default material also includes a grid texture, but it may
    still be challenging to establish the required sizes without some visible values.
    So, let’s use the visual dimensions of the objects we’ll be building. From the
    **File** menu, set the **Dimensions** overlay to **Show** by going to **Tools**
    | **ProBuilder** | **Dimensions**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我有机械制图和CAD的经验，所以我喜欢知道我在使用什么尺寸——即使，是的，我们将吸附到我们刚刚定义的网格单位上。ProBuilder的默认材质也包括一个网格纹理，但仍然可能很难在没有一些可见值的情况下确定所需的尺寸。因此，让我们使用我们将要构建的对象的视觉尺寸。从**文件**菜单，通过转到**工具**
    | **ProBuilder** | **尺寸**来设置**尺寸**覆盖层为**显示**。
- en: Grid snapping will be of tremendous help – ensuring consistent sizing of the
    modular parts – but we can take another step with a simple construction aid.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 网格吸附将非常有帮助——确保模块部分尺寸的一致性——但我们还可以通过一个简单的构建辅助工具再进一步。
- en: Construction plane
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建设平面
- en: We will put down a reference plane to assist in creating modules. I’ve decided
    the standard module size will be 6 units in length (this is rather arbitrary for
    how large the base modules are that you’ll want to work with; I felt it would
    be better to work with smaller modules for this design), so we’ll base all the
    dimensions – modules as well as map dimensions – on this standard (and the divisible
    dimensions of it by the snap unit size of 2; so, hopefully, that all works out).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将放置一个参考平面以帮助创建模块。我决定标准模块尺寸将是6个单位（对于你想要与之一起工作的基座模块的大小来说，这相当任意；我觉得对于这个设计来说，使用较小的模块会更好），因此我们将所有尺寸——包括模块以及地图尺寸——都基于这个标准（以及它的可分割尺寸，即吸附单位大小为2；所以，希望这一切都能顺利进行）。
- en: 'Let’s proceed:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续：
- en: In the `Assets/Scenes` folder, duplicate `SampleScene` and name it `Habitat`
    `Interior 1`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Scenes`文件夹中，复制`SampleScene`并将其命名为`Habitat` `Interior 1`。
- en: Now, with the **ProBuilder** window open, select **New Shape** and then click
    the **Plane** selection icon in the **Create** **Shape** overlay.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**ProBuilder**窗口打开的情况下，选择**新建形状**，然后点击**创建形状**覆盖层中的**平面**选择图标。
- en: Grid snapping and dimensions showing are enabled, so click and drag out a plane
    that is 6 x 6 units in size.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网格吸附和尺寸显示已启用，因此点击并拖出一个6 x 6单位的平面。
- en: '![Figure 10.4 – ProBuilder reference plane](img/B18347_10_4.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – ProBuilder参考平面](img/B18347_10_4.jpg)'
- en: Figure 10.4 – ProBuilder reference plane
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – ProBuilder参考平面
- en: Click **New Shape** again to stop creating shapes.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击**新建形状**来停止创建形状。
- en: Now, let’s reset the plane position to `(0, 0, 0)` in world space. With the
    plane selected, right-click the `(0, 0, 0)``Module` `Reference Plane`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将平面位置重置为世界空间中的`(0, 0, 0)`。在平面被选中时，右键点击`(0, 0, 0)`的`Module` `Reference
    Plane`。
- en: Tip | Maximize Unity window
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 | 最大化Unity窗口
- en: To maximize the currently active window in Unity, as seen with the scene view
    window in *Figure 10**.3*, you can use the keyboard shortcut *Shift* + *spacebar.*
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Unity中最大化当前活动窗口，如*图10.3*中场景视图窗口所示，您可以使用键盘快捷键*Shift* + *空格键*。
- en: And now, to make our first modular part!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们制作第一个模块部分！
- en: Making modular parts
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 制作模块部分
- en: 'Our modular parts will seamlessly snap together in numerous configurations
    to make the variations we need to create the larger complex space of the habitat
    station’s level design. So, let’s start making modular parts for our environment
    with a wall segment:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些模块部分无缝地组合在一起，以形成我们需要的各种配置，从而制作出栖息地站级的复杂空间。因此，让我们开始制作我们环境的模块部分，从一个墙段开始：
- en: To make a wall segment, click **New Shape**, but click the **Cube** selection
    icon this time.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要制作一个墙段，点击**新建形状**，但这次点击**立方体**选择图标。
- en: Starting at `(0, 0, 0)` drag out a shape that is the length of the reference
    plane (6 units) and -2 units in the **Z** direction (away from the reference plane;
    the blue gizmo axis).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`(0, 0, 0)`开始，拖出一个长度为参考平面（6个单位）且在**Z**方向（远离参考平面；蓝色辅助轴）上-2个单位的形状。
- en: Then, move up (in the `4` units in height.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，向上移动（高度为`4`单位。
- en: 'As a result of snapping to the grid, it looks like the box is a bit too thick
    to represent a wall, so let’s edit the shape and make it a bit thinner:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网格吸附的结果，看起来这个盒子有点太厚，无法代表一堵墙，所以让我们编辑形状并使其稍微薄一些：
- en: As seen in *Figure 10**.5*, rotate the camera to see the other side of the wall.
    We can rotate within the scene view by holding down the *Alt*/*Option* key and
    then clicking and dragging the mouse pointer.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如*图10.5*所示，旋转相机以查看墙的另一侧。我们可以在场景视图中通过按住*Alt*/*Option*键，然后点击并拖动鼠标指针来旋转。
- en: Then click the **Face Selection** option in the **ProBuilder Selection** overlay
    (*A*).
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在**ProBuilder选择**覆盖层中点击**面部选择**选项（*A*）。
- en: Clicking on the facing side of the wall will now select just the face polygons.
    While holding down the *Ctrl*/*Cmd* key, drag the Z-axis handle (blue) of the
    move transform gizmo until the wall is 1 unit thick (*B*).
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击墙的正面将只选择面多边形。在按住*Ctrl*/*Cmd*键的同时，拖动移动变换操控器的Z轴手柄（蓝色），直到墙体厚度为1单位（*B*）。
- en: '![Figure 10.5 – ProBuilder incremental surface snap editing](img/B18347_10_5.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – ProBuilder增量表面对齐编辑](img/B18347_10_5.jpg)'
- en: Figure 10.5 – ProBuilder incremental surface snap editing
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – ProBuilder增量表面对齐编辑
- en: When done editing the face, return to the **Object Selection** mode (*A*).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成编辑面后，返回到**对象选择**模式（*A*）。
- en: Greyboxing doesn’t necessarily mean 100% void of all details; I generally like
    to add at least some small elements to my greyboxing kit parts to convey some
    design aesthetics, so we’ll add a few minor details to the wall segment before
    building up some additional parts.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 灰盒化不一定意味着100%没有所有细节；我通常喜欢在我的灰盒化组件部分中添加至少一些小元素，以传达一些设计美学，因此我们将在构建一些附加部分之前，在墙体段上添加一些细微的细节。
- en: 'Let’s add some geometry detail to the wall segment:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在墙体段上添加一些几何细节：
- en: Make a new cube of 2 x 2 units with a height of 4 units. Then, using `1.5` x
    `0.25` x `4`. Position it at the end of the wall segment to provide an end cap.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作一个2 x 2单位的新立方体，高度为4单位。然后，使用`1.5` x `0.25` x `4`。将其放置在墙体段末端以提供端盖。
- en: Duplicate the **End Cap** cube and place it at the other end of the wall segment
    (like bookends). Note that both ends should be within the reference plane and
    will therefore intersect the wall segment (this is fine – we want to constrain
    the parts within our reference size so everything snaps together like Lego bricks).
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制**端盖**立方体，并将其放置在墙体段另一端（就像书签）。请注意，两端应位于参考平面内，因此将与墙体段相交（这是可以的——我们希望将部件限制在我们的参考尺寸内，以便像乐高积木一样对齐）。
- en: Make a new cube of `6` x `2` units with a height of `2` units, then edit its
    size and position it to make a sort of connecting bar thing along the length of
    the wall segment.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作一个`6` x `2`单位的新立方体，高度为`2`单位，然后编辑其大小并将其定位，使其在墙体段长度上形成一种连接条。
- en: 'The results of our 3D modeling can be seen in the following screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们3D建模的结果可以在以下屏幕截图中看到：
- en: '![Figure 10.6 – Wall section details added](img/B18347_10_6.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 墙体截面细节添加](img/B18347_10_6.jpg)'
- en: Figure 10.6 – Wall section details added
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 墙体截面细节添加
- en: Tip | Lighting
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 | 照明
- en: Note that the shadows on the lighting in the scene have been turned off to focus
    on the modeling task. You can do this by selecting the **Directional Light** object
    in the scene hierarchy, then, in the Inspector, find the **Shadows** section and
    set **Shadow Type** to **No Shadows**.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，场景中的光照阴影已被关闭，以便专注于建模任务。您可以通过在场景层次结构中选择**方向光**对象，然后在检查器中找到**阴影**部分，将**阴影类型**设置为**无阴影**来实现这一点。
- en: I would say this wall section is now complete for our first modular kit part.
    So, we’ll, of course, want to make it a Prefab so we can reuse it where needed,
    and should we need to modify it, all references in the scene will be updated.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我会说这个墙体部分现在对我们第一个模块化组件来说是完整的。因此，我们当然会想要将其制作成Prefab，这样我们就可以在需要的地方重复使用它，并且如果我们需要修改它，场景中的所有引用都将更新。
- en: 'Follow these steps to create the wall Prefab:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建墙体Prefab：
- en: Add a new empty GameObject and reset `(0, 0, 0)` . This will be our parent object
    and ensure that our modular parts maintain consistency for their snapping point
    – the individual objects that all make up the module will be transformed by this
    anchor pivot.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的空GameObject，并将`(0, 0, 0)`重置。这将是我们父对象，并确保我们的模块化部分在它们的对齐点上保持一致性——构成模块的各个单独对象将通过这个锚点枢轴进行变换。
- en: Select and drag all the parts of the wall assembly to be a child of the new
    empty GameObject.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择并拖动墙体组件的所有部分，使其成为新空GameObject的子对象。
- en: Now, rename the parent object to `Wall 1` and drag it to a new `Assets/Prefabs`
    folder to make the Prefab.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将父对象重命名为`Wall 1`，并将其拖动到新的`Assets/Prefabs`文件夹中，以创建Prefab。
- en: You now have all the tools and knowledge to make the rest of the modular parts
    needed for our greyboxing kit. That was easy, yay!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在拥有制作灰色盒子工具包所需的所有工具和知识。这很简单，太好了！
- en: 'What are all the Prefabs we need for our greyboxing kit to produce a complete
    block out of the level? We can get our answer from the map legend (see *Figure
    10**.2*). There are only a few to make – minus one for the wall we just made:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的灰色盒子工具包准备哪些预制件才能从关卡中制作出完整的块？我们可以从地图图例（见*图10.2*）中找到答案。只需要几个预制件即可制作——减去我们刚刚制作的那个墙：
- en: '| (A) | Wall 1 | 6 units length |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| (A) | 墙1 | 6单位长度 |'
- en: '| (B) | Wall 2 | 12 units length |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| (B) | 墙2 | 12单位长度 |'
- en: '| (C) | Doorway | 18 units length (equal wall, open space, wall) |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| (C) | 门口 | 18单位长度（等长的墙、开放空间、墙）|'
- en: '| (D) | Connector 1 | 6 x 6 units with floor plane |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| (D) | 连接器1 | 6 x 6单位，带有地面平面 |'
- en: '| (E) | Connector 2 | 6 x 12 units with floor plane |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| (E) | 连接器2 | 6 x 12单位，带有地面平面 |'
- en: Table 10.5 – Greyboxing kit parts
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.5 – 灰色盒子工具包部件
- en: '*Connector 1* (*D*) will be the same type of connector between rooms so that
    it can be created as a completed module and not have to be assembled from individual
    wall parts whenever we need one. It’s the same for the *Connector 2* (*E*) Prefab,
    just longer. Here, we can see all the modular parts:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*连接器1* (*D*) 将是房间之间相同类型的连接器，这样它就可以作为一个完成的模块创建，而无需在需要时从单个墙部件组装。*连接器2* (*E*)
    预制件也是如此，只是更长。在这里，我们可以看到所有模块化部件：'
- en: '![Figure 10.7 – Greyboxing kit Prefabs](img/B18347_10_7.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 灰色盒子工具包预制件](img/B18347_10_7.jpg)'
- en: Figure 10.7 – Greyboxing kit Prefabs
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 灰色盒子工具包预制件
- en: Go ahead and create the additional wall, door, and connector modular parts now;
    I’ll wait. Just be sure to always start from the origin of our construction plane
    to ensure the anchor pivot is at `(0, 0, 0)` – by creating a new empty GameObject
    there and parent the cubes to it – so that our kit parts will always snap into
    place properly. These anchor pivot instructions are based on what’s seen in *Figure
    10**.4* and not as seen in *Figure 10**.7*, where the wall parts were moved for
    better visibility after being created.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续创建额外的墙、门和连接器模块化部件；我会等着。只需确保始终从我们的建筑平面原点开始，以确保锚点枢轴位于`(0, 0, 0)`——通过在那里创建一个新的空GameObject并将其作为立方体的父对象——这样我们的工具包部件就能始终正确地定位。这些锚点枢轴指令基于*图10.4*中所示，而不是*图10.7*中所示，在那里墙部件在创建后被移动以获得更好的可见性。
- en: With our greyboxing kit complete, we can now start mapping out the level.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的灰色盒子工具包完成后，我们现在可以开始绘制关卡。
- en: Greyboxing the level design
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 灰色盒子关卡设计
- en: We have our map sketch as a reference, but it would still be too abstract if
    we start haphazardly dragging in kit Prefabs to try and block it out. To streamline
    the process a bit more, we can use ProBuilder planes to lay out the map sketch
    according to our snapping grid. This will ensure that adding the kit modules will
    be straightforward and quick.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有地图草图作为参考，但如果我们随意拖动工具包预制件来尝试填充它，这仍然会过于抽象。为了使过程更加流畅，我们可以使用ProBuilder平面根据我们的对齐网格来布置地图草图。这将确保添加工具包模块将变得简单快捷。
- en: Another drawing aid (we take all the help we can get) is to set the **Grid Visual**
    setting for **Opacity** to the max value (as seen in *Figure 10**.7*) so the grid
    is fully visible.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个绘图辅助工具（我们尽可能多地获取帮助）是将**网格视觉**设置的**不透明度**设置为最大值（如*图10.7*所示），以便网格完全可见。
- en: 'Following our sketch and considering the size of our modular kit parts in *Table
    10.5*, use the ProBuilder planes to map out the level: walls, doorways, and connectors.
    ProBuilder will create the planes at **Y**, **0** by default, which is right where
    we want them (floor level). It would then help to have the view locked to a top-down
    view while we draw out the level. So, using the scene gizmo (top-right corner
    of the scene view, (*A*) in *Figure 10**.8*), click the **Y** (green) handle,
    click the center cube to set the view to orthographic (no perspective), then click
    the little lock icon.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的草图和*表10.5*中我们模块化工具包部件的大小，使用ProBuilder平面绘制关卡：墙壁、门和连接器。ProBuilder默认将平面创建在**Y**，**0**处，这正是我们想要的位置（地面水平）。在绘制关卡时，锁定视图为俯视图将有所帮助。因此，使用场景gizmo（场景视图右上角，*图10.8*中的(*A*)），点击**Y**（绿色）手柄，点击中心立方体以设置视图为正交（无透视），然后点击小锁图标。
- en: Additional reading | Unity documentation
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: 'Scene view navigation: [https://docs.unity3d.com/2022.3/Documentation/Manual/SceneViewNavigation.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/SceneViewNavigation.xhtml)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 场景视图导航：[https://docs.unity3d.com/2022.3/Documentation/Manual/SceneViewNavigation.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/SceneViewNavigation.xhtml)
- en: 'Here is the start of our level map:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们关卡地图的开始：
- en: '![Figure 10.8 – Map layout planes](img/B18347_10_8.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – 地图布局平面](img/B18347_10_8.jpg)'
- en: Figure 10.8 – Map layout planes
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 地图布局平面
- en: As you’ll notice (and as seen in *Figure 10**.8*), the white ProBuilder planes
    are glowing a bit. This is because the post-processing volume was in the scene
    from when we duplicated **SampleScene**. If it’s a distraction, simply disable
    the **Global Volume** object in the hierarchy or, toggle off the effects via the
    **View Options** toolbar (*B*) while mapping out the level.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将注意到的（如图 *图 10*.8 所示），白色的 ProBuilder 平面有点发光。这是因为从我们复制 **SampleScene** 以来，后处理体积就在场景中。如果它是一个干扰因素，只需在层次结构中禁用
    **全局体积** 对象，或者，在绘制关卡时，通过 **视图选项** 工具栏（*B*）关闭效果。
- en: 'Here is the completed level map with the entryway at location (*A*), and making
    our way to the central control system room at location (*B*):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完成后的关卡地图，入口位于位置 (*A*)，并前往位于位置 (*B*) 的中央控制系统室：
- en: '![Figure 10.9 – Completed map layout](img/B18347_10_9.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 完成的地图布局](img/B18347_10_9.jpg)'
- en: Figure 10.9 – Completed map layout
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 完成的地图布局
- en: I’m using the *of greatest importance* definition for the word central here,
    not the *in the middle of something* definition, just to clear up any possible
    confusion with the layout of the rooms.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用“极其重要”的定义来解释“中心”这个词，而不是“在某个东西的中间”的定义，只是为了澄清与房间布局的任何可能的混淆。
- en: All the hard stuff is done. All we have to do now is to drag our modular kit
    parts to the edges of the mapped floor planes – with the anchor pivots we ensured
    are at the origin of the module. We’ve guaranteed everything should snap in place
    and to each other. Once you have a modular Prefab in the scene, you can use *Ctrl*/*Cmd*
    + *D* to duplicate it quickly, then move and rotate it into place.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所有困难的事情都已经完成。我们现在要做的就是将我们的模块化工具包部件拖到绘制地板平面的边缘 - 我们确保的锚点枢轴位于模块的原点。我们已经确保一切应该能够正确吸附并相互连接。一旦你在场景中有一个模块化预制件，你可以使用
    *Ctrl*/*Cmd* + *D* 快速复制它，然后移动和旋转到合适的位置。
- en: Note that you will have to rotate modules to enclose the perimeter of the rooms
    and corridors. This is where the anchor pivot also plays a crucial role – the
    part will rotate at the pivot, ensuring proper snapping will be maintained. You
    can turn the parts by typing a value in the Inspector or using the **Rotate Transform**
    tool in the **Toolbar** overlay (hold the *Ctrl*/*Cmd* key to rotate incrementally
    and ensure precisely 90 or 180 degrees of rotation).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可能需要旋转模块以封闭房间和走廊的周边。这就是锚点枢轴也发挥关键作用的地方 - 部件将在枢轴处旋转，确保保持正确的吸附。您可以在检查器中输入一个值或使用
    **工具栏** 面板中的 **旋转变换** 工具（按住 *Ctrl*/*Cmd* 键以进行增量旋转并确保精确的 90 或 180 度旋转）来旋转部件。
- en: If we make any mistakes in the size or spacing of the map’s rooms and corridors,
    we’ll quickly find out, but rapidly making changes for corrections is trivial
    with this modular approach. Easy-peasy.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在地图的房间和走廊的大小或间距上犯任何错误，我们会很快发现，但使用这种模块化方法快速进行更正是微不足道的。轻而易举。
- en: 'Here are the results of my effort in bringing the interior habitat level together
    with our modular greyboxing kit:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我将内部栖息地关卡与我们的模块化灰色盒子工具包结合起来的结果：
- en: '![Figure 10.10 – Finished habitat interior greyboxing](img/B18347_10_10.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – 完成的栖息地内部灰色盒子](img/B18347_10_10.jpg)'
- en: Figure 10.10 – Finished habitat interior greyboxing
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 完成的栖息地内部灰色盒子
- en: In this section, we learned how to block out a 3D environment made of simple
    ProBuilder model Prefabs used to create a simple greyboxing parts kit. We then
    discovered how to map out a level design and use Unity’s grid snapping system
    to make fitting everything together quick and easy.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用简单的 ProBuilder 模型预制件构建的 3D 环境，这些预制件用于创建简单的灰色盒子部件套件。然后我们发现了如何绘制关卡设计并使用
    Unity 的网格吸附系统来快速轻松地使一切就位。
- en: For the next part, we need to playtest what we’ve built. Rather than coding
    a player controller from scratch, this time, we’ll be leveraging Unity’s Starter
    Assets to construct the player rapidly.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一部分，我们需要测试我们所构建的内容。这次，我们不会从头开始编写玩家控制器，而是将利用 Unity 的 Starter Assets 快速构建玩家。
- en: Creating an FPS player character with the Unity Starter Asset
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Unity Starter Asset 创建 FPS 玩家角色
- en: 'Let’s quickly look at some of the general benefits of using prebuilt assets
    – like Unity’s **Starter Asset character controller** – compared to coding ones
    ourselves:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下使用预构建资产（如Unity的**Starter Asset角色控制器**）与自行编码相比的一些一般性好处：
- en: They save time and effort – complex systems take time to build and troubleshoot
    any issues that arise along the way
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们节省时间和精力——构建复杂系统需要时间，并且需要解决过程中出现的任何问题。
- en: They are tested and optimized for performance and generally use best practices
    – as they’re provided by Unity (they know a thing or two about creating components
    for use in their engine) and widely used by game developers of all levels, these
    assets will be performant and much less likely to have bugs
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们经过测试和优化以提高性能，并且通常使用最佳实践——因为它们是由Unity提供的（他们对在引擎中创建组件有一些了解），并且被各个级别的游戏开发者广泛使用，这些资产将具有高性能并且不太可能出现错误。
- en: They are built on Unity’s `CharacterController` component – these assets are
    built modularly, ensuring compatibility with other systems (such as camera and
    combat systems) and assets; they are a great starting foundation for an FPS game
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些资产基于Unity的`CharacterController`组件构建——这些资产是模块化构建的，确保与其它系统（如相机和战斗系统）和资产兼容；它们是FPS游戏的一个很好的起始基础。
- en: They offer a learning opportunity – prebuilt assets can be a great learning
    tool because you can examine how they work
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供了一个学习机会——预构建资产可以是一个很好的学习工具，因为你可以检查它们是如何工作的。
- en: They have plenty of customization options – Unity provides many customization
    options out of the box for most player controller uses (especially for an FPS
    in this case, which is fantastic for us!)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供了丰富的自定义选项——Unity为大多数玩家控制器使用提供了许多开箱即用的自定义选项（特别是对于这种情况下的FPS，这对我们来说太棒了！）
- en: These advantages are pretty significant to minimize problems getting your game
    up and running quickly; we will take full advantage of them right now. Let’s install
    the Unity Starter Assets.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优势非常显著，有助于快速解决问题，我们将充分利用它们。现在让我们安装Unity Starter Assets。
- en: Installing the Unity Starter Assets
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Unity Starter Assets
- en: We’ll use the `Starter Assets - FirstPerson CharacterController` | `URP` asset
    provided (for free) by Unity from the Asset Store for our 3D FPS game.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Unity从Asset Store提供的（免费）`Starter Assets - FirstPerson CharacterController`
    | `URP`资产来构建我们的3D第一人称射击游戏。
- en: Starter Assets - FirstPerson CharacterController | URP (Unity Technologies)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Starter Assets - FirstPerson CharacterController | URP (Unity Technologies)
- en: 'You can find this asset in the Unity Asset Store here: [https://assetstore.unity.com/packages/essentials/starter-assets-first-person-character-controller-urp-196525](https://assetstore.unity.com/packages/essentials/starter-assets-first-person-character-controller-urp-196525).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Unity Asset Store这里找到这个资产：[https://assetstore.unity.com/packages/essentials/starter-assets-first-person-character-controller-urp-196525](https://assetstore.unity.com/packages/essentials/starter-assets-first-person-character-controller-urp-196525)。
- en: 'Installing will be straightforward and similar to how we’ve already installed
    assets from the Package Manager. However, since the Starter Assets have some required
    dependencies, there will be a bit of a hiccup in the process. Don’t worry; it’s
    only a minor inconvenience, as you’ll soon see by following these steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程将非常直接，与我们已经从包管理器中安装资产的方式类似。然而，由于Starter Assets有一些必需的依赖项，安装过程中可能会有一些小插曲。不用担心；这只是一个小麻烦，正如你通过以下步骤很快就会看到的那样：
- en: Save your scene now (*Ctrl*/*Cmd* + *S*) if you haven’t already – you’ll see
    why in a few steps.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有保存场景，现在保存一下（*Ctrl*/*Cmd* + *S*）——你将在接下来的几步中看到原因。
- en: Follow the preceding URL to open the asset in the Unity Asset Store.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照前面的URL打开Unity Asset Store中的资产。
- en: Sign in if not already signed in.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未登录，请登录。
- en: Click the **Add to My Assets** button (accept **Asset Store Terms of Service**
    **and EULA**).
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加到我的资产**按钮（接受**Asset Store服务条款** **和EULA**）。
- en: 'With the project already open in the Unity Editor, click the **Open in Unity**
    button that appears at the top of the browser window (you can also always click
    the **Open in Unity** button on the Asset Store page at any time later) and you’ll
    see the following dialog:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中打开项目后，点击浏览器窗口顶部的**在Unity中打开**按钮（你也可以在任何时候点击Asset Store页面上的**在Unity中打开**按钮），你会看到以下对话框：
- en: '![Figure 10.11 – Open in Unity dialog](img/B18347_10_11.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11 – 在Unity中打开对话框](img/B18347_10_11.jpg)'
- en: Figure 10.11 – Open in Unity dialog
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 在Unity中打开对话框
- en: Clicking the **Open Unity Editor** button will set the focus to the Unity Editor
    and open the Package Manager with the **Starter Assets - FirstPerson CharacterController**
    | **URP** package already selected (how convenient).
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**打开Unity编辑器**按钮将焦点设置到Unity编辑器，并打开包管理器，其中已预先选中**Starter Assets - FirstPerson
    CharacterController** | **URP**包（多么方便）。
- en: Click the **Download** button (top right of the window).
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗口右上角的**下载**按钮。
- en: When the download has finished, click the **Install** button.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，点击**安装**按钮。
- en: 'The Starter Assets packages require the new `PackageChecker` script), and we’ll
    be prompted concerning this, as seen in the following screenshot:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Starter Assets包需要新的`PackageChecker`脚本），我们将会收到提示，如下截图所示：
- en: '![Figure 10.12 – Starter Assets dependencies warning](img/B18347_10_12.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12 – Starter Assets依赖警告](img/B18347_10_12.jpg)'
- en: Figure 10.12 – Starter Assets dependencies warning
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 – Starter Assets依赖警告
- en: 'Of course, we want to click **Install/Upgrade** so we can actually use the
    Starter Asset in our project! If you accidentally skip this step, you can still
    install the new **Input System** package and **Cinemachine** package through the
    Package Manager. When the **Input System** dependency is installed, however, we’ll
    be presented with this dialog for enabling the native platform backends:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，我们想要点击**安装/升级**，这样我们才能在我们的项目中实际使用Starter Asset！如果你不小心跳过了这个步骤，你仍然可以通过包管理器安装新的**输入系统**包和**Cinemachine**包。然而，当**输入系统**依赖项安装完成后，我们将看到一个对话框来启用原生平台后端：
- en: '![Figure 10.13 – Update native platform backends](img/B18347_10_13.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13 – 更新原生平台后端](img/B18347_10_13.jpg)'
- en: Figure 10.13 – Update native platform backends
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 – 更新原生平台后端
- en: Click **Yes**, and the Unity Editor will restart (aren’t you glad I told you
    to save your scene in *step 1*?).
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**是**，Unity编辑器将重新启动（你不高兴我告诉你在*步骤1*中保存场景吗？）。
- en: When the Unity Editor reopens, return to the Package Manager and click the **Install**
    button again (just a bit annoying but it seems unavoidable with the current dependency
    requirements). This time, the installation will finish without a hitch.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Unity编辑器重新打开时，返回包管理器并再次点击**安装**按钮（有点烦人，但似乎在当前的依赖要求下是不可避免的）。这次，安装将顺利完成。
- en: That takes care of the installation, so let’s look at what the Starter Assets
    provide.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了安装，让我们看看Starter Assets提供了什么。
- en: Starter Assets Playground scene
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Starter Assets游乐场场景
- en: We can quickly test the first-person character controller by opening the provided
    playground scene. Go to `Assets/StarterAssets/FirstPersonController/Scenes` to
    find the **Playground** scene. In the **Playground** scene, we have the necessary
    objects for the first-person character controller, as well as a simple environment
    we can test the character controller in.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过打开提供的游乐场场景来快速测试第一人称角色控制器。前往`Assets/StarterAssets/FirstPersonController/Scenes`以找到**游乐场**场景。在**游乐场**场景中，我们有第一人称角色控制器所需的所有对象，以及一个我们可以测试角色控制器的简单环境。
- en: However, you can quickly manipulate the playground environment to provide some
    additional test geometry with the available parts by snapping them together using
    their mesh vertexes rather than trying to figure out a snapping grid setup. To
    snap objects together using their vertexes, select the mesh you want to transform
    with the **Move** tool active, then press and hold the *V* key to activate vertex
    snapping. Move to the vertex you want to use – generally a corner point of the
    mesh – then click and drag to any other vertex on another object. Simple and quite
    helpful!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以通过将它们使用网格顶点吸附在一起来快速操作游乐场环境，以提供一些额外的测试几何形状。而不是试图确定吸附网格设置。要使用顶点吸附对象，请使用**移动**工具选择你想要转换的网格，然后按住*V*键以激活顶点吸附。移动到你想要使用的顶点——通常是网格的角点——然后点击并拖动到另一个对象的任何其他顶点上。简单且非常有帮助！
- en: Additional reading | Unity documentation
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: 'Positioning GameObjects and vertex snapping: [https://docs.unity3d.com/Manual/PositioningGameObjects.xhtml](https://docs.unity3d.com/Manual/PositioningGameObjects.xhtml)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 定位游戏对象和顶点吸附：[https://docs.unity3d.com/Manual/PositioningGameObjects.xhtml](https://docs.unity3d.com/Manual/PositioningGameObjects.xhtml)
- en: Of particular note, you can also use vertex snapping to place an object precisely
    on the surface of another object. To accomplish this, while already holding down
    the *V* key, hold down the *Shift* + *Ctrl*/*Cmd* keys while moving over the surface
    you want to snap to.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 特别值得注意的是，你还可以使用顶点吸附来将对象精确地放置在另一个对象的表面上。为了完成这个操作，在已经按住 *V* 键的同时，在移动到想要吸附的表面时按住
    *Shift* + *Ctrl*/*Cmd* 键。
- en: Don’t forget that you can use the *F* key in the scene view window at any time
    to refocus on the currently selected object – this sets orbiting, panning, and
    zooming around that object.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，你可以在场景视图窗口中随时使用 *F* 键来重新聚焦当前选定的对象 – 这将围绕该对象设置环绕、平移和缩放。
- en: Okay, let’s look at getting around with the first-person character controller
    we’ll use for our game.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们看看如何使用我们将用于游戏的第一个视角角色控制器进行移动。
- en: Getting around
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动方式
- en: First things first, enter Play Mode. Now, you can look around using the mouse,
    move the player with the *W*, *A*, *S*, *D* keys, hold *Shift* to sprint, and
    press the *spacebar* to jump. The *move*, *look*, *jump*, and *sprint* actions
    for both keyboard/mouse and gamepad input are established with the `StarterAssets`
    Input Action Asset (Input Actions) located in the `Assets/StarterAssets/InputSystem`
    folder.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，进入播放模式。现在，你可以使用鼠标四处查看，用 *W*、*A*、*S*、*D* 键移动玩家，按住 *Shift* 进行冲刺，并按 *空格键* 跳跃。键盘/鼠标和游戏手柄输入的
    *移动*、*查看*、*跳跃* 和 *冲刺* 动作由位于 `Assets/StarterAssets/InputSystem` 文件夹中的 `StarterAssets`
    输入动作资产（输入动作）建立。
- en: 'As seen in the scene **Hierarchy** window in the following screenshot, we have
    the objects that make up the Starter Assets first-person character controller:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图中的场景**层次结构**窗口所示，我们拥有组成 Starter Assets 第一人称角色控制器的对象：
- en: '![Figure 10.14 – Standard Assets Playground scene Hierarchy](img/B18347_10_14.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14 – 标准资产游乐场场景层次结构](img/B18347_10_14.jpg)'
- en: Figure 10.14 – Standard Assets Playground scene Hierarchy
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 标准资产游乐场场景层次结构
- en: 'The `PlayerCapsule` object is the primary object (Prefab) holding the modular
    components that provide the behavior for the first-person character controller.
    Starting with `PlayerCapsule`, the process flow for the components – from input
    to transform manipulation – looks like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerCapsule` 对象是主要对象（Prefab），它包含提供第一人称角色控制器行为的模块化组件。从 `PlayerCapsule` 开始，组件的过程流程
    – 从输入到变换操作 – 看起来是这样的：'
- en: '`PlayerCapsule` à [`StarterAssets` (Input Action Asset / Input Actions)] `Player`
    à `PlayerInput` [SendMessages] à `StarterAssetsInputs` à `FirstPersonController`
    à `CharacterController`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerCapsule` à [`StarterAssets` (输入动作资产 / 输入动作)] `Player` à `PlayerInput`
    [发送消息] à `StarterAssetsInputs` à `FirstPersonController` à `CharacterController`'
- en: I encourage you to look into each of the components to gain some familiarity
    with how things are connected to provide this functionality. We don’t actually
    need to dig into these components to get things working, so I won’t be covering
    it. We will, however, extend upon the base functionality the Starter Assets provide
    when required.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你查看每个组件，以熟悉事物是如何连接起来提供这种功能的。我们实际上不需要深入研究这些组件来使事物工作，所以不会涉及。然而，当需要时，我们将扩展 Starter
    Assets 提供的基本功能。
- en: However, with this brief overview, we should understand what’s needed to bring
    the first-person character controller into our greybox habitat level.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过这个简要概述，我们应该了解将第一人称角色控制器引入我们的灰色盒子栖息地级别所需的内容。
- en: Adding the first-person controller to our level
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将第一人称控制器添加到我们的级别
- en: Now that you’ve finished having some fun in the Starter Assets `Playground`
    scene, let’s go back to our habitat interior scene to add the player so we can
    progress further with our game. As we saw in the `Playground` scene hierarchy,
    a few Prefabs worked together to provide the first-person character controller
    functionality. So, we’ll use these Prefabs too.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在 Starter Assets `Playground` 场景中玩得开心之后，让我们回到我们的栖息地内部场景，添加玩家，以便我们可以进一步推进我们的游戏。正如我们在
    `Playground` 场景层次结构中看到的那样，几个 Prefab 一起工作以提供第一人称角色控制器功能。因此，我们也会使用这些 Prefab。
- en: 'Bringing this in is made simple with a provided nested Prefab. Here are the
    steps we’ll follow to bring the controller setup into the scene:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提供的嵌套 Prefab，将控制器设置引入场景变得简单。以下是我们将遵循的步骤来将控制器设置引入场景：
- en: In the `Assets/StarterAssets/FirstPersonController/Prefabs` folder, find the
    `NestedParent_Unpack` Prefab. As the name no doubt indicates, this is a nested
    Prefab containing everything we need to set up the player.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/StarterAssets/FirstPersonController/Prefabs`文件夹中，找到`NestedParent_Unpack`
    Prefab。正如其名所示，这是一个嵌套 Prefab，包含了我们设置玩家所需的所有内容。
- en: Drag and drop `NestedParent_Unpack` into the scene hierarchy.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`NestedParent_Unpack`拖放到场景层次结构中。
- en: As the name indicates, we’ll want to unpack this nested Prefab, so we have just
    the child Prefabs. Right-click `NestedParent_Unpack`, and then select **Prefab**
    | **Unpack**.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如其名称所示，我们想要解包这个嵌套预制件，以便我们只有子预制件。右键单击`NestedParent_Unpack`，然后选择**Prefab** | **Unpack**。
- en: With the prefab now unpacked, drag the child objects out into the root of the
    **Hierarchy** window.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在预制件已经解包，将子对象拖动到**层次结构**窗口的根目录。
- en: You can now delete `NestedParent_Unpack`, and we are ready to go!
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以删除`NestedParent_Unpack`，我们就可以出发了！
- en: As you can see in the `UI_Canvas_StarterAssetsInputs_Joysticks` Prefab object
    in the hierarchy.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在层次结构中的`UI_Canvas_StarterAssetsInputs_Joysticks`预制件对象中看到的。
- en: '![Figure 10.15 – Starter Assets mobile controls](img/B18347_10_15.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图10.15 – Starter Assets移动控制](img/B18347_10_15.jpg)'
- en: Figure 10.15 – Starter Assets mobile controls
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 – Starter Assets移动控制
- en: I think it’s great that Unity has decided to include mobile support with the
    Starter Assets; again, this saves us a lot of time if we want to get a mobile
    game up and running quickly – as well as all the previous benefits noted.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为Unity决定在Starter Assets中包含移动支持是非常棒的；再次强调，如果我们想快速将移动游戏上线，这将节省我们大量的时间——以及之前提到的所有好处。
- en: We’re now ready to give the level a playtest!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好对这个级别进行试玩测试了！
- en: Playtesting the level
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 级别试玩测试
- en: To get things started, we’ll have to move the `PlayerCapsule` object into a
    position at the start of our level map, assuming we just entered the habitat station
    after solving the entryway puzzle. You can see an example of placement in *Figure
    10**.15*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们必须将`PlayerCapsule`对象移动到我们的级别地图的起始位置，假设我们在解决了入口谜题后刚刚进入栖息地站。您可以在*图10.15*中看到一个放置示例。
- en: The ProBuilder models include **Colliders** for the planes we used to map out
    the level floor and the cubes we used to make the modular wall Prefabs, so the
    level is already set! Enter Play Mode and have a look around.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ProBuilder模型包括用于绘制级别地面的**碰撞器**和平面，以及用于制作模块化墙壁预制件的立方体，因此级别已经设置好了！进入游戏模式并四处看看。
- en: Additional reading | Starter Assets documentation
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Starter Assets文档
- en: Additional details for the Starter Assets package can be found in the documentation
    included with the package. The documentation is in PDF form and can be found in
    the **Assets/StarterAssets** folder.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Starter Assets包的额外详细信息可以在包中包含的文档中找到。文档为PDF格式，可在**Assets/StarterAssets**文件夹中找到。
- en: In this section, we learned how to rapidly add a first-person character controller
    to our game’s level by leveraging the Unity Starter Assets.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何通过利用Unity Starter Assets快速将第一人称角色控制器添加到我们的游戏级别。
- en: In the next section, we’ll revisit some reusable components from the 2D game
    projects to use in our 3D FPS game project.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾一些2D游戏项目中的可重用组件，以用于我们的3D FPS游戏项目。
- en: Refactoring environment interactions to 3D API methods
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将环境交互重构为3D API方法
- en: From the previous 2D game projects, we have a small library of components built
    up already, but they are 2D, and we are now in 3D, so it requires a bit of refactoring
    for us to use them. Let’s first revisit the `TriggeredEvent` component we created
    in [*Chapter 4*](B18347_04.xhtml#_idTextAnchor079).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的2D游戏项目中，我们已经建立了一个小的组件库，但它们是2D的，我们现在处于3D状态，因此我们需要进行一些重构才能使用它们。让我们首先回顾一下在[*第4章*](B18347_04.xhtml#_idTextAnchor079)中创建的`TriggeredEvent`组件。
- en: Revisiting the TriggeredEvent component
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾`TriggeredEvent`组件
- en: The Physics 2D API method we used for the `TriggeredEvent` component is `OnTriggerEnter2D()`.
    Its 3D counterpart simply drops the *2D* part, and so it’s just `OnTriggerEnter()`
    (Unity is 3D under the hood, and it would make sense that only the 2D-specific
    methods are indicated as such).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于`TriggeredEvent`组件的Physics 2D API方法是`OnTriggerEnter2D()`。它的3D对应物简单地省略了*2D*部分，因此它只是`OnTriggerEnter()`（Unity底层是3D，因此只有特定的2D方法被这样标记是有意义的）。
- en: 'Now, considering the above, let’s look at how we’ll update the `TriggeredEvent`
    code. Provided that you copied in the `Assets/Scripts/TriggeredEvent.cs` file
    from the previous 2D project, only a few changes are required. Otherwise, you
    can first revisit the earlier code in the book or even download the 2D version
    of the script from the GitHub project repo: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/Unity%20Project/Assets/Scripts](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/Unity%20Project/Assets/Scripts).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑到上述内容，让我们看看我们将如何更新`TriggeredEvent`代码。假设您已经从之前的2D项目中复制了`Assets/Scripts/TriggeredEvent.cs`文件，只需进行少量更改。否则，您可以先回顾书中的早期代码，甚至可以从GitHub项目仓库中下载2D版本的脚本：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/Unity%20Project/Assets/Scripts](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch4/Unity%20Project/Assets/Scripts).
- en: 'Here are the changes we’ll make:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将进行的更改：
- en: 'The Unity Physics message event from this appears as follows, but we will change
    it:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自此处的Unity物理消息事件如下，但我们将进行更改：
- en: '[PRE0]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And here it is after the change:'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 改变之后，它看起来是这样的：
- en: '[PRE1]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Update the `[RequiredComponent]` attribute from the original, which looks like
    this:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新原始的`[RequiredComponent]`属性，看起来像这样：
- en: '[PRE2]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I believe this one is self-explanatory – we don’t require the collider to be
    a `Collider2D` type.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我认为这一点是显而易见的——我们不需要将碰撞体设置为`Collider2D`类型。
- en: 'If you save the script now, you’ll likely notice we have an error displayed
    in the Console window with the `Tags` type not being found: `Tags.Player`).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在保存脚本，您可能会在控制台窗口中注意到显示了一个错误，表明找不到`Tags`类型：`Tags.Player`）。
- en: 'We can resolve this error by copying the `Assets/Scripts/Tags.cs` file again
    from the 2D project, creating the `Tags.cs` file manually and typing out the constant
    variable declaration, or using the IDE’s refactoring tools to generate `Tags.cs`.
    Either way, we’ll end up with the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过再次从2D项目复制`Assets/Scripts/Tags.cs`文件、手动创建`Tags.cs`文件并输入常量变量声明，或者使用IDE的重构工具生成`Tags.cs`来解决这个错误。无论如何，我们最终都会得到以下内容：
- en: '[PRE3]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Concerning our `Player` tag, the `PlayerCapsule` object from the Unity Starter
    Assets first-person character controller is already tagged as `Player`. How convenient!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的`Player`标签，Unity Starter Assets中的`PlayerCapsule`对象已经被标记为`Player`。多么方便啊！
- en: With the `TriggeredEvent` script all sorted, let’s implement it now by adding
    a triggered interaction to the interior habitat level.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TriggeredEvent`脚本全部整理好之后，让我们现在通过向内部栖息地关卡添加触发交互来实现它。
- en: Implementing a TriggeredEvent in our level design
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的关卡设计中实现TriggeredEvent
- en: 'We’ve already seen how we can leverage editor tooling and reusable components
    to build out environments and add behavior or functionality to our games. This
    current implementation will be no exception. So, let’s see how we can use both
    ProBuilder and the `TriggeredEvent` component to add a door to the level design
    that automatically opens when the player gets near it:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何利用编辑器工具和可重用组件来构建环境，并为我们的游戏添加行为或功能。当前的实现将不会例外。所以，让我们看看我们如何使用ProBuilder和`TriggeredEvent`组件向关卡设计中添加一个门，当玩家靠近时它会自动打开：
- en: We’ll start by creating a trigger volume using a ProBuilder cube. Using *Figure
    10**.16* as a reference, draw out a cube just in front of the first doorway of
    the room the player starts from – and don’t forget your *grid snapping*!
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个触发体积，使用ProBuilder立方体。以*图10.16*为参考，在玩家开始房间的前门前面画出一个立方体——别忘了你的*网格吸附*！
- en: Once the cube is created, select it, then in the ProBuilder `OnTriggerEnter()`
    message event will be fired.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了立方体，选择它，然后在ProBuilder的`OnTriggerEnter()`消息事件将被触发。
- en: With that, we have quickly made a trigger volume visible at design time but
    hidden at runtime – another excellent feature ProBuilder provides.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们在设计时快速创建了一个可见的触发体积，但在运行时是隐藏的——这是ProBuilder提供的另一个优秀功能。
- en: Let’s go ahead and add the refactored `TriggeredEvent` component to our trigger
    volume ProBuilder cube object now. We can now use the `TriggeredEvent` component
    to wire up and trigger an animation.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加重构后的`TriggeredEvent`组件到我们的触发体积ProBuilder立方体对象中。现在我们可以使用`TriggeredEvent`组件来连接并触发一个动画。
- en: Animating the door opening
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 门打开的动画
- en: Now that we have a `UnityEvent` that can be triggered when the player enters
    the trigger volume at our doorway, let’s add a closed door that will animate open.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`UnityEvent`，当玩家进入门口的触发体积时可以触发，让我们添加一个关闭的门，它会动画打开。
- en: 'First, we’ll create the door following these steps:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将按照以下步骤创建门：
- en: Create a new ProBuilder cube.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的ProBuilder立方体。
- en: Use face editing and incremental snapping to make the cube thin (you know, like
    a door).
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用面编辑和增量吸附来使立方体变薄（你知道，就像一扇门）。
- en: Place the cube in the doorway to obstruct entry (as if it were closed).
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将立方体放置在门口以阻挡入口（就像它关闭了一样）。
- en: Rename the object `Door`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名对象`Door`。
- en: By assigning a color, let’s quickly differentiate the door mesh from our greyboxing
    kit parts. We can do that using the **Vertex Colors** command in the ProBuilder
    window. With the **Door** object selected, clicking **Vertex Colors** will open
    a new window with a default color palette shown. Clicking one of the colors’ related
    **Apply** button will set a new color on the object. Easy-peasy. (Oh… and as seen
    in *Figure 10**.16*, I chose blue.)
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过分配颜色，我们可以快速区分门网格和我们的灰色盒子组件。我们可以使用ProBuilder窗口中的**Vertex Colors**命令来完成此操作。选择**Door**对象后，点击**Vertex
    Colors**将打开一个显示默认颜色调板的窗口。点击颜色相关的**Apply**按钮将为对象设置新颜色。简单易行。（哦……就像在*图10**.16*中看到的那样，我选择了蓝色。）
- en: We can now add an animation to the door that we can trigger to play from the
    `TriggeredEvent` component.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以向门添加一个可以由`TriggeredEvent`组件触发的动画。
- en: With the `.anim`) that we’ll name `Door-idle` and save to a new `Assets/Animation`
    folder. In the associated **Animator**, this sets the idle animation as the default
    state. Since we don’t want the door to do anything at all in its idle state, we’re
    done with it. Now, we want to create the animation for opening the door.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.anim`)，我们将命名为`Door-idle`并将其保存到新的`Assets/Animation`文件夹。在相关的**Animator**中，这会将空闲动画设置为默认状态。由于我们不想在空闲状态下让门做任何事情，所以我们已经完成了。现在，我们想要创建开门的动画。
- en: 'Now, follow these steps to create the door-opening animation:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤创建开门动画：
- en: In the **Animation** window, with the **Door** object selected, click on the
    **Animation Clip** dropdown – currently set to **Door-idle** – then select **Create**
    **New Clip…**.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Animation**窗口中，选择**Door**对象，点击**Animation Clip**下拉菜单（当前设置为**Door-idle**），然后选择**Create**
    **New Clip…**。
- en: When prompted, save the new animation clip and name it `Door-open`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，保存新的动画剪辑并将其命名为`Door-open`。
- en: Click the red `0.5` seconds.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击红色`0.5`秒。
- en: 'Using the **Move** tool, move the **Door** into an open position (or change
    the **Transform** position value in the Inspector for the open direction axis)
    wide enough for the player to pass through. This will create two keyframes in
    the timeline: one at the start and one at the current time.'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**Move**工具，将**Door**移动到打开的位置（或更改检查器中的**Transform**位置值以改变打开方向轴）足够宽，以便玩家可以通过。这将创建时间线上的两个关键帧：一个在开始处，一个在当前时间。
- en: Click the **Record** button again now to stop animating.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击**Record**按钮以停止动画。
- en: Now, open the **Animator** window by going to **Window** | **Animation** | **Animator**.
    You’ll see both the **Door-idle** and **Door-open** nodes (the animations) already
    there and a **Default State Transition** line from **Entry** to **Door-idle**
    – precisely what we want. We don’t want the door to do anything when we start
    playing the game.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过转到**Window** | **Animation** | **Animator**打开**Animator**窗口。你会看到已经存在的**Door-idle**和**Door-open**节点（动画），以及从**Entry**到**Door-idle**的**Default
    State Transition**线——这正是我们想要的。我们不希望门在游戏开始时做任何事情。
- en: Double-click the **Door-open** animation, then, in the Inspector, uncheck **Loop
    Time**. We want the door to open and stop playing the animation, not continuously
    loop back and do it repeatedly.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**Door-open**动画，然后在检查器中取消选中**Loop Time**。我们希望门打开并停止播放动画，而不是连续循环并重复执行。
- en: 'The last thing to do is wire up `UnityEvent` on the `TriggeredEvent` component:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件要做的事情是在`TriggeredEvent`组件上连接`UnityEvent`：
- en: Select the `TriggeredEvent` component, click the little plus (**+**) icon to
    add a new event listener.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`TriggeredEvent`组件，点击小加号（**+**）图标以添加新的事件监听器。
- en: Drag the **Door** to the **Object** field.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Door**拖到**Object**字段。
- en: In the function selection dropdown, select `Door-open` in the provided field
    – and double-check your spelling! The spelling here must match the name of the
    animation node in the **Animator**.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数选择下拉菜单中，在提供的字段中选择`Door-open`，并确保拼写正确！这里的拼写必须与**Animator**中动画节点的名称匹配。
- en: 'The preceding `TriggeredEvent` listener assignment, the **Door-open** animation
    timeline, the blue **Door** object, and the ProBuilder **Cube** trigger volume
    object can all be seen in the following screenshot:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面的`TriggeredEvent`监听器分配、**Door-open**动画时间线、蓝色**Door**对象以及ProBuilder**Cube**触发体积对象：
- en: '![Figure 10.16 – Triggered door open animation](img/B18347_10_16.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图10.16 – 触发门开启动画](img/B18347_10_16.jpg)'
- en: Figure 10.16 – Triggered door open animation
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 – 触发门开启动画
- en: 'Let’s make our triggered/animated door a Prefab as the final step:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们的触发/动画门作为最终步骤成为一个Prefab：
- en: Parent the **Cube** and **Door** objects in the hierarchy to a new empty GameObject
    by selecting both objects.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择两个对象，将层次结构中的**Cube**和**Door**对象设置为一个新的空GameObject。
- en: Then right-click and choose **Create** **Empty Parent**.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后右键点击并选择**创建** **空父对象**。
- en: Name the new GameObject `Door_Triggered`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的GameObject命名为`Door_Triggered`。
- en: Then drag it from the hierarchy to the `Assets/Prefabs` folder.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后从层次结构拖动它到`Assets/Prefabs`文件夹。
- en: Note that you may need to fix the **Door-open** animation since the **Door**
    object is now a child GameObject whose local position is offset in relation to
    the parent. If so, select **Door**, open the **Animation** window, and select
    the **Door-open** animation from the dropdown. You can now manually reset the
    values for each keyframe in the timeline. Use the **Preview** buttons to play
    the animation and test to adjust accordingly until resolved (you’ve got this).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可能需要修复**门开启**动画，因为**门**对象现在是一个子GameObject，其局部位置相对于父对象偏移。如果是这样，选择**门**，打开**动画**窗口，并从下拉菜单中选择**门开启**动画。现在您可以手动重置时间轴上每个关键帧的值。使用**预览**按钮播放动画并相应地调整，直到解决问题（您能行）。
- en: You can now duplicate the `Door_Triggered` Prefab in the scene (*Ctrl*/*Cmd*
    + *D*), drag it in from the **Project** window, and place it throughout the level
    where it makes sense for the desired gameplay. For example, having a patrolling
    enemy behind a closed door is always fun.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在场景中复制`Door_Triggered` Prefab（*Ctrl*/*Cmd* + *D*），从**项目**窗口拖动它，并将其放置在适合所需游戏玩法的地方。例如，有一个巡逻敌人躲在关闭的门后总是很有趣。
- en: In this section, we learned how to easily refactor a 2D API method to reuse
    some existing code and proceeded to use it and grasped some new learnings for
    rapidly creating 3D objects with ProBuilder to implement new functionality for
    the level. Next, we’ll look at more code reuse.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何轻松重构2D API方法以重用一些现有代码，并继续使用它，通过使用ProBuilder快速创建3D对象来为关卡实现新功能。接下来，我们将探讨更多的代码重用。
- en: Code reuse in practice – Adding premade components to the player
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践中的代码重用 – 向玩家添加预制组件
- en: In addition to refactoring some existing code to work in our new project, we
    can also bring in our existing system code – this could then be considered premade
    components, ready for use. So, referring back to the GDD now, we will use `HealthSystem`
    from the 2D adventure game project to decrease and recharge the player’s power
    suit (i.e., health).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 除了重构一些现有代码以在新项目中工作外，我们还可以引入现有的系统代码——这可以被认为是预制组件，随时可以使用。因此，现在回到GDD，我们将使用2D冒险游戏项目中的`HealthSystem`来减少和充电玩家的动力装甲（即健康）。
- en: 'If you don’t already have the 2D adventure game scripts locally, you can download
    the project source from the GitHub repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有本地2D冒险游戏脚本，您可以从GitHub仓库下载项目源代码：[https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)
- en: 'Now, from the 2D adventure game project, copy the following files into the
    3D FPS game project (in the same locations):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从2D冒险游戏项目，将以下文件复制到3D FPS游戏项目（在相同的位置）：
- en: From `Assets/Scripts/Systems`
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`Assets/Scripts/Systems`
- en: '`HealthSystem.cs`'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HealthSystem.cs`'
- en: From `Assets/Scripts/Interfaces`
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`Assets/Scripts/Interfaces`
- en: '`IHeal.cs`'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IHeal.cs`'
- en: '`IDamage.cs`'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IDamage.cs`'
- en: '`IHaveHealth.cs`'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IHaveHealth.cs`'
- en: Now that the health system has been added to the project, the first thing to
    do is refactor any of the 2D API methods and types to the non-2D counterparts
    just like we did in the previous section, *Refactoring environment interactions
    to 3D API methods*. This includes changing all references of `OnTriggerEnter2D`
    to `OnTriggerEnter` and `Collider2D` to `Collider`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在健康系统已经添加到项目中，首先要做的是重构任何2D API方法和类型到非2D对应物，就像我们在上一节中做的那样，*重构环境交互到3D API方法*。这包括将所有`OnTriggerEnter2D`的引用更改为`OnTriggerEnter`，将`Collider2D`更改为`Collider`。
- en: Now, let’s go ahead and add `HealthSystem` as a component on the **PlayerCapsule**
    Prefab (again, in the Unity Starter Assets first-person character controller,
    this is the **Player** object).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续添加`HealthSystem`作为**PlayerCapsule** Prefab（再次提醒，在Unity Starter Assets第一人称角色控制器中，这是**玩家**对象）的组件。
- en: To satisfy the GDD requirement of decreasing the player’s power suit level (health),
    let’s write some code that extends upon the existing `HealthSystem` code that
    will slowly decrease health at an assigned rate. We’ll ensure we expose fields
    in the Inspector for the amount to reduce health by and the rate of decrease.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足降低玩家动力装甲等级（健康值）的GDD要求，让我们编写一些代码，扩展现有的 `HealthSystem` 代码，以在指定的速率缓慢减少健康值。我们将确保在检查器中公开减少健康值的数量和减少速率的字段。
- en: Constant damage script
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续伤害脚本
- en: Create a new C# script named `ConstantDamage` in the `Assets/Scripts` folder
    and open it for editing. We’ll replace the script template code with the following
    code, which should look familiar since we will implement the `IDamage` interface.
    The difference is that we won’t be triggering the damage from an object collision
    (like before with the `ProjectileDamage` class). Instead, we’ll be applying damage
    directly to the `HealthSystem` over time.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Assets/Scripts` 文件夹中创建一个新的 C# 脚本名为 `ConstantDamage` 并打开它进行编辑。我们将用以下代码替换脚本模板代码，这个代码应该看起来很熟悉，因为我们将实现
    `IDamage` 接口。区别在于，我们不会像之前的 `ProjectileDamage` 类那样从对象碰撞中触发伤害。相反，我们将直接在一段时间内对 `HealthSystem`
    施加伤害。
- en: 'Let’s start with the required implementations for `IDamage`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `IDamage` 的必需实现开始：
- en: '[PRE4]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A quick breakdown of the code looks like this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的快速概述如下：
- en: '`ConstantDamage : MonoBehaviour, IDamage`: This class is inheriting the `IDamage`
    interface, which means we’ll have to implement the properties and methods defined
    (the contract): `DamageMask`, `DamageAmount`, and `DoDamage()`.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConstantDamage : MonoBehaviour, IDamage`: 这个类继承自 `IDamage` 接口，这意味着我们必须实现定义的属性和方法（合同）：`DamageMask`、`DamageAmount`
    和 `DoDamage()`。'
- en: '`_damageMask`: This encapsulated private variable is serialized and assignable
    in the Inspector, with the `public DamageMask` getter (to satisfy the interface
    contract) referenced by `HealthSystem`.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_damageMask`: 这是一个封装的私有变量，可以在检查器中进行序列化和赋值，并通过 `public DamageMask` 获取器（以满足接口合同）被
    `HealthSystem` 引用。'
- en: The `_damageMask` is a `LayerMask` that determines what object **Layer** can
    be damaged by this.
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`_damageMask` 是一个 `LayerMask`，它决定了哪些对象 **层** 可以被这个脚本造成的伤害。'
- en: '`_damageAmount`: This encapsulated private variable is serialized and assignable
    in the Inspector, with the `public DamageAmount` getter (to satisfy the interface
    contract) referenced by `HealthSystem.TakeDamage()`.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_damageAmount`: 这是一个封装的私有变量，可以在检查器中进行序列化和赋值，并通过 `public DamageAmount` 获取器（以满足接口合同）被
    `HealthSystem.TakeDamage()` 引用。'
- en: This determines the amount of damage that will be applied to the object over
    time (via **coroutine**).
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这决定了将在一段时间内应用于对象的伤害量（通过 **协程**）。
- en: 'Now, we’ll add the code for applying damage over a set time interval:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加在设定的时间间隔内施加伤害的代码：
- en: '[PRE5]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And here’s a quick breakdown of the preceding code:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的快速概述：
- en: '`_damageInterval`: This is the private member variable that is serialized and
    assignable in the Inspector.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_damageInterval`: 这是一个序列化和可赋值的私有成员变量。'
- en: It determines the time interval of the damage amount that will be applied to
    the object (the damage rate).
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它确定了将应用于对象的伤害量（伤害速率）的时间间隔。
- en: '`StartCoroutine(ApplyDamageOverTime())`: This is how we start the coroutine
    in the `Start()` Unity message event, which will begin applying damage to the
    player right away.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StartCoroutine(ApplyDamageOverTime())`: 这是我们在 `Start()` Unity 消息事件中启动协程的方式，它将立即开始对玩家施加伤害。'
- en: '`ApplyDamageOverTime()`: This is our `IEnumerator` coroutine method that uses
    `while (true)` to loop indefinitely, calling `HandleDamageCollision()` then delaying
    5 seconds via `WaitForSeconds()` before looping again.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplyDamageOverTime()`: 这是一个 `IEnumerator` 协程方法，它使用 `while (true)` 无限循环，然后调用
    `HandleDamageCollision()`，并通过 `WaitForSeconds()` 延迟5秒后再次循环。'
- en: '`HandleDamageCollision(null…`: Here, we’re passing in a value of `null` for
    the `Collider` parameter since, well, we don’t have a collision occurring. We’ll
    just have to ensure we do a `DoDamage()`.'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HandleDamageCollision(null…`: 在这里，我们为 `Collider` 参数传递了一个 `null` 值，因为，嗯，我们没有发生碰撞。我们只需确保执行
    `DoDamage()`。'
- en: '`DoDamage()`: This declaration is required for the interface implementation
    (to satisfy the contract), but we won’t use it now.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoDamage()`: 这个声明是必需的，用于接口实现（以满足合同），但现在我们不会使用它。'
- en: Whew, that makes it seem like we have to do so much for only a dozen or so lines
    of code! And that’s the point. We introduce good architecture, patterns, and practices
    into our projects to accomplish more with less.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 呼，这让人感觉我们为了仅仅十几行代码就要做这么多！这正是重点。我们将良好的架构、模式和最佳实践引入我们的项目中，以更少的代码完成更多的工作。
- en: 'Add `ConstantDamage` as a component on the `PlayerCapsule` object (this will
    be a sibling component of `HealthSystem`) – so that the player’s health constantly
    decreases. Before we can test it out, assign the following values to the fields
    in the Inspector:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `ConstantDamage` 作为组件添加到 `PlayerCapsule` 对象上（这将是一个与 `HealthSystem` 相同的兄弟组件）——这样玩家的健康值就会不断减少。在我们测试之前，可以在检查器中将以下值分配给字段：
- en: '`Player` (you may have to add `Player` to the project’s layers list first,
    using the `PlayerCapsule` object in the hierarchy to the `Player` layer)'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player`（你可能需要首先将 `Player` 添加到项目的图层列表中，使用层次结构中的 `PlayerCapsule` 对象到 `Player`
    图层）'
- en: '`1`'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`'
- en: '`5` (seconds)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5`（秒）'
- en: Now you can save (*Ctrl*/*Cmd* + *S*) and enter `PlayerCapsule` `FirstPersonController`
    values under the `Player` header until the movement feels right in the level.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以保存（*Ctrl*/*Cmd* + *S*）并在 `Player` 标题下输入 `PlayerCapsule` `FirstPersonController`
    值，直到在关卡中感觉移动是正确的。
- en: It will be difficult to see if anything is happening right now because we don’t
    have any visual indicators in the scene, and the variable holding the current
    health value isn’t visible in the Inspector. No worries, Unity has a solution
    for this.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 目前可能很难看到任何正在发生的事情，因为我们场景中没有任何视觉指示器，并且当前健康值变量在检查器中不可见。不用担心，Unity 有解决方案。
- en: Inspector Debug
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查器调试
- en: The Unity Inspector has a Debug mode that will peek into our components’ code
    and expose private member variable fields as read-only values. While still in
    Play Mode, go ahead and switch the Inspector into Debug mode by clicking the vertical
    ellipsis (**⋮**) **More Items** menu (also known as the kabab menu) button (*A*),
    then click **Debug** to switch from **Normal** mode, as seen in the following
    screenshot.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 检查器有一个调试模式，可以查看我们的组件代码，并将私有成员变量字段作为只读值公开。在仍然处于播放模式时，点击垂直省略号（**⋮**）**更多项目**菜单（也称为咖喱菜单）按钮（*A*），然后点击**调试**以从**正常**模式切换，如以下截图所示。
- en: '![Figure 10.17 - Applying damage to the player](img/B18347_10_17.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.17 - 对玩家施加伤害](img/B18347_10_17.jpg)'
- en: Figure 10.17 - Applying damage to the player
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.17 - 对玩家施加伤害
- en: And now, we can see the private `_healthCurrent` variable field as `HealthSystem`
    component, which, according to our `ConstantDamage` assignments, will decrease
    `_healthCurrent` by a value of `1` every `5` seconds. Be sure to switch the Inspector
    back to Normal Mode when you’ve finished inspecting the value (you won’t generally
    need to see all the additional debug information).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到 `_healthCurrent` 私有变量字段作为 `HealthSystem` 组件，根据我们的 `ConstantDamage`
    分配，每 `5` 秒将 `_healthCurrent` 减少 `1` 的值。确保在检查完值后切换检查器回正常模式（你通常不需要看到所有额外的调试信息）。
- en: Additional reading | Unity documentation
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 附加阅读 | Unity 文档
- en: 'Learn more about working in the Inspector: [https://docs.unity3d.com/Manual/InspectorOptions.xhtml](https://docs.unity3d.com/Manual/InspectorOptions.xhtml).'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于在检查器中工作的信息：[https://docs.unity3d.com/Manual/InspectorOptions.xhtml](https://docs.unity3d.com/Manual/InspectorOptions.xhtml)。
- en: 'Also seen in *Figure 10**.17*, the **Console** warning message is (*C*): **HealthSystem
    on PlayerCapsule’ requires a sibling component that inherits** **from IHaveHealth!**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 还在 *图 10*.17 中看到，**控制台**警告信息是（*C*）：**PlayerCapsule 上的 HealthSystem 需要一个继承自 IHaveHealth
    的兄弟组件**！
- en: 'This console output results from a null check we had implemented in the original
    `HealthSystem` code when the `HealthChanged()` method is called. It just ensures
    that an object – that implements the `IHaveHealth` interface – exists before calling
    `HealthChanged()` or `Died()` methods on it, as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制台输出是由我们在原始 `HealthSystem` 代码中实现的空值检查产生的，当调用 `HealthChanged()` 方法时。它只是确保在调用
    `HealthChanged()` 或 `Died()` 方法之前，存在一个实现 `IHaveHealth` 接口的对象，如下所示：
- en: '[PRE6]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That takes care of the constantly decreasing health of the player. Now, how
    do we recharge this Kryk’zylx power suit?
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了玩家不断减少的健康值。现在，我们该如何为这个 Kryk’zylx 力量战服充电呢？
- en: Recharging aka healing
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 充电即治疗
- en: We’re going to create a pickup that will recharge (heal) the player, and this
    might be the quickest we’re going to add new functionality to our game yet! This
    is because we will again use previously written code and a similar approach to
    things we’ve already made.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个可以充电（治疗）玩家的拾取物，这可能是我们向游戏中添加新功能最快的方式！这是因为我们又将使用之前编写的代码和类似的方法来处理我们已经制作过的事物。
- en: From the previous 2D adventure game project, copy in the `PickupHeal.cs` and
    `Destroyer.cs` scripts. We’re going to place pickups for recharging/healing the
    player throughout the level – which is something we’ve made before, so maybe try
    making this on your own first? The only difference is that now we will create
    a ProBuilder object as a 3D pickup compared to the 2D sprite pickup we previously
    made.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的 2D 冒险游戏项目复制 `PickupHeal.cs` 和 `Destroyer.cs` 脚本。我们将在整个级别中放置用于为玩家充电/治疗的拾取物——这是我们之前制作过的，所以也许你可以先自己尝试制作？唯一的区别是，现在我们将创建一个
    ProBuilder 对象作为 3D 拾取物，而不是我们之前制作的 2D 精灵拾取物。
- en: 'Don’t worry; we’re still going to follow the below steps that you can check
    your work against. So, here we go. To make a 3D object as a healing pickup, follow
    these steps:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心；我们仍然会按照以下步骤进行，以便你可以对照检查你的工作。所以，让我们开始吧。要将一个 3D 对象作为治疗拾取物，请遵循以下步骤：
- en: Make a ProBuilder object to use as a pickup (a cube, sphere, cone, etc.). With
    grid snapping enabled, you’ll want to use incremental snapping (hold *Ctrl*/*Cmd*)
    to make it a suitable size compared to the player.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 ProBuilder 对象作为拾取物（一个立方体、球体、圆锥体等）。启用网格吸附后，你将想要使用增量吸附（按住 *Ctrl*/*Cmd*）来使其大小与玩家相匹配。
- en: On the new object you’ve made for the pickup, set **MeshCollider** as **Convex**
    and **IsTrigger** as **Enabled** (don’t use the **SetTrigger** option from ProBuilder
    because we want the mesh to be visible as is).
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你为拾取物创建的新对象上，将 **MeshCollider** 设置为 **凸面**，将 **IsTrigger** 设置为 **启用**（不要使用
    ProBuilder 中的 **SetTrigger** 选项，因为我们希望网格保持可见）。
- en: Use ProBuilder’s **Vertex Colors** to set a new color on the pickup object.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 ProBuilder 的 **顶点颜色** 为拾取对象设置新的颜色。
- en: Add both `PickupHeal` and `Destroyer` as components on the ProBuilder object.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 ProBuilder 对象上添加 `PickupHeal` 和 `Destroyer` 作为组件。
- en: Assign `Player` as the `Destroyer.DestroyMe` as a listener for `OnHealEvent`
    (ensure it’s set to **Runtime Only** and not **Off**).
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Player` 作为 `Destroyer.DestroyMe` 的监听器分配给 `OnHealEvent`（确保设置为 **仅运行时** 而不是
    **关闭**）。
- en: Rename the object to `Heal Pickup` (or `Recharge Pickup`) and drag it from the
    hierarchy to the `Assets/Prefabs` folder to make it a reusable Prefab.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象重命名为 `Heal Pickup`（或 `Recharge Pickup`），并将其从层次结构拖动到 `Assets/Prefabs` 文件夹以使其成为可重用的
    Prefab。
- en: How’d you do on your own? With our healing pickup Prefab completed, we can now
    scatter them throughout the level in a strategic way to create good, challenging
    gameplay for the player. Enter Play Mode now and verify in the Inspector **Debug
    mode** that the current health value is restored when a pickup is collected. As
    always, you’ll continue to playtest – or better, enlist others to playtest as
    you observe – and balance values to provide the best player experience!
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 你自己做得怎么样？随着我们的治疗拾取物 Prefab 完成，我们现在可以以战略方式将它们散布在整个级别中，为玩家创造良好的、具有挑战性的游戏体验。现在进入游戏模式，并在检查器中的
    **调试模式** 中验证，当拾取物被收集时，当前的健康值是否已恢复。一如既往，你将继续进行游戏测试——或者更好的是，在观察的同时让其他人进行游戏测试——并调整数值以提供最佳的玩家体验！
- en: In this section, we saw how to reuse existing components to quickly add health
    system functionality to the player and extend functionality with a new component
    that applies constant damage. We also learned how to view and debug private member
    component values in the Inspector, then finished with more code reuse to rapidly
    create a 3D pickup object that recharges the player’s health.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何重用现有组件以快速向玩家添加健康系统功能，并通过添加一个应用恒定伤害的新组件来扩展功能。我们还学习了如何在检查器中查看和调试私有成员组件值，然后通过更多的代码重用来快速创建一个为玩家恢复健康的
    3D 拾取物对象。
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter first covered a quick addition to our GDD to add specifics for
    our new 3D FPS game, including considerations for 3D-level design. We used the
    updated GDD to block out the interior habitat level environment from a greyboxing
    kit of modular parts that snap together and draw out a level map, all using Unity
    ProBuilder.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先对我们的 GDD 进行了快速补充，以添加我们新 3D 第一人称射击游戏的具体内容，包括 3D 级别设计的考虑。我们使用更新的 GDD 从模块化部件的灰色盒子套件中构建内部栖息地级别环境，绘制出级别地图，所有这些操作都使用
    Unity ProBuilder 完成。
- en: We continued by learning how to rapidly add an FPS player character to our game
    by leveraging the Unity Starter Assets first-person character controller. We also
    rapidly added behavior to our player with code reuse for the health system and
    healing pickups. Code reuse and refactoring 2D components to the 3D API method
    counterparts also allowed us to quickly make an animated door that opens when
    the player triggers.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续学习如何通过利用 Unity Starter Assets 中的第一人称角色控制器快速将 FPS 玩家角色添加到我们的游戏中。我们还通过代码复用为玩家添加了健康系统和治疗拾取的行为。代码复用和将
    2D 组件重构为 3D API 方法对应者，也使我们能够快速制作一个当玩家触发时开启的动画门。
- en: 'In the next chapter, we’ll continue with the environment-level design by replacing
    the modular greybox kit Prefabs with art assets and decorating with more Unity-provided
    tooling: Polybrush and Decals. We will then finalize the environment design process
    by baking the 3D environment lighting to ensure high-performance rendering while
    comparing it with real-time lighting to evaluate the pros and cons of each.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续环境级别的设计，通过用艺术资源替换模块化灰盒套件 Prefabs，并使用更多 Unity 提供的工具进行装饰：Polybrush
    和 Decals。然后，我们将通过烘焙 3D 环境照明来最终确定环境设计过程，以确保高性能渲染，同时将其与实时照明进行比较，以评估各自的优缺点。
