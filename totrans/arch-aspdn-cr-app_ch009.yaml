- en: 8 Dependency Injection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 依赖注入
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始之前：加入我们的 Discord 书籍社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的 Discord 服务器上与其他早期读者聊天（在“architecting-aspnet-core-apps-3e”频道下找到，属于早期访问订阅）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file39.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![二维码描述自动生成](img/file39.png)'
- en: 'This chapter explores the ASP.NET Core **Dependency Injection** (**DI**) system,
    how to leverage it efficiently, and its limits and capabilities.We learn to compose
    objects using DI and delve into the Inversion of Control (IoC) principle. As we
    traverse the landscape of the built-in DI container, we explore its features and
    potential uses.Beyond practical examples, we lay down the conceptual foundation
    of Dependency Injection to understand its purpose, its benefits, and the problems
    it solves and to lay down the ground for the rest of the book as we rely heavily
    on DI.We then return to the first three Gang of Four (GoF) design patterns we
    encountered, but this time, through the lens of Dependency Injection. By refactoring
    these patterns using DI, we gain a more holistic understanding of how this powerful
    design tool influences the structure and flexibility of our software.Dependency
    Injection is a cornerstone in your path toward mastering modern application design
    and its transformative role in developing efficient, adaptable, testable, and
    maintainable software.In this chapter, we cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了 ASP.NET Core **依赖注入（DI**）系统，如何高效地利用它，以及其局限性和能力。我们学习使用 DI 来组合对象，并深入研究控制反转（IoC）原则。在我们遍历内置
    DI 容器时，我们探索其特性和潜在用途。除了实际示例之外，我们还为依赖注入奠定概念基础，以了解其目的、其好处以及它解决的问题，并为本书的其余部分奠定基础，因为我们严重依赖
    DI。然后，我们回到我们遇到的前三个四人帮（GoF）设计模式，但这次是通过依赖注入的视角。通过使用 DI 重构这些模式，我们获得了对这个强大设计工具如何影响我们软件的结构和灵活性的更全面的理解。依赖注入是您通往掌握现代应用程序设计的基石，它在开发高效、可适应、可测试和可维护的软件中发挥着变革性的作用。在本章中，我们涵盖了以下主题：
- en: What is dependency injection?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是依赖注入？
- en: Revisiting the Strategy pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视策略模式
- en: Understanding guard clauses
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解守卫子句
- en: Revisiting the Singleton pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视单例模式
- en: Understanding the Service Locator pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解服务定位器模式
- en: Revisiting the Factory pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视工厂模式
- en: What is dependency injection?
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是依赖注入？
- en: DI is a way to apply the **Inversion of Control** (**IoC**) principle. IoC is
    a broader version of the dependency inversion principle (the *D* in SOLID).The
    idea behind DI is to move the creation of dependencies from the objects themselves
    to the **composition root**. That way, we can delegate the management of dependencies
    to an **IoC container**, which does the heavy lifting.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入（DI）是应用控制反转（IoC）原则的一种方式。IoC 是依赖倒置原则（SOLID 中的 *D*）的更广泛版本。依赖注入背后的想法是将依赖的创建从对象本身转移到**组合根**。这样，我们可以将依赖的管理委托给一个**IoC
    容器**，它来完成繁重的工作。
- en: An IoC container and a **DI container** are the same thing—they’re just different
    words people use. I use both interchangeably in real life, but I stick to IoC
    container in the book because it seems more accurate than DI container.
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IoC 容器和 DI 容器是同一件事——只是人们用的不同词汇。我在现实生活中两者都交替使用，但在书中我坚持使用 IoC 容器，因为它似乎比 DI 容器更准确。
- en: ''
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: IoC is the concept (the principle), while DI is a way of inverting the flow
    of control (applying IoC). For example, you apply the IoC principle (inverting
    the flow) by injecting dependencies at runtime (doing DI) using a container. Feel
    free to use any or both.
  id: totrans-16
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IoC 是一个概念（原则），而 DI 是一种反转控制流（应用 IoC）的方式。例如，通过使用容器在运行时注入依赖（执行 DI）来应用 IoC 原则（反转流）。您可以根据需要使用任何或两者。
- en: Next, we define the composition root.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义组合根。
- en: The composition root
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合根
- en: 'A critical concept behind DI is the composition root. The composition root
    is where we tell the container about our dependencies and their expected lifetime:
    where we compose our dependency trees. The composition root should be as close
    to the program''s starting point as possible, so from ASP.NET Core 6 onward, the
    composition root is in the `Program.cs` file. In the previous versions, it was
    in the `Program` or `Startup` classes.Next, we explore how to leverage DI to create
    highly adaptable systems.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: DI 背后的一个关键概念是组合根。组合根是我们告诉容器我们的依赖关系及其预期生命周期的位置：我们构建依赖关系树的地方。组合根应尽可能接近程序的起点，因此从
    ASP.NET Core 6 开始，组合根位于 `Program.cs` 文件中。在之前的版本中，它位于 `Program` 或 `Startup` 类中。接下来，我们将探讨如何利用
    DI 创建高度适应性的系统。
- en: Striving for adaptability
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 追求适应性
- en: 'To achieve a high degree of flexibility with DI, we can apply the following
    formula, driven by the SOLID principles:Object `A` should not know about object
    `B` that it is using. Instead, `A` should use an interface, `I`, implemented by
    `B`, and `B` should be resolved and injected at runtime.Let’s decompose this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 DI 实现高度的灵活性，我们可以应用以下公式，由 SOLID 原则驱动：对象 `A` 不应了解它所使用的对象 `B`。相反，`A` 应该使用由
    `B` 实现的接口 `I`，`B` 应在运行时解决并注入。让我们分解一下：
- en: Object `A` should depend on interface `I` instead of concrete type `B`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象 `A` 应依赖接口 `I` 而不是具体的类型 `B`。
- en: Instance `B`, injected into `A`, should be resolved by the IoC container at
    runtime.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例 `B` 注入到 `A` 中，应在运行时由 IoC 容器解决。
- en: '`A` should not be aware of the existence of `B`.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A` 不应意识到 `B` 的存在。'
- en: '`A` should not control the lifetime of `B`.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A` 不应控制 `B` 的生命周期。'
- en: We can also inject objects directly without passing by an interface. It all
    depends on what we inject, in what context, and our requirements. We tackle many
    use cases throughout the book to help you understand DI.
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们也可以直接注入对象，而不通过接口传递。这完全取决于我们注入的内容、上下文以及我们的需求。本书中我们探讨了多个用例，以帮助您理解 DI。
- en: Next, we translate this equation into an analogy that helps explain the reasons
    to use a container.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将这个方程式转化为一个类比，以帮助解释使用容器的理由。
- en: Understanding the use of the IoC container
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 IoC 容器的使用
- en: 'To better understand the use of the IoC container and to create an image around
    the previous adaptability concept, let’s start with a LEGO® analogy where IoC
    is the equivalent of drawing a plan to build a LEGO®castle:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 IoC 容器的使用并围绕之前的适应性概念创建一个图像，让我们从一个乐高®类比开始，其中 IoC 是绘制建造乐高®城堡计划的等价物：
- en: We draw the plan
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们绘制计划
- en: We gather the blocks
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们收集模块
- en: We press the start button on a hypothetical robot builder
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们按下假设的机器人建造者的启动按钮
- en: The robot assembles the blocks by following our plan
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 机器人按照我们的计划组装模块
- en: The castle is complete
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 城堡已建成
- en: By following this logic, we can create a new 4x4 block with a unicorn painted
    on its side (concrete type), update the plan (composition root), and then press
    the restart button to rebuild the castle with that new block inserted into it,
    replacing the old one without affecting the structural integrity of the castle
    (program). As long as we respect the 4x4 block contract (interface), everything
    is updatable without impacting the rest of the castle, leading to great flexibility.Following
    that idea, if we need to manage every single LEGO® block one by one, it would
    quickly become incredibly complex! Therefore, managing all dependencies by hand
    in a project would be super tedious and error-prone, even in the smallest program.
    This situation is where an IoC container (the hypothetical robot builder) comes
    into play.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这个逻辑，我们可以创建一个新的 4x4 模块，其侧面画有独角兽（具体类型），更新计划（组合根），然后按下重启按钮，将新模块插入其中，替换旧的模块，而不影响城堡的结构完整性（程序）。只要我们尊重
    4x4 模块合同（接口），一切都可以更新，而不会影响城堡的其他部分，从而实现极大的灵活性。遵循这个想法，如果我们需要逐个管理每个乐高®模块，这会迅速变得极其复杂！因此，在项目中手动管理所有依赖关系将非常繁琐且容易出错，即使在最小的程序中也是如此。这种情况就是
    IoC 容器（假设的机器人建造者）发挥作用的时候。
- en: The role of an IoC container
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IoC 容器的角色
- en: 'An IoC container manages objects for us. We configure it, and then, when we
    ask for a service, the container resolves and injects it. On top of that, the
    container manages the lifetime of dependencies, leaving our classes to do only
    one thing, the job we designed them to do. No more need to think about their dependencies!The
    bottom line is that an IoC container is a DI framework that does the auto-wiring
    for us. We can conceptualize Dependency Injection as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: IoC容器为我们管理对象。我们对其进行配置，然后，当我们请求一个服务时，容器解析并注入它。除此之外，容器还管理依赖的生命周期，让我们的类只做一件事，即它们被设计来做的任务。不再需要考虑它们的依赖！总之，IoC容器是一个DI框架，为我们自动连接。我们可以这样理解依赖注入：
- en: The *consumer* of a dependency states its needs about one or more dependencies
    (contracts).
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖的*消费者*声明其对一个或多个依赖（契约）的需求。
- en: The IoC container injects that dependency (implementation) upon creating the
    *consumer*, fulfilling its needs at runtime.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IoC容器在创建*消费者*时注入该依赖（实现），在运行时满足其需求。
- en: Next, we explore an code smell that applying Dependency Injection helps us avoid.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一个依赖注入可以帮助我们避免的代码异味。
- en: Code smell – Control Freak
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码异味 – 控制狂
- en: 'Control freak is a code smell and even an anti-pattern that forbids us from
    using the `new` keyword. Yes, using the `new` keyword is the code smell! The following
    code is wrong and can’t leverage DI:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 控制狂是一种代码异味，甚至是一种反模式，它禁止我们使用`new`关键字。是的，使用`new`关键字就是代码异味！以下代码是错误的，无法利用DI：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The highlighted line shows the anti-pattern in action. To enable the Consumer
    class to use dependency injection, we could update it like the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮行显示了反模式的作用。为了使Consumer类能够使用依赖注入，我们可以像以下这样更新它：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code removes the new keyword and is now open for modification.
    The highlighted lines represent the constructor injection pattern we explore subsequently
    in this chapter.Nevertheless, do not ban the `new` keyword just yet. Instead,
    every time you use it, ask yourself whether the object you instantiated using
    the `new` keyword is a dependency that could be managed by the container and injected
    instead.To help with that, I borrowed two terms from Mark Seemann’s book *Dependency
    Injection in .NET*; the name *Control Freak* also comes from that book. He describes
    the following two categories of dependencies:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码去掉了`new`关键字，现在可以修改。高亮行表示我们在本章随后探讨的构造函数注入模式。不过，现在还不要禁止使用`new`关键字。相反，每次你使用它时，都要问问自己，你使用`new`关键字实例化的对象是否是容器可以管理的依赖，并可以注入。为了帮助做到这一点，我从Mark
    Seemann的《.NET依赖注入》一书中借用了两个术语；*控制狂*这个名字也来自那本书。他描述了以下两种依赖类别：
- en: Stable dependencies
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定依赖
- en: Volatile dependencies
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易变依赖
- en: Next is my take on defining them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将谈谈如何定义它们。
- en: Stable dependencies
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 稳定依赖
- en: '**Stable dependencies** should not break our application when a new version
    is released. They should use deterministic algorithms (input `X` should always
    produce output `Y`), and you should not expect to change them with something else
    in the future.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**稳定依赖**在发布新版本时不应破坏我们的应用程序。它们应使用确定性算法（输入`X`应始终产生输出`Y`），并且你不应该期望将来用其他东西来改变它们。'
- en: Most data structures devoided of behaviors, like Data Transfer Objects (DTOs),
    fall into this category. You can also consider the .NET BCL as stable dependencies.
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数没有行为的数据库结构，如数据传输对象（DTOs），都属于这一类。你也可以将.NET BCL视为稳定的依赖。
- en: We can still instantiate objects using the `new` keyword when they fall into
    this category because the dependencies are stable and unlikely to break anything
    if they change.Next, we look at their counterpart.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当它们属于这一类别时，我们仍然可以使用`new`关键字来实例化对象，因为依赖是稳定的，并且不太可能因为变化而破坏任何东西。接下来，我们来看看它们的对立面。
- en: Volatile dependencies
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 易变依赖
- en: '**Volatile dependencies** can change at runtime, like extendable elements with
    contextual behaviors. They may also be likely to change for various reasons like
    new features development.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**易变依赖**可能在运行时发生变化，例如具有上下文行为的可扩展元素。它们也可能因为各种原因（如新功能开发）而可能发生变化。'
- en: Most classes we create, such as data access and business logic code, are volatile
    dependencies.
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们创建的大多数类，如数据访问和业务逻辑代码，都是易变依赖。
- en: The primary way to break the tight coupling between classes is to rely on interfaces
    and DI and no longer instantiate those volatile dependencies using the `new` keyword.
    Volatile dependencies are why dependency injection is key to building flexible,
    testable, and maintainable software.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 打破类之间紧密耦合的主要方式是依赖接口和依赖注入，并且不再使用`new`关键字来实例化那些易变的依赖项。易变的依赖项是依赖注入成为构建灵活、可测试和可维护的软件的关键。
- en: Conclusion
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结论
- en: 'To conclude this interlude: don’t be a control freak anymore; those days are
    behind you!'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结这个插曲：别再当控制狂了；那些日子已经过去了！
- en: When in doubt, inject the dependency instead of using the `new` keyword.
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果有疑问，请注入依赖项而不是使用`new`关键字。
- en: Next, we explore the available lifetimes we can attribute to our volatile dependencies.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨我们可以分配给我们的易变依赖项的可用的生命周期。
- en: Object lifetime
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象生命周期
- en: Now that we understand we should no longer use the `new` keyword, we need a
    way to create those classes. From now on, the IoC container will play that role
    and manage object instantiation and their lifetime for us.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们明白我们不应再使用`new`关键字，我们需要一种创建这些类的方法。从现在起，IoC容器将扮演这个角色，并为我们管理对象实例化和它们的生命周期。
- en: What’s an object's lifetime?
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对象的生命周期是什么？
- en: When we create an instance manually, using the `new` keyword, we create a hold
    on that object; we know when we create it and when its life ends. That’s the lifetime
    of the object.Of course, using the `new` keyword leaves no chance to control these
    objects from the outside, enhance them, intercept them, or swap them for another
    implementation—as covered in the preceding *Code smell – Control Freak* section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们手动创建实例时，使用`new`关键字，我们会对该对象产生依赖；我们知道何时创建它以及何时结束其生命周期。这就是对象的生命周期。当然，使用`new`关键字不会给我们留下从外部控制这些对象、增强它们、拦截它们或用另一个实现替换它们的机会——如前文所述的*代码异味
    - 控制狂*部分。
- en: .NET object lifetime
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: .NET对象生命周期
- en: 'With dependency injection, we need to forget about controlling objects and
    start to think about using dependencies, or more explicitly, depending on their
    interfaces. In ASP.NET Core, there are three possible lifetimes to choose from:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖注入，我们需要忘记控制对象，开始考虑使用依赖项，或者更明确地说，依赖它们的接口。在ASP.NET Core中，有三种可能的生命周期可供选择：
- en: '| **Lifetime** | **Description** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **生命周期** | **描述** |'
- en: '| Transient | The container creates a new instance every time. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 瞬态 | 容器每次都会创建一个新的实例。 |'
- en: '| Scoped | The container creates an instance per HTTP request and reuses it.In
    some rare cases, we can also create custom scopes. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 作用域 | 容器为每个HTTP请求创建一个实例并重用它。在某些罕见情况下，我们还可以创建自定义作用域。 |'
- en: '| Singleton | The container creates a single instance of that dependency and
    always reuses that unique object. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 单例 | 容器为该依赖项创建单个实例，并始终重用该唯一对象。 |'
- en: 'Table 8.1: objects lifetime description'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1：对象生命周期描述
- en: 'We can now manage our volatile dependencies using one of those three scopes.
    Here are some questions to help you choose:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这三种作用域之一来管理我们的易变依赖项。以下是一些帮助你选择的问题：
- en: Do I need a single instance of my dependency? Yes? Use the **singleton** lifetime.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否需要我为我的依赖项创建单个实例？是的？使用**单例**生命周期。
- en: Do I need a single instance of my dependency shared over an HTTP request? Yes?
    Use the **scoped** lifetime.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否需要我在整个HTTP请求中共享我的依赖项的单个实例？是的？使用**作用域**生命周期。
- en: Do I need a new instance of my dependency every time? Yes? Use the **transient**
    lifetime.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次是否需要我为我的依赖项创建一个新的实例？是的？使用**瞬态**生命周期。
- en: A general approach to object lifetime is to design the components to be *singletons*.
    When impossible, we go for *scoped*. When *scoped* is also impossible, go for
    *transient*. This way, we maximize instance reuse, lower the overhead of creating
    objects, lower the memory cost of keeping those objects in memory, and lower the
    amount of garbage collection needed to remove unused instances.
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对象生命周期的通用方法是设计组件为**单例**。当不可能时，我们选择**作用域**。当**作用域**也不可能时，选择**瞬态**。这样，我们最大化实例重用，降低创建对象的开销，降低保持这些对象在内存中的内存成本，并降低移除未使用实例所需的垃圾回收量。
- en: ''
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, we can pick *singleton* mindlessly for stateless objects, which
    are the easiest to maintain and less likely to break.
  id: totrans-79
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，我们可以不加思考地选择**单例**用于无状态对象，这些对象最容易维护且不太可能出错。
- en: ''
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For stateful objects, where multiple consumers use the same instance, we must
    ensure the object is thread-safe if the lifetime is *singleton* or *scoped* because
    multiple consumers could try to access it simultaneously.
  id: totrans-81
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于多个消费者使用相同实例的状态对象，如果生命周期是 *singleton* 或 *scoped*，我们必须确保对象是线程安全的，因为多个消费者可能会同时尝试访问它。
- en: ''
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: One essential aspect to consider when choosing a lifetime is the consumers of
    stateful objects. For example, if we load data related to the current user, we
    must ensure that data do not leak to other users. To do so, we can define the
    lifetime of that object to *scoped*, which is limited to a single HTTP request.
    If we don’t want to reuse that state between multiple consumers, we can choose
    a *transient* lifetime to ensure every consumer gets their own instance.
  id: totrans-83
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在选择生命周期时，需要考虑的一个基本方面是状态对象的消费者。例如，如果我们加载与当前用户相关的数据，我们必须确保数据不会泄露到其他用户。为此，我们可以将那个对象的生命周期定义为
    *scoped*，这限制于单个 HTTP 请求。如果我们不希望在多个消费者之间重用该状态，我们可以选择 *transient* 生命周期以确保每个消费者都得到自己的实例。
- en: How does that translate into code? .NET offers multiple extension methods to
    help us configure the lifetimes of our objects, like `AddTransient`, `AddScoped`,
    and `AddSingleton`, which explicitly state their lifetimes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这如何转化为代码？.NET 提供了多个扩展方法来帮助我们配置对象的生命周期，如 `AddTransient`、`AddScoped` 和 `AddSingleton`，它们明确声明了它们的生命周期。
- en: We use the built-in container throughout the book with many of its registration
    methods, so you should grow familiar with it very quickly. It has good discoverability,
    so you can explore the possibilities using IntelliSense while writing code or
    reading the documentation.
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在整本书中使用了内置的容器，并对其许多注册方法进行了使用，因此你应该很快就能熟悉它。它具有良好的可发现性，因此你可以在编写代码或阅读文档时使用 IntelliSense
    来探索其可能性。
- en: Next, we use those methods and explore how to register dependencies with the
    container.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用这些方法并探索如何使用容器注册依赖项。
- en: Registering our dependencies
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册我们的依赖项
- en: 'In ASP.NET Core, we register our dependencies in the `Program.cs` file, which
    represents the composition root. Since the minimal hosting model, the `WebApplicationBuilder`
    exposes the `Services` property we use to add our dependencies to the container.
    Afterward, .NET creates the container when it builds the `WebApplication` instance.Next
    is a minimal `Program.cs` file depicting this concept:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 中，我们在 `Program.cs` 文件中注册我们的依赖项，该文件代表组合根。由于最小托管模型，`WebApplicationBuilder`
    提供了 `Services` 属性，我们可以用它将依赖项添加到容器中。之后，.NET 在构建 `WebApplication` 实例时创建容器。以下是一个展示这一概念的简化
    `Program.cs` 文件：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we use the `builder.Services` property to register our dependencies in
    that `IServiceCollection` implementation. Here’s an example of registering some
    dependencies:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `builder.Services` 属性在 `IServiceCollection` 实现中注册我们的依赖项。以下是一些注册依赖项的示例：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code registers the dependencies using the singleton lifetime,
    so we get the same instance each time we request one.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用单例生命周期注册了依赖项，因此每次请求时我们都得到相同的实例。
- en: Remember to compose the program in the composition root. That removes the need
    for those pesky `new` keywords spread around your code base and all the tight
    coupling that come with them. Moreover, it centralizes the application’s composition
    into that location, creating the plan to assemble the LEGO® blocks.
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 记住要在组合根中组合程序。这消除了在代码库中散布的 `new` 关键字的需求，以及随之而来的所有紧密耦合。此外，它将应用程序的组合集中到那个位置，创建组装乐高®积木的计划。
- en: As you may be thinking right now, that can lead to a lot of registration statements
    in a single location, and you are correct; maintaining such a composition root
    would be a challenge in almost any application. To address this concern, we introduce
    an elegant way to encapsulate the registration code next, ensuring it remains
    manageable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在可能正在想的那样，这可能导致在单个位置出现大量的注册语句，而且你是正确的；在几乎任何应用程序中维护这样的组合根都是一个挑战。为了解决这个问题，我们引入了一种优雅的方式来封装注册代码，确保它保持可管理。
- en: Registering your features elegantly
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优雅地注册你的功能
- en: As we've just discovered, while we should register dependencies in the composition
    root, we can also arrange our registration code in a structured manner. For example,
    we can break down our application's composition into several methods or classes
    and invoke them from our composition root. Another strategy could be to use an
    auto-discovery system to automate the registration of certain services.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚发现的，虽然我们应该在组合根中注册依赖项，但我们也可以以结构化的方式安排我们的注册代码。例如，我们可以将应用程序的组合分解成几个方法或类，并从我们的组合根中调用它们。另一种策略是使用自动发现系统来自动注册某些服务。
- en: The critical part is to centralize the program composition in one place.
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关键部分是将程序组成集中在一个地方。
- en: A common pattern in ASP.NET Core is having special methods like `Add[Feature
    name]`. These methods register their dependencies, letting us add a group of dependencies
    with just one method call. This pattern is convenient for breaking down program
    composition into smaller, easier-to-handle parts, like individual features. This
    also makes the composition root more readable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 中，一个常见的模式是拥有像 `Add[功能名称]` 这样的特殊方法。这些方法注册它们的依赖项，让我们只需一个方法调用就能添加一组依赖项。这种模式方便将程序组成分解成更小、更容易处理的部件，如单个功能。这也使得组合根更加易于阅读。
- en: A feature is the correct size as long as it stays cohesive. If your feature
    becomes too big, does too many things, or starts to share dependencies with other
    features, it may be time for a redesign before losing control over it. That’s
    usually a good indicator of undesired coupling.
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只要功能保持内聚，其大小就是正确的。如果你的功能变得太大，做了太多事情，或者开始与其他功能共享依赖项，那么在失去控制之前可能需要重新设计。这通常是不希望耦合的好指标。
- en: 'To implement this pattern, we use extension methods, making it trivial. Here’s
    a guide:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此模式，我们使用扩展方法，使其变得简单。以下是一个指南：
- en: Create a static class named `[subject]Extensions` in the `Microsoft.Extensions.DependencyInjection`
    namespace.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Microsoft.Extensions.DependencyInjection` 命名空间中创建一个名为 `[subject]Extensions`
    的静态类。
- en: Create an extension method that returns the `IServiceCollection` interface,
    which allows method calls to be chained.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个返回 `IServiceCollection` 接口的扩展方法，这允许方法调用链式调用。
- en: According to Microsoft's recommendation, we should create the class in the same
    namespace as the element we extend. In our case, the `IServiceCollection` interface
    lives in the `Microsoft.Extensions.DependencyInjection` namespace.
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 根据微软的建议，我们应该在我们扩展的元素所在的命名空间中创建该类。在我们的例子中，`IServiceCollection` 接口位于 `Microsoft.Extensions.DependencyInjection`
    命名空间中。
- en: Of course, this is not mandatory, and we can adapt this process to our needs.
    For example, we can define the class in another namespace if we want consumers
    to add a `using` statement implicitly. We can also return something else when
    the registration process can continue beyond that first method, like a builder
    interface.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并非强制性的，我们可以根据我们的需求调整此过程。例如，如果我们想消费者隐式地添加 `using` 语句，我们可以将类定义在另一个命名空间中。我们还可以在注册过程可以继续到第一个方法之后返回其他内容，例如构建器接口。
- en: Builder interfaces are used to configure more complex features, like ASP.NET
    Core MVC. For example, the `AddControllers` extension method returns an `IMvcBuilder`
    interface that contains a `PartManager` property. Moreover, some extension methods
    target the `IMvcBuilder` interface, allowing further configuration of the feature
    by requiring its registration first; that is, you can’t configure `IMvcBuilder`
    before calling `AddControllers`. You can also design your features to leverage
    that pattern when needed.
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 构建器接口用于配置更复杂的功能，如 ASP.NET Core MVC。例如，`AddControllers` 扩展方法返回一个 `IMvcBuilder`
    接口，该接口包含一个 `PartManager` 属性。此外，一些扩展方法针对 `IMvcBuilder` 接口，允许通过首先注册它来进一步配置功能；也就是说，在调用
    `AddControllers` 之前不能配置 `IMvcBuilder`。你还可以设计你的功能，以便在需要时利用该模式。
- en: Let’s explore a demo.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一个演示。
- en: Project – Registering the Demo Feature
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 – 注册演示功能
- en: 'Let’s explore registering the dependencies of the Demo Feature. That feature
    contains the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索注册演示功能的依赖项。该功能包含以下代码：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As we can see, there is nothing complex but two empty classes and an interface.
    Remember that we are exploring the registration of dependencies, not what to do
    with them or what they can do—yet.Now, we want the container to serve an instance
    of the `MyFeatureDependency` class when a dependency requests the `IMyFeatureDependency`
    interface as the `MyFeature` class does. We want a singleton lifetime.To achieve
    this, in the `Program.cs` file, we can write the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，没有复杂的东西，只有两个空类和一个接口。记住，我们正在探索依赖项的注册，而不是它们要做什么或能做什么——现在。现在，我们希望当依赖项请求`IMyFeatureDependency`接口作为`MyFeature`类所做的那样时，容器能够提供一个`MyFeatureDependency`类的实例。我们希望它是单例生命周期。为了实现这一点，在`Program.cs`文件中，我们可以编写以下代码：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can also chain the two method calls instead:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将两个方法调用链式调用：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, this is not yet elegant. What we want to achieve is this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这还不是优雅的。我们想要实现的是这个：
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To build that registration method, we can write the following extension method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建这个注册方法，我们可以编写以下扩展方法：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As highlighted, the registration is the same but uses the `services` parameter,
    which is the extended type, instead of the `builder.Services` (`builder` does
    not exist in that class, yet the `services` parameter is the same object as the
    `builder.Services` property).If you are unfamiliar with extension methods, they
    come in handy for extending existing classes, like we just did. Besides having
    a static method inside a static class, the `this` keyword next to the first parameter
    determines whether it is an extension method.For example, we can build sophisticated
    libraries that are easy to use with a set of extension methods. Think `System.Linq`
    for such a system.Now that we learned the basics of dependency injection, there
    is one last thing to cover before revisiting the Strategy design pattern.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如同所强调的，注册方式相同，但使用的是`services`参数，这是扩展类型，而不是`builder.Services`（`builder`在这个类中不存在，但`services`参数与`builder.Services`属性是同一个对象）。如果你不熟悉扩展方法，它们对于扩展现有类非常有用，就像我们刚才做的那样。除了在静态类内部有静态方法之外，第一个参数旁边的`this`关键字决定了它是否是一个扩展方法。例如，我们可以构建一套扩展方法，这些方法可以构建易于使用的复杂库。想想`System.Linq`这样的系统。现在，我们学习了依赖注入的基础知识，在重新访问策略设计模式之前，还有最后一件事要介绍。
- en: Using external IoC containers
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用外部 IoC 容器
- en: 'ASP.NET Core provides an extensible built-in IoC container out of the box.
    It is not the most powerful IoC container because it lacks some advanced features,
    but it does the job for most applications.Rest assured; we can change it to another
    one if need be. You might also want to do that if you are used to another IoC
    container and want to stick to it.Here’s the strategy I recommend:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core提供了一个开箱即用的可扩展内置 IoC 容器。它不是最强大的 IoC 容器，因为它缺少一些高级功能，但它对大多数应用程序来说都能完成任务。请放心，如果需要，我们可以将其更改为另一个。如果你习惯于使用另一个
    IoC 容器并希望继续使用它，你可能也想这样做。以下是我推荐的策略：
- en: Use the built-in container, as per Microsoft's recommendation.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照微软的建议，使用内置容器。
- en: When you can’t achieve something with it, look at your design and see if you
    can redesign your feature to work with the built-in container and simplify your
    design.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你不能用它实现某事时，看看你的设计，看看你是否可以重新设计你的功能以与内置容器一起工作并简化你的设计。
- en: If it is impossible to achieve your goal, see if extending the default container
    using an existing library or coding the feature yourself is possible.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果无法实现你的目标，看看是否可以通过使用现有库扩展默认容器或自己编写功能来实现。
- en: If it is still impossible, explore swapping it for another IoC container.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果仍然不可能，尝试将其替换为另一个 IoC 容器。
- en: 'Assuming the container supports it, it is super simple to swap. The third-party
    container must implement the `IServiceProviderFactory<TContainerBuilder>` interface.
    Then, in the `Program.cs` file, we must register that factory using the `UseServiceProviderFactory<TContainerBuilder>`
    method like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设容器支持它，替换它非常简单。第三方容器必须实现`IServiceProviderFactory<TContainerBuilder>`接口。然后，在`Program.cs`文件中，我们必须使用`UseServiceProviderFactory<TContainerBuilder>`方法注册该工厂，如下所示：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this case, the `ContainerBuilder` and `ContainerBuilderFactory` classes
    are just wrappers around ASP.NET Core, but your third-party container of choice
    should provide you with those types. I suggest you visit their documentation to
    know more.Once that factory is registered, we can configure the container using
    the `ConfigureContainer<TContainerBuilder>` method and register our dependencies
    as usual, like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`ContainerBuilder` 和 `ContainerBuilderFactory` 类只是 ASP.NET Core 的包装器，但您选择的第三方容器应该提供这些类型。我建议您访问他们的文档以了解更多信息。一旦该工厂注册成功，我们就可以使用
    `ConfigureContainer<TContainerBuilder>` 方法来配置容器，并像通常一样注册我们的依赖项，如下所示：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'That’s the only difference; the rest of the `Program.cs` file remains the same.As
    I sense you don’t feel like implementing your own IoC container, multiple third-party
    integrations already exist. Here is a non-exhaustive list taken from the official
    documentation:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是唯一的区别；`Program.cs` 文件的其他部分保持不变。正如我感觉到您可能不想实现自己的 IoC 容器，已经存在多个第三方集成。以下是从官方文档中摘取的非详尽列表：
- en: Autofac
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Autofac
- en: DryIoc
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DryIoc
- en: Grace
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优雅
- en: LightInject
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LightInject
- en: Lamar
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lamar
- en: Stashbox
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stashbox
- en: Simple Injector
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单注入器
- en: On top of replacing the container entirely, some libraries extend the default
    container and add functionalities to it. We explore this option in *Chapter 11*,
    *Structural Patterns*.Now that we have covered most of the theory, we revisit
    the Strategy pattern as the primary tool to compose our applications and add flexibility
    to our systems.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了完全替换容器之外，一些库还扩展了默认容器并添加了功能。我们在第 11 章，*结构型模式*中探讨了这一选项。现在我们已经涵盖了大部分理论，我们重新审视策略模式，将其作为组合应用程序和增加系统灵活性的主要工具。
- en: Revisiting the Strategy pattern
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视策略模式
- en: 'In this section, we leverage the Strategy pattern to compose complex object
    trees and use DI to dynamically create those instances without using the `new`
    keyword, moving away from being control freaks and toward writing DI-ready code.The
    Strategy pattern is a behavioral design pattern we can use to compose object trees
    at runtime, allowing extra flexibility and control over objects’ behavior. Composing
    our objects using the Strategy pattern makes our classes smaller, easier to test
    and maintain, and puts us on the SOLID path.From now on, we want to compose objects
    and lower the amount of inheritance to a minimum. We call that principle **composition
    over inheritance**. The goal is to inject dependencies (composition) into the
    current class instead of depending on base class features (inheritance). Additionally,
    this approach enables us to pull out behaviors and place them in separate classes,
    adhering to the Single Responsibility Principle (SRP) and Interface Segregation
    Principle (ISP). We can reuse these behaviors in one or more different classes
    through their interface, embodying the Dependency Inversion Principle (DIP). This
    strategy promotes code reuse and composition.The following list covers the most
    popular ways of injecting dependencies into objects, allowing us to control their
    behaviors from the outside by composing our objects:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们利用策略模式来组合复杂对象树，并使用 DI 动态创建这些实例，而不使用 `new` 关键字，从而摆脱控制狂，转向编写 DI 准备好的代码。策略模式是一种行为设计模式，我们可以在运行时使用它来组合对象树，允许额外的灵活性和对对象行为的控制。使用策略模式组合我们的对象使我们的类更小，更容易测试和维护，并使我们走上
    SOLID 路径。从现在开始，我们想要组合对象并将继承量降到最低。我们称之为**组合优于继承**的原则。目标是向当前类注入依赖（组合）而不是依赖于基类功能（继承）。此外，这种方法使我们能够将行为提取出来并放置在单独的类中，遵循单一职责原则（SRP）和接口隔离原则（ISP）。我们可以通过它们的接口在多个不同的类中重用这些行为，体现依赖倒置原则（DIP）。这种策略促进了代码重用和组合。以下列表涵盖了将依赖注入对象的最流行方式，使我们能够通过组合我们的对象从外部控制它们的行为：
- en: Constructor injection
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: Property injection
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性注入
- en: Method injection
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法注入
- en: We can also get dependencies directly from the container. This is known as the
    Service Locator (anti-)pattern. We explore the Service Locator pattern later in
    this chapter.
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们还可以直接从容器中获取依赖项。这被称为服务定位器（反）模式。我们将在本章后面探讨服务定位器模式。
- en: Let’s look at some theory and then jump into the code to see DI in action.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些理论，然后跳入代码，看看依赖注入（DI）的实际应用。
- en: Constructor injection
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: '**Constructor injection** consists of injecting dependencies into the constructor
    as parameters. This is the most popular and preferred technique by far. Constructor
    injection is useful for injecting required dependencies; you can add null checks
    to ensure that, also known as the guard clause (see the *Adding a guard clause*
    section).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**构造函数注入**是指将依赖项作为参数注入构造函数中。这是迄今为止最受欢迎和首选的技术。构造函数注入对于注入必需依赖项很有用；你可以添加空值检查以确保这一点，也称为保护子句（见*添加保护子句*部分）。'
- en: Property injection
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性注入
- en: 'The built-in IoC container does not support **property injection** out of the
    box. The concept is to inject **optional dependencies** into properties. Most
    of the time, you want to avoid doing this because property injection leads to
    optional dependencies, leading to nullable properties, more null checks, and often
    avoidable code complexity. So when we think about it, it is good that ASP.NET
    Core left this one out of the built-in container.You can usually remove the property
    injection requirements by reworking your design, leading to a better design. If
    you cannot avoid using property injection, use a third-party container or find
    a way to build the dependency tree yourself (maybe leveraging one of the Factory
    patterns).Nevertheless, from a high-level view, the container would do something
    like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的IoC容器默认不支持**属性注入**。其概念是将**可选依赖项**注入到属性中。大多数情况下，你希望避免这样做，因为属性注入会导致可选依赖项，进而导致可空属性、更多的空值检查，以及通常可以避免的代码复杂性。所以当我们考虑这一点时，ASP.NET
    Core没有将其包含在内置容器中是件好事。通常，你可以通过重新设计你的设计来移除属性注入的要求，从而得到更好的设计。如果你无法避免使用属性注入，可以使用第三方容器或找到一种方法自己构建依赖项树（可能利用其中一个工厂模式）。然而，从高层次的角度来看，容器会做类似这样的事情：
- en: Create a new instance of the class and inject all required dependencies into
    the constructor.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建类的新的实例并将所有必需的依赖项注入到构造函数中。
- en: Find extension points by scanning properties (this could be attributes, contextual
    bindings, or something else).
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过扫描属性（这可能包括属性、上下文绑定或其他内容）来查找扩展点。
- en: For each extension point, inject (set) a dependency, leaving unconfigured properties
    untouched, hence its definition of an optional dependency.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个扩展点，注入（设置）一个依赖项，保持未配置的属性不变，因此其定义是一个可选依赖项。
- en: 'There are a couple of exceptions to the previous statement regarding the lack
    of support:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前关于不支持的说法，有几个例外：
- en: Razor components (Blazor) support property injection using the `[Inject]` attribute.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Razor组件（Blazor）支持使用 `[Inject]` 属性进行属性注入。
- en: Razor contains the `@inject` directive, which generates a property to hold a
    dependency (ASP.NET Core manages to inject it).
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Razor包含 `@inject` 指令，该指令生成一个用于持有依赖项的属性（ASP.NET Core能够注入它）。
- en: We can’t call that property injection per se because they are not optional but
    required, and the `@inject` directive is more about generating code than doing
    DI. They are more about an internal workaround than “real” property injection.
    That is as close as .NET gets from property injection.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能直接称之为属性注入，因为它们不是可选的，而是必需的，`@inject` 指令更多的是关于生成代码而不是进行依赖注入。它们更多的是关于内部解决方案而不是“真正的”属性注入。这就是.NET在属性注入方面所能达到的极限。
- en: I recommend aiming for constructor injection instead. Not having property injection
    should not cause you any problems. Often, our need for property injection stems
    from less-than-optimal design choices, whether from our design strategies or a
    framework we're utilizing.
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '我建议以构造函数注入为目标。没有属性注入不应该给你带来任何问题。通常，我们对属性注入的需求源于设计策略或我们正在使用的框架中不太理想的设计选择。 '
- en: Next, we look at method injection.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看方法注入。
- en: Method injection
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法注入
- en: ASP.NET Core supports method injection only at a few locations, such as in a
    controller’s actions (methods), the `Startup` class (if you are using the pre-.NET
    6 hosting model), and the middleware’s `Invoke` or `InvokeAsync` methods. We cannot
    liberally use method injection in our classes without some work on our part.Method
    injection is also used to inject **optional dependencies** into classes. We can
    also validate those at runtime using null checks or any other required logic.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core仅在少数位置支持方法注入，例如在控制器操作（方法）、`Startup` 类（如果你使用的是预-.NET 6托管模型）以及中间件的
    `Invoke` 或 `InvokeAsync` 方法中。我们无法在不进行一些工作的情况下自由地在我们的类中使用方法注入。方法注入也用于将**可选依赖项**注入到类中。我们还可以使用空值检查或其他任何必需的逻辑在运行时验证这些依赖项。
- en: '**I recommend aiming for constructor injection whenever you can**. We should
    only resort to method injection when it''s our sole option or when it brings added
    value to our design.'
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**我建议尽可能使用构造函数注入**。我们应该只在没有其他选择或它能为我们的设计带来额外价值时才求助于方法注入。'
- en: ''
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, in a controller, injecting a transient service in the only action
    that needs it instead of using constructor injection could save a lot of useless
    object instantiation and, by doing so, increase performance (less instantiation
    and less garbage collection). This can also lower the number of class-level dependencies
    a single class has.
  id: totrans-162
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，在一个控制器中，在只有一个操作需要它的情况下注入一个瞬态服务，而不是使用构造函数注入，可以节省大量的无用对象实例化，并通过这样做提高性能（更少的实例化和更少的垃圾回收）。这也可以减少单个类拥有的类级别依赖项的数量。
- en: 'Manually injecting a dependency in a method as an argument is valid. Here’s
    an example, starting with the classes:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将依赖手动注入方法作为参数是有效的。以下是一个例子，从类开始：
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code represents the `Subject` class that consumes an instance
    of the `Context` from its `Operation` method. It then returns the value of its
    `Number` property.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码表示的是 `Subject` 类，它从其 `Operation` 方法中获取 `Context` 实例。然后返回其 `Number` 属性的值。
- en: This example follows a similar pattern to injecting an `HttpContext` into an
    endpoint delegate. In that case, the `HttpContext` represents the current HTTP
    request. In our case, the `Context` contains only an arbitrary number we use in
    the consuming code next.
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个例子遵循了将 `HttpContext` 注入到端点委托的类似模式。在那个例子中，`HttpContext` 代表当前的 HTTP 请求。在我们的情况下，`Context`
    只包含我们在消费代码中使用的任意数字。
- en: 'To test that our code does as it should, we can write the following test:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的代码是否按预期工作，我们可以编写以下测试：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we run the test, it works. We successfully injected the `context` into
    the `subject`. Now to simulate a more complex system, let’s have a look at a theory
    that does the same more dynamically:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试时，它工作正常。我们成功地将 `context` 注入到 `subject` 中。现在为了模拟一个更复杂的系统，让我们看看一个更动态地执行相同操作的原理：
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code showcases the same concept, but xUnit injects the dependencies
    into the method, which is closer to what would happen in a real program. Remember,
    we want to remove the `new` keywords from our life!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了相同的概念，但 xUnit 将依赖注入到方法中，这更接近实际程序中可能发生的情况。记住，我们想要从我们的生活中移除 `new` 关键字！
- en: The rest of the implementation is not important. I only pieced the simulation
    together to showcase this scenario. One interesting detail is that the `Subject`
    is always the same (singleton) while the `Context` is always different (transient),
    leading to a different outcome every time (`Context { Number = 0 }`, `Context
    { Number = 1 }`, and `Context { Number = 2 }`).
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现的其余部分并不重要。我仅仅拼凑了这个模拟来展示这个场景。一个有趣的细节是，`Subject` 总是相同的（单例），而 `Context` 总是不同的（瞬态），导致每次的结果都不同（`Context
    { Number = 0 }`，`Context { Number = 1 }`，和 `Context { Number = 2 }`）。
- en: Having explored how to inject dependencies, we are ready to roll up our sleeves
    and dive into hands-on coding.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了如何注入依赖之后，我们准备好动手进行实际编码。
- en: Project – Strategy
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 策略
- en: 'In the Strategy project, we delve into various methods of injecting dependencies,
    transitioning from the Control Freak approach to a SOLID one. Through this exploration,
    we evaluate the advantages and drawbacks of each technique.The project takes the
    form of a travel agency''s location API, initially returning only hardcoded cities.
    We''ve implemented the same endpoint five times across different controllers to
    facilitate comparison and trace the progression. Each controller comes in pair
    except for one. The pairs comprise a base controller that uses an in-memory service
    (dev) and an updated controller that simulates a SQL database (production). Here’s
    the breakdown of each controller:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在策略项目中，我们深入研究了各种注入依赖的方法，从控制狂热方法过渡到 SOLID 方法。通过这次探索，我们评估了每种技术的优缺点。该项目以旅行社的位置
    API 为形式，最初只返回硬编码的城市。我们在不同的控制器中实现了相同的端点五次，以方便比较和追踪进展。除了一个之外，每个控制器都是成对的。这些对包括一个使用内存服务（开发）的基控制器和一个模拟
    SQL 数据库（生产）的更新控制器。以下是每个控制器的分解：
- en: The `ControlFreakLocationsController` instantiates the `InMemoryLocationService`
    class using the `new` keyword.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ControlFreakLocationsController` 使用 `new` 关键字实例化了 `InMemoryLocationService`
    类。'
- en: The `ControlFreakUpdatedLocationsController` instantiates the `SqlLocationService`
    class and its dependency using the `new` keyword.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ControlFreakUpdatedLocationsController`使用`new`关键字实例化`SqlLocationService`类及其依赖项。'
- en: The `InjectImplementationLocationsController` leverages constructor injection
    to get an instance of the `InMemoryLocationService` class from the container.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InjectImplementationLocationsController`利用构造函数注入从容器中获取`InMemoryLocationService`类的实例。'
- en: The `InjectImplementationUpdatedLocationsController` leverages constructor injection
    to get an instance of the `SqlLocationService` class from the container.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InjectImplementationUpdatedLocationsController`利用构造函数注入从容器中获取`SqlLocationService`类的实例。'
- en: The `InjectAbstractionLocationsController` leverages dependency injection and
    interfaces to let its consumers change its behavior at runtime.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InjectAbstractionLocationsController`利用依赖注入和接口让消费者在运行时改变其行为。'
- en: The controllers share the same building blocks; let’s start there.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器共享相同的构建块；让我们从这里开始。
- en: Shared building blocks
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共享构建块
- en: 'The `Location` data structure is the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Location`数据结构如下所示：'
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `LocationSummary` DTO returned by the controller is the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器返回的`LocationSummary` DTO如下所示：
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The service interface is the following and has only one method that returns
    one or more `Location` objects:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 服务接口如下，并且只有一个返回一个或多个`Location`对象的方法：
- en: '[PRE16]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The two implementations of this interface are an in-memory version to use when
    developing and a SQL version to use when deploying (let’s call this production
    to keep it simple).The in-memory service returns a predefined list of cities:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口的两个实现是一个内存版本，用于开发时使用，以及一个SQL版本，用于部署（为了简单起见，我们将其称为生产）。内存服务返回一个预定义的城市列表：
- en: '[PRE17]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The SQL implementation uses an `IDatabase` interface to access the data:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: SQL实现使用`IDatabase`接口来访问数据：
- en: '[PRE18]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'That database access interface is simply the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 那个数据库访问接口如下所示：
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the project itself, the `IDatabase` interface has only the `NotImplementedDatabase`
    implementation, which throws a `NotImplementedException` when its `ReadManyAsync`
    method is called:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目本身中，`IDatabase`接口只有`NotImplementedDatabase`实现，当其`ReadManyAsync`方法被调用时抛出`NotImplementedException`：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since the goal is not learning database access, I mocked that part in a test
    case in a xUnit test using the controller and the `SqlLocationService` class.
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于目标不是学习数据库访问，我在xUnit测试中使用控制器和`SqlLocationService`类模拟了这部分。
- en: With those shared pieces, we can start with the first two controllers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些共享的部分，我们可以从前两个控制器开始。
- en: Control Freak controllers
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制狂控制器
- en: 'This first version of the code showcases the lack of flexibility that creating
    dependencies using the `new` keyword brings when the time to update the application
    arises. Here’s the initial controller that leverages an in-memory collection:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一个版本的代码展示了当需要更新应用程序时，使用`new`关键字创建依赖项所带来的缺乏灵活性。以下是利用内存集合的初始控制器：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Executing this code works and returns the `LocationSummary` equivalent of the
    `Location` objects returned by the `FetchAllAsync` method of the `InMemoryLocationService`
    class. However, changing the `InMemoryLocationService` to a `SqlLocationService`
    is impossible without changing the code like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码有效，并返回`InMemoryLocationService`类的`FetchAllAsync`方法返回的`Location`对象的`LocationSummary`等效对象。然而，要将`InMemoryLocationService`更改为`SqlLocationService`，必须像这样更改代码：
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The changes are highlighted in the two code blocks. We could also create an
    if statement to load one or the other conditionally, but exporting this to a whole
    system makes a lot of duplication.**Advantages:**
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 两个代码块中的更改被突出显示。我们也可以创建一个if语句有条件地加载一个或另一个，但将此扩展到整个系统会导致大量重复。**优点：**
- en: It is easy to understand the code and what objects the controller uses.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解代码及其使用的对象很容易。
- en: '**Disadvantages:**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点：**'
- en: The controller is tightly coupled with its dependencies, leading to a lack of
    flexibility.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器与其依赖项紧密耦合，导致缺乏灵活性。
- en: Going from `InMemoryLocationService` to `SqlLocationService` requires updating
    the code.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`InMemoryLocationService`到`SqlLocationService`的转换需要更新代码。
- en: Let’s improve on that design next with the next controller pair.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过下一个控制器对来改进这个设计。
- en: Injecting an implementation in the controllers
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在控制器中注入实现
- en: 'This second version of the codebase improves flexibility by leveraging dependency
    injection. In the following controller, we inject the `InMemoryLocationService`
    class in its constructor:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Assuming the **InMemoryLocationService** class is registered with the container,
    running this code would yield the same result as the Control Freak version and
    return the in-memory cities.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'To register a class with the container, we can do the following:'
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Unfortunately, to change that service for the `SqlLocationService`, we need
    to change the code again. This time, however, we must only change the constructor
    injection code like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is yet another not ideal outcome.**Advantages:**
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to understand the code and what objects the controller uses.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using constructor injection allows changing the dependency in one place, and
    all the methods get it (assuming we have more than one method).
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can inject subclasses without changing the code.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages:**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The controller is tightly coupled with its dependencies, leading to a lack of
    flexibility.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going from `InMemoryLocationService` to `SqlLocationService` requires updating
    the code.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are getting there but still have a last step to make that controller flexible.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Injecting an abstraction in the controller
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this last controller, we leverage the SOLID principles, constructor injection,
    and, inherently, the Strategy pattern to build a controller that we can change
    from the outside. All we have to do to make the code flexible is inject the interface
    instead of its implementation, like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The highlighted lines showcase the changes. Injecting the `ILocationService`
    interface lets us control if we inject an instance of the `InMemoryLocationService`
    class, the `SqlLocationService` class, or any other implementation we’d like.This
    is the most flexible possibility we can get.**Advantages:**
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Using constructor injection allows changing the dependency in one place, and
    all the methods get it (assuming we have more than one method).
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting the `ILocationService` interface allows us to inject any of its implementations
    without changing the code.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the `ILocationService` interface, the controller is loosely coupled
    with its dependencies.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages:**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what objects the controller uses is harder since the dependencies
    are resolved at runtime. However, this forces us to program against an interface
    instead (a good thing).
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s have a look at this flexibility in action.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the InjectAbstractionLocationsController
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I created a few xUnit tests to explore the possibilities, making it easy to
    create classes manually.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: I used Moq to mock implementations. If you are unfamiliar with Moq and want
    to learn more, I left a link in the *Further Reading* section.
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Two of the tests refers to the following member, a static `Location` object:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The test cases are not to assess the correctness of our code but to explore
    how easy it is to compose the controller differently. Let’s explore the first
    test case.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例不是为了评估我们代码的正确性，而是为了探索以不同的方式组合控制器有多容易。让我们探索第一个测试用例。
- en: Mock_the_IDatabase
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Mock_the_IDatabase
- en: 'The first is an integration test that injects an instance of the `SqlLocationService`
    class into the controller and mocks the database. The fake database returns a
    collection of one item. That item is the `Location` instance referenced by the
    `ExpectedLocation` property. Here’s that code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是集成测试，它将`SqlLocationService`类的实例注入到控制器中并模拟数据库。模拟数据库返回一个包含一个项目的集合。该项目是`ExpectedLocation`属性引用的`Location`实例。以下是那段代码：
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding code shows how we can control the dependency we inject into the
    classes because of how the `InjectAbstractionLocationsController` was designed.
    We can’t say the same about the four other controller versions.Next, we call the
    GetAsync method to verify that everything works as expected:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码展示了我们如何通过`InjectAbstractionLocationsController`的设计来控制注入到类中的依赖项。对于其他四个控制器版本，我们无法说同样的话。接下来，我们调用`GetAsync`方法来验证一切是否按预期工作：
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, let’s verify we received that collection of one object:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们验证我们是否收到了那个包含一个对象的集合：
- en: '[PRE30]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Optionally, or instead, we could validate the service called the database mock,
    like this:'
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可选的，或者相反，我们可以验证调用数据库模拟的服务，如下所示：
- en: '[PRE31]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There are a lot of useful features in the Moq library.
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Moq库中有很多有用的功能。
- en: 'Validating that the code was correct is not important for this example. The
    key is to understand the composition of the controller, which the following diagram
    represents:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 验证代码的正确性对于本例来说并不重要。关键是要理解控制器的组成，以下图表展示了这一点：
- en: '![Figure 8.1: Composition of the controller in a test that mocks the IDatabase
    interface](img/file40.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：模拟IDatabase接口的测试中控制器的组成](img/file40.png)'
- en: 'Figure 8.1: Composition of the controller in a test that mocks the IDatabase
    interface'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：模拟IDatabase接口的测试中控制器的组成
- en: As we can see from the diagram, the classes depend on interfaces, and we inject
    implementations when building them. The next two tests are simpler than this,
    only depending on the `ILocationService`. Let’s explore the second one.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从图中可以看出，类依赖于接口，我们在构建它们时注入实现。接下来的两个测试比这个简单，只依赖于`ILocationService`。让我们探索第二个。
- en: Use_the_InMemoryLocationService
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Use_the_InMemoryLocationService
- en: 'Next, we use the in-memory location service to compose the controller like
    this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用内存中的位置服务以这种方式组合控制器：
- en: '[PRE32]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As we can see from the preceding code, we injected a different service into
    the controller, changing its behavior. This time, after calling the `GetAsync`
    method, the controller returned the ten `Location` objects from the `InMemoryLocationService`.The
    visual representation of our object tree is as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从前面的代码中可以看出，我们向控制器注入了不同的服务，改变了其行为。这次，在调用`GetAsync`方法后，控制器从`InMemoryLocationService`返回了十个`Location`对象。我们对象树的视觉表示如下：
- en: '![Figure 8.2: Composition of the controller in a test that injects an InMemoryLocationService
    instance.](img/file41.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：注入InMemoryLocationService实例的测试中控制器的组成](img/file41.png)'
- en: 'Figure 8.2: Composition of the controller in a test that injects an InMemoryLocationService
    instance.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：注入InMemoryLocationService实例的测试中控制器的组成。
- en: It is harder to write assertions for the preceding test because we inject an
    instance of the `InMemoryLocationService` class, which ties the result to its
    implementation. For this reason, we won’t look at that code here. Nonetheless,
    we succeeded at composing the controller differently. Let’s have a look at the
    last test case.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的测试用例，编写断言更困难，因为我们注入了`InMemoryLocationService`类的实例，这将结果与其实现绑定。因此，我们在这里不会查看那段代码。尽管如此，我们成功地以不同的方式组合了控制器。让我们看看最后一个测试用例。
- en: Mock_the_ILocationService
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Mock_the_ILocationService
- en: 'The last unit test mocks the ILocationService directly. The mock service returns
    a collection of one item. That item is the `Location` instance referenced by the
    `ExpectedLocation` property. Here’s that code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个单元测试直接模拟`ILocationService`。模拟服务返回一个包含一个项目的集合。该项目是`ExpectedLocation`属性引用的`Location`实例。以下是那段代码：
- en: '[PRE33]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When executing the `GetAsync` method, we get the same result as in the first
    test case: a collection of a single test `Location` object. We can assert the
    correctness of the method by comparing values like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`GetAsync`方法时，我们得到与第一个测试用例相同的结果：一个包含单个测试`Location`对象的集合。我们可以通过比较以下值来断言方法的正确性：
- en: '[PRE34]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can also leverage Moq to verify that the controller called the `FetchAllAsync`
    method using the following code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以利用Moq来验证控制器是否使用了以下代码调用了`FetchAllAsync`方法：
- en: '[PRE35]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The object tree of is very similar to the previous diagram but we faked the
    service implementation, making this a real unit test:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象树与之前的图非常相似，但我们伪造了服务实现，这使得这是一个真正的单元测试：
- en: '![Figure 8.3: Composition of the controller in a test that mocks the ILocationService
    interface.](img/file42.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3：模拟ILocationService接口的测试中控制器的组合](img/file42.png)'
- en: 'Figure 8.3: Composition of the controller in a test that mocks the ILocationService
    interface.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：模拟ILocationService接口的测试中控制器的组合
- en: As we explored in this project, with the right design and dependency injection,
    we can easily compose different object trees using the same building blocks. However,
    with a bad design, it is hard to impossible to do so without altering the code.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本项目中探讨的那样，通过正确的设计和依赖注入，我们可以轻松地使用相同的构建块组合不同的对象树。然而，如果设计不当，则很难甚至不可能在不更改代码的情况下做到这一点。
- en: As you may have noticed, we used the `new` keyword in the controller to instantiate
    the DTO. DTOs are stable dependencies. We also explore object mappers in *Chapter
    15*, *Object mappers, Aggregate Services, and Façade*, which is a way to encapsulate
    the logic of copying an object into another.
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如您可能已注意到的，我们在控制器中使用了`new`关键字来实例化DTO。DTOs是稳定的依赖项。我们还在*第15章*，*对象映射器、聚合服务和外观*中探讨了对象映射器，这是将一个对象复制到另一个对象中的逻辑封装起来的方法。
- en: Let’s conclude before our next subject.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们下一个主题之前，让我们先总结一下。
- en: Conclusion
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'In this section, we saw that the strategy pattern went from a simple behavioral
    GoF pattern to the cornerstone of dependency injection. We explored different
    ways of injecting dependencies with a strong focus on constructor injection.Constructor
    injection is the most commonly used approach as it injects required dependencies,
    which we want the most. Method injection allows injecting algorithms, shared states,
    or contexts in a method that could not otherwise access that information. We can
    use property injection to inject optional dependencies, which should rarely happen.You
    can see optional dependencies as code smells because if the class has an optional
    role to play, it also has a primary role resulting in dual responsibilities. Moreover,
    if a role is optional, it could be better to move it to another class or rethink
    the system''s design in that specific area.To practice what you just learned,
    you could connect the code sample to a real database, an Azure Table, Redis, a
    JSON file, or any other data source—tip: code classes that implement the `ILocationService`
    interface.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到策略模式从简单的GoF行为模式转变为依赖注入的基石。我们探讨了注入依赖的不同方法，重点放在构造函数注入上。构造函数注入是最常用的方法，因为它注入了所需的依赖项，这是我们最想要的。方法注入允许在无法访问该信息的方法中注入算法、共享状态或上下文。我们可以使用属性注入来注入可选依赖项，这种情况很少发生。您可以将可选依赖项视为代码异味，因为如果类有一个可选的角色要扮演，它也有一个主要角色，从而导致双重职责。此外，如果角色是可选的，将其移动到另一个类或重新思考该特定区域的系统设计可能更好。为了练习您刚刚学到的内容，您可以将代码示例连接到真实的数据库、Azure
    Table、Redis、JSON文件或其他数据源——提示：编写实现`ILocationService`接口的代码类。
- en: As we covered, we can inject classes into other classes directly. There is nothing
    wrong with that. However, I suggest injecting interfaces as your initial approach
    until you are confident that you have mastered the different architectural principles
    and patterns covered in this book.
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，我们可以直接将类注入到其他类中。这样做没有问题。然而，我建议在您对本书中涵盖的不同架构原则和模式有信心之前，将接口作为您的初始注入方法。
- en: Next, we explore guard clauses.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨守卫子句。
- en: Understanding guard clauses
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解守卫子句
- en: 'A guard clause represents a condition the code must meet before executing a
    method. Essentially, it''s a type of code that "guards" against continuing the
    execution of the method if certain conditions aren''t met.In most cases, guard
    clauses are implemented at the beginning of a method to throw an exception early
    when the conditions necessary for the method''s execution are not satisfied. Throwing
    an exception allows callers to catch the error without the need to implement a
    more complex communication mechanism.We already stated that we use constructor
    injection to inject the required dependencies reliably. However, nothing fully
    guarantees us that the dependencies are not `null`. Ensuring a dependency is not
    `null` is one of the most common guard clauses, which is trivial to implement.
    For example, we could check for nulls in the controller by replacing the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 保护子句表示代码在执行方法之前必须满足的条件。本质上，它是一种“保护”代码，如果某些条件不满足，则阻止方法的继续执行。在大多数情况下，保护子句是在方法的开头实现的，以便在方法执行所需条件不满足时尽早抛出异常。抛出异常允许调用者捕获错误，而无需实现更复杂的通信机制。我们之前已经提到，我们使用构造函数注入来可靠地注入所需的依赖项。然而，没有任何东西可以完全保证依赖项不是
    `null`。确保依赖项不是 `null` 是最常见的保护子句之一，实现起来非常简单。例如，我们可以在控制器中检查 `null`，通过替换以下代码：
- en: '[PRE36]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为以下代码：
- en: '[PRE37]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding code uses a `throw` expression from C# 7 (See *Appendix A* for
    more information). The `ArgumentNullException` type makes it evident that the
    `locationService` parameter is `null`. So if the `locationService` parameter is
    `null`, an `ArgumentNullException` is thrown; otherwise, the `locationService`
    parameter is assigned to the `_locationService` member.Of course, with the introduction
    of the nullable reference types (see *Appendix A*), receiving a `null` argument
    is less likely yet still possible.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码使用了 C# 7 的 `throw` 表达式（更多信息请见 *附录 A*）。`ArgumentNullException` 类型使得 `locationService`
    参数为 `null` 的情形变得明显。因此，如果 `locationService` 参数为 `null`，则会抛出 `ArgumentNullException`；否则，`locationService`
    参数会被分配给 `_locationService` 成员。当然，随着可空引用类型的引入（更多信息请见 *附录 A*），接收 `null` 参数的可能性降低了，但仍有可能发生。
- en: A built-in container will automatically throw an exception if it can’t fulfill
    all dependencies during the instantiation of a class (such as a controller). That
    does not mean that all third-party containers act the same.
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 内置容器在类（如控制器）实例化过程中无法满足所有依赖项时，会自动抛出异常。但这并不意味着所有第三方容器的行为都相同。
- en: ''
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Moreover, that does not protect you from passing `null` to a class you manually
    instantiates, nor that a method will not receive a `null` value. I recommend adding
    guards even since they are less mandatory now. The tooling can handle most of
    the work for us, leading to only a minor time overhead.
  id: totrans-288
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，这并不能保护你免受将 `null` 传递给手动实例化的类的侵害，也不能保证方法不会接收到 `null` 值。我建议即使现在不那么强制，也要添加保护措施。工具可以为我们处理大部分工作，从而只产生微小的开销。
- en: ''
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Furthermore, suppose you are writing code consumed by other projects, like a
    library. In that case, adding guards is more important since nothing guarantees
    that the consumers of that code have nullable reference type checks enabled.
  id: totrans-290
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，如果你正在编写其他项目使用的代码，例如库，那么添加保护措施就更加重要了，因为没有保证代码的消费者已经启用了可空引用类型检查。
- en: 'When we need to validate a parameter and don''t need an assignment, like with
    most parameters of a constructor, we can use the following helper, and the BCL
    handles the check for us:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要验证一个参数而不需要赋值时，例如大多数构造函数的参数，我们可以使用以下辅助工具，BCL 会为我们处理检查：
- en: '[PRE38]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When we need to validate a string and want to ensure it is not empty, we can
    use the following instead:ArgumentException.ThrowIfNullOrEmpty(name);Of course,
    we can always revert to `if` statements to validate parameters. When doing so,
    we must ensure we throw relevant exceptions. If no pertinent exceptions exist,
    we can create one. Creating custom exceptions is a great way to write manageable
    applications.Next, we revisit an (anti-)pattern while exploring the singleton
    lifetime replacing it.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要验证一个字符串并确保它不为空时，我们可以使用以下替代方法：ArgumentException.ThrowIfNullOrEmpty(name);当然，我们总是可以回退到
    `if` 语句来验证参数。在这样做的时候，我们必须确保我们抛出相关的异常。如果没有相关的异常，我们可以创建一个。创建自定义异常是编写可管理应用程序的好方法。接下来，我们在探索单例生命周期时回顾（反）模式。
- en: Revisiting the Singleton pattern
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾 Singleton 模式
- en: 'The Singleton pattern is obsolete, goes against the SOLID principles, and we
    replace it with a lifetime, as we’ve already seen. This section explores that
    lifetime and recreates the good old application state, which is nothing more than
    a singleton-scoped dictionary.We explore two examples: one about the application
    state, in case you were wondering where that feature disappeared to. Then, the
    Wishlist project also uses the singleton lifetime to provide an application-level
    feature. There are also a few unit tests to play with testability and to allow
    safe refactoring.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式已经过时，违反了SOLID原则，我们已经用生命周期来替代它，正如我们之前所看到的。本节将探讨这个生命周期，并重新创建那个古老的应用状态，它不过是一个单例作用域的字典。我们探讨了两个例子：一个关于应用状态，以防你好奇那个功能去哪里了。然后，Wishlist项目也使用单例生命周期来提供应用级别的功能。还有一些单元测试，用于测试可测试性和允许安全重构。
- en: Project – Application state
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 应用状态
- en: You might remember the application state if you programmed ASP.NET using .NET
    Framework or the “good” old classic ASP with VBScript. If you don’t, the application
    state was a key/value dictionary that allowed you to store data globally in your
    application, shared between all sessions and requests. That is one of the things
    that ASP always had and other languages, such as PHP, did not (or do not easily
    allow).For example, I remember designing a generic reusable typed shopping cart
    system with classic ASP/VBScript. VBScript was not a strongly typed language and
    had limited object-oriented capabilities. The shopping cart fields and types were
    defined at the application level (once per application), and then each user had
    their own “instance” containing the products in their “private shopping cart”
    (created once per session).In ASP.NET Core, there is no more `Application` dictionary.
    To achieve the same goal, you could use a static class or static members, which
    is not the best approach; remember that global objects (`static`) make your application
    harder to test and less flexible. We could also use the Singleton pattern or create
    an ambient context, allowing us to create an application-level instance of an
    object. We could even mix that with a factory to create end-user shopping carts,
    but we won’t; these are not the best solution either. Another way could be to
    use one of the ASP.NET Core caching mechanisms, memory cache, or distributed cache,
    but this is a stretch.We could also save everything in a database to persist the
    shopping cart between visits, but that is not related to the application state
    and requires more work, potentially a user account, so we will not do that either.We
    could save the shopping cart on the client-side using cookies, local storage,
    or any other modern mechanism to save data on the user’s computer. However, we’d
    get even further from the application state than using a database.For most cases
    requiring an application state-like feature, the best approach would be to create
    a standard class and an interface and then register the binding with a singleton
    lifetime in the container. Finally, you inject it into the component that needs
    it, using constructor injection. Doing so allows the mocking of dependencies and
    changing the implementations without touching the code but the composition root.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用.NET Framework编程ASP.NET或者使用“好”旧的经典ASP与VBScript编程，你可能还记得应用状态。如果你不记得，应用状态是一个键/值字典，允许你在应用程序中全局存储数据，在所有会话和请求之间共享。这是ASP一直拥有的，而其他语言，如PHP，则没有（或者不容易允许）。例如，我记得设计了一个通用的可重用类型购物车系统，使用经典ASP/VBScript。VBScript不是一个强类型语言，并且具有有限的面向对象功能。购物车字段和类型在应用级别定义（每个应用一次），然后每个用户都有自己的“实例”，包含他们“私人购物车”中的产品（每个会话创建一次）。在ASP.NET
    Core中，不再有`Application`字典。为了达到相同的目标，你可以使用静态类或静态成员，但这不是最佳方法；记住，全局对象（`static`）会使你的应用程序更难测试且更不灵活。我们还可以使用单例模式或创建一个环境上下文，允许我们创建一个对象的应用级别实例。我们甚至可以将其与工厂混合来创建最终用户的购物车，但我们不会这么做；这些也不是最佳解决方案。另一种方法可能是使用ASP.NET
    Core的缓存机制之一，如内存缓存或分布式缓存，但这有些牵强。我们还可以将购物车保存在客户端，使用cookies、本地存储或其他任何现代机制在用户的计算机上保存数据。然而，这将比使用数据库更远离应用状态。对于大多数需要类似应用状态功能的情况，最佳方法可能是创建一个标准类和一个接口，然后在容器中将绑定注册为单例生命周期。最后，通过构造函数注入将其注入到需要它的组件中。这样做允许模拟依赖关系，在不接触代码但接触组合根的情况下更改实现。
- en: Sometimes, the best solution is not the technically complex ones or design pattern-oriented;
    the best solution is often the simplest. Less code means less maintenance and
    fewer tests, resulting in a simpler application.
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时候，最好的解决方案不是技术复杂的解决方案或面向设计模式的解决方案；最好的解决方案通常是简单的。更少的代码意味着更少的维护和更少的测试，从而产生更简单的应用程序。
- en: 'Let’s implement a small program that simulates the application state. The API
    is a single interface with two implementations. The program also exposes part
    of the API over HTTP, allowing users to get or set a value associated with the
    specified key. We use the singleton lifetime to ensure the data is shared between
    all requests.The interface looks like the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个小程序来模拟应用程序状态。API是一个具有两个实现的单一接口。程序还通过HTTP公开了API的一部分，允许用户获取或设置与指定键关联的值。我们使用单例生命周期来确保数据在所有请求之间共享。接口看起来如下：
- en: '[PRE39]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can get the value associated with a key, associate a value with a key (set),
    and validate whether a key exists.The `Program.cs` file contains the code responsible
    for handling HTTP requests. We can swap the implementations by commenting or uncommenting
    the first line of the `Program.cs` file, which is `#define USE_MEMORY_CACHE`.
    That changes the dependency registration, as highlighted in the following code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取与键关联的值，将值与键关联（设置），并验证键是否存在。《Program.cs》文件包含处理HTTP请求的代码。我们可以通过注释或取消注释`Program.cs`文件的第一行来交换实现，该行是`#define
    USE_MEMORY_CACHE`。这改变了依赖注册，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Let’s now explore the first implementation.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们探索第一种实现。
- en: First implementation
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第一种实现
- en: 'The first implementation uses the memory cache system, and I thought it would
    be educational to show that to you. Caching data in memory is something you might
    need to do sooner rather than later. However, we are hiding the cache system behind
    our implementation, which is also educational.Here is the `ApplicationMemoryCache`
    class:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种实现使用了内存缓存系统，我认为向您展示这一点是有教育意义的。在内存中缓存数据可能是您需要尽早而不是稍后去做的事情。然而，我们在实现中隐藏了缓存系统，这也是有教育意义的。下面是`ApplicationMemoryCache`类：
- en: '[PRE41]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Note**'
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `ApplicationMemoryCache` class is a thin wrapper over `IMemoryCache`, hiding
    the implementation details. Such a wrapper is similar to the Façade and Adapter
    patterns we explore in *Chapter 11*, *Structural Patterns*.
  id: totrans-309
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ApplicationMemoryCache`类是`IMemoryCache`的一个薄包装，隐藏了实现细节。这样的包装类似于我们在第11章中探讨的**外观模式**和**适配器模式**。'
- en: This simple class and two lines in our composition root make it an application-wide
    key-value store; done already! Let’s now explore the second implementation.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的类和我们的组合根中的两行代码使其成为一个应用级别的键值存储；已经完成了！现在让我们探索第二种实现。
- en: Second implementation
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第二种实现
- en: 'The second implementation uses `ConcurrentDictionary<string, object>` to store
    the application state data and ensure thread safety, as multiple users could use
    the application state simultaneously. The `ApplicationDictionary` class is almost
    as simple as `ApplicationMemoryCache`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种实现使用`ConcurrentDictionary<string, object>`来存储应用程序状态数据并确保线程安全，因为多个用户可能同时使用应用程序状态。`ApplicationDictionary`类几乎和`ApplicationMemoryCache`一样简单：
- en: '[PRE42]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding code leverages the `TryGetValue` and `AddOrUpdate` methods to
    ensure thread safety while keeping the logic to a minimum and ensuring we avoid
    coding mistakes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码利用`TryGetValue`和`AddOrUpdate`方法确保线程安全，同时将逻辑保持到最小，并确保我们避免编码错误。
- en: Can you spot the flaw that might cause some problems in this design? See the
    solution at the end of the project section.
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你能发现这个设计中可能引起一些问题的缺陷吗？请参见项目部分末尾的解决方案。
- en: Let’s explore how to use the implementations.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何使用这些实现。
- en: Using the implementations
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用实现
- en: 'We can now use any of the two implementations without impacting the rest of
    the program. That demonstrates the strength of DI when it comes to dependency
    management. Moreover, we control the lifetime of the dependencies from the composition
    root.If we were to use the `IApplicationState` interface in another class, say
    `SomeConsumer`, its usage could look similar to the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这两种实现中的任何一种，而不会影响程序的其余部分。这展示了DI在依赖管理方面的优势。此外，我们从组合根控制依赖项的生命周期。如果我们要在另一个类中使用`IApplicationState`接口，比如`SomeConsumer`，其使用可能类似于以下内容：
- en: '[PRE43]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In that code, `SomeConsumer` depends only on the `IApplicationState` interface,
    not `ApplicationDictionary` or `ApplicationMemoryCache`, and even less on `IMemoryCache`
    or `ConcurrentDictionary<string, object>`. Using DI allows us to hide the implementation
    by inverting the flow of dependencies. It also breaks direct coupling between
    concrete implementations. This approach also promotes programming against interfaces,
    as recommended by the Dependency Inversion Principle (DIP), and facilitates the
    creation of open-closed classes, in accordance with the Open/Closed Principle
    (OCP).Here is a diagram illustrating our application state system, making it visually
    easier to notice how it breaks coupling:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在那段代码中，`SomeConsumer` 只依赖于 `IApplicationState` 接口，而不是 `ApplicationDictionary`
    或 `ApplicationMemoryCache`，更不用说 `IMemoryCache` 或 `ConcurrentDictionary<string,
    object>`。使用DI允许我们通过反转依赖关系流来隐藏实现。它还打破了具体实现的直接耦合。这种方法还促进了按照依赖倒置原则（DIP）推荐的方式针对接口进行编程，并有助于创建符合开放/封闭原则（OCP）的开放/封闭类。以下是说明我们的应用状态系统的图，使它更直观地显示如何打破耦合：
- en: '![Figure 8.2: DI-oriented diagram representing the application state system](img/file43.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：表示应用状态系统的DI导向图](img/file43.png)'
- en: 'Figure 8.2: DI-oriented diagram representing the application state system'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：表示应用状态系统的DI导向图
- en: From this sample, let’s remember that the singleton lifetime allows us to reuse
    objects between requests and share them application-wide. Moreover, hiding implementation
    details behind interfaces can improve the flexibility of our design.It is important
    to note that the singleton scope is only valid in a single process, so you can’t
    rely purely on in-memory mechanisms for larger applications that span multiple
    servers. We could use the `IDistributedCache` interface to circumvent this limitation
    and persist our application state system to a persistent caching tool, like Redis.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个示例中，让我们记住单例生命周期允许我们在请求之间重用对象并在应用程序范围内共享它们。此外，在接口后面隐藏实现细节可以提高我们设计的灵活性。重要的是要注意，单例作用域仅在单个进程中有效，因此你不能完全依赖内存机制来支持跨多个服务器的更大应用程序。我们可以使用
    `IDistributedCache` 接口来规避这一限制，并将我们的应用状态系统持久化到持久化缓存工具，如Redis。
- en: '**The flaw**: If we look closely at the `Has<TItem>` method, it returns true
    only when an entry is present for the specified key AND has the right type. So
    we could override an entry of a different type without knowing it exists.'
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**缺陷**：如果我们仔细查看 `Has<TItem>` 方法，它仅在存在指定键的条目并且具有正确类型时才返回 `true`。因此，我们可以在不知道它存在的情况下覆盖不同类型的条目。'
- en: ''
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For example, `ConsumerA` sets an item of type `A` for the key `K`. Elsewhere
    in the code, `ConsumerB` looks to see if an item of type `B` exists for the key
    `K`. The method returns `false` because it’s a different type. `ConsumerB` overrides
    the value of the `K` with an object of type `B`. Here’s the code representing
    this:'
  id: totrans-326
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，`ConsumerA` 为键 `K` 设置了类型为 `A` 的项。在代码的其他地方，`ConsumerB` 检查是否存在类型为 `B` 的项。由于类型不同，方法返回
    `false`。`ConsumerB` 用类型为 `B` 的对象覆盖了 `K` 的值。以下是表示这一点的代码：
- en: '[PRE44]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Improving the design to support such a scenario could be a good practice exercise.
    You could, for example, remove the `TItem` type from the `Has` method or, even
    better, allow storing multiple items under the same key, as long as their types
    are different.
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 改进设计以支持此类场景可能是一个好的实践练习。例如，你可以从 `Has` 方法中移除 `TItem` 类型，或者更好，允许在相同键下存储多个项，只要它们的类型不同。
- en: Let’s now explore the next project.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探索下一个项目。
- en: Project – Wishlist
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 愿望清单
- en: 'Let’s get into another sample to illustrate using the singleton lifetime and
    DI. Seeing DI in action should help understand it and then leverage it to create
    SOLID software.**Context**: The application is a site-wide wishlist where users
    can add items. Items expire every 30 seconds. When a user adds an existing item,
    the system must increment the count and reset the item’s expiration time. That
    way, popular items stay on the list longer, making it to the top. When displayed,
    the system must sort the items by count (highest count first).'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个示例来展示如何使用单例生命周期和DI。看到DI的实际应用应该有助于理解它，然后利用它来创建SOLID软件。**背景**：该应用程序是一个网站范围的愿望清单，用户可以添加项目。项目每30秒过期。当用户添加一个现有项目时，系统必须增加计数并重置项目的过期时间。这样，热门项目就能在列表上停留更长时间，达到顶部。当显示时，系统必须按计数（计数最高优先）对项目进行排序。
- en: An expiration time of 30 seconds is very fast, but I’m sure you don’t want to
    wait days before an item expires when running the app. It is a test config.
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 30 秒的过期时间非常快，但我确信你不想在运行应用程序时等待几天才让项目过期。这是一个测试配置。
- en: 'The program is a tiny web API that exposes two endpoints:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序是一个小巧的 Web API，公开了两个端点：
- en: Add an item to the wishlist (`POST`).
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向愿望清单添加项目（`POST`）。
- en: Read the wishlist (`GET`).
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取愿望清单（`GET`）。
- en: 'The wishlist interface looks like this:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 愿望清单接口看起来像这样：
- en: '[PRE45]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The two operations are there, and by making them async (returning a `Task<T>`),
    we could implement another version that relies on a remote system, such as a database,
    instead of an in-memory store. Then, the `WishListItem` record class is part of
    the `IWishList` contract; it is the model. To keep it simple, the wishlist only
    stores the names of items.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个操作都在那里，通过使它们异步（返回 `Task<T>`），我们可以实现另一个版本，该版本依赖于远程系统，例如数据库，而不是内存存储。然后，`WishListItem`
    记录类是 `IWishList` 合同的一部分；它是模型。为了保持简单，愿望清单只存储项目的名称。
- en: '**Note**'
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Trying to foresee the future is not usually a good idea, but designing APIs
    to be awaitable is generally a safe bet. Other than this, I’d recommend you stick
    to the simplest code that satisfies the program's needs (KISS). When you try to
    solve problems that do not exist yet, you usually end up coding a lot of useless
    stuff, leading to additional unnecessary maintenance and testing time.
  id: totrans-341
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 预测未来通常不是一个好主意，但设计可等待的 API 通常是一个安全的赌注。除此之外，我建议你坚持使用最简单的代码来满足程序的需求（KISS）。当你试图解决尚未存在的问题时，你通常会编写大量的无用代码，导致额外的维护和测试时间。
- en: 'In the composition root, we must serve the `IWishList` implementation instance
    in a singleton scope (highlighted) so all requests share the same instance. Let’s
    start with the first half of the `Program.cs` file:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合根中，我们必须在单例作用域（突出显示）中提供 `IWishList` 实现实例，以便所有请求共享相同的实例。让我们从 `Program.cs` 文件的第一个部分开始：
- en: '[PRE46]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you are wondering where `IConfigureOptions`, `IValidateOptions`, and `IOptions`
    come from, we cover the ASP.NET Core Options pattern in *Chapter 9*, *Options,
    Settings, and Configuration*.
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你想知道 `IConfigureOptions`、`IValidateOptions` 和 `IOptions` 从哪里来，我们在第 9 章 *Options,
    Settings, and Configuration* 中介绍了 ASP.NET Core Options 模式。
- en: 'Let’s now look at the second half of the `Program.cs` file that contains the
    minimal API code to handle the HTTP requests:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 `Program.cs` 文件的第二部分，它包含处理 HTTP 请求的最小 API 代码：
- en: '[PRE47]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `GET` endpoint delegates the logic to the injected `IWishList` implementation
    and returns the result, while the `POST` endpoint validates the `CreateItem` DTO
    before delegating the logic to the wishlist.To help us implement the `InMemoryWishList`
    class, we started by writing some tests to back our specifications up. Since static
    members are hard to configure in tests (remember globals?), I borrowed a concept
    from the ASP.NET Core memory cache and created an `ISystemClock` interface that
    abstracts away the static call to `DateTimeOffset.UtcNow` or `DateTime.UtcNow`.This
    way, we can program the value of `UtcNow` in our tests to create expired items.
    Here’s the clock interface and implementation:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET` 端点将逻辑委托给注入的 `IWishList` 实现，并返回结果，而 `POST` 端点在将逻辑委托给愿望清单之前验证 `CreateItem`
    DTO。为了帮助我们实现 `InMemoryWishList` 类，我们首先编写了一些测试来支持我们的规范。由于静态成员在测试中难以配置（记得全局变量？），我借鉴了
    ASP.NET Core 内存缓存的概念，创建了一个 `ISystemClock` 接口，该接口抽象掉了对 `DateTimeOffset.UtcNow`
    或 `DateTime.UtcNow` 的静态调用。这样，我们可以在测试中编程 `UtcNow` 的值来创建已过期的项目。以下是时钟接口和实现：'
- en: '[PRE48]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '.NET 8 adds a new `TimeProvider` class to the `System` namespace, which does
    not help us much here. However, if we want to leverage that API, we could update
    the SystemClock to the following:'
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: .NET 8 在 `System` 命名空间中添加了一个新的 `TimeProvider` 类，但这在这里对我们帮助不大。然而，如果我们想利用该 API，我们可以将
    SystemClock 更新为以下内容：
- en: '[PRE49]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: That code leverages the new API, but we’ll stick to our simple implementation
    instead.
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 那段代码利用了新的 API，但我们将坚持我们的简单实现。
- en: 'Let’s look at the outline of the unit tests next because the whole code would
    take pages and be of low value:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来看看单元测试的大纲，因为整个代码会占用很多页面，且价值不高：
- en: '[PRE50]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The full source code is on GitHub: [https://adpg.link/ywy8](https://adpg.link/ywy8).'
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 完整的源代码位于GitHub上：[https://adpg.link/ywy8](https://adpg.link/ywy8).
- en: 'In the test class, we can mock the `ISystemClock` interface and program it
    to obtain the desired results based on each test case. We can also program some
    helper methods to make it easier to read the tests. Those helpers use tuples to
    return multiple values (see *Appendix A* for more information on language features).
    Here’s the mock field:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试类中，我们可以模拟`ISystemClock`接口并编程它根据每个测试用例获取期望的结果。我们还可以编程一些辅助方法来使测试更容易阅读。这些辅助方法使用元组来返回多个值（更多信息请见*附录A*关于语言特性的说明）。以下是模拟字段：
- en: '[PRE51]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here’s an example of such a helper method setting the clock to the present
    time and the `ExpectedExpiryTime` to a later time (`UtcNow + ExpirationInSeconds`
    later):'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个设置时钟为当前时间并将`ExpectedExpiryTime`设置为稍后时间的辅助方法示例（`UtcNow + ExpirationInSeconds`之后）：
- en: '[PRE52]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here is an example of another helper method setting the clock and the `ExpectedExpiryTime`
    to the past (two-time `ExpirationInSeconds` for the clock and once `ExpirationInSeconds`
    for the `ExpectedExpiryTime`):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个设置时钟和`ExpectedExpiryTime`为过去时间的另一个辅助方法示例（时钟的`ExpirationInSeconds`为两倍时间，而`ExpectedExpiryTime`的`ExpirationInSeconds`为一次）：
- en: '[PRE53]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We now have five tests covering the `AddOrRefreshAsync` method and two covering
    the `AllAsync` method. Now that we have those failing tests, here is the implementation
    of the `InMemoryWishList` class:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有五个测试覆盖了`AddOrRefreshAsync`方法，还有两个覆盖了`AllAsync`方法。现在我们有了这些失败的测试，下面是`InMemoryWishList`类的实现：
- en: '[PRE54]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `InMemoryWishList` class uses `ConcurrentDictionary<string, InternalItem>`
    internally to store the items and make the wishlist thread-safe. It also uses
    a `with` expression to manipulate and copy the `InternalItem` record class.The
    `AllAsync` method filters out expired items, while the `AddOrRefreshAsync` method
    removes expired items. This might not be the most advanced logic ever, but that
    does the trick.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`InMemoryWishList`类内部使用`ConcurrentDictionary<string, InternalItem>`来存储项目并使愿望清单线程安全。它还使用`with`表达式来操作和复制`InternalItem`记录类。《AllAsync》方法过滤掉已过期的项目，而《AddOrRefreshAsync》方法移除已过期的项目。这或许不是最先进的逻辑，但足以解决问题。'
- en: You might have noticed that the code is not the most elegant of all, and I left
    it this way on purpose. While using the test suite, I invite you to refactor the
    methods of the `InMemoryWishList` class to be more readable.
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能已经注意到代码并不十分优雅，我故意这样留下。在使用测试套件时，我邀请你重构`InMemoryWishList`类的方法以使其更易于阅读。
- en: ''
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I took a few minutes to refactor it myself and saved it as `InMemoryWishListRefactored`.
    You can also uncomment the first line of `InMemoryWishListTest.cs` to test that
    class instead of the main one. My refactoring is a way to make the code cleaner,
    to give you ideas. It is not the only way, nor the best way, to write that class
    (the “best way” being subjective).
  id: totrans-366
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我花了几分钟时间自己重构它，并将其保存为`InMemoryWishListRefactored`。你还可以取消注释`InMemoryWishListTest.cs`的第一行来测试那个类而不是主类。我的重构是为了使代码更整洁，给你一些想法。这并不是编写该类的唯一方式，也不是最佳方式（“最佳方式”是主观的）。
- en: ''
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Lastly, optimizing for readability and performance are often very different
    things.
  id: totrans-368
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，为了可读性和性能进行优化通常是两件非常不同的事情。
- en: 'Back to DI, the line that makes the wishlist shared between users is in the
    composition root we explored earlier. As a reference, here it is:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到DI，实现用户间共享愿望清单的行就在我们之前探索过的组合根中。作为一个参考，这里就是：
- en: '[PRE55]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Yes, only that line makes all the difference between creating multiple instances
    and a single shared instance. Setting the lifetime to Singleton allows you to
    open multiple browsers and share the wishlist.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，只有那一行代码在创建多个实例和单个共享实例之间做出了所有区别。将生命周期设置为Singleton允许你在多个浏览器中共享愿望清单。
- en: To `POST` to the API, I recommend using the `Wishlist.http` file in the project
    or the Postman collection ([https://adpg.link/postman6](https://adpg.link/postman6))
    that comes with the book. The collection already contains multiple requests you
    can execute in batches or individually. You can also use the Swagger UI that I
    added to the project.
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要向API `POST`，我建议使用项目中的`Wishlist.http`文件或书中附带的可用于Postman的集合([https://adpg.link/postman6](https://adpg.link/postman6))。该集合已经包含了你可以批量或单独执行的多个请求。你也可以使用我添加到项目中的Swagger
    UI。
- en: That’s it! All that code to demo what a single line of code in the composition
    root can do, and we have a working program, as tiny as it may be.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！所有这些代码都是为了演示组合根中的一行代码能做什么，我们就得到了一个工作程序，尽管它可能非常小巧。
- en: Conclusion
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'This section explored replacing the classic Singleton pattern with a standard
    instantiable class registered with a singleton lifetime. We looked at the old
    application state, learned that it was no more, and implemented two versions of
    it. We no longer need that, but it was a good way of learning about singletons.We
    then implemented a wishlist system as a second example. We concluded that the
    whole thing was working due to and managed by a single line of the composition
    root: the call to the `AddSingleton` method. Changing that line could drastically
    change the system''s behavior, making it unusable.From now on, you can see the
    Singleton pattern as an anti-pattern in .NET, and unless you find strong reasons
    to implement it, you should stick to normal classes and DI instead. Doing this
    moves the creation responsibility from the singleton class to the composition
    root, which is the composition root’s responsibility, leaving the class only one
    responsibility.Next, we explore the Service Locator anti-pattern/code smell.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了用具有单例生命周期的标准可实例化类替换经典的单例模式。我们回顾了旧的应用程序状态，了解到它已经不再存在，并实现了两个版本。我们不再需要它，但这是一个了解单例的好方法。然后，我们以愿望清单系统作为第二个示例。我们得出结论，整个系统之所以能正常工作，是因为有一个单一的根组件：调用
    `AddSingleton` 方法。更改这一行可能会极大地改变系统的行为，使其无法使用。从现在起，你可以将单例模式视为 .NET 中的反模式，除非你有充分的理由来实现它，否则你应该坚持使用正常类和依赖注入。这样做将创建责任从单例类转移到组合根，这是组合根的责任，使类只承担一个责任。接下来，我们将探讨服务定位器反模式/代码异味。
- en: Understanding the Service Locator pattern
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解服务定位器模式
- en: Service Locator is an anti-pattern that reverts the IoC principle to its Control
    Freak roots. The only difference is using the IoC container to build the dependency
    tree instead of the `new` keyword.There is some use of this pattern in ASP.NET,
    and we may argue that there are some reasons for using the Service Locator pattern,
    but it should happen rarely or never in most applications. For that reason, let’s
    call the Service Locator pattern a **code smell** instead of an **anti-pattern**.My
    strong recommendation is *don’t use the Service Locator pattern* unless you know
    you are not creating hidden coupling or have no other option. As a rule of thumb,
    you want to avoid injecting an `IServiceProvider` in your application’s codebase.
    Doing so reverts to the classic flow of control and defeats the purpose of dependency
    injection.A good use of Service Locator could be to migrate a legacy system that
    is too big to rewrite. So you could build the new code using DI and update the
    legacy code using the Service Locator pattern, allowing both systems to live together
    or migrate one into the other, depending on your goal. Fetching dependencies dynamically
    is another potential use of the Service Locator pattern; we explore this in *Chapter
    15*, *Object Mappers, Aggregate Services, and Façade*.Without further ado, let’s
    jump into some more code.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定位器是一种反模式，它将 IoC 原则退回到其控制狂根源。唯一的区别是使用 IoC 容器来构建依赖树，而不是使用 `new` 关键字。在 ASP.NET
    中有一些使用这种模式的例子，我们可能会争论使用服务定位器模式有一些理由，但在大多数应用程序中，它应该很少或从不发生。因此，让我们将服务定位器模式称为 **代码异味**
    而不是 **反模式**。我强烈建议除非你知道你不会创建隐藏的耦合或没有其他选择，否则不要使用服务定位器模式。作为一个经验法则，你想要避免在你的应用程序代码库中注入
    `IServiceProvider`。这样做会回到经典的控制流，并违背了依赖注入的目的。服务定位器的一个良好用途可能是迁移一个太大而无法重写的遗留系统。因此，你可以使用依赖注入构建新代码，并使用服务定位器模式更新遗留代码，使两个系统可以共存或根据你的目标迁移一个到另一个。动态获取依赖项是服务定位器模式的另一个潜在用途；我们将在第
    15 章，*对象映射器、聚合服务和外观*中探讨这一点。现在，我们不再拖延，直接进入更多的代码。
- en: Project – ServiceLocator
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 服务定位器
- en: 'The best way to avoid something is to know about it, so let’s see how to implement
    the Service Locator pattern using `IServiceProvider` to find a dependency.The
    service we want to use is an implementation of `IMyService`. Let’s start with
    the interface:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 避免某事最好的方法就是了解它，所以让我们看看如何使用 `IServiceProvider` 来实现服务定位器模式以查找依赖。我们想要使用的服务是 `IMyService`
    的一个实现。让我们从接口开始：
- en: '[PRE56]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The interface inherits from the `IDisposable` interface and contains a single
    `Execute` method. Here is the implementation, which does nothing more than throw
    an exception if the instance has been disposed of (we’ll leverage this later):'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口继承自 `IDisposable` 接口，并包含一个单一的 `Execute` 方法。以下是实现，它所做的只是如果实例已被销毁则抛出异常（我们稍后会利用这一点）：
- en: '[PRE57]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, let’s add a controller that implements the Service Locator pattern:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们添加一个实现服务定位器模式的控制器：
- en: '[PRE58]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the preceding code, instead of injecting `IMyService` into the constructor,
    we are injecting `IServiceProvider`. Then, we use it (highlighted line) to locate
    the `IMyService` instance. Doing so shifts the responsibility for creating the
    object from the container to the consumer (`MyController`, in this case). `MyController`
    should not be aware of `IServiceProvider` and should let the container do its
    job without interference.What could go wrong? If we run the application and navigate
    to `/service-locator`, everything works as expected. However, if we reload the
    page, we get an error thrown by the `Execute()` method because we called `Dispose()`
    during the previous request. `MyController` should not control its injected dependencies,
    which is the point that I am trying to emphasize here: leave the container to
    control the lifetime of dependencies rather than trying to be a control freak.
    Using the Service Locator pattern opens pathways toward those wrong behaviors,
    which will likely cause more harm than good in the long run.Moreover, even though
    the ASP.NET Core container does not natively support this, we lose the ability
    to inject dependencies contextually when using the Service Locator pattern because
    the consumer controls its dependencies. What do I mean by contextually? Let’s
    assume we have two classes, `A` and `B`, implementing interface `I`. We could
    inject an instance of `A` into `Consumer1` but an instance of `B` into `Consumer2`.Before
    exploring ways to fix this, here is the `Program.cs` code that powers this program:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们不是将 `IMyService` 注入到构造函数中，而是注入了 `IServiceProvider`。然后，我们使用它（高亮行）来定位
    `IMyService` 实例。这样做将创建对象的责任从容器转移到了消费者（在这个例子中是 `MyController`）。`MyController` 不应该知道
    `IServiceProvider`，而应该让容器在其不干扰的情况下完成工作。可能会出什么问题？如果我们运行应用程序并导航到 `/service-locator`，一切都会按预期工作。然而，如果我们重新加载页面，`Execute()`
    方法会抛出一个错误，因为我们之前在请求期间调用了 `Dispose()`。`MyController` 不应该控制其注入的依赖项，这正是我想强调的点：让容器控制依赖项的生命周期，而不是试图成为一个控制狂。使用服务定位器模式会开启通往这些错误行为的途径，从长远来看可能会造成比好处更多的伤害。此外，尽管
    ASP.NET Core 容器本身不支持这一点，但在使用服务定位器模式时，我们失去了根据上下文注入依赖项的能力，因为消费者控制其依赖项。我说的上下文是什么意思？让我们假设我们有两个类，`A`
    和 `B`，它们实现了接口 `I`。我们可以将 `A` 的一个实例注入到 `Consumer1` 中，但将 `B` 的一个实例注入到 `Consumer2`
    中。在探索修复方法之前，这是驱动这个程序的 `Program.cs` 代码：
- en: '[PRE59]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The preceding code enables controller support and registers our service.To
    fix the controller, we must either remove the using statement or even better:
    move away from the Service Locator pattern and inject our dependencies instead.
    Of course, you are reading a dependency injection chapter, so I picked moving
    away from the Service Locator pattern. Here''s what we are about to tackle:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码启用了控制器支持并注册了我们的服务。为了修复控制器，我们必须删除使用语句，或者更好的方法是：远离服务定位器模式并注入我们的依赖项。当然，你正在阅读一个依赖注入章节，所以我选择了远离服务定位器模式。下面是我们将要解决的问题：
- en: Method injection
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法注入
- en: Constructor injection
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: Minimal API
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化 API
- en: Let’s start with method injection.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从方法注入开始。
- en: Implementing method injection
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现方法注入
- en: 'The following controller uses *method injection* instead of the Service Locator
    pattern. Here’s the code that demonstrates this:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 以下控制器使用 *方法注入* 而不是服务定位器模式。这是演示这一点的代码：
- en: '[PRE60]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let’s analyze the code:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下代码：
- en: The `FromServicesAttribute` class tells the model binder about method injection.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FromServicesAttribute` 类告诉模型绑定器关于方法注入的信息。'
- en: We added a guard clause to protect us from `null`.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个保护子句来保护我们免受 `null` 的侵害。
- en: Finally, we kept the original code except for the `using` statement.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们保留了原始代码，除了 `using` 语句。
- en: Method injection like this is convenient when a controller has multiple actions
    but only one uses the service.
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当控制器有多个操作但只有一个使用服务时，这种方法注入很方便。
- en: Let’s reexplore constructor injection.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新探索构造函数注入。
- en: Implementing constructor injection
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现构造函数注入
- en: 'At this point, you should be familiar with constructor injection. Nonetheless,
    next is the controller''s code after migrating the Service Locator pattern to
    constructor injection:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你应该已经熟悉了构造函数注入。尽管如此，接下来是迁移到构造函数注入后的控制器代码：
- en: '[PRE61]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When using constructor injection, we ensure that `IMyService` is not `null`
    upon class instantiation. Since it is a class member, it is even less tempting
    to call its `Dispose()` method in an action method, leaving that responsibility
    to the container (as it should be).Let’s analyze the code before moving to the
    next possibility:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用构造函数注入时，我们确保在类实例化时`IMyService`不是`null`。由于它是一个类成员，因此在操作方法中调用其`Dispose()`方法的可能性更小，将此责任留给容器（正如它应该做的那样）。在考虑下一个可能性之前，让我们分析一下代码：
- en: We implemented the strategy pattern with constructor injection.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用构造函数注入实现了策略模式。
- en: We added a guard clause to ensure no `null` value could get in at runtime.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个守卫子句以确保在运行时不会出现`null`值。
- en: We simplified the action to the bare minimum.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将操作简化到了最基本的形式。
- en: Both techniques are an acceptable replacement for the Service Locator pattern.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种技术都是服务定位器模式的可接受替代方案。
- en: Implementing a minimal API
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现最小API
- en: 'Of course, we can do the same with a minimal API. Here is the code of that
    endpoint:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以用最小API做同样的事情。以下是该端点的代码：
- en: '[PRE62]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'That code does the same as the method injection sample without the guard clause
    that I omitted because no external consumer will likely inject nulls into it:
    the endpoint is a delegate passed directly to the `MapGet` method.Refactoring
    out the Service Locator pattern is often as trivial as this.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码与没有守卫子句的方法注入示例做的是同样的事情，因为我省略了守卫子句，因为不太可能外部消费者会将其注入为`null`：端点是直接传递给`MapGet`方法的委托。重构服务定位器模式通常就像这样简单。
- en: Conclusion
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: Most of the time, by following the Service Locator anti-pattern, we only hide
    that we are taking control of objects instead of decoupling our components. The
    code sample demonstrated a problem when disposing of an object, which could also
    happen using constructor injection. However, when thinking about it, it is more
    tempting to dispose of an object that we create than one we inject.Moreover, the
    service locator takes control away from the container and moves it into the consumer,
    against the **Open-Closed Principle**. You should be able to update the consumer
    by updating the composition root’s bindings.In the case of the sample code, we
    could change the binding, and it would work. In a more advanced case, binding
    two implementations to the same interface would be tough when contextual injection
    is required.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，通过遵循服务定位器反模式，我们只是隐藏了我们在控制对象而不是解耦我们的组件。代码示例演示了在销毁对象时可能出现的问题，这也可能发生在构造函数注入的情况下。然而，当我们思考这个问题时，销毁我们创建的对象比销毁我们注入的对象更有诱惑力。此外，服务定位器将控制权从容器移走，转移到消费者，违反了**开放封闭原则**。你应该能够通过更新组合根的绑定来更新消费者。在示例代码的情况下，我们可以更改绑定，并且它将正常工作。在更复杂的情况下，当需要上下文注入时，将两个实现绑定到同一个接口将变得困难。
- en: The IoC container is responsible for weaving the program’s thread, connecting
    its pieces together where each independent piece should be as clueless as possible
    about the others.
  id: totrans-415
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IoC容器负责编织程序的线程，将其各个部分连接在一起，其中每个独立的部件应该尽可能对其他部件一无所知。
- en: On top of that, the Service Locator pattern complicates testing. When unit testing
    your class, you must mock a container that returns a mocked service instead of
    mocking only the service.One place where I can see its usage justified is in the
    composition root, where bindings are defined, and sometimes, especially when using
    the built-in container, we can’t avoid it to compensate for the lack of advanced
    features. Another good place would be a library that adds functionalities to the
    container. Other than that, try to stay away!
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之上，服务定位器模式使测试变得复杂。当对类进行单元测试时，你必须模拟一个返回模拟服务的容器，而不是只模拟服务。我可以看到其使用有理可据的地方是在组合根，其中定义了绑定，有时，特别是当使用内置容器时，我们无法避免它来弥补缺乏高级功能。另一个好地方是添加功能到容器的库。除此之外，尽量远离！
- en: '**Beware**'
  id: totrans-417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**小心**'
- en: ''
  id: totrans-418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Moving the service locator elsewhere does not make it disappear; it only moves
    it around, like any dependency. However, moving it to the composition root can
    improve the maintainability of that code and remove the tight coupling.
  id: totrans-419
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将服务定位器移动到其他地方并不会让它消失；它只是将其移动，就像任何依赖项一样。然而，将其移动到组合根可以提高该代码的可维护性并消除紧密耦合。
- en: Next, we revisit our third and final pattern of this chapter.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们回顾本章的第三种也是最后一种模式。
- en: Revisiting the Factory pattern
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾工厂模式
- en: A factory creates other objects; it is like a literal real-world factory. We
    explored in the previous chapter how to leverage the Abstract Factory pattern
    to create families of objects. A factory can be as simple as an interface with
    one or more `Create[Object]` methods or, even more, a simple delegate. We explore
    a DI-oriented simple factory in this section. We are building on top of the Strategy
    pattern example.In that example, we coded two classes implementing the `ILocationService`
    interface. The composition root used the `#define` preprocessor directive to tell
    the compiler what bindings to compile. In this version, we want to choose the
    implementation at runtime.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂创建其他对象；它就像一个现实世界的工厂。我们在上一章探讨了如何利用抽象工厂模式创建对象系列。一个工厂可以像具有一个或多个`Create[Object]`方法的接口一样简单，或者甚至更简单，只是一个简单的委托。在本节中，我们探索一个以DI为导向的简单工厂。我们是在策略模式示例的基础上构建的。在那个例子中，我们编写了两个实现`ILocationService`接口的类。组合根使用`#define`预处理器指令来告诉编译器要编译哪些绑定。在这个版本中，我们希望在运行时选择实现。
- en: Not compiling the code we don’t need is good for many reasons, including security
    (lowering the attack surface). In this case, we are simply using an alternative
    strategy useful for many scenarios.
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不编译我们不需要的代码有很多好处，包括安全性（降低攻击面）。在这种情况下，我们只是使用一种适用于许多场景的替代策略。
- en: To achieve our new goal, we can extract the construction logic of the `ILocationService`
    interface into a factory.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的新目标，我们可以将`ILocationService`接口的构建逻辑提取到一个工厂中。
- en: Project – Factory
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – 工厂
- en: 'In the project, a copy from the Strategy project, we start by renaming the
    `InjectAbstractionLocationsController` class to `LocationsController`. We can
    then delete the other controllers.Now, we want to change the `ILocationService`
    bindings to reflect the following logic:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中，从策略项目复制过来，我们首先将`InjectAbstractionLocationsController`类重命名为`LocationsController`。然后我们可以删除其他控制器。现在，我们想要更改`ILocationService`绑定以反映以下逻辑：
- en: When developing the application, we use the `InMemoryLocationService` class.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发应用程序时，我们使用`InMemoryLocationService`类。
- en: When deploying to any environment, we must use the `SqlLocationService` class.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当部署到任何环境时，我们必须使用`SqlLocationService`类。
- en: 'To achieve this, we use the `Environment` property of the `WebApplicationBuilder`
    object. That property of type `IWebHostEnvironment` contains some useful properties
    like the `EnvironmentName`, and .NET adds extension methods, like the `IsDevelopment`
    method that returns true when the `EnvironmentName` equals `Development`. Here’s
    the `Program.cs` file code:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们使用`WebApplicationBuilder`对象的`Environment`属性。该属性的类型为`IWebHostEnvironment`，包含一些有用的属性，如`EnvironmentName`，.NET还添加了扩展方法，如当`EnvironmentName`等于`Development`时返回true的`IsDevelopment`方法。以下是`Program.cs`文件中的代码：
- en: '[PRE63]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The preceding code is fairly straightforward; it registers a delegate to act
    as a factory, which builds the appropriate service based on the ASP.NET Core `Environment`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码相当直接；它注册了一个委托作为工厂，根据ASP.NET Core的`Environment`构建适当的服务。
- en: We are using the `new` keyword here, but is this wrong? The composition root
    is where we should create or configure elements, so instantiating objects there
    is correct, as it is to use the Service Locator pattern. It is best to avoid the
    `new` keyword and the Service Locator pattern whenever possible, but using the
    default container makes it harder than with a full-featured third-party one. Nevertheless,
    we can avoid doing that in many cases, and even if we must use the `new` keyword
    and the Service Locator pattern, we often don’t need a third-party container.
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在这里使用`new`关键字，但这错了吗？组合根是我们创建或配置元素的地方，因此在那里实例化对象是正确的，就像使用服务定位器模式一样。最好尽可能避免使用`new`关键字和服务定位器模式，但使用默认容器比使用功能齐全的第三方容器更困难。尽管如此，我们可以在许多情况下避免这样做，即使我们必须使用`new`关键字和服务定位器模式，我们通常也不需要第三方容器。
- en: 'When we run the program, the right instance is injected into the controller
    based on the logic we added to the factory. The flow is similar to the following:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行程序时，根据我们添加到工厂中的逻辑，正确的实例被注入到控制器中。流程类似于以下内容：
- en: The application starts.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序启动。
- en: A client sends an HTTP request to the controller (`GET /travel/locations`).
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向控制器发送HTTP请求（`GET /travel/locations`）。
- en: ASP.NET Core creates the controller and leverages the IoC container to inject
    the `ILocationService` dependency.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core创建控制器并利用IoC容器注入`ILocationService`依赖项。
- en: Our factory creates the correct instance based on the current environment.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的工厂根据当前环境创建正确的实例。
- en: The action method runs, and the client receives the response.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动作方法运行，客户端接收响应。
- en: We could also create a factory class and an interface, as explored in the previous
    chapter. However, in this case, it would likely just create noise.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以创建一个工厂类和一个接口，就像前一章所探讨的那样。然而，在这种情况下，这可能会只是增加噪音。
- en: An essential thing to remember is that *moving code around your codebase does
    not make that code, logic, dependencies, or coupling disappear*. Coding a factory
    doesn’t make all your design issues disappear. Moreover, adding more complexity
    adds a cost to your project, so factory or not, each time you try to break tight
    coupling or remove a dependency, ensure that you are not just moving the responsibility
    elsewhere or overengineering your solution.
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 需要记住的一个重要事情是，*在代码库中移动代码并不能使那些代码、逻辑、依赖或耦合消失*。编写一个工厂并不能解决你所有的设计问题。此外，增加更多的复杂性会给你的项目带来成本，所以无论是否使用工厂，每次你尝试打破紧密耦合或移除依赖时，确保你不是只是在将责任转移到别处或过度设计你的解决方案。
- en: Of course, to keep our composition root clean, we could create an extension
    method that does the registration, like an `AddLocationService` method. I’ll leave
    you to try this one out, find other ways to improve the project, or even improve
    one of your own projects.The possibilities are almost endless when you think about
    the Factory patterns. Now that you’ve seen a few in action, you may find other
    uses for a factory when injecting some classes with complex instantiation logic
    into other objects.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了保持我们的组件根目录干净，我们可以创建一个扩展方法来进行注册，就像一个`AddLocationService`方法。我将把这个任务留给你去尝试，寻找其他改进项目的方法，或者甚至改进你自己的项目。当你思考工厂模式时，可能性几乎是无限的。现在你已经看到一些实际应用，你可能会在其他场景中找到工厂模式的使用，比如在将具有复杂实例化逻辑的类注入其他对象时。
- en: Summary
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter delved into Dependency Injection, understanding its crucial role
    in crafting adaptable systems. We learned how DI applies the Inversion of Control
    principle, shifting dependency creation from the objects to the composition root.
    We explored the IoC container''s role in object management, service resolution
    and injection, and dependency lifetime management. We tackled the Control Freak
    anti-pattern, advocating for dependency injection over using the `new` keyword.We
    revisited the Strategy pattern and explored how to use it with Dependency Injection
    to compose complex object trees. We learned about the principle of composition
    over inheritance, which encourages us to inject dependencies into the classes
    instead of relying on base class features and inheritance. We explored different
    ways of injecting dependencies into objects, including constructor injection,
    property injection, and method injection.We learned that a guard clause is a condition
    that must be met before a method is executed, often used to prevent null dependencies.
    We explored how to implement guard clauses. We also discussed the importance of
    adding guard clauses, as nullable reference type checks offer no guarantee at
    runtime.We revisited the Singleton pattern and how to replace it with a lifetime.
    We explored two examples utilizing the singleton lifetime to provide application-level
    features.We delved into the Service Locator pattern, often considered an anti-pattern,
    as it can create hidden coupling and revert the Inversion of Control principle.
    We learned that avoiding using the Service Locator pattern is generally best.
    We explored how to implement the Service Locator pattern and discussed the potential
    issues that could arise. We revisited the Factory pattern and learned how to build
    a simple, DI-oriented factory that replaces the object creation logic of the IoC
    container.**Here are the key takeaways from this substantial chapter**:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了依赖注入，理解其在构建可适应系统中的关键作用。我们学习了DI如何应用控制反转原则，将依赖创建从对象转移到组合根。我们探讨了IoC容器在对象管理、服务解析和注入以及依赖生命周期管理中的作用。我们解决了控制狂反模式，提倡使用依赖注入而不是使用`new`关键字。我们回顾了策略模式，并探讨了如何将其与依赖注入结合使用以组合复杂对象树。我们学习了组合优于继承的原则，这鼓励我们将依赖注入到类中，而不是依赖于基类特性和继承。我们探讨了将依赖注入到对象中的不同方法，包括构造函数注入、属性注入和方法注入。我们了解到守卫子句是在方法执行之前必须满足的条件，通常用于防止空依赖。我们探讨了如何实现守卫子句。我们还讨论了添加守卫子句的重要性，因为可空引用类型检查在运行时并不提供任何保证。我们回顾了单例模式，并探讨了如何用生命周期替换它。我们探讨了两个利用单例生命周期提供应用程序级功能的示例。我们深入探讨了服务定位器模式，通常被认为是一个反模式，因为它可以创建隐藏耦合并逆转控制反转原则。我们了解到避免使用服务定位器模式通常是最好的。我们探讨了如何实现服务定位器模式，并讨论了可能出现的潜在问题。我们回顾了工厂模式，并学习了如何构建一个简单、以依赖注入为导向的工厂，以替换IoC容器的对象创建逻辑。**以下是本章的主要内容**：
- en: Dependency Injection is a technique applying the Inversion of Control principle
    for effective dependency management and lifetime control.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入是一种应用控制反转原则的技术，用于有效管理依赖关系和生命周期控制。
- en: An IoC container resolves and manages dependencies, offering varying control
    over object behavior.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IoC容器解析和管理依赖关系，提供不同级别的对象行为控制。
- en: We can categorize dependencies into stable and volatile, the latter justifying
    DI.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将依赖分为稳定和易变两类，后者正是依赖注入的合理性所在。
- en: The lifetime of a service is Transient, Scoped, or Singleton.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务的生命周期是瞬时的、作用域的或单例的。
- en: Dependency injection allows us to avoid the Control Freak anti-pattern and stop
    creating objects with the `new` keyword, improving flexibility and testability.
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入使我们能够避免控制狂反模式，并停止使用`new`关键字创建对象，从而提高灵活性和可测试性。
- en: The Service Locator pattern often creates hidden coupling and should be avoided
    but in the composition root.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务定位器模式经常创建隐藏耦合，应该避免，但在组合根中除外。
- en: The composition root is where we register our service bindings with the IoC
    container; in the `Program.cs` file.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合根是我们将服务绑定注册到IoC容器的地方；在`Program.cs`文件中。
- en: Composing objects using the Strategy pattern alongside constructor injection
    facilitates handling complex object trees, emphasizing the principle of composition
    over inheritance.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用策略模式和构造函数注入组合对象有助于处理复杂对象树，强调了组合优于继承的原则。
- en: On top of constructor injection, there’s also method injection and property
    injection, which are less supported. It is best to prioritize constructor injection
    over the others.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了构造函数注入之外，还有方法注入和属性注入，这些支持较少。最好优先考虑构造函数注入。
- en: Guard clauses safeguard method execution from unmet conditions.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 守卫子句保护方法执行不受未满足条件的影响。
- en: It is better to avoid the Singleton pattern in favor of binding a class and
    an interface with a singleton lifetime in the container.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比起单例模式，更好的做法是将类和接口绑定到容器中的单例生命周期。
- en: The Factory pattern is ideal for creating objects with complex instantiation
    logic.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂模式是创建具有复杂实例化逻辑的对象的理想选择。
- en: Moving code around doesn't eliminate dependencies or coupling; it's important
    not to overengineer solutions.
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动代码并不能消除依赖或耦合；不要过度设计解决方案是很重要的。
- en: In subsequent sections, we explore tools that add functionalities to the default
    built-in container. Meanwhile, we explore options, settings, and configurations
    in the next chapter. These ASP.NET Core patterns aim to make our lives easier
    when managing such common problems.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节中，我们探讨添加功能到默认内置容器的工具。同时，在下一章中，我们将探讨选项、设置和配置。这些ASP.NET Core模式旨在使我们在管理此类常见问题时更加轻松。
- en: Questions
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s take a look at a few practice questions:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个练习题：
- en: What are the three DI lifetimes that we can assign to objects in ASP.NET Core?
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在ASP.NET Core中分配给对象的三个DI生命周期是什么？
- en: What is the composition root for?
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合根的作用是什么？
- en: Is it true that we should avoid the `new` keyword when instantiating volatile
    dependencies?
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是否应该避免使用`new`关键字来实例化易变依赖项？
- en: What is the pattern that we revisited in this chapter that helps compose objects
    to eliminate inheritance?
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在本章中重新审视的，帮助组合对象以消除继承的模式是什么？
- en: Is the Service Locator pattern a design pattern, a code smell, or an anti-pattern?
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务定位器模式是设计模式、代码异味还是反模式？
- en: What is the principle of composition over inheritance?
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是组合优于继承的原则？
- en: Further reading
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some links to build upon what we have learned in the chapter:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些链接，可以帮助我们巩固本章所学的内容：
- en: 'Moq: [https://adpg.link/XZv8](https://adpg.link/XZv8)'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Moq: [https://adpg.link/XZv8](https://adpg.link/XZv8)'
- en: 'If you need more options, such as contextual injections, you can check out
    an open-source library I built. It adds support for new scenarios: [https://adpg.link/S3aT](https://adpg.link/S3aT)'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要更多选项，例如上下文注入，你可以查看我构建的一个开源库。它增加了对新场景的支持：[https://adpg.link/S3aT](https://adpg.link/S3aT)
- en: 'Official documentation, Default service container replacement: [https://adpg.link/5ZoG](https://adpg.link/5ZoG)'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档，默认服务容器替换：[https://adpg.link/5ZoG](https://adpg.link/5ZoG)
- en: Answers
  id: totrans-471
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: Transient, Scoped, Singleton.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 临时、作用域、单例。
- en: The composition root holds the code that describes how to compose the program’s
    object graph—the types bindings.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合根包含描述如何组合程序对象图的代码——类型绑定。
- en: Yes, it is true. Volatile dependencies should be injected instead of instantiated.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，这是真的。易变依赖项应该通过注入而不是实例化。
- en: The Strategy pattern.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 策略模式。
- en: The Service Locator pattern is all three. It is a design pattern used by DI
    libraries internally but becomes a code smell in application code. If misused,
    it is an anti-pattern with the same drawbacks as using the `new` keyword directly.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务定位器模式是三者兼而有之。它是一个由DI库内部使用的模式，但在应用程序代码中却成为了一种代码异味。如果误用，它将是一个与直接使用`new`关键字相同的反模式。
- en: The principle of composition over inheritance encourages us to inject dependencies
    into classes and use them instead of relying on base class features and inheritance.
    This approach promotes flexibility and code reuse. It also negates the need for
    the LSP.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合优于继承的原则鼓励我们将依赖项注入到类中，并使用它们而不是依赖于基类功能和继承。这种方法促进了灵活性和代码重用。它还否定了对LSP的需求。
