- en: Multiplayer Setup
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多人设置
- en: The desire of every indie game developer is to make a multiplayer game. The
    reality is, creating multiplayer games is difficult. There are a lot of scenarios
    that you need to take into consideration as a game designer/developer. Besides
    the technical complexities that are involved in the nature of creating online
    multiplayer games, there are also game-play elements that you will need to consider.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个独立游戏开发者的愿望都是制作一个多人游戏。现实是，创建多人游戏是困难的。作为游戏设计师/开发者，您需要考虑很多场景。除了创建在线多人游戏所固有的技术复杂性外，还有游戏玩法元素需要考虑。
- en: The purpose of this chapter is to give you a good overview of the out-of-box
    networking functionality using the new Unity networking paradigm. This is a complex
    topic, and as such we cannot cover everything in this chapter. A whole new book
    will be required to really dive into the details.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是为您提供一个使用新的Unity网络范式对开箱即用的网络功能的好概述。这是一个复杂的话题，因此我们无法在本章中涵盖所有内容。要真正深入了解细节，将需要一本全新的书籍。
- en: Having said that, I have prepared this chapter to include one simple project,
    which will be used to illustrate the fundamentals of networking. I will then show
    you how to network-enable our own game objects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我已经准备了这一章，包括一个简单的项目，该项目将用于说明网络的基础知识。然后我会向您展示如何使我们的游戏对象具备网络功能。
- en: 'In this chapter, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Heads-up display
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头戴式显示器
- en: Completing a HUD design
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成HUD设计
- en: Integrating the code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成代码
- en: Here we go!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们开始！
- en: Challenges of a multiplayer game
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多人游戏的挑战
- en: A general rule of thumb is, if you don't need to enable your game to be multiplayer,
    don't! It just adds a whole lot of complexity and extra requirements and specifications
    that you will need to start worrying about. But if you must, then you must!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个普遍的规则是，如果您不需要使您的游戏成为多人游戏，那么就别这么做！这只会增加大量的复杂性和额外的需求和规范，您将需要开始担心。但如果是必须的，那么就必须这么做！
- en: 'You probably know by now that creating even the simplest multiplayer game has
    its own challenges you will need to address as the game designer. There are different
    types of online multiplayer game design, as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可能已经知道，即使是创建最简单的多人游戏也有其挑战，作为游戏设计师，您需要解决这些问题。存在不同类型的在线多人游戏设计，如下所示：
- en: Real-time multiplayer games
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时多人游戏
- en: Turn-based multiplayer games
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮流制多人游戏
- en: Asynchronous multiplayer games
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步多人游戏
- en: Local multiplayer games
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地多人游戏
- en: The most challenging out of all the different types of multiplayer games is
    real-time multiplayer gaming. This is because all players have to be synchronized
    in a proper and effective way with the latest game state at any given time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有不同类型的多人游戏中，最具挑战性的是实时多人游戏。这是因为所有玩家必须在任何给定时间以适当和有效的方式与最新的游戏状态同步。
- en: That is, if we have Player A perform a specific action, Player B will see the
    action at the same time on his or her screen. Now, consider we have another player
    join, say Player C; Players A and B will need to synchronize with Player C, and
    in turn Player C will need to synchronize its own environment with Player A's
    and Player B's state.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果我们让玩家A执行特定的动作，玩家B将同时在他的或她的屏幕上看到这个动作。现在，考虑我们还有另一个玩家加入，比如说玩家C；玩家A和B需要与玩家C同步，而玩家C反过来需要将其自己的环境与玩家A和玩家B的状态同步。
- en: Not only does the actual position/rotation of the players have to be synchronized,
    but also all of the player data. Now, imagine what will happen when you multiply
    this by 100, 1,000, or 1,000,000 connected players.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅玩家的实际位置/旋转需要同步，所有玩家数据也需要同步。现在，想象一下当您将这个数字乘以100、1,000或1,000,000个连接的玩家时会发生什么。
- en: For a real-world multiplayer game, what we will cover here is not enough, and
    what Unity provides out of the box is not enough either. Chances are you will
    need to write your own server-side code to handle the player data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现实世界的多人游戏，我们在这里涵盖的内容是不够的，Unity提供的开箱即用的功能也不够。很可能您需要编写自己的服务器端代码来处理玩家数据。
- en: Now you can see the challenge involved in designing and developing multiplayer
    games, we can start by building our first multiplayer game.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以看到设计和开发多人游戏所涉及的挑战，我们可以从构建我们的第一个多人游戏开始。
- en: Initial multiplayer game
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始多人游戏
- en: The best way to learn about multiplayer games is by looking at a simple example.
    The following project is based on the Unity networking tutorial but has been extended
    to have some other features implemented that will be helpful in the implementation
    of networking in our RPG.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 了解多人游戏的最佳方式是通过查看一个简单的示例。以下项目基于 Unity 网络教程，但已经扩展了一些其他功能，这些功能将有助于我们在 RPG 中实现网络功能。
- en: Fundamental networking components
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本网络组件
- en: Since the first edition of the book, a lot of technical and architectural changes
    have occurred within the Unity engine. Networking is one of the areas that has
    improved drastically since the publication of the first edition.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 自从本书第一版以来，Unity 引擎内部发生了许多技术和架构上的变化。自第一版出版以来，网络领域有了显著改进。
- en: 'Let''s take a look and see how we can quickly get started. The first thing
    you will need to do is download the *Network Lobby* asset from the Asset Store,
    as shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何快速开始。首先你需要做的是从资源商店下载 *网络大厅* 资产，如下截图所示：
- en: '![](img/00169.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00169.jpeg)'
- en: This is a great starting point, as we have a generic network lobby to start
    off with, so we don't have to waste time creating everything from scratch!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的起点，因为我们有一个通用的网络大厅可以开始，所以我们不必浪费时间从头开始创建一切！
- en: 'We need to get familiar with some networking components that will be used for
    the creation of our network-enabled games. These components are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要熟悉一些将用于创建我们的网络游戏的一些网络组件。这些组件如下：
- en: Network Manager: `NetworkManager` is a high-level class that allows you to control
    the state of a networked game. It provides an interface in the editor to control
    the configuration of the network, the prefabs used for spawning, and the scenes
    to use for different network game states.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络管理器：`NetworkManager` 是一个高级类，允许你控制网络游戏的网络状态。它提供了一个编辑器界面来控制网络的配置、用于实例化的预制体以及用于不同网络游戏状态的场景。
- en: 'Network Lobby Manager: `NetworkLobbyManager` is a specialized type of `NetworkManager`
    that provides a multiplayer lobby before entering the main play scene of the game.
    Ideal for matchmaking.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络大厅管理器：`NetworkLobbyManager` 是一种特殊的 `NetworkManager` 类型，在进入游戏的主玩场景之前提供多人游戏大厅。非常适合匹配。
- en: 'Network Manager HUD: This provides a default user interface for controlling
    the network state of the game. It also shows information about the current state
    of `NetworkManager` in the editor.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络管理器HUD：这提供了一个默认的用户界面来控制游戏的网络状态。它还显示了编辑器中 `NetworkManager` 的当前状态信息。
- en: 'Network Identity: The `NetworkIdentity` component is at the heart of the new
    networking system. This component controls an object''s network identity, and
    it makes the networking system aware of it.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络身份：`NetworkIdentity` 组件是新的网络系统的核心。该组件控制对象的网络身份，并使网络系统了解它。
- en: 'Network Transform: The `NetworkTransform` component synchronizes the movement
    of game objects across the network. This component takes authority into account,
    so `LocalPlayer` objects synchronize their position from the client to the server,
    then out to other clients. Other objects (with server authority) synchronize their
    position from the server to clients.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络变换：`NetworkTransform` 组件同步网络中游戏对象的移动。该组件考虑了权限，因此 `LocalPlayer` 对象从客户端同步位置到服务器，然后同步到其他客户端。其他对象（具有服务器权限）从服务器同步位置到客户端。
- en: My tank networking project
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我的坦克网络项目
- en: It is assumed that you have downloaded and imported the Network Lobby asset.
    We will be using two scenes to illustrate the concept. The first scene will be
    the lobby scene, and the second scene will be where the game will take place.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经下载并导入了网络大厅资产。我们将使用两个场景来展示这个概念。第一个场景将是大厅场景，第二个场景将是游戏进行的场景。
- en: 'Go ahead and create a scene, and name it `NetworkingGameLobby`. This is where
    the game will start. Take a look at the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 继续创建一个场景，并将其命名为 `NetworkingGameLobby`。游戏将从这里开始。请看以下截图：
- en: '![](img/00170.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00170.jpeg)'
- en: My tank network lobby
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我的坦克网络大厅
- en: Add the `LobbyManager` prefab to the scene. Select the `LobbyManager` GameObject
    in the scene, and note the `LobbyManager` component in the Inspector window. There
    are several things to notice here. First, you will need to assign the Lobby Scene
    and the Play Scene properties. We need to assign our `NetworkingGameLobby` scene
    to the Lobby Scene property, and the `NetworkingGamePlay` scene to the Play Scene
    property. Next, you will need to assign the `Game Player` Prefab property with
    the `Player` prefab. Don't worry, we will create the `Player` prefab next. Finally,
    we need to configure the Spawn Info section, and register the prefabs (GameObjects)
    that will be spawned during game time; in our case, these will be the Bullet and
    the Enemy Tanks.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将`LobbyManager`预制体添加到场景中。在场景中选择`LobbyManager`游戏对象，并在检查器窗口中注意`LobbyManager`组件。这里有几个需要注意的地方。首先，你需要分配大厅场景和游戏场景属性。我们需要将我们的`NetworkingGameLobby`场景分配给大厅场景属性，将`NetworkingGamePlay`场景分配给游戏场景属性。接下来，你需要将`Game
    Player`预制体属性分配给`Player`预制体。别担心，我们将在下一部分创建`Player`预制体。最后，我们需要配置出生信息部分，并注册游戏过程中将生成的预制体（游戏对象）；在我们的例子中，这些将是子弹和敌方坦克。
- en: Adding a player character
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加玩家角色
- en: 'We will now add a simple player character. You can really use any primitive
    GameObject to represent your PC; I will create my player to take the shape of
    a simple tank. Take a look at the following screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将添加一个简单的玩家角色。你可以使用任何原始游戏对象来表示你的PC；我将创建一个玩家，使其形状为一个简单的坦克。请看以下截图：
- en: '![](img/00171.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00171.jpeg)'
- en: 'The following screenshot will illustrate the hierarchy of the `Tank` GameObject:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图将展示`Tank`游戏对象的层次结构：
- en: '![](img/00172.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00172.jpeg)'
- en: I will not cover how to create the GameObject, as you should be able to do that
    very easily by now. What I will cover, is how to enable the new network-enabled Tank
    GameObject.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会介绍如何创建游戏对象，因为你现在应该能够非常容易地做到这一点。我会介绍的是如何启用新的网络启用型坦克游戏对象。
- en: We will attach two network components to the `Tank` GameObject. The first one
    will be `NetworkIdentity`, which can be added by selecting the `Tank` GameObject,
    and from within the Inspector window, select Add Component | Network | Network
    Identity.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`Tank`游戏对象上附加两个网络组件。第一个将是`NetworkIdentity`，可以通过选择`Tank`游戏对象，并在检查器窗口中选择添加组件
    | 网络 | 网络身份来添加。
- en: 'When you are done adding the component, make sure to check the Local Player
    Authority property checkbox, as shown in the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成组件添加后，请确保检查本地玩家权限属性复选框，如图所示：
- en: '![](img/00173.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00173.jpeg)'
- en: Local Player Authority allows the object to be controlled by the client that
    owns it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本地玩家权限允许对象被拥有它的客户端控制。
- en: 'Next, we need to add the `NetworkTransform` component to the Tank GameObject.
    Again, selecting the `Tank` GameObject, from the Inspector window, click Add Component
    | Network | NetworkTransform to add the component:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将`NetworkTransform`组件添加到坦克游戏对象上。再次选择`Tank`游戏对象，在检查器窗口中，点击添加组件 | 网络 |
    网络变换来添加组件：
- en: '![](img/00174.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00174.jpeg)'
- en: We will keep the default values for the `NetworkTransform` component. With the
    exception of the rotation properties, since we are only rotating on the *Y*-axis,
    we don't have to send all XYZ information, so change that to Y (Top-Down 2D) and
    increase the interpolate Rotation field to 15, and change the Compress Ratio to
    High. You can read more about the different properties on your own using the online
    documentation. The main attribute you might want to adjust is the Network Send
    Rate.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留`NetworkTransform`组件的默认值。除了旋转属性外，因为我们只沿*Y*轴旋转，所以我们不需要发送所有XYZ信息，因此将其更改为Y（俯视2D）并增加插值旋转字段到15，并将压缩比更改为高。你可以通过在线文档自行了解更多关于不同属性的信息。你可能想要调整的主要属性是网络发送速率。
- en: Next, we want to create a script that will allow us to control the movement
    of the Tank. Go ahead and create a new C# script and name it `MyPlayerController.cs`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要创建一个脚本，使我们能够控制坦克的移动。现在就创建一个新的C#脚本，并将其命名为`MyPlayerController.cs`。
- en: 'Here is a listing of the script:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是脚本列表：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code is straightforward, but there are some important concepts that we need
    to discuss. First and foremost, you will notice that we are inheriting from `NetworkBehaviour`
    instead of `MonoBehaviour`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单，但有一些重要的概念我们需要讨论。首先，你会注意到我们是从`NetworkBehaviour`继承，而不是从`MonoBehaviour`继承。
- en: '`NetworkBehaviour` is used to work with objects with the `NetworkIdentiy` component.
    This allows you to perform network-related functions such as `Commands`, `ClientRPCs`,
    `SyncEvents`, and `SyncVars`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetworkBehaviour`用于与具有`NetworkIdentity`组件的对象一起工作。这允许你执行与网络相关的函数，如`Commands`、`ClientRPCs`、`SyncEvents`和`SyncVars`。'
- en: Variable synchronization
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量同步
- en: Synchronizing variables is one of the important aspects of a multiplayer game.
    If you recall, one of the challenges of multiplayer games is the ability to make
    sure all of the key data for the game is synchronized across the server and the
    clients. This is accomplished by the `SyncVar` attribute. You will see how this
    is applied in the next script, which we will create for the health of the unity.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 同步变量是多玩家游戏的重要方面之一。如果你还记得，多玩家游戏的一个挑战是确保游戏的所有关键数据在服务器和客户端之间同步。这是通过`SyncVar`属性实现的。你将在下一个脚本中看到这一点，我们将为Unity的健康状态创建这个脚本。
- en: Network callbacks
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络回调
- en: 'Network callbacks are functions that are invoked on the `NetworkBehaviour`
    script for various network events. They are listed as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 网络回调是针对`NetworkBehaviour`脚本在多种网络事件上调用的函数。它们列示如下：
- en: '`OnStartServer()` is called when an object is spawned on the server, or when
    the server is started for objects in the scene'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnStartServer()`在服务器上创建对象时或当服务器为场景中的对象启动时被调用'
- en: '`OnStartClient()` is called when the object is spawned on the client, or when
    the client connects to a server for objects in the scene'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnStartClient()`在客户端上创建对象时或当客户端连接到服务器以处理场景中的对象时被调用'
- en: '`OnSerialize()` is called to gather state to send from the server to the clients'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnSerialize()`被调用以收集从服务器发送到客户端的状态'
- en: '`OnDeSerialize()` is called to apply state to objects on clients'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDeSerialize()`被调用以将状态应用于客户端上的对象'
- en: '`OnNetworkDestroy()` is called on clients when the server tells the object
    to be destroyed'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnNetworkDestroy()`在服务器告诉对象被销毁时在客户端上被调用'
- en: '`OnStartLocalPlayer()` is called on clients for player objects for the local
    client only'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnStartLocalPlayer()`在本地客户端的玩家对象上被调用'
- en: '`OnRebuildObservers()` is called on the server when the set of observers for
    an object is rebuilt'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnRebuildObservers()`在服务器上被调用，当对象的观察者集合被重建时'
- en: '`OnSetLocalVisibility()` is called on a host when the visibility of an object
    changes for the local client'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnSetLocalVisibility()`在主机上被调用，当对象的可见性对本地客户端发生变化时'
- en: '`OnCheckObserver()` is called on the server to check the visibility state for
    a new client'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnCheckObserver()`在服务器上被调用，用于检查新客户端的可见状态'
- en: In the `PlayerController.cs` script, you will notice that we are using `OnStartClient()`
    to highlight the local player by changing its material color to blue.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PlayerController.cs`脚本中，你会注意到我们正在使用`OnStartClient()`通过将材质颜色更改为蓝色来突出显示本地玩家。
- en: Sending commands
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送命令
- en: Commands are how clients request a function to be performed on the server. In
    a server authoritative system, clients can only do things through commands. Commands
    are run on the player object on the server that corresponds to the client that
    sent the command. This routing happens automatically, so it is impossible for
    a client to send a command for a different player.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 命令是客户端请求在服务器上执行函数的方式。在服务器权威系统中，客户端只能通过命令做事。命令在服务器上对应发送命令的客户端的玩家对象上运行。这种路由是自动发生的，因此客户端不可能为不同的玩家发送命令。
- en: A command must begin with the prefix "Cmd" and have the `[Command]` custom attribute
    on it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 命令必须以前缀“Cmd”开始，并在其上具有`[Command]`自定义属性。
- en: In our `PlayerController.cs` script, when the player fires, it sends a Command
    to the server using the `CmdFire()` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`PlayerController.cs`脚本中，当玩家开火时，它使用`CmdFire()`函数向服务器发送命令。
- en: Client RPC calls
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端RPC调用
- en: Client RPC calls are a way for server objects to cause things to happen on client
    objects. This is the reverse direction to how commands send messages, but the
    concepts are the same. Client RPC calls, however, are not only invoked on player
    objects; they can also be invoked on any `NetworkIdentity` object. They must begin
    with the prefix "Rpc" and have the `[ClientRPC]` custom attribute.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端RPC调用是服务器对象在客户端对象上引发事件的一种方式。这与命令发送消息的方向相反，但概念是相同的。然而，客户端RPC调用不仅可以在玩家对象上调用；它们也可以在任何`NetworkIdentity`对象上调用。它们必须以“Rpc”前缀开始，并具有`[ClientRPC]`自定义属性。
- en: You will see an example of this on the `Health.cs` script, which we will be
    creating next.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在我们接下来要创建的`Health.cs`脚本中看到这个示例。
- en: We will also need a way to keep track of our player character's health. This
    will be done using a new script called `Health.cs`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一种方法来跟踪玩家角色的健康状态。这将通过一个新的脚本`Health.cs`来实现。
- en: 'A listing of the script is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本列表如下：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that, in this script, we are also inheriting from `NetworkBehaviour`.
    The two main items I want to bring to your attention are the `SyncVar`, the `ClientRpc`,
    and the `Start()` functions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个脚本中，我们还在继承自`NetworkBehaviour`。我想重点介绍的两个主要项目是`SyncVar`、`ClientRpc`和`Start()`函数。
- en: We want to synchronize the player's health across the network. To do this, we
    use the `SyncVarNetworkBehaviour`. `SyncVar` can be any basic type, not classes,
    lists, or other collections.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在网络中同步玩家的健康状态。为此，我们使用`SyncVarNetworkBehaviour`。`SyncVar`可以是任何基本类型，但不能是类、列表或其他集合。
- en: When the value of *SyncVar* is changed on the server, it will be sent to all
    of the ready clients in the game. When objects are spawned, they are created on
    the client with the latest state of all *SyncVars* from the server.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器上*SyncVar*的值发生变化时，它将被发送到游戏中所有准备好的客户端。当对象被实例化时，它们将在客户端上创建，并具有来自服务器的所有*SyncVars*的最新状态。
- en: The `OnStartClient()` function makes sure that each object with the `Health.cs`
    script attached to it will have the most up-to-date value to display on the health
    bar UI.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnStartClient()`函数确保所有附加了`Health.cs`脚本的物体都将具有最新的值，以便在健康条UI上显示。'
- en: I want to take a moment and make sure I give you a crucial pointer here. Assume
    we are running a networked game session, and we have the `Host`, `Player A`, and
    `Player B` connected and going about their business. During the gameplay, `Player
    A` and `Player B` have their health value changed. Now, we have a third player
    connect to the game, `Player C`. If `Start()` is not implemented, the client for
    `Player C` will have the correct data synchronized for all of the GameObjects
    with the `Health.cs` script; however, the data will not reflect correctly on the
    UI because we need to have a trigger for that to happen. This can be handled in
    the `Start()` function, as shown in the code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这里花点时间确保我给你一个关键提示。假设我们正在运行一个网络游戏会话，我们有`主机`、`玩家A`和`玩家B`连接并正在忙于自己的事情。在游戏过程中，`玩家A`和`玩家B`的健康值发生变化。现在，有第三个玩家连接到游戏，即`玩家C`。如果没有实现`Start()`，`玩家C`的客户端将具有所有带有`Health.cs`脚本的GameObject的正确数据同步；然而，数据将不会正确反映在UI上，因为我们需要一个触发器来实现这一点。这可以在`Start()`函数中处理，如代码所示。
- en: The next function is the `RpcRespawn()` function. In the `TakeDamage()` function,
    we check the health of the current GameObject. If the health drops below zero,
    we check to see if the `destroyOnDeath` Boolean variable is set. If it is not
    set, we go ahead and reset the `currentHealth` value to `maxHealth` value, and
    we use the `RpcRespawn()` method to re-spawn the player at the origin. Remember
    this function is executed on all clients!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是`RpcRespawn()`函数。在`TakeDamage()`函数中，我们检查当前GameObject的健康值。如果健康值降至零以下，我们检查`destroyOnDeath`布尔变量是否设置。如果没有设置，我们将`currentHealth`值重置为`maxHealth`值，并使用`RpcRespawn()`方法在原点重新生成玩家。记住，这个函数在所有客户端上都会执行！
- en: Within the function, we check to see if the caller is the local player by checking
    the `isLocalPlayer`variable. Yes, creating a multiplayer game does get confusing!
    This will become more apparent as you start experimenting with it more.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们通过检查`isLocalPlayer`变量来查看调用者是否是本地玩家。是的，创建多人游戏确实会让人感到困惑！当你开始更多地进行实验时，这一点将变得更加明显。
- en: Creating the cannonball for the tank
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建坦克的炮弹
- en: Let's create a prefab that will represent our cannonballs! Very simply, create
    a sphere and make it the same size as the nozzle of your tank gun.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个预制体来代表我们的炮弹！非常简单，创建一个球体并使其与坦克炮的喷嘴大小相同。
- en: 'We will need to attached the following components to the Canon Ball GameObject:
    `NetworkIdentity`, `NetworkTransform`, `Rigidbody`, and `Bullet.cs` scripts.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将以下组件附加到炮弹游戏对象上：`NetworkIdentity`、`NetworkTransform`、`Rigidbody`和`Bullet.cs`脚本。
- en: Make sure that you set the `Use Gravity` property to `False` on the `Rigidbody`
    component. Also, make sure that both Server Only and Local Player Authority properties
    are *False* on the `NetworkIdentity` component. On the `NetworkTransform` component,
    change `Network Send Rate` to `0`. Once we generate the object on the server,
    the physics will take care of the motion on each client.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在`Rigidbody`组件中将`Use Gravity`属性设置为`False`。同时，确保在`NetworkIdentity`组件中，`Server
    Only`和`Local Player Authority`属性都设置为`False`。在`NetworkTransform`组件中，将`Network Send
    Rate`改为`0`。一旦我们在服务器上生成了对象，物理引擎将负责每个客户端上的运动。
- en: Create a new C# script called `Bullet.cs`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本，命名为`Bullet.cs`。
- en: 'The listing for the script is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本列表如下：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All we are doing here is detecting a collision. If there is a collision, we
    get the `Health` component. If the `Health` component is not null, we call the
    `TakeDamage()` function and pass it a value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的只是检测碰撞。如果有碰撞，我们获取`Health`组件。如果`Health`组件不为空，我们调用`TakeDamage()`函数并传递一个值。
- en: If you recall from the `Health.cs` script, the `TakeDamage()` function reduces
    `currentHealth` of the player, which in return is a `SyncVar` that gets updated
    on all active clients.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得`Health.cs`脚本，`TakeDamage()`函数会减少玩家的`currentHealth`，这反过来是一个`SyncVar`，会在所有活动客户端上更新。
- en: 'One item we did not discuss is the idea of a `hook`. A `SyncVar` can have a
    `hook`. Think of a hook as an event handler. The hook attribute can be used to
    specify a function to be called when the `SyncVar` changes value on the client:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有讨论的一个概念是`hook`。一个`SyncVar`可以有一个`hook`。将`hook`想象成一个事件处理器。`hook`属性可以用来指定当`SyncVar`在客户端上更改值时要调用的函数：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `OnChangeHealth()` function is responsible for updating the UI canvas for
    displaying our health value:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnChangeHealth()`函数负责更新UI画布以显示我们的健康值：'
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Go ahead and also make a prefab of the cannonball and delete the instance from
    the scene.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，也创建炮弹的预制体，并将其实例从场景中删除。
- en: Make sure you have assigned the proper prefab associations that are required
    on each script. For instance, the `Tank` GameObject's `PlayerController.cs` script
    needs a reference to the cannonball prefab, and also the canon spawn location.
    The `Health.cs` script needs a reference to the HealthBar foreground image and
    so on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经为每个脚本分配了所需的正确预制体关联。例如，`Tank`游戏对象的`PlayerController.cs`脚本需要一个对炮弹预制体的引用，以及大炮的生成位置。`Health.cs`脚本需要一个对健康条前景图像的引用等等。
- en: Creating the tank prefab and configuring the network lobby manager
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建坦克预制体并配置网络大堂管理员
- en: Now that we have created our `Tank` GameObject and attached all of the necessary
    components and scripts to it, we need to make a prefab of it. This is because
    we will let `NetworkLobbyManger` spawn our player character, and in order for
    it to be able to do so, it needs to refer to a prefab that is a representation
    of your player character.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的`Tank`游戏对象，并将其所有必要的组件和脚本附加到它上面，我们需要为其创建一个预制体。这是因为我们将让`NetworkLobbyManger`生成我们的玩家角色，为了使其能够这样做，它需要引用一个代表你的玩家角色的预制体。
- en: The `NetworkLobbyManager` has a `Spawn Info` section that you can assign the
    `Player` Prefab, determine if the `NetworkLobbyManager` can Auto Create Player
    and the `Player Spawn` Method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetworkLobbyManager`有一个`Spawn Info`部分，你可以在这里分配`Player`预制体，确定`NetworkLobbyManager`是否可以自动创建玩家以及`Player
    Spawn`方法。'
- en: There is also a section for `Registered Spawnable` Prefabs. We need to register
    all of the GameObjects that will be spawned by the `NetworkServer`. For instance,
    the Canon Ball prefab will need to be registered here so that we can spawn it
    across the network on different clients.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一个`Registered Spawnable`预制体部分。我们需要注册所有将由`NetworkServer`生成的游戏对象。例如，炮弹预制体需要在这里注册，这样我们就可以在不同的客户端上通过网络生成它。
- en: Select the `Network Lobby Manager` GameObject in the scene, and in the Inspector window
    assign the appropriate prefabs as needed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中选择`Network Lobby Manager`游戏对象，在检查器窗口中根据需要分配适当的预制体。
- en: 'Here is a screenshot of how the `NetworkLobbyManager` should look at this point:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是此时`NetworkLobbyManager`的截图：
- en: '![](img/00175.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00175.jpeg)'
- en: Lobby manager
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 大堂管理员
- en: 'At this point, you are ready to test out what we have built so far. Go ahead
    and create a stand-alone version of your game using the Build Settings window.
    Once you have your build ready, launch two instances of the application. We will
    use one instance to host the game, and the other to connect as a client, as shown
    in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经准备好测试我们所构建的内容。使用构建设置窗口创建游戏的独立版本。一旦你的构建就绪，启动两个应用程序实例。我们将使用一个实例来托管游戏，另一个作为客户端连接，如图所示：
- en: '![](img/00176.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00176.jpeg)'
- en: 'The following screenshot illustrates how your game instance will look when
    you run it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了运行游戏实例时的外观：
- en: '![](img/00177.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00177.jpeg)'
- en: 'The following screenshots illustrate how your screen will look during runtime.
    The game is created on an Android tablet:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了运行时屏幕的外观。游戏是在Android平板电脑上创建的：
- en: '![](img/00178.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00178.jpeg)'
- en: 'The second player selects LIST SERVERS and gets available matches, and clicks
    JOIN to enter the room, as shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个玩家选择“列出服务器”并获取可用匹配，然后点击“加入”进入房间，如图所示：
- en: '![](img/00179.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00179.jpeg)'
- en: Once everyone is ready, the game starts. Notice that each player has a unique
    tank color assign based on their color selection in the lobby.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有人都准备好了，游戏就开始。注意，每个玩家都有一个独特的坦克颜色，这是基于他们在大厅中的颜色选择分配的。
- en: In the preceding screenshot, note that each client has highlighted the player
    character it controls, that is, the tank it controls. It will be difficult to
    capture the fire command, but you can go ahead and use the Space Bar to fire the
    canon, and it will be triggered accordingly on all active clients.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，请注意每个客户端都突出显示了它控制的玩家角色，即它控制的坦克。捕捉火命令将很困难，但你可以使用空格键发射加农炮，它将在所有活动客户端上相应触发。
- en: You will also notice that the health of each tank will be reflected accurately
    if they do get a hit. Now we are ready to create an enemy to illustrate the non-player
    character in the game.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到，如果坦克受到攻击，它们的健康值将准确反映。现在我们准备创建一个敌方角色来展示游戏中的非玩家角色。
- en: Adding the enemy tank
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加敌方坦克
- en: Now it is time to add some of the non-player characters to our multiplayer demo.
    Adding the Enemy Tank will be simple as we will use our Tank prefab as a base.
    Go ahead and drop the Tank prefab into the scene, and change the name to `TankEnemy`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在我们的多人演示中添加一些非玩家角色了。添加敌方坦克将很简单，因为我们将以坦克预制体为基础。将坦克预制体拖放到场景中，并将其名称更改为`TankEnemy`。
- en: 'Remove the `MyPlayerCharacter.cs` script from the GameObject. We will create
    a separate script as the controller for the enemy tank. I have also gone ahead
    and applied different material to the enemy tank so that we can visually distinguish
    which tanks will be controlled by players and which ones will be non-player. Take
    a look at the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从GameObject中移除`MyPlayerCharacter.cs`脚本。我们将创建一个独立的脚本作为敌方坦克的控制脚本。我还在敌方坦克上应用了不同的材质，以便我们可以从视觉上区分哪些坦克将由玩家控制，哪些不是。请看以下截图：
- en: '![](img/00180.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00180.jpeg)'
- en: Enemy tank setup
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 敌方坦克设置
- en: The preceding screenshot illustrates how your `Tank` and `TankEnemy` prefabs
    should look. The main difference between the two is the controller script. Tank
    has the `MylayerController.cs` script, and `TankEnemy` has the `EnemyController.cs`
    script.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图展示了你的`Tank`和`TankEnemy`预制体应该看起来是什么样子。两者之间的主要区别是控制脚本。坦克有`MylayerController.cs`脚本，而`TankEnemy`有`EnemyController.cs`脚本。
- en: 'A listing of the `EnemyController.cs` script is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnemyController.cs`脚本的列表如下：'
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The script continuously searches for all players that are active in the scene
    and makes a list of them. Then it finds the closest one to itself. Once it determines
    which player is closest, it rotates to face the player.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本持续搜索场景中所有活跃的玩家，并为他们创建一个列表。然后它找到离自己最近的一个。一旦确定哪个玩家最近，它就会旋转以面对玩家。
- en: After that, it calculates the distance between itself and the selected player;
    if the distance is shorter than the acceptable threshold, then it starts firing
    at the player. Each time the enemy tank fires, it actually calls a `[Command]`
    named `CmdFire()`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，它计算自己与所选玩家的距离；如果距离小于可接受的阈值，它就开始向玩家开火。每次敌方坦克开火时，它实际上会调用一个名为`[Command]`的`CmdFire()`函数。
- en: This function is run on the server; it instantiates a cannonball prefab and
    spawns it on the network.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在服务器上运行；它实例化一个炮弹预制体，并在网络上生成它。
- en: The `EnemyController.cs` script also has a `SyncVar` for the `playertoAttack`
    variable, with a `hook` attached as an `OnChangePlayerToAttack()` function. This,
    in turn, makes sure that all clients get updated with the latest data on each
    Enemy `Tank` GameObject.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnemyController.cs` 脚本也有一个 `SyncVar` 用于 `playertoAttack` 变量，并附加了一个作为 `OnChangePlayerToAttack()`
    函数的 `hook`。这反过来确保所有客户端都更新了每个敌方 `Tank` GameObject 的最新数据。'
- en: The `Health.cs` script works the same as it does on the `Tank` GameObject.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Health.cs` 脚本在 `Tank` GameObject 上的工作方式相同。'
- en: 'There is one more item we need to cover: the spawning of the `Enemy Tanks`
    by the server. We can do this easily by creating another empty GameObject and
    naming it `Enemy Spawner`. We need to attach a `NetworkIdentity` component and
    make sure we set the `Server Only` property to `True`. This will make sure that
    only the server can instantiate the enemy objects.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要讨论另一个项目：服务器通过生成 `Enemy Tanks`。我们可以通过创建另一个空的 GameObject 并将其命名为 `Enemy Spawner`
    来轻松完成此操作。我们需要附加一个 `NetworkIdentity` 组件，并确保将 `Server Only` 属性设置为 `True`。这将确保只有服务器可以实例化敌方对象。
- en: 'The next step is to create the `EnemySpawner.cs` scripts. The listing is as
    follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建 `EnemySpawner.cs` 脚本。如下所示：
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code technically takes the prefab provided as the enemy tank and randomly
    spawns each enemy tank within a range over the network.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在技术上以提供的预制件作为敌方坦克，并在网络上随机在范围内生成每个敌方坦克。
- en: Make sure all of your prefabs have been assigned in the Inspector window for
    both the `Enemy Spawner` GameObject and the `TankEnemy` GameObject. Create a prefab
    of your `TankEnemy` if you have not done so already, and delete it from the scene.
    Do not delete the `Enemy Spawner`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 确保所有预制件都已分配到检查器窗口中的 `Enemy Spawner` GameObject 和 `TankEnemy` GameObject。如果你还没有这样做，创建一个
    `TankEnemy` 的预制件，并将其从场景中删除。不要删除 `Enemy Spawner`。
- en: We need to register the `TankEnemy` prefab with the `NetworkLobbyManager`. Go
    ahead and select the `Network Manager` GameObject, and from the Inspectorwindow,
    add a new Prefab to the `Registered Spawnable` Prefabs option.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将 `TankEnemy` 预制件注册到 `NetworkLobbyManager`。请继续选择 `Network Manager` GameObject，并在检查器窗口中，将一个新的预制件添加到
    `Registered Spawnable` 预制件选项中。
- en: 'Your `Network Manager` should now look as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `Network Manager` 应该如下所示：
- en: '![](img/00181.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00181.jpeg)'
- en: Lobby Network Manager Setup
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 大厅网络管理器设置
- en: Building and testing
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和测试
- en: 'We are ready to do our final test. Go ahead and build the stand-alone version
    of the project, and launch a new instance of the game. Player 1 will create the
    room, and the rest of the players will join the game, as shown in the following
    screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好进行最终测试。请继续构建项目的独立版本，并启动一个新的游戏实例。玩家1将创建房间，其余玩家将加入游戏，如下面的截图所示：
- en: '![](img/00182.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00182.jpeg)'
- en: Joining a game demo
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 加入游戏演示
- en: You will also notice that right after initialization, all of the enemy tanks
    will rotate toward the player character tank and if within range, they will start
    firing at it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会注意到，初始化后，所有敌方坦克都会转向玩家角色坦克，如果在其射程内，它们将开始对其开火。
- en: 'The following screenshot illustrates the runtime of the game:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图说明了游戏的运行时状态：
- en: '![](img/00183.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00183.jpeg)'
- en: Notice that while I was trying to capture the screen, the enemy tanks were merciless
    and fired at Player 4 continuously. You can see that my health bar has reduced
    drastically. You can also see that one of the enemy tanks has also received some
    damage.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我试图捕获屏幕时，敌方坦克无情地连续向玩家4开火。你可以看到我的生命条大幅减少。你也可以看到敌方坦克之一也受到了一些伤害。
- en: I assure you that I had nothing to do with the damage taken by the enemy tank;
    it was actually caused by friendly fire. Yes, at the moment, the enemy tanks are
    not smart enough to hold fire if another team member is in the line of fire!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我向你保证，我与敌方坦克受到的伤害无关；实际上，这是由友军火力造成的。是的，目前，敌方坦克还不够聪明，无法在另一名团队成员处于火力线时停止开火！
- en: I will let you handle the implementation of that on your own. Shouldn't be too
    complex.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我将让你自己处理这个实现的细节。不应该太复杂。
- en: Use Raycasting to make sure there is no object between the enemy tank and the
    player prior to firing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用射线投射来确保在开火之前敌方坦克和玩家之间没有物体。
- en: Congratulations! You have just created your first multiplayer game! As mentioned
    previously, creating, maintaining, and hosting a multiplayer game is no small
    task, and covering every single aspect on how to do it is simply impossible in
    a few pages.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚创建了你第一个多人游戏！如前所述，创建、维护和托管多人游戏是一项不小的任务，在几页纸上涵盖每个方面是如何做的，简直是不可行的。
- en: The idea here is to give you the foundation and the fundamentals that you can
    take and expand upon. I would encourage you to take some time to study what we
    have just covered and do some more reading on the material, even though not much
    exists. The truth is that you will need to do a lot of experimentation and trial
    and error on your own.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是给你提供一个基础和基础，你可以在此基础上扩展。我鼓励你花些时间研究我们刚刚覆盖的内容，并对材料进行更多阅读，即使资料不多。事实是，你将需要自己进行大量的实验和尝试。
- en: Now that we know the basics, let's go ahead and apply what we have learned to
    our RPG assets.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基础知识，让我们将所学应用到我们的RPG资产上。
- en: Network-enabling RPG characters
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络化RPG角色
- en: In order to make life easier, I have decided to create a new scene that will
    be used to test and implement our network-enabled characters. This example will
    show you how to network-enable the player character, and also how to synchronize
    the player character data such as inventory items across the network, as well
    as provide you with the ability to network-enable the non-player character and
    make it synchronize its data across the clients.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让生活更简单，我决定创建一个新的场景，该场景将用于测试和实现我们的网络启用角色。这个例子将向你展示如何使玩家角色网络化，以及如何同步玩家角色数据，如库存物品，通过网络，以及提供你使非玩家角色网络化并使其数据在客户端之间同步的能力。
- en: Creating a scene for our RPG
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的RPG创建一个场景
- en: Just like the tank demo in the previous section, we will use two new scenes
    to illustrate the RPG networking concept here. We will create two scenes, one
    called `NetworkingMenu` and the other `DeathMatchMultiplayer`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一节中的坦克演示一样，我们将使用两个新的场景来展示RPG网络概念。我们将创建两个场景，一个叫做 `NetworkingMenu`，另一个叫做 `DeathMatchMultiplayer`。
- en: The `NetworkingMenu` scene is our lobby scene, so it will be exactly the same
    as the Tank Multiplayer lobby scene, with the exception that the player character
    will be replaced by the Barbarian prefab, and the `Registered Spawnable` Prefabs
    will be different. We shall see this later.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetworkingMenu` 场景是我们的大厅场景，所以它将与坦克多人游戏大厅场景完全相同，除了玩家角色将被野蛮人预制件替换，`Registered
    Spawnable` 预制件将不同。我们稍后会看到这一点。'
- en: 'In the `DeathMatchMultiplayer` scene, I have the following level design:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DeathMatchMultiplayer` 场景中，我的以下级别设计如下：
- en: '![](img/00184.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00184.jpeg)'
- en: Level design spawn enemy
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 级别设计生成敌人
- en: 'Your lobby scene should look something like the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你的大厅场景应该看起来像以下这样：
- en: '![](img/00185.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00185.jpeg)'
- en: The next step is to make sure our GameObjects are network-enabled.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是确保我们的GameObject启用网络功能。
- en: Networked player character
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络化玩家角色
- en: Go ahead and drag the player prefab you have created into the scene. We will
    use it as a base to create a new prefab, which will be used for the networked
    version of the game.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请将你创建的玩家预制件拖入场景。我们将将其用作创建新预制件的基础，该预制件将用于游戏的网络版本。
- en: Go ahead and remove the existing `BarbarianCharacterController.cs` and `BarbarianCharacterCustomization.cs`
    components from the instance. We will create new scripts that are network-enabled
    and use them. Rename the `PC` GameObject instance to `PC-C6-Network`. Now make
    a prefab of the instance. You should now have a new prefab named `PC-C6-Network`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请从实例中移除现有的 `BarbarianCharacterController.cs` 和 `BarbarianCharacterCustomization.cs`
    组件。我们将创建新的脚本，这些脚本将启用网络功能并使用它们。将 `PC` GameObject 实例重命名为 `PC-C6-Network`。现在创建实例的预制件。你现在应该有一个名为
    `PC-C6-Network` 的新预制件。
- en: 'Go ahead and attach the following components to the prefab: `NetworkIdentiy`,
    `NetworkTransform`, and `NetworkAnimator`, by using the `Inspector` Window and
    selecting Add Components *|* Network *|* <component name>.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用“检查器”窗口，选择添加组件 *|* 网络 *|* <组件名称>，将以下组件附加到预制件：`NetworkIdentiy`、`NetworkTransform`
    和 `NetworkAnimator`。
- en: On the `NetworkIdentity` component, set `Local Player Authority` to `True`.
    On the `NetworkTransform` component, change Transform Sync Mode to Sync Rigidbody
    3D. On the `NetworkAnimator` component, you will need to drag the `Animator` components
    attached to the GameObject into the `Animator` slot.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `NetworkIdentity` 组件上，将 `Local Player Authority` 设置为 `True`。在 `NetworkTransform`
    组件中，将变换同步模式更改为同步 Rigidbody 3D。在 `NetworkAnimator` 组件中，您需要将附加到 GameObject 上的 `Animator`
    组件拖放到 `Animator` 槽中。
- en: You will need to select the `Animator` component and drag it right down into
    the `Animator` slot on the `NetworkAnimator` components.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要选择 `Animator` 组件，并将其拖放到 `NetworkAnimator` 组件上的 `Animator` 槽中。
- en: Next, we need to create a new character controller so that it is network compatible.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个新的角色控制器，使其具有网络兼容性。
- en: Create a new C# script and call it `BarbarianCharacterNetworkController.cs`.
    Attach the script to the `PC-C6-Network` prefab. The new character controller
    is a stripped-down version of the original character controller.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 C# 脚本，命名为 `BarbarianCharacterNetworkController.cs`。将脚本附加到 `PC-C6-Network`
    预制件上。新的角色控制器是原始角色控制器的一个简化版本。
- en: 'The listing for it is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 它的列表如下：
- en: '[PRE8]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first thing you should notice is that we are inheriting from `NetworkBehaviour`
    instead of `MonoBehaviour`. This is necessary if we want to enable certain network
    behaviors on the GameObject. Take a look at the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先应该注意到的是，我们正在从 `NetworkBehaviour` 继承，而不是 `MonoBehaviour`。如果我们想在 GameObject
    上启用某些网络行为，这是必要的。看看下面的截图：
- en: '![](img/00186.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![img/00186.jpeg]'
- en: Level setup for RPG network
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: RPG 网络级别设置
- en: Next, let's look at some of the variables that need to be synchronized across
    the network for each player character that is connected. These variables are `enemyToAttack`
    and `Health`. There are two more variables, `Shield` and `Helmet`, which we will
    discuss later.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看需要同步到网络上的某些变量，这些变量适用于每个连接的玩家角色。这些变量是 `enemyToAttack` 和 `Health`。还有两个其他变量，`Shield`
    和 `Helmet`，我们将在稍后讨论。
- en: 'In the `Update()` function, we need a way to check and make sure that it is
    the local player before giving the controller the chance to execute the player.
    This is done by having the following code check to see if the current client is
    the local player:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Update()` 函数中，我们需要一种方法来检查并确保在给控制器机会执行玩家之前，它是本地玩家。这是通过以下代码检查当前客户端是否是本地玩家来完成的：
- en: '[PRE9]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will make sure that the code runs only for the current client (player).
    The rest of the code in the `Update()` function checks to see if the enemy is
    in sight, and makes sure the player character is facing the enemy to attack.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保代码只为当前客户端（玩家）运行。`Update()` 函数中的其余代码检查敌人是否在视野中，并确保玩家角色面向敌人进行攻击。
- en: 'If the player is in attack mode and the enemy is in our view, we set `enemyInSight`
    to `True` and `enemyToAttack` to the enemy GameObject, which is stored in the
    `hitAttack` variable of type `RacastHit`. The important element here is the `CmdEnemyToAttack()`
    function. The client needs to send a command to the server telling the server
    who the target of attack is:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家处于攻击模式，并且敌人在我们的视野中，我们将 `enemyInSight` 设置为 `True`，并将 `enemyToAttack` 设置为存储在
    `hitAttack` 变量中的敌人 GameObject，该变量类型为 `RacastHit`。这里的重要元素是 `CmdEnemyToAttack()`
    函数。客户端需要向服务器发送一个命令，告诉服务器攻击的目标是谁：
- en: '[PRE10]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will make sure that the data is registered correctly on the server and
    that it is synchronized to other clients. We also have another function, called
    `CmdEnemyTakeDamage()`, which is used to reduce the health of the enemy character
    on the server. The server then calls the `RpcEnemyTakeDamage()` function to synchronize the
    health value of the enemy across all clients:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保数据在服务器上正确注册，并且与其他客户端同步。我们还有一个名为 `CmdEnemyTakeDamage()` 的函数，用于在服务器上减少敌人角色的健康值。然后服务器调用
    `RpcEnemyTakeDamage()` 函数来同步所有客户端上的敌人健康值：
- en: '[PRE11]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This idea is a bit confusing at first, but it will be clearer as you start to
    study it more carefully.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法一开始有点令人困惑，但随着你开始更仔细地研究它，它将变得更加清晰。
- en: 'We also have the following function to send commands to the server when the
    player dies:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个函数用于在玩家死亡时向服务器发送命令：
- en: '[PRE12]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding functions make sure that the player character is dead and destroyed
    on all connected clients at the moment of the game.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数确保在游戏时刻，玩家角色在所有连接的客户端上死亡并被销毁。
- en: 'And finally, the following hook functions are used by the `SyncVar` on the
    Health and `enemyToAttack` variables:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下钩子函数被用于健康和 `enemyToAttack` 变量的 `SyncVar`：
- en: '[PRE13]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This idea is also a bit confusing at first, but it will be clearer as you start
    to study it more carefully.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法一开始可能有点令人困惑，但随着你开始更仔细地研究它，它将会变得清晰起来。
- en: If you have not done so already, apply and save all of your changes to your
    `PC-CC-Network` prefab.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请应用并保存你所有的更改到你的`PC-CC-Network`预制件。
- en: At this stage, your character is ready to be integrated with `NetworkManager`*;* you
    can drag and drop the prefab into the `Player` Prefab slot, and build a stand-alone
    version to test out your character movement and synchronization.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你的角色已经准备好与`NetworkManager`*；*集成；你可以将预制件拖放到`Player`预制件槽中，并构建一个独立版本来测试你的角色移动和同步。
- en: Networked non-player character
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络化非玩家角色
- en: Just like the player character network-enabled prefab, we will use the non-player
    character prefab as our base to get started. Go ahead and create an instance of
    your NPC in the scene.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 就像玩家角色网络启用预制件一样，我们将使用非玩家角色预制件作为我们的基础来开始。请创建场景中NPC的一个实例。
- en: 'Go ahead and remove the existing `NPC_Movement.cs` component from the prefab.
    Rename the Prefab to `B1-Network` and attach the following components to it: `NetworkIdentity`,
    `NetworkTransform`, and `NetworkAnimator`, by selecting `Add Component` *|* Network
    *|* <component name> from the Inspector window.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请从预制件中移除现有的`NPC_Movement.cs`组件。将预制件重命名为`B1-Network`，并通过从检查器窗口中选择`Add Component`
    *|* Network *|* <component name>来附加以下组件：`NetworkIdentity`、`NetworkTransform`和`NetworkAnimator`。
- en: 'On the `NetworkIdentity` component, set `Local Player Authority` to `True`*;* in
    the `NetworkTransform` component, set `Transform Sync Mode` to `Sync Transform`;
    and for the `NetworkAnimator` component, set the `Animator` slot to the `Animator`
    controller attached to the prefab, by dragging it and dropping into the slot,
    as shown in the following screenshot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NetworkIdentity`组件中，将`Local Player Authority`设置为`True`*；*在`NetworkTransform`组件中，将`Transform
    Sync Mode`设置为`Sync Transform`；对于`NetworkAnimator`组件，将`Animator`槽设置为附加到预制件的`Animator`控制器，通过将其拖放到槽中，如图所示：
- en: '![](img/00187.jpeg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00187.jpeg)'
- en: 'We now need to create a new script for our NPC movement that is network-enabled.
    Go ahead and create a new C# script, and name it `NPC_Movement_Network.cs`. A
    listing of the scripts is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要为我们的NPC移动创建一个新的网络启用脚本。请创建一个新的C#脚本，并将其命名为`NPC_Movement_Network.cs`。脚本列表如下：
- en: '[PRE14]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are a few variables that have been indicated as `SyncVars`*;* these are: `die`, `distance`, `direction`, `angle`, `playerInSight`, `fieldOfViewAngle`, `calculatedAngle`, `playerToAttack`,
    and `Health`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个变量已被标记为`SyncVars`*；*这些是：`die`、`distance`、`direction`、`angle`、`playerInSight`、`fieldOfViewAngle`、`calculatedAngle`、`playerToAttack`和`Health`。
- en: 'Take a look at the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '[PRE16]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Some of the `SyncVars` have a `hook`*;* these are `Health`, `playerToAttack`,
    `playerInSight`, and `die`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一些`SyncVars`有`hook`*；*这些是`Health`、`playerToAttack`、`playerInSight`和`die`。
- en: 'In the `Update()` function, we check to make sure we are the server by the
    following line:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update()`函数中，我们通过以下行来确保我们是服务器：
- en: '[PRE17]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we are the server, we use the `CmdUpdateNetwork()` and `RpcUpdateNetwork()`
    functions to perform our duties. These are just for the movement and action for
    the NPC. The key here is the `SyncVars` and `hook` functions that are used to
    synchronize the NPC data to all clients:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们是服务器，我们使用`CmdUpdateNetwork()`和`RpcUpdateNetwork()`函数来执行我们的职责。这些只是用于NPC的移动和动作。关键在于用于将NPC数据同步到所有客户端的`SyncVars`和`hook`函数：
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That is all we need for the NPC. Go ahead and add the script to the prefab and
    apply the changes. Save it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于NPC来说，这就足够了。请将脚本添加到预制件中并应用更改。保存它。
- en: 'Your new NPC prefab should have the following components attached:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新NPC预制件应该附加以下组件：
- en: Synchronizing player customization and items
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步玩家自定义和物品
- en: In order for this to work, we need to perform configure and create several more
    new inventory item prefabs. I will use two inventory items to demonstrate this
    particular point.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这起作用，我们需要配置并创建几个更多的新的库存物品预制件。我将使用两个库存物品来演示这个特定的点。
- en: I will use one of the `Helmet` prefabs from my inventory items. Duplicate it,
    and remove the `InventoryItemAgent.cs` component. We will create a new script
    that is network-enabled, as we did for our PC and NPC.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用我库存物品中的一个`Helmet`预制件。复制它，并移除`InventoryItemAgent.cs`组件。我们将创建一个新的网络启用脚本，就像我们为我们的PC和NPC所做的那样。
- en: 'Attach the following components to the instance: `NetworkIdentity` and `NetworkTransform`,
    using Add Component | Network | <component name> from the Inspector window*:*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下组件附加到实例上：`NetworkIdentity`和`NetworkTransform`，从检查器窗口使用添加组件 | 网络 | `<组件名称>`：*
- en: '![](img/00188.jpeg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00188.jpeg)'
- en: 'Create a new script named `InventoryItemAgent_Network.cs`. The listing is as
    follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`InventoryItemAgent_Network.cs`的新脚本。如下所示：
- en: '[PRE19]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: All this script does is assign the inventory item to the player character using
    the `PlayerArmourChanged()` function in the `CharacterController_Network.cs` script.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些脚本所做的只是使用`CharacterController_Network.cs`脚本中的`PlayerArmourChanged()`函数将库存物品分配给玩家角色。
- en: The `PlayerArmourChanged()` function uses another script we need to create that
    is network enabled, and that is the `CharacterCustomization_Network.cs` script.
    I will not list the script here as it is very long. You can look at the script
    in the code supplied with the book.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerArmourChanged()`函数使用我们需要创建的另一个脚本，这是一个网络启用脚本，即`CharacterCustomization_Network.cs`脚本。我不会在这里列出脚本，因为它非常长。您可以在书中提供的代码中查看脚本。'
- en: Spawning NPCs and other items
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成NPC和其他物品
- en: We need a way to spawn our NPC as well as the inventory items we will be using
    for the next demonstration.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来生成我们的NPC以及我们将用于下一个演示的库存物品。
- en: In the Hierarchy window, right-click and select Create Empty*;* this will create
    an `Empty` GameObject. Rename it `SpawnEnemy`, and add a `NetworkIdentity` component
    to it by selecting Add Component | Network | NetworkIdentity from the Inspector
    window.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次结构窗口中，右键单击并选择创建空对象*；*这将创建一个`Empty`GameObject。将其重命名为`SpawnEnemy`，并通过从检查器窗口选择添加组件
    | 网络 | 网络身份将其添加一个`NetworkIdentity`组件。
- en: 'We will create a new script called `EnemySpawn_Network.cs`. The listing is
    as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`EnemySpawn_Network.cs`的新脚本。如下所示：
- en: '[PRE20]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The script is very simple, as you can see. We are just referencing the GameObjects
    that represent the prefabs for the NPC and inventory items prefab.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，脚本非常简单。我们只是引用代表NPC和库存物品预制件的GameObject。
- en: Attach the new script to the `SpawnEnemy` prefab in the Hierarchy Window.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次结构窗口中，将新脚本附加到`SpawnEnemy`预制件上。
- en: Testing our network-enabled PC and NPC
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的网络启用PC和NPC
- en: At this point, we have all of the assets needed to test out our network-enabled
    RPG characters. There is one final step that we need to perform if you have not
    done so already.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经拥有了测试我们的网络启用RPG角色所需的全部资产。如果您还没有这样做，我们需要执行一个最后的步骤。
- en: Select the `NetworkManager` GameObject in the Hierarchy window, and from the
    Inspector window, you will need to make sure certain things have been assigned
    in the *Spawn* Info section.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次结构窗口中选择`NetworkManager`GameObject，并在检查器窗口中，您需要确保在*生成*信息部分已经分配了某些内容。
- en: '*Player Prefab* should be assigned to your player character prefab. Mine is
    named `PC-CC-Network-1`. Make sure Auto Create Player is set to `True`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*玩家预制件*应该分配给您的玩家角色预制件。我的名字叫`PC-CC-Network-1`。确保自动创建玩家设置为`True`。'
- en: You will also register your NPC prefabs and other network-enabled non-character
    prefabs in the Registered Spawnable Prefabs. I have the barbarian prefab named
    `B1-Network-1` assigned, `barbarian_helmet_01_LOD0_Network`, and `shield_01_LOD0_Networ`*k*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在“已注册可生成预制件”中注册你的NPC预制件和其他网络启用非角色预制件。我已经将名为`B1-Network-1`的野蛮人预制件分配，`barbarian_helmet_01_LOD0_Network`，以及`shield_01_LOD0_Networ`*k*。
- en: 'Take a look at the following screenshot:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的屏幕截图：
- en: '![](img/00189.jpeg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00189.jpeg)'
- en: 'Alright, at last, we can do a build. Let''s go ahead and make a stand-alone
    build of our game. Make sure that the current scene is in the build configuration:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，最后，我们可以进行构建。让我们继续制作我们游戏的独立构建。确保当前场景在构建配置中：
- en: '![](img/00190.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00190.jpeg)'
- en: Go ahead and launch two instances of the build. Make one of them the host, and
    the other the client.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，继续启动两个构建实例。其中一个作为主机，另一个作为客户端。
- en: 'Take a look at the following screenshot:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的屏幕截图：
- en: '![](img/00191.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00191.jpeg)'
- en: 'In the preceding screenshot, we have started a client as a server and the player
    character has picked up one of the inventory items, a shield. When we connect
    the second client, it should correctly take into consideration the current state
    of all PCs and NPCs active in the game:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们已经启动了一个作为服务器的客户端，玩家角色已经拿起了一个库存物品，一个盾牌。当我们连接第二个客户端时，它应该正确考虑游戏中所有活跃的PC和NPC的当前状态：
- en: '![](img/00192.jpeg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00192.jpeg)'
- en: Keeping both of the instances running, use the Unity IDE to connect the third
    client. You can use the client to perform debugging on the client end, and also
    to see what is going on.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 保持两个实例运行，使用Unity IDE连接第三个客户端。你可以使用客户端在客户端端进行调试，并查看正在发生的事情。
- en: 'Take a look at the following screenshot:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图：
- en: '![](img/00193.jpeg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00193.jpeg)'
- en: In the preceding screenshot, you can see all of the player characters and how
    they have been accurately synchronized with one another. Select B1-Network-1 GameObject
    from the Hierarchy Window, and use one of the client instances to take the player
    character and attack the NPC.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到所有玩家角色以及它们是如何被准确同步的。从层次窗口中选择B1-Network-1 GameObject，并使用一个客户端实例来控制玩家角色攻击NPC。
- en: 'We will pause the editor and inspect the variables and how they have been properly
    synchronized, as shown in the following screenshot:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将暂停编辑器，检查变量以及它们是如何被正确同步的，如下面的截图所示：
- en: '![](img/00194.jpeg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00194.jpeg)'
- en: What's next?
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: As you have witnessed, network programming is simple, but at the same time,
    it can be difficult. The difficulty lies in managing and understanding the synchronization
    of the data between all players in an efficient and meaningful way.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见证的，网络编程很简单，但同时也可能很困难。困难在于以高效和有意义的方式管理和理解所有玩家之间的数据同步。
- en: It can actually get a bit more involved if you are truly considering creating
    a game with a large number of clients. Unity networking will not be able to handle
    that; you will need to create your own backend server managers and messaging systems.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真正考虑创建一个拥有大量客户端的游戏，实际上可能会更加复杂。Unity网络将无法处理这种情况；你需要创建自己的后端服务器管理器和消息系统。
- en: What we have covered in this chapter will give you a good understanding to take
    it to the next level. Keep on coding until we meet again!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所涵盖的内容将为你提供一个很好的理解，以便将其提升到下一个层次。继续编码，直到我们再次见面！
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we looked at network programming using the Unity networking
    components. The main objective of the chapter was to introduce you to the fundamentals
    of networking in Unity by implementing two samples.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了Unity网络组件来研究网络编程。本章的主要目标是通过对两个示例的实现，向您介绍Unity网络的基础。
- en: We started the chapter by discussing some of the challenges you will face as
    a game designer and developer for a multiplayer game. One of the main questions
    raised is whether you really need to invest the time and energy to create a multiplayer
    mode for your game. Assuming you really do want or need to create a multiplayer
    game, we started by looking at the different types of multiplayer games popular
    today.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章开始时讨论了作为多人游戏的游戏设计师和开发者可能会面临的挑战。提出的主要问题之一是，你是否真的需要投入时间和精力为你的游戏创建多人模式。假设你真的想要或需要创建多人游戏，我们首先研究了目前流行的不同类型的多人游戏。
- en: We then went on with our first example of a simplified multiplayer game. The
    multiplayer game we developed are real-time, that is, all clients are synchronized
    with one another based on the activity on each active player's state; namely,
    the position, rotation, movement, and other important data needs to be synchronized
    with all clients connected to the game session.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续我们的第一个简化版多人游戏的示例。我们开发的多人游戏是实时的，也就是说，所有客户端都是基于每个活跃玩家状态的活动同步的；也就是说，位置、旋转、移动和其他重要数据需要与所有连接到游戏会话的客户端同步。
- en: We looked at the fundamentals of Unity's networking components, such as the
    Network Manager, Network Manager HUD, Network Identity, and Network Transform.
    These are the base components that are used to illustrate multiplayer programming
    in Unity. Once we understood what these components are used for, we started with
    a simple sample.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了Unity网络组件的基础，例如网络管理器、网络管理器HUD、网络身份和网络变换。这些是用于说明Unity中多人编程的基础组件。一旦我们了解了这些组件的用途，我们就从一个简单的示例开始。
- en: We created a simple tank game that demonstrated how to put together all of the
    essential components for a multiplayer game. We created the necessary player character
    prefab with the appropriate network-enabled scripts and components. We also created
    the non-player character prefab with its own network-enabled scripts. The game
    demonstrates how to spawn, and how to synchronize between the player characters
    and non-player characters.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的坦克游戏，展示了如何将多人游戏所需的所有基本组件组合在一起。我们创建了必要的玩家角色预制体，并添加了适当的网络启用脚本和组件。我们还创建了非玩家角色预制体，并为其添加了自身的网络启用脚本。游戏演示了如何生成玩家角色和非玩家角色，以及如何在它们之间进行同步。
- en: During the construction of the tank game, we covered how to synchronize variables
    and use network callbacks that are crucial for the development of a multiplayer
    game. We also covered what *Commands* and *ClientRPC* calls are and how to use
    them properly.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建坦克游戏的过程中，我们介绍了如何同步变量和使用对多人游戏开发至关重要的网络回调。我们还解释了什么是*命令*和*ClientRPC*调用，以及如何正确使用它们。
- en: Next, we applied what we learned to the RPG characters we developed in previous
    chapters. We used the existing prefabs as a base, and extended them to include
    the networking components and create new network-enabled scripts to handle the
    character movement, character customization, and NPC movement scripts.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将所学知识应用到之前章节中开发的RPG角色上。我们以现有的预制体为基础，扩展了它们以包含网络组件，并创建了新的网络启用脚本以处理角色移动、角色定制和非玩家角色移动脚本。
- en: One of the crucial elements that we covered is the synchronization of each player
    character's inventory items visually with the rest of the players. We closed the
    chapter by testing and discussing how to debug your code on the client and the
    server while developing your multiplayer game.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的一个关键元素是，如何将每个玩家角色的库存物品在视觉上与其他玩家同步。我们在章节的最后通过测试和讨论如何在开发多人游戏时调试客户端和服务器上的代码来结束本章。
