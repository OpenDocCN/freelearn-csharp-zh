- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UI Images and Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve worked with UI Images in the previous chapters, but now we’ll learn more
    about the component’s specific properties, as well as how to access the component
    via code. We’ll also look at some of the UI effect components that we can apply
    to our UI objects for visual appeal. While we will look at the components thoroughly,
    the majority of this chapter focuses on specific worked-out examples of UI functionality
    that you will find in video games, particularly mobile video games.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating UI Images and setting their properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the various UI effects components to further customize our graphical UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing horizontal and circular progress bars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create Buttons that swap sprites without using the built-in transitions,
    like a mute/unmute Button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a press-and-hold/long-press functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an onscreen four-directional virtual D-Pad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a floating eight-directional virtual analog stick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All the examples shown in the sections before the *Examples* section can be
    found within the Unity project provided in the code bundle. They can be found
    within the scene labeled **Chapter11**.
  prefs: []
  type: TYPE_NORMAL
- en: Each example figure has a caption stating the example name within the scene.
  prefs: []
  type: TYPE_NORMAL
- en: In the scene, each example is on its own Canvas, and some of the Canvases are
    deactivated. To view an example on a deactivated Canvas, simply select the checkbox
    next to the Canvas’ name in the Inspector. Each Canvas is also given its own Event
    System. This will cause errors if you have more than one Canvas activated at a
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the relevant codes and asset files of this chapter here: [https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2011](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2011)'
  prefs: []
  type: TYPE_NORMAL
- en: UI Image component properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve created a UI Image before, but let’s look at its properties and components.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a new UI Image object using **+** | **UI** | **Image**.
  prefs: []
  type: TYPE_NORMAL
- en: The UI `Image` object contains the **Rect Transform** and **Canvas Renderer**
    components as well as the **Image** component. We’ve looked at the **Rect Transform**
    and **Canvas Renderer** components extensively; now, let’s look at the **Image**
    component.
  prefs: []
  type: TYPE_NORMAL
- en: The first setting on the **Image** component is the **Source Image** property,
    which represents the sprite that will be rendered. The **Color** property represents
    the base color of the sprite being rendered. Leaving the color at white will make
    the Image appear exactly as the sprite, but changing the color will add a tinted
    color overlay to the Image. You can also change the transparency of the Image
    by reducing the alpha value. The **Material** property allows you to add a material
    to the Image.
  prefs: []
  type: TYPE_NORMAL
- en: The **Raycast Target** and **Raycast Padding** properties work the same way
    they do on the **Text** component, by specifying whether the Image will block
    clicks on UI objects behind it or not and if there is any padding to the block.
    The **Maskable** property determines if the Image can be affected by masks or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a sprite is assigned to the **Source Image** slot, new options appear
    in the **Image** component under **Image Type**, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: The UI Image component and all its properties](img/B18327_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: The UI Image component and all its properties'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the various options for **Image Type** and how they affect a sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Image Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Image Type** property determines how the sprite specified by **Source
    Image** will appear. There are four options: **Simple**, **Sliced**, **Tiled**,
    and **Filled**. Let’s take a look at them.'
  prefs: []
  type: TYPE_NORMAL
- en: Simple
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An Image with its **Image Type** property set to **Simple** scales evenly across
    the sprite. This is the default type. When **Simple** is selected as the **Image
    Type**, a toggle labeled **Use Sprite Mesh**, a toggle labeled **Preserve Aspect**,
    and a button labeled **Set Native Size** become available.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the **Use Sprite Mesh** toggle will have the Image use the sprite
    mesh created by the **TextureImporter**. By default, this property is deselected,
    and the sprite’s mesh is a quad. You will select this property if you don’t want
    the Image represented by a rectangle, but instead want it to have a mesh that
    fits tightly around the visible area of the Image.
  prefs: []
  type: TYPE_NORMAL
- en: When the **Preserve Aspect** property is checked, the sprite will display with
    its portions preserved and may not appear to fill the entire area of the Rect
    Transform. Selecting this property ensures that your sprites look as originally
    intended and are not stretched out.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the **Set Native Size** button sets the dimensions of the Image to
    the pixel dimensions of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Sliced
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sliced** Images are split into nine areas. When a **Sliced** Image is scaled,
    all areas of the Image are scaled, except the corners. This allows you to scale
    an Image without distorting its corners. This works particularly well with sprites
    that have rounded corners that you want to be able to stretch into rounded rectangles.'
  prefs: []
  type: TYPE_NORMAL
- en: When an image is set to **Sliced**, the **Fill Center** and **Pixels Per Unit
    Multiplier** properties appear. The following figure shows a rounded rectangle
    with five alternate versions of it being stretched. You can see how selecting
    **Sliced** allows the rounded rectangle to stretch in a way that maintains the
    rounded rectangle shape while leaving the **Image Type** at **Simple** causes
    a distortion in the edges of the Image when it is scaled.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: Sliced Image Type Example in the Chapter11 scene](img/B18327_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Sliced Image Type Example in the Chapter11 scene'
  prefs: []
  type: TYPE_NORMAL
- en: You must specify where the nine areas will be, within the **Sprite Editor**
    of the sprite or sprite sheet. If you have not specified the regions, a message
    will appear within the **Image** component.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify the area in the **Sprite Editor**, you need to drag the green boxes
    on the edges of the sprite to the desired position. As you can see from the following
    screenshot, you want to drag the green lines so that they stop surrounding the
    curves of the edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: Specifying the nine areas of a sprite in the Sprite Editor](img/B18327_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Specifying the nine areas of a sprite in the Sprite Editor'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s talk about the **Tiled** option under the **Image Type**.
  prefs: []
  type: TYPE_NORMAL
- en: Tiled
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Selecting **Tiled** for **Image Type** will cause the Image to repeat to fill
    the stretched area. The following figure demonstrates how selecting **Simple**
    and **Tiled** for **Image Type** affects the scaled Images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4: Tiled Image Type Example in the Chapter11 scene](img/B18327_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Tiled Image Type Example in the Chapter11 scene'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s talk about the **Filled** option under the **Image Type**.
  prefs: []
  type: TYPE_NORMAL
- en: Filled
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Images with **Filled** selected for their **Image Type** will fill in a percentage
    of the sprite, starting at an origin in a specified direction. Any part of the
    sprite past the designated percentage will not be rendered. When **Filled** is
    selected, new properties are displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5: Properties for a Filled Image](img/B18327_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Properties for a Filled Image'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `0.75` or 75 percent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6: Filled Image Type Example in the Chapter11 scene](img/B18327_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: Filled Image Type Example in the Chapter11 scene'
  prefs: []
  type: TYPE_NORMAL
- en: The **Horizontal** and **Vertical** **Fill Method** options are somewhat self-explanatory
    when you see them in action, but it’s a little more difficult to determine exactly
    how the three radial methods work just from looking at them. **Radial 90** places
    the center of the radial at one of the corners, **Radial 180** places the center
    of the radial at one of the edges, and **Radial 360** places the center of the
    radial in the center of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: The **Filled** **Image Type** option also has the **Set Native** **Size** property.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explored the UI Image component, we can look at some UI effect
    components.
  prefs: []
  type: TYPE_NORMAL
- en: UI effect components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Three effects components allow you to add special effects to your Text and
    Image objects: **Shadow**, **Outline**, and **Position as UV1**. They can all
    be found under **Add Component** | **UI** | **Effects**. Let’s look at each one
    individually, starting with the Shadow component.'
  prefs: []
  type: TYPE_NORMAL
- en: Shadow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Shadow** component adds a simple shadow to your Text or Image object.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7: The Shadow component](img/B18327_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: The Shadow component'
  prefs: []
  type: TYPE_NORMAL
- en: You can change the color and transparency of the shadow with the `0`, rendering
    it invisible, the shadow would remain visible based on the alpha specified on
    the **Effect** **Color** property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows a few examples of the **Shadow** component in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8: Shadow Component Example in the Chapter11 scene](img/B18327_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: Shadow Component Example in the Chapter11 scene'
  prefs: []
  type: TYPE_NORMAL
- en: All four bananas have the same alpha value set on their `0`, but since **Use
    Graphic Alpha** is not selected on the **Shadow** component, the shadow did not
    dim with the banana and remains at its designated alpha value.
  prefs: []
  type: TYPE_NORMAL
- en: Outline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Outline** component simulates an outline around the graphic by creating
    four shadows around it at specified distances.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9: The Outline component](img/B18327_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: The Outline component'
  prefs: []
  type: TYPE_NORMAL
- en: The **Outline** component will create two shadows to the left and right of the
    original graphic based on **Effect Distance X** and two shadows to the top and
    bottom of the original graphic based on **Effect Distance Y**. Unlike the **Shadow**
    component, there is no difference in a negative or positive value for these two
    distances because the two shadows created for each axis are mirrored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the `-3` essentially just switches the positions of the two horizontal
    shadows, but the effect looks the same, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10: Outline Component Example 1 in the Chapter11 scene](img/B18327_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.10: Outline Component Example 1 in the Chapter11 scene'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Use Graphic Alpha** property works identically on this component as it
    does on the **Shadow** component, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11: Outline Component Example 2 in the Chapter11 scene](img/B18327_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.11: Outline Component Example 2 in the Chapter11 scene'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at the **Position As** **UV1** component.
  prefs: []
  type: TYPE_NORMAL
- en: Position As UV1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Position As UV1** component allows you to change the UV channel that the
    Canvas renders on. This is used if you want to create custom shaders that utilize
    baked light maps.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12: The Position As UV1 component](img/B18327_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.12: The Position As UV1 component'
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, custom shaders are a pretty heavy topic and go past the scope of this
    text, so I won’t go any further into the usage of this component.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve reviewed the UI Image component and some UI effect components,
    let’s look at some examples of ways we can use these components.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll expand on the scene we’ve been building further by adding
    some new UI elements. We’ll also look at some mobile/touchscreen UI and interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these examples may seem better suited for the chapter on Buttons, but
    since they include access to the Image component’s properties, I placed them here.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created two scenes that load into the scene we’ve been building upon:
    a start screen and an intro scene. Since I’ve been duplicating our main scene
    to make progress from each chapter easy to track, our intro sScene will not navigate
    to the updates we make in this and future chapters unless we keep updating the
    **Next Scene** variable on our **Dialogue Boxes** component in the intro sScene
    and including the new scene in our **Build Settings**.'
  prefs: []
  type: TYPE_NORMAL
- en: I will not be including this update in the steps since scene navigation is no
    longer a focus of these examples. However, it will be included in the packages
    I include in each chapter’s completed scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal and circular health/progress meters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s get back to our main scene. Duplicate the `Chapter10-Examples` scene to
    create a `Chapter11-Examples` scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll cover how to create two types of progress meters, a
    horizontal one and a circular one, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13: Example of horizontal and vertical progress bars](img/B18327_11_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.13: Example of horizontal and vertical progress bars'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll hook up the circular and horizontal progress meters so that they both
    display the progress of the same variable, and we can watch them both change at
    the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The circular progress meter doesn’t really fit in the main scene that we’ve
    been building, and we’ll hide it after this chapter, but circular progress bars
    are common game elements, so I thought it was important to include an example
    of how to do them in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal health bar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a few different ways that a horizontal health bar can be created,
    but the quickest and easiest way is to scale a single axis based on percentage.
    When setting up a horizontal health bar in this way, it is important to ensure
    that the anchor is set at a position that represents a completely depleted bar.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that back in [*Chapter 6*](B18327_06.xhtml#_idTextAnchor085), we set
    the anchor of the health bar to the left, so we have already set the anchor correctly.
    We also scaled the health bar in the *x* direction to show what the bar would
    look like as it depleted.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18327_11_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.14: The Health Bar’s Rect Transform component'
  prefs: []
  type: TYPE_NORMAL
- en: Now, all we need to do is tie the percentage to the **X Scale** value of the
    health bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'To tie the fill of the health bar to an actual value, complete the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# script in your `Scripts` folder and name it `ProgressMeters.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `ProgressMeters` script, initialize the following four variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `health` variable represents the current health of the player, and the `totalHealth`
    variable represents the total health the player can obtain. As it doesn’t make
    sense for these values to be negative, they have been initialized at the `uint`
    type or a positive integer. I have made the `health` variable `public` so that
    it can be accessed via other scripts and seen within the Inspector. I made `totalHealth`
    a private `SerializeField` so that it cannot be accessed via other scripts but
    still be seen and assigned via the Inspector.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `percentHealth` variable will be calculated based on the quotient of the
    `health` and `totalHealth` variables. I made this value private and serialized,
    not so that we can edit it in the Inspector but so that we can easily see its
    value change in the Inspector.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `healthBar` variable stores the `RectTransform` component of the `Health
    Bar` UI Image within our scene.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since **RectTransform** inherits from **Transform**, we could have declared
    **healthBar** as a **Transform** and the following code would still work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to the Unity Editor and drag the `ProgessMeters` script onto `HUD Canvas`
    > `Top Left Panel`. Assign the value `500` to both the `Health Bar` UI Image into
    the **Health Bar** slot. Any value you try to type into the **Percent Health**
    slot will be overridden by the code we write in the next step. Your component
    should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.15: The Progress Meters component](img/B18327_11_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.15: The Progress Meters component'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want any changes made to our `health` value to automatically update the
    `percentHealth` value and the scale of our `healthBar`. To do that, we can put
    the following code in the `Update()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Declaring our `health` and `totalHealth` variables with the `uint` type stopped
    them from becoming negative, but we still need to put an upper cap on our `health`
    variable. It doesn’t make sense for it to exceed the `totalHealth` variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: While `percentHealth` is a `float` variable, performing a division between two
    `uint` variables will result in a `uint` type, so adding `(float)` at the beginning
    of the integer division provides a `float` result from the division.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The last part of the code sets the `localScale` value of the `healthBar`. When
    you scale a UI object, you have to use `localScale`. This scales the object locally,
    meaning relative to its parent object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can test the code easily in the Editor. Play the game and hover your
    mouse over the word **Health** in the **Progress Meters** component until the
    mouse displays two arrows around it, as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.16: The Progress Meters component’s effect on the meter](img/B18327_11_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.16: The Progress Meters component’s effect on the meter'
  prefs: []
  type: TYPE_NORMAL
- en: When these arrows appear, clicking and dragging will manipulate the values of
    the variable based on your mouse position. You’ll see, as you do this, that as
    the `Health Bar` in the scene changes size. You’ll note that you cannot set the
    value of `0` or above `500`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, setting up a horizontal health bar isn’t terribly difficult.
    Duplicating this process in a game where the health reduces by Events won’t require
    a lot of steps to achieve. Just ensure that you set the anchor of the health bar
    correctly. This process will work similarly for a vertical health bar.
  prefs: []
  type: TYPE_NORMAL
- en: Circular progress meter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Horizontal health bars didn’t take a lot of work to set up. The work to make
    a circular progress meter is just about as easy and can be completed with only
    two more lines of code. Since we don’t already have a circular progress bar in
    our scene, we will have to start with a bit of setup first.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a circular progress bar, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the code bundle, drag the `circularMeter.png` sprite into the `Sprites`
    folder of your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `circularMeter.png` sprite to **Multiple** and automatically slice it
    in the **Sprite Editor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Top Left Panel` within the Hierarchy and give it a new UI Image
    child. Name the Image `Progress Holder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similar to how we set up the health bar, there will be a holder and a fill.
    Drag the `circularMeter_0` sub-sprite into the `Progress Holder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s important that we get the right proportions for our holder and fill Images.
    So, to ensure that the Image is correctly proportioned, hit the **Set Native Size**
    button on the **Image** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, add a child UI Image to `Progress Holder` called `Progress Meter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the anchor preset of `Progress Meter` to middle center. Do not stretch it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `circularMeter_1` to the `Progress Meter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hit the `Progress Meter` **Image** component as well. After completing this
    step, you should see the following:![Figure 11.17: The progress on the Progress
    Meter](img/B18327_11_17.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.17: The progress on the Progress Meter'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the pink fill is not perfectly nestled inside the blue holder, you may have
    forgotten to hit the `Progress Meter` does not have its anchor preset set to middle
    center.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s move this meter and scale it a bit. Select `Progress Holder` and move
    it so that it is positioned in the scene below `Character Holder`. Set the `Progress
    Holder` to `0.8` to make it a little smaller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.18: Repositioning the circular progress meter](img/B18327_11_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.18: Repositioning the circular progress meter'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do to the code is to change the `Progress Meter`. Change
    the **Image Type** to **Filled** with a **Radial 360 Fill Method**. Change the
    **Fill Origin** to **Top**. Adjust the scroll bar on the **Fill Amount** to preview
    the meter filling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.19: Adjusting the fill amount on the circular progress meter](img/B18327_11_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.19: Adjusting the fill amount on the circular progress meter'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we’re ready to write some code. As you have probably guessed from adjusting
    the `fillAmount` value to the `percentHealth` variable in our code. First, we
    need to create a variable with which we can access the Image component of our
    `Progress Meter`. Declare the following variable at the top of your code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the following at the end of the `Update()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last thing we need to do is hook the `Progress Meter` UI Image to the `progressMeter`
    variable. Drag the `Progress Meter` into the **Progress** **Meter** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.20: The Progress Meter component’s updates](img/B18327_11_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.20: The Progress Meter component’s updates'
  prefs: []
  type: TYPE_NORMAL
- en: Play the game and adjust the **Health** value in the Inspector as you did earlier,
    and watch the two meters move in unison.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.21: Result of the Progress Meter](img/B18327_11_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.21: Result of the Progress Meter'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, making a circular progress meter is really not more difficult
    than making a horizontal one!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the same way we used the fill amount for the circular progress bar, we could
    have used the fill amount for the horizontal health bar. Setting the **Image Type**
    property to **Filled** and **Horizontal** and then affecting the **Fill Amount**
    value rather than the scale would have had a similar effect.
  prefs: []
  type: TYPE_NORMAL
- en: Because this circular progress meter wasn’t part of the original UI plan and
    was only placed in the scene for demonstration purposes, I am going to disable
    it in all future figures and screenshots.
  prefs: []
  type: TYPE_NORMAL
- en: Mute Buttons with sprite swap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s look at an example where we swap the sprite of a Button based on
    a pre-defined state. This is different than a sprite swap transition, which we
    discussed in [*Chapter 9*](B18327_09.xhtml#_idTextAnchor213), because it won’t
    use the states of highlighted, pressed, selected, or disabled. It’s included in
    this chapter rather than the Buttons chapter since it involves affecting the Image
    component, not the Button component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the scene, we have a `Pause Panel` that pops up when the *P* key is hit
    on the keyboard. On this Panel, we will place two mute Buttons, one for music
    and one for sound, which will toggle between muted and unmuted states. The Panel
    will appear as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.22: The Pause Panel with new mute Buttons](img/B18327_11_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.22: The Pause Panel with new mute Buttons'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the music and sound Buttons shown in the preceding screenshot, complete
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to bring in a new art asset. The Button sprites on the sprite
    sheet we imported previously are a bit too small and don’t contain a muted version.
    So, I edited them a bit and provided a new sprite for you. In the book’s source
    files, you should find an `.png` file named `muteUnmute.png`:![Figure 11.23: The
    muteUnmute.png sprite](img/B18327_11_23.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.23: The muteUnmute.png sprite'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Import this `.png` file into your project’s `Assets/Sprites` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Slice the sprite into multiple sub-sprites by changing its **Sprite Mode**
    to **Multiple**, opening its **Sprite Editor**, and applying the automatic slice
    type. Multiple sprites should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.24: The muteUnmute.png sprite sliced](img/B18327_11_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.24: The muteUnmute.png sprite sliced'
  prefs: []
  type: TYPE_NORMAL
- en: Create two new Buttons as children of the `Pause Panel` and name them `Music
    Button` and `Sound Button`. Delete their text children because we do not need
    them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.25: The current view of the Hierarchy](img/B18327_11_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.25: The current view of the Hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Give the two new Buttons the following **Rect Transform** and **Image** properties:![Figure
    11.26: The Rect Transform of the two Buttons](img/B18327_11_26.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.26: The Rect Transform of the two Buttons'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Your Panel should now look just like the one at the beginning of this example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.27: The Pause Panel](img/B18327_11_27.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.27: The Pause Panel'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let’s write some code to make these Buttons swap sprites that will represent
    the sound and music toggling on and off. Create a new script called `MuteUnmute.cs`
    in your `Assets/Scripts` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the code of `MuteUnmute` with the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, this code contains two main functions: `ToggleMusic()` and
    `ToggleSound()`. These two function identically by simply swapping the sprite
    on the specified Button based on the `musicOn` and `soundOn` Boolean values.'
  prefs: []
  type: TYPE_NORMAL
- en: To swap the sprite, the script first finds the Image component on the two Buttons
    specified as `musicButton` and `soundButton`, within the `Awake()` function. These
    Buttons will be assigned in the Inspector. It then swaps the sprite of the Image
    component to the correct sprite from an array of sprites. The sprites for the
    mute and unmute states will be assigned in the Inspector in a future step.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Sadly, this book does not cover adding sound and music to a Unity project.
    The code provided here doesn’t actually mute and unmute audio; it simply swaps
    sprites. You will simply need to include two audio sources: one for playing music
    and one for playing sounds that have the **Music** and **Sound** tags, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the Unity Editor and attach the `MuteUnmute.cs` script to the `Pause
    Panel` by dragging it into its **Inspector**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.28: The Mute Unmute component](img/B18327_11_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.28: The Mute Unmute component'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we want to assign the appropriate Buttons and sprites to the slots. Drag
    the `Music Button` and `Sound Button` into their designated slots from the Hierarchy.
    Drag and drop the audio Button sprites from the project view to their appropriate
    slots, making sure to put the muted sprite in the 0 element of the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.29: The updated Mute Unmute component](img/B18327_11_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.29: The updated Mute Unmute component'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we just need to hook up the Buttons to call the appropriate functions.
    Select the `Music Button`. Select the `OnClick()` Event list of the `MuteUnmute.cs`,
    is on the `Pause Panel`, so drag the `Pause Panel` into the object slot. Now,
    from the function dropdown menu, select **MuteUnmute** | **ToggleMusic**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform the same actions as you did in the previous step for the `Sound Button`,
    but this time select **MuteUnmute** | **ToggleSound** from the function dropdown
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, play the game, press *P* to bring up the `Pause Panel`, and you will see
    the Buttons toggle back and forth between their two different sprites.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at how to implement progress meters and sprite swap Buttons,
    let’s look at how to implement a few different mobile-specific interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding press-and-hold/long-press functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Press-and-hold is utilized frequently in mobile games. Many games that use right-click
    on a PC or the web use press-and-hold when they are converted to the mobile platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how to implement press-and-hold functionality, we will create
    a Button that has a growing ring that represents hold time. Once a specified amount
    of time has passed, a function will fire:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.30: Press-and-hold Button example](img/B18327_11_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.30: Press-and-hold Button example'
  prefs: []
  type: TYPE_NORMAL
- en: When working on this example, it is important to remember that even though the
    code is referencing a pointer, this functionality does not work exclusively with
    a mouse. Placing a finger on a touchscreen functions in the same way as a pointer
    down, and picking up the finger works the same as a pointer up.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a Button with a growing ring that represents hold time, complete
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene named `Chapter11-Examples-Buttons1` in the `Assets/Scenes`
    folder and open the new scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **+** | **UI** | **Button** to create a new Button in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Button’s **Transition** type on the **Button** component to **None**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the text on the Button to say `Press` `and Hold`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `Button` in the Hierarchy and select `Image` child to the `Button`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `Image`’s `50`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the `circularMeter_1` sprite to the **Source Image** property of the
    **Image** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create press-and-hold functionality on the `Button`, we will utilize the
    `Button` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Add New Event Type** and select **PointerDown**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Add New Event Type** and select **PointerUp**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to actually write the functions that will be called by the Event
    Triggers we set up in the previous steps. Create a new script in the `Assets/Scripts`
    folder called `LongPressButton`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before opening the script, go ahead and attach it as a component to `Button`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `UnityEngine.UI` namespace to the top of the script with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check how long the Button is being pressed, we will use a Boolean variable
    that checks to see if the Button is being held and a few different variables related
    to time. Add the following variable declaration to your script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `buttonPressed` variable will be set to `true` with the `startTime` variable
    will be set to the current time when the `holdTime` variable will determine how
    much time has passed since `startTime`. The `longHoldTime` variable is the amount
    of time the Button must be held down before the long press is complete. It is
    serialized so that it can be easily customized.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last variable we need will represent the radial filling Image. Add the
    following variable declaration to your code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to write a function that will be called by both the **Pointer
    Down** and **Pointer** **Up** Events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function accepts a Boolean variable from the Event Trigger. It then sets
    the value of `buttonPressed` to the passed value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When the Button is released, a value of `false` will be passed to the function.
    If the value passed is `false`, the amount of time that has passed, `holdTime`,
    is reset to `0`, and the `radialFillImage` Image is reset to have a `fillAmount`
    value of `0`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When the Button is pressed, the `startTime` value will be set to the current
    time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a function that will be called once the full amount of time needed for
    the long press, specified by `longHoldTime`, has completed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function doesn’t really do anything but reset the filling Image and print
    out a `Debug.Log`. However, you can later reuse this code and replace the `Debug.Log`
    line with more interesting and meaningful actions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `Update()` function can be used to make the timer count upward. Adjust
    the `Update()` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code makes the value of `holdTime` tick upward if the `buttonPressed` value
    is set to `true`. Remember—`buttonPressed` will be set to `true` with a `false`
    with a `holdTime` value reaches the value specified by `longHoldTime`, the timer
    will stop ticking up, because `buttonPressed` will be reset to `false`. Additionally,
    the `LongPressCompleted()` function is called. If `longHoldTime` has not yet been
    reached, the Image’s radial fill will update to represent the percentage of total
    required time that has transpired.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that the script is completed, we can hook up the `PressAndRelease()` function
    with the Event Triggers on the Button. Add the `PressAndRelease` function from
    the static list to both the `PressAndRelease()` function accepts a Boolean variable,
    there is a checkbox representing the Boolean value that should be passed. Select
    the checkbox for the `true`) but not for the `false`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.31: The Event Trigger component](img/B18327_11_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.31: The Event Trigger component'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to assign the `Image` to the **Radial Fill Image** slot on the
    **Long** **Press** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.32: The Long Press component](img/B18327_11_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.32: The Long Press component'
  prefs: []
  type: TYPE_NORMAL
- en: Playing the game now will demonstrate the Image radially filling when you hold
    the Button and printing `Do something after long press` in the console. If you
    release the Button before the fill has completed, it will go away and reset for
    when you start clicking again.
  prefs: []
  type: TYPE_NORMAL
- en: Press-and-hold is a pretty common functionality, and while it isn’t a pre-installed
    Event in the Unity Event library, luckily it isn’t too difficult to hook up. I
    recommend holding on to that script so that you can reuse it in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a static four-directional virtual D-Pad
  prefs: []
  type: TYPE_NORMAL
- en: A D-Pad is simply four Buttons on a directional pad. To create a D-Pad for a
    mobile game, you just need to create a graphic that contains four Buttons on the
    directions.
  prefs: []
  type: TYPE_NORMAL
- en: The art used in this example was obtained from [https://opengameart.org/content/onscreen-controls-8-styles](https://opengameart.org/content/onscreen-controls-8-styles).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a virtual D-Pad, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene named `Chapter11-Examples-Buttons2` in the `Assets/Scenes`
    folder and open the new scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `dPadButtons.png` sprite sheet into the `Assets/Sprites` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the newly imported sprite’s **Sprite Mode** to **Multiple** and automatically
    slice it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Canvas with `D-Pad Canvas`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The size of a D-Pad is incredibly important on mobile devices. Even if the screen
    gets smaller, you’ll probably want the D-Pad to be about the same size. If it
    gets too small, the game can be unplayable or uncomfortable. Therefore, set the
    **Canvas Scaler** component’s **UI Scale Mode** value to **Constant** **Physical
    Size**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new Image as a child of `D-Pad Canvas` with `D-Pad Background`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `dPadButtons_4`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its anchor and pivot to the lower-left corner of the screen, and set its
    `30`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set its `200`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.33: The D-Pad positioned correctly](img/B18327_11_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.33: The D-Pad positioned correctly'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on `D-Pad Background` and add a new Button as a child with `Up`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove its child `Text` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Up` Button to `0`, `65`, `60`, and `60`, respectively. This will create
    a square over just the up position of the D-Pad Image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.34: The D-Pad with an Up Button](img/B18327_11_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.34: The D-Pad with an Up Button'
  prefs: []
  type: TYPE_NORMAL
- en: Duplicate the `Up` Button three times and rename the duplicates `Right`, `Left`,
    and `Down`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Right` Button’s `65` and `0`, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Left` Button’s `-65` and `0`, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `Down` Button’s `0` and `-65`, respectively. You should now have four
    Buttons positioned as follows:![Figure 11.35: The D-Pad with all of its Buttons](img/B18327_11_35.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.35: The D-Pad with all of its Buttons'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These four Buttons cover the entire area of the arms of the directional pad.
    They will act as the hit area for the directions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We only really want these four Buttons for their hit area and don’t want to
    actually have them visible in the UI. Select all four of the Buttons in the Hierarchy
    and set the alpha value on the `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the directional pad Image is static and not split into four separate Buttons,
    any transitions applied to it would cover the whole Image. However, we can make
    the individual directions look as if they are being pressed and have some sort
    of color transition by adding sub-Images for the arrows on the directions. Right-click
    the `Up` Button and add an Image as a child with `Arrow`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the `dPadButtons_5` sprite to the **Source Image** on its **Image** component
    and select **Preserve Aspect**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scale and move the Image so that it is appropriately lined up with the arrow
    displayed on the D-Pad background Image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.36: The Up Arrow of the D-Pad](img/B18327_11_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.36: The Up Arrow of the D-Pad'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Arrow` Image component and use the eye dropper tool to grab the
    color of the arrows from the `D-Pad Background` Image. This will make it a light
    gray instead of white.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create `Arrow` children for each of the other three Buttons, and size, position,
    and color them appropriately. Make sure to also use the correct sub-Image of the
    `dPadButtons` sprite sheet. Once completed, your D-Pad and Hierarchy should appear
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.37: All Arrows on the D-Pad](img/B18327_11_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.37: All Arrows on the D-Pad'
  prefs: []
  type: TYPE_NORMAL
- en: Now, so that the D-Pad will react visually when the four directions are pressed,
    we will set the four `Arrow` children to have color tint Button `Arrow` child
    into the **Target Graphic** slot on its **Button** component. Now, when you press
    the individual Buttons, you will see a slight change in the color of the arrows,
    indicating which direction is pressed. You may wish to change the pressed color
    to something a bit more drastic than the default gray if you are having difficulty
    telling that a change is occurring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the script named `DPad.cs` from the book’s code bundle to the `Assets/Scripts`
    folder. This is an incredibly simple script that contains four functions that
    only write to the console. Hooking up these four functions to the individual directional
    Buttons won’t do anything fun, but it will allow us to see logs in the console
    that let us know the Buttons are performing as they should.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the script to the `D-Pad` `Background` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select each of the four directional Buttons and, with all of them selected,
    add an **On Click ()** Event to the **Button** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, drag the `D-Pad Background` object into the object slot of the **On Click
    ()** Event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select each Button individually and assign the appropriate functions, `PressUp`,
    `PressDown`, `PressLeft`, and `PressRight`, to their **On Click ()** Events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Playing the game and selecting the four directional Buttons should result in
    the appropriate message being displayed on the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many D-Pads actually accept nine inputs: the four directs, the four diagonals
    (corners), and the center. If you want to accept diagonal inputs as well as a
    center-click for your D-Pad, I’d suggest using a grid layout group to evenly space
    your nine Buttons.'
  prefs: []
  type: TYPE_NORMAL
- en: Since D-Pads tend to allow press-and-hold, you may want to combine the process
    used in this example with actions similar to those described in the previous example.
    Instead of using the `OnPointerDown` and `OnPointerUp` Events. These Events could
    then set a Boolean variable to `true` and `false`. For example, on the `Right`
    Button, you could have the `OnPointerDown` Event set a variable called `moveRight`
    to `true` and the `OnPointerUp` Event set `moveRight` to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a floating eight-directional virtual analog stick
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we will create a floating eight-directional virtual analog
    stick. First, we will create an eight-directional D-Pad that simulates a control
    stick that moves in the direction the player drags:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.38: The positions of the floating analog stick](img/B18327_11_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.38: The positions of the floating analog stick'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will expand the eight-directional D-Pad so that it is floating, which
    means it will not be visible in the scene until the player presses somewhere in
    the screen. Then, it will appear where the player’s thumb is located and perform
    the eight-direction movement based on the player’s thumb dragging.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the eight-directional virtual analog stick
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an analog stick that moves in eight directions, as shown in the previous
    figure, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene named `Chapter11-Examples-Buttons3` in the `Assets/Scenes`
    folder and open the new scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Image with `Stick Base`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `dPadButtons_15` sprite to the **Source Image** slot of its **Image**
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resize it so that it has a `200` and give it a `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click `Stick Base` in the Hierarchy and select `Image` child to the `Stick
    Base`. Name the child `Stick`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resize the `Stick` Image to match the `Stick Base` by setting its **Rect Transform**
    stretch and anchor to stretch fully across both directions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `dPadButtons_0` sprite to the `Stick` Image component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `10` to give some padding around the edges of the `Stick`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, set the pivot and position to `Stick` will not move around appropriately
    on the `Stick Base`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.39: The Rect Transform component of the Stick](img/B18327_11_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.39: The Rect Transform component of the Stick'
  prefs: []
  type: TYPE_NORMAL
- en: That’s all there is for the setup to get our virtual analog stick working. We’ll
    just leave it in the center of the screen for now. Now, we need to write some
    code. Create a new script in the `Assets/Script` folder and name it `FloatingAnalogStick`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `UnityEngine.UI` namespace to the top of the script with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make the stick wiggle around on top of the base, we need the following variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first three variables should be pretty self-explanatory. The `dragPadding`
    variable will be used to determine how far the player has to drag the stick before
    it actually registers as being moved.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before we write the code that checks how far the player has dragged their finger,
    let’s add a few dummy functions that would allow this analog stick to actually
    control something in the future. Add the following functions to your script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Stick` will move outward when the player moves their finger from their
    starting finger-down position. So, let’s create a function that will find the
    starting position when the player begins dragging their finger. Add the following
    function to your script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember—when working with a touchscreen, `Input.mousePosition` will give the
    value of the touch position.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s create a function that checks how far the player has dragged their
    finger and moves the `Stick` based on that information. Add the following function
    to your script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last piece we need to add is something that will reset the stick to its
    original position once the player stops dragging or lifts up their finger. Add
    the following function to your script to do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we need to hook this script and these functions to the items within the
    scene. Add the `FloatingAnalogStick` script to the `Stick` `Base` Image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Stick` Image to the **Stick** property in the **Floating Analog** **Stick**
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `Stick Base` object with **Add Component** | **Events** | **Event Trigger**.
    This will allow the user to use Event Types other than **On Click()**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the **Begin Drag**, **Drag**, and **End Drag** Event Types with the **Add
    New Event** **Type** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the appropriate functions on the `FloatingAnalogStick` script attached
    to the `Stick Base` to the Events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.40: The Event Trigger component](img/B18327_11_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.40: The Event Trigger component'
  prefs: []
  type: TYPE_NORMAL
- en: If you play the game now, you should see the eight-directional analog stick
    responding appropriately. Clicking on it and dragging in any direction will cause
    the stick to move in the direction of the drag.
  prefs: []
  type: TYPE_NORMAL
- en: Making the eight-directional virtual analog stick float
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If all you want is an eight-directional analog stick, you’re good to go! But
    if you want the analog stick to float—appear where the players press on the screen
    and disappear when they lift their finger—you have to do a little bit more work.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the analog stick appear where the player clicks, complete the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create an area where the player will click to bring up the
    analog stick. Right-click `Canvas` in the Hierarchy and select `Button` child
    to the `Canvas`. Rename the `Button` child `Click Area`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `Text` child object from the `Click Area`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stretch the `Click Area` to fill the whole `Canvas`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add some padding to the sides of `Click Area` by changing the `50`. I have added
    this padding so that the player cannot click on the very edge of the screen and
    have the analog stick appear mostly off-screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Hierarchy, move `Click Area` so that it is above `Stick Base`. Now,
    `Click Area` will render behind the analog stick:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.41: The Hierarchy showing Click Area and Stick Base](img/B18327_11_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.41: The Hierarchy showing Click Area and Stick Base'
  prefs: []
  type: TYPE_NORMAL
- en: Open up your `FloatingAnalogStick` code so that we can add some functionality
    to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the position of our analog stick more easily hook to the position of
    the mouse on the screen, we should move our stick base so that it is centered
    at the lower-left corner of the `Canvas`. Set the anchor and position to the **bottom
    left** anchor preset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, set the `0.5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `0`. This should place the analog stick at the lower-left corner of
    the Canvas (or screen) with its pivot point set to its center:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.42: The Hierarchy showing Click Area and Stick Base](img/B18327_11_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.42: The Hierarchy showing Click Area and Stick Base'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need two more variables now to get the analog stick to appear where we want
    it to in the scene. Add the following variable to your script to assign the stick
    and track if it has been added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create the following function to add the stick to the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `Update()` function to determine when the stick will appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `Stick Base` to the **The** **Base** slot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.43: The Floating Analog Stick component](img/B18327_11_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.43: The Floating Analog Stick component'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `Click Area`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `Click Area`:![Figure 11.44: The Event Trigger component](img/B18327_11_44.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.44: The Event Trigger component'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Playing the game now will have the analog stick appear where you click and move
    around with your dragging.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let’s make it so that the analog stick is only visible when the player
    is touching the screen. Add a `Stick Base`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `0`, `false`, and `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following variable to your `FloatingAnalogStick` script to keep track
    of the `CanvasGroup`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `Awake()` function to initialize the `theBaseVisibility`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new function called `ToggleBaseCanvasGroup()` to toggle the `CanvasGroup`’s
    properties on and off:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to the `AddTheStick()` function to turn on the `CanvasGroup`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to the innermost `if` statement within the `Update()` function
    to turn off the `CanvasGroup`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, the analog stick will appear when the player presses down, move in the
    direction of their finger, and disappear when the player lifts their finger.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UI Images are one of the core components of the Unity UI system and manipulating
    them is essential to creating visually interactive user interfaces. This chapter
    culminated all the skills we have learned in the preceding chapters by letting
    us create interesting interfaces that utilized Events, Buttons, and Images.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at how to create masks and scroll views so that
    we can hold even more child objects within our Panel containers.
  prefs: []
  type: TYPE_NORMAL
