<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-203"><a id="_idTextAnchor223"/>13</h1>
<h1 id="_idParaDest-204"><a id="_idTextAnchor224"/>Unit Testing</h1>
<p>Let’s dive into something critical: <strong class="bold">unit testing</strong>. Think of it as your safety net. It’s not just about knowing your app runs smoothly now, but ensuring that after every tweak, update, or overhaul, your app keeps on ticking without hiccups or unexpected surprises. Regression bugs? We’re looking at you! With MVVM and the right testing practices, we can effectively guard against these potential issues.</p>
<p>In this chapter, we’re going to tackle the following:</p>
<ul>
<li>The importance of unit testing</li>
<li>Setting up a unit test project</li>
<li>Generating data with Bogus</li>
<li>Mocking dependencies with Moq</li>
<li>Testing MAUI-specific code</li>
</ul>
<p>While we won’t be diving deep into the weeds (after all, the intricacies can vary widely depending on the tools you use), I’ll guide you using a set of tools I’m familiar with: <strong class="bold">xUnit</strong>, <strong class="bold">Bogus</strong>, <strong class="bold">AutoBogus</strong>, and <strong class="bold">Moq</strong>. These are my go-to building blocks, but let’s remember: the .NET ecosystem is vast and versatile. There are several other fantastic frameworks and libraries out there, such as <strong class="bold">NUnit</strong>, <strong class="bold">AutoFixture</strong>, <strong class="bold">NSubstitute</strong>, and more. The principles we cover will largely remain the same; it’s just a matter of which tools resonate with your workflow. At the end of the day, it’s all about personal preference.</p>
<p>By the end of this chapter, you should be firmly convinced of the immense value unit tests offer. Additionally, you’ll have a clear view of how to effectively use tools and techniques for writing unit tests.</p>
<h1 id="_idParaDest-205"><a id="_idTextAnchor225"/>Technical requirements</h1>
<p>To ensure you’re in sync with the upcoming content, make your way to our GitHub repository: <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter13">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter13</a>. Kick off with the materials in the <code>Start</code> folder. And remember – if you’re ever in need of a consolidated reference, the <code>Finish</code> folder holds the final, refined code at the chapter’s close.</p>
<h1 id="_idParaDest-206"><a id="_idTextAnchor226"/>The importance of unit testing</h1>
<p>A lesson I learned the hard way forever transformed my stance on software development: <em class="italic">never underestimate </em><em class="italic">unit testing</em>.</p>
<p>Years ago, I was part of a <a id="_idIndexMarker872"/>dedicated team crafting an ambitious app. Our expertise in C# and the platform was undeniable. Yet, we overlooked unit tests, placing our faith in manual testing and our <strong class="bold">Quality Assurance</strong> (<strong class="bold">QA</strong>) team. The end product was highly recognized and praised, but the journey was a tumultuous one. Feedback from QA often revealed bugs, making each code adjustment feel risky.</p>
<p>Nearing deadlines was synonymous with sleepless nights, hasty bug fixes, and a looming fear of regressions. Post-project, I collaborated with diverse developers and encountered a colleague profoundly <a id="_idIndexMarker873"/>devoted to <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>). It was a true eye-opener, not just for the essence of unit testing but also for the flaws in our previous design choices.</p>
<p>My evolving journey underscored the <a id="_idIndexMarker874"/>real benefits of unit tests:</p>
<ul>
<li><strong class="bold">Efficiency</strong>: No more long-lasting deployments before manual verifications. Unit tests swiftly validate my code, streamlining development.</li>
<li><strong class="bold">Quality and confidence</strong>: With each test, the software’s quality rises, as does my confidence. It becomes a safety net, allowing explorative coding without the fear of unintended consequences.</li>
<li><strong class="bold">Guarding against regressions</strong>: Unit tests ensure alterations don’t unintentionally break existing features.</li>
</ul>
<p>With time, I’ve also observed that unit tests serve as an evolving documentation. New team members can determine the expected behavior and logic from these tests, facilitating quicker integration and more confident code modifications.</p>
<p>My old teammates and I still meet up from time to time. We chat about the old days and our shared experiences. In our conversations, a shared realization stands out: after our time together, each of us matured in our individual projects. This often leads us to a mutual reflection: if we had embraced unit testing in that project we did years ago, our work lived might have been a lot smoother. Don’t get me wrong; our clients were happy with what we delivered. But for all of us, on a personal level, having tests from the get-go could have saved many stressful nights, health issues, and uncertainties.</p>
<p>While unit testing enjoys acclaim in many developer circles, I still witness hesitancy, especially in parts of the .NET world. My advocacy isn’t about achieving a coverage metric or TDD fanaticism. It’s about recognizing unit tests for their benefits, from ensuring code reliability to uplifting team morale.</p>
<p>Unit testing is not<a id="_idIndexMarker875"/> about achieving an abstract notion of perfection. It’s about having a safety net, allowing for code acrobatics without fearing a misstep. Do I write tests for every single line of code I have? In all honesty: no. Is all my code easy to test? Not always. But the tests I write really do help. They let me know quickly if things work, if I broke something, or if I fixed a bug the right way. And that gives me confidence in my work. When a bug is being reported, the first thing I do is write a failing test, exposing this bug. I can then go ahead and work on this bug, and as soon as the test passes, I know I’ve fixed it. And not only is the bug now fixed, but with the additional test (or tests), the code has become even more robust and protected against future regressions.</p>
<p>As software continuously evolves in our fast-paced world, unit testing is not just best practice; it’s a lifeline. The peace of mind it offers is unparalleled, ensuring that the software not only functions but is robust against inevitable change.</p>
<p>To those beginning their developer journey or reevaluating unit tests: don’t mimic my initial oversight. See tests not as a chore but as a trusty companion.</p>
<p>Having said that, it’s time to pivot from the <em class="italic">why</em> to the <em class="italic">how</em>. For those still with me, let’s delve into the details: setting up unit tests for ViewModels. Believe me, it’s simpler than it seems!</p>
<h1 id="_idParaDest-207"><a id="_idTextAnchor227"/>Setting up a unit test project</h1>
<p>In this section, we will be <a id="_idIndexMarker876"/>walking through the steps of setting up a unit test project and creating a first test. We’ll be using xUnit in this section. We’re not going to get all tangled up in the tiny details of this specific library because there are tons of other awesome ones. No matter what you choose, the big takeaways should stick with you. So, without further ado, let’s dive in and start setting the stage for effective ViewModel testing!</p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor228"/>Creating a unit test project</h2>
<p>Let’s start by creating an xUnit Test project. In xUnit, one of the things I appreciate is its simplicity. Test classes and <a id="_idIndexMarker877"/>methods are just normal classes and methods, without the need for special base classes or complex setups. Here’s how:</p>
<ol>
<li>In the <strong class="bold">Solution Explorer</strong> in <strong class="bold">Visual Studio</strong>, right-click <strong class="bold">Solution ‘Recipes App’</strong> and select <strong class="bold">Add</strong> | <strong class="bold">New Project…</strong>.</li>
<li>In the <code>xunit</code> in the search box and select <strong class="bold">xUnit Test Project</strong> from the list (<em class="italic">Figure 13</em><em class="italic">.1</em>):</li>
</ol>
<div><div><img alt="Figure 13.1: Creating a new xUnit test project" height="1150" src="img/B20941_13_01.jpg" width="1648"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1: Creating a new xUnit test project</p>
<ol>
<li value="3">Click the <code>Recipes.Client.Core.UnitTests</code> as the project name. Click <strong class="bold">Next</strong>.</li>
<li>When prompted, select <strong class="bold">.NET 8.0 (Long Term Support)</strong> from the <strong class="bold">Framework</strong> list and hit the <strong class="bold">Create</strong> button.</li>
<li>Once the project is generated, right-click on it, select <code>Recipes.Client.Core</code> project from the list.</li>
</ol>
<p>With the project and its reference to the <code>Recipes.Client.Core</code> project in place, we can start writing our unit tests. Let’s go ahead and write our first one!</p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor229"/>Creating unit tests</h2>
<p>Let’s start by testing something<a id="_idIndexMarker878"/> pretty straightforward: testing the initialization of the <code>RecipeListItemViewModel</code>. Here’s how:</p>
<ol>
<li>Delete the generated <code>UnitTest1.cs</code> file.</li>
<li>Add a new C# class called <code>RecipeListItemViewModelTests</code> to the project.</li>
<li>Make the class public and add a public method called <code>ViewModel_Initialized_PropertiesSetCorrectly</code>, as shown in the following snippet:<pre class="source-code">
<strong class="bold">[Fact]</strong>
public void
  ViewModel_Initialized_PropertiesSetCorrectly()
{
}</pre><p class="list-inset">Note how the <code>Fact</code> attribute is added to this method. This attribute signals that this is a test method. Without it, the method won’t be identified as a test and therefore won’t be executed as one during test runs.</p></li> <li>Add the following code to this method:<pre class="source-code">
<strong class="bold">//Arrange</strong>
string id = "id1";
string title = "title1";
bool isFavorite = false;
string image = "image1";
<strong class="bold">//Act</strong>
var sut = new RecipeListItemViewModel(id, title,
    isFavorite, image);
<strong class="bold">//Assert</strong>
Assert.Equal(id, sut.Id);
Assert.Equal(title, sut.Title);
Assert.Equal(isFavorite, sut.IsFavorite);
Assert.Equal(image, sut.Image);</pre></li> </ol>
<p>This creates and validates a <code>RecipeListItemViewModel</code> instance. This code block first creates an instance of the <code>RecipeListItemViewModel</code> class using sample data. It then calls a <a id="_idIndexMarker879"/>series of assertions to confirm that the object’s properties were initialized as expected.</p>
<p>In unit testing jargon, our instantiated <a id="_idIndexMarker880"/>object is named <code>sut</code>, which stands for <strong class="bold">system under test</strong>. This is a name commonly used in unit tests.</p>
<p>Lastly, the role of the <code>Assert</code> statements, inherent to the xUnit framework, deserves special mention. <code>Assert</code> methods play a pivotal role in validating object states to ensure they meet our expectations. <code>Assert.True</code>, <code>Assert.Empty</code>, <code>Assert.Contains</code>, and many more are at our disposal. The <code>Assert.Equal</code> method, as shown in this example, evaluates if the expected value matches the object’s actual value. In this context, it ensures that properties of our <code>sut</code> object, such as <code>Id</code>, <code>Title</code>, <code>IsFavorite</code>, and <code>Image</code>, were initialized as expected.</p>
<p>In the previous code snippet, you may notice the clear structure, which is guided by comments: <code>//Arrange</code>, <code>//Act</code>, and <code>//Assert</code>. This corresponds to a fundamental pattern in unit testing known as <strong class="bold">Arrange-Act-Assert</strong> (<strong class="bold">AAA</strong>). Let’s<a id="_idIndexMarker881"/> delve briefly into what each stage signifies:</p>
<ul>
<li><code>Arrange</code>: This stage involves setting up any prerequisites for a test. We establish the conditions our test operates under. This might include initializing variables, creating mock objects, or setting up resources. In our example, this is where we define our sample data: <code>id</code>, <code>title</code>, <code>isFavorite</code>, and <code>image</code>.</li>
<li><code>Act</code>: Here, we perform the action that we intend to test. This is where the <code>sut</code> object is invoked, and it’s typically a single action. In our context, it’s the instantiation of <code>RecipeListItemViewModel</code> with the sample data we arranged.</li>
<li><code>Assert</code>: This final stage is where we verify if the test has passed or failed by checking the outcome against the expected results. In our example, this is done using the <code>Assert.Equal</code> method to ensure that our <code>RecipeListItemViewModel</code> object’s properties match the values we initialized them with.</li>
</ul>
<p>Following the AAA pattern ensures that tests are organized and readable, making it easier for you, or anyone reviewing your code, to understand the purpose and behavior of each test.</p>
<p>Go ahead and run the <a id="_idIndexMarker882"/>test! This can be done by right-clicking inside the test method you want to test and selecting <strong class="bold">Run Tests</strong>. Alternatively, you can choose <strong class="bold">Debug Tests</strong>, which runs your test and breaks on any breakpoints you have added, allowing you to step through the unit test. Test methods are also visible in the <strong class="bold">Test Explorer</strong> in <strong class="bold">Visual Studio</strong>. From there, you can easily run multiple tests. This pane also shows the current status of your tests: which ran successfully and which failed, alongside other relevant info, as shown in <em class="italic">Figure 13</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 13.2: Visual Studio’s Test Explorer" height="366" src="img/B20941_13_02.jpg" width="1242"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2: Visual Studio’s Test Explorer</p>
<p>Let’s add a couple more tests! Each instance of a <code>RecipeListItemViewModel</code> should listen for a <code>FavoriteUpdateMessage</code> and when such a message arrives, its <code>IsFavorite</code> property should be updated accordingly. So, let’s first write a test that validates that a newly instantiated <code>RecipeListItemViewModel</code> is registered as a recipient for a <code>FavoriteUpdateMessage</code> message. Secondly, in separate tests, we can check if the class reacts as expected to such a message:</p>
<ol>
<li>Let’s start off by <a id="_idIndexMarker883"/>adding the following test to the <code>RecipeListItemViewModelTests</code> class:<pre class="source-code">
[Fact]
public void
  VM_Initialized_SubscribedToFavoriteUpdateMessage()
{
    //Arrange, Act
    var sut = new RecipeListItemViewModel(
        "id", "title", true, "image");
    //Assert
    Assert.True(WeakReferenceMessenger.Default
        .IsRegistered&lt;FavoriteUpdateMessage&gt;(sut));
}</pre><p class="list-inset">The <code>WeakReferenceMessenger.Default.IsRegistered</code> method allows us to check whether a particular object is registered for a particular message. We expect our <code>sut</code> to be registered for the <code>FavoriteUpdateMessage</code>, so we can call this method and validate the outcome to be true with <code>Assert.True</code>.</p></li> <li>We should also validate that when a <code>FavoriteUpdateMessage</code> is received by the <code>sut</code>, the <code>IsFavorite</code> property is updated accordingly – only, of course, when the id sent by the message matches the id of the <code>sut</code>. Take a look:<pre class="source-code">
[Fact]
public void
  FavoriteUpdateMsgReceived_SameId_FavoriteUpdated()
{
    //Arrange
    var id = "id";
    var originalValue = false;
    var updateToValue= !originalValue;
    var sut = new RecipeListItemViewModel(
        "someid", "title", originalValue, "image");
    //Act
    WeakReferenceMessenger.Default.Send(
        new FavoriteUpdateMessage(
            id, updatedFavorite));
    //Assert
    Assert.Equal(updatedFavorite, sut.IsFavorite);
}</pre><p class="list-inset">The <code>FavoriteUpdateMessage</code> sends <a id="_idIndexMarker884"/>the inverse of the <code>originalValue</code> value that is used to instantiate the sut. After sending the message, which contains the same <code>RecipeId</code> as the sut, we can check whether the value of the <code>IsFavorite</code> property equals the value we’ve sent.</p></li> <li>As a last test, we might want to validate that a <code>RecipeListItemViewModel</code> doesn’t react to a <code>FavoriteMessage</code> with a different <code>RecipeId</code>. This is very similar to our previous test, as you can see here:<pre class="source-code">
[Fact]
public void FavoriteUpdateMsgReceived_DifferentId
  _FavoriteNotUpdated()
{
    //Arrange
    var originalValue = false;
    var updateToValue= !originalValue;
    var sut = new RecipeListItemViewModel(
        "someid", "title", originalValue, "image");
    //Act
    WeakReferenceMessenger.Default.Send(
        new FavoriteUpdateMessage(
            "otherid", updatedFavorite));
    //Assert
    Assert.Equal(originalValue, sut.IsFavorite);
}</pre><p class="list-inset">Because the message sends a different <code>RecipeId</code> than the ID on the <code>RecipeListItemViewModel</code>, we want to validate that the <code>IsFavorite</code> property on the<a id="_idIndexMarker885"/> sut is still the same as the originally set value.</p></li> </ol>
<p class="callout-heading">The “unit” in unit tests</p>
<p class="callout">When we talk <a id="_idIndexMarker886"/>about <em class="italic">unit tests</em>, that <em class="italic">unit</em> part is crucial. It’s all about keeping things small and focused. Take a peek at the tests we just created. The first one ensures the ViewModel is registered for incoming <code>FavoriteUpdateMessage</code>s, while the other one checks how the ViewModel responds to an incoming message. Sure – the latter indirectly verifies the message listener too, but that doesn’t mean we can skip the first test. Each <em class="italic">unit</em> test should stick to checking one tiny piece of the puzzle to make sure every bit is working as it should.</p>
<p>With our first test passing, let’s see how we can make them more data-driven.</p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor230"/>Looking at data-driven tests</h2>
<p><code>false</code> as the third parameter. Now, if we were to remove <code>IsFavorite = isFavorite;</code> from the <code>RecipeListItemViewModel</code> class’s constructor, our test would deceptively still pass – a classic example of a false positive in testing. This is because, by coincidence, the default value of <code>IsFavorite</code> is <code>false</code>, but in fact, it is never assigned the value we passed in as a parameter. We could create another test method with different values in the <code>Theory</code> and <code>InlineData</code> attributes to leverage data-driven tests.</p>
<p>In xUnit, while the <code>Fact</code> attribute denotes a straightforward unit test that runs once, there’s another powerful feature: the <code>Theory</code> attribute. Paired with the <code>InlineData</code> attribute, <code>Theory</code> allows us to create parameterized tests. This means we can run the same test logic with different input values, ensuring our code is robust against a variety of scenarios without duplicating our test methods. Let’s dive in and refactor our earlier test to take advantage of this capability:</p>
<ol>
<li>Modify the <code>ViewModel_Initialized_PropertiesSetCorrectly</code> method to include the following parameters:<pre class="source-code">
public void
  ViewModel_Initialized_PropertiesSetCorrectly(
<strong class="bold">    string id, string title, bool isFavorite,</strong>
<code>Arrange</code> phase and use the provided parameters directly to instantiate our ViewModel:<pre class="source-code">
//Arrange, Act
var sut = new RecipeListItemViewModel(id, title,
    isFavorite, image);
//Assert
Assert.Equal(id, sut.Id);
Assert.Equal(title, sut.Title);
Assert.Equal(isFavorite, sut.IsFavorite);
Assert.Equal(image, sut.Image);</pre></li> <li>Let’s now remove the <code>Fact</code> attribute and add a <code>Theory</code> attribute and some <code>InlineData</code> attributes <a id="_idIndexMarker888"/>to this method:<pre class="source-code">
[Theory]
[InlineData("id1", "title1", false, "image1")]
[InlineData("id2", "title2", true, "image2")]
[InlineData("foo", "bar", true, null)]
[InlineData(null, null, false, null)]</pre></li> </ol>
<p>The <code>Theory</code> attribute is used to mark a test method as being a data-driven test. This means that the test method will be executed once for each set of data values specified using the <code>InlineData</code> attribute. Each of those runs of the test will have access to the data values provided by <code>InlineData</code>. When the <code>Theory</code> method is executed, xUnit will create a new instance of the test class for each set of data values specified in the <code>InlineData</code> attribute, and then execute the test method using those data values. The values provided in the <code>InlineData</code> attribute should exactly match the number and types of parameters on the method that is being tested.</p>
<p>Here’s how we can update the <code>FavoriteUpdateMsgReceived_SameId_FavoriteUpdated</code> method to turn it into a data-driven<a id="_idIndexMarker889"/> test method:</p>
<pre class="source-code">
[Theory]
[InlineData(true, false)]
[InlineData(false, true)]
[InlineData(true, true)]
[InlineData(false, false)]
public void
    FavoriteUpdateMsgReceived_SameId_FavoriteUpdated(
    bool originalValue, bool updateToValue)
{
    //Arrange
    var id = "id";
    var sut = new RecipeListItemViewModel(
        id, "title", originalValue, "image");
    //Act
    WeakReferenceMessenger.Default.Send(
        new FavoriteUpdateMessage(id, updateToValue));
    //Assert
    Assert.Equal(updateToValue, sut.IsFavorite);
}</pre> <p>The <code>FavoriteUpdateMsgReceived_DifferentId_FavoriteNotUpdated</code> can be updated similarly, as shown here:</p>
<pre class="source-code">
[Theory]
[InlineData(true, false)]
[InlineData(false, true)]
[InlineData(true, true)]
[InlineData(false, false)]
public void FavoriteUpdateMsgReceived_
  DifferentId_FavoriteNotUpdated(
bool originalValue, bool updateToValue)
{
    //Arrange
    var sut = new RecipeListItemViewModel(
        "someid", "title", originalValue, "image");
    //Act
    WeakReferenceMessenger.Default.Send(
        new FavoriteUpdateMessage(
        "otherid", updateToValue));
    //Assert
    Assert.Equal(originalValue, sut.IsFavorite);
}</pre> <p>By adopting the <code>Theory</code> and <code>InlineData</code> attributes, we’ve enhanced our testing capability significantly. These <a id="_idIndexMarker890"/>updated test methods can now validate across a diverse set of values, ensuring that our ViewModel behaves consistently in varied scenarios. It’s an elegant way to increase test coverage without adding redundant code.</p>
<p>Sometimes, it’s beneficial to have test data generated for us, especially when we’re more concerned about the logic than the specific values. That’s where tools such as Bogus and AutoBogus come into play, helping us effortlessly generate diverse test values without manual<a id="_idIndexMarker891"/> intervention. Let’s have a look!</p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor231"/>Generating data with Bogus</h1>
<p>While handpicked data has<a id="_idIndexMarker892"/> its place in unit tests, it often comes with inherent bias: because we’ve written the functionality that we want to test, we have a certain expectation about the format of the values being used. To combat this, many tests benefit from randomized or generated data, especially when the specific input matters less than the resulting outcome. Bogus is a powerful tool tailored for those moments when you need reliable, unbiased test data without the manual labor.</p>
<p>In this section, we’ll introduce Bogus and AutoBogus and explore some of its basic capabilities. However, it’s worth noting that we’re merely scratching the surface here. These tools offer many features, but for the sake of brevity and focus, we’ll keep our discussion high-level, touching only upon a few fundamental use cases.</p>
<p>Let’s start off by adding AutoBogus (and thus also Bogus) to our project:</p>
<ol>
<li>In <code>Recipes.Client.Core.UnitTests</code> project and select <strong class="bold">Manage </strong><strong class="bold">NuGet Packages…</strong>.</li>
<li>In the <code>autobogus</code> and install the <strong class="bold">AutoBogus</strong> package:</li>
</ol>
<div><div><img alt="Figure 13.3: AutoBogus NuGet Package" height="339" src="img/B20941_13_03.jpg" width="1032"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3: AutoBogus NuGet Package</p>
<p>Now that we have installed these packages, let’s put this library into practice by testing the <code>EmptyOrWithinRangeAttribute</code> class:</p>
<ol>
<li>Create a new class called <code>EmptyOrWithinRangeAttributeTests</code>.</li>
<li>Place the following<a id="_idIndexMarker893"/> member variables into the new class:<pre class="source-code">
const int MinValueStart = 5;
const int MinValueEnd = 10;
const int MaxValueStart = 11;
const int MaxValueEnd = 15;
readonly EmptyOrWithinRangeAttribute sut;</pre><p class="list-inset">In this class, we’ll be putting our <code>sut</code> object as a class member. This allows us to write the instantiation code of the <code>sut</code> object once in the constructor (or inline), preventing repeatable code in each test for setting everything up. As each test method runs in a separate instance of the <code>EmptyOrWithinRangeAttributeTests</code> class, this also has no side effects on other tests.</p></li> <li>Add a constructor to the class and add the following code:<pre class="source-code">
sut = new Faker&lt;EmptyOrWithinRangeAttribute&gt;()
    .RuleFor(r =&gt; r.MinLength, f =&gt;
        f.Random.Int(MinValueStart, MinValueEnd))
    .RuleFor(r =&gt; r.MaxLength, f =&gt;
        f.Random.Int(MaxValueStart, MaxValueEnd))
    .Generate();</pre></li> </ol>
<p>Instead of manually creating an instance of the <code>EmptyOrWithinRangeAttribute</code> class, we are delegating this to the Bogus framework. We do this by instantiating a new <code>Faker</code> class, passing in the type we want it to generate. With the <code>RuleFor</code> methods of the <code>Faker</code> class, we can configure the values for the individual properties.</p>
<p>In a <code>RuleFor</code> method, we first need to point to the property we want to configure. The next parameter of this method is a function with a <code>Faker</code> class as a parameter that allows us to define the value<a id="_idIndexMarker894"/> of the property. In this case, we use the <code>Faker</code>’s <code>Random.Int</code> method to indicate we want it to be a generated int value between two values.</p>
<p>By calling the <code>Generate</code> method, the Bogus framework will generate an instance of the type we want, adhering to the rules we’ve defined. This gives back the instance of the <code>EmptyOrWithinRangeAttribute</code> we want to work with.</p>
<p>Let’s go ahead and implement a test that checks if <code>EmptyOrWithinRangeAttribute</code> validates input correctly:</p>
<ol>
<li>Add the <code>Value_WithinRange_IsValid</code> to this class, as shown here:<pre class="source-code">
[Fact]
public void Value_WithinRange_IsValid()
{
    //Arrange
    var input = new Faker().Random.String2(
        sut.MinLength, sut.MaxLength);
    //Act
    var isValid = sut.IsValid(input);
    //Assert
    Assert.True(isValid);
}</pre><p class="list-inset">In the <code>Arrange</code> step, we’re using Bogus’ <code>Faker</code> class to generate a random string with a length that falls between the <code>MinLength</code> and <code>MaxLength</code> properties of the <code>sut</code>. Remember – these <code>MinLength</code> and <code>MaxLength</code> properties are values generated by Bogus. This generated string value can now be used to check whether the <code>IsValid</code> method of the <code>EmptyOrWithingRangeAttribute</code> does what we expect it to do. The returned value <a id="_idIndexMarker895"/>should be <code>true</code>, which we can easily check with the <code>Assert.True</code> method.</p></li> <li>Similarly, we can add a <code>Value_TooShort_IsNotValid</code> method that checks that the <code>IsValid</code> method returns <code>false</code> when the provided value isn’t correct:<pre class="source-code">
[Fact]
public void Value_TooShort_IsNotValid()
{
    //Arrange
    var input = new Faker().Random.String2(
        1, MinValueStart - 1);
    //Act
    var isValid = sut.IsValid(input);
    //Assert
    Assert.False(isValid);
}</pre></li> <li>While we’re at it, let’s also add a check to see if an empty string is returned as being valid. This is shown in the following code block:<pre class="source-code">
[Fact]
public void Value_Empty_IsValid()
{
    //Arrange
    var input = string.Empty;
    //Act
    var isValid = sut.IsValid(input);
    //Assert
    Assert.True(isValid);
}</pre></li> </ol>
<p>Notice how short and straightforward these test methods are! Adding extra checks for input values being too long or <a id="_idIndexMarker896"/>null really isn’t hard labor. And because we are not working with hardcoded data, we can be pretty confident the <code>IsValid</code> method of the <code>EmptyOrWithingRangeAttributes</code> class works as expected in many different scenarios. On top of that, think about the speed and efficiency with which we’re validating this <code>ValidationAttribute</code> class. We haven’t deployed our app or clicked through its interface. Still, we’re already certain about the correctness of our code. That’s a significant boost in development efficiency!</p>
<p>Remember the <code>VM_Initialized_SubscribedToFavoriteUpdateMessage</code> method in the <code>RecipeListItemViewModelTests</code> class we wrote earlier? This method checks whether an instance of the <code>RecipeListItemViewModel</code> is registered as a receiver for the <code>FavoriteUpdateMessage</code>. In this test method, we had to initialize our sut. However, the values that were used to create it aren’t of any value inside the test: whichever values are used, the instance should listen for the <code>FavoriteUpdateMessage</code>. This is an ideal scenario to introduce AutoBogus. Just take a look at the updated code of the <code>VM_Initialized_SubscribedToFavoriteUpdateMessage</code> method:</p>
<pre class="source-code">
//Arrange, Act
var sut = AutoFaker.Generate&lt;RecipeListItemViewModel&gt;();
//Assert
Assert.True(WeakReferenceMessenger.Default
    .IsRegistered&lt;FavoriteUpdateMessage&gt;(sut));</pre> <p>With the static <code>Generate</code> method of the <code>AutoFaker</code> class, we can generate an instance of <code>RecipeListItemViewModel</code>. The <code>Faker</code> class typically requires a default constructor for the object type we want to instantiate. The <code>RecipeListItemViewModel</code> doesn’t have a default constructor and that’s where <code>AutoFaker</code> comes into play: it will automatically provide fake values for the parameters. We basically don’t care <a id="_idIndexMarker897"/>which values are used to create this class. All that we are interested in in this test, is the fact the instantiated class is registered for the <code>FavoriteUpdateMessage</code>.</p>
<p>In other test methods, such as those in <code>RecipeListItemViewModelTests</code>, we’ve relied on hardcoded dummy data. We can use AutoBogus to get rid of these hardcoded values as well. Take a look at the updated <code>FavoriteUpdateMsgReceived_SameId_FavoriteUpdated</code> method:</p>
<pre class="source-code">
public void
    FavoriteUpdateMsgReceived_SameId_FavoriteUpdated(
    bool originalValue, bool updateToValue)
{
    //Arrange
    var id = <strong class="bold">AutoFaker.Generate&lt;string&gt;();</strong>
    var sut = new RecipeListItemViewModel(id,
        <strong class="bold">AutoFaker.Generate&lt;string&gt;()</strong>,
        originalValue,
        <strong class="bold">AutoFaker.Generate&lt;string&gt;()</strong>);
    //Act
    WeakReferenceMessenger.Default.Send(new
        FavoriteUpdateMessage(id, updateToValue));
    //Assert
    Assert.Equal(updateToValue, sut.IsFavorite);
}</pre> <p>In this previous code block, we’re leveraging AutoBogus’ <code>Generate</code> method to generate random data for us.</p>
<p>Bogus and AutoBogus automate .NET testing by generating unbiased, randomized test data, eliminating manual and potentially biased inputs.</p>
<p>Instead of merely <a id="_idIndexMarker898"/>providing fake data, we often need to mock entire components or behavior. This is where a dedicated mocking framework, such as Moq, becomes invaluable. Let’s delve into how Moq empowers us to effectively mock dependencies and streamline our testing process.</p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor232"/>Mocking dependencies with Moq</h1>
<p>Testing frequently<a id="_idIndexMarker899"/> involves scenarios where our system under test interacts with external dependencies, whether they are databases, APIs, or other services. Running tests <a id="_idIndexMarker900"/>against these real dependencies can lead to slow, unpredictable outcomes and potentially unwanted side effects. Mocking provides a solution by simulating these dependencies, ensuring our tests focus purely on the component at hand. Through mocking, we gain control over external interactions, ensuring our tests are swift, reliable, and free from external influences.</p>
<p class="callout-heading">Integration tests</p>
<p class="callout">When writing unit tests, we typically want to mock external dependencies as much as possible. However, it is often valuable to also test the integration of different components to ensure they work together <a id="_idIndexMarker901"/>seamlessly. This is where integration tests come in. Unlike unit tests, which focus heavily on mocking to test units in isolation, integration tests often involve fewer mocks. This ensures that components interact with each other in the exact manner we expect, verifying that they behave correctly as a unified whole.</p>
<p>The principles of DI and separation of concerns accentuate this approach. When we design our components to be decoupled and inject their dependencies, it becomes seamless to replace real dependencies with mock versions during testing. Think of DI, SoC, and mocking as<a id="_idIndexMarker902"/> interlocking puzzle pieces, each complementing the other, leading to a comprehensive <a id="_idIndexMarker903"/>and maintainable testing strategy. Now, let’s dive into how Moq assists us in achieving this goal.</p>
<p>When we inspect the <code>RecipeDetailViewModel</code>’s constructor, it’s evident that it depends on several services:</p>
<pre class="source-code">
public RecipeDetailViewModel(
    IRecipeService recipeService,
    IFavoritesService favoritesService,
    IRatingsService ratingsService,
    INavigationService navigationService,
    IDialogService dialogService)
{
...
}</pre> <p>To effectively test this ViewModel, we need to abstract away its external dependencies. Mocking the <code>recipeService</code> parameter can be achieved like this:</p>
<pre class="source-code">
var recipeServiceMock = new Mock&lt;IRecipeService&gt;();</pre> <p>The mocked value can then be passed-in the <code>RecipeDetailViewModel</code> as follows:</p>
<pre class="source-code">
var sut = new RecipeDetailViewModel
  (<code>recipeServiceMock</code> with fake method implementations. We can configure our mock object with specific method behaviors. Consider the <code>LoadRecipe</code> method of <code>IRecipeService</code>:</p>
<pre class="source-code">
Task&lt;Result&lt;RecipeDetail&gt;&gt; LoadRecipe(string id);</pre> <p>Here’s how to instruct Moq to mimic this method:</p>
<pre class="source-code">
recipeServiceMock
    .Setup(m =&gt; m.LoadRecipe(It.IsAny&lt;string&gt;()))
    .ReturnsAsync(
    Result&lt;RecipeDetail&gt;.Success(new RecipeDetail(...));</pre> <p>With the <code>Setup</code> method, we can tell Moq which method we want to simulate. In our example, we’re targeting the <code>LoadRecipe</code> method. <code>It.IsAny&lt;string&gt;</code> is a matcher, which signifies that we’re indifferent to the exact value passed into the method. In simpler<a id="_idIndexMarker904"/> terms, any string value will trigger the behavior we’re <a id="_idIndexMarker905"/>defining here. Speaking of which, <code>ReturnsAsync</code> specifies the result our mock method should produce. For example, we’re returning a successful result containing dummy <code>RecipeDetail</code> data. In essence, this code configures <code>recipeServiceMock</code> to always produce a specific result for any call to <code>LoadRecipe</code>, ensuring our tests are predictable and not reliant on real implementations. Let’s see how we can add a set of new tests.</p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor233"/>Applying mocking in our ViewModel tests</h2>
<p>To start testing <code>RecipeDetailViewModel</code>, let’s add a new class named <code>RecipeDetailViewModelTests</code> to the test<a id="_idIndexMarker906"/> project and follow these steps:</p>
<ol>
<li>Add the following fields to the <code>RecipeDetailViewModelTests</code> class:<pre class="source-code">
readonly Mock&lt;IRecipeService&gt; _recipeServiceMock;
readonly Mock&lt;IFavoritesService&gt;
    _favoritesServiceMock;
readonly Mock&lt;IRatingsService&gt; _ratingsServiceMock;
readonly Mock&lt;INavigationService&gt;
    _navigationServiceMock;
readonly Mock&lt;IDialogService&gt; _dialogServiceMock;
readonly RecipeDetailViewModel sut;</pre></li> <li>Instantiate these<a id="_idIndexMarker907"/> fields in the class’s constructor, as shown here:<pre class="source-code">
public RecipeDetailViewModelTests()
{
    _recipeServiceMock = new();
    _favoritesServiceMock = new();
    _ratingsServiceMock = new();
    _navigationServiceMock = new();
    _dialogServiceMock = new();
    _ratingsServiceMock
        .Setup(m =&gt;
            m.LoadRatingsSummary(It.IsAny&lt;string&gt;()))
        .ReturnsAsync(Result&lt;RatingsSummary&gt;.Success(
            AutoFaker.Generate&lt;RatingsSummary&gt;()));
    sut = new RecipeDetailViewModel(
        _recipeServiceMock.Object,
        _favoritesServiceMock.Object,
        _ratingsServiceMock.Object,
        _navigationServiceMock.Object,
        _dialogServiceMock.Object);
}</pre><p class="list-inset">In this previous code block, we’re instantiating all of our mock classes and using them to instantiate the <code>sut</code> object. By putting this in the constructor, we don’t have to repeat this code in every unit test. We can even already provide some default mock implementations, as shown with <code>_ratingServiceMock</code>. If, for a specific test, we need a different behavior for <code>_ratingServiceMock</code>, we can easily override the default behavior set in the constructor in the test itself. When we specify a<a id="_idIndexMarker908"/> new behavior in the test method, Moq will use the most recent setup, ensuring flexibility in our tests.</p></li> <li>In the first test, we want to validate that the parameter that is being used to navigate to the detail page, is effectively being passed to the injected <code>IRecipeService</code>’s <code>LoadRecipe</code> method to retrieve the detail information. Start by adding the following method to this class:<pre class="source-code">
[Fact]
public async Task OnNavigatedTo_Should_Load_Recipe()
{
...
}</pre></li> <li>Let’s have a look at this test’s <code>Arrange</code> step:<pre class="source-code">
//Arrange
var recipeId = AutoFaker.Generate&lt;string&gt;();
var parameters = new Dictionary&lt;string, object&gt; {
    { "id", recipeId }
};
_recipeServiceMock
    .Setup(m =&gt; m.LoadRecipe(It.IsAny&lt;string&gt;()))
    .ReturnsAsync(Result&lt;RecipeDetail&gt;
    .Success(AutoFaker.Generate&lt;RecipeDetail&gt;()));</pre><p class="list-inset">In the <code>Arrange</code> step, we’re generating a <code>recipeId</code> using <code>AutoFaker</code>. This value is put in a Dictionary named parameters which we’ll use in the next step. We’re also configuring <a id="_idIndexMarker909"/>the behavior of the <code>_recipeServiceMock</code>’s <code>LoadRecipe</code> method. As we’re not interested in what exactly is being returned in this test, we’ll leave it to <code>AutoFaker</code> to generate a <code>RecipeDetail</code> instance.</p></li> <li>Add the following code below the <code>Arrange</code> steps:<pre class="source-code">
//Act
await sut.OnNavigatedTo(parameters);</pre><p class="list-inset">By calling the ViewModel’s <code>OnNavigatedTo</code> method and passing a dictionary, we can mimic navigating to the ViewModel. This should trigger the load of the recipe’s detail information, using the passed-in <code>"id"</code> item from the dictionary.</p></li> <li>Validating whether the <code>LoadRecipe</code> method of the injected <code>IRecipeService</code> is correctly called can be achieved like this:<pre class="source-code">
//Assert
_recipeServiceMock.Verify(
    m =&gt; m.LoadRecipe(recipeId), Times.Once);</pre><p class="list-inset">The <code>Verify</code> method on a <code>Mock</code> object allows us to check whether a specific method was invoked or not. Note that we’re explicitly specifying that the <code>LoadRecipe</code> should have been called with the <code>recipeId</code> parameter. Also, with <code>Times.Once</code> we define that the method, with the given parameter, should have been called exactly once. If that isn’t the case, an exception will be thrown that will fail the test.</p></li> </ol>
<p>This powerful feature of Moq ensures that certain interactions (method calls) take place as expected. But by using Moq, we can also make our tests predictable, allowing us to check for particular output values. The following test shows how we can validate whether the data<a id="_idIndexMarker910"/> returned by the <code>IRecipeService</code>’s <code>LoadRecipe</code> method is correctly mapped on to the ViewModel:</p>
<pre class="source-code">
[Fact]
public async Task OnNavigatedTo_Should_Map_RecipeDetail()
{
    //Arrange
    <strong class="bold">var recipeDetail = AutoFaker.Generate&lt;RecipeDetail&gt;();</strong>
    var parameters = new Dictionary&lt;string, object&gt; {
        { "id", AutoFaker.Generate&lt;string&gt;() }
    };
    _recipeServiceMock
        .Setup(m =&gt; m.LoadRecipe(It.IsAny&lt;string&gt;()))
        .<strong class="bold">ReturnsAsync(Result&lt;RecipeDetail&gt;</strong>
<strong class="bold">        .Success(recipeDetail));</strong>
    //Act
    await sut.OnNavigatedTo(parameters);
    //Assert
    <strong class="bold">Assert.Equal(recipeDetail.Name, sut.Title);</strong>
<strong class="bold">    Assert.Equal(recipeDetail.Author, sut.Author);</strong>
}</pre> <p>A generated <code>recipeDetail</code> is what the <code>_recipeServiceMock</code>’s <code>LoadRecipe</code> method returns. After navigating to the ViewModel, we can check whether the properties match the<a id="_idIndexMarker911"/> value of the returned <code>recipeDetail</code> variable, assuring us the values are correctly mapped.</p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor234"/>Thin UI, deep tests</h2>
<p>One of the pinnacle benefits of the MVVM pattern, especially when coupled with DI, is the depth of our unit testing capability. Let’s look at an <a id="_idIndexMarker912"/>example that demonstrates this. Traditionally, interactions such as dialog prompts or navigation might be considered to be UI testing. But here, we’ll see how we can validate these interactions through simple unit tests. The <code>IDialogService</code> and <code>INavigationService</code>, while seeming intrinsically linked to UI, are injected as platform-independent dependencies. This abstraction ensures that our tests remain agnostic to the final UI layer, whether it’s a mobile app, a web interface, or desktop software. As a result, the UI layer remains incredibly thin, and our confidence in the bulk of our application logic – verified through these tests — remains high. Let’s dive into an example: when the <code>RecipeDetailViewModel</code> is unable to load the recipe detail, a prompt should be shown asking the user to retry. If the user selects <strong class="bold">No</strong>, the app should automatically navigate back to the previous page. Here’s what this test looks like:</p>
<pre class="source-code">
[Fact]
public async Task FailedLoad_Should_ShowDialog()
{
    //Arrange
    var parameters = new Dictionary&lt;string, object&gt; {
        { "id", AutoFaker.Generate&lt;string&gt;() }
    };
    _recipeServiceMock
        .Setup(m =&gt; m.LoadRecipe(It.IsAny&lt;string&gt;()))
        <strong class="bold">.ReturnsAsync(Result&lt;RecipeDetail&gt;</strong>
<strong class="bold">        .Fail(AutoFaker.Generate&lt;string&gt;())</strong>);
<strong class="bold">    _dialogServiceMock</strong>
<strong class="bold">        .Setup(m =&gt; m.AskYesNo(It.IsAny&lt;string&gt;(), ...))</strong>
<strong class="bold">        .ReturnsAsync(false);</strong>
    //Act
    await sut.OnNavigatedTo(parameters);
    //Assert
<strong class="bold">    _dialogServiceMock.Verify(m =&gt;       m.AskYesNo </strong><strong class="bold">(It.IsAny&lt;string&gt;(), ...), Times.Once);</strong>
<strong class="bold">    _navigationServiceMock.Verify(m =&gt; m.GoBack(),</strong>
<strong class="bold">      Times.Once);</strong>
}</pre> <p>In the previous code block, we’re configuring <code>_recipeServiceMock</code> so that it returns a <code>Fail</code> result every time the <code>LoadRecipe</code> method is called. <code>_dialogServiceMock</code> is configured so that when the <code>AskYesNo</code> method is invoked, a <code>false</code> value is returned. This mimics the user selecting <code>No</code> in the presented dialog. With all this in place, we can <a id="_idIndexMarker913"/>check that the dialog is being shown and that back navigation is triggered as a result of the user selecting <code>No</code> in the retry dialog.</p>
<p>This demonstrates how, with the right architecture and tools, even intricate interactions that touch upon UI elements can be captured, controlled, and tested – all without direct dependency on platform-specific components. This platform-independent unit testing not only ensures that our application remains both maintainable and reliable but also hardens its adaptability across various platforms. It underscores the power of the MVVM pattern!</p>
<p>However, there is still some code to<a id="_idIndexMarker914"/> be tested that is platform-specific. Let’s have a look at that before we end this chapter.</p>
<h1 id="_idParaDest-215"><a id="_idTextAnchor235"/>Testing MAUI-specific code</h1>
<p>As shown in the previous <a id="_idIndexMarker915"/>examples, the majority of our code can be tested independently of the platform. But let’s not forget that there is code in our MAUI project as well that could benefit from some unit tests.</p>
<p>Let’s start by adding a new project to hold our tests for the <code>Recipes.Mobile</code> project:</p>
<ol>
<li>Add a new <code>Recipes.Mobile.UnitTests</code>.</li>
<li>Once the project has been created, add a reference to the <code>Recipes.Mobile</code> project.</li>
<li>Add the <strong class="bold">AutoBogus</strong> NuGet package to this project.</li>
</ol>
<p>The <code>Recipes.Mobile.UnitTests</code> project doesn’t target any specific frameworks other than <code>net8.0</code>. Because of that, we need to make sure <code>net8.0</code> is on the list of target frameworks of the MAUI project as well. Also, we need to make sure that when the <code>Recipes.Mobile</code> project targets this additional <code>net8.0</code> framework, it doesn’t output an EXE file. Let’s see how to properly configure this:</p>
<ol>
<li>Open the <code>Recipes.Mobile.csproj</code> file by clicking on the project name in the <strong class="bold">Solution Explorer</strong> in <strong class="bold">Visual Studio</strong> or by right-clicking the project and selecting <strong class="bold">Edit </strong><strong class="bold">Project File</strong>.</li>
<li>Add <code>net8.0</code> to the <code>TargetFrameworks</code> tag, as shown here:<pre class="source-code">
&lt;TargetFrameworks&gt;<strong class="bold">net8.0;</strong>net8.0-android;net8.0-
  ios;net8.0-maccatalyst&lt;/TargetFrameworks&gt;</pre></li> <li>Find the <code>OutputType</code> tag in the <code>.csproj</code> file and update the following:<pre class="source-code">
&lt;OutputType <strong class="bold">Condition="'$(TargetFramework)' !=</strong>
<code>Recipes.Mobile</code> project and select <strong class="bold">Unload Project</strong>. Once unloaded, right-click it again and select <strong class="bold">Reload Project</strong>.</li>
</ol>
<p>Once the <code>Recipes.Mobile</code> project is configured, we also need to add one thing to the <code>Recipes.Mobile.UnitTests</code> project. In its <code>.csproj</code> file, find the first <code>PropertyGroup</code> tag and <a id="_idIndexMarker916"/>add the following: <code>&lt;UseMaui&gt;true&lt;/UseMaui&gt;</code>.</p>
<p>With all of this in place, writing tests for functionality in the <code>Recipes.Mobile</code> project isn’t any different from the tests we’ve written so far. Let’s have a look at how to test the <code>RatingToStarsConverter</code> class:</p>
<ol>
<li>Start by creating a new class called <code>RatingToStarsConverterTests</code>.</li>
<li>This converter makes for a good data-driven test. We can specify the input and expected output through method parameters, as shown in the following code block:<pre class="source-code">
public void Convert_Should_Return_ExpectedOutput(
    object input, string expectedOutput)
{
    //Arrange
    var sut = new Converters.RatingToStarsConverter();
    //Act
    var result = sut.Convert(input,
        null, null, null);
    //Assert
    Assert.Equal(expectedOutput, result);
}</pre><p class="list-inset">The passed-in input value is the value we want our converter to convert. The result is compared to the converted value by using <code>Assert.Equal</code>.</p></li> <li>Add the <code>Theory</code> attribute and the following <code>InlineData</code> attributes for different – edge-case – scenarios to this method:<pre class="source-code">
[InlineData("foo", "")]
[InlineData(-1d, "")]
[InlineData(6d, "")]
[InlineData(1d, "\ue838")]
[InlineData(2d, "\ue838\ue838")]
[InlineData(2.2d, "\ue838\ue838")]
[InlineData(2.5d, "\ue838\ue838\ue839")]
[InlineData(2.9d, "\ue838\ue838\ue839")]</pre></li> </ol>
<p>This test method successfully validates if the <code>RatingToStarsConverter</code> converts a given value to a string representing star-icons. Not only are happy paths tested, but also the expected behavior when passing in invalid data.</p>
<p>One other thing we can<a id="_idIndexMarker917"/> test is the <code>InstructionsDataTemplateSelector</code> class. The following steps show you how this can be done:</p>
<ol>
<li>Add a new class <code>InstructionsDataTemplateSelectorTests</code> to the <code>Recipes.Mobile.UnitTests</code> project.</li>
<li>Here’s what a test for this <code>TemplateSelector</code> could look like:<pre class="source-code">
[Fact]
public void SelectTemplate_NoteVM_Should_Return
  _NoteTemplate()
{
    //Arrange
    var template = new DataTemplate();
    var sut = new InstructionsDataTemplateSelector();
    sut.NoteTemplate = template;
    sut.InstructionTemplate = new DataTemplate();
    //Act
    var result = sut.SelectTemplate(
        AutoFaker.Generate&lt;NoteViewModel&gt;(), null);
    //Assert
    Assert.Equal(template, result);
}</pre><p class="list-inset">In this test, we’re <a id="_idIndexMarker918"/>creating a template that gets assigned to the <code>NoteTemplate</code> property of the sut. The <code>SelectTemplate</code> method of the sut gets invoked, passing in a generated <code>NoteViewModel</code>. We expect the returned <code>DataTemplate</code> to be the one we created and assigned to the <code>NoteTemplate</code> property.</p></li> </ol>
<p>With simple tests like these, we can easily validate the behavior of a <code>TemplateSelector</code> without deploying and running our app once! Testing if the <code>InstructionsDataTemplateSelector</code> works as expected for an <code>InstructionViewModel</code> or an unsupported ViewModel, should be pretty straightforward.</p>
<h1 id="_idParaDest-216"><a id="_idTextAnchor236"/>Summary</h1>
<p>In this chapter, we delved into unit testing within the MAUI framework, specifically focusing on testing ViewModels and some MAUI components. It’s worth noting that while we focused on these areas, the tools and techniques discussed are equally effective for testing services, repositories, and other integral parts of your application. Beyond just validating the code’s functionality, unit testing acts as a safety net, ensuring maintainability and robustness by reducing the chances of regression bugs. This powerful approach empowers us to iterate faster, removing the constant need for cumbersome deployments or manual checks. Leveraging mock implementations, we can seamlessly mimic and validate countless scenarios, and this validation remains ingrained in our code base. As we add or modify features, this ensures every intricate use case remains covered. A key takeaway is the significant portion of our app that can be tested independently of platform-specific details. This not only enhances adaptability but solidifies the effectiveness of the MVVM pattern. In conclusion, unit testing in MAUI isn’t just a checkbox; it’s a foundational element that drives us to build robust applications with agility and confidence. In the next and final chapter of this book, we’ll be looking at some troubleshooting and debugging tips that might come in handy when building an MVVM app with .NET MAUI.</p>
<h1 id="_idParaDest-217"><a id="_idTextAnchor237"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li>xUnit: <a href="https://xunit.net/">https://xunit.net/</a></li>
<li>Bogus for .NET: <a href="https://github.com/bchavez/Bogus">https://github.com/bchavez/Bogus</a></li>
<li>AutoBogus: <a href="https://github.com/nickdodd79/AutoBogus">https://github.com/nickdodd79/AutoBogus</a></li>
<li>Moq: <a href="https://github.com/devlooped/moq">https://github.com/devlooped/moq</a></li>
<li><em class="italic">Unit testing C# in .NET Core using dotnet test and </em><em class="italic">xUnit</em>: <a href="https://learn.microsoft.com/dotnet/core/testing/unit-testing-with-dotnet-test">https://learn.microsoft.com/dotnet/core/testing/unit-testing-with-dotnet-test</a></li>
</ul>
</div>
</div></body></html>