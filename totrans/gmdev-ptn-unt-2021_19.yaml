- en: Managing Dependencies with the Service Locator Pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will be brief because the Service Locator pattern we will review
    is simple and efficient. The core idea of this pattern is straightforward: it
    revolves around having a central registry of initialized dependencies. But to
    be more precise, these dependencies are components that offer specific services
    that we can expose with interfaces we call "service contracts". Hence, when a
    client needs to call upon a particular service, it doesn''t need to know how to
    localize and initialize it; it just needs to ask the Service Locator pattern,
    and this will do all the legwork to fulfill the service contract.'
  prefs: []
  type: TYPE_NORMAL
- en: As we will see in this chapter, it's quite a simple design and is easy to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Service Locator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a Service Locator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing alternative solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We simplified this chapter's code example for learning purposes, to present
    the pattern's core concepts without being distracted by the implementation details.
    So, the code shown is neither optimized nor contextualized enough to be used as-is
    in a project.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following chapter is hands-on, so you will need to have a basic understanding
    of Unity and C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following Unity-specific engine and C# language concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Statics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If unfamiliar with these concepts, please review [Chapter 3](c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml), *A
    Short Primer to Programming in Unity*.
  prefs: []
  type: TYPE_NORMAL
- en: The code files of this chapter can be found on GitHub, at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter16](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter16).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [https://bit.ly/36AKWli](https://bit.ly/36AKWli)
  prefs: []
  type: TYPE_NORMAL
- en: Static is a keyword modifier. A method declared as static in a class can be
    called without instantiating an object.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Service Locator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compared to more traditional patterns, the Service Locator pattern has less
    academic theory behind it and is very pragmatic in its overall design. As its
    name implies, its purpose is to locate services for a client. It achieves this
    by maintaining a central registry of objects that offer specific services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review a diagram of a typical Service Locator implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d532f91-cc29-465f-ac92-14affd8ebd4f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1 – Diagram of the Service Locator pattern
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, we could easily say that the Service Locator pattern is acting
    as a proxy between the clients (requestors) and the service providers, and this
    approach decouples them to a certain degree. A client will only need to call the Service
    Locator pattern when it has a dependency to resolve and needs access to a service. We
    could say that the Service Locator pattern is acting similarly to a waiter in
    a restaurant, taking orders from clients and acting as an intermediary between
    the various services that the restaurant offers to its clientele.
  prefs: []
  type: TYPE_NORMAL
- en: The Service Locator pattern has a bad reputation in some circles; experts often
    criticize it for being an anti-pattern. The core reason for this criticism is
    that it violates several coding best practices as it hides class dependencies
    instead of exposing them. In consequence, this could make your code harder to
    maintain and test.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks of the Service Locator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some of the potential benefits of using the Service Locator pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Runtime optimization**: The Service Locator pattern can optimize an application
    by dynamically detecting more optimized libraries or components to complete a
    specific service, depending on the runtime context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity**: Service Locator is one of the most straightforward dependency
    management patterns to implement and doesn''t have the steep learning curve of
    a **dependency injection** (**DI**) framework. Hence, you can quickly start using
    it in a project or teach it to colleagues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some drawbacks of using the Service Locator pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Black boxing**: The Service Locator pattern''s registry obfuscates class
    dependencies. Consequently, some issues might pop up at runtime instead of during
    compilation if dependencies are missing or incorrectly registered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Globally dependent**: If overly used and with the wrong intentions, the Service
    Locator pattern can become a global dependency in itself that''s arduous to manage.
    Your code will become excessively dependent on it, and eventually, it won''t be
    easy to decouple it from the rest of your core components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Service Locator pattern was popular among Java developers; it was defined
    in part by Martin Fowler in a blog post published in 2004, which you can read
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://martinfowler.com/articles/injection.html](https://martinfowler.com/articles/injection.html)'
  prefs: []
  type: TYPE_NORMAL
- en: When to use the Service Locator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The question on when to use the Service Locator pattern is self-explanatory,
    based on its description. For example, if you have a list of services that you
    dynamically need to access but want to encapsulate the process involved in obtaining
    them, then this pattern can offer a solution.
  prefs: []
  type: TYPE_NORMAL
- en: But another aspect we should consider when contemplating using the Service Locator
    pattern is when not to use it. Because a Service Locator pattern is usually globally
    accessible, as its name implies, it should locate and provide access to services.
    Then, we should use it only to expose services that have a global scope.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, we need to access the **heads-up display** (**HUD**) to update
    one of its **user interface** (**UI**) components. Should we consider the HUD
    a global service that should be accessible through the Service Locator pattern?
    The answer should be no, as the HUD only appears during certain parts of the game
    and should be accessible only by particular components in a specific context.
    But if we design a custom logging system, we could justify exposing it through
    a Service Locator pattern, as we might need to log information from anywhere in
    our code independently of context and scope.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gone through the theory, let's get our hands dirty and write
    a Service Locator pattern to provide access to a logger, an analytics system,
    and an **advertising network** (**ad network**) provider.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Service Locator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to implement a basic Service Locator pattern to expose three specific
    services, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logger**: A service that acts as a facade to a centralized logging system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analytics**: A service that sends custom analytical information to a backend
    to provide insight on player behavior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advertisement**: A service that pulls video **advertisements** (**ads**)
    from a network and displays them to monetize the game''s content at specific moments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are adding these services to the registry of the Service Locator pattern
    because of their following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: They offer a specific service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They need to be accessible from anywhere in the code base.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be mocked or removed without causing any regression in the gameplay
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we are going to see from the following code example, implementing a basic
    Service Locator pattern is a straightforward process. These are the steps we''ll
    take:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing the most important ingredient—the `ServiceLocator` class,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This version of a Service Locator pattern has three primary responsibilities,
    outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It manages a registry of services in the form of a `Dictionary`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It offers a static function named `RegisterService()` that permits an object
    to be registered as a service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It returns an instance of `service` of a specific type when requested through
    the `GetService()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has to take into account that both `RegisterService()` and `GetService()`
    are static functions, hence they are accessible directly without needing to initialize
    the `ServiceLocator` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `Services` dictionary holds a list of available services, and we flagged
    it as `readonly` and `private`; thus, we protect it from being overridden or accessed
    directly. Instead, a client will have to go through the public methods that the
    Service Locator pattern exposes to add or get a service.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our Service Locator class ready, we can now start implementing
    some service contracts in the form of interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first interface is for the `Logger` service, as illustrated in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The next interface is for the `Analytics` service, as we can see here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, we implement the code for our `Advertisement` service''s interface,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, we are going to implement concrete service classes, starting with
    the `Logger` class. The code to accomplish this is illustrated in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is the `Analytics` class. Here''s the code you''ll need to implement
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, we implement our concrete `Advertisement` service class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We now have a Service Locator pattern with services that we can register and
    access from anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Service Locator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test our implementation of the Service Locator pattern, let''s write a client
    class that we will attach as a component to a GameObject in an empty Unity scene,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It's important to note that in an actual implementation of the Service Locator
    pattern in a Unity project, we would register our services as early as possible
    during our game's lifespan so that they are made available at all times—for example,
    this task could be given to a `GameManager` object that we initialized in the
    first scene of our project. If we know that the scene and the Game Manager object
    will always be loaded when the player starts the game, we are sure the registry
    of the Service Locator pattern will be updated before clients start requesting
    access to services.
  prefs: []
  type: TYPE_NORMAL
- en: A key benefit of our approach is that we are registering services by referring
    to their interfaces, which means that at the moment we register services, we can
    choose which concrete implementation to use. Thus, we could easily have mock versions
    of each service running in a debug build. Furthermore, this approach will avoid
    adding noise to the logs and analytics during the **quality assurance** (**QA**)
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, this is one of the cool features of this pattern; you can dynamically
    inject various service versions depending on the runtime context.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main benefits of using Unity as your engine is that it offers a range
    of integrated services, including ads and analytics services, therefore most of
    the time, you will not have to implement them by hand. You can read about the
    range of available Unity services at the following link: [https://docs.unity3d.com/Manual/UnityServices.html.](https://docs.unity3d.com/Manual/UnityServices.html)
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing alternative solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are having issues with the management of dependencies in your code base,
    it might be time to start investigating the use of a DI framework. DI is a technique
    in which an object receives dependencies it needs through an "injection mechanism."
    There are several ways an object can receive its dependencies—through the constructor,
    a setter, or even with an interface that provides an injector method.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to start using DI in a structured manner is through a framework
    because this gives you a helping hand in managing complex relationships between
    objects, the initialization process, and the lifespan of dependencies. In conclusion,
    you should start considering using a DI framework when you see tight coupling
    between classes and when their dependencies are becoming a bottleneck to writing
    consistent, testable, and maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Extenject** is a free DI framework for Unity that can be downloaded from
    the Asset Store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://assetstore.unity.com/packages/tools/utilities/extenject-dependency-injection-ioc-157735](https://assetstore.unity.com/packages/tools/utilities/extenject-dependency-injection-ioc-157735)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the Service Locator pattern. This pattern is a
    simple solution to resolving a recurring challenge of managing dependencies between
    objects relying on services (functionalities) that other objects offer. In its
    simplest form, the Service Locator pattern decouples the relationship between
    a client (requester) and a service provider.
  prefs: []
  type: TYPE_NORMAL
- en: We have arrived at the end of our journey, as this is the last chapter of the
    book. We hope you enjoyed the content of each chapter. Please remember that the
    concepts presented throughout this book are just introductions, not the final
    word on the subject matter. There's a lot more to learn about design patterns,
    Unity, and game development—so much that we can't define it in a single book.
    Thus, we encourage you to continue learning, take what we reviewed together in
    each chapter, and make it better because there's always room for improvement.
  prefs: []
  type: TYPE_NORMAL
