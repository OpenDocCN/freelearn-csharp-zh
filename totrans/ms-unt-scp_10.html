<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Source Control and Other Tips</h1></div></div></div><p>This chapter considers three main tips and tricks to script in C# or to work with scripts. These tips are themselves powerful and important but do not belong squarely in any of the previous chapters, which are divided mainly by subject matter. The tips are listed here in no particular order and their main justification for inclusion is based largely on their usefulness, and also because their documentation elsewhere is sparse and often inconclusive. Consequently, this chapter reads as a useful collection of did-you-know tips and tricks, which taken together, offer knowledge that is substantial and practical. The three tips cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Git revision control</li><li class="listitem" style="list-style-type: disc">Resource folders and externals files</li><li class="listitem" style="list-style-type: disc">Loading and saving games</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec95"/>Git – source control</h1></div></div></div><p>The term <strong>source control</strong> or <strong>revision control</strong><a id="id712" class="indexterm"/> refers to any software aimed at making development in practice<a id="id713" class="indexterm"/> both simpler and safer for as many people as possible. In short, it allows you to track and undo changes to your files easily and quickly, as well as share these changes with others. Typically, software development (including game development) relies on two important facts or ingredients. First, it’s a collective effort where multiple<a id="id714" class="indexterm"/> developers work together as part of a team, either at the same physical location (such as an office) or across distant locations but sharing a virtual space (such as a virtual office, forum, or even e-mail). Second, during development, developers will tweak, edit, and make improvements to the source code. From these two seemingly simple facts comes a range of important needs that revision control aims to satisfy.</p><p>These needs are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Collaboration</strong>: When multiple developers work on coding the same project, they’ll usually need to <a id="id715" class="indexterm"/>share source files. They can send them back and forth through e-mail or other manual methods, but this makes coding difficult on a large scale and on long-term projects. It quickly becomes difficult to monitor the code changes over time and integrate or merge two sets of changes into one file.</li><li class="listitem" style="list-style-type: disc"><strong>Reverting</strong>: Sometimes, code changes and improvements turn out to be mistaken. A proposed edit or fix doesn’t always have the intended outcome and must be undone<a id="id716" class="indexterm"/> or reverted to the earlier state. You can keep copies of the earlier files yourself, but maintaining potentially many copies over time will be tedious and unnecessarily confusing.</li><li class="listitem" style="list-style-type: disc"><strong>Tracking changes and histories</strong>: Often, you’ll need to keep track of who does what, especially when debugging. If someone makes a code edit, you’ll want to know who <a id="id717" class="indexterm"/>changed the code, why, and when. Again, you could manually maintain a logfile, writing in comments and<a id="id718" class="indexterm"/> entries to document the changed process, but this would be tedious and time consuming.</li></ul></div><p>Revision control aims to solve the three main problems of collaboration, reversion, and tracking changes. Revision control software includes Git, Perforce, Microsoft Team Foundation Server, and others. This chapter specifically considers Git; it is widely used, free, cross-platform, and open source. Using Git, you can begin by configuring a special database, known as a<a id="id719" class="indexterm"/> <strong>repository</strong>, which can be either local (on your computer) or remote (via a network). Then, once configured, you can track and maintain all and any changes to your Unity projects, allowing you to revert to the earlier states of your project, if needed, and to share or collaborate with others. Let’s see how to configure Git for general use using a graphical user interface.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec58"/>Step #1 – downloading</h2></div></div></div><p>There are many ways<a id="id720" class="indexterm"/> to get up and running with Git for Unity projects. This chapter explores a combination of the official Git package alongside the frontend TortoiseGit. Using these two packages, developers can track and maintain all changes to their projects, whether working alone or in a team.</p><p>To get started, download and install the official Git<a id="id721" class="indexterm"/> software, which is available at <a class="ulink" href="http://git-scm.com/">http://git-scm.com/</a>:</p><div><img src="img/0655OT_10_01.jpg" alt="Step #1 – downloading"/><div><p>Downloading and installing Git</p></div></div><div><div><h3 class="title"><a id="tip66"/>Tip</h3><p>Detailed information on using Git can be found in the free, online e-book, <em>Pro Git</em>, <em>Scott Chacon and Ben Straub</em>, <em>Apress</em>, available<a id="id722" class="indexterm"/> at <a class="ulink" href="http://git-scm.com/book/en/v2">http://git-scm.com/book/en/v2</a>.</p></div></div><p>After Git is installed <a id="id723" class="indexterm"/>and downloaded, it’s useful to get TortoiseGit. This is not part of the original Git package but is an optional frontend component for Windows, which it allows you to integrate Git with the Windows shell as well as interact with Git through a GUI rather than the command line.</p><p>To<a id="id724" class="indexterm"/> download and install TortoiseGit, go to <a class="ulink" href="https://code.google.com/p/tortoisegit/">https://code.google.com/p/tortoisegit/</a>:</p><div><img src="img/0655OT_10_02.jpg" alt="Step #1 – downloading"/><div><p>Downloading and installing TortoiseGit</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec59"/>Step #2 – building a Unity project</h2></div></div></div><p>The reason to install Git originally was to track and maintain changes to a Unity project, allowing you to revert them if needed, acting as a backup version in case anything happens to the original files, and to<a id="id725" class="indexterm"/> share changes with other developers. This depends, therefore, on whether <a id="id726" class="indexterm"/>you already have a Unity project to maintain. The next step, then, after installing both Git and TortoiseGit is to either create a new Unity project or to find an existing one that should be tracked. The following is the screenshot of the Unity project folder:</p><div><img src="img/0655OT_10_03.jpg" alt="Step #2 – building a Unity project"/><div><p>Viewing a Unity project folder</p></div></div><p>After finding a Unity project, open the project folder in Windows explorer to see the project files. If you don’t know or don’t remember the location of the folder, you could open it directly in explorer from the Unity Editor interface. To achieve this, right-click inside the Unity <strong>Project</strong> panel and select <strong>Show in Explorer</strong> from the context menu:</p><div><img src="img/0655OT_10_04.jpg" alt="Step #2 – building a Unity project"/><div><p>Accessing the project folder from the Unity interface</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec60"/>Step #3 – configuring Unity for source control</h2></div></div></div><p>Git works with both binary and text files, but it works best with text files. When working with Unity, the editor generates many metadata files for your project and the assets you import. By default, these files are hidden and are in a binary form, and they exist inside the Unity project folder. Some <a id="id727" class="indexterm"/>of the generated metafiles<a id="id728" class="indexterm"/> are specific only to the instance of Unity that runs on your computer, such as interface preferences, while other files pertain to assets and data that are part of the project, such as meshes, textures, and script files. To get the best results from Git, you’ll need to adjust Unity’s default behavior by making metafiles visible in the <strong>Project</strong> explorer, and also using text-based formats as opposed to binary formats. To achieve this, go to <strong>Edit</strong> | <strong>Project Settings</strong> | <strong>Editor</strong> from the menu bar.</p><p>From here, use the object inspector to set the <strong>Version Control</strong> field to <strong>Visible Meta Files</strong> and the <strong>Asset Serialization</strong> field to <strong>Force Text</strong>:</p><div><img src="img/0655OT_10_05.jpg" alt="Step #3 – configuring Unity for source control"/><div><p>Configuring Unity for version control</p></div></div><p>When these settings are changed, you will see a <code class="literal">.meta</code> file associated with each project asset, including scenes. In <a id="id729" class="indexterm"/>addition, the metafile will be in a human-readable text format, which can even be edited (though manual editing is not recommended). Have a look at the following screenshot:</p><div><img src="img/0655OT_10_06.jpg" alt="Step #3 – configuring Unity for source control"/><div><p>Viewing a scene asset (in text format) inside a text editor</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec61"/>Step #4 – creating a Git repository</h2></div></div></div><p>The next phase, after creating and configuring a Unity project, is to create the Git database or repository itself that will track and maintain all changes to the Unity files. The repository can be either<a id="id730" class="indexterm"/> remote (hosted on a network or external computer) or local (hosted on the same computer). The repository will retain the original files and all the changes done to them over time, allowing you to revert to earlier versions of files, if required. The repository can also be shared and merged with other repositories for file sharing. This chapter considers only local repositories, so let’s create one now. To do this, open the Unity project folder (the root folder) and then right-click to show the Windows context menu. From the menu, choose <strong>Git Init Here</strong>:</p><div><img src="img/0655OT_10_07.jpg" alt="Step #4 – creating a Git repository"/><div><p>Creating a Git repository</p></div></div><p>Once created, a new and hidden folder named <code class="literal">.git</code> will be generated. This folder features all the repository files for the project. The icons for files and folders will change to default red symbols, indicating that the files inside the project folder have not yet been added to the repository, so Git cannot track changes made to them (we’ll deal with this soon). This is shown in the following screenshot:</p><div><img src="img/0655OT_10_08.jpg" alt="Step #4 – creating a Git repository"/><div><p>Folders highlighted in red contain files not included in the Git repository</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec62"/>Step #5 – ignoring files</h2></div></div></div><p>The Git repository is now created, ready to receive its first set of files (a <em>commit</em>). However, before adding <a id="id731" class="indexterm"/>them, there are some specific files and types that can safely be ignored. Unity features some project or system-specific files that are less project critical than user critical; that is, some files always contain only user interface preferences as <a id="id732" class="indexterm"/>well as read-only files, or temps, and other specific data that need not be added to the repository and can be safely ignored. To ignore these, we can create a <code class="literal">.gitignore</code> text file inside the project’s root folder and list all the files and folders to be ignored, as shown here:</p><div><img src="img/0655OT_10_09.jpg" alt="Step #5 – ignoring files"/><div><p>Creating a Git ignore file to exclude specific file types from the repository</p></div></div><p>For Unity, this file (<code class="literal">.gitignore</code>) should look as follows. Be sure to put the file inside the root folder:</p><div><pre class="programlisting">[Ll]ibrary/
[Tt]emp/
[Oo]bj/
[Bb]uild/
/*.csproj
/*.unityproj
/*.sln
/*.suo
/*.user
/*.userprefs
/*.pidb
/*.booproj
sysinfo.txt</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec63"/>Step #6 – creating the first commit</h2></div></div></div><p>The repository is now configured to receive the first set of Unity project files. To add these, right-click inside<a id="id733" class="indexterm"/> the root folder window, and from the context menu, go to <strong>Git Commit</strong> | <strong>Master</strong>. In Git, files are typically submitted not one by one but in batches. The <strong>Commit</strong> window allows you to <a id="id734" class="indexterm"/>select all files to commit.</p><p>Click on the <strong>All</strong> button to select all files in the folder and then assign a description in the <strong>Message</strong> field to the commit. The message should allow any user to understand the files that the commit contains. When ready, click on <strong>OK</strong> to commit the files:</p><div><img src="img/0655OT_10_10.jpg" alt="Step #6 – creating the first commit"/><div><p>Submitting the original project files</p></div></div><p>When the commit is completed, the file icons will turn green to indicate a file match, that is, to indicate that the files in the project folder are identical to those in the repository:</p><div><img src="img/0655OT_10_11.jpg" alt="Step #6 – creating the first commit"/><div><p>Files are up to date with the repository</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec64"/>Step #7 – changing files</h2></div></div></div><p>Git is supposed<a id="id735" class="indexterm"/> to be a complete file-tracking solution; this means that it should store not only your original files but all the subsequent changes and edits, allowing you to revert to any <a id="id736" class="indexterm"/>previous version.</p><p>If you now return to Unity and change your files, adding new assets or editing the existing ones, the file icons inside the Windows explorer change to red again, indicating a mismatch between the local files and the repository files:</p><div><img src="img/0655OT_10_12.jpg" alt="Step #7 – changing files"/><div><p>Changing files</p></div></div><p>If you decide that your most recent changes were a mistake and you’d like to revert back to the changes made last, you can do this by right-clicking inside the project folder window and going to <strong>TortoiseGit</strong> | <strong>Revert...</strong> from the context menu:</p><div><img src="img/0655OT_10_13.jpg" alt="Step #7 – changing files"/><div><p>Reverting (undoing) recent changes</p></div></div><p>The <strong>Revert</strong> dialog will show, allowing you to select files for reversion. Select all the required files and then <a id="id737" class="indexterm"/>choose <strong>OK</strong>. Git will then restore all the selected files, overwriting the local versions with the latest versions from the repository:</p><div><img src="img/0655OT_10_14.jpg" alt="Step #7 – changing files"/><div><p>Select files to revert</p></div></div><p>On the other hand, you might not want to revert or undo the recent changes. Instead, you might have created a valid change; this should be added to the Git repo as the latest version of the files. If so, then simply recommit the files. Right-click inside the project folder window and, from the<a id="id738" class="indexterm"/> context menu, go to <strong>Git Commit</strong> | <strong>Master</strong>. Be sure to enter a new and descriptive message for the commit inside the <strong>Message</strong> field of the <strong>Commit</strong> dialog.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec65"/>Step #8 – getting files from the repo</h2></div></div></div><p>Once the original<a id="id739" class="indexterm"/> commit of all the files has been made, if you<a id="id740" class="indexterm"/> were to delete every file in the Unity folder either intentionally or accidentally, except <a id="id741" class="indexterm"/>for the <code class="literal">.git</code> and <code class="literal">.gitignore</code> files, you could still retrieve all the latest files again. This is because the Git repo contains the files.</p><div><img src="img/0655OT_10_15.jpg" alt="Step #8 – getting files from the repo"/><div><p>You can retrieve deleted files in the project folder from the Git repo</p></div></div><div><div><h3 class="title"><a id="tip67"/>Tip</h3><p>Of course, if you are really following along with the book by deleting your own files, make sure to keep a manual backup of them, in case anything goes wrong during testing!</p></div></div><p>To achieve this, right-click inside the project folder window and navigate to <strong>TortoiseGit</strong> | <strong>Switch/Checkout</strong> from the context menu:</p><div><img src="img/0655OT_10_16.jpg" alt="Step #8 – getting files from the repo"/><div><p>Using the Switch/Checkout option to retrieve the latest files from the repo</p></div></div><p>From the <strong>Switch/Checkout</strong> dialog, select the <strong>Master</strong> branch for the <strong>Switch To</strong> field.</p><p>You might also need to enable the <strong>Force</strong> check from the options (see the documentation for more details). Then, click on <strong>OK</strong> to retrieve the latest files. You will see the following screenshot once<a id="id742" class="indexterm"/> all the files are retrieved:</p><div><img src="img/0655OT_10_17.jpg" alt="Step #8 – getting files from the repo"/><div><p>Retrieving the latest files with checkout</p></div></div><p>Alternatively, you <a id="id743" class="indexterm"/>might want to switch your project back to an earlier commit in the repo, retrieving not the latest files, but an earlier commit instead. To do this, first go to <strong>Tortoise Git</strong> | <strong>Switch /Checkout</strong> from the context menu to show the <strong>Checkout</strong> dialog. Then, from the <strong>Switch To</strong> group, enable the <strong>Commit</strong> radio box:</p><div><img src="img/0655OT_10_18.jpg" alt="Step #8 – getting files from the repo"/><div><p>Enabling the Commit radio button to retrieve older commits</p></div></div><p>Click the browse button (<strong>…</strong>) next to the <strong>Commit</strong> field to display the repo commits available, and select the earlier version to switch to. Then, click on <strong>OK</strong> to exit the <strong>Repo Commits</strong> dialog, and click on <strong>OK</strong> again to confirm the checkout from the selected commit. The files <a id="id744" class="indexterm"/>from the selected commit will then be restored to the project folder. Remember that each<a id="id745" class="indexterm"/> commit has an author (for those working in teams), and this lets you get a picture of who has changed what:</p><div><img src="img/0655OT_10_19.jpg" alt="Step #8 – getting files from the repo"/><div><p>Selecting older commits from the repo to restore</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec66"/>Step #9 – browsing the repo</h2></div></div></div><p>Sometimes, you’ll want to<a id="id746" class="indexterm"/> neither add nor retrieve files from the repository, but simply browse them to see <a id="id747" class="indexterm"/>what is there. You can do this quickly and easily using the Repo Browser tool, which is part of TortoiseGit. To access the tool, go to <strong>TortoiseGit</strong> | <strong>Repo Browser</strong> from the context menu:</p><div><img src="img/0655OT_10_20.jpg" alt="Step #9 – browsing the repo"/><div><p>View the Repo Browser tool</p></div></div><p>The Repo Browser tool allows you to preview the files and hierarchy from a GUI window:</p><div><img src="img/0655OT_10_21.jpg" alt="Step #9 – browsing the repo"/><div><p>Examining the files inside the repo</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec96"/>Resources folder and external files</h1></div></div></div><p>Your games <a id="id748" class="indexterm"/>will frequently rely on external data loaded from files such<a id="id749" class="indexterm"/> as XML files, perhaps, for subtitles, localization, or level serialization. Have a look at the following screenshot:</p><div><img src="img/0655OT_10_22.jpg" alt="Resources folder and external files"/><div><p>Printing a message loaded from an external text file asset that will compile with the project</p></div></div><p>In these cases, you want a specific range of abilities. The first one is the ability to dynamically load data from the file into memory in a way that Unity can parse and understand. The second is the ability to change and edit the file contents, even after importing it into Unity, and then have the effects of the changes update in the game without requiring code changes. The third is the ability to compile and distribute your standalone game with the file included<a id="id750" class="indexterm"/> as part of the main Unity build, rather than as a separate and editable file alongside the main executable. To elaborate further on the third point, you don’t usually want to distribute your game as a standalone build alongside<a id="id751" class="indexterm"/> separate and external files, such as XML files, which can be opened and edited by the gamer. Instead, as the developer, you want to edit and change the files from the Unity Editor, and you want the files themselves to be compiled and built into your final Unity standalone project, like other assets. You can achieve this using resource folders.</p><p>To use resource folders, create a folder named <code class="literal">resources</code> in the Unity project. A project can feature none, one, or more <code class="literal">resources</code> folders. Inside the folder, add all assets, such as text files that can be loaded by Unity at runtime:</p><div><img src="img/0655OT_10_23.jpg" alt="Resources folder and external files"/><div><p>Adding external files to the resources folder</p></div></div><p>Once a file is added to the <code class="literal">resources</code> folder, you can load it into memory with the <code class="literal">Resources.Load</code> function. See the<a id="id752" class="indexterm"/> following code sample 10-1, which loads a sample text asset into a UI text component:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;
using UnityEngine.UI;
//---------------------------------------------
public class LoadTextData : MonoBehaviour
{
  //Reference to UI Text Component
  private Text MyText = null;

  //Reference to text asset in resources folder
  private TextAsset TextData = null;
  //---------------------------------------------
  // Use this for initialization
  void Awake () {
    //Get Text Component
    MyText = GetComponent&lt;Text&gt;();

    //Load text data from resources folder
    TextData = Resources.Load("TextData") as TextAsset;
  }
  //---------------------------------------------
  // Update is called once per frame
  void Update () {
    //Update text label component
    MyText.text = TextData.text;
  }
  //---------------------------------------------
}
//---------------------------------------------</pre></div><div><div><h3 class="title"><a id="tip68"/>Tip</h3><p>More information <a id="id753" class="indexterm"/>on resource<a id="id754" class="indexterm"/> folders and the <code class="literal">Resources</code> class is available in the online Unity <a id="id755" class="indexterm"/>documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Resources.html">http://docs.unity3d.com/ScriptReference/Resources.html</a>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec97"/>AssetBundles and external files</h1></div></div></div><p>If you’re using Unity<a id="id756" class="indexterm"/> Pro and want to offer dynamic content to users, allowing gamers to<a id="id757" class="indexterm"/> <strong>modify</strong> (<strong>mod</strong>) game content, add their own assets, and add-ons, as well as support your own add-ons and plugins, then AssetBundles can be useful. AssetBundles<a id="id758" class="indexterm"/> let you package together many disparate Unity assets into a single, external file outside the main project, which can be loaded into any Unity project dynamically, either from a local file on disk or via the Internet:</p><div><img src="img/0655OT_10_24.jpg" alt="AssetBundles and external files"/><div><p>Building AssetBundles from selected assets</p></div></div><p>To get started, import the Unity asset bundle editor script to build AssetBundles easily from the <strong>Project</strong> panel. To do this, paste the<a id="id759" class="indexterm"/> following code sample<a id="id760" class="indexterm"/> 10-2 into a C# script file located inside an <code class="literal">Editor</code> folder in your project; otherwise, you can<a id="id761" class="indexterm"/> download the script from: <a class="ulink" href="http://docs.unity3d.com/ScriptReference/BuildPipeline.BuildAssetBundle.html">http://docs.unity3d.com/ScriptReference/BuildPipeline.BuildAssetBundle.html</a>:</p><div><pre class="programlisting">  // C# Example
  // Builds an asset bundle from the selected objects in the
  // project view.
  // Once compiled go to "Menu" -&gt; "Assets" and select one of the
  // choices to build the Asset Bundle

  using UnityEngine;
  using UnityEditor;
  public class ExportAssetBundles {
    [MenuItem("Assets/Build AssetBundle From Selection - Track dependencies")]
    static void ExportResource () {
      // Bring up save panel
      string path = EditorUtility.SaveFilePanel ("Save Resource", "", "New Resource", "unity3d");
      if (path.Length != 0) {
        // Build the resource file from the active selection.
        Object[] selection = Selection.GetFiltered(typeof(Object), SelectionMode.DeepAssets);
        BuildPipeline.BuildAssetBundle(Selection.activeObject, selection, path,
          BuildAssetBundleOptions.CollectDependencies | BuildAssetBundleOptions.CompleteAssets);
        Selection.objects = selection;
      }
    }
    [MenuItem("Assets/Build AssetBundle From Selection - No dependency tracking")]
    static void ExportResourceNoTrack () {
      // Bring up save panel
      string path = EditorUtility.SaveFilePanel ("Save Resource", "", "New Resource", "unity3d");
      if (path.Length != 0) {
        // Build the resource file from the active selection.
        BuildPipeline.BuildAssetBundle(Selection.activeObject, Selection.objects, path);
      }
    }
  }</pre></div><p>To make an AssetBundle, select all the assets in the <strong>Project</strong> panel to be included in the bundle and then go to <strong>Assets</strong> | <strong>Build AssetBundle from Selection</strong> from the menu bar. Once selected, choose<a id="id762" class="indexterm"/> a location on your computer where the bundle should be saved.</p><div><img src="img/0655OT_10_25.jpg" alt="AssetBundles and external files"/><div><p>Selecting assets to be included in an AssetBundle</p></div></div><p>Then, to test the AssetBundle, create a new project or open a different project without the assets, and you can load them into<a id="id763" class="indexterm"/> your project at runtime using the <code class="literal">WWW</code> class. See the following code sample 10-3 for a sample script that downloads an AssetBundle from a local file, extracts a texture asset, and assigns it to the material of an attached mesh renderer component:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class LoadAssetBundle : MonoBehaviour
{
  //Mesh Renderer Reference
  private MeshRenderer MR = null;

  // Use this for initialization
  IEnumerator Start ()
  {
    //Get asset bundle file from local machine
    WWW www = new WWW (@"file:///c:\asset_textures.unity3d");

    //Wait until load is completed
    yield return www;

    //Retrieve texture from asset bundle
    Texture2D Tex = www.assetBundle.Load("texture_wood",typeof(Texture2D)) as Texture2D;

    //Assign texture in bundle to mesh
    MR = GetComponent&lt;MeshRenderer&gt;();
    MR.material.mainTexture = Tex;
  }
}</pre></div><p>This is how the<a id="id764" class="indexterm"/> texture asset<a id="id765" class="indexterm"/> will look:</p><div><img src="img/0655OT_10_26.jpg" alt="AssetBundles and external files"/><div><p>Loading a texture asset from an AssetBundle onto a mesh renderer</p></div></div><div><div><h3 class="title"><a id="tip69"/>Tip</h3><p>More information on <a id="id766" class="indexterm"/>AssetBundles can be found in the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/AssetBundlesIntro.html">http://docs.unity3d.com/Manual/AssetBundlesIntro.html</a>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec98"/>Persistent data and saved games</h1></div></div></div><p>Allowing the gamer to<a id="id767" class="indexterm"/> save and load the state of their game is important for many games, especially longer<a id="id768" class="indexterm"/> duration games such as adventures, real-time strategies, and RPGs. In these cases, the game should allow the user to save and load game data to and from external files.</p><p>This is achieved in Unity using data serialization via either XML or binary files:</p><div><img src="img/0655OT_10_27.jpg" alt="Persistent data and saved games"/><div><p>Saving the Transform properties of an object to an XML file</p></div></div><p>
<strong>Serialization</strong> is the process of converting, or translating, data in memory (such as the state of a component on a <code class="literal">GameObject</code>) into a stream that can be written to a file and then loaded back from a file to<a id="id769" class="indexterm"/> recreate the component in memory, as it was when it was saved. The process of creating a save-game, therefore, is about first deciding which data must be saved and loaded (which is game specific) and then creating a new class to hold that data. Consider the following code sample 10-4 (<code class="literal">ObjSerializer.cs</code>) that <a id="id770" class="indexterm"/>can be attached to any <code class="literal">GameObject</code> to serialize its Transform component (Translation, Rotation, and Scale) to and from an external file, both in the XML and binary formats. To achieve this, the <code class="literal">XmlSerializer</code> class is used to convert an object in memory to XML, and the BinaryFormatter<a id="id771" class="indexterm"/> converts an object in memory to a binary file. XML files are human-readable text files, while binary files cannot normally be read or understood by humans:</p><div><pre class="programlisting">001 //-----------------------------------------------
002 using UnityEngine;
003 using System.Collections;
004 using System.Collections.Generic;
005 using System.Xml;
006 using System.Xml.Serialization;
007 using System.Runtime.Serialization.Formatters.Binary;
008 using System.IO;
009 //-----------------------------------------------
010 public class ObjSerializer : MonoBehaviour
011 {
012   //Data to save to file XML or Binary
013   [System.Serializable]
014   [XmlRoot("GameData")]
015   public class MySaveData
016   {
017     //Transform data to save/load to and from file
018     //represents a conversion of a transform object
019     //into simpler values, like floats
020     [System.Serializable]
021     public struct DataTransform
022     {
023       public float X;
024       public float Y;
025       public float Z;
026       public float RotX;
027       public float RotY;
028       public float RotZ;
029       public float ScaleX;
030       public float ScaleY;
031       public float ScaleZ;
032     }
033
034     //Transform object to save
035   public DataTransform MyTransform = new DataTransform();

036   }
037
038   //My Save Data Object declared here
039   public MySaveData MyData = new MySaveData();
040   //-----------------------------------------------
041   //Populate structure MyData with transform data
042   //This is the data to be saved to a file
043   private void GetTransform()
044   {
045     //Get transform component on this object
046     Transform ThisTransform = transform;
047
048     //Got transform, now fill data structure
049     MyData.MyTransform.X = ThisTransform.position.x;
050     MyData.MyTransform.Y = ThisTransform.position.y;
051     MyData.MyTransform.Z = ThisTransform.position.z;
052     MyData.MyTransform.RotX = ThisTransform.localRotation.eulerAngles.x;

053     MyData.MyTransform.RotY = ThisTransform.localRotation.eulerAngles.y;

054     MyData.MyTransform.RotZ = ThisTransform.localRotation.eulerAngles.z;

055     MyData.MyTransform.ScaleX = ThisTransform.localScale.x;

056     MyData.MyTransform.ScaleY = ThisTransform.localScale.y;

057     MyData.MyTransform.ScaleZ = ThisTransform.localScale.z;
058     }
059     //-----------------------------------------------
060     //Restore the transform component with loaded data
061     //Call this function after loading data back from a file
        // for restore
062     private void SetTransform()
063     {
064       //Get transform component on this object
065       Transform ThisTransform = transform;
066
067       //We got the transform component, now restore data
068       ThisTransform.position = new Vector3(MyData.MyTransform.X, MyData.MyTransform.Y, MyData.MyTransform.Z);

069       ThisTransform.rotation = Quaternion.Euler(MyData.MyTransform.RotX, MyData.MyTransform.RotY, MyData.MyTransform.RotZ);

070       ThisTransform.localScale = new Vector3(MyData.MyTransform.ScaleX, MyData.MyTransform.ScaleY, MyData.MyTransform.ScaleZ);

071     }
072   //-----------------------------------------------
073   //Saves game data to XML file
074   //Call this function to save data to an XML file
075   //Call as Save
076   public void SaveXML(string FileName = "GameData.xml")
077   {
078     //Get transform data
079     GetTransform();
080
081     //Now save game data
082     XmlSerializer Serializer = new XmlSerializer(typeof(MySaveData));

083     FileStream Stream = new FileStream(FileName, FileMode.Create);

084     Serializer.Serialize(Stream, MyData);
085     Stream.Close();
086   }
087   //-----------------------------------------------
088   //Load game data from XML file
089   //Call this function to load data from an XML file
090   //Call as Load
091   public void LoadXML(string FileName = "GameData.xml")
092   {
093     //If file doesn’t exist, then exit
094     if(!File.Exists(FileName)) return;
095
096     XmlSerializer Serializer = new XmlSerializer(typeof(MySaveData));

097     FileStream Stream = new FileStream(FileName, FileMode.Open);

098     MyData = Serializer.Deserialize(Stream) as MySaveData;

099     Stream.Close();
100
101     //Set transform - load back from a file
102     SetTransform();
103   }
104   //-----------------------------------------------
105   public void SaveBinary(string FileName = "GameData.sav")
106   {
107     //Get transform data
108     GetTransform();
109
110     BinaryFormatter bf = new BinaryFormatter();
111     FileStream Stream = File.Create(FileName);
112     bf.Serialize(Stream, MyData);
113     Stream.Close();
114   }
115   //-----------------------------------------------
116   public void LoadBinary(string FileName = "GameData.sav")
117   {
118     //If file doesn’t exist, then exit
119     if(!File.Exists(FileName)) return;
120
121     BinaryFormatter bf = new BinaryFormatter();
122   FileStream Stream = File.Open(FileName, FileMode.Open);

123     MyData = bf.Deserialize(Stream) as MySaveData;
124     Stream.Close();
125
126     //Set transform - load back from a file
127     SetTransform();
128   }
129   //-----------------------------------------------
130 }
131 //-----------------------------------------------</pre></div><div><div><h3 class="title"><a id="tip70"/>Tip</h3><p>A full example<a id="id772" class="indexterm"/> of loading and saving game data can be found in the book’s companion files<a id="id773" class="indexterm"/> in the <code class="literal">Chapter10/XML_and_Binary</code> folder.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec99"/>Summary</h1></div></div></div><p>This final chapter considered three main tips of which, perhaps, the only underlying theme has been file management. The first tip considered Git version control, specifically, how the free and open source version control software allows us to track changes across a project as well as collaborate easily with other developers. The second tip concerned loading file data dynamically, first using internal project files inside a <code class="literal">resources</code> folder and then using AssetBundles. The latter options are especially useful for the creation of external assets that can be edited by both developers and gamers alike. The third and final tip demonstrated how in-game data can be saved to a file and then loaded back through serialization. Through serialization, users can save and restore game data, allowing them to resume playback at a later time.</p></div></body></html>