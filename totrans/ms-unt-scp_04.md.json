["```cs\n // Update is called once per frame\n void Update () \n {\n    //Check enemy health\n    //Are we dead?\n    if(Health <= 0)\n    {\n          //Then perform die behaviour\n          Die();\n          return;\n    }\n\n    //Check for health low\n    if(health <= 20)\n    {\n          //Health is low, so find first-aid\n          RunAndFindHealthRestore();\n          return;\n    }\n\n    //Check ammo\n\n    //Have we run out of ammo?\n    if(Ammo <= 0)\n    {\n          //Then find more\n          SearchMore();\n          return;\n    }\n\n    //Health and ammo are fine. Can we see player? If so, shoot\n    if(HaveLineOfSight)\n    {\n            FireAtPlayer();\n   }\n }\n```", "```cs\n using UnityEngine;\n using System.Collections;\n\n public class EnemyObject : MonoBehaviour \n {\n    //-------------------------------------------------------\n    //C# accessors for private variables\n public int Health\n    {\n          get{return _health;}\n          set\n          {\n                //Clamp health between 0-100\n               _health = Mathf.Clamp(value, 0, 100);\n\n                //Check if dead\n                if(_health <= 0)\n                {\n                      OnDead();\n                      return;\n                }\n\n                //Check health and raise event if required\n                if(_health <= 20)\n                {\n                      OnHealthLow();\n                      return;\n                }\n          }\n    }\n    //-------------------------------------------------------\n public int Ammo\n    {\n          get{return _ammo;}\n          set\n          {\n               //Clamp ammo between 0-50\n              _ammo = Mathf.Clamp(value,0,50);\n                //Check if ammo empty\n                if(_ammo <= 0)\n                {\n                      //Call expired event\n                      OnAmmoExpired();\n                      return;\n                }\n          }\n    }\n    //-------------------------------------------------------\n   //Internal variables for health and ammo\n private int _health = 100;\n private int _ammo = 50;\n    //-------------------------------------------------------\n    // Update is called once per frame\n    void Update () \n    {\n    }\n    //-------------------------------------------------------\n    //This event is called when health is low\n   void OnHealthLow()\n    {\n          //Handle event response here\n    }\n    //-------------------------------------------------------\n    //This event is called when enemy is dead\n void OnDead()\n    {\n        //Handle event response here\n    }\n    //-------------------------------------------------------\n    //Ammo run out event\n void OnAmmoExpired()\n    {\n        //Handle event response here\n    }\n    //-------------------------------------------------------\n }\n```", "```cs\n01 using UnityEngine;\n02 using System.Collections;\n03 //-----------------------------------------------------------\n04 //Enum defining all possible game events\n05 //More events should be added to the list\n06 public enum EVENT_TYPE {GAME_INIT, \n07                                 GAME_END,\n08                                 AMMO_EMPTY,\n09                                 HEALTH_CHANGE,\n10                                 DEAD};\n11 //-----------------------------------------------------------\n12 //Listener interface to be implemented on Listener classes\n13 public interface IListener\n14 {\n15 //Notification function invoked when events happen\n16 void OnEvent(EVENT_TYPE Event_Type, Component Sender, Object Param = null);\n\n17 }\n18 //-----------------------------------------------------------\n```", "```cs\nusing UnityEngine;\n using System.Collections;\n\n public class MyCustomListener : MonoBehaviour, IListener\n {\n    // Use this for initialization\n    void Start () {}\n    // Update is called once per frame\n    void Update () {}\n    //---------------------------------------\n    //Implement OnEvent function to receive Events \n public void OnEvent(EVENT_TYPE Event_Type, Component Sender, Object Param = null)\n    {\n    }\n    //---------------------------------------\n }\n```", "```cs\n001 using UnityEngine;\n002 using System.Collections;\n003 using System.Collections.Generic;\n004 //-----------------------------------\n005 //Singleton EventManager to send events to listeners\n006 //Works with IListener implementations\n007 public class EventManager : MonoBehaviour\n008 {\n009      #region C# properties\n010 //-----------------------------------\n011     //Public access to instance\n012     public static EventManager Instance\n013       {\n014             get{return instance;}\n015             set{}\n016       }\n017    #endregion\n018 \n019    #region variables\n020       // Notifications Manager instance (singleton design pattern)\n021    private static EventManager instance = null;\n022 \n023      //Array of listeners (all objects registered for events)\n024      private Dictionary<EVENT_TYPE, List<IListener>> Listeners = new Dictionary<EVENT_TYPE, List<IListener>>();\n\n025     #endregion\n026 //-----------------------------------------------------------\n027     #region methods\n028      //Called at start-up to initialize\n029     void Awake()\n030     {\n031             //If no instance exists, then assign this instance\n032             if(instance == null)\n033            {\n034                   instance = this;\n035                   DontDestroyOnLoad(gameObject); \n036            }\n037             else\n038                   DestroyImmediate(this);\n039      }\n040//-----------------------------------------------------------\n041      /// <summary>\n042      /// Function to add listener to array of listeners\n043      /// </summary>\n044      /// <param name=\"Event_Type\">Event to Listen for</param>\n045     /// <param name=\"Listener\">Object to listen for event</param>\n046     public void AddListener(EVENT_TYPE Event_Type, IListener Listener)\n047     {\n048            //List of listeners for this event\n049            List<IListener> ListenList = null;\n050 \n051            // Check existing event type key. If exists, add to list\n052            if(Listeners.TryGetValue(Event_Type, out ListenList))\n053            {\n054                   //List exists, so add new item\n055                   ListenList.Add(Listener);\n056                   return;\n057            }\n058 \n059            //Otherwise create new list as dictionary key\n060            ListenList = new List<IListener>();\n061            ListenList.Add(Listener);\n062            Listeners.Add(Event_Type, ListenList); \n063      }\n064 //-----------------------------------------------------------\n065       /// <summary>\n066       /// Function to post event to listeners\n067       /// </summary>\n068       /// <param name=\"Event_Type\">Event to invoke</param>\n069       /// <param name=\"Sender\">Object invoking event</param>\n070       /// <param name=\"Param\">Optional argument</param>\n071       public void PostNotification(EVENT_TYPE Event_Type, Component Sender, Object Param = null)\n\n072       {\n073            //Notify all listeners of an event\n074 \n075            //List of listeners for this event only\n076            List<IListener> ListenList = null;\n077 \n078            //If no event exists, then exit \n079            if(!Listeners.TryGetValue(Event_Type, out ListenList))\n080                    return;\n081 \n082             //Entry exists. Now notify appropriate listeners\n083             for(int i=0; i<ListenList.Count; i++)\n084             {\n085                   if(!ListenList[i].Equals(null)) \n086 \nListenList[i].OnEvent(Event_Type, Sender, Param);\n087             }\n088      }\n089 //-----------------------------------------------------------\n090      //Remove event from dictionary, including all listeners\n091      public void RemoveEvent(EVENT_TYPE Event_Type)\n092      {\n093            //Remove entry from dictionary\n094            Listeners.Remove(Event_Type);\n095      }\n096 //-----------------------------------------------------------\n097       //Remove all redundant entries from the Dictionary\n098      public void RemoveRedundancies()\n099      {\n100             //Create new dictionary\n101             Dictionary<EVENT_TYPE, List<IListener>> TmpListeners = new Dictionary<EVENT_TYPE, List<IListener>>();\n\n102 \n103             //Cycle through all dictionary entries\n104             foreach(KeyValuePair<EVENT_TYPE, List<IListener>> Item in Listeners)\n\n105             {\n106                   //Cycle all listeners, remove null objects\n107                   for(int i = Item.Value.Count-1; i>=0; i--)\n108                   {\n109                         //If null, then remove item\n110                         if(Item.Value[i].Equals(null))\n111                                 Item.Value.RemoveAt(i);\n112                   }\n113 \n114            //If items remain in list, then add to tmp dictionary\n115                    if(Item.Value.Count > 0)\n116                          TmpListeners.Add (Item.Key, Item.Value);\n117             }\n118 \n119             //Replace listeners object with new dictionary\n120             Listeners = TmpListeners;\n121       }\n122 //-----------------------------------------------------------\n123       //Called on scene change. Clean up dictionary\n124       void OnLevelWasLoaded()\n125       {\n126            RemoveRedundancies();\n127       }\n128 //-----------------------------------------------------------\n129      #endregion\n130 }\n```", "```cs\n//Called at start-up\nvoid Start()\n{\n//Add myself as listener for health change events\nEventManager.Instance.AddListener(EVENT_TYPE.HEALTH_CHANGE, this);\n}\n```", "```cs\npublic int Health\n{\nget{return _health;}\nset\n{\n   //Clamp health between 0-100\n   _health = Mathf.Clamp(value, 0, 100);\n\n   //Post notification - health has been changed EventManager.Instance.PostNotification(EVENT_TYPE.HEALTH_CHANGE, this, _health);\n}\n}\n```", "```cs\n//Called when events happen\npublic void OnEvent(EVENT_TYPE Event_Type, Component Sender, object Param = null)\n{\n//Detect event type\nswitch(Event_Type)\n{\n    case EVENT_TYPE.HEALTH_CHANGE:\n         OnHealthChange(Sender, (int)Param);\n    break;\n}\n}\n```", "```cs\n001 using UnityEngine;\n002 using System.Collections;\n003 using System.Collections.Generic;\n004 //-----------------------------------------------------------\n005 //Enum defining all possible game events\n006 //More events should be added to the list\n007 public enum EVENT_TYPE {GAME_INIT, \n008       GAME_END,\n009       AMMO_CHANGE,\n010        HEALTH_CHANGE,\n011        DEAD};\n012 //-----------------------------------------------------------\n013 //Singleton EventManager to send events to listeners\n014 //Works with delegate implementations\n015 public class EventManager : MonoBehaviour\n016 {\n017       #region C# properties\n018 //-----------------------------------------------------------\n019      //Public access to instance\n020      public static EventManager Instance\n021      {\n022             get{return instance;}\n023             set{}\n024      }\n025      #endregion\n026 \n027      #region variables\n028      //Notifications Manager instance (singleton design pattern)\n029      private static EventManager instance = null;\n030 \n031      // Declare a delegate type for events\n032      public delegate void OnEvent(EVENT_TYPE Event_Type, Component Sender, object Param = null);\n\n033 \n034       //Array of listener objects\n035       private Dictionary<EVENT_TYPE, List<OnEvent>> Listeners = new Dictionary<EVENT_TYPE, List<OnEvent>>();\n\n036       #endregion\n037 //-----------------------------------------------------------\n038      #region methods\n039      //Called at start-up to initialize\n040      void Awake()\n041      {\n042            //If no instance exists, then assign this instance\n043           if(instance == null)\n044            {\n045                   instance = this;\n046                   DontDestroyOnLoad(gameObject); \n047            }\n048            else\n049                   DestroyImmediate(this);\n050      }\n051 //-----------------------------------------------------------\n052      /// <summary>\n053      /// Add listener-object to array of listeners\n054      /// </summary>\n055      /// <param name=\"Event_Type\">Event to Listen for</param>\n056      /// <param name=\"Listener\">Object to listen for event</param>\n057     public void AddListener(EVENT_TYPE Event_Type, OnEvent Listener)\n\n058     {\n059             //List of listeners for this event\n060             List<OnEvent> ListenList = null;\n061 \n062            // Check existing event. If one exists, add to list\n063           if(Listeners.TryGetValue(Event_Type, out ListenList))\n064            {\n065                   //List exists, so add new item\n066                   ListenList.Add(Listener);\n067                   return;\n068             }\n069 \n070            //Otherwise create new list as dictionary key\n071            ListenList = new List<OnEvent>();\n072            ListenList.Add(Listener);\n073            Listeners.Add(Event_Type, ListenList); \n074      }\n075 //-----------------------------------------------------------\n076       /// <summary>\n077       /// Function to post event to listeners\n078       /// </summary>\n079       /// <param name=\"Event_Type\">Event to invoke</param>\n080       /// <param name=\"Sender\">Object invoking event</param>\n081       /// <param name=\"Param\">Optional argument</param>\n082       public void PostNotification(EVENT_TYPE Event_Type, Component Sender, object Param = null)\n\n083       {\n084             //Notify all listeners of an event\n085 \n086             //List of listeners for this event only\n087             List<OnEvent> ListenList = null;\n088 \n089             //If no entry exists, then exit \n090            if(!Listeners.TryGetValue(Event_Type, out ListenList))\n091                   return;\n092 \n093            //Entry exists. Now notify appropriate listeners\n094            for(int i=0; i<ListenList.Count; i++)\n095             {\n096                 if(!ListenList[i].Equals(null)) \n097                         ListenList[i](Event_Type, Sender, Param);\n098            }\n099      }\n100 //-----------------------------------------------------------\n101       //Remove event from dictionary, including all listeners\n102       public void RemoveEvent(EVENT_TYPE Event_Type)\n103       {\n104            //Remove entry from dictionary\n105            Listeners.Remove(Event_Type);\n106       }\n107 //-----------------------------------------------------------\n108       //Remove all redundant entries from the Dictionary\n109       public void RemoveRedundancies()\n110       {\n111             //Create new dictionary\n112             Dictionary<EVENT_TYPE, List<OnEvent>> TmpListeners = new Dictionary<EVENT_TYPE, List<OnEvent>>();\n\n113 \n114            //Cycle through all dictionary entries\n115            foreach(KeyValuePair<EVENT_TYPE, List<OnEvent>> Item in Listeners)\n\n116            {\n117                   //Cycle through all listeners\n118                   for(int i = Item.Value.Count-1; i>=0; i--)\n119                   {\n120                        //If null, then remove item\n121                       if(Item.Value[i].Equals(null))\n122                            Item.Value.RemoveAt(i);\n123                   }\n124 \n125                  //If items remain, then add to tmp dictionary\n126                  if(Item.Value.Count > 0)\n127                       TmpListeners.Add (Item.Key, Item.Value);\n128            }\n129 \n130            //Replace listeners with new dictionary\n131            Listeners = TmpListeners;\n132      }\n133 //-----------------------------------------------------------\n134      //Called on scene change. Clean up dictionary\n135      void OnLevelWasLoaded()\n136      {\n137              RemoveRedundancies();\n138      }\n139 //-----------------------------------------------------------\n140       #endregion\n141 }\n```", "```cs\nusing UnityEngine;\n using System.Collections;\n //---------------------\n public class ManualMouse : MonoBehaviour\n {\n    //---------------------\n    //Get collider attached to this object\n    private Collider Col = null;\n    //---------------------\n    //Awake function - called at start up\n    void Awake()\n    {\n         //Get collider\n         Col = GetComponent<Collider>();\n    }\n    //---------------------\n    //Start Coroutine\n    void Start()\n    {\n          StartCoroutine(UpdateMouse());\n   }\n   //---------------------\n   public IEnumerator UpdateMouse()\n   {\n         //Are we being intersected\n         bool bIntersected = false;\n\n         //Is button down or up\n         bool bButtonDown = false;\n\n         //Loop forever\n         while(true)\n         {\n         //Get mouse screen position in terms of X and Y\n         //You may need to use a different camera Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\n         RaycastHit hit;\n\n               //Test ray for collision against this collider\n               if (Col.Raycast(ray, out hit, Mathf.Infinity))\n               {\n   //Object was interesected  if(!bIntersected) SendMessage(\"OnMouseEnter\", SendMessageOptions.DontRequireReceiver);\n\n                       bIntersected = true;\n\n               //Test for mouse events\n               if(!bButtonDown && Input.GetMouseButton(0))\n{\nbButtonDown = true; SendMessage(\"OnMouseDown\", SendMessageOptions.DontRequireReceiver);\n}\n\n                if(bButtonDown && !Input.GetMouseButton(0))\n{\nbButtonDown = false; SendMessage(\"OnMouseUp\", SendMessageOptions.DontRequireReceiver);\n}\n                }\n                else\n                {\n                      //Was previously entered and now leaving\n                      if(bIntersected) SendMessage(\"OnMouseExit\", SendMessageOptions.DontRequireReceiver);\n\n                      bIntersected = false;\n                      bButtonDown = false;\n                }\n\n                //Wait until next frame\n                yield return null;\n           }\n    }\n    //---------------------\n }\n //---------------------\n```"]