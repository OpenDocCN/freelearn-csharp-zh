- en: Chapter 6. Platform Extras
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。平台扩展
- en: 'This chapter concentrates on platform-specific APIs and features. It explains
    some of the peripherals that can be employed in Xamarin applications. We will
    also discuss native libraries and how to include them in cross platform Xamarin
    applications. The following topics will be discussed:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专注于特定平台的 API 和功能。它解释了可以在 Xamarin 应用程序中使用的某些外设。我们还将讨论原生库以及如何在跨平台 Xamarin 应用程序中包含它们。以下主题将被讨论：
- en: Content sharing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容共享
- en: Peripherals
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外设
- en: Location data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置数据
- en: Native libraries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生库
- en: Content sharing
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容共享
- en: Each Xamarin target platform implements a certain strategy to share formatted
    content between the applications. Sharing implementations increases the visibility
    of your applications by allowing users to open files from your application in
    any other app. In addition, these types of implementations provide added value
    to the quality of your cross platform projects from the nativity perspective.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Xamarin 目标平台都实现了一种在应用程序之间共享格式化内容的策略。共享实现通过允许用户在任何其他应用程序中打开来自您的应用程序的文件来提高您应用程序的可见性。此外，这些类型的实现从原生角度为您的跨平台项目提供了额外的价值。
- en: The inter-application sharing occurs with the underlying runtime acting as a
    broker between the sharing source and target applications. On iOS and Windows
    Store applications, the sharing is facilitated in the form of abstract file elements.
    Android applications, however, can take it one step further by sharing formatted
    data that can be manipulated by the receiving application, which essentially allows
    the source application to almost act as a data repository.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序间的共享是通过底层运行时作为共享源和目标应用程序之间的经纪人来实现的。在 iOS 和 Windows Store 应用程序中，共享以抽象文件元素的形式进行。然而，Android
    应用程序可以更进一步，通过共享可以被接收应用程序操作格式化数据来共享，这本质上允许源应用程序几乎充当数据存储库。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Windows Store, applications can actively share content such as media elements,
    URIs, text content, and other types of data. However, in this implementation strategy,
    that is, sharing contact implementation, the source application has to initiate
    the sharing process. The content sharing scenarios described in this book are
    about target applications accessing the content via the source application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows Store 中，应用程序可以主动共享内容，如媒体元素、URI、文本内容和其他类型的数据。然而，在这个实现策略中，即共享实现策略中，源应用程序必须启动共享过程。本书中描述的内容共享场景是关于目标应用程序通过源应用程序访问内容。
- en: On Windows Runtime, applications interact with each other or with the operating
    system through the usage of so-called application contracts. With the help of
    contracts, applications can immerse into the runtime and get one step closer to
    become part of the runtime.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows Runtime 中，应用程序通过所谓的应用程序合约的用法相互交互或与操作系统交互。借助合约，应用程序可以沉浸到运行时中，并更接近成为运行时的一部分。
- en: The same functionality is achieved by the implementation of the base `ContentProviders`
    on Android and the implementation of document provider extensions on the iOS platform.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 Android 上实现基本 `ContentProviders` 和在 iOS 平台上实现文档提供程序扩展，实现了相同的功能。
- en: File pickers and contracts (Windows Store apps)
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件选择器和合约（Windows Store 应用程序）
- en: One of the most commonly used contracts is the File Open Picker contract on
    Windows Runtime. In this contract implementation, the source application has to
    implement the activation strategy for when it is called to provide file content
    for the target application. When the target application requires a certain type
    of file, the runtime lists all possible source applications that declares this
    type in their app manifest (for example, on a Windows Phone, when you want to
    attach a document on the mail client together along with a picture, the OneDrive
    application is displayed as one of the possible sources).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Runtime 中最常用的合约之一是文件打开选择器合约。在这个合约实现中，源应用程序必须实现当它被调用以为目标应用程序提供文件内容时的激活策略。当目标应用程序需要某种类型的文件时，运行时会列出所有可能声明这种类型在其应用程序清单中的源应用程序（例如，在
    Windows Phone 上，当您想在邮件客户端中附加文档并附带一张图片时，OneDrive 应用程序会显示为可能来源之一）。
- en: The user then selects the file that they want to use in the current application
    and the provider app is responsible for either creating or providing the file
    to the target application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 用户随后选择他们想要在当前应用程序中使用的文件，提供程序应用程序负责为目标应用程序创建或提供文件。
- en: '![File pickers and contracts (Windows Store apps)](img/B04693_06_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![文件选择器和合约（Windows Store应用程序）](img/B04693_06_01.jpg)'
- en: File picker contract in Windows Runtime
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Runtime中的文件选择器合约
- en: In this methodology, the file does not necessarily need to be an actual document
    item, but it can be a conceptual one. For instance, if we were to implement the
    File Open Picker in the TravelTrace app, we would not need to use actual documents
    in the File Open Picker to provide content. The shared content items could be
    the previous trips that the user kept track of and the selected trip could provide
    a generated scrap book or a collage of images in an image format or as a PDF document
    according to the type of document that is being requested by the consumer app.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，文件不一定是实际的文档项，但它可以是概念性的。例如，如果我们要在TravelTrace应用程序中实现文件打开选择器，我们不需要在文件打开选择器中使用实际的文档来提供内容。共享的内容项可以是用户跟踪的之前的旅行，所选的旅行可以提供一个生成的剪贴簿或图像的拼贴，根据消费者应用程序请求的文档类型，可以是图像格式或PDF文档。
- en: Document Provider extensions (iOS)
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档提供者扩展（iOS）
- en: The Document Provider extensions (introduced in iOS 8) allow applications, that
    is, consuming applications) to access documents outside their application sandbox.
    Document Provider extensions are twofold. The Document Picker View Controller
    extension provides a UI implementation for the operating system to display whenever
    the source application is selected as a document source in the document picker
    view. However, the File Provider extension is responsible for providing the document
    level operations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 文档提供者扩展（在iOS 8中引入）允许应用程序（即消费应用程序）访问其应用程序沙盒之外的文档。文档提供者扩展有两方面。文档选择器视图控制器扩展为操作系统提供UI实现，以便在源应用程序被选为文档选择器视图中的文档源时显示。然而，文件提供者扩展负责提供文档级别的操作。
- en: In order to create a provider extension, we can use the existing project template
    in Xamarin Studio.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个提供者扩展，我们可以在Xamarin Studio中使用现有的项目模板。
- en: '![Document Provider extensions (iOS)](img/B04693_06_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![文档提供者扩展（iOS）](img/B04693_06_02.jpg)'
- en: The Document Picker extension project template
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 文档选择器扩展项目模板
- en: Once the project is created, we are responsible for creating the view on the
    storyboard and implementing `DocumentPickerViewController` so that the available
    files are listed on the UI when our application is selected to provide files.
    `DocumentPickerViewController` initially has two methods that require our attention.
    The `PrepareForPresentation` method receives the picker mode (`Import`, `Open`,
    `ExportToService`, or `MoveToService`) so the user interface can be prepared according
    to the requested operation. The `OpenDocument` method is implemented just for
    our convenience to demonstrate the fact that once the user selects a document,
    we should prepare the corresponding file URL and pass it onto the runtime using
    the `DismissGrantingAccess` method.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建项目，我们就负责在故事板中创建视图并实现`DocumentPickerViewController`，以便当我们的应用程序被选中提供文件时，可用的文件在UI上列出。`DocumentPickerViewController`最初有两个需要我们注意的方法。`PrepareForPresentation`方法接收选择器模式（`Import`、`Open`、`ExportToService`或`MoveToService`），以便用户界面可以根据请求的操作进行准备。`OpenDocument`方法仅为了我们的方便而实现，以证明一旦用户选择了一个文档，我们应该准备相应的文件URL，并使用`DismissGrantingAccess`方法将其传递给运行时。
- en: It is important to keep in mind that the URL provided from our Document Picker
    extension should already point to an actual file, or we should go on to implement
    the Document File Provider extension that will provide the files when either the
    consuming app displays the document picker and the user selects the file or the
    consuming app opens the file directly using the cached URL.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，我们文档选择器扩展提供的URL应该已经指向一个实际文件，或者我们应该继续实现文档文件提供者扩展，该扩展将在消费应用程序显示文档选择器并用户选择文件，或者消费应用程序直接使用缓存的URL打开文件时提供文件。
- en: In the Document File Provider extension project, the crucial implementation
    is located in the `StartProvidingItemAtUrl` method. This method uses the `FileCoordinator`
    class provided to create the file at the target URL (for example, generates the
    file or downloads it from a remote location).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档文件提供者扩展项目中，关键实现位于`StartProvidingItemAtUrl`方法。此方法使用提供的`FileCoordinator`类在目标URL处创建文件（例如，生成文件或从远程位置下载）。
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After the implementation of the extensions is complete, we have to prepare the
    project metadata entries. Each project (both extensions and the container application)
    needs to make use of the **App Groups** capability. This capability needs to be
    set up in the **Entitlements** option list. Other settings involve the base document
    storage URL, type of operations supported for the document picker, and so on.
    However, these configuration values are inserted in the `Info.plist` option list.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展实现完成后，我们必须准备项目元数据条目。每个项目（包括扩展和容器应用程序）都需要使用**App Groups**功能。这个功能需要在**Entitlements**选项列表中设置。其他设置包括基本文档存储URL、文档选择器支持的操作类型等。然而，这些配置值是在`Info.plist`选项列表中插入的。
- en: '![Document Provider extensions (iOS)](img/B04693_06_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![文档提供者扩展（iOS）](img/B04693_06_03.jpg)'
- en: Entitlements for Document Provider extensions
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 文档提供者扩展的权限
- en: In order to add the extensions to the containing application, the only thing
    we need to do is to add them as references to the main project. If you look at
    the project file of the main project, you will notice that the references are
    added with the `IsExtension` flag set to true.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将扩展添加到包含的应用程序中，我们只需要将它们作为引用添加到主项目中。如果你查看主项目文件，你会注意到引用是通过将`IsExtension`标志设置为true来添加的。
- en: ContentProvider and ContentResolver (Android)
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ContentProvider和ContentResolver（Android）
- en: Content providers on Android platform act as data repositories. These repositories
    are exposed to consuming applications through structured endpoint descriptions
    (similar to REST endpoints on web services). Using the metadata provided, providers'
    content is resolved by the consuming app through the implementation of `ContentResolvers`.
    Using content providers, applications can expose well-known data types such as
    contact list photos or calendar events, as well as custom data types and formatted
    data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓平台上的内容提供者充当数据存储库。这些存储库通过结构化端点描述（类似于网络服务上的REST端点）暴露给消费应用程序。使用提供的元数据，消费应用程序通过实现`ContentResolvers`来解析提供者的内容。使用内容提供者，应用程序可以公开已知的数据类型，如联系人列表照片或日历事件，以及自定义数据类型和格式化数据。
- en: On the consumer side of this infrastructure, there are many content providers
    already implemented by default on Android runtime, such as `Contacts`, `MediaStore`,
    `UserDictionary`, and so on. These providers can be accessed by implementing base
    classes such as `ContentResolver` and `CursorAdapter`. `CursorAdapter` is used
    to feed the data that is retrieved by `ContentResolver` to a UI list view control.
    The `ContentProvider` API operations can involve list queries and CRUD operations
    on individual records.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础设施的消费端，Android运行时已经默认实现了许多内容提供者，例如`Contacts`、`MediaStore`、`UserDictionary`等。这些提供者可以通过实现基类如`ContentResolver`和`CursorAdapter`来访问。`CursorAdapter`用于将`ContentResolver`检索到的数据馈送到UI列表视图控件。`ContentProvider`
    API操作可能涉及列表查询和对单个记录的CRUD操作。
- en: Provider applications are responsible for registering an authority that is unique
    to the application. The authority entry can be described as the base content URI
    for a specific application. Either it can be added to the manifest file, or an
    attribute entry could be used on the class that is implementing `ContentProvider`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者应用程序负责注册一个对应用程序唯一的权限。权限条目可以描述为特定应用程序的基本内容URI。它既可以添加到清单文件中，也可以在实现`ContentProvider`的类上使用属性条目。
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Another important piece of metadata that the content provider needs to provide
    is the Mime-Type information. In order to facilitate the use of `CursorAdapter`
    on consumer applications, the content provider needs to provide a Mime-Type for
    a list of items (starting with `vnd.android.cursor.dir`) as well as for a single
    item (starting with `vnd.android.cursor.item`).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 内容提供者还需要提供另一项重要的元数据，即Mime-Type信息。为了便于在消费应用程序中使用`CursorAdapter`，内容提供者需要为项目列表（以`vnd.android.cursor.dir`开头）以及单个项目（以`vnd.android.cursor.item`开头）提供Mime-Type。
- en: Finally, the content provider needs to expose the data columns for the data
    that is being made available to other applications. This is achieved by hiding
    the `InterfaceConstants` nested class from the base abstract class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，内容提供者需要公开其他应用程序可用的数据的数据列。这是通过从基本抽象类中隐藏`InterfaceConstants`嵌套类来实现的。
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Another optional implementation would be to create a `UriMatcher` class that
    could ease the implementation process for the query methods.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可选的实现方法是创建一个`UriMatcher`类，这可以简化查询方法的实现过程。
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The final implementation is related to the query, update, insert, and delete
    methods. Each of these methods needs to return the `ICursor` implementations according
    to the abstract class defined.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最终实现与查询、更新、插入和删除方法相关。这些方法中的每一个都需要根据定义的抽象类返回`ICursor`实现。
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Overall, while providing more flexibility for content sharing, Android makes
    it a little more difficult for other applications to consume the data provided
    by the source application. The data provided by a content provider implementation
    on a Xamarin.Android application cannot be consumed by another without a specialized
    implementation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，虽然 Android 提供了更多内容共享的灵活性，但它使得其他应用程序消费源应用程序提供的数据变得稍微困难一些。在 Xamarin.Android
    应用程序上，内容提供程序实现提供的数据无法在没有专门实现的情况下被其他应用程序消费。
- en: Peripherals
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外设
- en: In this section, we will discuss several communication protocols that enable
    applications to communicate with other platforms and other devices.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论几个通信协议，这些协议使应用程序能够与其他平台和其他设备进行通信。
- en: Bluetooth
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蓝牙
- en: The Bluetooth communication protocol has become an invaluable feature on mobile
    devices. Especially with the emerging technologies related to **IoT** (**Internet
    of Things**), and various accessories we use in daily life, our dependency on
    the Bluetooth stack on mobile platforms has increased.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙通信协议已成为移动设备上的一个宝贵功能。特别是随着与**物联网（IoT）**相关的技术的兴起，以及我们日常生活中使用的各种配件，我们对移动平台上的蓝牙堆栈的依赖性有所增加。
- en: While Xamarin.Android applications and Windows Runtime applications can make
    use of both GATT (Bluetooth Low Energy) and RFCOMM (Bluetooth Serial), iOS applications
    can only communicate through the Bluetooth LE protocol. The main reason for this
    discrepancy is the fact that Android and Windows Runtime implement the serial
    communication port according to shared specifications. However, Apple implements
    a propriety communication stack using an encryption system. This, unfortunately,
    limits the serial communication to between only Apple produced/compliant accessories
    or devices.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Xamarin.Android 应用程序和 Windows Runtime 应用程序都可以使用 GATT（蓝牙低功耗）和 RFCOMM（蓝牙串行），但
    iOS 应用程序只能通过蓝牙低功耗协议进行通信。这种差异的主要原因是 Android 和 Windows Runtime 根据共享规范实现串行通信端口。然而，苹果使用一个专有的通信堆栈，并使用加密系统。这不幸地限制了串行通信仅限于苹果生产或符合标准的配件或设备之间。
- en: 'For Xamarin.Android, Bluetooth APIs reside in the `Android.Bluetooth` namespace.
    Using the provided classes, developers can enhance their applications with features
    like:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Xamarin.Android，蓝牙 API 位于`Android.Bluetooth`命名空间中。使用提供的类，开发者可以增强他们的应用程序，添加如下功能：
- en: Scanning for discoverable Bluetooth devices (including LE protocol)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描可发现蓝牙设备（包括 LE 协议）
- en: Getting information on the local BT adapter and paired devices
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取本地蓝牙适配器和配对设备的信息
- en: Creating Serial Communication Sockets using the RFCOMM protocol
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RFCOMM 协议创建串行通信套接字
- en: Acting both as a GATT client or a GATT server
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时作为 GATT 客户端或 GATT 服务器
- en: Bluetooth protocols can be accessed only with the user permission manifest entry
    for Bluetooth.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在用户权限清单条目中声明蓝牙的情况下，才能访问蓝牙协议。
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On Windows Runtime, Bluetooth-related features are implemented in the `Windows.Devices.Bluetooth`
    namespace. Similar to the feature-set in Android, Windows Runtime Bluetooth stack
    requires the applications to declare the adapter access requirement and the protocol
    to be used in the application manifest (for some specific devices and protocols,
    the Bluetooth capability declaration has to be inserted manually into the manifest).
    An important feature on this platform is that the Bluetooth connectivity can be
    facilitated and kept alive by background tasks, enabling the devices to continue
    their operations in the backgrounded or suspended states.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows Runtime 上，蓝牙相关功能在`Windows.Devices.Bluetooth`命名空间中实现。与 Android 中的功能集类似，Windows
    Runtime 蓝牙堆栈要求应用程序在应用程序清单中声明适配器访问要求和要使用的协议（对于某些特定设备和协议，蓝牙能力声明必须手动插入到清单中）。该平台的一个重要特性是，可以通过后台任务促进并保持蓝牙连接，使设备能够在后台或挂起状态下继续其操作。
- en: For Xamarin.iOS, Bluetooth LE related implementations would need to use the
    `CoreBluetooth` framework.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Xamarin.iOS，蓝牙低功耗（BLE）相关的实现需要使用`CoreBluetooth`框架。
- en: An important component that is currently in the Xamarin store for cross-platform
    peripherals integration is the Monkey.Robotics project. While implementing the
    basic APIs for Bluetooth LE and Wi-Fi, some other vendor-specific peripherals,
    such as health monitoring devices and smart watches, can be used with this component.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在Xamarin商店中，用于跨平台外围设备集成的关键组件是Monkey.Robotics项目。在实现蓝牙LE和Wi-Fi的基本API时，可以使用此组件与一些其他供应商特定的外围设备，例如健康监测设备和智能手表。
- en: Wi-Fi Direct
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Wi-Fi Direct
- en: Wi-Fi Direct is another communication protocol that allows Wi-Fi enabled devices
    to create **peer-to-peer** (**P2P**) networks and exchange information using the
    Wi-Fi adapter without using a common provider network connection.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Wi-Fi Direct是另一种通信协议，允许Wi-Fi设备创建**点对点**（**P2P**）网络，并使用Wi-Fi适配器在不使用公共提供者网络连接的情况下交换信息。
- en: Out of the Xamarin target platforms that are described in this book, only the
    Android platform supports this protocol. The Windows 10 platform will support
    Wi-Fi Direct; however, this implementation will be targeting only Windows based
    devices.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中描述的Xamarin目标平台中，只有Android平台支持此协议。Windows 10平台将支持Wi-Fi Direct；然而，此实现将仅针对基于Windows的设备。
- en: On Android devices, with the introduction of Wi-Fi P2P, developers can create
    applications that can communicate with higher speeds and through much longer distances
    than with Bluetooth adapters. Wi-Fi P2P features were introduced in Android 4.0
    (API level 14) and they comply with the Wi-Fi Alliance's Wi-Fi Direct standards.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android设备上，随着Wi-Fi P2P的引入，开发者可以创建能够以更高的速度和更长的距离进行通信的应用程序，这比蓝牙适配器要远得多。Wi-Fi
    P2P功能是在Android 4.0（API级别14）中引入的，并且符合Wi-Fi联盟的Wi-Fi Direct标准。
- en: In order to be able to use this feature, the application manifest should contain
    permissions for `ACCESS_WIFI_STATE`, `CHANGE_WIFI_STATE`, and `INTERNET`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用此功能，应用程序清单应包含`ACCESS_WIFI_STATE`、`CHANGE_WIFI_STATE`和`INTERNET`权限。
- en: Access to these services is provided with the WifiP2pManager, which is located
    in the Android.Net.Wifi.P2P namespace. Using this manager, applications can broadcast,
    create groups, request peers, and developers can create applications that can
    communicate over P2P sockets via Wi-Fi Direct.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务的访问是通过位于Android.Net.Wifi.P2P命名空间中的WifiP2pManager提供的。使用此管理器，应用程序可以广播、创建组、请求对等设备，并且开发者可以创建通过Wi-Fi
    Direct在P2P套接字上进行通信的应用程序。
- en: Near Field Communication
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 近场通信
- en: The **Near Field Communication** (**NFC**) protocol provides an easy alternative
    to Bluetooth for pairing and advertising scenarios (for example, NFC tags). With
    NFC, it is possible to create sockets and transfer data between mobile devices
    that are in proximity to each other.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**近场通信**（**NFC**）协议为配对和广告场景（例如，NFC标签）提供了一种易于使用的蓝牙替代方案。使用NFC，可以在彼此靠近的移动设备之间创建套接字并传输数据。'
- en: Unfortunately, the NFC protocol is another unsupported communication protocol
    on iOS devices. (Reports suggest that iPhone 6 technically has the ability to
    use this protocol; however, this API is not made available to developers.)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，NFC协议是iOS设备上另一个不受支持的通信协议。（报告表明iPhone 6在技术上具有使用此协议的能力；然而，此API并未向开发者提供。）
- en: The NFC stacks on Windows Phone and Android devices, however, implement most
    of the same profiles. In essence, it is technically possible to communicate over
    NFC across Windows and Android devices in proximity (by default, the tap and send
    feature works as a cross-platform feature). In spite of the fact that Windows
    devices use a propriety messaging scheme (`Windows:`), there are third-party frameworks
    for NDEF. NDEF is a cross-platform messaging scheme that is currently the default
    for Android.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Windows Phone和Android设备上的NFC堆栈实现了大多数相同的配置文件。本质上，在技术上可以在靠近的Windows和Android设备之间通过NFC进行通信（默认情况下，轻触发送功能作为一个跨平台功能工作）。尽管Windows设备使用专有消息方案（`Windows:`），但仍有第三方框架支持NDEF。NDEF是一个跨平台的消息方案，目前是Android的默认方案。
- en: Location data
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置数据
- en: Nowadays, geo-context (location awareness) is becoming more and more crucial
    for applications, especially the ones running on mobile platforms. For instance,
    search engines optimize results according to the location information they gather
    from the client platform, social media and photo applications add geo-tags to
    posts and media items, and there are many more use cases for the data about *not
    how or on which platform the application is running, but where*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，地理上下文（位置感知）对于应用程序变得越来越重要，尤其是运行在移动平台上的应用程序。例如，搜索引擎根据从客户端平台收集的位置信息优化结果，社交媒体和照片应用程序为帖子和中媒体项添加地理标签，还有许多其他关于*应用程序运行的方式或平台，而是位置*的数据用例。
- en: On Xamarin platforms, the location information is provided making use of several
    different sources. The most accurate of these sources is **GPS** (**Global Position
    System**). This option consumes the most power and, generally, is only available
    for foreground applications. Other options that can provide somewhat less accurate
    data are network providers such as Wi-Fi or Cellular data. iBeacon is another
    technology introduced by Apple and applicable to iOS 7+ devices. iBeacon-compatible
    devices transmit location information using the Bluetooth LE protocol, and this
    transmission is then used by the Bluetooth adapter on mobile phones and tablets.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin平台上，位置信息是通过使用几个不同的来源提供的。其中最准确的是**GPS**（**全球定位系统**）。此选项消耗最多的电量，并且通常仅适用于前台应用程序。其他可以提供相对不太准确数据的选项是网络提供者，如Wi-Fi或蜂窝数据。iBeacon是苹果公司引入的另一种技术，适用于iOS
    7+设备。iBeacon兼容设备使用蓝牙LE协议传输位置信息，然后这种传输被手机和平板电脑上的蓝牙适配器使用。
- en: On Xamarin target platforms, location information can be accessed both proactively
    and through system events and triggers. In each platform, access to a location
    is limited by the privacy settings and it is always up to the user whether a certain
    (or every) application can access the location services.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin目标平台上，可以通过系统事件和触发器主动访问位置信息。在每个平台上，对位置的访问都受到隐私设置的限制，并且始终由用户决定某个（或每个）应用程序是否可以访问位置服务。
- en: Android location and Google Play services
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android位置和Google Play服务
- en: In early versions of Android runtime, the `android.location` API was the framework-designated
    module for adding location awareness to applications. However, after the release
    of Google Play Services SDK (compatible with Android v2.2, API level 8, or higher),
    location APIs provided by Google became the preferred way to access location data
    on Android platform.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android运行时的早期版本中，`android.location` API是框架指定的模块，用于向应用程序添加位置感知。然而，在Google Play
    Services SDK（兼容Android v2.2、API级别8或更高版本）发布后，Google提供的位置API成为在Android平台上访问位置数据的首选方式。
- en: '`LocationManager`, a `LocationServices` implementation, is a system-wide service
    and can be accessed through the application context in Xamarin.Android applications.
    In order to get location information, the application has to subscribe to the
    location updates with an implementation of `ILocationListener`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocationManager`，一个`LocationServices`实现，是一个全局服务，可以在Xamarin.Android应用程序中通过应用程序上下文访问。为了获取位置信息，应用程序必须通过`ILocationListener`的实现订阅位置更新。'
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the location listener interface, there are several events that can be utilized.
    Other than the location change information, developers are provided with the updates
    related to different location provider status changes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在位置监听器接口中，有几个事件可以被利用。除了位置变化信息外，开发者还提供了与不同位置提供者状态变化相关的更新。
- en: 'A simple location listener implementation used in the previous example would
    resemble this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中使用的简单位置监听器实现将类似于以下内容：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The listener interface can be implemented on the current `Activity` itself or
    any other `JavaObject` class implementation. Using the backgrounding techniques
    defined in [Chapter 3](ch03.html "Chapter 3. Asynchronous Programming"), *Asynchronous
    Programming*, the listener interface can also be implemented on a custom started
    service and the application can receive background updates on the location changes
    through the service data directly (bound scenario) or through information persisted
    by the service.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器接口可以在当前的`Activity`本身或任何其他`JavaObject`类实现上实现。使用在[第3章](ch03.html "第3章。异步编程")中定义的背景化技术，即*异步编程*，监听器接口也可以在自定义启动的服务上实现，并且应用程序可以通过服务数据直接（绑定场景）或通过服务持久化的信息接收位置变化的背景更新。
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Testing location information can be difficult on mobile applications. In order
    to facilitate GPS data testing and diagnostics, Android Emulator in Android SDK
    and Visual Studio Android Emulator are equipped with location emulation functionality.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动应用程序上测试位置信息可能很困难。为了便于GPS数据测试和诊断，Android SDK和Visual Studio Android模拟器都配备了位置模拟功能。
- en: '![Android location and Google Play services](img/B04693_06_04.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Android位置和Google Play服务](img/B04693_06_04.jpg)'
- en: Emulating a car travelling on a route
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟在路线上行驶的汽车
- en: Visual Studio Android Emulator also provides features to emulate the usage of
    an automobile, or other means of transport, on a route or GPS location changing
    according to the defined pins with defined intervals.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Android模拟器还提供了模拟在路线或根据定义的标记和定义的间隔更改GPS位置上行驶的汽车或其他交通工具的功能。
- en: On top of the location information, using the location provider status information,
    location info can be gathered in a more efficient and reliable way (for example,
    switching between GPS and network provided information according to connectivity
    and requirement for accuracy). In order to get the optimal provider that is currently
    available for the application scope, you can use the `GetBestProvider` method
    with the desired criteria for accuracy (Coarse or Fine Location Info) and for
    power consumption (high, medium, and low).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在位置信息的基础上，使用位置提供者状态信息，可以更高效、更可靠地收集位置信息（例如，根据连接性和对精度的要求在GPS和网络提供的信息之间切换）。为了获取当前适用于应用程序范围的最佳提供者，可以使用`GetBestProvider`方法，并指定所需的精度标准（粗略或精确位置信息）和功耗标准（高、中、低）。
- en: This intelligent switch between location data providers is the main advantage
    of using the Fused Location Provider (Google Play Services SDK) and Google Location
    Services over the default location API.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种智能地在位置数据提供者之间切换是使用Fused Location Provider（Google Play Services SDK）和Google位置服务而不是默认位置API的主要优势。
- en: '![Android location and Google Play services](img/B04693_06_05.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![Android位置和Google Play服务](img/B04693_06_05.jpg)'
- en: Google Play services Xamarin components
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Google Play服务Xamarin组件
- en: Xamarin binding libraries to Google Play Services SDK, which are available as
    components for Xamarin.Android v4.8+ developers, provide an easy way to integrate
    various services, including location APIs, into Xamarin.Android applications.
    These components implement the Java Binding projects and take care of the cumbersome
    implementation and compilation of the Google provided Android libraries.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可供Xamarin.Android v4.8+开发者作为组件使用的Xamarin绑定库到Google Play Services SDK，提供了一种简单的方法将各种服务，包括位置API，集成到Xamarin.Android应用程序中。这些组件实现了Java绑定项目，并负责Google提供的Android库的繁琐实现和编译。
- en: 'After installing the Google Play services'' location component, while trying
    to build the Xamarin.Android application, you might receive a compilation error
    similar to this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装Google Play服务的位置组件后，在尝试构建Xamarin.Android应用程序时，您可能会收到类似于以下这样的编译错误：
- en: '*"No resource found that matches the given name (at ''value'' with value ''@integer/google_play_services_version'')."*'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"没有找到与给定名称匹配的资源（在''value''处，值为''@integer/google_play_services_version'')."*'
- en: The reason for this error is the fact that the Xamarin component is dependent
    on the Google Play Services SDK and the SDK modules are supposed to be installed
    manually using the Android SDK Manager.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误的原因是Xamarin组件依赖于Google Play Services SDK，并且SDK模块应该通过Android SDK Manager手动安装。
- en: '![Android location and Google Play services](img/B04693_06_06.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![Android位置和Google Play服务](img/B04693_06_06.jpg)'
- en: Android Google Play SDK
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Android Google Play SDK
- en: After installing the SDK module, the Xamarin.Android application can be built
    without errors.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 安装SDK模块后，Xamarin.Android应用程序可以无错误地构建。
- en: 'Once the setup and configuration is complete, the `GoogleApiClient` class can
    be initialized and used in Xamarin applications. `GoogleApiClient` requires the
    implementation of two interfaces to gather information about the client connection
    status: `GoogleApiClient.IConnectionCallbacks` and `GoogleApiClient.IOnConnectionFailedListener`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置和配置完成，就可以在Xamarin应用程序中初始化并使用`GoogleApiClient`类。`GoogleApiClient`需要实现两个接口以收集有关客户端连接状态的信息：`GoogleApiClient.IConnectionCallbacks`和`GoogleApiClient.IOnConnectionFailedListener`。
- en: If the application you are implementing does not depend on continuous updates
    of location data, but rather just the current location, you can use the `GetLastLocation`
    method provided on the `GoogleApiClient`. This method provides a one-time reading
    option.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在实现的应用程序不依赖于位置数据的持续更新，而是只需要当前的位置，您可以使用`GoogleApiClient`上提供的`GetLastLocation`方法。此方法提供了一次性读取选项。
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In order to receive real-time updates with the fused location provider, you
    must implement the `ILocationListener` interface for the Google Location Services
    API. This listener is different from the default one; it only contains a single
    event handler implementation for location changes. The events related to the data
    providers do not need to be implemented since the fused location provider itself
    is responsible for smart switching between the location data providers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接收融合位置提供者的实时更新，您必须为Google位置服务API实现`ILocationListener`接口。此监听器与默认的不同；它只包含一个用于位置变化的事件处理器实现。与数据提供者相关的事件不需要实现，因为融合位置提供者本身负责在位置数据提供者之间智能切换。
- en: Although the type of provider and provider status changes are not relevant for
    us using the fused location provider, it is still possible to let the fused provider
    know which type of accuracy and priority our application scope demands. For this
    purpose, we can use the `SetPriority` method with the appropriate flag on `LocationRequest`
    while subscribing to the location updates.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然提供者类型和提供者状态变化对我们使用融合位置提供者来说并不相关，但仍然可以通知融合提供者我们的应用程序范围需要哪种类型的准确性和优先级。为此，我们可以在订阅位置更新时使用`SetPriority`方法，并在`LocationRequest`上使用适当的标志。
- en: '**High accuracy (100)**: Requests the finest location available'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高精度（100）**：请求最精细的位置'
- en: '**Balanced power/accuracy (102) (default)**: Requests the `block` level accuracy
    (~100m accuracy)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平衡电源/精度（102）（默认）**：请求`block`级别的精度（约100米精度）'
- en: '**Low power (104)**: Requests the `city` level accuracy (~10km accuracy)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低电源（104）**：请求`city`级别的精度（约10公里精度）'
- en: '**No power (105)**: Sets the location updates to use passive mode; waits for
    location updates delivered to other client applications (also known as **piggybacking**)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无电源（105）**：将位置更新设置为使用被动模式；等待发送到其他客户端应用程序的位置更新（也称为**骑乘**）'
- en: As well as the priority, a fused location provider lets developers set other
    important delineations of location updates, such as minimum interval, smallest
    displacement, and expiration time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了优先级之外，融合位置提供者还允许开发者设置其他重要的位置更新划分，例如最小间隔、最小位移和过期时间。
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Unfortunately, Google Play services are only preinstalled on Android SDK emulator
    and for the other emulators, the Google applications package has to be downloaded
    and installed on the emulator image.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Google Play服务仅在Android SDK模拟器上预安装，而对于其他模拟器，必须在模拟器映像上下载并安装Google应用程序包。
- en: Location services on iOS
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iOS上的位置服务
- en: On the iOS platform, the location data is accessed through the `CoreLocation`
    library, and similar to the android location API, location changes are sent to
    the subscribing application with the help of event delegates. The `CLLocationManager`
    class makes it a trivial task to get location data updates from the mobile device.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS平台上，位置数据通过`CoreLocation`库访问，类似于Android位置API，位置变化通过事件代理的帮助发送给订阅的应用程序。`CLLocationManager`类使得从移动设备获取位置数据更新变得非常简单。
- en: 'The Xamarin.iOS location data access implementation starts with creating the
    required `Info.plist` entries, which will explain why the application requires
    access to the user''s location. In order to do this, we have to edit the Info.plist
    file, adding one or both of the following entries:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.iOS位置数据访问实现从创建所需的`Info.plist`条目开始，这将解释为什么应用程序需要访问用户的地理位置。为了做到这一点，我们必须编辑Info.plist文件，添加以下条目之一或两个：
- en: '![Location services on iOS](img/B04693_06_07.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![iOS上的位置服务](img/B04693_06_07.jpg)'
- en: Info.plist entries for location info
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 位置信息的Info.plist条目
- en: 'In addition to the Info.plist entry, you should also keep in mind that starting
    with iOS 8, applications have to explicitly ask for permission to use the location
    data. In order to get consent from the user, the location manager exposes two
    methods: one for authorizing the app for continuous local data updates and the
    other one just to be used when the application is in the foreground.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Info.plist条目外，还应记住，从iOS 8开始，应用程序必须明确请求使用位置数据的权限。为了获得用户的同意，位置管理器公开了两种方法：一种用于授权应用程序进行持续本地数据更新，另一种仅当应用程序处于前台时使用。
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, we can subscribe to the `LocationsUpdated` event to receive the latest
    location update information.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以订阅`LocationsUpdated`事件以接收最新的位置更新信息。
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The location information can be further optimized for the application scope
    using the exposed criteria properties and methods. It is also possible to retrieve
    other types of information such as heading direction. However, it is important
    to first check if the service is available and request updates according to the
    system status information.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用公开的准则属性和方法进一步优化应用程序范围内的位置信息。也可以检索其他类型的信息，例如航向方向。然而，首先检查服务是否可用，并根据系统状态信息请求更新是很重要的。
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Location data on Windows Runtime
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows Runtime上的位置数据
- en: On Windows Runtime (Windows Store apps), the `Windows.Device.Geolocation` namespace
    is dedicated for tracking the device's location over time. The `Geolocator` class
    replaces the main access points in the previous platforms and can give on-demand
    data and information updates through events.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows Runtime（Windows商店应用程序）中，`Windows.Device.Geolocation`命名空间专门用于跟踪设备随时间变化的位置。`Geolocator`类替代了先前平台中的主要访问点，可以通过事件提供按需数据和信息更新。
- en: Similar to iOS access request, the application can request consent from the
    application user with the `RequestAccessAsync` method and according to the response,
    methods or events can be accessed through the `Geolocator` class.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与iOS访问请求类似，应用程序可以使用`RequestAccessAsync`方法请求应用程序用户的同意，并根据响应，可以通过`Geolocator`类访问方法或事件。
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Geofencing
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地理围栏
- en: A geofence is an abstract boundary that can be defined with location services
    so that the application which created the geofence receives an update from the
    mobile device whenever the user is entering or exiting this boundary. This eliminates
    the need for polling for the location info and opens up different implementation
    opportunities for mobile applications.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 地理围栏是一个抽象的边界，可以通过位置服务定义，以便创建地理围栏的应用程序在用户进入或离开此边界时从移动设备接收更新。这消除了轮询位置信息的需求，并为移动应用程序提供了不同的实现机会。
- en: The use cases for geofences vary from simple reminders on certain locations
    to virtual tours created by showing certain images or information according to
    the current region.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 地理围栏的使用案例从简单的位置提醒到根据当前区域显示某些图像或信息创建的虚拟导游不等。
- en: All the Xamarin target platforms support the creation and usage of geofences.
    For instance, in order to create a geofence on an iOS platform, we would need
    to use `CLCircularRegion` and the location monitoring feature of the `CoreLocation`
    library. There are two events of interest that are fired when the mobile device
    enters and exists in the region.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Xamarin目标平台都支持创建和使用地理围栏。例如，要在iOS平台上创建地理围栏，我们需要使用`CLCircularRegion`和`CoreLocation`库的位置监控功能。当移动设备进入和离开该区域时，会触发两个感兴趣的事件。
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This implementation creates a geofence around the described region (with a center
    defined by the coordinates and a radius of 600 m) and sends out a notification
    when the specified fence is entered, giving information about the location.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现创建了一个围绕描述区域（由坐标定义的中心和半径为600米的圆）的地理围栏，并在指定的围栏被进入时发送通知，提供有关位置的信息。
- en: '![Geofencing](img/B04693_06_08.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![地理围栏](img/B04693_06_08.jpg)'
- en: Old town geofence
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 老城区地理围栏
- en: The same implementation on Android platform would use `LocationServices` in
    conjunction with the `GeofenceBuilder` class to create `IGeofence` type boundaries
    and add them to the watch list. One important difference on the Android platform
    is that the events are handled through delegates and are generally implemented
    by an intent service.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android平台上，相同的实现会结合使用`LocationServices`和`GeofenceBuilder`类来创建`IGeofence`类型的边界，并将它们添加到观察列表中。在Android平台上，一个重要的区别是事件通过代理处理，通常由一个意图服务实现。
- en: The implementation starts with creating `GoogleApiClient` like in the previous
    examples, and once the API client is connected, we can go ahead and create the
    geofence(s) and the intent service that is going to handle the callbacks.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实现开始于创建`GoogleApiClient`，就像之前的示例一样，一旦API客户端连接成功，我们就可以继续创建地理围栏（geofence(s)）和将要处理回调的意图服务（intent
    service）。
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The intent service implementation for sending out a local toast notification
    on location updates would look similar to this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在位置更新时发送本地toast通知的意图服务实现看起来会类似于以下：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The classes used by Windows Store apps for geofences are the `GeofenceMonitor`
    and `Geofence`/`GeoCircle` descriptive classes. A simple `Geofence` class would
    consist of a `Geocircle` class and the associated ID.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Store应用用于地理围栏的类是`GeofenceMonitor`和`Geofence`/`GeoCircle`描述类。一个简单的`Geofence`类将包括一个`Geocircle`类和相关的ID。
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once the geofence is initialized, we can use the `GeofenceMonitor` class to
    add the geofence and subscribe to the events.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦地理围栏初始化，我们可以使用`GeofenceMonitor`类添加地理围栏并订阅事件。
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is also possible to use the geofence status change events as triggers for
    a background task so that the registering application does not need to be in the
    foreground or even in the running state.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用地理围栏状态更改事件作为触发后台任务的触发器，这样注册的应用程序就不需要在前台或甚至运行状态。
- en: Native libraries
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地库
- en: In spite of the fact that the Xamarin framework and .NET core implementations
    on Xamarin.Android and Xamarin.iOS platforms provide a vast amount of features,
    in some cases it is unavoidable to include native code in cross-platform implementations.
    Fortunately, it is possible to bind or link native libraries on both of these
    platforms.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Xamarin框架和.NET核心在Xamarin.Android和Xamarin.iOS平台上的实现提供了大量的功能，但在某些情况下，在跨平台实现中包含本地代码是不可避免的。幸运的是，在这两个平台上都可以绑定或链接本地库。
- en: Managed callable wrappers (Android)
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理可调用包装器（Android）
- en: As mentioned in previous chapters, managed callable wrappers are generated managed
    code libraries which provide a way to interact with the Java Runtime over the
    JNI bridge to execute code from certain Java libraries.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，管理可调用包装器是生成的管理代码库，它提供了一种通过JNI桥与Java运行时交互的方法，以执行某些Java库中的代码。
- en: Java libraries are often packaged in Java archive files (JAR files) and it is
    possible, using the compiled Java library project, to create a binding library
    which can be included in Xamarin.Android applications.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Java库通常打包在Java归档文件（JAR文件）中，使用编译后的Java库项目，可以创建一个绑定库，该库可以包含在Xamarin.Android应用中。
- en: In order to demonstrate this usage, we will be creating a MCW for a simple JSON
    parsing library. The first step of creating our binding library would be to use
    the built-in project template to create our binding project.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这种用法，我们将创建一个用于简单JSON解析库的MCW。创建我们的绑定库的第一步是使用内置的项目模板创建我们的绑定项目。
- en: '![Managed callable wrappers (Android)](img/B04693_06_09.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![管理可调用包装器（Android）](img/B04693_06_09.jpg)'
- en: Binding library project
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定库项目
- en: 'Once the binding project is created, we can copy the JAR into the created Jars
    folder in the binding project. After the copying is completed, an important step
    would be to check the **Build Action** configuration for the JAR resource. The
    copied JAVA library files can be used in two ways:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建绑定项目，我们可以将JAR文件复制到绑定项目中的创建的Jars文件夹。复制完成后，一个重要的步骤是检查JAR资源的**构建动作**配置。复制的JAVA库文件可以使用两种方式：
- en: '**InputJar**: This is a Java library archive that is going to be used to generate
    the managed wrapper.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入Jar**：这是一个将要用于生成管理包装器的Java库归档。'
- en: '**ReferenceJar**: This is a Java library archive that is only going to be used
    as a reference and not to generate a wrapper.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用Jar**：这是一个仅用作参考而不用于生成包装器的Java库归档。'
- en: '![Managed callable wrappers (Android)](img/B04693_06_10.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![管理可调用包装器（Android）](img/B04693_06_10.jpg)'
- en: Binding library structure and build action
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定库结构和构建动作
- en: After setting the **Build Action** field to `InputJar` (this simple library
    does not have any dependencies), we can build the library project. Once the build
    is successful, you can see the generated managed files in the `<Project Directory>\obj\Debug\generated\src`
    directory.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在将**构建动作**字段设置为`InputJar`（这个简单的库没有任何依赖项）之后，我们可以构建库项目。一旦构建成功，你可以在`<项目目录>\obj\Debug\generated\src`目录中看到生成的管理文件。
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Looking at the main parser file, you will notice that the definition for a class
    consists of an Android runtime registration and a class deriving from a Java object.
    Metadata about the class or class members also has a metadata comment, which defines
    the path of the item in the Java library package.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 查看主解析文件，你会注意到一个类的定义由一个Android运行时注册和一个从Java对象派生的类组成。关于类或类成员的元数据也有一个元数据注释，它定义了Java库包中项的路径。
- en: If we wanted to change the name of a namespace (by default, they are generated
    from the package names defined in the `api.xml` file), or the name of any members
    of a class or the class itself, we could make use of the `Metadata.xml` file that
    is located in the bindings project. The `Metadata.xml` file contains transforms
    on the api.xml document that is generated from the jar files. This API description
    document contains the class definitions and components in a format similar to
    that of GAPI that is used by mono compiler. With the transforms included in the
    Metadata.xml, we can redefine the managed names designated for the generated C#
    items.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更改命名空间（默认情况下，它们是从`api.xml`文件中定义的包名生成的），或者类或类的任何成员的名称，我们可以使用位于绑定项目中的`Metadata.xml`文件。`Metadata.xml`文件包含对从jar文件生成的api.xml文档的转换。这个API描述文档包含类定义和组件，其格式类似于mono编译器使用的GAPI。通过包含在`Metadata.xml`中的转换，我们可以重新定义为生成的C#项指定的托管名称。
- en: 'For instance, in order to change the namespace, we would use a description
    similar to this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了更改命名空间，我们会使用类似以下的描述：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For changing the class names, the syntax is quite similar:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更改类名，语法相当类似：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, the generated class declaration would look similar to this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，生成的类声明将类似于以下内容：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Linking versus binding (iOS)
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接与绑定（iOS）
- en: While dealing with native code on the Xamarin.iOS platform, there are several
    options developers can use.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin.iOS平台上处理本地代码时，开发者可以使用几种选项。
- en: If we were dealing with simple static utility libraries on C or Objective-C,
    it is possible to create so-called **fat binaries** and then link them at the
    compile time. Later in Xamarin runtime (remember there is no Xamarin runtime in
    iOS, everything is compiled into static code), methods from the native library
    can be invoked using the P/Invoke functionality in the Xamarin framework.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理的是简单的C或Objective-C静态实用库，则可以创建所谓的**胖二进制**，然后在编译时链接它们。在Xamarin运行时（记住iOS中没有Xamarin运行时，所有内容都编译成静态代码），可以使用Xamarin框架中的P/Invoke功能调用本地库中的方法。
- en: The other option, which enables users to create a stronger "bridge" (at the
    cost of performance) with native libraries, is to create bindings to Objective-C
    classes and methods. Using this approach, similar to managed callable wrappers
    in Android runtime, we would need to create a C# wrapper over the Objective-C
    framework library and use the managed wrapper to access the native implementation.
    Even though this approach creates a more intuitive and manageable access point
    to native code, since the managed wrapper is, in essence, a high-level implementation
    and the mono compiler actually generates the P/Invoke and Imports for accessing
    native functionality, it is inherently a little more costly than native linking.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项，它允许用户通过创建与Objective-C类和方法绑定的方式，与本地库建立更强的“桥梁”（以性能为代价），是创建到Objective-C类和方法的绑定。使用这种方法，类似于Android运行时的托管调用包装器，我们需要在Objective-C框架库上创建一个C#包装器，并使用托管包装器来访问本地实现。尽管这种方法为原生代码提供了一个更直观和可管理的访问点，因为托管包装器本质上是一个高级实现，而mono编译器实际上生成P/Invoke和Imports来访问原生功能，所以它比本地链接稍微昂贵一些。
- en: Both implementations require the creation of the fat binary as a starting point.
    A fat binary is the colloquial term used to describe binary packages that contain
    native binary compilations for all possible CPU architectures (i386 for the Simulator
    and ARMv7/ARM64 for the devices). In order to create the universal binary that
    is suitable for use in all iOS development targets, one needs to make use of the
    command-line utility in Mac OS X.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 两种实现都需要从创建胖二进制文件作为起点。胖二进制是口语化的术语，用来描述包含所有可能的CPU架构（模拟器为i386，设备为ARMv7/ARM64）的本地二进制编译的二进制包。为了创建适用于所有iOS开发目标的通用二进制文件，需要使用Mac
    OS X中的命令行工具。
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After the universal binary is created, you can now copy the universal package
    into a project folder in the Xamarin.iOS application, set the build action to
    **None**, and instruct the mtouch compiler to link the binary in compile time.
    For build instructions, you would need to use the build arguments section in project
    properties and gcc flags.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建通用的二进制文件后，现在您可以将通用包复制到 Xamarin.iOS 应用程序的项目文件夹中，将构建操作设置为 **None**，并指示 mtouch
    编译器在编译时链接二进制文件。对于构建说明，您需要在项目属性中的构建参数部分使用 gcc 标志。
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Additional parameters might need to be included according to the frameworks
    being used or if the binary includes C++ code (for example, the `–cxx` flag for
    C++ code).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 根据使用的框架或二进制文件中是否包含 C++ 代码（例如，C++ 代码的 `–cxx` 标志），可能需要包含额外的参数。
- en: 'The other option is to create a `LinkWith` declaration (in most cases, this
    is created automatically) in an Objective-C binding project. The code is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是在 Objective-C 绑定项目中创建一个 `LinkWith` 声明（在大多数情况下，这是自动创建的）。代码如下：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In an Objective-C binding project, you must first familiarize yourself with
    the types, methods, and other constructs in the native library to be able to start
    implementing the responding managed types in the binding library.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 绑定项目中，您必须首先熟悉原生库中的类型、方法和其他构造，以便能够开始实现绑定库中的相应托管类型。
- en: Tip
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Objective Sharpie is a useful tool for creating managed wrappers for Objective-C
    libraries. Initially, an internal tool used by the Xamarin team, it soon was released
    to public. Even though the implementation is not complete and it is not fully
    supported as an official product, it can help accelerate the implementation against
    native libraries.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Objective Sharpie 是一个用于创建 Objective-C 库托管包装的有用工具。最初，它是 Xamarin 团队内部使用的一个工具，很快就被公开发布。尽管实现并不完整，并且它作为一个官方产品并不完全受支持，但它可以帮助加速对原生库的实现。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked about some platform-specific features related to
    inter-app communications, peripherals, and location data.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一些与跨应用通信、外围设备和位置数据相关的特定平台特性。
- en: Using platform-specific features can make your applications more attractive
    to platform users by providing scenarios that they are familiar with and increase
    the native look and feel of your applications.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特定平台的特性可以使您的应用程序更吸引平台用户，通过提供他们熟悉的场景并增强应用程序的本地外观和感觉。
- en: Platform-specific features related to different communication protocols, such
    as Bluetooth, NFC, and Wi-Direct, can be employed for various scenarios. However,
    most of the protocols and profiles described here target Android and Windows Phone.
    Xamarin.iOS applications can only benefit from the Bluetooth LE profile.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与不同通信协议（如蓝牙、NFC 和 Wi-Direct）相关的特定平台特性可以用于各种场景。然而，这里描述的大多数协议和配置文件都针对 Android
    和 Windows Phone。Xamarin.iOS 应用程序只能从蓝牙 LE 配置文件中受益。
- en: Location awareness is another platform-specific implementation that all mobile
    applications can benefit from. By adding a location context to the business logic
    of applications, developers can create a more personalized experience for users.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 位置感知是另一个所有移动应用程序都可以从中受益的特定平台实现。通过将位置上下文添加到应用程序的业务逻辑中，开发者可以为用户提供更个性化的体验。
- en: Finally, if needed, Xamarin provides important features for binding and linking
    native libraries for Android and iOS platforms, which transform a complex porting
    task into merely imports.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果需要，Xamarin 为 Android 和 iOS 平台提供了绑定和链接原生库的重要功能，将复杂的移植任务简化为仅仅导入。
- en: In the next chapter, we will discuss the user interface components on different
    platforms and how they correlate with each other.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论不同平台上的用户界面组件以及它们之间的相互关系。
