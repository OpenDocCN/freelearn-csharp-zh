<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Interacting with Data in C# - Entity Framework Core</h1>
                </header>
            
            <article>
                
<p>As we mentioned in <a href="49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml">Chapter 5</a>, <em>Applying a Microservice Architecture to Your Enterprise Application</em>, software systems are organized into layers, and each layer communicates with the previous and next layers through interfaces that don't depend on how the layer is implemented. When the software is a Business/Enterprise system, it usually contains at least three layers: the data layer, the business layer, and the presentation layer. In general, the interface that's offered by each layer and the way the layer is implemented depends on the application.</p>
<p>However, it turns out that the functionalities offered by data layers are quite standard, since they just map data from a data storage subsystem into objects and vice versa. This leads to the conceptions of general-purpose frameworks for implementing data layers in a substantially declarative way. These tools are called <span><strong>Object-Relational Mapping</strong> (</span><strong>ORM</strong>) tools since they are data storage subsystems based on relational databases. However, they also work well with the modern non-relational storages classified as NoSQL databases (such as MongoDB and Azure Cosmos DB) since their data model is closer to the target object model than a pure relational model.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li><span>Understanding</span> ORM basics</li>
<li>Configuring Entity Framework Core</li>
<li>Entity Framework Core migrations</li>
<li>Querying and updating data with Entity Framework Core</li>
<li>Deploying your data layer</li>
<li>Understanding Entity Framework Core advanced features <span>– global filters</span></li>
</ul>
<p><span>This chapter describes</span><span> </span><span>ORMs </span><span>and how to configure them,</span><span> and then focuses on Entity Framework Core, the </span><span>ORM included in</span><span> .NET Core.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter requires Visual Studio 2017 or 2019 free Community Edition or better with all the database tools installed.</p>
<p><span>All the concepts in this chapter will be clarified with practical examples based on the WWTravelClub book use case. </span>You will find the code for this chapter at <a href="https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8">https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8</a>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding ORM basics</h1>
                </header>
            
            <article>
                
<p>ORMs map relational DB tables into in-memory collections of objects where object properties correspond to DB table fields. Types from C#, such as Booleans, numeric types, and strings, have corresponding DB types. If GUIDs are not available in the mapped database, while single characters are mapped to DB single-character strings, then t<span>ypes such as GUIDs are mapped to their equivalent string representations</span>. All date and time types are mapped either to C# <kbd>DateTime</kbd> when date/time contains no time zone information or to <kbd>DateTimeOffset</kbd> when date/time also contains explicit time zone information. Any DB time duration is mapped to a <kbd>TimeSpan</kbd>.</p>
<p>Since the string properties of most object-oriented languages have no length limits associated with them (while DB string fields usually have length limits), the DB limits are taken into account in the DB mapping configuration. In general, when the mapping between DB types and object-oriented language types need options to be specified, these options are declared in the mapping configuration.</p>
<p>The way the whole configuration is defined depends on the specific ORM. Entity Framework Core offers three options:</p>
<ul>
<li>Data annotations (property attributes)</li>
<li>Name conventions</li>
<li>Fluent configuration interface based on configuration objects and methods</li>
</ul>
<p>While the fluent interface can be used to specify any configuration option, the data annotations <span>and name conventions </span>can be used for a smaller subset of them.</p>
<p>Each ORM adapts to a specific DB type (Oracle, MySQL, SQL Server, and so on) with DB-specific adapters called <strong>providers</strong> or <strong>connectors</strong>. Entity Framework Core has providers for most of the available DB engines.</p>
<p class="mce-root"/>
<div class="packt_infobox">A complete list of providers can be found at <a href="https://docs.microsoft.com/en-US/ef/core/providers/">https://docs.microsoft.com/en-US/ef/core/providers/</a>.</div>
<p>Adapters are necessary for the differences in DB types, for the way transactions are handled, and for all the other features that are not standardized by the SQL language.</p>
<p>Relations among tables are represented with object pointers. For instance, in a one-to-many relationship, the class that's <span>mapped to</span> the <em>one</em> side of the relationship contains a collection that is populated with the related objects on the <em>many</em> side of the relationship. On the other hand, the class <span>mapped t</span>o the <em>many</em> side of the relationship has a simple property <span>that is populated </span><span>with the uniquely related object on the <em>one</em> side of the relationship.</span></p>
<p>The whole database (or just a part of it) is represented by an in-memory cache class that contains a property for each collection that's mapped to a DB table. First, the query and update operations are performed on an instance of an <span>in-memory cache </span>class, and then this instance is synchronized with the database. The in-memory cache class that's used by Entity Framework Core is called <kbd>DBContext</kbd> and it also contains the mapping configuration. More specifically, the application-specific in-memory cache class is obtained by inheriting <kbd>DBContext</kbd> and adding it to all the mapped collections and all the necessary configuration information.</p>
<p>Summing up, <kbd>DBContext</kbd> subclass instances contain partial snapshots of the DB that are synchronized with the database to get/update the actual data.</p>
<p>DB queries are performed with a query language made of method calls on the collections of the in-memory cache class. The actual SQL is created and executed during the synchronization stage. For instance, Entity Framework Core performs <span><strong>Language Integrated Queries</strong> </span>(<strong>LINQ</strong>) on the collections mapped to the DB tables.</p>
<p>In general, LINQ queries produce <kbd>IEnumerable</kbd> instances, that is, collections whose elements are not computed when <kbd>IEnumerable</kbd> is created at the end of the query, but when <span><span>you </span></span>actually attempt to retrieve <span><span>the collection elements </span></span>from <kbd>IEnumerable</kbd>. This works as follows:</p>
<ul>
<li>LINQ queries that start from a mapped collection of a <kbd>DBContext</kbd> create a specific subclass of <kbd>IEnumerable</kbd> called <kbd>IQueryable</kbd>.</li>
<li>An <kbd>IQueryable</kbd> contains all the information that's needed to issue a query to the database, but the actual SQL is produced and executed when the first element of the <kbd>IQueryable</kbd> is retrieved.</li>
<li>Thus, in the case of Entity Framework Core, the synchronization with the database is performed when an element is actually retrieved from the final <kbd>IQueryable</kbd>.</li>
<li>Typically, each Entity Framework query ends with a <kbd>ToList</kbd> <span>or</span> <kbd>ToArray</kbd> <span>operation that transforms the</span> <kbd>IQueryable</kbd> <span>into a list or array, thereby causing the actual execution of the query on the database.</span></li>
<li><span>In case the query is expected to return just a single element or no element at all,</span> we <span>typically execute a</span> <kbd>FirstOrDefault</kbd> <span>operation that returns a single element, if any, or</span> <kbd>null</kbd><span>. </span></li>
</ul>
<p>Also, updates, deletions, and additions of new entities to a DB table are performed by mimicking these operations on a <kbd>DBContext</kbd> collection property that represents the database table. However, entities may only be updated or deleted this way after they have been loaded in that memory collection by means of a query. An update query requires the in-memory representation of the entity to be modified as needed, while a delete query requires the in-memory representation of the entity to be removed from its in-memory mapped collection. In Entity Framework Core, the removal operation is performed by calling the <kbd>Remove(entity)</kbd> method of the collection.</p>
<p>The addition of a new entity has no further requirements. It is enough to add the new entity to the in-memory collection. U<span>pdates, deletes, and additions that are performed on various in-memory collections are actually passed to the database with an explicit call to a DB synchronization method. For instance, Entity Framework Core passes all the changes that are performed on a <kbd>DBContext</kbd> instance to the database when you call the</span> <kbd><span>DBContext.S</span>aveChanges()</kbd> <span>method.</span></p>
<p>Changes that are passed to the database during a synchronization operation are executed in a single transaction. Moreover, for ORMs, such as Entity Framework Core, that have an explicit representation of transactions, a synchronization operation is executed in the scope of a transaction, since it uses that transaction instead of creating a new one.</p>
<p>The remaining sections in this chapter explain how to use Entity Framework Core, along with some example code based on this book's WWTravelClub use case.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Entity Framework Core</h1>
                </header>
            
            <article>
                
<p>Since Database handling is confined within a dedicated application layer, it is good practice to define your Entity Framework Core (<kbd>DBContext</kbd>) in a separate library. Accordingly, we need to define a .NET Core class library project. As we discussed in the <em>Book use case <span>– </span>.NET Core in action, Main Types of .NET Core projects</em> section of <a href="a4194162-692d-4ac4-9b8e-a48199e746ab.xhtml">Chapter 2</a>, <em>Functional and Nonfunctional Requirements</em>, we have two different kinds of library projects: <strong>.NET</strong> <strong>Standard</strong> <span>and</span> <strong>.NET Core</strong><span>.</span></p>
<p>While .NET Core libraries are tied to a specific .NET Core version, .NET Standard 2.0 libraries have a wide range of applications since they work with any .NET version greater than 2.0 and also with the classical .NET Framework.</p>
<p>However, the <kbd>Microsoft.EntityFrameworkCore</kbd> package (which we need in our DB layer) depends just on .NET Standard 2.0. It is designed to work with a specific .NET Core version (its version numbers are the same as the .NET Core versions). Therefore, if we define our DB layer as .NET Standard 2.0, the specific <span><kbd>Microsoft.EntityFrameworkCore</kbd> package that we add as a dependency </span>may conflict with another version of the same library contained in another system component that's tied to a specific .NET Core version.</p>
<p>Since our library is not a general-purpose library (it's just <span>a </span>component of a specific application), it is preferable to tie it to a specific .NET Core version than to track its version dependencies in the whole design of our application. Therefore, let's choose a .NET Core library project for the latest .NET Core version installed on our machine. Our .NET Core library project can be created and prepared as follows:</p>
<ol>
<li>Open Visual Studio and define a new solution named <kbd>WWTravelClubDB</kbd> and then select <span class="packt_screen">Class Library (.NET Core)</span> for the latest .NET Core version available.</li>
<li>We must install all Entity Framework Core-related dependencies. The simplest way to have all the necessary dependencies installed is to add the NuGet package for the provider of the database engine we are going to use <span>– </span>in our case, SQL Server <span>–</span> as we mentioned in <a href="049a0a4b-74b6-41a1-92db-87a4f8af9fd1.xhtml">Chapter 4</a>, <em>Deciding on the Best Cloud-Based Solution</em>. In fact, any provider will install all the required packages since it has all of them as dependencies. So, let's add the latest stable version of <kbd>Microsoft.EntityFrameworkCore.SqlServer</kbd><span>. If you plan to use several database engines, you can also add other providers since they can work side by side. Later in this chapter, we will install other NuGet packages that contain tools that we need to process our Entity Framework Core. Then, we will explain how to install further tools that are needed to process Entity Framework Core's configuration.</span></li>
</ol>
<ol start="3">
<li>Let's rename the default <kbd>Class1</kbd> class to<span> <kbd>MainDBContext</kbd></span>.<span> </span>This was automatically added to the class library.</li>
<li>Now, let's replace its content with the following code:</li>
</ol>
<pre style="padding-left: 60px">using System;<br/>using Microsoft.EntityFrameworkCore;<br/><br/>namespace WWTravelClubDB<br/>{<br/>    public class MainDBContext: DbContext<br/>    {<br/>        public MainDBContext(DbContextOptions options)<br/>            : base(options)<br/>        {<br/>        }<br/>        protected override void OnModelCreating(ModelBuilder <br/>        builder)<br/>        {<br/>        } <br/>    }<br/>}</pre>
<ol start="5">
<li>We inherit from <kbd>DbContext</kbd> and we are required to pass <kbd>DbContextOptions</kbd> to the <kbd>DBContext</kbd> constructor. <kbd>DbContextOptions</kbd> contains creation options such as the database connection string, which depend on the target DB engine.</li>
<li>All the collections that have been mapped to database tables will be added as properties of <kbd>MainDBContext</kbd>. The mapping configuration will be defined inside of the overridden <kbd>OnModelCreating</kbd> method with the help of the <kbd>ModelBuilder</kbd> object passed as a parameter.</li>
</ol>
<p>The next step is the creation of all the classes that represent all the DB table rows. These are called <strong>entities</strong>. We need an entity class for each DB table we want to map. Let's create a <kbd>Models</kbd> folder in the project root for all of them. The next subsection explains how to define all the required entities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining DB entities</h1>
                </header>
            
            <article>
                
<p>DB design, like the whole application design, is organized in iterations. Let's suppose that, in the first iteration, we need a prototype with two database tables: one for all the travel packages and another one for all the locations referenced by the packages. Each package covers just one location, while a single location may be covered by several packages, so the two tables are connected by a one-to-many relationship.</p>
<p>So, let's start with the location database table. As we mentioned at the end of the previous section, we need an entity class to represent the rows of this table. Let's call <kbd>Destination</kbd> the entity class:</p>
<pre>namespace WWTravelClubDB.Models<br/>{<br/>    public class Destination<br/>    {<br/>        public int Id { get; set; }<br/>        public string Name { get; set; }<br/>        public string Country { get; set; }<br/>        public string Description { get; set; }<br/>    }<br/>}</pre>
<p><span>All the DB fields must be represented by read/write C# properties. </span>Suppose that each destination is something like a town or a region that can be defined by just its name and the country it is in, and that all the relevant information is contained in its <kbd>Description</kbd>. In future iterations, we will probably add several more fields. <kbd>Id</kbd> is an auto-generated key. </p>
<p>However, now, we need to add information about how all the fields are mapped to DB fields. In Entity Framework Core, all the primitive types are mapped automatically to DB types by the DB engine-specific provider that's used (in our case, SQL Server provider). Our only preoccupations are as follows:</p>
<ul>
<li><strong>Length limits on the string</strong>: They can be taken into account by applying adequate <kbd>MaxLength</kbd> and <kbd>MinLength</kbd> attributes to each string property. All the attributes that are useful for the entity's configuration are contained in the <kbd>System.ComponentModel.DataAnnotation</kbd> and <kbd>System.ComponentModel.DataAnnotations.Schema</kbd> namespaces. Therefore, it's good practice to add both of them to all the entity definitions. </li>
<li><strong>Specifying which fields are obligatory and which ones are optional</strong>: By default, all the reference types (such as all the strings) are assumed to be optional, while all the value types (numbers and GUIDs, for instance) are assumed to be obligatory. If we want a reference type to be obligatory, then we must decorate it with the <kbd>Required</kbd> attribute. However, if we want a <kbd>T</kbd> value type property to be optional, then we must replace it with <kbd>T?</kbd>.</li>
<li><strong>Specifying which property represents the primary key</strong>: The key may be specified by decorating a property with the <kbd>Key</kbd> attribute. However, if no <kbd>Key</kbd> attribute is found, a property named <kbd>Id</kbd> (if there is one) is taken as the primary key. In our case, there is no need for the <kbd>Key</kbd> attribute. If the primary key is composed of several properties, it is enough to add the <kbd>Key</kbd> attribute to all of them.</li>
</ul>
<p>Since each destination is on the <em>one</em> side of a one-to-many relationship, it must contain a collection for the related package entities; otherwise, we will not be able to refer to the related entities in the clauses of our LINQ queries.</p>
<p>Putting everything together, the final version of the <kbd>Destination</kbd> class is as follows:</p>
<pre>using System.Collections.Generic;<br/>using System.ComponentModel.DataAnnotations;<br/>using System.ComponentModel.DataAnnotations.Schema;<br/><br/>namespace WWTravelClubDB.Models<br/>{<br/>    public class Destination<br/>    {<br/>        public int Id { get; set; }<br/>        [MaxLength(128), Required]<br/>        public string Name { get; set; }<br/>        [MaxLength(128), Required]<br/>        public string Country { get; set; }<br/>        public string Description { get; set; }<br/>        public ICollection&lt;Package&gt; Packages { get; set; }<br/>    }<br/>}</pre>
<p>Since the <kbd>Description</kbd> property has no length limits, it will be implemented with a SQL Server <kbd><span>ntext</span></kbd> field of indefinite length. We can write the code for the <kbd>Package</kbd> class in a similar way:</p>
<pre>using System;<br/>using System.ComponentModel.DataAnnotations;<br/>using System.ComponentModel.DataAnnotations.Schema;<br/>namespace WWTravelClubDB.Models<br/>{<br/>    public class Package<br/>    {<br/>        public int Id { get; set; }<br/>        [MaxLength(128), Required]<br/>        public string Name { get; set; }<br/>        [MaxLength(128)]<br/>        public string Description { get; set; }<br/>        public decimal Price { get; set; }<br/>        public int DuratioInDays { get; set; }<br/>        public DateTime? StartValidityDate { get; set; }<br/>        public DateTime? EndValidityDate { get; set; }<br/>        public Destination MyDestination { get; set; }<br/>        public int DestinationId { get; set; }<br/>    }<br/>}</pre>
<p>Each package has a duration in days, as well as optional start and stop dates in which the package offer is valid. <kbd>MyDestination</kbd> connects packages with their destinations in the many-to-one relationship that they have with the <kbd>Destination</kbd> entity, while <kbd>DestinationId</kbd> is the external key of the same relation.</p>
<p>While it is not obligatory to specify the external key, it is good practice to do so since this is the only way to specify some properties of the relationship. For instance, in our case, since <kbd>DestinationId</kbd> is an <kbd>int</kbd> (value type), it is obligatory. Therefore, the relationship here is one-to-many and not (0, 1)-to-many. Defining <kbd>DestinationId</kbd> as <kbd>int?</kbd>, instead of <kbd>int</kbd>, would turn the one-to-many relationship into a <span>(0, 1)-to-many relationship.</span></p>
<p>In the next section, we will explain how to define the in-memory collection that represents the database tables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the mapped collections</h1>
                </header>
            
            <article>
                
<p>Once we have defined all the entities that are object-oriented representations of the database rows, we need to define the in-memory collections that represent the database tables themselves. <span>As we mentioned in the <em>ORM basics</em> section, a</span>ll the database operations are mapped to the operations on these collections (the <em>Querying and updating data with Entity Framework Core</em> section of this chapter explains <em>how</em>). It is enough to add a <kbd>DbSet&lt;T&gt;</kbd> collection property to our <kbd>DBContext</kbd> for each entity, <kbd>T</kbd>. Usually, the name of each of these properties is obtained by pluralizing the entity name. Thus, we need to add the following two properties to our <kbd>MainDBContext</kbd>:</p>
<pre>public DbSet&lt;Package&gt; Packages { get; set; }<br/>public DbSet&lt;Destination&gt; Destinations { get; set; }</pre>
<p class="mce-root">Up until now, we've translated database stuff into properties, classes, and data annotations. However, Entity Framework needs further information to interact with a database. The next subsection explains how to provide them.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Completing the mapping configuration</h1>
                </header>
            
            <article>
                
<p>The mapping configuration <span>information that we couldn't specify in the entity definitions must be added in the </span><kbd>OnModelCreating DBContext</kbd><span> </span><span>method. Each configuration information relat</span><span>ive to an entity,</span> <kbd>T</kbd>, <span>starts with </span><kbd>builder.Entity&lt;T&gt;()</kbd> <span>and continues with a call to a method that specifies that kind of constraint. Further nested calls specify further properties of the constraint. For instance, our one-to-many relationship may be configured as follows:</span></p>
<pre>builder.Entity&lt;Destination&gt;()<br/>    .HasMany(m =&gt; m.Packages)<br/>    .WithOne(m =&gt; m.MyDestination)<br/>    .HasForeignKey(m =&gt; m.DestinationId)<br/>    .OnDelete(DeleteBehavior.Cascade);</pre>
<p>The two sides of the relationship are specified through the navigation properties that we added to our entities. <kbd>HasForeignKey</kbd> specifies the external key. Finally, <kbd>OnDelete</kbd> specifies what to do with packages when a destination is deleted. In our case, it performs a cascade delete of all the packages related to that destination.</p>
<p>The same configuration can be defined by starting from the other side of the relationship, that is, starting with <kbd>builder.Entity&lt;Package&gt;()</kbd>:</p>
<pre>builder.Entity&lt;Package&gt;()<br/>    .HasOne(m =&gt; m.MyDestination)<br/>    .WithMany(m =&gt; m.Packages)<br/>    .HasForeignKey(m =&gt; m.DestinationId)<br/>    .OnDelete(DeleteBehavior.Cascade);</pre>
<p>The only difference is that the previous statement's <kbd>HasMany</kbd>-<kbd>WithOne</kbd> methods are replaced by the <kbd>HasOne</kbd>-<kbd>WithMany</kbd> methods since we started from the other side of the relationship.</p>
<p>The <kbd>ModelBuilder builder</kbd> object allows us to specify database indexes with something such as the following:</p>
<pre>builder.Entity&lt;T&gt;()<br/>   .HasIndex(m =&gt; m.PropertyName);</pre>
<p>Multi-property indexes are defined as follows:</p>
<pre>builder.Entity&lt;T&gt;()<br/>    .HasIndex("propertyName1", "propertyName2", ...);</pre>
<p>If we add all the necessary configuration information, then our <kbd>OnModelCreating</kbd> method will look as follows:</p>
<pre>protected override void OnModelCreating(ModelBuilder builder)<br/>{<br/>    builder.Entity&lt;Destination&gt;()<br/>        .HasMany(m =&gt; m.Packages)<br/>        .WithOne(m =&gt; m.MyDestination)<br/>        .HasForeignKey(m =&gt; m.DestinationId)<br/>        .OnDelete(DeleteBehavior.Cascade);<br/><br/>    builder.Entity&lt;Destination&gt;()<br/>        .HasIndex(m =&gt; m.Country);<br/><br/>    builder.Entity&lt;Destination&gt;()<br/>        .HasIndex(m =&gt; m.Name);<br/><br/>    builder.Entity&lt;Package&gt;()<br/> .HasIndex(m =&gt; m.Name);<br/><br/>    builder.Entity&lt;Package&gt;()<br/>        .HasIndex("StartValidityDate", "EndValidityDate");<br/>} </pre>
<p>Once you've configured Entity Framework Core, we can use all the configuration information we have to create the actual database and put all the tools we need in place in order to update the database's structure as the application evolves. The next section explains how.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entity Framework Core migrations</h1>
                </header>
            
            <article>
                
<p>Now that we've configured Entity Framework and defined our application-specific <kbd>DBContext</kbd> subclass, we can use the Entity Framework Core design tools to generate the physical database and create the database structure snapshot that's needed by Entity Framework Core to interact with the database.</p>
<p>Entity Framework Core design tools must be installed in each project that needs them as NuGet packages.<span> </span>There are two equivalent options:</p>
<ul>
<li><strong>Tools that work in any Windows console</strong>: These are available through the <kbd>Microsoft.EntityFrameworkCore.Design</kbd><span> </span>NuGet package. All Entity Framework Core commands are in <kbd>dotnet ef .....</kbd> format since they are contained in the<span> </span><kbd>ef</kbd><span> </span>command line's .NET Core application.</li>
<li><strong>Tools that are specific to the Visual Studio</strong> <span class="packt_screen">Package Manager Console</span>: These are contained in the <kbd>Microsoft.EntityFrameworkCore.Tools</kbd><span> </span>NuGet package. They don't need the <kbd>dotnet ef</kbd><span> </span>prefix since they can only be launched from the <span class="packt_screen">Package Manager Console</span> inside of Visual Studio.</li>
</ul>
<p>Entity Framework Core's design tools are used within the design/update procedure. This procedure is as follows:</p>
<ol>
<li>We modify <kbd>DBContext</kbd> and Entities' definitions as needed.</li>
<li>We launch the design tools to ask Entity Framework Core to detect and process all the changes we made.</li>
<li>Once launched, the design tools update the database structure snapshot and generate a new <em>migration</em>, that is, a file containing all the instructions we need in order to modify the physical database to reflect all the changes we made.</li>
<li>We launch another tool to update the database with the newly created migration.</li>
<li>We test the newly configured DB layer and, if new changes are necessary, we go back to <em>step 1</em>. </li>
<li>When the data layer is ready, it is deployed in staging or production, where all the migrations are applied once more to the actual staging/production database.</li>
</ol>
<p>This is repeated several times in the various software project iterations and during the lifetime of the application. If we operate on an already existing database, we need to configure <kbd>DBContext</kbd> and its models to reflect the existing structure of all the tables we want to map. Then, we call the design tools with an <kbd>IgnoreChanges</kbd> option so that they generate an empty migration. Also, this empty migration must be passed to the physical database so that it can synchronize a database structure version associated with the physical database with the version that's been recorded in the database snapshot. This version is important because it determines which migrations must be applied to a database and which ones have already been applied.</p>
<p class="mce-root"/>
<p>The whole design process needs a test/design database and, if we operate on an existing database, the structure of this test/design database must reflect the actual database <span>–</span> at least in terms of the tables we want to map. To enable design tools so that we can interact with the database, we must define the <kbd>DbContextOptions</kbd> options that they pass to the <kbd>DBContext</kbd> constructor. These options are important at design time since they contain the connection string of the test/design database. The design tools can be informed about our <kbd>DbContextOptions</kbd><span> options if we create</span> a class that implements the <kbd>IDesignTimeDbContextFactory&lt;T&gt;</kbd> interface, where <kbd>T</kbd> is our <kbd>DBContext</kbd> subclass:</p>
<pre>using Microsoft.EntityFrameworkCore;<br/>using Microsoft.EntityFrameworkCore.Design;<br/><br/>namespace WWTravelClubDB<br/>{<br/>    public class LibraryDesignTimeDbContextFactory<br/>        : IDesignTimeDbContextFactory&lt;MainDBContext&gt;<br/>    {<br/>        private const string connectionString =<br/>            @"Server=(localdb)\mssqllocaldb;Database=wwtravelclub;<br/>                Trusted_Connection=True;MultipleActiveResultSets=true";<br/>        public MainDBContext CreateDbContext(params string[] args)<br/>        {<br/>            var builder = new DbContextOptionsBuilder&lt;MainDBContext&gt;();<br/>            <br/>            builder.UseSqlServer(connectionString);<br/>            return new MainDBContext(builder.Options);<br/>        }<br/>    }<br/>}</pre>
<p><kbd>connectionString</kbd> will be used by Entity Framework to create a new database in the local SQL Server instance that's been installed in the development machine and connects with Windows credentials. You are free to change it to reflect your needs.</p>
<p>Now, we are ready to create our first migration! Let's get started:</p>
<ol>
<li>Let's go to the Package Manager Console and ensure that WWTravelClubDB is selected as our default project.</li>
</ol>
<ol start="2">
<li>Now, type <kbd>Add-Migration initial</kbd> and press <em>Enter</em> to issue this command:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d81b11a6-78ee-4f9f-b286-002c0b88ddb1.png" style="width:37.83em;height:9.50em;"/></p>
<div class="packt_infobox"><kbd>initial</kbd> is the name we gave our first migration. So, in general, the command is <kbd>Add-Migration &lt;migration name&gt;</kbd>. When we operate on an existing database, we must add the <kbd>-IgnoreChanges</kbd> option to the first migration (and just to that) so that an empty migration is created. References to the whole set of commands can be found in the <em>Further reading</em> section.</div>
<ol start="3">
<li>If, after having created the migration, but before having applied the migration to the database, we realize we made some errors, we can undo our action with the <kbd>Remove-Migration</kbd> command. If the migration has already been applied to the database, the simplest way to correct our error is to make all the necessary changes to the code and then apply another migration.</li>
<li>As soon as the <kbd>Add-Migration</kbd> <span>command is executed, a new folder appears in our project:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bb865a32-ee95-460d-ab24-c9b86ee779a6.png" style="width:18.58em;height:5.58em;"/></p>
<div class="packt_infobox"><kbd>20190205102637_initial.cs</kbd> is our migration expressed in an easy to understand language.</div>
<p>You may review the code to verify that everything is okay and you may also modify the migration content (only if you are enough of an expert to do it reliably). Each migration contains an <kbd>Up</kbd> method and a <kbd>Down</kbd> method. The <kbd>Up</kbd> method implies the migration, while the <kbd>Down</kbd> method undoes its changes. Accordingly, the <kbd>Down</kbd> method contains the reverse actions of all the actions included in the <kbd>Up</kbd> method in reverse order.</p>
<p><kbd>20190205102637_initial.Designer.cs</kbd> is the Visual Studio designer code you <em>mustn't</em> modify, while <kbd>MainDBContextModelSnapshot.cs</kbd> is the overall database structure snapshot. If you add further migrations, new migration files and their designer counterparts will appear and the unique <kbd>MainDBContextModelSnapshot.cs</kbd> database structure snapshot will be updated to reflect the database's overall structure.</p>
<p>The same command can be issued in a Windows console by typing <kbd>dotnet ef migrations add initial</kbd>. However, this command must be issued from within the project's root folder (not from within the solution's root folder).</p>
<p>Migrations can be applied to the database by typing <kbd>Update-Database</kbd> in the Package Manager Console. The equivalent Windows console command is <kbd>dotnet ef database update</kbd>. Let's try using this command to create the physical database!</p>
<p>The next subsection explains how to create database stuff that Entity Framework is unable to create automatically. After that, in the next section, we will use Entity Framework's configuration and the database we generated with <kbd><span>dotnet ef database update</span></kbd> to create, query, and update data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding stored procedures and direct SQL commands</h1>
                </header>
            
            <article>
                
<p>Some database structures can't be generated automatically by the Entity Framework Core commands and declarations we described previously. For instance, Entity Framework Core can't generate automatically stored procedures. Stored procedures such as generic SQL strings can be included manually in the <kbd>Up</kbd> and <kbd>Down</kbd> methods through the <kbd>migrationBuilder.Sql("&lt;sql scommand&gt;")</kbd> method.</p>
<p>The safest way to do this is by adding a migration without performing any configuration changes so that the migration is empty when it's created. Then, we can add the necessary SQL commands to the empty <kbd>Up</kbd> method of this migration and their converse commands in the empty <kbd>Down</kbd> method. It is good practice to put all the SQL strings in the properties of resource files (<kbd>.resx</kbd> files).</p>
<p>Now, you are ready to interact with the database through Entity Framework Core.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Querying and updating data with Entity Framework Core</h1>
                </header>
            
            <article>
                
<p>To test our DB layer, we need to add a console project based on the same .NET Core version as our library to the solution. Let's get started:</p>
<ol>
<li>Let's call the new console project <kbd>WWTravelClubDBTest</kbd>.</li>
<li>Now, we need to add our data layer as a dependency of the console project by right-clicking on the <em>References</em> node of the console project and selecting <em>Add reference</em>.</li>
<li>Remove the content of the <kbd>Main</kbd> <span>static method in the <kbd>program.cs</kbd> file and start by writing the following:</span></li>
</ol>
<pre style="padding-left: 60px">Console.WriteLine("program start: populate database");<br/>Console.ReadKey();</pre>
<ol start="4">
<li>Then, add the following namespaces at the top of the file:</li>
</ol>
<pre style="padding-left: 60px">using WWTravelClubDB;<br/>using WWTravelClubDB.Models;<br/>using Microsoft.EntityFrameworkCore;<br/>using System.Linq;</pre>
<p>Now that we have finished preparing our test project, we can experiment with queries and data updates. Let's start by creating some database objects, that is, some destinations and packages. Follow these steps to do so:</p>
<ol>
<li>First, we must create an instance of our <kbd>DBContext</kbd> subclass with an appropriate connection string. We can use the same <kbd>LibraryDesignTimeDbContextFactory</kbd> class that's used by the design tools to get it:</li>
</ol>
<pre style="padding-left: 60px">var context = new LibraryDesignTimeDbContextFactory()<br/>    .CreateDbContext(); </pre>
<ol start="2">
<li>New rows can be created by simply adding class instances to the mapped collections of our <kbd>DBContext</kbd> subclass. If a <kbd>Destination</kbd> instance has packages associated with it, we can simply add them to its <kbd>Packages</kbd> property:</li>
</ol>
<pre style="padding-left: 60px">var firstDestination= new Destination<br/>{<br/>    Name = "Florence",<br/>    Country = "Italy",<br/>    Packages = new List&lt;Package&gt;()<br/>    {<br/>        new Package<br/>        {<br/>            Name = "Summer in Florence",<br/>            StartValidityDate = new DateTime(2019, 6, 1),<br/>            EndValidityDate = new DateTime(2019, 10, 1),<br/>            DuratioInDays=7,<br/>            Price=1000<br/>        },<br/>        new Package<br/>        {<br/>            Name = "Winter in Florence",<br/>            StartValidityDate = new DateTime(2019, 12, 1),<br/>            EndValidityDate = new DateTime(2020, 2, 1),<br/>            DuratioInDays=7,<br/>            Price=500<br/>        }<br/>    }<br/>};<br/>context.Destinations.Add(firstDestination);<br/>context.SaveChanges();<br/>Console.WriteLine(<br/>    "DB populated: first destination id is "+<br/>    firstDestination.Id);<br/>Console.ReadKey();</pre>
<p>There is no need to specify primary keys since they are auto-generated and will be filled in by the database. In fact, after the <kbd>SaveChanges()</kbd> operation synchronizes our context with the actual DB, the <kbd>firstDestination.Id</kbd> property has a non-zero value. The same is true for the primary keys of <kbd>Package</kbd>.</p>
<p>When we declare that an entity (in our case, a <kbd>Package</kbd>) is a child of another entity (in our case, a <kbd>Destination</kbd>) by inserting it in a father entity collection (in our case, the <kbd>Packages</kbd> collection), there is no need to explicitly set its external key (in our case, <kbd>DestinationId</kbd>) since it is inferred automatically by Entity Framework Core. Once created and synchronized <span>with the</span> <kbd>firstDestination</kbd><span> database, we can add further packages in two different ways:</span></p>
<ul>
<li>Create a <kbd>Package</kbd> class instance, set its <kbd>DestinationId</kbd> <span>external key </span>to <kbd>firstDestination.Id</kbd> and add it to <kbd>context.Packages</kbd></li>
<li>Create a <kbd>Package</kbd> class instance, with no need to set its external key, and then add it to the <kbd>Packages</kbd> collection of its father <kbd>Destination</kbd> instance.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The latter option is the only possibility when a child entity (<kbd>Package</kbd>) is added with its father entity (<kbd>Destination</kbd>) and the father entity has an auto-generated principal key since, in this case, the external key isn't available at the time we perform the additions. In most of the other circumstances, the former option is simpler since the second option requires the father <kbd>Destination</kbd> entity to be loaded in memory, along with its <kbd>Packages</kbd> collection, that is, together with all the packages associated with the <kbd>Destination</kbd> object (by default, connected entities aren't loaded by queries).</p>
<p>Now, let's say we want to modify the <em>Florence</em> destination and <span>give a 10% increment to all <kbd>Florence</kbd> packages prices. How do we proceed? Follow these steps to find out how:</span></p>
<ol>
<li>First, we need to load the entity into memory with a query, modify it, and call <kbd>SaveChanges()</kbd> to synchronize our changes with the database. If we want to modify, say, just its description, a query such as the following is enough:</li>
</ol>
<pre style="padding-left: 60px">var toModify = context.Destinations<br/>    .Where(m =&gt; m.Name == "Florence").FirstOrDefault();</pre>
<ol start="2">
<li> We need to load all the related destination packages that are not loaded by default. This can be done with the <kbd>Include</kbd> clause, as follows:</li>
</ol>
<pre style="padding-left: 60px">var toModify = context.Destinations<br/>    .Where(m =&gt; m.Name == "Florence")<br/>    .Include(m =&gt; m.Packages)<br/>    .FirstOrDefault();</pre>
<ol start="3">
<li>After that, we can modify the description and package prices, as follows:</li>
</ol>
<pre style="padding-left: 60px">toModify.Description = <br/>  "Florence is a famous historical Italian town";<br/>foreach (var package in toModify.Packages)<br/>   package.Price = package.Price * 1.1m;<br/>context.SaveChanges();<br/><br/>var verifyChanges= context.Destinations<br/>    .Where(m =&gt; m.Name == "Florence")<br/>    .FirstOrDefault();<br/><br/>Console.WriteLine(<br/>    "New Florence description: " +<br/>    verifyChanges.Description);<br/>Console.ReadKey();</pre>
<p>So far, we've performed queries whose unique purpose is to update the retrieved entities. Next, we will explain how to retrieve information that will be shown to the user and/or be used by complex business operations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Returning data to the presentation layer</h1>
                </header>
            
            <article>
                
<p>To keep the layers separated and to adapt queries to the data that's actually needed by each <em>use case</em>, DB entities aren't sent as they are to the presentation layer. Instead, the data is projected into smaller classes that contain the information that's needed by the <em>use case</em>. These are implemented by the presentation layer's caller method. <span>Objects that</span> <span>move data from one layer to another are called <strong>Data Transport Objects</strong> (<strong>DTOs</strong>). As an example, let's create a DTO containing the summary information that is worth showing when returning a list of packages to the user (we suppose that, if needed, the user can get more details by clicking the package they are interested in):</span></p>
<ol>
<li>Let's <span>add a DTO to our WWTravelClubDBTest project</span> that contains all the information that needs to be shown in a list of packages: </li>
</ol>
<pre style="padding-left: 60px">namespace WWTravelClubDBTest<br/>{<br/>    public class PackagesListDTO<br/>    {<br/>        public int Id { get; set; }<br/>        public string Name { get; set; }<br/>        public decimal Price { get; set; }<br/>        public int DuratioInDays { get; set; }<br/>        public DateTime? StartValidityDate { get; set; }<br/>        public DateTime? EndValidityDate { get; set; }<br/>        public string DestinationName { get; set; }<br/>        public int DestinationId { get; set; }<br/>        public override string ToString()<br/>        {<br/>            return string.Format("{0}. {1} days in {2}, price: <br/>            {3}", Name, DuratioInDays, DestinationName, Price);<br/>        }<br/>    }<br/>}</pre>
<div class="packt_infobox">We don't need to load entities in memory and then copy their data into the DTO, but database data can be projected directly into the DTO, thanks to the LINQ <kbd>Select</kbd> clause. This minimizes how much data is exchanged with the database.</div>
<ol start="2">
<li>As an example, we can populate our DTOs with a query that checks all the packages that are available around the 10th of August:</li>
</ol>
<pre style="padding-left: 60px">var period = new DateTime(2019, 8, 10);<br/>var list = context.Packages<br/>    .Where(m =&gt; period &gt;= m.StartValidityDate<br/>    &amp;&amp; period &lt;= m.EndValidityDate)<br/>    .Select(m =&gt; new PackagesListDTO<br/>    {<br/>        StartValidityDate=m.StartValidityDate,<br/>        EndValidityDate=m.EndValidityDate,<br/>        Name=m.Name,<br/>        DuratioInDays=m.DuratioInDays,<br/>        Id=m.Id,<br/>        Price=m.Price,<br/>        DestinationName=m.MyDestination.Name,<br/>        DestinationId = m.DestinationId<br/>    })<br/>    .ToList();<br/>foreach (var result in list)<br/>    Console.WriteLine(result.ToString());<br/>Console.ReadKey();</pre>
<ol start="3">
<li>In the <kbd>Select</kbd> clause, we can also navigate to any related entities to get the data we need. For instance, the preceding query navigates to the related <kbd>Destination</kbd> entity to get the <kbd>Package</kbd> destination name.</li>
<li>Now, right-click on the WWTravelClubDBTest project in the Solution Explorer and set it as the start project. Then, run the solution.</li>
<li>The programs stop at each <kbd>Console.ReadKey()</kbd> method<span>, waiting for you to hit any key. This way, you have time to analyze the output that's produced by all the code snippets that we added to the</span> <kbd>Main</kbd> <span>method.</span></li>
</ol>
<p>Now, we will learn how to handle operations that can't be efficaciously mapped to the immediate operations in the in-memory collections that represent the database tables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Issuing direct SQL commands</h1>
                </header>
            
            <article>
                
<p>Not all database operations can be executed efficiently by querying the database with LINQ and updating in-memory entities. For instance, counter increments can be performed more efficiently with a single SQL instruction. Moreover, some operations can be executed with acceptable performance if we define adequate stored procedures/SQL commands. In these cases, we are forced to either issue direct SQL commands to the database or call database stored procedures from our Entity Framework code. There are two possibilities: SQL statements that perform database operations but do not return entities, and SQL statements that do return entities. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>SQL commands that don't return entities can be executed with the <kbd>DBContext</kbd> method, as follows:</p>
<pre>int DBContext.Database.ExecuteSqlRaw(string sql, params object[] parameters)</pre>
<p>Parameters can be referenced in the string as <kbd>{0}, {1}, ..., {n}</kbd>. Each <kbd>{m}</kbd> is filled with the object contained at the <kbd>m</kbd> index of the <kbd>parameters</kbd> array, which is converted from a .NET type into the corresponding SQL type. The method returns the number of affected rows.</p>
<p>SQL commands that return collections of entities must be issued through the <kbd>FromSqlRaw</kbd> method of the mapped collection associated with those entities:</p>
<pre>context.&lt;mapped collection&gt;.FromSqlRaw(string sql, params object[] parameters)</pre>
<p>Thus, for instance, a command that returns <kbd>Package</kbd> instances would look something like this:</p>
<pre>var results = context.Packages.FromSqlRaw("&lt;some sql&gt;", par1, par2, ...).ToList();</pre>
<p>SQL strings and parameters work like this in the <kbd>ExecuteSqlRaw</kbd> method. The following is a simple example:</p>
<pre><span class="pl-smi">var allPackages =context</span>.<span class="pl-smi">Packages</span>.<span class="pl-en">FromSqlRaw</span>(
    <span class="pl-s"><span class="pl-pds">"</span>SELECT * FROM Products WHERE Name = {0}<span class="pl-pds">"</span></span>,
    myP<span class="pl-smi">ackage</span><span class="pl-smi">Name</span>)</pre>
<p>It is good practice to put all the SQL strings in resource files and encapsulate all the <kbd>ExecuteSqlRaw</kbd> and <kbd>FromSqlRaw</kbd> calls inside the public methods that you defined in your <kbd>DBContext</kbd> subclasses, in order to keep the dependence from a specific database inside of your Entity Framework Core-based data layer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling transactions</h1>
                </header>
            
            <article>
                
<p>All the changes that are made to a <kbd>DBContext</kbd> instance are passed in a single transaction at the first <kbd>SaveChanges</kbd> call. However, sometimes, it is necessary to include queries and updates in the same transaction. In these cases, we must handle the transaction explicitly. Several entity Framework Core commands can be included in a transaction if we put them inside a <kbd>using</kbd> block associated with a transaction object:</p>
<pre>using (var dbContextTransaction = context.Database.BeginTransaction())<br/>{<br/>    try{<br/>        ...<br/>        ...<br/>        dbContextTransaction.Commit();<br/>    }<br/>    catch<br/>    {<br/>        dbContextTransaction.Rollback();<br/>    }<br/>}</pre>
<p>In the preceding code, <kbd>context</kbd> is an instance of our <kbd>DBContext</kbd> subclass. Inside of the <kbd>using</kbd> block, the transaction can be aborted and committed by calling its <kbd>Rollback</kbd> and <kbd>Commit</kbd> methods. Any <kbd>SaveChanges</kbd> calls that are included in the transaction block use the transaction they are already in, instead of creating new ones.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying your data layer</h1>
                </header>
            
            <article>
                
<p>When your database layer is deployed in production or in staging, usually, an empty database already exists, so you must apply all the migrations in order to create all the database objects. This can be done by calling <kbd>context.Database.Migrate()</kbd>. The <kbd>Migrate</kbd> method applies the migrations that haven't been applied to the databases yet, so it may be called safely several times during the application's lifetime. <kbd>context</kbd> is an instance of our <kbd>DBContext</kbd> class that must be passed through a connection string with enough privileges to create tables and to perform all the operations included in our migrations. Thus, typically, this connection string is different from the string we will use during normal application operations.</p>
<p>During the deployment of a web application on Azure, we are given the opportunity to check migrations with a connection string we provide. We can also check migrations manually by calling the <kbd>context.Database.Migrate()</kbd> method when the application starts. This will be discussed in detail in <a href="003ee8cb-5995-4364-8772-73d73df29cf8.xhtml">Chapter 13</a>, <em>Presenting ASP.NET Core MVC</em>, which is dedicated to ASP.NET MVC Web applications.</p>
<p>For desktop applications, we can apply migrations during the installation of the application and of its subsequent updates.</p>
<p>At the first application installation and/or in subsequent application updates, we may need to populate some tables with initial data. For Web applications this operation can be performed at application start, while for desktop application this operation can be included in the installation.</p>
<p>Database tables can be populated with Entity Framework Core commands. First, though, we need to <span>verify</span> whether the table is empty in order to avoid adding the same table rows several times. This can be done with the <kbd>Any()</kbd> LINQ method, as shown in the following code:</p>
<pre>if(!context.Destinations.Any())<br/>{<br/>    //populate here the Destinations table<br/>}</pre>
<p>Let's take a look at a few advanced features that Entity Framework Core has to share.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding Entity Framework Core advanced feature – global filters</h1>
                </header>
            
            <article>
                
<p>Global filters were introduced at the end of 2017. They enable techniques such as soft delete and multi-tenant tables that are shared by several users, where each user <span>just </span><em>sees</em> its records.</p>
<p>Global filters are defined with the <kbd>modelBuilder</kbd> object, which is available in the <kbd>DBContext OnModelCreating</kbd> method. The syntax for this method is as follows:</p>
<pre><span>modelBuilder.Entity&lt;MyEntity&gt;().HasQueryFilter(m =&gt; &lt;define filter condition here&gt;);<br/></span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>For instance, if we add an <kbd>IsDeleted</kbd> property to our <kbd>Package</kbd> class, we may soft delete a Package without removing it from the database by defining the following filter:</p>
<pre><span>modelBuilder.Entity&lt;Package&gt;().HasQueryFilter(m =&gt; !m.IsDeleted);</span></pre>
<p>However, filters contain <kbd>DBContext</kbd> properties. Thus, for instance, if we add a <kbd>CurrentUserID</kbd> property to our <kbd>DBContext</kbd> subclass (whose value is set as soon as a <kbd>DBContext</kbd> instance is created), then we can add a filter like the following one to all the entities that refer to a user ID:</p>
<pre>modelBuilder.Entity&lt;Document&gt;().HasQueryFilter(m =&gt; m.UserId == CurrentUserId);</pre>
<p>With the preceding filter in place, the currently logged user can <span>only</span> access the documents they own (the ones that have their <kbd>UserId</kbd>). Similar techniques are very useful in the implementation of multi-tenant applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at the essentials of ORM basics and why they are so useful. Then, we described Entity Framework Core. In particular, we discussed how to configure the database mappings with class annotations and other declarations and commands that are included in <kbd>DBContext</kbd> subclasses. </p>
<p>Then, we discussed how to automatically create and update the physical database structure with the help of migrations, as well as how to query and pass updates to the database through Entity Framework Core. Finally, we learned how to pass direct SQL commands and transactions through Entity Framework Core, as well as how to deploy a data layer based on Entity Framework Core.</p>
<p>This chapter also reviewed some of the advanced features that had been introduced in the latest Entity Framework Core releases.</p>
<p><span>In the next chapter, we will discuss how Entity Framework Core can be used with NoSQL data models and</span> the various types of storage options that are available in the cloud and, in particular, in Azure.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>How does Entity Framework Core adapt to several different database engines?</li>
<li>How are primary keys declared in E<span>ntity Framework Core?</span></li>
<li>How is a string field's length declared in E<span>ntity Framework Core?</span></li>
<li>How are indexes declared in E<span>ntity Framework Core?</span></li>
<li>How are relations declared in Entity Framework Core?</li>
<li>What are the two important migration commands? </li>
<li>By default, are related entities loaded by LINQ queries?</li>
<li>Is it possible to return database data in a class instance that isn't a database entity? If yes, how?</li>
<li>How are migrations applied in production and staging?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>More details about migrations commands can be found at <a href="https://docs.microsoft.com/en-US/ef/core/miscellaneous/cli/index">https://docs.microsoft.com/en-US/ef/core/miscellaneous/cli/index</a> and in the other links contained there.</li>
<li>More details about Entity Framework Core can be found in the official Microsoft documentation: <a href="https://docs.microsoft.com/en-us/ef/core/">https://docs.microsoft.com/en-us/ef/core/</a>.</li>
<li>An exhaustive set of <span>examples </span>of complex LINQ queries can be found here: <a href="https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b">https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b.</a></li>
</ul>


            </article>

            
        </section>
    </body></html>