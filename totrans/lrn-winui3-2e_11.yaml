- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Debugging WinUI Applications with Visual Studio
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Visual Studio调试WinUI应用程序
- en: Good debugging skills are essential for developers. While .NET developers need
    to know how to use features including breakpoints and the **Output** and **Immediate**
    windows, WinUI project debugging adds another set of tools and techniques to master.
    There are issues that can arise in the UI layer with data binding, layout, and
    resources. You will learn how to use **Live Visual Tree** and **Live Property
    Explorer** and how to discover data binding errors with Visual Studio’s **XAML
    Binding** **Failures** window.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的调试技能对于开发者至关重要。虽然.NET开发者需要了解如何使用包括断点和**输出**以及**立即**窗口在内的功能，但WinUI项目调试增加了另一套需要掌握的工具和技术。在UI层中可能会出现与数据绑定、布局和资源相关的问题。你将学习如何使用**实时视觉树**和**实时属性探索器**，以及如何使用Visual
    Studio的**XAML绑定****失败**窗口发现数据绑定错误。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to debug WinUI applications and work with breakpoints in ViewModels and
    service classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何调试WinUI应用程序并与ViewModel和服务类中的断点一起工作
- en: How to debug data binding failures by leveraging the **XAML Binding Failures**
    window in Visual Studio and avoid common problems when binding to collections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过利用Visual Studio中的**XAML绑定失败**窗口来调试数据绑定失败，并避免在绑定到集合时遇到常见问题
- en: Explore the **Live Visual Tree** window in Visual Studio to find layout problems
    in your XAML
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Visual Studio中探索**实时视觉树**窗口以找到你的XAML中的布局问题
- en: Discover and use **Live Property Explorer** to get and set data in your XAML
    elements at runtime
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现并使用**实时属性探索器**在运行时获取和设置你的XAML元素中的数据
- en: By the end of this chapter, you will be comfortable with debugging common problems
    typically encountered by WinUI developers while developing applications. You’ll
    be able to use these skills while building applications with other XAML frameworks,
    such as .NET MAUI, WPF, and UWP, too.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够舒适地调试WinUI开发者在开发应用程序时通常遇到的常见问题。你将能够在构建其他XAML框架（如.NET MAUI、WPF和UWP）的应用程序时使用这些技能。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples in this chapter, the following software is
    required:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中的示例，需要以下软件：
- en: Windows 10 version 1809 (build 17763) or newer or Windows 11
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 10版本1809（构建17763）或更高版本或Windows 11
- en: Visual Studio 2022 or later with the .NET Desktop Development workload configured
    for Windows App SDK development
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置了Windows App SDK开发的Visual Studio 2022或更高版本
- en: 'The source code for this chapter is available on GitHub at this URL: [https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter11](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter11).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下GitHub URL处获取：[https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter11](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter11)。
- en: Debugging in Visual Studio
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Visual Studio中调试
- en: There are several fundamental areas of debugging WinUI applications that we
    will be covering in this section. Some of these techniques are applicable to debugging
    other types of .NET applications, whereas others are specific to XAML and WinUI
    development. Throughout the book, we’ve run our projects with Visual Studio, which
    is an example of a local debugging session. We will explore other ways to debug
    local applications as well as remote applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖调试WinUI应用程序的几个基本领域。其中一些技术适用于调试其他类型的.NET应用程序，而其他技术则特定于XAML和WinUI开发。在整个书中，我们使用Visual
    Studio运行我们的项目，这是一个本地调试会话的例子。我们还将探讨其他调试本地应用程序以及远程应用程序的方法。
- en: Simple mistakes in XAML markup are not always apparent when we’re writing it,
    and this kind of problem is not detected by the compiler. In this section, we
    will see how to detect and avoid XAML markup issues and how to adhere to best
    practices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写XAML标记时，简单的错误并不总是显而易见，这种问题也不会被编译器检测到。在本节中，我们将看到如何检测和避免XAML标记问题，以及如何遵循最佳实践。
- en: Let’s get started by taking a closer look at debugging local applications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更仔细地查看调试本地应用程序开始。
- en: Debugging local applications
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试本地应用程序
- en: Open the **Ch11-MyMediaCollection** project from GitHub and compile it to make
    sure you have downloaded all the referenced NuGet packages. This is the WinUI
    3 project that we’ve been building throughout the previous chapters. Run the application
    to make sure everything works as expected.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从GitHub打开**Ch11-MyMediaCollection**项目并编译它，以确保你已下载所有引用的NuGet包。这是我们之前章节中一直在构建的WinUI
    3项目。运行应用程序以确保一切按预期工作。
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you have experience in developing and debugging WPF or UWP applications,
    you’re probably familiar with **XAML Designer** in Visual Studio. There is no
    designer support for WinUI 3 applications at this time. It’s unclear if or when
    this feature will be added. There is some discussion on GitHub about this topic
    here: [https://github.com/microsoft/microsoft-ui-xaml/issues/5917](https://github.com/microsoft/microsoft-ui-xaml/issues/5917).
    As one of the comments in the issue suggests, you can try to work around this
    limitation by leveraging **XAML Hot Reload** in Visual Studio to make changes
    to the XAML file while debugging. While there are some limitations to this approach
    (see [https://github.com/microsoft/microsoft-ui-xaml/issues/7043](https://github.com/microsoft/microsoft-ui-xaml/issues/7043)),
    most simple XAML changes will be reflected in the running app when saving. For
    more information about XAML Hot Reload, see the Microsoft Learn documentation:
    [https://learn.microsoft.com/visualstudio/xaml-tools/xaml-hot-reload](https://learn.microsoft.com/visualstudio/xaml-tools/xaml-hot-reload).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有开发和使用WPF或UWP应用程序的调试经验，您可能熟悉Visual Studio中的**XAML设计器**。目前WinUI 3应用程序没有设计器支持。不清楚这个功能是否会添加，以及何时会添加。GitHub上关于这个话题有一些讨论：[https://github.com/microsoft/microsoft-ui-xaml/issues/5917](https://github.com/microsoft/microsoft-ui-xaml/issues/5917)。问题中的一个评论建议，您可以通过利用Visual
    Studio中的**XAML热重载**来尝试解决这个问题，以便在调试时更改XAML文件。虽然这种方法有一些限制（见[https://github.com/microsoft/microsoft-ui-xaml/issues/7043](https://github.com/microsoft/microsoft-ui-xaml/issues/7043)），但大多数简单的XAML更改在保存时都会反映在运行的应用程序中。有关XAML热重载的更多信息，请参阅Microsoft
    Learn文档：[https://learn.microsoft.com/visualstudio/xaml-tools/xaml-hot-reload](https://learn.microsoft.com/visualstudio/xaml-tools/xaml-hot-reload)。
- en: For our first walk-through, let’s look at how to debug a local application installed
    on your PC.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一次演练中，让我们看看如何调试您PC上安装的本地应用程序。
- en: Debugging a locally installed application
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试本地安装的应用程序
- en: We have been running and debugging our Visual Studio solutions throughout this
    book. Now we will see how you can debug an application that you have already installed
    in Windows.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在本书中运行和调试我们的Visual Studio解决方案。现在我们将看看您如何调试已安装在Windows中的应用程序。
- en: 'You have previously run several projects while reading this book. Unless you
    uninstalled them, each should appear as an installed app package that you can
    debug. Let’s start with the steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您在阅读本书时已经运行了几个项目。除非您已卸载它们，否则每个项目都应显示为可调试的已安装应用程序包。让我们从以下步骤开始：
- en: 'Start by selecting **Debug** | **Other Debug Targets** | **Debug Installed
    App Package** in Visual Studio. The **Debug Installed App Package** window will
    appear:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，首先选择**调试** | **其他调试目标** | **调试已安装应用程序包**。将出现**调试已安装应用程序包**窗口：
- en: '![Figure 11.1 – The Debug Installed App Package window](img/B20908_11_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 调试已安装应用程序包窗口](img/B20908_11_01.jpg)'
- en: Figure 11.1 – The Debug Installed App Package window
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 调试已安装应用程序包窗口
- en: This window will show all the installed packages on your Windows PC. Some names
    will be familiar, such as **Microsoft.WindowsTerminal**, **Fluent XAML Theme Editor**,
    or **Microsoft Defender**. Others will only be listed by their application ID.
    You can select some of these other applications to debug, but without debug symbols,
    you won’t be able to hit any breakpoints or step through the code. Let’s find
    one of our applications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此窗口将显示您Windows PC上安装的所有软件包。一些名称您可能很熟悉，例如**Microsoft.WindowsTerminal**、**Fluent
    XAML Theme Editor**或**Microsoft Defender**。其他名称可能只以应用程序ID列出。您可以选择这些其他应用程序进行调试，但没有调试符号，您将无法设置断点或逐步执行代码。让我们找到我们的一个应用程序。
- en: If you have debugged the `MyMediaCollection`. The **MyMediaCollection** application
    will appear in the search results. If you do not see it, make sure you have run
    the application from Visual Studio at least once. This step is necessary to package
    and deploy the application to Windows.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已经调试了`MyMediaCollection`。**MyMediaCollection**应用程序将出现在搜索结果中。如果您看不到它，请确保您至少从Visual
    Studio运行了该应用程序一次。这一步是必要的，以便将应用程序打包并部署到Windows。
- en: Select it and click **Start**. The application will run, and Visual Studio will
    start debugging.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择它并点击**开始**。应用程序将运行，Visual Studio将开始调试。
- en: If you don’t want to start debugging immediately, you can select the **Do not
    launch, but debug my code when it starts** checkbox. Now, Visual Studio will start
    debugging when you start the application from the **Start** menu or any other
    method.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您不想立即开始调试，您可以选择**不启动，但启动应用程序时调试我的代码**复选框。现在，当您从**开始**菜单或任何其他方法启动应用程序时，Visual
    Studio将开始调试。
- en: 'Another way to start debugging an installed local application is by attaching
    it to a running application:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种开始调试已安装的本地应用程序的方法是将它附加到正在运行的应用程序：
- en: First, run the app from the **Start** menu, and in Visual Studio, go to **Debug**
    | **Attach** **to Process**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从**开始**菜单运行应用程序，然后在 Visual Studio 中转到**调试** | **附加** **到进程**。
- en: 'In the `ApplicationFrameHost.exe` process with the title that matches the application
    you want to debug. This is the process that hosts every packaged WinUI and UWP
    application on Windows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标题与您要调试的应用程序匹配的 `ApplicationFrameHost.exe` 进程中。这是在 Windows 上托管每个打包的 WinUI 和
    UWP 应用程序的过程：
- en: '![Figure 11.2 – Attaching to a running process to debug a packaged application](img/B20908_11_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 附加到正在运行的过程以调试打包的应用程序](img/B20908_11_02.jpg)'
- en: Figure 11.2 – Attaching to a running process to debug a packaged application
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 附加到正在运行的过程以调试打包的应用程序
- en: Click **Attach** and begin debugging as usual.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**附加**并像往常一样开始调试。
- en: These are different ways to start a debugging session on a local application,
    but what if you want to debug your application running on another machine? Let’s
    examine those options next.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是启动本地应用程序调试会话的不同方法，但如果你想在另一台机器上调试你的应用程序怎么办？让我们接下来检查那些选项。
- en: Debugging remote applications
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试远程应用程序
- en: There are many reasons why you might want to debug an application on a remote
    machine. Sometimes you can only reproduce an error on one device. Perhaps there
    is an issue that only occurs on a specific device type or screen size. If you
    were working with a UWP project, there are some devices, such as Xbox, where you
    have to use remote debugging.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能有很多原因想在远程机器上调试应用程序。有时您只能在某个设备上重现错误。也许存在仅在特定设备类型或屏幕尺寸上出现的问题。如果您正在处理 UWP 项目，有些设备，如
    Xbox，您必须使用远程调试。
- en: Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before starting any remote debugging session, ensure that the target device
    has **developer mode** enabled. For more information about activating developer
    mode, you can read this Microsoft Docs article: [https://learn.microsoft.com/windows/apps/get-started/enable-your-device-for-development](https://learn.microsoft.com/windows/apps/get-started/enable-your-device-for-development).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始任何远程调试会话之前，请确保目标设备已启用**开发者模式**。有关激活开发者模式的更多信息，您可以阅读这篇 Microsoft Docs 文章：[https://learn.microsoft.com/windows/apps/get-started/enable-your-device-for-development](https://learn.microsoft.com/windows/apps/get-started/enable-your-device-for-development)。
- en: 'To debug a remote installed application, you will use Visual Studio’s **Debug
    Installed App Package** window again:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试远程已安装的应用程序，您将再次使用 Visual Studio 的**调试已安装应用程序包**窗口：
- en: Open the window from **Debug** | **Other Debug Targets** | **Debug Installed**
    **App Package**.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**调试** | **其他调试目标** | **调试已安装** **应用程序包**打开窗口。
- en: 'Change **Connection Type** to **Remote Machine**:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**连接类型**更改为**远程机器**：
- en: '![Figure 11.3 – Debugging an application package on a remote machine](img/B20908_11_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 在远程机器上调试应用程序包](img/B20908_11_03.jpg)'
- en: Figure 11.3 – Debugging an application package on a remote machine
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 在远程机器上调试应用程序包
- en: Click the **Change** button in the **Connection Type** section to open the **Remote**
    **Connections** window.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**连接类型**部分的**更改**按钮以打开**远程** **连接**窗口。
- en: 'Visual Studio will attempt to discover other Windows devices and list them
    in the **Auto Detected** section. If you see the device you want, select it to
    continue. If the device you want to debug isn’t shown, enter its IP address in
    the **Address** field in the **Manual Configuration** section and click **Select**:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 将尝试发现其他 Windows 设备并将它们列在**自动检测**部分。如果您看到您想要的设备，请选择它以继续。如果您要调试的设备没有显示，请在**手动配置**部分的**地址**字段中输入其
    IP 地址，然后点击**选择**：
- en: '![Figure 11.4 – Enter a manually configured remote connection for debugging](img/B20908_11_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 为调试手动配置远程连接](img/B20908_11_04.jpg)'
- en: Figure 11.4 – Enter a manually configured remote connection for debugging
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 为调试手动配置远程连接
- en: When you return to the previous window, you can select the application to debug
    from the list of installed app packages on the selected device.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你返回到之前的窗口时，你可以从所选设备上安装的应用程序包列表中选择要调试的应用程序。
- en: Click **Start** to begin debugging, just as we did with the locally installed
    application in the previous section.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**开始**以开始调试，就像我们在上一节中在本地安装的应用程序中做的那样。
- en: 'These techniques will allow you to connect to other Windows machines. For UWP
    applications, this includes other device types, such as Xbox, HoloLens, Surface
    Hub, and Windows IoT devices. Debugging options and resources can also be accessed
    from the **Debug** tab of the project’s **Properties** page. Select **Open debug
    launch profiles UI** to open the **Launch** **Profiles** window:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术将允许您连接到其他 Windows 机器。对于 UWP 应用程序，这包括其他设备类型，例如 Xbox、HoloLens、Surface Hub
    和 Windows IoT 设备。您还可以从项目的 **属性** 页面的 **调试** 选项卡访问调试选项和资源。选择 **打开调试启动配置文件 UI**
    以打开 **启动** **配置文件** 窗口：
- en: '![Figure 11.5 – The Launch Profiles window in Visual Studio](img/B20908_11_05.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – Visual Studio 中的启动配置文件窗口](img/B20908_11_05.jpg)'
- en: Figure 11.5 – The Launch Profiles window in Visual Studio
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – Visual Studio 中的启动配置文件窗口
- en: Let’s shift gears and examine some common mistakes that can cause rendering
    issues in your application’s UI.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转换一下思路，来检查一些可能导致应用程序 UI 出现渲染问题的常见错误。
- en: Common XAML layout mistakes
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的 XAML 布局错误
- en: There are many kinds of mistakes that XAML developers can make while coding
    the UI. Some of them won’t be caught by the compiler. If you have a syntax error
    or an invalid `x:Bind` expression, these will fail while compiling, but many other
    issues will not.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: XAML 开发者在编码 UI 时可能会犯许多种错误。其中一些错误不会被编译器捕获。如果您有语法错误或无效的 `x:Bind` 表达式，这些错误将在编译时失败，但许多其他问题则不会。
- en: The first source of common XAML layout mistakes we will explore is the `Grid`
    control.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的第一个常见 XAML 布局错误的来源是 `Grid` 控件。
- en: Grid layout issues
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网格布局问题
- en: Some mistakes related to the `Grid` control revolve around its rows and columns.
    Forgetting to set `Grid.Row` or `Grid.Column` on child controls leads to overlapping
    or obscured elements at runtime. Similar issues can be seen when setting these
    values incorrectly or when working with `Grid.RowSpan` and `Grid.ColumnSpan`.
    One mistake that’s not always immediately apparent is setting `Grid.Row` or `Grid.Column`
    to a value that’s beyond the defined number of rows or columns.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一些与 `Grid` 控件相关的错误围绕着其行和列。忘记在子控件上设置 `Grid.Row` 或 `Grid.Column` 会导致运行时重叠或遮挡元素。当设置这些值不正确或处理
    `Grid.RowSpan` 和 `Grid.ColumnSpan` 时，也会出现类似的问题。一个不一定立即显而易见的错误是将 `Grid.Row` 或 `Grid.Column`
    设置为一个超出定义的行或列数的值。
- en: Open `Grid.Row` attribute from the `Border` control containing the `Button`
    controls at the bottom of the page. If you run the application, you will see the
    buttons move to the top of the page and overlap the controls in the header area.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从包含页面底部按钮控件的 `Border` 控件中打开 `Grid.Row` 属性。如果您运行应用程序，您将看到按钮移动到页面顶部并覆盖标题区域中的控件。
- en: Now restore the `Grid.Row` attribute but change the value to `5`. If this were
    the last row in the grid, everything would look fine even though `Grid` only has
    four rows. Since `5` is greater than the number of available rows, the control
    is added to the last row in `Grid`. However, because we have `InfoBar` below the
    buttons in the fourth row, the buttons and the `InfoBar` overlap.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在恢复 `Grid.Row` 属性，但将值更改为 `5`。如果这是网格中的最后一行，一切看起来都会很好，即使 `Grid` 只有三行。由于 `5` 大于可用的行数，控件被添加到
    `Grid` 的最后一行。然而，因为我们有 `InfoBar` 在第四行的按钮下方，所以按钮和 `InfoBar` 发生了重叠。
- en: Problems when applying style
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用样式时的问题
- en: XAML `Style` resources are another common source of unintentional UI changes.
    When creating `Style` in `Resource`, you should be aware of how it will be applied
    to controls within the scope of that `Resource`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: XAML 的 `Style` 资源是另一个常见的无意中导致 UI 变化的来源。在 `Resource` 中创建 `Style` 时，您应该意识到它将如何应用于该
    `Resource` 范围内的控件。
- en: 'Open `Page.Resources` section. This is where we created three `Style` elements
    for the current page. Each has a different `Target` type: `TextBlock`, `TextBox`,
    and `ComboBox`. However, they won’t be applied to every control of those types
    on the `Page` because we also gave each `Style` an `x:Key`. That means that `Style`
    will only be applied to elements of that type when the `Style` property is explicitly
    set to that named resource. These are referred to as *explicit styles*:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Page.Resources` 部分。这是我们为当前页面创建了三个 `Style` 元素的地方。每个都有不同的 `Target` 类型：`TextBlock`、`TextBox`
    和 `ComboBox`。然而，它们不会应用于 `Page` 上这些类型的每个控件，因为我们还给了每个 `Style` 一个 `x:Key`。这意味着只有当
    `Style` 属性明确设置为该命名资源时，`Style` 才会应用于该类型的元素。这些被称为 *显式样式*：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you remove `x:Key` from `Style` in `Page.Resources`, that *implicit style*
    will apply to every control of the specified `Target` type on the `Page`, unless
    those controls have another explicit `Style` set. In a large application with
    styles declared at different scopes (`Application`, `Page`, or control), it can
    sometimes be difficult to determine which style has been applied to a control.
    We will see how to do this later in the chapter when discussing Visual Studio’s
    **Live Property Explorer** window. It’s a best practice to have implicit styles
    always inherit from an explicit style. This enables developers to inherit from
    a default style and reduces repeated implicit style attributes across elements.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从 `Page.Resources` 中的 `Style` 移除 `x:Key`，那么这种 *隐式样式* 将应用于 `Page` 上指定 `Target`
    类型的每个控件，除非这些控件已设置了另一个显式 `Style`。在一个具有在不同作用域（`Application`、`Page` 或控件）中声明的样式的应用程序中，有时很难确定应用于控件的样式。我们将在本章后面讨论
    Visual Studio 的 **实时属性浏览器** 窗口时看到如何做到这一点。让隐式样式始终继承自显式样式是一种最佳实践。这使开发者能够从默认样式继承，并减少元素间重复的隐式样式属性。
- en: Next, we will look at a third-party extension that can help find common XAML
    problems through **static** **code analysis**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看一个第三方扩展，它可以通过 **静态** **代码分析**来帮助找到常见的 XAML 问题。
- en: Improving your XAML with static code analysis
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过静态代码分析改进您的 XAML
- en: There is a free, open source extension for Visual Studio that, among other things,
    adds support for static code analysis to XAML files. **Rapid XAML Toolkit** ([https://rapidxaml.dev/](https://rapidxaml.dev/))
    provides XAML analyzers and code fixes for common issues and provides support
    for adding your own custom XAML analyzers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个免费的、开源的 Visual Studio 扩展，它提供了对 XAML 文件进行静态代码分析的支持。**Rapid XAML Toolkit**
    ([https://rapidxaml.dev/](https://rapidxaml.dev/)) 提供了针对常见问题的 XAML 分析器和代码修复，并支持添加您自己的自定义
    XAML 分析器。
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, Rapid XAML Toolkit for Visual Studio 2022 has not yet
    been released. It is being developed and should be available by the time you read
    this book. The current example illustrates how to use the extension currently
    available for Visual Studio 2019.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Visual Studio 2022 的 Rapid XAML 工具包尚未发布。它正在开发中，并应在您阅读本书时可用。当前示例说明了如何使用目前适用于
    Visual Studio 2019 的扩展。
- en: 'Let’s install the tool in Visual Studio and see what kind of issues it can
    identify in a WinUI project:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Visual Studio 中安装这个工具，看看它能在 WinUI 项目中识别出哪些问题：
- en: In Visual Studio, go to **Extensions** | **Manage Extensions**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，转到 **扩展** | **管理扩展**。
- en: 'The `rapid xaml`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rapid xaml`:'
- en: "![Figure 11.6 – Installing Rapid XAM\uFEFFL Toolkit](img/B20908_11_06.jpg)"
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – 安装 Rapid XAML 工具包](img/B20908_11_06.jpg)'
- en: Figure 11.6 – Installing Rapid XAML Toolkit
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 安装 Rapid XAML 工具包
- en: Click **Download** to queue the extension for installation. When the download
    completes, you can close the **Manage Extensions** window and restart Visual Studio
    to complete the installation.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下载** 将扩展排队以进行安装。下载完成后，您可以关闭 **管理扩展** 窗口，重新启动 Visual Studio 以完成安装。
- en: 'Now, when you view the **Error List** window in Visual Studio, there are a
    handful of warnings from Rapid XAML’s analyzers:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当您在 Visual Studio 中查看 **错误列表** 窗口时，会有一些来自 Rapid XAML 分析器的警告：
- en: '![Figure 11.7 – Viewing the new warnings from Rapid XAML Toolkit](img/B20908_11_07.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – 查看Rapid XAML 工具包的新警告](img/B20908_11_07.jpg)'
- en: Figure 11.7 – Viewing the new warnings from Rapid XAML Toolkit
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 查看Rapid XAML 工具包的新警告
- en: 'Open **ItemDetailPage.xaml**, place your cursor over one of the green squiggles
    created by the code analyzer, and click the lightbulb icon:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **ItemDetailPage.xaml**，将光标移至由代码分析器创建的绿色波浪线之一，然后点击灯泡图标：
- en: '![Figure 11.8 – View the quick fix for a code analyzer warning](img/B20908_11_08.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – 查看代码分析器警告的快速修复](img/B20908_11_08.jpg)'
- en: Figure 11.8 – View the quick fix for a code analyzer warning
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – 查看代码分析器警告的快速修复
- en: Alternatively, you can right-click on the XAML and select **Rapid XAML** | **Move
    hard-coded string to resource file.** to fix all warnings of this type.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以在 XAML 上右键单击，选择 **Rapid XAML** | **将硬编码字符串移动到资源文件**，以修复此类警告的所有问题。
- en: 'This is a list of other analyzers that are provided by the toolkit:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是工具包提供的其他分析器的列表：
- en: '`Grid.Row` value without a corresponding `RowDefinition`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Grid.Row` 值没有对应的 `RowDefinition`'
- en: '`Grid.Column` value without a corresponding `ColumnDefinition`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Grid.Column` 值没有对应的 `ColumnDefinition`'
- en: '`Grid.RowSpan` value without a corresponding `ColumnDefinition`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Grid.RowSpan` 值没有对应的 `ColumnDefinition`'
- en: '`Grid.ColumnSpan` value without a corresponding `ColumnDefinition`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Grid.ColumnSpan` 值没有对应的 `ColumnDefinition`'
- en: '`TextBox` does not have `InputScope` specified'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextBox` 没有指定 `InputScope`'
- en: '`SelectedItem` binding should probably be `TwoWay`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectedItem` 绑定可能应该是 `TwoWay`'
- en: '**RXT200**: The hardcoded string value that should be a resource'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RXT200**：应该是资源的硬编码字符串值'
- en: '`Entry` does not have a `Keyboard` specified'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Entry` 没有指定 `Keyboard`'
- en: '`MaxLength` specified'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定了 `MaxLength`
- en: '`Image` lacks accessibility consideration'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Image` 缺乏无障碍考虑'
- en: '`ImageButton` lacks accessibility consideration'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageButton` 缺乏无障碍考虑'
- en: '`Checked` and `Unchecked` events for a `CheckBox`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CheckBox` 的 `Checked` 和 `Unchecked` 事件'
- en: '`MediaPlayerElement` in place of `MediaElement`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `MediaPlayerElement` 替代 `MediaElement`
- en: '`x:Uid` should begin with an uppercase character'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x:Uid` 应该以大写字母开头'
- en: '`Name` should begin with an uppercase character'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name` 应该以大写字母开头'
- en: '**RXT999**: Unknown error – something went wrong when parsing the XAML document'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RXT999**：未知错误 – 解析 XAML 文档时出错'
- en: 'Rapid XAML Toolkit has many other features outside of analyzers and code fixes,
    and new features and analyzers are being added frequently. To see a list of upcoming
    features and fixes being considered, you can view the issues on GitHub: [https://github.com/mrlacey/Rapid-XAML-Toolkit/issues](https://github.com/mrlacey/Rapid-XAML-Toolkit/issues).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Rapid XAML Toolkit 除了分析器和代码修复之外还有许多其他功能，并且经常添加新功能和分析器。要查看即将推出功能和修复的列表，您可以查看
    GitHub 上的问题：[https://github.com/mrlacey/Rapid-XAML-Toolkit/issues](https://github.com/mrlacey/Rapid-XAML-Toolkit/issues)。
- en: Note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Community-driven projects like this are always looking for contributors. It’s
    a great way to get started with the open source community.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的社区驱动项目始终在寻找贡献者。这是开始参与开源社区的一个好方法。
- en: Another related topic that can be a common source of developer angst is debugging
    data binding. Let’s see how we can avoid some common pitfalls in the next section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能成为开发者烦恼来源的相关主题是调试数据绑定。让我们看看在下节中如何避免一些常见的陷阱。
- en: Pinpointing data binding failures
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精确定位数据绑定失败
- en: While debugging data binding problems is not as difficult in WinUI and UWP as
    it is in WPF (if you use `x:Bind`-compiled bindings), there are still some *gotchas*
    to avoid. In this section, we will look at what can go wrong in views and ViewModels
    and how you can diagnose and fix the problems.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 WinUI 和 UWP 中调试数据绑定问题不像在 WPF 中（如果你使用 `x:Bind` 编译的绑定）那么困难，但仍有一些需要注意的陷阱。在本节中，我们将探讨在视图和
    ViewModels 中可能发生的问题，以及如何诊断和修复这些问题。
- en: Common mistakes in data binding
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据绑定中的常见错误
- en: If you use `x:Bind`, the compiler will evaluate whether you’re binding to a
    valid source and can give you the peace of mind of knowing that your views and
    ViewModels are hooked up correctly, but there is still a lot that can go wrong.
    Let’s review a few of the most common mistakes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `x:Bind`，编译器将评估你是否绑定到有效的源，并可以让你放心地知道你的视图和 ViewModels 是否正确连接，但仍有许多可能出错的地方。让我们回顾一些最常见错误。
- en: Selecting the best binding mode
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择最佳绑定模式
- en: We have seen in previous chapters that the default mode for most controls with
    `x:Bind` is `OneTime`, while the default for `Binding` is `OneWay`. Defaulting
    to `OneTime` helps with performance as many read-only properties are only ever
    set when the view is first created. However, if you forget to change this for
    controls bound to data that changes as the user is interacting with the page,
    you may not immediately realize why the data in the UI isn’t updating.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中看到，大多数带有 `x:Bind` 的控件默认模式是 `OneTime`，而 `Binding` 的默认模式是 `OneWay`。默认为
    `OneTime` 有助于性能，因为许多只读属性仅在视图首次创建时设置。然而，如果你忘记更改绑定到用户与页面交互时数据会变化的控件，你可能不会立即意识到为什么
    UI 中的数据没有更新。
- en: When you’re binding controls that need data to flow in both directions, remember
    to set `Mode` to `TwoWay`. We used this in the `ComboBox.SelectedItem` property
    to filter the collection by media type.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当你绑定需要数据双向流动的控件时，请记住将 `Mode` 设置为 `TwoWay`。我们曾在 `ComboBox.SelectedItem` 属性中使用它来按媒体类型筛选集合。
- en: Triggering PropertyChanged notifications
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触发 PropertyChanged 通知
- en: 'By binding to a ViewModel that properly implements `INotifyPropertyChanged`
    for all its public properties, issues related to `PropertyChanged` are not common.
    Using MVVM Toolkit makes it even simpler. Problems can still arise if ViewModel
    code outside of one of these properties updates the property’s value by setting
    the `private` backing variable. This will update the property’s value without
    notifying the view. If you are using MVVM Toolkit, it will call out this issue
    when it generates its code in the hidden partial class. You can avoid this by
    always using the `public` property to update the value. If there is a good reason
    for not updating the property directly, then a `PropertyChanged` event should
    be manually triggered for that property after updating the value. It is a best
    practice to use the `nameof` method in C# to ensure you use a property name that
    exists. Misspelled property names will be caught at compile time and highlighted
    in the editor. You can also use `CallerMemberNameAttribute` in .NET: [https://learn.microsoft.com/dotnet/api/system.runtime.compilerservices.callermembernameattribute](https://learn.microsoft.com/dotnet/api/system.runtime.compilerservices.callermembernameattribute).
    An exception will be raised if your application tries to raise a property change
    notification for a property that does not exist.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过绑定到一个正确实现所有公共属性`INotifyPropertyChanged`的ViewModel，与`PropertyChanged`相关的问题并不常见。使用MVVM
    Toolkit可以使这个过程更加简单。如果ViewModel代码更新了这些属性之外的一个属性值，仍然可能会出现问题。这将更新属性值而不通知视图。如果你使用MVVM
    Toolkit，它将在生成隐藏的派生类代码时指出这个问题。你可以通过始终使用`public`属性来更新值来避免这种情况。如果没有直接更新属性的好理由，那么在更新值后应该手动触发该属性的`PropertyChanged`事件。使用C#中的`nameof`方法是最佳实践，以确保你使用存在的属性名称。拼写错误的属性名称将在编译时被捕获并在编辑器中突出显示。你还可以在.NET中使用`CallerMemberNameAttribute`：[https://learn.microsoft.com/dotnet/api/system.runtime.compilerservices.callermembernameattribute](https://learn.microsoft.com/dotnet/api/system.runtime.compilerservices.callermembernameattribute)。如果你的应用程序尝试为一个不存在的属性触发属性更改通知，将引发异常。
- en: Working with ObservableCollection<T>
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`ObservableCollection<T>`
- en: '`ObservableCollection<T>` serves an important role. Lists in the view will
    stay synchronized with the collections if they are used correctly. There are a
    few practices to avoid when using observable collections.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObservableCollection<T>`扮演着重要的角色。如果使用正确，视图中的列表将与集合保持同步。在使用可观察集合时有一些做法需要避免。'
- en: Do not replace the entire value of an observable collection. The element on
    the view bound to the property will still be bound to the original collection.
    Any subsequent changes to the collection will not be reflected in the view. While
    you can work around this by triggering a `PropertyChanged` notification, this
    can have performance implications with larger collections. It can also be jarring
    to the user, as most controls will reset the current view to the beginning of
    the list. Set ViewModel properties that use `ObservableCollection<T>` to be read-only
    to avoid accidentally resetting the entire collection. The one exception to this
    is if you know the collection will be completely repopulated. Removing and re-adding
    a large number of items individually in a list can result in a poor user experience.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不要替换可观察集合的整个值。绑定到属性的视图元素仍然绑定到原始集合。对集合的任何后续更改都不会反映在视图中。虽然你可以通过触发`PropertyChanged`通知来解决这个问题，但这在大集合中可能会有性能影响。这也可能对用户造成冲击，因为大多数控件都会将当前视图重置为列表的开头。将使用`ObservableCollection<T>`的ViewModel属性设置为只读，以避免意外重置整个集合。唯一的例外是如果你知道集合将被完全重新填充。在列表中逐个删除和重新添加大量项目可能会导致用户体验不佳。
- en: Do not use LINQ to modify observable collections. LINQ expressions do not operate
    by calling the `Add` and `Remove` methods on the observable collections. They
    do not even return `ObservableCollection<T>`. If you use LINQ and convert the
    results back to `ObservableCollection<T>`, you will be back to replace the entire
    collection, which was just discussed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用LINQ修改可观察集合。LINQ表达式不是通过在可观察集合上调用`Add`和`Remove`方法来操作的。它们甚至不返回`ObservableCollection<T>`。如果你使用LINQ并将结果转换回`ObservableCollection<T>`，你将回到替换整个集合，这正是刚才讨论过的。
- en: 'Here is an example using LINQ. This will cause the view to stop receiving `CollectionChanged`
    notifications because LINQ does not return an `ObservableCollection`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用LINQ的示例。这将导致视图停止接收`CollectionChanged`通知，因为LINQ不返回`ObservableCollection`：
- en: '[PRE1]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: for (int i = _entryList.Count - 1; i >= 0; i--)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = _entryList.Count - 1; i >= 0; i--)
- en: '{'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Entry entry = _entryList[i];
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Entry entry = _entryList[i];
- en: if (!entry.Lastname.StartsWith("J"))
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 (!entry.Lastname.StartsWith("J"))
- en: '{'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: _entryList.Remove(entry);
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: _entryList.Remove(entry);
- en: '}'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE2]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <StackPanel DataContext="Test" Background="LightGray">
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <StackPanel DataContext="Test" Background="LightGray">
- en: <TextBox x:Name="Text1"
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <TextBox x:Name="Text1"
- en: Text="{Binding Path=SomeText,
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Text="{Binding Path=SomeText,
- en: Mode=TwoWay}"/>
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Mode=TwoWay}"/>
- en: <TextBox Text="{Binding ElementName=Text1,
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <TextBox Text="{Binding ElementName=Text1,
- en: Path=Text, Mode=OneWay}"/>
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Path=Text, Mode=OneWay}"/>
- en: </StackPanel>
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </StackPanel>
- en: '[PRE3]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <StackPanel DataContext="Test"
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <StackPanel DataContext="Test"
- en: Background="LightGray">
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Background="LightGray">
- en: <TextBox x:Name="Text1"
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <TextBox x:Name="Text1"
- en: Text="{Binding Path=SomeText,
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Text="{Binding Path=SomeText,
- en: Mode=TwoWay}"/>
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Mode=TwoWay}"/>
- en: <TextBox Text="{Binding ElementName=Text1,
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <TextBox Text="{Binding ElementName=Text1,
- en: Path=Text, Mode=OneWay}"/>
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Path=Text, Mode=OneWay}"/>
- en: </StackPanel>
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </StackPanel>
- en: '[PRE4]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
