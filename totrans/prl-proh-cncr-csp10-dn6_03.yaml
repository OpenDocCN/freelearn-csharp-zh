- en: '*Chapter 2*: Evolution of Multithreaded Programming in .NET'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：.NET 中多线程编程的演变'
- en: As .NET and C# have evolved over the last 20 years, new and innovative approaches
    to multithreaded programming have been introduced. C# has added new language features
    to support asynchronous programming, and .NET Framework and .NET Core have added
    new types to support the languages. The most impactful improvements were introduced
    with C# 5 and .NET Framework 4.0 when Microsoft added the `async` and `await`
    keywords.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 .NET 和 C# 在过去 20 年中的发展，引入了新的和创新的多线程编程方法。C# 添加了新的语言功能来支持异步编程，而 .NET Framework
    和 .NET Core 添加了新的类型来支持这些语言。最具影响力的改进是在 C# 5 和 .NET Framework 4.0 中引入的，当时微软添加了 `async`
    和 `await` 关键字。
- en: This chapter will introduce concepts and features that will be explored in greater
    depth in subsequent chapters. These concepts include the .NET `async` and `await`,
    concurrent collections, and parallelism. We will start by discovering when and
    why threading features were added to .NET and C#. Then, we will create some practical
    examples of how to use the new concepts. Finally, we will wrap up the chapter
    by discussing when it makes sense to use these new features in your own projects.
    It is important to select the best tool for every real-world scenario.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍将在后续章节中更深入探讨的概念和功能。这些概念包括 .NET 的 `async` 和 `await`、并发集合和并行。我们将从探讨何时以及为什么在
    .NET 和 C# 中添加了线程功能开始。然后，我们将创建一些实际示例来展示如何使用这些新概念。最后，我们将通过讨论在您的项目中何时使用这些新功能是有意义的来结束本章。选择最适合每个实际场景的最佳工具非常重要。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解以下内容：
- en: .NET threading through the years
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 年份的线程
- en: Beyond threading basics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超越线程基础
- en: Introduction to parallelism
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行简介
- en: Introduction to concurrency
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发简介
- en: Basics of `async` and `await`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async` 和 `await` 的基础知识'
- en: Choosing the right path forward
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择正确的道路
- en: By the end of this chapter, you will have learned how your options have expanded
    when selecting how to approach concurrency in your .NET applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解在选择如何处理 .NET 应用程序中的并发时，您的选项是如何扩大的。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples in this chapter, the following software is
    recommended for Windows users:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中的示例，建议 Windows 用户使用以下软件：
- en: Visual Studio 2022 version 17.0 or later.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022 版本 17.0 或更高版本。
- en: .NET 6.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 6.
- en: To use the WorkingWithTimers project, you will need to install the Visual Studio
    workload for **.NET desktop development**.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用 WorkingWithTimers 项目，您需要安装 Visual Studio 的 **.NET 桌面开发**工作负载。
- en: While these are recommended, if you have .NET 6 installed, you can use your
    preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later,
    JetBrains Rider, or Visual Studio Code will work just as well.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些是推荐使用的，但如果您已安装 .NET 6，您可以使用您喜欢的编辑器。例如，macOS 10.13 或更高版本的 Visual Studio 2022
    for Mac、JetBrains Rider 或 Visual Studio Code 都可以正常工作。
- en: All the code examples for this chapter can be found on GitHub at https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter02.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在 GitHub 上找到：https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter02。
- en: Let’s start the chapter with a .NET and C# history lesson.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 .NET 和 C# 的历史课开始本章。
- en: .NET threading through the years
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET 年份的线程
- en: Working with threads in .NET and C# has undergone much evolution since .NET
    Framework 1.0 and C# 1.0 were introduced in 2002\. Most of the concepts discussed
    in [*Chapter 1*](B18552_01_ePub.xhtml#_idTextAnchor014), regarding the `System.Threading.Thread`
    objects have been available since those early days of .NET. While the `Thread`
    object is still available in .NET 6 and can be useful for simple scenarios, there
    are more elegant and modern solutions that are available today.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 2002 年引入 .NET Framework 1.0 和 C# 1.0 以来，在 .NET 和 C# 中处理线程的工作已经经历了许多演变。在[*第一章*](B18552_01_ePub.xhtml#_idTextAnchor014)中讨论的大部分关于
    `System.Threading.Thread` 对象的概念，自那些 .NET 的早期日子起就已经可用。虽然 `Thread` 对象在 .NET 6 中仍然可用，并且对于简单场景可能很有用，但今天有更多优雅和现代的解决方案。
- en: This section will highlight when the most impactful parallelism and concurrency
    features were added. We will begin by skipping ahead 8 years to 2010.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将突出显示最具影响力的并行和并发功能何时被添加。我们将首先跳过 8 年，来到 2010 年。
- en: C# 4 and .NET Framework 4.0
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 4 和 .NET Framework 4.0
- en: 'In 2010, Microsoft released Visual Studio 2010 alongside C# 4 and .NET Framework
    4.0\. While some earlier language and framework features such as **generics**,
    **lambda expressions**, and **anonymous methods** would help facilitate later
    threading features, these 2010 releases were the most significant for threading
    since 2002\. .NET Framework included the following features that will be explored
    in more detail in the subsequent sections and chapters:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年，微软发布了Visual Studio 2010，与C# 4和.NET Framework 4.0一同发布。虽然一些早期的语言和框架特性，如**泛型**、**lambda表达式**和**匿名方法**有助于促进后来的线程功能，但这些2010年的发布自2002年以来对线程功能来说是最重要的。.NET
    Framework包括了以下特性，将在后续章节中更详细地探讨：
- en: '`System.Collections.Concurrent` namespace to provide safe access to collections
    of data in multithreaded code.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Collections.Concurrent` 命名空间提供对多线程代码中数据集合的安全访问。'
- en: '`Parallel.For` and `Parallel.ForEach` and for invoking parallel operations
    with `Parallel.Invoke`.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parallel.For` 和 `Parallel.ForEach` 以及使用 `Parallel.Invoke` 来调用并行操作。'
- en: '`AsParallel`, `WithCancellation`, and `WithDegreeOfParallelism`.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsParallel`, `WithCancellation`, 和 `WithDegreeOfParallelism`。'
- en: We will cover these features in the *Introduction to concurrency* and *Introduction
    to parallelism* sections. Next, we will learn about the important threading features
    that were included in .NET and C# two years later.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在“并发简介”和“并行简介”部分介绍这些特性。接下来，我们将学习两年后包含在.NET和C#中的重要线程功能。
- en: C# 5 and 6 and .NET Framework 4.5.x
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 5 和 6 以及 .NET Framework 4.5.x
- en: 'In 2012, Microsoft released what could be considered the most important feature
    for modern multithreaded programming with .NET: asynchronous programming with
    `async` and `await`. The `async` and `await` keywords were added to C# 5 in the
    same release when .NET Framework 4.5 added the TPL. The centerpiece of the TPL
    was the `Task` class in the new `System.Threading.Tasks` namespace.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 2012年，微软发布了可能是使用.NET进行现代多线程编程最重要的特性：使用`async`和`await`进行异步编程。`async`和`await`关键字在C#
    5中添加，当时.NET Framework 4.5添加了TPL。TPL的核心是位于新`System.Threading.Tasks`命名空间中的`Task`类。
- en: The `Task` object returns from an `async` operation, providing a way for developers
    to check the status of the operation or wait for its completion. The work of an
    `async` task is performed on a background thread on the thread pool, rather than
    in the main thread. We will learn more about thread pools in the *Beyond threading
    basics* section. The basics of the TPL will be discussed in the *Basics of async
    and await* section of this chapter and in more depth in [*Chapter 5*](B18552_05_ePub.xhtml#_idTextAnchor082).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task`对象从异步操作返回，为开发者提供了检查操作状态或等待其完成的方式。异步任务的工作是在线程池的后台线程上执行的，而不是在主线程上。我们将在“线程基础之外”部分了解更多关于线程池的内容。本章的“async和await基础”部分和第5章将更深入地讨论TPL的基本知识。[第5章](B18552_05_ePub.xhtml#_idTextAnchor082)。'
- en: Some tooling and language features related to async programming were added in
    the following years. In 2013, .NET Framework 4.5.1 was released. This release
    corresponded to the release of Visual Studio 2013, which added async debugging
    features to the `catch` and `finally` blocks of exception handlers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几年中，添加了一些与异步编程相关的工具和语言特性。2013年，发布了.NET Framework 4.5.1。这个版本对应于Visual Studio
    2013的发布，它为异常处理程序的`catch`和`finally`块添加了异步调试功能。
- en: The next features came in 2017 with Microsoft’s continued shift from .NET Framework
    to .NET Core.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个特性是在2017年随着微软从.NET Framework持续转向.NET Core而出现的。
- en: C# 7.x and .NET Core 2.0
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 7.x 和 .NET Core 2.0
- en: 'The second major version of .NET Core released by the .NET team included the
    new `ValueTask` and `ValueTask<TResult>` types. A `ValueTask` type is a structure
    that wraps a `Task` or an `IValueTaskSource` instance and includes some additional
    fields. It is only available when using C# 7.0 or later. The `ValueTask` type
    was added because many async operations, in practice, complete synchronously but
    still incur the overhead of allocating a `Task` instance to return to the caller.
    In these cases, performance can be improved by replacing `Task` with `ValueTask`,
    which does not incur any allocation when completing its work synchronously. To
    read more about the motivation behind the introduction of `ValueTask` and when
    to use it, you can read the following blog post by Stephen Toub of the .NET team:
    https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: .NET团队发布的.NET Core的第二大版本包括了新的`ValueTask`和`ValueTask<TResult>`类型。`ValueTask`类型是一个结构，它封装了一个`Task`或一个`IValueTaskSource`实例，并包含了一些额外的字段。它仅在C#
    7.0或更高版本中使用时可用。添加`ValueTask`类型是因为在实践中，许多异步操作是同步完成的，但仍然需要分配一个`Task`实例来返回给调用者。在这些情况下，可以通过用`ValueTask`替换`Task`来提高性能，因为`ValueTask`在同步完成其工作时不会产生任何分配。要了解更多关于引入`ValueTask`背后的动机以及何时使用它，你可以阅读.NET团队Stephen
    Toub的以下博客文章：https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/。
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are not familiar with Stephen Toub, he is a Partner Software Engineer
    for Microsoft and works as a developer on the .NET Team. His work on the .NET
    team was key in bringing `async`, `await`, and the TPL to the .NET developer community.
    You can read some of his other articles on the .NET Parallel Programming blog
    at https://devblogs.microsoft.com/pfxteam/author/toub/.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉Stephen Toub，他是微软的合作伙伴软件工程师，并在.NET团队担任开发者。他在.NET团队的工作对于将`async`、`await`和TPL带给.NET开发者社区至关重要。你可以在.NET并行编程博客上阅读他的其他文章：https://devblogs.microsoft.com/pfxteam/author/toub/。
- en: C# 7.0 also introduced `_`) to replace an intentionally unused variable. A `Task`
    instance returned by an async call. By using a discard in this scenario, it signals
    to the compiler explicitly that you want to ignore the returned `Task` instance.
    Discards can be used as placeholders for variables in other scenarios, too. Using
    discards can make the intent of your code clearer and, in some cases, reduce memory
    allocation. You can read more about their use on the Microsoft Docs website at
    https://docs.microsoft.com/dotnet/csharp/fundamentals/functional/discards.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.0还引入了`_`)来替换一个故意未使用的变量。一个由异步调用返回的`Task`实例。通过在这种情况下使用丢弃，向编译器明确表示你想要忽略返回的`Task`实例。丢弃也可以在其他场景中用作变量的占位符。使用丢弃可以使你的代码意图更清晰，在某些情况下，还可以减少内存分配。你可以在Microsoft
    Docs网站上了解更多关于它们的使用方法：https://docs.microsoft.com/dotnet/csharp/fundamentals/functional/discards。
- en: 'Later in 2017, C# 7.1 was released, adding a feature of note for async programming:
    the ability to declare the `Main` method of a class as async. This made it possible
    to await other async methods directly from the `Main` method.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年后期，发布了C# 7.1版本，为异步编程添加了一个值得注意的功能：可以将类的`Main`方法声明为异步。这使得从`Main`方法中直接等待其他异步方法成为可能。
- en: The next async features of note came along in 2019 with C# 8.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个值得注意的异步功能是在2019年随着C# 8的发布一同出现的。
- en: C# 8 and .NET Core 3.0
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 8和.NET Core 3.0
- en: When C# 8 and .NET Core 3.0 were released in 2019, several languages and .NET
    features were added to support the new `IAsyncEnumerable` type to provide a streaming
    source of asynchronous data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当2019年发布了C# 8和.NET Core 3.0时，添加了几个语言和.NET功能来支持新的`IAsyncEnumerable`类型，以提供异步数据的流式源。
- en: 'Let’s examine a code snippet that uses `IAsyncEnumerable`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一个使用`IAsyncEnumerable`的代码片段：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, the new `await foreach` language feature is used to call an
    async method to get all the orders for a customer. It then uses a `yield return`
    operation to return each `order` object with more than 10 items via the `IAsyncEnumerable`
    type as it is processed. We will cover some more real-world scenarios of using
    `IAsyncEnumerable` in [*Chapter 5*](B18552_05_ePub.xhtml#_idTextAnchor082).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，使用了新的`await foreach`语言特性来调用一个异步方法以获取客户的全部订单。然后，它使用`yield return`操作，通过`IAsyncEnumerable`类型在处理过程中返回每个包含超过10个项目的`order`对象。我们将在[*第五章*](B18552_05_ePub.xhtml#_idTextAnchor082)中介绍更多使用`IAsyncEnumerable`的实际场景。
- en: The other async feature added in C# 8 was the `System.IAsyncDisposable` interface.
    When implementing `IAsyncDisposable`, your class must implement a parameterless
    `DisposeAsync` method. If your class consumes managed resources that implement
    `IAsyncDisposable`, and they cannot be disposed of in line with an `async using`
    block, you should implement `IAsyncDisposable` and clean up these resources in
    a protected `DisposeAsyncCore` method. For a comprehensive example that uses both
    `IDisposable` and `IAsyncDisposable`, you can review the Microsoft Docs example
    at https://docs.microsoft.com/dotnet/standard/garbage-collection/implementing-disposeasync#implement-both-dispose-and-async-dispose-patterns.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8 中添加的另一个异步功能是 `System.IAsyncDisposable` 接口。当实现 `IAsyncDisposable` 时，你的类必须实现一个无参数的
    `DisposeAsync` 方法。如果你的类消耗实现了 `IAsyncDisposable` 的托管资源，并且它们不能与 `async using` 块一起在线释放，你应该实现
    `IAsyncDisposable` 并在受保护的 `DisposeAsyncCore` 方法中清理这些资源。有关同时使用 `IDisposable` 和
    `IAsyncDisposable` 的综合示例，你可以查看 Microsoft Docs 上的示例，链接为 https://docs.microsoft.com/dotnet/standard/garbage-collection/implementing-disposeasync#implement-both-dispose-and-async-dispose-patterns。
- en: This brings us to the most recent releases of C# and .NET. Let’s review what’s
    new for async developers in these 2021 releases.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们来到了 C# 和 .NET 的最新版本。让我们回顾一下在 2021 年的这些版本中，异步开发人员有哪些新功能。
- en: C# 10 and .NET 6
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 10 和 .NET 6
- en: .NET 6 was released in November 2021 along with C# 10\. One of the new features
    in .NET 6 was the ability of `System.Text.Json` to serialize and deserialize an
    `IAsyncEnumerable` type. Prior to .NET 6, a serialized `IAsyncEnumerable` type
    would contain an empty JSON object. This is considered a breaking change in .NET
    6, but it is a change for the better. The primary motivation behind the change
    was to support `IAsyncEnumerable<T>` responses in the ASP.NET Core MVC controller
    methods.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6 与 C# 10 一起在 2021 年 11 月发布。.NET 6 中的新功能之一是 `System.Text.Json` 能够序列化和反序列化
    `IAsyncEnumerable` 类型。在 .NET 6 之前，序列化的 `IAsyncEnumerable` 类型将包含一个空的 JSON 对象。这在
    .NET 6 中被视为一个破坏性变更，但这是一个改进。变更背后的主要动机是支持 ASP.NET Core MVC 控制器方法中的 `IAsyncEnumerable<T>`
    响应。
- en: 'The other .NET 6 feature of note for async developers is that the C# project
    templates in Visual Studio 2021 were modernized to leverage several recent language
    features, including the `async Main` method available in C# 7.1 and later. The
    .NET team blogged about these updated templates when .NET 6 release candidate
    2 was released in October 2021: https://devblogs.microsoft.com/dotnet/announcing-net-6-release-candidate-2/#net-sdk-c-project-templates-modernized.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异步开发人员来说，.NET 6 的另一个值得注意的功能是 Visual Studio 2021 中的 C# 项目模板得到了现代化，以利用包括 C#
    7.1 及以后的 `async Main` 方法在内的几个最近的语言功能。当 .NET 6 发布候选版 2 在 2021 年 10 月发布时，.NET 团队在其博客上发布了关于这些更新模板的信息：https://devblogs.microsoft.com/dotnet/announcing-net-6-release-candidate-2/#net-sdk-c-project-templates-modernized。
- en: This should give you an idea of when each of the significant threading features
    was added to C# and .NET, and it sets the stage for the upcoming sections of this
    chapter, where we will cover some of the basics of parallel programming and concurrency.
    Let’s begin by looking at some more features of threading, starting with the .NET
    thread pool.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该能让你了解每个重要的线程功能是在 C# 和 .NET 中何时添加的，并为本章即将到来的部分设定了舞台，我们将介绍并行编程和并发的一些基础知识。让我们从查看线程的一些更多功能开始，首先是
    .NET 线程池。
- en: Beyond threading basics
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越线程基础
- en: Before we introduce parallel programming, concurrency, and async programming
    with .NET and C#, we have a few more threading concepts to cover. The most important
    of these is the .NET managed thread pool, which is used by awaited method calls
    that execute asynchronously in C#.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍使用 .NET 和 C# 的并行编程、并发和异步编程之前，我们还有一些线程概念需要覆盖。其中最重要的是 .NET 管理线程池，它被用于在 C#
    中异步执行的等待方法调用。
- en: Managed thread pool
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理线程池
- en: The `ThreadPool` class in the `System.Threading` namespace has been part of
    .NET since the beginning. It provides developers with a pool of worker threads
    that they can leverage to perform tasks in the background. In fact, that is one
    of the key characteristics of thread pool threads. They are background threads
    that run at the default priority. When one of these threads completes its task,
    it is returned to the pool of available threads to await its next task. You can
    queue as many tasks to the thread pool as the available memory will support, but
    the number of active threads is limited by the number that the operating system
    can allocate to your application, based on the processor capacity and other running
    processes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Threading`命名空间中的`ThreadPool`类自.NET开始以来就是其中的一部分。它为开发者提供了一个工作线程池，他们可以利用它来在后台执行任务。实际上，这是线程池线程的一个关键特性。它们是运行在默认优先级的后台线程。当这些线程中的任何一个完成任务时，它将被返回到可用的线程池以等待其下一个任务。您可以将尽可能多的任务排队到线程池中，但活动线程的数量受操作系统根据处理器能力和其他运行进程分配给您的应用程序的数量限制。'
- en: 'If you were to use the `ThreadPool` class in a .NET 6 application, you would
    typically do so through the TPL, but let’s explore how it can be used directly
    with `ThreadPool.QueueUserWorkItem`. The following code takes the example scenario
    of [*Chapter 1*](B18552_01_ePub.xhtml#_idTextAnchor014), but uses a `ThreadPool`
    thread to perform the background process:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要在.NET 6应用程序中使用`ThreadPool`类，您通常会通过TPL（Task Parallel Library）来这样做，但让我们探索如何直接使用`ThreadPool.QueueUserWorkItem`。以下代码采用了[*第1章*](B18552_01_ePub.xhtml#_idTextAnchor014)的示例场景，但使用`ThreadPool`线程来执行后台过程：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, the key differences are that there is no need to set `IsBackground` to
    `true`, and you do not call `Start()`. The process will start either as soon as
    the item is queued on `ThreadPool` or when the next `ThreadPool` becomes available.
    While you might not explicitly use `ThreadPool` frequently in your code, it is
    leveraged by many of the common threading features in .NET. So, it’s important
    to have some understanding of how it works.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，关键的区别是无需将`IsBackground`设置为`true`，并且您不需要调用`Start()`。进程将在项目被排队到`ThreadPool`上时或当下一个`ThreadPool`可用时启动。虽然您可能不会经常在代码中显式使用`ThreadPool`，但它被.NET中许多常见的线程功能所利用。因此，了解它是如何工作的是很重要的。
- en: One of the common .NET features that use `ThreadPool` is timers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，使用`ThreadPool`的常见功能之一是计时器。
- en: Threading and timers
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程和计时器
- en: In this section, we will examine two timer classes that use `ThreadPool`, `System.Timers.Timer`
    and `System.Threading.Timer`. Both of these types are safe to use with managed
    threading and are available on every platform supported by .NET 6.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查两个使用`ThreadPool`的计时器类，即`System.Timers.Timer`和`System.Threading.Timer`。这两种类型都适用于托管线程，并且可在.NET
    6支持的每个平台上使用。
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Some additional timers are only applicable to either web or Windows platform
    development. This section will focus on the timers that are platform agnostic.
    To read more about the other timers, you can refer to the documentation on the
    Microsoft Docs website at https://docs.microsoft.com/dotnet/standard/threading/timers.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一些额外的计时器仅适用于Web或Windows平台开发。本节将专注于平台无关的计时器。要了解更多关于其他计时器的信息，您可以参考Microsoft Docs网站上的文档：https://docs.microsoft.com/dotnet/standard/threading/timers。
- en: System.Timers.Timer
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: System.Timers.Timer
- en: You are probably most familiar with the `Timer` object in the `System.Timers`
    namespace. This timer will raise an `Elapsed` event on a thread pool thread at
    the interval specified in the `Interval` property. The mechanism can be stopped
    or started by using the Boolean `Enabled` property. If you need the `Elapsed`
    event to only fire once, the `AutoReset` property can be set to `false`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能最熟悉`System.Timers`命名空间中的`Timer`对象。此计时器将在`Interval`属性指定的间隔内在线程池线程上触发一个`Elapsed`事件。可以通过使用布尔`Enabled`属性来停止或启动该机制。如果您需要`Elapsed`事件仅触发一次，可以将`AutoReset`属性设置为`false`。
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To follow along with the code in this example, download the code from the **WorkingWithTimers**
    project of this chapter’s GitHub repository: https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter02.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本例中的代码，请从本章GitHub仓库的**WorkingWithTimers**项目中下载代码：https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter02。
- en: 'This example uses a `Timer` object to check for new messages and alert a user
    if any are found:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用`Timer`对象来检查新消息，并在找到任何消息时提醒用户：
- en: 'Start by declaring a `Timer` object and setting it up in an `InitializeTimer`
    method:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，声明一个 `Timer` 对象，并在 `InitializeTimer` 方法中设置它：
- en: '[PRE28]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, create the `_timer_Elapsed` event handler to check for messages and update
    the users:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建 `_timer_Elapsed` 事件处理程序以检查消息并更新用户：
- en: '[PRE29]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After the `_timer` object has its `Enabled` property set to `true`, the `Elapsed`
    event will fire every second. In the `StartTimer()` and `StopTimer()` methods
    in the `TimerSample` class:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将 `_timer` 对象的 `Enabled` 属性设置为 `true` 之后，`Elapsed` 事件将每秒触发一次。在 `TimerSample`
    类的 `StartTimer()` 和 `StopTimer()` 方法中：
- en: '[PRE30]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Run the **WorkingWithTimers** project and try using the **Start Timer** and
    **Stop Timer** buttons.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 **WorkingWithTimers** 项目，并尝试使用 **启动定时器** 和 **停止定时器** 按钮。
- en: You should see messages in Visual Studio’s debug **Output** window appearing
    every second while the timer is enabled.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当定时器启用时，您应该在 Visual Studio 的调试 **输出** 窗口中每秒看到消息。
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that timer events are firing on a thread pool thread. The code executing
    in these methods might not have access to update the UI. These timer examples
    are part of a `InvokeRequired` on the form or user control and then updating the
    UI with the `Invoke` method, if necessary. More information about how to update
    a WinForms UI can be found on the Microsoft Docs website at https://docs.microsoft.com/dotnet/desktop/winforms/controls/how-to-make-thread-safe-calls.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，定时器事件是在线程池线程上触发的。在这些方法中执行的代码可能无法更新 UI。这些定时器示例是 `InvokeRequired` 在表单或用户控件上的一部分，如果需要，然后使用
    `Invoke` 方法更新 UI。有关如何更新 WinForms UI 的更多信息，可以在 Microsoft Docs 网站上找到，网址为 https://docs.microsoft.com/dotnet/desktop/winforms/controls/how-to-make-thread-safe-calls。
- en: In your own applications, you would use the `AlertUser` method to present an
    alert message to the user or update a notification icon in the UI. Next, let’s
    try the `System.Threading.Timer` class.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在您自己的应用程序中，您将使用 `AlertUser` 方法向用户显示警报消息或在 UI 中更新通知图标。接下来，让我们尝试使用 `System.Threading.Timer`
    类。
- en: System.Threading.Timer
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: System.Threading.Timer
- en: 'Now, we will create the same example with the `System.Threading.Timer` class.
    This `Timer` class must be initialized a little differently:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 `System.Threading.Timer` 类创建相同的示例。这个 `Timer` 类的初始化方式略有不同：
- en: Note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To follow along with the code in this example, download the code from the **WorkingWithTimers**
    project of this chapter’s GitHub repository: https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter02.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本例中的代码，请从本章 GitHub 存储库的 **WorkingWithTimers** 项目中下载代码：https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter02。
- en: 'Start by creating a new `InitializeTimer` method:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的 `InitializeTimer` 方法：
- en: '[PRE31]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The constructor for the `Timer` class takes four parameters. The `callback`
    parameter is a delegate to invoke on the thread pool when the timer period elapses.
    The `state` parameter is an object to pass to the callback delegate. The `dueTime`
    parameter tells the timer how long (in milliseconds) to wait before triggering
    the timer for the first time. Finally, the `period` parameter specifies the interval
    (in milliseconds) between each delegate invocation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timer` 类的构造函数接受四个参数。`callback` 参数是在定时器周期结束时在线程池上调用的委托。`state` 参数是要传递给回调委托的对象。`dueTime`
    参数告诉定时器在第一次触发定时器之前要等待多长时间（以毫秒为单位）。最后，`period` 参数指定每个委托调用之间的间隔（以毫秒为单位）。'
- en: 'After instantiating the timer, it will immediately start. There is no `Enabled`
    property to start or stop this timer. When you are done with it, you should dispose
    of it with either the `Dispose` method or the `DisposeAsync` method. This is happening
    in our `DisposeTimerAsync` method:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化定时器后，它将立即开始。没有 `Enabled` 属性来启动或停止这个定时器。当您完成使用后，您应该使用 `Dispose` 方法或 `DisposeAsync`
    方法来释放它。这发生在我们的 `DisposeTimerAsync` 方法中：
- en: '[PRE32]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`MessageUpdater` is a class that is used as the `state` object provided to
    the `TimerCallback` method. It has a single method that handles updates to the
    message count. The logic to update the user about new messages can be encapsulated
    by this class. In our case, it will simply update the debug output with the number
    of new messages:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MessageUpdater` 是一个用作 `TimerCallback` 方法提供的 `state` 对象的类。它有一个处理消息计数更新的单方法。通过这个类可以封装更新用户关于新消息的逻辑。在我们的例子中，它将简单地更新调试输出中的新消息数量：'
- en: '[PRE33]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The final piece to examine is the `TimerFired` callback method:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要检查的最后一部分是 `TimerFired` 回调方法：
- en: '[PRE34]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Similar to the `_timer_Elapsed` method from the previous example, this method
    simply checks for new messages and triggers an update. However, this time, the
    update is performed by the `MessageUpdater` class, which, in your application,
    could be abstracted through an `IMessageUpdater` interface and injected into this
    class for improved separation of concerns and testability.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Try this example by using the **Start Threading Timer** and **Stop Threading
    Timer** buttons in the application. You should see a debug message appearing with
    new message counts in the **Output** window, as you did in the previous example.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The two timers serve similar purposes; however, most of the time, you will want
    to use `System.Threading.Timer` to leverage its async nature. However, if you
    need to frequently stop and start your timer processes, the `System.Timers.Timer`
    class is a better choice.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered some additional managed threading concepts to level-set
    your knowledge, it’s time to shift gears and introduce the concept of parallel
    programming with C#.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to parallelism
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While exploring the history of threading in C# and .NET, we learned that parallelism
    was introduced to developers in .NET Framework 4.0\. In this section, the aspects
    that will be explored are exposed in the TPL through the `System.Threading.Tasks.Parallel`
    class. In addition, we will cover some of the basics of PLINQ through examples.
    These data parallelism concepts will be covered in greater detail with real-world
    examples in [*Chapter 6*](B18552_06_ePub.xhtml#_idTextAnchor098), [*Chapter 7*](B18552_07_ePub.xhtml#_idTextAnchor120),
    and [*Chapter 8*](B18552_08_ePub.xhtml#_idTextAnchor130).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, parallelism is the concept of executing multiple tasks in parallel.
    These tasks could be related to one another, but this is not a requirement. In
    fact, related tasks running in parallel run a greater risk of encountering synchronization
    issues or blocking one another. For example, if your application loads order data
    from an orders service and user preferences and application state from an **Azure
    blob store**, these two processes can be run in parallel without having to worry
    about conflicts or data synchronization. On the other hand, if the application
    is loading order data from two different order services and combining the results
    in a single collection, you will need a synchronization strategy.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: That type of scenario will be discussed, in greater depth, in [*Chapter 9*](B18552_09_ePub.xhtml#_idTextAnchor146).
    In this section, we will prepare for those advanced scenarios by learning some
    uses of the `Parallel` class. Let’s start with `Parallel.Invoke`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Using Parallel.Invoke
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Parallel.Invoke` is a method that can execute multiple actions, and they could
    be executed in parallel. There is no guarantee of the order in which they will
    execute. Each action will be queued in the thread pool. The `Invoke` call will
    return when all the actions have been completed.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the `Parallel.Invoke` call will execute four actions: another
    method in the `ParallelInvokeExample` class named `DoComplexWork`, a lambda expression,
    an `Action` declared inline, and a `delegate`. Here is the complete `ParallelInvokeExample`
    class:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Parallel.Invoke`调用将执行四个操作：`ParallelInvokeExample`类中的另一个方法`DoComplexWork`、一个lambda表达式、一个内联声明的`Action`和一个委托。以下是完整的`ParallelInvokeExample`类：
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Creating a new instance of `ParallelInvokeExample` and executing `DoWorkInParallel`
    from a console application will produce an output similar to the following, although
    the order of operations may vary:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`ParallelInvokeExample`的新实例并从控制台应用程序执行`DoWorkInParallel`将产生类似于以下内容的输出，尽管操作顺序可能不同：
- en: '![Figure 2.1 – Output produced by the DoWorkInParallel method ](img/Figure_2.1_B18552.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – DoWorkInParallel方法产生的输出](img/Figure_2.1_B18552.jpg)'
- en: Figure 2.1 – Output produced by the DoWorkInParallel method
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – DoWorkInParallel方法产生的输出
- en: In the next section, we will learn how to implement a `Parallel.ForEach` loop
    and discuss when you might want to leverage it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何实现`Parallel.ForEach`循环，并讨论你可能想要利用它的情况。
- en: Using Parallel.ForEach
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Parallel.ForEach
- en: '`Parallel.ForEach` is probably the most used member of the `Parallel` class
    in .NET. This is because, in many cases, you can simply take the body of a standard
    `foreach` loop and use it inside a `Parallel.ForEach` loop. However, when introducing
    any parallelism into a code base, you must be sure that the code being invoked
    is thread-safe. If the body of a `Parallel.ForEach` loop modifies any of the collections,
    you will either need to employ one of the synchronization methods discussed in
    [*Chapter 1*](B18552_01_ePub.xhtml#_idTextAnchor014), or use one of .NET’s concurrent
    collections. We will introduce concurrent collections in the *Introduction to
    concurrency* section.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.ForEach` 可能是.NET中`Parallel`类中使用最频繁的成员。这是因为，在许多情况下，你可以直接将标准`foreach`循环的主体用于`Parallel.ForEach`循环中。然而，在将任何并行性引入代码库时，你必须确保被调用的代码是线程安全的。如果`Parallel.ForEach`循环的主体修改了任何集合，你可能需要采用[*第1章*](B18552_01_ePub.xhtml#_idTextAnchor014)中讨论的同步方法之一，或者使用.NET的并发集合之一。我们将在*并发介绍*部分介绍并发集合。'
- en: 'As an example of using `Parallel.ForEach`, we will create a method that accepts
    a list of numbers and checks whether each number is contained in a string representation
    of the current time:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用`Parallel.ForEach`的示例，我们将创建一个接受数字列表的方法，并检查每个数字是否包含在当前时间的字符串表示中：
- en: '[PRE67]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Here is the call to `ExecuteParallelForEach` from the console application’s
    `Main` method:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是从控制台应用程序的`Main`方法调用`ExecuteParallelForEach`的代码：
- en: '[PRE87]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Execute the program, and examine the console output. You should see that more
    than one thread was used to process the loop:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 执行程序，并检查控制台输出。你应该能看到使用了多个线程来处理循环：
- en: '![Figure 2.2 – Console output from a Parallel.ForEach loop ](img/Figure_2.2_B18552.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – Parallel.ForEach循环的控制台输出](img/Figure_2.2_B18552.jpg)'
- en: Figure 2.2 – Console output from a Parallel.ForEach loop
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – Parallel.ForEach循环的控制台输出
- en: Next, we will wrap up this section on parallelism in .NET with an introduction
    to PLINQ.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过介绍PLINQ来总结.NET中的并行性这一章节。
- en: Basics of Parallel LINQ
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Parallel LINQ 基础
- en: 'This section will look at one of the simplest ways to add some parallelism
    to your code. By adding the `AsParallel` method to your LINQ query, you can transform
    it into a PLINQ query, with the operations after `AsParallel` being executed on
    the thread pool when necessary. There are many factors to consider when deciding
    when to use PLINQ. We will discuss those in some depth in [*Chapter 8*](B18552_08_ePub.xhtml#_idTextAnchor130).
    For this example, we will introduce `Where` clause that checks whether each given
    integer is an even number. To help illustrate how PLINQ can impact sequences,
    `Task.Delay` is also introduced. Here is the complete `ParallelLinqExample` class
    implementation:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将探讨向你的代码中添加一些并行性的最简单方法之一。通过将`AsParallel`方法添加到你的LINQ查询中，你可以将其转换为PLINQ查询，`AsParallel`之后的操作在必要时将在线程池上执行。在决定何时使用PLINQ时需要考虑许多因素。我们将在[*第8章*](B18552_08_ePub.xhtml#_idTextAnchor130)中深入讨论这些因素。对于这个示例，我们将介绍检查每个给定整数是否为偶数的`Where`子句。为了帮助说明PLINQ如何影响序列，还引入了`Task.Delay`。以下是完整的`ParallelLinqExample`类实现：
- en: '[PRE90]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'In the `Main` method of your console application, add some code to pass a list
    of integers to both the `ExecuteLinqQuery` and `ExecuteParallelLinqQuery` methods:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的控制台应用程序的`Main`方法中，添加一些代码将整数列表传递给`ExecuteLinqQuery`和`ExecuteParallelLinqQuery`方法：
- en: '[PRE113]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Examine the output, and you should see that the order of the numbers in the
    PLINQ sequence has changed:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 检查输出，你应该会看到 PLINQ 序列中数字的顺序已改变：
- en: '![Figure 2.3 – Console output of the LINQ and PLINQ queries ](img/Figure_2.3_B18552.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – LINQ 和 PLINQ 查询的控制台输出](img/Figure_2.3_B18552.jpg)'
- en: Figure 2.3 – Console output of the LINQ and PLINQ queries
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – LINQ 和 PLINQ 查询的控制台输出
- en: We will explore more aspects of parallelism over several chapters in *Part 2*,
    *Parallel Programming and Concurrency with C#,* of this book. Let’s shift gears
    and learn about some concurrency patterns in C#.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的 *第 2 部分*，*使用 C# 进行并行编程和并发* 中，通过几章来探讨并行性的更多方面。让我们转换一下，学习一些 C# 中的并发模式。
- en: Introduction to concurrency
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发简介
- en: So, what is concurrency and how does it relate to parallelism in the context
    of C# and .NET? The terms are frequently used interchangeably, and if you think
    about it, they do have similar meanings. When multiple threads are executing in
    parallel, they are running concurrently. In this book, we will use the term concurrency
    when discussing patterns to follow when designing for managed threading. Additionally,
    we will discuss concurrency in the context of the concurrent collections that
    were introduced to .NET developers in .NET Framework 4.0\. Let’s start by learning
    about the concurrent collections in the `System.Collections.Concurrent` namespace.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是并发，它与 C# 和 .NET 中的并行性有何关系？这两个术语经常被互换使用，如果你仔细想想，它们确实有相似的含义。当多个线程并行执行时，它们是并发执行的。在这本书中，当我们讨论设计托管线程时应遵循的模式时，我们将使用并发这个术语。此外，我们还将讨论并发集合，这些集合是在
    .NET Framework 4.0 中介绍给 .NET 开发者的。让我们先了解 `System.Collections.Concurrent` 命名空间中的并发集合。
- en: .NET has several collections that have been created with thread safety built-in.
    These collections can all be found in the `System.Collections.Concurrent` namespace.
    In this section, we will introduce five of the collections. The remaining three
    are variations of `Partitioner`. These will be explored in [*Chapter 9*](B18552_09_ePub.xhtml#_idTextAnchor146),
    where we will work with each of the collection types through practical examples.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 有几个集合是内置线程安全的。这些集合都可以在 `System.Collections.Concurrent` 命名空间中找到。在本节中，我们将介绍五个集合。其余三个是
    `Partitioner` 的变体。这些将在 [*第 9 章*](B18552_09_ePub.xhtml#_idTextAnchor146) 中探讨，我们将通过实际示例与每种集合类型一起工作。
- en: Note
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'While your code does not require the use of locks when using concurrent collections,
    different techniques for synchronization are being employed inside these collections.
    Some of them do use locking, while others have retry mechanisms to deal with contention.
    To read more about how concurrent collections handle contention, check out this
    Microsoft blog post on the .NET Parallel Programming blog: https://devblogs.microsoft.com/pfxteam/faq-are-all-of-the-new-concurrent-collections-lock-free/.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在使用并发集合时，你的代码不需要使用锁，但这些集合内部正在使用不同的同步技术。其中一些使用锁，而另一些则具有重试机制来处理竞争。要了解更多关于并发集合如何处理竞争的信息，请查看
    Microsoft 在 .NET 并行编程博客上的这篇博客文章：https://devblogs.microsoft.com/pfxteam/faq-are-all-of-the-new-concurrent-collections-lock-free/.
- en: The first collection we will introduce is `ConcurrentBag<T>`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的第一个集合是 `ConcurrentBag<T>`。
- en: ConcurrentBag<T>
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ConcurrentBag<T>
- en: The `ConcurrentBag<T>` collection is a concurrent collection intended to hold
    a collection of unordered objects. Duplicate values are allowed, as are null values
    when `T` is a nullable type. It makes an excellent thread-safe replacement for
    an array, `List<T>`, or other `IEnumerable<T>` instances where the ordering of
    items is not a requirement.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentBag<T>` 集合是一个并发集合，旨在存储一组无序对象。允许重复值，当 `T` 是可空类型时，也允许 `null` 值。它是一个出色的线程安全替代品，用于数组、`List<T>`
    或其他不需要项目排序的 `IEnumerable<T>` 实例。'
- en: Internally, `ConcurrentBag<T>` stores a linked list of items for each thread
    adding items. As items are taken or peeked at from the collection, priority will
    be given to the internal list, which had items added by the current thread. Let’s
    suppose thread 1 adds items A, B, and C and thread 2 adds items D, E, F, and G.
    If thread 1 calls `TryPeek` or `TryTake` four times, `ConcurrentBag<T>` will get
    items from the A, B, and C list first before taking items from the linked list
    containing items from thread 2.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`ConcurrentBag<T>` 为每个添加项目的线程存储一个项目链表。当从集合中取出或查看项目时，将优先考虑由当前线程添加项目的内部列表。假设线程
    1 添加了项目 A、B 和 C，线程 2 添加了项目 D、E、F 和 G。如果线程 1 调用 `TryPeek` 或 `TryTake` 四次，`ConcurrentBag<T>`
    将首先从 A、B 和 C 列表中获取项目，然后再从包含线程 2 项目链表中获取项目。
- en: 'The following list details the properties and methods of `ConcurrentBag<T>`
    that you are likely to use in most implementations:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表详细说明了您在大多数实现中可能会使用的 `ConcurrentBag<T>` 的属性和方法：
- en: '`Add(T)`: This adds an object to the bag.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add(T)`: 这会将一个对象添加到集合中。'
- en: '`TryPeek(out T)`: This tries to fetch a value from the bag with an `out` parameter
    but does not remove that item.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TryPeek(out T)`: 这尝试从集合中获取一个值，并通过 `out` 参数返回，但不移除该项。'
- en: '`TryTake(out T)`: This attempts to fetch a value from the bag with an `out`
    parameter and removes it.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TryTake(out T)`: 这尝试通过 `out` 参数从集合中获取一个值并移除它。'
- en: '`Clear()`: This clears all of the objects from the bag.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear()`: 这清除集合中的所有对象。'
- en: '`Count`: This returns the number of objects in the bag.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Count`: 这返回集合中的对象数量。'
- en: '`IsEmpty`: This returns a `bool` value indicating whether the bag is empty.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsEmpty`: 这返回一个 `bool` 值，指示集合是否为空。'
- en: '`ToArray()`: This returns an array of objects of type `T`.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToArray()`: 这返回类型为 `T` 的对象数组。'
- en: The `ConcurrentBag<T>` collection has two constructors. One constructor takes
    no parameters and simply creates a new empty bag. The other accepts an `IEnumerable<T>`
    type of object to be copied to the new bag.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentBag<T>` 集合有两个构造函数。一个构造函数不接受任何参数，只是简单地创建一个新的空集合。另一个接受一个要复制到新集合中的
    `IEnumerable<T>` 类型的对象。'
- en: Next, let’s take a quick look at the `ConcurrentQueue<T>` collection.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们快速看一下 `ConcurrentQueue<T>` 集合。
- en: ConcurrentQueue<T>
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ConcurrentQueue<T>
- en: The .NET `ConcurrentQueue<T>` collection is similar in implementation to its
    thread-unsafe counterpart, `Queue<T>`. As such, it makes a great replacement for
    `Queue<T>` when managed threading is introduced to an existing code base. `ConcurrentQueue<T>`
    is a strongly typed list of objects that enforces **first in, first out** (**FIFO**)
    logic, which is the definition of a **queue**.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 的 `ConcurrentQueue<T>` 集合在实现上与它的线程不安全版本 `Queue<T>` 类似。因此，当将线程管理引入现有代码库时，它是一个很好的
    `Queue<T>` 替代品。`ConcurrentQueue<T>` 是一个强类型对象列表，它强制执行 **先进先出**（**FIFO**）逻辑，这是 **队列**
    的定义。
- en: Note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**FIFO** logic is commonly seen in the manufacturing industry and in warehouse
    management software. When working with perishable goods, it is important to use
    your oldest raw materials first. Therefore, those pallets of goods that were the
    first to be put into the warehouse should be the first to be pulled when a pallet
    of that type is requested by the system.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**FIFO** 逻辑在制造业和仓库管理软件中很常见。当处理易腐货物时，首先使用最老的原料是很重要的。因此，那些首先被放入仓库的货物托盘，在系统请求该类型的托盘时，应该首先被提取。'
- en: 'These are the commonly used members of the `ConcurrentQueue<T>` type:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 `ConcurrentQueue<T>` 类型常用的成员：
- en: '`Enqueue(T)`: This adds a new object to the queue.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enqueue(T)`: 这将一个新的对象添加到队列中。'
- en: '`TryPeek(out T)`: This attempts to get the object at the front of the queue
    without removing it.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TryPeek(out T)`: 这尝试获取队列前面的对象而不移除它。'
- en: '`TryDequeue(out T)`: This tries to get the object at the front of the queue
    and removes it.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TryDequeue(out T)`: 这尝试获取队列前面的对象并移除它。'
- en: '`Clear()`: This clears the queue.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear()`: 这清除队列。'
- en: '`Count`: This returns the number of objects in the queue.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Count`: 这返回队列中的对象数量。'
- en: '`IsEmpty`: This returns a `bool` value indicating whether the queue is empty.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsEmpty`: 这返回一个 `bool` 值，指示队列是否为空。'
- en: '`ToArray()`: This returns the objects in the queue as an array of type `T`.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToArray()`: 这将队列中的对象作为类型为 `T` 的数组返回。'
- en: 'Similar to the `ConcurrentBag<T>` collection, the `ConcurrentQueue<T>` collection
    has two constructors: one parameterless and one that takes an `Ienumerable<T>`
    type to populate the new queue. Next, let’s introduce a similar collection: `ConcurrentStack<T>`.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: ConcurrentStack<T>
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ConcurrentStack<T>` can be thought of as `ConcurrentQueue<T>`, but it uses
    `Push` method instead of `Enqueue`, and removing items uses a `TryPop` method
    instead of `TryDequeue`. Another advantage of the `ConcurrentStack<T>` collection
    is that it can add or remove multiple objects in one operation. These range operations
    are supported by using the `PushRange` and `TryPopRange` methods. The range operations
    take arrays of `T` as parameters.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: C`oncurrentStack<T>` and `ConcurrentQueue<T>` in .NET 6 both implement the `IReadOnlyCollection<T>`
    interface. This means that once the collection has been created, it is read-only
    and cannot be reassigned or set to `null`. You can only add or remove items or
    use `Clear()` to empty the collection.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to one of the most powerful concurrent collections, `BlockingCollection<T>`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: BlockingCollection<T>
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`BlockingCollection<T>` is a thread-safe collection of objects that implements
    several interfaces, including `IProducerConsumerCollection<T>`. The `IProducerConsumerCollection<T>`
    interface provides a set of members intended to support applications that need
    to implement the **producer/consumer pattern**.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The producer/consumer pattern is a concurrency design pattern where a set of
    data is concurrently fed by one or more producer threads. At the same time, there
    are one or more consumer threads monitoring and fetching the data being produced
    to consume and process it concurrently. The `BlockingCollection<T>` collection
    is the data store in this producer/consumer pattern. You can read more about producer/consumer
    on Wikipedia at https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '`BlockingCollection<T>` has several methods and properties that assist in a
    producer/consumer workflow. You can indicate that the producer process is done
    adding items to the collection by calling the `CompleteAdding` method. Once this
    method is called, no more items can be added to the collection with the `Add`
    or `TryAdd` methods. If you plan to use `CompleteAdding` in your workflow, it
    is best to always use `TryAdd` and check the Boolean result when adding objects
    to the collection. If the collection has been marked as complete for adding, calling
    `Add` will throw `InvalidOperationException`. Additionally, you can check the
    `IsAddingCompleted` property to find out whether `CompleteAdding` has already
    been called.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Items are removed from `BlockingCollection<T>` by a consumer process with the
    `Take` or `TryTake` methods. Again, it is safer to use `TryTake` to avoid any
    exceptions when the collection is empty. If `CompleteAdding` has been called and
    all objects have been removed from the collection, the `IsCompleted` property
    will return true.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: We will walk through a real-world producer/consumer implementation in [*Chapter
    9*](B18552_09_ePub.xhtml#_idTextAnchor146) *.NET*. Now, let’s move on to our final
    concurrent collection in this section, `ConcurrentDictionary<T>`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨一个真实的生产者/消费者实现，位于[*第 9 章*](B18552_09_ePub.xhtml#_idTextAnchor146) *.NET*。现在，让我们继续本节最后一个并发集合，`ConcurrentDictionary<T>`。
- en: ConcurrentDictionary<TKey, TValue>
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ConcurrentDictionary<TKey, TValue>
- en: 'As you have probably guessed, `ConcurrentDictionary<TKey,` `TValue>` is a great
    replacement for `Dictionary<TKey, TValue>` when working with managed threading.
    Both collections implement the `IDictionary<TKey, TValue>` interface. The concurrent
    version of this collection adds the following methods for working with data concurrently:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，`ConcurrentDictionary<TKey, TValue>` 是在处理托管线程时 `Dictionary<TKey, TValue>`
    的优秀替代品。这两个集合都实现了 `IDictionary<TKey, TValue>` 接口。此集合的并发版本增加了以下用于并发处理数据的方法：
- en: '`TryAdd`: This tries to add a new key/value pair to the dictionary and returns
    a Boolean value indicating whether the object was successfully added to the dictionary.
    If the key already exists, the method will return `false`.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TryAdd`: 尝试将新的键/值对添加到字典中，并返回一个布尔值，指示对象是否成功添加到字典中。如果键已存在，则方法将返回 `false`。'
- en: '`TryUpdate`: This operation passes a key along with the existing and new values
    for the item. It will update the existing item to the new value if it exists in
    the dictionary with the existing value provided. The Boolean value that is returned
    indicates whether the object was successfully updated in the dictionary.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TryUpdate`: 此操作传递一个键以及项的现有值和新值。如果它存在于字典中且提供了现有值，则将现有项更新为新值。返回的布尔值指示对象是否在字典中成功更新。'
- en: '`AddOrUpdate`: This method will add or update an item in the dictionary based
    on whether the key exists and uses an update delegate to perform any logic based
    on the current and new values for the item.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddOrUpdate`: 此方法将根据键是否存在，在字典中添加或更新项，并使用更新委托来执行基于当前值和新值的任何逻辑。'
- en: '`GetOrAdd`: This method will add an item if the key does not already exist.
    If it does exist, the existing value is returned.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetOrAdd`: 如果键不存在，此方法将添加项。如果它已存在，则返回现有值。'
- en: These are the most important and common concurrent collections in .NET to understand.
    We will cover some examples of each and learn about more of the collections in
    `System.Collections.Concurrent` later, but this section should provide a solid
    base for understanding what is to come.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 .NET 中最重要的和常见的并发集合，需要理解。我们将涵盖每个集合的一些示例，并在稍后学习 `System.Collections.Concurrent`
    中的更多集合，但本节应该为理解接下来要学习的内容提供一个坚实的基础。
- en: In the next section, we will introduce the C# `async` and `await` keywords that
    were added to C# 5.0.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍添加到 C# 5.0 的 C# `async` 和 `await` 关键字。
- en: Basics of async and await
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: async 和 await 的基础知识
- en: When the TPL was introduced in .NET Framework 4.5, C# 5.0 also added language
    support for task-based asynchronous programming with the `async` and `await` keywords.
    This immediately became the default method of implementing asynchronous workflows
    in C# and .NET. Now, 10 years later, `async`/`await` and the TPL have become an
    integral part of building robust, scalable .NET applications. You might be wondering
    why it is so important to adopt async programming in your applications.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当 TPL 在 .NET Framework 4.5 中引入时，C# 5.0 也添加了对基于任务的异步编程的语言支持，使用了 `async` 和 `await`
    关键字。这立即成为在 C# 和 .NET 中实现异步工作流的首选方法。现在，10 年过去了，`async`/`await` 和 TPL 已经成为构建健壮、可扩展
    .NET 应用程序不可或缺的一部分。你可能想知道为什么在应用程序中采用异步编程如此重要。
- en: Understanding the async keyword
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 async 关键字
- en: There are many reasons for writing async code. If you’re writing server-side
    code on a web server, using async allows the server to handle additional requests
    while your code is awaiting a long-running operation. On a client application,
    freeing the UI thread to perform other operations with async code allows your
    UI to remain responsive to users.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 编写异步代码有许多原因。如果你在 Web 服务器上编写服务器端代码，使用异步可以让服务器在代码等待长时间运行的操作时处理额外的请求。在客户端应用程序中，使用异步代码释放
    UI 线程执行其他操作，可以让你的 UI 对用户保持响应。
- en: 'Another important reason to adopt async programming in .NET is that many third-party
    and open source libraries are using `async`/`await`. Even .NET itself is exposing
    more APIs as async in every release, especially those involving IO operations:
    networking, file, and database access.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try writing your first async method with C#.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Writing an async method
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating and consuming an async method is easy. Let’s try a simple example
    with a new console application:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Create a new console application in Visual Studio and name it **AsyncConsoleExample**.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a class to the project, named `NetworkHelper`, and add the following methods
    to the class:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: There are a few things to point out in the preceding code. Both methods have
    an `async` modifier, indicating that they will be awaiting some work and will
    run asynchronously. Inside the methods, we are using the `await` keyword with
    the calls to `Task.Delay`. This will ensure that no code after this point will
    execute until the awaited method has been completed. However, during this time,
    the active thread can be released to perform other work elsewhere.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Finally, look at the call to `NetworkCheckInternalAsync`. Instead of awaiting
    this call, we are capturing the returned `Task` instance in a variable named `t`,
    and we don’t `await` it until after the `for` loop. This means that the `for`
    loops in both methods will run concurrently. If we had, instead, awaited `NetworkCheckInternalAsync`,
    its `for` loop would have been completed before the `for` loop in `CheckNetworkStatusAsync`
    could begin.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, replace the code in `Program.cs` with the following:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: We are awaiting the call to `CheckNetworkStatusAsync`. This is possible because
    the default `Main` method in a .NET 6 console application is `async` by default.
    If you try to `await` something in a method that is not marked as `async`, you
    will get a compiler error. We will explore some of the options you can use when
    you must call async methods from existing non-async code in [*Chapter 5*](B18552_05_ePub.xhtml#_idTextAnchor082).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, run the application and examine the output:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Console output for the async sample application ](img/Figure_2.4_B18552.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Console output for the async sample application
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: As expected, capturing the async method’s result allowed the two loops to run
    concurrently. Try awaiting the call to `NetworkCheckInternalAsync` and see how
    the output changes. You should see that all the output from the private method
    will appear before the output from the `for` loop in `CheckNetworkStatusAsync`
    begins.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: This was a brief introduction to the world of async programming with C#. We’ll
    be working with it quite a lot throughout the rest of this book. Let’s wrap things
    up by discussing how to choose which of these options to leverage when building
    a new project or enhancing an existing application.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right path forward
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have been introduced to some advanced managed threading concepts,
    parallel programming, concurrent collections, and the async/await paradigm, let’s
    discuss how they all fit together in the real world. Choosing the right path forward
    with multithreaded development in .NET will usually involve more than one of these
    concepts.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经接触了一些高级托管线程概念，并行编程、并发集合以及 async/await 模式，让我们讨论它们如何在现实世界中相互结合。在 .NET 中进行多线程开发时，选择正确的路径通常涉及多个这些概念。
- en: When working with .NET 6, you should usually choose to create `async` methods
    in your projects. The reasons discussed in this chapter are compelling. Asynchronous
    programming keeps both client and server applications responsive, and `async`
    is used extensively throughout .NET itself.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 .NET 6 时，你应该通常选择在项目中创建 `async` 方法。本章中讨论的原因很有说服力。异步编程保持了客户端和服务器应用程序的响应性，`async`
    在 .NET 本身中被广泛使用。
- en: Some of the `Parallel` class operations can be leveraged when your code needs
    to process a set of items quickly and the underlying code doing the processing
    is thread-safe. This is one place where concurrent collections can be introduced.
    If any parallel or async operations are manipulating shared data, the data should
    be stored in one of the .NET concurrent collections.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码需要快速处理一组项目并且底层执行处理的代码是线程安全的时候，可以利用一些 `Parallel` 类操作。这是可以引入并发集合的一个地方。如果任何并行或异步操作正在操作共享数据，数据应该存储在
    .NET 并发集合之一中。
- en: If you are working with existing code, often, the most prudent path is to limit
    how much multithreaded code is added. Legacy projects such as these are a great
    place to incrementally add some `ThreadPool` or `Parallel` operations and test
    the results. It is important to test the application functionally and for performance.
    Performance testing tools for managed threading will be covered in [*Chapter 10*](B18552_10_ePub.xhtml#_idTextAnchor158).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理现有的代码，通常最谨慎的做法是限制添加的多线程代码量。像这样的遗留项目是逐步添加一些 `ThreadPool` 或 `Parallel`
    操作并测试结果的好地方。对应用程序的功能和性能进行测试非常重要。关于托管线程的性能测试工具将在 [*第 10 章*](B18552_10_ePub.xhtml#_idTextAnchor158)
    中介绍。
- en: This preliminary guidance will help you get an idea of where you can boost your
    applications’ performance with managed threading. We will build on your learning
    and this guidance throughout the rest of the book. Let’s wrap up and discuss what
    you have learned in this chapter.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这份初步指南将帮助你了解如何通过托管线程提高应用程序的性能。我们将在本书的其余部分继续构建你的学习和这些指南。让我们总结一下，并讨论本章你学到了什么。
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we started by looking at a brief history of C#, .NET, and managed
    threading. We discussed how Microsoft has added features for asynchronous and
    parallel programming over the last 20 years. Next, we took a tour of parallel
    programming with .NET, concurrent collections, and asynchronous development with
    C#. Finally, we examined when you might choose each of these concepts for your
    own applications and why you will often choose more than one of them. You will
    be able to take what you learned in this chapter and start thinking about practical
    applications of managed threading in your day-to-day work.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先回顾了 C#、.NET 和托管线程的简要历史。我们讨论了微软在过去 20 年中如何添加异步和并行编程的功能。接下来，我们游览了使用 .NET
    的并行编程、并发集合以及使用 C# 的异步开发。最后，我们探讨了在哪些情况下你可能选择这些概念用于自己的应用程序，以及为什么你通常会选择多个概念。你将能够运用本章学到的知识，开始思考在日常工作中托管线程的实际应用。
- en: In the next chapter, we will take what you have learned so far and discuss some
    of the best practices for the practical application of the concepts.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论到目前为止你所学的知识，并讨论一些概念在实际应用中的最佳实践。
- en: Questions
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which class in .NET manages the thread pool threads available to your application?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 .NET 中，哪个类管理着应用程序可用的线程池线程？
- en: In which version of C# were the `async` and `await` keywords introduced?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`async` 和 `await` 关键字是在哪个版本的 C# 中引入的？'
- en: In which version of .NET was the TPL introduced?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TPL 是在哪个版本的 .NET 中引入的？
- en: In which version of .NET Core was `IAsyncEnumerable` introduced?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IAsyncEnumerable` 是在哪个版本的 .NET Core 中引入的？'
- en: What type should every `async` method return?
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个 `async` 方法应该返回什么类型？
- en: Which concurrent collection would you choose to replace `Dictionary<TKey, TValue>`
    in a multithreaded scenario?
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在多线程场景中，你会选择哪个并发集合来替换 `Dictionary<TKey, TValue>`？
- en: Which concurrent collection is frequently used with the producer/consumer design
    pattern in .NET?
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.NET中，哪种并发集合经常与生产者/消费者设计模式一起使用？
- en: Which parallel feature in .NET features the `AsParallel` method?
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET中哪个并行特性包含`AsParallel`方法？
