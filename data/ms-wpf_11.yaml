- en: Improving Application Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升应用程序性能
- en: The performance of **Windows Presentation Foundation** (**WPF**) applications,
    in general, is one of its biggest problems. The more visual layers that our rendered
    data objects and UIs contain, the more time it takes to render them, so we often
    need to maintain a balance between making our applications visually appealing
    and making them perform better.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，**Windows Presentation Foundation**（WPF）应用程序的性能是其最大的问题之一。我们的渲染数据对象和UI包含的视觉层越多，渲染它们所需的时间就越长，因此我们通常需要在使应用程序视觉吸引力和提高性能之间保持平衡。
- en: This situation can be improved by running our WPF applications on more powerful
    computers. This explains why these applications are most prevalent in the financial
    industry. However, not everyone can afford to update all of their users' computers
    for this purpose.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在更强大的计算机上运行我们的WPF应用程序，可以改善这种状况。这也解释了为什么这些应用程序在金融行业中最为普遍。然而，并不是每个人都能承担起为所有用户更新计算机的费用。
- en: Luckily, there are a number of ways in which we can improve the performance
    of our WPF applications, and we'll investigate them here. The art of improving
    application performance really comes down to making a lot of small improvements
    that, together, all add up to a noticeable difference.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有多种方法可以提升我们的WPF应用程序的性能，我们将在下面探讨这些方法。提升应用程序性能的技巧实际上归结于进行许多小的改进，这些改进累积起来会产生明显的效果。
- en: In this chapter, we'll explore how we can better utilize the graphics rendering
    power of our computer's graphics card and declare our resources more efficiently.
    We'll investigate how we can improve our application's performance by opting to
    use lighter weight UI controls, more efficient data binding modes, and by employing
    other techniques, such as virtualization.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何更好地利用计算机图形卡的图形渲染能力，并更有效地声明我们的资源。我们将研究如何通过选择使用更轻量级的UI控件、更高效的数据绑定模式以及采用其他技术（如虚拟化）来提高应用程序的性能。
- en: Leveraging the power of hardware rendering
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用硬件渲染的强大功能
- en: As we've already learned, the visuals that WPF can output, while beautiful,
    can be very CPU-intensive and we often need to bear this in mind when designing
    our Views. However, rather than compromising our designs, we can offload the intensive
    rendering processes to the host computer's **Graphics Processing Unit** (**GPU**)
    instead.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经学到的，WPF可以输出的视觉效果虽然美丽，但可能非常CPU密集型，我们在设计视图时需要牢记这一点。然而，我们不必牺牲设计，可以将密集的渲染过程卸载到宿主计算机的**图形处理单元**（GPU）上。
- en: While WPF will default to utilize its software rendering pipeline, it is also
    able to take advantage of a hardware rendering pipeline. This hardware pipeline
    leverages features of Microsoft DirectX, as long as the host PC has DirectX version
    7, or higher, installed. Furthermore, if the version of DirectX that is installed
    is version 9 or higher, increased performance improvements will be seen.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然WPF默认会使用其软件渲染管道，但它也能利用硬件渲染管道。这个硬件管道利用了Microsoft DirectX的特性，只要宿主PC安装了DirectX
    7或更高版本。此外，如果安装的DirectX版本为9或更高，性能提升会更加明显。
- en: The WPF Framework looks at the graphics hardware that is installed on the computer
    that it is running on and puts it into one of three categories, depending on its
    features, such as video RAM, shaders, and support for multi-textures. If it does
    not support version 7 of DirectX or higher, then it is classed in Rendering Tier
    0 and will not be used for hardware rendering at all.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: WPF框架会查看运行在其上的计算机上安装的图形硬件，并根据其特性（如视频RAM、着色器和多纹理支持）将其分为三类。如果它不支持DirectX 7或更高版本，则被归类为渲染层级0，并且完全不会用于硬件渲染。
- en: However, if it does support DirectX version 7 or higher, but less than version
    9, then it is classed in Rendering Tier 1 and will be used for partial hardware
    rendering. However, as practically all new graphics cards support versions of
    DirectX higher than 9, they would all be classed in Rendering Tier 2 and would
    be used for full hardware rendering.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果它支持DirectX 7或更高版本，但低于版本9，则被归类为渲染层级1，并将用于部分硬件渲染。然而，由于几乎所有新的显卡都支持高于9版本的DirectX，它们都会被归类为渲染层级2，并用于完全硬件渲染。
- en: As the UI will freeze during the rendering time, care should be taken to minimize
    the number of visual layers that are rendered. Therefore, for WPF applications
    that will run on computers that have graphics hardware classed in Rendering Tier
    0 and use software rendering, we need to take extra care.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在渲染过程中UI将会冻结，因此应尽量减少需要渲染的视觉层数量。因此，对于将在具有渲染等级0的图形硬件上运行且使用软件渲染的WPF应用程序，我们需要格外小心。
- en: However, if our application is likely to be run on older computers, or computers
    with older graphics hardware, we can detect this using the rendering tier and
    run more efficient code in these instances. We can find out the rendering tier
    of the host computer's graphics hardware using the static `Tier` property of the
    `RenderCapability` class.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们的应用程序可能需要在较旧的计算机上运行，或者具有较旧图形硬件的计算机上运行，我们可以通过渲染等级来检测这一点，并在这些情况下运行更高效的代码。我们可以使用`RenderCapability`类的静态`Tier`属性来找出主机计算机图形硬件的渲染等级。
- en: 'Unfortunately, instead of the type of this property being some kind of useful
    enumeration, it is, in fact, an integer, where only the high-order word represents
    the value of the tier and can be either `0`, `1`, or `2`. We can attain it by
    shifting the bits in the integer to read the value from just the last two bytes:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个属性的类型并不是某种有用的枚举，而实际上是一个整数，其中只有高位字表示等级的值，可以是`0`、`1`或`2`。我们可以通过在整数中移位位来获取它，只从最后两个字节读取值：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once we know the rendering tier of the host computer''s graphics hardware,
    we can write code accordingly. For example, let''s imagine that we had a processor-intensive
    View, with lots of visuals making up each item in a collection. We could set the
    tier value to a property and data bind it to the View, where we could select different
    data templates to use depending on the processing power of the host computer.
    Let''s examine this example by first creating the missing enumeration:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道主机计算机图形硬件的渲染等级，我们就可以相应地编写代码。例如，让我们想象我们有一个处理器密集型的视图，其中包含大量视觉元素，每个元素都由集合中的每个项目组成。我们可以将等级值设置到一个属性中，并将其数据绑定到视图上，这样我们就可以根据主机计算机的处理能力选择不同的数据模板。让我们通过首先创建缺失的枚举来检查这个示例：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we need to add a property of the `RenderingTier` type into our `StateManager`
    class from [Chapter 3](b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml), *Writing Custom
    Application Frameworks*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的`StateManager`类中添加一个`RenderingTier`类型的属性，该类来自[第3章](b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml)，*编写自定义应用程序框架*：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We don''t need to inform the `INotifyPropertyChanged` interface of any changes
    to this property because it will only be set once upon application startup. Let''s
    adjust our previous example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要通知`INotifyPropertyChanged`接口关于此属性任何更改，因为它将在应用程序启动时只设置一次。让我们调整我们之前的示例：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After casting the bit shifted integer value into our `RenderingTier` enumeration
    and setting it to the new `RenderingTier` property in the `StateManager` class,
    we can then start to use it in our Views to determine the level of visualizations
    that we can employ:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在将移位后的整数值转换为我们的`RenderingTier`枚举并将其设置到`StateManager`类中的新`RenderingTier`属性之后，我们就可以开始在视图中使用它，以确定我们可以使用多少可视化级别：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we have a `ListBox` control that is displaying a collection
    of products. The idea is that we can declare three different data templates to
    define what each product will look like. We have a `SimpleDataTemplate` template
    that might just provide a text-based output, a `MoreComplexDataTemplate` template
    that could contain some basic visuals, and a `MostComplexDataTemplate` template
    that could contain several layers of visuals.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们有一个`ListBox`控件，它正在显示一组产品。我们的想法是可以声明三个不同的数据模板来定义每个产品将看起来是什么样子。我们有一个`SimpleDataTemplate`模板，它可能只提供基于文本的输出，一个`MoreComplexDataTemplate`模板，它可能包含一些基本视觉元素，以及一个`MostComplexDataTemplate`模板，它可能包含多层视觉元素。
- en: In the style that is applied to the list box, we set the default `SimpleDataTemp``late`
    template as the value of its `ItemTemplate` property. Using the `RenderingTier`
    property of the `StateManager` class, we then declare a couple of data triggers
    to switch the value of the `ItemTemplate` property to one of the more complex
    templates, depending on the rendering tier of the host computer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用于列表框的样式中，我们将默认的`SimpleDataTemp``late`模板设置为它的`ItemTemplate`属性的值。然后，使用`StateManager`类的`RenderingTier`属性，我们声明了一些数据触发器，根据主机计算机的渲染等级将`ItemTemplate`属性的值切换到更复杂的模板之一。
- en: Making more efficient resources
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作更高效资源
- en: When we reference our resources, we can either use a `StaticResource` or a `DynamicResource`.
    If you remember from [Chapter 5](d5906090-c679-45d6-81cd-016d4337eb75.xhtml),
    *Using the Right Controls for the Job*, a `StaticResource` will look up the value
    of the resource just once, which is comparative to a compile-time lookup. A `DynamicResource`
    will repeatedly look up the value of the resource each time it is requested, whether
    it has changed or not, just like a runtime lookup.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们引用资源时，我们可以使用`StaticResource`或`DynamicResource`。如果你还记得[第5章](d5906090-c679-45d6-81cd-016d4337eb75.xhtml)中的内容，即*为工作选择正确的控件*，`StaticResource`将只查找资源值一次，这相当于编译时查找。而`DynamicResource`每次请求资源时都会重复查找资源值，无论其是否已更改，就像运行时查找一样。
- en: For this reason, we should only ever use a `DynamicResource` if we really need
    to, as we can attain a much better performance by using the `StaticResource` class
    instead. If we find that we need to use a lot of `DynamicResource` references
    to access our resources, then we can refactor our code to data bind to properties
    in our `StateManager` class instead of the resources, in order to increase performance.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只有在真正需要时才应使用`DynamicResource`，因为我们可以通过使用`StaticResource`类来获得更好的性能。如果我们发现我们需要使用大量的`DynamicResource`引用来访问资源，那么我们可以重构我们的代码，将数据绑定到`StateManager`类中的属性，而不是资源，以提高性能。
- en: Another simple way to improve the performance of our resources is to reuse them.
    Instead of declaring them inline in the place that they are used in the XAML,
    we should declare them in a suitable resource section and reference them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 提高资源性能的另一种简单方法是将它们重用。我们不应在XAML中它们被使用的位置内联声明它们，而应在合适的资源部分声明它们并引用它们。
- en: In this way, each resource is created just once and shared. To extend this idea
    further, we could define all of our shared resources in the application resources
    in the `App.xaml` file and share them between all of the application Views.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每个资源只创建一次并共享。为了进一步扩展这个想法，我们可以在`App.xaml`文件中的应用程序资源中定义所有共享资源，并在所有应用程序视图中共享它们。
- en: Imagine a situation where some brush resources were declared inline with the
    XAML within a `DataTemplate` element. Now imagine that this template is set as
    the `ItemTemplate` of an `ItemsControl` object and that the collection that is
    data bound to its `ItemsSource` property contains a thousand elements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这样的情况：一些画笔资源在`DataTemplate`元素内的XAML中被内联声明。现在想象这个模板被设置为`ItemsControl`对象的`ItemTemplate`，并且绑定到其`ItemsSource`属性集合包含了一千个元素。
- en: The application will, therefore, create a thousand brush objects with identical
    properties for each brush that is declared locally within the data template. Now
    compare this to another situation where we declare each required brush just once
    in a resource section and reference it from the template. It's clear to see the
    benefit of this method and the huge savings that can be made of the computer's
    resources.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，应用程序将为每个在数据模板中局部声明的具有相同属性的画笔创建一千个画笔对象。现在将此与另一种情况进行比较，在这种情况下，我们只需在资源部分声明一次所需的画笔，并从模板中引用它。这种方法的好处和可以节省的计算机资源是显而易见的。
- en: Furthermore, this idea also affects the `Resources` sections of our Views, especially
    if we are displaying more than one of them at once. If we declare a View to define
    how each object in a collection should be rendered, then all of the resources
    that are declared in the View will be initialized once for each element in the
    collection. In this case, it is better to declare them at the application level.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个想法也影响了我们的视图的`Resources`部分，特别是如果我们同时显示多个视图时。如果我们声明一个视图来定义集合中每个对象应该如何渲染，那么在集合中的每个元素上都会初始化一次在视图中声明的所有资源。在这种情况下，在应用程序级别声明它们会更好。
- en: Freezing objects
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冻结对象
- en: In WPF, certain resource objects, such as animations, geometries, brushes, and
    pens, can be made `Freezable`. This provides special features that can help to
    improve the performance of our WPF applications. `Freezable` objects can either
    be frozen or unfrozen. In the unfrozen state, they behave like any other object;
    however, when frozen, they become immutable and can no longer be modified.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPF中，某些资源对象，如动画、几何形状、画笔和笔，可以被设置为`Freezable`。这提供了可以帮助提高我们WPF应用程序性能的特殊功能。`Freezable`对象可以是冻结的或非冻结的。在非冻结状态下，它们的行为就像任何其他对象一样；然而，当冻结时，它们变得不可变，并且不能再被修改。
- en: The main benefit of freezing objects is that it can improve application performance,
    because frozen objects no longer require resources to be consumed when monitoring
    and issuing change notifications. Another benefit is that a frozen object is also
    safe to be shared across threads, unlike unfrozen objects.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 冻结对象的主要好处是它可以提高应用程序的性能，因为冻结的对象在监控和发布更改通知时不再需要消耗资源。另一个好处是，冻结的对象也可以安全地在线程之间共享，这与未冻结的对象不同。
- en: Many UI-related objects extend the `Freezable` class to provide this functionality
    and most `Freezable` objects relate to the graphics sub-system, as rendering visuals
    is one of the areas where performance improvements are most needed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 许多与 UI 相关的对象扩展了 `Freezable` 类以提供此功能，并且大多数 `Freezable` 对象都与图形子系统相关，因为渲染视觉是性能提升最需要的领域之一。
- en: Classes such as the `Brush`, `Geometry`, and `Transform` classes contain unmanaged
    resources and the system must monitor them for changes. By freezing these objects
    and making them immutable, the system is able to free up its monitoring resources
    and better utilize them elsewhere. Furthermore, even the memory footprint of a
    frozen object is considerably less than its unfrozen counterpart.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Brush`、`Geometry` 和 `Transform` 类等类包含非托管资源，系统必须监控它们的变化。通过冻结这些对象并使它们不可变，系统能够释放其监控资源，并在其他地方更好地利用它们。此外，冻结对象的内存占用也远小于其未冻结的对应物。
- en: Therefore, in order to make the greatest performance improvements, we should
    get used to freezing all of our resources in all of the `Resource` sections, as
    long as we have no plans to modify them. As most resources typically remain unmodified,
    we are usually able to freeze the vast majority of them and gain significant and
    noticeable improvements in performance by doing so.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了获得最大的性能提升，我们应该习惯在所有 `Resource` 部分中冻结所有资源，只要我们没有修改它们的计划。由于大多数资源通常保持未修改状态，我们通常能够冻结绝大多数资源，并通过这样做获得显著和明显的性能提升。
- en: 'In [Chapter 8](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml), *Creating Visually
    Appealing User Interfaces*, we learned how to freeze a `Freezable` object in code
    by calling its `Freeze` method. Let''s now look at how we can freeze our resources
    in XAML. First, we need to add a XAML namespace prefix to the presentation options
    namespace to access its `Freeze` attribute:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml)，*创建视觉吸引人的用户界面*中，我们学习了如何通过调用其
    `Freeze` 方法在代码中冻结 `Freezable` 对象。现在，让我们看看我们如何在 XAML 中冻结我们的资源。首先，我们需要向表示选项命名空间添加一个
    XAML 命名空间前缀，以便访问其 `Freeze` 属性：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that we also include another XAML namespace prefix to be able to access
    the `Ignorable` attribute, and we set our `PresentationOptions` prefix as its
    value. This is because the `Freeze` attribute is primarily only recognized by
    the WPF XAML processor, and, in order to maintain compatibility with other XAML
    readers, we need to specify that the attribute can be ignored.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还包括另一个 XAML 命名空间前缀，以便能够访问 `Ignorable` 属性，并将我们的 `PresentationOptions` 前缀设置为它的值。这是因为
    `Freeze` 属性主要只被 WPF XAML 处理器识别，并且为了与其他 XAML 读取器保持兼容性，我们需要指定该属性可以被忽略。
- en: 'We''ll find a full example in the *Drawing conclusions* section coming up soon,
    but for now, using a resource from an earlier example, let''s examine how to freeze
    a `Freezable` object in XAML:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在即将到来的*得出结论*部分找到一个完整的示例，但现在，让我们使用早期示例中的一个资源，来探讨如何在 XAML 中冻结一个 `Freezable`
    对象：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Some `Freezable` objects, such as the animation and geometry objects, can contain
    other `Freezable` objects. When a `Freezable` object is frozen, its child objects
    are also frozen. However, there are a few cases where a `Freezable` object cannot
    be frozen.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 `Freezable` 对象，例如动画和几何对象，可以包含其他 `Freezable` 对象。当一个 `Freezable` 对象被冻结时，其子对象也会被冻结。然而，也有一些情况下
    `Freezable` 对象无法被冻结。
- en: One case happens if it has any properties that might change in value, due to
    animations, data binding, or `DynamicResource` references. The other case occurs
    when the `Freezable` object has any child objects that cannot be frozen.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它有任何可能因动画、数据绑定或 `DynamicResource` 引用而改变值的属性，则会出现一种情况。另一种情况发生在 `Freezable`
    对象有任何无法冻结的子对象时。
- en: 'If we are freezing resource type objects in the code behind of a custom control,
    for example, then we can call the `CanFreeze` property of the `Freezable` class
    to check whether each `Freezable` object can be frozen before attempting to freeze
    them:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们正在自定义控件的代码后部冻结资源类型对象，那么我们可以调用 `Freezable` 类的 `CanFreeze` 属性来检查每个 `Freezable`
    对象是否可以冻结，然后再尝试冻结它们：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once a `Freezable` object is frozen, it cannot be modified, and attempting
    to do so will cause an `InvalidOperationException` to be thrown. Note that a `Freezable`
    object cannot be unfrozen; so, to avoid this situation, we can check the value
    of the `IsFrozen` property before attempting to modify the object. If it is frozen,
    we can make a copy of it using its `Clone` method and modify that instead:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Freezable`对象被冻结，它就不能再被修改，尝试修改它将引发`InvalidOperationException`异常。请注意，`Freezable`对象不能被解冻；因此，为了避免这种情况，我们可以在尝试修改对象之前检查`IsFrozen`属性的值。如果它被冻结，我们可以使用它的`Clone`方法制作一个副本并对其进行修改：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If a `Freezable` object is cloned, any `Freezable` children that it might have
    will also be copied to enable modification. When a frozen object is animated,
    the animation system will make cloned copies of it in this way so that it can
    modify them. But, as this adds an overhead to performance, it is advisable not
    to freeze a `Freezable` object if you expect to be animated.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果克隆了一个`Freezable`对象，它可能拥有的任何`Freezable`子对象也将被复制以允许修改。当一个冻结对象被动画化时，动画系统会以这种方式创建它的克隆副本，以便它可以修改它们。但是，由于这会增加性能开销，因此如果预期对象将被动画化，建议不要冻结`Freezable`对象。
- en: Using the right controls for performance
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用适合性能的控件
- en: As we mentioned previously, there are usually several different ways of achieving
    the same functionality, or UI display, when using WPF. Some ways will provide
    better performance than others. For example, we learned how some panels do more
    intensive layout work and, therefore, consume more CPU cycles and/or RAM than
    others.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在使用WPF时，通常有几种不同的方法可以实现相同的功能或UI显示。有些方法比其他方法提供更好的性能。例如，我们了解到一些面板执行更密集的布局工作，因此比其他面板消耗更多的CPU周期和/或RAM。
- en: Therefore, this is one area that we can investigate in order to make performance
    improvements. If we do not require the complex layout and resizing abilities of
    a `Grid` panel, then we can gain a performance improvement by utilizing a more
    efficient `StackPanel` or `Canvas` panel instead.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是我们可以在其中进行调查以改进性能的一个领域。如果我们不需要`Grid`面板的复杂布局和调整大小能力，那么我们可以通过利用更高效的`StackPanel`或`Canvas`面板来获得性能提升。
- en: Another example could be that if we do not require the ability to select in
    a collection control, then we should use an `ItemsControl` element instead of
    a `ListBox`. While swapping one control will not make much of a performance improvement
    on its own, making this same swap in the `DataTemplate` of an item that will be
    displayed thousands of times will make a noticeable difference.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子可能是，如果我们不需要在集合控件中选择的能力，那么我们应该使用`ItemsControl`元素而不是`ListBox`。虽然交换一个控件本身不会对性能产生太大的改善，但在将此相同的交换应用于将显示数千次的项目的`DataTemplate`中，将会产生明显的差异。
- en: As we discovered in [Chapter 5](d5906090-c679-45d6-81cd-016d4337eb75.xhtml),
    *Using the Right Controls for the Job*, each time a UI element is rendered, the
    layout system must complete two passes, a measure pass and an arrange pass, which
    is collectively known as a layout pass. If the element has children and/or grandchildren,
    they will all need to complete the layout pass too. This process is intensive
    and the fewer passes that can be made, the quicker our Views will render.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第5章](d5906090-c679-45d6-81cd-016d4337eb75.xhtml)“使用适合工作的控件”中发现的，每次渲染UI元素时，布局系统必须完成两个遍历，一个测量遍历和一个排列遍历，这共同被称为布局遍历。如果元素有子元素和/或孙元素，它们都需要完成布局遍历。这个过程很复杂，遍历次数越少，我们的视图渲染速度就越快。
- en: As mentioned earlier, we need to be careful to ensure that we do not unnecessarily
    trigger additional passes of the layout system, as this can lead to poor performance.
    This can occur when adding or removing items to or from a panel, applying transforms
    on the elements, or by calling the `UIElement.UpdateLayout` method, which forces
    a new layout pass.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要小心确保不会不必要地触发布局系统的额外遍历，因为这可能导致性能下降。这种情况可能发生在向或从面板添加或删除项目、对元素应用转换或调用`UIElement.UpdateLayout`方法时，后者会强制进行新的布局遍历。
- en: Because of the way that changes to a UI element will invalidate its children
    and force a new layout pass, we need to be especially careful when building hierarchical
    data in code. If we create the child elements first, then their parent objects,
    and then the parents of those objects, and so on, we will incur a huge performance
    hit, due to the existing child items being forced to perform multiple layout passes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 UI 元素的变化会使其子元素无效并强制进行新的布局遍历，因此在代码中构建层次化数据时，我们需要特别小心。如果我们首先创建子元素，然后是它们的父对象，然后是这些对象的父对象，依此类推，我们将因为现有的子项被迫执行多次布局遍历而遭受巨大的性能损失。
- en: In order to address this issue, we need to always ensure that we build our tree
    from the top-down, rather than the top-up method just described. If we add the
    parent element(s) first, then add their children and their children if any, we
    can avoid the additional layout passes. The performance improvement of using the
    top-down method is approximately five times quicker to render, and so is not insignificant.
    Let's take a look at some further control-related performance benefits that we
    can employ next.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要始终确保从上到下构建我们的树，而不是像刚才描述的那样从上到下。如果我们首先添加父元素（们），然后添加它们的子元素，如果有，再添加这些子元素的父元素，等等，我们就可以避免额外的布局遍历。使用自上而下的方法可以提升性能，大约快五倍，因此这一点不容忽视。让我们看看我们可以采用的更多与控制相关的性能优势。
- en: Drawing conclusions
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制结论
- en: When we have a requirement to draw shapes in our UI, such as in our callout
    window example in [Chapter 8](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml), *Creating
    Visually Appealing User Interfaces*, we tend to use the abstract `Shape` class
    or, more accurately, one or more of its derived classes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要在 UI 中绘制形状时，例如在 [第 8 章](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml) 的示例中，即“创建视觉上吸引人的用户界面”，我们倾向于使用抽象的
    `Shape` 类，或者更准确地说，使用其一或多个派生类。
- en: The `Shape` class extends the `FrameworkElement` class, so it can make use of
    the layout system, be styled, have access to a range of stroke and fill properties,
    and its properties can be data bound and animated. This makes it easy to use and,
    generally, the preferred method of drawing in WPF applications.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shape` 类扩展了 `FrameworkElement` 类，因此可以利用布局系统，可以进行样式化，可以访问一系列的描边和填充属性，其属性可以进行数据绑定和动画处理。这使得它易于使用，并且通常是
    WPF 应用程序中绘制形状的首选方法。'
- en: However, WPF also provides lower-level classes that can achieve the same end
    results, but more efficiently. The five classes that extend the abstract `Drawing`
    class have a much smaller inheritance hierarchy and, as such, have a much smaller
    memory footprint than their `Shape` object-based counterparts.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，WPF 也提供了更底层的类，这些类可以以更高效的方式实现相同的结果。扩展抽象 `Drawing` 类的五个类具有更小的继承层次结构，因此与基于 `Shape`
    对象的对应类相比，它们的内存占用更小。
- en: The two most commonly used classes include the `GeometryDrawing` class, which
    is used to draw geometrical shapes, and the `DrawingGroup` class, which is used
    to combine multiple drawing objects into a single composite drawing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的两个类包括用于绘制几何形状的 `GeometryDrawing` 类，以及用于将多个绘图对象组合成单个复合绘图的 `DrawingGroup`
    类。
- en: Additionally, the `Drawing` class is also extended by the `GlyphRunDrawing`
    class, which renders text; the `ImageDrawing` class, which displays images; and
    the `VideoDrawing` class, which enables us to play video files. As the `Drawing`
    class extends the `Freezable` class, further efficiency savings can be made by
    freezing its instances, that is, if they do not need to be modified afterward.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Drawing` 类还被 `GlyphRunDrawing` 类扩展，用于渲染文本；`ImageDrawing` 类用于显示图像；以及 `VideoDrawing`
    类，它使我们能够播放视频文件。由于 `Drawing` 类扩展了 `Freezable` 类，如果这些实例之后不需要修改，通过冻结其实例可以进一步节省效率。
- en: There is one other, and potentially even more efficient, method of drawing shapes
    in WPF. The `DrawingVisual` class does not provide event handling or layout functionality,
    so its performance is improved compared with other drawing methods. However, this
    is a code-only solution and there is no XAML-based `DrawingVisual` option.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WPF 中绘制形状还有另一种方法，可能甚至更高效。`DrawingVisual` 类不提供事件处理或布局功能，因此与其它绘图方法相比，其性能得到了提升。然而，这是一个仅限代码的解决方案，没有基于
    XAML 的 `DrawingVisual` 选项。
- en: Furthermore, its lack of layout abilities means that, in order to display it,
    we need to create a class that extends a class that provides layout support in
    the UI, such as the `FrameworkElement` class. To be even more efficient, though,
    we could extend the `Visual` class, as that is the lightest-weight class that
    can be rendered in the UI, with the fewest properties and no events to handle.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它缺乏布局能力意味着，为了显示它，我们需要创建一个扩展提供 UI 布局支持的类（如 `FrameworkElement` 类）的类。然而，为了更高效，我们也可以扩展
    `Visual` 类，因为这是在 UI 中可以渲染的最轻量级的类，具有最少的属性和无需处理的事件。
- en: This class would be responsible for maintaining a collection of `Visual` elements
    to be rendered, creating one or more `DrawingVisual` objects to add to the collection,
    and overriding a property and a method, in order to participate in the rendering
    process. It could also, optionally, provide event handling and hit-testing capabilities
    if user interaction was required.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将负责维护一个要渲染的 `Visual` 元素集合，创建一个或多个 `DrawingVisual` 对象以添加到集合中，并重写一个属性和一个方法，以便参与渲染过程。它还可以选择性地提供事件处理和点击测试功能，如果需要用户交互的话。
- en: It really depends on what we want to draw. Typically, the more efficient the
    drawing, the less flexible it is. For example, if we were just drawing some static
    clipart, background image, or, perhaps, logo, we could take advantage of the more
    efficient drawing methods. However, if we need our drawing to grow and shrink
    as the application windows change size, then we'll need to use the less efficient
    methods that provide more flexibility, or use another class in addition that provides
    that functionality.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全取决于我们想要绘制的内容。通常，绘图越高效，其灵活性就越低。例如，如果我们只是绘制一些静态的剪贴画、背景图像，或者可能是标志，我们可以利用更高效的绘图方法。然而，如果我们需要我们的绘图随着应用程序窗口大小的变化而增长和缩小，那么我们就需要使用灵活性更高的、效率较低的方法，或者使用另一个提供该功能的类。
- en: 'Let''s explore an example that creates the same graphical image using each
    of the three different drawing methods. We''ll define some smiley face emoticons,
    starting with the `Shape`-based method on the left-hand side, the `Drawing` object-based
    method in the center, and the `DrawingVisual`-based method on the right. Let''s
    first look at the visual output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一个示例，使用三种不同的绘图方法创建相同的图形图像。我们将定义一些笑脸表情符号，从左侧的基于 `Shape` 的方法开始，中间是基于 `Drawing`
    对象的方法，右侧是基于 `DrawingVisual` 的方法。让我们首先看看视觉输出：
- en: '![](img/e1216ee2-906c-4871-bdd2-139de05898bd.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e1216ee2-906c-4871-bdd2-139de05898bd.png)'
- en: 'Now, let''s inspect the XAML:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查一下 XAML：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first thing that we can see straight away from this example is that the
    `Shape` object-based method of drawing is far simpler, achieving the same output
    as the far more verbose `Drawing` object-based method in far fewer lines of XAML.
    Let's now investigate the code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们可以立即看到的第一件事是，基于 `Shape` 对象的绘图方法要简单得多，用更少的 XAML 代码行就能达到与基于更冗长的 `Drawing`
    对象的方法相同的输出。现在让我们来研究一下代码。
- en: After defining the `PresentationOptions` XAML namespace, we declare a `RadialGradientBrush`
    resource and optimize its efficiency, by freezing it using the `Freeze` attribute
    that was discussed earlier in the chapter. Note that if we were planning on using
    this control multiple times simultaneously, then we could be even more efficient,
    by declaring all of our `Brush` and `Pen` objects in the application resources
    and referencing them with `StaticResource` references.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了 `PresentationOptions` XAML 命名空间之后，我们声明了一个 `RadialGradientBrush` 资源，并通过使用本章前面讨论过的
    `Freeze` 属性来冻结它，从而优化其效率。请注意，如果我们打算同时多次使用这个控件，那么我们可以通过在应用程序资源中声明所有的 `Brush` 和 `Pen`
    对象，并使用 `StaticResource` 引用来引用它们，来进一步提高效率。
- en: We then declare an outer `Grid` panel that has two columns. In the left column,
    we declare another `Grid` panel, with five rows and five columns. This inner panel
    is used to position the various `Shape` elements that make up the first smiley
    face. Note that we use star sizing on the row definitions of this panel in order
    to slightly increase the sizes of the top and bottom rows to better position the
    eyes and mouth of the face.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们声明一个外部的 `Grid` 面板，它有两个列。在左侧列中，我们声明另一个 `Grid` 面板，有五行和五列。这个内部面板用于定位构成第一个笑脸的各种
    `Shape` 元素。请注意，我们在这个面板的行定义上使用星号大小，以略微增加顶部和底部行的大小，以便更好地定位眼睛和嘴巴。
- en: Inside the panel, we define an `Ellipse` object to create the overall shape
    of the face, fill it with our brush from the resources, and add an outline with
    a black brush. We then use two further `Ellipse` elements filled with the black
    brush to draw the eyes and a `Path` element to draw the smile. Note that we do
    not fill the `Path` element, as that would look more like an open mouth than a
    smile.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在面板内部，我们定义一个`Ellipse`对象来创建脸的整体形状，用资源中的画笔填充它，并用黑色画笔添加轮廓。然后我们使用两个进一步填充黑色画笔的`Ellipse`元素来绘制眼睛，以及一个`Path`元素来绘制微笑。请注意，我们没有填充`Path`元素，因为这看起来更像是一个张开的嘴巴而不是微笑。
- en: Two other important points to note are that we must set the `Stretch` property
    to `Fill` in order to get the `Path` element to fill the available space that
    we provide it with, and we must set the `StrokeStartLineCap` and `StrokeEndLineCap`
    properties to `Round` to produce the nice, rounded ends of the smile.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的两个其他重要点是，我们必须将`Stretch`属性设置为`Fill`，以便让`Path`元素填充我们提供的可用空间，并且我们必须将`StrokeStartLineCap`和`StrokeEndLineCap`属性设置为`Round`，以产生微笑的圆润末端。
- en: 'We specify the shape that the `Path` element should be using its `Data` property
    and the inline mini-language that we used previously. Let''s now break this value
    down into the various mini-language commands:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定`Path`元素应使用的形状，使用其`Data`属性和之前使用的内联迷你语言。现在让我们将这个值分解成各种迷你语言命令：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As with the previous example, we start with the Move command, specified by `M` and
    the following coordinate pair, which dictates the start point for the line. The
    remainder is taken up with the Elliptical Arc command, which is specified by `A`
    and the following five figures.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子一样，我们首先使用指定为`M`和随后的坐标对的移动命令，这决定了线的起点。其余部分由椭圆弧命令组成，该命令由`A`和随后的五个参数指定。
- en: In order, the five figures of the Elliptical Arc command relate to the size
    of the arc, or its *x* and *y* radii, its rotation angle, a bit field to specify
    whether the angle of the arc should be greater than 180 degrees or not, another
    bit field to specify whether the arc should be drawn in a clockwise or an anti-clockwise
    direction, and, finally, the end point of the arc.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序，椭圆弧命令的五个参数与弧的大小有关，或者说是其*x*和*y*半径，旋转角度，一个位字段用于指定弧的角度是否应该大于180度，另一个位字段用于指定弧应该顺时针还是逆时针绘制，最后是弧的终点。
- en: 'Full details of this path mini-language syntax can be found on the Microsoft
    website. Note that we could change the bit field of the drawing direction to a
    `1` in order to draw a frown instead:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个路径迷你语言语法的完整细节可以在微软网站上找到。请注意，我们可以将绘制方向的位字段更改为`1`，以绘制一个皱眉：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, let's move onto the second column of the outer `Grid` panel now. In this
    column, we recreate the same smiley face but using the more efficient `Drawing`
    object-based objects. As they cannot render themselves like the `Shape` classes
    and we need to utilize other elements to do that job for us, we define them inside
    a `DrawingBrush` element and use that to paint the background of a `Canvas` object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向外部`Grid`面板的第二列。在这一列中，我们重新创建相同的笑脸，但使用更高效的基于`Drawing`对象的对象。由于它们不能像`Shape`类那样自行渲染，我们需要利用其他元素来完成这项工作，因此我们定义它们在`DrawingBrush`元素内部，并使用它来绘制`Canvas`对象的背景。
- en: There are two important things to note here. The first is that we could have
    used the `DrawingBrush` element to paint any class that extends the `FrameworkElement`
    class, such as a `Rectangle` element, or another type of panel.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个需要注意的重要事项。首先，我们本可以使用`DrawingBrush`元素来绘制任何扩展`FrameworkElement`类的类，例如`Rectangle`元素或另一种类型的面板。
- en: The second is that as we have frozen the `DrawingBrush` element using the `Freeze`
    attribute, all of the inner elements that extend the `Freezable` type will also
    be frozen. In this case, that includes the `GeometryDrawing` objects, the `EllipseGeometry`
    and `PathGeometry` objects, and even the `Brush` and `Pen` elements that were
    used to paint them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点是，由于我们使用`Freeze`属性冻结了`DrawingBrush`元素，所有扩展`Freezable`类型的内部元素也将被冻结。在这种情况下，这包括`GeometryDrawing`对象、`EllipseGeometry`和`PathGeometry`对象，甚至用于绘制它们的`Brush`和`Pen`元素。
- en: When using a `DrawingBrush` object to render our drawings, we must define them
    using the `Drawing` property. As we want to build up our image from multiple `Drawing`-based
    objects, we need to wrap them all in a `DrawingGroup` object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`DrawingBrush`对象来渲染我们的绘图时，我们必须使用`Drawing`属性来定义它们。由于我们希望从多个基于`Drawing`的对象构建我们的图像，我们需要将它们全部包裹在一个`DrawingGroup`对象中。
- en: In order to recreate the overall shape of the face, we start with a `GeometryDrawing`
    element and specify an `EllipseGeometry` object as its `Geometry` property value.
    With this `GeometryDrawing` element, we paint the background by setting a reference
    of our `RadialGradientBrush` resource to its `Brush` property, and define a new
    `Pen` instance in its `Pen` property to specify a stroke for it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重新创建脸的整体形状，我们从一个`GeometryDrawing`元素开始，并指定一个`EllipseGeometry`对象作为其`Geometry`属性值。使用这个`GeometryDrawing`元素，我们通过设置我们的`RadialGradientBrush`资源引用到其`Brush`属性来绘制背景，并在其`Pen`属性中定义一个新的`Pen`实例以指定其轮廓。
- en: As with all `Geometry` objects, we specify its dimensions so that they are in
    scale with each other, rather than using exact pixel sizes. For example, our View
    is 150 pixels high; however, instead of setting the `Center` property of this
    `EllipseGeometry` object to 75, which is half of the height, we have set it to
    50.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有`Geometry`对象一样，我们指定其尺寸，使它们相互成比例，而不是使用确切的像素大小。例如，我们的视图高度为150像素；然而，我们并没有将这个`EllipseGeometry`对象的`Center`属性设置为75，即高度的一半，而是将其设置为50。
- en: As the two radii properties are also set to 50, they remain in scale with the
    position of the center and the resulting image is scaled to fit the container
    that it is rendered in. The scale that we use is up to our preference. For example,
    we could divide or multiply all of the coordinates, radii, and brush and pen thicknesses
    in our drawing example by the same amount and we would end up with the same face
    visual.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个半径属性也设置为50，它们与中心的相对位置保持一致，因此生成的图像按比例缩放以适应其渲染的容器。我们使用的比例取决于我们的偏好。例如，我们可以在我们的绘图示例中将所有坐标、半径、画笔和笔触厚度都除以相同的数值，最终得到相同的面视觉。
- en: Next, we add another `GeometryDrawing` element with an `EllipseGeometry` object
    specified in its `Drawing` property for each of the two eyes on the face. These
    have no stroke and so have nothing assigned to the `Pen` property and are colored
    only using a black `Brush` set to their `Brush` properties. The final `GeometryDrawing`
    element hosts a `PathGeometry` object that draws the smile on the face.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为脸上的两个眼睛各自添加另一个具有`EllipseGeometry`对象指定在其`Drawing`属性中的`GeometryDrawing`元素。这些没有轮廓，因此`Pen`属性没有分配任何内容，并且仅使用黑色`Brush`设置其`Brush`属性进行着色。最后的`GeometryDrawing`元素承载了一个绘制脸上微笑的`PathGeometry`对象。
- en: Note that defining a `PathGeometry` object in XAML is far more verbose than
    using the path mini-language syntax. In it, we need to specify each `PathFigure`
    element in the `PathFigures` collection property, although actually declaring
    the surrounding collection in XAML is optional. In the case of our smile, we just
    need to define a single `PathFigure` element containing an `ArcSegment` object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在XAML中定义`PathGeometry`对象比使用路径迷你语言语法更为冗长。在其中，我们需要在`PathFigures`集合属性中指定每个`PathFigure`元素，尽管实际上在XAML中声明周围集合是可选的。在我们的笑脸示例中，我们只需要定义一个包含`ArcSegment`对象的单个`PathFigure`元素。
- en: The `StartPoint` property of the `PathFigure` element dictates where the arc
    should start, the `Size` property of the `ArcSegment` object relates to the size
    of the arc, or its *x* and *y* radii, while its `Point` property specifies the
    end point of the arc.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`PathFigure`元素的`StartPoint`属性决定了弧应该开始的位置，`ArcSegment`对象的`Size`属性与弧的大小相关，或者其*x*和*y*半径，而其`Point`属性指定了弧的终点。'
- en: In order to define round ends for the smile, as we did with the previous smiley
    face, the `Pen` element that we specify for this `PathGeometry` object must have
    its `StartLineCap` and `EndLineCap` properties set to the `Round` member of the
    `PenLineCap` enumeration. This completes the second method of drawing a smiley
    face.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义与之前笑脸相同的圆滑端点，我们指定给这个`PathGeometry`对象的`Pen`元素必须将其`StartLineCap`和`EndLineCap`属性设置为`PenLineCap`枚举的`Round`成员。这完成了绘制笑脸的第二种方法。
- en: The third method uses `DrawingVisual` objects in code internally and results
    in a `Visual` object. As the items in the `Children` collection of the `Grid`
    panel are of the `UIElement` type, we cannot add our `Visual` control to it directly.
    Instead, we can set it to the `Visual` property of a `VisualBrush` element and
    paint the background of an efficient container, such as a `Canvas` control, with
    it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法在代码内部使用`DrawingVisual`对象，并生成一个`Visual`对象。由于`Grid`面板的`Children`集合中的项是`UIElement`类型，我们无法直接将其添加到其中。相反，我们可以将其设置为`VisualBrush`元素的`Visual`属性，并使用它来绘制一个高效容器（如`Canvas`控件）的背景。
- en: 'Let''s now take a look at the code in this `SmileyFace` class:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看`SmileyFace`类中的代码：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There are several classes that we could have extended our `SmileyFace` class
    from, in order to display it in the UI. As we saw in [Chapter 5](d5906090-c679-45d6-81cd-016d4337eb75.xhtml),
    *Using the Right Controls for the Job,* most UI controls have a rich inheritance
    hierarchy, with each extended class offering some particular functionality.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从几个类中扩展我们的`SmileyFace`类，以便在UI中显示它。正如我们在[第5章](d5906090-c679-45d6-81cd-016d4337eb75.xhtml)中看到的，*使用适合工作的正确控件*，大多数UI控件都有丰富的继承层次结构，每个扩展类都提供了一些特定的功能。
- en: In order to make the most efficient container for our `DrawingVisual`, we want
    to extend a class that enables it to take part in the layout process, but adds
    as little additional overhead via unused properties and unrequired event handling
    as possible. As such, we have chosen the `Visual` class, which cannot be used
    as a UI element directly in the XAML, but it can be displayed as the visual of
    a `VisualBrush` element and used to paint a surface with.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的`DrawingVisual`最有效的容器，我们希望扩展一个类，使其能够参与布局过程，但通过未使用的属性和不必要的事件处理尽可能减少额外的开销。因此，我们选择了`Visual`类，它不能直接在XAML中用作UI元素，但它可以作为`VisualBrush`元素的视觉并用于绘制表面。
- en: To generate one or more `DrawingVisual` elements in our `SmileyFace` class,
    we need to declare and maintain a `VisualCollection` instance that will hold the
    `Visual` elements that we want to display. In the constructor, we initialize this
    collection and add the single `DrawingVisual` element that we want to render to
    it in this example, via the `GetFaceDrawingVisual` method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`SmileyFace`类中生成一个或多个`DrawingVisual`元素，我们需要声明并维护一个`VisualCollection`实例，该实例将包含我们想要显示的`Visual`元素。在构造函数中，我们初始化这个集合，并通过`GetFaceDrawingVisual`方法将我们想要渲染的单个`DrawingVisual`元素添加到其中。
- en: In the `GetFaceDrawingVisual` method, we first declare a new version of our
    `RadialBrush` resource using the `RadialGradientBrush` class and a `Pen` element
    and freeze them using their `Freeze` methods. Next, we initialize a single `DrawingVisual`
    element and access a `DrawingContext` object from its `RenderOpen` method, with
    which to draw our shape.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetFaceDrawingVisual`方法中，我们首先使用`RadialGradientBrush`类和一个`Pen`元素声明我们`RadialBrush`资源的新版本，并使用它们的`Freeze`方法将其冻结。接下来，我们初始化一个单独的`DrawingVisual`元素，并从其`RenderOpen`方法中访问一个`DrawingContext`对象，以便绘制我们的形状。
- en: We use the `DrawingContext` object to draw the ellipse that serves as the background
    for the face first. It is colored using the frozen `Brush` and `pen` elements.
    Note that, as the `Visual` class has no `Stretch` property or concept of size,
    the dimensions that we use here are exact device-independent pixel dimensions,
    rather than relative values, as were used in the previous drawing methods.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`DrawingContext`对象首先绘制作为脸部背景的椭圆。它使用冻结的`Brush`和`pen`元素着色。请注意，由于`Visual`类没有`Stretch`属性或大小概念，我们在这里使用的维度是精确的设备无关像素维度，而不是像之前绘图方法中使用的那种相对值。
- en: In this example, our smiley faces are 150 pixels wide by 150 pixels tall, so
    the center position will be half of that. Therefore, these exact pixel values
    can be calculated by multiplying the relative values from the previous `Drawing`-based
    example by `1.5`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的笑脸宽度为150像素，高度为150像素，因此中心位置将是其一半。因此，这些精确的像素值可以通过将之前基于`Drawing`的示例中的相对值乘以`1.5`来计算。
- en: However, we also need to consider the fact that the outline will be drawn half
    inside the drawing and half outside. As such, we need to adjust the two radii
    of this ellipse, reducing them by half of the outline size. As the pen used for
    this ellipse has a thickness of `5.25` device-independent pixels, we need to reduce
    each radius by `2.625`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还需要考虑这样一个事实，轮廓将有一半在绘制内部，一半在绘制外部。因此，我们需要调整这个椭圆的两个半径，将它们减少到轮廓大小的一半。由于用于这个椭圆的笔的厚度为`5.25`设备无关像素，我们需要将每个半径减少`2.625`。
- en: Next, we call the `DrawEllipse` method again to draw each of the eyes, passing
    in a black brush and no `Pen` element, along with their newly calculated positions
    and sizes. For the smile, we first need to create an `ArcSegment` element and
    add that to a collection of the `PathSegment` type, while initializing a `PathFigure`
    object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再次调用`DrawEllipse`方法来绘制每个眼睛，传入一个黑色画刷和没有`Pen`元素，以及它们新计算的位置和大小。对于微笑，我们首先需要创建一个`ArcSegment`元素并将其添加到`PathSegment`类型的集合中，同时初始化一个`PathFigure`对象。
- en: We then add the `PathFigure` object to a collection and pass that to the constructor
    of the `PathGeometry` object to initialize it. Next, we define the `Pen` object
    that will be used to draw the smile, ensuring that we set its `StartLineCap` and
    `EndLineCap` properties to the `Round` member of the `PenLineCap` enumeration,
    as in the previous examples.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `PathFigure` 对象添加到一个集合中，并将其传递给 `PathGeometry` 对象的构造函数以初始化它。接下来，我们定义将用于绘制笑脸的
    `Pen` 对象，确保我们将它的 `StartLineCap` 和 `EndLineCap` 属性设置为 `PenLineCap` 枚举的 `Round`
    成员，就像之前的例子一样。
- en: We then freeze this `Pen` object and pass it, along with the `PathGeometry`
    object, to the `DrawGeometry` method of the `DrawingContext` object to draw it.
    Finally, we close the drawing context using its `Close` method and return the
    single `DrawingVisual` element that we just created.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这个 `Pen` 对象冻结，并将其与 `PathGeometry` 对象一起传递给 `DrawingContext` 对象的 `DrawGeometry`
    方法来绘制它。最后，我们使用其 `Close` 方法关闭绘图上下文，并返回我们刚刚创建的单个 `DrawingVisual` 元素。
- en: While we have now taken care of the code that draws our smiley face, we will
    not be able to see anything in the UI yet. In order to participate in the rendering
    process, we need to override a couple of members from the `Visual` class, the
    `VisualChildrenCount` property, and the `GetVisualChild` method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在已经处理了绘制笑脸的代码，但在 UI 中我们仍然看不到任何东西。为了参与渲染过程，我们需要覆盖 `Visual` 类的几个成员，即 `VisualChildrenCount`
    属性和 `GetVisualChild` 方法。
- en: When overriding these members, we need to inform the `Visual` class of the visuals
    that we want it to render for us. As such, we simply return the number of items
    in our internal `VisualCollection` object from the `VisualChildrenCount` property
    and return the item in the collection that relates to the specified `index` input
    parameter from the `GetVisualChild` method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当覆盖这些成员时，我们需要通知 `Visual` 类它为我们渲染的视觉元素。因此，我们只需从 `VisualChildrenCount` 属性返回我们内部
    `VisualCollection` 对象中的项目数量，并从 `GetVisualChild` 方法返回与指定 `index` 输入参数相关的集合中的项目。
- en: In this example, we have added a check for invalid values from the `index` input
    parameter, although this shouldn't ever occur if we output the correct number
    of items from the `VisualChildrenCount` property in the first place.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们添加了对 `index` 输入参数无效值的检查，尽管如果我们最初从 `VisualChildrenCount` 属性输出正确数量的项目，这种情况永远不会发生。
- en: So, now we have seen three different drawing methods for creating the same visual
    output, with each being more efficient than the previous one. However, apart from
    the efficiency differences, we should also be aware of the differences in these
    drawing methods when it comes to the manipulation and versatility of the elements.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经看到了三种不同的绘图方法来创建相同的视觉输出，每个方法都比前一个更高效。然而，除了效率差异之外，我们还应该意识到这些绘图方法在元素操作和多功能性方面的差异。
- en: 'As an example, let''s adjust the `Width` of our `DrawingView` class, set its
    `ClipToBounds` property to `true`, and view its new output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们调整我们的 `DrawingView` 类的 `Width`，将其 `ClipToBounds` 属性设置为 `true`，并查看其新的输出：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s now run the application again and see the output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们再次运行应用程序并查看输出：
- en: '![](img/a6b6efa1-8049-48ae-b74c-1e4153a7481c.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a6b6efa1-8049-48ae-b74c-1e4153a7481c.png)'
- en: As you can see from the preceding screenshot, these drawing methods behave differently
    when resized. The first method is redrawn at the current size and the thickness
    of each drawn line remains the same, even though the width of this face has been
    narrowed by the space provided to it from the parent `Grid` panel.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，这些绘图方法在调整大小时表现不同。第一个方法在当前大小下重新绘制，每条绘制线的厚度保持不变，尽管这个脸的宽度已经被提供给它的父 `Grid`
    面板的空隙所缩小。
- en: However, the second and third smiley faces actually look like squashed images,
    where the thickness of each line is no longer static; the more vertical the line
    is, the thinner it now becomes. The overall widths of these faces have also been
    adjusted by the parent `Grid` panel.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二个和第三个笑脸实际上看起来像被压扁的图像，其中每条线的厚度不再静态；线条越垂直，现在它就越细。这些脸的整体宽度也已经被父 `Grid` 面板调整。
- en: 'The third face, however, has only been scaled by the `VisualBrush` object that
    is used to display it. If instead of extending the `Visual` class, we had wanted
    to derive from the `UIElement` class to utilize some of its functionality, or
    perhaps to enable us to display our `SmileyFace` control directly in the XAML,
    then we would see a different output. Let''s make a slight adjustment to our class
    declaration:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第三个脸部却只被用于显示它的 `VisualBrush` 对象进行了缩放。如果我们不是扩展 `Visual` 类，而是从 `UIElement`
    类派生以利用其一些功能，或者可能使我们能够直接在 XAML 中显示我们的 `SmileyFace` 控件，那么我们会看到不同的输出。让我们对我们的类声明做一些轻微的调整：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s also display it directly in the XAML now, replacing the `Canvas` and
    `VisualBrush` objects that previously displayed it:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们也直接在 XAML 中显示它，替换掉之前显示它的 `Canvas` 和 `VisualBrush` 对象：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, if we run the application again and see the output, it will look very
    different:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次运行应用程序并查看输出，它看起来会非常不同：
- en: '![](img/3e591496-9319-4a2e-9272-1e5730e7942c.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3e591496-9319-4a2e-9272-1e5730e7942c.png)'
- en: Because we specified exact values for our drawing, our `SmileyFace` control
    does not extend any class that would enable resizing or scaling, and we no longer
    have the `VisualBrush` object to resize it. That is, the drawing remains exactly
    as it would be at full size, except that it now no longer fits into the space
    provided to it from the parent `Grid` panel.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为绘图指定了精确的值，我们的 `SmileyFace` 控件没有扩展任何能够实现调整大小或缩放的类，而且我们也不再拥有 `VisualBrush`
    对象来调整它的大小。也就是说，绘图将保持完整的大小，除了它现在不再适合从父 `Grid` 面板提供的空间。
- en: In order to build the ability to draw the shape at different sizes into our
    class, we'll need to derive it from a class that provides us with additional properties
    and functionality. The `FrameworkElement` class supplies us with both dimension
    properties that we can use to draw our shape at the required size and a `Loaded`
    event that we can use to delay the construction of our shape until the relevant
    size has been calculated by the layout system.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将绘制不同大小形状的能力构建到我们的类中，我们需要从提供额外属性和功能性的类中派生它。`FrameworkElement` 类为我们提供了可以使用来绘制所需大小形状的尺寸属性，以及一个
    `Loaded` 事件，我们可以使用它来延迟构建我们的形状，直到布局系统计算出相关的大小。
- en: 'Let''s examine the changes that we''d need to make to achieve this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们需要做出的更改以实现这一点：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first change is that we need to move the call to generate the shape from
    the constructor to the `SmileyFace_Loaded` handling method. If we had not moved
    this, our shape would have no size, because the `ActualWidth` and `ActualHeight`
    properties that are used to define its size would not have been set by the layout
    system at that time.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个更改是我们需要将生成形状的调用从构造函数移动到 `SmileyFace_Loaded` 处理方法。如果我们没有移动这个调用，我们的形状将没有大小，因为用于定义其大小的
    `ActualWidth` 和 `ActualHeight` 属性在那个时间点还没有被布局系统设置。
- en: Next, in the `GetFaceDrawingVisual` method, we need to replace the hardcoded
    values with divisions of the control's dimensions. The ellipse that draws the
    whole face is simple to calculate, with a position of half the width and height
    of the control and radii of half of the width and height of the control minus
    half of the thickness of the `Pen` element that draws its outline.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `GetFaceDrawingVisual` 方法中，我们需要将硬编码的值替换为控件尺寸的分割。绘制整个脸部的椭圆计算简单，其位置为控件宽度和高度的一半，半径为控件宽度和高度的一半减去绘制轮廓的
    `Pen` 元素厚度的一半。
- en: However, if you were wondering where all of the remaining long decimal divisor
    values came from, the answer is basic mathematics. The original drawing was 150
    pixels wide by 150 pixels tall, so we can divide this by the various positions
    and sizes of the drawn lines from the previous example.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想知道所有剩余的长小数除数值是从哪里来的，答案是基本的数学。原始绘图宽度和高度都是 `150` 像素，因此我们可以将这个值除以之前示例中绘制的线条的各种位置和大小。
- en: For example, the ellipse that draws the first eye was previously centered with
    an `X` position of `44.25`. So, to calculate our required width divisor, we simply
    divide `150` by `44.25`, which equals `3.3898305084745761`. Therefore, when the
    control is provided with `150` pixels of space, it will draw the left eye at an
    `X` position of `44.25` and it will now scale correctly at all of the other sizes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，绘制第一个眼睛的椭圆之前是居中的，`X` 位置为 `44.25`。因此，为了计算我们所需的宽度除数，我们只需将 `150` 除以 `44.25`，结果为
    `3.3898305084745761`。因此，当控件提供 `150` 像素的空间时，它将在 `X` 位置 `44.25` 处绘制左眼，并且现在将在所有其他大小上正确缩放。
- en: The divisors for each position and size of the drawn shapes were all calculated
    using this method, to ensure that they would be sized appropriately for the space
    provided to our control. Note that we could have altered the brush and pen thicknesses
    likewise, but we have opted not to do so in this example for brevity.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每个绘制形状的位置和大小除数都是使用这种方法计算的，以确保它们能够适当地适应提供给我们的控件的空间。请注意，我们同样可以改变画笔和笔的粗细，但在这个例子中为了简洁我们没有这样做。
- en: 'When running this example now, we again have a slightly different output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当现在运行这个示例时，我们再次得到了一个略微不同的输出：
- en: '![](img/af68f172-08f9-49df-ad19-75ac2b3c2036.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/af68f172-08f9-49df-ad19-75ac2b3c2036.png)'
- en: Now, the first and third faces look more similar, with the thicknesses of their
    drawn lines being static and unchanging along their length, unlike the second
    face. So, we can see that we have many options when it comes to creating custom
    drawings, and we need to balance the need for efficiency with the ease of use
    of the drawing method and also take the use of the resulting image into consideration.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第一面和第三面的外观更相似，它们绘制的线条的厚度在长度上是静态且不变的，与第二面不同。因此，我们可以看到在创建自定义绘图时有很多选择，我们需要在效率的需求与绘图方法的易用性之间取得平衡，同时也要考虑最终图像的使用。
- en: Before moving onto the next topic in this chapter, there are a few further efficiency
    savings that we can make when drawing complex shapes. If our code uses a large
    number of `PathGeometry` objects, then we can replace them by using a `StreamGeometry`
    object instead.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入本章的下一个主题之前，我们在绘制复杂形状时还可以做出一些额外的效率提升。如果我们的代码使用了大量的`PathGeometry`对象，那么我们可以通过使用`StreamGeometry`对象来替换它们。
- en: The `StreamGeometry` class is specifically optimized to handle multiple path
    geometries and shows better performance than can be attained from using multiple
    `PathGeometry` instances. In fact, we have already been using the `StreamGeometry`
    class inadvertently, as that is what is used internally when the binding path
    mini-language syntax is parsed by the XAML reader.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamGeometry`类专门优化了处理多个路径几何形状，并且比使用多个`PathGeometry`实例的性能更好。实际上，我们已经在无意中使用`StreamGeometry`类了，因为当XAML读取器解析绑定路径迷你语言语法时，它内部使用的就是这个类。'
- en: It can be thought of in a similar way to the `StringBuilder` class, in that
    it is more efficient at drawing complex shapes than using multiple instances of
    the `PathGeometry` class, but it also has some overhead and so only benefits us
    when replacing a fair number of them.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以与`StringBuilder`类类似地考虑，即它比使用多个`PathGeometry`类的实例绘制复杂形状更有效率，但它也有一些开销，因此只有在替换相当数量的它们时才会对我们有益。
- en: Finally, rather than display our `DrawingVisual` using a `VisualBrush`, which
    is refreshed during each layout pass, if our drawings are never to be manipulated
    in the UI, it is even more efficient to create actual images from them and display
    those instead.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，而不是使用`VisualBrush`来显示我们的`DrawingVisual`，`VisualBrush`在每次布局过程中都会刷新，如果我们的绘图在UI中永远不会被操作，那么从它们创建实际图像并显示这些图像将更加高效。
- en: 'The `RenderTargetBitmap` class provides a simple way for us to create images
    from `Visual` instances, using its `Render` method. Let''s explore an example
    of this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderTargetBitmap`类为我们提供了一个简单的方法，通过其`Render`方法从`Visual`实例创建图像。让我们看看一个这样的例子：'
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We start by initializing a `RenderTargetBitmap` object with the required dimensions,
    resolution, and pixel format of the image to create. Note that the `Pbgra32` member
    of the static `PixelFormats` class specifies a pixel format that follows the sRGB
    format, using 32 bits per pixel, with each of the four alpha, red, green, and
    blue channels receiving 8 bits each per pixel.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化一个`RenderTargetBitmap`对象，指定要创建的图像所需的尺寸、分辨率和像素格式。请注意，静态`PixelFormats`类的`Pbgra32`成员指定了一个遵循sRGB格式的像素格式，每个像素使用32位，每个alpha、红色、绿色和蓝色通道每个像素接收8位。
- en: Next, we pass our `DrawingVisual` element, or any other element that extends
    the `Visual` class, to the `Render` method of the `RenderTargetBitmap` class to
    render it. To make the operation more efficient still, we then call its `Freeze`
    method to freeze the object.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将我们的`DrawingVisual`元素或任何扩展了`Visual`类的其他元素传递给`RenderTargetBitmap`类的`Render`方法以渲染它。为了使操作更加高效，我们随后调用它的`Freeze`方法来冻结对象。
- en: In order to save a PNG image file, we first initialize a `PngBitmapEncoder`
    object and add the `renderTargetBitmap` variable to its `Frames` collection via
    the `Create` method of the `BitmapFrame` class. Finally, we initialize a `Stream`
    object using the `File.Create` method, passing in the desired file name and path,
    and call its `Save` method to save the file to the computer's hard drive. Alternatively,
    the `JpegBitmapEncoder` class can be used to create a JPG image file.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保存 PNG 图像文件，我们首先初始化一个 `PngBitmapEncoder` 对象，并通过 `BitmapFrame` 类的 `Create`
    方法将 `renderTargetBitmap` 变量添加到其 `Frames` 集合中。最后，我们使用 `File.Create` 方法初始化一个 `Stream`
    对象，传入所需的文件名和路径，并调用其 `Save` 方法将文件保存到计算机的硬盘上。或者，可以使用 `JpegBitmapEncoder` 类来创建 JPG
    图像文件。
- en: Let's now move on to find ways of using images more efficiently.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探讨如何更有效地使用图像。
- en: Imaging more efficiently
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更高效地使用图像
- en: When an image is displayed in a WPF application, it is loaded and decoded in
    its full size by default. If your application displays a number of thumbnails
    from the original images, then you can gain enhanced performance by copying your
    full-size images and then resizing them to the correct size for the thumbnails,
    rather than letting WPF do it for you.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 WPF 应用程序中显示图像时，它默认以全尺寸加载和解码。如果你的应用程序显示来自原始图像的多个缩略图，那么通过复制你的全尺寸图像并将它们调整到缩略图正确的尺寸，而不是让
    WPF 为你完成，你可以获得更好的性能。
- en: 'Alternatively, you can request that WPF decodes your images to the size required
    by the thumbnails, although, if you want to display the full-size images, you
    would really need to decode each full-size image separately. Let''s take a look
    at how we can achieve this by using a `BitmapImage` object as the source for an
    `Image` control:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以要求 WPF 将你的图像解码到缩略图所需的大小，尽管如果你想要显示全尺寸图像，你实际上需要分别解码每个全尺寸图像。让我们看看如何通过使用 `BitmapImage`
    对象作为 `Image` 控件的源来实现这一点：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The important part of this example is the `DecodePixelWidth` property of the
    `BitmapImage` class, which specifies the actual size of the image to decode to.
    In this example, this would result in a smaller memory footprint as well as faster
    rendering.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中的重要部分是 `BitmapImage` 类的 `DecodePixelWidth` 属性，它指定了解码到图像的实际大小。在这个示例中，这将导致更小的内存占用以及更快的渲染速度。
- en: Note that if the `DecodePixelHeight` and `DecodePixelWidth` properties of the
    `BitmapImage` class are both set, a new aspect ratio will be calculated from their
    values. However, if only one of these properties is set, then the image's original
    aspect ratio will be used. It is, therefore, customary to only set one of these
    properties in order to decode to a different size from the original, while maintaining
    its aspect ratio.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果 `BitmapImage` 类的 `DecodePixelHeight` 和 `DecodePixelWidth` 属性都设置了，将根据它们的值计算一个新的宽高比。然而，如果只设置其中一个属性，则将使用图像的原始宽高比。因此，通常只设置其中一个属性，以便将图像解码到与原始大小不同的尺寸，同时保持其宽高比。
- en: Normally, when images are used in a WPF application, they are all cached into
    memory at load time. Another benefit that can be gained if using code in the aforementioned
    scenario is to set the `CacheOption` property of the `BitmapImage` class to the
    `OnDemand` enumeration member, which postpones the caching of the relevant image
    until the image is actually requested to be displayed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当在 WPF 应用程序中使用图像时，它们在加载时都会被缓存到内存中。如果在上述场景中使用代码，还可以获得的一个好处是将 `BitmapImage`
    类的 `CacheOption` 属性设置为 `OnDemand` 枚举成员，这将推迟相关图像的缓存，直到实际请求显示图像。
- en: This can save a significant amount of resources at load time, although each
    image will take a tiny bit longer to display the first time they are displayed.
    Once the image is cached, however, it will work in exactly the same way as the
    images created in the default way.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在加载时节省大量的资源，尽管每个图像在首次显示时将稍微慢一点。然而，一旦图像被缓存，它将完全以默认方式创建的图像相同的方式工作。
- en: There is one additional property in the `BitmapImage` class that can be used
    to improve the performance when loading multiple image files. The `CreateOptions`
    property is of the `BitmapCreateOptions` enumeration type and enables us to specify
    initialization options that relate to the loading of images. This enumeration
    can be set using bitwise combinations as it specifies the `FlagsAttribute` attribute
    in its declaration.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BitmapImage`类中还有一个额外的属性，可以在加载多个图像文件时提高性能。`CreateOptions`属性是`BitmapCreateOptions`枚举类型，使我们能够指定与图像加载相关的初始化选项。此枚举可以使用位组合设置，因为它在其声明中指定了`FlagsAttribute`属性。
- en: The `DelayCreation` member can be used to delay the initialization of each image
    until it is actually required, thereby speeding up the process of loading the
    relevant View, while adding a tiny cost to the process of requesting each image
    when it is actually required.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`DelayCreation`成员来延迟每个图像的初始化，直到实际需要时，从而加快加载相关视图的过程，同时在实际需要时请求每个图像的过程会增加微小的成本。
- en: This would benefit a photo gallery type of application, for example, where the
    initialization of each full-size image could be delayed until the user clicks
    on the appropriate thumbnail. It is only at that point that the image would be
    created, but as there would only be a single image to create at that point, the
    initialization time would be negligible.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有利于例如照片画廊类型的应用程序，例如，每个完整尺寸图像的初始化可以延迟到用户点击相应的缩略图时。只有在那时，图像才会被创建，但由于那时只需创建单个图像，因此初始化时间可以忽略不计。
- en: 'While it is possible to set more than one of these members to the `CreateOptions`
    property using the bitwise OR operator (`|`), care should be taken to not also
    set the `PreservePixelFormat` member, unless specifically required, as that can
    result in lower performance. When it is not set, the system will choose the pixel
    format with the best performance by default. Let''s look at a short example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用位或运算符（`|`）将多个这些成员设置为`CreateOptions`属性，但应注意不要同时设置`PreservePixelFormat`成员，除非确实需要，因为这可能会导致性能降低。当未设置时，系统将默认选择具有最佳性能的像素格式。让我们来看一个简短的例子：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When creating images in code, we need to initialize an instance of the `BitmapImage`
    class to use as the source for the actual `Image` object that will be displayed
    in the UI. When doing so, we need to call its `BeginInit` method before making
    changes to it and then call its `EndInit` method afterward. Note that all changes
    made after initialization will be ignored.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中创建图像时，我们需要初始化`BitmapImage`类的一个实例，将其用作将在UI中显示的实际`Image`对象的数据源。在这样做时，我们需要在对其进行更改之前调用其`BeginInit`方法，然后在其之后调用`EndInit`方法。请注意，初始化之后所做的所有更改都将被忽略。
- en: During initialization, we set the `CacheOption` property to the `OnDemand` member
    and the `CreateOptions` property to the `DelayCreation` member. Note that we do
    not set the `DecodePixelWidth` or `DecodePixelHeight` properties here, because
    this code example is setup for initializing the full-size images in our gallery
    example.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化过程中，我们将`CacheOption`属性设置为`OnDemand`成员，将`CreateOptions`属性设置为`DelayCreation`成员。请注意，我们在此处没有设置`DecodePixelWidth`或`DecodePixelHeight`属性，因为此代码示例是为初始化我们画廊示例中的完整尺寸图像而设置的。
- en: 'Additionally, note that, in this particular example, we initialize the `Uri`
    object using an absolute file path, by passing the `Absolute` member of the `UriKind`
    enumeration into the constructor. If you prefer to work with relative file paths,
    you can change this line to specify a relative file path by passing the `Relative`
    member to the constructor instead:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，在这个特定的例子中，我们使用绝对文件路径初始化`Uri`对象，通过将`UriKind`枚举的`Absolute`成员传递给构造函数。如果您更喜欢使用相对文件路径，可以将此行更改为指定相对文件路径，通过将`UriKind`枚举的`Relative`成员传递给构造函数：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Returning to the end of the example now, we can see the call to the `Freeze`
    method, which ensures that the `BitmapImage` object will be unmodifiable and in
    its most efficient state. This line can be omitted if the images need to be modified
    later.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到示例的末尾，我们可以看到对`Freeze`方法的调用，这确保了`BitmapImage`对象将是不可修改的，并且处于其最有效状态。如果稍后需要修改图像，则可以省略此行。
- en: Finally, we call the `EndInit` method to signal the end of the `BitmapImage` object initialization,
    set the `BitmapImage` object as the `Source` property value of the `Image` object
    to return, and then return the `Image` object to the method caller.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `EndInit` 方法来表示 `BitmapImage` 对象初始化的结束，将 `BitmapImage` 对象设置为返回的 `Image`
    对象的 `Source` 属性值，然后返回 `Image` 对象给方法调用者。
- en: Now that we've seen some tips on how to display our images more efficiently,
    let's investigate how we might do the same for our application's textual output.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一些关于如何更有效地显示我们的图像的提示，让我们来调查一下我们如何为我们的应用程序的文本输出做同样的事情。
- en: Enhancing the performance of textual output
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升文本输出的性能
- en: WPF provides similar options for creating text as it does for drawing shapes;
    the more versatile the output method, the easier it is to use, but the less efficient
    it is and vice versa. The vast majority of us opt for the simplest, but least
    efficient, method of using the high-level `TextBlock` or `Label` elements.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: WPF 提供了与绘制形状类似的选择来创建文本；输出方法越灵活，使用起来就越容易，但效率就越低，反之亦然。我们中的绝大多数人选择最简单但效率最低的方法，即使用高级的
    `TextBlock` 或 `Label` 元素。
- en: While this doesn't typically cause us any problems when used in typical forms,
    there is definitely room for improvement when displaying thousands of text blocks
    in a data grid, or other collection control. If we require formatted text, we
    can utilize the more efficient `FormattedText` object; otherwise, we can use the
    lowest-level method and the most efficient `Glyphs` elements.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在典型表单中使用时这通常不会给我们带来任何问题，但在数据网格或其他集合控件中显示成千上万的文本块时，肯定有改进的空间。如果我们需要格式化文本，我们可以利用更高效的
    `FormattedText` 对象；否则，我们可以使用最低级的方法和最有效的 `Glyphs` 元素。
- en: 'Let''s look at an example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we have a View that has a `Grid` panel with four rows. The first row holds
    a `Label` control, which although fairly efficient, is the least efficient of
    the textual output methods shown here and, as we'll see soon, should only be used
    in very specific circumstances. On it, we specify the `FontFamily`, `FontSize`,
    `FontWeight`, `FontStyle`, and `Foreground` properties to define how its text
    should look.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个包含四个行的 `Grid` 面板的视图。第一行包含一个 `Label` 控件，尽管相当高效，但在这里显示的文本输出方法中效率最低，并且正如我们很快就会看到的，它只应在非常特定的情况下使用。在其上，我们指定
    `FontFamily`、`FontSize`、`FontWeight`、`FontStyle` 和 `Foreground` 属性来定义其文本的外观。
- en: The second row contains a `TextBlock` element, which is slightly more efficient,
    and, like the `Label` element, we specify the `FontFamily`, `FontSize`, `FontWeight`, `FontStyle`,
    and `Foreground` properties on it directly. It's worth noting that to result in
    the same visual output, we don't need to set its `Padding` property to `0`, which
    was required with the `Label` control.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行包含一个 `TextBlock` 元素，它稍微高效一些，并且像 `Label` 元素一样，我们直接在其上指定 `FontFamily`、`FontSize`、`FontWeight`、`FontStyle`
    和 `Foreground` 属性。值得注意的是，为了产生相同的视觉输出，我们不需要将其 `Padding` 属性设置为 `0`，这在 `Label` 控件中是必需的。
- en: In the third row, we have a custom `FormattedTextOutput` control that uses a
    `FormattedText` object internally and is slightly more efficient still. As we'll
    see shortly, we need to specify the relevant properties of this text object in
    code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行，我们有一个自定义的 `FormattedTextOutput` 控件，它内部使用 `FormattedText` 对象，并且仍然稍微高效一些。正如我们很快就会看到的，我们需要在代码中指定这个文本对象的相关属性。
- en: Finally, we see a `Glyphs` element in the fourth row and this represents the
    most efficient method of outputting text in a WPF application. Note that when
    using this method of textual output, we don't specify a font family by name, but
    instead set an exact font file path to its `FontUri` property.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在第四行看到一个 `Glyphs` 元素，这代表了在 WPF 应用程序中输出文本的最有效方法。请注意，当使用这种文本输出方法时，我们不是通过名称指定字体族，而是将其精确的字体文件路径设置为
    `FontUri` 属性。
- en: As we want to match the bold italic version of the Times New Roman font, we
    specifically need to set the file path to that exact file. Therefore, we need
    to specify the `timesbi.ttf` file, rather than the normal `times.ttf` version.
    Other than setting the font size to the `FontRenderingEmSize` property and the
    margin to the `OriginX` and `OriginY` properties, this class is fairly self-explanatory.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要匹配 Times New Roman 字体的粗体斜体版本，我们需要特别设置文件路径到那个确切的文件。因此，我们需要指定 `timesbi.ttf`
    文件，而不是正常的 `times.ttf` 版本。除了将字体大小设置为 `FontRenderingEmSize` 属性以及将边距设置为 `OriginX`
    和 `OriginY` 属性外，这个类相当直观。
- en: 'Before continuing, let''s first take a look at the visual output of this View:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们首先看看这个视图的视觉输出：
- en: '![](img/b839587f-85d3-46dd-b448-f25cd86a7f9c.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b839587f-85d3-46dd-b448-f25cd86a7f9c.png)'
- en: 'Let''s now take a look at the code inside the `FormattedTextOutput` class:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看`FormattedTextOutput`类内部的代码：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `FormattedTextOutput` class is a fairly simple affair, with a single Dependency
    Property and its associated CLR wrapper and a single overridden base class method.
    One very important point to note is our use of the `AffectsRender` member of the
    `FrameworkPropertyMetadataOptions` enumeration to specify that changes to this
    property need to cause a new rendering pass.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormattedTextOutput`类相对简单，只有一个依赖属性及其关联的CLR包装和一个重写的基类方法。一个非常重要的一点是，我们使用`FrameworkPropertyMetadataOptions`枚举的`AffectsRender`成员来指定更改此属性需要引起新的渲染过程。'
- en: Typically, the `Text` property will be updated from any data binding after the
    `OnRender` method is called by the `UIElement` base class. Without specifying
    this option, our class will never output any data bound values. By specifying
    this option, we are, in fact, telling the Framework to call the `OnRender` method
    again each time this property value changes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`Text`属性将在`UIElement`基类调用`OnRender`方法之后从任何数据绑定中更新。如果不指定此选项，我们的类将永远不会输出任何数据绑定的值。通过指定此选项，我们实际上是在告诉框架每次此属性值更改时都再次调用`OnRender`方法。
- en: In the overridden `OnRender` method, we first initialize a `FormattedText` object
    with basic properties, such as the text to render, the current culture, and the
    color, size, and type of the font to use. Additional style properties can be set
    using the various set methods that the class exposes. Finally, we call the `DrawText`
    method of the `DrawingContext` object specified by the `drawingContext` input
    parameter, passing in the `FormattedText` object and the position to render it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在重写的`OnRender`方法中，我们首先使用基本属性初始化一个`FormattedText`对象，例如要渲染的文本、当前的区域设置以及要使用的字体颜色、大小和类型。可以通过类公开的各种设置方法设置额外的样式属性。最后，我们调用由`drawingContext`输入参数指定的`DrawingContext`对象的`DrawText`方法，传入`FormattedText`对象和渲染位置。
- en: 'Note that we can use data binding with all of these text rendering methods,
    so let''s now update our previous example to demonstrate this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以使用数据绑定与所有这些文本渲染方法，所以现在让我们更新之前的示例来演示这一点：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For this example, we can simply hardcode a value in our View Model:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们可以在我们的视图模型中简单地硬编码一个值：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Although we can data bind when using all of these textual output methods, there
    are some caveats to be aware of. We've just learned of one relating to the required
    metadata of the `Text` property in our custom `FormattedTextOutput` class and
    there is another relating to the `Glyphs` class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在使用所有这些文本输出方法时进行数据绑定，但也有一些需要注意的事项。我们刚刚了解到与我们自定义的`FormattedTextOutput`类中的`Text`属性所需的元数据相关的一个问题，还有一个与`Glyphs`类相关的问题。
- en: 'It has a requirement that the `UnicodeString` property cannot be empty if the
    `Indicies` property, which represents an alternative method of providing the text
    to render, is also empty. Unfortunately, because of this requirement, attempting
    to data bind to the `UnicodeString` property, as we did in our extended example,
    will result in a compilation error:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个要求，即如果表示提供要渲染的文本的替代方法的`Indicies`属性也为空，则`UnicodeString`属性不能为空。遗憾的是，由于这个要求，尝试像我们在扩展示例中所做的那样将数据绑定到`UnicodeString`属性，将导致编译错误：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To address this issue, we can simply provide a value for the `FallbackValue`
    property of the `Binding` class, so that the `Glyphs` class can be rest assured
    that even if there is no data bound value, its `UnicodeString` property will have
    a non-empty value.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以简单地为`Binding`类的`FallbackValue`属性提供一个值，这样`Glyphs`类就可以确信，即使没有数据绑定的值，其`UnicodeString`属性也将有一个非空值。
- en: 'Note that setting the `FallbackValue` property to an empty string will result
    in the same error being raised:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将`FallbackValue`属性设置为空字符串将导致抛出相同的错误：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There is one further issue regarding data binding; however, this time, it involves
    the `Content` property of the `Label` class. Because the `string` type is immutable,
    each time a data bound value updates the `Content` property, the previous `string` type
    will be discarded and replaced with the new one.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据绑定还有一个进一步的问题；然而，这次它涉及到`Label`类的`Content`属性。因为`string`类型是不可变的，每次数据绑定的值更新`Content`属性时，之前的`string`类型将被丢弃并替换为新的类型。
- en: Furthermore, if the default `ContentTemplate` element is used, it will generate
    a new `TextBlock` element and discard the previous element each time the property
    string is replaced. As a result, updating a data bound `TextBlock` is approximately
    four times quicker than updating a `Label` control. Therefore, if we need to update
    our data bound text values, we should not use a `Label` control.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果使用默认的`ContentTemplate`元素，它将在每次替换属性字符串时生成一个新的`TextBlock`元素并丢弃之前的元素。因此，更新数据绑定的`TextBlock`比更新`Label`控件快大约四倍。因此，如果我们需要更新我们的数据绑定的文本值，我们不应使用`Label`控件。
- en: In fact, each method of rendering text has its own purpose. The `Label` control
    should specifically be used to label text fields in a form, and, in doing so,
    we can take advantage of its access key functionality and its ability to reference
    a target control. The `TextBlock` element is a general-purpose text output method
    that should be used the majority of the time.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每种渲染文本的方法都有其特定的目的。`Label`控件应专门用于在表单中标记文本字段，并且通过这样做，我们可以利用其访问键功能及其引用目标控件的能力。`TextBlock`元素是一种通用的文本输出方法，应该大多数时候使用。
- en: The `FormattedText` object should really only be used when we specifically want
    to format some text in a particular way. It provides the ability to output text
    with a wide range of effects, such as being able to paint the stroke and fill
    of the text independently and to format particular ranges of characters within
    the rendered text string.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormattedText`对象应该只在我们需要以特定方式格式化某些文本时使用。它提供了输出具有广泛效果的文本的能力，例如能够独立绘制文本的轮廓和填充，以及格式化渲染文本字符串中的特定字符范围。'
- en: The `Glyphs` class extends the `FrameworkElement` class directly and is, therefore,
    extremely light-weight and should be utilized when we need to recreate our text
    output more efficiently than we can by using the alternative methods. Although
    the `FormattedText` class can make use of lower, core level classes to render
    its output, the most efficient way to render text is to use `Glyphs` objects.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Glyphs`类直接扩展了`FrameworkElement`类，因此它非常轻量级，并且在我们需要比使用替代方法更有效地重新创建文本输出时应该使用它。尽管`FormattedText`类可以利用较低级别的核心类来渲染其输出，但渲染文本最有效的方法是使用`Glyphs`对象。'
- en: Liking the linking
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 喜欢链接
- en: As you have already seen, each UI element that we use in our Views takes time
    to render. Simply put, the fewer elements that we use, the quicker the View will
    be displayed. Those of us that have used `Hyperlink` elements in our Views will
    already be aware that we cannot display them on their own but, instead, have to
    wrap them inside a `TextBlock` element.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经看到的，我们在视图中使用的每个UI元素都需要时间来渲染。简单来说，我们使用的元素越少，视图显示得就越快。那些在我们视图中使用过`Hyperlink`元素的人可能已经知道，我们不能单独显示它们，而必须将它们包裹在一个`TextBlock`元素中。
- en: 'However, as each `Hyperlink` element is self-contained, with its own navigation
    URI, content, and property options, we can actually display more than one of them
    in a single `TextBlock` element. This will reduce the render time; therefore,
    the more `TextBlock` elements that we can remove, the quicker it will become.
    Let''s look at an example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于每个`Hyperlink`元素都是自包含的，拥有自己的导航URI、内容和属性选项，我们实际上可以在单个`TextBlock`元素中显示多个它们。这将减少渲染时间；因此，我们可以移除的`TextBlock`元素越多，它就会变得越快。让我们看一个例子：
- en: '[PRE27]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we have a collection of `Product` objects that are data bound to a `ListBox`,
    with each item displaying its name, price, and three commands in the form of `Hyperlink`
    objects. Let''s see what this looks like before continuing:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`Product`对象的集合，这些对象绑定到`ListBox`上，每个项目都显示其名称、价格以及以`Hyperlink`对象形式呈现的三个命令。在继续之前，让我们看看它是什么样子：
- en: '![](img/71baf69c-b6bc-4216-a5af-32069a49df30.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71baf69c-b6bc-4216-a5af-32069a49df30.png)'
- en: Focusing on the links now, our example uses nine UI elements per item to render
    these three links. The `StackPanel` element keeps them altogether, with each `Hyperlink`
    object having its own `TextBlock` element and a further two `TextBlock` elements
    to display the pipe separator characters.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在专注于链接，我们的示例在每个项目中使用九个UI元素来渲染这三个链接。`StackPanel`元素将它们全部组合在一起，每个`Hyperlink`对象都有自己的`TextBlock`元素和另外两个`TextBlock`元素来显示管道分隔符字符。
- en: The `Hyperlink` objects are data bound to commands in the View Model and the
    `CommandParameter` property is data bound to the whole `Product` object that is
    set as the data source for each item. In this way, we will have access to the
    relevant `Product` instance in the View Model when a link is clicked on.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hyperlink` 对象绑定到视图模型中的命令，而 `CommandParameter` 属性绑定到整个 `Product` 对象，该对象被设置为每个项目的数据源。这样，当点击链接时，我们将能够访问视图模型中的相关
    `Product` 实例。'
- en: 'While there is nothing wrong with this XAML, if we need to be more efficient,
    then we can replace everything inside the `StackPanel` and the panel itself with
    the following `TextBlock` element:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个 XAML 没有什么问题，但如果我们需要更高效，那么我们可以用以下 `TextBlock` 元素替换 `StackPanel` 中的所有内容以及面板本身：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, we now host all three `Hyperlink` objects inside a single `TextBlock`
    element and have replaced the two `TextBlock` elements that displayed the pipe
    characters with `Run` objects. Using the `Run` class is moderately more efficient
    than using one `TextBlock` element inside another.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们现在将所有三个 `Hyperlink` 对象都放在一个单独的 `TextBlock` 元素中，并用 `Run` 对象替换了显示管道字符的两个
    `TextBlock` 元素。使用 `Run` 类比在另一个 `TextBlock` 元素中使用一个 `TextBlock` 元素要高效得多。
- en: Now, we need only render six elements per item to produce the links, including
    using two more efficient elements, rendering three elements fewer per item. However,
    if we had 1,000 products, we would end up rendering 3,000 fewer UI elements, with
    2,000 more efficient replacements, so it is easy to see how this can soon add
    up to some real efficiency savings.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要为每个项目渲染六个元素来生成链接，包括使用两个更高效的元素，每个项目渲染的元素减少三个。然而，如果我们有 1,000 个产品，我们最终将渲染
    3,000 个更少的 UI 元素，用 2,000 个更高效的替换，所以很容易看出这可以很快地积累成一些真正的效率节省。
- en: 'In this example, we could make further improvements, simply by removing the
    line under each link. Bizarrely, we can save up to 25 percent of the rendering
    time taken to render our `Hyperlink` elements if we remove their underlines. We
    can do this by setting their `TextDecorations` property to `None`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以通过简单地删除每个链接下的行来进一步改进。令人惊讶的是，如果我们删除它们的下划线，我们可以将渲染我们的 `Hyperlink` 元素所需的时间减少高达
    25%。我们可以通过将它们的 `TextDecorations` 属性设置为 `None` 来做到这一点：
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We could extend this idea further, by only displaying the underline when the
    user''s mouse cursor is over the link. In this way, we still give the visual confirmation
    that the link is, in fact, a link, but we save the initial rendering time:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过仅在用户的鼠标光标悬停在链接上时显示下划线来进一步扩展这个想法。这样，我们仍然提供了视觉确认，表明链接实际上是一个链接，但我们节省了初始渲染时间：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let's now turn our attention to a number of performance improvements that we
    can make when data binding in our applications.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向在应用程序中的数据绑定时可以做出的多项性能改进。
- en: Data binding
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定
- en: The simplest improvement in performance when data binding can be obtained by
    simply setting the `Binding.Mode` property correctly. In order to make data binding
    possible, the Framework attaches handlers to listen out for changes to our data
    bound properties.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据绑定时，性能的最简单改进可以通过正确设置 `Binding.Mode` 属性来获得。为了使数据绑定成为可能，框架会附加处理程序来监听我们数据绑定属性的变化。
- en: For two-way bindings, event handlers will be attached to the `PropertyChanged`
    event of the `INotifyPropertyChanged` interface to listen to changes in our data
    Model objects or View Models and to various other `XxxChanged` events in the relevant
    binding target controls to listen to UI-based property changes.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于双向绑定，事件处理程序将被附加到 `INotifyPropertyChanged` 接口的 `PropertyChanged` 事件，以监听我们数据模型对象或视图模型中的变化，以及相关绑定目标控件中的各种其他
    `XxxChanged` 事件，以监听基于 UI 的属性变化。
- en: When we only require one-way bindings, we can save some computing resources
    by setting the `Mode` property of the `Binding` class to the appropriate member
    of the `BindingMode` enumeration. If you remember, when a data bound property
    is for display purposes only, we should set its `Mode` property to `OneWay`, and
    when we have no need to update an editable field from the View Model, we should
    set its `Mode` property to the `OneWayToSource` member.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只需要单向绑定时，我们可以通过将 `Binding` 类的 `Mode` 属性设置为 `BindingMode` 枚举的适当成员来节省一些计算资源。如果你还记得，当一个数据绑定属性仅用于显示目的时，我们应该将其
    `Mode` 属性设置为 `OneWay`，而当我们不需要从视图模型更新可编辑字段时，我们应该将其 `Mode` 属性设置为 `OneWayToSource`
    成员。
- en: In doing this, we cut down the number of event handlers listening for changes
    and, therefore, free up resources to be used where they are actually needed. Once
    again, the effect of doing this on one binding alone would be negligible, but
    if we practice this on every relevant binding, then the efficiency improvement
    will start to make a difference.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做的时候，我们减少了监听变化的处理程序数量，因此可以释放资源以供实际需要的地方使用。再次强调，仅对单个绑定执行此操作的影响将微乎其微，但如果我们对每个相关的绑定都这样做，那么效率的提高将开始产生差异。
- en: Another good practice to get into is to set the `FallbackValue` property of
    the `Binding` class on each binding that we declare. As mentioned in [Chapter
    4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml), *Becoming Proficient with Data
    Binding*, doing this will stop the WPF Framework from performing a lookup of the
    default value of the target Dependency Property when there are data binding errors
    and will prevent trace statements from being generated and output.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个良好的实践是，为每个我们声明的绑定设置`Binding`类的`FallbackValue`属性。如[第4章](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml)中提到的*精通数据绑定*，这样做将阻止WPF框架在数据绑定错误时查找目标依赖属性的默认值，并防止生成和输出跟踪语句。
- en: Likewise, setting the `TargetNullValue` property is similar to setting the `FallbackValue`
    property in that it is slightly more efficient than not setting it. Again, doing
    this on a single binding will have a negligible effect; however, if we do this
    on every binding, it will free up CPU cycles for rendering or other required processes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，设置`TargetNullValue`属性与设置`FallbackValue`属性相似，因为它比不设置它稍微高效一些。再次强调，在单个绑定上这样做的影响可以忽略不计；然而，如果我们对每个绑定都这样做，它将为渲染或其他所需过程释放CPU周期。
- en: In fact, the best binding-related way to increase the performance of our applications
    is to simply fix any data binding errors that we may have. Each time a binding
    cannot be resolved, the Framework will perform a number of checks, using up valuable
    resources, as mentioned previously in this section. Therefore, keeping the Output
    window free of binding errors is a must when it comes to performance.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，提高我们应用程序性能的最佳绑定相关方法是简单地修复我们可能有的任何数据绑定错误。每次绑定无法解析时，框架都会执行一系列检查，消耗宝贵的资源，正如本节前面所提到的。因此，当涉及到性能时，保持输出窗口没有绑定错误是必须的。
- en: Registering Dependency Properties
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册依赖属性
- en: As we saw in the *Using the right controls for performance* section earlier
    in this chapter, we need to be careful when setting the metadata for our Dependency
    Properties. Incorrectly specifying the framework metadata while registering our
    Dependency Properties can lower performance by forcing the layout system to unnecessarily
    perform additional layout passes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面的*使用正确的控件以获得性能*部分所看到的，在设置我们的依赖属性元数据时，我们需要小心。在注册依赖属性时错误地指定框架元数据可能会降低性能，迫使布局系统进行不必要的额外布局遍历。
- en: In particular, we need to be careful when specifying any of the `AffectsMeasure`,
    `AffectsArrange`, `AffectsParentMeasure`, `AffectsParentArrange`, or `AffectsRender`
    members of the `FrameworkPropertyMetadataOptions` enumeration and ensure that
    they are actually required.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在指定`FrameworkPropertyMetadataOptions`枚举中的任何`AffectsMeasure`、`AffectsArrange`、`AffectsParentMeasure`、`AffectsParentArrange`或`AffectsRender`成员时，我们需要格外小心，并确保它们确实是必需的。
- en: Likewise, if we specify the `Inherits` member of the `FrameworkPropertyMetadataOptions`
    enumeration when registering our Dependency Property, we are effectively increasing
    the length of time that invalidation will take on the property. As such, we should
    ensure that this particular metadata member is only used when it is really necessary.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们注册依赖属性时指定了`FrameworkPropertyMetadataOptions`枚举的`Inherits`成员，那么实际上是在增加属性无效化所需的时间长度。因此，我们应该确保这个特定的元数据成员仅在真正需要时使用。
- en: One last metadata option that can improve the performance of the application
    is the `SubPropertiesDoNotAffectRender` member. If the type of our Dependency
    Property is a reference type, we can specify this enumeration member to stop the
    layout system from checking for changes to all sub-properties of the object, which
    it would otherwise do by default.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个可以改善应用程序性能的元数据选项是`SubPropertiesDoNotAffectRender`成员。如果我们的依赖属性类型是引用类型，我们可以指定这个枚举成员以阻止布局系统检查对象的所有子属性的变化，否则它将默认这样做。
- en: While we may need to call the `OverrideMetadata` method of the `DependencyProperty`
    class to override the metadata of the pre-existing properties in the .NET Framework,
    this comes with a small performance impact. When setting the metadata for our
    own custom Dependency Properties, we should always use the appropriate `Register`
    or `RegisterAttached` method to specify our requirements, as this offers far better
    performance.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可能需要调用`DependencyProperty`类的`OverrideMetadata`方法来覆盖.NET Framework中现有属性的元数据，但这会带来轻微的性能影响。当我们为我们的自定义依赖属性设置元数据时，我们应该始终使用适当的`Register`或`RegisterAttached`方法来指定我们的要求，因为这提供了更好的性能。
- en: Likewise, when registering our custom Dependency Properties, we should also
    set their default values using the relevant `Register` or `RegisterAttached` method
    as they are created, rather than initializing each instance individually in a
    constructor, or by using some other method.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当注册我们的自定义依赖属性时，我们也应该使用相关的`Register`或`RegisterAttached`方法设置它们的默认值，因为它们被创建时，而不是在构造函数中逐个实例化，或者使用其他方法。
- en: Binding to collections
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定到集合
- en: As you are most probably aware, when dealing with collections that will be updated
    in a WPF application, we tend to prefer using the generic `ObservableCollection<T>`
    class. The reason for this is because this class implements the `INotifyCollectionChanged`
    interface, which notifies listeners of changes to the collection, such as adding,
    removing, or clearing items.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所可能意识到的，当在WPF应用程序中处理将要更新的集合时，我们倾向于使用泛型的`ObservableCollection<T>`类。原因在于这个类实现了`INotifyCollectionChanged`接口，该接口会通知监听者集合的变化，例如添加、删除或清除项目。
- en: What we may not realize is the incredible performance improvement that we get
    from using this class to hold our data collections. When comparing this with the
    generic `List<T>` class, for example, we note that it does not automatically raise
    any collection changed event. In order to enable the View to display the updated
    collection, we need to reset it as the `ItemsSource` property value of the relevant
    collection control.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能没有意识到，使用此类来保存我们的数据集合可以带来惊人的性能提升。例如，与泛型的`List<T>`类相比，我们注意到它不会自动引发任何集合更改事件。为了使视图能够显示更新的集合，我们需要将其重置为相关集合控件的相关`ItemsSource`属性值。
- en: However, each time that the `ItemsSource` property is set, the data bound collection
    control will clear its current list of items and completely regenerate them again,
    which can be a time-consuming process. So, to add a single item to an `ObservableCollection<T>`
    takes approximately 20 milliseconds to render, but to reset the `ItemsSource`
    property value could take over 1.5 seconds.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每次设置`ItemsSource`属性时，数据绑定集合控件都会清除其当前的项目列表并完全重新生成它们，这可能会是一个耗时的过程。因此，向`ObservableCollection<T>`添加单个项目大约需要20毫秒来渲染，但重置`ItemsSource`属性值可能需要超过1.5秒。
- en: However, if our collection is immutable and we will not be altering it in any
    way, we do not need to use the generic `ObservableCollection<T>` class, as we
    have no need for its change handlers. Rather than wasting resources on unused
    change handlers, we can use a different type of collection class.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们的集合是不可变的，并且我们不会以任何方式更改它，我们就不需要使用泛型的`ObservableCollection<T>`类，因为我们不需要它的更改处理程序。与其浪费资源在未使用的更改处理程序上，我们可以使用不同类型的集合类。
- en: While there is not a preferred type of collection to use when data binding immutable
    collections to UI controls, we should try to avoid using the `IEnumerable` class
    as the collection container. This type cannot be used directly by the `ItemsControl`
    class, and, when it is used, the WPF Framework will generate a generic `IList<T>`
    collection to wrap the `IEnumerable` instance and this can also negatively affect
    performance.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当将不可变集合绑定到UI控件时，虽然没有首选的集合类型，但我们应尽量避免使用`IEnumerable`类作为集合容器。此类不能直接由`ItemsControl`类使用，并且当它被使用时，WPF框架将生成一个泛型的`IList<T>`集合来包装`IEnumerable`实例，这也可能对性能产生负面影响。
- en: In the next few sections, we'll explore other ways in which we can display large
    collections efficiently.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨其他我们可以高效显示大量集合的方法。
- en: Shrinking data objects
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩小数据对象
- en: Quite often, our applications will have fairly sizable data objects, with dozens,
    or even hundreds, of properties. If we were to load all of the properties for
    each data object when we have thousands of them, our application would slow down
    and possibly even run out of memory.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见，我们的应用程序将拥有相当大的数据对象，拥有数十个甚至数百个属性。如果我们有数千个这样的数据对象，并且为每个数据对象加载所有属性，我们的应用程序会变慢，甚至可能耗尽内存。
- en: We might think that we can save on RAM by simply not populating all of the property
    values; however, if we use the same classes, we'll soon find that even the default
    or empty values for these properties may consume too much memory. In general,
    and with a few exceptions, unset properties take the same amount of RAM as set
    properties.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会认为，如果我们简单地不填充所有属性值，就可以节省RAM；然而，如果我们使用相同的类，我们很快就会发现，即使是这些属性的默认值或空值也可能消耗太多的内存。一般来说，除了少数例外，未设置的属性与已设置的属性占用相同的RAM。
- en: If our data model object has a very large number of properties, one solution
    would be to break it down into much smaller pieces. For example, we could create
    a number of smaller, sub product classes, such as `ProductTechnicalSpecification`,
    `ProductDescription`, `ProductDimension`, `ProductPricing`, and more.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的数据模型对象具有非常多的属性，一个解决方案是将它分解成更小的部分。例如，我们可以创建多个较小的子产品类，如`ProductTechnicalSpecification`、`ProductDescription`、`ProductDimension`、`ProductPricing`等。
- en: Rather than building one giant View to edit the whole product, we could then
    provide a number of smaller Views, perhaps even accessible from different tabs
    within the same View. In this way, we would be able to just load the `ProductDescription`
    objects for the user to select from and then load the individual sections of the
    product in each sub View.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是构建一个巨大的视图来编辑整个产品，我们还可以提供多个较小的视图，可能甚至可以从同一视图的不同标签页中访问。这样，我们就可以只加载`ProductDescription`对象供用户选择，然后在每个子视图中加载产品的各个部分。
- en: There is a significant performance increase to be gained by this method, as
    binding to a single object with a great many properties can take up to four times
    longer than binding to a great many objects with fewer properties.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法可以获得显著的性能提升，因为绑定到一个具有许多属性的单一对象可能需要比绑定到具有较少属性的许多对象多四倍的时间。
- en: One alternative to breaking our data objects into smaller pieces would be to
    use the concept of thin data objects. For example, imagine that our `Product`
    class had dozens of properties and that we had thousands of products. We could
    create a `ThinProduct` class that contains only the properties that would be used
    to identify the full data object to load when selected and those displayed in
    the product collection.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的数据对象拆分成更小的部分的一个替代方案是使用瘦数据对象的概念。例如，假设我们的`Product`类有数十个属性，而我们有成千上万的产品。我们可以创建一个只包含用于识别在选中时加载的完整数据对象以及显示在产品集合中的属性的`ThinProduct`类。
- en: In this case, we might simply need two properties in our `ThinProduct` class,
    a unique identification property, and a display name property. In this way, we
    can reduce the memory footprint of our products by a factor of 10 or even more.
    This means that they can be loaded from the database and displayed in a fraction
    of the time of the full `Product` objects.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可能只需要在`ThinProduct`类中设置两个属性，一个唯一的标识属性和一个显示名称属性。这样，我们可以将产品的内存占用减少10倍甚至更多。这意味着它们可以从数据库中加载并在极短的时间内显示，比完整的`Product`对象快得多。
- en: 'In order to facilitate easy transferal between the `Product` and `ThinProduct`
    classes, we can add constructors into each class that accepts the other type and
    updates the relevant properties:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便在`Product`和`ThinProduct`类之间进行数据传输，我们可以在每个类中添加构造函数，该构造函数接受另一个类型并更新相关属性：
- en: '[PRE31]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The properties in this `ThinProduct` class basically mirror those from the
    `Product` class that we saw earlier, but only the ones that are used to identify
    each instance. A constructor is added that takes an input parameter of type `Product`
    to enable easy transferal between the two. A similar constructor is added to the
    `Product` class, but takes an input parameter of type `ThinProduct`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`ThinProduct`类中的属性基本上反映了我们之前看到的`Product`类中的属性，但只是用于识别每个实例的属性。添加了一个构造函数，它接受一个类型为`Product`的输入参数，以实现两个类之间的轻松转换。类似的构造函数也添加到`Product`类中，但它接受一个类型为`ThinProduct`的输入参数：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The idea is that we have a View Model that displays a large number of products
    and in code, we actually load a large number of these much lighter `ThinProduct`
    instances. When the user selects one of the products to view or edit, we use the
    identification number of the selected item to then load the full `Product` object
    that relates to that identifier.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是我们有一个视图模型，它显示大量产品，在代码中，我们实际上加载了大量这些更轻的 `ThinProduct` 实例。当用户选择一个产品进行查看或编辑时，我们使用所选项目的标识号来加载与该标识符相关的完整
    `Product` 对象。
- en: 'Given a base collection of these `ThinProduct` instances in a property named
    `Products`, we could achieve this as follows. First, let''s bind our collection
    to a `ListBox` control:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个名为 `Products` 的属性中的这些 `ThinProduct` 实例的基础集合，我们可以这样实现。首先，让我们将我们的集合绑定到一个 `ListBox`
    控件上：
- en: '[PRE33]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When the user selects a product from the list, the collection's `CurrentItem`
    property will hold a reference to the selected item. If we attach a handler to
    the collection's `CurrentItemChanged` delegate when it is first loaded, we can
    be notified when the item is selected.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户从列表中选择一个产品时，集合的 `CurrentItem` 属性将持有所选项目的引用。如果我们在一开始加载集合时将其 `CurrentItemChanged`
    代理附加到一个处理程序上，我们就可以在项目被选中时得到通知。
- en: 'At that point, we can load the full `Product` object using the identifier from
    the selected `ThinProduct` instance and output the associated feedback to the
    user:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以使用所选 `ThinProduct` 实例的标识符来加载完整的 `Product` 对象，并将相关的反馈输出给用户：
- en: '[PRE34]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the next section, we'll find out how we can display our large collections
    more efficiently using collection controls, rather than having to break up our
    large classes into smaller classes or create associated thin data objects.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解如何使用集合控件更有效地显示我们的大量集合，而不是将我们的大型类拆分成更小的类或创建相关联的轻量级数据对象。
- en: Virtualizing collections
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟化集合
- en: When we display large numbers of items in our collection controls, it can negatively
    affect the application's performance. This is because the layout system will create
    a layout container, such as a `ComboBoxItem` in the case of a `ComboBox`, for
    example, for every item in the data bound collection. As only a small subset of
    the complete number of items is displayed at any one time, we can take advantage
    of virtualization to improve the situation.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在集合控件中显示大量项目时，可能会对应用程序的性能产生负面影响。这是因为布局系统将为数据绑定集合中的每个项目创建一个布局容器，例如，在 `ComboBox`
    的情况下，创建一个 `ComboBoxItem`。由于在任何时候只显示完整项目数的一小部分，我们可以利用虚拟化来改善这种情况。
- en: UI virtualization defers the generation and layout of these item containers
    until each item is actually visible in the relevant collection control, often
    saving on large amounts of resources. We can take advantage of virtualization
    without doing anything at all if we use `ListBox` or `ListView` controls to display
    our collections, as they use it by default.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: UI 虚拟化将生成和布局这些项目容器推迟到每个项目实际上在相关集合控件中可见时，通常可以节省大量资源。如果我们使用 `ListBox` 或 `ListView`
    控件来显示我们的集合，我们可以利用虚拟化而不必做任何事情，因为它们默认使用它。
- en: 'Virtualization can also be enabled in `ComboBox`, `ContextMenu`, and `TreeView`
    controls, although it will have to be done manually. When using a `TreeView` control,
    we can enable virtualization by simply setting the `VirtualizingStackPanel.IsVirtualizing` Attached
    Property to `True` on it:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ComboBox`、`ContextMenu` 和 `TreeView` 控件中也可以启用虚拟化，尽管这需要手动完成。当使用 `TreeView`
    控件时，我们可以通过将 `VirtualizingStackPanel.IsVirtualizing` 附加属性设置为 `True` 来启用虚拟化：
- en: '[PRE35]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For other controls that use the `StackPanel` class internally, such as the
    `ComboBox` and `ContextMenu` controls, we can enable virtualization by setting
    an `ItemsPanelTemplate` element hosting an instance of the `VirtualizingStackPanel`
    class with its `IsVirtualizing` property set to `True` to its `ItemsPanel` property:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内部使用 `StackPanel` 类的其他控件，例如 `ComboBox` 和 `ContextMenu` 控件，我们可以通过将一个包含 `VirtualizingStackPanel`
    类实例的 `ItemsPanelTemplate` 元素设置为 `ItemsPanel` 属性，并将它的 `IsVirtualizing` 属性设置为 `True`
    来启用虚拟化：
- en: '[PRE36]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Apart from setting the `IsVirtualizing` property to `False`, there are a few
    other reasons why UI virtualization may not work. One case is when item containers
    have manually been added to an `ItemsControl` object or one of its derived controls.
    Another case is when the item containers are of different types.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将 `IsVirtualizing` 属性设置为 `False` 之外，还有其他一些原因可能导致 UI 虚拟化不起作用。一种情况是项目容器已被手动添加到
    `ItemsControl` 对象或其派生控件中。另一种情况是项目容器具有不同的类型。
- en: The final reason why virtualization may not work is not so obvious and relates
    to the `CanContentScroll` property of the `ScrollViewer` class. This is an interesting
    property that specifies whether the `ScrollViewer` in a collection control will
    scroll its items in logical units or physical units. The default value is `False`,
    which smoothly scrolls in terms of physical units.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化可能不起作用的最后一个原因并不那么明显，它与`ScrollViewer`类的`CanContentScroll`属性有关。这是一个有趣的属性，它指定了集合控件中的`ScrollViewer`是否将以逻辑单位或物理单位滚动其项。默认值是`False`，这意味着以物理单位平滑滚动。
- en: Physical units relate to the device-independent pixels that WPF works with,
    while logical units relate to the widths or heights of the collection items, depending
    on the orientation of the control. As the default value of the `CanContentScroll`
    property is `False`, this will need to be set to `True` to enable virtualization.
    This is so that scrolling is performed item by item and not pixel by pixel.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 物理单位与WPF工作的设备无关像素相关，而逻辑单位与集合项的宽度或高度相关，这取决于控件的方向。由于`CanContentScroll`属性的默认值是`False`，因此需要将其设置为`True`以启用虚拟化。这样，滚动是逐项进行的，而不是逐像素进行的。
- en: When virtualization is employed in a collection control that extends the `ItemsControl`
    class and the user scrolls, new item containers are created for the newly visible
    items and the containers for the items that are no longer visible are disposed
    of.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当在扩展`ItemsControl`类的集合控件中使用虚拟化，并且用户滚动时，会为新的可见项创建新的项容器，并且不再可见的项的容器将被销毁。
- en: 'In version 3.5 of the .NET Framework, an optimization of the virtualization
    system was introduced. Container recycling enables the collection control to reuse
    the item containers, instead of creating new ones and disposing of old ones as
    the user scrolls. This offers an additional performance benefit and can be enabled
    by setting the `VirtualizationMode` Attached Property to a value of `Recycling`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Framework 3.5版本中，引入了对虚拟化系统的优化。容器回收使集合控件能够重用项容器，而不是在用户滚动时创建新的容器并丢弃旧的容器。这提供了额外的性能优势，可以通过将`VirtualizationMode`附加属性设置为`Recycling`值来启用：
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: One further optimization that WPF provides us with is deferred scrolling. Normally,
    scrolling in a collection control continuously updates the UI. However, if our
    data items or their item containers have several layers of visuals that define
    them and scrolling is slow, we can opt to defer the UI update until scrolling
    has finished.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: WPF为我们提供的另一个进一步优化是延迟滚动。通常，在集合控件中滚动会持续更新UI。然而，如果我们的数据项或它们的项容器有多个定义它们的视觉层，并且滚动速度较慢，我们可以选择将UI更新延迟到滚动完成。
- en: 'In order to enable deferred scrolling on a collection control, we need to set
    the `ScrollViewer.IsDeferredScrollingEnabled` Attached Property to `True`. Although
    we don''t generally use `ScrollViewer` elements in XAML directly, we can also
    attach this property to collection controls that host a `ScrollViewer` element
    in their control templates:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在集合控件上启用延迟滚动，我们需要将`ScrollViewer.IsDeferredScrollingEnabled`附加属性设置为`True`。尽管我们通常不在XAML中直接使用`ScrollViewer`元素，但我们也可以将此属性附加到在其控件模板中包含`ScrollViewer`元素的集合控件上：
- en: '[PRE38]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We've now investigated performance improvements that we can make with computer
    hardware, resources, correct control selection, methods of drawing and displaying
    images, outputting text, linking, data binding, minimizing memory footprints,
    and data virtualization. There is just one more essential area to look at, that
    is, events, so let's look at that next.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经调查了我们可以通过计算机硬件、资源、正确的控件选择、绘制和显示图像的方法、输出文本、链接、数据绑定、最小化内存占用以及数据虚拟化来实现的性能改进。只有一个关键领域需要考虑，那就是事件，所以让我们看看下一个。
- en: Handling events
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理事件
- en: One of the most common causes of memory leaks appearing in an application is
    the failure to remove event handlers once they are no longer needed. When we attach
    an event handler to an object's event in the usual way, we are effectively passing
    that object a reference to the handler and creating a hard reference to it.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中出现内存泄漏的最常见原因之一是未能移除不再需要的处理程序。当我们以常规方式将事件处理程序附加到对象的某个事件上时，我们实际上是在向该对象传递处理程序的引用，并为其创建了一个硬引用。
- en: When the object is no longer needed and could otherwise be disposed of, the
    reference in the object that raises the event will prevent that from occurring.
    This is because the garbage collector cannot collect an object that can be accessed
    from any part of the application code. In the worst-case scenario, the object
    being kept alive may contain numerous other objects and, therefore, inadvertently
    keep them alive as well.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象不再需要且可能被释放时，引发事件的那个对象中的引用将阻止这种情况发生。这是因为垃圾收集器无法收集可以从应用程序代码的任何部分访问的对象。在最坏的情况下，保持对象存活可能包含许多其他对象，因此无意中也将它们保持存活。
- en: The problem with this is that keeping objects alive after they are no longer
    needed will unnecessarily increase the memory footprint of the application, in
    some cases, with dramatic and irreversible consequences, leading to an `OutOfMemoryException`
    being thrown. It is, therefore, essential that we detach our event handlers from
    the events that they are subscribed to in objects that we have no further use
    for before trying to dispose of them.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在于，在对象不再需要后继续保持对象存活将无谓地增加应用程序的内存占用，在某些情况下，会有戏剧性和不可逆转的后果，导致抛出 `OutOfMemoryException`。因此，在尝试释放它们之前，从我们不再使用的对象中移除我们订阅的事件的事件处理器是至关重要的。
- en: There is, however, an alternative method that we can use to avoid this situation.
    In the .NET Framework, there is a `WeakReference` class and it can be used to
    remove the hard references caused by attaching event handlers to events using
    the traditional method.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个替代方法可以用来避免这种情况。在 .NET Framework 中，有一个 `WeakReference` 类，它可以用来移除使用传统方法将事件处理器附加到事件所引起的硬引用。
- en: 'The basic idea is that the class that raises the event should maintain a collection
    of `WeakReference` instances and add to it each time another class attaches an
    event handler to the event. Let''s now create a new `WeakReferenceActionCommand`
    class from our `ActionCommand` class from earlier to use this `WeakReference`
    class:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的想法是，引发事件的类应该维护一个 `WeakReference` 实例的集合，并在另一个类将事件处理器附加到事件时将其添加到该集合中。现在，让我们从之前创建的
    `ActionCommand` 类中创建一个新的 `WeakReferenceActionCommand` 类，以使用这个 `WeakReference`
    类：
- en: '[PRE39]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We start by adding a declaration of our new collection containing objects of
    the `WeakReference` type to the pre-existing fields. The two constructors remain
    unchanged, but when attaching handlers in the `CanExecuteChanged` event, we now
    wrap the event handling delegate in a `WeakReference` object and add it to the
    collection. We still need to pass the references to the handlers that get attached
    through to the `RequerySuggested` event of the `CommandManager` class as before.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将我们的新集合的声明添加到现有的字段中，该集合包含 `WeakReference` 类型的对象。两个构造函数保持不变，但在 `CanExecuteChanged`
    事件中附加处理器时，我们现在将事件处理委托包装在一个 `WeakReference` 对象中，并将其添加到集合中。我们仍然需要像之前一样将附加到处理器上的引用传递到
    `CommandManager` 类的 `RequerySuggested` 事件。
- en: When an event handler is removed, we first double-check that our `WeakReference`
    collection is not `null` and simply return control to the caller if it is. If
    not, we use a `for` loop to iterate through the collection in reverse so that
    we can remove items without affecting the loop index.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当移除事件处理器时，我们首先检查我们的 `WeakReference` 集合是否不是 `null`，如果是，则简单地返回控制权给调用者。如果不是，我们使用一个
    `for` 循环以相反的顺序遍历集合，这样我们就可以在不影响循环索引的情况下移除项目。
- en: We attempt to access the actual event handler from the `Target` property of
    each `WeakReference` object in turn, converting it to the `EventHandler` base
    type using the `as` keyword. We then remove the `WeakReference` instance if its
    event handler reference is either `null` or it matches the handler being removed.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们依次尝试从每个 `WeakReference` 对象的 `Target` 属性中访问实际的事件处理器，使用 `as` 关键字将其转换为 `EventHandler`
    基类型。然后，如果其事件处理器引用是 `null` 或与正在移除的处理程序匹配，我们就移除该 `WeakReference` 实例。
- en: Note that a `null` reference in the `Target` property would be the result of
    an event handler from a class that has been disposed of by the garbage collector.
    As before, we then also detach the event handler from the `CommandManager.RequerySuggested` event.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Target` 属性中的 `null` 引用将是垃圾收集器已处理掉的一个类的事件处理器的结果。和之前一样，我们随后也会从 `CommandManager.RequerySuggested`
    事件中移除该事件处理器。
- en: Finally, we need to update our `RaiseCanExecuteChanged` method to use our new
    collection of `WeakReference` objects. In it, we again iterate through each instance
    in the collection using our `ForEach` Extension Method and after checking whether
    its `Target` property is `null` by using the null conditional operator, call it
    using the delegate's `Invoke` method.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新我们的`RaiseCanExecuteChanged`方法，以便使用我们新的`WeakReference`对象集合。在其中，我们再次使用我们的`ForEach`扩展方法遍历集合中的每个实例，并使用空条件运算符检查其`Target`属性是否为`null`，然后通过委托的`Invoke`方法调用它。
- en: So, the idea here is that we no longer directly hold on to any references to
    the attached event handlers and are, therefore, free to dispose of those classes
    at any point without fear of them being kept alive unnecessarily.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的想法是我们不再直接持有任何对附加事件处理程序的引用，因此我们可以随时自由地处置这些类，而不用担心它们被不必要地保留。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored a number of options that we can use to increase
    the performance of our WPF applications. As we have now seen, this is more a case
    of making a large number of little changes to gain an overall noticeable performance
    benefit.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了我们可以使用的多种选项来提高我们的WPF应用程序的性能。正如我们所看到的，这更多的是通过进行大量的小改动来获得整体明显的性能提升。
- en: We saw that we can utilize the graphics rendering power of our computer's graphics
    card and declare our resources more efficiently. We investigated ways to improve
    our application's performance using lighter-weight UI controls and more efficient
    methods of rendering drawings, images, and text. We also learned how to data bind,
    display large objects and collections, and handle events with improved performance.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们可以利用计算机图形卡的图形渲染能力，并更有效地声明资源。我们研究了使用更轻量级的UI控件和更高效的渲染绘图、图像和文本的方法来提高我们应用程序的性能。我们还学习了如何进行数据绑定、显示大型对象和集合，以及以改进的性能处理事件。
- en: In the next chapter, we will investigate the final requirement for all professional
    applications, that is, deployment. In it, we will first cover the older method,
    using the Windows Installer software, and then progress to investigate the more
    common and up-to-date method, that is, using ClickOnce functionality.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨所有专业应用最终的需求，即部署。在其中，我们首先将介绍较老的方法，即使用Windows Installer软件，然后进一步研究更常见且更新的方法，即使用ClickOnce功能。
