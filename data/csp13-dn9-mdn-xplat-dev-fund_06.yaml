- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Implementing Interfaces and Inheriting Classes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现接口和继承类
- en: This chapter is about deriving new types from existing ones using **object-oriented
    programming** (**OOP**). You will learn how to use operators as an alternative
    method to implement simple functionality, and you will learn how to use generics
    to make your code safer and more performant. You will learn about delegates and
    events to exchange messages between types. You will implement interfaces for common
    functionality. You will create a derived class to inherit from a base class to
    reuse functionality, override an inherited type member, and use polymorphism.
    Finally, you will learn how to create extension methods and cast between classes
    in an inheritance hierarchy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍如何使用面向对象编程（**OOP**）从现有类型派生出新类型。您将学习如何使用运算符作为实现简单功能的一种替代方法，以及如何使用泛型使代码更安全、性能更高。您将了解委托和事件在类型之间交换消息。您将实现接口以实现常见功能。您将创建一个派生类从基类继承功能，重写继承的类型成员，并使用多态。最后，您将学习如何创建扩展方法和在继承层次结构中类之间的转换。
- en: In an online-only section, you will see the differences between reference and
    value types and how they are stored in memory. You will find links to online materials
    at the end of this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在仅在线部分，您将看到引用类型和值类型之间的区别以及它们如何在内存中存储。您将在本章末尾找到在线材料的链接。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Setting up a class library and console application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置类库和控制台应用程序
- en: Static methods and overloading operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法和运算符重载
- en: Making types safely reusable with generics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型安全地使类型可重用
- en: Raising and handling events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出和处理事件
- en: Implementing interfaces
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现接口
- en: Working with `null` values
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 `null` 值
- en: Inheriting from classes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从类继承
- en: Casting within inheritance hierarchies
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在继承层次结构中进行转换
- en: Inheriting and extending .NET types
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承和扩展 .NET 类型
- en: Summarizing custom type choices
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结自定义类型选择
- en: Setting up a class library and console application
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置类库和控制台应用程序
- en: 'We will start by defining a solution with two projects, like the one created
    in *Chapter 5*, *Building Your Own Types with Object-Oriented Programming*. Even
    if you completed all the exercises in that chapter, follow the instructions below
    so that you start this chapter with fresh working projects:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个包含两个项目的解决方案，就像在 *第5章*，*使用面向对象编程构建自己的类型* 中创建的那样。即使您完成了该章节的所有练习，也请遵循以下说明，以便您以全新的工作项目开始本章：
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器创建一个新项目，如下面的列表所示：
- en: 'Project template: **Class Library** / `classlib`'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**类库** / `classlib`
- en: 'Project file and folder: `PacktLibrary`'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`PacktLibrary`
- en: 'Solution file and folder: `Chapter06`'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter06`
- en: 'Framework: .NET 9.0 (Standard-Term Support)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架：.NET 9.0（标准支持期）
- en: 'Add a new project, as defined in the following list:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新项目，如下面的列表所示：
- en: 'Project template: **Console App** / `console`'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Project file and folder: `PeopleApp`'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`PeopleApp`
- en: 'Solution file and folder: `Chapter06`'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter06`
- en: 'Framework: .NET 9.0 (Standard-Term Support)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架：.NET 9.0（标准支持期）
- en: 'Do not use top-level statements: Cleared'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用顶级语句：已清除
- en: 'Enable native AOT publish: Cleared'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用原生AOT发布：已清除
- en: In this chapter, both projects target .NET 9 and, therefore, use the C# 13 compiler
    by default.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，两个项目都针对 .NET 9，因此默认使用 C# 13 编译器。
- en: In the `PacktLibrary` project, rename the file named `Class1.cs` to `Person.cs`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PacktLibrary` 项目中，将名为 `Class1.cs` 的文件重命名为 `Person.cs`。
- en: 'In both projects, add `<ItemGroup>` to globally and statically import the `System.Console`
    class, as shown in the following markup:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个项目中，添加 `<ItemGroup>` 以全局和静态导入 `System.Console` 类，如下面的标记所示：
- en: '[PRE0]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In `Person.cs`, delete any existing statements and define a `Person` class,
    as shown in the following code:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 中，删除任何现有的语句并定义一个 `Person` 类，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `PeopleApp` project, add a project reference to `PacktLibrary`, as shown
    in the following markup:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PeopleApp` 项目中，添加对 `PacktLibrary` 的项目引用，如下面的标记所示：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In `Program.cs`, delete the existing statements, write statements to create
    an instance of `Person`, and then write information about it to the console, as
    shown in the following code:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，删除现有的语句，编写语句创建 `Person` 实例，然后将相关信息写入控制台，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you use Visual Studio, configure the startup project for the solution as
    the current selection.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用Visual Studio，请将解决方案的启动项目配置为当前选择。
- en: 'Run the `PeopleApp` project and note the result, as shown in the following
    output:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`PeopleApp`项目并注意结果，如下所示输出：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Static methods and overloading operators
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态方法和运算符重载
- en: This section is specifically about methods that apply to two instances of the
    same type. It is not about the more general case of methods that apply to zero,
    one, or more than two instances. Remember that static methods do not require an
    object instance. They are called directly using the class name.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本节专门讨论适用于同一类型两个实例的方法。它不是关于更一般的情况，即适用于零个、一个或多个实例的方法。请记住，静态方法不需要对象实例。它们可以直接使用类名来调用。
- en: I wanted to think of some methods that would apply to two `Person` instances
    that could also become binary operators, like `+` and `*`. What would adding two
    people together represent? What would multiplying two people represent? The obvious
    answers are getting married and having babies.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我想想出一些适用于两个`Person`实例的方法，这些方法也可以成为二元运算符，如`+`和`*`。将两个人相加代表什么？将两个人相乘代表什么？明显的答案就是结婚和生孩子。
- en: 'We will design our methods to enable us to model the story of Lamech and his
    two wives and their children, as described at the following link:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计我们的方法，以便我们可以模拟拉麦和他的两位妻子及其子女的故事，如下链接所述：
- en: '[https://www.kingjamesbibleonline.org/Genesis-4-19/](https://www.kingjamesbibleonline.org/Genesis-4-19/)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.kingjamesbibleonline.org/Genesis-4-19/](https://www.kingjamesbibleonline.org/Genesis-4-19/)'
- en: We might want two instances of `Person` to be able to marry and procreate. We
    can implement this by writing methods and overriding operators. Instance methods
    are actions that an object does to itself; static methods are actions the type
    does.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望两个`Person`实例能够结婚并生育。我们可以通过编写方法和重载运算符来实现这一点。实例方法是对象对自己执行的操作；静态方法是类型执行的操作。
- en: Which you choose depends on what makes the most sense for the action.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择哪种取决于哪种方式对操作来说最有意义。
- en: '**Good Practice**: Having both static and instance methods to perform similar
    actions often makes sense. For example, `string` has both a `Compare` static method
    and a `CompareTo` instance method. This puts the choice of how to use the functionality
    in the hands of the programmers using your type, giving them more flexibility.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：拥有静态和实例方法来执行类似操作通常是有意义的。例如，`string`既有`Compare`静态方法，也有`CompareTo`实例方法。这把如何使用功能的选择权交给了使用您类型的程序员，给了他们更多的灵活性。'
- en: Implementing functionality using methods
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用方法实现功能
- en: 'Let’s start by implementing some functionality by using both static and instance
    methods:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先通过使用静态和实例方法来实现一些功能：
- en: 'In `Person.cs`, add properties with private backing storage fields to indicate
    if that person is married and to whom, as shown in the following code:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加具有私有后备存储字段的属性，以指示该人是否已婚以及与谁结婚，如下所示代码：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In `Person.cs`, add one instance method and one static method that will allow
    two `Person` objects to marry, as shown in the following code:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加一个实例方法和一个静态方法，允许两个`Person`对象结婚，如下所示代码：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: In the `static` method, the `Person` objects are passed as parameters named
    `p1` and `p2`, and guard clauses are used to check for `null` values. If either
    is already married to the other, an exception is thrown; otherwise, they are each
    added to each other’s list of spouses. You can model this differently if you want
    to allow two people to have multiple marriage ceremonies. In that case, you might
    choose to not throw an exception and instead do nothing. Their state of marriage
    would remain the same. Additional calls to `Marry` would not change if they are
    married or not. In this scenario, I want you to see that the code recognizes that
    they are already married by throwing an exception.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`static`方法中，`Person`对象作为名为`p1`和`p2`的参数传递，并使用保护子句来检查`null`值。如果其中任何一个已经与对方结婚，则抛出异常；否则，它们各自被添加到对方的配偶列表中。如果您想允许两个人有多次婚礼，您可以采取不同的建模方式。在这种情况下，您可能选择不抛出异常，而是什么都不做。他们的婚姻状态将保持不变。如果他们已婚或未婚，额外的`Marry`调用不会改变。在这个场景中，我想让您看到代码通过抛出异常来识别他们已经结婚。
- en: In the instance method, a call is made to the `static` method, passing the current
    person (`this`) and the `partner` they want to marry.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实例方法中，调用`static`方法，传递当前的人（`this`）和他们想要结婚的伴侣。
- en: '**Warning!** Although instance methods can call static methods, the opposite
    is not true. A static method cannot call an instance method because there isn’t
    an object instance to call it on.'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**警告**！尽管实例方法可以调用静态方法，但反之则不然。静态方法不能调用实例方法，因为没有对象实例可以调用它。'
- en: 'In `Person.cs`, add an instance method to the `Person` class that will output
    the spouses of a person if they are married, as shown in the following code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 中，向 `Person` 类添加一个实例方法，该方法可以输出已婚的人的配偶，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In `Person.cs`, add one instance method and one static method to the `Person`
    class that will allow two `Person` objects to procreate if they are married to
    each other, as shown in the following code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 中，向 `Person` 类添加一个实例方法和一个静态方法，使得两个 `Person` 对象如果彼此结婚，就可以繁殖，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下事项：
- en: In the `static` method named `Procreate`, the `Person` objects that will procreate
    are passed as parameters named `p1` and `p2`.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在名为 `static` 的 `Procreate` 方法中，将要繁殖的 `Person` 对象作为名为 `p1` 和 `p2` 的参数传递。
- en: A new `Person` class named `baby` is created with a name composed of a combination
    of the two people who have procreated. This could be changed later by setting
    the returned `baby` variable’s `Name` property. Although we could add a third
    parameter to the `Procreate` method for the baby name, we will define a binary
    operator later, and they cannot have third parameters. So, for consistency, we
    will just return the baby reference and let the calling code set the name of it.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个名为 `baby` 的新 `Person` 类，其名称由繁殖的两个人的名字组合而成。这可以通过设置返回的 `baby` 变量的 `Name`
    属性来稍后更改。虽然我们可以在 `Procreate` 方法中添加一个用于婴儿名字的第三个参数，但我们将在稍后定义一个二元运算符，它们不能有第三个参数。因此，为了保持一致性，我们只返回婴儿引用，并让调用代码设置它的名字。
- en: The `baby` object is added to the `Children` collection of both parents and
    then returned. Classes are reference types, meaning a reference to the `baby`
    object stored in memory is added, not a clone of the `baby` object.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baby` 对象被添加到父母的 `Children` 集合中，然后返回。类是引用类型，这意味着在内存中存储的 `baby` 对象的引用被添加，而不是
    `baby` 对象的克隆。'
- en: In the instance method named `ProcreateWith`, the `Person` object to procreate
    with is passed as a parameter named `partner`, and that, along with `this`, which
    represents the current object, is passed to the static `Procreate` method to reuse
    the method implementation. `this` is a keyword that references the current instance
    of the class. It is a convention to use different method names for related static
    and instance methods, but not to the extent that you would fail to match standard
    English meaning.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在名为 `ProcreateWith` 的实例方法中，要繁殖的 `Person` 对象作为名为 `partner` 的参数传递，并且与 `this` 一起传递给静态
    `Procreate` 方法以重用方法实现。`this` 是一个关键字，引用类的当前实例。使用不同的方法名对于相关的静态和实例方法是一种约定，但不要到无法匹配标准英语意义的地步。
- en: So, that could mean naming both methods the same, as in the example of `Marry(x,
    y)` for the static method name and `x.Marry(y)` for the instance method name.
    More commonly, it would mean using a different method name, for example, `Procreate(x,
    y)` for the static method name and `x.ProcreateWith(y)` for the instance method
    name, or `Compare(x, y)` for the static method name and `x.CompareTo(y)` for the
    instance method name.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这可能意味着将两个方法命名为相同，例如，静态方法名为 `Marry(x, y)`，实例方法名为 `x.Marry(y)`。更常见的是，这意味着使用不同的方法名，例如，静态方法名为
    `Procreate(x, y)`，实例方法名为 `x.ProcreateWith(y)`，或者静态方法名为 `Compare(x, y)`，实例方法名为
    `x.CompareTo(y)`。
- en: '**Good Practice**: A method that creates a new object, or modifies an existing
    object, should return a reference to that object so that the caller can access
    the results.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：创建新对象或修改现有对象的方法应该返回对该对象的引用，以便调用者可以访问结果。'
- en: '5\. In `Program.cs`, create three people and have them marry and then procreate
    with each other, noting that to add a double-quote character into a `string`,
    you must prefix it with a backslash character like this, `\"`, as shown in the
    following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 在 `Program.cs` 中，创建三个人，让他们结婚并相互繁殖，注意要在 `string` 中添加一个双引号字符，必须使用反斜杠字符作为前缀，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I used a `for` instead of a `foreach` statement so that I could use the `i`
    variable with the indexer to access each child.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 `for` 循环而不是 `foreach` 语句，这样我就可以使用 `i` 变量通过索引器访问每个孩子。
- en: '6\. Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 运行 `PeopleApp` 项目并查看结果，如下面的输出所示：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you have just seen, for functionality that applies to two instances of an
    object type, it is easy to provide both static and instance methods to implement
    the same functionality. Neither static nor instance methods are best in all scenarios,
    and you cannot predict how your type might be used. It is best to provide both
    to allow a developer to use your types in the way that best fits their needs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，对于适用于对象类型两个实例的功能，很容易提供静态和实例方法来实现相同的功能。在所有情况下，静态或实例方法都不是最好的，你无法预测你的类型可能会如何被使用。最好两者都提供，以便开发者能够以最适合他们需求的方式使用你的类型。
- en: Now let’s see how we can add a third way to provide the same functionality for
    two instances of a type.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何为同一类型的两个实例添加第三种提供相同功能的方法。
- en: Implementing functionality using operators
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用操作符实现功能
- en: 'The `System.String` class has a `static` method named `Concat` that concatenates
    two `string` values and returns the result, as shown in the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.String` 类有一个名为 `Concat` 的 `static` 方法，它将两个 `string` 值连接起来并返回结果，如下面的代码所示：'
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Calling a method like `Concat` works, but it might be more natural for a programmer
    to use the `+` symbol operator to “add” two `string` values together, as shown
    in the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个像 `Concat` 这样的方法是可以的，但可能对程序员来说，使用 `+` 符号操作符将两个 `string` 值“相加”会更自然，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A well-known biblical phrase is *Go forth and multiply*, meaning to procreate.
    Let’s write code so that the `*` (multiply) symbol will allow two `Person` objects
    to procreate. And we will use the `+` operator to marry two people.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个著名的圣经短语是 *Go forth and multiply*，意味着繁殖。让我们编写代码，使 `*`（乘法）符号允许两个 `Person` 对象繁殖。我们将使用
    `+` 操作符来结婚两个人。
- en: 'We do this by defining a `static` operator for the `*` symbol. The syntax is
    rather like a method, because in effect, an operator *is* a method, but it uses
    a symbol instead of a method name, which makes the syntax more concise:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过为 `*` 符号定义一个 `static` 操作符来实现这一点。语法相当像方法，因为实际上操作符 * 确实是一个方法，但它使用符号而不是方法名，这使得语法更简洁：
- en: 'In `Person.cs`, create a `static` operator for the `+` symbol, as shown in
    the following code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 中，为 `+` 符号创建一个 `static` 操作符，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The return type for an operator does not need to match the types passed as parameters
    to the operator, but the return type cannot be `void`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符的返回类型不需要与操作符参数的类型匹配，但返回类型不能是 `void`。
- en: 'In `Person.cs`, create a `static` operator for the `*` symbol, as shown in
    the following code:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 中，为 `*` 符号创建一个 `static` 操作符，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Good Practice**: Unlike methods, operators do not appear in IntelliSense
    lists for a type or a type instance when you enter a dot (`.`). For every operator
    that you define, make a method as well, because it may not be obvious to a programmer
    that the operator is available. The implementation of the operator can then call
    the method, reusing the code you have written. A second reason to provide a method
    is that operators are not supported by every language compiler; for example, although
    arithmetic operators like `*` are supported by Visual Basic and F#, there is no
    requirement that other languages support all operators supported by C#. You have
    to read the type definition or the documentation to discover whether operators
    are implemented.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：与方法不同，当你输入点号（`.`）时，操作符不会出现在类型或类型实例的 IntelliSense 列表中。对于你定义的每个操作符，都要创建一个方法，因为程序员可能不会明显地意识到操作符是可用的。然后操作符的实现可以调用该方法，重用你编写的代码。提供方法的第二个原因是，并非所有语言编译器都支持操作符；例如，尽管
    `*` 这样的算术操作符在 Visual Basic 和 F# 中受支持，但并没有要求其他语言支持 C# 支持的所有操作符。你必须阅读类型定义或文档来发现是否实现了操作符。'
- en: 'In `Program.cs`, comment out the statement that calls the static `Marry` method
    to marry Zillah and Lamech, and replace it with an `if` statement that uses the
    `+` operator to marry them, as shown in the following code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，注释掉调用静态 `Marry` 方法的语句，并用一个使用 `+` 操作符将他们结婚的 `if` 语句替换它，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In `Program.cs`, after calling the `Procreate` method and before the statements
    that write the children to the console, use the `*` operator for Lamech to have
    two more babies with his wives, Adah and Zillah, as highlighted in the following
    code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，在调用 `Procreate` 方法并在将子代写入控制台语句之前，使用 `*` 操作符让拉麦和他的妻子亚达和西拉再有两个孩子，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下面的输出所示：
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**More Information**: To learn more about operator overloading, you can read
    the documentation at the following link:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：要了解更多关于运算符重载的信息，你可以阅读以下链接中的文档：'
- en: '[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading)'
- en: Making types safely reusable with generics
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型安全地重用类型
- en: In 2005, with C# 2 and .NET Framework 2, Microsoft introduced a feature named
    **generics**, which enables your types to be more safely reusable and efficient.
    It does this by allowing a programmer to pass types as parameters, like how you
    can pass objects as parameters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在2005年，随着C# 2和.NET Framework 2的推出，微软引入了一个名为**泛型**的功能，这使得你的类型可以更安全地重用和高效。它是通过允许程序员传递类型作为参数来实现的，就像你可以传递对象作为参数一样。
- en: This topic is only about types that need to provide flexibility for the types
    they work with. For example, collection types need to be able to store multiple
    instances of any type. That flexibility can be provided either by using the `System.Object`
    type or generics. For other scenarios that do not need type flexibility, the use
    of non-generic types is good practice.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本主题仅关于需要为其所处理的类型提供灵活性的类型。例如，集合类型需要能够存储任何类型的多个实例。这种灵活性可以通过使用`System.Object`类型或泛型来实现。对于不需要类型灵活性的其他场景，使用非泛型类型是良好的实践。
- en: Working with non-generic types
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用非泛型类型
- en: First, let’s look at an example of working with a non-generic type so that you
    can understand the problems that generics are designed to solve, such as weakly
    typed parameters and values, and performance problems caused by using `System.Object`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看使用非泛型类型的示例，以便你可以理解泛型旨在解决的问题，例如弱类型参数和值，以及使用`System.Object`引起的性能问题。
- en: '`System.Collections.Hashtable` can be used to store multiple key-value pairs,
    each with a unique key that can later be used to quickly look up its value. Both
    the key and value can be any object because they are declared as `System.Object`.
    Although this provides flexibility, it is slow, and bugs are easier to introduce
    because no type checks are made when adding items.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections.Hashtable`可用于存储多个键值对，每个键值对都有一个唯一的键，稍后可以用来快速查找其值。键和值都可以是任何对象，因为它们被声明为`System.Object`。尽管这提供了灵活性，但它速度较慢，并且更容易引入错误，因为在添加项目时没有进行类型检查。'
- en: 'Let’s write some code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码：
- en: 'In `Program.cs`, create an instance of the non-generic collection, `System.Collections.Hashtable`,
    and then add four items to it, as shown in the following code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，创建一个非泛型集合`System.Collections.Hashtable`的实例，并向其中添加四个项目，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that three items have a unique integer key to look them up. The last item
    has a `Person` object as its key to look it up. This is valid in a non-generic
    collection.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有三个项目具有唯一的整数键以查找它们。最后一个项目使用`Person`对象作为其键来查找。这在非泛型集合中是有效的。
- en: 'Add statements to define a `key` with the value of `2` and use it to look up
    its value in the *hash* table, as shown in the following code:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句定义一个值为`2`的`key`，并使用它来在*哈希表*中查找其值，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add statements to use the `harry` object to look up its value, as shown in
    the following code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句使用`harry`对象来查找其值，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the `PeopleApp` project and note that it works, as shown in the following
    output:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`PeopleApp`项目，并注意它按如下所示正常工作：
- en: '[PRE21]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Although the code works, there is potential for mistakes because literally any
    type can be used for the key or value. If another developer used your variable
    named `lookupObject` and expected all the items to be a certain type, they might
    cast them to that type and get exceptions because some values might be a different
    type. A lookup object with lots of items would also give poor performance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码可以工作，但由于可以使用任何类型作为键或值，因此存在出错的可能性。如果另一位开发者使用了你名为`lookupObject`的变量，并期望所有项目都是某种类型，他们可能会将它们转换为该类型并引发异常，因为某些值可能是不同类型。拥有大量项目的查找对象也会导致性能不佳。
- en: '**Good Practice**: Avoid types in the `System.Collections` namespace. Use types
    in the `System.Collections.Generics` and related namespaces instead. If you need
    to use a library that uses non-generic types, then of course you will have to
    use non-generic types. This is an example of what is commonly referred to as technical
    debt.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：避免使用`System.Collections`命名空间中的类型。使用`System.Collections.Generics`和相关命名空间中的类型。如果你需要使用使用非泛型类型的库，那么当然你必须使用非泛型类型。这通常被称为技术债务的例子。'
- en: Working with generic types
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与泛型类型一起工作
- en: '`System.Collections.Generic.Dictionary<TKey, TValue>` can be used to store
    multiple values, each with a unique key that can later be used to quickly look
    up its value. Both the key and value can be any object, but you must tell the
    compiler what the types of the key and value will be when you first instantiate
    the collection. You do this by specifying types for the **generic parameters**
    in angle brackets `<>`, `TKey`, and `TValue`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections.Generic.Dictionary<TKey, TValue>`可以用来存储多个值，每个值都有一个唯一的键，稍后可以用来快速查找其值。键和值都可以是任何对象，但你必须在首次实例化集合时告诉编译器键和值的类型。你通过指定尖括号`<>`中的**泛型参数**类型`TKey`和`TValue`来完成此操作。'
- en: '**Good Practice**: When a generic type has one definable type, it should be
    named `T`, for example, `List<T>`, where `T` is the type stored in the list. When
    a generic type has multiple definable types, it should use `T` as a name prefix
    and have a sensible name, for example, `Dictionary<TKey, TValue>`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：当泛型类型有一个可定义的类型时，它应该命名为`T`，例如，`List<T>`，其中`T`是列表中存储的类型。当泛型类型有多个可定义的类型时，它应该使用`T`作为名称前缀，并有一个合理的名称，例如，`Dictionary<TKey,
    TValue>`。'
- en: Generics provides flexibility, is faster, and makes bugs easier to avoid because
    type checks are made when adding items at compile time. We will not need to explicitly
    specify the `System.Collections.Generic` namespace that contains `Dictionary<TKey,
    TValue>` because it is implicitly and globally imported by default.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型提供了灵活性，运行更快，并且使错误更容易避免，因为类型检查是在编译时添加项目时进行的。我们不需要显式指定包含`Dictionary<TKey, TValue>`的`System.Collections.Generic`命名空间，因为它默认隐式和全局导入。
- en: 'Let’s write some code to solve the problem by using generics:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来使用泛型解决问题：
- en: 'In `Program.cs`, create an instance of the generic lookup collection `Dictionary<TKey,
    TValue>` and then add four items to it, as shown in the following code:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，创建一个泛型查找集合`Dictionary<TKey, TValue>`的实例，然后向其中添加四个项目，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note the compile error when using `harry` as a key, as shown in the following
    output:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意使用`harry`作为键时的编译错误，如下面的输出所示：
- en: '[PRE23]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Replace `harry` with `4`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`harry`替换为`4`。
- en: 'Add statements to set the `key` to `3`, and use it to look up its value in
    the dictionary, as shown in the following code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句将`key`设置为`3`，并使用它来查找字典中的值，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the `PeopleApp` project and note that it works, as shown in the following
    output:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`PeopleApp`项目，并注意它按预期工作，如下面的输出所示：
- en: '[PRE25]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You have now seen the difference between non-generic and generic types that
    need the flexibility to store any type. You know to always use generic collection
    types if possible. Unless you are unlucky enough to be forced to use a legacy
    non-generic library, you never need to write code that uses non-generic types
    that can store any type again.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了非泛型类型和需要存储任何类型的泛型类型之间的区别。你知道如果可能的话，始终使用泛型集合类型。除非你非常不幸，不得不使用遗留的非泛型库，否则你再也不需要编写使用可以存储任何类型的非泛型类型的代码了。
- en: Just because it is good practice to use generic collection types in preference
    to non-generic collection types does not mean the more general case is also true.
    Non-generic non-collection types and other types that do not need the flexibility
    to work with any type are used all the time. Collection types just happen to be
    the most common type that benefits from generics.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用泛型集合类型而不是非泛型集合类型是良好实践，但这并不意味着更一般的情况也是正确的。非泛型非集合类型和其他不需要与任何类型交互的类型的类型被经常使用。集合类型只是碰巧是最常见的从泛型中受益的类型。
- en: Raising and handling events
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发和处理事件
- en: Methods are often described as *actions that an object can perform, either on
    itself or on related objects*. For example, `List<T>` can add an item to itself
    or clear itself, and `File` can create or delete a file in the filesystem.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 方法通常被描述为*对象可以执行的操作，无论是对自己还是对相关对象*。例如，`List<T>`可以向自身添加项目或清除自身，而`File`可以在文件系统中创建或删除文件。
- en: Events are often described as *actions that happen to an object*. For example,
    in a user interface, `Button` has a `Click` event, a click being something that
    happens to a button. Also, `FileSystemWatcher` listens to the filesystem for change
    notifications and raises events like `Created` and `Deleted`, which are triggered
    when a directory or file changes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 事件通常被描述为*发生在对象上的动作*。例如，在用户界面中，`Button`有一个`Click`事件，点击是发生在按钮上的事情。同样，`FileSystemWatcher`监听文件系统以获取更改通知，并引发如`Created`和`Deleted`等事件，这些事件在目录或文件更改时触发。
- en: Another way to think of events is that they provide a way of exchanging messages
    between objects.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考事件的方式是，它们提供了一种在对象之间交换消息的方法。
- en: Events are built on **delegates**, so let’s start by having a look at what delegates
    are and how they work.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 事件建立在**委托**的基础上，所以让我们先看看什么是委托以及它们是如何工作的。
- en: Calling methods using delegates
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用委托调用方法
- en: 'You have already seen the most common way to call or execute a method: using
    the `.` operator to access the method using its name. For example, `Console.WriteLine`
    tells the `Console` type to call its `WriteLine` method.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了调用或执行方法最常见的方式：使用`.`运算符通过其名称来访问方法。例如，`Console.WriteLine`告诉`Console`类型调用其`WriteLine`方法。
- en: The other way to call or execute a method is to use a delegate. If you have
    used languages that support **function pointers**, then think of a delegate as
    being a **type-safe method pointer**.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种调用或执行方法的方式是使用委托。如果你使用过支持**函数指针**的语言，那么可以将委托视为**类型安全的函数指针**。
- en: In other words, a delegate contains the memory address of a method that must
    match the same signature as the delegate, enabling it to be called safely with
    the correct parameter types.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，一个委托包含了一个必须与委托具有相同签名的方法的内存地址，使其能够以正确的参数类型安全地调用。
- en: The code in this section is illustrative and not meant to be typed into a project.
    You will explore code like this in the next section, so for now, just read the
    code and try to understand its meaning.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码是说明性的，并不打算将其输入到项目中。你将在下一节中探索这样的代码，所以现在只需阅读代码并尝试理解其含义。
- en: 'For example, imagine there is a method in the `Person` class that must have
    a `string` type passed as its only parameter, and it returns an `int` type, as
    shown in the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下在`Person`类中有一个方法，它必须以一个`string`类型的参数传入，并返回一个`int`类型，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'I can call this method on an instance of `Person` named `p1` like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以像这样在名为`p1`的`Person`实例上调用此方法：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alternatively, I can define a delegate with a matching signature to call the
    method indirectly. Note that the names of the parameters do not have to match.
    Only the types of parameters and return values must match, as shown in the following
    code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我可以定义一个与签名匹配的委托来间接调用方法。请注意，参数的名称不必匹配。只有参数的类型和返回值必须匹配，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Good Practice**: A `delegate` is a reference type like a `class`, so if you
    define one in `Program.cs`, then it must be at the bottom of the file. It would
    be best to define it in its own class file, for example, `Program.Delegates.cs`.
    If you defined a delegate in the middle of `Program.cs`, then you would see the
    following compiler error: `CS8803: Top-level statements must precede namespace
    and type declarations`.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：`delegate`是一个类似于`class`的引用类型，所以如果你在`Program.cs`中定义了一个，那么它必须位于文件的底部。最好将其定义在其自己的类文件中，例如，`Program.Delegates.cs`。如果你在`Program.cs`的中间定义了一个委托，那么你会看到以下编译器错误：`CS8803:
    Top-level statements must precede namespace and type declarations`。'
- en: 'Now, I can create an instance of the delegate, point it at the method, and
    finally, call the delegate (which calls the method), as shown in the following
    code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以创建一个代表，将其指向该方法，最后调用代表（它调用该方法），如下面的代码所示：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Examples of delegate use
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 委托使用的示例
- en: You are probably thinking, *“What’s the point of that?”*
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在想，“那有什么用呢？”
- en: It provides flexibility. For example, we could use delegates to create a queue
    of methods that need to be called in order. Queuing actions that need to be performed
    is common in services to provide improved scalability.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了灵活性。例如，我们可以使用委托创建一个需要按顺序调用的方法的队列。在服务中排队执行的操作是常见的，以提高可伸缩性。
- en: Another example is to allow multiple actions to execute in parallel. Delegates
    have built-in support for asynchronous operations that run on a different thread,
    which can provide improved responsiveness.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是允许并行执行多个操作。委托内置了对在另一个线程上运行的异步操作的支持，这可以提高响应性。
- en: The most important example is that delegates allow us to implement events to
    send messages between different objects that do not need to know about each other.
    Events are an example of loose coupling between components because they do not
    need to know about each other; they just need to know the event signature.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的例子是，委托允许我们在不需要相互了解的不同对象之间实现事件以发送消息。事件是组件之间松散耦合的一个例子，因为它们不需要相互了解；它们只需要知道事件签名。
- en: 'Status: It’s complicated'
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态：很复杂
- en: Delegates and events are two of the most confusing features of C# and can take
    a few attempts to understand, so don’t worry if you feel lost as we walk through
    how they work! Move on to other topics and come back again another day when your
    brain has had the opportunity to process the concepts while you sleep.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 委托和事件是C#中最令人困惑的特性之一，可能需要尝试几次才能理解，所以当你跟随我们了解它们的工作原理时，如果你感到迷茫，请不要担心！继续学习其他主题，并在你的大脑有机会在睡眠中处理这些概念之后再回来。
- en: Defining and handling delegates
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和处理委托
- en: 'Microsoft has two predefined delegates for use as events. They both have two
    parameters:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 微软为用作事件提供了两个预定义的委托。它们都有两个参数：
- en: '`object? sender`: This parameter is a reference to the object raising the event
    or sending the message. The `?` indicates that this reference could be `null`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object? sender`：此参数是对引发事件或发送消息的对象的引用。`?`表示此引用可以是`null`。'
- en: '`EventArgs e` or `TEventArgs e`: This parameter contains additional relevant
    information about the event. For example, in a GUI app, you might define `MouseMoveEventArgs`,
    which has properties for the `X` and `Y` coordinates for the mouse pointer. A
    bank account might have a `WithdrawEventArgs` with a property for the `Amount`
    to withdraw.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventArgs e` 或 `TEventArgs e`：此参数包含有关事件的附加相关信息。例如，在一个GUI应用程序中，你可能定义`MouseMoveEventArgs`，它具有鼠标指针的`X`和`Y`坐标属性。一个银行账户可能有一个`WithdrawEventArgs`，它有一个用于`Amount`的属性。'
- en: 'Their signatures are simple, yet flexible, as shown in the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的签名简单，但灵活，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Good Practice**: When you want to define an event in your own type, you should
    use one of these two predefined delegates.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：当你想在自定义类型中定义一个事件时，你应该使用这两个预定义的委托之一。'
- en: 'Some types provide “empty” values for when you need an instance, but it doesn’t
    need to have any particular value. For example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类型在需要实例但不需要特定值时提供“空”值。例如：
- en: '`string.Empty` is an empty string value `""`. It is better to use `string.Empty`
    than `""` because every time you use `""` the compiler must instantiate a new
    empty string instance. You can think of `string.Empty` as a global single instance
    of an empty string. Sharing it is more efficient than creating your own new instances
    every time you need to reference an empty string value.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string.Empty`是一个空字符串值`""`。与使用`""`相比，使用`string.Empty`更好，因为每次使用`""`时，编译器都必须实例化一个新的空字符串实例。你可以将`string.Empty`视为一个全局的单例空字符串。共享它比每次需要引用空字符串值时创建自己的新实例更有效。'
- en: '`EventArgs.Empty` is an empty `EventArgs` value. Use it when you must conform
    to the built-in event delegates that require an `EventArgs` instance to be passed
    as a parameter, but it doesn’t need any particular value because it won’t be read
    or used in the method anyway.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventArgs.Empty`是一个空的`EventArgs`值。当必须符合需要将`EventArgs`实例作为参数传递的内置事件委托，但不需要任何特定值，因为无论如何它都不会被读取或使用在方法中时，使用它。'
- en: 'You might have a delegate defined, as shown in the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经定义了一个委托，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In that case, there are multiple ways to call the delegate, as shown in the
    following code examples:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，有多种方式可以调用委托，如下面的代码示例所示：
- en: 'Use its variable name, `Shout`:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其变量名，`Shout`：
- en: '[PRE32]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Use its `Invoke` method to call it synchronously:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用它的`Invoke`方法来同步调用它：
- en: '[PRE33]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Use its `BeginInvoke` method to call it asynchronously, without a callback
    function or any state:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用它的`BeginInvoke`方法来异步调用它，无需回调函数或任何状态：
- en: '[PRE34]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `BeginInvoke` method is beyond the scope of this book, but I have included
    it so that you know it exists.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeginInvoke`方法超出了本书的范围，但我包括它，以便你知道它的存在。'
- en: 'Delegates and their method handlers have a potentially many-to-many relationship.
    One delegate can have one method handler. But one delegate can also have many
    method handlers (you will do this when you hook up `Shout` to both `Harry_Shout`
    and `Harry_Shout_2`). And many delegates can reference one method handler, or
    any combination of these. Let’s explore delegates and events:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 委托及其方法处理程序可能存在多对多的关系。一个委托可以有一个方法处理程序。但一个委托也可以有多个方法处理程序（当你将`Shout`连接到`Harry_Shout`和`Harry_Shout_2`时，你会这样做）。许多委托可以引用一个方法处理程序，或者这些组合中的任何组合。让我们来探索委托和事件：
- en: 'Add statements to the `Person` class and note the following points, as shown
    in the following code:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Person`类中添加语句，并注意以下要点，如下面的代码所示：
- en: It defines an `EventHandler` delegate field named `Shout`.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个名为`Shout`的`EventHandler`委托字段。
- en: It defines an `int` field to store `AngerLevel`.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个`int`字段来存储`AngerLevel`。
- en: It defines a method named `Poke`.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个名为`Poke`的方法。
- en: 'Each time a person is poked, their `AngerLevel` increments. Once their `AngerLevel`
    reaches three, they raise the `Shout` event, but only if there is at least one
    event delegate pointing at a method defined somewhere else in the code; that is,
    it is not `null`:'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次有人被戳时，他们的`AngerLevel`都会增加。一旦他们的`AngerLevel`达到三，他们就会引发`Shout`事件，但前提是至少有一个事件委托指向代码中其他地方定义的方法；也就是说，它不是`null`：
- en: '[PRE35]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Checking whether an object is not `null` before calling one of its methods
    is very common. C# 6 and later allow `null` checks to be simplified inline using
    a `?` symbol before the `.` operator, as shown in the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用对象的一个方法之前检查该对象是否不是`null`是非常常见的。C# 6及以后版本允许使用`?`符号在`.`操作符之前简化行内`null`检查，如下面的代码所示：
- en: '`Shout?.Invoke(this, EventArgs.Empty);`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shout?.Invoke(this, EventArgs.Empty);`'
- en: In the `PeopleApp` project, add a new class file named `Program.EventHandlers.cs`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PeopleApp`项目中，添加一个名为`Program.EventHandlers.cs`的新类文件。
- en: 'In `Program.EventHandlers.cs`, delete any existing statements, and then add
    a method with a matching signature that gets a reference to the `Person` object
    from the `sender` parameter and outputs some information about them, as shown
    in the following code:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.EventHandlers.cs`中，删除任何现有的语句，然后添加一个具有匹配签名的函数，该函数从`sender`参数获取`Person`对象的引用，并输出一些关于它们的信息，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Good Practice**: Microsoft’s convention for method names that handle events
    is `ObjectName_EventName`. In this project, `sender` will always be a `Person`
    instance, so the `null` checks are not necessary, and the event handler could
    be much simpler with just the `WriteLine` statement. However, it is important
    to know that these types of `null` checks make your code more robust in cases
    of event misuse.'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：Microsoft 对处理事件的方法定义的约定是`ObjectName_EventName`。在本项目中，`sender`始终是一个`Person`实例，因此不需要进行`null`检查，并且事件处理程序可以仅使用`WriteLine`语句变得更加简单。然而，重要的是要知道，这些类型的`null`检查可以使你的代码在事件误用的情况下更加健壮。'
- en: You can have as many methods as you like to be event handlers, named whatever
    you like, as long as the method signature matches the delegate signature. This
    means you could have 50 `Person` instances, each with their own method, or have
    one method that they all share. The methods can be declared at any level that
    makes sense for the scenario and matches the access levels set (like `protected`,
    `private`, `public`, and so on). One of the key benefits of delegates and events
    is loose binding between components so maximum flexibility is desired.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以拥有任意多的方法作为事件处理程序，命名任意，只要方法签名与委托签名匹配。这意味着你可以有50个`Person`实例，每个实例都有自己的方法，或者有一个它们都共享的方法。这些方法可以在任何对场景有意义的级别声明，并且与设置的访问级别相匹配（如`protected`、`private`、`public`等）。委托和事件的一个关键好处是组件之间的松散绑定，因此希望具有最大的灵活性。
- en: 'In `Program.cs`, add a statement to assign the method to the delegate field,
    and then add statements to call the `Poke` method four times, as shown in the
    following code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一个语句将方法分配给委托字段，然后添加语句调用`Poke`方法四次，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the `PeopleApp` project and view the result. Note that Harry says nothing
    the first two times he is poked, and only gets angry enough to shout once he’s
    been poked at least three times, as shown in the following output:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`PeopleApp`项目并查看结果。注意，哈里在前两次被戳时没有说话，而且只有在他至少被戳了三次之后，他才足够生气而大喊，如下面的输出所示：
- en: '[PRE38]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In Step 3, note that the `sender` is checked to make sure it is a `Person`
    instance, and if it is, then it is assigned to a local variable named `p`, as
    shown in the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 步中，请注意检查 `sender` 是否是一个 `Person` 实例，如果是，则将其分配给名为 `p` 的局部变量，如下所示：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first statement does two things at once, which needs more explanation. The
    parameter named `sender` is declared to be of type `object`. This means we cannot
    just say `sender.Name` or `sender.AngerLevel`. We need to cast `sender` to a local
    variable that is explicitly defined as `Person`. We also need to check that `sender`
    actually is a `Person`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条语句同时做了两件事，需要更多的解释。名为 `sender` 的参数被声明为 `object` 类型。这意味着我们无法直接说 `sender.Name`
    或 `sender.AngerLevel`。我们需要将 `sender` 强制转换为显式定义为 `Person` 的局部变量。我们还需要检查 `sender`
    是否实际上是一个 `Person`。
- en: 'We can do both things at once in a single expression: `sender is not Person
    p`. This expression will return `true` if `sender` is not a `Person`, and hence
    the statement executes `return` so the method immediately returns. Or the expression
    returns `false` if `sender` is a `Person`, and sender will be stored in the local
    variable named `p`, which is of type `Person`. After that, we can use expressions
    like `p.Name` and `p.AngerLevel`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在单个表达式中同时完成这两件事：`sender is not Person p`。如果 `sender` 不是一个 `Person`，则此表达式将返回
    `true`，因此执行 `return` 语句，方法立即返回。或者，如果 `sender` 是一个 `Person`，则 `sender` 将被存储在名为
    `p` 的局部变量中，该变量是 `Person` 类型。之后，我们可以使用 `p.Name` 和 `p.AngerLevel` 这样的表达式。
- en: Defining and handling events
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和处理事件
- en: 'You’ve now seen how delegates implement the most important functionality of
    events: the ability to define a signature for a method that can be implemented
    by a completely different piece of code, calling that method and any others that
    are hooked up to the delegate field.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了代理如何实现事件最重要的功能：定义一个可以由完全不同的代码块实现的方法签名，调用该方法以及任何连接到代理字段的其他方法。
- en: But what about events? There is less to them than you might think.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 但事件又如何呢？它们比你想象的要简单。
- en: When assigning a method to a delegate field, you should not use the simple assignment
    operator as we did in the preceding example.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当将方法分配给代理字段时，你不应该使用我们在前一个示例中使用的简单赋值运算符。
- en: Delegates are multicast, meaning that you can assign multiple delegates to a
    single delegate field. Instead of the `=` assignment, we could have used the `+=`
    operator so that we could add more methods to the same delegate field. When the
    delegate is called, all the assigned methods are called, although you have no
    control over the order in which they are called. Do not use events to implement
    a queuing system to buy concert tickets; otherwise, the wrath of millions of Swifties
    will fall upon you.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是多播的，这意味着你可以将多个代理分配给单个代理字段。我们本可以使用 `+=` 操作符，而不是 `=` 赋值，以便向同一个代理字段添加更多方法。当调用代理时，所有分配的方法都会被调用，尽管你无法控制它们调用的顺序。不要使用事件来实现购票排队系统；否则，数百万
    Swifties 的愤怒将降临到你身上。
- en: 'If the `Shout` delegate field already referenced one or more methods, by assigning
    another method, that method would replace all the others. With delegates that
    are used for events, we usually want to make sure that a programmer only ever
    uses either the `+=` operator or the `-=` operator to assign and remove methods:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Shout` 代理字段已经引用了一个或多个方法，通过分配另一个方法，该方法将替换所有其他方法。对于用于事件的代理，我们通常希望确保程序员只使用
    `+=` 或 `-=` 操作符来分配和删除方法：
- en: 'To enforce this, in `Person.cs`, add the `event` keyword to the delegate field
    declaration, as highlighted in the following code:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了强制执行此操作，在 `Person.cs` 文件中，将 `event` 关键字添加到代理字段声明中，如下所示：
- en: '[PRE40]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Build the `PeopleApp` project and note the compiler error message, as shown
    in the following output:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建名为 `PeopleApp` 的项目，并注意编译器错误信息，如下所示：
- en: '[PRE41]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is (almost) all that the `event` keyword does! If you will never have more
    than one method assigned to a delegate field, then technically you do not need
    events, but it is still good practice to indicate your meaning and that you expect
    a delegate field to be used as an event.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是（几乎）`event` 关键字所做的一切！如果你永远不会将多个方法分配给代理字段，那么从技术上讲，你不需要事件，但仍然是一个好习惯，表明你的意图，并期望代理字段被用作事件。
- en: 'In `Program.cs`, modify the comment and the method assignment to use `+=` instead
    of just `=`, as highlighted in the following code:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，修改注释和方法赋值，使用 `+=` 而不是仅仅使用 `=`, 如以下代码所示：
- en: '[PRE42]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Run the `PeopleApp` project and note that it has the same behavior as before.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并注意它具有与之前相同的行为。
- en: 'In `Program.EventHandlers.cs`, create a second event handler for Harry’s `Shout`
    event, as shown in the following code:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.EventHandlers.cs` 中，为 Harry 的 `Shout` 事件创建第二个事件处理程序，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In `Program.cs`, after the statement that assigns the `Harry_Shout` method
    to the `Shout` event, add a statement to attach the new event handler to the `Shout`
    event too, as shown highlighted in the following code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，在将 `Harry_Shout` 方法分配给 `Shout` 事件的语句之后，添加一个语句将新的事件处理程序附加到 `Shout`
    事件，如下面的代码所示（高亮显示）：
- en: '[PRE44]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the `PeopleApp` project, view the result. Note that both event handlers
    execute whenever an event is raised, which only happens once the anger level is
    three or more, as shown in the following output:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目，查看结果。注意，每当引发事件时，这两个事件处理程序都会执行，这仅发生在愤怒水平达到三或更高时，如下面的输出所示：
- en: '[PRE45]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In Windows desktop development, imagine that you have three buttons: `AddButton`,
    `SaveButton`, and `DeleteButton`. Each button has very different functionality.
    Good practice would be to create three methods to handle their `Click` events,
    named `AddButton_Click`, `SaveButton_Click`, and `DeleteButton_Click`. Each would
    have a different implementation code.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 桌面开发中，想象你有三个按钮：`AddButton`、`SaveButton` 和 `DeleteButton`。每个按钮都有非常不同的功能。良好的实践是创建三个方法来处理它们的
    `Click` 事件，分别命名为 `AddButton_Click`、`SaveButton_Click` 和 `DeleteButton_Click`。每个方法都会有不同的实现代码。
- en: 'But now, imagine you have 26 buttons: `AButton`, `BButton`, `CButton`, and
    so on, up to `ZButton`. Each button has the same functionality: to filter a list
    of people by the first letter of their name. Good practice would be to create
    one method to handle their `Click` events, perhaps named `AtoZButtons_Click`.
    This method would have an implementation code that would use the `sender` parameter
    to know which button was clicked, and therefore how to apply the filtering, but
    otherwise be the same for all the buttons.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，想象你有 26 个按钮：`AButton`、`BButton`、`CButton` 等等，直到 `ZButton`。每个按钮都有相同的功能：通过姓名的第一个字母过滤人员列表。良好的实践是创建一个方法来处理它们的
    `Click` 事件，可能命名为 `AtoZButtons_Click`。此方法将包含一个实现代码，该代码将使用 `sender` 参数来确定哪个按钮被点击，因此知道如何应用过滤，但除此之外对所有按钮都是相同的。
- en: That’s it for events. Now, let’s look at interfaces.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 事件就到这里。现在，让我们看看接口。
- en: Implementing interfaces
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现接口
- en: Interfaces are a way to implement standard functionality and connect different
    types to make new things. Think of them like the studs on top of LEGO™ bricks,
    which allow them to “stick” together, or electrical standards for plugs and sockets.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是实现标准功能并将不同类型连接起来以创建新事物的一种方式。想想看，它们就像 LEGO™ 砖块顶部的凸起，允许它们“粘”在一起，或者插头和插座的标准电气标准。
- en: If a type implements an interface, then it makes a promise to the rest of .NET
    that it supports specific functionality. Therefore, they are sometimes described
    as contracts.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类型实现了接口，那么它向 .NET 的其余部分承诺它支持特定的功能。因此，它们有时被描述为合同。
- en: Common interfaces
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见接口
- en: '*Table 6.1* shows some common interfaces that your types might implement:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 6.1* 展示了一些你的类型可能实现的常见接口：'
- en: '| **Interface** | **Method(s)** | **Description** |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| **接口** | **方法(s)** | **描述** |'
- en: '| `IComparable` | `CompareTo(other)` | This defines a comparison method that
    a type implements to order or sort its instances. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `IComparable` | `CompareTo(other)` | 这定义了一个类型实现以对或排序其实例的比较方法。|'
- en: '| `IComparer` | `Compare(first, second)` | This defines a comparison method
    that a secondary type implements to order or sort instances of a primary type.
    |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `IComparer` | `Compare(first, second)` | 这定义了一个二级类型实现以对或排序主类型实例的比较方法。|'
- en: '| `IDisposable` | `Dispose()` | This defines a disposal method to release unmanaged
    resources more efficiently than waiting for a finalizer. See the *Releasing unmanaged
    resources* section later in this chapter for more details. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `IDisposable` | `Dispose()` | 这定义了一个释放非托管资源的销毁方法，比等待终结器更有效。有关更多详细信息，请参阅本章后面的
    *释放非托管资源* 部分。|'
- en: '| `IFormattable` | `ToString(format, culture)` | This defines a culture-aware
    method to format the value of an object into a string representation. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `IFormattable` | `ToString(format, culture)` | 这定义了一个文化感知的方法，将对象的值格式化为字符串表示形式。|'
- en: '| `IFormatter` | `Serialize(stream, object)``Deserialize(stream)` | This defines
    methods to convert an object to and from a stream of bytes for storage or transfer.
    |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `IFormatter` | `Serialize(stream, object)` `Deserialize(stream)` | 这定义了将对象转换为和从字节流进行存储或传输的方法。|'
- en: '| `IFormatProvider` | `GetFormat(type)` | This defines a method to format inputs
    based on a language and region. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `IFormatProvider` | `GetFormat(type)` | 这定义了一个基于语言和区域格式化输入的方法。|'
- en: 'Table 6.1: Some common interfaces that your types might implement'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1：你可能希望你的数据类型实现的常见接口
- en: Comparing objects when sorting
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序时比较对象
- en: One of the most common interfaces that you will want to implement in your types
    that represent data is `IComparable`. If a type implements one of the `IComparable`
    interfaces, then arrays and collections containing instances of that type can
    be sorted.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的数据类型中，你将想要实现的最常见的接口之一是 `IComparable`。如果一个类型实现了 `IComparable` 接口之一，那么包含该类型实例的数组和集合可以被排序。
- en: This is an example of an abstraction for the concept of sorting. To sort any
    type, the minimum functionality would be the ability to compare two items and
    decide which goes before the other. If a type implements that minimum functionality,
    then a sorting algorithm can use it to sort instances of that type in any way
    the sorting algorithm wants.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是排序概念的抽象示例。要排序任何类型，最小功能就是能够比较两个项目并决定哪个在前。如果一个类型实现了这种最小功能，那么排序算法可以使用它以任何排序算法想要的方式对那个类型的实例进行排序。
- en: 'The `IComparable` interface has one method named `CompareTo`. This has two
    variations, one that works with a nullable `object` type and one that works with
    a nullable generic type `T`, as shown in the following code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`IComparable` 接口有一个名为 `CompareTo` 的方法。这个方法有两种变体，一种与可空 `object` 类型一起工作，另一种与可空泛型类型
    `T` 一起工作，如下面的代码所示：'
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `in` keyword specifies that the type parameter `T` is contravariant, which
    means that you can use a less derived type than that specified. For example, if
    `Employee` derives from `Person`, then both can be compared to each other.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`in` 关键字指定类型参数 `T` 是协变的，这意味着你可以使用比指定的更不派生的类型。例如，如果 `Employee` 从 `Person` 继承，那么两者都可以相互比较。'
- en: For example, the `string` type implements `IComparable` by returning `-1` if
    the `string` should be sorted before the `string` is compared to, `1` if it should
    be sorted after, and `0` if they are equal. The `int` type implements `IComparable`
    by returning `-1` if the `int` is less than the `int` being compared to, `1` if
    it is greater, and `0` if they are equal.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`string` 类型通过在比较之前返回 `-1`（如果 `string` 应该在比较的 `string` 之前排序），返回 `1`（如果它应该在比较的
    `string` 之后排序），以及返回 `0`（如果它们相等）来实现 `IComparable`。`int` 类型通过在比较的 `int` 小于被比较的 `int`
    时返回 `-1`，在比较的 `int` 大于时返回 `1`，以及相等时返回 `0` 来实现 `IComparable`。
- en: '`CompareTo` return values can be summarized as shown in *Table 6.2*:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompareTo` 返回值可以总结如下 *表 6.2*：'
- en: '| **this before other** | **this is equal to other** | **this after other**
    |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| **此对象在其它对象之前** | **此对象等于其它对象** | **此对象在其它对象之后** |'
- en: '| -1 | 0 | 1 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| -1 | 0 | 1 |'
- en: 'Table 6.2: Summary of the CompareTo return values'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.2：`CompareTo` 返回值摘要
- en: 'Before we implement the `IComparable` interface and its `CompareTo` method
    for the `Person` class, let’s see what happens when we try to sort an array of
    `Person` instances without implementing this interface, including some that are
    `null` or have a `null` value for their `Name` property:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为 `Person` 类实现 `IComparable` 接口及其 `CompareTo` 方法之前，让我们看看当我们尝试对未实现此接口的 `Person`
    实例数组进行排序时会发生什么，包括一些 `null` 或 `Name` 属性具有 `null` 值的实例：
- en: In the `PeopleApp` project, add a new class file named `Program.Helpers.cs`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PeopleApp` 项目中，添加一个名为 `Program.Helpers.cs` 的新类文件。
- en: 'In `Program.Helpers.cs`, delete any existing statements. Then define a method
    for the `partial` `Program` class that will output all the names of a collection
    of people passed as a parameter, with a title beforehand, as shown in the following
    code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Helpers.cs` 中，删除任何现有的语句。然后为 `partial` `Program` 类定义一个方法，该方法将输出作为参数传递的一个人名集合的所有名称，并在之前添加一个标题，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In `Program.cs`, add statements that create an array of `Person` instances,
    call the `OutputPeopleNames` method to write the items to the console, and then
    attempt to sort the array and write the items to the console again, as shown in
    the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加创建 `Person` 实例数组的语句，调用 `OutputPeopleNames` 方法将项目写入控制台，然后尝试对数组进行排序并将项目再次写入控制台，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Run the `PeopleApp` project and an exception will be thrown. As the message
    explains, to fix the problem, our type must implement `IComparable`, as shown
    in the following output:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目，将会抛出异常。正如消息所解释的，为了修复这个问题，我们的类型必须实现 `IComparable`，如下面的输出所示：
- en: '[PRE49]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In `Person.cs`, after inheriting from `object`, add a comma and enter `IComparable<Person?>`,
    as highlighted in the following code:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs` 文件中，在继承自 `object` 之后，添加一个逗号并输入 `IComparable<Person?>`，如下面的代码所示：
- en: '[PRE50]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Your code editor will draw a red squiggle under the new code to warn you that
    you have not yet implemented the method you promised to. Your code editor can
    write the skeleton implementation for you.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的代码编辑器将在新代码下方绘制一个红色波浪线以警告您尚未实现您承诺的方法。您的代码编辑器可以为您编写骨架实现。
- en: Click on the light bulb and then click **Implement interface**.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击灯泡图标，然后点击 **实现接口**。
- en: 'Scroll down to the bottom of the `Person` class to find the method that was
    written for you, as shown in the following code:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到 `Person` 类的底部以找到为您编写的代码，如下面的代码所示：
- en: '[PRE51]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Delete the statement that throws the `NotImplementedException` error.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除抛出 `NotImplementedException` 错误的语句。
- en: 'Add statements to handle variations of input values, including `null`. Call
    the `CompareTo` method of the `Name` field, which uses the `string` type’s implementation
    of `CompareTo`. Return the result, as shown in the following code:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加处理输入值变体的语句，包括 `null`。调用 `Name` 字段的 `CompareTo` 方法，该方法使用 `string` 类型的 `CompareTo`
    实现方式。如以下代码所示，返回结果：
- en: '[PRE52]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We have chosen to compare two `Person` instances by comparing their `Name` fields.
    `Person` instances will, therefore, be sorted alphabetically by their name. `null`
    values will be sorted to the bottom of the collection. Storing the calculated
    `position` before returning it is useful when debugging. I’ve also used more round
    brackets than the compiler needs to make the code easier for me to read. If you
    prefer fewer brackets, then feel free to remove them.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择通过比较 `Name` 字段来比较两个 `Person` 实例。因此，`Person` 实例将按名称字母顺序排序。`null` 值将被排序到集合的底部。在返回之前存储计算出的
    `position` 对于调试很有用。我还使用了比编译器需要的更多圆括号，以便代码更容易阅读。如果您更喜欢较少的括号，那么请随意删除它们。
- en: Also, note that the final `else` statement will never execute because the logic
    of the `if` and `else` `if` clauses means it will only execute when `this` (the
    current object instance) is `null`. In that scenario, the method could not execute
    anyway since the object wouldn’t exist! I wrote the `if` statement to exhaustively
    cover all combinations of `null` and not `null` for `other` and `this`, but the
    last of those combinations could, in practice, never happen.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，最终的 `else` 语句永远不会执行，因为 `if` 和 `else if` 子句的逻辑意味着它只有在 `this`（当前对象实例）为
    `null` 时才会执行。在这种情况下，方法无论如何都无法执行，因为对象根本不存在！我编写了 `if` 语句来详尽地涵盖 `other` 和 `this`
    的 `null` 和非 `null` 所有可能的组合，但实际上最后一种组合可能永远不会发生。
- en: 'Run the `PeopleApp` project. Note that this time it works as it should, sorted
    alphabetically by name, as shown in the following output:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目。注意这次它应该按名称字母顺序排序，如下面的输出所示：
- en: '[PRE53]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Good Practice**: If you want to sort an array or collection of instances
    of your type, then implement the `IComparable` interface.'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：如果您想对您的类型的数组或集合进行排序，那么实现 `IComparable` 接口。'
- en: Comparing objects using a separate class
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用单独的类比较对象
- en: 'Sometimes, you won’t have access to the source code for a type, and it might
    not implement the `IComparable` interface. Luckily, there is another way to sort
    instances of a type. You can create a separate type that implements a slightly
    different interface, named `IComparer`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能无法访问类型的源代码，并且它可能没有实现 `IComparable` 接口。幸运的是，还有另一种对类型实例进行排序的方法。您可以创建一个实现略微不同接口的单独类型，该接口名为
    `IComparer`：
- en: 'In the `PacktLibrary` project, add a new class file named `PersonComparer.cs`,
    containing a class implementing the `IComparer` interface that will compare two
    people, that is, two `Person` instances. Implement it by comparing the length
    of their `Name` fields, or if the names are the same length, then compare the
    names alphabetically, as shown in the following code:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PacktLibrary` 项目中，添加一个名为 `PersonComparer.cs` 的新类文件，其中包含一个实现 `IComparer` 接口的类，该类将比较两个人，即两个
    `Person` 实例。通过比较它们的 `Name` 字段的长度来实现它，如果名称长度相同，则按字母顺序比较名称，如下面的代码所示：
- en: '[PRE54]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In `Program.cs`, add statements to sort the array using an alternative implementation,
    as shown in the following code:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加语句以使用替代实现来对数组进行排序，如下面的代码所示：
- en: '[PRE55]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Run the `PeopleApp` project, and view the result of sorting the people by the
    length of their names and then alphabetically, as shown in the following output:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目，查看按名称长度然后按字母顺序对人员进行排序的结果，如下面的输出所示：
- en: '[PRE56]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This time, when we sort the `people` array, we explicitly ask the sorting algorithm
    to use the `PersonComparer` type instead so that the people are sorted with the
    shortest names first, like `Adam`, and the longest names last, like `Richard`.
    When the lengths of two or more names are equal, they are sorted alphabetically,
    like `Jenny` and `Simon`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当我们对 `people` 数组进行排序时，我们明确要求排序算法使用 `PersonComparer` 类型，以便按名字长度从短到长对人员进行排序，例如
    `Adam`，以及从长到短排序，例如 `Richard`。当两个或更多名字的长度相等时，它们将按字母顺序排序，例如 `Jenny` 和 `Simon`。
- en: Implicit and explicit interface implementations
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式和显式接口实现
- en: Interfaces can be implemented implicitly and explicitly. Implicit implementations
    are simpler and more common. Explicit implementations are only necessary if a
    type must have multiple methods with the same name and signature. Personally,
    the only time I can remember ever having to explicitly implement an interface
    is when writing the code example for this book.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以隐式和显式实现。隐式实现更简单，更常见。显式实现仅在类型必须具有具有相同名称和签名的多个方法时才是必要的。就我个人而言，我记得唯一一次需要显式实现接口是在编写这本书的代码示例时。
- en: For example, both `IGamePlayer` and `IKeyHolder` might have a method called
    `Lose` with the same parameters because both a game and a key can be lost. The
    members of an interface are always and automatically `public` because they have
    to be accessible for another type to implement them!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`IGamePlayer` 和 `IKeyHolder` 都可能有一个名为 `Lose` 的方法，具有相同的参数，因为游戏和钥匙都可能丢失。接口的成员始终且自动是
    `public` 的，因为它们必须可访问，以便其他类型可以实现它们！
- en: 'In a type that must implement both interfaces, only one implementation of `Lose`
    can be the implicit method. If both interfaces can share the same implementation,
    there is no problem, but if not, then the other `Lose` method will have to be
    implemented differently and called explicitly, as shown in the following code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在必须实现两个接口的类型中，只有一个 `Lose` 的隐式方法可以实现。如果两个接口可以共享相同的实现，则没有问题，但如果不行，则其他 `Lose` 方法必须以不同的方式实现并显式调用，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Although the implementation of `IGamePlayer.Lose` in `Human` is `private`, the
    `IGamePlayer.Lose` member itself has an access modifier of `public`, so if we
    cast the `Human` instance into the interface type, then that `Lose` implementation
    is accessible.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 `Human` 中 `IGamePlayer.Lose` 的实现是 `private` 的，但 `IGamePlayer.Lose` 成员本身有一个
    `public` 访问修饰符，所以如果我们将 `Human` 实例转换为接口类型，那么那个 `Lose` 实现是可访问的。
- en: '**Warning!** Method access modifiers in an implementation type must match the
    method definition in the interface. For example, the `Lose` method in the interface
    is `public`, so the method implementation in the class must also be `public`.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！**实现类型中的方法访问修饰符必须与接口中的方法定义匹配。例如，接口中的 `Lose` 方法是 `public`，所以类中的方法实现也必须是
    `public`。'
- en: Defining interfaces with default implementations
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义具有默认实现的接口
- en: A language feature introduced in C# 8 is the **default implementation** for
    an interface. This allows an interface to contain implementation. This breaks
    the clean separation between interfaces that define a contract and classes and
    other types that implement them. It is considered by some .NET developers to be
    a perversion of the language.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8 中引入的一项语言特性是接口的**默认实现**。这允许接口包含实现。这打破了定义契约的接口和实现它们的类以及其他类型之间的清晰分离。一些 .NET
    开发者认为这是对语言的扭曲。
- en: 'Let’s see it in action:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际效果：
- en: 'In the `PacktLibrary` project, add a new file named `IPlayable.cs`, and modify
    the statements to define a public `IPlayable` interface with two methods to `Play`
    and `Pause`, as shown in the following code:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PacktLibrary` 项目中，添加一个名为 `IPlayable.cs` 的新文件，并修改语句以定义一个公共 `IPlayable` 接口，包含两个方法
    `Play` 和 `Pause`，如下面的代码所示：
- en: '[PRE58]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the `PacktLibrary` project, add a new class file named `DvdPlayer.cs`, and
    modify the statements in the file to implement the `IPlayable` interface, as shown
    in the following code:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PacktLibrary` 项目中，添加一个名为 `DvdPlayer.cs` 的新类文件，并修改文件中的语句以实现 `IPlayable` 接口，如下面的代码所示：
- en: '[PRE59]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is useful, but what if we decide to add a third method named `Stop`? Before
    C# 8, this would be impossible once at least one type is implemented in the original
    interface. One of the main traits of an interface is that it is a fixed contract.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有用，但如果我们决定添加一个名为 `Stop` 的第三个方法呢？在 C# 8 之前，一旦在原始接口中实现了一个类型，这将是无法实现的。接口的一个主要特征是它是一个固定的契约。
- en: C# 8 allows you to add new members to an interface after release if those new
    members have a default implementation. C# purists do not like the idea, but for
    practical reasons, such as avoiding breaking changes or having to define a whole
    new interface, it is useful, and other languages such as Java and Swift enable
    similar techniques.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8 允许在发布后向接口添加新成员，如果这些新成员具有默认实现。C# 纯粹主义者不喜欢这个想法，但出于实际原因，例如避免破坏性更改或需要定义全新的接口，这很有用，并且其他语言如
    Java 和 Swift 也启用了类似的技术。
- en: Support for default interface implementations requires some fundamental changes
    to the underlying platform, so they are only supported with C# if the target framework
    is .NET 5 or later, .NET Core 3 or later, or .NET Standard 2.1\. They are, therefore,
    not supported by .NET Framework.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 支持默认接口实现需要对底层平台进行一些基本更改，因此它们仅在目标框架为 .NET 5 或更高版本、.NET Core 3 或更高版本或 .NET Standard
    2.1 时才受支持。因此，.NET Framework 不支持它们。
- en: 'Let’s add a default implementation to the interface:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接口中添加一个默认实现：
- en: 'Modify the `IPlayable` interface to add a `Stop` method with a default implementation,
    as highlighted in the following code:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `IPlayable` 接口修改为添加一个具有默认实现的 `Stop` 方法，如下代码所示：
- en: '[PRE60]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Build the `PeopleApp` project, and note that the projects compile successfully
    despite the `DvdPlayer` class not implementing `Stop`. In the future, we could
    override the default implementation of `Stop` by implementing it in the `DvdPlayer`
    class.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 `PeopleApp` 项目，并注意尽管 `DvdPlayer` 类没有实现 `Stop`，项目仍然编译成功。在未来，我们可以在 `DvdPlayer`
    类中实现 `Stop` 方法来覆盖默认实现。
- en: Although controversial, default implementations in interfaces might be useful
    in scenarios where the most common implementation is known at the time of defining
    the interface. Therefore, it is best if the interface defines that implementation
    once, and then most types that implement that interface can inherit it without
    needing to implement their own. However, if the interface definer does not know
    how the member should or even could be implemented, then it is a waste of effort
    to add a default implementation because it will always be replaced.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有争议，但在接口中添加默认实现可能在定义接口时已知最常见实现的情况下很有用。因此，最好是在接口中定义一次该实现，然后大多数实现该接口的类型可以继承它而无需实现自己的。然而，如果接口定义者不知道成员应该如何或甚至能否实现，那么添加默认实现是徒劳的，因为它总会被替换。
- en: Think about the `IComparable` interface that you saw earlier in this chapter.
    It defines a `CompareTo` method. What might a default implementation of that method
    be? Personally, I think it’s obvious that there is no default implementation that
    would make any practical sense. The least-worst implementation that I can think
    of would be to compare the `string` values returned from calling `ToString` on
    the two objects. However, every type really should implement its own `CompareTo`
    method. You are likely to find the same with 99.9% of the interfaces you use.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你在本章前面看到的 `IComparable` 接口。它定义了一个 `CompareTo` 方法。那个方法的默认实现可能是什么？我个人认为，显然没有默认实现会具有任何实际意义。我能想到的最不糟糕的实现是将两个对象上调用
    `ToString` 返回的 `string` 值进行比较。然而，每个类型实际上都应该实现自己的 `CompareTo` 方法。你很可能会在使用的 99.9%
    的接口中找到相同的情况。
- en: Now let’s look at how to work with null values.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何处理空值。
- en: Working with null values
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理空值
- en: What if a variable does not yet have a value? How can we indicate that? C# has
    the concept of a `null` value, which can be used to indicate that a variable has
    not been set.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个变量还没有值怎么办？我们如何表示这一点？C# 有 `null` 值的概念，可以用来表示变量尚未设置。
- en: 'If you are unsure of the difference between reference types and value types
    in .NET, then I recommend that you read the following online-only section before
    you continue with this section: [https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md).'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定 .NET 中引用类型和值类型之间的区别，那么我建议你在继续阅读本节之前先阅读以下仅在线的章节：[https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md)。
- en: Making a value type nullable
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使值类型可空
- en: By default, **value types** like `int` and `DateTime` must always have a *value*,
    hence their name. Sometimes, for example, when reading values stored in a database
    that allows empty, missing, or `null` values, it is convenient to allow a value
    type to be `null`. We call this a **nullable value type**.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，**值类型**如`int`和`DateTime`必须始终有一个*值*，因此得名。有时，例如，当读取允许空、缺失或`null`值的数据库中存储的值时，允许值类型为`null`是很方便的。我们称这种类型为**可空值类型**。
- en: You can enable this by adding a question mark as a suffix to the type when declaring
    a variable.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在声明变量时将问号作为后缀来启用此功能。
- en: 'Let’s see an example. We will create a new project because some of the null
    handling options are set at the project level:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。我们将创建一个新的项目，因为一些null处理选项是在项目级别设置的：
- en: Use your preferred code editor to add a new **Console App**/`console` project
    named `NullHandling` to the `Chapter06` solution.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的代码编辑器将一个新的**控制台应用程序**/`console`项目命名为`NullHandling`添加到`Chapter06`解决方案中。
- en: In `NullHandling.csproj`, add an `<ItemGroup>` to globally and statically import
    the `System.Console` class.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NullHandling.csproj`中，添加一个`<ItemGroup>`以全局和静态导入`System.Console`类。
- en: 'In `Program.cs`, delete the existing statements, and then add statements to
    declare and assign values, including `null`, two `int` variables, one suffixed
    with `?` and one not, as shown in the following code:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有的语句，然后添加声明和赋值的语句，包括`null`，两个`int`变量，一个带有`?`后缀，一个不带，如下面的代码所示：
- en: '[PRE61]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Build the project and note the compile error, as shown in the following output:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并注意编译错误，如下面的输出所示：
- en: '[PRE62]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Comment out the statement that gives the compile error, as shown in the following
    code:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉导致编译错误的语句，如下面的代码所示：
- en: '[PRE63]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Run the project and view the result, as shown in the following output:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行项目并查看结果，如下面的输出所示：
- en: '[PRE64]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The second line is blank because it outputs the `null` value.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行是空的，因为它输出了`null`值。
- en: 'Add statements to use alternative syntax, as shown in the following code:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以使用替代语法，如下面的代码所示：
- en: '[PRE65]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Click on `Nullable<int>` and press *F12*, or right-click and choose **Go To
    Definition**.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Nullable<int>`并按*F12*，或右键单击并选择**转到定义**。
- en: 'Note that the generic value type, `Nullable<T>`, must have a type `T`, which
    is a `struct`, or a value type. It has useful members like `HasValue`, `Value`,
    and `GetValueOrDefault`, as shown in *Figure 6.1*:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，泛型值类型`Nullable<T>`必须有一个类型`T`，它是一个`struct`或值类型。它具有如`HasValue`、`Value`和`GetValueOrDefault`等有用的成员，如图6.1所示：
- en: '![](img/B22322_06_01.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_06_01.png)'
- en: 'Figure 6.1: Revealing Nullable<T> members'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：揭示`Nullable<T>`成员
- en: '**Good Practice**: When you append a `?` after a `struct` type, you change
    it to a different type. For example, `DateTime?` becomes `Nullable<DateTime>`.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：当你在`struct`类型后追加一个`?`时，你将其转换为不同的类型。例如，`DateTime?`变为`Nullable<DateTime>`。'
- en: Understanding null-related initialisms
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解与null相关的缩写
- en: 'Before we see some code, let’s review some commonly used initialisms in *Table
    6.3*:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看一些代码之前，让我们回顾一下表6.3中的一些常用缩写：
- en: '| **Initialism** | **Meaning** | **Description** |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| **缩写** | **含义** | **描述** |'
- en: '| NRT | Nullable Reference Type | This is a compiler feature introduced with
    C# 8 and enabled by default in new projects with C# 10, which performs static
    analysis of your code at design time and shows warnings of potential misuse of
    `null` values for reference types. |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| NRT | 可空引用类型 | 这是C# 8中引入的编译器功能，在C# 10的新项目中默认启用，它在设计时对您的代码进行静态分析，并显示对引用类型`null`值潜在误用的警告。
    |'
- en: '| NRE | `NullReferenceException` | This is an exception thrown at runtime when
    **dereferencing** a `null` value, also known as accessing a variable or member
    on an object that is `null`. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| NRE | `NullReferenceException` | 当**取消引用**一个`null`值时，在运行时抛出此异常，也称为访问一个`null`对象上的变量或成员。
    |'
- en: '| ANE | `ArgumentNullException` | This is an exception thrown at runtime by
    a method, property, or indexer invocation when an argument or value is `null`,
    and when the business logic determines that it is not valid. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| ANE | `ArgumentNullException` | 当方法、属性或索引器调用抛出异常时，如果参数或值为`null`，并且业务逻辑确定它无效，则会在运行时抛出此异常。
    |'
- en: 'Table 6.3: Commonly used initialisms'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.3：常用缩写
- en: Understanding nullable reference types
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解可空引用类型
- en: The use of the `null` value is so common, in so many languages, that many experienced
    programmers never question the need for its existence. However, there are many
    scenarios where we could write better, simpler code if a variable is not allowed
    to have a `null` value.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`值的用法在许多语言中都很常见，以至于许多经验丰富的程序员从未质疑其存在的必要性。然而，有许多场景，如果我们不允许变量有`null`值，我们可以编写更好、更简单的代码。'
- en: The most significant change to the C# 8 language compiler was the introduction
    of checks and warnings for nullable and non-nullable reference types. *“But wait!”*,
    you are probably thinking. *“Reference types are already nullable!”*
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8语言编译器最显著的变化是引入了对可空和不可空引用类型的检查和警告。*“但是等等！”*，你可能正在想。*“引用类型已经是可空的！”*
- en: And you would be right, but in C# 8 and later, reference types can be configured
    to warn you about `null` values by setting a file- or project-level option, enabling
    this useful new feature. Since this is a big change for C#, Microsoft decided
    to make the feature an opt-in.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你是对的，但在C# 8及以后的版本中，可以通过设置文件或项目级别的选项来配置引用类型，以警告`null`值，从而启用这个有用的新功能。由于这是C#的一个重大变化，微软决定将此功能作为可选功能。
- en: It will take several years for this new C# language compiler feature to make
    an impact, since thousands of existing library packages and apps will expect the
    old behavior. Even Microsoft did not have time to fully implement this new feature
    in all the main .NET packages until .NET 6\. Important libraries like `Microsoft.Extensions`
    for logging, dependency injections, and configuration were not annotated until
    .NET 7.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数千个现有的库包和应用程序将期望旧的行为，这个新的C#语言编译器功能要产生影响可能需要几年时间。甚至微软也没有时间在所有主要的.NET包中完全实现这个新功能，直到.NET
    6。像`Microsoft.Extensions`这样的重要库，用于日志记录、依赖注入和配置，直到.NET 7才进行注解。
- en: 'During the transition, you can choose between several approaches for your own
    projects:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在过渡期间，你可以为你的项目选择几种方法：
- en: '**Default**: For projects created using .NET 5 or earlier, no changes are needed.
    Non-nullable reference types are not checked. For projects created using .NET
    6 or later, nullability checks are enabled by default, but this can be disabled
    by either deleting the `<Nullable>` entry in the project file or setting it to
    `disable`.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认**：对于使用.NET 5或更早版本创建的项目，不需要进行任何更改。不可为空的引用类型不会被检查。对于使用.NET 6或更高版本创建的项目，默认启用nullability检查，但可以通过删除项目文件中的`<Nullable>`条目或将它设置为`disable`来禁用。'
- en: '**Opt-in project and opt-out files**: Enable the feature at the project level,
    and for any files that need to remain compatible with old behavior, opt out. This
    was the approach Microsoft used internally while it updated its own packages to
    use this new feature.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择加入项目和选择退出文件**：在项目级别启用功能，对于需要保持与旧行为兼容的任何文件，选择退出。这是微软在更新其自己的包以使用此新功能时内部使用的做法。'
- en: '**Opt-in files**: Only enable the NRT feature for individual files.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择加入文件**：仅对单个文件启用NRT功能。'
- en: '**Warning!** This NRT feature does not *prevent* `null` values – it just *warns*
    you about them, and the warnings can be disabled, so you still need to be careful!
    For example, using the `?` character to declare a variable as nullable does not
    allow `null` values, it just disables the warning, as shown in the following code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！** 此NRT功能并不能**阻止**`null`值，它只是**警告**你有关它们的信息，而且警告可以被禁用，所以你仍然需要小心！例如，使用`?`字符声明一个变量为可空并不允许`null`值，它只是禁用了警告，如下面的代码所示：'
- en: '[PRE66]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Controlling the nullability warning check feature
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制nullability警告检查功能
- en: 'To enable the nullability warning check feature at the project level, have
    the `<Nullable>` element set to `enable` in your project file, as highlighted
    in the following markup:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目级别启用nullability警告检查功能，请在项目文件中将`<Nullable>`元素设置为`enable`，如下面的标记所示：
- en: '[PRE67]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To disable the nullability warning check feature at the project level, have
    the `<Nullable>` element set to `disable` in your project file, as highlighted
    in the following markup:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目级别禁用nullability警告检查功能，请在项目文件中将`<Nullable>`元素设置为`disable`，如下面的标记所示：
- en: '[PRE68]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You could also remove the `<Nullable>` element completely because the default,
    if not explicitly set, is disabled.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以完全删除`<Nullable>`元素，因为默认情况下如果没有明确设置，则禁用。
- en: 'To disable the feature at the file level, add the following at the top of a
    code file:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要在文件级别禁用此功能，请在代码文件顶部添加以下内容：
- en: '[PRE69]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To enable the feature at the file level, add the following at the top of a
    code file:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要在文件级别启用此功能，请在代码文件顶部添加以下内容：
- en: '[PRE70]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Disabling null and other compiler warnings
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用null和其他编译器警告
- en: 'You could decide to enable the nullability feature at the project or file level
    but then disable some of the 50+ warnings related to it. Some common nullability
    warnings are shown in *Table 6.4*:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择在项目或文件级别启用可空性功能，但随后可能需要禁用与它相关的50多个警告。一些常见的可空性警告如下表6.4所示：
- en: '| **Code** | **Description** |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| **代码** | **描述** |'
- en: '| `CS8600` | Converting a null literal or a possible null value to a non-nullable
    type |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `CS8600` | 将空字面量或可能的空值转换为非可空类型 |'
- en: '| `CS8601` | A possible null reference assignment |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| `CS8601` | 一个可能的空引用赋值 |'
- en: '| `CS8602` | A dereference of a possibly null reference |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| `CS8602` | 可能的空引用解引用 |'
- en: '| `CS8603` | A possible null reference return |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| `CS8603` | 一个可能的空引用返回 |'
- en: '| `CS8604` | A possible null reference argument for a parameter |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| `CS8604` | 参数的一个可能的空引用参数 |'
- en: '| `CS8618` | A non-nullable field `<field_name>` must contain a non-null value
    when exiting a constructor. Consider declaring the field as nullable |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| `CS8618` | 当退出构造函数时，非可空字段`<field_name>`必须包含一个非空值。考虑将字段声明为可空的 |'
- en: '| `CS8625` | Cannot convert a null literal to a non-nullable reference type
    |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| `CS8625` | 无法将空字面量转换为非可空引用类型 |'
- en: '| `CS8655` | The switch expression does not handle some null inputs (it is
    not exhaustive) |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| `CS8655` | switch表达式没有处理一些空输入（它不是详尽的） |'
- en: 'Table 6.4: Common nullability warnings'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.4：常见的可空性警告
- en: 'You can disable compiler warnings for a whole project. To do so, add a `NoWarn`
    element with a semicolon-separated list of compiler warning codes, as shown in
    the following markup:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以禁用整个项目的编译器警告。为此，添加一个`NoWarn`元素，其中包含用分号分隔的编译器警告代码列表，如下面的标记所示：
- en: '[PRE71]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To disable compiler warnings at the statement level, you can disable and then
    restore a specified compiler warning to temporarily suppress it for a block of
    statements, as shown in the following code:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 要在语句级别禁用编译器警告，你可以禁用并恢复指定的编译器警告，以暂时抑制一组语句，如下面的代码所示：
- en: '[PRE72]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: These techniques can be used for any compiler warnings, not just those related
    to nullability.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术可以用于任何编译器警告，而不仅仅是与可空性相关的警告。
- en: Declaring non-nullable variables and parameters
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明非可空变量和参数
- en: If you enable NRTs and you want a reference type to be assigned the `null` value,
    then you will have to use the same syntax to make a value type nullable, that
    is, adding a `?` symbol after the type declaration.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启用了NRTs并且想要将`null`值分配给引用类型，那么你必须使用相同的语法来使值类型可空，即在类型声明后添加一个`?`符号。
- en: 'So, how do NRTs work? Let’s look at an example. When storing information about
    an address, you might want to force a value for the street, city, and region,
    but the building can be left blank, that is, `null`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，NRTs是如何工作的呢？让我们看一个例子。当存储关于地址的信息时，你可能想要强制为街道、城市和地区设置一个值，但建筑可以留空，即`null`：
- en: In the `NullHandling` project, add a class file named `Address.cs`.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NullHandling`项目中，添加一个名为`Address.cs`的类文件。
- en: 'In `Address.cs`, delete any existing statements and then add statements to
    declare an `Address` class with four fields, as shown in the following code:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Address.cs`中，删除任何现有的语句，然后添加语句来声明一个具有四个字段的`Address`类，如下面的代码所示：
- en: '[PRE73]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'After a few seconds, note the warnings about non-nullable fields, like `Street`
    not being initialized, as shown in *Figure 6.2*:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，注意关于非可空字段的警告，例如`Street`未初始化，如下表6.2所示：
- en: '![](img/B22322_06_02.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_06_02.png)'
- en: 'Figure 6.2: Warning messages about non-nullable fields in the Error List window'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：错误列表窗口中的非可空字段警告信息
- en: 'Assign the empty `string` value to the `Street` field, and define constructors
    to set the other fields that are non-nullable, as highlighted in the following
    code:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将空`string`值分配给`Street`字段，并定义构造函数来设置其他非空字段，如下面的代码所示：
- en: '[PRE74]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In `Program.cs`, import the namespace to use `Address`, as shown in the following
    code:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，导入命名空间以使用`Address`，如下面的代码所示：
- en: '[PRE75]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In `Program.cs`, add statements to instantiate an `Address` and set its properties,
    as shown in the following code:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句来实例化一个`Address`并设置其属性，如下面的代码所示：
- en: '[PRE76]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Note the `Warning` `CS8625` on setting the `Street` but not the `Building`,
    as shown in the following output:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意设置`Street`时的`Warning` `CS8625`，但没有`Building`，如下面的输出所示：
- en: '[PRE77]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Append an exclamation mark to `null` when setting `Street`, as highlighted
    in the following code:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置`Street`时，在`null`后添加一个感叹号，如下面的代码所示：
- en: '[PRE78]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note that the warning disappears.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意警告消失了。
- en: 'Add statements that will dereference the `Building` and `Street` properties,
    as shown in the following code:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加将取消引用 `Building` 和 `Street` 属性的语句，如下面的代码所示：
- en: '[PRE79]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Note the `Warning CS8602` on setting the `Building` but not the `Street`, as
    shown in the following output:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意设置 `Building` 但没有设置 `Street` 时的 `Warning CS8602`，如下面的输出所示：
- en: '[PRE80]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: At runtime it is still possible for an exception to be thrown when working with
    `Street`, but the compiler should continue to warn you of potential exceptions
    when working with `Building` so that you can change your code to avoid them.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，当与 `Street` 一起工作时，仍然可能会抛出异常，但编译器应该继续警告你与 `Building` 一起工作时可能出现的潜在异常，这样你就可以更改代码以避免它们。
- en: 'Use the null-conditional operator to return `null` instead of accessing the
    `Length`, as shown in the following code:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用空条件运算符返回 `null` 而不是访问 `Length`，如下面的代码所示：
- en: '[PRE81]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Run the console app, and note that the statement that accesses the `Length`
    of the `Building` outputs a `null` value (blank line), but a runtime exception
    occurs when we access the `Length` of the `Street`, as shown in the following
    output:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，注意访问 `Building` 的 `Length` 输出 `null` 值（空白行），但当我们访问 `Street` 的 `Length`
    时，会抛出运行时异常，如下面的输出所示：
- en: '[PRE82]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Wrap the statement that accesses the `Street` length in a null check, as shown
    in the following code:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将访问 `Street` 长度的语句包裹在空检查中，如下面的代码所示：
- en: '[PRE83]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: It is worth reminding yourself that an NRT is only about asking the compiler
    to provide warnings about potential `null` values that might cause problems. It
    does not actually change the behavior of your code. It performs a static analysis
    of your code at compile time.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 值得提醒的是，NRTs 只关于请求编译器提供有关可能引起问题的潜在 `null` 值的警告。它实际上并不改变你的代码的行为。它是在编译时对代码进行静态分析。
- en: This explains why the new language feature is named **nullable reference types**
    (**NRTs**). Starting with C# 8, unadorned reference types can become non-nullable,
    and the same syntax is used to make a reference type nullable, as it is used for
    value types.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么新的语言特性被命名为 **可空引用类型**（**NRTs**）。从 C# 8 开始，未修饰的引用类型可以变为不可空，并且使用与值类型相同的语法来使引用类型变为可空。
- en: Suffixing a reference type with `?` does not change the type. This is different
    from suffixing a value type with `?`, which changes its type to `Nullable<T>`.
    Reference types can already have `null` values. All you do with **NRTs** is tell
    the compiler that you expect it to be `null`, so the compiler does not need to
    warn you. However, this does not remove the need to perform `null` checks throughout
    your code.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在引用类型后添加 `?` 并不会改变类型。这与在值类型后添加 `?` 不同，后者将其类型更改为 `Nullable<T>`。引用类型已经可以具有 `null`
    值。你通过 **NRTs** 做的只是告诉编译器你期望它为 `null`，因此编译器不需要警告你。然而，这并不消除在整个代码中执行 `null` 检查的需要。
- en: Now let’s look at language features to work with `null` values that change the
    behavior of your code and work well as a complement to NRTs.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看与 `null` 值一起工作的语言特性，这些特性会改变你的代码的行为，并且作为 NRTs 的良好补充。
- en: Checking for null
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查空值
- en: 'Checking whether a nullable reference type or value type variable currently
    contains `null` is important because if you do not, a `NullReferenceException`
    can be thrown, which results in an error. You should check for a `null` value
    before using a nullable variable, as shown in the following code:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一个可空引用类型或值类型变量当前是否包含 `null` 是很重要的，因为如果你不这样做，可能会抛出 `NullReferenceException`
    异常，从而导致错误。在使用可空变量之前，你应该检查 `null` 值，如下面的代码所示：
- en: '[PRE84]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'C# 7 introduced `is` combined with the `!` (`not`) operator as an alternative
    to `!=`, as shown in the following code:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7 引入了 `is` 与 `!`（非）操作符的组合作为 `!=` 的替代方案，如下面的代码所示：
- en: '[PRE85]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'C# 9 introduced `is not` as an even clearer alternative, as shown in the following
    code:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9 引入了 `is not` 作为 `!=` 的一个更清晰的替代方案，如下面的代码所示：
- en: '[PRE86]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '**Good Practice**: Although you would traditionally use the expression `(thisCouldBeNull
    != null)`, this is no longer considered good practice because the developer could
    have overloaded the `!=` operator to change how it works. Using pattern matching
    with `is null` and `is not null` is the only guaranteed way to check for `null`.
    For many developers, it is still instinctual to use `!=`, so I apologize in advance
    if you catch me still using it!'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：虽然你传统上会使用 `(thisCouldBeNull != null)` 这样的表达式，但这已经不再被认为是良好的实践，因为开发者可能已经重载了
    `!=` 操作符来改变其工作方式。使用 `is null` 和 `is not null` 的模式匹配是检查 `null` 的唯一保证方法。对于许多开发者来说，使用
    `!=` 仍然是一种本能，所以如果我发现我还在使用它，我提前向你道歉！'
- en: 'Since the `is` operator cannot be overloaded by a developer, its behavior is
    guaranteed. Both the `==` and `!=` operators could be overloaded by a developer
    so their behavior could change. The .NET team has now consistently implemented
    their null checks using `is`, so I recommend that you do the same, as you can
    see at the following link:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `is` 运算符不能被开发者重载，其行为是保证的。`==` 和 `!=` 运算符可以被开发者重载，因此它们的行为可能会改变。.NET 团队现在已经一致地使用
    `is` 来实现它们的空值检查，所以我建议你也这样做，如下面的链接所示：
- en: '[https://twitter.com/Dave_DotNet/status/1764995927868076428](https://twitter.com/Dave_DotNet/status/1764995927868076428)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://twitter.com/Dave_DotNet/status/1764995927868076428](https://twitter.com/Dave_DotNet/status/1764995927868076428)'
- en: The term *overriding* is about altering or extending the behavior of an inherited
    method in the context of object-oriented inheritance. *Overloading* occurs when
    you provide a new implementation for an existing operator or method.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: “重写”这个术语是指在面向对象继承的上下文中改变或扩展继承方法的行为。“重载”发生在你为现有的运算符或方法提供新的实现时。
- en: 'If you try to use a member of a variable that might be `null`, use the **null-conditional
    operator**, `?.`, as shown in the following code:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用可能为 `null` 的变量的成员，请使用 **空条件运算符** `?.`，如下面的代码所示：
- en: '[PRE87]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Sometimes, you want to either assign a variable to a result or use an alternative
    value, such as `3`, if the variable is `null`. You do this using the **null-coalescing
    operator**, `??`, as shown in the following code:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能想要将变量分配给结果，或者如果变量为 `null`，则使用替代值，例如 `3`。你可以使用 **空合并运算符** `??` 来完成这个操作，如下面的代码所示：
- en: '[PRE88]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Checking for null in method parameters
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在方法参数中检查 `null`
- en: Even if you enable NRTs, when defining methods with parameters, it is good practice
    to check for `null` values.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你启用了 NRTs，在定义带有参数的方法时，检查 `null` 值也是良好的实践。
- en: 'In earlier versions of C#, you would have to write `if` statements to check
    for `null` parameter values and then throw an `ArgumentNullException` for any
    parameter that is `null`, as shown in the following code:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 的早期版本中，你必须编写 `if` 语句来检查 `null` 参数值，然后为任何 `null` 参数抛出 `ArgumentNullException`
    异常，如下面的代码所示：
- en: '[PRE89]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'C# 10 introduced a convenience method to throw an exception if an argument
    is `null`, as shown in the following code:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: C# 10 引入了一个便利方法，如果参数为 `null`，则会抛出异常，如下面的代码所示：
- en: '[PRE90]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'C# 11 previews proposed and introduced a new `!!` operator that does this for
    you, as shown in the following code:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: C# 11 预览版提出了并引入了一个新的 `!!` 运算符，它可以为你完成这个操作，如下面的代码所示：
- en: '[PRE91]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The `if` statement and throwing of the exception would be done for you. The
    code is injected and executed before any statements that you write.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句和异常的抛出将由系统自动完成。代码会在你编写的任何语句之前注入并执行。'
- en: This proposal was controversial within the C# developer community. Some would
    prefer the use of attributes to decorate parameters instead of a pair of characters.
    The .NET product team said they reduced the .NET libraries by more than 10,000
    lines of code by using this feature.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提议在 C# 开发者社区中引起了争议。有些人可能更愿意使用属性来装饰参数，而不是一对字符。.NET 产品团队表示，他们通过使用这个特性将 .NET
    库减少了超过 10,000 行代码。
- en: 'That sounds like a good reason to use it to me! And no one must use it if they
    choose not to. Unfortunately, the team eventually decided to remove the feature,
    so now we all have to write the null checks manually. If you’re interested in
    this story, then you can read more about it at the following link:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是一个使用它的好理由！而且，如果他们选择不使用，没有人必须使用它。不幸的是，团队最终决定删除这个特性，所以我们现在都必须手动编写空值检查。如果你对这个故事感兴趣，你可以在以下链接中了解更多信息：
- en: '[https://devblogs.microsoft.com/dotnet/csharp-11-preview-updates/#remove-parameter-null-checking-from-c-11](https://devblogs.microsoft.com/dotnet/csharp-11-preview-updates/#remove-parameter-null-checking-from-c-11)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/csharp-11-preview-updates/#remove-parameter-null-checking-from-c-11](https://devblogs.microsoft.com/dotnet/csharp-11-preview-updates/#remove-parameter-null-checking-from-c-11)'
- en: I include this story in this book because I think it’s an interesting example
    of Microsoft being transparent, by developing .NET in the open and listening to
    and responding to feedback from the community.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这个故事包含在这本书中，因为我认为它是微软透明度的一个有趣例子，通过在公开环境中开发 .NET 并倾听并回应社区的反馈。
- en: '**Good Practice**: Always remember that nullable is a warning check, not an
    enforcement. You can read more about the compiler warnings relating to `null`
    at the following link:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：始终记住，可空性是一个警告检查，而不是强制执行。你可以在以下链接中了解更多有关与 `null` 相关的编译器警告的信息：'
- en: '[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/nullable-warnings](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/nullable-warnings)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/nullable-warnings](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/nullable-warnings)'
- en: That’s more than enough talk about “nothing”! Let’s look at the meat of this
    chapter, inheritance.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 关于“无”的讨论已经足够多了！让我们看看本章的重点，继承。
- en: Inheriting from classes
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从类中继承
- en: 'The `Person` type we created earlier derived (inherited) from `System.Object`.
    Now, we will create a subclass that inherits from `Person`:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建的 `Person` 类型是从 `System.Object` 继承（继承）的。现在，我们将创建一个从 `Person` 继承的子类：
- en: In the `PacktLibrary` project, add a new class file named `Employee.cs`.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PacktLibrary` 项目中，添加一个名为 `Employee.cs` 的新类文件。
- en: 'Modify its contents to define a class named `Employee` that derives from `Person`,
    as shown in the following code:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改其内容以定义一个名为 `Employee` 的类，该类从 `Person` 继承，如下面的代码所示：
- en: '[PRE92]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'In the `PeopleApp` project, in `Program.cs`, add statements to create an instance
    of the `Employee` class, as shown in the following code:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PeopleApp` 项目中，在 `Program.cs` 文件中添加语句以创建 `Employee` 类的一个实例，如下面的代码所示：
- en: '[PRE93]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下面的输出所示：
- en: '[PRE94]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Note that the `Employee` class has inherited all the members of `Person`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Employee` 类继承了 `Person` 类的所有成员。
- en: Extending classes to add functionality
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展类以添加功能
- en: 'Now, we will add some employee-specific members to extend the class:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一些特定于员工的新成员以扩展这个类：
- en: 'In `Employee.cs`, add statements to define two properties, for an employee
    code and the date they were hired (we do not need to know a start time, so we
    can use the `DateOnly` type), as shown in the following code:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Employee.cs` 文件中，添加语句以定义两个属性，一个用于员工代码，另一个用于他们被雇佣的日期（我们不需要知道开始时间，因此可以使用 `DateOnly`
    类型），如下面的代码所示：
- en: '[PRE95]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'In `Program.cs`, add statements to set John’s employee code and hire date,
    as shown in the following code:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加语句以设置约翰的员工代码和雇佣日期，如下面的代码所示：
- en: '[PRE96]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下面的输出所示：
- en: '[PRE97]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Hiding members
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏成员
- en: 'So far, the `WriteToConsole` method is inherited from `Person`, and it only
    outputs the employee’s name and date and time of birth. We might want to change
    what this method does for an employee:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`WriteToConsole` 方法是从 `Person` 继承的，并且它只输出员工的名字和出生日期和时间。我们可能想要改变这个方法对员工的行为：
- en: 'In `Employee.cs`, add statements to redefine the `WriteToConsole` method, as
    highlighted in the following code:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Employee.cs` 文件中，添加语句以重新定义 `WriteToConsole` 方法，如下面的代码所示：
- en: '[PRE98]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Run the `PeopleApp` project, view the result, and note that the first line
    of output is before the employees were hired; hence, it has a default date, as
    shown in the following output:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目，查看结果，并注意输出中的第一行是在员工被雇佣之前；因此，它有一个默认日期，如下面的输出所示：
- en: '[PRE99]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Your code editor warns you that your method now hides the method from `Person`
    by drawing a squiggle under the method name, the **PROBLEMS**/**Error List** window
    includes more details, and the compiler will output a warning when you build and
    run the console application, as shown in *Figure 6.3*:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码编辑器会警告你，你的方法现在通过在方法名下画波浪线来隐藏 `Person` 中的方法，**问题**/**错误列表**窗口包含更多详细信息，并且在构建和运行控制台应用程序时，编译器会输出警告，如图
    *6.3* 所示：
- en: '![](img/B22322_06_03.png)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_06_03.png)'
- en: 'Figure 6.3: Hidden method warning'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3：隐藏方法警告
- en: 'As the warning describes, you should hide this message by applying the `new`
    keyword to the method, indicating that you are deliberately replacing the old
    method, as highlighted in the following code:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如警告所述，你应该通过应用 `new` 关键字来隐藏这个消息，这表示你故意替换了旧方法，如下面的代码所示：
- en: '[PRE100]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Make this fix now.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 现在立即修复这个问题。
- en: Understanding the this and base keywords
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 this 和 base 关键字
- en: 'There are two special C# keywords that can be used to refer to the current
    object instance or the base class that it inherits from:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个特殊的 C# 关键字可以用来引用当前对象实例或它继承的基类：
- en: '`this`: It represents the current object instance. For example, in the `Person`
    class instance members (but not in static members), you could use the expression
    `this.Born` to access the `Born` field of the current object instance. You rarely
    need to use it, since the expression `Born` would also work. It is only when there
    is a local variable also named `Born` that you would need to use `this.Born` to
    explicitly say you are referring to the field, not the local variable.'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this`：它代表当前对象实例。例如，在 `Person` 类的实例成员（但不在静态成员中），你可以使用表达式 `this.Born` 来访问当前对象实例的
    `Born` 字段。你很少需要使用它，因为表达式 `Born` 也会起作用。只有当存在一个也命名为 `Born` 的局部变量时，你才需要使用 `this.Born`
    来明确表示你正在引用字段，而不是局部变量。'
- en: '`base`: It represents the base class that the current object inherits from.
    For example, anywhere in the `Person` class, you could use the expression `base.ToString()`
    to call the base class implementation of that method.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base`：它代表当前对象继承的基类。例如，在 `Person` 类的任何地方，你可以使用表达式 `base.ToString()` 来调用该方法的基类实现。'
- en: You will (hopefully) remember from *Chapter 5*, *Building Your Own Types with
    Object-Oriented Programming*, that to access static members, you must use the
    type name.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该（希望）从 *第5章*，*使用面向对象编程构建自己的类型* 中记住，要访问静态成员，必须使用类型名称。
- en: Overriding members
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖成员
- en: Rather than hiding a method, it is usually better to **override** it. You can
    only override it if the base class chooses to allow overriding, by applying the
    `virtual` keyword to any methods that should allow overriding.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 与隐藏方法相比，通常更好的做法是 **覆盖** 它。只有当基类选择允许覆盖时，你才能覆盖它，通过将 `virtual` 关键字应用于应允许覆盖的任何方法。
- en: 'Let’s see an example:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: 'In `Program.cs`, add a statement to write the value of the `john` variable
    to the console using its `string` representation, as shown in the following code:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加一个语句将 `john` 变量的值使用其 `string` 表示形式写入控制台，如下面的代码所示：
- en: '[PRE101]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Run the `PeopleApp` project and note that the `ToString` method is inherited
    from `System.Object`, so the implementation returns the namespace and type name,
    as shown in the following output:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并注意，`ToString` 方法是从 `System.Object` 继承的，因此其实现返回命名空间和类型名称，如下面的输出所示：
- en: '[PRE102]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'In `Person.cs` (not in the `Employee` class!), override this behavior by adding
    a `ToString` method to output the name of the person as well as the type name,
    as shown in the following code:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Person.cs`（不在 `Employee` 类中！）中，通过添加一个 `ToString` 方法来覆盖此行为，输出人员的名称以及类型名称，如下面的代码所示：
- en: '[PRE103]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The `base` keyword allows a subclass to access members of its superclass, that
    is, the **base class** that it inherits or derives from.
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`base` 关键字允许子类访问其超类的成员，即它继承或派生的 **基类**。'
- en: '**Good Practice**: Some code editors like Visual Studio will automatically
    add a call to the base class member when you override a member. To decide if you
    need to keep the call or not, view the tooltip or definition of the member. For
    example, in *Chapter 10*, *Working with Data Using Entity Framework Core*, you
    will override a method of the `DbContext` class named `OnConfiguring`. If you
    hover over the method name, its tooltip tells you “The base implementation does
    nothing.” If you **Go To Definition** (*F12*) of the method, you will see that
    it does nothing, as shown in the following code:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：一些代码编辑器，如 Visual Studio，在覆盖成员时将自动添加对基类成员的调用。为了决定是否需要保留此调用，请查看成员的提示或定义。例如，在
    *第10章*，*使用 Entity Framework Core 处理数据* 中，你将覆盖 `DbContext` 类的一个名为 `OnConfiguring`
    的方法。如果你将鼠标悬停在方法名称上，其提示会告诉你“基类实现不执行任何操作。”如果你 **转到定义** (*F12*) 方法，你会看到它确实不执行任何操作，如下面的代码所示：'
- en: '[PRE104]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The method only exists in the base class so that subclasses can override it
    and then EF Core can call your code when it needs to configure the data context.
    It would be a waste for your overridden method implementation to call the base
    implementation.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法仅存在于基类中，这样子类就可以覆盖它，然后当 EF Core 需要配置数据上下文时可以调用你的代码。覆盖方法实现调用基类实现将是一种浪费。
- en: 'Run the `PeopleApp` project and view the result. Now, when the `ToString` method
    is called, it outputs the person’s name, as well as returning the base class’s
    implementation of `ToString`, as shown in the following output:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果。现在，当调用 `ToString` 方法时，它将输出人员的名称，同时返回基类的 `ToString` 实现如下所示：
- en: '[PRE105]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '**Good Practice**: Many real-world APIs, for example, Microsoft’s Entity Framework
    Core, Castle’s DynamicProxy, and Optimizely CMS’s content models, require the
    properties that you define in your classes to be marked as `virtual` so that they
    can be overridden. Carefully decide which of your methods and property members
    should be marked as `virtual`.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：许多现实世界的 API，例如微软的 Entity Framework Core、Castle 的 DynamicProxy 和 Optimizely
    CMS 的内容模型，要求你在类中定义的属性被标记为 `virtual`，这样它们才能被重写。仔细决定哪些方法和属性成员应该被标记为 `virtual`。'
- en: Inheriting from abstract classes
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从抽象类继承
- en: Earlier in this chapter, you learned about interfaces that can define a set
    of members that a type must have to meet a basic level of functionality. These
    are very useful, but their main limitation is that until C# 8 they could not provide
    any implementation of their own.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，你学习了可以定义一组成员的类型，这些成员必须满足基本功能级别。这些非常有用，但它们的主要限制是，直到 C# 8，它们不能提供自己的任何实现。
- en: This is a particular problem if you still need to create class libraries that
    will work with .NET Framework and other platforms that do not support .NET Standard
    2.1.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特别的问题，如果你仍然需要创建将与 .NET Framework 和不支持 .NET Standard 2.1 的其他平台一起工作的类库。
- en: In those earlier platforms, you could use an **abstract class** as a sort of
    halfway house between a pure interface and a fully implemented class.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些早期的平台上，你可以使用一个 **abstract class** 作为纯接口和完全实现类之间的某种中间解决方案。
- en: When a class is marked as `abstract`, this means that it cannot be instantiated
    because you have indicated that the class is not complete. It needs more implementation
    before it can be instantiated.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类被标记为 `abstract` 时，这意味着它不能被实例化，因为你已经表明这个类是不完整的。在它可以被实例化之前，它需要更多的实现。
- en: For example, the `System.IO.Stream` class is `abstract` because it implements
    common functionality that all streams would need but is not complete. Therefore,
    it is useless without more implementation that is specific to the type of stream,
    so you cannot instantiate it using `new Stream()`.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`System.IO.Stream` 类是 `abstract` 的，因为它实现了所有流都需要但又不完整的通用功能。因此，如果没有更多针对特定流类型的特定实现，它就毫无用处，所以你不能使用
    `new Stream()` 来实例化它。
- en: 'Let’s compare the two types of interface and the two types of class, as shown
    in the following code:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较以下代码中显示的两种接口类型和两种类类型：
- en: '[PRE106]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Choosing between an interface and an abstract class
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在接口和抽象类之间进行选择
- en: You have now seen examples of implementing the concept of abstraction using
    either an interface or an `abstract` class. Which should you pick? Now that an
    interface can have default implementations for its members, is the `abstract`
    keyword for a class obsolete?
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了使用接口或 `abstract` 类实现抽象概念的示例。你应该选择哪一个？现在，由于接口可以为它的成员提供默认实现，类中的 `abstract`
    关键字是否已经过时了？
- en: Well, let’s think about a real example. `Stream` is an `abstract` class. Would
    or could the .NET team use an interface for that today?
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们考虑一个真实的例子。`Stream` 是一个 `abstract` 类。.NET 团队今天会使用接口来处理它吗？
- en: Every member of an interface must be `public` (or at least match the interface’s
    access level, which could be `internal` if it should only be used in the class
    library that it’s defined in). An `abstract` class has more flexibility in its
    members’ access modifiers.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的所有成员都必须是 `public`（或者至少与接口的访问级别相匹配，如果它应该只在其定义的类库中使用，则可以是 `internal`）。抽象类在其成员的访问修饰符方面有更多的灵活性。
- en: Another advantage of an `abstract` class over an interface is that serialization
    often does not work for an interface. So, no, we still need to be able to define
    abstract classes.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 与接口相比，抽象类的一个优点是，序列化通常不适用于接口。所以，不，我们仍然需要能够定义抽象类。
- en: Preventing inheritance and overriding
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止继承和重写
- en: 'You can prevent another developer from inheriting from your class by applying
    the `sealed` keyword to its definition. For example, no one can inherit from Scrooge
    McDuck, as shown in the following code:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将 `sealed` 关键字应用于其定义来防止其他开发者从你的类继承。例如，正如以下代码所示，没有人可以从 Scrooge McDuck 继承。
- en: '[PRE107]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: An example of `sealed` in .NET is the `string` class. Microsoft has implemented
    some extreme optimizations inside the `string` class that could be negatively
    affected by your inheritance, so Microsoft prevents that.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 中 `sealed` 的一个例子是 `string` 类。微软在 `string` 类内部实现了一些可能因你的继承而受到负面影响的极端优化，所以微软阻止了这种情况。
- en: 'You can prevent someone from further overriding a `virtual` method in your
    class by applying the `sealed` keyword to the method. For example, no one can
    change the way Lady Gaga sings, as shown in the following code:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在方法上应用`sealed`关键字来防止你的类中进一步重写`virtual`方法。例如，没有人可以改变Lady Gaga的唱歌方式，如下面的代码所示：
- en: '[PRE108]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: You can only seal an overridden method.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能密封重写的方法。
- en: Understanding polymorphism
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解多态性
- en: You have now seen two ways to change the behavior of an inherited method. We
    can *hide* it using the `new` keyword (known as **non-polymorphic inheritance**),
    or we can *override* it (known as **polymorphic inheritance**).
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了两种改变继承方法行为的方法。我们可以使用`new`关键字（称为**非多态继承**）来**隐藏**它，或者我们可以**重写**它（称为**多态继承**）。
- en: Both ways can access members of the base or superclass by using the `base` keyword,
    so what is the difference?
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方式都可以通过使用`base`关键字来访问基类或超类的成员，那么它们之间有什么区别呢？
- en: It all depends on the type of variable holding a reference to the object. For
    example, a variable of the `Person` type can hold a reference to a `Person` class,
    or any type that derives from `Person`.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都取决于持有对象引用的变量的类型。例如，一个`Person`类型的变量可以持有`Person`类的引用，或者任何从`Person`派生的类型。
- en: 'Let’s see how this could affect your code:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这可能会如何影响你的代码：
- en: 'In `Employee.cs`, add statements to override the `ToString` method so that
    it writes the employee’s name and code to the console, as shown in the following
    code:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Employee.cs`中，添加语句来重写`ToString`方法，以便将员工的名字和代码写入控制台，如下面的代码所示：
- en: '[PRE109]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In `Program.cs`, write statements to create a new employee named Alice stored
    in a variable of type `Employee`. Also, store Alice in a second variable of type
    `Person`, and then call both variables’ `WriteToConsole` and `ToString` methods,
    as shown in the following code:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，编写语句创建一个新的员工Alice，并将其存储在类型为`Employee`的变量中。然后，将Alice存储在另一个类型为`Person`的变量中，然后调用两个变量的`WriteToConsole`和`ToString`方法，如下面的代码所示：
- en: '[PRE110]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`PeopleApp`项目并查看结果，如下面的输出所示：
- en: '[PRE111]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: When a method is hidden with `new`, the compiler is not smart enough to know
    that the object is an `Employee`, so it calls the `WriteToConsole` method in `Person`.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法被`new`关键字隐藏时，编译器并不足够智能，无法知道该对象是一个`Employee`，因此它会调用`Person`中的`WriteToConsole`方法。
- en: When a method is overridden with `virtual` and `override`, the compiler is smart
    enough to know that although the variable is declared as a `Person` class and
    the object itself is an `Employee` class, and therefore, the `Employee` implementation
    of `ToString` is called.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法使用`virtual`和`override`关键字被重写时，编译器足够智能，知道尽管变量被声明为`Person`类，而对象本身是`Employee`类，因此调用的是`Employee`类的`ToString`实现。
- en: 'The member modifiers and the effect they have are summarized in *Table 6.5*:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 成员修饰符及其影响总结在*表6.5*中：
- en: '| **Variable type** | **Member modifier** | **Method executed** | **In class**
    |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '| **变量类型** | **成员修饰符** | **执行的方法** | **在类中** |'
- en: '| `Person` |  | `WriteToConsole` | `Person` |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '| `Person` |  | `WriteToConsole` | `Person` |'
- en: '| `Employee` | `new` | `WriteToConsole` | `Employee` |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '| `Employee` | `new` | `WriteToConsole` | `Employee` |'
- en: '| `Person` | `virtual` | `ToString` | `Employee` |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '| `Person` | `virtual` | `ToString` | `Employee` |'
- en: '| `Employee` | `override` | `ToString` | `Employee` |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| `Employee` | `override` | `ToString` | `Employee` |'
- en: 'Table 6.5: Member modifiers and the effect they have'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.5：成员修饰符及其影响
- en: In my opinion, polymorphism is academic to most programmers. If you get the
    concept, that’s cool; but if not, I suggest that you don’t worry about it. Some
    people like to make others feel inferior by saying understanding polymorphism
    is important for all C# programmers, but in my opinion, it’s not. There are thousands
    of other topics that your time and effort will be better spent on.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，多态性对大多数程序员来说都是学术性的。如果你理解了这个概念，那很好；但如果不懂，我建议你不要担心。有些人喜欢通过说理解多态性对所有C#程序员都很重要来让别人感到自卑，但在我看来，这并不重要。还有成千上万的其他主题，你的时间和精力将更好地花在这些主题上。
- en: You can have a successful career with C# and never need to be able to explain
    polymorphism, just as a racing car driver doesn’t need to explain the engineering
    behind fuel injection.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用C#成功地进行职业生涯，而无需能够解释多态性，就像赛车手不需要解释燃油喷射的工程原理一样。
- en: '**Good Practice**: You should use `virtual` and `override` rather than `new`
    to change the implementation of an inherited method whenever possible.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：在可能的情况下，你应该使用`virtual`和`override`而不是`new`来更改继承方法的实现。'
- en: Casting within inheritance hierarchies
  id: totrans-533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在继承层次结构中进行类型转换
- en: '**Casting** between types is subtly different from converting between types.
    Casting is between similar types, like between a 16-bit integer and a 32-bit integer,
    or between a superclass and one of its subclasses. **Converting** is between dissimilar
    types, such as between text and a number.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换**在类型之间是微妙不同的，与类型之间的转换不同。转换是在相似类型之间，比如在16位整数和32位整数之间，或者在超类和它的子类之间。**转换**是在不相似类型之间，例如在文本和数字之间。'
- en: For example, if you need to work with multiple types of `stream`, then instead
    of declaring specific types of stream like `MemoryStream` or `FileStream`, you
    could declare an array of `Stream`, the supertype of `MemoryStream`, and `FileStream`.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你需要处理多种类型的`stream`，那么你不需要声明特定的流类型，如`MemoryStream`或`FileStream`，你可以声明一个`Stream`类型的数组，它是`MemoryStream`和`FileStream`的超类型。
- en: Implicit casting
  id: totrans-536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式转换
- en: In the previous example, you saw how an instance of a derived type can be stored
    in a variable of its base type (or its base’s base type, and so on). When we do
    this, it is called **implicit casting**.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你看到了如何将派生类型的实例存储在其基类型（或其基的基类型，等等）的变量中。当我们这样做时，这被称为**隐式转换**。
- en: Explicit casting
  id: totrans-538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式转换
- en: 'The opposite of implicit casting is explicit casting, and you must use parentheses
    around the type you want to cast into as a prefix to do it:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式转换的相反是显式转换，你必须使用括号将你想要转换到的类型作为前缀来执行：
- en: 'In `Program.cs`, add a statement to assign the `aliceInPerson` variable to
    a new `Employee` variable, as shown in the following code:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句将`aliceInPerson`变量赋值给一个新的`Employee`变量，如下代码所示：
- en: '[PRE112]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Your code editor displays a red squiggle and a compile error, as shown in *Figure
    6.4*:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的代码编辑器显示了一个红色波浪线和编译错误，如图6.4所示：
- en: '![](img/B22322_06_04.png)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22322_06_04.png)'
- en: 'Figure 6.4: A missing explicit cast compile error'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：缺少显式转换的编译错误
- en: 'Change the statement to prefix the assigned variable name with a cast to the
    `Employee` type, as shown highlighted in the following code:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将语句改为在分配的变量名前加上`Employee`类型的转换，如下代码所示：
- en: '[PRE113]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Avoiding casting exceptions
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免转换异常
- en: The compiler is now happy; however, because `aliceInPerson` might be a different
    derived type, like `Student` instead of `Employee`, we need to be careful. In
    a real application with more complex code, the current value of this variable
    could have been set to a `Student` instance, and then this statement would throw
    an `InvalidCastException` error at runtime.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器现在很高兴；然而，因为`aliceInPerson`可能是一个不同的派生类型，比如`Student`而不是`Employee`，我们需要小心。在一个具有更复杂代码的真实应用中，这个变量的当前值可能被设置为`Student`实例，然后这个语句在运行时会抛出`InvalidCastException`错误。
- en: Using is to check a type
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`is`关键字检查类型
- en: 'We can handle this by writing a `try` statement, but there is a better way.
    We can check the type of an object using the `is` keyword:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过编写`try`语句来处理这个问题，但有一个更好的方法。我们可以使用`is`关键字来检查对象的类型：
- en: 'Wrap the explicit cast statement in an `if` statement, as highlighted in the
    following code:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将显式转换语句包裹在`if`语句中，如下代码所示：
- en: '[PRE114]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`PeopleApp`项目并查看结果，如下输出所示：
- en: '[PRE115]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '**Good Practice**: You could simplify the code further using a declaration
    pattern, and this will avoid the need to perform an explicit cast, as shown in
    the following code:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：你可以进一步简化代码，使用声明模式，这将避免执行显式转换，如下代码所示：'
- en: '[PRE116]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This technique of both checking and casting was covered in *Chapter 3*, *Controlling
    Flow, Converting Types, and Handling Exceptions*.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这种检查和转换的技术在*第3章*，*控制流程，转换类型和处理异常*中有所介绍。
- en: What if you want to execute a block of statements when Alice is *not* an employee?
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Alice不是员工的情况下执行一组语句怎么办？
- en: 'In the past, you would have had to use the `!` (not) operator, as shown in
    the following code:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，你将不得不使用`!`（非）运算符，如下代码所示：
- en: '[PRE117]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'With C# 9 and later, you can use the `not` keyword, as shown in the following
    code:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 9及以后版本中，你可以使用`not`关键字，如下代码所示：
- en: '[PRE118]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Using as to cast a type
  id: totrans-563
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`as`关键字转换类型
- en: 'Alternatively, you can use the `as` keyword to cast a type. Instead of throwing
    an exception, the `as` keyword returns `null` if the type cannot be cast:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用`as`关键字来转换类型。如果类型不能转换，`as`关键字返回`null`而不是抛出异常：
- en: 'In `Program.cs`, add statements to cast Alice using the `as` keyword, and then
    check whether the return value is not null, as shown in the following code:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句使用`as`关键字将Alice转换，然后检查返回值是否不为null，如下代码所示：
- en: '[PRE119]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Since accessing a member of a `null` variable will throw a `NullReferenceException`
    error, you should always check for `null` before using the result.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 由于访问`null`变量的成员将抛出`NullReferenceException`错误，因此在使用结果之前，您应该始终检查`null`。
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`PeopleApp`项目并查看以下输出结果：
- en: '[PRE120]'
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '**Good Practice**: Use the `is` and `as` keywords to prevent throwing exceptions
    when casting between derived types. If you don’t do this, you must write `try`-`catch`
    statements for `InvalidCastException`.'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：在派生类型之间进行转换时，使用`is`和`as`关键字以防止抛出异常。如果您不这样做，您必须为`InvalidCastException`编写`try`-`catch`语句。'
- en: Inheriting and extending .NET types
  id: totrans-571
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承和扩展.NET类型
- en: .NET has pre-built class libraries containing hundreds of thousands of types.
    Rather than creating your own completely new types, you can often get a head start
    by deriving from one of Microsoft’s types to inherit some or all its behavior,
    and then overriding or extending it.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: .NET包含预构建的类库，包含数十万个类型。您不必创建自己的完全新的类型，您通常可以通过从微软的类型中派生来获得先机，以继承其部分或全部行为，然后对其进行重写或扩展。
- en: Inheriting exceptions
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承异常
- en: 'As an example of inheritance, we will derive a new type of exception:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 作为继承的一个例子，我们将派生一种新的异常类型：
- en: In the `PacktLibrary` project, add a new class file named `PersonException.cs`.
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，添加一个名为`PersonException.cs`的新类文件。
- en: 'Modify the contents of the file to define a class named `PersonException` with
    three constructors, as shown in the following code:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改文件内容以定义一个名为`PersonException`的类，具有三个构造函数，如下所示：
- en: '[PRE121]'
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Unlike ordinary methods, constructors are not inherited, so we must explicitly
    declare and explicitly call the `base` constructor implementations in `System.Exception`
    (or whichever exception class you derived from) to make them available to programmers
    who might want to use those constructors with our custom exception.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通方法不同，构造函数不是继承的，因此我们必须显式声明并显式调用`System.Exception`（或您从中派生的任何异常类）中的`base`构造函数实现，以便它们可供可能希望使用这些构造函数与我们的自定义异常的程序员使用。
- en: 'In `Person.cs`, add statements to define a method that throws an exception
    if a date/time parameter is earlier than a person’s date and time of birth, as
    shown in the following code:'
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中添加语句以定义一个方法，如果日期/时间参数早于一个人的出生日期和时间，则抛出异常，如下所示：
- en: '[PRE122]'
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'In `Program.cs`, add statements to test what happens when employee John Jones
    tries to time-travel too far back, as shown in the following code:'
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中添加语句以测试当员工John Jones尝试穿越到太远的时间时会发生什么，如下所示：
- en: '[PRE123]'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`PeopleApp`项目并查看以下输出结果：
- en: '[PRE124]'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '**Good Practice**: When defining your own exceptions, give them the same three
    constructors that explicitly call the built-in ones in `System.Exception`. Other
    exceptions that you might inherit from may have more.'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：在定义自己的异常时，给它们与在`System.Exception`中显式调用内置构造函数相同的三个构造函数。您可能继承的其他异常可能有更多。'
- en: Extending types when you can’t inherit
  id: totrans-586
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当无法继承时扩展类型
- en: Earlier, we saw how the `sealed` modifier can be used to prevent inheritance.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了如何使用`sealed`修饰符来防止继承。
- en: Microsoft has applied the `sealed` keyword to the `System.String` class so that
    no one can inherit and potentially break the behavior of strings.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 微软已将`sealed`关键字应用于`System.String`类，这样就没有人可以继承并可能破坏字符串的行为。
- en: Can we still add new methods to strings? Yes, if we use a language feature named
    **extension methods**, which was introduced with C# 3.0\. To properly understand
    extension methods, we need to review static methods first.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否还能向字符串添加新方法？是的，如果我们使用名为**扩展方法**的语言特性，该特性是在C# 3.0中引入的。为了正确理解扩展方法，我们需要首先回顾静态方法。
- en: Using static methods to reuse functionality
  id: totrans-590
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用静态方法重用功能
- en: Since the first version of C#, we’ve been able to create `static` methods to
    reuse functionality, such as the ability to validate that a `string` contains
    an email address. The implementation will use a regular expression that you will
    learn more about in *Chapter 8*, *Working with Common .NET Types*.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 自从C#的第一个版本以来，我们能够创建`static`方法来重用功能，例如验证一个`string`是否包含电子邮件地址的能力。实现将使用您将在第8章*与常见.NET类型一起工作*中了解更多信息的正则表达式。
- en: 'Let’s write some code:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码：
- en: In the `PacktLibrary` project, add a new class file named `StringExtensions.cs`.
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，添加一个名为`StringExtensions.cs`的新类文件。
- en: 'Modify `StringExtensions.cs`, as shown in the following code, and note the
    following:'
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `StringExtensions.cs`，如下所示代码，并注意以下内容：
- en: The class imports a namespace to handle regular expressions.
  id: totrans-595
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类导入一个命名空间来处理正则表达式。
- en: 'The `IsValidEmail` method is `static`, and it uses the `Regex` type to check
    for matches against a simple email pattern that looks for valid characters before
    and after the `@` symbol:'
  id: totrans-596
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsValidEmail` 方法是 `static` 的，它使用 `Regex` 类型来检查与简单电子邮件模式匹配，该模式查找 `@` 符号前后有效的字符：'
- en: '[PRE125]'
  id: totrans-597
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'In `Program.cs`, add statements to validate two examples of email addresses,
    as shown in the following code:'
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中添加语句以验证两个电子邮件地址示例，如下所示代码：
- en: '[PRE126]'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，如下所示输出：
- en: '[PRE127]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: This works, but extension methods can reduce the amount of code we must type
    and simplify the usage of this function.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 这可行，但扩展方法可以减少我们必须键入的代码量，并简化此函数的使用。
- en: Using extension methods to reuse functionality
  id: totrans-603
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用扩展方法重用功能
- en: 'It is easy to turn `static` methods into extension methods:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `static` 方法转换为扩展方法很容易：
- en: 'In `StringExtensions.cs`, add the `static` modifier before the class, and then
    add the `this` modifier before the `string` type, as highlighted in the following
    code:'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `StringExtensions.cs` 中，在类之前添加 `static` 修饰符，然后在 `string` 类型之前添加 `this` 修饰符，如下所示代码中突出显示：
- en: '[PRE128]'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '**Good Practice**: These two changes tell the compiler that it should treat
    the method as one that extends the `string` type.'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：这两个更改告诉编译器将此方法视为扩展 `string` 类型的方法。'
- en: 'In `Program.cs`, add statements to use the extension method for `string` values
    that need to be checked for valid email addresses, as shown in the following code:'
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中添加语句以使用需要检查有效电子邮件地址的 `string` 值的扩展方法，如下所示代码：
- en: '[PRE129]'
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Note the subtle simplification in the syntax to call the `IsValidEmail` method.
    The older, longer syntax still works too.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 注意调用 `IsValidEmail` 方法的语法中的微妙简化。较旧、较长的语法仍然有效。
- en: 'The `IsValidEmail` extension method now appears to be a method just like all
    the actual instance methods of the `string` type, such as `IsNormalized`, except
    with a small down arrow on the method icon to indicate an extension method, as
    shown in *Figure 6.5*:'
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IsValidEmail` 扩展方法现在看起来就像 `string` 类型的所有实际实例方法一样，例如 `IsNormalized`，只是在方法图标上有一个小向下箭头，以表示这是一个扩展方法，如图
    *图6.5* 所示：'
- en: '![](img/B22322_06_05.png)'
  id: totrans-612
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22322_06_05.png)'
- en: 'Figure 6.5: Extension methods appear in IntelliSense alongside instance methods'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：扩展方法出现在 IntelliSense 中，与实例方法并列
- en: Run the `PeopleApp` project and view the result, which will be the same as before.
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `PeopleApp` 项目并查看结果，这将与之前相同。
- en: '**Good Practice**: Extension methods cannot replace or override existing instance
    methods. You cannot, for example, redefine the `Insert` method. The extension
    method will appear as an overload in IntelliSense, but an instance method will
    be called in preference to an extension method with the same name and signature.'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：扩展方法不能替换或覆盖现有的实例方法。例如，你不能重新定义 `Insert` 方法。扩展方法将作为重载出现在 IntelliSense
    中，但将优先调用具有相同名称和签名的实例方法。'
- en: Although extension methods might not seem to give a big benefit, in *Chapter
    11*, *Querying and Manipulating Data Using LINQ*, you will see some extremely
    powerful uses of extension methods.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然扩展方法可能看起来没有带来很大的好处，但在 *第11章*，*使用 LINQ 查询和操作数据* 中，你将看到一些非常强大的扩展方法用法。
- en: Method chaining or fluent style
  id: totrans-617
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法链或流畅式
- en: Method chaining, also known as fluent style, is a programming technique where
    multiple method calls are chained together in a single statement. This is achieved
    by having each method return an instance of the same object (often the object
    the method was called on), enabling a sequence of method calls on the same object.
    This style is popular in C# for creating readable and concise code, especially
    for configuring objects or building complex queries.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 方法链，也称为流畅式，是一种编程技术，其中多个方法调用在一个语句中链接在一起。这是通过让每个方法返回相同对象的实例（通常是方法被调用的对象）来实现的，从而允许对同一对象进行一系列方法调用。这种风格在
    C# 中很受欢迎，用于创建可读性和简洁的代码，尤其是在配置对象或构建复杂查询时。
- en: 'For example, consider this `Person` class:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个 `Person` 类：
- en: '[PRE130]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'To construct a `Person` instance, you can chain method calls, as shown in the
    following code:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建 `Person` 实例，你可以链式调用方法，如下所示代码：
- en: '[PRE131]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Extension methods allow adding new methods to existing types without modifying
    their source code or creating a new derived type. When combined with method chaining,
    this can enhance the readability and functionality of existing classes.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法允许在不修改其源代码或创建新的派生类型的情况下向现有类型添加新方法。当与链式调用结合使用时，这可以增强现有类的可读性和功能性。
- en: 'Suppose you have a `Car` class, as shown in the following code:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个`Car`类，如下面的代码所示：
- en: '[PRE132]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'You can create extension methods to enable method chaining for the `Car` class:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建扩展方法来为`Car`类启用方法链式调用：
- en: '[PRE133]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Now you can use these extension methods to chain method calls on a Car object:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用这些扩展方法在`Car`对象上链式调用方法：
- en: '[PRE134]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The benefits of method chaining include:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 链式调用的好处包括：
- en: '**Readability**: The code is more readable and resembles natural language'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性**：代码更易读，更接近自然语言'
- en: '**Conciseness**: Reduces the need for repetitive code'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁性**：减少了重复代码的需求'
- en: '**Configurability**: Allows the flexible and easy configuration of objects'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可配置性**：允许灵活且易于配置对象'
- en: But the potential drawbacks of method chaining include debugging difficulty
    because long chains can be harder to debug, and misleading code because if not
    used carefully, it can lead to less intuitive code, especially when dealing with
    nullable objects or complex logic.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 但链式调用的潜在缺点包括调试困难，因为长链可能更难调试，以及误导性的代码，如果不小心使用，可能会导致代码不够直观，尤其是在处理可空对象或复杂逻辑时。
- en: '**Good practice**: When method chaining, use clear method names to ensure they
    clearly indicate their purpose, return `this` or the object itself to maintain
    the chain, and carefully consider how to handle potential errors or exceptions
    within chained methods.'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：在链式调用时，使用清晰的方法名称以确保它们清楚地表明其目的，返回`this`或对象本身以保持链式调用，并仔细考虑如何在链式方法中处理潜在的错误或异常。'
- en: Method chaining and the fluent style, especially when combined with extension
    methods in C#, provide clean, readable, and maintainable code.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 链式调用和流畅风格，尤其是当与C#中的扩展方法结合使用时，可以提供干净、易读且易于维护的代码。
- en: Summarizing custom type choices
  id: totrans-637
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结自定义类型选择
- en: Now that we have covered OOP and the C# features that enable you to define your
    own types, let’s summarize what you’ve learned.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了面向对象编程和C#中使您能够定义自己的类型的特性，让我们总结一下您所学的知识。
- en: Categories of custom types and their capabilities
  id: totrans-639
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义类型的类别及其功能
- en: 'Categories of custom types and their capabilities are summarized in *Table
    6.6*:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义类型的类别及其功能总结在*表6.6*中：
- en: '| **Type** | **Instantiation** | **Inheritance** | **Equality** | **Memory**
    |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
  zh: '| **Type** | **Instantiation** | **Inheritance** | **Equality** | **Memory**
    |'
- en: '| `class` | Yes | Single | Reference | Heap |'
  id: totrans-642
  prefs: []
  type: TYPE_TB
  zh: '| `class` | Yes | Single | Reference | Heap |'
- en: '| `sealed` `class` | Yes | None | Reference | Heap |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
  zh: '| `sealed` `class` | Yes | None | Reference | Heap |'
- en: '| `abstract` `class` | No | Single | Reference | Heap |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
  zh: '| `abstract` `class` | No | Single | Reference | Heap |'
- en: '| `record` or `record` `class` | Yes | Single | Value | Heap |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
  zh: '| `record`或`record` `class` | Yes | Single | Value | Heap |'
- en: '| `struct` or `record` `struct` | Yes | None | Value | Stack |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '| `struct`或`record` `struct` | Yes | None | Value | Stack |'
- en: '| `interface` | No | Multiple | Reference | Heap |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
  zh: '| `interface` | No | Multiple | Reference | Heap |'
- en: 'Table 6.6: Categories of custom types and their capabilities'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.6：自定义类型的类别及其功能
- en: It is best to think about these differences by starting with the “normal” case
    and then spotting the differences in other cases. For example, a “normal” `class`
    can be instantiated with `new`, it supports single inheritance, it uses memory
    reference equality, and its state is stored in heap memory.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 最好通过从“正常”情况开始思考，然后找出其他情况中的差异来考虑这些不同之处。例如，一个“正常”的`class`可以通过`new`来实例化，它支持单一继承，它使用内存引用相等性，并且其状态存储在堆内存中。
- en: 'Now let’s highlight what is different about the more specialized types of classes:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们突出显示更专业化的类类型的不同之处：
- en: A `sealed` class does not support inheritance.
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`sealed`类不支持继承。
- en: An `abstract` class does not allow instantiation with `new`.
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`abstract`类不允许使用`new`进行实例化。
- en: A `record` class uses value equality instead of reference equality.
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`record`类使用值相等性而不是引用相等性。
- en: 'We can do the same for other types compared to a “normal” class:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对与其他“正常”类相比的其他类型做同样的事情：
- en: A `struct` or `record struct` does not support inheritance, it uses value equality
    instead of reference equality, and its state is stored in stack memory.
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`struct`或`record struct`不支持继承，它使用值相等性而不是引用相等性，并且其状态存储在栈内存中。
- en: An `interface` does not allow instantiation with `new` and supports multiple
    inheritance.
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interface`不允许使用`new`关键字进行实例化，并支持多重继承。'
- en: Mutability and records
  id: totrans-657
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变性和记录
- en: 'A common misconception is that `record` types are immutable, meaning their
    instance property and field values cannot be changed after initialization. However,
    the mutability of a `record` type actually depends on how the `record` is defined.
    Let’s explore mutability:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的误解是认为`record`类型是不可变的，这意味着它们的实例属性和字段值在初始化后不能被更改。然而，`record`类型的可变性实际上取决于`record`是如何定义的。让我们来探讨可变性：
- en: In the `PacktLibrary` project, add a new class file named `Mutability.cs`.
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，添加一个名为`Mutability.cs`的新类文件。
- en: 'Modify `Mutability.cs`, as shown in the following code, and note the following:'
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`Mutability.cs`，如下面的代码所示，并注意以下内容：
- en: '[PRE135]'
  id: totrans-661
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'In the `PeopleApp` project, in `Program.cs`, create an instance of each type,
    setting the initial `Name` value to `Bob`, and then modify the `Name` property
    to `Bill`. You will see the two types that are immutable after initialization
    because they will give the compiler error `CS8852`, as shown in the following
    code:'
  id: totrans-662
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PeopleApp`项目中的`Program.cs`文件里，为每种类型创建一个实例，将初始`Name`值设置为`Bob`，然后修改`Name`属性为`Bill`。你会看到两种在初始化后不可变的类型，因为它们会给出编译器错误`CS8852`，如下面的代码所示：
- en: '[PRE136]'
  id: totrans-663
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Note that record `C1` is mutable and `C2` is immutable. Note that `S1` and `S2`
    are mutable and `S3` is immutable.
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，记录`C1`是可变的，而`C2`是不可变的。注意`S1`和`S2`是可变的，而`S3`是不可变的。
- en: Comment out the two statements that cause compiler errors.
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉导致编译器错误的两个语句。
- en: Microsoft made some interesting design choices with records. Make sure you remember
    the subtle differences in behavior when combining record, class, and struct, and
    use different types of declaration of each.
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 微软在记录方面做出了一些有趣的设计选择。确保你记住在结合记录、类和结构体时的行为上的微妙差异，并使用每种类型的不同声明方式。
- en: Comparing inheritance and implementation
  id: totrans-667
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较继承和实现
- en: For me, the terms *inherit* and *implement* are different, and in the early
    days of C# and .NET you could strictly apply them to classes and interfaces, respectively.
    For example, the `FileStream` class inherits from the `Stream` class, and the
    `Int32` `struct` implements the `IComparable` interface.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我来说，“继承”和“实现”这两个术语是不同的，在C#和.NET的早期，你可以严格地将它们应用于类和接口。例如，`FileStream`类继承自`Stream`类，而`Int32`
    `struct`实现了`IComparable`接口。
- en: '*Inherit* implies some functionality that a subclass gets “for free” by inheriting
    from its **base**, or **superclass**. *Implement* implies some functionality that
    is NOT inherited but instead MUST be provided by the subclass. This is why I chose
    to title this chapter *Implementing Interfaces and Inheriting Classes*.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: “继承”意味着子类通过从其**基类**或**超类**继承而获得一些“免费”的功能。而“实现”意味着一些不是继承的而是必须由子类提供的功能。这就是为什么我选择将本章标题为“实现接口和继承类”。
- en: Before C# 8, interfaces were always purely contracts. There was no functionality
    in an interface that you could inherit. In those days, you could strictly use
    the term *implement* for interfaces that represent a list of members that your
    type must implement, and *inherit* for classes with functionality that your type
    can inherit and potentially override.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 8之前，接口始终是纯契约。接口中没有你可以继承的功能。在那些日子里，你可以严格地使用“实现”这个词来表示你的类型必须实现的一组成员，而“继承”用于表示你的类型可以继承并可能重写的类。
- en: With C# 8, interfaces can now include default implementations, making them more
    like abstract classes, and the term *inherit* for an interface that has default
    implementations does make sense. But I feel uncomfortable with this capability,
    as do many other .NET developers, because it messes up what used to be a clean
    language design. Default interfaces also require changes to the underlying .NET
    runtime, so they cannot be used with legacy platforms like .NET Standard 2.0 class
    libraries and .NET Framework.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 8中，接口现在可以包含默认实现，这使得它们更像抽象类，并且对于具有默认实现的接口来说，使用“继承”这个词是有意义的。但许多其他.NET开发者和我一样，对这个功能感到不舒服，因为它破坏了曾经干净的语言设计。默认接口还需要对底层.NET运行时进行更改，因此它们不能与像.NET
    Standard 2.0类库和.NET Framework这样的遗留平台一起使用。
- en: Classes can also have abstract members, for example, methods or properties without
    any implementation, just like an interface could have. When a subclass inherits
    from this class, it MUST provide an implementation of those abstract members,
    and the base class must be decorated with the `abstract` keyword to prevent it
    from being instantiated using `new` because it is missing some functionality.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 类也可以有抽象成员，例如，没有实现的方法或属性，就像接口可以有。当一个子类从此类继承时，它必须提供这些抽象成员的实现，并且基类必须用`abstract`关键字装饰，以防止使用`new`关键字实例化，因为它缺少一些功能。
- en: Reviewing illustrative code
  id: totrans-673
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾示例代码
- en: Let’s review some example code that illustrates some of the important differences
    between types.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一些示例代码，说明类型之间的一些重要区别。
- en: 'Note the following:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: To simplify the code, I have left out access modifiers like `private` and `public`.
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简化代码，我省略了`private`和`public`等访问修饰符。
- en: 'Instead of normal brace formatting, to save vertical space I have put all the
    method implementations in one statement, for example:'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了节省垂直空间，我没有使用常规的花括号格式，而是将所有方法实现放在一个语句中，例如：
- en: '[PRE137]'
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Using “I” as a prefix for interfaces is a convention, not a requirement. It
    is useful to highlight interfaces using this prefix, since only interfaces support
    multiple inheritance.
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“I”作为接口的前缀是一种约定，而不是强制要求。使用这个前缀来突出接口是有用的，因为只有接口支持多重继承。
- en: 'Here’s the code:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE138]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Practicing and exploring
  id: totrans-682
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with more in-depth research.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题、进行一些实际操作练习，以及更深入地研究本章主题来测试你的知识和理解。
- en: Exercise 6.1 – Online material
  id: totrans-684
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.1 – 在线材料
- en: Online material can be extra content written by me for this book, or it can
    be references to content created by Microsoft or third parties.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 在线材料可以是为我这本书编写的额外内容，也可以是Microsoft或第三方创建的内容的引用。
- en: Managing memory with reference and value types
  id: totrans-686
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用引用和值类型管理内存
- en: 'Read the following online-only section to learn how to manage memory with reference
    and value types:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读以下仅在网络上提供的部分，了解如何使用引用和值类型管理内存：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md)'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md)'
- en: Writing better code
  id: totrans-689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写更好的代码
- en: 'Read the following online-only section to learn how to use analyzers to write
    better code:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读以下仅在网络上提供的部分，了解如何使用分析器编写更好的代码：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch06-writing-better-code.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch06-writing-better-code.md)'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch06-writing-better-code.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch06-writing-better-code.md)'
- en: Exercise 6.2 – Practice creating an inheritance hierarchy
  id: totrans-692
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.2 – 练习创建继承层次结构
- en: 'Explore inheritance hierarchies by following these steps:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤探索继承层次结构：
- en: Add a new console app named `Exercise_Inheritance` to your `Chapter06` solution.
  id: totrans-694
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter06`解决方案中添加一个名为`Exercise_Inheritance`的新控制台应用程序。
- en: Create a class named `Shape` with properties named `Height`, `Width`, and `Area`.
  id: totrans-695
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Shape`的类，具有名为`Height`、`Width`和`Area`的属性。
- en: Add three classes that derive from it—`Rectangle`, `Square`, and `Circle`—with
    any additional members you feel are appropriate and that override and implement
    the `Area` property correctly.
  id: totrans-696
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加三个从它派生的类——`Rectangle`、`Square`和`Circle`——以及你认为合适的任何附加成员，并正确地重写和实现`Area`属性。
- en: 'In `Program.cs`, add statements to create one instance of each shape, as shown
    in the following code:'
  id: totrans-697
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中添加语句创建每个形状的一个实例，如下面的代码所示：
- en: '[PRE139]'
  id: totrans-698
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Run the console app and ensure that the result looks like the following output:'
  id: totrans-699
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，确保结果看起来像以下输出：
- en: '[PRE140]'
  id: totrans-700
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Exercise 6.3 – Test your knowledge
  id: totrans-701
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.3 – 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What is a delegate?
  id: totrans-703
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是委托？
- en: What is an event?
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是事件？
- en: How are a base class and a derived class related, and how can the derived class
    access the base class?
  id: totrans-705
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基类和派生类是如何关联的，派生类如何访问基类？
- en: What is the difference between the `is` and `as` operators?
  id: totrans-706
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`is`和`as`运算符的区别是什么？'
- en: Which keyword is used to prevent a class from being derived from or a method
    from being further overridden?
  id: totrans-707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个关键字用于防止类被派生或方法被进一步重写？
- en: Which keyword is used to prevent a class from being instantiated with the `new`
    keyword?
  id: totrans-708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个关键字用于防止使用`new`关键字实例化类？
- en: Which keyword is used to allow a member to be overridden?
  id: totrans-709
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个关键字用于允许成员被重写？
- en: What’s the difference between a destructor and a deconstruct method?
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 析构函数和解构方法的区别是什么？
- en: What are the signatures of the constructors that all exceptions should have?
  id: totrans-711
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有异常都应该有的构造函数的签名是什么？
- en: What is an extension method, and how do you define one?
  id: totrans-712
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展方法是什么，以及如何定义一个？
- en: Exercise 6.4 – Explore topics
  id: totrans-713
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.4 – 探索主题
- en: 'Use the links on the following page to learn more about the topics covered
    in this chapter:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下一页上的链接了解本章涵盖的主题：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes)'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes)'
- en: Summary
  id: totrans-716
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned about:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了以下内容：
- en: Operators
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符
- en: Generic types
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型类型
- en: Delegates and events
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托和事件
- en: Implementing interfaces
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现接口
- en: Memory usage differences between reference and value types
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型和值类型之间的内存使用差异
- en: Working with null values
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与空值一起工作
- en: Deriving and casting types using inheritance
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用继承派生和转换类型
- en: Base and derived classes, how to override a type member, and using polymorphism
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基类和派生类，如何重写类型成员，以及使用多态
- en: In the next chapter, you will learn how .NET is packaged and deployed, and in
    subsequent chapters, the types that it provides you with to implement common functionality,
    such as file handling and database access.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习.NET是如何打包和部署的，在随后的章节中，它为你提供的类型以实现常见功能，例如文件处理和数据库访问。
