# 微服务安全

安全性是网络应用最重要的横切关注点之一。不幸的是，知名网站的数据泄露似乎已成为家常便饭。考虑到这一点，信息和应用安全对网络应用变得至关重要。同样，安全应用不应再是事后考虑的事情。在组织中，安全是每个人的责任。

与微服务相比，单体应用具有更小的攻击面。然而，微服务本质上是由分布式系统组成的。原则上，微服务是相互隔离的；因此，实施良好的微服务比单体应用更安全。单体与微服务相比有不同的攻击向量。微服务架构风格迫使我们从安全的角度进行不同的思考。然而，我要提前告诉你，微服务安全是一个复杂且难以理解和实施的领域。

在我们深入探讨微服务安全之前，让我们了解我们对此的方法。我们将更多地关注认证和授权（在章节中统称为**认证**）的工作方式以及.NET 生态系统中的可用选项。

我们将探索 Azure API 管理及其作为.NET 微服务环境 API 网关的适用性；我们还将看到 Azure API 管理如何通过其安全功能帮助我们保护微服务。然后，我们将简要介绍为微服务安全提供*深度防御*机制的不同外围方面。我们还将讨论以下主题：

+   为什么表单认证和较老的技术不足够？

+   认证和可用的选项，包括 OpenID 和 Azure Active Directory

+   介绍 OAuth 2.0

+   介绍 Azure API 管理作为 API 网关

+   使用 Azure API 管理进行安全

+   互服务通信安全方法

+   容器安全和其他外围安全方面

# 单体应用中的安全性

要理解微服务安全，让我们回顾一下我们过去是如何保护.NET 单体应用的。这将帮助我们更好地理解为什么微服务的认证机制需要不同。

保护应用的关键机制一直是认证。认证验证用户的*身份*。授权管理用户可以或不可以访问的内容，也称为*权限*。加密，嗯，这是帮助你在客户端和服务器之间传输数据时保护数据的机制。不过，我们不会过多地讨论加密，只需确保所有通过网络传输的数据都进行了加密。这可以通过使用 HTTPS 协议来实现。

以下图表描述了.NET 单体中典型认证机制的流程：

![图片](img/32f49f3e-6ee8-46b2-bab1-522df1864c8b.png)

在前面的图中，我们可以看到用户通常通过 Web 浏览器输入他们的用户名和密码。然后，这个请求击中了 Web 应用中的一个薄层，该层负责认证。这个层或组件连接到用户凭据存储，在.NET 应用的情况下通常是 SQL 服务器。认证层验证用户提供的凭据与凭据存储中存储的用户名和密码是否匹配。

一旦验证了会话的用户凭据，浏览器中就会创建一个会话 cookie。除非用户有一个有效的会话 cookie，否则他无法访问应用。通常，会话 cookie 会随每个请求一起发送。在这些类型的单体应用中，模块可以自由地相互交互，因为它们在同一个进程中，并且有内存访问权限。这意味着在这些应用模块之间信任是隐含的，因此它们在相互通信时不需要单独验证和验证请求。

# 微服务中的安全性

现在让我们看看微服务的案例。从本质上讲，微服务是分布式系统。没有单个应用实例；相反，有多个不同的应用，它们和谐地相互协调以产生所需的输出。

# 为什么传统的 .NET 认证机制不起作用？

微服务安全性的可能方法之一可能是：我们模仿单体应用中认证层的相同行为。这可以描述如下：

![](img/9605f3e4-dac1-41d9-ac5a-f72ffbd955ae.png)

在这种方法中，我们将认证层进行了分布式部署，并将其提供给所有微服务。由于每个都是一个不同的应用，它将需要一个自己的认证机制。这本质上意味着每个微服务的用户凭据存储也是不同的。这引发了许多问题，例如我们如何保持所有服务之间的认证同步？我们如何验证服务间的通信，或者我们是否跳过它？我们对这些问题没有满意的答案。因此，这种方法没有意义，只是增加了复杂性。采用这种方法，我们甚至不能确定它是否能在现实世界中工作。

对于现代应用，我们还需要考虑一个额外的因素。在微服务世界中，我们需要支持原生移动应用和其他非标准形态设备，以及物联网应用。随着原生移动应用的显著普及，微服务架构也需要支持客户端和微服务之间的安全通信。这与传统的基于 Web 浏览器的用户界面不同。在移动平台上，Web 浏览器不是任何原生移动应用的一部分。这意味着基于 cookie 或基于会话的认证是不可能的。因此，微服务需要支持这种客户端应用之间的互操作性。这对于.NET 单体应用从未是问题。

在传统认证的情况下，浏览器负责在每次请求时发送 cookie。但我们在原生移动应用中并没有使用浏览器。实际上，我们既没有使用 ASPX 页面，也没有使用表单的认证模块。对于 iOS 客户端或 Android，情况完全不同。更重要的是，我们还在尝试限制对 API 的未授权访问。在前面的例子中，我们会保护客户端，无论是 MVC 应用还是 Windows Phone 应用，而不是微服务。此外，所有这些移动客户端设备都不是信任子系统的组成部分。对于每个请求，我们无法信任移动用户确实是所有者；通信通道也没有得到保护。因此，来自他们的任何请求都完全不可信。

但除了这些问题之外，我们还有一个更概念性的问题。为什么应用程序应该负责认证用户和授权？这不是应该分开的吗？

解决这个问题的另一个方案是使用 SAML 协议，但同样，这基于 SOAP 和 XML，所以并不是微服务的最佳选择。SAML 实现的复杂性也很高。

因此，从前面的讨论中可以明显看出，我们需要一个基于令牌的解决方案。微服务认证的解决方案以 OpenID Connect 和 OAuth 2.0 的形式出现。OpenID Connect 是认证的标准，OAuth 2.0 是授权的规范。然而，这种授权本质上是委托的。

我们将在后续章节中详细探讨这一点。但在那之前，让我们暂时偏离一下，看看 JSON Web Tokens，并了解为什么它们在微服务安全方面具有重要意义。

# JSON Web Tokens

**JSON Web Tokens** (**JWT**) 读作 *JOT*。它是一个定义良好的 JSON 架构或格式，用于描述数据交换过程中涉及的令牌。JWTs 在 *RFC 7519* 中进行了描述。

JWTs 与 OpenID Connect 或 OAuth 2.0 无关。这意味着它们可以独立使用，不受 OAuth 2.0 或 OpenID Connect 的影响。OpenID Connect 强制在过程中交换的所有令牌都使用 JWT。在 OAuth 2.0 中，JWT 的使用不是强制性的，而更像是一种实现格式。此外，.NET 框架内置了对 JWT 的支持。

基于 JWT 的安全令牌的目的是生成一个包含发行者、接收者信息以及发送者身份描述的数据结构。因此，令牌应该在传输过程中得到保护，以防止被篡改。为此，令牌使用对称或非对称密钥进行签名。这意味着当接收者信任令牌的发行者时，它也可以信任其中的信息。

下面是一个 JWT 的例子：

```cs
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```

这是 JWT 的编码形式。如果我们以解码形式查看相同的令牌，它有三个部分：头部、负载和签名；它们都由点号 (.) 分隔。前面的示例令牌可以按以下方式解码：

```cs
Header: {"alg": "HS256", "type": "JWT"}
Payload: {"sub": "1234567890","name": "John Doe","admin": true}
Signature:HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload),secret)
```

.NET 4.5.1 及以后的版本内置了对生成和消费 JWT 的支持。您可以使用包管理控制台使用以下命令在任何.NET 应用程序中安装 JWT 支持：

```cs
Install-Package System.IdentityModel.Tokens.Jwt
```

访问[`jwt.io/`](https://jwt.io/)，您可以在那里非常容易地查看和解码 JWT。此外，您还可以将其添加到 Chrome 调试器中，这非常方便。

# 什么是 OAuth 2.0？

好的，你可能不知道 OAuth 2.0 是什么，但你肯定在多个网站上使用过它。如今，许多网站允许你使用 Facebook、Twitter 或 Google 账户的用户名和密码登录。例如，访问你喜欢的网站，比如[www.stackoverflow.com](http://www.stackoverflow.com)的登录页面。那里有一个登录按钮，上面写着你可以使用 Google 账户登录，例如。当你点击 Google 按钮时，它会带你到 Google 的登录页面，并显示一些提到的权限。在这里，你提供你的 Google 用户名和密码，然后点击允许按钮，以授予你喜欢的网站权限。然后，Google 将你重定向到 Stack Overflow，你将使用适当的权限在 Stack Overflow 上登录。这仅仅是 OAuth 2.0 和 OpenID Connect 的最终用户体验。

OAuth 2.0 可以最好地描述为一系列规范转变为授权框架。*RFC 6749*将 OAuth 定义为以下内容：

“OAuth 2.0 授权框架允许第三方应用程序代表资源所有者通过在资源所有者和 HTTP 服务之间协调一个批准交互，或者允许第三方应用程序代表自己获取对 HTTP 服务的有限访问。”

OAuth 2.0 处理网络、原生移动应用程序以及所有无头服务器应用程序（在我们的语境中，这些不过是微服务实例）。你可能想知道为什么我们先讨论授权而不是认证。原因是 OAuth 2.0 是一个委托授权框架。这意味着，为了完成授权流程，它依赖于一个认证机制。

现在我们来看一些与之相关的术语。

OAuth 2.0 角色描述了授权过程中的相关方：

+   资源：这是指从未授权访问和使用的实体。在我们的案例中，这不过是一个微服务。

+   资源所有者：资源所有者是指拥有指定资源的个人或实体。当一个人拥有资源时，他就是最终用户。

+   客户端：客户端是指所有类型的客户端应用程序。这指的是任何试图访问受保护资源的应用程序。在微服务语境中，涉及的应用程序包括单页应用程序、Web 用户界面客户端、原生移动应用程序，甚至是一个试图访问下游另一个微服务的微服务。

+   授权服务器：这是托管安全令牌服务并在成功验证资源所有者并从资源所有者或代表他们获得权限后向客户端颁发令牌的服务器。

你可能已经注意到 OAuth 区分了最终用户和最终用户使用的应用程序。这有点奇怪，但完全合理，因为它也被普遍视为“我正在授权这个应用程序代表我执行这些操作”。

下图描述了这些角色如何在 OAuth 框架中授权的一般流程中相互交互：

![](img/e58404a3-3107-4236-ba49-b9e8dda72c70.png)

在*步骤 6*，如前图所示，客户端将授权授予传递给授权服务器。这一步看起来并不简单。授权授予有多种类型。授权类型代表 OAuth 2.0 中获取访问令牌的四种不同可能的使用场景。如果你选择了错误的授权类型，可能会危及安全：

+   授权代码：这是服务器端 Web 应用程序典型使用的 OAuth 授权，你会在你的 ASP.NET 应用程序中使用它。

+   隐式：通过服务器进行身份验证会返回一个访问令牌到浏览器，然后可以用来访问资源。这对于通信不能是私密的单页应用程序很有用。

+   资源所有者密码凭证：这要求用户直接在应用程序中输入他们的用户名和密码。当你开发一个用于与自己的服务器进行身份验证的第一方应用程序时，这很有用。例如，一个移动应用程序可能会使用资源所有者授权来与你的服务器进行身份验证。

+   客户端凭证：这通常用于客户端代表自己（客户端也是资源所有者）或基于与授权服务器预先安排的授权请求访问受保护资源时使用。

# 什么是 OpenID Connect？

OpenID Connect 1.0 是 OAuth 2.0 协议之上的简单身份层。OpenID Connect 全部关于身份验证。它允许客户端根据授权服务器执行的身份验证来验证最终用户。它还以可互操作和类似 REST 的方式获取关于最终用户的基本配置文件信息。

因此，OpenID Connect 允许所有类型的客户端——基于 Web、移动和 JavaScript 的客户端——请求并接收有关经过身份验证的会话和最终用户的信息。我们知道 OAuth 2.0 定义了访问令牌。那么，OpenID Connect 定义了一个标准化的身份令牌（通常称为 **ID 令牌**）。身份令牌被发送到应用程序，以便应用程序可以验证用户身份。它定义了一个端点，用于获取该用户的信息，例如他们的姓名或电子邮件地址。这就是用户信息端点。

它建立在 OAuth 2.0 之上，因此流程是相同的。它可以与授权码授权和隐式授权一起使用。由于客户端凭据授权用于服务器到服务器的通信，因此无法使用客户端凭据授权。

在此过程中没有涉及最终用户，因此也没有最终用户身份。同样，对于使用或流程的资源所有者路径来说，这也没有意义。那么它是如何工作的呢？好吧，我们不仅请求访问令牌，还会从实现 OpenID Connect 规范的 **安全令牌服务**（**STS**）请求一个额外的 ID 令牌。客户端收到一个 ID 令牌，通常还会收到一个访问令牌。为了获取有关已认证用户的更多信息，客户端可以随后使用访问令牌向用户信息端点发送请求；然后该端点将返回关于新用户的声明。

OpenID 支持授权码流和隐式流。它还增加了一些额外的协议，包括发现和动态注册。

# Azure Active Directory

OAuth 2.0 和 OpenID Connect 1.0 规范有多个提供者。**Azure Active Directory**（**Azure AD**）就是其中之一。Azure AD 为组织提供企业级云应用程序的身份管理。Azure AD 集成将为您的用户提供流畅的登录体验，并帮助您的应用程序符合 IT 政策。Azure AD 提供高级安全功能，如多因素身份验证，并且随着应用程序的增长而具有良好的可扩展性。它被用于所有 Microsoft Azure 云产品中，包括 Office 365，并且每天处理超过十亿次登录。 

传统 .NET 环境的一个有趣方面是，它们可以将组织的 Windows Server Active Directory 与 Azure AD 集成得非常好。这可以通过 Azure AD 同步工具或新的传递身份验证功能来实现。因此，组织的 IT 合规性仍然会被管理。

# 使用 OpenID Connect、OAuth 2.0 和 Azure AD 的微服务身份验证示例

现在我们已经具备了所有先决知识，可以开始编码了。让我们尝试构建一个 `ToDoList` 应用程序。我们将要保护 `TodoListService`，它代表我们的一个微服务。在解决方案中，`ToDoList` 微服务由 `TodoListService` 项目表示，而 `ToDoListWebApp` 代表服务器端 Web 应用程序。如果您打开本章提供的名为 `OpenIdOAuthAzureAD.sln` 的 Visual Studio 解决方案，这将更容易理解。此示例使用客户端凭据授权。

注意，由于 Azure 门户和相应的 Azure 服务 UI 的不断变化，建议您使用 Azure 服务管理 API 并自动化一些即将进行的注册任务。然而，出于学习和鼓励新接触 Azure 或可能首次尝试 Azure AD 的开发者的目的，我们将遵循 Azure 门户用户界面。

这里是先决条件：

+   Visual Studio 2017 更新 3

+   一个 Azure 订阅（如果您没有这个，您可以使用此演示的免费试用账户）

+   Azure AD 租户（单租户）：您也可以使用您 Azure 账户的默认目录，这应该与 Microsoft 组织的不同。

# 使用 Azure AD 租户注册 TodoListService 和 TodoListWebApp

现在我们来看看如何注册 `TodoListService`。

在此步骤中，我们将使用 Azure AD 租户添加 `TodoListService`。为了实现这一点，请登录到 Azure 管理门户，然后执行以下操作：

1.  点击“应用注册”。点击添加按钮。它将打开创建窗格，如图所示：

![图片](img/64a8579c-88d4-4915-ba87-4fa8380a541c.png)

1.  提供前面截图显示的所有必填详细信息，并在创建窗格的底部点击创建按钮。当我们提供登录 URL 时，请确保您为您的应用程序提供它。在我们的例子中，`TodoListService` 是一个微服务，因此我们不会有特殊的登录 URL。因此，我们必须提供默认 URL 或只是我们的微服务的主机名。我们将从我们的机器上运行该服务，因此 localhost URL 就足够了。您可以在`TodoListService`项目下的项目 URL 上右键单击，然后转到 Web，如图所示：

![图片](img/c17fcbdb-a832-45a4-a51a-0be9d55c28c7.png)

在 Azure 门户中的登录 URL 应该有尾随的 `/`；否则，即使您正确执行了所有步骤，也可能遇到错误。

1.  如果您使用 Microsoft Azure App Service 计划部署您的服务，您将获得一个类似于 `https://todolistservice-xyz.azurewebsites.net/` 的 URL。如果您在 Azure 上部署服务，您可以稍后更改登录 URL。

1.  一旦点击创建按钮，Azure 将将应用程序添加到您的 Azure AD 租户中。然而，为了完成 TodoListService 的注册，还需要填写一些更多细节。因此，导航到“应用注册”|“TodoListService”|“属性”。您会注意到还有一些额外的属性，例如 App ID URL，现在已经提供了。

1.  对于 App ID URL，输入 [`https://[Your_Tenant_Name]/TodoListService`](https://[Your_Tenant_Name]/TodoListService)，将 `[Your_Tenant_Name]` 替换为您的 Azure AD 租户名称。点击确定完成注册。最终的配置应如下所示：

![图片](img/084b7590-c707-4eb9-a75c-898ae12cf8b9.png)

现在我们继续注册 TodoListWebApp：

1.  首先，我们注册 TodoListWebApp。这是必要的，因为我们打算使用 OpenID Connect 连接到这个基于浏览器的 Web 应用程序。因此，我们需要在最终用户（即我们）和 TodoListWebApp 之间建立信任。

1.  点击“应用注册”。点击“添加”按钮。它将打开创建面板，如以下屏幕截图所示。填写登录 URL 为 `https://localhost:44322/`。

1.  同样，在 TodoListService 注册过程中，一旦创建 Web 应用程序，我们就能查看大部分附加属性。所以，最终的属性配置将看起来像这样：

![](img/4a21493b-5c13-4e8c-b04b-cb687e1f607b.png)

1.  这里需要注意的一个设置是注销 URL：我们将其设置为 `https://localhost:44322/Account/EndSession`。

    这是因为在结束会话后，Azure AD 将将用户重定向到这个 URL。对于 App ID URL，输入 `https://[Your_AD_Tenant_Name]/TodoListWebApp`，将 `[Your_AD_Tenant_Name]` 替换为您的 Azure AD 租户名称。点击“确定”以完成注册。

1.  现在我们需要在 TodoListWebApp 中设置权限，以便它可以调用我们的微服务：TodoListService。因此，再次导航到“应用注册”|“TodoListWebApp”|“必需权限”并点击“添加”。现在点击“1 选择一个 API”。此导航在以下屏幕截图中显示。您需要键入 ToDoListService 以使其在 API 面板中显示：

![](img/46044531-310c-4a25-aa0d-29b222d2bf12.png)

1.  现在，您将能够查看“启用访问”面板，在该面板下，您需要在“委托权限”下勾选“访问 TodoListService 权限”，并在“添加 API 访问”面板下勾选“完成”。这将保存权限。

# 为 TodoListWebApp 生成 AppKey

注册过程中的另一个重要步骤是添加 `client_secret`，这是在 Azure AD 和 TodoListWebApp 之间建立信任所必需的。这个 `client_secret` 只生成一次，并在 Web 应用程序中进行配置。要生成这个密钥，请导航到“应用注册”|“TodoListWebApp”|“密钥”。然后，将描述添加为`AppKey`并点击保存。一旦密钥保存，Azure 将自动生成密钥值，并将其显示在描述旁边。这个密钥只会显示一次，所以您必须立即复制并保存以供以后使用。在这种情况下，我们将把这个密钥保存在 TodoListWebApp 的 `web.config` 文件中。

存储的密钥将在 Azure 门户中如下显示：

![](img/a983ea10-4845-4d3d-809f-d39af7965390.png)

对于生产级应用程序，将 `client_Secret` 和所有此类关键密钥值保留在 `web.config` 中是一个坏主意。良好的做法是将它们加密并与应用程序隔离。为此目的，在生产级应用程序中，您可以使用 Azure Key Vault ([`azure.microsoft.com/en-us/services/key-vault/`](https://azure.microsoft.com/en-us/services/key-vault/)) 来保护所有密钥。密钥库的另一个优点是您可以按环境管理密钥，例如 dev-test-staging 和生产。

# 配置 Visual Studio 解决方案项目

首先，我们来看看如何使用 `TodoListService` 项目进行配置。

打开 `web.config` 文件并替换以下密钥：

1.  搜索 `ida:Tenant` 密钥。将其值替换为您的 AD 租户名称，例如，`contoso.onmicrosoft.com`。这也将成为应用程序 APP ID URL 的一部分。

1.  替换 `ida:Audience` 密钥。将其值替换为 `https://[您的 AD 租户名称]/TodoListService`。

    将 `[您的 AD 租户名称]` 替换为您的 Azure AD 租户名称。

现在我们来看看如何使用 `TodoListWebApp` 项目进行配置。

打开 `web.config` 文件并找到并替换以下密钥，使用提供的值：

1.  将 `todo:TodoListResourceid` 替换为 `https://[您的租户名称]/TodoListService`。

1.  将 `todo:TodoListBaseAddress` 替换为 `https://localhost:44321/`。

1.  将 `ida:ClientId` 替换为 ToDoListWebApp 的应用程序 ID。您可以通过导航到 App Registration | TodoListWebApp 获取它。

1.  将 `ida:AppKey` 替换为在注册 TodoListWebApp 的过程中步骤 2 中生成的 `client_secret`。如果您错过了记录此密钥，您需要删除之前的密钥并生成一个新的密钥。

1.  将 `ida:Tenant` 替换为您的 AD 租户名称，例如，`contoso.onmicrosoft.com`。

1.  将 `ida:RedirectUri` 替换为当用户从 TodoListWebApp 登出时应用程序要重定向到的 URL。在我们的例子中，默认是 `https://localhost:44322/`，因为我们希望用户导航到应用程序的主页。

# 在 IIS Express 上生成客户端证书

现在 `TodoListService` 和 `TodoListWebApp` 将通过安全通道进行通信。为了建立安全通道，`ToDoListWebApp` 需要信任客户端证书。这两个服务都托管在同一台机器上，并在 IIS Express 上运行。

要配置计算机信任 IIS Express SSL 证书，以管理员身份打开 PowerShell 命令窗口。查询您的个人证书存储以找到 `CN=localhost` 证书的指纹：

```cs
PS C:windowssystem32> dir Cert:LocalMachineMy
Directory: Microsoft.PowerShell.SecurityCertificate::LocalMachineMy
Thumbprint Subject
---------- -------
C24798908DA71693C1053F42A462327543B38042 CN=localhost
```

接下来，将证书添加到受信任的根存储中：

```cs
PS C:windowssystem32> $cert = (get-item cert:LocalMachineMyC24798908DA71693C1053F42A462327543B38042)
PS C:windowssystem32> $store = (get-item cert:LocalmachineRoot)
PS C:windowssystem32> $store.Open("ReadWrite")
PS C:windowssystem32> $store.Add($cert)
PS C:windowssystem32> $store.Close()
```

上一组指令将客户端证书添加到本地计算机的证书存储中。

# 运行两个应用程序

我们已经完成了所有那些繁琐的配置屏幕和密钥替换。兴奋吗？但在你按下 *F5* 之前，将 `ToDoListService` 和 `ToDoListWebApp` 设置为启动项目。一旦完成，我们就可以安全地运行我们的应用程序，并欢迎来到我们应用程序的登录页面。如果你点击登录按钮，你将被重定向到 [login.microsoftonline.com](http://login.microsoftonline.com)；这代表 Azure AD 登录。一旦你能够登录，你将看到以下登录页面：

![](img/e29198da-d86b-4acc-a219-c9565624f490.png)

当你登录应用程序以研究 ID 令牌的详细交换并获取访问令牌时，你可以观察到网络流量和 URL 重定向。如果你通过 ToDoList 菜单探索应用程序，你将能够访问 ToDoList 屏幕以及向 ToDoList 添加项目。这就是我们的 `TodoListService` 微服务被调用的地方，以及从 `TodoWebApp` 网络应用程序获取授权权限的地方。如果你探索配置文件菜单，你会看到 ID 令牌与你的名字、姓氏和电子邮件 ID 一起返回，这显示了 OpenID Connect 的实际应用。

如果你想要详细探索代码，`TodoListService` 项目的 `TodoListController.cs`、`Startup.Auth.cs` 和 `TodoListController.cs` 包含了一些有趣的代码片段以及解释性注释。

在这个例子中，我们使用了 OAuth 和 OpenID Connect 来保护基于浏览器的用户界面、网络应用程序和微服务。如果我们有一个 API 网关位于用户界面网络应用程序和微服务之间，事情可能会有所不同。在这种情况下，我们需要在 Web 应用程序和 API 网关之间建立信任。此外，我们必须将 ID 令牌和访问令牌从 Web 应用程序传递到 API 网关。然后，它将这些令牌传递到微服务。然而，在本章的范围内讨论和实现这一点是不切实际的。

# Azure API 管理作为一个 API 网关

微服务实现中的另一个重要模式是 **前后端分离**（**BFF**）。这个模式是由 Sam Newman 引入并推广的。BFF 模式的实际实现是通过在各类客户端和微服务之间引入 API 网关来完成的。

这在以下图中表示：

![](img/d10acc55-d9a0-4d01-806d-95039ad04cfc.png)

Azure API Management（以下简称 **Azure APIM** 或 **APIM**）正是合适的选择，它可以在基于 .NET 的微服务实现中充当 API 网关。由于 Azure APIM 是云服务之一，它具有超强的可扩展性，并且可以很好地集成到 Azure 生态系统中。在本章中，我们将重点关注 Azure APIM 的以下功能。

Azure APIM 在逻辑上分为三个部分：

+   API 网关：API 网关仅仅是客户端应用程序和服务之间的代理。它负责以下功能；这些主要用于各种应用程序与微服务通信：

    +   接受 API 调用并将它们路由到您的后端

    +   验证 API 密钥、JWT 和证书

    +   支持通过 Azure AD 和 OAuth 2.0 访问令牌进行身份验证

    +   强制执行使用配额和速率限制

    +   无需代码修改即可即时转换 API

    +   缓存后端响应的设置位置

    +   为分析目的记录调用元数据

+   发布者门户：这是组织并发布 API 程序的行政接口。它主要用于微服务开发者使微服务/API 可供 API 消费者或客户端应用程序使用。通过这种方式，API 开发者可以：

    +   定义或导入 API 模式

    +   将 API 打包成产品

    +   在 API 上设置策略，如配额或转换

    +   从分析中获得洞察

    +   管理用户

+   开发者门户：这作为 API 消费者的主要网络存在，他们可以执行以下操作：

    +   阅读 API 文档

    +   通过交互式控制台尝试 API

    +   创建账户并订阅以获取 API 密钥

    +   分析它们自己的使用情况

Azure APIM 附带易于遵循的用户界面和良好的文档。Azure API 管理还附带其 REST API，因此您在 Azure APIM 门户中看到的所有功能都可以通过 Azure REST API 端点以编程方式实现。

现在，让我们快速了解一下 Azure APIM 中的一些安全相关概念以及它们如何在微服务中使用：

+   产品：产品仅仅是 API 的集合。它们还包含使用配额和使用条款。

+   策略：策略是 API 管理的动态安全功能。它们允许发布者通过配置更改 API 的行为。策略是在 API 请求或响应上顺序执行的语句集合。API 管理本质上是一个代理，位于我们托管在 Azure 中的微服务和客户端应用程序之间。由于它是一个中间层，因此能够提供额外的服务。这些额外服务是在称为**策略**的声明性 XML 语法中定义的。Azure APIM 允许各种策略。实际上，您可以通过组合现有的策略来创建自己的自定义策略。以下是一些重要的策略：

+   访问限制策略：

    +   检查 HTTP 头：此策略检查是否每个接收到的 Azure APIM 请求中存在特定的 HTTP 头或其值。

    +   通过订阅限制调用速率：此策略根据每个订阅中特定服务被调用的次数，允许或拒绝对微服务的访问。

    +   限制调用者 IP：此策略指的是 IP 地址的白盒化，因此只有已知的 IP 可以访问服务。

    +   按订阅设置使用配额：此策略允许一定数量的调用。它允许您在每个订阅的基础上强制执行可续订或终身调用量以及/或带宽配额。

    +   验证 JWT：此策略验证用于应用程序认证的 JWT 令牌参数。

+   认证策略：

    +   使用基本认证进行认证：此策略有助于在入站请求上应用基本认证。

    +   使用客户端证书进行认证：此策略有助于使用客户端证书对 API 网关后面的服务进行认证。

+   跨域策略：

    +   允许跨域调用：此策略使我们能够通过 Azure APIM 进行 CORS 请求。

    +   CORS：这为端点或微服务添加了 CORS 支持，允许基于浏览器的 Web 应用程序进行跨域调用。

    +   JSONP：JSONP 策略为端点或整个微服务添加了**JSON 填充**（**JSONP**）支持，以允许 Java Script Web 应用程序进行跨域调用。

+   转换策略：

    +   在内容中遮蔽 URL：此策略通过 Azure APIM 遮蔽响应中的 URL。

    +   设置后端服务：此策略改变了入站请求的后端服务行为。

策略的另一个优点是它们可以应用于入站和出站请求。

# 速率限制和配额策略示例

在上一节中，我们看到了策略的含义。现在让我们看看一个例子。以下是一个应用于端点的配额策略之一：

```cs
<policies>
  <inbound>
    <!-- Change the quota to immediately see the effect-->
    <rate-limit calls="100" renewal-period="60">
    </rate-limit>
    <quota calls="200" renewal-period="604800">
    </quota>
    <base />
  </inbound>
  <outbound>
    <base/>
  </outbound>
</policies>
```

在这个例子中，我们正在限制来自单个用户的入站请求（入站）。因此，API 用户只能在 60 秒内进行`100`次调用。如果他们在该时间段内尝试进行更多调用，用户将收到状态码为`429`的错误，这基本上表示*速率限制已超过*。此外，我们为同一用户分配了每年`200`次的配额限制。这种节流行为是保护微服务免受不受欢迎的请求甚至 DOS 攻击的好方法。

Azure APIM 还支持使用 OAuth 2.0 和 OpenID Connect 进行认证。在发布者门户中，您可以轻松地看到 OAuth 和 OpenID Connect 选项卡以配置提供者。

# 容器安全

Docker 是工业应用容器化的一个重要部分。随着容器的大规模使用，很明显，我们需要在容器周围采取有效的安全措施。如果我们看一下容器的内部架构，它们与宿主操作系统的内核非常接近。

Docker 应用了最小权限原则来提供隔离并减少攻击面。尽管取得了进展，以下要点将帮助您了解可以为容器采取的安全措施：

+   确保所有用于微服务的容器镜像都已签名并来自受信任的注册表

+   增强宿主环境、守护进程和镜像的安全性

+   遵循最小权限原则，不要提升对访问设备的访问权限

+   使用 Linux 中的控制组来监控资源，如内存、I/O 和 CPU。

+   尽管容器生命周期非常短暂，但记录所有容器活动是建议的，并且对于后续分析非常重要。

+   如果可能的话，将容器扫描过程与工具集成，例如 Aqua ([`www.aquasec.com`](http://www.aquasec.com)) 或 Twistlock ([`www.twistlock.com`](https://www.twistlock.com))。

# 其他安全最佳实践

微服务架构风格是新的，尽管围绕基础设施和编写安全代码的一些安全实践仍然适用。在本节中，让我们讨论一些这些实践：

+   库和框架的标准化：在开发过程中引入新的库、框架或工具应该有一个流程。这将简化补丁的修复，如果发现任何漏洞；它也将最小化由开发中临时实施的库或工具带来的风险。

+   定期漏洞识别和缓解：使用行业标准的安全扫描器扫描源代码和二进制文件应该是开发过程中的一个常规部分。发现和观察结果应该像功能缺陷一样得到处理。

+   第三方审计和渗透测试：外部审计和渗透测试练习非常有价值。应该定期进行此类练习。这对于处理关键任务或敏感数据的应用程序来说至关重要。

+   日志和监控：日志是一种非常有用的技术，可以用于检测和从攻击中恢复。在微服务的情况下，能够聚合来自不同系统的日志是必不可少的。Riverbed、AppDynamics 和 Splunk 等工具在这个领域非常有用。

+   防火墙：在网络边界拥有一个或多个防火墙总是有益的。防火墙规则应该配置得当。

+   网络隔离：在单体架构的情况下，网络分区是受限制和有限的。然而，在微服务架构中，我们需要逻辑上创建不同的网络段和子网。基于微服务交互模式的分区可以非常有效地保持和发展额外的安全措施。

# 摘要

微服务架构风格，由于其设计上的分布式特性，为我们提供了更好的保护宝贵业务关键系统的选项。传统的基于 .NET 的身份验证和授权技术不足以应用在微服务世界中。我们也看到了为什么基于安全令牌的方法，如 OAuth 2.0 和 OpenID Connect 1.0，正在成为微服务授权和认证的实体标准。如果您想了解更多与安全相关的通用信息，请访问**开放网络应用安全项目**（**OWASP**）的网站 [`www.owasp.org`](http://www.owasp.org) 和微软安全开发生命周期 [`www.microsoft.com/en-us/sdl/`](https://www.microsoft.com/en-us/sdl/)。Azure AD 可以很好地支持 OAuth 2.0 和 OpenID Connect 1.0。Azure API 管理还可以在微服务的实现中充当 API 网关，并提供诸如策略等便捷的安全功能。

Azure AD 和 Azure API 管理提供了许多强大的功能来监控和记录接收到的请求。这对安全和追踪及故障排除场景都将非常有用。我们将在下一章中看到关于微服务故障排除的日志记录、监控和整体仪表化。
