<html><head></head><body>
		<div id="_idContainer137">
			<h1 id="_idParaDest-152" class="chapter-number"><a id="_idTextAnchor155"/>10</h1>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor156"/>Testing CLI Applications</h1>
			<p>Testing is an important phase of any software development project. The purpose of testing<a id="_idIndexMarker302"/> is to ensure that the application we put into the hands of our users behaves as expected and doesn‚Äôt cause any harm to users (by leaking their personal information or by allowing malicious actors to take advantage of a security issue to <span class="No-Break">harm users).</span></p>
			<p>In this chapter, we will discuss why testing is so important and explore different testing techniques and tools that will help us achieve this goal. More specifically, we will discuss <span class="No-Break">the following:</span></p>
			<ul>
				<li>Why testing <span class="No-Break">is important</span></li>
				<li>Different types <span class="No-Break">of tests</span></li>
				<li>What to test, how to do it, and when to run <span class="No-Break">these tests</span></li>
				<li>How to mock external dependencies when writing <span class="No-Break">unit tests</span></li>
			</ul>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor157"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the GitHub repository accompanying this <span class="No-Break">book, </span><a href="https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter10"><span class="No-Break">https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter10</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor158"/>Why is testing so important?</h1>
			<p>Over the years, testing<a id="_idIndexMarker303"/> has proven to be very valuable when it comes to providing great software and digital experiences to users. Any developer, team, or organization that is serious about their software development project and truly cares about their users and the experience they have when using their applications will invest in <span class="No-Break">software testing.</span></p>
			<p>Testing<a id="_idIndexMarker304"/> allows us to ensure that the applications we put into the hands of our users are of great quality, reliable, performant, <span class="No-Break">and secure.</span></p>
			<p>Here are some key benefits<a id="_idIndexMarker305"/> you can expect from testing <span class="No-Break">your application:</span></p>
			<ul>
				<li><strong class="bold">Ensuring your application‚Äôs quality, usability, and reliability</strong>: Testing ensures that the application behaves as expected, meets stakeholders‚Äô needs, adheres to business requirements and technical specifications, and provides value to users. This helps increase user (and customer) satisfaction and prevents a poorly designed or developed application from having a negative impact on the organization‚Äôs reputation. This can, for example, be achieved by validating API responses and verifying the output formatting of the <span class="No-Break">CLI application.</span></li>
				<li><strong class="bold">Ensuring your application‚Äôs security and compliance</strong>: Testing plays a crucial role in validating the security of the application. It helps identify potential vulnerabilities and weaknesses that could be exploited by malicious actors. It also ensures that the application complies with industry standards, regulations, and other critical requirements that an organization (or an industry) might be <span class="No-Break">subject to.</span></li>
				<li><strong class="bold">Acting as your application‚Äôs documentation</strong>: If you have ever worked on IT projects, you know how hard it is to maintain accurate and up-to-date documentation. A by-product of software testing is that it also acts as live documentation for your application: you can run it at any time to understand the behavior of <span class="No-Break">the application.</span></li>
				<li><strong class="bold">Simplify the application‚Äôs evolution</strong>: If you have ever worked on IT projects, you know how scary it is when you have to modify the code of an application that works fine. We even have a saying for that: ‚ÄúIf it‚Äôs not broken, don‚Äôt fix it!‚Äù. However, by having an efficient suite of tests, modifying that code is way less scary because we know that we can rely on that test suite to ensure that we didn‚Äôt introduce any bug in the existing code and functionalities (we call <span class="No-Break">these </span><span class="No-Break"><em class="italic">regressions</em></span><span class="No-Break">).</span></li>
				<li><strong class="bold">Achieving cost savings and efficiency</strong>: It is well-known that the cost of finding and fixing a bug in production might be 100 times more expensive than finding it and fixing it during the development or testing phase. This cost also includes the cost of loss of efficiency as the team has to stop working on new features and concentrate on <a id="_idIndexMarker306"/>fixing <span class="No-Break">that bug.</span></li>
			</ul>
			<p class="callout-heading">This is not a book about testing!</p>
			<p class="callout">During my career, I have coached and trained development teams, both for the organizations I worked for and for our customers, on testing and raising awareness about its importance. That‚Äôs why I couldn‚Äôt write a book about development without covering <span class="No-Break">this topic.</span></p>
			<p class="callout">However, although we will provide very valuable information and guidance throughout this chapter, keep in mind that this is not a book about software testing. Hence, concepts such as test-driven development, behavior-driven development, and code coverage, will not <span class="No-Break">be covered.</span></p>
			<p class="callout">That being said, I provide many references in <a href="B22400_14.xhtml#_idTextAnchor236"><span class="No-Break"><em class="italic">Chapter 14</em></span></a> if you want to dig into this <span class="No-Break">fascinating topic.</span></p>
			<p>As you can see, there are various types of tests. Let‚Äôs <span class="No-Break">highlight them!</span></p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor159"/>Types of tests</h1>
			<p>There is a wide variety of test types. They can be classified into <span class="No-Break">two categories:</span></p>
			<ul>
				<li><strong class="bold">Functional tests</strong>: This category of <a id="_idIndexMarker307"/>tests verifies that the application performs its <a id="_idIndexMarker308"/>intended function, according to its specifications. In other words, it ensures that the application does what it is supposed to do (what it has been <span class="No-Break">designed for).</span></li>
				<li><strong class="bold">Non-functional tests</strong>: This category <a id="_idIndexMarker309"/>of tests verifies that the <a id="_idIndexMarker310"/>application does what is intended to do in a way that meets user expectations and <span class="No-Break">quality standards.</span></li>
			</ul>
			<p>Each of these categories is composed of various types of tests. This figure illustrates <span class="No-Break">this relationship:</span></p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B22400_10_01.jpg" alt="Figure 10.1 ‚Äì Categories and types of software tests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 ‚Äì Categories and types of software tests</p>
			<p>Let‚Äôs briefly describe each of these types <span class="No-Break">of test:</span></p>
			<ul>
				<li><strong class="bold">Unit tests</strong>: Here, we<a id="_idIndexMarker311"/> focus on testing methods in isolation (i.e., without relying on <a id="_idIndexMarker312"/>their dependencies such as databases or external services. To achieve this, we use <em class="italic">mocking</em> techniques (more on that later) to avoid relying on these dependencies. These tests are usually fast and provide immediate feedback. They therefore help ensure that a very specific portion of the code (a method) is doing exactly what it is intended to do. In the event that a bug is discovered, this type of test proves very useful as it narrows the issue down to the line of code that causes it! It is however important not to overuse mocks as it can lead to tests that do not represent reality, making <span class="No-Break">them worthless.</span></li>
				<li><strong class="bold">Integration tests</strong>: This type of<a id="_idIndexMarker313"/> test verifies the interactions between different <a id="_idIndexMarker314"/>components of the application, ensuring that the integrated parts work together as expected. It also helps ensure that the flow of data and communication between these components is correct and can surface integration issues, usually due to <span class="No-Break">interface defects.</span></li>
				<li><strong class="bold">System tests</strong>: This type of<a id="_idIndexMarker315"/> test verifies that the complete application meets the <a id="_idIndexMarker316"/>specified requirements. This covers end-to-end functionality and behavior and relies on external dependencies. These tests are performed in an environment that is similar to the production environment (usually the staging or <span class="No-Break">pre-production environment).</span></li>
				<li><strong class="bold">Acceptance tests</strong>: This type <a id="_idIndexMarker317"/>of test validates that the application meets the users‚Äô <a id="_idIndexMarker318"/>needs and business requirements. The main difference is that acceptance tests are usually performed by users or stakeholders and serve as a final approval before going <span class="No-Break">to production.</span></li>
			</ul>
			<p>We just described the types of functional tests. Let‚Äôs now describe the types of <span class="No-Break">non-functional tests:</span></p>
			<ul>
				<li><strong class="bold">Security tests</strong>: This<a id="_idIndexMarker319"/> type of test is intended to reveal vulnerabilities and security<a id="_idIndexMarker320"/> breaches in the application and aims to protect users against data breaches, unauthorized access, and cyber-attacks <span class="No-Break">in general.</span></li>
				<li><strong class="bold">Performance tests</strong>: This <a id="_idIndexMarker321"/>type of test is intended to identify performance issues and bottlenecks by measuring response times and resource usage and<a id="_idIndexMarker322"/> identifying scalability or capacity limits under various workloads.. This provides valuable insights into what parts of the application require special attention, such as redesigning or refactoring, in order to meet the performance requirements and <span class="No-Break">users‚Äô expectations.</span></li>
				<li><strong class="bold">Usability tests</strong>: This type of <a id="_idIndexMarker323"/>test focuses on assessing the user-friendliness and ease of <a id="_idIndexMarker324"/>use of the application. This involves asking real users to test the application by completing tasks, gathering feedback and metrics along the way (such as the user experience in general, how easy it is to navigate the application, how long it takes to complete a task, and the user‚Äôs appreciation <span class="No-Break">in general).</span></li>
				<li><strong class="bold">Compatibility tests</strong>: This<a id="_idIndexMarker325"/> type of test verifies that the application works as expected across different environments. For a cross-platform CLI<a id="_idIndexMarker326"/> application, this means that we need to ensure that it works correctly whether it is running on Windows, Linux, or macOS. Another example is to ensure that it gracefully degrades when necessary. Remember that we designed an <strong class="source-inline">interactive</strong> command, which means that the terminal it is running in is compliant with the requirements. We should then ensure that it works as expected when these requirements are met and gracefully degrades (e.g., converts to text-based output) when they <span class="No-Break">are not.</span></li>
			</ul>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor160"/>About usability tests</h2>
			<p>As you may have<a id="_idIndexMarker327"/> guessed, usability tests <a id="_idIndexMarker328"/>are intended to be performed manually. While it may not always be possible to gather real users together to perform these tests, one way to achieve this goal in the context of a CLI application is by implementing a command in the CLI application that allows users to <span class="No-Break">provide feedback.</span></p>
			<p>Here is, as an example, how the Azure CLI team does it: they provide a <strong class="source-inline">survey</strong> command that directs the user to an online form where they can <span class="No-Break">provide feedback.</span></p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B22400_10_02.jpg" alt="Figure 10.2 ‚Äì Allowing users to provide feedback"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 ‚Äì Allowing users to provide feedback</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor161"/>The pyramid of (software) testing</h2>
			<p>Many of you may not be familiar with the concepts of functional and non-functional tests, but you may be familiar with the<a id="_idIndexMarker329"/> pyramid of testing. It is worth mentioning that this pyramid includes many of the functional and non-functional types of test that we <span class="No-Break">just discussed.</span></p>
			<p>As a reminder, the pyramid of testing<a id="_idIndexMarker330"/> looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/B22400_10_03.jpg" alt="Figure 10.3 ‚Äì The pyramid of (software) testing"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 ‚Äì The pyramid of (software) testing</p>
			<p>The <a id="_idIndexMarker331"/>reason this is presented as a pyramid is to illustrate the quantity of tests to be expected at each step. The larger the step, the more tests it is expected to contain. As an example, a project is likely to have more unit tests than system tests and more system tests than UAT tests. This is due to the cost of creating and maintaining <span class="No-Break">such tests.</span></p>
			<p>It is important to keep in mind that what separates these various types of tests is their scope and their intent, not the frameworks or libraries used to <span class="No-Break">implement them.</span></p>
			<p>It is also important to keep in mind that you can create your own types of tests if you need to. Let me give you <span class="No-Break">some examples.</span></p>
			<p class="callout-heading">About custom types of tests</p>
			<p class="callout">In my career, I have worked with <a id="_idIndexMarker332"/>organizations that had their own custom types of tests that suited their needs <span class="No-Break">and policies.</span></p>
			<p class="callout">For example, some organizations may <a id="_idIndexMarker333"/>have <em class="italic">architectural tests</em>, which are tests <a id="_idIndexMarker334"/>written to ensure that an application (and its components) are developed following their architectural standards, such as what components can reference what components, ensure that every service class exposes an interface, and <span class="No-Break">so on.</span></p>
			<p class="callout">Another type of test I have seen can be referred to<a id="_idIndexMarker335"/> as <em class="italic">naming conventions tests</em>. These<a id="_idIndexMarker336"/> tests are meant to ensure that every component (such as classes, services or libraries) is named according to the organization‚Äôs naming conventions <span class="No-Break">and standards.</span></p>
			<p>These two types of tests are intended to simplify the code review process and can be automated as part of validating a <span class="No-Break">pull request.</span></p>
			<p>We now have a better understanding of the various types of tests. The next logical question (the one that I get every time I discuss software testing with clients) is: <em class="italic">‚ÄúWhat should we test?‚Äù</em> Let‚Äôs discuss <span class="No-Break">this now.</span></p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor162"/>What should we test?</h1>
			<p>This is a <a id="_idIndexMarker337"/><span class="No-Break">great question!</span></p>
			<p>It is easy to say that you should test every possible scenario in your application. However, we need to consider <span class="No-Break">the following:</span></p>
			<ul>
				<li>How do you define ‚Äú<span class="No-Break">every scenario‚Äù?</span></li>
				<li>Can you really test ‚Äúevery scenario‚Äù? How many tests does <span class="No-Break">that mean?</span></li>
			</ul>
			<p>In a nutshell, your suite of tests should cover both of <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">The happy path</strong>: This <a id="_idIndexMarker338"/>means testing the situation in which the required input for your application is provided and is in the <span class="No-Break">expected format</span></li>
				<li><strong class="bold">The unhappy path</strong>: Here, we<a id="_idIndexMarker339"/> test the behavior of the application under unexpected circumstances, such as input in the wrong format, user errors, network issues (when relying on external dependencies), the user canceling a task, and <span class="No-Break">so on</span></li>
			</ul>
			<p>Once again, this is not a book<a id="_idIndexMarker340"/> about software testing, but I would like to give you some guidance on what to test in <span class="No-Break">different situations:</span></p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Input parameters</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Test both valid and <span class="No-Break">invalid values.</span></p>
							<p>As an example, if a method takes only one integer parameter, and the range of valid values is between 1 and 100, we should also test it with values outside of this range, such as <strong class="source-inline">-1</strong>, <strong class="source-inline">0</strong>, and <strong class="source-inline">2000</strong> (we usually call these <strong class="bold">boundary values</strong>), along<a id="_idIndexMarker341"/> with values in the wrong format, such as <strong class="source-inline">"bonjour"</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">1.23</strong></span><span class="No-Break">.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Lists</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>When dealing with <a id="_idIndexMarker342"/>lists, we should ensure that the list only contains the expected elements, no more, no less. It is not sufficient to check the number of elements in the list because if a bug in the code inserts an element more than once or inserts inappropriate elements, the count could meet the expected value, but the list might not contain the <span class="No-Break">appropriate elements.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Exceptions</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>If the application throws <a id="_idIndexMarker343"/>exceptions, this should be tested too to ensure that the right type of exception is thrown and with the <span class="No-Break">expected details.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Methods/services </strong><span class="No-Break"><strong class="bold">returned values</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>It is easy to <a id="_idIndexMarker344"/>verify that a numerical or string value matches the expected value, but if the return value is an object (or a list of objects), we should verify that the values of all meaningful properties match the <span class="No-Break">expected ones.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Methods/services </strong><span class="No-Break"><strong class="bold">behavior</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>While most developers verify the returned values of their methods or services when implementing tests, they fail at verifying that these methods or services behave <span class="No-Break">as expected.</span></p>
							<p>Verifying the behavior of a method or service means that we need to <span class="No-Break">ensure that:</span></p>
							<ul>
								<li>The correct subsequent methods are called with the expected parameters. These could be logging or caching methods or calls to external dependencies such as database or external APIs <span class="No-Break">for example.</span></li>
								<li>The state changes within the object, the class, or the service are accurate <span class="No-Break">and expected.</span></li>
								<li>Side effects, such as database updates or changes to files, are accurate <span class="No-Break">and expected.</span></li>
								<li>Idempotency occurs when appropriate, which means that if the same method is called more than once, it maintains the coherence of the system. Think of a method that performs a call to a payment gateway or to a reservation system. We certainly don‚Äôt want the customer to be charged twice for the same purchase, nor for multiple reservations<a id="_idIndexMarker345"/> to be made for the <span class="No-Break">same appointment.</span></li>
							</ul>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 ‚Äì What to test</p>
			<p>It is just as important to know what to test as it is to know what <em class="italic">not</em> <span class="No-Break">to test.</span></p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor163"/>What not to test</h2>
			<p>You should not test external frameworks and libraries because this is the responsibility of their creators and maintainers. It is very likely that they have already been tested before you had a chance to use them. So, don‚Äôt do <span class="No-Break">this, please!</span></p>
			<p>Other code artifacts that do not need to be tested are model classes<a id="_idIndexMarker346"/> and <strong class="bold">Data Transfer Objects</strong> (<strong class="bold">DTOs</strong>) as they are supposed to only contain properties, not methods, since they do not perform any processing of any kind, only move <span class="No-Break">data around.</span></p>
			<p>Also, you may have heard that it is not recommended to test private methods. There is a heated debate about whether we should test private methods. My personal opinion is that you should not, for two <span class="No-Break">main reasons:</span></p>
			<ul>
				<li><strong class="bold">A private method is intended to be invoked by at least one public method</strong>: Hence, when testing that public method, you are also testing the <span class="No-Break">private one.</span></li>
				<li><strong class="bold">Technical difficulties when testing private methods</strong>: Testing private methods relies on reflection in order to invoke the method and also relies on an array of <strong class="source-inline">Object</strong> to pass parameters to it. It is hence very easy to break these tests at runtime (they will compile, though) since the name of the method is usually passed as a string, and since every data type inherits from the <strong class="source-inline">Object</strong> class, if we change the data type or structure for a given parameter, it will still inherit from that same base class even though it is not expected by the private <span class="No-Break">method anymore.</span></li>
			</ul>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor164"/>Testing is a safety net</h2>
			<p>As I tell my customers and students, a test suite<a id="_idIndexMarker347"/> is like a <span class="No-Break">safety net:</span></p>
			<ul>
				<li>The more test cases you cover, the wider the safety net. If you fall from 30 feet and your safety net is 2 inches by 2 inches, the chances are that it <span class="No-Break">won‚Äôt help.</span></li>
				<li>On the other hand, if you have a safety net that is 50 feet by 50 feet but its meshes are 3 feet by 3 feet large, it won‚Äôt help either. What I mean here is that if you have an extensive test suite in terms of a number of tests, but these tests do not cover meaningful situations, your test suite is of <span class="No-Break">no use.</span></li>
			</ul>
			<p>So, we are now aware of the different types of tests, and we know what to test. But when should we run these tests? Let‚Äôs <span class="No-Break">discuss this.</span></p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor165"/>When should we run tests?</h1>
			<p>The various types of tests we discussed are intended to be run at different points during the <span class="No-Break">development lifecycle.</span></p>
			<p>An organization (or even a developer or a team) may have policies and preferences but, in general, the following recommendations are adopted by <span class="No-Break">the industry:</span></p>
			<ul>
				<li><strong class="bold">Unit tests</strong>: These <a id="_idIndexMarker348"/>tests are intended to be run during development. In other words, the developer should run them as they write the code. There are some IDEs (such as Visual Studio Enterprise) that even allow you to configure unit tests to be run in the <a id="_idIndexMarker349"/>background as you type your code! This has to be configured and used carefully as it might quickly become cumbersome. You have to, however, run them before committing your changes, and before creating or updating a pull request. Unit tests are also usually run as part of a CI/CD pipeline. For these reasons, unit tests should always be automated and are actually very easy <span class="No-Break">to automate.</span></li>
				<li><strong class="bold">Integration tests</strong>: These<a id="_idIndexMarker350"/> tests are to be run after unit tests have passed (that is, <span class="No-Break">run successfully).</span></li>
				<li><strong class="bold">Smoke tests</strong>: These<a id="_idIndexMarker351"/> tests should be run after a new build has been deployed and before QA testers engage in more extensive testing. For this reason, these tests are usually triggered by the CI/CD pipeline, right after the deployment operation <span class="No-Break">is completed.</span></li>
				<li><strong class="bold">System tests</strong>: These <a id="_idIndexMarker352"/>tests are run on a staging or pre-production environment, right before releasing the application to production. These tests are to be triggered after integration tests <span class="No-Break">have passed.</span></li>
				<li><strong class="bold">Regression tests</strong>: These tests<a id="_idIndexMarker353"/> should be run at least before committing your changes. They should also be part of the <span class="No-Break">CI/CD pipeline.</span></li>
				<li><strong class="bold">Performance tests</strong>: These<a id="_idIndexMarker354"/> should be run when new features (especially the ones dealing with external dependencies) or any significant code changes have <span class="No-Break">been made.</span></li>
				<li><strong class="bold">UAT tests</strong>: These special tests are performed by users (or their representatives, such as stakeholders) and are<a id="_idIndexMarker355"/> intended to obtain final approval before releasing the application to production. Hence, these tests are <span class="No-Break">usually manual.</span></li>
			</ul>
			<p>As you may have noticed, we haven‚Äôt covered all the possible types of tests. We have only focused on the ones that are part of the pyramid of <span class="No-Break">software testing.</span></p>
			<p>Okay. Now that we understand the importance of software testing, and we know what to test, let‚Äôs implement testing into our <span class="No-Break">CLI application.</span></p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor166"/>Adding a test project to Bookmarkr</h1>
			<p>In order to add a test project for<a id="_idIndexMarker356"/> our CLI application, I needed to make a slight <a id="_idIndexMarker357"/>change to the project structure, which was to extract the solution file (<strong class="source-inline">.sln</strong>) from the project directory and edit it to update the path to the <strong class="source-inline">.csproj</strong> file. This allows us to create a test project and add it to <span class="No-Break">the solution.</span></p>
			<p>Next, let‚Äôs type the following command to create the <span class="No-Break">test project:</span></p>
			<pre class="console">
dotnet new mstest -n bookmarkr.UnitTests</pre>			<p>This will create a new directory, named <strong class="source-inline">bookmarkr.UnitTests</strong>, in which the content of the test project <span class="No-Break">will reside.</span></p>
			<p>Right now, this directory only contains <span class="No-Break">two files:</span></p>
			<ul>
				<li><strong class="source-inline">Bookmarkr.UnitTests.csproj</strong>, which describes the project, its configuration, and <span class="No-Break">its dependencies</span></li>
				<li><strong class="source-inline">UnitTest1.cs</strong>, which acts as a sample <span class="No-Break">test class</span></li>
			</ul>
			<p>It is interesting to<a id="_idIndexMarker358"/> note that the <strong class="source-inline">.csproj</strong> file already references some testing libraries and frameworks, particularly the <strong class="bold">MS Test</strong> testing framework, which<a id="_idIndexMarker359"/> is the one we will be using throughout <span class="No-Break">this </span><span class="No-Break"><a id="_idIndexMarker360"/></span><span class="No-Break">chapter.</span></p>
			<p class="callout-heading">About testing frameworks</p>
			<p class="callout">While there are <a id="_idIndexMarker361"/>many testing frameworks, the most common ones<a id="_idIndexMarker362"/> being <strong class="bold">NUnit</strong>, <strong class="bold">xUnit</strong>, and <strong class="bold">MS Test</strong>, we decided <a id="_idIndexMarker363"/>to use the latter for <span class="No-Break">many reasons:</span></p>
			<p class="callout">- MS Test is Microsoft‚Äôs testing framework and is widely known <span class="No-Break">and used</span></p>
			<p class="callout">- MS Test has evolved over the years and has a rich feature set, such as built-in support for testing parallel code, data-driven testing, and test <span class="No-Break">grouping capabilities</span></p>
			<p class="callout">That being said, no matter what your preferred testing framework is, the concepts are similar and the one covered in this chapter will apply as well. The main difference will be in the keywords provided by each <span class="No-Break">testing framework.</span></p>
			<p>It is also interesting to note that the test project is defined as <em class="italic">non-packable</em>. This means that this project will not be packaged and distributed as part of the application, which makes <span class="No-Break">perfect sense.</span></p>
			<p>But before we go any further, let‚Äôs add the test project to the solution using this command (which has to be run at the same location as the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">sln</strong></span><span class="No-Break"> file):</span></p>
			<pre class="console">
dotnet sln add bookmarkr.UnitTests/bookmarkr.UnitTests.csproj</pre>			<p>Now, if we open the solution in Visual Studio, it will contain both the code and the <span class="No-Break">test projects.</span></p>
			<p>The next step is to make our test project reference the actual project. This is required so that we can<a id="_idIndexMarker364"/> test the actual code. So, let‚Äôs navigate to the test <a id="_idIndexMarker365"/>project‚Äôs directory and type <span class="No-Break">this command:</span></p>
			<pre class="console">
dotnet add reference ../bookmarkr/bookmarkr.csproj</pre>			<p>There is one last step we need to take before we start implementing unit tests, which is to define a structure for our <span class="No-Break">test project.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor167"/>Structuring the test project</h2>
			<p>Each developer, team, or organization <a id="_idIndexMarker366"/>will have preferences when it comes to structuring their test projects. In this section, I will introduce you to my way of structuring test projects, which I implemented during my career and <span class="No-Break">found valuable.</span></p>
			<p>First, if your application is composed of multiple components and each component has its own Visual Studio project, you will want to create a separate unit tests project for each component while having a single integration tests project. This structure may be similar <span class="No-Break">to this:</span></p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/B22400_10_04.jpg" alt="Figure 10.5 ‚Äì Structure of test projects"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 ‚Äì Structure of test projects</p>
			<p>In this chapter, we will <a id="_idIndexMarker367"/>only focus on unit tests, but the same principles apply to integration tests. This is the reason why we only have a <span class="No-Break"><strong class="source-inline">bookmarkr.UnitTests</strong></span><span class="No-Break"> project.</span></p>
			<p>However, if you create multiple test projects within the solution, remember to always use the same version of the testing framework across all projects to prevent side effects due to <span class="No-Break">compatibility issues.</span></p>
			<p>Now, let‚Äôs structure our unit tests project. Here, again, there are unlimited possibilities depending on personal choices and teams‚Äô/organizations‚Äô policies. My approach is to have one test class for each code class. The test class will have the same name as the code class completed with the <strong class="source-inline">Tests</strong> suffix. I also like to replicate, in the test project, the same folder structure as in the code project as I find it easier to navigate in the test project because of the structure parity between the <span class="No-Break">two projects.</span></p>
			<p>After applying these principles, the structure of our test project looks <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/B22400_10_05.jpg" alt="Figure 10.6 ‚Äì Test project‚Äôs structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 ‚Äì Test project‚Äôs structure</p>
			<p>Now that the structure of our test project is set up, we can start implementing our unit tests. But wait! Are there any code artifacts that should not be tested? <span class="No-Break">Yes, indeed!</span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor168"/>Code artifacts that should not be tested</h2>
			<p>The following artifacts do not need to be tested since they do not perform <span class="No-Break">any processing:</span></p>
			<ul>
				<li><strong class="source-inline">Bookmark.cs</strong> and <strong class="source-inline">BookmarkConflictModel.cs</strong> since they are only model classes and hence only serve the purpose of moving <span class="No-Break">data around.</span></li>
				<li><strong class="source-inline">Program.cs</strong>: The purpose of this class is to configure the CLI application, configure logging, identify which command is the root command and build the <span class="No-Break">command hierarchy.</span></li>
				<li><strong class="source-inline">Helper.cs</strong>: This helper class‚Äôs methods are used to format the text outputs using different colors and formatting. Hence, this class is more suitable for UI testing rather than unit testing. For this reason, it is excluded from unit testing. However, it could be tested as part of manual tests or <span class="No-Break">end-to-end tests.</span></li>
			</ul>
			<p>Keep in mind that even though we decided not to test these code artifacts for valid reasons, MS Test will tell us, as part of the test results, that these artifacts were <span class="No-Break">not tested.</span></p>
			<p>We can inform MS Test that we have chosen not to test these artifacts using the <strong class="source-inline">[ExcludeFromCodeCoverage]</strong> attribute. This attribute is very flexible: it can be applied to the property, method, class, or even assembly level. This attribute also allows us to pass a string to justify <span class="No-Break">our decision.</span></p>
			<p>As an example, this is how we will apply it to the <span class="No-Break"><strong class="source-inline">Program</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
using System.Diagnostics.CodeAnalysis;
//‚Ä¶
[ExcludeFromCodeCoverage(Justification="CLI application configuration. No processing is performed in this class.")]
class Program
{
¬†¬†¬†¬†// ‚Ä¶
}</pre>			<p>We are finally ready to start implementing some tests. Let‚Äôs <span class="No-Break">dive in!</span></p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor169"/>Writing effective tests</h1>
			<p>We will learn how to implement<a id="_idIndexMarker368"/> tests by writing tests for the <strong class="source-inline">link</strong> and the <span class="No-Break"><strong class="source-inline">import</strong></span><span class="No-Break"> commands.</span></p>
			<p>The first thing we need to do is to add a test class for each command. We already have the folder structure in place, so let‚Äôs add the test classes. As I mentioned earlier, I find it useful to name my test classes after the actual classes with an added suffix of <strong class="source-inline">Tests</strong>. So, our test classes will be named <strong class="source-inline">LinkCommandTests</strong> and <span class="No-Break"><strong class="source-inline">ImportCommandTests</strong></span><span class="No-Break">, respectively.</span></p>
			<p>Now, let me introduce you to the best practices of structuring a test class and its test methods (yes, we will talk about structure once <span class="No-Break">again! </span><span class="No-Break">üòä</span><span class="No-Break">):</span></p>
			<ul>
				<li>Using MS Test, a test class<a id="_idIndexMarker369"/> is decorated with the <strong class="source-inline">[TestClass]</strong> attribute. If you don‚Äôt <a id="_idIndexMarker370"/>provide this attribute, the class will not be considered a test class and the test methods it contains will not <span class="No-Break">be run.</span></li>
				<li>A test class usually<a id="_idIndexMarker371"/> consists of multiple test methods. The name of a test method should convey its intent. This is important since the test report will only present the names of the methods along with an icon indicating the result of this test method (pass, fail, skipped, and so on). The usual approach is that the name of test a method is composed of its name, its input parameters‚Äô values, and the expected result. Examples of such names are <strong class="source-inline">GetEmployeeById_ValidId_ReturnsTheExpectedEmployeeObject</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">GetEmployeeById_InvalidId_ThrowsEmployeeNotFoundException.</strong></span></li>
				<li>Using MS Test, a test method is decorated with the <strong class="source-inline">[TestMethod]</strong> attribute. If you don‚Äôt provide this attribute, the class will not be considered as a test method and will not <span class="No-Break">be run.</span></li>
				<li>A test method should test one and only one outcome (whether this is a result or a behavior). This is important since we need to be able to know that, if a test method fails, it is because it didn‚Äôt achieve the expected outcome (a result or a behavior). To achieve this, however, a test method may contain more than one assertion as long as these multiple assertions serve the purpose of validating that <span class="No-Break">one outcome.</span></li>
				<li>To maximize clarity and readability, it is advised that a test method‚Äôs body be chunked into three parts (also known as <span class="No-Break">the 3As):</span><ul><li><strong class="bold">Arrange</strong>: where all <a id="_idIndexMarker372"/>the objects required to perform the test are instantiated <span class="No-Break">and initialized.</span></li><li><strong class="bold">Act</strong>: where the code artifact to be tested is invoked and the result <span class="No-Break">is gathered.</span></li><li><strong class="bold">Assert</strong>: where the obtained result (usually referred to as the ‚Äúactual‚Äù result) is compared to the expected result. If both match, the test is considered to be a <a id="_idIndexMarker373"/>success. However, the test is considered to be <span class="No-Break">a failure.</span></li></ul></li>
			</ul>
			<p>Armed with this new <a id="_idIndexMarker374"/>knowledge, we have everything we need to write our first test. Let‚Äôs start by writing tests for the <span class="No-Break"><strong class="source-inline">link</strong></span><span class="No-Break"> command.</span></p>
			<p>Looking at the code of the <strong class="source-inline">LinkCommand</strong> class, we notice that it does not have any methods. However, we see that its constructor calls the <strong class="source-inline">AddCommand</strong> method to set the <strong class="source-inline">LinkAddCommand</strong> as a sub-command of <strong class="source-inline">Linkcommand</strong> (that is why <strong class="source-inline">add</strong> appears as a child of the <span class="No-Break"><strong class="source-inline">link</strong></span><span class="No-Break"> command).</span></p>
			<p>In this case, our test method will not be verifying a result but rather a behavior. In this case, we want to verify that <strong class="source-inline">LinkAddCommand</strong> is actually a sub-command <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">LinkCommand</strong></span><span class="No-Break">.</span></p>
			<p>Here is the code for this <span class="No-Break">test method:</span></p>
			<pre class="source-code">
[TestMethod]
public void LinkCommand_CallingClassConstuctor_EnsuresThatLinkAddCommandIsTheOnlySubCommandOfLinkCommand()
{
¬†¬†¬†¬†// Arrange
¬†¬†¬†IBookmarkService service = null;
¬†¬†¬†var expectedSubCommand = new LinkAddCommand(service, "add", "Add a 
¬†¬†¬†new bookmark link");
¬†¬†¬†¬†// Act
¬†¬†¬†¬†var actualCommand = new LinkCommand(service, "link", "Manage 
¬†¬†¬†¬†bookmarks links");
¬†¬†¬†¬†var actualSubCommand = actualCommand.Subcommands[0];
¬†¬†¬†¬†// Assert
¬†¬†¬†Assert.AreEqual(1, actualCommand.Subcommands.Count);
¬†¬†¬†CollectionAssert.AreEqual(actualSubCommand.Aliases.ToList(), 
¬†¬†¬†expectedSubCommand.Aliases.ToList());
¬†¬†¬†Assert.AreEqual(actualSubCommand.Description, expectedSubCommand.
¬†¬†¬†Description);
}</pre>			<p>Although this code is self-explanatory and easy to understand, I wanted to point out a couple of <span class="No-Break">key points:</span></p>
			<ul>
				<li>Notice the naming <a id="_idIndexMarker375"/>convention applied to the name of the test method. It clearly indicates its intent: we are testing the <strong class="source-inline">LinkCommand</strong> class, and our test consists of calling the class constructor and ensuring that <strong class="source-inline">LinkAddCommand</strong> is its <span class="No-Break">only sub-command.</span></li>
				<li>Notice that we applied the 3A principle to structure the body of the <span class="No-Break">test method.</span></li>
				<li>Notice that we performed three assertions to verify the expected behavior. Also, note the usage of <strong class="source-inline">CollectionAssert</strong>, which helps with asserting collections and their items. It is way more convenient than using <strong class="source-inline">Assert</strong> when dealing with lists and collections of elements. This is my little secret for you, as many developers are not aware of it or don‚Äôt naturally tend to use <span class="No-Break">it </span><span class="No-Break">üòâ</span><span class="No-Break">.</span></li>
			</ul>
			<p>We are now ready to run our tests. Let‚Äôs see how we <span class="No-Break">do this.</span></p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor170"/>Running our tests</h1>
			<p>The .NET CLI provides a command for <a id="_idIndexMarker376"/><span class="No-Break">this purpose:</span></p>
			<pre class="console">
dotnet test</pre>			<p>This command will compile the code and the test project, discover the test classes and test methods, execute the tests, and return <span class="No-Break">the results.</span></p>
			<p>Visual Studio Code also provides <a id="_idIndexMarker377"/>a <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>) for listing and executing the tests. This pane can be displayed by clicking on the appropriate icon, as<a id="_idIndexMarker378"/> shown in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/B22400_10_06.jpg" alt="Figure 10.7 ‚Äì Running tests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 ‚Äì Running tests</p>
			<p>This GUI also provides a visual identification of the states of the test methods. In the preceding screenshot, we can see that our test method has been <span class="No-Break">completed successfully.</span></p>
			<p>From this GUI, we can also debug tests! This is a fantastic capability that helps us understand why a test is failing by strategically applying breakpoints and re-executing it in <span class="No-Break">debug mode.</span></p>
			<p>Excellent! We can implement <span class="No-Break">more tests.</span></p>
			<p><span class="No-Break">But wait!</span></p>
			<p>Have you noticed that we passed a <strong class="source-inline">null</strong> instance of the <strong class="source-inline">BookmarkrService</strong> as a parameter? This is fine since we are not relying on that parameter in the test we are conducting. But if we did (as we will when testing the <strong class="source-inline">import</strong> command), we would like to provide an instance <span class="No-Break">for it.</span></p>
			<p>We obviously don‚Äôt want to use an actual instance of that service as it is a dependency of the command and it may also rely on an external dependency, such as a database where the bookmarks <span class="No-Break">are stored.</span></p>
			<p>We will then need to provide a fake representation of it. This is <a id="_idIndexMarker379"/>where <strong class="bold">mocks</strong> come <span class="No-Break">into play!</span></p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor171"/>Mocking external dependencies</h1>
			<p>Mocking<a id="_idIndexMarker380"/> is useful for simulating the behavior of dependencies without actually relying on them. This is powerful because it allows us to test our application in isolation from its environment. The reason we want to do this is to have tests that ensure that the application‚Äôs code works correctly, irrespective of the state of <span class="No-Break">its dependencies.</span></p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor172"/>The role of mocking</h2>
			<p>Let me clarify this with an <a id="_idIndexMarker381"/>example. Let‚Äôs say you have a method that stores a bookmark in the database. You write a test method to verify that, and it fails. You run it again, and it passes. Can you tell, without investigating, whether this was due to a transient database connectivity problem or due to a bug in the code? You can‚Äôt! But if you remove the dependency (that is, the database) from the equation and the same behavior occurred, you can tell (with a high level of confidence) that this was due to a bug in <span class="No-Break">the code.</span></p>
			<p>It is worth mentioning that we usually write tests that take external dependencies out of the equation (namely, unit tests) and tests that take these external dependencies into account (such as integration or system tests). So, when facing such an issue, we can look at unit and integration or system tests to figure out if the problem is due to the dependency (such as a communication problem) or due to the <span class="No-Break">code itself.</span></p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor173"/>How to mock an external dependency</h2>
			<p>As mentioned earlier, we <a id="_idIndexMarker382"/>can write our own fake implementation of a dependency that simulates the behavior of the real dependency, but the major drawback of this approach is that we have to maintain (and possibly rewrite) these implementations if the behavior of the real <span class="No-Break">dependency changes.</span></p>
			<p>It is wiser to rely on a mocking framework that will perform this task for us. What we need to do is to provide an interface for that dependency and the mocking framework will create a fake representation of it at runtime. We can also pass instructions to the mocking framework to configure the behavior of the fake dependency in a certain way, depending on the test we need to perform. For example, we can instruct the mocking framework to simulate a certain error or exception when invoking a dependency with some parameter values to verify <a id="_idIndexMarker383"/>the behavior of our application under <span class="No-Break">these circumstances.</span></p>
			<p class="callout-heading">About mocking frameworks</p>
			<p class="callout">Just as there are many testing frameworks, there <a id="_idIndexMarker384"/>are also many mocking frameworks for you to choose from. One of the most commonly used ones, and my personal favorite, is <strong class="bold">NSubstitute</strong>. I like it <a id="_idIndexMarker385"/>because it is both powerful and easy to learn <span class="No-Break">and use.</span></p>
			<p class="callout">You can learn more about<a id="_idIndexMarker386"/> NSubstitute by visiting its <span class="No-Break">website: </span><a href="https://nsubstitute.github.io/help/getting-started/"><span class="No-Break">https://nsubstitute.github.io/help/getting-started/</span></a><span class="No-Break">.</span></p>
			<p>Let‚Äôs mock the <strong class="source-inline">BookmarkService</strong> service <span class="No-Break">using NSubstitute.</span></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor174"/>Mocking the BookmarkService service</h2>
			<p>The first thing we need to do<a id="_idIndexMarker387"/> is to add NSubstitute to the test project. We can achieve this by navigating to the directory of the test project and typing <span class="No-Break">this command:</span></p>
			<pre class="console">
dotnet add package NSubstitute</pre>			<p>Now, let‚Äôs update the <strong class="source-inline">LinkCommandTests</strong> test class by mocking the <strong class="source-inline">BookmarkService</strong> service. The updated code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
using NSubstitute;
‚Ä¶
namespace bookmarkr.Tests;
[TestClass]
public class LinkCommandTests
{
¬†¬†¬†¬†[TestMethod]
¬†¬†¬†¬†public void LinkCommand_CallingClassConstuctor_
¬†¬†¬†¬†EnsuresThatLinkAddCommandIsTheOnlySubCommandOfLinkCommand()
¬†¬†¬†¬†{
¬†¬†¬†¬†¬†¬†¬†¬†// Arrange
¬†¬†¬†¬†¬†¬†¬†¬†IBookmarkService service = Substitute.For&lt;IBookmarkService&gt;();
¬†¬†¬†¬†¬†¬†¬†¬†‚Ä¶
¬†¬†¬†¬†}
}</pre>			<p>As you can see, we haven‚Äôt done much here. We merely added a <strong class="source-inline">using</strong> statement for <strong class="source-inline">NSubstitute</strong> and instead of initializing the service to a <strong class="source-inline">null</strong> value, we asked <strong class="source-inline">NSubstitute</strong> to provide a simulation of it based on its interface (which is referred to as a <em class="italic">mock</em>). The result is a temporary, in-memory object built based on the structure of the <strong class="source-inline">IBookmarkService</strong> interface for which we can configure the behavior depending on the test we <span class="No-Break">are performing.</span></p>
			<p>If we now execute the test<a id="_idIndexMarker388"/> again, it still passes. Since we are not calling the service during our test, we do not need to configure its behavior. But we will need to do that for the upcoming test methods we are going <span class="No-Break">to implement.</span></p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor175"/>Using the mock version of the BookmarkService service</h2>
			<p>Let‚Äôs start by creating a test class<a id="_idIndexMarker389"/> for the <strong class="source-inline">import</strong> command. We first create the <strong class="source-inline">ImportCommandTests.cs</strong> file in the <strong class="source-inline">Commands\Import</strong> directory. This file will contain all the test methods related to the <span class="No-Break"><strong class="source-inline">import</strong></span><span class="No-Break"> command.</span></p>
			<p>Next, we lay out the base structure of the test class, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
using bookmarkr.Commands;
using bookmarkr.Services;
using NSubstitute;
namespace bookmarkr.Tests;
[TestClass]
public class ImportCommandTests
{
}</pre>			<p>This command has no subcommands, so we do not need to test that, or we can write a test that verifies this fact. If you want to do this, you can follow the same procedure as in the <span class="No-Break"><strong class="source-inline">LinkCommandTests</strong></span><span class="No-Break"> class.</span></p>
			<p>Before we start<a id="_idIndexMarker390"/> implementing tests, we need to identify the test cases we want to perform. In invite you to reflect on that, but in the meantime, here is a non-exhaustive list of <span class="No-Break">test cases:</span></p>
			<ul>
				<li><strong class="bold">Test case #1</strong>: Calling the <strong class="source-inline">OnImportCommand</strong> handler method will call the <strong class="source-inline">Import</strong> method <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">BookmarkService</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Test case #2</strong>: If the file name is invalid, an error message should be returned (for example, indicating that there is an forbidden character in <span class="No-Break">the filename).</span></li>
				<li><strong class="bold">Test case #3</strong>: If the file is not found, an error message, indicating that the file does not exist, should <span class="No-Break">be returned.</span></li>
				<li><strong class="bold">Test case #4</strong>: When importing bookmarks, if no conflict is detected, the imported bookmarks are found in the local collection <span class="No-Break">of bookmarks.</span></li>
				<li><strong class="bold">Test case #5</strong>: When importing bookmarks, if a conflict occurs, the conflicting bookmark‚Äôs name is updated but the URL remains unchanged. The <strong class="source-inline">Log</strong> method is <span class="No-Break">also called.</span></li>
			</ul>
			<p>For the purpose of this chapter, we will only implement test cases 1 and 5. The remaining test cases are left for you as <span class="No-Break">a challenge.</span></p>
			<p>However, before we can implement these test cases, some changes to the application‚Äôs code have to <span class="No-Break">be made.</span></p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor176"/>Changes to the code must be made!</h2>
			<p>Here is <a id="_idIndexMarker391"/>the idea: sometimes, changes to your code will have to be made so that the code can be testable. This is okay because some classes of the .NET framework aren‚Äôt testable <span class="No-Break">by nature.</span></p>
			<p>In our situation, this is the case with the <strong class="source-inline">FileInfo</strong> class, which is a sealed class and exposes no interface, hence it cannot be overridden <span class="No-Break">nor mocked.</span></p>
			<p>Fortunately, there is a library that allows us to work around this limitation. We will then need to add the following NuGet package to both the application and the <span class="No-Break">test projects:</span></p>
			<pre class="console">
dotnet add package System.IO.Abstractions</pre>			<p>For the test project, we will also need to add this NuGet package, which will help <span class="No-Break">with testing:</span></p>
			<pre class="console">
dotnet add package System.IO.Abstractions.TestingHelpers</pre>			<p>We will also need to make the following changes to the <span class="No-Break"><strong class="source-inline">ImportCommand</strong></span><span class="No-Break"> class:</span></p>
			<ol>
				<li>We will add a private property of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">IFileSystem</strong></span><span class="No-Break">.</span></li>
				<li>We will initialize this property to an instance of the <strong class="source-inline">FileSystem</strong> class in the <span class="No-Break">default constructor.</span></li>
				<li>We will add a second constructor that will only be used for testing. This constructor will take an extra parameter, of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">IFileSystem</strong></span><span class="No-Break">.</span></li>
				<li>Finally, we will add an overload of the <strong class="source-inline">OnImportCommand</strong> handler method that takes an <strong class="source-inline">IFileInfo</strong> parameter and whose only purpose is to call the original version of the <strong class="source-inline">OnImportCommand</strong> method, passing an instance of <strong class="source-inline">FileInfo</strong> based on the <strong class="source-inline">IFileInfo</strong> object <span class="No-Break">it received.</span></li>
			</ol>
			<p>Invoking the <strong class="source-inline">import</strong> command once again, we find out that it still works <span class="No-Break">as expected.</span></p>
			<p>We can now implement those <span class="No-Break">test cases.</span></p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor177"/>Going back to implementing the test cases</h2>
			<p>Let‚Äôs start with test<a id="_idIndexMarker392"/> case 1. Here is the associated <span class="No-Break">test method:</span></p>
			<pre class="source-code">
[TestMethod]
public void OnImportCommand_PassingAValidAndExistingFile_CallsImportMethodOnBookmarkService()
{
¬†¬†¬†¬†// Arrange
¬†¬†¬†¬†var mockBookmarkService = Substitute.For&lt;IBookmarkService&gt;();
¬†¬†¬†¬†string bookmarksAsJson = @"[
¬†¬†¬†¬†¬†¬†¬†¬†{
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Name"": ""Packt Publishing"",
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Url"": ""https://packtpub.com/"",
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Category"": ""Tech Books""
¬†¬†¬†¬†¬†¬†¬†¬†},
¬†¬†¬†¬†¬†¬†¬†¬†{
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Name"": ""Audi cars"",
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Url"": ""https://audi.ca"",
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Category"": ""See later""
¬†¬†¬†¬†¬†¬†¬†¬†},
¬†¬†¬†¬†¬†¬†¬†¬†{
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Name"": ""LinkedIn"",
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Url"": ""https://www.linkedin.com/"",
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Category"": ""Social Media""
¬†¬†¬†¬†¬†¬†¬†¬†}
¬†¬†¬†¬†]";
¬†¬†¬†¬†var mockFileSystem = new MockFileSystem(new Dictionary&lt;string, 
¬†¬†¬†¬†MockFileData&gt;
¬†¬†¬†¬†{
¬†¬†¬†¬†¬†¬†¬†¬†{@"bookmarks.json", new MockFileData(bookmarksAsJson)}
¬†¬†¬†¬†¬†¬†¬†¬†});
¬†¬†¬†¬†var command = new ImportCommand(mockBookmarkService, 
¬†¬†¬†¬†mockFileSystem, "import", "Imports all bookmarks from a file");
¬†¬†¬†¬†// Act
¬†¬†¬†¬†command.OnImportCommand(mockFileSystem.FileInfo.New("bookmarks.
¬†¬†¬†¬†json"));
¬†¬†¬†¬†// Assert
¬†¬†¬†¬†mockBookmarkService.Received(3).Import(Arg.Any&lt;Bookmark&gt;());
¬†¬†¬†¬†mockBookmarkService.Received(1).Import(Arg.Is&lt;Bookmark&gt;(b =&gt; 
¬†¬†¬†¬†b.Name == "Packt Publishing" &amp;&amp; b.Url == "https://packtpub.com/" 
¬†¬†¬†¬†&amp;&amp; b.Category == "Tech Books"));
¬†¬†¬†¬†mockBookmarkService.Received(1).Import(Arg.Is&lt;Bookmark&gt;(b =&gt; 
¬†¬†¬†¬†b.Name 
¬†¬†¬†¬†== "Audi cars" &amp;&amp; b.Url == "https://audi.ca" &amp;&amp; b.Category == "See 
¬†¬†¬†¬†later"));
¬†¬†¬†¬†mockBookmarkService.Received(1).Import(Arg.Is&lt;Bookmark&gt;(b =&gt; 
¬†¬†¬†¬†b.Name == "LinkedIn" &amp;&amp; b.Url == "https://www.linkedin.com/" &amp;&amp; 
¬†¬†¬†¬†b.Category == "Social Media"));
}</pre>			<p>This code deserves an explanation, so here <span class="No-Break">we go:</span></p>
			<ol>
				<li>We first create a mock of the <strong class="source-inline">BookmarkService</strong>, as we did in the <span class="No-Break">previous example.</span></li>
				<li>Then, we create a string representation of the JSON content for three bookmarks that will be needed for <span class="No-Break">our test.</span></li>
				<li>Next, and this is the reason why we performed the changes to the code that we described above, we create a mock of the filesystem and simulate the existence of a file named <strong class="source-inline">bookmarks.json</strong> that contains the JSON representation we created in the <span class="No-Break">previous step.</span></li>
				<li>After that, we <a id="_idIndexMarker393"/>create an instance of the <strong class="source-inline">ImportCommand</strong> class using the new constructor we have added, which allows us to pass the mock filesystem as <span class="No-Break">a parameter.</span></li>
				<li>We are now ready to invoke the <strong class="source-inline">OnImportCommand</strong> by relying on the mock filesystem and passing the name of the <strong class="source-inline">bookmarks.json</strong> file we simulated earlier. It is important to note here that if we pass the name of a file that was not part of the simulation, the test <span class="No-Break">will fail.</span></li>
				<li>We are now ready to verify whether our assertions are correct. Pay careful attention to how we did it: we first ensured that calling the <strong class="source-inline">OnImportCommand</strong> method triggered three calls to the <strong class="source-inline">Import</strong> method of <strong class="source-inline">BookmarkService</strong> (here, these calls are in fact made to the mock version of the service since we do not want the service to be activated but rather, we only want to validate that it was invoked as expected). This is, however, not sufficient to validate that the test is successful as these three calls could include unexpected calls. To make sure that these calls are legitimate, we verify them, one by one, ensuring that each of their meaningful properties matches what <span class="No-Break">is expected.</span></li>
			</ol>
			<p>And that‚Äôs it for test <a id="_idIndexMarker394"/>case #1. Let‚Äôs now move on to test <span class="No-Break">case #5.</span></p>
			<p>Here is the code for this <span class="No-Break">test case:</span></p>
			<pre class="source-code">
[TestMethod]
public void ImportCommand_Conflict_TheNameOfTheConflictingBookmarkIsUpdated()
{
¬†¬†¬†¬†// Arrange
¬†¬†¬†¬†var bookmarkService = new BookmarkService();
¬†¬†¬†¬†bookmarkService.ClearAll();
¬†¬†¬†¬†bookmarkService.AddLink("Audi Canada", "https://audi.ca", "See 
¬†¬†¬†¬†later");
¬†¬†¬†¬†string bookmarksAsJson = @"[
¬†¬†¬†¬†¬†¬†¬†¬†{
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Name"": ""Packt Publishing"",
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Url"": ""https://packtpub.com/"",
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Category"": ""Tech Books""
¬†¬†¬†¬†¬†¬†¬†¬†},
¬†¬†¬†¬†¬†¬†¬†¬†{
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Name"": ""Audi cars"",
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Url"": ""https://audi.ca"",
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Category"": ""See later""
¬†¬†¬†¬†¬†¬†¬†¬†},
¬†¬†¬†¬†¬†¬†¬†¬†{
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Name"": ""LinkedIn"",
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Url"": ""https://www.linkedin.com/"",
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Category"": ""Social Media""
¬†¬†¬†¬†¬†¬†¬†¬†}
¬†¬†¬†¬†]";
¬†¬†¬†¬†var mockFileSystem = new MockFileSystem(new Dictionary&lt;string,
¬†¬†¬†¬†MockFileData&gt;
¬†¬†¬†¬†{
¬†¬†¬†¬†¬†¬†¬†¬†{@"bookmarks.json", new MockFileData(bookmarksAsJson)}
¬†¬†¬†¬†});
¬†¬†¬†¬†var command = new ImportCommand(bookmarkService, mockFileSystem, 
¬†¬†¬†¬†"import", "Imports all bookmarks from a file");
¬†¬†¬†¬†// Act
¬†¬†¬†¬†command.OnImportCommand(mockFileSystem.FileInfo.New("bookmarks.
¬†¬†¬†¬†json"));
¬†¬†¬†¬†var currentBookmarks = bookmarkService.GetAll();
¬†¬†¬†¬†// Assert
¬†¬†¬†¬†Assert.AreEqual(3, currentBookmarks.Count);
¬†¬†¬†¬†Assert.IsTrue(currentBookmarks.Exists(b =&gt; b.Name == "Packt 
¬†¬†¬†¬†Publishing" &amp;&amp; b.Url == "https://packtpub.com/" &amp;&amp; b.Category == 
¬†¬†¬†¬†"Tech Books"));
¬†¬†¬†¬†Assert.IsTrue(currentBookmarks.Exists(b =&gt; b.Name == "Audi cars" 
¬†¬†¬†¬†&amp;&amp; b.Url == "https://audi.ca" &amp;&amp; b.Category == "See later"));
¬†¬†¬†¬†Assert.IsTrue(currentBookmarks.Exists(b =&gt; b.Name == "LinkedIn" 
¬†¬†¬†¬†&amp;&amp; b.Url == "https://www.linkedin.com/" &amp;&amp; b.Category == "Social 
¬†¬†¬†¬†Media"));
¬†¬†¬†¬†Assert.IsFalse(currentBookmarks.Exists(b =&gt; b.Name == "Audi 
¬†¬†¬†¬†Canada" &amp;&amp; b.Url == "https://audi.ca" &amp;&amp; b.Category == "See 
¬†¬†¬†¬†later"));
}</pre>			<p>The code for this test <a id="_idIndexMarker395"/>case is very similar to the code for test case #1, with two <span class="No-Break">noticeable differences:</span></p>
			<ul>
				<li>We are calling the real implementation of <strong class="source-inline">BookmarkService</strong>, not a mock. The reason is that we want to ensure that the bookmarks have been imported correctly and that the conflicting one has been renamed accordingly. If that service was relying on a database, we could have mocked <span class="No-Break">that database.</span></li>
				<li>The last assertion, although not necessary, ensures that the original, conflicting bookmark does not exist anymore since it has <span class="No-Break">been updated.</span></li>
			</ul>
			<p>Now, if you have been coding along with me, you have certainly noticed that this code does not work. In fact, it does not even compile! Don‚Äôt worry, this was intentional üòä. The intention is to teach you how to control visibility to <span class="No-Break">test artifacts.</span></p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor178"/>Internals visibility</h2>
			<p>In the <strong class="source-inline">ImportCommand</strong> class, we added a second constructor (which takes a parameter of type <strong class="source-inline">IFileSystem</strong>) and an overload for the <strong class="source-inline">OnImportCommand</strong> handler <a id="_idIndexMarker396"/>method. These two methods have been marked as <strong class="source-inline">internal</strong>, which simply means that they are visible to all parts  of the code within the current project but aren‚Äôt visible outside of that project unless we <span class="No-Break">specify otherwise.</span></p>
			<p>This is the recommended approach when you add artifacts specifically for <span class="No-Break">testing purposes.</span></p>
			<p>The <strong class="source-inline">internal</strong> accessor is very interesting. It allows us to control its visibility. In this case, we only want the test project to see these internal <span class="No-Break">code artifacts.</span></p>
			<p>To do that, we will need to update the <strong class="source-inline">bookmarkr.csproj</strong> file (the one where these code artifacts marked as <strong class="source-inline">internal</strong> are located) to indicate that we only want the test project to be able to access them. We can achieve this by adding <span class="No-Break">this entry:</span></p>
			<pre class="source-code">
&lt;ItemGroup&gt;
¬†¬†¬†¬†&lt;InternalsVisibleTo Include="bookmarkr.UnitTests" /&gt;
&lt;/ItemGroup&gt;</pre>			<p>This means that code artifacts that are marked as <strong class="source-inline">internal</strong> in the <strong class="source-inline">bookmarkr</strong> project can only be ‚Äúseen‚Äù by the <span class="No-Break"><strong class="source-inline">bookmarkr.UniTests</strong></span><span class="No-Break"> project.</span></p>
			<p>Now, you will notice that the code compiles and executes <span class="No-Break">as expected.</span></p>
			<p>Looking back at the<a id="_idIndexMarker397"/> test methods of the <strong class="source-inline">ImportCommandTests</strong> class, you have certainly noticed that in both test methods, we instantiated and initialized <strong class="source-inline">MockFileSystem</strong> and the string representation of the JSON structure of the bookmarks in the same way. Hence, this code is redundant and, if it changes over time, we need to update this code in both places. This will get even worse as the number of test <span class="No-Break">methods increases.</span></p>
			<p>Fortunately, MS Test provides a way to centralize this initialization. Let‚Äôs see how <span class="No-Break">this works.</span></p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor179"/>Centralizing test initialization</h2>
			<p>MS Test <a id="_idIndexMarker398"/>provides a <strong class="source-inline">[TestInitialize]</strong> attribute that can be used to decorate a method where any common instantiation, initialization, or configuration can <span class="No-Break">be centralized.</span></p>
			<p>This method is then automatically invoked by the MS Test framework before calling every test method. This has another benefit: every test method gets fresh instances of the objects instantiated in the initialization method, preventing the execution of a test method to have an impact and an influence on the execution of the next <span class="No-Break">test method.</span></p>
			<p>The code of the test initialization method looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
public required IBookmarkService _bookmarkService;
public required MockFileSystem _mockFileSystem;
[TestInitialize]
public void TestInitialize()
{
¬†¬†¬†¬†string bookmarksAsJson = @"[
¬†¬†¬†¬†¬†¬†¬†{
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Name"": ""Packt Publishing"",
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Url"": ""https://packtpub.com/"",
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Category"": ""Tech Books""
¬†¬†¬†¬†¬†¬†¬†¬†},
¬†¬†¬†¬†¬†¬†¬†¬†{
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Name"": ""Audi cars"",
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Url"": ""https://audi.ca"",
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Category"": ""See later""
¬†¬†¬†¬†¬†¬†¬†¬†},
¬†¬†¬†¬†¬†¬†¬†¬†{
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Name"": ""LinkedIn"",
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Url"": ""https://www.linkedin.com/"",
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†""Category"": ""Social Media""
¬†¬†¬†¬†¬†¬†¬†¬†}
¬†¬†¬†¬†]";
¬†¬†¬†¬†_mockFileSystem = new MockFileSystem(new Dictionary&lt;string, 
¬†¬†¬†¬†MockFileData&gt;
¬†¬†¬†¬†{
¬†¬†¬†¬†¬†¬†¬†¬†{@"bookmarks.json", new MockFileData(bookmarksAsJson)}
¬†¬†¬†¬†});
}</pre>			<p>Fantastic! Now we know <a id="_idIndexMarker399"/>everything we need to know to implement meaningful and efficient tests for our <span class="No-Break">CLI application.</span></p>
			<p>But before closing this chapter, there is one last thing I want to discuss with you. I want to tell you how you can use these tests that you are implementing to identify and eliminate <span class="No-Break">a bug.</span></p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor180"/>How to hunt a bug</h1>
			<p>Tests play a key role in hunting down a <a id="_idIndexMarker400"/>bug and ensuring it doesn‚Äôt come up again. To do that, you should follow <span class="No-Break">a process.</span></p>
			<p>Whenever a bug is discovered (by you or your team) or reported (by the user), you should write tests that reproduce it. These tests can be of different types. These are to ensure that the bug doesn‚Äôt come <span class="No-Break">up again.</span></p>
			<p>Now, run your tests and you should notice that tests are failing. Tests that cover wider ranges (such as system or integration tests) will tell you in what component of the application the bug is happening. Then, more granular tests (such as unit tests) will tell you in what class and ultimately in what method the bug <span class="No-Break">is hiding.</span></p>
			<p>By using a smart combination of both wide-range and granular tests, you will be able to hunt down the bug. Keep in mind that breakpoints will be <span class="No-Break">great allies.</span></p>
			<p>And that‚Äôs it! We are now armed with everything we need to enhance the quality of our application by leveraging <span class="No-Break">software testing.</span></p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor181"/>Summary</h1>
			<p>In this chapter, we learned why testing is an important step in the process of developing any application, including CLI applications. I like to call tests your safety nets: they ensure not only that your new features behave as expected but also that you don‚Äôt accidentally introduce bugs in existing functionalities (we call these <strong class="bold">regressions</strong>). I highly encourage you to write effective tests and run <span class="No-Break">them often.</span></p>
			<p>We also explored the categories and roles of tests, and we learned techniques for testing applications and applied them to <strong class="bold">Bookmarkr</strong>, our <span class="No-Break">CLI application.</span></p>
			<p>Our application now has the required functionalities, and we ensured, through testing, that these functionalities behave as expected. It is now time to deliver the application to <span class="No-Break">its users!</span></p>
			<p>This is why, in the next chapter, we will explore different techniques that will allow us to package, distribute, and deploy <span class="No-Break">our application.</span></p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor182"/>Your turn!</h1>
			<p>Following along with the provided code is a great way to learn <span class="No-Break">through practice.</span></p>
			<p>A better way is by challenging yourself to achieve tasks. Hence, I challenge you to improve the Bookmarkr application by adding the <span class="No-Break">following features.</span></p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor183"/>Task #1 ‚Äì Write the required unit tests for the remaining functionalities</h2>
			<p>In this chapter, we wrote tests only for the <strong class="source-inline">link</strong> and <strong class="source-inline">import</strong> commands. You are hence challenged to write tests for the other commands. You will have to figure out what test cases are to be considered and <span class="No-Break">implement them.</span></p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor184"/>Task #2 ‚Äì Write integration tests for the sync command</h2>
			<p>The <strong class="source-inline">sync</strong> command deals with a database. For the purpose of unit testing, you can mock the database using NSubstitute. However, when implementing an integration test, you need a real database. You are then challenged to write integration tests for the <strong class="source-inline">sync</strong> command. You will have to provide a test database and use the appropriate connection string depending on whether the application is running in production or in <span class="No-Break">testing mode.</span></p>
		</div>
	</body></html>