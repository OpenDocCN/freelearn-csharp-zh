- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simplifying Microservices with .NET Aspire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '.NET Aspire was conceived to simplify the testing of interacting microservices
    on development machines. In the *Running your microservices on Kubernetes* section
    of [*Chapter 8*](Chapter_8.xhtml#_idTextAnchor205), *Practical Microservices Organization
    with Kubernetes*, we listed two testing techniques we can adopt on our development
    machines:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the interacting microservices with minikube while debugging each single
    microservice with the bridge technique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting Visual Studio native support for Docker to debug and test our microservices
    while they interact through a Docker virtual network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the minikube technique is complete and more realistic, it is time-consuming,
    so most of the testing/debugging is performed with Docker virtual networks.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Aspire provides a simpler alternative to the direct usage of Docker networks.
    Moreover, it offers a simple way to configure the interaction between microservices
    and between each microservice and other resources. Finally, .NET Aspire projects
    can be compiled to produce instructions to both deploy all microservices on Azure
    Container Apps and to create some of the resources that they use on Azure. However,
    its main usage is in development and staging environments and it should not be
    used for automatically setting up actual production environments since it doesn’t
    handle all deployment options.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will describe the basics of .NET Aspire together with all
    the services and opportunities it offers. More specifically, this chapter covers
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET Aspire features and services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring microservices and resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using .NET Aspire in practice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a .NET Aspire project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 free *Community Edition*, at least.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Docker Desktop** for Windows ([https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)),
    which, in turn, requires Windows Subsystem for Linux (WSL), which can be installed
    by following these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `powershell` in the Windows 10/11 search bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When Windows PowerShell is proposed as a search result, click on **Run as an
    administrator**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Windows PowerShell administrative console that appears, run the `wsl
    --install` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find the sample code for this chapter at [https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp](https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp).
  prefs: []
  type: TYPE_NORMAL
- en: .NET Aspire features and services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '.NET Aspire takes care of the microservices interaction and offers other services,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It handles the interaction with environment resources such as databases and
    message brokers in a very simple way. You don’t need to specify a connection string
    that might change when the microservice is deployed; it is enough that you declare
    the interaction between a microservice and a resource together with some general
    configuration. This is done with a .NET feature called **local service discovery**,
    which will be discussed in detail in the *Service discovery and its role in .NET
    Aspire* subsection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It offers simulators of cloud services, together with common disk and in-memory
    databases and message brokers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interaction between microservices and other resources is configured declaratively
    in a dedicated .NET project, thus avoiding the usage of virtual addresses and
    connection strings inside the microservices code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a .NET Aspire project is run, all microservices and resources are run,
    and interactions among microservices and resources are automatically handled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While microservices are run in the development environment, both logs and statistics
    are collected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As soon as a .NET Aspire project is run, a smart console appears in the browser
    that shows all collected statistics and logs, together with the links to access
    all microservice endpoints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interactions between microservices and between microservices and other resources
    are declared in a special type of project called App Host. You can find the App
    Host project and all other Aspire templates by typing `Aspire` in the Visual Studio
    search box, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: Aspire projects and solution templates](img/B31916_12_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Aspire projects and solution templates'
  prefs: []
  type: TYPE_NORMAL
- en: Another Aspire-specific project type is the .NET Aspire Service Defaults project,
    which provides extension methods to configure various services. In order to ensure
    that some basic services are configured in the same way in all microservices,
    we define them in this project and then call their extension methods in the `Program.cs`
    configuration of all microservice projects. Accordingly, all microservices must
    add a reference to this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a default, all Aspire templates configure the following service defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpClient` service discovery: In the App Host configuration, microservices
    and resources are given names, and thanks to this configuration, `HttpClient`
    can use virtual URLs based on these names instead of the actual resource URLs,
    which might depend on where the resources are deployed in the various environments
    (development, staging, production, etc.).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpClient` resiliency: Each `HttpClient` call is automatically applied to
    all policies, as discussed in the *Resilient task execution* subsection of[*Chapter
    2*](Chapter_2.xhtml#_idTextAnchor038), *Demystifying Microservices Applications*.
    More specifically, retry, circuit break, timeout, and rate-limiting (bulkhead
    isolation) strategies are automatically applied and can be configured once and
    for all in the **.NET Aspire Service Defaults** project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenTelemetry, which will be discussed in a dedicated subsection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Public endpoints exposing microservice health conditions. Health checks are
    used both by the App Host orchestrator and by staging and production orchestrators
    such as Kubernetes (see the *Readiness, liveness, and startup probes* subsection
    of [*Chapter 8*](Chapter_8.xhtml#_idTextAnchor205), *Practical Microservices Organization
    with Kubernetes*). Two default endpoints are provided: `/health`, which returns
    a `200` HTTP code and a “healthy” test response if the microservice is healthy,
    and an `/alive` endpoint, which returns a `200` HTTP code and a “healthy” test
    response if the microservice is running and has not crashed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a default, both endpoints are exposed only during development for security
    reasons. However, if the microservice is not accessible to external users, it
    can also be safely exposed in production. You need just to remove the condition
    on the environment in the `MapDefaultEndpoints()` extension defined in the the
    .NET Aspire Service Defaults project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If, instead, the microservice is a frontend, these endpoints can be exposed
    only if they are protected by both authentication and a throttling strategy that
    prevents denial of service attacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don’t need to manually add all these configurations since they are automatically
    added when the project is created. Most of the time, you will need to only change
    some parameters, such as the parameters of the various resiliency strategies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each microservice needs just to call `builder.AddServiceDefaults()` and `app.MapDefaultEndpoints()`
    in order to apply all the configured defaults, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are also Aspire-specific testing projects based on xUnit, NUnit, and MSTest.
    They have all the needed references to create an app host, launch the application,
    and communicate with microservices through URLs based on their names (service
    discovery).
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as you add a test project, it contains an initial example test with
    the whole code for creating the App Host and issuing a call to a microservice.
    This code is commented out, so you need just to add a reference to your App Host
    project to uncomment the code, and to replace the fake App Host project name and
    microservice name with your App Host project name and microservice name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the fake names that must be replaced are highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: A template called **.NET Aspire Empty App** is also available, which creates
    both the App Host and Service Defaults projects, and a **.NET Aspire Starter App**
    template that adds some example microservices and resources, together with their
    App Host configurations.
  prefs: []
  type: TYPE_NORMAL
- en: The **.NET Aspire Starter App** template has a great didactic value because
    it immediately shows basic configurations, and how to configure and use `HttpClient`
    with service discovery. Moreover, it is a good way to explore the console that
    appears in the browser when the application is launched with its statistics and
    logs, and the links to access all microservice endpoints. You are encouraged to
    create, explore, and run this project.
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery is not an Aspire-specific feature but is a general .NET feature.
    It relies on various providers to map service names to actual URLs. We will discuss
    it in more detail in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery and its role in .NET Aspire.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Service discovery is an `HttpClient` feature provided through extension methods
    defined in the `Microsoft.Extensions.ServiceDiscovery` NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: Service names are mapped to actual URLs by using maps defined by providers.
    As a default, just the .NET configuration provider is added to the list of providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This provider tries to read these maps from the `Service`s section of the project
    configuration, where they must be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When the service is called with `http://myservice`, the endpoint specified in
    the `http` subsection is chosen; otherwise, if it is called with `https://myservice`,
    the one in the `https` subsection is chosen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration-based provider is added with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code also adds the pass-through provider, which simply resolves
    each service name to the service name itself. In other words, the pass-through
    provider does nothing! It must be used when deploying to Kubernetes since, in
    Kubernetes, names are resolved by services.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when deploying to Kubernetes, each Microservice must have an associated
    service whose name is identical to the microservice name.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if we have a microservice called `routes_planning` that is deployed
    in a Kubernetes `routes_planning` Deployment, then communications to `routes_planning`
    must be passed through a Kubernetes service called `routes-planning`.
  prefs: []
  type: TYPE_NORMAL
- en: If a service name is not resolved by the configuration-based provider, it is
    passed to the next provider, which is the pass-through provider.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we would like to deploy on Kubernetes but, first, we need to test our
    application with .NET Aspire. Do we need two different service discovery settings
    for these two environments?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is no! In fact, .NET Aspire doesn’t use a configuration file to define
    the service maps. Instead, when the App Host project launches a microservice,
    it injects all service resolution rules it needs into environment variables that
    are then merged with all other microservice configuration information.
  prefs: []
  type: TYPE_NORMAL
- en: When the application is published to a Kubernetes cluster, there will be no
    App Host, so no service resolution maps are injected in the configuration, and
    all resolutions are passed to the pass-through provider.
  prefs: []
  type: TYPE_NORMAL
- en: One can also use `AddServiceDiscoveryCore()`, which doesn’t add any default
    provider instead of `AddServiceDiscovery()`. In this case, providers must be added
    manually by calling
  prefs: []
  type: TYPE_NORMAL
- en: '`AddPassThroughServiceEndpointProvider()` and `AddConfigurationServiceEndpointProvider()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we would like to add just the configuration-based provider,
    we can simply write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Service discovery can be also customized by setting the properties of the `ConfigurationServiceEndPointResolverOptions`
    option object. For instance, the following code changes the name of the `Services`
    section in which to place all service name maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have added and configured service discovery, we must specify the HTTP
    clients that must use it. The following code applies service discovery to all
    HTTP clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`ConfigureHttpClientDefaults` can also be used to add and configure the various
    resiliency policies for all HTTP clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is the default `HttpClient` configuration added in all **.NET
    Aspire Service Defaults** projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Service discovery can also be added to a specific `HttpClient`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When service discovery is in place, we can also write URIs such as `"https+http://routes_planning"`
    or `"http+https://routes_planning"`. In this case, service discovery will attempt
    to resolve the URI with the first protocol (`https` or `http`), and will move
    to the second protocol in the case of failure.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful when we use `http` during development and `https` in staging
    and production. For this purpose, it is enough to define just `http` endpoints
    in the launch settings of all microservice projects. In fact, the App Host uses
    each microservice’s launch settings to create the service discovery maps that
    it injects into the environment variables. Therefore, only `http` maps would be
    generated during development, so the `https` resolution will fail. After deployment,
    instead, just the pass-through provider will work so the `https` resolution will
    succeed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up to this point, we supposed that each microservice has just a single endpoint,
    but sometimes, some services might have several endpoints, each on a different
    port. When a microservice has several endpoints, we must give names to all the
    endpoints except one (the default endpoint). Endpoint names are given in the service
    definition and configuration that is in the App Host. The following is the definition
    of a microservice with a default endpoint and a named endpoint whose name is `"aux"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the generated configuration map will associate two URLs to the
    service name, one for the default endpoint and the other for the named endpoint,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The default endpoint can be accessed with `"https://routes_planning"`, while,
    for the named endpoint, we must add also the endpoint name to the URI, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When using Aspire App Host, the preceding configuration is automatically created
    and injected into all services that need it, so we don’t need to worry about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we deploy on Kubernetes, we must define a Kubernetes service that
    correctly resolves both `"https://routes_planning"` and `"https://_aux.routes_planning"`.
    This result is easily achieved with named ports, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The port associated with the default endpoint must be given the `default` name,
    while all ports associated with named endpoints must be given the same name as
    the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the magic behind actual service URL discovery, let’s
    move on to the magic behind resource integration and automatic connection string
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: Resource integration and automatic resource configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Resources needed for the various microservice projects can be simulated when
    the solution is run. It is enough to add the corresponding Aspire NuGet packages
    and declare and configure the resource in the App Host. There are extension methods
    for declaring the main databases, Redis, and the main message brokers such as
    RabbitMQ, Kafka, and even an Azure Service Bus simulator. For a complete list
    of all resources that can be added to an Aspire project and configured in its
    App Host, please refer to the official documentation on integration at [https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/integrations-overview](https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/integrations-overview).
  prefs: []
  type: TYPE_NORMAL
- en: Behind the curtain, all these resources are implemented with Docker images,
    so most extension methods also allow you to choose a specific Docker image and
    a specific version. Furthermore, since the App Host supports generic Docker images,
    one can implement extension methods for a custom resource that is not yet supported.
    However, the list of supported resources is growing quickly, so you should find
    all the resources you need already implemented.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Using .NET Aspire in practice* section of this chapter, you will see
    in detail how to integrate and configure SQL Server and RabbitMQ, and in the *Configuring
    Microservices and Resources* section, we will explain how to declare and configure
    both microservices and resources in the App Host.
  prefs: []
  type: TYPE_NORMAL
- en: When you configure a resource, you give it a name, and if the resource supports
    a connection string, that name is assumed to be the name of the connection string.
    Accordingly, when the App Host creates a resource, it computes its connection
    string and passes it in the `ConnectionStrings` section of the configuration of
    all microservices that use that resource. This is done by placing the configuration
    string in an environment variable called `ConnectionStrings__<name>`, where `<name>`
    is the name that we gave to the resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, suppose our application needs a SQL Server instance containing
    a database called `"mydatabase"`. In the App Host, we may declare these resources
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if a microservice defined in the `MyExampleProject` project must use the
    `"mydatabase"` database, it must declare it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `WithReference(db)` call causes the connection string for accessing `"mydatabase"`
    in the SQL Server instance to be injected in the `ConnectionStrings__mydatabase`
    environment variable of the `MyExampleProject` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, when we configure a resource, we can also specify the credentials to
    access it instead of using the default credentials created by the extension method.
  prefs: []
  type: TYPE_NORMAL
- en: More details on how to configure resources and microservices in the App Host
    will be given in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, together with the connection string, the App Host passes a whole configuration
    section containing more details on the resources, such as username and password.
    The format of this auxiliary data depends on the specific resource type. In the
    *Using .NET Aspire in practice* section of this chapter, we will see the RabbitMQ
    auxiliary information format. The auxiliary information format of all supported
    resources is available in the official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use an already existing resource, we don’t need to declare it
    in the App Host but we need to declare its connection string with `builder.AddConnectionString`
    so that the App Host can inject it into all the microservices that need it. For
    instance, if the SQL Server database of the previous example already exists both
    in the development environment and in the deployment environment, the code must
    be modified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `parameterName` is the name of the parameter that contains the connection
    string in the App Host configuration file in the `"Parameters"` section, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Needless to say, we can use .NET environments to provide different configurations
    in different environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remainder of the code remains unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: What happens to all the connection strings and the auxiliary resource data when
    the application is deployed in production or staging?
  prefs: []
  type: TYPE_NORMAL
- en: 'If deployment is manual, the same environment variable inserted by the App
    Host must be defined in the configuration of the target orchestrator. Thus, for
    instance, if the target orchestrator is Kubernetes, it must be defined in the
    `env` section of a Deployment. As we will see in more detail in the *Deploying
    a .NET Aspire project* section, when we use automatic tools for configuring the
    target orchestrator, there are two possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: If the automatic tool is capable of provisioning the required resources, it
    will also automatically configure all the environment variables, taking all the
    required information from the created resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the automatic tool doesn’t generate the required resources but only generates
    the code to configure all the microservices, it will ask the user for the environment
    variable values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next subsection details how to handle telemetry during development and when
    the application is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Application telemetry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Telemetry enables the monitoring of a microservices application as a whole
    by connecting adequately related events taking place in different microservices.
    More specifically, it collects the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Logging: Individual logs of all microservices and resources are collected and
    classified according to their generation time and source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tracing: Traces correlate log events that are part of the same logical activity
    (e.g., the handling of a single request), even if they’re spread across multiple
    machines or processes. Tracing is the starting point for diagnosing and debugging
    malfunctions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Metrics: Various microservice metrics are collected by each executing microservice
    and are sent to a collection point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the application is run in the development environment and uses the App
    Host as an orchestrator, each microservice’s telemetry is enabled by the `ConfigureOpenTelemetry()`
    call configured in the **.NET Aspire Service Defaults** project. This call enables
    the collection of metrics and the transmission of these metrics together with
    the microservice logs to an **OpenTelemetry** endpoint that implements the **OpenTelemetry
    Protocol (OTLP)**.
  prefs: []
  type: TYPE_NORMAL
- en: During development, the Aspire console that opens when the solution is run works
    as an OpenTelemetry endpoint, and the data for connecting with this endpoint is
    injected as an environment variable into all microservices by the App Host. Therefore,
    all the data we can see in this console comes from telemetry.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the application is deployed, the same environment variables must contain
    the data of an OpenTelemetry endpoint available in the deployment environment.
    Azure supports OTLP, so if, for instance, the application is deployed to Azure
    Kubernetes, we must pass the data of the telemetry endpoint that is created together
    with the Azure Kubernetes cluster. It is also possible to pass OpenTelemetry data
    to tools such as Grafana, which was described in the *Kubernetes administrative
    tools* subsection of [*Chapter 9*](Chapter_9.xhtml#_idTextAnchor261), *Simplifying
    Containers and Kubernetes: Azure Container Apps* *and other Tools*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The environment variables automatically injected in each microservice by the
    App Host that we must inject manually in the deployment environment are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OTEL_EXPORTER_OTLP_ENDPOINT`, which contains the URL of the OTLP endpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OTEL_SERVICE_NAME`, which contains the service name that the microservice
    must add to the data it sends. You should use the same name given to the microservice
    in the App Host configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OTEL_RESOURCE_ATTRIBUTES`, which contains a unique ID that univocally identifies
    each service instance. It must be added to all data, too, and must have the following
    format: `service.instance.id=<unique name>`. Typically, GUIDs are used as unique
    service names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have clarified all the services offered by Aspire, you need to learn
    how to configure the App Host.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring microservices and resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The App Host handles services as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '.NET projects: These can be configured with `var myService = builder.AddProject<Projects.MyProjectName>("myservicename");`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Containers stored in some registry: These can be configured with `var myService
    = builder.AddContainer("myservicename", "ContainerNameOrUri");`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Executables: These can be configured with `var myService = builder.AddExecutable("myservicename",
    "<shell command>", "<executable working directory>");`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Dockerfiles to be built: These can be configured with `var myService = builder.AddDockerfile(`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: where `"relative/context/path"` is the folder containing the Dockerfile and
    all files needed to build the Dockerfile. This path must be relative to the directory
    that contains the App Host project file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the preceding commands can be followed by several configuration options,
    passed with a fluent interface, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`WithReference` declares that the service communicates with the resource or
    service passed as an argument. It causes the injection of all environment variables
    containing the data needed by service discovery, connection strings, or other
    auxiliary resource information.'
  prefs: []
  type: TYPE_NORMAL
- en: '`WaitFor` declares that the microservice must be started after the service
    or resource passed as the argument is running.'
  prefs: []
  type: TYPE_NORMAL
- en: '`WithReplicas(int n)` is another important method of the fluent interface configuration.
    It declares that the microservice must be replicated *n* times. It is important
    if we plan to use an automatic tool to compile the App Host configuration into
    Kubernetes or Azure Container Apps configuration code.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, often, when in development mode, the limited power of our development
    machine doesn’t allow the same number of replicas that we need in production.
    Therefore, we should execute different configuration instructions in these cases.
  prefs: []
  type: TYPE_NORMAL
- en: The App Host configuration is executed both when we run the application on the
    development machine and when we use App Host configuration to generate code for
    other platforms. In the second case, we say that we are in publishing mode instead
    of running mode. Luckily, the `builder` object contains information on the execution
    environment in the `builder.ExecutionContext` property. In particular, we can
    use the `builder.ExecutionContext.IsPublishMode` and `builder.ExecutionContext.IsRunMode`
    properties to differentiate between the configuration in running mode and in publishing
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'As already mentioned, in the *Service discovery and its role in .NET Aspire*
    subsection, we can also use the `WithEndpoint` fluent interface method to declare
    auxiliary endpoints available on other ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`WithEndpoint` can be replaced by `WithHttpsEndpoint` and `WithHttpEndpoint`
    to declare, respectively, HTTPS-only and HTTP-only endpoints.'
  prefs: []
  type: TYPE_NORMAL
- en: The `WithExternalHttpEndpoints()` fluent interface method declares that the
    microservice endpoint must be available outside of the application for application
    clients. These endpoints will be exposed with `Ingress` or `LoadBalancer` services
    when publishing the application on Kubernetes and with external ingresses when
    publishing the application on Azure Container Apps.
  prefs: []
  type: TYPE_NORMAL
- en: Resources used by microservices can be declared and configured with the same
    fluent interface. Each resource type requires a dedicated NuGet package that provides
    the needed extension methods to the fluent interface. All these extension methods
    are built on the `builder.AddContainer` method since they use Docker images to
    implement the resources. Therefore, if a resource we need is not yet available,
    we can write the needed extension methods ourselves. However, as already mentioned,
    there are resources for all the main databases, Redis, all the main message brokers,
    and most Azure services. Some Azure resource configurators provision and use actual
    Azure resources, while others use local simulators. There are simulators for Azure
    Storage and Azure Service Bus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the official documentation for a list of all available resource integrations:
    [https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/integrations-overview](https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/integrations-overview).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a default, when the App Host is shut down, all database data is lost since
    all Docker images use temporary storage. However, we can use the `WithDataVolume()`
    fluent interface method to force the usage of permanent Docker volume storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When this method is called, a Docker volume with an auto-generated name is
    created. For more control over the volume name and the directory inside the container
    where it is mounted, you can use `WithBindMount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Most resources use a default username, such as `sa`, and an auto-generated password.
    Both credentials are available through the resources information link of the App
    Host browser console. However, if data is not persisted with a volume, this password
    may change at each run.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, all resources provide the possibility to specify some parameters, and
    `username` and `password` are always among them.
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, parameters are not inserted directly in the code, for obvious
    reasons. They are taken from the `"Parameter"` section of the App Host configuration.
    Therefore, they can be inserted in the App Host configuration file, so we can
    also provide a different value for each environment by using the usual .NET environment-based
    configuration file override.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is the definition of a parameter object with the name of the
    `"Parameters"` property that contains the actual value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: By setting `secret` to `true`, we enable the generation of a hint to store the
    parameter in a safe place when we run Aspire in publishing mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the parameter is placed in the right place of the resource extension
    method, which is resource-specific:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual value must be placed in the App Host project configuration file,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The next subsection describes how to integrate Azure Functions projects in .NET
    Aspire solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of writing this book, the integration of Azure Functions projects
    in .NET Aspire solutions is in preview. However, we will describe it briefly since
    it offers great opportunities.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, only Azure Functions with the following triggers are supported:
    Azure Event Hubs, Azure Service Bus, Azure Blob storage, Azure Queue storage,
    Azure CosmosDB, HTTP, and Timer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to configure an Azure Functions project, the App Host must reference
    the `Aspire.Hosting.Azure.Functions` NuGet package. Once this reference has been
    added, an Azure Functions project can be configured, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `AddAzureFunctionsProject` call can be chained with the usual configuration
    methods of all other project types, such as `WithExternalHttpEndpoints()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once defined in this way, `myFunction` can be referred to by other projects
    with the usual methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A local emulator of an Azure storage account may be added as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The emulator relies on the `Aspire.Hosting.Azure.Storage` NuGet package, which
    must be added to the App Host project.
  prefs: []
  type: TYPE_NORMAL
- en: 'References to other Azure resources can be added with `WithReference`, as usual.
    For instance, an Azure function with a Blob storage trigger on an emulated blob
    may be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This concludes our .NET Aspire description. In the next section, we will see
    how to translate the Kubernetes example of [*Chapter 8*](Chapter_8.xhtml#_idTextAnchor205),
    *Practical Microservices Organization with Kubernetes*, to run with Aspire. Finally,
    the *Deploying a .NET Aspire project* section will discuss how to use Aspire to
    generate the code for our target orchestrators, either manually or with automatic
    code generator tools.
  prefs: []
  type: TYPE_NORMAL
- en: Using .NET Aspire in practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will adapt the Kubernetes example of [*Chapter 8*](Chapter_8.xhtml#_idTextAnchor205),
    *Practical Microservices Organization with Kubernetes*, to run with Aspire. As
    a first step, let’s copy the whole solution folder into another in a different
    location, so we can modify it without destroying the previous version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let’s execute the following steps to prepare the overall solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new App Host project to the solution and call it `CarSharingAppHost`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new .NET Aspire Service Defaults project to the solution and call it `CarSharingServiceDefaults`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a reference to the `FakeSource`, `FakeDestination`, and `RoutesPlanning`
    projects to the `CarSharingAppHost` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a reference to the `CarSharingServiceDefaults` project to the `FakeSource`,
    `FakeDestination`, and `RoutesPlanning` projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `CarSharingAppHost` project and, in the menu that appears,
    select **Set as Startup Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The preceding steps prepare the solution for .NET Aspire. Now, let’s start
    modifying the code. As a first step, we must add service defaults to all the microservices.
    Therefore, let’s add `builder.AddServiceDefaults();` to the `program.cs` file
    of the `FakeSource`, `FakeDestination`, and `RoutesPlanning` projects. Then, we
    must add `app.MapDefaultEndpoints()`, which adds health endpoints just to the
    `program.cs` file of the `RoutesPlanning` project, since it is the only web project
    that we have among our microservices. It must be placed as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s remember that we added all the microservices parameters as environment
    variables in their `Properties/launcheSettings.json` file. We placed them in the
    Docker launch settings. Now, since these projects will not use Docker anymore
    while running in Aspire, we must copy all these definitions into the other launch
    setting profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the launch settings code of the `RoutesPlanning` project after this
    change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We replaced `host.docker.internal` with `localhost` in all connection strings
    as, when running in Aspire, our microservices will not access the SQL database
    and the RabbitMQ message broker from inside a Docker container image but directly
    from the development machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the launch settings of `FakeSource` become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the launch settings of `FakeDestination` become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The content of both the RabbitMQ and SQL Server connection strings shows that
    we decided to use pre-existing RabbitMQ and SQL instances that run outside of
    Aspire. This was the simplest choice for this solution since the whole code was
    already organized to run this way. However, it is often the best choice when we
    start a solution from scratch since instances that live when the App Host is not
    running are simpler to handle during development.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we can pass database migrations to the database with no need to launch
    the App Host while we are working with migrations. Similarly, we can inspect RabbitMQ
    from its browser console when the App Host is not running.
  prefs: []
  type: TYPE_NORMAL
- en: Another alternative would be to split the whole App Host configuration code
    into two code zones. The first code zone contains databases and message brokers
    that we need to manipulate when the application is not running, and the second
    code zone contains all other resources and microservices configuration.
  prefs: []
  type: TYPE_NORMAL
- en: When we need to manipulate the resources defined in the first code zone, we
    comment out the whole second zone code and run the App Host. After finishing working
    with migrations and inspecting the RabbitMQ queue, we uncomment the second code
    zone that defines and configures all other resources and microservices, and run
    the whole application.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding methodology can be refined by defining a Boolean App Host environment
    variable that selects the second configuration zone with an `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: After this premise, we can write our configuration code in the App Host `program.cs`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Since, in our case, each microservice has multiple launch settings profiles,
    we must specify the right profile to use with each microservice in the `AddProject`
    fluent interface method.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, since `FakeSource` sends data to the `RoutesPlanning` microservice,
    and the `RoutesPlanning` microservice sends data to the `FakeDestination` service,
    we must ensure that `RoutesPlanning` starts after `FakeDestination` has been started
    and `FakeSource` starts only after `RoutesPlanning` has started. We don’t need
    `WithReference` since not all microservices communicate directly, but rather,
    communicate through a RabbitMQ instance, and `WithReference` is only needed to
    inject information for communicating directly with a resource. We don’t need to
    declare a reference to RabbitMQ either, since we are using an external RabbitMQ
    instance that runs outside of the App Host, so we already have its connection
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easy to fulfill all constraints with the following configuration code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, the second argument of each `AddProject` call is the name of the launch
    profile to use for each microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s ensure that both the RabbitMQ and SQL Server external Docker containers
    are running, and then launch our solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything is working properly, you should see something like the following
    figure in the Aspire browser console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: App Host resources list](img/B31916_12_2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: App Host resources list'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s click the **Console** icon in the left menu to inspect all microservice
    logs. Let’s choose **fakedestination**; you should see something like the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: The fakedestination console](img/B31916_12_3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: The fakedestination console'
  prefs: []
  type: TYPE_NORMAL
- en: Logs should contain information about the connection with RabbitMQ through EasyNetQ
    and about the worker service start. Finally, you should see two messages coming
    from the `RoutesPlanning` microservice that declare that two matches have been
    found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since all Microservices use the same RabbitMQ connection string, we can improve
    the whole code organization by removing it from each microservice’s launch settings
    and factoring it out into the App Host configuration with the help of `AddConnectionString`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `RabbitMQParameterNam`e is the name of the App Host configuration parameter
    that contains the actual connection string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the next subsection, we will describe how to modify the code to run RabbitMQ
    inside the App Host.
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RabbitMQ is supported by Aspire integration so we can run it also inside the
    App Host. The first step for doing this is the addition of the `Aspire.Hosting.RabbitMQ`
    NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to configure the RabbitMQ instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we added a volume to persist data after the App Host is shut down and
    required the installation of the browser management console, so we can inspect
    all queues and can also configure the instance. The actual username and password
    must be provided in the `"Parameters"` section of the App Host configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: After that, we must declare a reference to this RabbitMQ instance in all microservices
    with `WithReference(rabbitmq)`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we need to remove the RabbitMQ connection strings from all the
    launch settings of our microservices since the same connection string will now
    be injected by the App Host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the injected connection string is not in the format needed by
    EasyNetQ but has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The simplest way to solve this problem is to write a string manipulation method
    that converts this string and adds all other auxiliary information. We can define
    this method in the Service Defaults project so it will be available to all microservices.
  prefs: []
  type: TYPE_NORMAL
- en: We need just to extract the URL, username, and password and then we may use
    them to build the connection string in the format needed by EasyNetQ. This can
    be done by splitting the string on `//`, then on `@`, and finally, on `:` to get
    username and password.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, we will describe how to get the configuration needed by
    our target orchestrator for an Aspire project.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a .NET Aspire project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET Aspire can be used to test an application or a small part of a complex
    microservice application on the development machine, thus replacing minikube and
    Docker networks.
  prefs: []
  type: TYPE_NORMAL
- en: However, small applications can be completely implemented in Aspire and then
    the Aspire code can be used to generate the configuration of the target orchestrator.
    This generation can be manual or based on automatic tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both manual generation and automatic tools rely on a JSON manifest that can
    be created automatically and that describes the application configuration. The
    JSON manifest can be generated by adding the following launch profile to the App
    Host project’s `launchSettings.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Once added to `launchSettings.json`, this profile appears in the Visual Studio
    profile selection combo next to the **Run** button. It is enough to select the
    `"generate-manifest"` profile and run the solution. When the solution runs, the
    application is compiled but, instead of running, it creates the JSON manifest
    in the App Host project folder.
  prefs: []
  type: TYPE_NORMAL
- en: You can manually read this manifest and use the information it contains to configure
    your orchestrator, or you can use automatic tools that generate the manifest and
    use it to automatically configure an orchestrator.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio natively supports the deployment of Azure Container Apps. Publishing
    to Azure Container Apps is straightforward. It is enough to right-click on the
    solution’s App Host project and select **Publish**. After that, you can select
    the Azure Container Apps publish target. The procedure will drive you to connect
    to your Azure subscription and provide all the information needed to publish the
    application,
  prefs: []
  type: TYPE_NORMAL
- en: The **Publish** wizard will publish all microservices as Azure Container Apps
    applications and will provision all other resources defined in the App Host in
    Azure, such as databases and other Azure resources.
  prefs: []
  type: TYPE_NORMAL
- en: An external tool called Aspir8 ([https://prom3theu5.github.io/aspirational-manifests/getting-started.html](https://prom3theu5.github.io/aspirational-manifests/getting-started.html))
    is also available, which is capable of deploying the application on a Kubernetes
    cluster. However, in this case, it will create just Kubernetes Deployments and
    Services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, Aspir8 supports the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aspirate init`: Initializes the Aspir8 project in the current directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aspirate generate`: Generates Kubernetes manifests based on the .NET Aspire
    app host manifest'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aspirate apply`: Applies the generated Kubernetes manifests to the Kubernetes
    cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aspirate destroy`: Deletes the resources created by the `apply` command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a simple application, you can deploy directly on a Kubernetes cluster, and
    in the case of more complex applications, you can use the Kubernetes manifest
    as a starting point for designing the needed Kubernetes configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `apply` and `destroy` commands need a `kubectl` installation, and all operations
    are performed using the current `kubectl` context. Please refer to the *Interacting
    with Kubernetes: kubectl, minikube, and AKS* section of[*Chapter 8*](Chapter_8.xhtml#_idTextAnchor205),
    *Practical Microservices Organization with Kubernetes*, for a definition of the
    `kubectl` context.'
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to manually inspect the manifest generated by the App Host,
    please refer to its official format documentation at [https://learn.microsoft.com/en-us/dotnet/aspire/deployment/manifest-format](https://learn.microsoft.com/en-us/dotnet/aspire/deployment/manifest-format).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we described the opportunities and services offered by .NET
    Aspire. We discussed how to configure a complex application made of microservices
    and other resources in the App Host project, and discussed in detail how service
    discovery works both in general and specifically with .NET Aspire.
  prefs: []
  type: TYPE_NORMAL
- en: We described how environment variables containing all the information needed
    for the interaction between microservices and resources are automatically injected
    into all microservices by the App Host.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed how Aspire implements observability with the help of telemetry,
    and how App Host configuration can be used to generate automatic configuration
    for the target orchestrators.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concludes our amazing journey among the concepts and technologies
    of modern distributed computing. We hope that you enjoyed reading this book as
    much as we enjoyed writing it.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the Aspire-specific .NET SDK projects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: .NET Aspire Starter Project, .NET Aspire Empty Project, .NET Aspire App Host,
    .NET Aspire Service Defaults, .and various NET Aspire Test projects.
  prefs: []
  type: TYPE_NORMAL
- en: Is service discovery an Aspire-specific feature?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, it is a general .NET feature.
  prefs: []
  type: TYPE_NORMAL
- en: How many service discovery providers come with the Aspire default settings?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just two.
  prefs: []
  type: TYPE_NORMAL
- en: What is the best way to handle pre-existing resources that are not defined with
    the App Host but are shared by several microservices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The usage of `AddConnectionString`.
  prefs: []
  type: TYPE_NORMAL
- en: Does Aspir8 provision Azure resources, too?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, at moment it provisions just Kubernetes resources.
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of the `WithReference` fluent interface method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declaring that a resource depends on another resource, meaning it needs information
    such as, URLs, and connection string, of that resource.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Official Aspire documentation: [https://learn.microsoft.com/en-us/dotnet/aspire/get-started/aspire-overview](https://learn.microsoft.com/en-us/dotnet/aspire/get-started/aspire-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All available Aspire integrations: [https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/integrations-overview](https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/integrations-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'App Host configuration manifest format: [https://learn.microsoft.com/en-us/dotnet/aspire/deployment/manifest-format](https://learn.microsoft.com/en-us/dotnet/aspire/deployment/manifest-format
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Aspir8: [https://prom3theu5.github.io/aspirational-manifests/getting-started.html](https://prom3theu5.github.io/aspirational-manifests/getting-started.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/PSMCSharp](https://packt.link/PSMCSharp)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/B31916_Discord-QR-Code.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Packt_Logo_New.png)'
  prefs: []
  type: TYPE_IMG
- en: '[packtpub.com](http://packtpub.com)'
  prefs: []
  type: TYPE_NORMAL
- en: Subscribe to our online digital library for full access to over 7,000 books
    and videos, as well as industry leading tools to help you plan your personal development
    and advance your career. For more information, please visit our website.
  prefs: []
  type: TYPE_NORMAL
- en: Why subscribe?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spend less time learning and more time coding with practical eBooks and Videos
    from over 4,000 industry professionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve your learning with Skill Plans built especially for you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a free eBook or video every month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fully searchable for easy access to vital information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy and paste, print, and bookmark content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At [www.packtpub.com](http://www.packtpub.com), you can also read a collection
    of free technical articles, sign up for a range of free newsletters, and receive
    exclusive discounts and offers on Packt books and eBooks.
  prefs: []
  type: TYPE_NORMAL
- en: Other Books You May Enjoy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you enjoyed this book, you may be interested in these other books by Packt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/9781835881231.jpg)](https://www.packtpub.com/en-in/product/c-13-and-net-9-modern-cross-platform-development-fundamentals-9781835881231)'
  prefs: []
  type: TYPE_NORMAL
- en: '**C# 13 and .NET 9 – Modern Cross-Platform Development Fundamentals**'
  prefs: []
  type: TYPE_NORMAL
- en: Mark J. Price
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 978-1-83588-123-1'
  prefs: []
  type: TYPE_NORMAL
- en: Discover the new features of .NET 9, including more flexible params and new
    LINQ like CountBy and Index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leverage the new ASP.NET Core 9 features for optimized static assets, OpenAPI
    document generation, and HybridCache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize the native AOT publish capability for faster startup and reduced memory
    footprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build rich web user interface experiences using Blazor in ASP.NET Core 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate and update databases in your applications using Entity Framework Core
    9 models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query and manipulate data using LINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build powerful services using Minimal APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[![](img/9781805122456.jpg)](https://www.packtpub.com/en-in/product/software-architecture-with-c-12-and-net-8-9781805122456)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Software Architecture with C# 12 and .NET 8**'
  prefs: []
  type: TYPE_NORMAL
- en: Gabriel Baptista, Francesco Abbruzzese
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 978-1-80512-245-6'
  prefs: []
  type: TYPE_NORMAL
- en: Program and maintain Azure DevOps and explore GitHub Projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage software requirements to design functional and non-functional needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply architectural approaches such as layered architecture and domain-driven
    design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make effective choices between cloud-based and data storage solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement resilient frontend microservices, worker microservices, and distributed
    transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand when to use test-driven development (TDD) and alternative approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose the best option for cloud development, from IaaS to Serverless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packt is searching for authors like you
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re interested in becoming an author for Packt, please visit [authors.packtpub.com](http://authors.packtpub.com)
    and apply today. We have worked with thousands of developers and tech professionals,
    just like you, to help them share their insight with the global tech community.
    You can make a general application, apply for a specific hot topic that we are
    recruiting an author for, or submit your own idea.
  prefs: []
  type: TYPE_NORMAL
- en: Share your thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you’ve read *Practical Serverless and Microservices with C#*, we’d love
    to hear your thoughts! Please [click here to go straight to the Amazon review
    page](https://packt.link/r/1836642016) for this book and share your feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Your review is important to us and the tech community and will help us make
    sure we’re delivering excellent quality content.
  prefs: []
  type: TYPE_NORMAL
