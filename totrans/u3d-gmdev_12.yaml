- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Finishing Touches
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完美细节
- en: Welcome to the *Finishing Touches* chapter! There is a misconception about how
    long games take to make and the overall difficulty of game development. This chapter
    will act as a toolbox to guide you in finishing your projects. This isn’t a straightforward
    next step, but rather an open box for you to see what we’re using to polish up
    our vertical slice. An interesting feature of the polishing process is that it
    covers a good 80% of game development. This might sound unintuitive; however,
    if you’ve been paying attention to the screenshots during the development, you
    will have noticed that we don’t have a complete game by any stretch of the imagination
    at this point from a consumer’s point of view. The mechanics work and the game
    is an experience by now, just not a complete one.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到**完美细节**章节！关于游戏制作所需时间和游戏开发的总体难度有一个误解。本章将作为一个工具箱，指导你完成你的项目。这不是一个直接的下一步，而是一个开放的盒子，让你看到我们用来打磨我们的垂直切片的东西。打磨过程的有趣之处在于，它涵盖了游戏开发的80%左右。这听起来可能不太直观；然而，如果你在开发过程中一直关注截图，你将注意到，从消费者的角度来看，我们在这个阶段根本不可能有一个完整的游戏。机制是有效的，游戏现在是一个体验，只是还不完整。
- en: 'This chapter will go over:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Overview
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述
- en: Asset finalization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资产最终化
- en: Lighting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灯光
- en: Sound polish
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音打磨
- en: Overview
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Finishing touches are extremely important to a complete experience. We need
    to take what we have and tighten up all the stitches. This is done in several
    ways.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完美细节对于完整的体验至关重要。我们需要把现有的东西都整理好，把所有的针脚都缝紧。这可以通过几种方式来完成。
- en: Lighting and sound are very difficult to finalize prior to this point. There
    can be **research and development** (**R&D**), but unless the game’s focus is
    one of those two topics, you won’t be getting finalized lighting or sound until
    there are finalized assets in the game, as seen in the list in the following section.
    You’re correct in wondering why we had a chapter on sound before this. We wanted
    to go over the basics of sound in general and get you familiar with the concept
    of sound design and its implementation within Unity.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，灯光和声音的最终确定非常困难。可能会有**研究和开发**（**R&D**），但除非游戏的重点是这两个主题之一，否则你不会在游戏中获得最终的灯光或声音，正如以下章节列表中所见。你正确地想知道为什么我们在之前有一章关于声音。我们想概述声音的基本知识，并让你熟悉声音设计和在Unity中的实现概念。
- en: Lighting could be worked on early to set a mood but will need to be finalized
    after environments and light pools are well defined and firm in place. Again,
    if lighting and mood are going to be in the experience, then heavy lighting R&D
    will need to take place even in the blocking-in stages of development. All the
    conversations here about lighting will guide you during that stage too if it’s
    needed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 灯光可以提前工作以设定氛围，但需要在环境和灯光池定义良好并固定后才能最终确定。再次强调，如果灯光和氛围将体现在体验中，那么在开发阶段的初步阶段就需要进行大量的灯光研究和开发。这里关于灯光的所有对话也将在这个阶段为你提供指导，如果需要的话。
- en: The way this will work is that there will be specific actions that we will cover
    in all three of the major sections in this chapter. These actions are specific
    to our project but could help you with your future projects all the same. Think
    of them as tools instead of a tutorial. Some of them may need programming, and
    some of them may not.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是这样工作的：我们将在本章的三个主要部分中涵盖特定的动作。这些动作特定于我们的项目，但同样可以帮助你未来的项目。把它们看作是工具而不是教程。其中一些可能需要编程，而另一些可能不需要。
- en: As most of the mechanics have been programmed to a certain degree, we will focus
    first on asset finalization. Remember, as we said, it’s hard to get lighting and
    sound if the assets aren’t done. Let’s start there!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数机制已经编程到一定程度，我们首先将关注资产最终化。记住，正如我们所说，如果资产没有完成，那么灯光和声音就很难得到。让我们从这里开始吧！
- en: Asset finalization
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资产最终化
- en: 'This section will be awesome. There are so many great art assets and finishing
    touches that we can go over. Here is a list of tools we used that may help you
    in your projects in the future:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将非常精彩。这里有如此多的优秀艺术资产和完美细节可以探讨。以下是我们在未来项目中可能帮助到你的工具列表：
- en: Stylized pass on assets
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资产上的风格化通道
- en: Detail normals
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 细节法线
- en: Architecture cleanup
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建筑清理
- en: Texture blending
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理混合
- en: Environment clutter
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境杂乱
- en: Detail meshes
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 细节网格
- en: Effects
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特效
- en: Cinematics
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画
- en: Secondary animation
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二级动画
- en: The way we will go through these sections is that we will have an explanation
    of why we will be doing this for our project, which may help you decide if you
    need to perform these polishing touches on your own projects in the future. After
    that, we will cover the literal steps that we took so that you can see how they
    are done. Interestingly, the actual steps we are taking may not be the only way
    to achieve these finishing touches. The best way to take these actions is as a
    concept or a starting point as the needs will be different for your project. We
    will begin our finishing touches with a stylized pass on our assets.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何浏览这些部分是，我们将解释为什么我们要为我们的项目做这件事，这可能会帮助你决定你是否需要在未来的项目中自己进行这些抛光处理。之后，我们将涵盖我们实际采取的步骤，以便你可以看到它们是如何完成的。有趣的是，我们实际采取的步骤可能不是实现这些最终修饰的唯一方法。采取这些行动的最佳方式是将它们作为一个概念或起点，因为你的项目需求可能会有所不同。我们将从对我们资产的风格化处理开始我们的最终修饰。
- en: Stylized pass on assets
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资产的风格化处理
- en: When defining an art style, we begin with broad strokes. Even if you take the
    time to outline the art direction, once you get to the polishing phase, you will
    need to make a pass on it to get the finishing touches in place. In our case,
    we found that our assets didn’t have enough of a stylized look to them to fit
    our art direction. The word stylized is used very often and it has the right to
    be used often for games as it means to just not look realistic. In our case, we
    want the stylizing to make everything feel more illustrative in nature. This means
    we need to push all our contrasting silhouettes and colors into the textures.
    We also need broader line weights in our textures.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义艺术风格时，我们首先从大笔触开始。即使你花时间概述艺术方向，一旦你进入抛光阶段，你将需要对其进行处理以放置最终修饰。在我们的案例中，我们发现我们的资产缺乏足够的风格化外观，以适应我们的艺术方向。风格化这个词经常被使用，并且它有权利经常被用于游戏，因为它意味着不仅仅是看起来不真实。在我们的案例中，我们希望风格化使一切感觉更具插图性质。这意味着我们需要将所有对比鲜明的轮廓和颜色推入纹理中。我们还需要在纹理中拥有更宽的线条粗细。
- en: A good example within our project is Myvari’s necklace. This art piece needs
    to stand out as it is the primary focus of Myvari’s telekinesis. We also know
    that we will be seeing it up close during cinematics, so we need to ensure that
    we put time into designing this piece.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，一个很好的例子是Myvari的项链。这件艺术品需要脱颖而出，因为它是Myvari心灵感应的主要焦点。我们也知道在电影中我们会近距离看到它，所以我们需要确保我们在这件作品上投入时间。
- en: '![A picture containing indoor, chair, desk, blue  Description automatically
    generated](img/B17304_12_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![包含室内、椅子、桌子、蓝色的图片  自动生成的描述](img/B17304_12_01.png)'
- en: 'Figure 12.1: Stylized passes for Myvari’s necklace'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：Myvari项链的风格化处理
- en: This needs to happen throughout all the art pieces to have as much consistency
    as possible within the character and the world. Once the stylized pass is completed,
    some models may need to have small details added. We call them “detail normals.”
    Let’s go over them now!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要在所有艺术作品中发生，以在角色和世界中尽可能保持一致性。一旦风格化处理完成，一些模型可能需要添加一些小细节。我们称它们为“细节法线”。现在让我们来了解一下它们！
- en: Detail normals
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 细节法线
- en: A detail normal can sometimes be considered part of the stylized pass. In our
    case, we wanted this to be a standout part of the art direction overall, so we
    pulled it out of the stylized pass. We want to drive home the stylized nature
    of the silhouettes in the models; however, we want to give the materials themselves
    a sense of realism. Leather will need to look like leather, and bark should look
    like bark. Below in *Figure 12.2*, we have a detail normal on the mushroom to
    give a bit of extra nuance to it. The left image has base normals and texture.
    The right image has detail normals layered on top.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，细节法线可以被认为是风格化处理的一部分。在我们的例子中，我们希望这成为整体艺术指导中的一个突出部分，所以我们将其从风格化处理中提取出来。我们希望强调模型轮廓的风格化特性；然而，我们希望材料本身有一种现实感。皮革需要看起来像皮革，树皮应该看起来像树皮。在下方的*图12.2*中，我们对蘑菇进行了细节法线处理，以给它增添一些额外的细微差别。左边的图像有基础法线和纹理。右边的图像在基础法线之上添加了细节法线。
- en: '![A picture containing coelenterate, blue, colorful, hydrozoan  Description
    automatically generated](img/B17304_12_02.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![包含水螅动物、蓝色、多彩、水母的图片  自动生成的描述](img/B17304_12_02.png)'
- en: 'Figure 12.2: Left, no detail normal; Right, detail normal added'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：左，无细节法线；右，添加了细节法线
- en: Detail textures are also interesting as they are generally smaller details from
    a tileable texture that won’t fit nicely on the texture itself due to the sizing
    of the model’s texture. To gain the small details, we layered them in the shader.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 细节纹理也很有趣，因为它们通常是来自可平铺纹理的较小细节，由于模型的纹理尺寸，它们不会很好地放在纹理本身上。为了获得小细节，我们在着色器中分层了它们。
- en: '![Graphical user interface  Description automatically generated](img/B17304_12_03.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面 自动生成描述](img/B17304_12_03.png)'
- en: 'Figure 12.3: Detail normals'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：细节法线
- en: Above is the shader we are using for our detail normal in *Figure 12.3*. The
    way we will break this down is by following the data connection points and explaining
    the reasoning per node. To start off, we begin with a UV node.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上图是我们用于*图12.3*中细节法线的着色器。我们将通过跟随数据连接点并逐节点解释推理来分解它。首先，我们从UV节点开始。
- en: '**UV node** – This node sets the UV space you will be manipulating. The dropdown
    allows you to choose which UV map to manipulate. Since we are using the main UV
    channel, we will keep it at `UV0`. We will take the output of the UV node and
    input it into a Swizzle node.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**UV节点** – 此节点设置你将操作的UV空间。下拉菜单允许你选择要操作的UV图。由于我们使用主UV通道，我们将它保持在`UV0`。我们将UV节点的输出输入到一个Swizzle节点。'
- en: '**Swizzle node** – The Swizzle node allows users to take an input and mix the
    channels to create an output with the data amount that is needed. You’ll notice
    that we have set `xy` as the output. Our input is a pin line, which refers to
    a `Vector4`, which is shown in the input of the Swizzle as well. We only need
    the red and green channels in this case, so we just request the `xy` or `rg` channel
    and we get a `Vector2` output green line. Unity’s `Shader Graph` already culls
    the rest of the channels, so we do not specifically need this, but it’s a good
    habit to only use the channels that you need to work with. We take this output
    into a Multiply node.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swizzle节点** – Swizzle节点允许用户取一个输入并混合通道以创建所需数据量的输出。你会注意到我们已将输出设置为`xy`。我们的输入是一个引脚线，它指的是一个`Vector4`，这也在Swizzle的输入中显示。在这种情况下，我们只需要红色和绿色通道，所以我们只请求`xy`或`rg`通道，我们得到一个输出绿色线的`Vector2`。Unity的`Shader
    Graph`已经裁剪了其余的通道，所以我们不需要特别这样做，但只使用你需要与之工作的通道是一个好习惯。我们将这个输出输入到一个乘法节点。'
- en: '**Multiply node** – We use a float parameter here for the customizability of
    the UVs down the line alongside the Swizzle input. The **Detail Normal Scale**
    parameter is exposed so we can make a change in the inspector later on, tweaking
    it to our needs. The output of this will go into the UV channel of a Sample Texture
    2D node.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**乘法节点** – 我们在这里使用一个浮点参数来提供UV的可定制性，以及Swizzle输入。`Detail Normal Scale`参数被公开，这样我们可以在检查器中稍后进行更改，调整以满足我们的需求。这个输出的结果将进入一个采样纹理2D节点的UV通道。'
- en: '**Sample Texture 2D node** – Another input to this node is our texture 2D parameter
    detail normal. We need to make sure that the **Space** option is set to **Tangent**
    as we will be affecting the tangents to reconstruct the normal later on. We will
    be taking the output and getting to a `Vector2` once again, but with a different
    method than Swizzle. We will be using a Combine node from the individual channels
    on the Sample Texture 2D node.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**采样纹理2D节点** – 此节点的另一个输入是我们的纹理2D参数细节法线。我们需要确保**空间**选项设置为**切线**，因为我们将在后面影响切线以重建法线。我们将输出取出来，再次得到一个`Vector2`，但使用的方法不同于Swizzle。我们将使用采样纹理2D节点上的单独通道的合并节点。'
- en: '**Combine node** – Taking in the R and G from the Sample Texture 2D node output,
    we combine it to make a `Vector2` that is sampling the texture we want and following
    the UVs we’re setting. Now we need to take this `Vector2` into a scale and bias
    it into a different range.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**合并节点** – 从采样纹理2D节点的输出中获取R和G，我们将它们合并以创建一个`Vector2`，它正在采样我们想要的纹理并遵循我们设置的UVs。现在我们需要将这个`Vector2`输入到一个缩放节点并对其进行偏置以进入不同的范围。'
- en: '**Scale and Bias nodes (using multiply and subtract)** – The next two nodes
    are a basic math function to transform the `(0 to 1)` range to a `(-1 to 1)` range.
    We do this by multiplying by 2 and then subtracting 1 on both the X and Y vectors.
    This is important to us as we may want the normal to appear as concave, or going
    into the model. After we finish this function, we will take the output into a
    Normal Reconstruct Z node.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**缩放和偏置节点（使用乘法和减法）** – 下两个节点是一个基本的数学函数，用于将`(0到1)`的范围转换为`(-1到1)`的范围。我们通过将2乘以并在X和Y向量上减去1来实现这一点。这对我们来说很重要，因为我们可能希望法线看起来是凹的，或者进入模型。在完成这个函数后，我们将输出输入到一个法线重建Z节点。'
- en: '**Normal Reconstruct Z node** – This node’s purpose is to derive the correct
    Z values for the input of R and G from the normal map we chose in the Sample Texture
    2D node.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**正常重建Z节点** – 这个节点的目的是从我们在样本纹理2D节点中选择的正常图中推导出R和G的正确Z值。'
- en: After this there are three more steps. We will be following individual figures
    for these next steps. We will take the output of this node and move it into a
    Normal Strength node.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 之后还有三个更多步骤。我们将遵循这些后续步骤的单独图。我们将把这个节点的输出移动到正常强度节点中。
- en: '**Normal Strength node –** Plugging into the Normal Strength node are the normals
    we had as an output from the Normal Reconstruct Z node. There is also a float
    value for which we created a parameter named **Detail Normal Strength**. This
    can be seen below in *Figure 12.4*. We’re using this node so that if the normal
    map seems like it might have too much detail or is not visually appealing, we
    can tone it down a little. The parameter we set in the **Strength** input allows
    us to dynamically set the Detail Normal Strength per material.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**正常强度节点** – 连接到正常强度节点的是我们从正常重建Z节点得到的法线。还有一个浮点值，我们为其创建了一个名为**详细法线强度**的参数。这可以在下面的*图12.4*中看到。我们使用这个节点是为了如果法线图看起来可能细节过多或者视觉上不吸引人，我们可以稍微降低一些。我们在**强度**输入中设置的参数允许我们动态地为每种材料设置详细法线强度。'
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B17304_12_04.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，自动生成描述，置信度中等](img/B17304_12_04.png)'
- en: 'Figure 12.4: Normal Strength node'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：正常强度节点
- en: We take the output of this and put it into a Normal Blend node.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个输出放入正常混合节点中。
- en: '**Normal Blend node –** We ultimately want these detail normals to be layered
    with the normal of the mesh itself. This is the node that we will be doing this
    with.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**正常混合节点** – 我们最终希望这些详细法线与网格本身的法线分层。这就是我们将要执行的节点。'
- en: '![Graphical user interface  Description automatically generated](img/B17304_12_05.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，自动生成描述](img/B17304_12_05.png)'
- en: 'Figure 12.5: Normal Blend node'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：正常混合节点
- en: It will output a normal map with both normals inside the data. We will then
    place the output into a Boolean keyword parameter, which we named `Detail Normal?`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它将输出一个包含数据内部法线的正常图。然后我们将输出放入布尔关键字参数中，我们将其命名为“详细法线？”。
- en: '**Boolean keyword** – This Boolean keyword is designed in a way to allow us
    to either use a detail normal or not. Since this shader is being used across many
    materials, we need a way to exclude a detail normal from being needed if a mesh
    may not have one. We’ve done this by having the input for `On` be the blended
    normals of the mesh and the detail normal. If it’s set to `Off` then just the
    mesh normal will be accepted.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**布尔关键字** – 这个布尔关键字设计成允许我们选择是否使用详细法线。由于这个着色器被用于许多材质中，我们需要一种方法来排除如果网格可能没有详细法线时不需要的情况。我们通过将“开启”的输入设置为网格的混合法线和详细法线来实现这一点。如果设置为“关闭”，则只接受网格法线。'
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_12_06.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，自动生成描述](img/B17304_12_06.png)'
- en: 'Figure 12.6: Detail normal Boolean keyword'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：详细法线布尔关键字
- en: The output of this will then go into the **Master Stack Normal** input. When
    you create a material, if you want to have a detail normal, all you need to do
    is select `On` with the checkbox of the `Detail Normal?` parameter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出将随后进入**主堆栈正常**输入。当你创建一个材质时，如果你想有一个详细法线，你只需要通过“详细法线？”参数的复选框选择“开启”。
- en: Next, we will work through cleaning up the architecture.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将清理架构。
- en: Architecture cleanup
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建筑清理
- en: The silhouettes of the current buildings may look good, but does the architecture
    make sense? This is an interesting design issue with building shapes. We need
    to ensure that the architecture looks like something that might be built by a
    living creature. This is a difficult task to get right as the creatures we’re
    looking to emulate don’t exist! They are fictional creatures, which means we need
    to be very clear on the path we take when architecting for them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当前建筑的轮廓可能看起来不错，但建筑本身是否合理？这是一个关于建筑形状的有趣设计问题。我们需要确保建筑看起来像是可能由一个活物建造的。这是一个很难做对的任务，因为我们试图模仿的生物并不存在！它们是虚构的生物，这意味着我们在为它们进行建筑规划时需要非常清楚我们所走的路径。
- en: We know that they are focused on celestial bodies and time concepts. The shapes
    of space, planets, and the concept of time need to take part in the silhouettes
    of the buildings and materials. This may not mean an entire remodel of the pieces
    but more pushing the shapes so the language stands out enough to fit the culture
    we’re designing for.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道它们专注于天体和时间概念。空间、行星的形状和时间的概念需要参与到建筑的轮廓和材质中。这可能并不意味着对部件进行彻底的改造，而是更多地推动形状，使语言足够突出，以适应我们正在设计的文化。
- en: We also need to get rid of some geometry that won’t ever be seen. This is in
    order to optimize the game and is important. In games, if you cannot see it, then
    it doesn’t need to render. Therefore, we do something called **backface culling**.
    This means that if you were to look at the back half of a sphere from the inside
    it would be invisible.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要去除一些永远不会被看到的几何形状。这是为了优化游戏，并且非常重要。在游戏中，如果你看不到它，那么它就不需要渲染。因此，我们做了一些称为**背面裁剪**的事情。这意味着如果你从内部看球体的背面，它将是不可见的。
- en: The backside of an object isn’t rendered as it’s not seen. If you didn’t do
    that then the sphere would have to render all the inside faces, which would be
    a waste of precious computer time; we need to render everything else.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 物体的背面不会被渲染，因为它看不见。如果你不这样做，球体将不得不渲染所有内部面，这将浪费宝贵的计算机时间；我们需要渲染其他所有东西。
- en: Texture blending
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纹理混合
- en: When building terrain or larger objects that need to connect, there is always
    a bit of a line that shows that the objects are 3D meshes. This is a common problem,
    and it can hurt immersion or break the experience if not worked with closely.
    There are several ways to make this better. You may add another mesh on top of
    the split. You could also layer or overlap the meshes to make a break in the model
    to let the player think that it was meant to be slightly broken. You could also
    perform something called **texture blending**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建地形或需要连接的大物体时，总会有一些线条显示物体是3D网格。这是一个常见问题，如果不密切处理，可能会损害沉浸感或破坏体验。有几种方法可以使这个问题变得更好。你可以在分裂的上方添加另一个网格。你也可以层叠或重叠网格，在模型中制造一个断裂，让玩家认为它是故意稍微破损的。你也可以执行一种称为**纹理混合**的操作。
- en: One way that we have done this is through Y-up materials. They may have other
    names as well, but I call them that due to using the Y-up axis to blend in materials.
    What we do is ask the shader to blend in positive Y of the world normal values.
    We use this value at the Lerp value in our shader where the base texture is on
    the A channel and B is the moss or snow texture. Let’s look at *Figures 12.7*
    through *12.9* below for screenshots of the Shadergraph imagery. In *Figure 12.7*,
    we’re showing some rocks that have a single UV set with a rock texture. These
    rocks are exactly the same except we’ve duplicated them and rotated them to show
    the shader that we put together that places the texture on the world normals.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现这一点的其中一种方式是通过Y-up材质。它们可能也有其他名称，但我之所以这样称呼它们，是因为它们使用Y-up轴来混合材质。我们所做的是要求着色器混合世界法线值的正Y。我们在着色器中使用这个值，其中基础纹理位于A通道，B是苔藓或雪纹理。让我们看一下下面的*图12.7*至*12.9*，以查看Shadergraph图像的截图。在*图12.7*中，我们展示了带有单个UV集和岩石纹理的一些岩石。这些岩石完全相同，除了我们复制了它们并将它们旋转以展示我们组合的着色器，该着色器将纹理放置在世界法线上。
- en: '![A picture containing indoor  Description automatically generated](img/B17304_12_07.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![包含室内图片的描述自动生成](img/B17304_12_07.png)'
- en: 'Figure 12.7: Rocks with our Y-up shader applied'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：应用了我们的Y-up着色器的岩石
- en: The textures applied to this aren’t final moss textures, but they are designed
    to be contrasted to the rock to show the textures separately. This allows us to
    work through the differences easily with visuals. You’ll notice that the rocks
    are the same, but scaled and rotated. This is a strong way to provide reuse within
    your meshes in your scene so you don’t have to model so many rocks! Let’s look
    at the `Shadergraph` on how this works next.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 应用到这些上的纹理不是最终的苔藓纹理，但它们被设计成与岩石形成对比，以分别显示纹理。这使得我们能够通过视觉轻松地处理这些差异。你会注意到岩石是相同的，但已缩放和旋转。这是在场景中的网格中提供重用的一种强有力的方式，这样你就不必建模那么多岩石！接下来让我们看看`Shadergraph`是如何实现这一点的。
- en: '![Graphical user interface  Description automatically generated](img/B17304_12_08.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面描述自动生成](img/B17304_12_08.png)'
- en: 'Figure 12.8: World normal Y-up for T value of Lerp'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：Lerp的T值的世界正常Y-up
- en: We need to plan out how we will split the rendering of the texture on the mesh.
    The interesting thing is that we need to make the texture always appear on the
    top of the mesh regardless of how it’s rotated. We decided to take the normal
    vector of the world space and then multiply it by a `Vector3` that we named `Offset`.
    We want the positive Y, so the default value of our `Offset` parameter will be
    `(0, 1, 0)`. We have two more blending parameters. They are `Blend` and `Level`
    and they are both floats. The **Blend** parameter is a hard value from 0 to 1\.
    With 0 there is no blending and the rock is the only texture, and with 1 there
    is no blending where the other texture has a hard line. This is complemented with
    the `Level` parameter. The `Level` parameter should be set to **Slider** with
    the min value set to 0 and the max to 100, and the **Default** set to 1; these
    can be set in the **Node Settings** in the **Graph Inspector**. We added it in
    this shader to show that you can add more tools for your artists per material.
    At the end of this line of data is a saturate.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要规划如何在网格上分割纹理的渲染。有趣的是，我们需要确保纹理无论如何旋转都能始终出现在网格的顶部。我们决定使用世界空间的法线向量，然后乘以一个我们命名为`Offset`的`Vector3`。我们想要正Y，所以`Offset`参数的默认值将是`(0,
    1, 0)`。我们还有两个额外的混合参数。它们是`Blend`和`Level`，它们都是浮点数。`Blend`参数是一个从0到1的硬值。当值为0时，没有混合，岩石是唯一的纹理；当值为1时，没有混合，其他纹理有一个硬的线条。这与`Level`参数相辅相成。`Level`参数应该设置为**滑动条**，最小值设置为0，最大值设置为100，默认值设置为1；这些可以在**图检视器**的**节点设置**中设置。我们添加它在这个着色器中是为了展示你可以为你的艺术家添加更多工具。在这行数据的末尾是一个饱和度。
- en: This ensures that the data sticks to the 0-1 range, which is what we need to
    be the T value of the Lerp, which we will go over next.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了数据保持在0-1的范围内，这是我们需要的Lerp的T值，我们将在下一部分讨论。
- en: '![Graphical user interface  Description automatically generated](img/B17304_12_09.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面 自动生成描述](img/B17304_12_09.png)'
- en: 'Figure 12.9: Texture lookups and Lerp'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：纹理查找和Lerp
- en: Above in *Figure 12.9* is our Lerp. Value is the base texture, and B is the
    Y-up texture. T is the output of our saturate in *Figure 12.8*. The output of
    the Lerp is going into our base color. This is only the beginning and you can
    bolster this by using normal maps and height maps to help mix the channels to
    make them even more seamless. We currently aren’t using extra maps in this shader,
    but the concept uses the exact same nodes, just with the additional maps as inputs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图*图12.9*所示，我们的Lerp。值是基础纹理，B是Y-up纹理。T是*图12.8*中饱和度的输出。Lerp的输出将进入我们的基础颜色。这只是开始，你可以通过使用法线贴图和高度贴图来帮助混合通道，使它们更加无缝。我们目前在这个着色器中不使用额外的贴图，但这个概念使用的是完全相同的节点，只是增加了作为输入的贴图。
- en: Environment clutter
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境杂乱
- en: This is a job all on its own. Those who work with environment clutter are known
    in the industry as clutter artists. Their job is to place items to make the environment
    feel lived in. Currently, we have an environment that is mechanically designed.
    We know where Myvari needs to be to trigger cinematics. We know how she will work
    with the physics puzzles. What we don’t know is how the people lived in this space
    previously.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项完全独立的工作。那些与环境杂乱工作的人在该行业中被称为杂乱艺术家。他们的工作是放置物品，使环境看起来有人居住。目前，我们有一个机械设计的环境。我们知道Myvari需要在哪里触发电影。我们知道她将如何与物理谜题合作。但我们不知道人们以前是如何在这个空间中生活的。
- en: What were these spaces used for before there were puzzles to open the doors?
    Should there be broken things around or did it all break down a long time ago?
    Should there be spiderwebs or plants growing over some pieces?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在有谜题可以打开门之前，这些空间是用来做什么的？周围应该有破碎的东西，或者是不是很久以前就都破碎了？应该有蜘蛛网或者植物覆盖在某个部分上吗？
- en: The clutter artists will have a set of small items to place around to make it
    feel like there was something going on here at one point in time. This is where
    we have an opportunity to tell small stories in every section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 杂乱艺术家将有一套小物品来放置，以营造出这里曾经发生过一些事情的感觉。这就是我们有机会在每个部分讲述小故事的地方。
- en: Detail meshes
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 细节网格
- en: Unity terrain can house detail meshes to place simple meshes, such as grass
    or small rocks. We explained this in *Chapter 5*, *Environment*, in the *Painting
    details* section briefly. The primary reason it’s in this chapter is to explain
    that there is more work to be done with the details. This is very similar to the
    clutter artist’s work; however, this isn’t specific to how the space was lived
    in but to develop the nature. In our case, we are using it for grass and rocks.
    We need to make sure that the grass and rocks are in a spot that makes sense.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Unity地形可以容纳细节网格，以放置简单的网格，例如草地或小石头。我们在*第5章*，*环境*，*绘制细节*部分中简要解释了这一点。这个章节的主要原因是要解释还有更多的工作要做在细节上。这与杂乱艺术家的工作非常相似；然而，这并不是特定于空间是如何被居住的，而是为了发展自然。在我们的案例中，我们正在使用它来处理草地和石头。我们需要确保草地和石头位于一个有意义的地点。
- en: This is primarily working through the finer details of cleaning up the scene
    in regard to the detail meshes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是通过清理场景的细节网格来工作的。
- en: Effects
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 效果
- en: Polishing effects are similar to polishing animations. They need to be finessed
    to ensure that it is stimulating the correct emotions of the viewer. Most of the
    effects in this vertical slice are meant to be ambient. We will be covering two
    effects. The first one will be the blocker to the stairs in the first portion
    of the cave. The second one will be Myvari’s telekinesis. We chose these two effects
    to cover in the book as they are quite unique from each other.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 抛光效果类似于抛光动画。它们需要经过精心调整以确保能够激发观众正确的情感。在这个垂直切片中的大多数效果都旨在营造氛围。我们将介绍两个效果。第一个将是洞穴第一部分楼梯的阻挡器。第二个将是Myvari的意念移物。我们选择这两个效果在书中进行介绍，因为它们彼此之间非常独特。
- en: Stair blocker
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 楼梯阻挡器
- en: The stair blocker is there to create an obstacle for the player in going up
    the stairs. They need to find a way to disable this so they can progress. We decided
    to go with arcane energy moving upward in front of the stairs. This will be done
    purely through a shader, which means we will cover some simple techniques in the
    Shader Graph.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 楼梯阻挡器是为了在玩家上楼梯时设置障碍。他们需要找到一种方法来禁用这个障碍，以便他们可以继续前进。我们决定使用在楼梯前方向上移动的神秘能量。这将完全通过着色器来完成，这意味着我们将介绍Shader
    Graph中的某些简单技术。
- en: The image shown here, in *Figure 12.10*, of the effect is static, so jump into
    the project and look at the first puzzle area in front of the stairs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的图像，*图12.10*中的效果是静态的，所以请进入项目并查看楼梯前面的第一个谜题区域。
- en: '![](img/B17304_12_10.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17304_12_10.png)'
- en: 'Figure 12.10: Stair blocking effect'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：楼梯阻挡效果
- en: This effect is made by utilizing a channel-packed texture with three unique
    cloud textures. The cloud textures are a grayscale perlin noise in Adobe Photoshop.
    We took each layer and placed it in the Red, Green, and Blue channels to have
    three textures in one image. This allows us to use multiple different clouds to
    build our own noise pattern when animating its UVs. To make this effect work,
    we needed a way to animate these UVs in multiple ways. We chose an A set and a
    B set, which we created in our parameters. Let’s go through all of our parameters
    to make sure we are on the same page. We will explain why we have each parameter
    as we grow out of this effect as seen in *Figure 12.11* below.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个效果是通过利用一个包含三个独特云纹理的通道打包纹理来制作的。云纹理是Adobe Photoshop中的灰度Perlin噪声。我们将每个图层放置在红色、绿色和蓝色通道中，以便在一个图像中拥有三个纹理。这使我们能够在动画其UVs时使用多个不同的云来构建我们自己的噪声模式。为了使这个效果工作，我们需要一种方法来以多种方式动画这些UVs。我们选择了一个A集和一个B集，我们在参数中创建了它们。让我们逐一介绍我们的所有参数，以确保我们处于同一页面上。随着我们从下面的*图12.11*中看到的效果逐渐展开，我们将解释为什么我们有每个参数。
- en: We have **Color**, which will be setting the overall color of the arcane magic.
    **Cloud Tex** will be the texture you can use for this shader. We then have **Offset**
    and **Tiling** with both an A and B version. We will cover the two parameters
    soon. Then we have two edges that are used for a Smoothstep node.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有**颜色**，这将设置神秘魔法的整体颜色。**云纹理**将是可用于此着色器的纹理。然后我们有**偏移**和**平铺**，两者都有A和B版本。我们很快就会介绍这两个参数。然后我们有两个用于Smoothstep节点的边缘。
- en: We need to first figure out how to make our texture animate. We will be using
    **Tiling**, **Offset**, and **Cloud Tex** to perform this initial section of the
    shader.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要弄清楚如何使我们的纹理动画化。我们将使用**平铺**、**偏移**和**云纹理**来执行这个着色器的初始部分。
- en: '![A screenshot of a phone  Description automatically generated with medium
    confidence](img/B17304_12_11.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![手机截图，描述由中等置信度自动生成](img/B17304_12_11.png)'
- en: 'Figure 12.11: StairShield parameters from Blackboard'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：来自Blackboard的StairShield参数
- en: Looking at *Figure 12.12* below, we’ve previously seen the Sample Texture 2D
    and **Multiply** nodes. Let’s go over the **Time** node. This node gives you access
    to the game time, the sin and cos of the game time, the delta time, and a smoothed
    delta. We will be using game time and multiplying it by a constant value for our
    speed. The next node that is new is the **Tiling And Offset** node. This node
    is a utility node to help deal with tiling and offsetting the UVs on a mesh that
    the material will be applied to. We assign the offset `Vector2` to the multiplication
    of time. This will provide a moving value for our offset. This will animate the
    UVs in the direction you want them to move.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下方的*图12.12*，我们之前已经看到了Sample Texture 2D和**Multiply**节点。现在让我们回顾一下**Time**节点。这个节点为您提供了游戏时间、游戏时间的正弦和余弦值、delta时间和平滑的delta值。我们将使用游戏时间并将其乘以一个常数值来获得我们的速度。下一个新的节点是**Tiling
    And Offset**节点。这个节点是一个实用节点，用于帮助处理将材质应用到网格上的UV的平铺和偏移。我们将`Vector2`偏移量分配给时间的乘积。这将为我们提供移动的偏移值。这将使UV按照您希望它们移动的方向进行动画。
- en: The last part is to plug the Tiling And Offset node into the UV input of the
    Sample Texture 2D node. You aren’t seeing the Offset and Tiling B set in this
    image as it’s the same nodes with different parameters. The reason we want to
    have multiple sets is that we want to have independent textures with different
    speeds and UV tiling scales. This makes a dynamic texture in the output.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是将Tiling And Offset节点连接到Sample Texture 2D节点的UV输入。您没有看到这张图中的偏移和Tiling B集，因为它们是具有不同参数的相同节点。我们想要多个集合的原因是我们想要有不同速度和UV平铺比例的独立纹理。这使得输出中的纹理具有动态效果。
- en: '![A screenshot of a video game  Description automatically generated](img/B17304_12_12.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![视频游戏截图  自动生成描述](img/B17304_12_12.png)'
- en: 'Figure 12.12: Offset and Tiling for our cloud texture'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12：云纹理的偏移和平铺
- en: We need to put together a seemingly never-ending tiling pattern. All of these
    noise patterns are tiling in both horizontal and vertical directions. Sometimes
    this is called a four-way tiling texture. We had planned to move Offset A up in
    the Y axis by a faster amount and then Offset B a bit slower. We would also tile
    the B set somewhere between .5 and .75\. This would give us a totally different
    set of noise to layer on top of the other.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要组合一个看似永无止境的平铺图案。所有这些噪声图案都在水平和垂直方向上平铺。有时这被称为四向平铺纹理。我们计划将偏移A在Y轴上以更快的速度移动，然后偏移B稍微慢一点。我们还会在0.5到0.75之间平铺B集。这将给我们提供一套完全不同的噪声，可以叠加在其他噪声之上。
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B17304_12_13.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  中度置信度自动生成描述](img/B17304_12_13.png)'
- en: 'Figure 12.13: Crossing the channels'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13：通道交叉
- en: In *Figure 12.13* above we are making three dynamic images to put together.
    Both Sample Texture 2D nodes have different tiling settings and different offsets
    moving in time. Putting them together with a multiply will inevitably create a
    living cloud structure as they cross paths. We’re doing that with all three channels
    `(R, G, B)`. Next, we will multiply each of these by 5 to force the entire image
    channels higher than their original. Then we add together the three channels into
    one output by adding the first two multiplied nodes, then adding the third one
    to that, as seen below in *Figure 12.14*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在上方的*图12.13*中，我们正在制作三个动态图像以组合在一起。两个Sample Texture 2D节点具有不同的平铺设置和随时间移动的不同偏移量。将它们通过乘法组合在一起，当它们交叉路径时不可避免地会形成一个活生生的云结构。我们用所有三个通道（R、G、B）来做这件事。接下来，我们将每个通道乘以5，以强制整个图像通道高于它们的原始值。然后，我们通过将前两个乘法节点相加，然后再加上第三个节点，将三个通道相加到一个输出中，如下面的*图12.14*所示。
- en: '![A screenshot of a video game  Description automatically generated](img/B17304_12_14.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![视频游戏截图  自动生成描述](img/B17304_12_14.png)'
- en: 'Figure 12.14: Multiply and Add'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14：乘法和加法
- en: Now that we have a single data stream with movement, we can push values to make
    a more interesting effect. We like to smoothstep data to push anything that is
    close to 0 to 0 and what is close to 1 to 1\. This makes the layered data make
    interesting shapes as seen in *Figure 12.15* below. The problem with this is the
    overall cloudiness is lost in that process, so we want to add in the previous
    **Add** and then saturate it to make sure it’s within the range 0-1 and then multiply
    it by a color parameter so we change the color in the inspector.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个带有运动的单个数据流，我们可以推送值来制作更有趣的效果。我们喜欢平滑步进数据，将接近0的任何东西推到0，将接近1的任何东西推到1。这使得分层数据在下面的*图12.15*中呈现出有趣的外形。这个问题是，在这个过程中，整体云层感丢失了，因此我们想要添加之前的**添加**，然后饱和它以确保它在0-1的范围内，然后乘以一个颜色参数，以便在检查器中更改颜色。
- en: '![A screenshot of a video game  Description automatically generated](img/B17304_12_15.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![视频游戏截图  描述自动生成](img/B17304_12_15.png)'
- en: 'Figure 12.15: Smoothstep and color'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15：平滑步进和颜色
- en: The output of the color node will go into the base color. We then make a material
    that uses the `SH_StairShield` shader, then apply it to a plane in the scene where
    we wanted to show there is something blocking the stairs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色节点的输出将进入基础颜色。然后我们制作一个使用`SH_StairShield`着色器的材质，并将其应用到场景中的一个平面上，我们想要展示那里有东西阻挡楼梯。
- en: Shuriken system – stair blocker particles layer
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 飞镖系统 – 楼梯阻挡粒子层
- en: We like the way the stair block feels, but the effects need layers to feel like
    well-made art. We also needed to spend a bit of time going over Shuriken itself.
    This effect will go over some basic portions of Shuriken for producing simple
    effects to layer into your world. What we will be creating is a stretched sprite
    moving upward to give more energy to the stair blocker.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢楼梯阻挡的感觉，但效果需要层次感才能显得像精心制作的艺术作品。我们还花了一些时间研究飞镖本身。这个效果将覆盖飞镖的一些基本部分，以产生简单的效果并将其分层到您的世界中。我们将创建一个向上拉伸的精灵，以给楼梯阻挡者更多的能量。
- en: To begin, we wanted to make something with a default item to show the power
    of particle systems. We are using the `ParticlesUnlit` material, which is a simple
    radial gradient from the center. We sometimes call these “math dots” as they can
    be created without a texture. We want to spawn particles that have a lot of energy
    upward but get slowed down near the end of their life and fade out. We will go
    through the settings below to make this happen; however, we encourage you to look
    in the project at the particle system and play with the settings. Make some changes
    to see if you can make something you feel looks better. Share it on Discord!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要制作一个带有默认物品的东西来展示粒子系统的强大功能。我们使用的是`ParticlesUnlit`材质，它是一个从中心开始的简单径向渐变。我们有时称这些为“数学点”，因为它们可以不使用纹理创建。我们想要生成具有大量向上能量的粒子，但在生命周期的末尾减速并逐渐消失。我们将通过下面的设置来实现这一点；然而，我们鼓励您查看项目中的粒子系统并调整设置。尝试一些更改，看看您是否能制作出您觉得看起来更好的效果。在Discord上分享它！
- en: The Shuriken system has a large number of parameters inside the modules. We
    will only be going over the ones we modified and needed to enable for this simple
    system. We implore you to look through the Unity documentation for an explanation
    of all the parameters and modules. Let’s look at the main module first, below
    in *Figure 12.16*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 飞镖系统在模块内部有大量的参数。我们只会讨论我们修改并需要启用以实现这个简单系统的参数。我们强烈建议您查阅Unity文档以了解所有参数和模块的解释。让我们首先看看主模块，如下面的*图12.16*所示。
- en: '![Graphical user interface  Description automatically generated with medium
    confidence](img/B17304_12_16.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  描述自动生成，中等置信度](img/B17304_12_16.png)'
- en: 'Figure 12.16: Shuriken main module'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16：飞镖主模块
- en: The only parameters we made changes to here were **Start Lifetime**, changing
    it to 1.4, and **Start Speed**, setting it to 0\. We made the lifetime change
    after making all of the other changes as we didn’t know exactly how long we wanted
    this particle system to live. The **Start Speed** we put to 0 because we knew
    we wanted to control the velocity. We also modified the color but we’ll override
    the color in the **Color Over Life** module later on. The next module we will
    go over is **Emission**.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们更改的唯一参数是**开始生命周期**，将其更改为1.4，以及**开始速度**，设置为0。我们在做出所有其他更改后更改生命周期，因为我们不知道这个粒子系统需要存活多长时间。我们将**开始速度**设置为0，因为我们知道我们想要控制速度。我们还修改了颜色，但稍后将在**颜色随生命周期变化**模块中覆盖颜色。接下来我们将讨论的是**发射**模块。
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17304_12_17.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成描述](img/B17304_12_17.png)'
- en: 'Figure 12.17: Emission module'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17：发射模块
- en: As seen above in *Figure 12.17*, this is the **Emission** module. We changed
    **Rate over Time** to 30 to make sure we have plenty of particles spawning. The
    emission of your particles is highly dependent on what you need to convey. For
    us, we wanted to have enough to add to the stair barrier shader, but not too much
    that we overpower it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图*图12.17*所示，这是**发射**模块。我们将**随时间变化率**设置为30，以确保有足够的粒子生成。你粒子的发射高度依赖于你需要传达的内容。对我们来说，我们希望有足够的粒子添加到楼梯屏障着色器中，但不要太多以至于压倒它。
- en: We now have a bunch of particles spawning, but we know we want it to be spawning
    near the bottom of the stair blocker. We will use the **Shape** module to restrict
    the spawning to a location that makes sense to the purpose of the effect.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一群粒子正在生成，但我们知道我们希望它们在楼梯阻挡器的底部附近生成。我们将使用**形状**模块来限制生成到对效果目的有意义的地点。
- en: '![Graphical user interface  Description automatically generated](img/B17304_12_18.png)![A
    screenshot of a video game  Description automatically generated](img/B17304_12_19.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成描述](img/B17304_12_18.png)![视频游戏截图  自动生成描述](img/B17304_12_19.png)'
- en: 'Figure 12.18: Shape module and shape placed in game'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18：形状模块和放置在游戏中的形状
- en: We chose the shape to be a box as we wanted the particles to spawn from the
    bottom of the stair blocker and move up from there to follow the flow of the movement.
    We then needed to get these particles moving. We know we wanted them moving upward
    quickly, thus setting 100 in **Linear Z**, shown in *Figure 12.19* below. This
    blasts them off to space, but we want to add a drag component to our velocity
    to slow them down near the top. This comes from the limit **Velocity over Lifetime**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择形状为盒子，因为我们希望粒子从楼梯阻挡器的底部生成，并从那里向上移动以跟随运动的流动。然后我们需要让这些粒子移动。我们知道我们希望它们快速向上移动，因此在下面的*图12.19*中设置**线性Z**为100。这把它们发射到太空中，但我们希望向我们的速度添加阻力成分以在顶部附近减慢它们的速度。这来自于限制**生命周期内速度**。
- en: '![Graphical user interface  Description automatically generated](img/B17304_12_20.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成描述](img/B17304_12_20.png)'
- en: 'Figure 12.19: Velocity over Lifetime module'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19：生命周期内速度模块
- en: '*Figure 12.20* below shows where we will add drag to our particles. We’re keeping
    the drag at a constant value and setting it to 5\. This value gave it a nice drag.
    This value wasn’t known beforehand; we just play around with it until it feels
    like what we’re looking for.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的*图12.20*显示了我们将在哪里添加阻力到我们的粒子。我们将阻力保持在一个恒定值，并将其设置为5。这个值给了它一个很好的阻力。这个值事先并不知道；我们只是随意调整，直到它感觉像是我们要找的东西。
- en: '![A picture containing text, electronics, screenshot  Description automatically
    generated](img/B17304_12_21.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、电子、截图的图片  自动生成描述](img/B17304_12_21.png)'
- en: 'Figure 12.20: Limit Velocity over Lifetime module'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20：生命周期内速度限制模块
- en: Next, we need to colorize these particles as they are just white math dots going
    upward. Enabling the **Color over Lifetime** module, seen below in *Figure 12.21*,
    allows you to define a gradient where the left side is the beginning of the particle’s
    life, and the right side is the end of the particle’s life, including the alpha
    of the particle if your material is set up to accept alpha.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要给这些粒子上色，因为它们只是向上移动的白色数学点。启用下面的*图12.21*中看到的**生命周期内颜色**模块，允许你定义一个渐变，其中左侧是粒子的开始生命周期，右侧是粒子的结束生命周期，包括粒子的alpha值，如果你的材质设置为接受alpha值。
- en: '![](img/B17304_12_22.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![img/B17304_12_22.png]'
- en: 'Figure 12.21: Color over Lifetime'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.21：生命周期内颜色
- en: Clicking on the gradient will pop up a gradient editor, which is seen below
    in *Figure 12.22*. The top of the gradient is the alpha and the bottom is for
    the color. Try to change the color on them to see it change the particles!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 点击渐变将弹出渐变编辑器，如下面的*图12.22*所示。渐变的顶部是alpha值，底部是颜色。尝试更改它们上的颜色，看看它如何改变粒子！
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_12_23.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成描述](img/B17304_12_23.png)'
- en: 'Figure 12.22: Gradient Editor'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.22：渐变编辑器
- en: Now we set the render mode from the **Renderer** module. Since we knew that
    we wanted the particles from the beginning to be stretched from the velocity,
    we changed this setting to **Stretched Billboard** very early. If you decided
    to follow along with this particle creation, your particles would look like colored
    dots instead of streaks.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从 **Renderer** 模块设置渲染模式。因为我们从一开始就知道我们想要的粒子应该从速度拉伸出来，所以我们很早就将这个设置改为 **Stretched
    Billboard**。如果你决定跟随这个粒子创建过程，你的粒子将看起来像彩色点而不是条纹。
- en: Changing the **Render Mode** to **Stretched Billboard** will fix that, as shown
    below in *Figure 12.23*. We also set **Speed Scale** to 0.1 as they are moving
    very fast, which makes them stretch very far if you go much higher than 0.1\.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将 **Render Mode** 更改为 **Stretched Billboard** 将解决这个问题，如下面的 *图 12.23* 所示。我们还设置了
    **Speed Scale** 为 0.1，因为它们移动得非常快，如果你将 0.1\ 以下设置得更高，它们会拉伸得更远。
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17304_12_24.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序描述自动生成](img/B17304_12_24.png)'
- en: 'Figure 12.23: Renderer module'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.23：Renderer 模块
- en: By going through these, we have just shown a simple example of a stretched particle
    to show some of the systems available. The power comes into play when you add
    shaders to the particles. A well-designed visual effect can trigger the emotion
    of an action happening. Though this may seem daunting at first, if you break down
    what you need, it becomes more of a fun time playing with the settings to get
    the right feel for your need. You will see other Shuriken effects around the level
    when you get into the project. Feel free to break them apart and put them back
    together to learn about the differences in the settings and how they play a part
    in the role of the visual effect.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些示例，我们仅仅展示了一个拉伸粒子的简单例子，以展示一些可用的系统。当你给粒子添加着色器时，力量就显现出来了。精心设计的视觉效果可以触发动作发生的情感。虽然一开始这可能看起来有些令人畏惧，但如果你分解你需要的东西，它就变成了更多是享受与设置玩耍的时间，以获得满足你需求的感觉。当你进入项目时，你会在关卡周围看到其他
    Shuriken 效果。请随意将它们拆分并重新组合，以了解设置的不同之处以及它们在视觉效果角色中的扮演。
- en: We will be going over VFX Graph in the next section. This is another particle
    system creator that allows us to create GPU particles. This is a different way
    of working as it has its own system design and UI outside of the inspector. Let’s
    get into an example we are using in the project.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中介绍 VFX 图形。这是一个允许我们创建 GPU 粒子的另一个粒子系统创建器。这是一种不同的工作方式，因为它在检查器之外有自己的系统设计和
    UI。让我们来看一下我们在项目中使用的示例。
- en: VFX Graph – Myvari’s telekinesis
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: VFX 图形 – Myvari 的心灵感应
- en: Telekinesis can look like anything. We want it to seem as though Myvari is harnessing
    celestial energy that is flowing from her toward the object she is controlling.
    For this portion, we will cover how we set up the entire VFX Graph, shader, and
    a bit of code for implementation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 心灵感应可以看起来像任何东西。我们希望它看起来像是 Myvari 正在利用从她那里流向她所控制物体的天体能量。对于这部分，我们将介绍我们如何设置整个 VFX
    图形、着色器和一些实现代码。
- en: We will assume that you have the VFX Graph package installed already and have
    opened up the `FX_BeamSetup` **Visual Effect Asset**.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你已经安装了 VFX 图形包，并且已经打开了 `FX_BeamSetup` **视觉效果资产**。
- en: The **Spawn** context starts out by default with a constant spawn rate block
    in this context. We want to just burst one time with 32 particles that we want
    to manipulate as long as the strip is up. We deleted the constant spawn and put
    in place a **Single Burst** block instead, as seen in *Figure 12.24* below.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spawn** 上下文默认情况下包含一个在此上下文中的恒定生成速率块。我们只想一次性爆发 32 个粒子，我们希望只要条带存在就操纵这些粒子。我们删除了恒定生成并放置了一个
    **Single Burst** 块，如下面的 *图 12.24* 所示。'
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_12_25.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B17304_12_25.png)'
- en: 'Figure 12.24: Spawn context'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.24：生成上下文
- en: The number 32 wasn’t a special number from the beginning. We weren’t sure how
    many we would need, but it’s easy enough to add more during the process of creating
    the strip. Below in *Figure 12.25* is our **Initialize** context. We need to set
    **Particle Per Strip Count** to the same number as the spawn in the burst above.
    We want a **Set Size** block and a **Set Custom Attribute** block. This attribute
    block will be a float data type and we called it `InterpolatedPosition`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 数字32最初并不是一个特殊的数字。我们不确定我们需要多少，但在创建条带的过程中添加更多是很简单的。下面的*图12.25*是我们的**初始化**上下文。我们需要将**每条带粒子数**设置为与上面爆发的生成相同的数字。我们需要一个**设置大小**块和一个**设置自定义属性**块。这个属性块将是一个浮点数据类型，我们称之为`InterpolatedPosition`。
- en: The reason we called it this is that we want to have an index of every particle
    so we can individually place them where we want them.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以这样称呼它，是因为我们想要每个粒子的索引，这样我们就可以将它们分别放置在我们想要的位置。
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_12_26.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成的描述](img/B17304_12_26.png)'
- en: 'Figure 12.25: Initialize context'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.25：初始化上下文
- en: We can see in *Figure 12.26* below that we are getting the particle index and
    then dividing it by one less than the total amount. The index starts at 0, so
    we need to start from one below the number we spawned. This gives us a value that
    we can work with and is stored in the float custom attribute we made.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在下面的*图12.26*中看到，我们正在获取粒子索引，然后将其除以总数减一。索引从0开始，因此我们需要从生成的数字下面开始。这给我们一个可以工作的值，并将其存储在我们创建的浮点自定义属性中。
- en: '![A screenshot of a video game  Description automatically generated](img/B17304_12_27.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![视频游戏屏幕截图  自动生成的描述](img/B17304_12_27.png)'
- en: 'Figure 12.26: Particle Index nodes'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.26：粒子索引节点
- en: Now we have a particle strip that needs to have a position to go to. We will
    make two transform parameters in the blackboard just like we do in the Shader
    Graph. We named them `BeamStart` and `BeamEnd`. We will Lerp the particles’ positions
    from the beam start to the beam end according to the interpolated position float
    we initialized with. Looking at *Figure 12.27* below, you can see how we connect
    them together. The output of the Lerp will go to the **Update Context**.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个需要定位的粒子条。我们将在黑板上创建两个变换参数，就像我们在Shader Graph中做的那样。我们给它们命名为`BeamStart`和`BeamEnd`。我们将根据我们初始化的插值位置浮点数将粒子的位置从光束起点插值到光束终点。查看下面的*图12.27*，你可以看到我们是如何将它们连接在一起的。Lerp的输出将进入**更新上下文**。
- en: '![Graphical user interface  Description automatically generated](img/B17304_12_28.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成的描述](img/B17304_12_28.png)'
- en: 'Figure 12.27: Positioning the beam'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.27：定位光束
- en: 'In the update context we have two blocks as seen below in *Figure 12.28*: **Set
    Position** and **Add Position**. We will be adding the output of the Lerp for
    their position into this block. There is one trick that will make some strange
    movement happen. On the **Set Position** block there is a small *w* in the middle.
    If it is an *L,* then that means it’s moving the local position. This will cause
    double transforms when moving around the GameObjects. If you click on the *L*
    it will change to *w*, which stands for world space. It is fine to leave **Add
    Position** in local space.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新上下文中，我们有两个块，如下面的*图12.28*所示：**设置位置**和**添加位置**。我们将把Lerp的输出位置添加到这个块中。有一个技巧会使一些奇怪的移动发生。在**设置位置**块中，中间有一个小的*w*。如果它是*L*，那么这意味着它在移动局部位置。这将在移动GameObject时导致双重变换。如果你点击*L*，它将变成*w*，代表世界空间。将**添加位置**留在局部空间是完全可以的。
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B17304_12_29.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  中度置信度自动生成的描述](img/B17304_12_29.png)'
- en: 'Figure 12.28: Update context'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.28：更新上下文
- en: Currently we have a straight beam from start to end. This is fine for testing,
    but we need something a bit more fun. Let’s add some turbulence so it isn’t so
    rigid. We will use the Add Position block and the input for that will be some
    manipulations of 3D noise. This has a few more nodes to make the right data for
    nice turbulence, but we will walk through them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们有一个从起点到终点的直线光束。这对于测试来说很好，但我们需要一些更有趣的东西。让我们添加一些湍流，使其不那么僵硬。我们将使用添加位置块，其输入将是3D噪声的一些操作。这需要更多的节点来制作出漂亮湍流所需的数据，但我们将逐一介绍。
- en: Looking at *Figure 12.29* below, these five nodes are all we need. We want to
    get our current position, then add that to time. We have a **Multiply** node in
    between there so we could speed up or slow down the time value. This could be
    a variable that’s tunable as well. After **Add** is a **Perlin Noise 3D**. The
    values here are purely subjective. Place your coordinates in the **Coordinate**
    slot and then place the output derivates into the **Add Position** block input
    in the **Update** context. From there, play around with the values until it gives
    you the nice turbulence you want. There is a problem with this approach. This
    will update every particle, including the beam start and beam end. This feels
    odd as we wanted it to come from our character’s hand.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下面的**图12.29**，我们需要的节点只有这五个。我们想要获取当前位置，然后将其添加到时间上。中间有一个**乘法**节点，因此我们可以加快或减慢时间值。这也可以是一个可调的变量。在**加法**之后是**Perlin噪声3D**。这里的值完全是主观的。将你的坐标放入**坐标**槽中，然后将输出导数放入**更新**上下文中的**添加位置**块输入。从那里，调整这些值，直到它给你想要的良好湍流。这种方法有一个问题。这将更新每个粒子，包括光束的起点和终点。这感觉有点奇怪，因为我们希望它从角色的手中发出。
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_12_30.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B17304_12_30.png)'
- en: 'Figure 12.29: 3D Perlin Noise for turbulence'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.29：用于湍流的3D Perlin噪声
- en: To ensure that the beam start and end are independent of this, we went with
    a simple gradient to tell the position whether or not it should be using the turbulence.
    Looking at *Figure 12.30*, we see that we take the interpolated position value
    and sample it across that interpolation with time. The gradient now acts as a
    transfer to which particle will be affected. The 0 value at the beginning and
    end of the strip will make 0 values multiplied with the derivatives from the noise
    generator. Now we plug this into the **Add Position** block.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保光束的起点和终点与这个效果独立，我们采用了简单的渐变来告诉位置是否应该使用湍流。查看**图12.30**，我们看到我们取插值的位置值，并使用时间进行插值采样。现在渐变充当了一个传递，决定了哪个粒子会受到影响的。条带开始和结束处的0值将使0值与噪声发生器的导数相乘。现在我们将这个值插入到**添加位置**块中。
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_12_31.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B17304_12_31.png)'
- en: 'Figure 12.30: Mask for the turbulence'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.30：湍流的遮罩
- en: We’re in the home stretch for setting up the VFX Graph portion. The **Output**
    context is shown in *Figure 12.31*. By default this will be an **Output Particle
    Quad**. This won’t do us any good, so delete it if you have it on your VFX Graph
    and press the spacebar to make a new node. Then type `particlestrip`. You’re looking
    for the **Output ParticleStrip Quad**. The one below has unlit in the name; this
    is due to the material being used.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在设置VFX图形部分的最后阶段。**输出**上下文在**图12.31**中显示。默认情况下，这将是一个**输出粒子四边形**。这对我们没有任何好处，所以如果你在VFX图形中有它，请删除它，然后按空格键创建一个新的节点。然后输入`particlestrip`。你正在寻找的是**输出粒子条带四边形**。下面的是带有“unlit”名称的，这是由于使用的材质造成的。
- en: '![Graphical user interface  Description automatically generated](img/B17304_12_32.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，描述自动生成](img/B17304_12_32.png)'
- en: 'Figure 12.31: Output ParticleStrip Quad context'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.31：输出粒子条带四边形上下文
- en: The shader is a duplicate of `SH_StairShield` with one change. In the **Graph**
    inspector, the **Support VFX Graph** Boolean is set to true. This shader has enough
    versatility to get the job done for now. We may change the texture before its
    final use, but for now it has what we need to get it going. We then assign it
    to the Shadergraph attribute in the output context. This will expose the parameters
    in the shader.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该着色器是`SH_StairShield`的一个副本，但有一个改动。在**图形**检查器中，**支持VFX图形**布尔值设置为true。这个着色器现在足够灵活，可以完成这项工作。我们可能在最终使用之前更改纹理，但就目前而言，它已经包含了我们启动所需的一切。然后我们将它分配到输出上下文中的Shadergraph属性。这将暴露着色器中的参数。
- en: There are two more steps to finalize this effect. We need to create the GameObject’s
    beam start and beam end, and then implement this effect by placing the locations
    of the GameObjects during gameplay.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要最终完成这个效果，还有两个步骤。我们需要创建GameObject的光束起点和终点，然后在游戏过程中放置GameObject的位置来实现这个效果。
- en: To start, let’s make our prefab. Below in *Figure 12.32* we made an empty GameObject
    and named it `Telekinesis`. Then we placed the beam setup object as a child and
    set its position at `0, 0, 0`. Then we created two more empty GameObjects and
    named them `BeamStart` and `BeamEnd`. We also set these positions at `0, 0, 0`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们制作我们的预制件。在下方的*图12.32*中，我们创建了一个空的GameObject，并将其命名为`Telekinesis`。然后我们将光束设置对象作为子对象放置，并将其位置设置为`0,
    0, 0`。然后我们创建了另外两个空的GameObject，并将它们命名为`BeamStart`和`BeamEnd`。我们也将这些位置设置为`0, 0, 0`。
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17304_12_33.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B17304_12_33.png)'
- en: 'Figure 12.32: Telekinesis prefab'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.32：心灵感应预制件
- en: There is a component you can add to VFX Graph assets called **VFX Property Binder**.
    Add this component to the `FX_BeamSetup` GameObject. We then create two bound
    properties to the transform and name them the same as the properties in the VFX
    Graph (`BeamStart` and `BeamEnd`). Drag the GameObject into the **Target** slot
    to reference the GameObject’s transform. Do the same for `BeamEnd`. This will
    look like *Figure 12.33* below.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向VFX Graph资产添加一个名为**VFX Property Binder**的组件。将此组件添加到`FX_BeamSetup` GameObject。然后我们创建两个绑定属性并将其与变换绑定，并命名为VFX
    Graph中的属性（`BeamStart`和`BeamEnd`）。将GameObject拖入**目标**槽位以引用GameObject的变换。对`BeamEnd`也做同样的操作。这将在下方的*图12.33*中看起来。
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_12_34.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成的描述](img/B17304_12_34.png)'
- en: 'Figure 12.33: VFX Property Binder component'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.33：VFX Property Binder组件
- en: We now need to go over the implementation. The considerations here are that
    the start of the beam needed to come from our character’s left hand. We also know
    we need the end to be attached to the item we are controlling with physics. We
    also need to turn on and off the visual effect only when the interact button is
    interacting with a physics puzzle item. We will be working with `DragRigidBody.cs`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要了解实现方法。这里的考虑是，光束的起点需要来自我们的角色的左手。我们还知道我们需要将终点连接到我们用物理控制的物品上。我们还需要在交互按钮与物理谜题物品交互时才打开和关闭视觉效果。我们将使用`DragRigidBody.cs`。
- en: This script takes the center of the screen as a point of reference and if you
    are within range of the physics item that you can interact with, it will give
    Myvari control of that Rigidbody from the use of the physics puzzle pieces scripts
    we went over in *Chapter 6*, *Interactions and Mechanics*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本以屏幕中心作为参考点，如果你在可以与之交互的物理物品的范围内，它将通过我们在*第6章*，*交互和力学*中讨论的物理谜题部件脚本，将Myvari控制该Rigidbody。
- en: 'Fields to add:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 需要添加的字段：
- en: '[PRE0]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These will be assigned in the editor and should be self-explanatory except possibly
    the `leftWristLoc`. This transform is from Myvari’s joints in her hierarchy. Expand
    her hierarchy and drag the left wrist onto this slot in the inspector.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将在编辑器中分配，应该一目了然，除非可能是`leftWristLoc`。这个变换来自Myvari的关节层次结构。展开她的层次结构，并将左腕拖到检查器中的这个槽位。
- en: In the update, we want to turn off the beam if the interact button is released.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新中，我们希望在交互按钮释放时关闭光束。
- en: '[PRE1]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After this we need to work with the `FixedUpdate`. We are working with physics,
    so we need to ask the program to check if we have a Rigidbody, and on the `FixedUpdate`,
    we will turn on the beam if true and set the positions of the `beamStart` and
    `beamEnd` at every `FixedUpdate` loop with the physics.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们需要处理`FixedUpdate`。我们正在处理物理，因此我们需要程序检查我们是否有Rigidbody，在`FixedUpdate`中，如果为真，我们将打开光束，并在每个`FixedUpdate`循环中用物理设置`beamStart`和`beamEnd`的位置。
- en: '[PRE2]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is it! Save your files, get back in the editor, and assign the transforms
    and visual effects to the script. This script is located in `Main Camera`. *Figure
    12.34* below shows the selected object with the script.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单！保存你的文件，回到编辑器，并将变换和视觉效果分配给脚本。此脚本位于`Main Camera`。下方的*图12.34*显示了带有脚本的选定对象。
- en: '![Text  Description automatically generated](img/B17304_12_35.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![文本  自动生成的描述](img/B17304_12_35.png)'
- en: 'Figure 12.34: Main Camera location for telekinesis scripting'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.34：用于心灵感应脚本的Main Camera位置
- en: Particle effects and shader work are always interesting problems to be handled
    with care. Too much of a good thing ends up not feeling good. When working through
    a level, take a moment to think about the tiny details and see if it makes sense
    to add small movements to sell the experience.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子效果和着色器工作总是需要小心处理的有意思的问题。好事做过了头反而不好。在处理关卡时，花点时间思考一下细节，看看是否需要添加小动作来增强体验。
- en: From the above two effects, there is quite a bit of thought put into each visual
    effect no matter the size of the effect. Take your time going through each effect
    in the game to break down the parts.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述两种效果来看，每个视觉效果都投入了大量的思考，无论效果的大小。花时间逐一分析游戏中的每个效果，分解其组成部分。
- en: Cinematics
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电影片段
- en: In our project, we’re using cinematics for three purposes. The first one is
    to explain that the area has been around a long time, so the areas are fragile.
    The second one is showing the player that Myvari has innate powers by her defending
    herself against a falling boulder. The third cinematic is the ending scene when
    she puts on her tiara and goes through the portal after finishing the final puzzle.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们使用电影片段有三个目的。第一个目的是解释这个区域已经存在很长时间了，所以这些区域很脆弱。第二个目的是向玩家展示Myvari拥有天生的力量，因为她通过自卫来对抗滚落的巨石。第三个电影片段是当她戴上王冠并通过传送门完成最终谜题后的结尾场景。
- en: The way that we work through cinematics is we export the models while they are
    in place in the environment. This allows us to make sure that our cinematics match
    with the environment with as much precision as possible.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理电影片段的方式是在它们在环境中就位时导出模型。这使我们能够确保我们的电影片段尽可能精确地与环境匹配。
- en: Secondary animation
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二级动画
- en: Sometimes there needs to be additional animation that is easier to simulate
    than it is to rig and hand-key. Hair is a good example of this. The actions that
    hair takes are a secondary animation after momentum is gained. Hand-keying this
    is possible but takes a lot of patience and can be done instead with physics.
    We will be using Unity’s Spring Joint component for this. There are also several
    assets in Unity’s Asset Store that have been made to make this process more robust.
    If you need just simple physics for your secondary animation, it can be done through
    the Unity physics Rigidbody component, the Spring Joint component, and capsule
    colliders.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候需要额外的动画，这些动画比绑定和手动关键帧更容易模拟。头发就是一个很好的例子。头发所采取的动作是在获得动量之后的二级动画。手动关键帧是可能的，但需要大量的耐心，而使用物理方法则可以完成。我们将使用Unity的弹簧关节组件来完成这项工作。Unity的Asset
    Store中也有一些资产被制作出来，以使这个过程更加稳健。如果你只需要简单的物理来处理二级动画，可以通过Unity的物理Rigidbody组件、弹簧关节组件和胶囊碰撞器来完成。
- en: Lighting
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 照明
- en: We’ve decided to put lighting in the finishing touches, but this could have
    had its own book. This is one of those topics that are a massive rabbit hole.
    We wanted to go over some basics of lighting here and the reason why it’s important
    to pay attention to lighting, as well as highlighting a few polishing tools and
    how to use lighting in Unity.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经决定在最终阶段添加照明效果，但这可能需要一本自己的书来详细阐述。这是那些可能变成巨大兔子洞的话题之一。我们在这里想概述一些照明的基础知识，以及为什么重视照明的重要性，同时还会介绍一些抛光工具以及如何在Unity中使用照明。
- en: First, we need to explain that lighting is an art. The purpose of lighting includes
    defining 3D form, providing mood, and designing methods for gameplay. After we
    go through a few design thoughts on lighting, we will take a tour of the Unity
    mixed lighting, lightmaps, reflection, and light probes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要解释照明是一门艺术。照明的目的包括定义3D模型、提供氛围以及设计游戏玩法的方法。在讨论了几个关于照明的构思之后，我们将游览Unity的混合照明、光照贴图、反射和光照探针。
- en: 3D form
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3D模型
- en: Without lighting, a 3D form is flat. In fact, we use unlit shaders for most
    effects. One reason is that we don’t need to add shadowing and lighting for small
    shiny effects that will only be on screen for a short time. They are flat and
    don’t need lighting to help define them; their texture shape does that work for
    it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 没有照明，3D模型看起来是平面的。实际上，我们大多数效果都使用未照明的着色器。一个原因是，我们不需要为那些只会在屏幕上短暂显示的小型闪亮效果添加阴影和照明。它们是平面的，不需要照明来定义它们；它们的纹理形状已经完成了这项工作。
- en: Providing mood
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 营造氛围
- en: This goes along with the design of the areas but is focused specifically on
    the lighting. Is the alleyway getting darker as you walk down it? This could push
    a sense of danger or nervousness in your player. Do you want unnatural lighting
    colors around certain areas to give an arcane feeling inside a mage’s house? Completely
    possible! All of these decisions should be thought about when placing lighting.
    In the same vein as mood, we could want our lights to define the gameplay.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这与区域设计相一致，但专注于光照。当你走过小巷时，小巷是否变得越来越暗？这可能会给你的玩家带来危险或紧张感。你希望某些区域周围有不自然的照明颜色，以在法师的家中营造出一种神秘感吗？完全可以实现！在放置光照时，应该考虑所有这些决定。与氛围一样，我们可能希望我们的灯光定义游戏玩法。
- en: Gameplay design
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏玩法设计
- en: Gameplay can be defined through light in many ways. In fact, your entire game
    could be designed around light.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏玩法可以通过多种方式通过光照来定义。实际上，你的整个游戏可以围绕光照来设计。
- en: Horror games often use light sources as a way to push away enemies, but it’s
    limited to a small timer as your batteries are inevitably running out! Taking
    a unique route, an older game named Boktai used a light sensor peripheral for
    the Game Boy to charge up your weapons, and if you played it in the dark the game
    was more difficult.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 恐怖游戏经常使用光源作为推开敌人的方式，但它的限制是一个小计时器，因为你的电池不可避免地会耗尽！采取一条独特的路线，一款名为Boktai的老游戏使用Game
    Boy的光传感器外设来充电你的武器，如果你在黑暗中玩这款游戏，游戏会更难。
- en: These concepts are a bit on the edge of gameplay elements. We could just use
    light to give the player an idea of where to go, or where to stay away from. We
    probably have a good idea now about general concepts of lighting design and how
    it can influence the player’s experience. Let’s dig into Unity lighting.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念在游戏玩法元素中有点边缘。我们只需使用光照让玩家知道去哪里，或者避开哪里。我们现在可能已经对光照设计的通用概念以及它如何影响玩家的体验有了很好的了解。让我们深入了解Unity照明。
- en: Unity lighting
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity 照明
- en: To get to a polished state we need to go over the basics first. This will be
    an overview of what you are capable of doing in Unity for lighting, and then we
    will be going over what settings and uses we have for our project. Built-in renderer,
    URP, and HDRP lighting are all different from each other. We will be talking about
    URP lighting specifically. We will also be pushing for a certain feel and explaining
    features that helped us achieve the desired look that we aimed for in our vertical
    slice. Each lighting asset can be configured in different ways, which means that
    these steps will only give as much help as needed to get your feet wet with lighting.
    After you go through this and play around with what we explain, we highly recommend
    reading the documentation for other lighting objects for different rendering pipelines
    depending on the needs of your project. Now that we’ve gone over the construct
    of lighting here, we will begin by talking about mixed lighting.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要达到一个光洁的状态，我们首先需要了解基础知识。这将是一个概述，说明你在Unity中可以进行哪些照明操作，然后我们将讨论我们项目中的设置和用途。内置渲染器、URP和HDRP照明彼此不同。我们将具体讨论URP照明。我们还将推动一种特定的感觉，并解释帮助我们实现垂直切片中期望的外观的功能。每个照明资产都可以以不同的方式配置，这意味着这些步骤只会提供所需帮助，以使你对照明有所了解。在你了解这些并尝试我们所解释的内容之后，我们强烈建议阅读其他照明对象的文档，根据项目需求，针对不同的渲染管线。现在我们已经讨论了光照的结构，我们将从混合照明开始讨论。
- en: Mixed lighting
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合照明
- en: We’re taking a slight shortcut here by going into mixed lighting from the start.
    To utilize mixed lighting properly, you need to be using indirect baked lighting
    and dynamic lighting. We will touch on both right now, then get back to mixed
    lighting.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里采取了一种小捷径，直接从混合照明开始。要正确使用混合照明，你需要使用间接烘焙光照和动态光照。我们现在将讨论这两者，然后回到混合照明。
- en: Indirect baked lighting
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 间接烘焙光照
- en: Real-time lights, that are casting light rays onto static GameObjects bouncing
    off geometry in the world, will be baked onto a lightmap. Those terms are new!
    Static game objects are defined by selecting the **Static** checkbox in the inspector,
    as seen in *Figure 12.35* below.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 实时灯光，将光线投射到静态GameObject上，这些GameObject在世界的几何形状上反弹，将被烘焙到光照贴图上。这些术语是新的！静态游戏对象通过在检查器中选择**静态**复选框来定义，如下面的*图12.35*所示。
- en: '![Graphical user interface  Description automatically generated](img/B17304_12_36.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面 自动生成描述](img/B17304_12_36.png)'
- en: 'Figure 12.35: Static checkbox'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.35：静态复选框
- en: hen this is selected, when the game is baking its lightmaps into the Lightmap
    UVs, it will know to add this to the items to bake. You would only choose this
    to be static if you know for certain you will never move the GameObject that you
    would make static. We are fairly certain this concrete fence will remain solid
    the entire game, so we selected it as static. The next term is lightmap. This
    is a secondary set of UVs that are not allowed to overlap with the object that
    you want to bake the lighting onto. When you import a model, you can let Unity
    generate the lightmap UVs for you, and it does a decent job at taking care of
    this. You can do this by selecting the FBX for the 3D model and choosing **Generate
    Lightmap UVs**, as in *Figure 12.36* below.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当选中此选项时，当游戏将光图烘焙到光图UV中时，它将知道要将此添加到烘焙的物品中。只有当您确信您永远不会移动您将设置为静态的GameObject时，您才会选择此选项。我们相当确信这个混凝土栅栏在整个游戏中都将保持稳固，所以我们将其选为静态。下一个术语是光图。这是一组不允许与您想要烘焙光照的对象重叠的UV。当您导入模型时，可以让Unity为您生成光图UV，它在这方面做得相当不错。您可以通过选择3D模型的FBX并选择**生成光图UV**来完成此操作，如下面的**图12.36**所示。
- en: When you select the checkbox, Lightmap UV settings will show up. These values
    are the average per object you have in your scene. These settings will do a decent
    job of setting up the basics but you may need to look into each attribute to make
    sure each object receives light the way you would expect it to.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当您选中复选框时，将显示光图UV设置。这些值是您场景中每个对象的平均值。这些设置将很好地设置基础，但您可能需要查看每个属性以确保每个对象以您期望的方式接收光照。
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B17304_12_37.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的中等置信度描述](img/B17304_12_37.png)'
- en: 'Figure 12.36: Generate Lightmap UVs option'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.36：生成光图UV选项
- en: That is for the objects that receive light. As for the lights, you can set any
    available light to be a baked light. Directional, spot, point, and area light
    are all available to be added to lightmaps when generating or baking lighting.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对接收光照的物体而言。至于灯光，您可以将任何可用的灯光设置为烘焙光。方向光、聚光灯、点光源和区域光都可以在生成或烘焙光照时添加到光图中。
- en: Dynamic lighting
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 动态照明
- en: This is also referred to as real-time lighting. Real-time lighting has to deal
    with real-time shadows and many settings involved with this. Real-time lighting
    is applied to any item that wasn’t chosen as static. Skeletal meshes are always
    real time as they cannot be static. Their nature is to move!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这也被称为实时照明。实时照明必须处理实时阴影以及与此相关的许多设置。实时照明应用于未被选为静态的任何物品。骨骼网格始终是实时的，因为它们不能是静态的。它们的本质就是移动！
- en: In our URP asset we can see that in the **Shadows** settings, we can set the
    distance to where the quality of shadows goes down. Below in *Figure 12.37* you
    can see this range in the **Shadows** section.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的URP资产中，我们可以看到在**阴影**设置中，我们可以设置阴影质量下降的距离。在下方的**图12.37**中，您可以在**阴影**部分看到这个范围。
- en: '![Graphical user interface  Description automatically generated](img/B17304_12_38.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成的描述](img/B17304_12_38.png)'
- en: 'Figure 12.37: URP Shadows settings'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.37：URP阴影设置
- en: Each real-time light will use these settings for the shadows. **Cascades** are
    how many times the light quality goes down. It’s set in meters by default. This
    can help us design the limits as we know how tall our characters should be in
    general. 1 Unity unit is by default 1 meter. You could set up a test scene to
    see what the shadows would look like for the distance of each cascade to help
    make these decisions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实时灯光都将使用这些设置来处理阴影。**级联**是指灯光质量下降的次数。默认情况下，它以米为单位设置。这可以帮助我们设计限制，因为我们知道我们的角色通常有多高。默认情况下，1个Unity单位是1米。您可以设置一个测试场景，以查看每个级联距离的阴影效果，以帮助做出这些决定。
- en: Something that’s unique to real-time lights is the four lights that are available.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 实时灯光的独特之处在于有四种可用的灯光。
- en: The directional, point, and spot lights are available for real-time lighting
    information. Area lights cannot create real-time shadows.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 方向光、点光源和聚光灯都可用于实时照明信息。区域光不能创建实时阴影。
- en: Now that we’ve gone over the basics of real-time and indirect lighting, we need
    to get back into mixed lighting mode. First, we need to let you know how to put
    lights on the scene. In *Figure 12.38* below you can see the list of lights. You
    can access this menu just as you create any GameObject, by right-clicking in the
    hierarchy or going to the GameObject menu and hovering over the **Light** option
    to get the submenu seen in *Figure 12.38*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了实时和间接照明的基础知识，我们需要回到混合照明模式。首先，我们需要告诉你如何在场景中放置灯光。在下面的图12.38中，你可以看到灯光列表。你可以像创建任何GameObject一样访问这个菜单，通过在层次结构中右键单击或转到GameObject菜单，并将鼠标悬停在**灯光**选项上以获取图12.38中显示的子菜单。
- en: '![A picture containing graphical user interface  Description automatically
    generated](img/B17304_12_39.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![包含图形用户界面的图片  自动生成的描述](img/B17304_12_39.png)'
- en: 'Figure 12.38: Light options'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.38：灯光选项
- en: Now we need to get back to mixed lighting. We’ve talked about both lighting
    modes. Some games may only use baked lighting while some games might only use
    real-time lighting. The majority will use both in URP. When you select any light
    that you make, the inspector has an option to choose real-time, mixed, or baked.
    Remember, baked means baked indirect light. The best part of mixed is that it
    allows the light to be baked where it is, but acts as dynamic when introduced
    to a non-static GameObject. This is useful for the directional light. This light
    acts like the sun, so we want it to bake for the static items, but be dynamic
    for the character or anything non-static. You can see this selected within the
    inspector in *Figure 12.39* below.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要回到混合照明。我们已经讨论了这两种照明模式。有些游戏可能只使用烘焙照明，而有些游戏可能只使用实时照明。大多数游戏在URP中都会使用这两种照明。当你选择你创建的任何灯光时，检查器有一个选项可以选择实时、混合或烘焙。记住，烘焙意味着烘焙的间接光。混合照明最好的部分是它允许灯光在它所在的位置烘焙，但与非静态GameObject结合时表现出动态效果。这对于方向光很有用。这种光的作用就像太阳，所以我们希望它为静态物品烘焙，但对于角色或任何非静态物品则是动态的。你可以在下面的图12.39中检查器中看到这一点。
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17304_12_40.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B17304_12_40.png)'
- en: 'Figure 12.39: Directional light set to mixed'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.39：设置为混合的方向光
- en: Even after you’ve set all the meshes to static that you need to, and placed
    lights and set them to either real-time, baked, or mixed, you still need to set
    up your lighting settings within the lighting window. To get there, use the screenshot
    below, in *Figure 12.40*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你已经设置了所有需要的静态网格，放置了灯光并将它们设置为实时、烘焙或混合模式，你仍然需要在灯光窗口中设置你的灯光设置。要到达那里，请参考下面的截图，如图12.40所示。
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_12_41.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成的描述](img/B17304_12_41.png)'
- en: 'Figure 12.40: Path to the lighting window'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.40：灯光窗口的路径
- en: Within the window that pops up, you will have several tunable settings. These
    settings are going to be unique for every project. We know that we want some nice
    shadow fidelity. This means we need more samples and higher resolution for our
    lightmaps. We’re also going to be fairly close to the character in the game and
    during cinematics, which is still real time. These factors need to be considered
    when thinking about your settings. You could potentially crank up the settings
    and have nice shadows with a huge light bake, but then your real-time shadows
    might not be able to handle it and will be blocky, which will cause the game to
    have a strange feel to it. It’s good to consider the system your game will be
    played on and thoroughly test the performance again after adding more lights and
    lightmaps.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在弹出的窗口中，你将拥有几个可调的设置。这些设置将针对每个项目都是独特的。我们知道我们想要一些很好的阴影保真度。这意味着我们需要更多的样本和更高分辨率的灯光贴图。我们还将非常接近游戏中的角色，在电影场景中，这仍然是实时。在考虑你的设置时，需要考虑这些因素。你可能会提高设置，并使用巨大的灯光烘焙获得很好的阴影，但你的实时阴影可能无法处理它，并且会变得块状，这会使游戏感觉奇怪。考虑你的游戏将在哪个系统上播放，并在添加更多灯光和灯光贴图后彻底测试性能是个好主意。
- en: There is another tool to use to gain more accurate real-time lighting information
    inside Unity without needing to have a lot of real-time lights. It is called light
    probes. Let’s take a look at that tool.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有另一个工具可以在Unity中获取更精确的实时照明信息，而无需拥有大量的实时灯光。它被称为光探针。让我们看看这个工具。
- en: Light probes
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 光探针
- en: Creating light probes is as easy as going to your **Light** GameObject group
    and selecting **Light Probe Group**.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 创建光探针就像进入你的 **Light** GameObject 组并选择 **Light Probe Group** 一样简单。
- en: You can see this in the options three figures above in *Figure 12.38*. What
    this tool does is sample the lighting information at points in 3D which are shown
    in *Figure 12.42*. That information is then used in real time even if the lighting
    is baked information only. This is very helpful if you want to use the coloration
    from an area light (which is only baked) and add it to a character. Think about
    a light on a wall where you don’t need to cast a shadow or for it to be real time.
    Instead of being resource-intensive, you can just use light probes around that
    area and it will help pick up on non-static geometry in real time.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在上面的三幅图中的 *图 12.38* 中看到这一点。这个工具的作用是在 3D 中的点采样光线信息，这些点在 *图 12.42* 中显示。即使光线是烘焙信息，这些信息也会实时使用。如果你想要使用区域光（仅烘焙）的颜色并将其添加到角色上，这将非常有帮助。想象一下墙上的灯光，你不需要它投射阴影或实时。而不是资源密集型，你只需在该区域周围使用光探针，它将帮助实时捕捉非静态几何形状。
- en: To set this up though, you need to place light probes by hand. There are assets
    on the Asset Store to automatically place them but keep in mind that anything
    automated in the entertainment industry needs to have an artist’s input to achieve
    what the experience needs.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置这个，你需要手动放置光探针。资产商店上有自动放置它们的资产，但请记住，娱乐行业中任何自动化都需要艺术家的输入才能达到所需的经验。
- en: '**Light Probe Group** when editing the group looks like *Figure 12.41* below
    in the inspector.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**光探针组**在编辑组时，在检查器中看起来像下面的 *图 12.41*。'
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_12_42.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，自动生成的描述](img/B17304_12_42.png)'
- en: 'Figure 12.41: Light Probe Group component in inspector'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.41：检查器中的光探针组组件
- en: You can add, delete, select all, and duplicate selected. When you’re placing
    Light Probes, just know that they are averages of multiple color locations. These
    aren’t a perfect representation of the light in one area, but more of an approximation
    to give a bit of extra boost to ensure the mood is kept for the real-time actors
    in the game. With that being said, add probes until they form a nice lattice.
    The more you have, the more computational power it will take. For each project,
    as usual, it will depend on the system to know how many light probes will be allowed
    for performance.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加、删除、选择全部，以及复制选中的内容。当你放置光探针时，只需知道它们是多个颜色位置的平均值。这些并不是一个区域光线的完美表示，而是一种近似，以提供额外的提升，确保游戏中的实时演员能够保持情绪。因此，添加探针直到它们形成一个漂亮的晶格。你拥有的越多，所需的计算能力就越大。对于每个项目，像往常一样，它将取决于系统来知道允许多少光探针以保持性能。
- en: After you’ve placed them, you can either press play and walk around, or just
    drag your non-static GameObjects around the scene to see the lighting shift slightly.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 放置好它们之后，你可以按下播放并四处走动，或者只需将你的非静态 GameObject 在场景中拖动，以看到光线略微偏移。
- en: Here is an example of the initial hallway of our vertical slice’s light probe
    lattice in *Figure 12.42*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 12.42* 中，这是我们的垂直切片初始走廊的光探针晶格的一个示例。
- en: '![A picture containing indoor, athletic game, tennis  Description automatically
    generated](img/B17304_12_43.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![包含室内、运动游戏、网球的照片，自动生成的描述](img/B17304_12_43.png)'
- en: 'Figure 12.42: Light Probe lattice'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.42：光探针晶格
- en: This can take some time and will be done after placing your lights. If you change
    up your lighting configuration, make sure to rethink your light probes as well
    afterward. There is just one last thing before we get to polishing sound. We want
    to go over reflections.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要一些时间，并且将在放置你的灯光之后完成。如果你更改了你的照明配置，确保之后也重新考虑你的光探针。在我们开始抛光声音之前，还有最后一件事。我们想要回顾一下反射。
- en: Reflection probe
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反射探针
- en: There are materials in the world that reflect the color of the environment.
    These are metallic and/or glossy materials. The problem is, what do they reflect?
    I’m happy you asked that because Unity initially will create a reflection map
    of just the skybox so there is something reflected in those materials. There is
    another tool you can add to your scene, which is a reflection probe that will
    allow you to designate a volume that has the reflection data in that area. You
    can also have overlapping volumes.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 世界中有一些材料会反射环境的颜色。这些是金属和/或光滑的材料。问题是，它们会反射什么？我很高兴你问了这个问题，因为Unity最初会创建一个仅包含天空盒的反射贴图，这样那些材料中就有东西可以反射了。你可以添加到场景中的另一个工具是反射探测器，它允许你指定一个区域，该区域具有该区域的反射数据。你也可以有重叠的体积。
- en: This is an interesting issue as it’s not a perfect representation as the probe’s
    reflection position is from the center of the position of that probe. If you have
    a large area, and you need to be very close to the reflections while also needing
    that reflection to be accurate, you will need multiple reflection probes, with
    each probe’s volumes only as large as you need them. The smaller the volume, the
    crisper the reflection image. These types of things won’t be very clear until
    you have run around the world and looked for this or worked through the cinematics
    of your game and seen a strange-looking reflection. There is a small caveat here;
    you can create real-time reflections, but they are very expensive. These should
    be used with caution. That is until we all have quantum computers in our houses.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的问题，因为它并不是完美的表示，因为探测器的反射位置是从该探测器位置的中心开始的。如果你有一个很大的区域，你需要非常接近反射，同时还需要反射非常准确，你需要多个反射探测器，每个探测器的体积只需你需要的那么大。体积越小，反射图像越清晰。这些类型的事情直到你在这个世界上四处走动并寻找这个或处理你游戏的镜头，看到奇怪的反射，才会变得非常清楚。这里有一个小的注意事项；你可以创建实时反射，但它们非常昂贵。这些应该谨慎使用。直到我们都在家里有了量子计算机。
- en: To create a reflection probe, the option is in the same place as all the rest
    of the lighting, in the GameObject menu under **Lighting**.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建反射探测器，选项与所有其他照明选项相同，在GameObject菜单下的**照明**中。
- en: When you create the probe and place it in the location you want to reflect around,
    you will have to then use the inspector to edit the volume, which looks like the
    below *Figure 12.43*.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建探测器并将其放置在你想要反射的位置时，你将需要使用检查器来编辑体积，它看起来就像下面的*图12.43*。
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_12_44.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，自动生成的描述](img/B17304_12_44.png)'
- en: 'Figure 12.43: Reflection Probe component in the inspector'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.43：检查器中的反射探测器组件
- en: The top-center two icons are for editing and moving the volume. Selecting the
    points icon gives you access to the volume’s shape to shrink and grow it to your
    needs. The type can be **Baked**, **Real-time**, or **Custom**. **Baked** will
    only be baked once and cannot change during runtime. **Real-time** changes as
    the game is running every frame. **Custom** allows you to place your own custom
    cubemap instead of sampling the environment. This could be useful if you want
    to distort the environment in the reflections! The cubemap settings are to tweak
    the cubemap’s scale and parameters to increase the needed fidelity at a performance
    cost.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部中间的两个图标用于编辑和移动体积。选择点图标可以让你访问体积的形状，以便根据需要缩小和放大它。类型可以是**烘焙的**、**实时的**或**自定义的**。**烘焙的**只会烘焙一次，在运行时无法更改。**实时的**会随着游戏的每一帧运行而改变。**自定义的**允许你放置自己的自定义立方体贴图，而不是采样环境。如果你想在反射中扭曲环境，这可能很有用！立方体贴图设置用于调整立方体贴图的缩放和参数，以在性能成本增加的情况下提高所需的保真度。
- en: One of the most important settings is the **Importance** setting! This setting
    is an integer that you set to tell the game which reflection probe is being displayed
    when there are overlapping reflection volumes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的设置之一是**重要性**设置！这个设置是一个整数，你将其设置为告诉游戏在存在重叠反射体积时显示哪个反射探测器。
- en: The way this works is that the higher the number, the higher the importance.
    If you have two overlapping volumes, such as inside the entrance to a cave versus
    right outside of it, you would then set the hallway to importance level 2\. This
    way when you enter the volume that is of higher importance, the reflection probe
    will switch to it. This can cause some popping on very close reflection surfaces.
    Play through your game and pay attention to reflections when they transition.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的工作原理是，数字越高，重要性就越高。如果你有两个重叠的音量，比如洞穴入口处与洞穴外面的音量，那么你就可以将走廊设置为重要性级别 2。这样，当你进入重要性更高的音量区域时，反射探头会切换到它。这可能会在非常接近的反射表面上引起一些爆裂声。玩你的游戏时，注意它们在过渡时的反射。
- en: Adding lighting overall is a fun task. It can greatly improve the graphical
    quality of your game and there are some great tricks to set that up. Next up is
    sound polish.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 添加整体照明是一项有趣的任务。它可以大大提高你游戏的可视质量，并且有一些很好的技巧可以设置它。接下来是声音润色。
- en: Sound polish
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音润色
- en: We have a few things we can do to make sounds in our game more believable. Sound
    polish comes down to tweaking the volume of sounds, changing the minimum and maximum
    attenuation distances, and even replacing sounds that you feel don’t sound good.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在游戏中做一些事情来使声音更加逼真。声音润色主要涉及调整声音的音量、更改最小和最大衰减距离，甚至替换那些你觉得听起来不好的声音。
- en: These are all things we’ve adjusted throughout the project already. For example,
    on one of our first ambiences, we can adjust the volume or pitch to see what feels
    right. Or we can change the minimum or maximum distances on the attenuation, add
    sounds that we may have missed, make sure that certain sounds that are more important
    are louder than others, etc.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是在项目过程中已经调整过的内容。例如，在我们的第一个环境音中，我们可以调整音量或音调，看看什么感觉合适。或者我们可以更改衰减的最小或最大距离，添加我们可能遗漏的声音，确保某些更重要声音的音量比其他声音大，等等。
- en: Overall, mixing and sound polish is a very iterative process of just manipulating
    the values and replacing sounds with other sounds to get a feel for what’s best.
    You never know how a sound will fit with the rest of the sounds until you place
    it in the game.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，混音和声音润色是一个反复迭代的过程，只是操纵数值，用其他声音替换声音，以获得最佳感觉。除非你将其放置在游戏中，否则你永远不知道一个声音会如何与其他声音搭配。
- en: Triggering sound through animation events
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过动画事件触发声音
- en: We wanted to show you how to add sound to an animation event. It’s quite an
    easy process as we already know how to add animation events, and how to trigger
    sounds using `AudioSource` components. We’ll be adding footstep sounds to our
    character walking.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想展示如何将声音添加到动画事件中。这个过程相当简单，因为我们已经知道如何添加动画事件，以及如何使用 `AudioSource` 组件触发声音。我们将为我们的角色行走添加脚步声。
- en: 'First let’s select our character, the `MyvariWithCameraRig`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们选择我们的角色，`MyvariWithCameraRig`：
- en: '![](img/B17304_12_45.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17304_12_45.png)'
- en: 'Figure 12.44: MyvariWithCameraRig'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.44：MyvariWithCameraRig
- en: Then let’s drop down into its child objects to find the `SM_Myvari` GameObject.
    Here you will see the animator component! We only need a few things here.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们进入其子对象中，找到 `SM_Myvari` GameObject。在这里，你会看到动画组件！我们这里只需要几个东西。
- en: 'First, let’s create a new script and call it `AnimationSounds`, then we’ll
    put this right below our **Animator Component**. After this, we’ll add our `AudioSource`
    component. It should all look something like *Figure 12.45* below:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的脚本，命名为 `AnimationSounds`，然后我们将它放在我们的 **Animator 组件** 下方。之后，我们将添加
    `AudioSource` 组件。它应该看起来像下面的 *图 12.45*：
- en: '![Graphical user interface  Description automatically generated](img/B17304_12_46.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成的描述](img/B17304_12_46.png)'
- en: 'Figure 12.45: SM_Myvari inspector window'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.45：SM_Myvari 检查器窗口
- en: Before we continue forward, let’s add a function to our `AnimationSounds` script.
    Remove the **Start** and **Update** functions and add a new one called `PlaySound()`.
    Above this new function, declare a new public variable called `public AudioSource`
    `AnimSound`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，让我们在我们的 `AnimationSounds` 脚本中添加一个函数。移除 **Start** 和 **Update** 函数，并添加一个新的函数，命名为
    `PlaySound()`。在这个新函数上方，声明一个新的公共变量，名为 `public AudioSource` `AnimSound`。
- en: '![Text  Description automatically generated](img/B17304_12_47.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![文本  自动生成的描述](img/B17304_12_47.png)'
- en: 'Figure 12.46: Our new AnimationSounds.cs'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.46：我们的新 AnimationSounds.cs
- en: Now, inside of our `PlaySound()` function, let’s add `AnimSound.Play()`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的 `PlaySound()` 函数中，让我们添加 `AnimSound.Play()`。
- en: Next, in the inspector, we can add the `AudioSource` component to the serialized
    field in the `AnimationSounds.cs` component and add a footstep sound effect!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在检查器中，我们可以将`AudioSource`组件添加到`AnimationSounds.cs`组件的序列化字段中，并添加脚步声效果！
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_12_48.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成的描述](img/B17304_12_48.png)'
- en: 'Figure 12.47: AnimationSounds.cs script in the inspector'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.47：检查器中的AnimationSounds.cs脚本
- en: Awesome! Now we can move on to tagging our animation with events.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们可以继续给动画添加事件标签。
- en: Tagging animations with events for sound
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为声音事件标记动画
- en: One big problem that we have with adding animation events is that we can’t add
    events directly through the animation window, so we’ll have to open up the FBX
    file inside of Unity.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在添加动画事件时遇到的一个大问题是，我们无法直接通过动画窗口添加事件，所以我们需要在Unity中打开FBX文件。
- en: The best way to do this is to go into **Assets** > **Animations** and select
    the `Myvari_Walk_Basic` FBX.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法是进入**资产** > **动画**并选择`Myvari_Walk_Basic` FBX。
- en: '![Application, icon  Description automatically generated](img/B17304_12_49.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序，图标  自动生成的描述](img/B17304_12_49.png)'
- en: 'Figure 12.48: The project explorer in Unity in the Assets > Animations folder'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.48：Unity中“资产”>“动画”文件夹的项目资源管理器
- en: Next we’ll scroll down on the inspector until we reach the **Events** dropdown.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在检查器中向下滚动，直到我们到达**事件**下拉菜单。
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17304_12_50.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B17304_12_50.png)'
- en: 'Figure 12.49: Animation clip inspector window'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.49：动画剪辑检查器窗口
- en: Open up that **Events** dropdown, and also open up the **Preview** window at
    the bottom of the inspector.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 打开那个**事件**下拉菜单，也打开检查器底部的**预览**窗口。
- en: 'It might be hidden at the bottom of the inspector, but you can click and drag
    from the bottom to bring it up! It should look something like *Figure 12.50*:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能隐藏在检查器的底部，但你可以点击并拖动从底部将其拉上来！它应该看起来像*图12.50*：
- en: '![Graphical user interface  Description automatically generated](img/B17304_12_51.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成的描述](img/B17304_12_51.png)'
- en: 'Figure 12.50: Animation Clip inspector window preview'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.50：动画剪辑检查器窗口预览
- en: 'Next, using the timeline above the preview, we can cycle to different parts
    of the animation. In particular, we are trying to find places for footsteps, so
    we’ll want to find spots like this, where the foot is meeting the ground:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用预览上方的时间轴，我们可以循环到动画的不同部分。特别是，我们正在寻找放置脚步的地方，所以我们会想要找到这样的地方，脚接触地面：
- en: '![A picture containing graphical user interface  Description automatically
    generated](img/B17304_12_52.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![包含图形用户界面的图片  自动生成的描述](img/B17304_12_52.png)'
- en: 'Figure 12.51: Animation Clip inspector window preview'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.51：动画剪辑检查器窗口预览
- en: Once your timeline is lined up, go ahead and add an animation event. And in
    the spot that says **Function**, type in `PlaySound` — *do not* include the parentheses
    you’ve seen previously (in `PlaySound()`)! For some reason, including the parentheses
    won’t trigger our function properly.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的时间轴对齐，就可以添加一个动画事件。然后在说**函数**的地方输入`PlaySound`——*不要*包括你之前看到的括号（在`PlaySound()`中）！由于某种原因，包括括号不会正确触发我们的函数。
- en: Here is where we placed our events.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就是我们放置事件的位置。
- en: '![Graphical user interface  Description automatically generated](img/B17304_12_53.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面  自动生成的描述](img/B17304_12_53.png)'
- en: 'Figure 12.52: Animation Clip inspector window timeline with events'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.52：带有事件的动画剪辑检查器窗口时间轴
- en: Now, when you go into the game and walk around, you’ll hear sound! Congrats!
    We now have footstep sounds!
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你进入游戏并四处走动时，你会听到声音！恭喜！我们现在有了脚步声！
- en: Randomized sounds
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机声音
- en: You’ll probably notice that our footstep sound is fairly repetitive. This is
    why we often like to add randomized sounds to a game!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们的脚步声相当重复。这就是为什么我们经常喜欢在游戏中添加随机声音！
- en: 'This is a process of randomly playing from a pool of sound effects so that
    sounds will be less repetitive! In this instance, we have five different footstep
    sound effects to choose from, which can be found in `/Assets/Sounds`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个从音效池中随机播放的过程，这样声音就不会那么重复了！在这个例子中，我们有五种不同的脚步声效果可供选择，它们位于`/Assets/Sounds`：
- en: '`MainFS_01.wav` – `MainFS_05.wav`'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainFS_01.wav` – `MainFS_05.wav`'
- en: 'Next, let’s open up our `AnimationSounds.cs` script and check out how we can
    add randomized sounds. So in this instance, we’re going to use a list of `AudioClips`,
    like this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们打开我们的`AnimationSounds.cs`脚本，看看我们如何添加随机声音。在这个例子中，我们将使用一个`AudioClips`列表，如下所示：
- en: '![](img/B17304_12_54.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17304_12_54.png)'
- en: 'Figure 12.53: Animation.cs public list soundPool'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.53：Animation.cs公共列表soundPool
- en: 'Then, inside of `PlaySound` we’re going to select a random clip from this,
    and load it into our `AudioSource` component. We’ll use `Random.Range` to accomplish
    this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`PlaySound`内部，我们将从这个列表中随机选择一个剪辑，并将其加载到我们的`AudioSource`组件中。我们将使用`Random.Range`来完成这个任务：
- en: '![Graphical user interface, text  Description automatically generated](img/B17304_12_55.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本描述自动生成](img/B17304_12_55.png)'
- en: 'Figure 12.54: Animation.cs PlaySound() function'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.54：Animation.cs PlaySound()函数
- en: 'Next, let’s open up the inspector where our `AnimationSounds.cs` script lies,
    highlight all of our `MainFS.wav` sounds, and click and drag them directly into
    our sound pool serialized field:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们打开我们的`AnimationSounds.cs`脚本，看看我们如何添加随机声音。在这个例子中，我们将使用一个`AudioClips`列表，如下所示：
- en: '![Graphical user interface  Description automatically generated](img/B17304_12_56.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面描述自动生成](img/B17304_12_56.png)'
- en: 'Figure 12.55: Animation.cs in the inspector'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.55：Animation.cs在检查器中
- en: And that’s all! We now are playing from a pool of random sounds!
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在正在从随机声音池中播放！
- en: Randomized pitch
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机音调
- en: Sometimes adding even more variation can be accomplished through randomizing
    the pitch. This is a very simple process as well. The first thing we have to do
    is define the range of pitch that we will affect.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，通过随机化音调甚至可以增加更多的变化。这个过程也非常简单。我们首先必须定义我们将要影响的音调范围。
- en: I like to just play the sound and play around with the pitch to see where it
    sounds good. Open up the `AudioSource` component that holds our footstep sound
    and toggle the **Pitch** slider! This will update in real time.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢直接播放声音，然后调整音调来听听哪里听起来不错。打开包含我们脚步声的`AudioSource`组件，切换**音调**滑块！这将实时更新。
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_12_57.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用描述自动生成](img/B17304_12_57.png)'
- en: 'Figure 12.56: AudioSource component'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.56：`AudioSource`组件
- en: You’ll hear that going too high or too low makes a fairly unrealistic sound.
    So I like to stick to a range of 0.3 and -0.3\. In our code, let’s just add a
    simple `Random.Range()` while targeting the pitch of our `AudioSource` component.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你会听到音调过高或过低会产生相当不真实的声音。所以我喜欢保持在0.3和-0.3的范围内。在我们的代码中，我们只需在针对`AudioSource`组件的音调时添加一个简单的`Random.Range()`即可。
- en: '![Graphical user interface  Description automatically generated with medium
    confidence](img/B17304_12_58.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面描述自动生成，中等置信度](img/B17304_12_58.png)'
- en: 'Figure 12.57: AudioSource component showing how random pitch is achieved'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.57：`AudioSource`组件显示如何实现随机音调
- en: This is all we need! One of the most important ways to create depth in the soundscape
    of our game is to add as many sources as possible. And adding things like random
    variation, sound to small details in animations, and dynamic audio can go a long
    way! Go ahead and play the game to hear your changes.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的全部！在游戏的声音景观中创建深度最重要的方法之一是添加尽可能多的来源。添加像随机变化、动画中的小细节声音和动态音频这样的东西可以走得很远！继续玩游戏，听听你的变化。
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter went over many different tools that we have worked through within
    our project. We took some time to go over our process for finalizing the art and
    assets. We focused not only on the models and textures but also on checking in
    on the design to make sure that each asset fits within the world as expected.
    Within this, we also went over adding effects from the Shuriken and VFX Graph
    particle systems. This included the implementation of effects to show telekinesis.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了我们在项目中使用过的许多不同工具。我们花了一些时间来回顾我们的最终艺术和资产处理流程。我们不仅关注模型和纹理，还检查设计，以确保每个资产都符合预期。在这个过程中，我们还介绍了从Shuriken和VFX图粒子系统中添加效果。这包括实现显示心灵感应效果的效果。
- en: We then went over the lighting design. We broke down Unity lighting with lightmaps,
    reflection, light probes, and baking. Lighting can add so much to a game, so this
    part shouldn’t be taken lightly!
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了光照设计。我们将Unity光照分解为光照贴图、反射、光照探针和烘焙。光照可以为游戏增添很多，所以这部分不应该被轻视！
- en: Then to round up our game polish we went through sound polishing to trigger
    sounds through animations and add randomness to the sounds to bring more life
    to the gameplay.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然后为了完善我们的游戏，我们进行了声音优化，通过动画触发声音，并为声音添加随机性，以使游戏玩法更加生动。
- en: This is it for the book! Thank you so much for reading all the way through and
    we hope it provided you with lots of knowledge. Please consider joining the Discord
    server, where we will be able to answer questions and go over the project in more
    detail.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本书的全部内容！非常感谢您一直阅读到最后，并希望它为您提供了大量的知识。请考虑加入我们的Discord服务器，在那里我们可以回答问题，并更详细地讨论项目。
- en: There is a bonus chapter after this that goes over some more Unity tools that
    can be used for different projects as well as some products that Unity has to
    offer for multiplayer, XR, and visual scripting. Let us know if you would like
    a book on those topics as well!
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，有一个附加章节，介绍了更多可以用于不同项目的Unity工具，以及Unity为多人游戏、XR和视觉脚本提供的一些产品。如果您也想要关于这些主题的书籍，请告诉我们！
