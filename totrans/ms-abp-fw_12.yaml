- en: '*Chapter 9*: Understanding Domain-Driven Design'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 9 章*：理解领域驱动设计'
- en: The ABP Framework project's main goal is to introduce an architectural approach
    to application development and provide the necessary infrastructure and tools
    to implement that architecture with best practices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 框架项目的主要目标是介绍一种应用程序开发架构方法，并提供必要的基础设施和工具，以最佳实践实施该架构。
- en: '**Domain-driven design** (**DDD**) is one of the core parts of ABP Framework''s
    architecture offering. ABP''s startup templates are layered based on DDD principles
    and patterns. ABP''s entity, repository, domain service, domain event, specification,
    and many other concepts are directly mapped to the tactical patterns of DDD.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域驱动设计**（**DDD**）是 ABP 框架架构提供的核心部分之一。ABP 的启动模板基于 DDD 原则和模式分层。ABP 的实体、仓储、领域服务、领域事件、规范以及许多其他概念都直接映射到
    DDD 的战术模式。'
- en: Since DDD is a core part of the ABP application development architecture, this
    book has a dedicated section, *Part 3,* *Implementing Domain-Driven Design,* for
    DDD that consists of three chapters. In this book, I will focus on practical implementation
    details rather than the theoretical and strategic approaches and concepts of DDD.
    The examples will be mostly based on the *EventHub* project that was introduced
    in [*Chapter 4*](B17287_04_Epub_AM.xhtml#_idTextAnchor130), *Understanding the
    Reference Solution*. In addition, I will show different examples for some scenarios
    that the *EventHub* project has no proper examples of.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 DDD 是 ABP 应用程序开发架构的核心部分，因此本书有一个专门的章节，*第 3 部分*，*实施领域驱动设计*，其中包含三个章节，专门介绍 DDD。在本书中，我将侧重于实际实施细节，而不是
    DDD 的理论、战略方法和概念。示例将主要基于在 [*第 4 章*](B17287_04_Epub_AM.xhtml#_idTextAnchor130)，*理解参考解决方案*
    中介绍的 *EventHub* 项目。此外，我还会展示一些 *EventHub* 项目没有适当示例的场景的不同示例。
- en: The next two chapters will show you explicit rules and concrete code examples
    for implementing DDD to help you learn how to implement DDD with the ABP Framework.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两章将向您展示实施 DDD 的明确规则和具体代码示例，以帮助您学习如何使用 ABP 框架实施 DDD。
- en: 'However, in this first chapter, we will look at DDD in general and explore
    the core technical concepts in the following order:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章的第一部分，我们将一般性地探讨 DDD，并按以下顺序探讨后续章节中的核心技术概念：
- en: Introducing DDD
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 DDD
- en: Structuring a .NET solution based on DDD
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 DDD 构建.NET解决方案
- en: Dealing with multiple applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理多个应用程序
- en: Understanding the execution flow
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解执行流程
- en: The common principles of DDD
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DDD 的常见原则
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can clone or download the source code for the *EventHub* project from GitHub:
    [https://github.com/volosoft/eventhub](https://github.com/volosoft/eventhub).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 GitHub 克隆或下载 *EventHub* 项目的源代码：[https://github.com/volosoft/eventhub](https://github.com/volosoft/eventhub)。
- en: If you want to run the solution in your local development environment, you need
    to have an IDE/editor (such as Visual Studio) to build and run ASP.NET Core solutions.
    Also, if you want to create ABP solutions, you need to have the ABP CLI installed,
    as explained in [*Chapter 2*](B17287_02_Epub_AM.xhtml#_idTextAnchor026), *Getting
    Started with ABP Framework*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在本地开发环境中运行解决方案，您需要一个 IDE/编辑器（如 Visual Studio）来构建和运行 ASP.NET Core 解决方案。此外，如果您想创建
    ABP 解决方案，您需要安装 ABP CLI，如 [*第 2 章*](B17287_02_Epub_AM.xhtml#_idTextAnchor026)，*开始使用
    ABP 框架* 中所述。
- en: Introducing DDD
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 DDD
- en: Before we cover the implementation details, let's define DDD's core concepts
    and building blocks. Let's begin with the definition of DDD.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍实现细节之前，让我们定义 DDD 的核心概念和构建块。让我们从 DDD 的定义开始。
- en: What is domain-driven design?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是领域驱动设计？
- en: DDD is a software development approach for complex needs where you connect the
    software's implementation to an evolving model.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: DDD 是一种针对复杂需求的软件开发方法，其中将软件的实现与不断发展的模型相连接。
- en: DDD is suitable for complex domains and large-scale applications. In the case
    of simple, short-lived **Create, Read, Update, Delete** (**CRUD**) applications,
    you typically don't need to follow all the DDD principles. Fortunately, ABP doesn't
    force you to implement all the DDD principles in every application; you can just
    use which principles work best for your application. However, following DDD principles
    and patterns in a complex application helps you build a flexible, modular, and
    maintainable code base.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: DDD适用于复杂领域和大型应用程序。在简单、短期存在的**创建、读取、更新、删除**（**CRUD**）应用程序的情况下，通常不需要遵循所有DDD原则。幸运的是，ABP不会强迫你在每个应用程序中实施所有DDD原则；你可以只使用最适合你应用程序的原则。然而，在复杂应用程序中遵循DDD原则和模式有助于你构建一个灵活、模块化和易于维护的代码库。
- en: DDD focuses on core domain logic rather than the infrastructure details, which
    are generally isolated from the business code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: DDD关注核心领域逻辑，而不是基础设施细节，这些细节通常与业务代码隔离。
- en: Implementing DDD is closely related to **object-oriented programming** (**OOP**)
    principles. This book doesn't cover these basic principles, but still, a good
    understanding of OOP and the **single responsibility, open-closed, Liskov-substitution,
    interface segregation, and dependency inversion** (**SOLID**) principles will
    help you a lot while you're shaping and organizing your code base and implementing
    DDD in practice.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实施领域驱动设计（DDD）与**面向对象编程**（**OOP**）原则密切相关。本书不涵盖这些基本原理，但仍然，对OOP以及**单一职责、开闭原则、里氏替换原则、接口隔离原则和依赖倒置原则**（**SOLID**）的良好理解将有助于你在塑造和组织代码库以及实际实施DDD时。
- en: Now that we've provided this brief definition, we can explore the fundamental
    layers of DDD.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经提供了这个简要的定义，我们可以探索DDD的基本层。
- en: DDD layers
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DDD层
- en: 'Layering is a common principle of organizing software solutions to reduce complexity
    and increase reusability. DDD offers a four-layered model to help you organize
    your business logic and abstract the infrastructure from the business logic, as
    shown in the following diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 分层是组织软件解决方案以减少复杂性和提高可重用性的常见原则。DDD提供了一个四层模型来帮助你组织业务逻辑，并将基础设施从业务逻辑中抽象出来，如下面的图所示：
- en: '![Figure 9.1 – Layers of DDD'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – DDD的层'
- en: '](img/Figure_9.01_B17287.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.01_B17287.jpg)'
- en: Figure 9.1 – Layers of DDD
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – DDD的层
- en: 'The preceding diagram shows the layers and their relationships:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图显示了层及其关系：
- en: The **domain layer** contains the essential business objects and implements
    the core, use case-independent, reusable domain logic of the solution. This layer
    doesn't depend on any other layer, but all the other layers directly or indirectly
    depend on it.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域层**包含基本业务对象，并实现了解决方案的核心、用例无关的、可重用的领域逻辑。这一层不依赖于任何其他层，但所有其他层直接或间接地依赖于它。'
- en: The **application layer** implements the use cases of the applications. A use
    case is typically an action that's taken by the user through the UI. The **application
    layer** uses the **domain layer's** objects to perform these use cases.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**实现了应用程序的用例。用例通常是用户通过UI执行的操作。**应用层**使用**领域层**的对象来执行这些用例。'
- en: The **presentation layer** contains the UI components of the application, such
    as the views, JavaScript, and CSS files for a web application. It does not directly
    use the **domain layer** or database objects. Instead, it uses the **application
    layer**. Typically, for every use case/action that's performed on the UI, there
    is a corresponding functionality/method on the **application layer**.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**包含应用程序的UI组件，例如Web应用程序的视图、JavaScript和CSS文件。它不直接使用**领域层**或数据库对象。相反，它使用**应用层**。通常，对于在UI上执行的所有用例/操作，**应用层**都有一个相应的功能/方法。'
- en: The **infrastructure layer** depends on all the other layers and implements
    the abstractions that have been defined by these layers. It helps gracefully separate
    your business logic from third-party libraries and systems, such as database or
    cache providers.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施层**依赖于所有其他层，并实现了这些层定义的抽象。它有助于优雅地将业务逻辑与第三方库和系统（如数据库或缓存提供者）分离。'
- en: Each layer of this model has a responsibility and contains various building
    blocks, which are introduced in the next section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型中的每一层都有其职责，并包含各种构建块，这些构建块将在下一节中介绍。
- en: Building blocks
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建块
- en: From a technical perspective, DDD is mostly related to designing your business
    code by focusing on the domain you are working on. Business logic is separated
    into two layers – the domain layer and the application layer. The other layers
    (presentation and infrastructure) are considered as implementation details and
    should be implemented based on the best practices of the specific technologies
    you are using, such as Entity Framework.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，领域驱动设计（DDD）主要与通过关注你正在工作的领域来设计你的业务代码相关。业务逻辑被分为两层——领域层和应用层。其他层（表示层和基础设施层）被视为实现细节，应根据你使用的特定技术的最佳实践来实现，例如Entity
    Framework。
- en: 'The domain layer implements the core domain logic by using the following fundamental
    building blocks:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 领域层通过以下基本构建块来实现核心领域逻辑：
- en: '`Event` and `Organization` entities.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`事件`和`组织`实体。'
- en: '**Value Object**: A value object is another type of business object. Value
    objects are identified by their state (properties), and they don''t have an identifier.
    This means that two value objects are considered the same if all their properties
    are the same. Value objects are generally simpler than entities and are typically
    implemented as immutable. For example, we can create value objects such as address,
    money, or date.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值对象**: 值对象是另一种业务对象。值对象通过其状态（属性）来识别，并且没有标识符。这意味着如果两个值对象的属性都相同，则认为它们是相同的。值对象通常比实体简单，并且通常作为不可变对象实现。例如，我们可以创建地址、货币或日期等值对象。'
- en: '`Event` entity of the EventHub solution is the aggregate root entity of the
    Event aggregate, which contains tracks and sessions as sub-collections.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EventHub解决方案中的`事件`实体是事件聚合的根实体，它包含跟踪和会话作为子集合。
- en: '**Repository**: A repository is a collection-like interface that''s used by
    the domain and application layers to access the persistence system. It hides the
    complexity of the database provider from the business code.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓储**: 仓储是一个类似于集合的接口，由领域层和应用层用来访问持久化系统。它隐藏了数据库提供者的复杂性，使其从业务代码中分离出来。'
- en: '**Domain Service**: A domain service is a stateless service (class) that implements
    core business rules. It is useful to implement domain logic that depends on multiple
    aggregate types (so that none of these aggregates can be responsible for implementing
    that logic) or external services. Domain services get/return domain objects and
    are generally consumed by the application services or other domain services.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域服务**: 领域服务是一个无状态的服务（类），它实现了核心业务规则。它对于实现依赖于多个聚合类型（因此这些聚合中的任何一个都不应负责实现该逻辑）或外部服务的领域逻辑非常有用。领域服务获取/返回领域对象，通常由应用服务或其他领域服务消费。'
- en: '**Specification**: A specification is a named, reusable, testable, and combinable
    filter that''s applied to business objects to select them based on specific business
    rules.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规范**: 规范是一个命名、可重用、可测试和可组合的过滤器，它应用于业务对象，根据特定的业务规则来选择它们。'
- en: '**Domain Event**: A domain event is a way of informing other services in a
    loosely coupled manner when a domain-specific event occurs. It is useful for implementing
    side effects across multiple aggregates.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域事件**: 领域事件是一种以松耦合方式通知其他服务在发生特定领域事件时的方式。它在实现跨多个聚合的副作用时非常有用。'
- en: 'The application layer implements the use case of the application by using the
    following building blocks:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层通过以下构建块来实现应用的使用案例：
- en: '**Application Service**: An application service is a stateless service (class)
    that implements the use cases of the application. It typically gets and returns
    data transfer objects, and its methods are used by the presentation layer. It
    uses and orchestrates the domain layer objects to perform a specific use case.
    A use case is typically implemented as a transactional (atomic) process.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用服务**: 应用服务是一个无状态的服务（类），它实现了应用的使用案例。它通常获取和返回数据传输对象，并且其方法被表示层使用。它使用和编排领域层对象以执行特定的使用案例。一个使用案例通常被实现为一个事务性（原子）过程。'
- en: '**Data Transfer Objects** (**DTO**): A DTO is used to transfer data (state)
    between the presentation and application layers. It doesn''t contain any business
    logic.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据传输对象（DTO**）: DTO用于在表示层和应用层之间传输数据（状态）。它不包含任何业务逻辑。'
- en: '**Unit of Work** (**UOW**): A UOW is a transaction boundary. All the state
    changes (typically database operations) in a UOW must be implemented as atomic,
    committed together on success, or rolled back together on failure.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作单元**（**UOW**）：UOW 是一个事务边界。UOW 中的所有状态变化（通常是数据库操作）都必须实现为原子操作，在成功时一起提交，在失败时一起回滚。'
- en: It was important to see the big picture and become familiar with the core building
    blocks of DDD, which I why I introduced them in brief here. In the next few chapters,
    we will use them in practice and understand their implementation details. However,
    in this chapter, I will continue with the big picture and explain how ABP places
    the layers and building blocks into a .NET solution.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 看到整体图景并熟悉 DDD 的核心构建块非常重要，这就是为什么我在这里简要介绍了它们。在接下来的几章中，我们将实际使用它们并了解它们的实现细节。然而，在本章中，我将继续从整体图景出发，解释
    ABP 如何将层和构建块放入 .NET 解决方案中。
- en: Structuring a .NET solution based on DDD
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据 DDD 结构化 .NET 解决方案
- en: So far, we have been introduced to the layers and core building blocks of a
    DDD-based software solution. In this section, we will learn how a .NET solution
    can be layered based on DDD. I will begin with the simplest possible solution
    structure. Then, I will explain how ABP's startup solution template evolved into
    its current structure. Finally, you will understand why the ABP startup solution
    has that many projects inside it and the purpose of each.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了基于 DDD 的软件解决方案的层和核心构建块。在本节中，我们将学习如何根据 DDD 对 .NET 解决方案进行分层。我将从最简单的解决方案结构开始。然后，我将解释
    ABP 的启动解决方案模板是如何演变成其当前结构的。最后，您将了解为什么 ABP 启动解决方案内部有那么多项目，以及每个项目的目的。
- en: Creating a simple DDD-based .NET solution
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的基于 DDD 的 .NET 解决方案
- en: 'Let''s start from scratch and keep things simple by creating four projects
    in our .NET solution, as shown in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从零开始，通过在我们的 .NET 解决方案中创建四个项目来保持事情简单，如下截图所示：
- en: '![Figure 9.2 – A simple DDD-based .NET solution in Visual Studio'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.2 – Visual Studio 中基于 DDD 的简单 .NET 解决方案'
- en: '](img/Figure_9.02_B17287.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.02_B17287.jpg)'
- en: Figure 9.2 – A simple DDD-based .NET solution in Visual Studio
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – Visual Studio 中基于 DDD 的简单 .NET 解决方案
- en: Assuming that we are building a **Customer Relationship Management** (**CRM**)
    solution, **Acme** is our company name, and **Crm** is the product name in this
    example. I've created a separate C# project for each layer. .NET projects perfectly
    fit into layers as they can physically separate the code base into different packages.
    A class/type in a project can directly use other classes/types in the same project.
    However, a class/type can't use a class/type in another project unless you explicitly
    define the dependency by referencing the other project.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在构建一个 **客户关系管理**（**CRM**）解决方案，**Acme** 是我们的公司名称，而 **Crm** 是本例中的产品名称。我为每个层创建了一个单独的
    C# 项目。.NET 项目完美地适应层，因为它们可以将代码库物理地分离到不同的包中。项目中的一个类/类型可以直接使用同一项目中的其他类/类型。然而，一个类/类型不能使用另一个项目中的类/类型，除非您通过引用其他项目显式定义依赖关系。
- en: '*Figure 9.2* shows the projects in the solution in Visual Studio, as well as
    the dependencies between these projects:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9.2* 展示了 Visual Studio 中解决方案中的项目以及这些项目之间的依赖关系：'
- en: '![Figure 9.3 – Project dependencies of the simple DDD-based .NET solution'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3 – 简单基于 DDD 的 .NET 解决方案的项目依赖关系'
- en: '](img/Figure_9.03_B17287.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.03_B17287.jpg)'
- en: Figure 9.3 – Project dependencies of the simple DDD-based .NET solution
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 简单基于 DDD 的 .NET 解决方案的项目依赖关系
- en: In the preceding diagram, the solid lines represent development-time dependencies
    (project references), while the dashed line represents runtime dependencies. I
    will explain the difference later in this section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，实线表示开发时依赖（项目引用），而虚线表示运行时依赖。我将在本节后面解释这种差异。
- en: 'To understand these dependencies, we need to know what type of components these
    projects may contain. We saw which components are located in the domain and application
    layers in the *Building blocks* section. Here, I will mention some example components
    that are included in the projects of that CRM solution:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这些依赖关系，我们需要知道这些项目可能包含哪些类型的组件。我们在 *构建块* 部分中看到了哪些组件位于领域和应用层。在这里，我将提到一些包含在该
    CRM 解决方案项目中的示例组件：
- en: '`Product` class (aggregate root entity) and an `IProductRepository` interface
    (repository abstraction). The `Product` class represents a product and has some
    properties such as `Id`, `Name`, and `Price`. `IProductRepository` has some methods
    to perform database operations for products, such as `Insert`, `Delete`, and `GetList`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Product`类（聚合根实体）和`IProductRepository`接口（存储库抽象）。`Product`类代表一个产品，并具有一些属性，如`Id`、`Name`和`Price`。`IProductRepository`有一些方法用于对产品执行数据库操作，例如`Insert`、`Delete`和`GetList`。'
- en: '`CrmDbContext` class (the EF Core data context), which maps the `Product` entity
    to a database table. It also contains the `EfProductRepository` class, which implements
    the `IproductRepository` interface.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CrmDbContext`类（EF Core数据上下文），它将`Product`实体映射到数据库表。它还包含`EfProductRepository`类，该类实现了`IproductRepository`接口。'
- en: '`ProductAppService` (application service), along with some methods to create,
    update, delete, and get a list of products. This service internally uses the `IProductRepository`
    interface and the `Product` entity (the domain objects).'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductAppService`（应用程序服务），以及一些用于创建、更新、删除和获取产品列表的方法。此服务内部使用`IProductRepository`接口和`Product`实体（领域对象）。'
- en: '`Products.cshtml` page (and a related JavaScript file) that renders the product
    data on the UI and allows you to manage (create, edit, and delete) the products.
    It internally uses `ProductAppService` to perform the actual operations.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Products.cshtml`页面（以及一个相关的JavaScript文件），它用于在UI上渲染产品数据，并允许您管理（创建、编辑和删除）产品。它内部使用`ProductAppService`来执行实际操作。'
- en: 'Now that we understand the purpose and contents of these projects, let''s see
    why the projects have these dependencies:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了这些项目的目的和内容，让我们看看为什么这些项目有这些依赖项：
- en: '**Acme.Crm.Domain** has no dependencies. In general, the domain layer has a
    minimal dependency and is abstracted from the infrastructural details.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Acme.Crm.Domain**没有依赖项。一般来说，领域层具有最小依赖性，并且从基础设施细节中抽象出来。'
- en: '`Product` class to map it to a database table, and it implements the `IProductRepository`
    interface.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Product`类映射到数据库表，并实现了`IProductRepository`接口。
- en: '`IProductRepository` repository and the `Product` entity to perform the use
    cases.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`IProductRepository`存储库和`Product`实体来执行用例。
- en: Finally, `ProductAppService`).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`ProductAppService`).
- en: 'The **Acme.Crm.Web** project has one more dependency: it references the **Acme.Crm.Infrastructure**
    project. It doesn''t directly use any class in that project, so there is no need
    for a direct dependency. However, **Acme.Crm.Web** is also the project that runs
    the application, and the application needs the infrastructure layer at runtime
    to use the database. An alternative structure will be discussed in the *Separating
    the hosting from the UI* section so that you can get rid of that dependency.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**Acme.Crm.Web**项目还有一个依赖项：它引用了**Acme.Crm.Infrastructure**项目。它不直接使用该项目中的任何类，因此不需要直接依赖。然而，**Acme.Crm.Web**也是运行应用程序的项目，应用程序在运行时需要基础设施层来使用数据库。在*将托管与UI分离*这一节中，我们将讨论一种替代结构，以便您可以消除这个依赖项。'
- en: This was a minimalistic layering of a DDD-based solution. In the next section,
    we will use that solution and explain how ABP's startup solution has evolved.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种基于DDD的解决方案的最小化分层。在下一节中，我们将使用该解决方案并解释ABP的启动解决方案是如何演变的。
- en: Evolution of the ABP startup solution
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ABP启动解决方案的演变
- en: 'ABP''s startup solution is more complex than the solution shown in *Figure
    9.2*. The following screenshot shows the same solution that was created with the
    ABP startup template, but this time using the `abp new Acme.Crm` CLI command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ABP的启动解决方案比*图9.2*中显示的解决方案更复杂。以下截图显示了使用ABP启动模板创建的相同解决方案，但这次使用的是`abp new Acme.Crm`
    CLI命令：
- en: '![Figure 9.4 – The CRM solution created using the ABP startup template'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 – 使用ABP启动模板创建的CRM解决方案'
- en: '](img/Figure_9.04_B17287.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.04_B17287.jpg)'
- en: Figure 9.4 – The CRM solution created using the ABP startup template
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 使用ABP启动模板创建的CRM解决方案
- en: Let's explain how this solution evolved from the four-project solution explained
    in the previous section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这个解决方案是如何从上一节中解释的四个项目解决方案中演变而来的。
- en: Introducing the EntityFrameworkCore project
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍EntityFrameworkCore项目
- en: The minimalistic DDD solution contains the **Acme.Crm.Infrastructure** project,
    which is assumed to implement all the infrastructural abstractions and integrations.
    An ABP solution, on the other hand, has a dedicated Entity Framework Core integration
    project (**Acme.Crm.EntityFrameworkCore**) since we think it is good to create
    separate projects for such major dependencies, especially for the database integration.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化 DDD 解决方案包含 **Acme.Crm.Infrastructure** 项目，该项目假定实现所有基础设施抽象和集成。另一方面，ABP 解决方案有一个专门的
    Entity Framework Core 集成项目（**Acme.Crm.EntityFrameworkCore**），因为我们认为为这样的主要依赖创建单独的项目是好的，尤其是对于数据库集成。
- en: The infrastructure layer can be split into multiple projects. The ABP startup
    template has no such major dependency. The only infrastructure project is the
    **Acme.Crm.EntityFrameworkCore** project. If your solution grows, you can create
    additional infrastructure projects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施层可以拆分为多个项目。ABP 启动模板没有这样的主要依赖。唯一的 Infrastructure 项目是 **Acme.Crm.EntityFrameworkCore**
    项目。如果您的解决方案增长，您可以创建额外的基础设施项目。
- en: 'With this change, the initial minimalistic DDD-based solution will be as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个变更，最初的基于 DDD 的最小化解决方案将如下所示：
- en: '![Figure 9.5 – Introducing the Entity Framework Core integration project'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.5 – 介绍 Entity Framework Core 集成项目]'
- en: '](img/Figure_9.05_B17287.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.05_B17287.jpg)'
- en: Figure 9.5 – Introducing the Entity Framework Core integration project
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 介绍 Entity Framework Core 集成项目
- en: This change was trivial. It can be thought of as changing the **Acme.Crm.Infrastructure**
    project's name to **Acme.Crm.EntityFrameworkCore**. The next section will introduce
    a new project to the solution.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变更微不足道。它可以被认为是将 **Acme.Crm.Infrastructure** 项目的名称更改为 **Acme.Crm.EntityFrameworkCore**。下一节将介绍一个新的项目到解决方案中。
- en: Introducing the application contracts
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍应用程序合约
- en: Currently, the **Acme.Crm.Application** project contains the application service
    classes. Therefore, the **Acme.Crm.Web** project references the **Acme.Crm.Application**
    project to use these services.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，**Acme.Crm.Application** 项目包含应用程序服务类。因此，**Acme.Crm.Web** 项目引用 **Acme.Crm.Application**
    项目以使用这些服务。
- en: 'This design has a problem: the **Acme.Crm.Web** project indirectly references
    the **Acme.Crm.Domain** project (over the **Acme.Crm.Application** project). This
    exposes the business objects (such as entities, domain services, and repositories)
    in the domain layer to the presentation layer and breaks the abstraction and true
    layering.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计有一个问题：**Acme.Crm.Web** 项目间接引用了 **Acme.Crm.Domain** 项目（通过 **Acme.Crm.Application**
    项目）。这暴露了领域层中的业务对象（如实体、领域服务和存储库）给表示层，打破了抽象和真正的分层。
- en: 'The ABP startup template separates the application layer into two projects:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 启动模板将应用层拆分为两个项目：
- en: The `IProductAppService`) and the related DTOs (such as `ProductCreationDto`).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IProductAppService` 和相关的 DTO（例如 `ProductCreationDto`）。'
- en: The `ProductAppService`).
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductAppService`。'
- en: 'Introducing contracts (interfaces) for the application services has two important
    advantages:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为应用程序服务引入（接口）合约有两个重要的优点：
- en: The UI layer (the **Acme.Crm.Web** project here) can depend on the service contracts
    without depending on the implementation, and therefore the domain layer.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI 层（此处为 **Acme.Crm.Web** 项目）可以依赖服务合约，而不依赖于实现，因此不依赖于领域层。
- en: You can share the **Acme.Crm.Application.Contracts** project with a client application
    to rely on the same service interfaces and reuse the same DTO classes without
    sharing your business layers.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将 **Acme.Crm.Application.Contracts** 项目与客户端应用程序共享，以便依赖相同的接口并重用相同的 DTO 类，而无需共享您的业务层。
- en: The EventHub reference solution (introduced in [*Chapter 4*](B17287_04_Epub_AM.xhtml#_idTextAnchor130),
    *Understanding the Reference Solution*) takes advantage of this design and reuses
    the **Application.Contracts** project between the UI and the HTTP API applications.
    This way, it easily sets up a tiered architecture where the application layer
    and the presentation layer are hosted in different applications yet share service
    contracts.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: EventHub 引用解决方案（在第 [*第 4 章*](B17287_04_Epub_AM.xhtml#_idTextAnchor130)，*理解参考解决方案*）利用了这种设计，并在
    UI 和 HTTP API 应用程序之间重用了 **Application.Contracts** 项目。这样，它可以轻松地设置一个分层架构，其中应用层和表示层托管在不同的应用程序中，但共享服务合约。
- en: 'By separating the application contracts project, the current solution structure
    will look like the one in the following figure:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分离应用程序合约项目，当前解决方案的结构将类似于以下图示：
- en: '![Figure 9.6 – Introducing the application contracts project'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.6 – 介绍应用程序合约项目]'
- en: '](img/Figure_9.06_B17287.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.06_B17287.jpg](img/Figure_9.06_B17287.jpg)'
- en: Figure 9.6 – Introducing the application contracts project
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 介绍应用合同项目
- en: 'With this new design, the project dependency graph will be like in the following
    figure:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种新的设计，项目依赖关系图将如下所示：
- en: '![Figure 9.7 – Project dependencies for the application contracts project'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.7 – 应用合同项目的项目依赖关系'
- en: '](img/Figure_9.07_B17287.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.07_B17287.jpg](img/Figure_9.07_B17287.jpg)'
- en: Figure 9.7 – Project dependencies for the application contracts project
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 应用合同项目的项目依赖关系
- en: The **Acme.Crm.Web** project now only depends on the **Acme.Crm.Application.Contracts**
    project and should always use the application service interfaces to perform the
    user interactions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**Acme.Crm.Web** 项目现在只依赖于 **Acme.Crm.Application.Contracts** 项目，并且应该始终使用应用服务接口来执行用户交互。'
- en: The **Acme.Crm.Web** project still depends on the **Acme.Crm.Application** and
    **Acme.Crm.EntityFrameworkCore** projects since we need them at runtime. I have
    drawn these dependencies with dashed lines to indicate that these project dependencies
    should not exist in an ideal design, but are necessary for now. I will explain
    how we can get rid of those dependencies in the *Separating the hosting from the
    UI* section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**Acme.Crm.Web** 项目仍然依赖于 **Acme.Crm.Application** 和 **Acme.Crm.EntityFrameworkCore**
    项目，因为我们需要在运行时使用它们。我用虚线画出了这些依赖关系，以表明这些项目依赖关系在理想设计中不应存在，但现在却是必要的。我将在 *将托管与 UI 分离*
    部分解释我们如何消除这些依赖关系。'
- en: Separating the application contracts from the implementation brings a small
    problem that we will solve in the next section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用合同与实现分离带来了一些小问题，我们将在下一节中解决。
- en: Introducing the domain shared project
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍域共享项目
- en: Once we have separated the contracts, we can no longer use the objects of the
    domain layer inside the contracts project because they have no reference to the
    domain layer, as shown in the previous section. This doesn't seem to be a problem
    at first glance. We shouldn't use these entities and other business objects in
    the application service contracts anyway – we should use DTOs instead. However,
    we still may want to reuse some types or values defined in the domain project.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将合同分离出来，我们就不能再在合同项目中使用域层的对象，因为它们没有对域层的引用，如前节所示。乍一看这似乎不是一个问题。我们无论如何都不应该使用这些实体和其他业务对象在应用服务合同中
    – 我们应该使用 DTO。然而，我们仍然可能想要重用域项目中定义的一些类型或值。
- en: For example, we may want to reuse a `ProductType` enum in a DTO class or depend
    on the same constant value for the product name's maximum length. We don't want
    to duplicate such code parts, but we also can't add a reference to the **Acme.Crm.Domain**
    project from the **Acme.Crm.Application.Contracts** project. The solution is to
    introduce a new project to declare such types and values.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能想在 DTO 类中重用 `ProductType` 枚举，或者依赖于产品名称最大长度的相同常量值。我们不希望重复这样的代码部分，但我们也不能从
    **Acme.Crm.Application.Contracts** 项目中添加对 **Acme.Crm.Domain** 项目的引用。解决方案是引入一个新的项目来声明这样的类型和值。
- en: We will name this new project **Acme.Crm.Domain.Shared** since this project
    will be part of the domain layer and shared with the rest of the solution. This
    project won't contain so many types in practice, but we still don't want to duplicate
    these types.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个新项目命名为 **Acme.Crm.Domain.Shared**，因为这个项目将是域层的一部分，并与解决方案的其他部分共享。实际上，这个项目不会包含很多类型，但我们仍然不想重复这些类型。
- en: 'With the introduction of the **Acme.Crm.Domain.Shared** project, the new solution
    structure will be as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 **Acme.Crm.Domain.Shared** 项目的引入，新的解决方案结构如下所示：
- en: '![Figure 9.8 – Introducing the domain shared project'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.8 – 介绍域共享项目'
- en: '](img/Figure_9.08_B17287.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.08_B17287.jpg](img/Figure_9.08_B17287.jpg)'
- en: Figure 9.8 – Introducing the domain shared project
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.8 – 介绍域共享项目'
- en: 'The following diagram shows the dependencies between the projects in the solution:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了解决方案中项目之间的依赖关系：
- en: '![Figure 9.9 – Project dependencies for the domain shared project'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.09 – 域共享项目的项目依赖关系](img/Figure_9.09_B17287.jpg)'
- en: '](img/Figure_9.09_B17287.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.09_B17287.jpg](img/Figure_9.09_B17287.jpg)'
- en: Figure 9.9 – Project dependencies for the domain shared project
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 域共享项目的项目依赖关系
- en: The new **Acme.Crm.Domain.Shared** project is used by the **Acme.Crm.Domain**
    and **Acme.Crm.Application.Contracts** projects. In this way, directly or indirectly,
    all the other projects in the solution can use the types in that new project.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 **Acme.Crm.Domain.Shared** 项目被 **Acme.Crm.Domain** 和 **Acme.Crm.Application.Contracts**
    项目使用。这样，直接或间接地，解决方案中的所有其他项目都可以使用该新项目中的类型。
- en: At this point, the fundamental layers of the ABP startup solution are complete.
    However, if you look at *Figure 9.4*, you will see that the ABP startup solution
    has three more projects. We will discuss these in the following subsections.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，ABP 启动解决方案的基本层已经完成。然而，如果你查看 *图 9.4*，你会看到 ABP 启动解决方案还有三个额外的项目。我们将在接下来的小节中讨论这些内容。
- en: Introducing the HTTP API layer
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍 HTTP API 层
- en: In *Figure 9.4*, you can see that the ABP startup solution has two HTTP-related
    projects.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 9.4* 中，你可以看到 ABP 启动解决方案有两个与 HTTP 相关的项目。
- en: First, the **Acme.Crm.HttpApi** project contains the API Controllers (that is,
    the REST APIs) of the solution. This project was introduced with the idea that
    separating the API from the UI would be better to organize and develop the solution.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，**Acme.Crm.HttpApi** 项目包含解决方案的 API 控制器（即 REST API）。这个项目是在分离 API 和 UI 的想法下引入的，这样可以更好地组织和开发解决方案。
- en: Separating the HTTP API layer as a class library project makes some advanced
    scenarios possible by allowing them to be reused. The EventHub solution takes
    advantage of this separation by using the HTTP API layer as a proxy in the UI
    layer (the UI and HTTP API are hosted in different applications in that solution).
    See the *Main website* and *Main HTTP API* sections of [*Chapter 4*](B17287_04_Epub_AM.xhtml#_idTextAnchor130),
    *Understanding the Reference Solution*, to learn how it works.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将 HTTP API 层作为一个类库项目分离，通过允许它们被重用，使得一些高级场景成为可能。EventHub 解决方案通过在 UI 层（在该解决方案中
    UI 和 HTTP API 在不同的应用程序中托管）中使用 HTTP API 层作为代理来利用这种分离。参见 [*第 4 章*](B17287_04_Epub_AM.xhtml#_idTextAnchor130)
    *理解参考解决方案* 的 *主网站* 和 *主 HTTP API* 部分，了解它是如何工作的。
- en: The second HTTP API-related project is **Acme.Crm.HttpApi.Client**. This is
    a class library project that is not being used for this example solution but can
    be used in more advanced scenarios. You can use this library from a client application
    (it can be your application or a third-party .NET client) to easily consume your
    HTTP APIs. It uses ABP's Dynamic C# Client Proxy system, as will be explained
    in [*Chapter 14*](B17287_14_Epub_AM.xhtml#_idTextAnchor429), *Building HTTP APIs
    and Real-Time Services*. Most of the time, you don't make any changes to this
    project, but it *automagically* works. The EventHub solution uses this technique
    to perform HTTP API requests from the UI application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个与 HTTP API 相关的项目是 **Acme.Crm.HttpApi.Client**。这是一个类库项目，在这个示例解决方案中未使用，但在更高级的场景中可以使用。你可以从客户端应用程序（可以是你的应用程序或第三方
    .NET 客户端）中使用这个库来轻松消费你的 HTTP API。它使用 ABP 的动态 C# 客户端代理系统，正如将在 [*第 14 章*](B17287_14_Epub_AM.xhtml#_idTextAnchor429)
    *构建 HTTP API 和实时服务* 中解释的那样。大多数时候，你不需要对这个项目进行任何更改，但它 *自动* 工作。EventHub 解决方案使用这种技术从
    UI 应用程序执行 HTTP API 请求。
- en: 'By adding two new projects for the HTTP API layer, we now have eight projects
    in the solution, as shown in the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为 HTTP API 层添加两个新项目，我们现在在解决方案中拥有八个项目，如下截图所示：
- en: '![Figure 9.10 – Adding the HTTP API projects to the solution'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.10 – 将 HTTP API 项目添加到解决方案中'
- en: '](img/Figure_9.10_B17287.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.10_B17287.jpg)'
- en: Figure 9.10 – Adding the HTTP API projects to the solution
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 将 HTTP API 项目添加到解决方案中
- en: 'The following diagram shows the new dependency graph after adding these new
    projects (this time, I''ve removed the `Acme.Crm.` prefix from the project names
    to make them fit into the diagram):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了添加这些新项目后的新依赖关系图（这次，我已经从项目名称中移除了 `Acme.Crm.` 前缀，以便它们适合图表）：
- en: '![Figure 9.11 – Project dependencies for the HTTP API layer'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.11 – HTTP API 层的项目依赖关系'
- en: '](img/Figure_9.11_B17287.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.11_B17287.jpg)'
- en: Figure 9.11 – Project dependencies for the HTTP API layer
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – HTTP API 层的项目依赖关系
- en: The **Acme.Crm.HttpApi** and **Acme.Crm.HttpApi.Client** projects depend on
    the **Acme.Crm.Application.Contracts** project because the server and client share
    the same contracts (application service interfaces). The **Acme.Crm.Web** project
    depends on the **Acme.Crm.HttpApi** project since it serves the APIs at runtime.
    This example solution has a single application at runtime. You can revisit the
    EventHub solution structure that was provided in [*Chapter 4*](B17287_04_Epub_AM.xhtml#_idTextAnchor130),
    *Understanding the Reference Solution*, to see these projects in a more complex
    environment with multiple applications at runtime.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**Acme.Crm.HttpApi**和**Acme.Crm.HttpApi.Client**项目依赖于**Acme.Crm.Application.Contracts**项目，因为服务器和客户端共享相同的契约（应用程序服务接口）。**Acme.Crm.Web**项目依赖于**Acme.Crm.HttpApi**项目，因为它在运行时提供API。这个示例解决方案在运行时只有一个应用程序。你可以回顾一下在[*第4章*](B17287_04_Epub_AM.xhtml#_idTextAnchor130)中提供的EventHub解决方案结构，以在具有多个运行时应用程序的更复杂环境中查看这些项目。'
- en: Discarding the HTTP API Layer
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 丢弃HTTP API层
- en: Not every application needs to have HTTP APIs (that is, REST APIs). In this
    case, you can even remove this project from the solution. Also, if you like, you
    can move your API controllers to the **Acme.Crm.Web** project and discard the
    **Acme.Crm.HttpApi** project.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个应用程序都需要有HTTP API（即REST API）。在这种情况下，你甚至可以从解决方案中移除这个项目。此外，如果你愿意，你可以将你的API控制器移动到**Acme.Crm.Web**项目，并丢弃**Acme.Crm.HttpApi**项目。
- en: The next section will explain the last project in the solution.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将解释解决方案中的最后一个项目。
- en: Understanding the database migrator project
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解数据库迁移项目
- en: In *Figure 9.4*, there is one more project named **Acme.Crm.DbMigrator**. This
    is a console application that can be used to apply EF Core code-first migrations
    to the database. It is a utility application and not part of the essential solution,
    so there is no need to investigate its details here.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.4*中，还有一个名为**Acme.Crm.DbMigrator**的额外项目。这是一个控制台应用程序，可以用来将EF Core代码首先迁移应用到数据库中。它是一个实用程序应用程序，不是基本解决方案的一部分，因此在这里不需要调查其细节。
- en: Test Projects in the Solution
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案中的测试项目
- en: Besides these nine projects, there are six more projects in the solution under
    the `test` folder. They are unit/integration tests projects separately configured
    for each layer. One of them (**Acme.Crm.HttpApi.Client.ConsoleTestApp**) demonstrates
    how to consume HTTP APIs using the **Acme.Crm.HttpApi.Client** project. You can
    explore them yourself.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这九个项目之外，在`test`文件夹下还有六个更多项目。它们是为每个层分别配置的单元/集成测试项目。其中之一（**Acme.Crm.HttpApi.Client.ConsoleTestApp**）演示了如何使用**Acme.Crm.HttpApi.Client**项目来消费HTTP
    API。你可以自行探索它们。
- en: These are all the projects in the ABP startup solution. The solution structure
    that's been provided is the architectural model, followed by all the pre-built
    official ABP application modules. This model makes it possible to reuse the application
    modules in various scenarios, thanks to its flexibility and modularity.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是ABP启动解决方案中的所有项目。提供的解决方案结构是架构模型，随后是所有预构建的官方ABP应用程序模块。这种模型由于其灵活性和模块化，使得在各种场景中重用应用程序模块成为可能。
- en: In the next section, we will discuss an additional project that can be used
    to separate the hosting from the UI application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论一个可以用来将托管与UI应用程序分离的额外项目。
- en: Separating the hosting from the UI
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将托管与UI分离
- en: One annoying thing in the architectural model shown in *Figure 9.11* is that
    the **Web** project references the **Application** and **EntityFramework** projects.
    None of the pages/classes in the **Web** project directly use classes in these
    projects. However, since the **Web** project is the project that runs the application,
    we needed to reference these projects to make them available at runtime.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.11*中展示的架构模型中有一个令人烦恼的事情是，**Web**项目引用了**Application**和**EntityFramework**项目。**Web**项目中的任何页面/类都没有直接使用这些项目中的类。然而，由于**Web**项目是运行应用程序的项目，我们需要引用这些项目以使它们在运行时可用。
- en: 'This structure is not a big problem, so long as you do not accidentally leak
    your domain and database layer objects into the presentation (web) layer. However,
    if you are worried and do not want to set development time dependencies for these
    runtime dependencies, you can add one more project, **Acme.Crm.Web.Host**, as
    shown in the following screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构本身并没有太大问题，只要你没有不小心将你的域名和数据层对象泄露到表示层（Web层）。然而，如果你担心，并且不想为这些运行时依赖项设置开发时间依赖项，你可以在下面的屏幕截图中添加一个额外的项目，**Acme.Crm.Web.Host**：
- en: '![Figure 9.12 – Adding a separate hosting project'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.12 – 添加单独的托管项目'
- en: '](img/Figure_9.12_B17287.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.12_B17287.jpg)'
- en: Figure 9.12 – Adding a separate hosting project
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 添加单独的托管项目
- en: With this change, the `Startup.cs`, `Program.cs`, and `appsettings.json` files.
    The **Acme.Crm.Web.Host** project becomes responsible for hosting by bringing
    all the projects together at runtime. It doesn't contain any application UI page
    or component.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个变更，`Startup.cs`、`Program.cs` 和 `appsettings.json` 文件。`Acme.Crm.Web.Host`
    项目通过在运行时将所有项目组合在一起，负责托管。它不包含任何应用 UI 页面或组件。
- en: I think this design is better. It gracefully extracts the hosting configuration
    details from the UI layer, removes the runtime dependencies, and keeps it more
    focused. However, we haven't separated the hosting application in the ABP startup
    template since most of the developers already find the ABP startup template complicated
    (compared to single-project ASP.NET Core startup templates). This is because there
    are many projects inside it, and we didn't want to add one more. I believe that
    a solution with multiple projects, and with less code in each project, is a better
    approach than a single project with everything in one place.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这个设计更好。它优雅地从 UI 层提取托管配置细节，移除了运行时依赖，并使其更加专注。然而，我们没有在 ABP 启动模板中分离托管应用，因为大多数开发者已经觉得
    ABP 启动模板很复杂（与单项目 ASP.NET Core 启动模板相比）。这是因为其中有很多项目，我们不想再添加一个。我相信，具有多个项目且每个项目代码更少的解决方案，比所有内容都在一个地方的单个项目方案更好。
- en: You can find the solution with a separate host project in this book's GitHub
    repository at [https://github.com/PacktPublishing/Mastering-ABP-Framework/tree/main/Samples/Chapter-09/SeparateHosting](https://github.com/PacktPublishing/Mastering-ABP-Framework/tree/main/Samples/Chapter-09/SeparateHosting)
    and explore the structure provided.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库中找到具有单独托管项目的解决方案，网址为 [https://github.com/PacktPublishing/Mastering-ABP-Framework/tree/main/Samples/Chapter-09/SeparateHosting](https://github.com/PacktPublishing/Mastering-ABP-Framework/tree/main/Samples/Chapter-09/SeparateHosting)，并探索提供的结构。
- en: In this section, you understood the roles that each project has in the ABP startup
    template, so you should be more comfortable while developing your solutions. In
    the next section, we will briefly revisit the EventHub reference solution from
    a DDD perspective.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了 ABP 启动模板中每个项目的角色，因此在开发你的解决方案时应该更加得心应手。在下一节中，我们将从 DDD 视角简要回顾 EventHub
    引用解决方案。
- en: Dealing with multiple applications
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理多个应用
- en: So, we've learned the purpose of each of the projects in the ABP startup solution.
    It is a good starting point for a well-architected software solution. It sets
    up the layers properly, with a single domain layer and a single application layer
    (which is used by a single web application). However, in the real world, software
    solutions may be more complex. You may have multiple applications (on the same
    system) or may need to separate your domain into multiple sub-domains to reduce
    the complexity of each sub-domain.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经了解了 ABP 启动解决方案中每个项目的目的。这是一个良好架构的软件解决方案的良好起点。它正确设置了层，只有一个领域层和一个应用层（由单个
    Web 应用使用）。然而，在现实世界中，软件解决方案可能更复杂。你可能有多个应用（在同一个系统上）或者可能需要将领域分成多个子领域以降低每个子领域的复杂性。
- en: DDD addresses the design of complex software solutions. One of the main purposes
    of separating the business logic into domain logic and application logic is to
    correctly organize your code base when there are multiple applications in your
    solution. When you have multiple applications, you have multiple application layers.
    Each of these layers implements the application-specific business logic of the
    related application, yet still shares the same core domain logic by using the
    same domain layer.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: DDD 解决方案处理复杂软件设计。将业务逻辑分离成领域逻辑和应用逻辑的主要目的是，在解决方案中有多个应用时，正确组织你的代码库。当你有多个应用时，你会有多个应用层。这些层中的每一个都实现了相关应用的应用特定业务逻辑，同时通过使用相同的领域层，仍然共享相同的核心领域逻辑。
- en: 'The *EventHub* project (introduced in [*Chapter 4*](B17287_04_Epub_AM.xhtml#_idTextAnchor130),
    *Understanding the Reference Solution*) has two web applications. One of these
    applications is the main website that is used by end users. The other one is the
    admin (back office) application, which is used by system administrators. These
    applications have different user interfaces, different use cases, different authorization
    rules, and different performance, localization, caching, and scaling requirements.
    Separating these differences into two application layers helps us isolate these
    application-specific business and infrastructure requirements from each other.
    These applications share the core business logic that we don''t want to duplicate
    across the applications. This means that two application layers use the same domain
    layer, as shown in the following diagram:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*EventHub* 项目（在[*第4章*](B17287_04_Epub_AM.xhtml#_idTextAnchor130)，*理解参考解决方案*)有两个Web应用程序。其中一个是供最终用户使用的网站。另一个是管理员（后台）应用程序，供系统管理员使用。这些应用程序具有不同的用户界面、不同的用例、不同的授权规则以及不同的性能、本地化、缓存和扩展需求。将这些差异分离到两个应用程序层有助于我们将这些特定于应用程序的业务和基础设施需求相互隔离。这些应用程序共享我们不希望在应用程序之间重复的核心业务逻辑。这意味着两个应用程序层使用相同的领域层，如下面的图所示：'
- en: '![Figure 9.13 – EventHub – multiple application layers and a single domain
    layer'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.13 – EventHub – multiple application layers and a single domain
    layer'
- en: '](img/Figure_9.13_B17287.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.13_B17287.jpg]'
- en: Figure 9.13 – EventHub – multiple application layers and a single domain layer
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – EventHub – 多个应用程序层和单个领域层
- en: When we have multiple applications, separating the business logic between the
    application and domain layers becomes even more important. Leaking domain logic
    into the application layers duplicates it. On the other hand, placing application-specific
    logic in the domain layer leads you to coupling the business logic of different
    applications and writing many conditional statements to make the domain layer
    usable by these applications. Both of these situations make your code base buggy
    and difficult to maintain.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们拥有多个应用程序时，在应用程序和领域层之间分离业务逻辑变得更加重要。将领域逻辑泄漏到应用程序层会导致其重复。另一方面，将特定于应用程序的逻辑放置在领域层会使你耦合不同应用程序的业务逻辑，并编写许多条件语句以使领域层可用于这些应用程序。这两种情况都会使你的代码库出现错误且难以维护。
- en: Domain logic versus application logic separation is important. We will return
    to this topic in [*Chapter 11*](B17287_11_Epub_AM.xhtml#_idTextAnchor340), *DDD
    – The Application Layer*, after understanding the domain layer and the application
    layer building blocks. But before that, let's continue with the big picture and
    learn how a web request is executed in a DDD-based application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 领域逻辑与应用程序逻辑的分离很重要。在理解领域层和应用层构建块之后，我们将在[*第11章*](B17287_11_Epub_AM.xhtml#_idTextAnchor340)，*DDD
    – 应用程序层*中回到这个话题。但在那之前，让我们继续从大局出发，了解在基于DDD的应用程序中如何执行Web请求。
- en: Understanding the execution flow
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解执行流程
- en: 'We''ve introduced many building blocks and their descriptions, as well as how
    these building blocks are placed in layers in a .NET solution. In this section,
    we will explore how an HTTP request is executed in a typical web application that
    has been layered based on DDD. The following diagram shows the layers in action:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了许多构建块及其描述，以及这些构建块如何在.NET解决方案的层中放置。在本节中，我们将探讨在基于DDD分层的一个典型Web应用程序中如何执行HTTP请求。以下图显示了层的实际操作：
- en: '![Figure 9.14 – Execution flow through the layers'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.14 – Execution flow through the layers'
- en: '](img/Figure_9.14_B17287.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_9.14_B17287.jpg]'
- en: Figure 9.14 – Execution flow through the layers
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – 通过层的执行流程
- en: A request starts with a request from a client application. The client can be
    a browser that expects an HTML page (with its CSS/JavaScript files) or a data
    result (such as JSON). In this case, a Razor Page can process the request and
    returns an HTML page. If the application making the request is another kind of
    client (such as a console application), you probably respond to the request from
    an HTTP API (an API controller) endpoint and return a plain data result.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个请求从客户端应用程序发起。客户端可以是一个期望获取HTML页面（及其CSS/JavaScript文件）的浏览器，或者是一个数据结果（例如JSON）。在这种情况下，Razor页面可以处理请求并返回一个HTML页面。如果发起请求的应用程序是另一种类型的客户端（例如控制台应用程序），你可能需要从HTTP
    API（API控制器）端点响应请求并返回一个纯数据结果。
- en: The MVC page (in the presentation layer) processes the UI logic, may perform
    some data conversions, and delegates the actual operation to a method of an application
    in the application layer. The application service may take a DTO, implement the
    use case logic, and return a resulting DTO to the presentation layer.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: MVC页面（在表示层）处理UI逻辑，可能执行一些数据转换，并将实际操作委托给应用层中应用程序的一个方法。应用服务可能接受一个DTO，实现用例逻辑，并将结果DTO返回给表示层。
- en: The application service internally uses the domain objects (entities, repositories,
    domain services, and more) to coordinate the business operation. The business
    operation should be a unit of work. This means it should be atomic. All the database
    operations in a use case (typically, an application method) should be committed
    or rolled back together.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务内部使用领域对象（实体、存储库、领域服务等）来协调业务操作。业务操作应该是一个工作单元。这意味着它应该是原子的。在一个用例（通常是应用程序方法）中的所有数据库操作都应该一起提交或回滚。
- en: The presentation and application layers typically implement the cross-cutting
    concerns, such as authorization, validation, exception handling, caching, audit
    logging, and so on.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 表示层和应用层通常实现横切关注点，例如授权、验证、异常处理、缓存、审计日志等。
- en: As you learned in the previous chapters, ABP Framework provides a complete infrastructure
    for all these cross-cutting concerns and automates them wherever possible. It
    also provides proper base classes and practical conventions to help you structure
    your business components and implement DDD with best practices.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前几章中学到的，ABP框架为所有这些横切关注点提供了一个完整的架构，并在可能的情况下自动化它们。它还提供了适当的基类和实用的约定，以帮助您构建业务组件，并使用最佳实践实现DDD。
- en: As the last part of this chapter, we will see some common principles of DDD
    in the next section.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的最后一部分，我们将在下一节中看到DDD的一些常见原则。
- en: Understanding the common principles
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解通用原则
- en: DDD focuses on how you design your business code. It cares about state changes
    and how the business objects interact – how to create an entity, how to change
    its properties by applying (and even forcing) the business rules and constraints,
    and how to preserve the data validity and integrity.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: DDD关注的是您如何设计业务代码。它关心状态变化以及业务对象之间的交互——如何创建一个实体，如何通过应用（甚至强制）业务规则和约束来更改其属性，以及如何保持数据的有效性和完整性。
- en: DDD doesn't care about reporting or mass querying. You may take the power of
    a reporting tool to create cool dashboards for your application. You can fully
    use your underlying database provider's features for high performance. You can
    even duplicate the data in another database provider for read-only reporting purposes.
    You are free to do anything, so long as you don't mix the infrastructure details
    with your business code. All these are the concerns we should care about as a
    developer, but DDD doesn't care.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: DDD不关心报告或大量查询。您可以使用报告工具的强大功能为您的应用程序创建酷炫的仪表板。您可以充分利用底层数据库提供商的功能以实现高性能。您甚至可以在另一个数据库提供商中复制数据，用于只读报告目的。您可以自由地做任何事情，只要您不将基础设施细节与业务代码混合。所有这些是我们作为开发者应该关心的问题，但DDD并不关心。
- en: 'DDD also doesn''t care about the infrastructure details; you are expected to
    isolate your business code from these details with proper abstractions. Two of
    these abstractions are especially important since they take a big place in your
    code base: the presentation technology and the database provider. In the next
    few sections, I will explain these two principles and discuss if we need to implement
    them.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: DDD也不关心基础设施细节；您应该使用适当的抽象来隔离业务代码与这些细节。其中两个抽象特别重要，因为它们在您的代码库中占据了很大的空间：表示技术和数据库提供商。在接下来的几节中，我将解释这两个原则，并讨论我们是否需要实现它们。
- en: Database provider independence
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库提供商独立性
- en: 'It is a good practice to abstract the database integration in a DDD-based software
    solution. Your domain and application layers should be database and even ORM independent,
    in theory. There are some good reasons behind this suggestion. If you implement
    it, the following will occur:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于DDD的软件解决方案中抽象数据库集成是一种良好的实践。在理论上，您的领域和应用层应该是数据库和甚至ORM独立的。这个建议背后有一些很好的理由。如果您实施它，以下情况将会发生：
- en: Your database provider (ORM or DBMS) may change in the future without affecting
    your business code. This makes your business code longer-lived.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的数据库提供商（ORM或DBMS）在未来可能会发生变化，而不会影响您的业务代码。这使得您的业务代码具有更长的生命周期。
- en: Your domain and application layers become more focused on your business code
    by hiding the data access logic behind the repositories.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在仓储后面隐藏数据访问逻辑，你的领域层和应用层将更加专注于业务代码。
- en: You can mock the database layer for automated tests more efficiently.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以更有效地模拟数据库层以进行自动化测试。
- en: The ABP startup template follows this principle – it doesn't include references
    to the database provider from the domain and application layers. ABP Framework
    already provides the infrastructure to implement the repository pattern easily.
    The ABP startup template also comes with the database layer, which uses an in-memory
    database instance for automated tests.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 启动模板遵循这一原则——它不包含来自领域和应用层的数据库提供者引用。ABP 框架已经提供了实现仓储模式的简单基础设施。ABP 启动模板还附带数据库层，该层使用内存数据库实例进行自动化测试。
- en: 'The last two of these reasons are important and easy to apply with ABP Framework.
    However, the first one is not so easy. In the beginning, it seems like you make
    your business code ORM/database independent when you place your data access logic
    behind the repositories. However, it is not that simple. Let''s assume that you
    are currently using EF Core with SQL Server (a relational database) and want to
    design your business code and entities so that you can easily switch to MongoDB
    (a document database) later. If you want to accomplish that, you must take the
    following into account:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个原因中的最后一个是重要的，并且很容易与 ABP 框架一起应用。然而，第一个原因并不那么容易。一开始，当你将数据访问逻辑放在仓储后面时，你可能觉得你的业务代码是
    ORM/数据库无关的。然而，事情并不那么简单。让我们假设你目前正在使用 EF Core 和 SQL Server（一个关系型数据库）来设计你的业务代码和实体，以便你可以轻松地切换到
    MongoDB（一个文档数据库）。如果你想实现这一点，你必须考虑以下因素：
- en: You can't assume that you have the change tracking system of EF Core because
    the MongoDB .NET driver doesn't provide that feature. So, you should always manually
    update the changed entities at the end of your business logic.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能假设你有 EF Core 的变更跟踪系统，因为 MongoDB .NET 驱动程序不提供该功能。因此，你应该始终在业务逻辑的末尾手动更新已更改的实体。
- en: You can't add navigation or collection properties to your entity where these
    properties are types of other aggregates. You must strictly implement the aggregate
    pattern (as will be explained in [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316),
    *DDD – The Domain Layer*) by respecting the aggregate boundaries. This restriction
    deeply affects your entity design and the business code that works on your entities.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能将导航或集合属性添加到实体中，这些属性是其他聚合的类型。你必须严格实现聚合模式（如将在[*第 10 章*](B17287_10_Epub_AM.xhtml#_idTextAnchor316)，*领域层
    DDD*中解释），并尊重聚合边界。这种限制深刻地影响了你的实体设计和在实体上工作的业务代码。
- en: As you can see, being database-agnostic requires care when it comes to designing
    the entity and affects your code base.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，要实现数据库无关性，在设计实体时需要小心，这会影响你的代码库。
- en: You may be wondering, do you need it? Will you change the database provider
    in the future? If you change it later, how much effort do you need to make regarding
    that change? Is it more than your current effort to make it database-independent?
    Even if you try to do it, will it be truly database-independent (you may not know
    it before trying to switch)?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，你需要它吗？你将来会更改数据库提供者吗？如果你以后更改，你需要付出多少努力？这比使它数据库无关的努力要多吗？即使你尝试这样做，它将真正实现数据库无关（你可能不知道在尝试切换之前）？
- en: All ABP pre-built application modules are designed to be independent of the
    database provider, and the same business code works both on EF Core and MongoDB.
    This is necessary since they are reusable modules and can't assume a database
    provider. On the other hand, a final application can make this assumption. I still
    suggest hiding the data access code behind the repositories, and ABP makes this
    very easy. However, if you want to go with an EF Core dependency, I see no problem
    with that.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 ABP 预构建的应用程序模块都设计为独立于数据库提供者，相同的业务代码在 EF Core 和 MongoDB 上都能运行。这是必要的，因为它们是可重用模块，不能假设有数据库提供者。另一方面，最终应用程序可以做出这种假设。我仍然建议将数据访问代码隐藏在仓储后面，ABP
    使这一点变得非常简单。然而，如果你想要使用 EF Core 依赖项，我看不到有什么问题。
- en: Presentation technology-agnostic
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示技术无关
- en: UI frameworks are the most dynamic systems in the software industry. There are
    plenty of alternatives, and the trending approaches and tools are rapidly changing.
    Coupling your business code with your UI code would be a bad idea.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: UI 框架是软件行业中最为动态的系统。有大量的替代方案，趋势的方法和工具正在迅速变化。将您的业务代码与 UI 代码耦合将是一个糟糕的主意。
- en: Implementing this principle is more important and relatively easier, especially
    with ABP Framework. The ABP startup template comes with proper layering. ABP Framework
    provides many abstractions that you can use in your application and domain layers
    without depending on ASP.NET Core or any other UI framework.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 实施这一原则更为重要且相对容易，尤其是在使用 ABP 框架的情况下。ABP 启动模板自带了适当的分层。ABP 框架提供了许多抽象，您可以在应用程序和领域层中使用，而无需依赖于
    ASP.NET Core 或任何其他 UI 框架。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this first chapter on DDD, we looked at the four fundamental layers and the
    core building blocks in these layers. The ABP startup template is more complex
    than that four-layered structure. You learned how the startup template has evolved
    by one change at a time, and you understood the reasons behind these changes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本关于 DDD 的第一章中，我们探讨了四个基本层以及这些层中的核心构建块。ABP 启动模板比这四层结构更为复杂。您学习了启动模板是如何通过一次改变而逐步演变的，并且理解了这些改变背后的原因。
- en: 'Regarding DDD, you learned that the business logic is separated into two layers:
    the application layer and the domain layer. We discussed how to deal with multiple
    applications that share the same domain logic by referencing the EventHub example
    solution.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 DDD，您了解到业务逻辑被分为两层：应用层和领域层。我们讨论了如何通过引用 EventHub 示例解决方案来处理共享相同领域逻辑的多个应用程序。
- en: We then understood how an HTTP request is executed and passed through the layers
    in a typical DDD-based software. Finally, we discussed isolating your application
    and domain layers from the infrastructure details, especially the database providers
    and UI frameworks.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们了解了在典型的基于 DDD 的软件中，HTTP 请求是如何执行并通过各层的。最后，我们讨论了如何将应用程序和领域层与基础设施细节（尤其是数据库提供者和
    UI 框架）隔离开来。
- en: This chapter aimed to show the big picture and the fundamental concepts of DDD.
    The next chapter will focus on implementing domain layer building blocks, such
    as aggregates, repositories, and domain services.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在展示 DDD 的整体图景和基本概念。下一章将专注于实现领域层构建块，例如聚合、仓储和领域服务。
