- en: Chapter 10. Pattern Implementation Using Object/Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 使用对象/函数式编程实现模式
- en: Most modern programming languages (partially or completely) support **Functional
    Programming** (**FP**) constructs these days. As outlined in the previous chapters,
    the advent of many-core computing is a factor in this progressive evolution. In
    some cases, we can encode a solution using OOP, and there can be a functional
    version of the solution as well. The most pragmatic use of the FP constructs can
    be undertaken by judiciously mixing them with OOP code. This is also called object/functional
    programming, and is becoming a dominant paradigm in languages such as F#, Scala,
    Ruby, and so on. The C# programming language is not an exception. There are instances
    where programmers abuse FP constructs to make themselves appear modern, often
    resulting in unreadable code. Programming being a social activity (in addition
    to its intellectual appeal), the readability of code is as important as its elegance
    and performance. In this chapter, we will take a closer look at this popular paradigm
    by applying it in the context of GoF patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代编程语言（部分或全部）现在都支持**函数式编程**（**FP**）结构。正如前几章所述，多核计算的兴起是这种渐进式演化的一个因素。在某些情况下，我们可以使用面向对象编程（OOP）来编码解决方案，同时也可以有解决方案的函数式版本。最实用的FP结构使用方法是通过巧妙地将它们与OOP代码混合。这也被称为对象/函数式编程，并且正在成为F#、Scala、Ruby等语言中的主流范式。C#编程语言也不例外。有些程序员滥用FP结构来让自己看起来更现代，这往往会导致代码难以阅读。编程作为一种社会活动（除了其智力吸引力外），代码的可读性与其优雅性和性能一样重要。在本章中，我们将通过在GoF模式的应用中应用它来更深入地探讨这种流行的范式。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: A strategy pattern implementation using FP/OOP
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FP/OOP实现的策略模式
- en: A fresh look at the iterator pattern using FP/OOP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FP/OOP重新审视迭代器模式
- en: MapReduce programming idiom
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MapReduce编程惯用用法
- en: A new spin on the template method pattern using FP/OOP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FP/OOP对模板方法模式的新颖应用
- en: A strategy pattern implementation using FP/OOP
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FP/OOP实现的策略模式
- en: To focus on the programming model aspect, let us write a bubble sort routine
    to sort an array of the `int`, `double`, or `float` types. In a sort routine,
    we need to compare adjacent elements to decide whether one should swap the position
    of the elements. In computer science literature, this is called a **comparator**.
    Since we are using generic programming techniques, we can write a generic comparator
    interface to model the comparison action that would need to be performed while
    sorting is happening, and we will apply the strategy pattern to provide comparators
    based on types.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了专注于编程模型方面，让我们编写一个冒泡排序例程来对`int`、`double`或`float`类型的数组进行排序。在排序例程中，我们需要比较相邻元素以决定是否应该交换元素的位置。在计算机科学文献中，这被称为**比较器**。由于我们正在使用泛型编程技术，我们可以编写一个泛型比较器接口来模拟在排序过程中需要执行的比较操作，并且我们将应用策略模式来提供基于类型的比较器。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Even though we can use a single generic implementation for comparing elements,
    in real life we might need concrete classes that are specific to the types. We
    will implement two concrete classes for the comparison of integers and doubles.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以使用单个泛型实现来比较元素，但在现实生活中，我们可能需要具体类，这些类针对特定类型。我们将实现两个具体类来比较整数和双精度浮点数。
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Armed with the comparison classes, we can write a generic sort routine by parameterizing
    the comparison classes, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 借助比较类，我们可以通过参数化比较类来编写一个泛型排序例程，如下所示：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following code snippets show how the bubble sort routine can be invoked
    for sorting integers:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何调用冒泡排序例程来对整数进行排序：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The equivalent version for sorting doubles is given next:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来给出排序双精度浮点数的等效版本：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The OOP version of the code is simple and intuitive. But we need to resort to
    interface declaration and its implementation to write our code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: OOP版本的代码简单直观。但我们需要求助于接口声明及其实现来编写我们的代码。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In most cases, the comparison logic can be given at the call site, using lambda.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，比较逻辑可以通过lambda在调用位置给出。
- en: Using FP constructs to make the code better
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FP结构使代码更优
- en: Lambda functions can be used to write a comparison strategy routine in a much
    terser and intuitive manner. We can leverage the C# function type `Func<TIn,TResult>`
    construct to do this. Let's rewrite the sort routine to leverage this idiom. We
    could also impart this sort capability to the array types using extension methods.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda函数可以用来以更简洁、更直观的方式编写比较策略例程。我们可以利用C#函数类型`Func<TIn,TResult>`构造来做到这一点。让我们重写排序例程以利用这个习惯用法。我们还可以通过扩展方法将这种排序能力赋予数组类型。
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can invoke the routine by explicitly defining a `Func<T1,T2,TReturn>` method
    to do the comparison. The following code snippet demonstrates this method:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过显式定义一个`Func<T1,T2,TReturn>`方法来执行比较来调用该例程。以下代码片段演示了此方法：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also invoke the routine by writing a call site lambda, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过编写如下所示的调用位置lambda来调用该例程：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you want to sort a double array, the following code snippet will do the
    trick:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想对一个双精度数组进行排序，以下代码片段将完成这项任务：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The strategy routine, implemented as lambda expressions, made the code much
    terse and readable as well.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实现为lambda表达式的策略例程使代码更加简洁和可读。
- en: A fresh look at the iterator pattern using FP/OOP
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FP/OOP重新审视迭代器模式
- en: The C# programming language has built-in support for the iterator pattern using
    the `foreach` loop construct. Any programmer worth his salt might have written
    code to iterate over a collection and apply some kind of transformation. To get
    things in perspective, let's globally write some code to compute the arithmetic
    mean (average) of a set of numbers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: C#编程语言内置了对迭代器模式的支持，使用`foreach`循环构造。任何值得尊敬的程序员都可能编写过遍历集合并应用某种转换的代码。为了使事情更有条理，让我们全局编写一些代码来计算一组数字的算术平均数（平均值）。
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding imperative code does the job really well, and it is quite readable.
    Let us explore whether we can improve the situation further. If you take a closer
    look, the code iterates through a collection, and applies some logic which is
    context-dependent. If we want to calculate the product of numbers, we need to
    write the same code by slightly changing the operation. While computing the geometric
    mean, we compute the product of the numbers. To parametrize the computation, we
    will use a lambda expression or function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的过程式代码确实完成了这项工作，并且相当可读。让我们探索是否可以进一步改进情况。如果你仔细观察，代码会遍历一个集合，并应用一些依赖于上下文的逻辑。如果我们想计算数字的乘积，我们需要通过稍微改变操作来编写相同的代码。在计算几何平均数时，我们计算数字的乘积。为了参数化计算，我们将使用lambda表达式或函数。
- en: 'Let us write an aggregator function, which will iterate through an array of
    numbers and perform an operation we specify at the call site. We will use the
    function to compute the arithmetic sum (called **sigma**) or the multiplicative
    sum (called **PI**) by passing the transformer function as a parameter:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个聚合函数，该函数将遍历一个数字数组并执行在调用位置指定的操作。我们将使用该函数通过传递转换函数作为参数来计算算术和（称为**sigma**）或乘积和（称为**PI**）：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let us see how we can write the arithmetic mean function using our aggregator
    function. The following code uses a lambda expression to specify the computation:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用我们的聚合函数来编写算术平均函数。以下代码使用lambda表达式来指定计算：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The geometric mean can be computed in the following way (for brevity, we have
    ignored robustness concerns such as the presence of a zero, empty, or null array):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 几何平均数可以通过以下方式计算（为了简洁，我们忽略了诸如存在零、空或null数组等鲁棒性问题）：
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To put everything together, we will write a standard deviation (`STD`) method
    to compute the standard deviation of the elements in an array:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将所有内容整合在一起，我们将编写一个标准差（`STD`）方法来计算数组中元素的标准差：
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `STD` method takes the average of the list of numbers as a first step, and
    uses the value (`avg`) to compute the variance. For variance computation, the
    average is subtracted from each number and squared to make the resulting value
    positive, before accumulating it to a running sum (`b`) variable. Finally, the
    square root function is invoked to compute the standard deviation. The resulting
    code is readable, and can be used as a basis for other transformations on the
    list.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`STD`方法首先计算数字列表的平均值，然后使用该值（`avg`）来计算方差。在计算方差时，将平均值从每个数字中减去并平方，以使结果值变为正数，然后将其累积到一个运行总和（`b`）变量中。最后，调用平方根函数来计算标准差。生成的代码可读性良好，可以用作其他列表转换的基础。'
- en: MapReduce programming idiom
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MapReduce编程习惯
- en: In the FP world, **MapReduce** is considered as a programming idiom.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程（FP）的世界里，**MapReduce**被视为一种编程惯用用法。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The process of mapping can be described as the application of a function or
    computation on each element of a sequence to produce a new sequence. Reduction
    gathers computed elements to produce the result of a process, algorithm, or a
    functional transformation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 映射的过程可以描述为将函数或计算应用于序列中的每个元素以产生一个新的序列。归约将计算出的元素聚集起来，以产生过程、算法或函数变换的结果。
- en: 'In 2003, two Google engineers (Sanjay Ghemawat and Jeff Dean) published a paper
    about how the company used the MapReduce programming model to simplify their distributed
    programming tasks. The paper entitled *MapReduce: Simplified Data Processing on
    Large Clusters* is available on the public domain. This particular paper was very
    influential, and the Hadoop distributed programming model was based on the ideas
    outlined in the paper. You can search the Internet to find the details of the
    paper and the origin of the Hadoop data operating system.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在2003年，两位谷歌工程师（Sanjay Ghemawat和Jeff Dean）发表了一篇关于公司如何使用MapReduce编程模型简化其分布式编程任务的论文。这篇题为《MapReduce：简化大型集群上的数据处理》的论文可在公共领域找到。这篇特定的论文非常有影响力，Hadoop分布式编程模型就是基于论文中概述的思想。您可以在互联网上搜索论文的详细信息和Hadoop数据操作系统的起源。
- en: To reduce the complexity, we are going to implement a MapReduce function to
    apply the computation on an array of doubles. The following `Map` function applies
    a lambda on each element of the array, and returns another array; this actually
    transforms the original array without mutating it. For large arrays, in order
    to speed up the operation, we can leverage the `Parallel.For` construct in the
    code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了降低复杂性，我们将实现一个MapReduce函数，用于对双精度浮点数数组进行计算。下面的`Map`函数对数组中的每个元素应用一个lambda表达式，并返回另一个数组；这实际上转换了原始数组，但没有对其进行修改。对于大型数组，为了加快操作速度，我们可以利用代码中的`Parallel.For`构造。
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The MapReduce model can also be considered as the scatter/gather model of computation.
    In the last example, we leveraged parallel programming techniques to scatter the
    computation into different tasks, which would be scheduled in different threads.
    This way, computation for large arrays can be made faster. In the distributed
    version scenario, we scatter the computation to different machines. In the reduce
    scenario, we accumulate or aggregate the result of computation that occurred at
    the map stage. The following code shows the use of a serial operation in aggregating
    the value to an accumulator:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: MapReduce模型也可以被视为计算中的散列/聚集模型。在上一个例子中，我们利用并行编程技术将计算散列到不同的任务中，这些任务将在不同的线程中调度。这样，大型数组的计算可以更快。在分布式版本场景中，我们将计算散列到不同的机器上。在归约场景中，我们累积或汇总在映射阶段发生的计算结果。以下代码展示了在汇总值到一个累加器中使用串行操作：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding two functions can be used to compute standard deviation as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个函数可以用来计算标准差，如下所示：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For the time being, we are parking our discussion on the MapReduce programming
    model. It is a very vast topic, at least in the context of distributed computing
    environments. The Microsoft Azure platform offers a MapReduce implementation as
    part of its services. To be a modern developer, one should understand the MapReduce
    programming model and its stream processing counterparts available as part of
    various offerings.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将讨论的重点放在MapReduce编程模型上。这是一个非常广泛的话题，至少在分布式计算环境的背景下。微软Azure平台将其服务的一部分作为MapReduce实现提供。要成为一名现代开发者，应该了解MapReduce编程模型及其作为各种产品的一部分提供的流处理对应物。
- en: A new spin on the template method pattern using FP/OOP
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FP/OOP对模板方法模式进行新的尝试
- en: In this section, we will demonstrate how the template method pattern can be
    implemented using imperative programming techniques, and we will refactor the
    code to write an FP one. As a concrete example, we plan to use the computation
    of **Internal rate of return** (**IRR**) as a running example.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何使用命令式编程技术实现模板方法模式，并将对代码进行重构以编写一个函数式编程（FP）版本。作为一个具体的例子，我们计划使用**内部收益率**（**IRR**）的计算作为运行示例。
- en: 'To focus on the essentials, let us quickly hack an engine to compute the IRR,
    given a series of payments (`List<double>`), the rate, and the period. As a first
    step, we need to compute the present value of a series of payments by using the
    technique of discounting. The following routine computes the present value of
    the series of payments:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了专注于本质，让我们快速编写一个计算IRR的引擎，给定一系列支付（`List<double>`）、利率和期限。作为第一步，我们需要使用折现技术计算一系列支付的现值。以下程序计算了一系列支付的现值：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: '**The definition of IRR goes as follows**:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**IRR的定义如下**：'
- en: An IRR is a computation that maps a series of payments that are supposed to
    accrue to the present value by finding the rate at which the series of payments
    has to be discounted to make the future value equivalent to the present value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: IRR是一种计算，通过找到使一系列支付折现到现值的利率，将一系列应积累的支付映射到现值。
- en: The following routine has been ported from the book, *Financial Numerical Recipes
    in C++*, Bernt Arne Odegard. For details, one can consult section 3.2.1 (material
    on IRR) of the book available on the Internet.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序是从书籍《C++金融数值算法》中移植过来的，作者是Bernt Arne Odegard。有关详情，可以查阅互联网上该书的第3.2.1节（IRR相关材料）。
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With the routine under our belt, we can create an IRR calculation class that
    will use the template method pattern to receive the input for the computation
    of IRR, based on the series of future payments.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了这个程序后，我们可以创建一个IRR计算类，它将使用模板方法模式接收基于一系列未来支付的IRR计算输入。
- en: 'Let us create a class for the purpose of specifying inputs to the IRR computation
    sub system:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个类，用于指定IRR计算子系统的输入：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the template method pattern implementation, we define an `abstract` base
    class, which does the bulk of the computation, and an `abstract` method, which
    the concrete class has to override to create an object out of it:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板方法模式实现中，我们定义了一个`抽象`的基类，它执行大部分的计算，以及一个`抽象`的方法，具体类必须覆盖该方法以从中创建一个对象：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since the compute method is flagged as abstract, we cannot instantiate an object.
    The main thing which we can do is override the class and provide the content of
    the `abstract` method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算方法被标记为抽象，我们无法实例化一个对象。我们能做的事情主要是覆盖类并提供`抽象`方法的内容。
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can use the preceding class as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面的类如下：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using FP for the template method pattern implementation
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FP实现模板方法模式
- en: 'We will use lambda functions to simplify the template method pattern implementation.
    Instead of overriding a method after sub-classing the abstract class, we will
    use anonymous delegates to achieve the same objective. The resulting code, given
    next, is very simple and easy to understand:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用lambda函数来简化模板方法模式的实现。而不是在抽象类子类化后覆盖方法，我们将使用匿名委托来实现相同的目标。以下给出的代码非常简单易懂：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The class can be leveraged as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 该类可以被利用如下：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A quick note on the observer pattern
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于观察者模式的一个简要说明
- en: The functional programming model is well suited for implementing the observer
    pattern. Microsoft Corporation has already created a library, christened Rx, to
    exploit this synergy. This library implements a subset of features that falls
    under the category of compositional event streams. We will be covering the relationship
    between the observer pattern and functional programming from the next chapter
    onwards.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程模型非常适合实现观察者模式。微软公司已经创建了一个名为Rx的库，以利用这种协同作用。这个库实现了一组属于组合事件流类别的功能。从下一章开始，我们将介绍观察者模式与函数式编程之间的关系。
- en: Does FP replace GoF patterns?
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FP是否取代GoF模式？
- en: There is a notion among some programmers that functional programming can help
    to keep us away from GoF patterns. As far as the authors of this book are concerned,
    it is bit of an overstatement. In this chapter, we have already seen how GoF implementations
    can be made simple and better using functional language idioms. But the examples
    in this book are mostly written using C#. If we are using F# or Haskell, there
    are techniques available, in the rich type system of those languages, to do away
    with some of the GoF patterns.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员有一种观点，认为函数式编程可以帮助我们远离GoF模式。就本书的作者而言，这有点言过其实。在本章中，我们已经看到如何使用函数式语言的习惯用法使GoF实现变得简单和更好。但本书中的示例大多使用C#编写。如果我们使用F#或Haskell，这些语言的丰富类型系统中有一些技术可以用来消除一些GoF模式。
- en: 'Two examples are:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 两个例子是：
- en: Partial function applications have made the builder pattern unnecessary for
    FP programming languages
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分函数应用使得对于 FP 编程语言来说构建器模式变得不再必要
- en: Functional pattern matching helps us to eliminate the visitor pattern
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数模式匹配帮助我们消除访问者模式
- en: If you take a closer look at the scheme of things, the GoF pattern was a solution
    for the static and rigid type system of C++. After that, languages such as Java
    node C#, on reflection, came to the fore to simplify the implementation of GoF
    patterns. The FP can be treated as yet another enhancement. A dynamic language
    with FP support can help us implement GoF patterns better, or sometimes completely
    do away with patterns. But, completely replacing GoF patterns is bit of a shot
    in the dark!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察事物的模式，GoF 模式是为了解决 C++ 静态和僵化的类型系统而提出的解决方案。之后，诸如 Java 和 C# 这样的语言在反思中脱颖而出，简化了
    GoF 模式的实现。FP 可以被视为另一种增强。支持 FP 的动态语言可以帮助我们更好地实现 GoF 模式，有时甚至可以完全摒弃模式。但是，完全取代 GoF
    模式有点像摸黑射击！
- en: Summary
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you saw how imperative code (aka OOP code) can be mixed with
    FP constructs to write implementations of some of the GoF design patterns. Some
    functional programmers say that the GoF design patterns were conceived as a mechanism
    to overcome the limitations of an OOP in general (C++ in particular). If a language
    supports good FP constructs, most pattern implementations are unnecessary. According
    to our understanding, this view is a bit extreme and a middle path between FP
    and OOP seems to be a better option. In the coming days, FP idioms will become
    more and more popular and the progress will be a smooth transition. In the next
    chapter, we will delve into the nuances of functional reactive programming techniques.
    This is a very important paradigm where FP and events come together to provide
    us with frameworks such as .NET **Reactive Extensions** (**Rx**).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了如何将命令式代码（即 OOP 代码）与 FP 构造混合使用，以编写 GoF 设计模式的一些实现。一些函数式程序员认为，GoF 设计模式是为了克服
    OOP（特别是 C++）的一般局限性而设计的机制。如果一个语言支持良好的 FP 构造，那么大多数模式实现都是不必要的。根据我们的理解，这种观点有些极端，FP
    和 OOP 之间的中间道路似乎是一个更好的选择。在未来的日子里，FP 习惯用法将越来越受欢迎，进步将是一个平稳的过渡。在下一章中，我们将深入探讨函数式响应式编程技术的细微差别。这是一个非常重要的范式，其中
    FP 和事件结合在一起，为我们提供了如 .NET **Reactive Extensions**（**Rx**）这样的框架。
