- en: '*Chapter 9*: The Data-Oriented Technology Stack in Unity'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Unity engine is a very developer-friendly engine. When developing game logic,
    Unity's **GameObject-Components** architecture can help developers develop functions
    quickly, and adding a new behavior to a GameObject in Unity just requires attaching
    the corresponding component to it. However, with today's games becoming more complex,
    this approach, while very developer-friendly, especially to those familiar with
    traditional **Object-Oriented Programming** (**OOP**) models, is not ideal for
    game performance and project maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, Unity introduced the **Data-Oriented Technology Stack** (**DOTS**)
    to allow developers to write game code using an alternative programming philosophy
    that is data-oriented rather than object-oriented. It also introduces multithreading
    capabilities to optimize the performance of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following key topics will be part of our learning path in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: DOTS overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multithreading and the C# Job System in Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with ECS in Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using C# and the Burst compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By reading this chapter, you will learn what DOTS is and the difference between
    data-oriented design and traditional object-oriented design. You will also find
    out how to use Unity's **C# Job System** to implement multithreading to improve
    game performance, how to use Unity's **Entity Component System** (**ECS**) to
    write game logic code in a data-oriented way, and how to use the **Burst compiler**
    to optimize the generated native code for Unity games.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example project for this chapter is already available on GitHub. You can
    find it here: [https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers/tree/main/Chapter9-DOTS](https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers/tree/main/Chapter9-DOTS).'
  prefs: []
  type: TYPE_NORMAL
- en: DOTS overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DOTS is a new programming pattern in Unity and a topic that has been discussed
    a lot in the Unity developers community in recent years.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The Megacity demo based on DOTS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.01_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – The Megacity demo based on DOTS
  prefs: []
  type: TYPE_NORMAL
- en: If you have previous .NET programming experience, you will be familiar with
    the **Object-Oriented Programming** (**OOP**) pattern. OOP is widely adopted in
    the software industry, and developing games with Unity was no exception until
    Unity introduced DOTS. There's no doubt that OOP is an old habit for many programmers.
    Therefore, before discussing why Unity introduced DOTS, we will first talk about
    the problems that may be encountered when using OOP in Unity development.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented design pattern versus DOTS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, let''s talk about the concepts of OOP. We can find some useful
    information on Wikipedia. These concepts include **object/class**, **inheritance**,
    **interface**, **information hiding**, and **polymorphism**. The following link
    provides detailed explanations: [https://en.wikipedia.org/wiki/Object-oriented_design](https://en.wikipedia.org/wiki/Object-oriented_design).'
  prefs: []
  type: TYPE_NORMAL
- en: If we focus on the object/class and inheritance, we will find that these two
    concepts are the biggest difference between OOP and DOTS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with an **object/class**. In a traditional OOP pattern, a class
    is a tightly coupled set of data and behavior that acts on that data. Here, we
    have an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the code, we have a class called `Monster` and it has some
    data for its position, health, name, and whether or not it's dead. In addition,
    this class can also behave like a real object on its own data. Each `Monster`
    object can attack the target, move itself, or die.
  prefs: []
  type: TYPE_NORMAL
- en: So far, everything is perfect; the objects in the program are like objects in
    the real world, as if they have a life of their own, which is also in line with
    human experience. Next, let's discuss the **inheritance** concept of OOP. We can
    extend the data and behavior of a class and reuse some of its code via inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose in this example we realize that not all monsters attack other monsters;
    some may attack humans. From a programming perspective, humans and monsters have
    a lot in common: position, health, and whether or not it''s dead. But some monsters
    may not be killed, and humans cannot fly to move. In real life, we have a superset
    of monsters and humans, namely, creatures. Let''s put the data that monsters and
    humans share in the `Creature` class so that they can both have this data, but
    we don''t have to type them again, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Basically, if we keep going with this idea, we will end up with some complex
    class diagrams where you have a bunch of different creatures, such as monsters,
    humans, animals, and plants. We haven't even considered performance and we have
    already found that OOP can give us a lot of trouble.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how OOP also misuses the hardware. With the development of technology,
    processor hardware is getting faster and faster, but a point that is often overlooked
    is that if the data cannot be submitted from memory to the processor fast enough,
    then no matter how fast the processor is, it will not work as fast as expected.
    **Cache**, which is located closer to the processor core, is smaller, faster memory.
    When the processor issues a memory access request, it will first check whether
    there is data in the cache. If it exists (this is also called a cache hit), the
    data is returned directly without accessing the main memory; if it does not exist,
    the corresponding data in the main memory must be loaded into the cache first
    and then returned to the processor. CPUs typically use a hierarchy with multiple
    cache levels; for example, in a two-level cache system, the **L1 cache** is close
    to the processor side, and the **L2 cache** is close to the memory side.
  prefs: []
  type: TYPE_NORMAL
- en: CPU caches are designed around several assumptions. The reason why the caches
    are effective is mainly that the access to the memory when the program runs is
    characterized by locality. This locality includes both **spatial locality** and
    **temporal locality**. That is, the pieces of data we need to perform a series
    of related operations may be very close to each other in memory, or the data we
    just used for an operation may soon be used again for another operation. Taking
    advantage of this locality, caches can achieve extremely high hit rates.
  prefs: []
  type: TYPE_NORMAL
- en: However, OOP often misuses the hardware. Let's still use the `Monster` class
    as an example. Assuming a `Monster` object will occupy 56 bytes of memory, we
    iterate over a list of monsters and call their `Move()` function to change the
    monster's position property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pseudocode is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This code actually modifies a set of Vector3 data every frame, but how is this
    data allocated in memory? The following diagram shows how monster objects are
    allocated in memory when a 64-byte cache line is split up into 8-byte chunks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – The data layout in memory (OOP)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.02_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – The data layout in memory (OOP)
  prefs: []
  type: TYPE_NORMAL
- en: From the diagram, we can see that the position data that will be modified at
    every frame is discontinuous in memory, which means that our game cannot effectively
    use high-speed memory, that is, the caches.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the new programming pattern in Unity, DOTS.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike OOP, DOTS' philosophy is to design for data rather than objects, focusing
    on prioritizing and organizing data to make its memory access as efficient as
    possible. Let's still use the `Monster` class as an example to see how its data
    is allocated in memory when using DOTS.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – The data layout in memory (DOTS)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.03_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – The data layout in memory (DOTS)
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember? When moving a monster, we actually only need 12 bytes of position
    data for the monster, so the code only needs to load and process the position
    data of all the monsters to move them. Using DOTS allows us to pack all of this
    position data into an array and allocate memory more efficiently, as shown in
    the previous figure. Placing data in a contiguous array in memory improves data
    locality, which results in extremely high hit rates for caches, which improves
    code performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how does Unity''s DOTS make developers'' code run more efficiently? Well,
    DOTS in Unity is not just a change of programming paradigm from object-oriented
    to data-oriented; it actually includes a series of new technology modules, namely
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The C# Job System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Burst compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of them consists of one or more Unity packages. We can install the corresponding
    functions through Unity's Package Manager. Next, we will briefly introduce these
    three modules, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: C# Job System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using the C# Job System, we can write efficient asynchronous code in Unity
    that takes full advantage of the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Tech demo using the C# Job System'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.04_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Tech demo using the C# Job System
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding figure shows a demo project developed using Unity''s C# Job System,
    showing thousands of "soldiers" attacking the enemy in the scene. You can find
    this project on GitHub: [https://github.com/Unity-Technologies/UniteAustinTechnicalPresentation](https://github.com/Unity-Technologies/UniteAustinTechnicalPresentation).'
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the C# Job System in detail in the *Multithreaded and C# Job
    System in Unity* section.
  prefs: []
  type: TYPE_NORMAL
- en: ECS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The full name of **ECS** is **Entity Component System**. It is the core part
    of DOTS in Unity and is built around using data-oriented design, which is very
    different from the object-oriented design you may be used to.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – The Megacity demo'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.05_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – The Megacity demo
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding figure shows Unity''s impressive tech demo using ECS called **Megacity**,
    which developers can download here: [https://unity.com/megacity](https://unity.com/megacity).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Megacity download page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.06_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – Megacity download page
  prefs: []
  type: TYPE_NORMAL
- en: We'll cover ECS in detail in the *Working with ECS in Unity* section.
  prefs: []
  type: TYPE_NORMAL
- en: The Burst compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Burst compiler in Unity is an advanced compiler technology. Unity projects
    made with DOTS can use Burst technology to improve their runtime performance.
    Burst works on a subset of C# called **High-Performance C#** (**HPC#**) and applies
    advanced optimization methods under the LLVM compiler framework to generate efficient
    binaries, which achieves efficient use of device energy.
  prefs: []
  type: TYPE_NORMAL
- en: We will introduce how to use it in your project in a later section, *Using C#
    and the Burst compiler*.
  prefs: []
  type: TYPE_NORMAL
- en: This section introduces DOTS-related knowledge, such as what technology modules
    DOTS contains, how its design philosophy differs from traditional OOP, and what
    problems it solves. However, DOTS is not a replacement for OOP; it just provides
    another efficient programming pattern for game developers in Unity. For example,
    you can still use the C# Job System to implement multithreaded programming in
    the traditional Unity GameObject-Components style, rather than maintaining thread
    pools yourself. Well, next, let's explore how to implement efficient multithreaded
    programming in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading and the C# Job System in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous programming is very common when developing .NET projects. But unlike
    what many people who are familiar with .NET development think, Unity's support
    for asynchronous programming was not friendly at first.
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before Unity 2017, if a game developer wanted to handle asynchronous operations,
    a common scenario was waiting for a network response. The ideal solution was to
    use **coroutines** in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start a coroutine in Unity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the code, we use the `StartCoroutine` function to start a
    coroutine, and inside the coroutine, we can pause the execution by using `yield`
    statements. However, coroutines are still inherently single-threaded, just spread-out
    tasks across multiple frames, rather than multithreaded.
  prefs: []
  type: TYPE_NORMAL
- en: async/await
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unity introduced the `async/await` operator in Unity 2017, allowing game developers
    to use `async/await` in their games to write asynchronous code, but it''s still
    not like a normal .NET/C# program. This is because the Unity engine manages these
    threads by itself, and most of the logic runs on Unity''s main thread, which includes
    not only the C# code as scripts but also the engine''s C++ code. We can use the
    **Unity Profiler** tool to view the CPU timeline. As shown in the following screenshot,
    the Unity engine runs scripts in the main thread by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – The Timeline of CPU'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.07_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – The Timeline of CPU
  prefs: []
  type: TYPE_NORMAL
- en: There are 50 GameObjects in this scene, and each of them is attached with a
    **MainThreadExample** script. You can see that the **Update** functions in these
    50 scripts are executed one by one.
  prefs: []
  type: TYPE_NORMAL
- en: You can multithread different types of tasks; for example, doing some Vector3
    math in a separate thread is no problem. But as long as the task needs to access
    the transform or GameObject outside Unity's main thread, the program will throw
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. The purpose of the following code is to change the
    scale of the GameObject and use `async/await` to perform the operation in another
    thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach this script to a GameObject in the scene, then click the **Play** button
    in the Unity editor to run the script. The result of the operation is that the
    scale of the GameObject has not changed, and a **UnityException: get_transform
    can only be called from the main thread** exception is thrown, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Exception'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.08_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8 – Exception
  prefs: []
  type: TYPE_NORMAL
- en: So, you should take care of this and not access transforms or GameObjects from
    threads other than Unity's main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, we can do math in a separate thread. So, in order
    to make the previous code work correctly, we can just calculate the scale value
    in different threads, access the `Transform` component, and modify the `localScale`
    property of it in Unity''s main thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, everything is going well and if we view the Unity Profiler again,
    we can find the timeline of these threads in the **Scripting Threads** section,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Scripting threads'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.09_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.9 – Scripting threads
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as a developer, there are still many challenges with writing thread-safe
    and efficient code even in C#, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Thread-safe code is hard to write.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Race conditions, where the result of a computation depends on the order in which
    two or more threads are scheduled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inefficient context switching; is time-consuming when switching threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C# Job System in Unity is a solution that focuses on solving these challenges
    so that we can enjoy the benefits of multithreading to develop games. Next, let's
    explore how to use the C# Job System in our Unity projects.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the C# Job System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Job System** was originally the internal thread management system of the
    Unity engine, but with the growth of developers' demands for multithreaded programming
    in Unity, Unity introduced the C# Job System, which allows developers to write
    multithreaded parallel processing code painlessly in C# scripts to improve games'
    performance. Game developers do not need to implement complex thread pools themselves
    to keep each thread running properly. The C# Job System is integrated with Unity's
    native Job System, and C# script code and Unity engine's C++ code share threads.
  prefs: []
  type: TYPE_NORMAL
- en: This form of cooperation allows game developers to write code in the way required
    by the Job System; the Unity engine handles multithreading for game developers
    and developers no longer have to worry about problems that may be encountered
    when writing multithreaded code, because the C# Job System will not create any
    managed threads, but instead use Unity's worker threads on multiple cores, giving
    them tasks, which are called **jobs** in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Jobs package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to install and enable the **Job System** in your project, you need
    to install the **Jobs** package first, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – The Jobs package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.10_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.10 – The Jobs package
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the **Jobs** package is currently still in the preview state, as shown
    in the preceding screenshot, and the Unity Package Manager does not display packages
    in the preview state by default. So, if you can''t find the **Jobs** package,
    then you need to follow these steps to allow showing the package in the preview
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Project Settings** window by clicking the **Edit** | **Project Settings…**
    item in the Unity editor toolbar, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Opening the Project Settings window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.11_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.11 – Opening the Project Settings window
  prefs: []
  type: TYPE_NORMAL
- en: Next, click the **Package Manager** item in the category list on the left to
    open the **Package Manager** settings panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Opening the Package Manager settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.12_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.12 – Opening the Package Manager settings
  prefs: []
  type: TYPE_NORMAL
- en: In the following screenshot, you can see that the **Enable Preview Packages**
    option is not selected by default. Let's check it to enable preview packages in
    the Unity Package Manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Enable Preview Packages'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.13_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.13 – Enable Preview Packages
  prefs: []
  type: TYPE_NORMAL
- en: Once done, you should be able to find the **Jobs** package and install it into
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at an example to understand how to use the Job System to improve
    the performance of a game.
  prefs: []
  type: TYPE_NORMAL
- en: How to use the C# Job System
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we will first use Unity's traditional way, that is, the GameObject+Components
    way, to create 10,000 cartoon cars in a game scene, with each car containing a
    Movement component to move it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – The car models'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.14_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.14 – The car models
  prefs: []
  type: TYPE_NORMAL
- en: 'The car models used in this example are from the Unity Asset Store, and you
    can download them here: [https://assetstore.unity.com/packages/3d/vehicles/land/mobile-toon-cars-free-99857](https://assetstore.unity.com/packages/3d/vehicles/land/mobile-toon-cars-free-99857).
    Then, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our first C# script, named `CarSpawner`, to generate the cars
    in the scene. In this script, we can create 10,000 new car instances from the
    car prefab by pressing the spacebar. As you can see in the following code, inside
    the `Update` method, we use the `Input.GetKeyDown(KeyCode.Space)` method to check
    whether the spacebar is pressed. If the spacebar is pressed, the `CreateCars`
    method is called to create new car instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we also need another script that will be attached to each of the car
    objects to move them. As you can see, this `Movement` script is relatively simple;
    it moves the GameObject forward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, attach this `Movement` script to the car prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.15 – The car Prefab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.15_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.15 – The car Prefab
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Play** button in the Unity editor to run the example and press
    the spacebar to generate 10,000 cars in the scene. As shown in the following screenshot,
    when there are 10,000 cars in the scene, the value of **Frames per Second** (**FPS**)
    is around **12**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.16 – The FPS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.16_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.16 – The FPS
  prefs: []
  type: TYPE_NORMAL
- en: We can view the CPU usage timeline of this example. Press *Ctrl* + *7* or click
    the `Movement.Update` for these 10,000 cars happens on the main thread while the
    job workers are idle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.17 – The Timeline of CPU'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.17_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.17 – The Timeline of CPU
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, when we see all the logic being executed on the main thread, as game
    developers we definitely want to be able to have some operations running on other
    threads. However, before we start writing some real code, we should cover a little
    bit about how to write jobified code in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unity''s Job System, each job can be seen as a method call. When writing
    a new job, you must follow these points:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to ensure that the data is distributed contiguously in memory, and
    to reduce **Garbage Collection** (**GC**) pressure, a job must be a value type,
    which means it must be a struct, never a class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new job struct needs to implement the `IJob` interface. There are many variants
    of the `IJob` interface, such as `IJobParallelFor`, `IJobParallelForBatch`, and
    `IJobParallelForTransform`. When implementing these interfaces, we need to implement
    the `Execute` method. It is worth noting that the parameters required by the `Execute`
    method are different when implementing different variants of the `IJob` interface,
    which allows us to handle different scenarios. For example, a new `job` implementing
    the `IJobParallelForTransform` interface can access transform data, such as position,
    rotation, and scale data, in parallel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code is for a sample job that implements the `IJobParallelFor`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a new job, but how do we make it work? Well, we have to schedule
    it. Usually, scheduling a job is very simple. The following code demonstrates
    how to schedule it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve covered some basics on how to create a new job and how to make it work.
    Now, let''s use the Job System to rewrite the `Movement` script to distribute
    the operation of moving the cars to different threads to run:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s create a job that moves cars. You can find the new `MotionJob`
    script below. `MotionJob` is a struct rather than a class and implements the `IJobParallelForTransform`
    interface, so this job can access the position data and modify it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need another script called `JobsManager` to create the job, provide
    it with transform data (specifically in the script, we use the `TransformAccessArray`
    struct to provide this data), and schedule it. Also, this script is similar to
    the previous `CarSpawner` script. It checks whether the spacebar is pressed and
    creates 10,000 cars in the game scene if the spacebar is pressed. First, let''s
    see how to create and schedule a job on Unity''s Job worker thread. In the `Update`
    method, we create a new `MotionJob` object and pass data to it, such as `deltaTime`,
    `speed`, and `direction` to create a new job, then we call `_motionJob.Schedule`
    to distribute the job to different threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s see how to create cars in the code. Since we only need the position
    data for these cars this time, in the `CreateCars` method, we add the car''s transform
    data to `TransformAccessArray` so that the job we just created can access `TransformAccessArray`
    to get that transform data. The `CreateCars` method is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This time, we no longer need to attach the Movement component to each car instance
    at runtime to move the car, so we need to remove the **Movement** component that
    was previously attached to the car prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Removing the Movement component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.18_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.18 – Removing the Movement component
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Play** button in the Unity editor to run the example and press
    the spacebar to generate 10,000 cars in the scene. As shown in the following screenshot,
    when there are 10,000 cars in the scene, this time the value of FPS is around
    **19**. In a scene with 10,000 cars in motion, the game''s frame rate nearly doubled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.19 – The FPS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.19_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.19 – The FPS
  prefs: []
  type: TYPE_NORMAL
- en: Let's press *Ctrl* + *7* or click the **Window** | **Analysis** | **Profiler**
    item in the Unity editor toolbar to open the **Profiler** window to view the CPU
    usage timeline this time. Here, we can see that **MotionJob** is spread over multiple
    Job worker threads in Unity, instead of running on the main thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.20 – Running on Job worker threads'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.20_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.20 – Running on Job worker threads
  prefs: []
  type: TYPE_NORMAL
- en: Through this example, we saw how to use the Job System in Unity to improve the
    running performance of the game.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed topics related to using asynchronous programming
    in Unity. Next, we will discuss another important topic in DOTS – namely, ECS.
  prefs: []
  type: TYPE_NORMAL
- en: Working with ECS in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity has always been centered around the concept of components; for example,
    we can add a Movement component to a GameObject so that the object can move. We
    can also add a Light component to the GameObject to make it emit light. We also
    add the AudioSource component, which can make the GameObject emit sound. In this
    case, the GameObject is a container to which game developers can attach different
    components to provide different behaviors. We can call this architecture a **GameObject-Components**
    relationship. In this architecture, we use the traditional OOP programming paradigm
    to write components, coupling data and behavior together. In the previous section,
    *Object-oriented design pattern versus DOTS*, we also discussed the impact of
    OOP on game performance.
  prefs: []
  type: TYPE_NORMAL
- en: So, to address these issues, Unity introduced ECS, which allows developers to
    write data-oriented code in Unity. In ECS, data and behavior are separated, which
    can greatly improve memory usage efficiency and thus improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The so-called **behavior** here, specifically, is **methods**.
  prefs: []
  type: TYPE_NORMAL
- en: 'As its name suggests, ECS consists of three parts, namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will introduce them respectively in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Entity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using ECS, we talk more about entities, not GameObjects. You might think
    that there is not much difference between an entity and a GameObject, because
    you might think of an entity as a container for components, just like a GameObject.
    However, this is not the case. An entity is just an integer ID. It is neither
    an object nor a container. Its function is to associate the data of its components
    together.
  prefs: []
  type: TYPE_NORMAL
- en: EntityManager and World
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you want to create new entities in your own C# code, Unity provides the `EntityManager`
    class to manage entities, which you can use to create entities, update entities,
    and destroy entities. ECS uses the `World` class to organize entities, and only
    one `EntityManager` instance can exist in a `World`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we click the `World` by default, so we can get the `EntityManager` that
    exists in the default `World` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Archetypes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'ECS combines all entities with the same set of components in memory. ECS refers
    to this type of component set as an `EntityManager` to create an Archetype that
    holds a set of components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: NativeArray
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Undoubtedly, we also need an array to hold the newly created entities. But in
    ECS, we will use a different container than a traditional array in .NET programming,
    namely, `NativeArray`.
  prefs: []
  type: TYPE_NORMAL
- en: '`NativeArray` provides a C# wrapper for accessing native memory so that game
    developers can share data directly between managed and native memory. Therefore,
    operations on `NativeArray` do not generate GC of managed memory like common arrays
    in .NET and require elements to be value types, that is, structs. The following
    pseudocode shows how to create a new `NativeArray` and create new entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In ECS, there are also components, but the component in ECS is a different concept
    from the Movement "component" mentioned when talking about the GameObject-Components
    relationship previously. Before ECS was introduced, we usually thought of `MonoBehaviour`
    attached to GameObjects as components. `MonoBehaviour` contains data and behavior.
    ECS is different because entities and components do not have any behavioral logic;
    they only contain data, and logical operations will be handled by the system in
    ECS.
  prefs: []
  type: TYPE_NORMAL
- en: 'A component must be a struct rather than a class and needs to implement one
    of the following interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IComponentData`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ISharedComponentData`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IBufferElementData`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ISystemStateComponentData`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ISharedSystemStateComponentData`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `IComponentData` interface is commonly used. The following uses it as an
    example to show how to create a new component in ECS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to add this `SampleComponent` to a GameObject in the scene, you
    will find that you can''t because it doesn''t inherit from the `MonoBehaviour`
    class. But you can add the `[GenerateAuthoringComponent]` attribute to your component
    to mark it as an authoring component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: An authoring component can be added to a GameObject even if it does not inherit
    from MonoBehaviour.
  prefs: []
  type: TYPE_NORMAL
- en: System
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We already know that when using ECS, data and behavior are decoupled. In ECS,
    all logic is handled by **systems**, which takes a group of entities and performs
    the requested behavior based on the data contained in the grouped entities. As
    we already know, using ECS can make our code access memory efficiently, and in
    fact, systems in ECS can also be combined with the C# Job System to efficiently
    utilize multithreading and further improve game performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a new system in ECS. The following code is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, this new `SampleSystem` inherits the `SystemBase` class, and
    there is a `ScheduleParallel` Lambda function`Entites.ForEach` loop in `OnUpdate`
    for scheduling work to Unity's Job worker threads using the C# Job System.
  prefs: []
  type: TYPE_NORMAL
- en: Through these brief introductions, I believe you have a general understanding
    of ECS. Next, let's install ECS in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Entities and Hybrid Renderer packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to install and enable ECS in your project, you need to install the
    **Entities** package first, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21 – The Entities package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.21_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.21 – The Entities package
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding screenshot, the **Entities** package is also in the
    preview state. Although we checked the **Enable Preview Packages** option in the
    previous subsection, the Package Manager still does not display this package.
    This is because starting from Unity 2020.1, this package is no longer hosted on
    Unity Registry, but hosted on GitHub, so we need to follow these steps to install
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Package Manager window can be opened by clicking the **Window** | **Package
    Manager** item in the Unity editor toolbar, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.22 – Opening the Package Manager window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.22_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.22 – Opening the Package Manager window
  prefs: []
  type: TYPE_NORMAL
- en: Click the **+** button in the upper-left corner to add packages from other sources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.23 – Adding packages from other sources'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.23_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.23 – Adding packages from other sources
  prefs: []
  type: TYPE_NORMAL
- en: Click `com.unity.entities`, so we enter it and click the **Add** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.24 – Adding the Entities package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.24_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.24 – Adding the Entities package
  prefs: []
  type: TYPE_NORMAL
- en: Then, wait for the package installation to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.25 – Installing a Git package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.25_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.25 – Installing a Git package
  prefs: []
  type: TYPE_NORMAL
- en: Once done, you should be able to find the **Entities** package installed in
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we also need another package, the **Hybrid Renderer** package. This
    package helps us render ECS entities.
  prefs: []
  type: TYPE_NORMAL
- en: The process of installing the `com.unity.rendering.hybrid`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.26 – Installing the Hybrid Renderer package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.26_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.26 – Installing the Hybrid Renderer package
  prefs: []
  type: TYPE_NORMAL
- en: Wait for the package installation to complete, and then you'll find it's installed
    in your project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.27 – The Hybrid Renderer package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.27_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.27 – The Hybrid Renderer package
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will use the previous example to understand how to use ECS to further
    improve the performance of a game based on the use of the C# Job System.
  prefs: []
  type: TYPE_NORMAL
- en: How to use ECS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we will create a new component, entities, and a new system
    and use the C# Job System to distribute work to Unity's Job worker threads. Let's
    get started!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a component script just for the data. In this case, it''s
    the speed of cars:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we also need a normal script called `CarsManager` to access the `EntityManager`
    object in `World` to create archetypes and entities. Here, we''ll add some premade
    components from ECS to these entities, such as `Translation`, which contains only
    entity location data, and `RenderMesh`, which contains entity graphics attribute
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, attach this **CarsManager** script to a GameObject in the scene and assign
    the appropriate properties, such as the car's mesh, and speed values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.28 – The CarsManager object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.28_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.28 – The CarsManager object
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have set up the components and entities. The next thing to
    do is to create the system. The system is also where the game logic is handled.
    In this example, we''ll use the system to move these cars. As you can see in the
    following code, instead of searching for components in the traditional `Update`
    method and then operating on each instance at runtime, with ECS, we just statically
    declare that we need to process all entities with `Translation` and `CarSpeed`
    components attached. To find all of these entities, we just need to find the archetypes
    that match a specific "components set," which is done by the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Click the **Play** button in the Unity editor to run the example. As shown
    in the following screenshot, when there are 10,000 cars in the scene, this time
    the value of FPS is around **260**! In this scene with 10,000 moving cars, using
    ECS increased the game''s frame rate by nearly 30 times compared to the original
    traditional implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.29 – Using ECS to improve game performance'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.29_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.29 – Using ECS to improve game performance
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the **Hierarchy** panel of this game scene, we won't see any car
    objects in the list. This is because when using ECS, traditional GameObjects and
    traditional components are not created, but entities and components from ECS are
    used to organize data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.30 – No GameObjects are created'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.30_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.30 – No GameObjects are created
  prefs: []
  type: TYPE_NORMAL
- en: In order to see the entities, components, and system used in the scene, we can
    use the **Entity Debugger** to view this information. By clicking the **Window**
    | **Analysis** | **Entity Debugger** item from the toolbar in the Unity editor,
    we can open the **Entity Debugger** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.31 – Opening the Entity Debugger window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.31_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.31 – Opening the Entity Debugger window
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see a list of entities as well as a list of systems in the Entity Debugger
    window. As shown in the following screenshot, there are 10,002 entities, including
    10,000 car entities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.32 – The Entity Debugger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.32_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.32 – The Entity Debugger
  prefs: []
  type: TYPE_NORMAL
- en: If we select an entity in the entity list, the **Inspector** window for that
    entity will open, showing all components of this entity and data for those components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.33 – Inspector window for an entity'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.33_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.33 – Inspector window for an entity
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s view the CPU usage timeline in the **Profiler** window. If
    you forget how to open this window, just press *Ctrl* + *7* or click **Window**
    | **Analysis** | **Profiler** in the Unity Editor toolbar. Here, we can see that
    the ECS work is distributed to multiple Job worker threads by the C# Job System
    as we expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.34 – ECS and Job System'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.34_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.34 – ECS and Job System
  prefs: []
  type: TYPE_NORMAL
- en: Through the preceding steps, we changed the traditional GameObject-Components-style
    development method in Unity to the development method using ECS, adopting the
    data-oriented design method and using the C# Job System, making full use of multithreaded
    programming, and improving the running efficiency of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's discuss another technology in DOTS, the Burst compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Using C# and the Burst compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Burst compiler** in Unity is an advanced compiler technology that can
    be used to convert a subset of .NET code into highly optimized native code for
    Unity games. It should be noted that it is not a general-purpose compiler, but
    a compiler designed for Unity to make Unity games run faster.
  prefs: []
  type: TYPE_NORMAL
- en: Burst works on a subset of C# called HPC#, so let's explore this subset of C#
    next.
  prefs: []
  type: TYPE_NORMAL
- en: High-Performance C# (HPC#)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HPC# is a subset of C#. The standard C# language uses the concepts of "objects
    on the heap" and uses the garbage collector to reclaim unused memory automatically.
    So, as developers, we cannot control how the data is allocated in memory. On the
    other hand, HPC# doesn't support reference types, namely, classes, to avoid allocation
    in the heap and disable the garbage collector. In addition to these, some functions,
    such as `try-catch-finally`, are not supported in HPC# as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, we can use the following types in HPC#:'
  prefs: []
  type: TYPE_NORMAL
- en: Value types, such as int, float, bool, and char, enum types, and struct types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NativeArray` in Unity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling the Burst compiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Burst compiler is usually used with the C# Job System in Unity to optimize
    the code of a job. As we know, a job is a value type struct, so it is suitable
    for use with the Burst compiler. Enabling it in a job is very simple: just add
    the `[BurstCompile]` attribute to the job struct, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you also want to enable the Burst compiler in the Unity editor, you can find
    the settings for it at **Jobs** | **Burst** in the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.35 – Settings of Burst'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.35_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.35 – Settings of Burst
  prefs: []
  type: TYPE_NORMAL
- en: By reading this section, you should know what the Burst compiler and HPC# are.
    You should also know that the Burst compiler is often used with the C# Job System
    in Unity and how to enable it in job code to generate more efficient native binary
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter first introduced what data-oriented design is and the difference
    between data-oriented design and traditional object-oriented design. Then, we
    explored DOTS in Unity and the three technology modules that make it up, namely,
    the C# Job System, ECS, and the Burst compiler.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we discussed in detail how to implement asynchronous programming
    in Unity and used an example to demonstrate how to use Unity's C# Job System to
    implement multithreading to improve game performance.
  prefs: []
  type: TYPE_NORMAL
- en: We also introduced the concept of ECS, discussed the difference between ECS
    and the traditional GameObject-Components architecture in Unity, and demonstrated
    how to use ECS and the C# Job System to further improve game performance.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explored what the Burst compiler and HPC# are and how to enable
    them to generate highly optimized native code for your Unity games.
  prefs: []
  type: TYPE_NORMAL
- en: By reading this chapter, you should now understand how to work with DOTS correctly
    in Unity. In the next chapter, we will discuss topics related to assets management
    and serialization In Unity.
  prefs: []
  type: TYPE_NORMAL
