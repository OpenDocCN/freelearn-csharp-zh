<html><head></head><body>
<div><h1 class="chapterNumber">22</h1>
<h1 class="chapterTitle" id="_idParaDest-473">Case Study Extension: Developing .NET Microservices for Kubernetes</h1>
<p class="normal">In this chapter, we bridge the insights from <em class="italic">Chapter 21, Case Study</em>, where we explored the practical implementation of .NET microservices, with the foundational knowledge of Kubernetes presented in <em class="italic">Chapter 20, Kubernetes</em>. Our focus here is on preparing .NET code for seamless integration with Kubernetes, encompassing the complete development cycle—from coding to debugging, and even troubleshooting post-deployment challenges.</p>
<p class="normal">We will guide you through the process of setting up a development workstation optimized for Kubernetes, learn the intricacies of packaging code with Docker, and understand how to organize your codebase for flawless execution across varied environments, such as Docker Desktop, local minikube installations, and production or staging Kubernetes clusters.</p>
<p class="normal">Also, this chapter delves into the nuances of remote debugging, providing you with the necessary skills to efficiently troubleshoot and debug your application. Here, you will learn how to prepare each developer workstation, how to package the code with Docker, and how to organize the code so that it can immediately run both on the developer Docker Desktop, on the developer’s local Minikube installation, and on the production/staging Kubernetes clusters, without modifications.</p>
<p class="normal">By the end of the chapter, you will have mastered remote debugging techniques for applications in production or staging environments, enabling swift issue resolution and system reliability.</p>
<p class="normal">More specifically, you will learn about the following topics:</p>
<ul>
<li class="bulletList">The tools needed for .NET Kubernetes development</li>
<li class="bulletList">Organizing the development process</li>
<li class="bulletList">Running your application in Minikube</li>
<li class="bulletList">Remote debugging of a Kubernetes application</li>
</ul>
<p class="normal">All concepts will be explained with the help of a previous example taken from <em class="italic">Chapter 21</em>,<em class="italic"> Case Study</em>, which we will adapt for Kubernetes execution.</p>
<p class="normal">You’ll adapt the <code class="inlineCode">GrpcMicroService</code> microservice from <em class="italic">Chapter 21</em>,<em class="italic"> Case Study</em>, seeing firsthand how a real-world application transitions to Kubernetes.</p>
<p class="normal">To fully leverage this chapter, fortify your understanding of Docker and Kubernetes as laid out in <em class="italic">Chapter 11</em>,<em class="italic"> Applying a Microservice Architecture to Your Enterprise Application</em>, and <em class="italic">Chapter 20</em>,<em class="italic"> Kubernetes</em>, which form the foundation for the advanced practices discussed herein.</p>
<h1 class="heading-1" id="_idParaDest-474">Technical requirements</h1>
<p class="normal">This chapter requires Visual Studio 2022 free Community Edition or better, with all the database tools installed.</p>
<p class="normal">You will also need these:</p>
<ul>
<li class="bulletList"><strong class="keyWord">WSL</strong> (<strong class="keyWord">Windows Subsystem for Linux</strong>) and <em class="italic">Docker Desktop for Windows</em>. Detailed instructions on how to install both of them are given in the <em class="italic">Technical requirements</em> section of <em class="italic">Chapter 11, Applying a Microservice Architecture to Your Enterprise Application</em>.</li>
<li class="bulletList">A Minikube installation that specifies Docker as a virtualization tool. Minikube installation is described in the <em class="italic">Using Minikube</em> section of <em class="italic">Chapter 20</em>, <em class="italic">Kubernetes</em>.</li>
<li class="bulletList">A SQL Server database that allows TCP/IP connections. You can’t use <em class="italic">SQL Server Express LocalDB</em>, which comes with Visual Studio installation, since it doesn’t allow TCP/IP connections. So you need either a full SQL Express installation or an Azure SQL Server database. More details on how to fulfill this requirement will be given in the <em class="italic">Tools needed for .NET Kubernetes development</em> section of this chapter.</li>
</ul>
<p class="normal">All the code of this chapter can be found in the GitHub repository associated with this book: <a href="https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E">https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E</a>.</p>
<h1 class="heading-1" id="_idParaDest-475">The Tools needed for .NET Kubernetes development</h1>
<p class="normal">Each single microservice can be unit-tested and debugged independently from the remainder of its application, with the technique you learned <em class="italic">Chapter 9</em>,<em class="italic"> Testing Your Enterprise Application</em>. You don’t need to package it inside a Docker image to do this.</p>
<p class="normal">However, debugging and performing<a id="_idIndexMarker1728"/> integration tests on the whole application or parts of it requires that all involved microservices interact and are packaged as in the final application.</p>
<p class="normal">You can use a staging environment to beta-test your application. Prior to staging deployment, ensure your application’s stability in the development environment to prevent time-consuming troubleshooting, because the staging environment doesn’t have all the facilities that are available in a development environment. Otherwise, troubleshooting all frequent bugs and crashes discovered in the staging environment might imply an unacceptable time cost.</p>
<p class="normal">Therefore, it is preferable to reach good application stability before deploying the application in a staging environment. Moreover, for easier and more efficient debug-fix cycles, it is desirable that all microservices run on each single developer machine. That’s why each developer workstation must be equipped with both Docker and Minikube.</p>
<p class="normal">Furthermore, the developer machine must be able to simulate all communications between microservices and between services and other storage media, like databases.</p>
<p class="normal">It is likely that, Minikube can run and simulate all communications that occur in an actual Kubernetes cluster, including when it runs on a single development machine.</p>
<p class="normal">We can also let all involved Docker images communicate among them before loading them on Minikube because Docker Desktop allows the creation of virtual networks that are accessible by the local Docker images.</p>
<p class="normal">Finally, both Docker and Minikube virtual networks automatically include the development machine that hosts them, so we can place storage services like disk volumes and databases on the development machine itself.</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_22_01.png"/></figure>
<p class="packt_figref">Figure 22.1: Minikube and Docker network structure</p>
<p class="normal">However, the sophisticated virtual <a id="_idIndexMarker1729"/>network facilities of both Docker and Kubernetes are not enough to ensure an efficient development and debugging environment, and further tools are needed.</p>
<p class="normal">Below are all the issues we need to<a id="_idIndexMarker1730"/> fix to configure an efficacious development-debugging environment and how to solve them:</p>
<ul>
<li class="bulletList">As a default, Visual Studio installs <em class="italic">SQL Server Express LocalDB</em> instead of <em class="italic">SQL Server Express</em>, and SQL Server Express LocalDB is not able to communicate via actual or virtual networks. Therefore, we need either an SQL Server Express installation or an external database.</li>
<li class="bulletList">Since Kubernetes nodes have just virtual addresses that are handled by the Kubernetes engine itself, a Visual Studio debugger can be attached to a running microservice just through the REST API of the Kubernetes engine. At the time of writing, the best tool available for Visual Studio is <em class="italic">Bridge to Kubernetes, </em>which, in turn, uses <em class="italic">kubectl</em> to interact with the API of any Kubernetes cluster, Minikube included. Unluckily, we can’t use the Kubectl installation that runs on the virtual machine that hosts Minikube as we did in <em class="italic">Chapter 20</em>,<em class="italic"> Kubernetes</em>, but we need an installation that runs directly in the development machine.</li>
</ul>
<p class="normal">We describe how to install <a id="_idIndexMarker1731"/>and configure all tools mentioned in the above points in two dedicated subsections.</p>
<h2 class="heading-2" id="_idParaDest-476">Installing and configuring SQL Server Express</h2>
<p class="normal">If you have access to an SQL Server instance <a id="_idIndexMarker1732"/>running in your development <a id="_idIndexMarker1733"/>machine, you can use that one. Otherwise, you can choose between creating an SQL Server database in Azure following the instructions contained<em class="italic"> </em>in<em class="italic"> Chapter 12</em>,<em class="italic"> Choosing Your Data Storage in the Cloud</em>, or installing a local instance of SQL Server Express:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Begin by downloading the SQL Server installer from <a href="https://www.microsoft.com/en-US/download/details.aspx?id=104781">https://www.microsoft.com/en-US/download/details.aspx?id=104781</a>.</li>
<li class="numberedList">You can freely choose between SQL Server Express and SQL Server Express Advanced, but please select a complete installation that includes both <strong class="screenText">SQL Server Management Studio</strong> and the<strong class="screenText"> SQL Server Management console</strong>.</li>
<li class="numberedList">Select to install SQL Server as the default instance on your machine (the default in the installation procedure).
    <p class="normal">Immediately after the installation, you must run SQL Server Management Console (just write this name in the Windows search box) to enable TCP/IP-based connections. In order to configure SQL Server properly, follow all the steps below.</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4">Once in the SQL Server Management Console, expand the <strong class="screenText">SQL Server Network Configuration</strong> node.</li>
<li class="numberedList">Select <strong class="screenText">Protocols for &lt;your instance name&gt;</strong>.</li>
<li class="numberedList">On the right detail pane, you should see all the available communication protocols.</li>
<li class="numberedList">Right-click on <strong class="screenText">TCP</strong>/<strong class="screenText">IP</strong> and select <strong class="screenText">Enable</strong>.</li>
<li class="numberedList">Now, TCP/IP is enabled but on a dynamic port. In order to impose a fixed port, right-click on the same TCP/IP node and select <strong class="screenText">Properties</strong>.</li>
</ol>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_22_02.png"/></figure>
<p class="packt_figref">Figure 22.2: Forcing a static IP address</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="9">Select the <strong class="screenText">IP Addresses</strong> tab.</li>
<li class="numberedList">You should see several IP addresses. These are all IP addresses that are associated with your <a id="_idIndexMarker1734"/>computer, and each of them executes<a id="_idIndexMarker1735"/> the next step.</li>
<li class="numberedList">Remove the <strong class="screenText">0</strong> that is in <strong class="screenText">TCP Dynamic Port</strong> and keep this field empty, and then write <code class="inlineCode">1433</code> in the <strong class="screenText">TCP Port</strong> field.</li>
<li class="numberedList">Once finished, click on the <strong class="screenText">OK</strong> button.</li>
<li class="numberedList">Now, you need to restart the SQL Server service. Select <strong class="screenText">SQL Server Services</strong> in the left pane.</li>
<li class="numberedList">Finally, in the right detail pane, right-click on <strong class="screenText">SQL Server &lt;your instance name&gt;</strong> and select <strong class="screenText">Restart</strong>.</li>
<li class="numberedList">Once installed, the SQL Server only has Windows authentication enabled. In order to use the instance on a non-Windows network, you must enable username-based authentication and define at least one administrative user. This is a necessary step because <a id="_idIndexMarker1736"/>Windows authentication will not work on Docker networks and Kubernetes.</li>
<li class="numberedList">You can do this in SQL<a id="_idIndexMarker1737"/> Server Management Studio. Once SQL Server Management Studio opens, it prompts you for an instance to connect with and for authentication information. The instance name of the database you just installed should be something like <code class="inlineCode">&lt;computer name&gt;\SQLEXPRESS</code>; select it and also select <strong class="screenText">Windows Authentication</strong>, as shown below:</li>
</ol>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_22_03.png"/></figure>
<p class="packt_figref">Figure 22.3: Connecting with SQL Server Management Studio</p>
<p class="normal">Once connected with the database, you can enable username-based authentication as follows:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Right-click on your server icon in Object Explorer and choose <strong class="screenText">Properties</strong>.</li>
<li class="numberedList">In the window that opens, select <strong class="screenText">Security</strong> in the left pane.</li>
<li class="numberedList">Select <strong class="screenText">SQL Server and Windows Authentication mode</strong>, as shown in the screenshot below:</li>
</ol>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_22_04.png"/></figure>
<p class="packt_figref">Figure 22.4: Enabling SQL Server authentication</p>
<p class="normal">In order to make your changes <a id="_idIndexMarker1738"/>effective, you must restart SQL Server. You <a id="_idIndexMarker1739"/>can do it by right-clicking on your server icon in Object Explorer and by selecting <strong class="screenText">Restart</strong>.</p>
<p class="normal">Now, you need to define at least one user by following the steps below:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Expand the <code class="inlineCode">Security</code> folder <a id="_idIndexMarker1740"/>under your server icon in Object Explorer.</li>
<li class="numberedList">Right-click on the <strong class="screenText">Logins</strong> folder and <a id="_idIndexMarker1741"/>select <strong class="screenText">New Login</strong>.</li>
<li class="numberedList">In the window that opens, insert a username.</li>
<li class="numberedList">Select <strong class="screenText">SQL Server authentication</strong>, insert a password, and confirm it by retyping the same password in the <strong class="screenText">Confirm password</strong> field, as shown in the screenshot below:</li>
</ol>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_22_05.png"/></figure>
<p class="packt_figref">Figure 22.5: Defining user name and password</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">Finally, right-click on <strong class="screenText">Server Roles</strong> and<a id="_idIndexMarker1742"/> enable the <strong class="screenText">sysadmin</strong> role to give all rights to the new user.</li>
</ol>
<p class="normal">And there you have it! Now, your<a id="_idIndexMarker1743"/> SQL Server instance can be used by both Docker and Minikube.</p>
<p class="normal">The next subsection explains how to configure Visual Studio for debugging applications running on Minikube or any other Kubernetes cluster.</p>
<h2 class="heading-2" id="_idParaDest-477">Enabling Kubernetes application debugging with Bridge to Kubernetes</h2>
<p class="normal">Since microservices running on Kubernetes have no fixed IP address and ports attached to them, only virtual addresses that are solved at runtime by Kubernetes, we can’t attach the Visual Studio debugger directly to any running microservice. That’s why we need software like Bridge to Kubernetes, which interacts with the Kubernetes API to enable debugging.</p>
<p class="normal">Bridge to Kubernetes is a Visual Studio extension that’s easy to install, but it requires Kubectl to be installed on your development machine, which presents a challenge, as there is no direct Windows installer for Kubectl. In this subsection, we’ll guide you through the process of installing both Bridge to Kubernetes and Kubectl, overcoming the lack of a direct Windows installer for the latter.</p>
<p class="normal">Bridge to Kubernetes enables Kubernetes application debugging by interacting with the Kubernetes API via Kubectl. However, it is not a debugger driver or a debugger extension. It does a completely different job; it asks you to select a service running in a Kubernetes cluster and reroute all communication with this service to a locally running Visual Studio POD replica instead of the actual cluster POD.</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_22_06.png"/></figure>
<p class="packt_figref">Figure 22.6: How Bridge to Kubernetes works</p>
<p class="normal">Therefore, the developer debugs a<a id="_idIndexMarker1744"/> local copy of the POD code but in exactly the same dynamic Kubernetes environment as the original POD. This way, you have all the facilities <a id="_idIndexMarker1745"/>offered by a usual local debugging session, but while you are debugging it, your code interacts with the actual Kubernetes cluster you need to fix.</p>
<p class="normal">Bridge to Kubernetes doesn’t work just with Minikube; it works with any Kubernetes cluster. Thus, you can use it for debugging the whole application on your development machine, and also for debugging the staging application or the production application.</p>
<p class="normal">Since you debug just the local code and not the deployed code, you are not forced to compile an application in debug mode in order to debug it. You can deploy the application with all compilation optimizations you want without caring about possible debugging needs; it is enough to have local copies of the PODs you would like to debug compiled in debug mode.</p>
<p class="normal">You will learn how to use Bridge to Kubernetes in practice in the <em class="italic">Remote debugging of a Kubernetes application</em> section. The remainder of this section will explain all the steps needed to install Bridge to Kubernetes on a development machine.</p>
<p class="normal">First of all, you need to install Kubectl. The simplest way to do it is by using the Chocolatey package manager.</p>
<div><p class="normal">Chocolatey is a package manager like NuGet. Similarly, it consists of a public repository containing all packages and a client you must install on your machine, in order to interact with the public repository.</p>
</div>
<p class="normal">If you don’t have Chocolatey already installed, you can install it from a PowerShell prompt, as follows:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Search <strong class="screenText">PowerShell</strong> in the Windows search box.</li>
<li class="numberedList">Right-click on the PowerShell link and select to execute it as an administrator.</li>
<li class="numberedList">Finally, execute the PowerShell command <a id="_idIndexMarker1746"/>suggested on the official Chocolatey page: <a href="https://chocolatey.org/install#individual">https://chocolatey.org/install#individual</a>.</li>
</ol>
<p class="normal">The PowerShell command to<a id="_idIndexMarker1747"/> execute is repeated below for your convenience:</p>
<pre class="programlisting code"><code class="hljs-code">Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
</code></pre>
<p class="normal">Once installation is complete, run <code class="inlineCode">choco -?</code> to verify that the installation was successful and that the Chocolatey user interface works properly.</p>
<p class="normal">With Chocolatey installed, installing <a id="_idIndexMarker1748"/>Kubectl is super easy; just open a Windows Command Prompt as an administrator and type this:</p>
<pre class="programlisting con"><code class="hljs-con">choco install kubernetes-cli
</code></pre>
<p class="normal">You can check whether everything works properly by typing <code class="inlineCode">kubectl version –client</code>.</p>
<p class="normal">Kubectl should be configured to access a specific cluster, but when you start Minikube with <code class="inlineCode">minikube start</code>, Minikube automatically configures it to access the local Minikube cluster, so you don’t need to worry about Kubectl configuration.</p>
<p class="normal">Now, you are ready to install Bridge to Kubernetes, as follows:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Open Visual Studio and select <strong class="screenText">Extensions -&gt; Manage Extensions</strong>.</li>
<li class="numberedList">Search <code class="inlineCode">Bridge to Kubernetes</code>.</li>
<li class="numberedList">Select it and install it.</li>
</ol>
<p class="normal">And there you have it! Now, your development machine is ready for .NET Kubernetes development. The next section<a id="_idIndexMarker1749"/> details the development process and explains<a id="_idIndexMarker1750"/> how to modify an existing project to run with both the local Docker installation and any Kubernetes cluster.</p>
<h1 class="heading-1" id="_idParaDest-478">Organizing the development process</h1>
<p class="normal">Since Visual Studio and other IDEs offer <a id="_idIndexMarker1751"/>good support for Docker and a good integration with Docker Desktop, the best option for most of the development time is working with just Dockerized images without running them inside of Minicube.</p>
<p class="normal">In fact, as we will see shortly, once we have added Docker support to our projects, it is enough to click the Run Visual Studio button to start all our Dockerized microservices and to enable them to communicate through a Docker network. Conversely, running our application in Minikube requires several manual steps, and it takes some time to load the Docker images on Minikube and to create all the necessary Kubernetes objects.</p>
<p class="normal">Doing this in Visual Studio is super easy. It is enough to add Docker support for all microservice projects in your solution and to select the option of launching several projects simultaneously when the solution is run. Then, Visual Studio will automatically perform all the necessary tasks when your solution is run, namely:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Compile and link all code.</li>
<li class="numberedList">Build all microservice Docker images.</li>
<li class="numberedList">Insert the Docker images into the Docker Desktop local repository.</li>
<li class="numberedList">Launch all Docker images simultaneously.</li>
<li class="numberedList">Attach the debugger to all launched Docker images.</li>
</ol>
<p class="normal">You just need to take care of microservice communication by defining a virtual network with Docker Desktop.</p>
<p class="normal">We will explain all the details of the development process with a simple example in the next subsection.</p>
<h2 class="heading-2" id="_idParaDest-479">gRPC worker microservices revisited</h2>
<p class="normal">In the code associated with <em class="italic">Chapter 14</em>,<em class="italic"> Implementing Microservices with .NET</em>, and described in <em class="italic">Chapter 21</em>,<em class="italic"> Case study,</em> there is <a id="_idIndexMarker1752"/>a solution called <code class="inlineCode">GrpcMicroService</code>. The solution is composed of two microservices. The first microservice simulates purchases by generating random data, while the second one uses this data to compute statistics that it stores in a database. The whole code is available in the <code class="inlineCode">ch15-&gt;GrpcMicroService</code> folder of the GitHub repository associated with the book.</p>
<p class="normal">Let’s make a copy of the whole <code class="inlineCode">GrpcMicroService</code> folder and call it <code class="inlineCode">GrpcMicroServiceDocker</code>.</p>
<p class="normal">The steps below describe all <a id="_idIndexMarker1753"/>the modifications that need to be made to Docker to enable all microservices.</p>
<h3 class="heading-3" id="_idParaDest-480">Adding Docker support to GrpcMicroServiceDocker</h3>
<p class="normal">Open the <code class="inlineCode">GrpcMicroServiceDocker</code> solution in<a id="_idIndexMarker1754"/> Visual Studio. The solution<a id="_idIndexMarker1755"/> contains two microservices, called <code class="inlineCode">FakeSource</code> and <code class="inlineCode">GrpcMicroservice</code>. The last project is just the data layer of the <code class="inlineCode">GrpcMicroservice</code> project.</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_22_07.png"/></figure>
<p class="packt_figref">Figure 22.7: GrpcMicroServiceDocker solution</p>
<p class="normal">The solution is already configured to launch the two microservices when it is run. In other cases, you might need to configure multiple project launches by right-clicking on the solution node and selecting <strong class="screenText">Set Startup Projects….</strong></p>
<p class="normal">Adding Docker support to both microservices is super easy. Right-click on each microservice project within Visual Studio. Navigate to <strong class="screenText">Add</strong>, and then select <strong class="screenText">Docker Support</strong>. If prompted, choose the operating system for your Docker environment. If you are using Minikube, you must select <strong class="screenText">Linux</strong>.</p>
<p class="normal">All the necessary Docker files are <a id="_idIndexMarker1756"/>automatically created and configured by Visual Studio. And that’s it!</p>
<p class="normal">Now, we need to move the<a id="_idIndexMarker1757"/> database to the newly installed SQL Server instance.</p>
<h3 class="heading-3" id="_idParaDest-481">Moving GrpcMicroServiceDocker to SQL Server Express</h3>
<p class="normal">You need to change all connection<a id="_idIndexMarker1758"/> strings and configure the string that will be used at runtime so that it can be used from inside a Docker image.</p>
<p class="normal">First of all, let’s change the connection string that is inside <code class="inlineCode">GrpcMicroServiceStore-&gt; LibraryDesignTimeDbContextFactory.cs</code>. The new string should be something like this:</p>
<pre class="programlisting code"><code class="hljs-code">@"Server=&lt;your machine name&gt;\&lt;your instance name&gt;;Database=grpcmicroservice;Trusted_Connection=True;Trust Server Certificate=True;MultipleActiveResultSets=true"
</code></pre>
<p class="normal">where the instance name should be <code class="inlineCode">SQLEXPRESS</code>. You can take the above connection string directly from Visual Studio, as follows:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Open the <strong class="screenText">SQL Server Object Explorer</strong> window.</li>
<li class="numberedList">Right-click on the <strong class="screenText">SQL Server</strong> node and select <strong class="screenText">Add SQL Server</strong>.</li>
<li class="numberedList">In the window that opens, Visual Studio should enumerate all available SQL Server instances. Choose the newly installed SQL Server instance.</li>
<li class="numberedList">Select <strong class="screenText">Windows authentication</strong> and connect.</li>
<li class="numberedList">A new server icon should appear below the <strong class="screenText">SQL Server</strong> node. Select it.</li>
<li class="numberedList">In the <strong class="screenText">Visual Studio Properties</strong> tab, you should see all database connection properties. Take the value of <strong class="screenText">General-&gt; Connection string</strong>.</li>
</ol>
<p class="normal">Now, you have to run all migrations to recreate the database in the new SQL Server instance. As usual, right-click on the library project and define it as a startup project. Then, in the Visual Studio Package Manager Console <strong class="screenText">Default Project</strong>, select <code class="inlineCode">GrpcMicroServiceStore</code> and issue the <code class="inlineCode">Update-Database</code> command.</p>
<p class="normal">After the new database has been created, restore the two microservices as simultaneous startup projects.</p>
<p class="normal">Finally, update the runtime connection string in <code class="inlineCode">GrpcMicroService -&gt; appsettings.json</code>. If the newly<a id="_idIndexMarker1759"/> installed SQL Server instance has been defined as the default instance on your machine, the connection string below should work:</p>
<pre class="programlisting code"><code class="hljs-code">Server=host. Docker.internal;Database=grpcmicroservice;User Id=&lt;your user name&gt;;Password=&lt;your user password&gt;;Trust Server Certificate=True;MultipleActiveResultSets=true"
</code></pre>
<p class="normal">where <code class="inlineCode">host. Docker.internal</code> is the URL used by Docker Desktop images to communicate with the host machine. If your SQL Server is not the machine’s default instance, you must replace <code class="inlineCode">host.docker.internal</code> with <code class="inlineCode">host.docker.internal\&lt;your instance name&gt;</code>.</p>
<p class="normal">If, instead, you are using an external database, you can use its standard connection string with no modifications.</p>
<h3 class="heading-3" id="_idParaDest-482">Enabling communication among microservices with a Docker virtual network</h3>
<p class="normal">Creating a Docker virtual network in <a id="_idIndexMarker1760"/>Docker Desktop is easy; just open a Windows console and run the following command:</p>
<pre class="programlisting con"><code class="hljs-con">docker network create test-net,
</code></pre>
<p class="normal">where <code class="inlineCode">test-net</code> is the virtual network name. Once the network has been defined when we create a container instance from an image, we can specify that the launched container must be connected to our network and its hostname, with something like:</p>
<pre class="programlisting con"><code class="hljs-con">docker run --rm --net test-net --name grpcmicroservice &lt;microservice image name&gt;,
</code></pre>
<p class="normal">Here, the <code class="inlineCode">rm</code> option specifies that the container must be destroyed when it stops running, <code class="inlineCode">--net test-net</code> specifies the network where to connect the created container, and -<code class="inlineCode">-name grpcmicroservice</code> is the name of the created container that will also act as its hostname in the network.</p>
<p class="normal">We need to add to our <code class="inlineCode">test-net</code> just the containers that must act as servers—in our case, the <code class="inlineCode">GrpcMicroService</code> microservice.</p>
<p class="normal">Since Visual Studio automatically issues all necessary <code class="inlineCode">run</code> Docker commands when the solution is launched, we need just to specify the command options to add to Visual Studio’s original command. They must be specified in each microservice project file with the <code class="inlineCode">DockerfileRunArguments</code> parameter. Below is how to modify the <code class="inlineCode">GrpcMicroService</code> microservice project file, which is the only microservice acting as a server:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;PropertyGroup&gt;
&lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
&lt;Nullable&gt;enable&lt;/Nullable&gt;
&lt;UserSecretsId&gt;b4f03ff2-033c-4d5e-a33b-65f26786b052&lt;/UserSecretsId&gt;
&lt;DockerDefaultTargetOS&gt;Linux&lt;/DockerDefaultTargetOS&gt;
<strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">DockerfileRunArguments</strong><strong class="hljs-tag-slc">&gt;</strong>
<strong class="hljs-slc">--rm --net test-net --name grpcmicroservice</strong>
<strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">DockerfileRunArguments</strong><strong class="hljs-tag-slc">&gt;</strong>
&lt;/PropertyGroup&gt;
</code></pre>
<p class="normal">No modification is required to the <code class="inlineCode">FakeSource</code> project, since it must not act as a server.</p>
<p class="normal">Now, the <code class="inlineCode">grpcmicroservice</code> hostname<a id="_idIndexMarker1761"/> must be used by <code class="inlineCode">FakeSource</code> to communicate with the <code class="inlineCode">GrpcMicroService</code> microservice.</p>
<p class="normal">Therefore, we must replace the URL in the <code class="inlineCode">FakeSource-&gt;Worker.cs</code> file with <code class="inlineCode">http://grpcmicroservice:8080</code>, as shown in the code snippet below:</p>
<pre class="programlisting code"><code class="hljs-code">…
using var channel = GrpcChannel.ForAddress("http://grpcmicroservice:8080");
var client = new Counter.CounterClient(channel);
…
</code></pre>
<p class="normal">where we use the <code class="inlineCode">8080</code> default Kestrel <code class="inlineCode">http</code> port to communicate with the microservice. Therefore, we need to the Kestrel options in <code class="inlineCode">GrpcMicroService -&gt;Program.cs</code> that force Kestrel to listen to the <code class="inlineCode">5000</code> port by replacing the code below:</p>
<pre class="programlisting code"><code class="hljs-code">builder.WebHost.ConfigureKestrel(options =&gt;
{
    options.ListenLocalhost(5000, o =&gt;
        o.Protocols = Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols.Http2);
});
</code></pre>
<p class="normal">Now, we are ready to run our project. To be sure that both microservices are started with Docker, please select <a id="_idIndexMarker1762"/>each of them as a single startup project, and then select <strong class="screenText">Docker</strong> in the select box next to the run solution Visual Studio button, as shown in the image below:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_22_08.png"/></figure>
<p class="packt_figref">Figure 22.8: Selecting Docker execution</p>
<p class="normal">After that, you can restore the simultaneous launch of both microservices. Visual Studio will launch both of them with Docker.</p>
<p class="normal">Now, we can launch the solution. In order to verify that the server is properly receiving purchase information, place a breakpoint in the <code class="inlineCode">GrpcMicroService-&gt;HostedServices-&gt; ProcessPurchases.cs</code> file inside of the <code class="inlineCode">if</code> block below:</p>
<pre class="programlisting code"><code class="hljs-code">if (toProcess.Count &gt; 0)
{
	…
}
</code></pre>
<p class="normal">In fact, <code class="inlineCode">GrpcMicroService</code> enters that block only if it finds something in the input queue.</p>
<p class="normal">You can also inspect the content of the <code class="inlineCode">dbo.Purchases</code> database table to verify that it is filled with statistics on purchases. You can do it from within <strong class="screenText">SQL Server Object Explorer</strong> by right-clicking on the table and choosing <strong class="screenText">View Data</strong>.</p>
<p class="normal">Having understood how to test our application with a Docker network, we must now understand when and how to test it with Minikube also.</p>
<h2 class="heading-2" id="_idParaDest-483">When to test the application with Minikube</h2>
<p class="normal">Most of the debug-fix cycle involved in the<a id="_idIndexMarker1763"/> application development can be done with the Docker virtual network.</p>
<div><p class="normal">Docker networks usually work well without creating issues. So, if you experience communication problems, they are probably due to misspelled service URLs. Therefore, please double-check the URLs in all calls to the microservice that does not receive communications.</p>
</div>
<p class="normal">From time to time, we need to test an application with Minikube for the following reasons:</p>
<ul>
<li class="bulletList">Both ReplicaSets and StatefulSets can be tested with Docker and Visual Studio, but we are limited to a <a id="_idIndexMarker1764"/>single POD for each of them.</li>
<li class="bulletList">We must also test the <code class="inlineCode">.yaml</code> Kubernetes configuration file, which might contain more complex objects like ingresses, permanent storage, secrets, and other complex configurations.</li>
<li class="bulletList">You might need to integrate your microservices with other modules developed by other teams.</li>
</ul>
<p class="normal">Therefore, each developer should spend most of their time testing a few microservices that strongly interact among them with the Docker virtual network, but from time to time, they should try a wider integration with Minikube. This can be done before committing their code at the end of the working day, or just before closing a development iteration of the agile application development process.</p>
<p class="normal">Having learned when and how to test the application with Minikube, we must learn how to load and run our application on Minikube.</p>
<h1 class="heading-1" id="_idParaDest-484">Running your application in Minikube</h1>
<p class="normal">When Visual Studio runs your microservices with Docker, it creates special images that also contain information needed by the<a id="_idIndexMarker1765"/> Visual Studio debugger and have a <code class="inlineCode">dev</code> version name. These special images can be run just from Visual Studio, and if you try to launch them manually, you will get an error. For the same reason, you can’t use them in Minikube.</p>
<p class="normal">Therefore, the first step for running your microservice in Minikube is to create different “standard” images. You can do this by right-clicking both the <code class="inlineCode">FakeSource</code> and <code class="inlineCode">GrpcMicroService</code> Docker files in Visual Studio Solution Explorer and by selecting <strong class="screenText">Build Docker Image</strong>.</p>
<p class="normal">This way, you will create a <code class="inlineCode">grpcmicroservice</code> and a <code class="inlineCode">fakesource</code> image, both with the <code class="inlineCode">latest</code> version name, as shown in the image below:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_22_09.png"/></figure>
<p class="packt_figref">Figure 22.9: Creating Minikube-ready Docker images</p>
<p class="normal">As a next step, you must start<a id="_idIndexMarker1766"/> Minikube:</p>
<pre class="programlisting con"><code class="hljs-con">minikube start
</code></pre>
<p class="normal">Now, you must load your Docker images inside of the Minikube images cache with the following commands:</p>
<pre class="programlisting con"><code class="hljs-con">minikube image load fakesource:latest
minikube image load grpcmicroservice:latest
</code></pre>
<p class="normal">You can verify that your images have been correctly loaded by listing all the images loaded in Minikube:</p>
<pre class="programlisting con"><code class="hljs-con">minikube image ls
</code></pre>
<p class="normal">Now, we need to define a .<code class="inlineCode">yaml</code> Kubernetes configuration file with two deployments and a service that forwards communications to <code class="inlineCode">grpcmicroservice</code>, which is the only microservice acting as a server. Let’s call it <code class="inlineCode">minikubedeploy.yaml</code>.</p>
<p class="normal">The definition of the <code class="inlineCode">grpcmicroservice</code> deployment is straightforward:</p>
<pre class="programlisting code"><code class="hljs-code">apiVersion: apps/v1
kind: Deployment
metadata:
  name: grpcmicroservice
  labels:
    app: statistics
spec:
  selector:
    matchLabels:
      app: statistics
      role: worker
  replicas: 1
  template:
    metadata:
      labels:
        app: statistics
        role: worker
    spec:
      containers:
      - name: grpcmicroservice
        image: grpcmicroservice:latest
        imagePullPolicy: Never
        resources:
          requests:
            cpu: 10m
            memory: 10Mi
        env:
        - name: ASPNETCORE_HTTP_PORTS
          value: "8080"
        ports:
        - containerPort: 8080
          name: http
</code></pre>
<p class="normal">The code above requires just one replica, but you can experiment with two or three replicas. The <code class="inlineCode">ASPNETCORE_HTTP_PORTS</code> environment variable is a standard ASP.NET setting that informs Kestrel on the <a id="_idIndexMarker1767"/>HTTP port where to listen.</p>
<div><p class="normal">The <code class="inlineCode">imagePullPolicy: Never</code> setting specifies the image caching policy within the Kubernetes cluster. It prevents Minikube from trying to download a fresher version of the image from the original source into its cache. We need this setting, since there is no “original source” containing our image because we uploaded the image directly to the Minikube cache with the <code class="inlineCode">minikube image load</code> command. </p>
<p class="normal">You must always specify this setting when images are not available in a shared image repository but are uploaded directly to the Minikube cache from the Docker Desktop local repository. Shared images, instead, do not need to be uploaded manually in the Minikube cache but can be simply referenced with their full URL in the Kubernetes <code class="inlineCode">.yaml</code> file.</p>
</div>
<p class="normal">All other settings are quite standard.</p>
<p class="normal">The definition of the <code class="inlineCode">fakesource</code> deployment is completely analogous but doesn’t contain information about <a id="_idIndexMarker1768"/>the container ports, since this microservice doesn’t act as a server:</p>
<pre class="programlisting code"><code class="hljs-code">apiVersion: apps/v1
kind: Deployment
metadata:
  name: fakesource
  labels:
    app: sale
spec:
  selector:
    matchLabels:
      app: sales
      role: source
  replicas: 1
  template:
    metadata:
      labels:
        app: sales
        role: source
    spec:
      containers:
      - name: fakesource
        image: fakesource:latest
        imagePullPolicy: Never
        resources:
          requests:
            cpu: 10m
            memory: 10Mi
</code></pre>
<p class="normal">The definition of the service that forwards communications to <code class="inlineCode">grpcmicroservice</code> is quite standard:</p>
<pre class="programlisting code"><code class="hljs-code">apiVersion: v1
kind: Service
metadata:
  name: grpcmicroservice
  labels:
    app: contract
    role: worker
spec:
  ports:
  - port: 8080
    name: http
    protocol: TCP
    targetPort: 8080
  selector:
    app: statistics
    role: worker
</code></pre>
<p class="normal">You must pay attention only to the port numbers that must be coherent in all settings and to the service name, since they will be used in the URLs of all communication to the <code class="inlineCode">grpcmicroservice</code>.</p>
<div><p class="normal">If the service names match the hostnames in the Docker virtual network, the URLs will work both in Kubernetes and the Docker virtual network. So, you don’t need to modify any <a id="_idIndexMarker1769"/>code or configuration to adapt the code that runs in the Docker virtual network to Minikube or any other Kubernetes clusters.</p>
</div>
<p class="normal">The whole <code class="inlineCode">minkubedeploy.yaml</code> file is available in the <code class="inlineCode">ch22</code> folder of the GitHub repository associated with the book.</p>
<p class="normal">Now, let’s open a Windows prompt in the folder that contains the <code class="inlineCode">minkubedeploy.yaml</code> file, issuing the command below that will load the application configuration in the Minikube cluster:</p>
<pre class="programlisting con"><code class="hljs-con">kubectl create -f minkubedeploy.yaml
</code></pre>
<p class="normal">Then, issue the <code class="inlineCode">kubectl get deployment</code> command to verify that all deployments have been correctly defined and are running.</p>
<p class="normal">You can verify that the application is properly running by inspecting the data in the <code class="inlineCode">dbo.Purchases</code> database table, by right-clicking on the <code class="inlineCode">dbo.Purchases</code> table in <strong class="screenText">SQL Server Object Explorer</strong><em class="italic"> </em>and choosing <strong class="screenText">View Data</strong>:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_22_10.png"/></figure>
<p class="packt_figref">Figure 22.10: dbo.Purchases table</p>
<p class="normal">Each time you click the table refresh button, you should see new rows added to the database table. If new rows do not appear after several refreshes, your microservice is probably experiencing some <a id="_idIndexMarker1770"/>communication problem, or some exception was thrown before data was computed.</p>
<p class="normal">You can discover what the problem is just by debugging the application. The next section explains how to verify in detail what is happening in the application, with the help of Bridge to Kubernetes. Please do not delete all Kubernetes objects created with <code class="inlineCode">minkubedeploy.yaml</code> because we need the running application to attach Bridge to Kubernetes.</p>
<h1 class="heading-1" id="_idParaDest-485">Remote debugging a Kubernetes application</h1>
<p class="normal">As a final step, we will debug <code class="inlineCode">GrpcMicroService</code> with<a id="_idIndexMarker1771"/> Bridge to Kubernetes. Let’s set <code class="inlineCode">GrpcMicroService</code> as a starting project and change the project start from <strong class="screenText">Docker</strong> to <strong class="screenText">Bridge</strong> <strong class="screenText">to Kubernetes</strong>, as shown in the image below:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_22_11.png"/></figure>
<p class="packt_figref">Figure 22.11: Debugging GrpcMicroService with Bridge to Kubernetes</p>
<p class="normal">Let’s place a breakpoint in the <code class="inlineCode">GrpcMicroService-&gt;HostedServices-&gt; ProcessPurchases.cs</code> file inside of the <code class="inlineCode">if</code> block, as shown below:</p>
<pre class="programlisting code"><code class="hljs-code">if (toProcess.Count &gt; 0)
{
	…
}
</code></pre>
<p class="normal">Then, start debugging. As soon as <a id="_idIndexMarker1772"/>you click the <strong class="screenText">run</strong> button, a window appears that prompts you to configure Bridge to Kubernetes:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_22_12.png"/></figure>
<p class="packt_figref">Figure 22.12: Configuring Bridge to Kubernetes</p>
<p class="normal">If the window above doesn’t open, or you can’t see any Minikube node, <code class="inlineCode">Kubectl</code> is probably not working or configured for Minikube. Try issuing a <code class="inlineCode">Kubectl</code> command like <code class="inlineCode">kubectl get all</code>. If you face any issues, try stopping and restarting Minikube with <code class="inlineCode">minikube stop</code>, followed by <code class="inlineCode">minikube start</code>.</p>
<p class="normal">Bridge to Kubernetes prompts us to select a namespace—in our case, <code class="inlineCode">default</code>—and then choose a specific service within that namespace—in our case, <code class="inlineCode">grpmicroservice</code>. All communications to that service will be forwarded to the <code class="inlineCode">GrpcMicroService</code> code running on our development machine. Let’s set up the configuration window, as shown in the screenshot above. As soon as you submit your Bridge to Kubernetes configuration, debugging will automatically <a id="_idIndexMarker1773"/>start. In a short time, the breakpoint will be hit, and our local copy of the microservice will start interacting with the remainder of the code that is running in Minikube!</p>
<p class="normal">After you finish debugging, please restore the project start to <strong class="screenText">Docker</strong>, and restore the simultaneous start of both microservices so that you can continue working with the Docker virtual network.</p>
<p class="normal">After having finished working with Minikube, you need to remove all objects created by <code class="inlineCode">minkubedeploy.yaml</code> with the command below:</p>
<pre class="programlisting con"><code class="hljs-con">kubectl delete -f minkubedeploy.yaml
</code></pre>
<p class="normal">It is important to free up resources as soon as you don’t need them anymore; otherwise, they will continue wasting CPU time and memory, and if you constantly add more and more applications, sooner or later, you will experience performance problems on your development machine.</p>
<p class="normal">If you want to free up Minikube disk space, you can also remove the microservices images previously loaded in the Minikube cache with the commands below:</p>
<pre class="programlisting con"><code class="hljs-con">minikube image rm fakesource:latest
minikube image rm grpcmicroservice:latest
</code></pre>
<p class="normal">Finally, you need to stop Minikube with:</p>
<pre class="programlisting con"><code class="hljs-con">minikube stop
</code></pre>
<h1 class="heading-1" id="_idParaDest-486">Summary</h1>
<p class="normal">In this chapter, we explained how to prepare a developer workstation for .NET Kubernetes development and how to organize code testing and bug-fix cycles.</p>
<p class="normal">We also explained how to define a Docker virtual network to ensure microservices communication during development and name conventions for hostnames and Kubernetes services, enabling the same code to run both on the Docker virtual network, Minikube, and any other Kubernetes cluster.</p>
<p class="normal">Finally, we explained all the steps needed to run an application in Minikube and how to test it with Bridge to Kubernetes.</p>
<p class="normal">We’ve now reached the end of our journey through this book, and what a journey it has been!</p>
<p class="normal">Packed with numerous new and challenging ideas, this book is sure to be your good friend on your journey as a software architect. </p>
<p class="normal">These learnings will not only empower you to craft innovative solutions but also support your growth in the dynamic world of software projects. We sincerely hope you’ve enjoyed the adventure as much as we have creating this latest edition for you.</p>
<h1 class="heading-1" id="_idParaDest-487">Questions</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Why can’t the SQL Server installation that comes with Visual Studio be used for Kubernetes development?</li>
<li class="numberedList">What is Bridge to Kubernetes?</li>
<li class="numberedList">Is it true that Bridge to Kubernetes works just with Minikube?</li>
<li class="numberedList">How do you load the Minikube images cache?</li>
<li class="numberedList">How do we define Minikube as the Kubectl default cluster?</li>
</ol>
<h1 class="heading-1" id="_idParaDest-488">Further reading</h1>
<p class="normal">Most of the references in this chapter are the same as those previously listed in <em class="italic">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>, and <em class="italic">Chapter 14</em>, <em class="italic">Implementing Microservices with .NET</em>. Here, it is worth adding the link to the official documentation about Bridge to Kubernetes: <a href="https://learn.microsoft.com/en-us/visualstudio/bridge/    ">https://learn.microsoft.com/en-us/visualstudio/bridge/</a></p>
<p class="normal"><a href="https://learn.microsoft.com/en-us/visualstudio/bridge/    "/></p>
<p class="normal"><a href="https://learn.microsoft.com/en-us/visualstudio/bridge/    "/></p>
<p class="normal"><a href="https://learn.microsoft.com/en-us/visualstudio/bridge/    "/></p>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the authors, and learn about new releases – follow the QR code below:</p>
<p class="normal"><a href="https://packt.link/SoftwareArchitectureCSharp12Dotnet8">https://packt.link/SoftwareArchitectureCSharp12Dotnet8</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_Code175081751210902046.png"/></p>
</div>
</body></html>