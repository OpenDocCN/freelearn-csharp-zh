<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer257">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">15</span></h1>
<h1 class="chapterTitle" id="_idParaDest-302"><span class="koboSpan" id="kobo.2.1">Applying Service-Oriented Architectures with .NET</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">The term </span><strong class="keyWord"><span class="koboSpan" id="kobo.4.1">Service-Oriented Architecture</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.6.1">SOA</span></strong><span class="koboSpan" id="kobo.7.1">) refers to a modular architecture where interaction between system components is</span><a id="_idIndexMarker1061"/><span class="koboSpan" id="kobo.8.1"> achieved through communication. </span><span class="koboSpan" id="kobo.8.2">This approach has evolved for years and is now the basis of all communication between systems over the Internet. </span><span class="koboSpan" id="kobo.8.3">SOA allows applications from different organizations to exchange data and transactions automatically. </span><span class="koboSpan" id="kobo.8.4">Besides that, it allows organizations to offer services on the Internet. </span><span class="koboSpan" id="kobo.8.5">For instance, in a banking application, SOA can allow separate services for account management, transaction processing, and customer support to communicate seamlessly. </span><span class="koboSpan" id="kobo.8.6">More than that, it can enable suppliers to access customer support directly.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.9.1">Moreover, as we discussed in </span><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 11</span></em><span class="koboSpan" id="kobo.11.1">, </span><em class="italic"><span class="koboSpan" id="kobo.12.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.13.1">, communication-based interaction solves the binary compatibility and version mismatch problems that inevitably appear in complex systems made up of modules that share the same address space. </span><span class="koboSpan" id="kobo.13.2">Moreover, with SOA and its pattern of communication, you do not need to deploy different copies of the same component in the various systems/subsystems that use it – each component only needs to be deployed in one place, even if they</span><a id="_idIndexMarker1062"/><span class="koboSpan" id="kobo.14.1"> are written in different programming languages, simplifying the overall cycle of </span><strong class="keyWord"><span class="koboSpan" id="kobo.15.1">Continuous Integration/Continuous Delivery</span></strong><span class="koboSpan" id="kobo.16.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.17.1">CI/CD</span></strong><span class="koboSpan" id="kobo.18.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.19.1">If a newer version conforms to the communication interface that is declared to the clients, no incompatibilities can occur. </span><span class="koboSpan" id="kobo.19.2">For instance, if you have a backend service that calculates tax based on a specific rule and the entry of selling data, if the specific rule changes, but the selling data doesn’t, you will be able to update the service without changing the application in the clients. </span><span class="koboSpan" id="kobo.19.3">On the other hand, with DLLs/packages, when the same interface is maintained, incompatibilities may arise because of possible version mismatches in terms of the dependencies of other DLLs/packages that the library module might have in common with its clients.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.20.1">Organizing clusters/networks of cooperating services was discussed in </span><em class="italic"><span class="koboSpan" id="kobo.21.1">Chapter 11</span></em><span class="koboSpan" id="kobo.22.1">, </span><em class="italic"><span class="koboSpan" id="kobo.23.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.24.1">. </span><span class="koboSpan" id="kobo.24.2">In this chapter, we will focus on the two main communication interfaces used all over the world. </span><span class="koboSpan" id="kobo.24.3">More specifically, we will discuss the following topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.25.1">Understanding the principles of the SOA approach</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.26.1">SOAP and REST web services</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.27.1">How does .NET 8 deal with SOA?</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.28.1">By the end of this chapter, you will know how to publicly expose data from an application through an ASP.NET Core service.</span></p>
<h1 class="heading-1" id="_idParaDest-303"><span class="koboSpan" id="kobo.29.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.30.1">This chapter requires the Visual Studio 2022 free Community edition or better with all the database tools installed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.31.1">All the concepts in this chapter will be clarified with practical examples based on the WWTravelClub book use case, located in </span><em class="italic"><span class="koboSpan" id="kobo.32.1">Chapter 21, Case Study</span></em><span class="koboSpan" id="kobo.33.1">. </span><span class="koboSpan" id="kobo.33.2">You will find the code for this chapter at </span><a href="https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E"><span class="url"><span class="koboSpan" id="kobo.34.1">https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E</span></span></a><span class="koboSpan" id="kobo.35.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-304"><span class="koboSpan" id="kobo.36.1">Understanding the principles of the SOA approach</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.37.1">Like classes in an object-oriented architecture, services are implementations of interfaces that, in turn, come from a system’s functional specifications. </span><span class="koboSpan" id="kobo.37.2">Therefore, the first step in </span><em class="italic"><span class="koboSpan" id="kobo.38.1">service</span></em><span class="koboSpan" id="kobo.39.1"> design is the definition of its </span><em class="italic"><span class="koboSpan" id="kobo.40.1">abstract interface</span></em><span class="koboSpan" id="kobo.41.1">. </span><span class="koboSpan" id="kobo.41.2">During this initial stage, you might have two</span><a id="_idIndexMarker1063"/><span class="koboSpan" id="kobo.42.1"> approaches:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.43.1">Define all the service operations as interface methods that operate on the types of your favorite language (C#, Java, C++, JavaScript, and so on) and decide which operations to implement with synchronous communication and which ones to implement with asynchronous communication.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.44.1">Create the contract first in an interoperable format. </span><span class="koboSpan" id="kobo.44.2">In this approach, you can use definition files using patterns like OpenAPI, Protobuf, WSDL, and AsyncAPI without touching the programming language with which the services will be developed, using some tools to help.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.45.1">The interfaces that are defined in this initial stage will not necessarily be used in the actual service implementation and are just useful design tools. </span><span class="koboSpan" id="kobo.45.2">Once we have decided on the architecture of the services, these interfaces are usually redefined so that we can adapt them to the peculiarity of the architecture.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.46.1">It is worth pointing out that</span><a id="_idIndexMarker1064"/><span class="koboSpan" id="kobo.47.1"> SOA messages must keep the same kind of semantics as method calls/answers. </span><span class="koboSpan" id="kobo.47.2">Besides, SOA follows stateless development; that is, the reaction to a message must not depend on any previously received messages because the server does not save information from prior requests, which means the messages must be independent of each other.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.48.1">For instance, if the purpose of messages is to create a new database entry, this semantic must not change with the context of other messages, and the way the database entry is created must depend on the content of the current message and not on other previously received messages. </span><span class="koboSpan" id="kobo.48.2">Consequently, a client cannot create sessions and cannot log in to a service, perform some operations, and then log out. </span><span class="koboSpan" id="kobo.48.3">An authentication token must be repeated in each message.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.49.1">The reasons for this constraint are modularity, testability, and maintainability. </span><span class="koboSpan" id="kobo.49.2">In fact, a session-based service would be very hard to test and modify due to the interactions that are </span><em class="italic"><span class="koboSpan" id="kobo.50.1">hidden</span></em><span class="koboSpan" id="kobo.51.1"> in the session data.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.52.1">Once you have decided on the interface that is going to be implemented by a service, you must decide which communication stack/SOA to adopt. </span><span class="koboSpan" id="kobo.52.2">The communication stack must be part of some official or </span><em class="italic"><span class="koboSpan" id="kobo.53.1">de facto</span></em><span class="koboSpan" id="kobo.54.1"> standard to ensure the interoperability of the service.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.55.1">Interoperability is the main constraint prescribed by SOA: services must offer a communication interface that does not depend on a specific library used, implementation language, or deployment platform.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.56.1">Considering you have decided on the communication stack/architecture, you need to adapt your previous interfaces to the peculiarities of the architecture (see the </span><em class="italic"><span class="koboSpan" id="kobo.57.1">REST web services</span></em><span class="koboSpan" id="kobo.58.1"> subsection of this chapter for more details). </span><span class="koboSpan" id="kobo.58.2">Then, you must translate these interfaces into the chosen communication language. </span><span class="koboSpan" id="kobo.58.3">This means that you must map all the programming language types into types that are available in the chosen communication language.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.59.1">The actual translation of data is usually performed automatically by the SOA libraries that are used by your development environment. </span><span class="koboSpan" id="kobo.59.2">However, some configuration might be needed, and, in any case, we must be aware of how our programming language types are transformed before each communication. </span><span class="koboSpan" id="kobo.59.3">For instance, some numeric types might be transformed into types with less precision or with different ranges of values. </span><span class="koboSpan" id="kobo.59.4">In .NET 8, for instance, you should be </span><a id="_idIndexMarker1065"/><span class="koboSpan" id="kobo.60.1">aware that floating-point numeric types vary between </span><strong class="keyWord"><span class="koboSpan" id="kobo.61.1">float</span></strong><span class="koboSpan" id="kobo.62.1"> (~6-9 digits), </span><strong class="keyWord"><span class="koboSpan" id="kobo.63.1">double</span></strong><span class="koboSpan" id="kobo.64.1"> (~15-17 digits), and </span><strong class="keyWord"><span class="koboSpan" id="kobo.65.1">decimal</span></strong><span class="koboSpan" id="kobo.66.1"> (~28-29 digits). </span><span class="koboSpan" id="kobo.66.2">You may consider the alternative of using string variables to reduce the risk of imprecision while transferring numeric types.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.67.1">The interoperability constraint can be interpreted in a lighter form in the case of microservices that are not accessible outside of their clusters since they need to communicate with other microservices that belong to the same cluster. </span><span class="koboSpan" id="kobo.67.2">In this case, this means that the communication stack might be platform-specific so that it can increase performance, but it must be standard to avoid compatibility problems with other microservices that might be added to the cluster as the application evolves.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.68.1">We have spoken of the </span><em class="italic"><span class="koboSpan" id="kobo.69.1">communication stack</span></em><span class="koboSpan" id="kobo.70.1"> and not of the </span><em class="italic"><span class="koboSpan" id="kobo.71.1">communication protocol</span></em><span class="koboSpan" id="kobo.72.1"> because SOA communication standards usually define the format of the message’s content and provide different possibilities for the specific protocol that is used to embed those messages. </span><span class="koboSpan" id="kobo.72.2">For instance, REST services usually run over HTTP/HTTPS based on JSON messages, while the SOAP protocol just defines an XML-based format for the various kinds of messages, but SOAP messages can be conveyed by various protocols. </span><span class="koboSpan" id="kobo.72.3">Usually, the most common protocol that is used for SOAP is also HTTP, but you may decide to jump to the HTTP level and send SOAP messages directly over TCP/IP for better performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.73.1">The choice of communication stack you should adopt depends on several factors, as described below. </span><span class="koboSpan" id="kobo.73.2">When it comes to accessing data, maybe the communication stack will be mandatory and decided by the provider, but you should also be concerned about these factors when providing a service:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.74.1">Compatibility constraints</span></strong><span class="koboSpan" id="kobo.75.1">: If your service must be publicly available on the Internet to business clients, then you must conform to the most common choices, which means using SOAP over either HTTP or REST services. </span><span class="koboSpan" id="kobo.75.2">The most common choices are different if your clients are not business clients but </span><strong class="keyWord"><span class="koboSpan" id="kobo.76.1">Internet of Things</span></strong><span class="koboSpan" id="kobo.77.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.78.1">IoT</span></strong><span class="koboSpan" id="kobo.79.1">) clients. </span><span class="koboSpan" id="kobo.79.2">Also, within IoT, the protocols that are used in different application areas </span><a id="_idIndexMarker1066"/><span class="koboSpan" id="kobo.80.1">can be different. </span><span class="koboSpan" id="kobo.80.2">For instance, marine vehicle status data is typically exchanged with </span><em class="italic"><span class="koboSpan" id="kobo.81.1">Signal K</span></em><span class="koboSpan" id="kobo.82.1">. </span><span class="koboSpan" id="kobo.82.2">Although this protocol is too specific and is presented here just as an example, as a software architect, you must understand that you may face this kind of standard in a specific area.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.83.1">Development/deployment platform</span></strong><span class="koboSpan" id="kobo.84.1">: Not all communication stacks are available on all development </span><a id="_idIndexMarker1067"/><span class="koboSpan" id="kobo.85.1">frameworks and on all deployment platforms, but luckily, all the most common communication stacks that are used in public business services, such as SOAP- and JSON-based REST communication, are available on all the main development/deployment platforms.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.86.1">Performance</span></strong><span class="koboSpan" id="kobo.87.1">: If your system is not exposed to the outside world and is a private part of your microservice cluster, performance considerations have a higher priority. </span><span class="koboSpan" id="kobo.87.2">In this scenario, gRPC, which we will discuss soon in this chapter, can be noted as a good option.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.88.1">Availability of tools and knowledge in your team</span></strong><span class="koboSpan" id="kobo.89.1">: Knowing about the availability of tools in your team/organization is important when it comes to choosing between acceptable communication stacks.
    </span><p class="normal"><span class="koboSpan" id="kobo.90.1">However, this kind of constraint always has less priority than compatibility constraints since it makes no sense to conceive a system that is easy to implement for your team but that almost nobody can use.</span></p></li>
</ul>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.91.1">Flexibility versus available features</span></strong><span class="koboSpan" id="kobo.92.1">: Some communication solutions, while less complete, offer a higher degree of flexibility, while other solutions, though more complete, offer less flexibility. </span><span class="koboSpan" id="kobo.92.2">The need for flexibility started a movement from SOAP-based services to more flexible REST services in the last few years. </span><span class="koboSpan" id="kobo.92.3">This point will be discussed in more detail when we describe SOAP and REST services in the remainder of this section.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.93.1">Service description</span></strong><span class="koboSpan" id="kobo.94.1">: When services must be exposed on the Internet, client applications need a publicly available description of the service specifications to design their communication clients. </span><span class="koboSpan" id="kobo.94.2">Some communication stacks include languages and conventions to describe service specifications. </span><span class="koboSpan" id="kobo.94.3">Formal service specifications that are exposed this way can be processed so that they automatically create communication clients. </span><span class="koboSpan" id="kobo.94.4">SOAP goes further and allows service discoverability by means of a public XML-based directory containing information about the tasks each web service can carry out.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.95.1">Once you have chosen the communication stack you wish to use, you must use the tools that are available in your development environment to implement the service in a way that conforms to the chosen communication stack. </span><span class="koboSpan" id="kobo.95.2">Sometimes, communication stack compliance is automatically ensured by the development tools, but sometimes, it may require some development effort. </span><span class="koboSpan" id="kobo.95.3">For instance, in the .NET world, the compliance of SOAP services is automatically ensured by development tools if you use WCF, while the compliance of REST services falls under the developer’s responsibility, although you have, since .NET 5, automatic</span><a id="_idIndexMarker1068"/><span class="koboSpan" id="kobo.96.1"> support for the OpenAPI standard using Swagger. </span><span class="koboSpan" id="kobo.96.2">Some of the fundamental features of SOA solutions are as follows:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.97.1">Authentication</span></strong><span class="koboSpan" id="kobo.98.1">: Allows the client to authenticate to access service operations.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.99.1">Authorization</span></strong><span class="koboSpan" id="kobo.100.1">: Handles the client’s permissions.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.101.1">Security</span></strong><span class="koboSpan" id="kobo.102.1">: This is how communication is kept safe, that is, how to prevent unauthorized systems from reading and/or modifying the content of the communication. </span><span class="koboSpan" id="kobo.102.2">Typically, encryption prevents both unauthorized modifications and reading, while electronic signature algorithms prevent just modifications.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.103.1">Exceptions</span></strong><span class="koboSpan" id="kobo.104.1">: Returns exceptions to the client.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.105.1">Message reliability</span></strong><span class="koboSpan" id="kobo.106.1">: Ensures that messages reliably reach their destination in case of possible infrastructure faults.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.107.1">Though sometimes desirable, the following features are not always necessary:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.108.1">Distributed transactions</span></strong><span class="koboSpan" id="kobo.109.1">: The capability to handle distributed transactions, thus undoing all the changes you have made whenever the distributed transactions fail or are aborted.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.110.1">Support for the Publisher/Subscriber pattern</span></strong><span class="koboSpan" id="kobo.111.1">: If and how events and notifications are supported.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.112.1">Addressing</span></strong><span class="koboSpan" id="kobo.113.1">: If and how references to other services and/or methods are supported.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.114.1">Routing</span></strong><span class="koboSpan" id="kobo.115.1">: If and how messages can be routed through a network of services.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.116.1">The remainder of this section will describe SOAP services a bit. </span><span class="koboSpan" id="kobo.116.2">However, the focus will be REST services since today they are the </span><em class="italic"><span class="koboSpan" id="kobo.117.1">de facto</span></em><span class="koboSpan" id="kobo.118.1"> standard for business services that are exposed outside of their clusters/servers. </span><span class="koboSpan" id="kobo.118.2">For performance reasons, microservices use other protocols, discussed in </span><em class="italic"><span class="koboSpan" id="kobo.119.1">Chapter 11</span></em><span class="koboSpan" id="kobo.120.1">, </span><em class="italic"><span class="koboSpan" id="kobo.121.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.122.1">, </span><em class="italic"><span class="koboSpan" id="kobo.123.1">Chapter 14</span></em><span class="koboSpan" id="kobo.124.1">, </span><em class="italic"><span class="koboSpan" id="kobo.125.1">Implementing Microservices with .NET</span></em><span class="koboSpan" id="kobo.126.1">. </span><span class="koboSpan" id="kobo.126.2">For inter-cluster communication, </span><strong class="keyWord"><span class="koboSpan" id="kobo.127.1">Advanced Message Queuing Protocol</span></strong><span class="koboSpan" id="kobo.128.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.129.1">AMQP</span></strong><span class="koboSpan" id="kobo.130.1">) is used, and</span><a id="_idIndexMarker1069"/><span class="koboSpan" id="kobo.131.1"> links are given in the </span><em class="italic"><span class="koboSpan" id="kobo.132.1">Further reading</span></em><span class="koboSpan" id="kobo.133.1"> section.</span></p>
<h1 class="heading-1" id="_idParaDest-305"><span class="koboSpan" id="kobo.134.1">SOAP web services</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.135.1">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.136.1">Simple Object Access Protocol</span></strong><span class="koboSpan" id="kobo.137.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.138.1">SOAP</span></strong><span class="koboSpan" id="kobo.139.1">) allows both </span><a id="_idIndexMarker1070"/><span class="koboSpan" id="kobo.140.1">one-way messages and request/reply messages. </span><span class="koboSpan" id="kobo.140.2">Communication can be both synchronous and asynchronous, as explained in </span><em class="italic"><span class="koboSpan" id="kobo.141.1">Chapter 1, Understanding the Importance of Software Architecture</span></em><span class="koboSpan" id="kobo.142.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.143.1">Chapter 2, Non-Functional Requirements</span></em><span class="koboSpan" id="kobo.144.1">, but if the underlying protocol is synchronous, such as in the case of HTTP, the sender receives an acknowledgment </span><a id="_idIndexMarker1071"/><span class="koboSpan" id="kobo.145.1">saying that the message was received (but not necessarily processed). </span><span class="koboSpan" id="kobo.145.2">When asynchronous communication is used, the sender must listen for incoming communications. </span><span class="koboSpan" id="kobo.145.3">Often, asynchronous communication is implemented with the Publisher/Subscriber pattern, which we described in </span><em class="italic"><span class="koboSpan" id="kobo.146.1">Chapter 6</span></em><span class="koboSpan" id="kobo.147.1">, </span><em class="italic"><span class="koboSpan" id="kobo.148.1">Design Patterns and .NET 8 Implementation</span></em><span class="koboSpan" id="kobo.149.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.150.1">Messages are represented as XML documents called </span><strong class="keyWord"><span class="koboSpan" id="kobo.151.1">envelopes</span></strong><span class="koboSpan" id="kobo.152.1">. </span><span class="koboSpan" id="kobo.152.2">Each envelope contains </span><code class="inlineCode"><span class="koboSpan" id="kobo.153.1">header</span></code><span class="koboSpan" id="kobo.154.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.155.1">body</span></code><span class="koboSpan" id="kobo.156.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.157.1">fault</span></code><span class="koboSpan" id="kobo.158.1"> elements. </span><span class="koboSpan" id="kobo.158.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.159.1">body</span></code><span class="koboSpan" id="kobo.160.1"> is </span><a id="_idIndexMarker1072"/><span class="koboSpan" id="kobo.161.1">where the actual content of the message is placed. </span><span class="koboSpan" id="kobo.161.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.162.1">fault</span></code><span class="koboSpan" id="kobo.163.1"> element contains possible errors, so it is the way exceptions are exchanged when communication occurs. </span><span class="koboSpan" id="kobo.163.2">Finally, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.164.1">header</span></code><span class="koboSpan" id="kobo.165.1"> contains any auxiliary information that enriches the protocol but does not contain domain data. </span><span class="koboSpan" id="kobo.165.2">For example, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.166.1">header</span></code><span class="koboSpan" id="kobo.167.1"> may contain an authentication token and/or a signature if the message is signed.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.168.1">You can find the default namespace for</span><a id="_idIndexMarker1073"/><span class="koboSpan" id="kobo.169.1"> the SOAP envelope at </span><a href="https://www.w3.org/2003/05/soap-envelope/"><span class="url"><span class="koboSpan" id="kobo.170.1">https://www.w3.org/2003/05/soap-envelope/</span></span></a><span class="koboSpan" id="kobo.171.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.172.1">The underlying protocol that is used to send the XML envelopes is usually HTTP, since this is the protocol of the Internet, but the SOAP specification allows any protocol, so we can use TCP/IP or SMTP directly. </span><span class="koboSpan" id="kobo.172.2">As a matter of fact, the more diffused underlying protocol is HTTP, so if you do not have a good reason to choose another protocol, you should use HTTP to maximize the interoperability of the service.</span></p>
<h2 class="heading-2" id="_idParaDest-306"><span class="koboSpan" id="kobo.173.1">SOAP specifications</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.174.1">SOAP specifications contain the </span><a id="_idIndexMarker1074"/><span class="koboSpan" id="kobo.175.1">basics of message exchange, while other auxiliary features are described in separate specification documents called </span><code class="inlineCode"><span class="koboSpan" id="kobo.176.1">WS-</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.177.1">*</span></code><span class="koboSpan" id="kobo.178.1"> and are usually handled by adding extra information in the SOAP header. </span><code class="inlineCode"><span class="koboSpan" id="kobo.179.1">WS-*</span></code><span class="koboSpan" id="kobo.180.1"> specifications handle all the fundamental and desirable features of SOA we listed previously. </span><span class="koboSpan" id="kobo.180.2">We have some of them below:</span></p>
<table class="table-container" id="table001-4">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.181.1">WS-*</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.182.1">Main objective</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.183.1">WS-Security </span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.184.1">Takes care of security, including authentication, authorization, and encryption/signatures</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.185.1">WS-Eventing</span></code><span class="koboSpan" id="kobo.186.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.187.1">WS-Notification</span></code> </p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.188.1">Two alternative ways of implementing the Publisher/Subscriber pattern</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.189.1">WS-ReliableMessaging </span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.190.1">Concerned with the reliable delivery of messages in case of possible faults</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.191.1">WS-Transaction </span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.192.1">Concerned with distributed transactions</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.193.1">Table 15.1: Summary of Key WS-* Specifications and Their Main Objectives in SOAP-Based SOA</span></p>
<p class="normal"><span class="koboSpan" id="kobo.194.1">The preceding </span><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">WS- *</span></code><span class="koboSpan" id="kobo.196.1"> specifications are in no way exhaustive but are the more relevant and supported features. </span><span class="koboSpan" id="kobo.196.2">In fact, actual implementations in various environments (such as Java and .NET) furnish the more relevant </span><code class="inlineCode"><span class="koboSpan" id="kobo.197.1">WS- *</span></code><span class="koboSpan" id="kobo.198.1"> services, but no implementation supports all the </span><code class="inlineCode"><span class="koboSpan" id="kobo.199.1">WS- *</span></code><span class="koboSpan" id="kobo.200.1"> specifications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.201.1">All the XML documents/document parts involved in the SOAP protocol are formally defined in XSD documents, like in the example below, which are special XML documents whose content provides a description of XML structures.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.202.1">&lt;?xml version=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.203.1">"1.0"</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.204.1">?&gt;</span></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.205.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.206.1">xs:schema</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.207.1">id</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.208.1">=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.209.1">"sample"</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.210.1">targetNamespace</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.211.1">=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.212.1">"http://tempuri.org/sample.xsd"</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.213.1">elementFormDefault</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.214.1">=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.215.1">"qualified"</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.216.1">xmlns</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.217.1">=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.218.1">"http://tempuri.org/sample.xsd"</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.219.1">xmlns:xs</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.220.1">=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.221.1">"http://www.w3.org/2001/XMLSchema"</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.222.1">&gt;</span></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.223.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.224.1">xs:element</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.225.1">name</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.226.1">=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.227.1">'mySample'</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.228.1">&gt;</span></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.229.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.230.1">xs:complexType</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.231.1">&gt;</span></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.232.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.233.1">xs:simpleContent</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.234.1">&gt;</span></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.235.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.236.1">xs:extension</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.237.1">base</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.238.1">=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.239.1">'xs:decimal'</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.240.1">&gt;</span></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.241.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.242.1">xs:attribute</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.243.1">name</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.244.1">=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.245.1">'sizing'</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.246.1">type</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.247.1">=</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.248.1">'xs:string'</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.249.1"> /&gt;</span></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.250.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.251.1">xs:extension</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.252.1">&gt;</span></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.253.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.254.1">xs:simpleContent</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.255.1">&gt;</span></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.256.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.257.1">xs:complexType</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.258.1">&gt;</span></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.259.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.260.1">xs:element</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.261.1">&gt;</span></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.262.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.263.1">xs:schema</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.264.1">&gt;</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.265.1">Also, all your custom data structures (classes and interfaces in an object-oriented language) must be translated into XSD if they are going to be part of a SOAP envelope.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.266.1">Each XSD specification has an associated </span><code class="inlineCode"><span class="koboSpan" id="kobo.267.1">namespace</span></code><span class="koboSpan" id="kobo.268.1"> that identifies the specification and a physical location where it can be found. </span><span class="koboSpan" id="kobo.268.2">Both the namespace and the physical location are URIs. </span><span class="koboSpan" id="kobo.268.3">The location URI does not need to be publicly accessible if the web service is accessible just from within an intranet.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.269.1">The whole definition of a service is an XSD specification that may contain references to other namespaces, that is, to other XSD documents. </span><span class="koboSpan" id="kobo.269.2">Simply put, all the messages via SOAP communication must be defined in an XSD specification. </span><span class="koboSpan" id="kobo.269.3">Then, a server and a client can communicate if they</span><a id="_idIndexMarker1075"/><span class="koboSpan" id="kobo.270.1"> refer to the same XSD specifications. </span><span class="koboSpan" id="kobo.270.2">This means, for instance, that you need to create a new XSD specification each time you add another field to a message. </span><span class="koboSpan" id="kobo.270.3">After that, you need to update all the XSD files that reference the old message definition to the new message definition by creating a new version of them. </span><span class="koboSpan" id="kobo.270.4">In turn, these modifications require the creation of other versions for other XSD files, and so on. </span><span class="koboSpan" id="kobo.270.5">Therefore, simple modifications that maintain compatibility with the previous behavior (clients could simply ignore the field that was added) may cause an exponential chain of version changes.</span></p>
<h2 class="heading-2" id="_idParaDest-307"><span class="koboSpan" id="kobo.271.1">Difficulties associated with the standard</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.272.1">In the last few years, the difficulty in handling modifications, along with the complexity of handling the configuration of all the </span><code class="inlineCode"><span class="koboSpan" id="kobo.273.1">WS- *</span></code><span class="koboSpan" id="kobo.274.1"> specifications and performance problems, caused a gradual move</span><a id="_idIndexMarker1076"/><span class="koboSpan" id="kobo.275.1"> toward the simpler REST services that we will describe in the upcoming sections. </span><span class="koboSpan" id="kobo.275.2">This move started with services that were called from JavaScript due to the difficulty of implementing complete SOAP clients that were able to run efficiently in a web browser. </span><span class="koboSpan" id="kobo.275.3">Moreover, the complex SOAP machinery was oversized for the simple needs of the typical clients running in a browser and may have caused a complete waste of development time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.276.1">For this reason, services aimed at non-JavaScript clients started a massive move toward REST services, and nowadays, the preferred choice is REST services, with SOAP being used either for compatibility with legacy systems or when features that are not supported by REST services are needed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.277.1">Today, we can consider REST services that transfer data with JSON, the most-used approach all over the world. </span><span class="koboSpan" id="kobo.277.2">Security aspects, design patterns for enabling transactional support, performance, and even documentation have improved all over the years, so this is certainly the best alternative</span><a id="_idIndexMarker1077"/><span class="koboSpan" id="kobo.278.1"> for applying SOAs nowadays. </span><span class="koboSpan" id="kobo.278.2">Let’s have a look at REST web services in the next topic. </span></p>
<h1 class="heading-1" id="_idParaDest-308"><span class="koboSpan" id="kobo.279.1">REST web services</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.280.1">REST services were initially conceived to avoid the complex machinery of SOAP in simple cases, such as calls to a service from the JavaScript code of a web page. </span><span class="koboSpan" id="kobo.280.2">Then, they gradually became the preferred choice for </span><a id="_idIndexMarker1078"/><span class="koboSpan" id="kobo.281.1">complex systems. </span><span class="koboSpan" id="kobo.281.2">REST services use HTTP to exchange data in JSON or, less commonly, in XML format. </span><span class="koboSpan" id="kobo.281.3">Simply put, they replace the SOAP body with the HTTP body, the SOAP header with the HTTP header, and the HTTP response code replaces the fault element and furnishes further auxiliary information on the operation that was performed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.282.1">The main reason for the success of REST services is that HTTP already offers most of the SOAP features natively, which means we can avoid building a SOAP level on top of HTTP. </span><span class="koboSpan" id="kobo.282.2">Moreover, the whole HTTP machinery is simpler than SOAP: simpler to program, simpler to configure, and simpler to implement efficiently.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.283.1">Moreover, REST services impose fewer constraints on the clients. </span><span class="koboSpan" id="kobo.283.2">Type compatibility between servers and clients conforms to the more flexible JavaScript type compatibility model because JSON is a subset of JavaScript. </span><span class="koboSpan" id="kobo.283.3">Moreover, when XML is used in place of JSON, it maintains the same JavaScript type compatibility rules. </span><span class="koboSpan" id="kobo.283.4">No XML namespaces need to be specified.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.284.1">When using JSON and XML, if the server adds some more fields to the response while keeping the same semantics of all the other fields compatible with the previous client, they can simply ignore the new fields. </span><span class="koboSpan" id="kobo.284.2">Accordingly, changes that are made to a REST service definition only need to be propagated to previous clients in the case of breaking changes that cause actual incompatible behavior in the server.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.285.1">Moreover, it is likely that changes will be self-limited and won’t result in an exponential chain of changes because type compatibility does not require the reference to a specific type to be defined in a unique shared place and simply requires that the shape of types is compatible.</span></p>
<h2 class="heading-2" id="_idParaDest-309"><span class="koboSpan" id="kobo.286.1">Service type compatibility rules</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.287.1">Let’s clarify the REST service type compatibility rules with an example. </span><span class="koboSpan" id="kobo.287.2">Imagine that several services use a </span><code class="inlineCode"><span class="koboSpan" id="kobo.288.1">Person</span></code><span class="koboSpan" id="kobo.289.1"> object that </span><a id="_idIndexMarker1079"/><span class="koboSpan" id="kobo.290.1">contains </span><code class="inlineCode"><span class="koboSpan" id="kobo.291.1">Name</span></code><span class="koboSpan" id="kobo.292.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.293.1">Surname</span></code><span class="koboSpan" id="kobo.294.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.295.1">Address</span></code><span class="koboSpan" id="kobo.296.1"> string fields. </span><span class="koboSpan" id="kobo.296.2">This object is served by </span><strong class="keyWord"><span class="koboSpan" id="kobo.297.1">S1</span></strong><span class="koboSpan" id="kobo.298.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.299.1">{
    </span><span class="hljs-attr"><span class="koboSpan" id="kobo.300.1">Name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.301.1">string</span></span><span class="koboSpan" id="kobo.302.1">,
    </span><span class="hljs-attr"><span class="koboSpan" id="kobo.303.1">Surname:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.304.1">string</span></span><span class="koboSpan" id="kobo.305.1">,
    </span><span class="hljs-attr"><span class="koboSpan" id="kobo.306.1">Address:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.307.1">string</span></span><span class="koboSpan" id="kobo.308.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.309.1">Type compatibility is ensured if the service and client refer to different copies of the preceding definition. </span><span class="koboSpan" id="kobo.309.2">It is also acceptable for the client to use a definition with fewer fields since it can simply ignore all the other fields:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.310.1">{
    </span><span class="hljs-attr"><span class="koboSpan" id="kobo.311.1">Name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.312.1">string</span></span><span class="koboSpan" id="kobo.313.1">,
    </span><span class="hljs-attr"><span class="koboSpan" id="kobo.314.1">Surname:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.315.1">string</span></span><span class="koboSpan" id="kobo.316.1">,
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.317.1">You can only use a definition with fewer fields within your “own” code. </span><span class="koboSpan" id="kobo.317.2">Attempting to send information back to the server without the expected fields may cause problems.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.318.1">Now, imagine the scenario where you have an </span><strong class="keyWord"><span class="koboSpan" id="kobo.319.1">S2</span></strong><span class="koboSpan" id="kobo.320.1"> service that takes </span><code class="inlineCode"><span class="koboSpan" id="kobo.321.1">Person</span></code><span class="koboSpan" id="kobo.322.1"> objects from </span><strong class="keyWord"><span class="koboSpan" id="kobo.323.1">S1</span></strong><span class="koboSpan" id="kobo.324.1"> and adds them to the responses it returns on some of its methods. </span><span class="koboSpan" id="kobo.324.2">Suppose the </span><strong class="keyWord"><span class="koboSpan" id="kobo.325.1">S1</span></strong><span class="koboSpan" id="kobo.326.1"> service that handles the </span><code class="inlineCode"><span class="koboSpan" id="kobo.327.1">Person</span></code><span class="koboSpan" id="kobo.328.1"> object replaces the </span><code class="inlineCode"><span class="koboSpan" id="kobo.329.1">Address</span></code><span class="koboSpan" id="kobo.330.1"> string with a complex object:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.331.1">{
    </span><span class="hljs-attr"><span class="koboSpan" id="kobo.332.1">Name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.333.1">string</span></span><span class="koboSpan" id="kobo.334.1">,
    </span><span class="hljs-attr"><span class="koboSpan" id="kobo.335.1">Surname:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.336.1">string</span></span><span class="koboSpan" id="kobo.337.1">,
    </span><span class="hljs-attr"><span class="koboSpan" id="kobo.338.1">Address:</span></span><span class="koboSpan" id="kobo.339.1">
        {
            </span><span class="hljs-attr"><span class="koboSpan" id="kobo.340.1">Country:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.341.1">string</span></span><span class="koboSpan" id="kobo.342.1">,
            </span><span class="hljs-attr"><span class="koboSpan" id="kobo.343.1">Town:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.344.1">string</span></span><span class="koboSpan" id="kobo.345.1">,
            </span><span class="hljs-attr"><span class="koboSpan" id="kobo.346.1">Location:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.347.1">string</span></span><span class="koboSpan" id="kobo.348.1">
        }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.349.1">After the breaking change, the </span><strong class="keyWord"><span class="koboSpan" id="kobo.350.1">S2</span></strong><span class="koboSpan" id="kobo.351.1"> service will have to adapt its communication client that calls the </span><strong class="keyWord"><span class="koboSpan" id="kobo.352.1">S1</span></strong><span class="koboSpan" id="kobo.353.1"> service to the new format. </span><span class="koboSpan" id="kobo.353.2">Then, it can convert the new </span><code class="inlineCode"><span class="koboSpan" id="kobo.354.1">Person</span></code><span class="koboSpan" id="kobo.355.1"> format into the older one before using </span><code class="inlineCode"><span class="koboSpan" id="kobo.356.1">Person</span></code><span class="koboSpan" id="kobo.357.1"> objects in its responses. </span><span class="koboSpan" id="kobo.357.2">This way, the </span><strong class="keyWord"><span class="koboSpan" id="kobo.358.1">S2</span></strong><span class="koboSpan" id="kobo.359.1"> service avoids propagating the breaking change of </span><strong class="keyWord"><span class="koboSpan" id="kobo.360.1">S1</span></strong><span class="koboSpan" id="kobo.361.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.362.1">In general, basing type compatibility on the object shape (tree of nested properties) instead of a reference to the same formal type definition increases flexibility and modifiability. </span><span class="koboSpan" id="kobo.362.2">The price we pay for this increased flexibility is that type compatibility cannot be computed automatically by comparing the formal definition of server and client interfaces. </span><span class="koboSpan" id="kobo.362.3">In fact, in the absence of a univocal specification, each time a new version of the service is released, the developer must verify that the semantics of all the fields that the client and </span><a id="_idIndexMarker1080"/><span class="koboSpan" id="kobo.363.1">server have in common remain unchanged from the previous version.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.364.1">The basic idea behind REST services is to give up the severity checks and complex protocols for greater flexibility and simplicity, while SOAP does exactly the opposite.</span></p>
<h2 class="heading-2" id="_idParaDest-310"><span class="koboSpan" id="kobo.365.1">REST and native HTTP features</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.366.1">The REST services manifesto states</span><a id="_idIndexMarker1081"/><span class="koboSpan" id="kobo.367.1"> that REST uses native HTTP features to implement all the required service features. </span><span class="koboSpan" id="kobo.367.2">So, for instance, authentication will be performed directly with the HTTP </span><code class="inlineCode"><span class="koboSpan" id="kobo.368.1">Authorization</span></code><span class="koboSpan" id="kobo.369.1"> field, encryption will be achieved with HTTPS, exceptions will be handled with an HTTP error status code, and routing and reliable messaging will be handled by the machinery the HTTP protocol relies on. </span><span class="koboSpan" id="kobo.369.2">Addressing is achieved by using URLs to refer to services, their methods, and other resources.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.370.1">There is no native support for asynchronous communication since HTTP is a synchronous protocol. </span><span class="koboSpan" id="kobo.370.2">There is also no native support for the Publisher/Subscriber pattern, but two services can interact with the Publisher/Subscriber pattern by each exposing an endpoint to the other. </span><span class="koboSpan" id="kobo.370.3">More specifically, the first service exposes a subscription endpoint, while the second one exposes an endpoint where it receives its notifications, which are authorized through a common secret that is exchanged during the subscription. </span><span class="koboSpan" id="kobo.370.4">This pattern is quite common. </span><span class="koboSpan" id="kobo.370.5">GitHub also allows us to send repository events to our REST services.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.371.1">REST services offer no easy options when it comes to implementing distributed transactions, since HTTP is stateless. </span><span class="koboSpan" id="kobo.371.2">However, approaches like the SAGA pattern, described in </span><em class="italic"><span class="koboSpan" id="kobo.372.1">Chapter 14, Implementing Microservices with .NET</span></em><span class="koboSpan" id="kobo.373.1">, and event sourcing, described in </span><em class="italic"><span class="koboSpan" id="kobo.374.1">Chapter 7, Understanding the Different Domains in Software Solutions</span></em><span class="koboSpan" id="kobo.375.1">, helped a lot in the last years to solve this difficulty. </span><span class="koboSpan" id="kobo.375.2">Besides, luckily, most application areas do not need the strong form of consistency that is ensured by distributed transactions. </span><span class="koboSpan" id="kobo.375.3">For them, lighter forms of consistency, such as </span><em class="italic"><span class="koboSpan" id="kobo.376.1">eventual consistency</span></em><span class="koboSpan" id="kobo.377.1">, are enough and are preferred for performance reasons. </span><span class="koboSpan" id="kobo.377.2">Please refer to </span><em class="italic"><span class="koboSpan" id="kobo.378.1">Chapter 12</span></em><span class="koboSpan" id="kobo.379.1">, </span><em class="italic"><span class="koboSpan" id="kobo.380.1">Choosing Your Data Storage in the Cloud</span></em><span class="koboSpan" id="kobo.381.1">, for a discussion on the various types of consistencies.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.382.1">The REST manifesto not only prescribes the usage of the predefined solutions that are already available in HTTP but</span><a id="_idIndexMarker1082"/><span class="koboSpan" id="kobo.383.1"> also the usage of a web-like semantic. </span><span class="koboSpan" id="kobo.383.2">In general, service operations can be conceived as CRUD operations, but not limited to them on resources that are identified by URLs (the same resource may be identified by several URLs). </span><span class="koboSpan" id="kobo.383.3">In fact, REST is an acronym for </span><strong class="keyWord"><span class="koboSpan" id="kobo.384.1">Representational State Transfer</span></strong><span class="koboSpan" id="kobo.385.1">, meaning</span><a id="_idIndexMarker1083"/><span class="koboSpan" id="kobo.386.1"> that each URL is the representation of some sort of entity. </span><span class="koboSpan" id="kobo.386.2">As a best practice, each kind of service request needs to adopt the appropriate HTTP verb and return the status code as follows:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.387.1">GET</span></code><span class="koboSpan" id="kobo.388.1"> (read operation): The URL represents the resource that is returned by the read operation. </span><span class="koboSpan" id="kobo.388.2">Thus, </span><code class="inlineCode"><span class="koboSpan" id="kobo.389.1">GET</span></code><span class="koboSpan" id="kobo.390.1"> operations mimic pointer dereferencing. </span><span class="koboSpan" id="kobo.390.2">In the case of a successful operation, a 200 (OK) status code is returned.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.391.1">POST</span></code><span class="koboSpan" id="kobo.392.1"> (creation operation): The JSON/XML object that is contained in the request body is added as a new resource to the object represented by the operation URL. </span><span class="koboSpan" id="kobo.392.2">If the new resource is successfully created immediately, a 201 (created) status code is returned, along with a response object that depends on the operation and an indication as to where the created resource can be retrieved from. </span><span class="koboSpan" id="kobo.392.3">The response object should contain the most specific URL that identifies the created resource. </span><span class="koboSpan" id="kobo.392.4">If creation is deferred to a later time, a 202 (accepted) status code is returned.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.393.1">PUT</span></code><span class="koboSpan" id="kobo.394.1"> (edit operation): The JSON/XML object contained in the request body replaces the object referenced by the request URL. </span><span class="koboSpan" id="kobo.394.2">In the case of a successful operation, a 200 (OK) status code is returned. </span><span class="koboSpan" id="kobo.394.3">This operation is idempotent, meaning that repeating the same request twice causes the same modification. </span><span class="koboSpan" id="kobo.394.4">204 (No Content) is also a possible return value.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.395.1">PATCH</span></code><span class="koboSpan" id="kobo.396.1">: The JSON/XML object contained in the request body contains instructions on how to modify the object referenced by the request URL. </span><span class="koboSpan" id="kobo.396.2">This operation is not idempotent since the modification may be an increment of a numeric field. </span><span class="koboSpan" id="kobo.396.3">In the case of a successful operation, a 200 (OK) status code is returned.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.397.1">DELETE</span></code><span class="koboSpan" id="kobo.398.1">: The resource referenced by the request URL is removed. </span><span class="koboSpan" id="kobo.398.2">In the case of a successful operation, a 200 (OK) status code is returned.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.399.1">If the resource has been moved from the request URL to another URL, a redirect code is returned:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.400.1">301</span></code><span class="koboSpan" id="kobo.401.1"> (moved permanently), plus the new URL where we can find the resource</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.402.1">307</span></code><span class="koboSpan" id="kobo.403.1"> (moved temporarily), plus the new URL where we can find the resource</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.404.1">If the operation fails, a status code that</span><a id="_idIndexMarker1084"/><span class="koboSpan" id="kobo.405.1"> depends on the kind of failure is returned. </span><span class="koboSpan" id="kobo.405.2">Some examples of failure codes are as follows:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.406.1">400</span></code><span class="koboSpan" id="kobo.407.1"> (bad request): The request that was sent to the server is ill formed.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.408.1">404</span></code><span class="koboSpan" id="kobo.409.1"> (not found): When the request URL does not refer to any known object.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.410.1">405</span></code><span class="koboSpan" id="kobo.411.1"> (method not allowed): When the request verb is not supported by the resource referenced by the URL.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.412.1">401</span></code><span class="koboSpan" id="kobo.413.1"> (unauthorized): The operation requires authentication, but the client has not furnished any valid authorization header.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.414.1">403</span></code><span class="koboSpan" id="kobo.415.1"> (forbidden): The client is correctly authenticated but has no right to perform the operation.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.416.1">409</span></code><span class="koboSpan" id="kobo.417.1"> (conflict): The operation failed due to some conflict with the current state of the server.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.418.1">412</span></code><span class="koboSpan" id="kobo.419.1"> (precondition failed): The operation failed due to some precondition desired.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.420.1">422</span></code><span class="koboSpan" id="kobo.421.1"> (unprocessable content): The request was well formatted, but there are semantic errors in it.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.422.1">The preceding list of status codes is not exhaustive. </span><span class="koboSpan" id="kobo.422.2">A reference to an exhaustive list will be provided in the </span><em class="italic"><span class="koboSpan" id="kobo.423.1">Further reading</span></em><span class="koboSpan" id="kobo.424.1"> section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.425.1">It is fundamental to point out that </span><code class="inlineCode"><span class="koboSpan" id="kobo.426.1">POST</span></code><span class="koboSpan" id="kobo.427.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.428.1">PUT</span></code><span class="koboSpan" id="kobo.429.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.430.1">PATCH</span></code><span class="koboSpan" id="kobo.431.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.432.1">DELETE</span></code><span class="koboSpan" id="kobo.433.1"> operations may have – and usually have – side effects on other resources. </span><span class="koboSpan" id="kobo.433.2">Otherwise, it would be impossible to code operations that act simultaneously on several resources.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.434.1">In other words, the HTTP verb must conform with the operation that is performed on the resource and referenced by the request URL, but the operation might affect other resources. </span><span class="koboSpan" id="kobo.434.2">The same operation might be performed with a different HTTP verb on one of the other involved resources. </span><span class="koboSpan" id="kobo.434.3">It is the developer’s responsibility to choose which way to perform the same operation to implement it in the service interface.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.435.1">Thanks to the side effects of HTTP verbs, REST services can encode all these operations as CRUD operations on resources represented by URLs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.436.1">Often, moving an existing service to REST requires us to split the various inputs between the request URL and the request body. </span><span class="koboSpan" id="kobo.436.2">More specifically, we extract the input fields that univocally define one of the objects involved in the method’s execution and use them to create a URL that univocally identifies that object. </span><span class="koboSpan" id="kobo.436.3">Then, we decide on which HTTP verb to use based on the operation that is </span><a id="_idIndexMarker1085"/><span class="koboSpan" id="kobo.437.1">performed on the selected object. </span><span class="koboSpan" id="kobo.437.2">Finally, we place the remainder of the input in the request body.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.438.1">If our services were designed with an object-oriented architecture focused on the business domain objects (such as DDD, as described in </span><em class="italic"><span class="koboSpan" id="kobo.439.1">Chapter 7, Understanding the Different Domains in Software Solutions</span></em><span class="koboSpan" id="kobo.440.1">), the REST translation of all the service methods should be quite immediate since services should already be organized around domain resources. </span><span class="koboSpan" id="kobo.440.2">Otherwise, moving to REST might require some service interface redefinitions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.441.1">The adoption of full REST semantics has the advantage that services can be extended with or without small modifications being made to the preexisting operation definitions. </span><span class="koboSpan" id="kobo.441.2">In fact, extensions should mainly manifest as additional properties of some objects and as additional resource URLs with some associated operations. </span><span class="koboSpan" id="kobo.441.3">Therefore, preexisting clients can simply ignore them.</span></p>
<h2 class="heading-2" id="_idParaDest-311"><span class="koboSpan" id="kobo.442.1">Example of methods in the REST language</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.443.1">Now, let us learn how methods can be </span><a id="_idIndexMarker1086"/><span class="koboSpan" id="kobo.444.1">expressed in the REST language with a simple example of an intra-bank money transfer. </span><span class="koboSpan" id="kobo.444.2">We will present here two approaches.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.445.1">In the first one, a bank account can be represented by a URL as follows:</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.446.1">https://mybank.com/accounts/{bank account number}</span></code></p>
<p class="normal"><span class="koboSpan" id="kobo.447.1">If we imagine a bank transfer we may represent it as a </span><code class="inlineCode"><span class="koboSpan" id="kobo.448.1">PATCH</span></code><span class="koboSpan" id="kobo.449.1"> request, whose body contains an object with properties representing the amount of money, time of transfer, description, and the account receiving the money.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.450.1">The operation modifies the account mentioned in the URL but also the receiving account as a </span><em class="italic"><span class="koboSpan" id="kobo.451.1">side effect</span></em><span class="koboSpan" id="kobo.452.1">. </span><span class="koboSpan" id="kobo.452.2">If the account doesn’t have enough money, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.453.1">409</span></code><span class="koboSpan" id="kobo.454.1"> (conflict) status code is returned, along with an object with all the error details (an error description, the available funds, and so on).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.455.1">However, since all the bank operations are recorded in the account statement, the creation and addition of a new transfer object for a </span><em class="italic"><span class="koboSpan" id="kobo.456.1">bank account operations</span></em><span class="koboSpan" id="kobo.457.1"> collection associated with the bank account is a better way to represent the transfer. </span><span class="koboSpan" id="kobo.457.2">In this second approach, the URL might be something like the following:</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.458.1">https://mybank.com/accounts/{bank account number}/transactions</span></code></p>
<p class="normal"><span class="koboSpan" id="kobo.459.1">Here, the HTTP verb is </span><code class="inlineCode"><span class="koboSpan" id="kobo.460.1">POST</span></code><span class="koboSpan" id="kobo.461.1"> since we are creating a new object. </span><span class="koboSpan" id="kobo.461.2">The body content is the same, and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.462.1">422</span></code><span class="koboSpan" id="kobo.463.1"> status code is returned if there is a lack of funds.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.464.1">Both representations of</span><a id="_idIndexMarker1087"/><span class="koboSpan" id="kobo.465.1"> the transfer cause the same changes in the database. </span><span class="koboSpan" id="kobo.465.2">Moreover, once the inputs are extracted from the different URLs and from the possibly different request bodies, the subsequent processing is the same. </span><span class="koboSpan" id="kobo.465.3">In both cases, we have the same inputs and the same processing – it is just the exterior appearance of the two requests that are different.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.466.1">However, the introduction of the virtual </span><em class="italic"><span class="koboSpan" id="kobo.467.1">transactions</span></em><span class="koboSpan" id="kobo.468.1"> collection allows us to extend the service with several more </span><em class="italic"><span class="koboSpan" id="kobo.469.1">transaction</span></em><span class="koboSpan" id="kobo.470.1"> collection-specific methods. </span><span class="koboSpan" id="kobo.470.2">It is worth pointing out that the </span><em class="italic"><span class="koboSpan" id="kobo.471.1">transaction </span></em><span class="koboSpan" id="kobo.472.1">collection does not need to relate to a database table or any physical object: it lives in the world of URLs and creates a convenient way for us to model the transfer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.473.1">The increased usage of REST services leads to a description of REST service interfaces to be created like the ones developed for SOAP. </span><span class="koboSpan" id="kobo.473.2">This</span><a id="_idIndexMarker1088"/><span class="koboSpan" id="kobo.474.1"> standard is called </span><strong class="keyWord"><span class="koboSpan" id="kobo.475.1">OpenAPI</span></strong><span class="koboSpan" id="kobo.476.1">. </span><span class="koboSpan" id="kobo.476.2">We will talk about this in the following subsection.</span></p>
<h2 class="heading-2" id="_idParaDest-312"><span class="koboSpan" id="kobo.477.1">The OpenAPI standard</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.478.1">OpenAPI is a specification that is used </span><a id="_idIndexMarker1089"/><span class="koboSpan" id="kobo.479.1">worldwide for describing the REST APIs. </span><span class="koboSpan" id="kobo.479.2">The OpenAPI Initiative was founded in November 2015, as an open-source project under the Linux Foundation, with the help of companies like SmartBear, Google, IBM, and Microsoft. </span><span class="koboSpan" id="kobo.479.3">The specification is currently versioned as 3.1. </span><span class="koboSpan" id="kobo.479.4">The whole service is described by a JSON or YAML endpoint, that is, an endpoint that describes the service with a JSON object. </span><span class="koboSpan" id="kobo.479.5">This JSON object has a general section that applies to the whole service and contains the general features of the service, such as its version and description, as well as shared definitions.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.480.1">You can find OpenAPI Specification examples at </span><a href="https://github.com/OAI/OpenAPI-Specification/"><span class="url"><span class="koboSpan" id="kobo.481.1">https://github.com/OAI/OpenAPI-Specification/</span></span></a><span class="koboSpan" id="kobo.482.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.483.1">Then, each service endpoint has a specific section that describes the endpoint URL or URL format (in case some inputs are included in the URL), all its inputs, all the possible output types and status codes, and all the authorization protocols. </span><span class="koboSpan" id="kobo.483.2">Each endpoint-specific section can reference the </span><a id="_idIndexMarker1090"/><span class="koboSpan" id="kobo.484.1">definitions contained in the general section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.485.1">A complete description of the OpenAPI syntax is out of the scope of this book, but you will find visual editors on the Internet that can help you clarify the specification mentioned before. </span><span class="koboSpan" id="kobo.485.2">A great example is provided by SmartBear, one of the companies that founded the initiative, and it is called Swagger </span><a id="_idIndexMarker1091"/><span class="koboSpan" id="kobo.486.1">Editor. </span><span class="koboSpan" id="kobo.486.2">In the beta version of the online tool, you can load an example using OpenAPI version 3.1.0. </span><span class="koboSpan" id="kobo.486.3">This helps companies to create API contracts even before deciding the programming language of the API.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.487.1">Various development frameworks automatically generate OpenAPI documentation by processing the REST API code, and further information is provided by the developer, so your team does not need to have in-depth knowledge of OpenAPI syntax. </span><span class="koboSpan" id="kobo.487.2">An example of this is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.488.1">Swashbuckle.AspNetCore</span></code><span class="koboSpan" id="kobo.489.1"> NuGet package that we will present in this chapter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.490.1">The </span><em class="italic"><span class="koboSpan" id="kobo.491.1">How does .NET 8 deal with SOA?</span></em><span class="koboSpan" id="kobo.492.1"> section explains how we can automatically generate OpenAPI documentation in ASP.NET Core REST API projects, while the use case presented in </span><em class="italic"><span class="koboSpan" id="kobo.493.1">Chapter 21, Case Study, </span></em><span class="koboSpan" id="kobo.494.1">will provide a practical example of its usage.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.495.1">We will end this subsection by talking about how to handle authentication and authorization in REST services.</span></p>
<h2 class="heading-2" id="_idParaDest-313"><span class="koboSpan" id="kobo.496.1">REST service authorization and authentication</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.497.1">Since REST services are stateless, when</span><a id="_idIndexMarker1092"/><span class="koboSpan" id="kobo.498.1"> authentication is required, the client must send an authentication token in every single request. </span><span class="koboSpan" id="kobo.498.2">That token is usually placed in the HTTP authorization header, but this depends on the type of authentication protocol you are using. </span><span class="koboSpan" id="kobo.498.3">The simplest way to authenticate is through the explicit transmission of a shared secret. </span><span class="koboSpan" id="kobo.498.4">This can be done with the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.499.1">Authorization:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.500.1">Api-Key</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.501.1">&lt;string</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.502.1">known</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.503.1">by</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.504.1">both</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.505.1">server</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.506.1">and</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.507.1">client&gt;</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.508.1">The shared secret is called an API key. </span><span class="koboSpan" id="kobo.508.2">Since, at the time of writing, there is no standard on how to send it, API keys can also be sent in other headers, as shown in the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.509.1">X-API-Key:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.510.1">&lt;string</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.511.1">known</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.512.1">by</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.513.1">both</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.514.1">server</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.515.1">and</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.516.1">client&gt;</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.517.1">It is worth mentioning that API-key-based authentication needs HTTPS to stop shared secrets from being stolen. </span><span class="koboSpan" id="kobo.517.2">API keys are very simple to use, but they do not convey information about user authorizations, so they can be adopted when the operations allowed by the client are quite standard, and there are no complex authorization patterns. </span><span class="koboSpan" id="kobo.517.3">Moreover, when exchanged in requests, API keys are susceptible to being attacked on the server or client side. </span><span class="koboSpan" id="kobo.517.4">A common pattern to mitigate this is to create a “service account” user and </span><a id="_idIndexMarker1093"/><span class="koboSpan" id="kobo.518.1">restrict their authorizations to just those needed and use the API keys from that specific account when interacting with the API.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.519.1">If you need a more sophisticated authentication service, you may consider using the OAuth 2.0 protocol. </span><span class="koboSpan" id="kobo.519.2">For instance, when you implement “Sign in with [Some specific social media],” you are probably using this protocol. </span><span class="koboSpan" id="kobo.519.3">Of course, to use it, you have to define an authentication service provider.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.520.1">Safer techniques use shared secrets that are valid for a long period of time, just by the user logging in. </span><span class="koboSpan" id="kobo.520.2">Then, the login returns a short-life token that is used as a shared secret in all the subsequent requests. </span><span class="koboSpan" id="kobo.520.3">When the short-lived secret is going to expire, it can be renewed with a call to a renew endpoint.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.521.1">The whole logic is completely decoupled from the short-life token-based authorization logic. </span><span class="koboSpan" id="kobo.521.2">The login is usually based on login endpoints that receive long-term credentials and return short-life tokens. </span><span class="koboSpan" id="kobo.521.3">Login credentials are either usual username-password pairs that are passed as input to the login method or other kinds of authorization tokens that are converted into short-life tokens that are served by the login endpoint. </span><span class="koboSpan" id="kobo.521.4">Login can also be achieved with various authentication protocols based on X.509 certificates.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.522.1">The most widespread </span><a id="_idIndexMarker1094"/><span class="koboSpan" id="kobo.523.1">short-life token type is the so-called bearer token. </span><span class="koboSpan" id="kobo.523.2">Each bearer token encodes information about how long it lasts and a list of assertions, called claims, that can be used for authorization purposes. </span><span class="koboSpan" id="kobo.523.3">Bearer tokens are returned by either login operations or renewal operations. </span><span class="koboSpan" id="kobo.523.4">Their characteristic feature is that they are not tied to the client that receives them or to any other specific client, but they identify the client, which can simply use them in its invocations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.524.1">No matter how a client gets a bearer token, this is all a client needs to be granted, including all the rights implied by its claims. </span><span class="koboSpan" id="kobo.524.2">It is enough to transfer a bearer token to another client to empower that client with all the rights implied by all the bearer token claims since no proof of identity is required by bearer-token-based authorization.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.525.1">Therefore, once a client gets a bearer token, it can delegate some operations to third parties by transferring its bearer token to them. </span><span class="koboSpan" id="kobo.525.2">Typically, when a bearer token must be used for delegation, during the login phase, the client specifies the claims to include to restrict what operations can be </span><a id="_idIndexMarker1095"/><span class="koboSpan" id="kobo.526.1">authorized by the token.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.527.1">Compared to API key authentication, bearer-token-based authentication is disciplined by standards. </span><span class="koboSpan" id="kobo.527.2">They must use the following </span><code class="inlineCode"><span class="koboSpan" id="kobo.528.1">Authorization</span></code><span class="koboSpan" id="kobo.529.1"> header:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.530.1">Authorization: Bearer &lt;bearer token </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.531.1">string</span></span><span class="koboSpan" id="kobo.532.1">&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.533.1">Bearer tokens can be implemented in several ways. </span><span class="koboSpan" id="kobo.533.2">REST services typically use JWTs that are strings with a Base64 URL encoding of JSON objects. </span><span class="koboSpan" id="kobo.533.3">More specifically, JWT creation starts with a JSON header, as well as a JSON payload. </span><span class="koboSpan" id="kobo.533.4">The JSON header specifies the kind of token and how it is signed, while the payload consists of a JSON object that contains all the claims as property/value pairs. </span><span class="koboSpan" id="kobo.533.5">The following is an example header:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.534.1">{
  </span><span class="hljs-attr"><span class="koboSpan" id="kobo.535.1">"alg":</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.536.1">"RS256"</span></span><span class="koboSpan" id="kobo.537.1">,
  </span><span class="hljs-attr"><span class="koboSpan" id="kobo.538.1">"typ":</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.539.1">"JWT"</span></span><span class="koboSpan" id="kobo.540.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.541.1">The following is an example payload:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.542.1">{
  </span><span class="hljs-attr"><span class="koboSpan" id="kobo.543.1">"iss":</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.544.1">"wwtravelclub.com"</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.545.1">"sub":</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.546.1">"example"</span></span><span class="koboSpan" id="kobo.547.1">,
  </span><span class="hljs-attr"><span class="koboSpan" id="kobo.548.1">"aud":</span></span><span class="koboSpan" id="kobo.549.1"> [</span><span class="hljs-string"><span class="koboSpan" id="kobo.550.1">"S1"</span></span><span class="koboSpan" id="kobo.551.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.552.1">"S2"</span></span><span class="koboSpan" id="kobo.553.1">],
  </span><span class="hljs-attr"><span class="koboSpan" id="kobo.554.1">"roles":</span></span><span class="koboSpan" id="kobo.555.1"> [
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.556.1">"ADMIN"</span></span><span class="koboSpan" id="kobo.557.1">,
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.558.1">"USER"</span></span><span class="koboSpan" id="kobo.559.1">
  ],
  </span><span class="hljs-attr"><span class="koboSpan" id="kobo.560.1">"exp":</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.561.1">1512975450</span></span><span class="koboSpan" id="kobo.562.1">,
  </span><span class="hljs-attr"><span class="koboSpan" id="kobo.563.1">"iat":</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.564.1">1512968250230</span></span><span class="koboSpan" id="kobo.565.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.566.1">Then, the header and payload are Base64 URL-encoded, and the corresponding string is concatenated as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag"><span class="koboSpan" id="kobo.567.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.568.1">header</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.569.1">BASE64</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.570.1">string</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.571.1">&gt;</span></span><span class="koboSpan" id="kobo.572.1">.</span><span class="hljs-tag"><span class="koboSpan" id="kobo.573.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.574.1">payload</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.575.1">base64</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.576.1">string</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.577.1">&gt;</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.578.1">The preceding string is then signed with the algorithm specified in the header, which, in our example, is </span><code class="inlineCode"><span class="koboSpan" id="kobo.579.1">RSA +SHA256</span></code><span class="koboSpan" id="kobo.580.1">, and the signature string is concatenated with the original string as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag"><span class="koboSpan" id="kobo.581.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.582.1">header</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.583.1">BASE64</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.584.1">string</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.585.1">&gt;</span></span><span class="koboSpan" id="kobo.586.1">.</span><span class="hljs-tag"><span class="koboSpan" id="kobo.587.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.588.1">payload</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.589.1">base64</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.590.1">string</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.591.1">&gt;</span></span><span class="koboSpan" id="kobo.592.1">.</span><span class="hljs-tag"><span class="koboSpan" id="kobo.593.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.594.1">signature</span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="koboSpan" id="kobo.595.1">string</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.596.1">&gt;</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.597.1">The preceding code is the final bearer token string. </span><span class="koboSpan" id="kobo.597.2">A symmetric signature can be used instead of RSA, but, in this case, both</span><a id="_idIndexMarker1096"/><span class="koboSpan" id="kobo.598.1"> the JWT issuer and all the services using it for authorization must share a common secret, while, with RSA, the private key of the JWT issuer does not need to be shared with anyone, since the signature can be verified with just the issuer public key.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.599.1">Some payload properties are standard, such as the following:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.600.1">iss</span></code><span class="koboSpan" id="kobo.601.1">: Issuer of the JWT.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.602.1">aud</span></code><span class="koboSpan" id="kobo.603.1">: The audience, that is, the services and/or operations that can use the token for authorization. </span><span class="koboSpan" id="kobo.603.2">If a service does not see its identifier within this list, it should reject the token.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.604.1">sub</span></code><span class="koboSpan" id="kobo.605.1">: A string that identifies the </span><em class="italic"><span class="koboSpan" id="kobo.606.1">principal</span></em><span class="koboSpan" id="kobo.607.1"> (that is, the user) to which the JWT was issued.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.608.1">iat</span></code><span class="koboSpan" id="kobo.609.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.610.1">exp</span></code><span class="koboSpan" id="kobo.611.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.612.1">nbf</span></code><span class="koboSpan" id="kobo.613.1">: These are for the time the JWT was issued, its expiration time, and, if set, the time after which the token is valid, respectively. </span><span class="koboSpan" id="kobo.613.2">All the times are expressed as seconds from midnight UTC on January 1, 1970. </span><span class="koboSpan" id="kobo.613.3">Here, all the days are considered as having exactly 86,400 seconds in them.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.614.1">Other claims may be defined as public if we represent them with a unique URI; otherwise, they are considered private to the issuer and to the services known to the issuer.</span></p>
<h2 class="heading-2" id="_idParaDest-314"><span class="koboSpan" id="kobo.615.1">API versioning</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.616.1">Considering a natural scenario where</span><a id="_idIndexMarker1097"/><span class="koboSpan" id="kobo.617.1"> the number of APIs will increase in your application, and, more than that, the business logic will obviously evolve, as a software architect, you must decide how you are going to version the APIs, guaranteeing the compatibility between your services and the clients that consume these services.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.618.1">It is important to mention that there are several versioning options for doing so:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.619.1">URI</span></strong><span class="koboSpan" id="kobo.620.1">: It consists of defining the version of the API in its URI, for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.621.1">https://wwtravelclub.com/v1/trips</span></code><span class="koboSpan" id="kobo.622.1">.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.623.1">Parameter</span></strong><span class="koboSpan" id="kobo.624.1">: You can define a parameter in the request that defines the version, for instance, </span><code class="inlineCode"><span class="koboSpan" id="kobo.625.1">https://wwtravelclub.com/trips?version=2</span></code><span class="koboSpan" id="kobo.626.1">.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.627.1">Media type</span></strong><span class="koboSpan" id="kobo.628.1">: In this case, the desired version of the API will be presented in the HTTP </span><code class="inlineCode"><span class="koboSpan" id="kobo.629.1">Accept</span></code><span class="koboSpan" id="kobo.630.1"> header.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.631.1">Custom request header</span></strong><span class="koboSpan" id="kobo.632.1">: Like the media type versioning technique, but in this case the HTTP header will be customized by you.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.633.1">The first two alternatives are the most</span><a id="_idIndexMarker1098"/><span class="koboSpan" id="kobo.634.1"> commonly used, but the important point here is that you must consider crucial the implementation of a versioning technique.</span></p>
<h1 class="heading-1" id="_idParaDest-315"><span class="koboSpan" id="kobo.635.1">How does .NET 8 deal with SOA?</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.636.1">WCF technology has not been</span><a id="_idIndexMarker1099"/><span class="koboSpan" id="kobo.637.1"> ported to .NET 5+ and there are no plans to perform a complete port of it. </span><span class="koboSpan" id="kobo.637.2">Part of the source code was donated, and an open-source project started out of it. </span><span class="koboSpan" id="kobo.637.3">You can find information about this project at </span><a href="https://github.com/CoreWCF/CoreWCF"><span class="url"><span class="koboSpan" id="kobo.638.1">https://github.com/CoreWCF/CoreWCF</span></span></a><span class="koboSpan" id="kobo.639.1">. </span><span class="koboSpan" id="kobo.639.2">Instead, Microsoft is investing in gRPC, Google’s open-source technology. </span><span class="koboSpan" id="kobo.639.3">Besides, .NET 8 has excellent support for REST services through ASP.NET Core.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.640.1">There is a tool developed by Microsoft to help you with the migration of WCF applications to the latest .NET. </span><span class="koboSpan" id="kobo.640.2">You can find it at </span><a href="https://devblogs.microsoft.com/dotnet/migration-wcf-to-corewcf-upgrade-assistant/"><span class="url"><span class="koboSpan" id="kobo.641.1">https://devblogs.microsoft.com/dotnet/migration-wcf-to-corewcf-upgrade-assistant/</span></span></a><span class="koboSpan" id="kobo.642.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.643.1">The main reasons behind the decision to abandon WCF are as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.644.1">As we have already discussed, SOAP technology has been overtaken by REST technology in most application areas.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.645.1">WCF technology is strictly tied to Windows, so it would be very expensive to reimplement all its features from scratch in .NET 5+. </span><span class="koboSpan" id="kobo.645.2">Since support for full .NET will continue, users who need WCF can still rely on it.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.646.1">As a general strategy, with .NET 5+, Microsoft prefers investing in open-source technologies that can be shared with other competitors. </span><span class="koboSpan" id="kobo.646.2">That is why, instead of investing in WCF, Microsoft provided a gRPC implementation starting from .NET Core 3.0.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.647.1">The next subsections </span><a id="_idIndexMarker1100"/><span class="koboSpan" id="kobo.648.1">will cover the support provided inside Visual Studio for each technology we have mentioned.</span></p>
<h2 class="heading-2" id="_idParaDest-316"><span class="koboSpan" id="kobo.649.1">SOAP client support</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.650.1">In WCF, service specifications are </span><a id="_idIndexMarker1101"/><span class="koboSpan" id="kobo.651.1">defined through .NET interfaces, and the actual service code is supplied in classes that implement those interfaces. </span><span class="koboSpan" id="kobo.651.2">Endpoints, underlying protocols (HTTP and TCP/IP), and any other features are defined in a configuration file. </span><span class="koboSpan" id="kobo.651.3">In turn, the configuration file can be edited with an easy-to-use configuration tool. </span><span class="koboSpan" id="kobo.651.4">Therefore, the developer is responsible for providing just the service behavior as a standard .NET class and for configuring all the service features in a declarative way. </span><span class="koboSpan" id="kobo.651.5">This way, the service configuration is completely decoupled from the actual service behavior, and each service can be reconfigured so that it can be adapted to a different environment without the need to modify its code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.652.1">While .NET 8 does not support SOAP technology for creating new services, it does support the usage of SOAP clients when there are many SOAP services as legacy. </span><span class="koboSpan" id="kobo.652.2">More specifically, it is quite easy to create a SOAP service proxy for an existing SOAP service in Visual Studio (please refer to </span><em class="italic"><span class="koboSpan" id="kobo.653.1">Chapter 6</span></em><span class="koboSpan" id="kobo.654.1">, </span><em class="italic"><span class="koboSpan" id="kobo.655.1">Design Patterns and .NET 8 Implementation</span></em><span class="koboSpan" id="kobo.656.1">, for a discussion of what a proxy is and of the Proxy pattern).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.657.1">In the case of services, a proxy is a class that implements the service interface and whose methods perform their jobs by calling the analogous methods of the remote service.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.658.1">To create a service proxy, right-click </span><strong class="keyWord"><span class="koboSpan" id="kobo.659.1">Dependencies</span></strong><span class="koboSpan" id="kobo.660.1"> in your project in </span><strong class="keyWord"><span class="koboSpan" id="kobo.661.1">Solution Explorer</span></strong><span class="koboSpan" id="kobo.662.1">, and then select </span><strong class="keyWord"><span class="koboSpan" id="kobo.663.1">Add connected service</span></strong><span class="koboSpan" id="kobo.664.1">. </span><span class="koboSpan" id="kobo.664.2">Then, in the form that appears, select </span><strong class="keyWord"><span class="koboSpan" id="kobo.665.1">Microsoft WCF Service Reference Provider</span></strong><span class="koboSpan" id="kobo.666.1">. </span><span class="koboSpan" id="kobo.666.2">There, you can specify the URL of the service (where the WSDL service description is contained), the namespace where you wish to add the proxy class, and much more. </span><span class="koboSpan" id="kobo.666.3">At the end of the wizard, Visual Studio automatically adds all the necessary NuGet packages and scaffolds the proxy class. </span><span class="koboSpan" id="kobo.666.4">This is enough to create an instance of this class and to call its methods so that we can interact with the remote SOAP service.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.667.1">There are also third parties, such as NuGet packages, that provide limited support for SOAP services, but currently, they aren’t very useful since such limited support does not include features that aren’t available in </span><a id="_idIndexMarker1102"/><span class="koboSpan" id="kobo.668.1">REST services.</span></p>
<h2 class="heading-2" id="_idParaDest-317"><span class="koboSpan" id="kobo.669.1">gRPC support</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.670.1">The .NET SDK supports the gRPC </span><a id="_idIndexMarker1103"/><span class="koboSpan" id="kobo.671.1">project template, which scaffolds both a gRPC server and a gRPC client. </span><span class="koboSpan" id="kobo.671.2">gRPC implements a remote procedure call pattern that offers both synchronous and asynchronous calls, reducing the traffic of messages between the client and server.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.672.1">Using gRPC is super easy since Visual Studio’s gRPC project template scaffolds everything so that the gRPC service and its clients are working. </span><span class="koboSpan" id="kobo.672.2">The developer just needs to define the application-specific C# service interface and a class that implements it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.673.1">For configuring it, services are defined through interfaces written in a Protobuf file, and their code is provided in C# classes that implement those interfaces, while clients interact with those services through proxies that implement the same service interfaces.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.674.1">gRPC is a good option for internal communications within a microservices cluster. </span><span class="koboSpan" id="kobo.674.2">Since there are gRPC libraries for all the main languages and development frameworks, it can be used in Kubernetes-based clusters. </span><span class="koboSpan" id="kobo.674.3">Besides, gRPC is more efficient than the REST services protocol due to its more compact representation of data and its being easier to use since everything to do with the protocol is taken care of by the development framework.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.675.1">For this reason, we have added a brand-new chapter dedicated to discussing this implementation, </span><em class="italic"><span class="koboSpan" id="kobo.676.1">Chapter 14</span></em><span class="koboSpan" id="kobo.677.1">, </span><em class="italic"><span class="koboSpan" id="kobo.678.1">Implementing Microservices with .NET</span></em><span class="koboSpan" id="kobo.679.1">, and you can check details about the technology at </span><a href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-8.0"><span class="url"><span class="koboSpan" id="kobo.680.1">https://docs.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-8.0</span></span></a><span class="koboSpan" id="kobo.681.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.682.1">The remainder of the section is dedicated to .NET support for REST services from both the server and client sides.</span></p>
<h2 class="heading-2" id="_idParaDest-318"><span class="koboSpan" id="kobo.683.1">A short introduction to ASP.NET Core</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.684.1">ASP.NET Core applications are .NET </span><a id="_idIndexMarker1104"/><span class="koboSpan" id="kobo.685.1">applications based on the </span><em class="italic"><span class="koboSpan" id="kobo.686.1">Host</span></em><span class="koboSpan" id="kobo.687.1"> concept we described in the </span><em class="italic"><span class="koboSpan" id="kobo.688.1">Using generic hosts</span></em><span class="koboSpan" id="kobo.689.1"> subsection of </span><em class="italic"><span class="koboSpan" id="kobo.690.1">Chapter 11</span></em><span class="koboSpan" id="kobo.691.1">, </span><em class="italic"><span class="koboSpan" id="kobo.692.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.693.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.694.1">Using C# 12 and .NET 8, the template for creating ASP.NET Core apps has changed a bit. </span><span class="koboSpan" id="kobo.694.2">The main purpose is to simplify how we set it up. </span><span class="koboSpan" id="kobo.694.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.695.1">Program.cs</span></code><span class="koboSpan" id="kobo.696.1"> file of each ASP.NET application now creates a host, builds it, and runs it without needing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.697.1">Startup</span></code><span class="koboSpan" id="kobo.698.1"> class anymore, as we can see in the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.699.1">var</span></span><span class="koboSpan" id="kobo.700.1"> builder = WebApplication.CreateBuilder(args);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.701.1">// Add services to the container.</span></span><span class="koboSpan" id="kobo.702.1">
builder.Services.AddControllers();
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.703.1">// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle</span></span><span class="koboSpan" id="kobo.704.1">
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.705.1">var</span></span><span class="koboSpan" id="kobo.706.1"> app = builder.Build();
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.707.1">// Configure the HTTP request pipeline.</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.708.1">if</span></span><span class="koboSpan" id="kobo.709.1"> (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();
app.Run();
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.710.1">Environment</span></code><span class="koboSpan" id="kobo.711.1"> is taken from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.712.1">ASPNETCORE_ENVIRONMENT</span></code><span class="koboSpan" id="kobo.713.1"> environment variable. </span><span class="koboSpan" id="kobo.713.2">In turn, it is defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.714.1">Properties\launchSettings.json</span></code><span class="koboSpan" id="kobo.715.1"> file when the application runs in Visual Studio over </span><strong class="keyWord"><span class="koboSpan" id="kobo.716.1">Solution Explorer</span></strong><span class="koboSpan" id="kobo.717.1">. </span><span class="koboSpan" id="kobo.717.2">In this file, you can define several environments that can be selected with the dropdown next to Visual Studio’s run button, </span><strong class="keyWord"><span class="koboSpan" id="kobo.718.1">IIS Express</span></strong><span class="koboSpan" id="kobo.719.1">. </span><span class="koboSpan" id="kobo.719.2">By default, the </span><strong class="keyWord"><span class="koboSpan" id="kobo.720.1">IIS Express</span></strong><span class="koboSpan" id="kobo.721.1"> setting sets </span><code class="inlineCode"><span class="koboSpan" id="kobo.722.1">ASPNETCORE_ENVIRONMENT</span></code><span class="koboSpan" id="kobo.723.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.724.1">Development</span></code><span class="koboSpan" id="kobo.725.1">. </span><span class="koboSpan" id="kobo.725.2">The following is a typical </span><code class="inlineCode"><span class="koboSpan" id="kobo.726.1">launchSettings.json</span></code><span class="koboSpan" id="kobo.727.1"> file:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation"><span class="koboSpan" id="kobo.728.1">{</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.729.1">"iisSettings"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.730.1">:</span></span> <span class="hljs-punctuation"><span class="koboSpan" id="kobo.731.1">{</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.732.1">"windowsAuthentication"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.733.1">:</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.734.1">false</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.735.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.736.1">"anonymousAuthentication"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.737.1">:</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.738.1">true</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.739.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.740.1">"iisExpress"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.741.1">:</span></span> <span class="hljs-punctuation"><span class="koboSpan" id="kobo.742.1">{</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.743.1">"applicationUrl"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.744.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.745.1">"http://localhost:48638"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.746.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.747.1">"sslPort"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.748.1">:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.749.1">44367</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.750.1">}</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.751.1">},</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.752.1">"profiles"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.753.1">:</span></span> <span class="hljs-punctuation"><span class="koboSpan" id="kobo.754.1">{</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.755.1">"http"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.756.1">:</span></span> <span class="hljs-punctuation"><span class="koboSpan" id="kobo.757.1">{</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.758.1">"commandName"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.759.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.760.1">"Project"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.761.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.762.1">"dotnetRunMessages"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.763.1">:</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.764.1">true</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.765.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.766.1">"launchBrowser"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.767.1">:</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.768.1">true</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.769.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.770.1">"launchUrl"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.771.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.772.1">"swagger"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.773.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.774.1">"applicationUrl"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.775.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.776.1">"http://localhost:5085"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.777.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.778.1">"environmentVariables"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.779.1">:</span></span> <span class="hljs-punctuation"><span class="koboSpan" id="kobo.780.1">{</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.781.1">"ASPNETCORE_ENVIRONMENT"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.782.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.783.1">"Development"</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.784.1">}</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.785.1">},</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.786.1">"https"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.787.1">:</span></span> <span class="hljs-punctuation"><span class="koboSpan" id="kobo.788.1">{</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.789.1">"commandName"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.790.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.791.1">"Project"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.792.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.793.1">"dotnetRunMessages"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.794.1">:</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.795.1">true</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.796.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.797.1">"launchBrowser"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.798.1">:</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.799.1">true</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.800.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.801.1">"launchUrl"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.802.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.803.1">"swagger"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.804.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.805.1">"applicationUrl"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.806.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.807.1">"https://localhost:7214;http://localhost:5085"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.808.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.809.1">"environmentVariables"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.810.1">:</span></span> <span class="hljs-punctuation"><span class="koboSpan" id="kobo.811.1">{</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.812.1">"ASPNETCORE_ENVIRONMENT"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.813.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.814.1">"Development"</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.815.1">}</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.816.1">},</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.817.1">"IIS Express"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.818.1">:</span></span> <span class="hljs-punctuation"><span class="koboSpan" id="kobo.819.1">{</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.820.1">"commandName"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.821.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.822.1">"IISExpress"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.823.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.824.1">"launchBrowser"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.825.1">:</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.826.1">true</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.827.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.828.1">"launchUrl"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.829.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.830.1">"swagger"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.831.1">,</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.832.1">"environmentVariables"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.833.1">:</span></span> <span class="hljs-punctuation"><span class="koboSpan" id="kobo.834.1">{</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.835.1">"ASPNETCORE_ENVIRONMENT"</span></span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.836.1">:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.837.1">"Development"</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.838.1">}</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.839.1">}</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.840.1">}</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.841.1">}</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.842.1">The value to use for </span><code class="inlineCode"><span class="koboSpan" id="kobo.843.1">ASPNETCORE_ENVIRONMENT</span></code><span class="koboSpan" id="kobo.844.1"> when the application is published can be added to the published XML file after</span><a id="_idIndexMarker1105"/><span class="koboSpan" id="kobo.845.1"> it has been created by Visual Studio. </span><span class="koboSpan" id="kobo.845.2">This value is </span><code class="inlineCode"><span class="koboSpan" id="kobo.846.1">&lt;EnvironmentName&gt;Staging&lt;/EnvironmentName&gt;</span></code><span class="koboSpan" id="kobo.847.1">. </span><span class="koboSpan" id="kobo.847.2">It can also be specified in your Visual Studio ASP.NET Core project file (</span><code class="inlineCode"><span class="koboSpan" id="kobo.848.1">.csproj</span></code><span class="koboSpan" id="kobo.849.1">):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag"><span class="koboSpan" id="kobo.850.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.851.1">PropertyGroup</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.852.1">&gt;</span></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.853.1">&lt;</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.854.1">EnvironmentName</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.855.1">&gt;</span></span><span class="koboSpan" id="kobo.856.1">Staging</span><span class="hljs-tag"><span class="koboSpan" id="kobo.857.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.858.1">EnvironmentName</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.859.1">&gt;</span></span>
<span class="hljs-tag"><span class="koboSpan" id="kobo.860.1">&lt;/</span></span><span class="hljs-name"><span class="koboSpan" id="kobo.861.1">PropertyGroup</span></span><span class="hljs-tag"><span class="koboSpan" id="kobo.862.1">&gt;</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.863.1">Each middleware in the pipeline is defined by an </span><code class="inlineCode"><span class="koboSpan" id="kobo.864.1">app.Use&lt;something&gt;</span></code><span class="koboSpan" id="kobo.865.1"> method, which often accepts some options. </span><span class="koboSpan" id="kobo.865.2">Each of them processes the requests and then either forwards the modified request to the next one in the pipeline or returns an HTTP response. </span><span class="koboSpan" id="kobo.865.3">When an HTTP response is returned, it is processed by all the previous ones in reverse order.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.866.1">Modules are inserted in the pipeline</span><a id="_idIndexMarker1106"/><span class="koboSpan" id="kobo.867.1"> in the order they are defined by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.868.1">app.Use&lt;something&gt;</span></code><span class="koboSpan" id="kobo.869.1"> method calls. </span><span class="koboSpan" id="kobo.869.2">The preceding code adds an error page if </span><code class="inlineCode"><span class="koboSpan" id="kobo.870.1">ASPNETCORE_ENVIRONMENT</span></code><span class="koboSpan" id="kobo.871.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.872.1">Development</span></code><span class="koboSpan" id="kobo.873.1">. </span><span class="koboSpan" id="kobo.873.2">A complete description of the ASP.NET Core pipeline will be given in the </span><em class="italic"><span class="koboSpan" id="kobo.874.1">Understanding the presentation layers of web applications</span></em><span class="koboSpan" id="kobo.875.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.876.1">Chapter 17</span></em><span class="koboSpan" id="kobo.877.1">, </span><em class="italic"><span class="koboSpan" id="kobo.878.1">Presenting ASP.NET Core</span></em><span class="koboSpan" id="kobo.879.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.880.1">In the next subsection, we will explain how the MVC framework lets you implement REST services.</span></p>
<h2 class="heading-2" id="_idParaDest-319"><span class="koboSpan" id="kobo.881.1">Implementing REST services with ASP.NET Core</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.882.1">Today, we can guarantee that the use of MVC and a web API is consolidated. </span><span class="koboSpan" id="kobo.882.2">In the MVC framework, HTTP requests are processed by classes called controllers. </span><span class="koboSpan" id="kobo.882.3">Each request is mapped to the call of a controller </span><a id="_idIndexMarker1107"/><span class="koboSpan" id="kobo.883.1">public method. </span><span class="koboSpan" id="kobo.883.2">The selected controller </span><a id="_idIndexMarker1108"/><span class="koboSpan" id="kobo.884.1">and controller methods depend on the shape of the request path, and they are defined by routing rules, which, for the REST API, are usually provided through attributes associated with both the </span><code class="inlineCode"><span class="koboSpan" id="kobo.885.1">Controller</span></code><span class="koboSpan" id="kobo.886.1"> class and its methods.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.887.1">ASP.NET Core 6 has introduced minimal APIs to simplify the mechanism of implementing APIs with C#. </span><span class="koboSpan" id="kobo.887.2">You can find a good explanation of it at </span><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis"><span class="url"><span class="koboSpan" id="kobo.888.1">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis</span></span></a><span class="koboSpan" id="kobo.889.1">.</span></p>
</div>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.890.1">Controller</span></code><span class="koboSpan" id="kobo.891.1"> methods that process HTTP requests are called action methods. </span><span class="koboSpan" id="kobo.891.2">When the controller and action methods are selected, the MVC framework creates a controller instance to serve the request. </span><span class="koboSpan" id="kobo.891.3">All the parameters of the controller constructors are resolved with dependency injection.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.892.1">Please refer to the </span><em class="italic"><span class="koboSpan" id="kobo.893.1">Using generic hosts</span></em><span class="koboSpan" id="kobo.894.1"> subsection of </span><em class="italic"><span class="koboSpan" id="kobo.895.1">Chapter 11</span></em><span class="koboSpan" id="kobo.896.1">, </span><em class="italic"><span class="koboSpan" id="kobo.897.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.898.1">, for a description of how to use dependency injection with a .NET host and to the </span><em class="italic"><span class="koboSpan" id="kobo.899.1">Dependency injection pattern</span></em><span class="koboSpan" id="kobo.900.1"> subsection of </span><em class="italic"><span class="koboSpan" id="kobo.901.1">Chapter 6</span></em><span class="koboSpan" id="kobo.902.1">, </span><em class="italic"><span class="koboSpan" id="kobo.903.1">Design Patterns and .NET 8 Implementation</span></em><span class="koboSpan" id="kobo.904.1">, for a general discussion of dependency injection.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.905.1">The following is a typical REST</span><a id="_idIndexMarker1109"/><span class="koboSpan" id="kobo.906.1"> API controller and its controller method definitions:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.907.1">[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.908.1">Route(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.909.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.910.1">api/[controller]"</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.911.1">)</span></span><span class="koboSpan" id="kobo.912.1">]
[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.913.1">ApiController</span></span><span class="koboSpan" id="kobo.914.1">]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.915.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.916.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.917.1">ValuesController</span></span><span class="koboSpan" id="kobo.918.1"> : </span><span class="hljs-title"><span class="koboSpan" id="kobo.919.1">ControllerBase</span></span><span class="koboSpan" id="kobo.920.1">
{
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.921.1">// GET api/values/5</span></span><span class="koboSpan" id="kobo.922.1">
    [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.923.1">HttpGet(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.924.1">"{id}"</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.925.1">)</span></span><span class="koboSpan" id="kobo.926.1">]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.927.1">public</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.928.1"> ActionResult&lt;</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.929.1">string</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.930.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.931.1">Get</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.932.1">(</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.933.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.934.1"> id</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.935.1">)</span></span><span class="koboSpan" id="kobo.936.1">
    {
        ...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.937.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.938.1">[ApiController]</span></code><span class="koboSpan" id="kobo.939.1"> attribute </span><a id="_idIndexMarker1110"/><span class="koboSpan" id="kobo.940.1">declares that the controller is a REST API controller. </span><code class="inlineCode"><span class="koboSpan" id="kobo.941.1">[Route("api/[controller]")]</span></code><span class="koboSpan" id="kobo.942.1"> declares that the controller must be selected on paths that start with </span><code class="inlineCode"><span class="koboSpan" id="kobo.943.1">api/&lt;controller name&gt;</span></code><span class="koboSpan" id="kobo.944.1">. </span><span class="koboSpan" id="kobo.944.2">The controller’s name is the name of the controller class without the </span><code class="inlineCode"><span class="koboSpan" id="kobo.945.1">Controller</span></code><span class="koboSpan" id="kobo.946.1"> postfix. </span><span class="koboSpan" id="kobo.946.2">This is preferred over hardcoding a controller name to save time on refactoring. </span><span class="koboSpan" id="kobo.946.3">Thus, in this case, we have </span><code class="inlineCode"><span class="koboSpan" id="kobo.947.1">api/values</span></code><span class="koboSpan" id="kobo.948.1">.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.949.1">[HttpGet("{id}")]</span></code><span class="koboSpan" id="kobo.950.1"> declares that the method must be invoked on GET requests of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.951.1">api/values/&lt;id&gt;</span></code><span class="koboSpan" id="kobo.952.1"> type, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.953.1">id</span></code><span class="koboSpan" id="kobo.954.1"> must be a number that’s passed as an argument to the method invocation. </span><span class="koboSpan" id="kobo.954.2">This can be done with </span><code class="inlineCode"><span class="koboSpan" id="kobo.955.1">Get(int id)</span></code><span class="koboSpan" id="kobo.956.1">. </span><span class="koboSpan" id="kobo.956.2">There is also an </span><code class="inlineCode"><span class="koboSpan" id="kobo.957.1">Http&lt;verb&gt;</span></code><span class="koboSpan" id="kobo.958.1"> attribute for each HTTP verb: </span><code class="inlineCode"><span class="koboSpan" id="kobo.959.1">HttpPost</span></code><span class="koboSpan" id="kobo.960.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.961.1">HttpPatch</span></code><span class="koboSpan" id="kobo.962.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.963.1">We may also have another method defined like so:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.964.1">[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.965.1">HttpGet</span></span><span class="koboSpan" id="kobo.966.1">]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.967.1">public</span></span><span class="koboSpan" id="kobo.968.1"> ... </span><span class="koboSpan" id="kobo.968.2">Get()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.969.1">This method is invoked on </span><code class="inlineCode"><span class="koboSpan" id="kobo.970.1">GET</span></code><span class="koboSpan" id="kobo.971.1"> requests of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.972.1">api/values</span></code><span class="koboSpan" id="kobo.973.1"> type, that is, on </span><code class="inlineCode"><span class="koboSpan" id="kobo.974.1">GET</span></code><span class="koboSpan" id="kobo.975.1"> requests without </span><code class="inlineCode"><span class="koboSpan" id="kobo.976.1">id</span></code><span class="koboSpan" id="kobo.977.1"> after the controller’s name.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.978.1">Several action methods can have the same name, but only one should be compatible with each request path; otherwise, an exception is thrown. </span><span class="koboSpan" id="kobo.978.2">In other words, routing rules and </span><code class="inlineCode"><span class="koboSpan" id="kobo.979.1">Http&lt;verb&gt;</span></code><span class="koboSpan" id="kobo.980.1"> attributes must univocally define which controller and which of its action methods to select for each request.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.981.1">By default, parameters are passed to the action methods of API controllers according to the following rules.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.982.1">Simple types (</span><code class="inlineCode"><span class="koboSpan" id="kobo.983.1">integers</span></code><span class="koboSpan" id="kobo.984.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.985.1">floats</span></code><span class="koboSpan" id="kobo.986.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.987.1">DateTimes</span></code><span class="koboSpan" id="kobo.988.1">) are taken from the request path if routing rules specify them as parameters, as in the case of the previous example’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.989.1">[HttpGet("{id}")]</span></code><span class="koboSpan" id="kobo.990.1"> attribute. </span><span class="koboSpan" id="kobo.990.2">If they are not found in the routing rules, the ASP.NET Core framework looks for </span><a id="_idIndexMarker1111"/><span class="koboSpan" id="kobo.991.1">query string parameters with the same name. </span><span class="koboSpan" id="kobo.991.2">Thus, for instance, if we replace </span><code class="inlineCode"><span class="koboSpan" id="kobo.992.1">[HttpGet("{id}")]</span></code><span class="koboSpan" id="kobo.993.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.994.1">[HttpGet]</span></code><span class="koboSpan" id="kobo.995.1">, the ASP.NET Core framework will look for something like </span><code class="inlineCode"><span class="koboSpan" id="kobo.996.1">api/values?id=&lt;id type&gt;</span></code><span class="koboSpan" id="kobo.997.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.998.1">api/values/{id}</span></code><span class="koboSpan" id="kobo.999.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1000.1">Complex types are extracted from the request body by formatters. </span><span class="koboSpan" id="kobo.1000.2">The right formatter is chosen according to the value of the</span><a id="_idIndexMarker1112"/><span class="koboSpan" id="kobo.1001.1"> request’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.1002.1">Content-Type</span></code><span class="koboSpan" id="kobo.1003.1"> header. </span><span class="koboSpan" id="kobo.1003.2">If no </span><code class="inlineCode"><span class="koboSpan" id="kobo.1004.1">Content-Type</span></code><span class="koboSpan" id="kobo.1005.1"> header is specified, the JSON formatter is taken. </span><span class="koboSpan" id="kobo.1005.2">The JSON formatter tries to parse the request body as a JSON object and then tries to transform this JSON object into an instance of the .NET complex type. </span><span class="koboSpan" id="kobo.1005.3">If either the JSON extraction or the subsequent conversion fails, an exception is thrown. </span><span class="koboSpan" id="kobo.1005.4">As described in </span><em class="italic"><span class="koboSpan" id="kobo.1006.1">Chapter 2, Non-Functional Requirements</span></em><span class="koboSpan" id="kobo.1007.1">, be careful with exceptions since their computational costs are much higher than a normal code flow. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1008.1">If an exception is inevitable, consider using the recommendations for logging described in </span><em class="italic"><span class="koboSpan" id="kobo.1009.1">Chapter 4, Best Practices in Coding C# 12</span></em><span class="koboSpan" id="kobo.1010.1">. </span><span class="koboSpan" id="kobo.1010.2">By default, just the JSON input formatter is supported, but you can also add an XML formatter that can be used when </span><code class="inlineCode"><span class="koboSpan" id="kobo.1011.1">Content-Type</span></code><span class="koboSpan" id="kobo.1012.1"> specifies XML content.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1013.1">You can customize the source that is used to fill an action method parameter by prefixing the parameter with an adequate attribute. </span><span class="koboSpan" id="kobo.1013.2">The following code shows some examples of this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1014.1">...MyActionMethod(....[FromHeader] </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1015.1">string</span></span><span class="koboSpan" id="kobo.1016.1"> myHeader....)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1017.1">// x is taken from a request header named myHeader</span></span><span class="koboSpan" id="kobo.1018.1">
...MyActionMethod(....[FromServices] MyType x....)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1019.1">// x is filled with an instance of MyType through dependency injection</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1020.1">The return type of an action method can be an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1021.1">IActionResult</span></code><span class="koboSpan" id="kobo.1022.1"> interface, a type that implements that interface, or a DTO directly. </span><span class="koboSpan" id="kobo.1022.2">In turn, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1023.1">IActionResult</span></code><span class="koboSpan" id="kobo.1024.1"> has just the following method:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.1025.1">Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1026.1">ExecuteResultAsync</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1027.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1028.1">ActionContext context</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1029.1">)</span></span><span class="koboSpan" id="kobo.1030.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1031.1">This method is called by the MVC framework at the right time to create the actual response and response headers. </span><span class="koboSpan" id="kobo.1031.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1032.1">ActionContext</span></code><span class="koboSpan" id="kobo.1033.1"> object, when passed to the method, contains the whole context of the HTTP request, which includes a request object with all the necessary information about the original HTTP requests (headers, body, and cookies), as </span><a id="_idIndexMarker1113"/><span class="koboSpan" id="kobo.1034.1">well as a response object that collects all the pieces of the response that is being built.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1035.1">You do not have to create an</span><a id="_idIndexMarker1114"/><span class="koboSpan" id="kobo.1036.1"> implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1037.1">IActionResult</span></code><span class="koboSpan" id="kobo.1038.1"> manually since </span><code class="inlineCode"><span class="koboSpan" id="kobo.1039.1">ControllerBase</span></code><span class="koboSpan" id="kobo.1040.1"> already has methods to create </span><code class="inlineCode"><span class="koboSpan" id="kobo.1041.1">IActionResult</span></code><span class="koboSpan" id="kobo.1042.1"> implementations so that all the necessary HTTP responses are generated. </span><span class="koboSpan" id="kobo.1042.2">Some of these methods are as follows:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1043.1">OK</span></code><span class="koboSpan" id="kobo.1044.1">: This returns a 200 status code, as well as an optional result object. </span><span class="koboSpan" id="kobo.1044.2">It is used as either </span><code class="inlineCode"><span class="koboSpan" id="kobo.1045.1">return OK()</span></code><span class="koboSpan" id="kobo.1046.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1047.1">return OK(myResult)</span></code><span class="koboSpan" id="kobo.1048.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1049.1">BadRequest</span></code><span class="koboSpan" id="kobo.1050.1">: This returns a 400 status code, as well as an optional response object.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1051.1">Created(string uri, object o)</span></code><span class="koboSpan" id="kobo.1052.1">: This returns a 201 status code, as well as a result object and the URI of the created resource.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1053.1">Accepted</span></code><span class="koboSpan" id="kobo.1054.1">: This returns a 202 status result, as well as an optional result object and resource URI.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1055.1">Unauthorized</span></code><span class="koboSpan" id="kobo.1056.1">: This returns a 401 status result, as well as an optional result object.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1057.1">Forbid</span></code><span class="koboSpan" id="kobo.1058.1">: This returns a 403 status result, as well as an optional list of failed permissions.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1059.1">StatusCode(int statusCode, object o = null)</span></code><span class="koboSpan" id="kobo.1060.1">: This returns a custom status code, as well as an optional result object.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1061.1">An action method can return a result object directly with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1062.1">return myObject</span></code><span class="koboSpan" id="kobo.1063.1">. </span><span class="koboSpan" id="kobo.1063.2">This is equivalent to returning </span><code class="inlineCode"><span class="koboSpan" id="kobo.1064.1">OK(myObject)</span></code><span class="koboSpan" id="kobo.1065.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1066.1">When all the result paths return a result object of the same type, say, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1067.1">MyType</span></code><span class="koboSpan" id="kobo.1068.1">, the action method can be declared as returning </span><code class="inlineCode"><span class="koboSpan" id="kobo.1069.1">ActionResult&lt;MyType&gt;</span></code><span class="koboSpan" id="kobo.1070.1">. </span><span class="koboSpan" id="kobo.1070.2">You may also return responses like </span><code class="inlineCode"><span class="koboSpan" id="kobo.1071.1">NotFound</span></code><span class="koboSpan" id="kobo.1072.1">, but for sure, you will get a better type of check with this approach.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1073.1">By default, result objects are serialized in JSON in the response body. </span><span class="koboSpan" id="kobo.1073.2">However, if an XML formatter has been added to the ASP.NET Core framework processing pipeline, as shown previously, the way the result is serialized depends on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1074.1">Accept</span></code><span class="koboSpan" id="kobo.1075.1"> header of the HTTP request. </span><span class="koboSpan" id="kobo.1075.2">More specifically, if the client explicitly requires XML format with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1076.1">Accept</span></code><span class="koboSpan" id="kobo.1077.1"> header, the object will be serialized in XML; otherwise, it will be serialized in JSON.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1078.1">Complex objects that are passed</span><a id="_idIndexMarker1115"/><span class="koboSpan" id="kobo.1079.1"> as input to action methods can be validated with validation attributes as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1080.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1081.1">record</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1082.1">MyType</span></span><span class="koboSpan" id="kobo.1083.1">
{
   [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.1084.1">Required</span></span><span class="koboSpan" id="kobo.1085.1">]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1086.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1087.1">string</span></span><span class="koboSpan" id="kobo.1088.1"> Name{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1089.1">get</span></span><span class="koboSpan" id="kobo.1090.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1091.1">set</span></span><span class="koboSpan" id="kobo.1092.1">;}
    ...
    </span><span class="koboSpan" id="kobo.1092.2">[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.1093.1">MaxLength(64)</span></span><span class="koboSpan" id="kobo.1094.1">]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1095.1">public</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1096.1">string</span></span><span class="koboSpan" id="kobo.1097.1"> Description{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1098.1">get</span></span><span class="koboSpan" id="kobo.1099.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1100.1">set</span></span><span class="koboSpan" id="kobo.1101.1">;}
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1102.1">If the controller has been </span><a id="_idIndexMarker1116"/><span class="koboSpan" id="kobo.1103.1">decorated with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1104.1">[ApiController]</span></code><span class="koboSpan" id="kobo.1105.1"> attribute and if validation fails, the ASP.NET Core framework automatically creates a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1106.1">BadRequest</span></code><span class="koboSpan" id="kobo.1107.1"> response containing a dictionary with all the validation errors detected, without executing the action method. </span><span class="koboSpan" id="kobo.1107.2">Therefore, you do not need to add further code to handle validation errors.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1108.1">Action methods can also be declared as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1109.1">async</span></code><span class="koboSpan" id="kobo.1110.1"> methods, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1111.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1112.1">async</span></span><span class="koboSpan" id="kobo.1113.1"> Task&lt;IActionResult&gt;MyMethod(......)
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1114.1">await</span></span><span class="koboSpan" id="kobo.1115.1"> MyBusinessObject.MyBusinessMethod();
    ...
</span><span class="koboSpan" id="kobo.1115.2">}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1116.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1117.1">async</span></span><span class="koboSpan" id="kobo.1118.1"> Task&lt;ActionResult&lt;MyType&gt;&gt;MyMethod(......)
{
    ...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1119.1">Practical examples of controllers/action methods will be shown in </span><em class="italic"><span class="koboSpan" id="kobo.1120.1">Use case – exposing WWTravelClub packages, </span></em><span class="koboSpan" id="kobo.1121.1">presented in </span><em class="italic"><span class="koboSpan" id="kobo.1122.1">Chapter 21, Case Study</span></em><span class="koboSpan" id="kobo.1123.1">. </span><span class="koboSpan" id="kobo.1123.2">In the next subsection, we will explain how to handle authorization and authentication with JWTs.</span></p>
<h3 class="heading-3" id="_idParaDest-320"><span class="koboSpan" id="kobo.1124.1">ASP.NET Core service authorization</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.1125.1">When using a JWT, authorizations are based on the claims contained in the JWT. </span><span class="koboSpan" id="kobo.1125.2">All the token claims in any action method can</span><a id="_idIndexMarker1117"/><span class="koboSpan" id="kobo.1126.1"> be accessed through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1127.1">User.Claims</span></code><span class="koboSpan" id="kobo.1128.1"> controller property. </span><span class="koboSpan" id="kobo.1128.2">Since </span><code class="inlineCode"><span class="koboSpan" id="kobo.1129.1">User.Claims</span></code><span class="koboSpan" id="kobo.1130.1"> is an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1131.1">IEnumerable&lt;Claim&gt;</span></code><span class="koboSpan" id="kobo.1132.1">, it can be processed with LINQ to verify complex conditions on claims.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1133.1">If authorization is based on </span><em class="italic"><span class="koboSpan" id="kobo.1134.1">role</span></em><span class="koboSpan" id="kobo.1135.1"> claims, you can simply use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1136.1">User.IsInRole</span></code><span class="koboSpan" id="kobo.1137.1"> function, as shown in the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1138.1">If(User.IsInRole(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1139.1">"Administrators"</span></span><span class="koboSpan" id="kobo.1140.1">) || User.IsInRole(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1141.1">"SuperUsers"</span></span><span class="koboSpan" id="kobo.1142.1">))
{
    ...
</span><span class="koboSpan" id="kobo.1142.2">}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1143.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1144.1">return</span></span><span class="koboSpan" id="kobo.1145.1"> Forbid();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1146.1">However, permissions are not usually checked from within action methods and are automatically checked by the MVC framework according to authorization attributes that decorate either the whole controller or a single action method. </span><span class="koboSpan" id="kobo.1146.2">If an action method or the whole controller is decorated with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1147.1">[Authorize]</span></code><span class="koboSpan" id="kobo.1148.1">, then access to the action method is possible only if the request has a valid </span><a id="_idIndexMarker1118"/><span class="koboSpan" id="kobo.1149.1">authentication token, which means we don’t have to perform a check on the token claims. </span><span class="koboSpan" id="kobo.1149.2">It is also possible to check whether the token contains a set of roles using the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1150.1">[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.1151.1">Authorize(Roles = </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1152.1">"Administrators,SuperUsers"</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.1153.1">)</span></span><span class="koboSpan" id="kobo.1154.1">]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1155.1">More complex conditions on claims require that authorization policies be defined while building the app in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1156.1">Program.cs</span></code><span class="koboSpan" id="kobo.1157.1">, as shown in the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1158.1">var</span></span><span class="koboSpan" id="kobo.1159.1"> builder = WebApplication.CreateBuilder(args);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1160.1">// Add services to the container.</span></span><span class="koboSpan" id="kobo.1161.1">
builder.Services.AddControllers();
...
</span><span class="koboSpan" id="kobo.1161.2">builder.Services.AddAuthorization(options =&gt;
{
    options.AddPolicy(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1162.1">"CanDrive"</span></span><span class="koboSpan" id="kobo.1163.1">, policy =&gt;
       policy.RequireAssertion(context =&gt;
       context.User.HasClaim(c =&gt; c.Type == </span><span class="hljs-string"><span class="koboSpan" id="kobo.1164.1">"HasDrivingLicense"</span></span><span class="koboSpan" id="kobo.1165.1">)));
});
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1166.1">After that, you can decorate the action methods or controllers with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1167.1">[Authorize(Policy = "Father")]</span></code><span class="koboSpan" id="kobo.1168.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1169.1">Before using JWT-based authorization, you must configure it in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1170.1">Program.cs</span></code><span class="koboSpan" id="kobo.1171.1">. </span><span class="koboSpan" id="kobo.1171.2">First, you must add the middleware that processes authentication tokens in ASP.NET Core, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1172.1">var</span></span><span class="koboSpan" id="kobo.1173.1"> app = builder.Build();
...
</span><span class="koboSpan" id="kobo.1173.2">app.UseAuthorization();
app.MapControllers();
app.Run();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1174.1">Then, you must configure the authentication services. </span><span class="koboSpan" id="kobo.1174.2">There, you define the authentication options that will be</span><a id="_idIndexMarker1119"/><span class="koboSpan" id="kobo.1175.1"> injected through dependency injection into the authentication middleware:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1176.1">var</span></span><span class="koboSpan" id="kobo.1177.1"> builder = WebApplication.CreateBuilder(args);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1178.1">// Add services to the container.</span></span><span class="koboSpan" id="kobo.1179.1">
builder.Services.AddControllers();
...
</span><span class="koboSpan" id="kobo.1179.2">builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =&gt; {
        options.TokenValidationParameters =
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1180.1">new</span></span><span class="koboSpan" id="kobo.1181.1"> TokenValidationParameters
          {
              ValidateIssuer = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1182.1">true</span></span><span class="koboSpan" id="kobo.1183.1">,
              ValidateAudience = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1184.1">true</span></span><span class="koboSpan" id="kobo.1185.1">,
              ValidateLifetime = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1186.1">true</span></span><span class="koboSpan" id="kobo.1187.1">,
              ValidateIssuerSigningKey = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1188.1">true</span></span><span class="koboSpan" id="kobo.1189.1">,
              ValidIssuer = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1190.1">"My.Issuer"</span></span><span class="koboSpan" id="kobo.1191.1">,
              ValidAudience = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1192.1">"This.Website.Audience"</span></span><span class="koboSpan" id="kobo.1193.1">,
              IssuerSigningKey = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1194.1">new</span></span><span class="koboSpan" id="kobo.1195.1">
                  SymmetricSecurityKey(Encoding.ASCII.GetBytes(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1196.1">"MySecret"</span></span><span class="koboSpan" id="kobo.1197.1">))
          };
    });
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1198.1">The preceding code provides a name to the authentication scheme, that is, a default name. </span><span class="koboSpan" id="kobo.1198.2">Then, it specifies JWT authentication options. </span><span class="koboSpan" id="kobo.1198.3">Usually, we require that the authentication middleware verifies that the JWT is not expired (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1199.1">ValidateLifetime = true</span></code><span class="koboSpan" id="kobo.1200.1">), that it has the right issuer and audience (see the </span><em class="italic"><span class="koboSpan" id="kobo.1201.1">REST service authorization and authentication</span></em><span class="koboSpan" id="kobo.1202.1"> section of this chapter), and that its signature is valid.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1203.1">The preceding example uses a symmetric signing key generated from a string. </span><span class="koboSpan" id="kobo.1203.2">This means that the same key is used to sign and verify the signature. </span><span class="koboSpan" id="kobo.1203.3">This is an acceptable choice if JWTs are created by the same website that uses them, but it is not an acceptable choice if there is a unique JWT issuer that controls access to several web API sites.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1204.1">Here, we should use an asymmetric key (typically, an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1205.1">RsaSecurityKey</span></code><span class="koboSpan" id="kobo.1206.1">), so JWT verification requires just the knowledge of the public key associated with the actual private signing key. </span><span class="koboSpan" id="kobo.1206.2">IdentityServer 4 can be used to quickly create a website that works as an authentication server. </span><span class="koboSpan" id="kobo.1206.3">It emits a JWT with the usual username/password credentials or converts other authentication tokens. </span><span class="koboSpan" id="kobo.1206.4">If you use an authentication server such as IdentityServer 4, you do not need to specify the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1207.1">IssuerSigningKey</span></code><span class="koboSpan" id="kobo.1208.1"> option since the authorization middleware is able to retrieve the required public key from the authorization server automatically.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1209.1">It is enough to provide the authentication server URL, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1210.1">.AddJwtBearer(options =&gt; {
options.Authority = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1211.1">"https://www.MyAuthorizationserver.com"</span></span><span class="koboSpan" id="kobo.1212.1">;
options.TokenValidationParameters =...
        </span><span class="koboSpan" id="kobo.1212.2">...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1213.1">On the other hand, if you decide to emit a JWT in your web API’s site, you can define a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1214.1">Login</span></code><span class="koboSpan" id="kobo.1215.1"> action method that accepts an</span><a id="_idIndexMarker1120"/><span class="koboSpan" id="kobo.1216.1"> object with a username and password and that, while relying on database information, builds the JWT with code similar to the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1217.1">var</span></span><span class="koboSpan" id="kobo.1218.1"> claims = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1219.1">new</span></span><span class="koboSpan" id="kobo.1220.1"> List&lt;Claim&gt;
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1221.1">new</span></span><span class="koboSpan" id="kobo.1222.1"> Claim(...),
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1223.1">new</span></span><span class="koboSpan" id="kobo.1224.1"> Claim(...) ,
   ...
</span><span class="koboSpan" id="kobo.1224.2">};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1225.1">var</span></span><span class="koboSpan" id="kobo.1226.1"> token = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1227.1">new</span></span><span class="koboSpan" id="kobo.1228.1"> JwtSecurityToken(
          issuer: </span><span class="hljs-string"><span class="koboSpan" id="kobo.1229.1">"MyIssuer"</span></span><span class="koboSpan" id="kobo.1230.1">,
          audience: ...,
          claims: claims,
          expires: DateTime.UtcNow.AddMinutes(expiryInMinutes),
          signingCredentials:
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1231.1">new</span></span><span class="koboSpan" id="kobo.1232.1"> SymmetricSecurityKey(Encoding.ASCII.GetBytes(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1233.1">"MySecret"</span></span><span class="koboSpan" id="kobo.1234.1">));
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1235.1">return</span></span><span class="koboSpan" id="kobo.1236.1"> OK(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1237.1">new</span></span><span class="koboSpan" id="kobo.1238.1"> JwtSecurityTokenHandler().WriteToken(token));
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1239.1">Here, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1240.1">JwtSecurityTokenHandler().WriteToken(token)</span></code><span class="koboSpan" id="kobo.1241.1"> generates the actual token string from the token properties contained in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1242.1">JwtSecurityToken</span></code><span class="koboSpan" id="kobo.1243.1"> instance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1244.1">In the next subsection, we will learn how to empower our web API with an OpenAPI documentation endpoint so that proxy classes for communicating with our services can be generated automatically.</span></p>
<h3 class="heading-3" id="_idParaDest-321"><span class="koboSpan" id="kobo.1245.1">ASP.NET Core support for OpenAPI</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.1246.1">Most of the information that is needed to fill in an OpenAPI JSON document can be extracted from web API controllers </span><a id="_idIndexMarker1121"/><span class="koboSpan" id="kobo.1247.1">through reflection, that is, input types and sources (path, request body, and header) and endpoint paths (these can be extracted from routing rules). </span><span class="koboSpan" id="kobo.1247.2">Returned output types and status codes, in general, cannot be easily computed since they can be generated dynamically.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1248.1">Therefore, the MVC framework provides the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1249.1">ProducesResponseType </span></code><span class="koboSpan" id="kobo.1250.1">attribute so that we can declare a possible return type – a status code pair. </span><span class="koboSpan" id="kobo.1250.2">It is enough to decorate each action method with as many </span><code class="inlineCode"><span class="koboSpan" id="kobo.1251.1">ProducesResponseType</span></code><span class="koboSpan" id="kobo.1252.1"> attributes as there are possible types, that is, possible status code pairs, as shown in the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1253.1">[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.1254.1">HttpGet(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1255.1">"{id}"</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.1256.1">)</span></span><span class="koboSpan" id="kobo.1257.1">]
[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.1258.1">ProducesResponseType(typeof(MyReturnType), StatusCodes.Status200OK)</span></span><span class="koboSpan" id="kobo.1259.1">]
[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.1260.1">ProducesResponseType(typeof(MyErrorReturnType), StatusCodes.Status404NotFound)</span></span><span class="koboSpan" id="kobo.1261.1">]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1262.1">public</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1263.1"> IActionResult </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1264.1">GetById</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1265.1">(</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1266.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1267.1"> id</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1268.1">)...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1269.1">If no object is returned along a path, we can just declare the status code as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1270.1"> [</span><span class="hljs-meta"><span class="koboSpan" id="kobo.1271.1">ProducesResponseType(StatusCodes.Status403Forbidden)</span></span><span class="koboSpan" id="kobo.1272.1">]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1273.1">We can also specify just the status code when all the paths return the same type and when that type is specified in the action method return type as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1274.1">ActionResult&lt;CommonReturnType&gt;</span></code><span class="koboSpan" id="kobo.1275.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1276.1">Once all the action methods have been documented, to generate any actual documentation for the JSON endpoints, we must install the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1277.1">Swashbuckle.AspNetCore</span></code><span class="koboSpan" id="kobo.1278.1"> NuGet package and place some code in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1279.1">Program.cs</span></code><span class="koboSpan" id="kobo.1280.1"> file:</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.1281.1">In .NET 5+, you can automatically include it by leaving </span><strong class="keyWord"><span class="koboSpan" id="kobo.1282.1">OpenAPI support</span></strong><span class="koboSpan" id="kobo.1283.1"> checked when creating a project.</span></p>
</div>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1284.1">var</span></span><span class="koboSpan" id="kobo.1285.1"> builder = WebApplication.CreateBuilder(args);
...
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1286.1">//open api middleware</span></span><span class="koboSpan" id="kobo.1287.1">
builder.Services.AddSwaggerGen(c =&gt;
{
    c.SwaggerDoc(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1288.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1289.1">v1"</span></span><span class="koboSpan" id="kobo.1290.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1291.1">new</span></span><span class="koboSpan" id="kobo.1292.1">() { Title = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1293.1">"WWTravelClubREST60"</span></span><span class="koboSpan" id="kobo.1294.1">, Version = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1295.1">"v1"</span></span><span class="koboSpan" id="kobo.1296.1"> });
});
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1297.1">var</span></span><span class="koboSpan" id="kobo.1298.1"> app = builder.Build();
...
</span><span class="koboSpan" id="kobo.1298.2">app.UseSwagger();
app.UseSwaggerUI(c =&gt; c.SwaggerEndpoint(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1299.1">"/swagger/v1/swagger.json"</span></span><span class="koboSpan" id="kobo.1300.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1301.1">"WWTravelClubREST60 v1"</span></span><span class="koboSpan" id="kobo.1302.1">));
...
</span><span class="koboSpan" id="kobo.1302.2">app.Run();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1303.1">The first argument of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1304.1">SwaggerDoc</span></code><span class="koboSpan" id="kobo.1305.1"> method is the documentation endpoint name. </span><span class="koboSpan" id="kobo.1305.2">By default, the documentation endpoint is </span><a id="_idIndexMarker1122"/><span class="koboSpan" id="kobo.1306.1">accessible through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1307.1">&lt;webroot&gt;//swagger/&lt;endpoint name&gt;/swagger.json</span></code><span class="koboSpan" id="kobo.1308.1"> path, but this can be changed in several ways. </span><span class="koboSpan" id="kobo.1308.2">The rest of the information contained in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1309.1">Info</span></code><span class="koboSpan" id="kobo.1310.1"> class is self-explanatory.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1311.1">We can add several </span><code class="inlineCode"><span class="koboSpan" id="kobo.1312.1">SwaggerDoc</span></code><span class="koboSpan" id="kobo.1313.1"> calls to define several documentation endpoints. </span><span class="koboSpan" id="kobo.1313.2">However, by default, all the documentation endpoints will contain the same documentation, which includes a description of all the REST services included in the project. </span><span class="koboSpan" id="kobo.1313.3">This default can be changed by calling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1314.1">c.DocInclusionPredicate(Func&lt;string, ApiDescription&gt; predicate)</span></code><span class="koboSpan" id="kobo.1315.1"> method from within </span><code class="inlineCode"><span class="koboSpan" id="kobo.1316.1">services.AddSwaggerGen(c =&gt; {...})</span></code><span class="koboSpan" id="kobo.1317.1">.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1318.1">DocInclusionPredicate</span></code><span class="koboSpan" id="kobo.1319.1"> must be passed a function that receives a JSON document name and an action method description and must return </span><code class="inlineCode"><span class="koboSpan" id="kobo.1320.1">true</span></code><span class="koboSpan" id="kobo.1321.1"> if the documentation of the action must be included in that JSON document.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1322.1">To declare that your REST APIs need a JWT, you must add the following code within </span><code class="inlineCode"><span class="koboSpan" id="kobo.1323.1">services.AddSwaggerGen(c =&gt; {...})</span></code><span class="koboSpan" id="kobo.1324.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1325.1">var</span></span><span class="koboSpan" id="kobo.1326.1"> security = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1327.1">new</span></span><span class="koboSpan" id="kobo.1328.1"> Dictionary&lt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1329.1">string</span></span><span class="koboSpan" id="kobo.1330.1">, IEnumerable&lt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1331.1">string</span></span><span class="koboSpan" id="kobo.1332.1">&gt;&gt;
{
    {</span><span class="hljs-string"><span class="koboSpan" id="kobo.1333.1">"Bearer"</span></span><span class="koboSpan" id="kobo.1334.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1335.1">new</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1336.1">string</span></span><span class="koboSpan" id="kobo.1337.1">[] { }},
};
c.AddSecurityDefinition(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1338.1">"Bearer"</span></span><span class="koboSpan" id="kobo.1339.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1340.1">new</span></span><span class="koboSpan" id="kobo.1341.1"> ApiKeyScheme
{
    Description = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1342.1">"JWT Authorization header using the Bearer scheme.</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1343.1">    Example: \"Authorization: Bearer {token}\""</span></span><span class="koboSpan" id="kobo.1344.1">,
    Name = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1345.1">"Authorization"</span></span><span class="koboSpan" id="kobo.1346.1">,
    In = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1347.1">"header"</span></span><span class="koboSpan" id="kobo.1348.1">,
    Type = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1349.1">"apiKey"</span></span><span class="koboSpan" id="kobo.1350.1">
});
c.AddSecurityRequirement(security);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1351.1">You can enrich the JSON documentation endpoint with information that has been extracted from triple-slash comments, which are usually added to generate automatic code documentation. </span><span class="koboSpan" id="kobo.1351.2">The following code shows some examples of this. </span><span class="koboSpan" id="kobo.1351.3">The following snippet shows how we can add a method description and parameter information:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-doctag"><span class="koboSpan" id="kobo.1352.1">///</span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="koboSpan" id="kobo.1353.1">&lt;summary&gt;</span></span>
<span class="hljs-doctag"><span class="koboSpan" id="kobo.1354.1">///</span></span><span class="hljs-comment"><span class="koboSpan" id="kobo.1355.1"> Deletes a specific TodoItem.</span></span>
<span class="hljs-doctag"><span class="koboSpan" id="kobo.1356.1">///</span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="koboSpan" id="kobo.1357.1">&lt;/summary&gt;</span></span>
<span class="hljs-doctag"><span class="koboSpan" id="kobo.1358.1">///</span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="koboSpan" id="kobo.1359.1">&lt;param name="id"&gt;</span></span><span class="hljs-comment"><span class="koboSpan" id="kobo.1360.1">id to delete</span></span><span class="hljs-doctag"><span class="koboSpan" id="kobo.1361.1">&lt;/param&gt;</span></span><span class="koboSpan" id="kobo.1362.1">
[</span><span class="hljs-meta"><span class="koboSpan" id="kobo.1363.1">HttpDelete(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1364.1">"{id}"</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.1365.1">)</span></span><span class="koboSpan" id="kobo.1366.1">]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1367.1">public</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1368.1">IActionResultDelete</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1369.1">(</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1370.1">long</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1371.1"> id</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1372.1">)</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1373.1">The following snippet shows how</span><a id="_idIndexMarker1123"/><span class="koboSpan" id="kobo.1374.1"> we can add an example of usage:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-doctag"><span class="koboSpan" id="kobo.1375.1">///</span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="koboSpan" id="kobo.1376.1">&lt;summary&gt;</span></span>
<span class="hljs-doctag"><span class="koboSpan" id="kobo.1377.1">///</span></span><span class="hljs-comment"><span class="koboSpan" id="kobo.1378.1"> Creates an item.</span></span>
<span class="hljs-doctag"><span class="koboSpan" id="kobo.1379.1">///</span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="koboSpan" id="kobo.1380.1">&lt;/summary&gt;</span></span>
<span class="hljs-doctag"><span class="koboSpan" id="kobo.1381.1">///</span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="koboSpan" id="kobo.1382.1">&lt;remarks&gt;</span></span>
<span class="hljs-doctag"><span class="koboSpan" id="kobo.1383.1">///</span></span><span class="hljs-comment"><span class="koboSpan" id="kobo.1384.1"> Sample request:</span></span>
<span class="hljs-doctag"><span class="koboSpan" id="kobo.1385.1">///</span></span>
<span class="hljs-doctag"><span class="koboSpan" id="kobo.1386.1">///</span></span><span class="hljs-comment"><span class="koboSpan" id="kobo.1387.1"> POST /MyItem</span></span>
<span class="hljs-doctag"><span class="koboSpan" id="kobo.1388.1">///</span></span><span class="hljs-comment"><span class="koboSpan" id="kobo.1389.1"> {</span></span>
<span class="hljs-doctag"><span class="koboSpan" id="kobo.1390.1">///</span></span><span class="hljs-comment"><span class="koboSpan" id="kobo.1391.1"> "id": 1,</span></span>
<span class="hljs-doctag"><span class="koboSpan" id="kobo.1392.1">///</span></span><span class="hljs-comment"><span class="koboSpan" id="kobo.1393.1"> "name": "Item1"</span></span>
<span class="hljs-doctag"><span class="koboSpan" id="kobo.1394.1">///</span></span><span class="hljs-comment"><span class="koboSpan" id="kobo.1395.1"> }</span></span>
<span class="hljs-doctag"><span class="koboSpan" id="kobo.1396.1">///</span></span>
<span class="hljs-doctag"><span class="koboSpan" id="kobo.1397.1">///</span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="koboSpan" id="kobo.1398.1">&lt;/remarks&gt;</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1399.1">The following snippet shows how we can add parameter descriptions and return type descriptions for each HTTP status code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-doctag"><span class="koboSpan" id="kobo.1400.1">///</span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="koboSpan" id="kobo.1401.1">&lt;param name="item"&gt;</span></span><span class="hljs-comment"><span class="koboSpan" id="kobo.1402.1">item to be created</span></span><span class="hljs-doctag"><span class="koboSpan" id="kobo.1403.1">&lt;/param&gt;</span></span>
<span class="hljs-doctag"><span class="koboSpan" id="kobo.1404.1">///</span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="koboSpan" id="kobo.1405.1">&lt;returns&gt;</span></span><span class="hljs-comment"><span class="koboSpan" id="kobo.1406.1">A newly created TodoItem</span></span><span class="hljs-doctag"><span class="koboSpan" id="kobo.1407.1">&lt;/returns&gt;</span></span>
<span class="hljs-doctag"><span class="koboSpan" id="kobo.1408.1">///</span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="koboSpan" id="kobo.1409.1">&lt;response code="201"&gt;</span></span><span class="hljs-comment"><span class="koboSpan" id="kobo.1410.1">Returns the newly created item</span></span><span class="hljs-doctag"><span class="koboSpan" id="kobo.1411.1">&lt;/response&gt;</span></span>
<span class="hljs-doctag"><span class="koboSpan" id="kobo.1412.1">///</span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="koboSpan" id="kobo.1413.1">&lt;response code="400"&gt;</span></span><span class="hljs-comment"><span class="koboSpan" id="kobo.1414.1">If the item is null</span></span><span class="hljs-doctag"><span class="koboSpan" id="kobo.1415.1">&lt;/response&gt;</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1416.1">To enable extraction from triple-slash comments, we must enable code documentation creation by adding the following code to our project file (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1417.1">.csproj</span></code><span class="koboSpan" id="kobo.1418.1">):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1419.1">&lt;PropertyGroup&gt;
&lt;GenerateDocumentationFile&gt;</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1420.1">true</span></span><span class="koboSpan" id="kobo.1421.1">&lt;/GenerateDocumentationFile&gt;
&lt;NoWarn&gt;$(NoWarn);</span><span class="hljs-number"><span class="koboSpan" id="kobo.1422.1">1591</span></span><span class="koboSpan" id="kobo.1423.1">&lt;/NoWarn&gt;
&lt;/PropertyGroup&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1424.1">Then, we must enable code </span><a id="_idIndexMarker1124"/><span class="koboSpan" id="kobo.1425.1">documentation processing from within </span><code class="inlineCode"><span class="koboSpan" id="kobo.1426.1">services.AddSwaggerGen(c =&gt; {...})</span></code><span class="koboSpan" id="kobo.1427.1"> by adding the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1428.1">var</span></span><span class="koboSpan" id="kobo.1429.1"> xmlFile = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1430.1">$"</span></span><span class="hljs-subst"><span class="koboSpan" id="kobo.1431.1">{Assembly.GetExecutingAssembly().GetName().Name}</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1432.1">.xml"</span></span><span class="koboSpan" id="kobo.1433.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1434.1">var</span></span><span class="koboSpan" id="kobo.1435.1"> xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
c.IncludeXmlComments(xmlPath);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1436.1">Once our documentation endpoints are ready, we can add some more middleware that is contained in the same </span><code class="inlineCode"><span class="koboSpan" id="kobo.1437.1">Swashbuckle.AspNetCore</span></code><span class="koboSpan" id="kobo.1438.1"> NuGet package to generate a friendly user interface that we can test our REST API on:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1439.1">app.UseSwaggerUI(c =&gt;
{
    c.SwaggerEndpoint(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1440.1">"/swagger/&lt;documentation name&gt;/swagger.json"</span></span><span class="koboSpan" id="kobo.1441.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1442.1">"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1443.1">    &lt;api name that appears in dropdown&gt;"</span></span><span class="koboSpan" id="kobo.1444.1">);
});
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1445.1">If you have several documentation endpoints, you need to add a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1446.1">SwaggerEndpoint</span></code><span class="koboSpan" id="kobo.1447.1"> call for each of them. </span><span class="koboSpan" id="kobo.1447.2">We will use this interface to test the REST API defined in the book use case, presented in </span><em class="chapterRef"><span class="koboSpan" id="kobo.1448.1">Chapter 21, Case Study</span></em><span class="koboSpan" id="kobo.1449.1">. </span><span class="koboSpan" id="kobo.1449.2">There you will also find out how to use Postman, an API platform for building and using APIs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1450.1">Once you have a working JSON documentation endpoint, you can automatically generate the C# or TypeScript code of a proxy class, presented in </span><em class="chapterRef"><span class="koboSpan" id="kobo.1451.1">Chapter 6, Design Patterns and .NET 8 Implementation</span></em><span class="koboSpan" id="kobo.1452.1">, with one of the following methods:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1453.1">The NSwagStudio Windows program, which is available at </span><a href="https://github.com/RicoSuter/NSwag/wiki/NSwagStudio"><span class="url"><span class="koboSpan" id="kobo.1454.1">https://github.com/RicoSuter/NSwag/wiki/NSwagStudio</span></span></a><span class="koboSpan" id="kobo.1455.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1456.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1457.1">NSwag.CodeGeneration.CSharp</span></code><span class="koboSpan" id="kobo.1458.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1459.1">NSwag.CodeGeneration.TypeScript</span></code><span class="koboSpan" id="kobo.1460.1">NuGet packages if you want to customize code generation.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1461.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1462.1">NSwag.MSBuild</span></code><span class="koboSpan" id="kobo.1463.1"> NuGet package if you want to tie code generation to Visual Studio build operations. </span><span class="koboSpan" id="kobo.1463.2">The documentation for this can be found at </span><a href="https://github.com/RicoSuter/NSwag/wiki/NSwag.MSBuild"><span class="url"><span class="koboSpan" id="kobo.1464.1">https://github.com/RicoSuter/NSwag/wiki/NSwag.MSBuild</span></span></a><span class="koboSpan" id="kobo.1465.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1466.1">In the next subsection, you will learn how to invoke a REST API from another REST API or from a .NET client.</span></p>
<h3 class="heading-3" id="_idParaDest-322"><span class="koboSpan" id="kobo.1467.1">.NET HTTP clients</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.1468.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1469.1">HttpClient</span></code><span class="koboSpan" id="kobo.1470.1"> class in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1471.1">System.Net.Http</span></code><span class="koboSpan" id="kobo.1472.1"> namespace is a .NET Standard 2.0 built-in HTTP client class. </span><span class="koboSpan" id="kobo.1472.2">While it could be used directly whenever we need to interact with a REST service, there are some problems</span><a id="_idIndexMarker1125"/><span class="koboSpan" id="kobo.1473.1"> in creating and releasing </span><code class="inlineCode"><span class="koboSpan" id="kobo.1474.1">HttpClient</span></code><span class="koboSpan" id="kobo.1475.1"> instances repeatedly, as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1476.1">Their creation is expensive.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1477.1">When an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1478.1">HttpClient</span></code><span class="koboSpan" id="kobo.1479.1"> is released, for instance, in a using statement, the underlying connection is not closed immediately but at the first garbage collection session. </span><span class="koboSpan" id="kobo.1479.2">Therefore, repeated creation and release operations quickly exhaust the maximum number of connections the operating system can handle.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1480.1">Therefore, either a single </span><code class="inlineCode"><span class="koboSpan" id="kobo.1481.1">HttpClient</span></code><span class="koboSpan" id="kobo.1482.1"> instance is reused, such as a Singleton, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1483.1">HttpClient</span></code><span class="koboSpan" id="kobo.1484.1"> instances are somehow pooled. </span><span class="koboSpan" id="kobo.1484.2">Starting from the 2.1 version of .NET Core, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1485.1">HttpClientFactory</span></code><span class="koboSpan" id="kobo.1486.1"> class was introduced to pool HTTP clients. </span><span class="koboSpan" id="kobo.1486.2">More specifically, whenever a new </span><code class="inlineCode"><span class="koboSpan" id="kobo.1487.1">HttpClient</span></code><span class="koboSpan" id="kobo.1488.1"> instance is required for an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1489.1">HttpClientFactory</span></code><span class="koboSpan" id="kobo.1490.1"> object, a new </span><code class="inlineCode"><span class="koboSpan" id="kobo.1491.1">HttpClient</span></code><span class="koboSpan" id="kobo.1492.1"> is created. </span><span class="koboSpan" id="kobo.1492.2">However, the underlying </span><code class="inlineCode"><span class="koboSpan" id="kobo.1493.1">HttpClientMessageHandler</span></code><span class="koboSpan" id="kobo.1494.1"> instances, which are expensive to create, are pooled until their maximum lifetime expires.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1495.1">HttpClientMessageHandler</span></code><span class="koboSpan" id="kobo.1496.1"> instances must have a finite duration since they cache DNS resolution information that may change over time. </span><span class="koboSpan" id="kobo.1496.2">The default lifetime of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1497.1">HttpClientMessageHandler</span></code><span class="koboSpan" id="kobo.1498.1"> is 2 minutes, but it can be redefined by the developer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1499.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1500.1">HttpClientFactory</span></code><span class="koboSpan" id="kobo.1501.1"> allows us to automatically pipeline all the HTTP operations with other operations. </span><span class="koboSpan" id="kobo.1501.2">For instance, we can add a Polly retry strategy to handle all the failures of all our HTTP operations automatically. </span><span class="koboSpan" id="kobo.1501.3">For an introduction to Polly, please refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1502.1">Resilient task execution</span></em><span class="koboSpan" id="kobo.1503.1"> subsection of </span><em class="italic"><span class="koboSpan" id="kobo.1504.1">Chapter 5</span></em><span class="koboSpan" id="kobo.1505.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1506.1">Implementing Code Reusability in C# 12</span></em><span class="koboSpan" id="kobo.1507.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1508.1">The simplest way to exploit the advantages offered by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1509.1">HttpClientFactory</span></code><span class="koboSpan" id="kobo.1510.1"> class is to add the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1511.1">Microsoft.Extensions.Http</span></code><span class="koboSpan" id="kobo.1512.1"> NuGet package and then follow these steps:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1513.1">Define a proxy class, say, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1514.1">MyProxy</span></code><span class="koboSpan" id="kobo.1515.1">, to interact with the desired REST service.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1516.1">Let </span><code class="inlineCode"><span class="koboSpan" id="kobo.1517.1">MyProxy</span></code><span class="koboSpan" id="kobo.1518.1"> accept an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1519.1">HttpClient</span></code><span class="koboSpan" id="kobo.1520.1"> instance in its constructor.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1521.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1522.1">HttpClient</span></code><span class="koboSpan" id="kobo.1523.1"> that was injected into the constructor to implement all the necessary operations.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1524.1">Declare your proxy in the services configuration method of your host, which, in the case of an ASP.NET Core application, is in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1525.1">Program.cs</span></code><span class="koboSpan" id="kobo.1526.1"> class. </span><span class="koboSpan" id="kobo.1526.2">In the simplest case, the declaration is something similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1527.1">builder.Services.AddHttpClient&lt;MyProxy&gt;()</span></code><span class="koboSpan" id="kobo.1528.1">.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1529.1">This will automatically add </span><code class="inlineCode"><span class="koboSpan" id="kobo.1530.1">MyProxy</span></code><span class="koboSpan" id="kobo.1531.1"> to the services that are available for dependency injection, so you can easily inject it, for instance, in your controller’s constructors. </span><span class="koboSpan" id="kobo.1531.2">Moreover, each time an instance of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1532.1">MyProxy</span></code><span class="koboSpan" id="kobo.1533.1"> is created, an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1534.1">HttpClient</span></code><span class="koboSpan" id="kobo.1535.1"> is returned by an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1536.1">HttpClientFactory</span></code><span class="koboSpan" id="kobo.1537.1"> and is automatically</span><a id="_idIndexMarker1126"/><span class="koboSpan" id="kobo.1538.1"> injected into its constructor.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1539.1">In the constructors of the classes that need to interact with a REST service, we may also need an interface instead of a specific proxy implementation with a declaration of the type:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1540.1">builder.Services.AddHttpClient&lt;IMyProxy, MyProxy&gt;()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1541.1">This way, each client that is passed to the proxy is preconfigured so that it requires a JSON response and must work with a specific service. </span><span class="koboSpan" id="kobo.1541.2">Once the base address has been defined, each HTTP request needs to specify the relative path of the service method to call.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1542.1">The following code shows how to perform a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1543.1">POST</span></code><span class="koboSpan" id="kobo.1544.1"> to a service. </span><span class="koboSpan" id="kobo.1544.2">This requires an extra package, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1545.1">System.Net.Http.Json</span></code><span class="koboSpan" id="kobo.1546.1">, because of the usage of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1547.1">PostAsJsonAsync</span></code><span class="koboSpan" id="kobo.1548.1">. </span><span class="koboSpan" id="kobo.1548.2">Here, we are stating that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1549.1">HttpClient</span></code><span class="koboSpan" id="kobo.1550.1"> that was injected into the proxy constructor has been stored in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1551.1">webClient</span></code><span class="koboSpan" id="kobo.1552.1"> private field:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1553.1">//Add a bearer token to authenticate the call</span></span><span class="koboSpan" id="kobo.1554.1">
webClient.DefaultRequestHeaders.Add(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1555.1">"Authorization"</span></span><span class="koboSpan" id="kobo.1556.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1557.1">"Bearer "</span></span><span class="koboSpan" id="kobo.1558.1"> + token);
...
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1559.1">//Call service method with a POST verb and get response</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1560.1">var</span></span><span class="koboSpan" id="kobo.1561.1"> response = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1562.1">await</span></span><span class="koboSpan" id="kobo.1563.1"> webClient.PostAsJsonAsync&lt;MyPostModel&gt;(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1564.1">"my/method/relative/path"</span></span><span class="koboSpan" id="kobo.1565.1">,
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1566.1">new</span></span><span class="koboSpan" id="kobo.1567.1"> MyPostModel
    {
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1568.1">//fill model here</span></span><span class="koboSpan" id="kobo.1569.1">
        ...
    </span><span class="koboSpan" id="kobo.1569.2">});
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1570.1">//extract response status code</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1571.1">var</span></span><span class="koboSpan" id="kobo.1572.1"> status = response.StatusCode;
...
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1573.1">//extract body content from response</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1574.1">string</span></span><span class="koboSpan" id="kobo.1575.1"> stringResult = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1576.1">await</span></span><span class="koboSpan" id="kobo.1577.1"> response.Content.ReadAsStringAsync();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1578.1">If you use Polly, you do not need to intercept and handle communication errors since this job is performed by Polly. </span><span class="koboSpan" id="kobo.1578.2">First, you need to verify the status code to decide what to do next. </span><span class="koboSpan" id="kobo.1578.3">Then, you can parse the JSON string contained in the response body to get a .NET instance of a type that, in general, depends on the status code. </span><span class="koboSpan" id="kobo.1578.4">The code to perform the parsing is based </span><a id="_idIndexMarker1127"/><span class="koboSpan" id="kobo.1579.1">on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1580.1">System.Text.Json</span></code><span class="koboSpan" id="kobo.1581.1"> NuGet package’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.1582.1">JsonSerializer</span></code><span class="koboSpan" id="kobo.1583.1"> class and is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1584.1">var</span></span><span class="koboSpan" id="kobo.1585.1"> result =
  JsonSerializer.Deserialize&lt;MyResultClass&gt;(stringResult);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1586.1">Performing a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1587.1">GET</span></code><span class="koboSpan" id="kobo.1588.1"> request is similar, but instead of calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.1589.1">PostAsJsonAsync</span></code><span class="koboSpan" id="kobo.1590.1">, you need to call </span><code class="inlineCode"><span class="koboSpan" id="kobo.1591.1">GetAsync</span></code><span class="koboSpan" id="kobo.1592.1">, as shown here. </span><span class="koboSpan" id="kobo.1592.2">The use of other HTTP verbs is completely analogous:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1593.1">var</span></span><span class="koboSpan" id="kobo.1594.1"> response =
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1595.1">await</span></span><span class="koboSpan" id="kobo.1596.1"> webClient.GetAsync(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1597.1">"my/getmethod/relative/path"</span></span><span class="koboSpan" id="kobo.1598.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1599.1">As you can see from this section, accessing HTTP APIs is quite simple and requires the implementation of some .NET 6 libraries. </span><span class="koboSpan" id="kobo.1599.2">Since the beginning of .NET Core, Microsoft has been working a lot on improving the performance and simplicity of this part of the framework. </span><span class="koboSpan" id="kobo.1599.3">It is up to you to keep yourself updated on the documentation and facilities they keep implementing.</span></p>
<h1 class="heading-1" id="_idParaDest-323"><span class="koboSpan" id="kobo.1600.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1601.1">In this chapter, we introduced SOA, its design principles, and its constraints. </span><span class="koboSpan" id="kobo.1601.2">Among them, interoperability is worth remembering.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1602.1">Then, we focused on well-established standards for business applications that achieve the interoperability that is needed for publicly exposed services. </span><span class="koboSpan" id="kobo.1602.2">Therefore, SOAP and REST services were discussed in detail, along with the transition from SOAP services to REST services that has taken place in most application areas in the last few years. </span><span class="koboSpan" id="kobo.1602.3">Then, REST service principles, authentication/authorization, and documentation were described in greater detail.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1603.1">Finally, we looked at the tools that are available in .NET 8 that we can use to implement and interact with services. </span><span class="koboSpan" id="kobo.1603.2">We looked at a variety of frameworks for intra-cluster communication, such as .NET remoting and gRPC, and tools for SOAP- and REST-based public services.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1604.1">Here, we mainly focused on REST services. </span><span class="koboSpan" id="kobo.1604.2">Their ASP.NET Core implementations were described in detail, along with the techniques we can use to authenticate/authorize them and their documentation. </span><span class="koboSpan" id="kobo.1604.3">We also focused on how to implement efficient .NET proxies so that we can interact with REST services.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1605.1">In the next chapter, we will learn how to use .NET 8 to implement microservices with ASP.NET Core.</span></p>
<h1 class="heading-1" id="_idParaDest-324"><span class="koboSpan" id="kobo.1606.1">Questions</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1607.1">Can services use cookie-based sessions?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1608.1">Is it good practice to implement a service with a custom communication protocol? </span><span class="koboSpan" id="kobo.1608.2">Why or why not?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1609.1">Can a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1610.1">POST</span></code><span class="koboSpan" id="kobo.1611.1"> request to a REST service cause a deletion?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1612.1">How many dot-separated parts are contained in a JWT bearer token?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1613.1">By default, where are the complex type parameters of a REST service’s action methods taken from?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1614.1">How is a controller declared as a REST service?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1615.1">What are the main documentation attributes of ASP.NET Core services?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1616.1">How are ASP.NET Core REST service routing rules declared?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1617.1">How should a proxy be declared so that we can take advantage of .NET </span><code class="inlineCode"><span class="koboSpan" id="kobo.1618.1">HttpClientFactory</span></code><span class="koboSpan" id="kobo.1619.1"> class features?</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-325"><span class="koboSpan" id="kobo.1620.1">Further reading</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1621.1">This chapter mainly focused on the more commonly used REST service. </span><span class="koboSpan" id="kobo.1621.2">If you are interested in SOAP services, a good place to start is the Wikipedia page regarding SOAP specifications: </span><a href="https://en.wikipedia.org/wiki/List_of_web_service_specifications"><span class="url"><span class="koboSpan" id="kobo.1622.1">https://en.wikipedia.org/wiki/List_of_web_service_specifications</span></span></a><span class="koboSpan" id="kobo.1623.1">. </span><span class="koboSpan" id="kobo.1623.2">On the other hand, if you are interested in the Microsoft .NET WCF technology for implementing SOAP services, you can refer to WCF’s official documentation here: </span><a href="https://docs.microsoft.com/en-us/dotnet/framework/wcf/"><span class="url"><span class="koboSpan" id="kobo.1624.1">https://docs.microsoft.com/en-us/dotnet/framework/wcf/</span></span></a><span class="koboSpan" id="kobo.1625.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1626.1">This chapter mentioned the AMQP protocol as an option for intra-cluster communication without describing it. </span><span class="koboSpan" id="kobo.1626.2">Detailed information on this protocol is available on AMQP’s official site: </span><a href="https://www.amqp.org/"><span class="url"><span class="koboSpan" id="kobo.1627.1">https://www.amqp.org/</span></span></a><span class="koboSpan" id="kobo.1628.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1629.1">More information on gRPC is available on Google gRPC’s official site: </span><a href="https://grpc.io/"><span class="url"><span class="koboSpan" id="kobo.1630.1">https://grpc.io/</span></span></a><span class="koboSpan" id="kobo.1631.1">. </span><span class="koboSpan" id="kobo.1631.2">More information on the Visual Studio gRPC project template can be found here: </span><a href="https://docs.microsoft.com/en-US/aspnet/core/grpc/"><span class="url"><span class="koboSpan" id="kobo.1632.1">https://docs.microsoft.com/en-US/aspnet/core/grpc/</span></span></a><span class="koboSpan" id="kobo.1633.1">. </span><span class="koboSpan" id="kobo.1633.2">You may also want to check out gRPC-Web at </span><a href="https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/"><span class="url"><span class="koboSpan" id="kobo.1634.1">https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/</span></span></a><span class="koboSpan" id="kobo.1635.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1636.1">More details on ASP.NET Core services are available in the official documentation: </span><a href="https://docs.microsoft.com/en-US/aspnet/core/web-api/"><span class="url"><span class="koboSpan" id="kobo.1637.1">https://docs.microsoft.com/en-US/aspnet/core/web-api/</span></span></a><span class="koboSpan" id="kobo.1638.1">. </span><span class="koboSpan" id="kobo.1638.2">More information on the .NET HTTP client is available here: </span><a href="https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests"><span class="url"><span class="koboSpan" id="kobo.1639.1">https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests</span></span></a><span class="koboSpan" id="kobo.1640.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1641.1">Minimal APIs are described at </span><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis"><span class="url"><span class="koboSpan" id="kobo.1642.1">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis</span></span></a><span class="koboSpan" id="kobo.1643.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1644.1">More information on JWT authentication is available here: </span><a href="https://jwt.io/"><span class="url"><span class="koboSpan" id="kobo.1645.1">https://jwt.io/</span></span></a><span class="koboSpan" id="kobo.1646.1">. </span><span class="koboSpan" id="kobo.1646.2">If you would like to generate JWTs with IdentityServer, you may refer to its official documentation page: </span><a href="https://docs.duendesoftware.com/identityserver/v7"><span class="url"><span class="koboSpan" id="kobo.1647.1">https://docs.duendesoftware.com/identityserver/v7</span></span></a><span class="koboSpan" id="kobo.1648.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1649.1">More information on OpenAPI is available at </span><a href="https://swagger.io/docs/specification/about/"><span class="url"><span class="koboSpan" id="kobo.1650.1">https://swagger.io/docs/specification/about/</span></span></a><span class="koboSpan" id="kobo.1651.1">, while more information on Swashbuckle can be found on its GitHub repository page: </span><a href="https://github.com/domaindrivendev/Swashbuckle"><span class="url"><span class="koboSpan" id="kobo.1652.1">https://github.com/domaindrivendev/Swashbuckle</span></span></a><span class="koboSpan" id="kobo.1653.1">.</span></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.1654.1">Leave a review!</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1655.1">Enjoying this book? </span><span class="koboSpan" id="kobo.1655.2">Help readers like you by leaving an Amazon review. </span><span class="koboSpan" id="kobo.1655.3">Scan the QR code below for a 20% discount code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1656.1"><img alt="" role="presentation" src="../Images/Leave_a_review_QR.png"/></span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.1657.1">*Limited Offer</span></em></p>
</div>
</body></html>