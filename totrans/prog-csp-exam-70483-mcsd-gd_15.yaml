- en: Using LINQ Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In .NET, we often need to query data from different sources, such as XML, SQL,
    and web services. In earlier versions of .NET, we performed these operations using
    simple strings. The main issue with this approach is that it lacks any IntelliSense
    and is quite cumbersome in implementation. These queries also differ from one
    another as to the source from which we are querying the data, thereby increasing
    the code complexity.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome these issues, LINQ was firstly introduced in .NET 3.5\. Compared
    to conventional data access methods, LINQ introduces an easy and consistent approach
    for the querying and modification of data across different types of data sources
    such as XML and even in-memory data structures such as arrays. In LINQ, we query
    data using a query expression. The query expression enables us to perform filtering,
    ordering, and grouping of operations on the data using minimal code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing LINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the language features that make LINQ possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding LINQ query operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding LINQ behind the scenes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using LINQ to XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have learned how we can use LINQ queries
    while performing operations on an XML file. We will look at how LINQ queries can
    help us write, query, and modify XML files.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like in the previous chapters covered in this book, the programs explained in
    this book will be developed in Visual Studio 2017.
  prefs: []
  type: TYPE_NORMAL
- en: The sample code for this chapter can be found on GitHub in `Chapter 15` ([https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples](https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples)).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn the basics of LINQ. We can use LINQ queries against
    any collection of objects, with the only condition being that the object must
    support the `IEnumerable` or generic `IEnumerable<T>` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Along with that, the target framework of the project in which we are planning
    to use LINQ must be version 3.5 or more recent.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at queries, which form the basis of LINQ operations.
    We will be looking at the different components of a query and understand how they
    are constructed in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A query is a string expression that retrieves data from a data source. The
    expression is usually related to a particular data source such as SQL or XML and
    will generally be expressed in that respective data source language. However,
    with LINQ, we can develop a reusable coding pattern that works on different data
    sources. The pattern is divided into three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the data source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing the query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code that illustrates the three operations in their simplest
    forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we created an array of integers whose size is
    `3`. As it implements the `IEnumerable<int>` interface, we will be able to implement
    LINQ on the array. In the next step, we created a query in which we are filtering
    even numbers present in the array. Finally, in the third step, we are looping
    through the results of the query execution and printing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we used an array as the source of data. The array
    already supports the `IEnumerable` or `IEnumerable <T>` interface. However, in
    some cases, that may not always be the case. For example, when we read the data
    source from sources such as XML files, we need LINQ to load the data in memory
    as a queryable type. In this case, we can use the `XElement` type. The following
    is the syntax for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we have loaded the data from the XML file in
    the `XElement` object, which implements an `IQuerable` interface. Now, on this,
    we can easily write LINQ queries to execute any operation.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move ahead and understand more around LINQ, we must understand the
    built-in features of C# that help us implement LINQ queries. In the next section,
    we will discuss some of these features.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding language features that make LINQ possible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several features available in C# that are either necessary for the
    implementation of LINQ or that help us effectively use LINQ queries. These are
    some of the topics that we will be going through in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Implicitly typed variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object initialization syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extension methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anonymous types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicitly typed variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C#, we generally use statically typed variables. This implies that the compiler
    knows the type of variable at compile time. Due to this, if it finds any operation
    that may result in an error, it will highlight it at compile time. For example,
    refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will observe that the compiler will give us a compile-time error. The following
    is the screenshot this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1375d3c9-6bee-4f03-b32a-5163d2fef34c.png)'
  prefs: []
  type: TYPE_IMG
- en: As illustrated by the error description, the compiler identifies that the operation
    is not supported in terms of the type of the two variables, hence, it throws this
    error. This is referred to as explicit typing.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit typing was added to C# in version 3.0\. In implicit typing, the compiler
    automatically identifies the variable type at compile time. The compiler does
    this based on the value that is assigned to the variable during declaration. The
    compiler then strongly types the variable to that particular type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C#, we use implicit typing by using the `var` keyword. The following shows
    the same code written earlier, albeit with implicit typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that even though we have not implicitly specified the type of the
    variable as `int`, based upon the value `1` assigned to it, the compiler will
    infer that the type of the variable must be `int`. In this case, it will give
    us the same compile-time error. The following is the screenshot for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d910edc-fc1f-465c-8703-3c10af12adde.png)'
  prefs: []
  type: TYPE_IMG
- en: Implicit `Type` helps in the LINQ query in circumstances when the return type
    is determined at compile time. In addition to being a mandatory declaration, implicit
    typing also improves code readability. To illustrate this example, refer to the
    following declaration in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, instead of declaring the actual type, we have used the `Type` variable
    in the declaration, hence improving code readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will look at initializers and how they can improve code
    readability.
  prefs: []
  type: TYPE_NORMAL
- en: Object initialization syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Initializers in C# help us combine the creation of objects and set their properties.
    Let''s refer to the following code example. Let''s assume we have a `Student`
    class that has the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose we need to declare an object for this class. In a conventional
    way, without the use of object initializers, we can do it in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the preceding code, we have to specify the creation of the `p`
    and `p2` objects and set up their respective properties separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using object initialization syntax, we will be able to combine the creation
    of the object and the setting up of its properties in one statement. As an example,
    if we use object initialization to execute the same functionality that we did
    earlier, we can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that even though usage of object initialization is not necessary
    and doesn''t provide any additional capability or feature to us, it can improve
    the readability of our code. The code can also be enhanced if there is a requirement
    for creating a collection of the same objects. The following is the syntax for
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that object initialization syntax makes the code much more readable and,
    in cases where we are working with anonymous types, it is actually required. In
    the next section, we will look at lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda expressions were introduced to C# in 3.0 version. Lambda expressions
    are based upon anonymous functions and a lambda expression is a shorter way to
    represent an anonymous method.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](66c957f7-4032-461e-91e4-00da1eb6a517.xhtml), *Creating and Implementing
    Events and Callbacks*, in the *Initiate delegate using anonymous functions* section,
    we looked at how we can create anonymous functions in C# using the `delegate`
    keyword. In a nutshell, just to recap, using anonymous methods, we can create
    an inline method in some code, assign it to a variable, and pass it around.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 5](66c957f7-4032-461e-91e4-00da1eb6a517.xhtml), *Creating and Implementing
    Events and Callbacks*, in the *Lambda expressions* section, we looked at how we
    can convert an anonymous function into its equivalent lambda expression. However,
    just to recap, let''s go through the following code example, in which we will
    first create an anonymous function and then create a lambda expression for the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we declared a delegate function of the `Func<T,T>` format.
    This implies that this function takes an input of `int` and returns an integer
    output. Hence, the output for the preceding operation would be *1 * 5*, that is,
    *5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we need to write the same code using a lambda expression, we can use
    the following code syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Please also note the usage of the `=>` notation in a lambda expression. This
    notation translates into *becomes* or *for which*.
  prefs: []
  type: TYPE_NORMAL
- en: If we execute the two code blocks, we will notice that the results of the operations
    are the same. However, with lambda expressions, we end up with much cleaner code
    and avoid a lot of code typing. In the next section, we will look at extension
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extension methods in C# allow us to add methods to an existing type without
    altering them or using inheritance. The extension methods are defined in the `System.Linq.Enumerables`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'An extension method is always defined in a static class and as a static method.
    Along with that, it also uses the `this` keyword to qualify itself as an extension
    method. The following is a code example in which we have declared an extension
    method multiple on the `int` type. To identify the calling object as the first
    parameter being passed to the function, we have used the `this` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once the preceding code is executed, we get the output of `30`, which is the
    output when the calling object, `6`, is multiplied by `5`, which is declared in
    the extension method. In the next section, we will look at anonymous types.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An anonymous type is a combination of both object initializers and implicit
    typing. An anonymous type is a type that doesn't have a name. Using anonymous
    types, using the `var` and `new` keyword, we create an object without defining
    its type or class. The type of anonymous type variable is inferred based on the
    value with which it's initialized. Along with that, the properties of an anonymous
    variable are read-only, which means we cannot change their values after the variable
    has been initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is some sample code syntax where we have declared an object of
    an anonymous type. In the object, we have specified three properties, `PropertyNum1`,
    `PropertyNum2`, and `PropertyNum3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the code is executed, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/189311df-d804-4691-a019-dd54358ba221.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that, as we are displaying the type of the anonymous type, for each of
    its respective properties, the execution is displaying the type based upon the
    value that is assigned to the property. Hence, the output that we see is `String`,
    `Int32`, and `Boolean`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at some standard LINQ operators that we use
    often while writing LINQ queries.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding LINQ query operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described in the *Queries* section, each LINQ operation is divided into three
    parts. In the first part, we obtain data from a data source. In the second part,
    we do operations on the data and finally, in the last part, we extract the data.
  prefs: []
  type: TYPE_NORMAL
- en: While doing the second part, that is, performing operations on the data, there
    are some standard operators that we can use. These operators help us to achieve
    a consistent experience and a code base that can be easily adapted to different
    data sources.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the standard query operators are `Select`, `SelectMany`, `Join`, `OrderBy`,
    `Average`, `GroupBy`, `Max`, `Min`, and `Where`. In the following sections, let's
    see some code and learn how some of these operators work.
  prefs: []
  type: TYPE_NORMAL
- en: Select and SelectMany
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use `Select` in LINQ when we need to select some values from a collection.
    For example, in the following code syntax, we have declared an array of integers
    and are selecting all of the numbers present in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, if the preceding code is executed, it will print all of the numbers
    present in the array. The following is the output of the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33519f2d-91ab-4f1f-9976-f7b9ac49e50a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We use `Select` when we need to select a value from a collection. However,
    in scenarios where we need to select values from nested collections, that is,
    a collection of collections, we use the `SelectMany` operator. Refer to the following
    code example, in which we are using the `SelectMany` operator to retrieve individual
    characters from string objects present in a string array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following would be the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b9ee7f5-aace-425b-a5af-f7fd8236a23f.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding program, the source of data is an array of strings. Now, strings
    are again an array of characters. Using `SelectMany`, we have directly looped
    through the characters present in the `Introduction`, `In`, and `C#` strings.
    Hence, using `SelectMany`, we can perform actions using fewer statements than
    it would take otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at the `Join` operator, which helps us join
    two collections.
  prefs: []
  type: TYPE_NORMAL
- en: The join operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `join` operators in LINQ help us join two collections that could be linked
    to each other by a common attribute. Refer to the following code example, which
    will provide a better explanation of this. Consider that we have two class objects,
    one representing `ClassDetail` and another representing `Students` that are studying
    in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Please note that in the `ClassDetail` class, we have details specific to the
    class in itself such as `ClassID` and `ClassName`. In the `Student` class, we
    have details specific to the student such as `rollNum`, `Name`, and `ClassID`.
    In the `Student` class, `ClassID` attribute refers to the class in which the student
    is currently studying. We will use this attribute to link the collections of `ClassDetail`
    and `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code indicates how we make a join between the two collection
    items of `Student` and `Class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have created two collections lists, one each of `Student`
    and `ClassDetail`. Then, using a `join` operator, we are combining the two lists
    based on a common attribute, `ClassID`. In the resultant items, we are then saving
    the name of the student and the name of the class. If the code is executed, we
    will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3655d04-9042-4671-a052-d2831b55f665.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will look at the `orderby` operator.
  prefs: []
  type: TYPE_NORMAL
- en: The orderby operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `orderby` operator is used to sort your data in ascending or descending
    order. The following code shows how to sort the data in descending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have declared an array of integers. Now, from this
    array, we select all numbers that are greater than `5`. After selecting them,
    we sort them in descending order using the `orderby` clause. Finally, we print
    them. The following is the output of the program when it''s executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c8af6ae-a551-4b7c-93f6-f33272e25912.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that, in the preceding output, the numbers are in descending order and
    all are greater than `5`. In the next section, we will look at the `Average` operator
    in LINQ.
  prefs: []
  type: TYPE_NORMAL
- en: Average
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In LINQ, we sometimes need to calculate the `Average` value of any numeric
    item present in the collection. To execute this operation, we can use the `Average`
    operator. Let''s go through the following code example to see how it works. Let''s
    assume we have the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have created the following objects for the student class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate the average age of the students, we can use the following code
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the code, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1a52ae2-a84b-44db-aefd-c08ebcb570fc.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will look at the `GroupBy` operator.
  prefs: []
  type: TYPE_NORMAL
- en: GroupBy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use the `GroupBy` clause in LINQ when we need to group elements based upon
    some key value. Each group is represented by a respective key and a collection
    of grouped elements.
  prefs: []
  type: TYPE_NORMAL
- en: To explain this operator, we will consider the same `Class` and `Student` example
    we have been discussing throughout this chapter. Let's consider a scenario wherein
    we need to group students based upon the classes they are currently enrolled in.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, the following is the structure of the `Student` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assume that we have the following objects in the `Student` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To group the students in terms of class ID, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have created six objects of student class and are
    then trying to group them by `ClassID`. After the grouping is complete, we are
    looping through the groups that have been created. We are printing `Key`, which
    is, in this case, the class ID and the name of the student.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute the code, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/276152f8-54ae-4431-827e-238aa2542df6.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding code, the students are grouped with different classes. It shows
    the different students present in each class.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have seen how operators work in LINQ. In the next section, we
    will look at the behind-the-scenes interfaces that make LINQ queries possible.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding LINQ behind the scenes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a fair understanding of LINQ queries, let's consider a scenario
    in which we need to alter the way LINQ works. For the sake of explanation, let's
    consider a scenario in which we need to change the built-in implementation of
    the `Where` clause in the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we first need to understand how the `Where` clause works in LINQ
    queries. We can do this by looking at the definition of the `Where` clause in
    Visual Studio. The following is how the definition of the `Where` clause would
    appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, to create our own implementation of the `Where` clause, we will need to
    create an extension method with the same signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, we can remove the `using` statement for `System.Linq` in
    the respective class and, instead, use our own method. The following is the complete
    code in which we have altered the built-in implementation of the `Where` clause
    without its own custom implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Please note that in the preceding example, we have used the `Yield` keyword.
    The `Yield` keyword was introduced in C# in 2.0\. Using this keyword, the execution
    will basically remember the item that was returned from the previous execution
    of the `Where` function and will return the next item in the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: This is particularly important when we working using LINQ queries on data providers
    such as SQL. Due to the usage of `Yield`, the query won't be sent to the database
    until the result is iterated over. However, this would also mean if we execute
    the query multiple times, each time it will hit the database and hence have a
    negative effect on the performance of the system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how LINQ queries are used on an XML data
    source.
  prefs: []
  type: TYPE_NORMAL
- en: Using LINQ to XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working with XML files, we generally use the `XmlWriter`, `XmlReader`,
    and `XmlDocument` classes. Apart from these classes, we can also LINQ to execute
    operations on the XML file. One of the main advantages of using LINQ to execute
    XML operations is that we can use a consistent query experience that LINQ provides
    with other data providers.
  prefs: []
  type: TYPE_NORMAL
- en: Using LINQ, we can create, edit, and parse XML files. Apart from providing a
    consistent query experience, LINQ also helps us in writing much more powerful
    queries that are more compact than other XML classes. Let's look at the operations
    that we can perform on XML and understand how we can execute them via LINQ.
  prefs: []
  type: TYPE_NORMAL
- en: Querying XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While using LINQ on an XML file, we use the `XDocument` class to load the XML
    as a string in the memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until LINQ was introduced in .NET, developers used to work with the `XmlDocument`
    helper class to do operations on the XML file. `XDocument` is a similar helper
    class that we use in LINQ for doing operations on the XML file. Using LINQ for
    such `xml` operations not only helps to provide a consistent query experience
    but also increases the overall performance of the application. The `XDocument`
    class contains the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`XDeclaration`: This component signifies information in regards to `XmlDeclaration`
    and contains information such as XML version and the encoding used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XElement`: This component signifies the root node or object present in the
    XML class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XProcessingInstruction`: This component contains relevant information for
    the application that will ultimately be consuming the XML file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XComments`: This component contains any additional information apart from
    the `XElement` component that we want to add in the XML class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the preceding components derive from a common abstract class, `XNode`,
    and any operation executed using `XDocument` is based upon this `XNode` class.
    While working with `XDocument`, we can use `XNode` in several ways. For example,
    using the `XDocument.Nodes` syntax, we can loop through all of the nodes present
    in the XML file.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if we have a scenario to search for a specific element or node, we
    can also use the `XDocument.Descendants` or `XDocument.Elements` syntax. Using
    `XNode`, we can also directly reach a particular element or a node that's present
    in the XML file. This can greatly enhance the performance of the application as
    we no longer need to loop through the entire XML file rather than just straightway
    jumping to the required node.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that in an XML file, attributes are not considered nodes; instead,
    they are key-value pairs that belong to a node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sample shows a sample XML containing a set of students who
    all have the attributes of `Name`, `rollNum`, and contact information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we need to loop through all of the student records that are present
    in this XML file. Using LINQ, we can execute queries that would load all of the
    names of the students present in the XML file as a string. To use LINQ on an XML
    file, we first need to add a reference to the `System.Xml.Linq` namespace. The
    following code syntax shows how we can use the `Descendants` method and the `Attribute`
    method to load this data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d00938a-7891-4bbd-a387-3d86b3bd4f86.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding program, using a LINQ query, we are retrieving all of the child
    nodes present in the `Student` descendant in the XML file. Once we have retrieved
    all of the nodes, we are selecting the values in the attribute nodes, `Name` and
    `rollNum`. To select the respective element present in the node, we are using
    the `.Attribute` syntax. The method returns an instance of an `XAttribute` object.
    Even though `XAttribute` has a `Value` property of the string type, we can always
    use explicit operators to cast the value to other data types in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'While using LINQ on XML files, we can also use operators such as `Where` and
    `OrderBy` in the queries. The following code syntax shows how we can filter all
    students to only those with a phone number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have added a `where` clause, in which we have added
    a condition on the phone number. Note that, in the XML string, only one child
    node has a phone number. When the preceding code is executed, we get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d016f86a-f41b-43b5-915b-b0387515628e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding XML file, only one student record has a phone number, hence
    it's filtering out that particular record. In the next section, we will look at
    how we can create an XML file using LINQ.
  prefs: []
  type: TYPE_NORMAL
- en: Creating XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from querying XML, we can also use LINQ to create XML files. To do this,
    we can use the `XElement` class. There is an `ADD` method available in the class
    that we can use to construct an XML file. The following code syntax shows how
    we can create some XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have defined an element by the name `Student`. In
    the root element, we have added a child node of `Marks` to represent the marks
    the student has earned. We have also added a child node of `Attendance` to represent
    the attendance of `Student`. Finally, we have added a `"Roll Number"` attribute
    to represent the unique identifier of `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the code is executed, we will observe that it has created an XML file
    with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will look at how we can use LINQ to update XML.
  prefs: []
  type: TYPE_NORMAL
- en: Updating XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at how we can modify an XML file using LINQ.
    With LINQ, we can modify the XML file by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing existing nodes in the XML file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting new nodes in the XML file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the content of existing nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving the XML file back once the operation finishes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the sake of explanation, we will work on the same XML file that we created
    in the previous section. We will be writing a code that would add a mobile number
    element for all of the students. We will add this element in the node element
    of `ContactDetails`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are looping through all `Students` present in the
    XML and are then looping through the child element of `ChildDetails`. In that
    node, we are adding the element of `MobileNumber`. Once the code is executed,
    we will get the following output in the XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding XML, we have added a `MobileNumber` element in the `ContactDetails`
    node of `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how we can use LINQ to write consistent queries
    against multiple data sources. We learned about the different components of a
    LINQ query and understood how we can construct them in a query. We then looked
    at the features in a C# language that allows us to work with LINQ such as implicit
    typing, object initialization syntax, lambda expressions, extension methods, and
    anonymous types.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at the different operators available in LINQ such as `Select`,
    `SelectMany`, `Where`, `join`, and `Average`. Using code scenarios, we looked
    at different situations in which we should use each of them.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at the different interfaces that LINQ queries are based on. Finally,
    we looked at how we can use LINQ queries to perform an operation on XML files.
    Using code examples, we looked at how we perform, create, update, and query operations
    on LINQ.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the serialization and deserialization of
    data. We will look at the different collection items, such as arrays, lists, and
    dictionaries, which are available in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which LINQ code can be used to extract customers that have made sales of over
    5,000 dollars and whose name starts with A?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FROM p IN db.Purchases` `WHERE p.Customer.Name.StartsWith("A")` `WHERE p.PurchaseItems.Sum
    (pi => pi.SaleAmount) = 5000` `SELECT p`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FROM p IN db.Purchases` `WHERE p.Customer.Name.StartsWith("A")` `WHERE p.PurchaseItems.Sum
    (pi => pi.SaleAmount) > 5000` `SELECT p`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FROM p IN db.Purchases` `WHERE p.Customer.Name.EndsWith("A")` `WHERE p.PurchaseItems.Sum
    (pi => pi.SaleAmount) < 1000` `SELECT p`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FROM p IN db.Purchases` `WHERE p.Customer.Name.StartsWith("A")` `WHERE p.PurchaseItems.Sum
    (pi => pi.SaleAmount) >= 1000` `SELECT p`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following statements in regards to LINQ is incorrect?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compared to languages such as SQL, LINQ is more complex to code.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: LINQ supports `Join`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: LINQ can be used to do operations on XML files.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following supports LINQ queries?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Object Collection
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Entity Framework
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: XML Document
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**b**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**a**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**d**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
