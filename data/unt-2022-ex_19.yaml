- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Entering Mixed Reality with the XR Interaction Toolkit
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用XR Interaction Toolkit进入混合现实
- en: In [*Chapter 13*](B18347_13.xhtml#_idTextAnchor256), we made some changes to
    our 3D FPS game’s enemy NPCs. We upgraded them from 2D to 3D components while
    still using waypoints for navigation but utilized Unity’s NavMesh system to rapidly
    implement the patrolling behavior. We also enhanced the complexity of the NPC
    behavior by adding sensors that allow them to interact with the player and the
    environment in a more realistic way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第13章*](B18347_13.xhtml#_idTextAnchor256)中，我们对3D FPS游戏的敌人NPC进行了一些修改。我们将它们从2D组件升级到3D组件，同时仍然使用航点进行导航，但利用Unity的NavMesh系统快速实现巡逻行为。我们还通过添加传感器增强了NPC行为的复杂性，这些传感器允许它们以更真实的方式与玩家和环境交互。
- en: We continued by discussing how to create dynamic enemy behavior using our sensors
    as conditions within behavior trees. We then completed our AI discussion with
    an introduction to **machine learning** (**ML**) using Unity’s ML-Agents, which
    enables NPCs to learn and evolve. We can create remarkable experiences for our
    players by integrating advanced AI-based gameplay!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续讨论如何使用我们的传感器作为行为树中的条件来创建动态敌人行为。然后，我们通过介绍使用Unity的ML-Agents的**机器学习**（**ML**）来完成我们的AI讨论，这使得NPC能够学习和进化。通过集成基于高级AI的游戏玩法，我们可以为我们的玩家创造惊人的体验！
- en: In this chapter, we’ll finish the journey that started with the 3D FPS game
    by creating the final boss room encounter in **mixed reality** (**MR**). We’ll
    accomplish this by using the **Unity XR Interaction Toolkit** along with assets,
    reusable components, and systems accumulated from previous efforts, all coming
    together to create a battle to take place in your own room!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过创建**混合现实**（**MR**）中的最终老板房间遭遇战来完成从3D FPS游戏开始的旅程。我们将通过使用**Unity XR Interaction
    Toolkit**以及从先前努力中积累的资产、可重用组件和系统来实现这一点，所有这些都将汇集在一起，在你的房间里创造一场战斗！
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introduction to MR and development frameworks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合现实和开发框架简介
- en: Designing a boss room
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计老板房间
- en: Working with AR planes (AR Foundation)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与AR飞机（AR Foundation）合作
- en: Placing interactable objects in the world
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在世界中放置可交互对象
- en: Implementing the boss room mechanics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现老板房间机制
- en: By the end of this chapter, you’ll be able to make an MR game or experience
    that incorporates the player’s physical space – such as walls, the floor, and
    tables – to create a novel experience for players. You’ll also learn how to create
    interactable objects and manage their instantiation, particularly with regard
    to detected surface planes that define the boundaries and objects of the physical
    space. The chapter completes the accumulation of knowledge required to rapidly
    build out features and behaviors when making games.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够制作一个融合玩家物理空间（如墙壁、地板和桌子）的MR游戏或体验，为玩家创造新颖的体验。你还将学习如何创建可交互对象并管理它们的实例化，特别是关于定义物理空间边界和对象的检测表面平面。本章完成了制作游戏时快速构建功能和行为的知识积累。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along with this chapter, you’ll need a Meta Quest 2 or 3 headset and
    a USB-C cable to connect it to your computer. The cable lets you push the Unity
    project build to your device and test some functionality directly in the Unity
    Editor’s play mode.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，你需要一个Meta Quest 2或3头戴式设备以及一根USB-C线缆来将其连接到你的电脑。这条线缆让你可以将Unity项目构建推送到你的设备，并在Unity编辑器的播放模式下直接测试一些功能。
- en: If you don’t have an MR headset
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有MR头戴式设备
- en: 'You can still follow along in this chapter even without owning an MR headset
    – by using the Meta XR Simulator, available from the Unity Asset Store: [https://assetstore.unity.com/packages/tools/integration/meta-xr-simulator-266732](https://assetstore.unity.com/packages/tools/integration/meta-xr-simulator-266732).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有MR头戴式设备，你也可以跟随本章内容——通过使用从Unity Asset Store提供的Meta XR Simulator：[https://assetstore.unity.com/packages/tools/integration/meta-xr-simulator-266732](https://assetstore.unity.com/packages/tools/integration/meta-xr-simulator-266732)。
- en: You can download the complete project from GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从GitHub下载完整项目：[https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)。
- en: Introduction to MR and development frameworks
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合现实和开发框架简介
- en: '**Mixed reality** has only recently hit the forefront of what’s possible with
    the latest **head-mounted displays** (**HMDs**) to create environments where the
    physical and virtual worlds are blended to have digital and physical objects co-exist
    and appear to interact with one another. An MR gaming, educational, healthcare,
    or industrial application combines aspects of both **virtual reality** (**VR**)
    and **augmented reality** (**AR**) to offer an immersive experience where virtual
    content is anchored in the real world.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**混合现实**最近才成为可能，利用最新的**头戴式显示器**（**HMDs**）创造物理世界和虚拟世界融合的环境，使数字和物理对象共存，并看起来相互交互。混合现实游戏、教育、医疗保健或工业应用结合了**虚拟现实**（**VR**）和**增强现实**（**AR**）的方面，提供一种沉浸式体验，其中虚拟内容锚定在现实世界中。'
- en: One doesn’t need to look much further than popular VR adaptations of popular
    PC games such as **Skyrim VR** or **Resident Evil VR** to understand that VR-based
    technology has a strong outlook for the future of virtual entertainment. Additionally,
    games such as **Minecraft VR** and **Roblox VR**, with their enormous and engaged
    player base no less, offer immersive experiences that turn otherwise static surroundings
    into dynamic worlds that allow interaction and exploration in unprecedented ways
    never experienced before.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 只需看看像**Skyrim VR**或**Resident Evil VR**这样的流行PC游戏VR改编，就能理解基于VR的技术对未来虚拟娱乐的强大前景。此外，像**Minecraft
    VR**和**Roblox VR**这样的游戏，尽管玩家基数巨大且参与度高，也能提供沉浸式体验，将原本静态的环境转变为动态的世界，以前所未有的方式允许互动和探索。
- en: The breakout success of the original VR title **Beat Saber** also shows the
    diverse potential of the platform, not only for entertainment but also for physically
    involved gameplay. The future of VR, AR, and MR will continue to interest us,
    so let’s be sure we’re armed with the tools to succeed in this space.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 原始VR游戏标题**Beat Saber**的突破性成功也展示了该平台多样化的潜力，不仅限于娱乐，还包括身体参与的玩法。VR、AR和MR的未来将继续吸引我们的兴趣，因此让我们确保我们拥有在这个领域取得成功的工具。
- en: In this section, we’ll review the technology we’ll use to build our boss room
    game. The tech stack includes the Unity **XR Interaction Toolkit**, **AR Foundation**
    framework, and the **OpenXR** Meta package. These technologies on their own are
    powerful but combine one with another, and something new is created. They enable
    developers to create impressive MR experiences much more quickly when used in
    tandem.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾我们将用于构建我们的BOSS房间游戏的技术。技术栈包括Unity **XR Interaction Toolkit**、**AR Foundation**框架和**OpenXR**
    Meta包。这些技术本身很强大，但结合在一起，就能创造出新的东西。它们使开发者能够更快地创建令人印象深刻的MR体验。
- en: Let’s have a brief overview of each and see how they harmonize.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对每个部分进行简要概述，看看它们是如何协调一致的。
- en: XR Interaction Toolkit (XRI)
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XR Interaction Toolkit (XRI)
- en: Unity’s XRI is a versatile interaction system for VR/AR that simplifies and
    streamlines cross-platform creation. It provides a common framework for various
    interactions such as poking, gazing (i.e., rays), and grabbing for controllers
    and hands. It also includes virtual hands, haptic feedback, and responses for
    selections using scaling, animation, or even blend shapes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的XRI是一个适用于VR/AR的多功能交互系统，它简化并加速了跨平台创作。它为各种交互提供了通用框架，例如戳、注视（即射线）和抓取控制器和手。它还包括虚拟手、触觉反馈以及使用缩放、动画甚至混合形状进行选择时的响应。
- en: Additional reading | XR Interaction Toolkit (XRI)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | XR Interaction Toolkit (XRI)
- en: 'XRI: [https://docs.unity3d.com/Packages/com.unity.xr.interaction.toolkit%402.5/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.xr.interaction.toolkit%402.5/manual/index.xhtml).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 'XRI: [https://docs.unity3d.com/Packages/com.unity.xr.interaction.toolkit%402.5/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.xr.interaction.toolkit%402.5/manual/index.xhtml).'
- en: 'XRI examples: [https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples](https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 'XRI示例: [https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples](https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples).'
- en: 'XR: [https://docs.unity3d.com/Manual/XR.xhtml](https://docs.unity3d.com/Manual/XR.xhtml).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 'XR: [https://docs.unity3d.com/Manual/XR.xhtml](https://docs.unity3d.com/Manual/XR.xhtml).'
- en: The XRI toolkit dramatically simplifies the process of developing interactive
    VR and AR experiences by providing a comprehensive set of interaction components
    and systems, minimizing the barrier to entry for developers looking to enter this
    space. It allows for easy implementation of common functions such as head tracking,
    locomotion (i.e., movement), object interactions, and the UI within the virtual
    space. The toolkit is also flexible and modular, which provides an excellent foundation
    for creating an MR game.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: XRI工具包通过提供一套全面的交互组件和系统，极大地简化了开发交互式VR和AR体验的过程，降低了开发者进入这一领域的门槛。它允许轻松实现常见的功能，如头部跟踪、移动（即运动）、对象交互以及虚拟空间内的用户界面。该工具包也是灵活和模块化的，为创建MR游戏提供了一个优秀的基础。
- en: Specifically for Unity 2022, Unity’s cross-platform MR development tools for
    the Meta Quest HMDs have moved from the experimental preview state to fully supported
    in the 2022 LTS release!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 特别针对Unity 2022，Unity为Meta Quest HMDs提供的跨平台MR开发工具已从实验预览状态转移到2022 LTS版本中的完全支持状态！
- en: XRI provides the interaction part; now, let’s look at the environment part of
    these technologies.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: XRI提供了交互部分；现在，让我们看看这些技术的环境部分。
- en: AR Foundation
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AR Foundation
- en: Unity’s AR Foundation is a cross-platform framework that provides a unified
    API for simplifying building applications for mobile and head-worn AR/MR devices.
    The package is designed to work natively with XRI (and XR Hands), significantly
    reducing any hurdles for developers accessing the specific device features to
    support building AR applications.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的AR Foundation是一个跨平台框架，它提供了一个统一的API，用于简化为移动和头戴式AR/MR设备构建应用程序。该包旨在与XRI（以及XR
    Hands）原生工作，显著降低开发者访问特定设备功能以支持构建AR应用程序的障碍。
- en: Additional reading | AR Foundation
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | AR Foundation
- en: 'AR Foundation: [https://unity.com/unity/features/arfoundation](https://unity.com/unity/features/arfoundation)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 'AR Foundation: [https://unity.com/unity/features/arfoundation](https://unity.com/unity/features/arfoundation)'
- en: 'Unity documentation: [https://docs.unity3d.com/Packages/com.unity.xr.arfoundation%405.1/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.xr.arfoundation%405.1/manual/index.xhtml)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Unity文档：[https://docs.unity3d.com/Packages/com.unity.xr.arfoundation%405.1/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.xr.arfoundation%405.1/manual/index.xhtml)
- en: More specifically, AR Foundation is the layer that unifies **ARCore** (Google)
    and **ARKit** (Apple) APIs into a single higher-level API. This single API allows
    developers to write code once where the specific feature implementations of the
    underlying platforms are handled automagically.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，AR Foundation是统一**ARCore**（谷歌）和**ARKit**（苹果）API的层，将其整合为一个单一的更高层次的API。这个单一的API允许开发者编写一次代码，而底层平台的特定功能实现则自动处理。
- en: AR Foundation simplifies building spatial awareness into applications, making
    digital objects appear interactable with the real world. This is crucial for creating
    MR experiences that seamlessly blend the virtual and the real world.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: AR Foundation简化了将空间感知构建到应用程序中的过程，使数字对象看起来可以与真实世界交互。这对于创建无缝融合虚拟世界和真实世界的MR体验至关重要。
- en: We’ll be working specifically on the **Meta Quest HMD** platforms. Our boss
    room game will be compatible with Quest 2 and Quest 3 devices. The AR Foundation
    support for Meta Quest is built using a familiar industry-adopted standard interface
    for XR hardware and software, and that interface is called **OpenXR**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专门针对**Meta Quest HMD**平台进行工作。我们的老板房间游戏将与Quest 2和Quest 3设备兼容。AR Foundation对Meta
    Quest的支持是使用一个熟悉的行业采用的标准接口来构建的，这个接口被称为**OpenXR**。
- en: AR Foundation provides the visual part; now, let’s look at the platform support
    part of these technologies.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: AR Foundation提供了视觉部分；现在，让我们看看这些技术的平台支持部分。
- en: 'OpenXR: Meta package'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenXR：Meta包
- en: '**OpenXR** is an open, royalty-free standard that enables high-performance
    access via a unified interface across multiple AR and VR hardware and software
    platforms and devices, collectively known as XR.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenXR**是一个开放且无需支付版税的标准，它通过统一的界面，在多个AR和VR硬件和软件平台及设备上实现高性能访问，这些平台和设备统称为XR。'
- en: Developing with OpenXR simplifies the development process by allowing developers
    to target any supporting OpenXR system without worrying about specific platform
    details. The Meta package (available since Unity 2022.3.11.f1) contains **Meta-specific
    OpenXR** extensions and Meta’s **AR Foundation provider plugin** for its Quest
    devices – it ensures compatibility and interoperability between the software and
    hardware to support its specific input devices, head-mounted displays, and other
    peripherals.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenXR进行开发简化了开发过程，因为它允许开发者针对任何支持OpenXR的系统进行开发，无需担心特定平台的具体细节。自Unity 2022.3.11.f1版本以来，Meta包（包含**Meta特定的OpenXR扩展**和Meta为其Quest设备提供的**AR
    Foundation提供插件**）确保了软件和硬件之间的兼容性和互操作性，以支持其特定的输入设备、头戴式显示器和其他外围设备。
- en: Additional reading | OpenXR
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | OpenXR
- en: 'Kronos Group: OpenXR: [https://www.khronos.org/openxr/](https://www.khronos.org/openxr/)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 'Kronos Group: OpenXR: [https://www.khronos.org/openxr/](https://www.khronos.org/openxr/)'
- en: To summarize, OpenXR is the glue that binds the interaction and visual systems
    to any supporting hardware devices – especially new devices that feature better
    graphics performance and sensors. The trio of technologies, when combined, enable
    developers to rapidly create prototypes and deploy production-ready MR games and
    experiences – XRI provides the foundation for interactive elements, AR Foundation
    builds on the ability to merge digital and physical-world visuals, and OpenXR
    ensures the experiences are accessible across different devices.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，OpenXR是连接交互和视觉系统与任何支持硬件设备的粘合剂——特别是那些具有更好图形性能和传感器的全新设备。这三项技术的结合使用，使开发者能够快速创建原型并部署生产就绪的MR游戏和体验——XRI为交互元素提供基础，AR
    Foundation建立在融合数字和物理世界视觉的能力之上，而OpenXR确保了体验可以在不同设备上访问。
- en: '![Figure 14.1 – Unity XR tech stack](img/B18347_14_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – Unity XR技术堆栈](img/B18347_14_01.jpg)'
- en: Figure 14.1 – Unity XR tech stack
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – Unity XR技术堆栈
- en: In this section, we learned what Unity MR technologies are available to us and
    that this combination of MR-based technologies not only simplifies development
    but also enables the creation of complex, engaging MR applications to have broad
    end-user reach. This brings us right into the next section, where we’ll get down
    to the business of designing our MR boss room.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了Unity MR技术有哪些可供我们使用，以及这种基于MR技术的组合不仅简化了开发过程，而且能够创建复杂、引人入胜的MR应用程序，从而拥有广泛的终端用户覆盖范围。这直接引出了下一节，我们将着手设计我们的MR老板房间。
- en: Designing a boss room
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计老板房间
- en: Designing a boss room encounter is a critical part of game creation that combines
    aspects of narrative, mechanical, and environmental considerations to create an
    engaging and challenging experience for players.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 设计老板房间遭遇战是游戏制作的关键部分，它结合了叙事、机械和环境考虑因素，为玩家创造一个引人入胜且具有挑战性的体验。
- en: 'There are several key areas to consider when designing a boss room encounter,
    and we’ll take a shallow dive into a few:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 设计老板房间遭遇战时需要考虑几个关键区域，我们将简要探讨其中几个：
- en: '**Narrative element**: The encounter should feel like a natural progression
    or even the story’s climax.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**叙事元素**：遭遇战应该感觉像是一个自然的进展，甚至是故事的高潮。'
- en: '**Boss mechanics**: The player’s battle with the boss element should stand
    out as a unique experience, separate from the player mechanics mainly being used,
    requiring players to adapt a strategy to overcome attack patterns and other behaviors.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**老板机制**：玩家与老板元素的战斗应该是一个独特的体验，与玩家主要使用的机制分开，要求玩家调整策略以克服攻击模式和其它行为。'
- en: '**Environment design**: The layout of the boss room itself should complement
    the narrative and mechanics being implemented. This is a special consideration
    for MR because we’ll use the player’s own room (i.e., their physical space) to
    construct the gameplay environment and place the interactive elements, creating
    a novel challenge for each player.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境设计**：老板房间的布局应该与正在实施的叙事和机制相辅相成。这对于MR来说是一个特殊的考虑因素，因为我们将在玩家自己的房间（即他们的物理空间）中构建游戏环境并放置交互元素，为每位玩家创造一个新颖的挑战。'
- en: '**Balancing**: Challenges presented by boss encounters should be demanding
    yet feel pretty balanced to avoid undue frustration while still providing a solvable
    challenge for the player.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平衡**：老板遭遇战提出的挑战应该是具有挑战性的，同时感觉相当平衡，以避免不必要的挫败感，同时仍然为玩家提供一个可解决的挑战。'
- en: By incorporating these elements into our boss room, we aim to offer players
    an enjoyable and unforgettable experience. Overcoming the *boss challenge* will
    give them a sense of satisfaction and accomplishment. Moreover, with MR included
    in our case, the experience becomes even more remarkable and rewarding.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些元素纳入我们的Boss房间，我们旨在为玩家提供一段愉快且难忘的体验。克服Boss挑战将给他们带来满足感和成就感。此外，在我们的案例中加入MR，体验变得更加非凡和有回报。
- en: Let’s revisit our GDD for a moment to get a quick update for the boss room battle
    added that will provide the context we’ll follow when setting up our scene.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时回顾一下我们的GDD，以获取关于即将添加的Boss房间战斗的快速更新，这将为我们设置场景提供上下文。
- en: '| **What is the habitat interior’s** **boss encounter?** | In the game’s climax,
    players must infiltrate a heavily guarded central control room to re-energize
    the reactor that’s been turned off – its crystal modules have been ejected – by
    the evil alien plant entity that has taken over. The outcome of this battle will
    determine the future of the Kryk’zylx race on the planet. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **什么是栖息地内部的Boss遭遇？** | 在游戏的高潮部分，玩家必须潜入一个严密守卫的中心控制室，重新启动被邪恶的外星植物实体关闭的反应堆——其晶体模块已被弹出。这场战斗的结果将决定这个星球上Kryk’zylx种族的未来。|'
- en: Table 14.1 – GDD snippet setting the scene for the boss battle
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.1 – GDD片段设置Boss战斗场景
- en: 'Very nice. The context has been set, and we have some story background for
    the purpose of the boss battle. You are not just some kid from a trailer park;
    you are a Kryk’zylx scout! As such, you are armed with the most advanced energy-based
    weaponry, such as this laser pistol: pew-pew!'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。上下文已经设定，我们有一些关于Boss战斗目的的故事背景。你不是来自拖车公园的某个孩子；你是一名Kryk’zylx侦察兵！因此，你装备了最先进的基于能量的武器，比如这把激光手枪：砰砰！
- en: '![Figure 14.2 – XR interactable gun](img/B18347_14_02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 – XR交互式枪](img/B18347_14_02.jpg)'
- en: Figure 14.2 – XR interactable gun
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – XR交互式枪
- en: Let’s start by first defining our physical space, then move on to creating the
    Unity project and testing our MR setup.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义我们的物理空间，然后继续创建Unity项目并测试我们的MR设置。
- en: Setting up the physical space
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置物理空间
- en: Properly defining the physical space set up on the device for an MR game is
    of utmost importance, as it directly impacts the possibilities available in the
    immersive experience. It seamlessly blends virtual content, such as the horizontal
    AR surface planes defined for walls, the floor, the ceiling, tables, and seats,
    in addition to vertical AR surface planes, such as doors and windows. Having these
    virtual surface objects in place for their real-world counterparts enhances gameplay,
    ensures safety, and maximizes the player’s engagement. The physical space environment
    setup also serves as an interactive canvas for the game developer’s storytelling
    and exploration.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备上正确定义MR游戏的物理空间设置至关重要，因为它直接影响沉浸式体验的可能性。它无缝融合了虚拟内容，例如为墙壁、地板、天花板、桌子、座椅定义的水平AR表面平面，以及如门和窗户这样的垂直AR表面平面。这些虚拟表面对象与它们的现实世界对应物相匹配，增强了游戏玩法，确保了安全，并最大化了玩家的参与度。物理空间环境设置还充当了游戏开发者讲述故事和探索的互动画布。
- en: For Meta Quest 3, the headset includes a depth sensor to scan your room surroundings
    and detect the floor, walls, and ceiling to establish a starting point for your
    physical space setup. Once you’ve finished the room scan, you can manually confirm
    the walls and add furniture.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Meta Quest 3，头戴式设备包括一个深度传感器来扫描你的房间环境并检测地板、墙壁和天花板，以建立你的物理空间设置的起点。一旦完成房间扫描，你可以手动确认墙壁并添加家具。
- en: For Meta Quest 2, you’ll have to set up your physical space entirely manually.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Meta Quest 2，你必须完全手动设置你的物理空间。
- en: Meta Quest room setup
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Meta Quest房间设置
- en: For plane detection to function correctly on a Meta Quest device, you must first
    complete the new **Room Setup** feature found in **Settings** | **Physical Space**
    | **Space Setup** on the Quest headset before entering an MR game. To ensure optimal
    performance, it’s also recommended to include at least one piece of furniture
    with a horizontal surface, such as a table.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保Meta Quest设备上的平面检测功能正常工作，你必须首先在Quest头戴式设备上的**设置** | **物理空间** | **空间设置**中完成新的**房间设置**功能，然后再进入MR游戏。为了确保最佳性能，还建议至少包含一件带有水平表面的家具，例如桌子。
- en: Please note that the MR game we’ll create relies on providing examples for the
    different surface planes established by either the physical scan or manual space
    setup. You must ensure your room includes at least four walls and a table.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将创建的 MR 游戏依赖于提供由物理扫描或手动空间设置建立的不同的表面平面示例。您必须确保您的房间至少有四面墙和一张桌子。
- en: You can perform the room setup any time before running an MR game or experience,
    so you can do this at your leisure. But for now, we’ll move on to creating and
    setting up our Unity project to get started with our boss room battle.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在运行 MR 游戏或体验之前随时进行房间设置，因此您可以随时进行。但就目前而言，我们将继续创建和设置我们的 Unity 项目，以开始我们的老板房间战斗。
- en: Creating the Unity project
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Unity 项目
- en: Install the latest Unity 2022.3 LTS release if you haven’t already – this is
    so we have access to the new VR and MR templates in **Unity Hub**. We’ll also
    require the **Android Build Support** module to be available, so ensure you have
    that, along with the **OpenJDK** and **Android SDK & NDK Tools** modules installed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装，请安装最新的 Unity 2022.3 LTS 版本——这样我们才能在 **Unity Hub** 中访问新的 VR 和 MR 模板。我们还需要确保
    **Android Build Support** 模块可用，因此请确保您已安装该模块，以及 **OpenJDK** 和 **Android SDK & NDK
    Tools** 模块。
- en: '![Figure 14.3 – Install the Android Build Support module](img/B18347_14_03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.3 – 安装 Android Build Support 模块](img/B18347_14_03.jpg)'
- en: Figure 14.3 – Install the Android Build Support module
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – 安装 Android Build Support 模块
- en: With the minimum required Unity Editor version and Android dependency modules
    now installed, we’re ready to rapidly set up our MR boss room project using Unity’s
    new **Mixed Reality** (Core) template. It’s built upon the core MR technologies
    outlined in the *Introduction to MR and development frameworks* section. How very
    convenient!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已安装所需的最小 Unity 编辑器版本和 Android 依赖模块，我们可以使用 Unity 的新 **混合现实**（核心）模板快速设置我们的 MR
    老板房间项目。它基于 *MR 和开发框架简介* 部分中概述的核心 MR 技术。多么方便啊！
- en: The MR template project simplifies XR development by streamlining the implementation
    of advanced features such as plane detection, device passthrough, and spatial
    UI creation alongside designer-friendly XR interactable components. It comes pre-configured
    with essential packages such as XRI, AR Foundation, Unity OpenXR Meta, and XR
    Hands, making project setup and package management a breeze. This MR project template
    approach targets the needs of MR creators for richer content and reduces developer
    friction in accessing advanced MR features.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: MR 模板项目通过简化高级功能的实现（如平面检测、设备穿透和空间 UI 创建）以及设计友好的 XR 可交互组件，简化了 XR 开发。它预配置了必要的包，如
    XRI、AR Foundation、Unity OpenXR Meta 和 XR Hands，使得项目设置和包管理变得轻松。这种 MR 项目模板方法针对 MR
    创作者对更丰富内容的需求，并减少了开发者访问高级 MR 功能的摩擦。
- en: Additional reading | Unity MR template
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity MR 模板
- en: 'Mixed Reality Template Quick Start Guide: [https://docs.unity3d.com/Packages/com.unity.template.mixed-reality%401.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.template.mixed-reality%401.0/manual/index.xhtml)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 混合现实模板快速入门指南：[https://docs.unity3d.com/Packages/com.unity.template.mixed-reality%401.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.template.mixed-reality%401.0/manual/index.xhtml)
- en: 'Explore cross-platform MR development on Meta Quest 3: [https://blog.unity.com/engine-platform/cross-platform-mixed-reality-development-on-meta-quest-3](https://blog.unity.com/engine-platform/cross-platform-mixed-reality-development-on-meta-quest-3)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Meta Quest 3 上探索跨平台 MR 开发：[https://blog.unity.com/engine-platform/cross-platform-mixed-reality-development-on-meta-quest-3](https://blog.unity.com/engine-platform/cross-platform-mixed-reality-development-on-meta-quest-3)
- en: Open Unity Hub and click the **New Project** button (top-right corner) to create
    a new project. Then, referring to *Figure 14**.4*, follow these steps.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Unity Hub 并点击右上角的 **新建项目** 按钮，以创建一个新项目。然后，参照 *图 14.4*，按照以下步骤操作。
- en: Ensure the Unity 2022.3 LTS version previously installed is selected in the
    **Editor Version** dropdown at the top.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在顶部的 **编辑器版本** 下拉菜单中选择了之前安装的 Unity 2022.3 LTS 版本。
- en: In the center template list, scroll down and select **Mixed** **Reality** (Core).
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在中间的模板列表中，向下滚动并选择 **混合现实**（核心）。
- en: In the right pane, if you’re prompted with a **Download template** button, click
    to download the template.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧面板中，如果您看到 **下载模板** 按钮，请点击以下载模板。
- en: 'Once the template finishes downloading, provide these options:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦模板下载完成，提供以下选项：
- en: '`MR` `Boss Room`.'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MR` `Boss Room`。'
- en: '**Location**: Select the folder path for where to store your project files.'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置**：选择存储项目文件的文件夹路径。'
- en: '**Unity Cloud Organization**: You must select the organization to which this
    project will belong. When you create a new Unity ID account, Unity generates an
    organization associated with your username and ID. The base feature a Unity organization
    provides is the ability to organize your projects, services, and licenses.'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity云组织**: 您必须选择此项目所属的组织。当您创建一个新的Unity ID账户时，Unity会为您生成一个与您的用户名和ID关联的组织。Unity组织提供的基本功能是组织您的项目、服务和许可证。'
- en: '**Connect to Unity Cloud**: Only enable this if you wish to take advantage
    of gaming services for your project (generally, yes, you’ll want this).'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接到Unity云**: 只有当您希望利用游戏服务来支持您的项目时（通常，您会希望这样做）才启用此选项。'
- en: '**Use Unity Version Control**: Enable this option if you want to have Unity
    Cloud’s **version control system** (**VCS**) back up your project to the cloud
    and allow additional team members to collaborate on the project (we’ll cover Unity
    Version Control in [*Chapter 15*](B18347_15.xhtml#_idTextAnchor301)).'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Unity版本控制**: 如果您想使用Unity Cloud的**版本控制系统**（**VCS**）将项目备份到云中，并允许其他团队成员协作，请启用此选项（我们将在[*第15章*](B18347_15.xhtml#_idTextAnchor301)中介绍Unity版本控制）。'
- en: '![Figure 14.4 – New Mixed Reality project from a template](img/B18347_14_04.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图14.4 – 从模板创建的新混合现实项目](img/B18347_14_04.jpg)'
- en: Figure 14.4 – New Mixed Reality project from a template
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 – 从模板创建的新混合现实项目
- en: To start creating the project, click the **Create project** button and relax
    for a few minutes.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始创建项目，请点击**创建项目**按钮，并放松几分钟。
- en: Let’s finalize some essential setup steps once the project opens in the Unity
    Editor.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目在Unity编辑器中打开，让我们完成一些基本设置步骤。
- en: 'Open **File** | **Build Settings…** and follow these steps to configure the
    platform to support building to our Meta Quest device:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**文件** | **构建设置…**，按照以下步骤配置平台以支持构建到我们的Meta Quest设备：
- en: Select **Android** in the **Platform** list.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**平台**列表中选择**Android**。
- en: Select **ASTC** from the **Texture** **Compression** dropdown.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**纹理压缩**下拉菜单中选择**ASTC**。
- en: Click the **Switch** **Platform** button.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**切换平台**按钮。
- en: Done!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！
- en: ASTC
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ASTC
- en: '**Adaptable Scalable Texture Compression** (**ASTC**) is a texture compression
    method that uses variable block sizes instead of a single fixed size and replaces
    older formats while also providing additional features.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**可伸缩纹理压缩**（**ASTC**）是一种使用可变块大小而不是单个固定大小的纹理压缩方法，它取代了旧格式，同时也提供了额外的功能。'
- en: 'You can now open the `SampleScene` scene located in the `Assets/Scenes` folder
    to examine the scene setup, including the following GameObjects responsible for
    managing the XR features, including controller and hand tracking, interaction
    with the UI and virtual objects, and AR features such as surface plane detection
    and passthrough: **MR Interaction Setup**, **UI**, and **Environment**.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以打开位于`Assets/Scenes`文件夹中的`SampleScene`场景，以检查场景设置，包括以下负责管理XR功能（包括控制器和手部追踪、与UI和虚拟对象的交互以及AR功能，如表面平面检测和透视）的GameObject：**MR交互设置**、**UI**和**环境**。
- en: Universal RP renderer settings
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通用RP渲染器设置
- en: Please note that the Meta Quest headset is sensitive to the Unity renderer settings
    being correctly configured for the platform. Therefore, I suggest keeping the
    URP renderer and quality settings at the default values provided by the MR project
    template (unless you really know what you’re doing).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Meta Quest头显对Unity渲染器设置的正确配置非常敏感。因此，我建议将URP渲染器和质量设置保持在MR项目模板提供的默认值（除非您真的知道自己在做什么）。
- en: 'Also note that standalone VR hardware, such as the Quest, requires additional
    consideration for performance optimization to sustain a minimum FPS (typically,
    not less than 72 FPS): this is to prevent vection (the visual perception of motion
    while the body is still), which can make people nauseous.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，独立VR硬件，如Quest，需要额外的性能优化考虑，以维持最低FPS（通常，不低于72 FPS）：这是为了防止视觉运动（当身体静止时的视觉感知），这可能会让人感到恶心。
- en: With your Quest headset attached to your system with the USB-C cable, you can
    verify the device is recognized by Unity by going to the **Build Settings** window
    with the **Android** platform selected, in the **Run Device** field, and clicking
    the dropdown that currently shows **Default device**. Your Meta/Oculus Quest 3
    (or 2) device should be listed there.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的Quest头显通过USB-C线缆连接到系统后，您可以通过选择**Android**平台，在**运行设备**字段中，点击当前显示**默认设备**的下拉菜单，来验证Unity是否识别了该设备。您的Meta/Oculus
    Quest 3（或2）设备应该列在那里。
- en: Testing in Play Mode with Quest Link
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Quest Link在播放模式中进行测试
- en: To thoroughly test and play our game, we must build to the device because plane
    detection and passthrough are currently not supported with Quest Link when entering
    Play Mode in the Unity Editor. I would still recommend leveraging Quest Link for
    rapidly iterating on setting up object interactions independent of the gameplay
    and then building to the device for complete gameplay testing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了彻底测试和玩我们的游戏，我们必须在设备上构建，因为当在Unity编辑器中进入播放模式时，Quest Link目前不支持平面检测和passthrough。我仍然建议利用Quest
    Link来快速迭代设置对象交互，独立于游戏玩法，然后构建到设备上进行完整游戏测试。
- en: To use Quest Link, ensure you are connected to your system with the USB-C cable
    and have the Oculus app (Meta Quest Link) running, then click the Quest Link button
    on the Quest headset’s **Quick Settings** menu. Once established, you can enter
    Play Mode in Unity to playtest your scene.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Quest Link，请确保你用USB-C线缆连接到你的系统，并且Oculus应用（Meta Quest Link）正在运行，然后点击Quest头戴设备的**快速设置**菜单中的Quest
    Link按钮。一旦建立连接，你就可以在Unity中进入播放模式来测试你的场景。
- en: Now, still in the **Build Settings** window, click **Build And Run**, or press
    *Ctrl/Cmd* + *B* and pop on that headset!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，仍然在**构建设置**窗口中，点击**构建并运行**，或者按*Ctrl/Cmd* + *B*，然后戴上头戴设备！
- en: Tip
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: It’s vital to recenter or reset your orientation when you begin a MR environment.
    This ensures that virtual objects are placed correctly about your current position
    and facing direction. Doing this will enhance your experience, especially as device
    orientation detection technology continues to improve.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始MR环境时重新居中或重置你的方向至关重要。这确保了虚拟对象被正确地放置在你的当前位置和面向方向周围。这样做将增强你的体验，尤其是在设备方向检测技术持续改进的情况下。
- en: The MR template is configured to use either controllers or hands. Still, we’ll
    focus on using the controllers for our game, so I’d recommend you play around
    with using the controllers as input in the sample project.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: MR模板配置为使用控制器或双手。不过，我们仍将专注于使用控制器进行我们的游戏，所以我建议你在示例项目中尝试使用控制器作为输入。
- en: This verifies your Quest headset device and Unity MR project setup for XR development
    are ready. So, let’s start building out the boss room!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这验证了你的Quest头戴设备和Unity MR项目设置已准备好进行XR开发。那么，让我们开始构建老板房间吧！
- en: Laying out the boss room scene
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局老板房间场景
- en: According to our GDD, we must clear the central control system from the evil
    plant entity infestation. So, to do that, we need to energize the sabotaged control
    console and restart the reactor (yes, believe me, that will do the trick). Therefore,
    the boss room’s layout requires objects related to this context to be present
    in our scene.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的GDD，我们必须清除中央控制系统中的邪恶植物实体感染。因此，为了做到这一点，我们需要为受损的控制台供电并重启反应堆（是的，相信我，这会起作用）。因此，老板房间的布局需要在我们的场景中包含与此相关的对象。
- en: 'Here are the objects we’ll need for our boss room setup:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们为老板房间设置所需的对象：
- en: '**Control console**: Maintains the state of all the habitation station’s primary
    systems, including the main power reactor. It has three crystal module slots for
    energizing the system.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制台**：维护居住站所有主要系统的状态，包括主反应堆。它有三个晶体模块插槽来为系统供电。'
- en: '**Power reactor**: Provides power to the central systems, especially the ones
    in charge of environmental control and eradicating foreign entities.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反应堆**：为中央系统提供电力，特别是负责环境控制和清除外来实体的系统。'
- en: '**Corridors**: The habitat station comprises several rooms and connecting corridors
    – this should already be familiar from the 3D FPS project.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**走廊**：居住站由几个房间和连接走廊组成——这应该已经从3D FPS项目中熟悉了。'
- en: These are the primary objects we need in our scene, which, again, is your room,
    to provide the setting for the boss encounter. We’ll construct the layout to have
    the control console near the player and virtual corridors extending from the center
    of the room, providing a central focal point for the action.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们场景中所需的主要对象，再次强调，这是你的房间，为老板遭遇提供背景。我们将构建布局，使控制台靠近玩家，并从房间中心延伸出虚拟走廊，为动作提供一个中心焦点。
- en: With this layout in mind, in the following screenshot – from a Quest 3 with
    a passthrough visible – we can see the objects instantiated in this fashion in
    a real-world room.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个布局的考虑下，在下面的截图中——来自一个带有passthrough可见的Quest 3——我们可以看到以这种方式实例化的对象在现实世界房间中的样子。
- en: '![Figure 14.5 – Virtual objects spawned in a physical space](img/B18347_14_05.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图14.5 – 在物理空间中生成的虚拟对象](img/B18347_14_05.jpg)'
- en: Figure 14.5 – Virtual objects spawned in a physical space
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 – 在物理空间中孵化的虚拟对象
- en: 'Let’s first duplicate the provided MR template’s sample scene to start setting
    up the scene:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先复制提供的 MR 模板示例场景，开始设置场景：
- en: Find the `SampleScene` scene in the `Assets/Scenes` folder.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/Scenes` 文件夹中找到 `SampleScene` 场景。
- en: Duplicate it by selecting and pressing *Crtl/Cmd* + *D*.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择并按 *Crtl/Cmd* + *D* 复制它。
- en: Rename it to `Boss Room`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为 `Boss Room`。
- en: 'Now, open the scene, and we’ll deactivate some example content provided in
    the scene Hierarchy that we won’t use. Select and deactivate the following objects
    (using the checkbox at the top of the Inspector to the left of the object’s name):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开场景，我们将关闭场景中提供的某些示例内容，这些内容我们不会使用。选择并关闭以下对象（使用位于对象名称左侧的检查框）：
- en: 'Disable these two child objects of `MR` `Interaction Setup`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用 `MR` `交互设置` 的这两个子对象：
- en: '`Goal Manager`'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`目标管理器`'
- en: '`Object Spawner`'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`对象孵化器`'
- en: 'Disable these two child objects of `UI`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用 `UI` 的这两个子对象：
- en: '`Coaching UI`'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`教练界面`'
- en: '`Hand` `Menu Setup`'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`手` `菜单设置`'
- en: Save the scene.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。
- en: We’re done! We now have an empty scene with all the XR setup ready for us to
    create our MR game. Easy-peasy.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了！我们现在有一个空场景，所有 XR 设置都已准备好供我们创建我们的 MR 游戏。简单易行。
- en: In this section, we covered the fundamental principles of designing a boss room
    and the steps required to set up our physical space with our Quest devices. Additionally,
    we learned how to create a basic starting project using Unity’s MR template and
    configuring it for our use.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了设计老板房的基本原则和设置我们物理空间所需的步骤。此外，我们还学习了如何使用 Unity 的 MR 模板创建基本起始项目，并对其进行配置以供我们使用。
- en: When creating the virtual objects that construct our boss room, we use AR surface
    planes representing real-world objects in our physical space to spawn them dynamically.
    Let’s explore how to spawn virtual objects using detected AR planes next.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建构建我们老板房间的虚拟对象时，我们使用代表我们物理空间中真实世界对象的 AR 表面平面来动态地孵化它们。接下来，让我们探索如何使用检测到的 AR
    平面孵化虚拟对象。
- en: Working with AR planes (AR Foundation)
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 AR 平面（AR 基础）一起工作
- en: AR planes are virtual representations of flat planar surfaces, both horizontal
    and vertical, represented by dimensions and boundary points and detected by the
    AR Foundation technology. The planes provide a foundation for accurately placing
    digital objects and interacting with the surfaces.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: AR 平面是代表水平和平面表面的虚拟表示，无论是水平还是垂直，由尺寸和边界点表示，并由 AR 基础技术检测。这些平面为准确放置数字对象和与表面交互提供了基础。
- en: As previously mentioned, these planes represent the walls, floor and ceiling,
    tables, and so on, and we’ll use the walls, floor, and table specifically in this
    example boss room to blend the gameplay seamlessly with the player’s physical
    surroundings.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些平面代表墙壁、地板和天花板、桌子等，我们将在这个示例老板房中特别使用墙壁、地板和桌子，以无缝地将游戏玩法与玩家的物理环境融合在一起。
- en: Tip
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**AR Plane Manager** allows you to specify a prefab for plane visualization.
    The **AR Plane** Prefab, provided by the MR template, uses a shader that occludes
    objects assigned a material with transparency, so if you want objects that are
    meant to be seen past the AR planes, ensure you don’t use a transparent material.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR Plane Manager** 允许您指定用于平面可视化的预制件。由 MR 模板提供的 **AR Plane** 预制件使用一个着色器，它会遮挡分配了透明材料的对象，因此如果您想要在
    AR 平面之后可以看到的对象，请确保您不使用透明材料。'
- en: Now, let’s start working with our first horizontal plane type, the table, to
    see how we can detect the plane type and use its properties to spawn an object.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始处理我们的第一个水平平面类型，即桌子，看看我们如何检测平面类型并使用其属性来孵化一个对象。
- en: Spawning using planes with AR Plane Manager
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 AR Plane Manager 在飞机上孵化
- en: The `AR Plane Manager` component, located on the `XR Origin (XR Rig)` object
    as a child of the `MR Interaction Setup` root object, is responsible for the detection
    of the horizontal and vertical surfaces in the physical space and creates the
    virtual plane objects (`AR Plane` Prefab) that our virtual content can be placed
    and interacted with.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 位于 `XR Origin (XR Rig)` 对象上作为 `MR Interaction Setup` 根对象的子对象的 `AR Plane Manager`
    组件负责检测物理空间中的水平和垂直表面，并创建我们的虚拟内容可以放置和与之交互的虚拟平面对象（`AR Plane` 预制件）。
- en: Optimization note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 优化提示
- en: With **AR Plane Manager**, in addition to specifying the **AR Plane** Prefab,
    you can choose between horizontal, vertical, or both for **Detection Mode**. Turning
    off vertical plane detection is recommended if you only need to detect horizontal
    planes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**AR Plane Manager**，除了指定**AR Plane** Prefab外，您还可以在**检测模式**中选择水平、垂直或两者都选。如果您只需要检测水平平面，建议关闭垂直平面检测。
- en: One of the first things we’ll have to do is enable the `AR Plane Manager` component
    because it is deactivated by default within the MR sample scene. We’ll do that
    with our first script, the game manager.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先必须做的一件事是启用`AR Plane Manager`组件，因为它在MR示例场景中默认未激活。我们将通过我们的第一个脚本，即游戏管理器来完成此操作。
- en: 'Create a new script named `GameManager` in the `Assets/Scripts` folder, and
    start with the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Assets/Scripts`文件夹中创建一个名为`GameManager`的新脚本，并从以下代码开始：
- en: '[PRE0]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, create a GameObject in the scene and attach this script to it. As you can
    see, we’ve changed the method signature for the `Start()` method to be an `IEnumerator`
    (yes, you can do that), and we’ve delayed the execution of the `EnablePlaneManager()`
    method call for 2 seconds (to give XR components time to initialize).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在场景中创建一个GameObject，并将此脚本附加到它上。如您所见，我们已经将`Start()`方法的签名更改为`IEnumerator`（是的，您可以这样做），并且我们延迟了`EnablePlaneManager()`方法调用的执行2秒钟（以便给XR组件初始化时间）。
- en: 'Assign `_planeManager` in the Inspector by dragging in the `XR Origin (XR Rig)`
    object to the field on the `GameManager` component. We’re enabling the component
    in the `EnablePlaneManager()` method like so:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`XR Origin (XR Rig)`对象拖入`GameManager`组件的字段中，在检查器中分配`_planeManager`。我们像这样在`EnablePlaneManager()`方法中启用组件：
- en: '[PRE1]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can now playtest the boss room scene by first ensuring the scene is added
    to **Scenes in Build** in the **Build Settings** window, connecting your Quest
    device to your system via the USB-C cable, and clicking **Build And Run** (*Ctrl/Cmd*
    + *B*, i.e., *build* *and run)*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过确保场景已添加到**构建设置**窗口中的**构建场景**，通过USB-C线缆将您的Quest设备连接到系统，并点击**构建并运行**（*Ctrl/Cmd*
    + *B*，即*构建* *并运行*）来测试老板房间场景。
- en: You should see something similar to the following figure, where the detected
    planes for the walls, floor and ceiling, and any horizontal surfaces such as tables
    have a fading dotted material. Note that I’ve manually added the magenta lines
    for better visibility of the planar surfaces (which include a table, the walls,
    and the floor).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下类似的图像，其中墙壁、地板和天花板以及任何水平表面（如桌子）都有淡化的虚线材质。请注意，我已经手动添加了洋红色线条以更好地显示平面表面（包括桌子、墙壁和地板）。
- en: '![Figure 14.6 – Detected surface planes in the room](img/B18347_14_06.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图14.6 – 房间中检测到的表面平面](img/B18347_14_06.jpg)'
- en: Figure 14.6 – Detected surface planes in the room
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 – 房间中检测到的表面平面
- en: Now that we’ve verified we have planes to work with, let’s start spawning in
    our virtual objects for the boss room.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了我们可以使用平面，让我们开始为老板房间实例化我们的虚拟对象。
- en: Instantiating on a table plane
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在桌面上实例化
- en: 'Whoa, wait a second… we need the objects we’ll be spawning into the room. We
    can thank **Polypix Studios** again for providing 3D art for these assets: console,
    module, reactor, corridor, gun, and hover bot.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，等等……我们需要将对象放入房间中。我们可以再次感谢**Polypix Studios**为这些资源提供3D艺术：控制台、模块、反应器、走廊、枪和悬浮机器人。
- en: Boss room virtual objects
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 老板房间虚拟对象
- en: 'You can download **VirtualObjects-start.zip** from the book’s GitHub repo here:
    [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Art-Assets).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从本书的GitHub仓库中下载**VirtualObjects-start.zip**：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Art-Assets)。
- en: Unzip the file to get the '**.unitypackage**' file and import it into your project
    – you can do that by dragging and dropping the file from your system’s file manager
    to Unity’s **Project** window.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 解压文件以获取`**.unitypackage**`文件，并将其导入到您的项目中 – 您可以通过将文件从系统文件管理器拖放到Unity的**项目**窗口中来实现这一点。
- en: 'The first asset we’ll work with is the reactor model imported as the `Reactor`
    Prefab in the `Assets/Prefabs` folder, as seen in the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的第一个资源是作为`Reactor` Prefab导入到`Assets/Prefabs`文件夹中的反应器模型，如下截图所示：
- en: '![Figure 14.7 – Boss room 3D asset Prefabs](img/B18347_14_07.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图14.7 – 老板房间3D资产Prefab](img/B18347_14_07.jpg)'
- en: Figure 14.7 – Boss room 3D asset Prefabs
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7 – 老板房间3D资产Prefab
- en: And we’ll spawn the `Reactor` Prefab on the first table detected in the room.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`Reactor` Prefab实例化到房间中检测到的第一个桌子上。
- en: '`AR Plane Manager` provides a `planesChanged` event that we’ll subscribe to,
    and when a `PlaneClassification` is of the `Table` type, we know we should spawn
    the reactor. So, let’s add the listener in our `GameManager` class and the handler
    method for spawning the object:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`AR Plane Manager`提供了一个`planesChanged`事件，我们将订阅它，当`PlaneClassification`是`Table`类型时，我们知道我们应该生成反应堆。所以，让我们在我们的`GameManager`类中添加监听器和处理生成对象的处理方法：'
- en: '[PRE2]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Don’t forget to unsubscribe from the listener in `OnDisable()` or `OnDestroy()`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`OnDisable()`或`OnDestroy()`中取消订阅监听器。
- en: 'Now, add the handler method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加处理方法：
- en: '[PRE3]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, you can see we loop through all the detected planes (`ARPlane` type)
    provided by the handler’s `args` parameter with a `foreach` statement. Then, the
    `switch` statement allows us to work with the specific plane classification for
    our needs, which, again, is `Table`. We use a helper `SpawnPrefab()` method, which
    performs the instantiation – passing in the specific plane and Prefab:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们使用`foreach`语句遍历处理程序的`args`参数提供的所有检测到的平面（`ARPlane`类型）。然后，`switch`语句允许我们根据我们的需求处理特定的平面分类，这再次是`Table`。我们使用一个辅助的`SpawnPrefab()`方法，该方法执行实例化——传递特定的平面和Prefab：
- en: '[PRE4]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see we’re using the regular `Instantiate()` method and the plane’s `position`
    and `rotation` values for the point of instantiation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们正在使用常规的`Instantiate()`方法和平面的`position`和`rotation`值作为实例化的点。
- en: To ensure we’re only spawning one reactor in the scene, if the physical space
    has multiple table surfaces defined, we’ll use the `_hasSpawnedPrefab_Reactor`
    Boolean to limit it to one and call the `SpawnPrefab()` method, specifying the
    `ARPlane` and `Reactor` Prefab as the parameters. Setting `_hasSpawnedPrefab_Reactor`
    to `true` after calling the spawn method ensures only one Prefab is spawned.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保场景中只生成一个反应堆，如果物理空间定义了多个桌面表面，我们将使用`_hasSpawnedPrefab_Reactor`布尔值将其限制为一个，并调用`SpawnPrefab()`方法，指定`ARPlane`和`Reactor`
    Prefab作为参数。在调用生成方法后，将`_hasSpawnedPrefab_Reactor`设置为`true`确保只生成一个Prefab。
- en: You must ensure you’ve declared the variables to assign the `Reactor` Prefab
    and *has spawned* bool. Then, assign the `Reactor` Prefab from the `GameManager`
    field in the Inspector.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须确保你已经声明了变量来分配`Reactor` Prefab和`has spawned`布尔值。然后，从检查器中的`GameManager`字段分配`Reactor`
    Prefab。
- en: If you build and run the project on your device now, you should see the reactor
    appear on your table!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在在你的设备上构建并运行项目，你应该会在你的桌子上看到反应堆出现！
- en: '![Figure 14.8 – The reactor Prefab spawned on the table plane](img/B18347_14_08.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图14.8 – 在桌子上生成的反应堆Prefab](img/B18347_14_08.jpg)'
- en: Figure 14.8 – The reactor Prefab spawned on the table plane
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8 – 在桌子上生成的反应堆Prefab
- en: Enabling passthrough
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 启用穿透
- en: If you want to temporarily skip ahead to see the virtual objects sitting in
    your real-world surroundings, we’ll need to toggle the passthrough to be visible.
    In the *Toggling MR visuals with XR Input section*, we’ll add the ability to toggle
    passthrough visibility.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要暂时跳过，看看虚拟对象坐在你的真实世界环境中的样子，我们需要切换穿透以使其可见。在*使用XR输入切换MR视觉效果部分*，我们将添加切换穿透可见性的功能。
- en: That takes care of demonstrating how to instantiate an object on the table plane.
    Let’s move on to spawning on the floor plane next.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了如何在桌子上实例化对象的演示。接下来，让我们继续在地面平面上生成对象。
- en: Instantiating using the floor plane
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用地面平面实例化
- en: Unlike the reactor’s placement, we’ll prioritize the orientation of the controller
    console object relative to the player’s forward direction (when the planes are
    detected) to ensure immediate interaction availability for the player.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与反应堆的放置不同，我们将优先考虑控制器控制台对象相对于玩家前向方向（当检测到平面时）的朝向，以确保玩家可以立即进行交互。
- en: 'The process is relatively the same, except for said orientation. So, let’s
    first add to our `switch (plane.classification)` block to handle the `Floor` classification:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 流程基本上是相同的，只是方向不同。所以，我们首先将`switch (plane.classification)`块添加到我们的代码中，以处理`Floor`分类：
- en: '[PRE5]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have a similar Boolean check to ensure we don’t have multiple control consoles
    spawned into the room with the `_hasSpawnedPrefab_Console` variable and a method
    overload for `SpawnPrefab()`. The new spawn method signature takes an additional
    parameter for an offset – and we’ll assume that the offset is from the player’s
    location.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个类似的布尔检查，以确保我们不会在房间中通过`_hasSpawnedPrefab_Console`变量生成多个控制台，并且为`SpawnPrefab()`方法提供了一个方法重载。新的生成方法签名增加了一个额外的参数用于偏移量——我们将假设这个偏移量是从玩家位置开始的。
- en: 'The new spawner method with the offset looks like the following – add it to
    the `GameManager` class:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 带有偏移的新spawner方法如下——将其添加到`GameManager`类中：
- en: '[PRE6]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The points of interest in the new spawn method are as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 新的spawn方法中的重点如下：
- en: '`playerTransform`: We get the player’s current position in the world from the
    main camera, which is attached to `XR Origin (XR Rig)` to represent the player’s
    head.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playerTransform`: 我们从主相机中获取玩家的当前位置，该相机连接到`XR Origin (XR Rig)`以表示玩家的头部。'
- en: '`playerTransform.position`: We apply a new `Vector3` Y-value to `playerTransform`
    to anchor the instantiated model to the floor plane (its Y-value).'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playerTransform.position`: 我们将新的`Vector3` Y值应用到`playerTransform`上，以便将实例化的模型锚定到地板平面上（其Y值）。'
- en: '`worldOffset`: We take the player offset value provided and use the `TransformDirection()`
    method to ensure the player offset will be applied in the appropriate world space
    coordinates – there is no way we could know the world coordinates to pass into
    the spawn method since it is relative to the player’s current position.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`worldOffset`: 我们接收玩家偏移值并使用`TransformDirection()`方法来确保玩家偏移将在适当的世界空间坐标中应用——因为我们无法知道传递给spawn方法的坐标，因为它是相对于玩家当前位置的。'
- en: '`spawnRotation`: We want to ensure the console faces the player when instantiated,
    so we use `Quaternion.LookRotation()` to accomplish that.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spawnRotation`: 我们希望确保实例化时控制台面向玩家，所以我们使用`Quaternion.LookRotation()`来实现这一点。'
- en: We finish by just calling the `Instantiate()` method, like before. Add the required
    variables and make the Inspector assignments. Then, save your changes and go ahead
    and do another *build and run* to see the console in your room. An example of
    the console placement can be seen in the virtual objects spawned into the actual
    room in the *Figure 14**.5*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`Instantiate()`方法来完成，就像之前一样。添加所需的变量并执行检查器分配。然后，保存你的更改，继续进行另一个*构建和运行*，以查看你房间中的控制台。*图14*.5中可以看到控制台放置的示例。
- en: Okay, we’re making great progress on the boss room layout! The last environmental
    object to get into our room is the corridor, which will virtually extend the reality
    of the room and set the stage for our enemy hover bots to engage the player.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们在老板房间布局上取得了很大的进展！最后要进入我们房间的环境对象是走廊，它将虚拟扩展房间的现实，并为我们的敌人悬浮机器人与玩家交战设定舞台。
- en: Instantiating with wall planes
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用墙平面实例化
- en: Our last AR-detected plane instantiation example will still be relatively the
    same as the previous two, except we now have to account for spawning an object
    relative to a vertical surface. This will require a bit of additional care during
    positioning because the plane anchors are located in the center of the plane’s
    surface object.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一个AR检测到的平面实例化示例将与前两个相对相似，但现在我们必须考虑相对于垂直表面实例化对象。这将在定位时需要一些额外的注意，因为平面锚点位于平面表面对象的中心。
- en: 'Fortunately, we have access to all the basic `Bounds` properties, such as `extents`,
    but we still need the surface extent and orientation. So, let’s first add to our
    `switch (plane.classification)` block to handle the `Wall` classification:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以访问所有基本的`Bounds`属性，例如`extents`，但我们仍然需要表面范围和方向。所以，让我们首先向我们的`switch (plane.classification)`块添加代码来处理`Wall`分类：
- en: '[PRE7]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see the same pattern here as before, using the Boolean to determine
    whether we’ve spawned the corridor Prefab already and calling a spawn Prefab method,
    passing in just the plane and the Prefab again this time.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到与之前相同的模式，使用布尔值来确定我们是否已经实例化了走廊Prefab，并调用spawn Prefab方法，这次只传递了平面和Prefab。
- en: 'The `SpawnPrefabAtWallBase()` method looks like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpawnPrefabAtWallBase()`方法看起来如下：'
- en: '[PRE8]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Just a bit more calculation is required here to ensure we are anchoring the
    Prefab’s instantiation point to the vertical bottom of the surface plane – at
    the same Y-value as the floor – by using `plane.extents` and subtracting from
    the plane’s transform position (at the center of the plane).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要做一点额外的计算，以确保我们将Prefab的实例化点锚定到表面平面的垂直底部——与地板相同的Y值——通过使用`plane.extents`并从平面的变换位置（平面的中心）中减去。
- en: For the rotation of the spawned Prefab, we’ll again use `LookRotation()`, but
    this time, instead of using the *direction to player* vector, we’ll use the plane’s
    surface normal vector. The plane’s surface normal is pointing away from the center
    of the room, so we want to invert it for the instantiation of the corridor Prefab
    that has its forward direction looking down the corridor (for your own 3D models,
    you can invert either the normal vector or rotate the pivot’s forward direction
    for the correct orientation).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生成的Prefab的旋转，我们再次使用`LookRotation()`，但这次，我们不会使用**玩家方向**向量，而是使用平面的表面法线向量。平面的表面法线指向房间的中心，因此我们想要将其反转以实例化走廊Prefab，该Prefab的前进方向朝向走廊（对于你自己的3D模型，你可以反转法线向量或旋转枢轴的前进方向以获得正确的方向）。
- en: Again, add the required script variables, save the script, make the corridor
    Prefab assignment to the field on `GameManager`, save your scene, and build and
    run the app to test the placement of the corridor addition to the boss room.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，添加所需的脚本变量，保存脚本，将走廊Prefab分配到`GameManager`的字段上，保存你的场景，然后构建并运行应用程序以测试走廊添加到Boss房间中的位置。
- en: Now that we have the layout of the boss room completed, with all the elements
    required for the battle, let’s see how we can work with the MR visuals to set
    a proper gameplay experience without AR planes being visible and passthrough enabled.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了Boss房间的布局，包含了所有战斗所需的元素，让我们看看我们如何与MR视觉效果合作，在不显示AR平面和启用透传的情况下设置合适的游戏体验。
- en: Toggling MR visuals with XR Input
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用XR输入切换MR视觉效果
- en: You know how much of a fan I am of reusable components to build out functionality
    that is also designer-friendly in our games. So, let’s approach input from our
    XR controllers similarly by adding an *on button press* component that relies
    on an `InputAction` input signal (courtesy of the new Input System) to identify
    the button presses.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道我对在游戏中构建功能的同时也便于设计师使用的可重用组件有多大的热情。所以，让我们通过添加一个依赖于`InputAction`输入信号的**按钮按下**组件来以类似的方式从我们的XR控制器处理输入。
- en: 'You can get the `OnButtonPress` script file from the GitHub repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Code-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Code-Assets),
    then import it into your project in the `Assets/Scripts/Interaction` folder.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从GitHub仓库中获取`OnButtonPress`脚本文件：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Code-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Code-Assets)，然后将其导入到你的项目中`Assets/Scripts/Interaction`文件夹。
- en: 'We’re going to wire up buttons for the following in-game actions:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为以下游戏内动作设置按钮：
- en: Right controller, primary button (**A**) à Toggle passthrough visibility.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右控制器，主要按钮（**A**）→ 切换透传可见性。
- en: Right controller, secondary button (**B**) à Toggle AR plane surfaces.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右控制器，次要按钮（**B**）→ 切换AR平面表面。
- en: Left controller, primary button (**X**) à Start game.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左控制器，主要按钮（**X**）→ 开始游戏。
- en: Let’s see what the buttons for the Oculus controllers with Unity’s **XR Input**
    mappings look like in the following figure.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Unity的**XR输入**映射的Oculus控制器按钮在以下图中是什么样子。
- en: '![Figure 14.9 – Oculus XR controller button mapping](img/B18347_14_09.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图14.9 – Oculus XR控制器按钮映射](img/B18347_14_09.jpg)'
- en: Figure 14.9 – Oculus XR controller button mapping
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9 – Oculus XR控制器按钮映射
- en: Additional reading | XR Input
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | XR输入
- en: 'Unity XR Input mappings: [https://docs.unity3d.com/Manual/xr_input.xhtml#XRInputMappings](https://docs.unity3d.com/Manual/xr_input.xhtml#XRInputMappings)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Unity XR输入映射：[https://docs.unity3d.com/Manual/xr_input.xhtml#XRInputMappings](https://docs.unity3d.com/Manual/xr_input.xhtml#XRInputMappings)
- en: Okay, simple enough. Let’s start by wiring up the passthrough visibility toggle
    for when the **A** button is pressed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，很简单。让我们先为按下**A**按钮时设置透传可见性切换。
- en: Toggling passthrough
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切换透传
- en: The MR template showcases the ability to switch between the virtual environment
    and device passthrough. This is achieved by using a simple fade transition on
    an environment mesh. The mesh employs a vertex color **ShaderGraph**, which has
    an alpha property that can be smoothly transitioned.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: MR模板展示了在虚拟环境和设备透传之间切换的能力。这是通过在环境网格上使用简单的淡入淡出过渡来实现的。网格使用一个**ShaderGraph**着色器，它具有一个可以平滑过渡的alpha属性。
- en: We don’t even have to write a script to perform the fade transition. The MR
    template’s `Environment` Prefab already includes a `FadeMaterial` component with
    an exposed public method for fading!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至不需要编写脚本来实现淡入淡出过渡。MR模板的`Environment`预制件已经包含了一个`FadeMaterial`组件，该组件提供了一个公开的方法用于淡入淡出！
- en: 'So, let’s hook into it quickly to toggle the fade, starting with making a new
    controller script named `SceneController` in the `Assets/Scripts` folder with
    the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们快速进入并切换淡入淡出效果，首先在`Assets/Scripts`文件夹中创建一个新的控制器脚本，命名为`SceneController`，并使用以下代码：
- en: '[PRE9]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Save the script and add it to the `GameManager` object. As you can see, we’ll
    use a `UnityEvent` to assign the reference to the `FadeMaterial` function, passing
    a Boolean parameter representing the visible state to fade to.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本并将其添加到`GameManager`对象中。如您所见，我们将使用`UnityEvent`来分配对`FadeMaterial`函数的引用，传递一个表示要淡入可见状态的布尔参数。
- en: Let’s assign the `OnTogglePassthrough(Boolean)` callback in the Inspector and
    then finish by adding the toggle logic code afterward. So, start by clicking the
    **+** icon to add a new event callback entry. Then, using *Figure 14**.10* as
    a reference, find the **UI** | **Environment** object in the scene Hierarchy and
    drag it to the **Object** field.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在检查器中分配`OnTogglePassthrough(Boolean)`回调，然后完成添加切换逻辑代码。所以，首先点击**+**图标以添加新的事件回调条目。然后，使用*图14.10*作为参考，在场景层次结构中找到**UI**
    | **Environment**对象，并将其拖到**对象**字段。
- en: Now, select the `FadeMaterial.FadeSkybox` function at the top in the `UnityEvent`’s
    `bool` parameter when the event is invoked.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在事件被调用时，在`UnityEvent`的`bool`参数中选择顶部的`FadeMaterial.FadeSkybox`函数。
- en: '![Figure 14.10 – SceneController component setup](img/B18347_14_10.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图14.10 – SceneController组件设置](img/B18347_14_10.jpg)'
- en: Figure 14.10 – SceneController component setup
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10 – SceneController组件设置
- en: 'All that’s left to do is invoke the `OnTogglePassthrough` event when the player
    presses the right controller’s primary button (`SceneController` class for that:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是当玩家按下右侧控制器的主按钮时调用`OnTogglePassthrough`事件（对于该事件，`SceneController`类）：
- en: '[PRE10]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Straightforward, single-responsibility, and well-named methods. Add the private
    member variable `_isPassthroughVisible` for keeping track of the current toggle
    state, which defaults to `false` and is the correct default passthrough state.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 直观、单一职责且命名良好的方法。添加私有成员变量`_isPassthroughVisible`以跟踪当前的切换状态，默认为`false`，这是正确的默认透视状态。
- en: 'Lastly, referring to *Figure 14**.10* for these steps, to receive the player
    input when the controller’s button is pressed, let’s use the `OnButtonPress` component
    with the input action configured for the **A** button:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，参考*图14.10*中的这些步骤，当控制器按钮被按下时接收玩家输入，让我们使用`OnButtonPress`组件，并配置输入动作以用于**A**按钮：
- en: Add the `OnButtonPress` component to the `SceneController`).
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`OnButtonPress`组件添加到`SceneController`。
- en: Click the **+** dropdown, then **Add binding**.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**+**下拉菜单，然后选择**添加绑定**。
- en: Double-click **<****No Binding>**.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**<无绑定>**。
- en: In the **Path** dropdown, select **XR Controller** | **XR Controller (Right
    Hand)** | **Optional Controls** | **primaryButton**.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**路径**下拉菜单中，选择**XR控制器** | **XR控制器（右手）** | **可选控件** | **primaryButton**。
- en: Alternatively, enter the following text (click the `<XRController>{RightHand}/primaryButton.`
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，输入以下文本（点击`<XRController>{RightHand}/primaryButton.`）
- en: Lastly, assign the `OnPress()` `UnityEvent` function to `SceneController.TogglePassthrough`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`OnPress()` `UnityEvent`函数分配给`SceneController.TogglePassthrough`。
- en: Doing a *build and run* to your device now, you can toggle the passthrough visibility
    by pressing the **A** button on your right controller. This will be your first
    time seeing the boss room’s digital objects spawned within your real-world space
    – pretty awesome, right?
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行*构建和运行*到您的设备上，您可以通过按下右侧控制器上的**A**按钮来切换透视可见性。这将是你第一次看到在真实世界空间中生成的老板房间的数字对象——非常酷，对吧？
- en: Camera setup to support passthrough
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 支持透视的相机设置
- en: The MR template’s main camera comes preconfigured to enable device passthrough,
    but it’s worth mentioning the setup. The camera’s background type is **Solid Color**
    with the background color set to black, with **0** alpha. The **AR Camera Manager**
    component is also explicitly included to control passthrough on Meta Quest devices.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: MR模板的主相机已经预配置为启用设备透视，但提一下设置。相机的背景类型是**纯色**，背景颜色设置为黑色，**0**透明度。**AR Camera Manager**组件也被明确包含以控制Meta
    Quest设备上的透视。
- en: Passthrough, check! Now, let’s see about toggling the AR plane visibility when
    the **B** button is pressed.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Passthrough，检查！现在，让我们看看当按下 **B** 按钮时如何切换 AR 飞机可见性。
- en: Toggling AR plane visibility
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切换 AR 飞机可见性
- en: It shouldn’t be any surprise that we’ll mimic the passthrough toggle setup.
    We’ve already seen how to reference and use the `AR Plane Manager` to spawn the
    virtual objects for the different plane classifications. Well, we’ll be using
    it again here to access the current set of **trackables**.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模仿 passthrough 切换设置，这并不令人惊讶。我们已经看到了如何引用和使用 `AR Plane Manager` 来为不同的飞机分类生成虚拟对象。嗯，我们还会在这里再次使用它来访问当前的
    **trackables** 集合。
- en: A trackable is a component that represents AR objects detected in the real world.
    Examples include planes (you’re already familiar with these), point clouds, anchors,
    environment probes, faces, bodies, images, and 3D objects.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 可追踪组件是一个表示在真实世界中检测到的 AR 对象的组件。例如包括飞机（你已经熟悉这些了）、点云、锚点、环境探测、面部、身体、图像和 3D 对象。
- en: Trackables (AR Foundation)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 可追踪组件（AR 基础）
- en: 'Trackables and trackable managers: [https://docs.unity3d.com/Packages/com.unity.xr.arfoundation%405.1/manual/architecture/managers.xhtml#trackables-and-trackable-managers](https://docs.unity3d.com/Packages/com.unity.xr.arfoundation%405.1/manual/architecture/managers.xhtml#trackables-and-trackable-managers)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 可追踪组件和可追踪管理器：[https://docs.unity3d.com/Packages/com.unity.xr.arfoundation%405.1/manual/architecture/managers.xhtml#trackables-and-trackable-managers](https://docs.unity3d.com/Packages/com.unity.xr.arfoundation%405.1/manual/architecture/managers.xhtml#trackables-and-trackable-managers)
- en: 'Let’s start by adding the following toggle code to the `SceneController` class
    for plane visibility:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向 `SceneController` 类添加以下切换代码开始，用于控制飞机可见性：
- en: '[PRE11]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `foreach` loop in the `SetPlaneVisible()` method is responsible for implementing
    the fade on the planes found while iterating the trackable collection based on
    finding a `FadePlaneMaterial` component. If found, we simply call that plane’s
    `FadePlane()` method. The `FadePlaneMaterial` component provides us with the MR
    template’s `AR Plane` Prefab. Easy-peasy.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetPlaneVisible()` 方法中的 `foreach` 循环负责在迭代可追踪集合时根据找到的 `FadePlaneMaterial` 组件实现飞机的淡入。如果找到，我们只需调用该飞机的
    `FadePlane()` 方法。`FadePlaneMaterial` 组件为我们提供了 MR 模板的 `AR Plane` 预制件。简单易懂。'
- en: 'Let’s hook it up now to the controller button press – which will be the right
    controller’s secondary button (**B**):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将其连接到控制器按钮按下操作——这将是对应右侧控制器的次要按钮（**B**）：
- en: Add another `OnButtonPress` component to the `GameManager` object (just below
    the previous `OnButtonPress` component).
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `GameManager` 对象添加另一个 `OnButtonPress` 组件（位于之前的 `OnButtonPress` 组件下方）。
- en: Click the **+** dropdown, then **Add binding**.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **+** 下拉菜单，然后 **添加绑定**。
- en: Double-click **<****No Binding>**.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 **<****No Binding>**。
- en: In the **Path** dropdown, select **XR Controller** | **XR Controller (Right
    Hand)** | **Optional Controls** | **secondaryButton**.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **路径** 下拉菜单中，选择 **XR Controller** | **XR Controller (Right Hand)** | **Optional
    Controls** | **secondaryButton**。
- en: Alternatively, enter the following text (click the `<XRController>{RightHand}/secondaryButton.`
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，输入以下文本（点击 `<XRController>{RightHand}/secondaryButton.`）
- en: Lastly, assign the `OnPress()` `UnityEvent` function to `SceneController.` `TogglePlaneVisibility`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 `OnPress()` `UnityEvent` 函数分配给 `SceneController` 的 `TogglePlaneVisibility`。
- en: Doing a *build and run* to your device now, you can toggle the AR plane visibility
    by pressing the **B** button on your right controller. Toggling the plane visibility
    will mostly serve the purpose of debugging; in case objects spawn in unexpected
    ways, you can verify the plane detected in the physical space (any that do might
    indicate you need to revisit your Quest headset’s **Room** **Setup** configuration).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行 *构建和运行* 到你的设备上，你可以通过按下右侧控制器上的 **B** 按钮来切换 AR 飞机可见性。切换飞机可见性将主要用于调试；如果对象以意外的方式生成，你可以验证物理空间中检测到的飞机（任何检测到的都可能表明你需要重新检查
    Quest 头盔的 **Room** **Setup** 配置）。
- en: Mixed Reality template script fix!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 混合现实模板脚本修复！
- en: At the time of writing, the **/Assets/MRTemplateAssets/Scripts/FadePlaneMaterial.cs**
    script has an error with the **FadePlane()** method that must be corrected for
    the planes to fade in and out correctly after first being called in its **Awake()**
    method.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，**/Assets/MRTemplateAssets/Scripts/FadePlaneMaterial.cs** 脚本中存在一个与 **FadePlane()**
    方法的错误，必须纠正，以便在第一次在 **Awake()** 方法中调用后，飞机能够正确地淡入淡出。
- en: 'On *line 91*, within the **FadeAlpha()** method, replace the **k_DotViewRadius**
    variable with **k_Alpha**. The line should now read: **rend.material.SetFloat(k_Alpha,
    alphaValue);**.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 *91* 行，在 **FadeAlpha()** 方法内，将 **k_DotViewRadius** 变量替换为 **k_Alpha**。现在该行应读作：**rend.material.SetFloat(k_Alpha,
    alphaValue);**。
- en: Note that we’ll turn off the plane visibility when we start the game. Speaking
    of… let’s wire up starting the game now.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在开始游戏时将关闭飞机的可见性。说到……现在让我们连接开始游戏的功能。
- en: Starting the game
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始游戏
- en: Offering players a choice to start a game via a button or menu selection creates
    a sense of control and anticipation. In contrast, for MR and even VR, an automatic
    game start can be disorienting or, worse, jarring. Well, that is, unless you want
    to be hostile and throw players directly into unforgiving action without warning
    (ahem, *Dark Souls*, I see you).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 提供玩家通过按钮或菜单选择开始游戏的选择，可以创造一种控制和期待感。相比之下，对于MR甚至VR，自动开始游戏可能会让人感到迷失方向，或者更糟，令人震惊。嗯，除非你想要敌对，并且没有警告就将玩家直接投入无法原谅的行动中（嗯哼，*黑暗灵魂*，我看到你了）。
- en: 'As mentioned, we won’t be so cruel and will provide a button press for the
    player to enter the MR environment to start the game. With that in mind, we need
    to make some additions to the `GameManager` class. Let’s add the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们不会如此残忍，将为玩家提供一个按钮按下以进入MR环境开始游戏。考虑到这一点，我们需要对`GameManager`类做一些补充。让我们添加以下代码：
- en: '[PRE12]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we’re just getting a reference to the `SceneController` sibling component.
    Go ahead and add a `[RequireComponent]` attribute for the `SceneController` component,
    too.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是获取`SceneController`兄弟组件的引用。请继续添加一个`[RequireComponent]`属性给`SceneController`组件。
- en: 'Here’s the `StartGame()` method we’ll call from the button press:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将从按钮按下时调用的`StartGame()`方法：
- en: '[PRE13]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first thing we’ll do with the `EnablePlaneManager()` call is to enable the
    plane manager to spawn the virtual objects that make up our boss room game. We’ll
    then use a coroutine to delay calling the local `DelayStartGame()` function by
    1.5 seconds, setting planes invisible and the passthrough visible – this will
    ensure we see the virtual objects unobstructed in our real-world space.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`EnablePlaneManager()`调用首先启用平面管理器来生成构成我们Boss房间游戏的虚拟对象。然后，我们将使用协程延迟调用本地`DelayStartGame()`函数1.5秒，设置飞机不可见，穿透可见——这将确保我们在真实世界空间中看到虚拟对象时不受阻碍。
- en: Remove the IEnumerator Start() method
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 移除`IEnumerator Start()`方法
- en: Don’t forget, we’ll have to remove the **Start()** method we started with to
    set up the object spawning in the earlier *Spawning using planes with AR Plane
    Manager* section. We’re now going to wait until the player presses the button
    to start the game to enable spawning the virtual objects.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，我们将在之前“使用AR Plane Manager的平面生成”部分中设置的**Start()**方法移除。我们现在将等待玩家按下按钮开始游戏，以启用虚拟对象的生成。
- en: 'Okay, let’s finish things up by adding the **X** button press to start the
    game by following these steps again – but simplified this time (you got this):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们通过以下步骤再次完成事情，但这次简化一下——你做到了：
- en: Add another `OnButtonPress` component to the `GameManager` object.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将另一个`OnButtonPress`组件添加到`GameManager`对象中。
- en: Assign input action binding for the XR left-hand controller’s primary button
    (`<XRController>{LeftHand}/primaryButton`.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为XR左手控制器的主要按钮分配输入动作绑定（`<XRController>{LeftHand}/primaryButton`）。
- en: Assign the `OnPress()` function to `GameManager.StartGame`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`OnPress()`函数分配给`GameManager.StartGame`。
- en: This time, when you *build and run*, you’ll see yourself in the empty virtual
    environment until you press the **X** button to start the game and enter the boss
    room battle!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当你*构建并运行*时，你将看到自己在空旷的虚拟环境中，直到你按下**X**按钮开始游戏并进入Boss房间战斗！
- en: In this section, we learned how to work with the generated AR planes to spawn
    objects in our rooms about their transform position and rotation. We also learned
    how to access the AR systems and pre-made components (provided by the MR template)
    to toggle the visual state of passthrough and AR planes.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用生成的AR平面在我们的房间中生成对象，以及它们的变换位置和旋转。我们还学习了如何访问AR系统和使用预制的组件（由MR模板提供）来切换穿透和AR平面的视觉状态。
- en: We have the boss room environment taken care of now, and we have the game starting,
    but there’s still nothing for us to do or interact with. We’ll solve that problem
    now by adding XRI interactable objects to the room.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理好了Boss房间环境，并且游戏已经开始，但还没有我们能够做或与之交互的东西。我们将通过添加XRI交互对象来解决这个问题的现在。
- en: Placing interactable objects in the world
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在世界中放置交互对象
- en: In MR game design, interactive objects are essential to bridging the virtual
    and real worlds. Interactable objects are designed to respond to user input, even
    as basic as hand (or controller) movements that allow natural and intuitive interactions
    like pushing, grabbing, throwing, or even complex multi-hand manipulation (for
    example, rotating and scaling the object). They really help to sell the reality
    of the environment, and as a result, they significantly enhance the player’s engagement
    and overall gameplay experience.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MR 游戏设计中，交互对象对于连接虚拟世界和现实世界至关重要。交互对象被设计为响应用户输入，即使是基本的手（或控制器）移动，这也允许自然直观的交互，如推动、抓取、投掷，甚至复杂的双手操作（例如，旋转和缩放对象）。它们确实有助于营造环境的现实感，因此，它们显著增强了玩家的参与度和整体游戏体验。
- en: For our game’s purposes, we’ll have examples of a simple grab and placement
    interaction and, with the gun, a secondary interactable event action for shooting.
    Note that while many MR games and experiences are built for use with hands (hand
    tracking), our boss room example game will use controllers.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们游戏的目的，我们将有简单的抓取和放置交互的示例，以及使用枪的次要交互事件动作进行射击。请注意，尽管许多 MR 游戏 和体验是为使用双手（手部追踪）而构建的，但我们的老板房间示例游戏将使用控制器。
- en: Let’s start by configuring the modules for grabbing – these will then be configured
    to be inserted into the slots on the control console (refer to the GDD in the
    *Designing a boss* *room* section).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先配置抓取模块 – 这些模块随后将被配置以插入到控制台上的插槽中（参考 *设计一个房间* 部分的 GDD）。
- en: Making objects XR interactables
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将对象制作成 XR 交互对象
- en: The first grabbable object we’ll work with is the crystal module. The player
    must be able to grab the module and insert it into the control console, so we’ll
    open up the provided `Module` Prefab asset in Prefab Mode (double-click on it
    in the `XR Grab Interactable` component to the root.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先处理的第一个可抓取对象是水晶模块。玩家必须能够抓取模块并将其插入控制台，因此我们将打开提供的 `模块` 预制资产在预制模式中（在 `XR 捕捉交互`
    组件中双击它到根目录。
- en: As seen in the following screenshot, grabbable objects should have a transform
    positioned and appropriately rotated for grabbing the item with the correct orientation
    for proper usage – here, we see both the `Module` and the `Gun` assets with their
    `Attach` object positioned and rotated for a good grab.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，可抓取对象应有一个定位和适当旋转的变换，以便以正确的方向抓取物品，以便正确使用 – 这里，我们看到 `模块` 和 `枪` 资产都定位和旋转得很好，以便于良好的抓取。
- en: '![Figure 14.11 – Configuring the XR grab attach transforms](img/B18347_14_11.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.11 – 配置 XR 捕捉附着变换](img/B18347_14_11.jpg)'
- en: Figure 14.11 – Configuring the XR grab attach transforms
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.11 – 配置 XR 捕捉附着变换
- en: Note from the screenshot that the forward direction (Z-axis, blue arrow) of
    the `Attach` transform is pointing away from the player holding the object. Some
    experimentation may be done to attain the desired grab position.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 从截图注意，`附着` 变换的前向方向（Z 轴，蓝色箭头）是指向持有物体的玩家远离的方向。可能需要进行一些实验以达到所需的抓取位置。
- en: Now, we just need to assign the `Attach` object to the `XR Grab Interactable`
    **Attach Transform** field to ensure it gets properly attached to the player’s
    controller. You can find the **Attach Transform** field hidden within the many
    options the interactable component provides.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将 `附着` 对象分配给 `XR 捕捉交互` **附着变换** 字段，以确保它被正确地附着到玩家的控制器上。您可以在交互组件提供的许多选项中找到隐藏的
    **附着变换** 字段。
- en: '![Figure 14.12 – XR Grab Interactable Attach Transform assignment](img/B18347_14_12.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.12 – XR 捕捉交互可附着变换分配](img/B18347_14_12.jpg)'
- en: Figure 14.12 – XR Grab Interactable Attach Transform assignment
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.12 – XR 捕捉交互可附着变换分配
- en: Additional reading | Affordance system
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读更多 | 便利性系统
- en: The XRI affordance system gives visual color and audio feedback cues when interacting
    with objects, especially when haptics are unavailable while using hands, using
    an **XR Interactable Affordance State Provider** component with the interactable
    source. Samples are provided in the XRI example project.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: XRI 便利性系统在与物体交互时提供视觉颜色和音频反馈提示，尤其是在使用双手时触觉不可用的情况下，使用带有交互源的可交互便利性状态提供器组件。示例在 XRI
    示例项目中提供。
- en: 'Affordance system: [https://docs.unity3d.com/Packages/com.unity.xr.interaction.toolkit%402.5/manual/affordance-system.xhtml](https://docs.unity3d.com/Packages/com.unity.xr.interaction.toolkit%402.5/manual/affordance-system.xhtml)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 便利性系统：[https://docs.unity3d.com/Packages/com.unity.xr.interaction.toolkit%402.5/manual/affordance-system.xhtml](https://docs.unity3d.com/Packages/com.unity.xr.interaction.toolkit%402.5/manual/affordance-system.xhtml)
- en: Save the module and temporarily add it to your `Boss Room` scene near the `MR
    Interaction Setup` object. Enter Play Mode and test grabbing the module and moving
    it around with the controller (by using the grip button on the side of the controller,
    with your middle finger). Notice I said *enter play mode* this time, not *build
    and run*. That’s because we want to iterate changes like grab point attachment
    positions more quickly. For details, refer to the Quest Link callout in the *Creating
    the Unity* *project* section.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 保存模块并将其临时添加到您的`Boss Room`场景中，靠近`MR Interaction Setup`对象。进入播放模式并测试使用控制器（通过使用控制器侧面的握把按钮，用您的中指）抓取模块并在周围移动它。注意这次我说的是*进入播放模式*，而不是*构建和运行*。这是因为我们希望更快地迭代更改，如抓取点附件位置。有关详细信息，请参阅*创建Unity*
    *项目*部分的Quest Link提示。
- en: Completed interactable objects
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的交互对象
- en: 'All of the completed XR interactable objects are provided in the completed
    Unity project files for this chapter in the book’s GitHub repository here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/XR-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/XR-Assets).'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 所有完成后的XR交互对象都包含在本书GitHub仓库中该章节的完成Unity项目文件中：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/XR-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/XR-Assets)。
- en: That’s all there is to making an object interactable in XR. XRI makes it very
    easy to get the minimum required interactions, such as grabbing in place for games
    and experiences. We saw how to dynamically place other digital objects in the
    world; let’s do the same for the modules, but with a twist.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在XR中使一个物体可交互的全部内容就是这些。XRI使得获取游戏和体验所需的最小交互变得非常容易，例如在游戏中进行抓取。我们看到了如何在世界中动态放置其他数字对象；让我们为模块做同样的事情，但有所变化。
- en: Placing the modules in the room
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将模块放置在房间中
- en: In our boss room battle, our primary objective, besides just staying alive,
    is to collect the crystal modules to restore the functionality of the control
    console and energize the reactor to expel the evil plant entity. So, we have a
    sort of collection game here again! However, let’s add to the challenge of collecting
    and managing the modules.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Boss房间战斗中，我们的主要目标，除了保持生存之外，就是收集水晶模块以恢复控制台的功能并给反应堆供电，以驱逐邪恶的植物实体。所以，这里又有一场收集和管理模块的挑战！然而，让我们增加收集和管理模块的挑战性。
- en: Collecting objects in an MR game can be made more engaging by having these objects
    move around the room. The player will need to rely on their spatial awareness
    and timing skills, which introduces a more dynamic and novel challenge requiring
    them to explore the room. With the objects reacting to not only the player’s actions
    but the physicality of the space, it also deepens the immersion of the MR gameplay
    experience.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在MR游戏中，通过让这些物体在房间内移动，可以使收集物体变得更加有趣。玩家将需要依靠他们的空间意识和时间技巧，这引入了一个更具动态性和新颖性的挑战，要求他们探索房间。由于物体不仅对玩家的动作做出反应，还对空间的物理性做出反应，这也加深了MR游戏体验的沉浸感。
- en: If the collectible objects were to float somehow, the modules could also contribute
    to the game’s narrative or aesthetic theme. As it happens, crystal modules have
    a strange other-worldly property – gravity does not affect them, but forces do.
    ¯\_(ツ)_/¯
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收藏品能够以某种方式漂浮，模块也可以为游戏的故事或美学主题做出贡献。事实上，水晶模块具有一种奇特的异世界属性——重力不会影响它们，但力会。 ¯\_(ツ)_/¯
- en: With that context set, let’s first create the three required modules, then spawn
    them into the room when the game starts.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在设定了这样的背景之后，让我们首先创建三个所需的模块，然后在游戏开始时将它们实例化到房间中。
- en: Creating unique module variants
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建独特的模块变体
- en: The three `Module` Prefab variants we’ll create can be seen in *Figure 14**.7*,
    and each will have a unique identifier – the ID of the module will come into play
    when we configure the control console slots.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的三个`模块`预制件变体可以在*图14**.7*中看到，并且每个都将有一个唯一的标识符——模块的ID将在我们配置控制台插槽时发挥作用。
- en: 'There are multiple ways to create a Prefab variant, but this time, we’ll use
    the following steps to create each unique module:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 创建预制件变体有多种方法，但这次，我们将使用以下步骤来创建每个独特的模块：
- en: Make a Prefab variant of `Module` by right-clicking on it in the **Project**
    window and selecting **Create** | **Prefab Variant**.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**项目**窗口中右键单击`Module`并选择**创建** | **预制件变体**来创建`Module`的预制件变体。
- en: Name it `Module Variant A` (the proceeding variants will be `B` and `C`).
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`Module Variant A`（后续的变体将是`B`和`C`）。
- en: Double-click on `Module Variant A` to open it in Prefab Mode.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`Module Variant A`以在预制件模式中打开它。
- en: In the `Module` component, set it to `A` (followed by `B` and `C`). (The `Module`
    script is provided as part of the imported base assets.)
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Module`组件中，将其设置为`A`（随后是`B`和`C`）。（`Module`脚本作为导入的基本资产的一部分提供。）
- en: From the `Assets/Materials` folder, assign the `Module_A` material. You can
    easily do this by dragging the material from the **Project** window onto the model
    visible in the **Scene** view.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Assets/Materials`文件夹中分配`Module_A`材质。你可以通过将材质从**项目**窗口拖动到**场景**视图中可见的模型上轻松完成此操作。
- en: '`false` on the `Rigidbody` component.'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Rigidbody`组件上设置为`false`。
- en: Repeat these steps to create variants for modules `B` and `C`, respectively.
    Remember, any edits you make to a Prefab variant, such as modified property values
    or added/removed components, become overrides of the base Prefab, so you don’t
    want to apply these overrides, or you’ll be applying them to the base Prefab asset,
    and we don’t want that!
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 重复这些步骤为模块`B`和`C`创建变体。记住，你对预制件变体所做的任何编辑，例如修改属性值或添加/删除组件，都将成为基本预制件的覆盖，因此你不希望应用这些覆盖，否则你将应用它们到基本预制件资产，而我们不希望那样！
- en: XR interactable required component
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: XR交互所需组件
- en: Adding an **XR Grab Interactable** component to our objects will automatically
    add a **Rigidbody** component with its default values.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 将**XR抓取交互**组件添加到我们的对象中将自动添加一个具有默认值的**刚体**组件。
- en: Three unique modules, check! We can now add the necessary code to our game manager
    to spawn the modules when the game starts.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 三种独特的模块，检查！现在，我们可以添加必要的代码到我们的游戏管理器中，在游戏开始时生成模块。
- en: Spawning the modules to get things moving
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成模块以使事物开始移动
- en: There is no sense in reinventing the wheel to spawn another Prefab into the
    scene; we can rely on the work we’ve already coded (as we should generally do).
    We will, however, change the spawning up just a bit because we don’t want to instantiate
    the objects about a plane object. We want a more arbitrary position in the world,
    but still in relation to the player position.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 重新发明轮子来产生另一个预制件进入场景是没有意义的；我们可以依赖我们已经编码的工作（我们应该通常这样做）。然而，我们将稍微改变生成过程，因为我们不希望在平面对象周围实例化对象。我们希望在世界中有一个更随意的位置，但仍然与玩家位置相关。
- en: 'Open up the `GameManager` script for editing. Let’s first create the serialized
    private member variable where we can assign all the module variants in the Inspector
    that need to be spawned into the scene:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`GameManager`脚本进行编辑。让我们首先创建一个序列化的私有成员变量，我们可以将所有需要生成到场景中的模块变体分配到检查器中：
- en: '[PRE14]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we can create another method overload for the `SpawnPrefab()` method:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为`SpawnPrefab()`方法创建另一个方法重载：
- en: '[PRE15]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the method signature, we’ve made the `prefabs` parameter an array, `GameObject[]
    prefabs`, to accept any number of Prefabs to spawn, then added `forceDirection`
    and `force` parameters, which we’ll use to apply a force to the objects after
    instantiation.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法签名中，我们将`prefabs`参数改为数组，`GameObject[] prefabs`，以接受任何数量的预制件进行生成，然后添加了`forceDirection`和`force`参数，我们将使用这些参数在实例化后对对象施加力。
- en: The primary difference with this Prefab spawning method is that we’re using
    a `foreach` statement to iterate the array of Prefabs to ensure each one is instantiated.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 与这种预制件生成方法的主要区别在于，我们使用`foreach`语句迭代预制件数组，以确保每个都实例化。
- en: 'Now, we can add the call to `SpawnPrefab()` to do the module spawning. For
    simplicity’s sake, we’ll just tag it onto the console spawning. Add the following
    call to `SpawnPrefab()` in the `switch` statement’s floor plane classification
    `case` statement:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将`SpawnPrefab()`的调用添加到模块生成中。为了简单起见，我们将将其附加到控制台生成。在`switch`语句的地面平面分类`case`语句中添加以下对`SpawnPrefab()`的调用：
- en: '[PRE16]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A new vector position is passed in as the offset from the player’s position
    (world space), the `Vector3.up` is the direction force, and `0.05f` is the force
    applied to the modules when they are instantiated. Simple.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 传入一个新的向量位置作为从玩家位置（世界空间）的偏移量，`Vector3.up`是力的方向，`0.05f`是实例化模块时施加到模块上的力。很简单。
- en: 'Okay, we’ve talked about adding a force to the crystal modules so that they
    float about the room… now’s the time to implement it! Add the following lines
    to this iteration of the `SpawnPrefab()` method:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经讨论了向水晶模块添加力以使它们在房间内漂浮的话题……现在是时候实现它了！将以下行添加到`SpawnPrefab()`方法的这个迭代中：
- en: '[PRE17]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we have a force direction and amount passed as parameters to the `SpawnPrefab()`
    call that are not zero, we attempt to get the `Rigidbody` component of the instantiated
    Prefab. If the `Rigidbody` component reference is successfully retrieved, we call
    `ApplyForce()` and pass it in.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`SpawnPrefab()`调用中传递了非零的力方向和数量参数，我们尝试获取实例化预制体的`Rigidbody`组件。如果成功检索到`Rigidbody`组件引用，我们调用`ApplyForce()`并将它传递进去。
- en: 'All that remains is to add the `ApplyForce()` method as a local function to
    work its physics magic:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是将`ApplyForce()`方法作为局部函数添加，以发挥其物理魔法：
- en: '[PRE18]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The physics API methods we’re taking advantage of here are `rb.AddForce()` and
    `rb.AddTorque()` to apply forces using an `Impulse` force mode.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里利用的物理API方法是`rb.AddForce()`和`rb.AddTorque()`，使用`Impulse`力模式施加力。
- en: Additional reading | Unity documentation
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: '**Rigidbody.AddForce**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Rigidbody.AddForce.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Rigidbody.AddForce.xhtml)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rigidbody.AddForce**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Rigidbody.AddForce.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Rigidbody.AddForce.xhtml)'
- en: '**Rigidbody.AddTorque**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Rigidbody.AddTorque.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Rigidbody.AddTorque.xhtml)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rigidbody.AddTorque**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Rigidbody.AddTorque.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Rigidbody.AddTorque.xhtml)'
- en: Save the script and assign all the crystal module Prefab variants to the `GameManager`’s
    **Prefab Modules** field. Playtest and adjust the spawn position of the modules
    to your liking. Have fun chasing them down!
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本并将所有水晶模块预制体变体分配给`GameManager`的**Prefab Modules**字段。进行游戏测试并调整模块的生成位置，直到满意。享受追逐它们的乐趣！
- en: Applying impact force
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 应用冲击力
- en: The provided **Module** Prefab comes with an **ImpactApplyForce** script added
    to it that will apply an opposite force to the module when it collides with any
    other object with a collider. Combined with a very bouncy physics material assigned
    to the collider, this attempts to keep the modules moving about the room constantly.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的**模块**预制体中已添加了一个**ImpactApplyForce**脚本，当模块与任何具有碰撞器的其他对象发生碰撞时，该脚本将对模块施加相反的力。结合分配给碰撞器的非常弹性的物理材料，这试图使模块在房间内持续移动。
- en: In this section, we got the crystal modules floating about the room, adding
    the first challenge to the boss room battle mechanics. The second half of the
    challenge with the modules has to do with inserting them correctly into the slots
    of the control console. In the next section, we’ll perform the XR interactable
    configuration necessary for this interaction.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将晶模块悬浮在房间周围，为Boss房间战斗机制添加了第一个挑战。模块挑战的第二部分与将它们正确插入控制台插槽有关。在下一节中，我们将执行必要的XR交互配置。
- en: Making the module slots interactable
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使模块插槽可交互
- en: To have objects that can work together to create an intuitive system that mimics
    how things work in the real world, we use an `XR Grab Interactable` object and
    an `XR Socket Interactor` object – we have an *interactable* and an *interactor*.
    The grab interactor allows players to pick up and interact with objects, while
    the socket interactor provides the designated spots to place them. This handshake
    between the two components makes it easier for users to interact with objects
    and provides a more seamless and immersive experience in virtual or MR environments.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拥有能够协同工作以创建一个直观的系统，该系统模仿现实世界中事物的工作方式，我们使用了一个`XR Grab Interactable`对象和一个`XR
    Socket Interactor`对象——我们有一个*交互对象*和一个*交互者*。抓取交互者允许玩家拾取并与对象交互，而插座交互者提供了放置对象的位置。这两个组件之间的握手使得用户与对象交互更加容易，并在虚拟或MR环境中提供了更加流畅和沉浸式的体验。
- en: 'This means we’ll be configuring each control console slot with a socket interactor.
    Go ahead and open up the `Console` Prefab in Prefab Mode from the `Assets/Prefabs`
    folder. Add the `XR Socket Interactor` component for the `Slot A`, `Slot B`, and
    `Slot C` objects parented to the `ConsoleSlots` object. The object hierarchy can
    be seen in the following screenshot:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们将为每个控制台槽位配置一个插槽交互器。请从`Assets/Prefabs`文件夹中打开`Console` Prefab，并在预制模式中操作。为`ConsoleSlots`对象下的`Slot
    A`、`Slot B`和`Slot C`对象添加`XR Socket Interactor`组件。对象层次结构可以在以下屏幕截图中看到：
- en: '![Figure 14.13 – Console slot configuration](img/B18347_14_13.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图14.13 – 控制台槽位配置](img/B18347_14_13.jpg)'
- en: Figure 14.13 – Console slot configuration
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13 – 控制台槽位配置
- en: An *attach* transform object can also be seen in the preceding screenshot; each
    slot has an object parented to it, and named `Socket Attach`. For each socket
    interactor added to the slot objects, assign the *attach* object to the interactor’s
    **Attach Transform** field (just like we did for the grab interactables).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中还可以看到一个*附加*变换对象；每个槽位都有一个与其关联的对象，命名为`Socket Attach`。对于添加到槽位对象的每个插槽交互器，将*附加*对象分配给交互器的**附加变换**字段（就像我们对抓取交互器所做的那样）。
- en: We also want to ensure that only modules are inserted into the slots on the
    control console; we can do something about that. We can use the `Interaction Layer
    Mask` property of both `XR Grab Interactable` and `XR` `Socket Interactor`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望确保只有模块被插入到控制台上的槽位中；我们可以对此采取措施。我们可以使用`XR Grab Interactable`和`XR Socket Interactor`的`Interaction
    Layer Mask`属性。
- en: It doesn’t matter which one you start with, but it’s essential first to add
    a `Module` interaction layer. You can do that from any **Interaction Layer Mask**
    field by clicking the dropdown and selecting **Add layer…** (at the bottom), then
    going back to the component and selecting **Nothing**, then **Module** for each.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 无论从哪里开始都无关紧要，但首先添加一个`Module`交互层是至关重要的。您可以通过点击下拉菜单并选择**添加层…**（在底部），然后返回组件并选择**无**，然后为每个选择**模块**，从任何**交互层掩码**字段中完成此操作。
- en: Setting the interactive layer with the asset
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 使用资产设置交互层
- en: Alternatively, find the interactive layer asset at **Assets/XRI/Settings/Resources/InteractionLayerSettings**,
    add the **Module** layer, then return to the components and set the layer.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，找到交互层资产在**Assets/XRI/Settings/Resources/InteractionLayerSettings**，添加**模块**层，然后返回到组件并设置层。
- en: The last part of the slot configuration is that the slots are configured with
    a `ConsoleSlot` component already, similar to how we configured the module’s `Module`
    component; ensure `A`, `B`, and `C` again.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 槽位配置的最后部分是槽位已经配置了`ConsoleSlot`组件，类似于我们配置模块的`Module`组件；确保`A`、`B`和`C`再次正确配置。
- en: 'Speaking of the `ConsoleSlot` component, let’s take a closer look at the code.
    It’s more than just a slot ID – it can detect when a module is inserted or removed.
    This allows it to tell the parent console controller when the specific slot is
    interacted with, which can then respond accordingly:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到`ConsoleSlot`组件，让我们更深入地看看代码。它不仅仅是槽位ID——它还能检测模块的插入或移除。这使得它能够通知父控制台控制器何时与特定槽位交互，然后相应地做出反应：
- en: '[PRE19]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We declare our variables, then, in `Awake()`, once we have the references to
    the required components, we register the listeners for responding to the socket
    interactor `selectEntered` and `selectExited` events for handling inserting and
    removing modules, respectively.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Awake()`中声明我们的变量，一旦我们有了所需组件的引用，我们注册监听器以响应插槽交互器的`selectEntered`和`selectExited`事件，分别处理插入和移除模块。
- en: 'Here are the handler method declarations:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是处理方法声明：
- en: '[PRE20]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first thing we do is get the ID of the inserted module (remember, only modules
    can be inserted due to the interaction’s layer mask assignment). We then call
    a method of the `ConsoleController` instance for either the module being inserted,
    `InsertModule()`, or simply resetting the slots, `ResetSlots()`, when the module
    is removed.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取插入模块的ID（记住，由于交互层的掩码分配，只有模块可以插入）。然后，当模块被移除时，我们调用`ConsoleController`实例的方法，对于正在插入的模块，调用`InsertModule()`，或者简单地重置槽位，调用`ResetSlots()`。
- en: You might be considering having `ConsoleController` subscribe to a `ConsoleSlot`
    exposed event. Since there are three slots, it is more efficient to have each
    slot handle its own interactions (objects should be responsible for their own
    state) and notify the controller (by passing its ID and the module’s ID). This
    is a more simplified approach.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能正在考虑让 `ConsoleController` 订阅一个公开的 `ConsoleSlot` 事件。由于有三个插槽，让每个插槽处理自己的交互（对象应负责自己的状态）并通知控制器（通过传递其
    ID 和模块的 ID）会更有效率。这是一种更简化的方法。
- en: Bonus activity
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励活动
- en: Feel free to *flip the script* and experiment with the console controller listening
    to events on all three slots to compare the required code differences.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 随意 *翻转脚本* 并尝试使用控制台控制器监听所有三个插槽的事件，以比较所需的代码差异。
- en: You should now be able to playtest the console slot interactions by grabbing
    a crystal module and placing it in any slot. Fun!
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够通过拿起一个晶体模块并将其放入任何插槽来测试控制台插槽交互。有趣！
- en: There’s more fun to be had… let’s get that laser pistol configured to provide
    us some protection against infiltrated hover bots.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多乐趣等着我们……让我们配置那把激光手枪，为我们提供一些对抗潜入悬浮机器人的保护。
- en: Configuring the laser gun
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置激光枪
- en: The configuration for the interactable gun object is pretty much the same as
    the crystal module; we already saw how to configure an attach transform in *Figure
    14**.11*. Except now, we’ll add a secondary action for shooting when the trigger
    is pulled.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 可交互枪对象的配置基本上与晶体模块相同；我们已经在 *图 14.11* 中看到了如何配置附加变换。但现在，我们将添加一个当拉动扳机时的射击二级动作。
- en: Implementing shooting with XR Interactable Events
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 XR 交互事件实现射击
- en: We only want shooting triggered when we’re actually grabbing the gun, so we
    won’t be relying on the reusable `OnButtonPress` component this time. Instead,
    we’ll use the `XR Grab Interactable` component, specifically, `Activated`. `Activated`
    is called when the interactor selecting the interactable sends a command to activate
    the interactable – precisely what we need.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想在我们实际抓住枪时触发射击，所以这次我们不会依赖于可重用的 `OnButtonPress` 组件。相反，我们将使用 `XR Grab Interactable`
    组件，特别是 `Activated`。`Activated` 在选择交互对象的交互者发送命令以激活交互对象时被调用——这正是我们所需要的。
- en: Additional reading | Grab interactables
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | 捕捉交互对象
- en: 'Both basic and advanced examples of grab interactions are available in the
    XRI examples: [https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples/blob/main/Documentation/GrabInteractables.md](https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples/blob/main/Documentation/GrabInteractables.md).'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: XRI 示例中提供了捕捉交互的基本和高级示例：[https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples/blob/main/Documentation/GrabInteractables.md](https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples/blob/main/Documentation/GrabInteractables.md)。
- en: 'To set up the `Gun` Prefab, take the following steps:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 `Gun` 预制件，请按照以下步骤操作：
- en: Either modify the provided `Gun` Prefab directly or make a Prefab variant to
    work with.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以直接修改提供的 `Gun` 预制件，或者创建一个预制件变体以与之配合使用。
- en: Open the Prefab in **Prefab Mode**.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **预制件模式** 下打开预制件。
- en: Add an `XR Grab Interactable` component to the root.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根对象上添加 `XR Grab Interactable` 组件。
- en: Assign the `Attach` object to the `Activated`, assign the `Gun.Shoot` function.
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Attach` 对象分配给 `Activated`，分配 `Gun.Shoot` 函数。
- en: '![Figure 14.14 – XR Grab Interactable event Activated assignment](img/B18347_14_14.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.14 – XR 捕捉交互事件激活分配](img/B18347_14_14.jpg)'
- en: Figure 14.14 – XR Grab Interactable event Activated assignment
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.14 – XR 捕捉交互事件激活分配
- en: 'For the `Rigidbody` component, use the following property values (the gun will
    stay floating in the air right where the player releases their grip; Kryk’zylx
    military tech is truly advanced!):'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `Rigidbody` 组件，使用以下属性值（枪将在玩家松开握把的空中漂浮；Kryk’zylx 军事技术确实先进！）：
- en: '`false`'
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`'
- en: '`true`'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true`'
- en: And that’s all that’s required to configure the `Gun` Prefab to make it an interactable
    object that players can pick up and shoot. Pew-pew!
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 只需进行这些配置，就可以将 `Gun` 预制件设置为可交互对象，玩家可以拿起并射击。砰砰！
- en: Gun sound FX
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 枪声音效
- en: We also have sound FX added for the shooting, courtesy of **AudioManager** and
    the **AudioPlayerSFX3D** audio-playing component. So, add the audio manager to
    the boss room scene, create an audio mixer and the required mixer groups, and
    then assign the mixer groups to the audio manager. For a refresher, visit [*Chapter
    12*](B18347_12.xhtml#_idTextAnchor232).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了射击的音效FX，由**AudioManager**和**AudioPlayerSFX3D**音频播放组件提供。因此，将音频管理器添加到Boss房间场景中，创建音频混音器和所需的混音器组，然后将混音器组分配给音频管理器。为了复习，请访问[第12章](B18347_12.xhtml#_idTextAnchor232)。
- en: All the code responsible for making the gun shoot a laser beam when the `Shoot()`
    method is called is contained entirely within the `Gun` class. It’s single-responsibility
    for its specific use case in this game, and the code is simple and straightforward,
    so I didn’t feel the need to overcomplicate the architecture here.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 所有负责在调用`Shoot()`方法时使枪发射激光束的代码都完全包含在`Gun`类中。它针对这个游戏中特定用例的单职责，代码简单直接，所以我感觉没有必要在这里过度复杂化架构。
- en: Code architecture philosophy
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 代码架构哲学
- en: “*When you have a hammer, everything looks like a nail*” is a metaphor we can
    apply to a common pitfall in software development. People may use their favorite
    approaches to solve every problem they encounter, unintentionally leading to overcomplicated
    and inefficient code. Choosing the most appropriate solution for each problem
    or situation is important, rather than relying solely on a software doctrine.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: “**当你有一把锤子时，一切看起来都像钉子**”是一个我们可以应用到软件开发中常见陷阱的隐喻。人们可能会使用他们最喜欢的方案来解决他们遇到的每一个问题，无意中导致代码过度复杂和低效。为每个问题或情况选择最合适的解决方案很重要，而不是仅仅依赖于软件教条。
- en: Sometimes, you just need to embrace simplicity. Knowing when to – or not to
    – is called experience.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你只需要拥抱简单。知道何时以及何时不这样做被称为经验。
- en: When you examine the `Gun` script, you’ll see that we’re simply using `Physics.Raycast()`
    and `LineRenderer` with the two points for drawing the line set to the firing
    point and the end of the gun’s firing range, or the point at which the ray hits
    a damageable object (filtered by use of a **layer mask**).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查`Gun`脚本时，你会看到我们只是使用`Physics.Raycast()`和`LineRenderer`，两个用于绘制线的点设置为射击点和枪的射击范围末端，或者射线击中可损坏对象的点（通过使用**层掩码**过滤）。
- en: Tip
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Unity provides a specialized **XRLineRenderer** component for producing an XR-optimized
    line render compared to the regular **LineRenderer** component. It’s also capable
    of producing very inexpensive glow effects, which is fantastic for laser beams!
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了一个专门的**XRLineRenderer**组件，用于生成与常规**LineRenderer**组件相比优化的XR线渲染。它还能够在非常低成本的发光效果，这对于激光束来说太棒了！
- en: 'XR Line Renderer: [https://github.com/Unity-Technologies/XRLineRenderer](https://github.com/Unity-Technologies/XRLineRenderer)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: XR线渲染器：[https://github.com/Unity-Technologies/XRLineRenderer](https://github.com/Unity-Technologies/XRLineRenderer)
- en: If the raycast hits a damageable object, we pass the damage amount specified
    in `_damageAmount` in a call to `TakeDamage()`. This is how we’ll work within
    our health system, from [*Chapter 8*](B18347_08.xhtml#_idTextAnchor151) (yes,
    reusable system for the win!), to cause damage to objects that have health (i.e.,
    a `HealthSystem` component added).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果射线投射击中了一个可损坏的对象，我们将在调用`TakeDamage()`时传递`_damageAmount`中指定的伤害量。这是我们如何在我们的健康系统中工作的方式，从[第8章](B18347_08.xhtml#_idTextAnchor151)（是的，可重用系统是胜利的关键！），到对具有健康（即添加了`HealthSystem`组件）的对象造成伤害。
- en: Now that we have a functional self-defense weapon, let’s get it into the player’s
    hands.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个功能性的自卫武器，让我们把它放到玩家的手中。
- en: Spawning the gun position
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成枪的位置
- en: Alright, this will be a piece of cake! We’re already pros at spawning virtual
    objects into the room. We’ll reuse most of what we already have in place for spawning
    objects because we’ll spawn the gun near the player, on their right-hand side
    (sorry, left-handers).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这将会是一件小菜一碟！我们已经擅长将虚拟对象生成到房间中。我们将重用大部分已经用于生成对象的部分，因为我们将在玩家附近生成枪，在他们右手边（抱歉，左撇子们）。
- en: 'First things first, open up the `GameManager` script and add a declaration
    for a serialized private variable, `_prefabGun`, to hold the reference to the
    `Gun` Prefab:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开`GameManager`脚本，并添加一个序列化私有变量的声明，`_prefabGun`，以保存对`Gun` Prefab的引用：
- en: '[PRE21]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We’re already using the `Console` Prefab spawning section to spawn other objects,
    so let’s tag the gun instantiation onto it:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用`Console` Prefab的生成部分来生成其他对象，所以让我们将枪的实例化添加到它上面：
- en: '[PRE22]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice this time, when we call `SpawnPrefab()`, we have another new method signature.
    This is very much like the method overload we used to spawn the modules, except
    we’re going to spawn a single Prefab and won’t apply any physics force in a specified
    direction to it.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次，当我们调用`SpawnPrefab()`时，我们有一个另一个新的方法签名。这非常类似于我们用来生成模块的方法重载，除了我们将生成单个Prefab，并且不会在指定方向上对其应用任何物理力。
- en: 'In this version, let’s create a new method overload for spawning a single Prefab.
    This method will simply pass values to our previous `SpawnPrefab()` method, which
    requires an array of Prefabs. So, we just need to add the single Prefab to a *single
    item* *array* first:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，让我们为生成单个Prefab创建一个新的方法重载。这个方法将简单地传递值到我们之前的`SpawnPrefab()`方法，该方法需要一个Prefab数组。因此，我们首先需要将单个Prefab添加到一个*单个项目*
    *数组*中：
- en: '[PRE23]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice we preset the parameter values for `forceDirection` and `force` to zeros
    to ensure no physics forces will be applied to the spawned object.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们预设了`forceDirection`和`force`参数值为零，以确保不会对生成的对象应用任何物理力。
- en: Save the script, assign `Gun` to the `GameManager`’s **Prefab Gun** field, save
    the scene, and playtest with all the elements in place for the start of our game.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，将`Gun`分配给`GameManager`的**Prefab Gun**字段，保存场景，并使用所有元素进行游戏测试，以开始我们的游戏。
- en: In this section, we learned how to create interactable Prefab variants for the
    player and collect and place modules into slots on the control console, enhancing
    player engagement within the environment. We also learned how to implement shooting
    for the gun as a secondary activate action for objects held by the player. Now,
    with the added ability to shoot, let’s see how we bring everything together with
    the gameplay mechanics.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何为玩家创建可交互的Prefab变体，并将模块收集并放置到控制台上的插槽中，从而增强玩家在环境中的参与度。我们还学习了如何实现枪械的射击作为玩家持有的对象的次要激活动作。现在，随着射击能力的加入，让我们看看我们如何将所有这些元素与游戏玩法机制结合起来。
- en: Implementing the boss room mechanics
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Boss房间机制
- en: In our climactic boss room battle, the player will collect the crystal module
    puzzle pieces while defending against virtual enemies – the patrolling hover bots
    the evil plant entity has so rudely infected. With the unique blend of a physical
    space for exploration and interactive gameplay with digital objects the MR technology
    provides, our players will be challenged to think strategically while physically
    exerting themselves. This innovative and novel approach to boss room mechanics
    pushes the boundaries of traditional video game design, and I’m very excited to
    see this technology continue to mature and break more boundaries!
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们高潮的Boss房间战斗中，玩家将在防御虚拟敌人——被邪恶植物实体如此粗鲁感染的巡逻悬浮机器人——的同时收集晶体模块谜题碎片。凭借MR技术提供的物理空间探索和与数字对象的交互式游戏玩法，我们的玩家将面临战略思考的挑战，同时进行身体上的努力。这种创新且新颖的Boss房间机制方法推动了传统视频游戏设计的界限，我非常期待看到这项技术继续成熟并打破更多界限！
- en: This chapter is dedicated to introducing the Unity technologies that enable
    game developers and creators to rapidly produce compelling and immersive MR experiences
    for players to consume and enjoy enthusiastically. As such, the concepts for the
    boss room mechanics will be discussed in a broader sense and we’ll only dive into
    the details where additional clarification is required.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于介绍Unity技术，这些技术使游戏开发者和创作者能够快速制作出令人兴奋且沉浸式的MR体验，供玩家热情消费和享受。因此，Boss房间机制的概念将在更广泛的意义上讨论，我们只会在需要额外说明的地方深入细节。
- en: In this section, we’ll finalize the puzzle mechanic by implementing the logic
    required to solve it and energize the console. We’ll also set up the enemy bots
    to spawn and move toward the player, as well as their shooting behavior. Finally,
    we will complete the game loop by updating the game state.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过实现解决谜题所需的逻辑来最终确定谜题机制，并激活控制台。我们还将设置敌人机器人以生成并向玩家移动，以及它们的射击行为。最后，我们将通过更新游戏状态来完成游戏循环。
- en: So, first, concerning the crystal modules, let’s work with the problem of solving
    the control console puzzle.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，关于晶体模块，让我们来处理解决控制台谜题的问题。
- en: Solving the crystal modules puzzle
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决晶体模块谜题
- en: As previously discussed, the crystal modules must be collected and placed back
    into the control console. Each console slot and module have corresponding IDs,
    but the order in which they must be placed is not apparent to us – the console
    just shows some garbled characters. Let’s have a look at the console controller
    script to set the correct combination for the modules and determine when they’ve
    been inserted successfully.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，必须收集晶体模块并将它们放回控制台。每个控制台槽位和模块都有相应的ID，但它们必须放置的顺序对我们来说并不明显——控制台只显示一些乱码。让我们看看控制台控制器脚本，以设置模块的正确组合并确定它们何时成功插入。
- en: To complete the task of restoring the console and reenergizing the reactor successfully,
    the modules must be inserted in the exact order, starting with the first one –
    you cannot just randomly place them to end up in the correct order (that’s just
    how this tech works; I don’t think you should blame me for this). This makes the
    puzzle more challenging for the player because you must fend off the enemy hover
    bots while figuring this out!
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功完成恢复控制台和重新激活反应堆的任务，模块必须按正确顺序插入，从第一个开始——你不能随意放置它们以得到正确的顺序（这正是这项技术的工作方式；我不认为你应该为此责怪我）。这使得谜题对玩家更具挑战性，因为你必须在解决这个问题的同时抵御敌人悬浮机器人！
- en: 'Inspecting the `ConsoleController` script, we first see the solution code as
    a serialized private `string` variable, `_consoleCode`, so we can inspect and
    set it in the Inspector at any time:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`ConsoleController`脚本，我们首先看到解决方案代码作为一个序列化的私有`string`变量`_consoleCode`，因此我们可以在检查器中随时检查和设置它：
- en: '[PRE24]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `InsertModule()` code will efficiently handle modules inserted in a specific
    order, provide feedback for incorrect placement, and signal success for the correct
    sequence. The module insertion and solving logic should be carried out like so:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`InsertModule()`代码将有效地处理按特定顺序插入的模块，对错误放置提供反馈，并对正确序列发出成功信号。模块插入和解决逻辑应按以下方式执行：'
- en: Using the current slot index, starting at zero, check the slot order against
    the inserted module.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用当前的槽位索引，从零开始，检查槽位顺序与插入的模块是否一致。
- en: Increment the slot index when the next correct module ID has been provided;
    otherwise, reset the slots (index set back to zero).
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提供下一个正确的模块ID时，增加槽位索引；否则，重置槽位（索引恢复为零）。
- en: Check for code completion and update UI or trigger events accordingly.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查代码完成情况并相应更新UI或触发事件。
- en: Bonus challenge
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励挑战
- en: In the **ConsoleController** class, based on the above steps, code the puzzle-solving
    logic for the correct order of modules inserted into the console with the **InsertModule(_slotID,
    _moduleID)** method yourself first.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在**ConsoleController**类中，根据上述步骤，首先使用`InsertModule(_slotID, _moduleID)**方法自己编写解决谜题的逻辑，以正确顺序将模块插入控制台。
- en: 'You can get just the completed console puzzle code in the **ConsoleController**
    script from the GitHub repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Code-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Code-Assets).'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从GitHub仓库的**ConsoleController**脚本中获取完成的控制台谜题代码：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Code-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Code-Assets)。
- en: These steps are designed to ensure that the modules are inserted in the correct
    order and that a module’s ID matches the expected ID for the current slot index.
    The console is activated if all modules are correctly inserted, while progress
    is displayed on the console screen (UI).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤旨在确保模块按正确顺序插入，并且模块的ID与当前槽位索引预期的ID相匹配。如果所有模块都正确插入，则激活控制台，进度在控制台屏幕（UI）上显示。
- en: World space UI
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 世界空间UI
- en: For the console screen (UI) mentioned above, in step 3’s *update UI*, the control
    console Prefab includes a world space **uGUI Canvas**. A world space UI is a user
    interface that appears within the game’s 3D world instead of as a screen overlay.
    It is rendered on a canvas that can be positioned, rotated, and scaled just like
    any other 3D object in the scene. Developers use them to create interactive elements
    within the game world, such as control panels, information displays, or interactive
    menus.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述控制台屏幕（UI）中提到的步骤3的*更新UI*，控制台Prefab包括一个世界空间**uGUI Canvas**。世界空间UI是一种用户界面，它出现在游戏的3D世界中，而不是作为屏幕叠加。它被渲染在一个可以定位、旋转和缩放的画布上，就像场景中的任何其他3D对象一样。开发者使用它们在游戏世界中创建交互式元素，例如控制面板、信息显示或交互式菜单。
- en: '[PRE25]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When the player has restored the console, we can notify the reactor to energize
    it via an event. And what better event implementation could we use than our very
    own global event system? Refer to [*Chapter 9*](B18347_09.xhtml#_idTextAnchor169)
    for a refresher on the event system’s setup and usage (just make sure to add the
    `EventSystem` component to the scene somewhere). But you can see how we trigger
    this event in the `ConsoleEnergized()` method here:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家恢复控制台后，我们可以通过事件通知反应堆激活它。还有什么比我们自己的全局事件系统更好的实现方式呢？请参阅[*第 9 章*](B18347_09.xhtml#_idTextAnchor169)以刷新事件系统的设置和使用（只需确保在场景中某处添加`EventSystem`组件）。但你可以看到我们如何在`ConsoleEnergized()`方法中触发此事件：
- en: '[PRE26]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, in the `Reactor` script, we respond to the event by simply swapping the
    mesh renderer’s material to one with an emissive property to visually indicate
    that it has been energized (this can be much more than just a simple material
    change; think of a particle system, **VFX Graph**, or a custom **Shader Graph**):'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Reactor`脚本中，我们通过简单地交换网格渲染器的材质到一个具有发射属性的材料来响应事件，以视觉上指示它已经被激活（这可以不仅仅是简单的材质变化；想想粒子系统、**VFX
    图形**或自定义的**着色器图形**）：
- en: '[PRE27]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With the problem now solved to implement the puzzle mechanics, let’s move on
    to spawning the waves of hover bot enemies… since they are supposed to get in
    our way and make solving the puzzle even more challenging!
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 现在问题已经解决，可以实施谜题机制，让我们继续到生成悬浮机器人敌人的波次……因为它们应该挡住我们的路，使解决谜题变得更加具有挑战性！
- en: Spawning enemies
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成敌人
- en: We have a challenge. Now, let’s make it even more difficult for the player!
    Spawning waves of enemies in a boss room encounter dramatically enhances the player’s
    challenge and boosts the intensity of the gameplay. The approach of spawning an
    unrelenting number of adversaries not only heightens the excitement and satisfaction
    of overcoming the challenge but also deepens the player’s engagement with the
    mechanics of the battle.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个挑战。现在，让我们让玩家更加困难！在Boss房间遭遇中生成敌人的波次大大增加了玩家的挑战性，并提升了游戏体验的强度。生成无数敌人的方法不仅提高了克服挑战的兴奋感和满足感，而且加深了玩家对战斗机制的参与度。
- en: The `Corridor` Prefab provided with the boss room starter assets includes game
    objects for the locations of the spawner and the target position at the doorway
    end of the hallway for where the hover bot will travel. So, let’s complete the
    setup by adding the `EnemySpawner` component and configuring its properties.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: Boss房间起始资产包中提供的`Corridor`预制体包括用于生成器和走廊末端门口目标位置的的游戏对象，悬浮机器人将前往那里。因此，让我们通过添加`EnemySpawner`组件并配置其属性来完成设置。
- en: '![Figure 14.15 – The enemy spawner component values](img/B18347_14_15.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.15 – 敌人生成组件值](img/B18347_14_15.jpg)'
- en: Figure 14.15 – The enemy spawner component values
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.15 – 敌人生成组件值
- en: Note on the starter assets provided
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 关于提供的起始资产的说明
- en: The assets included in the provided starter assets package already imported
    have been created using the techniques in previous chapters. You will find that
    the design patterns, code architecture, and all the components used will be familiar.
    Therefore, we won’t be covering everything again. However, I recommend taking
    some time to examine the components used for configuring these Prefabs, especially
    **Enemy Hover Bot A Shooting 1**, since it offers the most significant example.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的起始资产包中包含的已导入的资产已经使用前几章中的技术创建。你会发现设计模式、代码架构以及所有使用的组件都将很熟悉。因此，我们不会再次涵盖所有内容。然而，我建议花些时间检查用于配置这些预制体的组件，特别是**敌人悬浮机器人
    A 射击 1**，因为它提供了最显著的例子。
- en: 'You may very well already be able to handle adding the spawner component and
    configuring it. If so, congrats! Still, for reference, here are the steps we can
    follow to configure it now:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经能够处理添加生成器组件并配置它。如果是这样，恭喜！不过，仅供参考，以下是我们可以遵循的配置步骤：
- en: Open the `Corridor` Prefab in the `Assets/Prefabs` folder in Prefab Mode.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在预制模式中，打开`Assets/Prefabs`文件夹中的`Corridor`预制体。
- en: Add the `EnemySpawner` script to the `SpawnerLocation` child object. We add
    the script here because we’ll use the object’s transform forward as the direction
    of travel for the spawned hover bot.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`EnemySpawner`脚本添加到`SpawnerLocation`子对象中。我们在这里添加脚本是因为我们将使用对象的变换前向作为生成悬浮机器人的移动方向。
- en: 'Assign the component’s field values:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配组件的字段值：
- en: '`2` (starting value – this is the time between checking if the currently instantiated
    bot has been destroyed).'
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`（起始值 – 这是检查当前实例化的机器人是否被销毁的时间间隔）。'
- en: '`(2, 6)` (the time between instantiating the bot and sending it on its way
    down the corridor).'
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(2, 6)`（从实例化机器人到将其送入走廊的时间段）。'
- en: Exit Prefab Mode and save the changes.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出预制件模式并保存更改。
- en: Now, when we do the *build and run* drill, we’ll have enemy hover bots repeatedly
    spawning when destroyed, moving toward us in their menacing fashion, and when
    they get within range, they’ll start shooting (using our pooled shooting setup,
    of course).
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们进行*构建和运行*练习时，我们将看到敌人悬浮机器人被摧毁后会反复生成，以威胁的方式向我们移动，当它们进入射程时，它们将开始射击（当然使用我们的池化射击设置）。
- en: We’ll have to ensure a few things are configured still because importing assets
    from `'.unitypackage'` is not the same as having a starting Unity project. Things
    such as **Layers** and **Tags**, **AI Navigation** settings, and **Build Settings**
    are not brought in with the imported assets.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须确保一些配置仍然正确，因为从`'.unitypackage'`导入资产并不等同于拥有一个起始Unity项目。例如，**层**和**标签**、**AI导航**设置和**构建设置**并不会随着导入的资产一起导入。
- en: Ensure the following layers are added to the project (`Projectile`, `Damageable`
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 确保以下层被添加到项目中（`投射物`，`可伤害的`）。
- en: 'Now, within the `Assets/Prefabs` folder, make the following Prefab objects’
    assignments:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`Assets/Prefabs`文件夹中，对以下预制件对象进行以下分配：
- en: '`PlasmaBall` Prefab: Select it and, in the Inspector, using the `Projectile`.'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`等离子球`预制件：选择它，在检查器中，使用`投射物`。'
- en: Also, use **Layer Collision Matrix** at the bottom of the **Edit** | **Project
    Settings…** | **Physics** settings page to disable collisions between **Placeable
    Surface** and **Projectile** – we don’t want the two to have a physics interaction.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`编辑` | `项目设置…` | `物理`设置页面的底部使用**层碰撞矩阵**来禁用**可放置表面**和**投射物**之间的碰撞——我们不希望两者之间有物理交互。
- en: '`Gun` Prefab: Select it and, in the Inspector, for the `Gun` component, set
    `Damageable`.'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`枪械`预制件：选择它，在检查器中，对于`枪械`组件，设置`可伤害的`。'
- en: '`Enemy Hover Bot A Shooting 1`: Select it and, in the Inspector, set `Damageable`.
    You can probably recognize how this layer assignment correlates to the damage
    mask assignment for the preceding gun.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`敌人悬浮机器人A射击1`：选择它，在检查器中，设置`可伤害的`。你可能会认出这种层分配与前面枪械的伤害掩码分配的相关性。'
- en: Complete code
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码
- en: 'For reference, the complete code and project setup for this section can be
    found in the Unity project files provided for this chapter in the book’s GitHub
    repository here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Unity-Project](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Unity-Project).'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 为了参考，本节完整的代码和项目设置可以在本书GitHub仓库中提供的Unity项目文件中找到：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Unity-Project](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch14/Unity-Project)。
- en: This time, playing the game will have the proper interactions between the interactable
    objects and the virtual room surfaces where the gun damages and destroys the hover
    bots, and the bot’s projectile weaponry, the plasma ball, approaches the player
    – you – fully. All that’s left to do is complete the game loop for win-and-lose
    conditions… making it an actual game challenge.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，玩游戏将会有交互对象和虚拟房间表面之间的适当交互，枪械会损坏并摧毁悬浮机器人，而机器人的投射武器，等离子球，会完全接近玩家——你。剩下要做的就是完成胜利和失败条件的游戏循环……使其成为一个真正的游戏挑战。
- en: Completing the game loop
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成游戏循环
- en: Completing a game loop with clear conditions for winning or losing is fundamental
    in game design. Winning conditions often culminate in overcoming a final challenge
    like our boss room and reward players with an enormous sense of accomplishment
    for winning, while losing conditions such as depleting health increases the game’s
    challenge. The fragile balance between these conditions is critical to ensure
    the experience is engaging, rewarding, and fair in terms of the time players invest
    in your game.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏设计中，完成一个具有明确胜利或失败条件的游戏循环是基本的。胜利条件通常以克服最终挑战（如我们的Boss房间）结束，并为获胜的玩家带来巨大的成就感，而失败条件，如健康值耗尽，则增加了游戏的挑战性。这些条件之间脆弱的平衡对于确保体验引人入胜、有奖励且公平（就玩家在游戏中的投入时间而言）至关重要。
- en: I’m not going to make the claim that I have accomplished perfect, or even near
    perfect, game balance in the boss room battle we’ve created with the default values
    provided in this chapter. It’s simply the foundation for what’s possible when
    creating an immersive, engaging, and fun MR game experience.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会宣称我已经在创建的Boss战房间战斗中实现了完美的，甚至接近完美的游戏平衡。这仅仅是创建一个沉浸式、吸引人、有趣的MR游戏体验的基础。
- en: Let’s finish up the boss room MR game by looking at how we tie in the winning
    and losing conditions from the gameplay created, starting with losing.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看如何将创建的游戏中的胜利和失败条件结合起来来完成Boss战房间MR游戏的开发，先从失败开始。
- en: Losing the battle
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 失败战斗
- en: When it comes to playing video games, losing is just as common as winning –
    anyone who’s played a video game has experienced losing. For our MR boss room
    battle, with enemy hover bots shooting at us, the apparent game-losing scenario
    is we run out of health to continue playing. So, that’s just what we’re going
    to do.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到玩电子游戏时，失败与胜利一样常见——任何玩过电子游戏的人都有过失败的经历。对于我们的MRBoss战房间战斗，当敌方悬浮机器人向我们射击时，明显的游戏失败场景是我们健康值耗尽，无法继续游戏。所以，这就是我们要做的。
- en: 'To complete the setup in our scene to support losing by player health depletion,
    we first need to ensure we have a `Player` object in the scene – a GameObject
    tagged `Player` with the `Player` script added. Follow these steps to complete
    the player setup:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的场景中完成设置以支持玩家健康值耗尽导致的失败，我们首先需要确保场景中有一个`Player`对象——一个标记为`Player`的GameObject，并添加了`Player`脚本。按照以下步骤完成玩家设置：
- en: Add the `Player` Prefab as a child of `MR` `Interaction Setup`.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Player`预制体添加为`MR`交互设置的子对象。
- en: Ensure it’s tagged as `Player`. Add the `Player` tag for assigning it now if
    it’s not already there.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保它被标记为`Player`。如果还没有添加，现在就添加`Player`标记。
- en: Ensure the `Player` object’s layer is set to `Damageable`.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保玩家对象（`Player`）的层级设置为`Damageable`。
- en: '`Player` implements the `IHaveHealth` interface for the health system, so also
    ensure the enemy’s `PlasmaBall` Prefab’s `ProjectileDamage` component has `Damageable`
    set for **Damage Mask**.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player`实现了健康系统接口`IHaveHealth`，因此也要确保敌人的`PlasmaBall`预制体的`ProjectileDamage`组件将**Damage
    Mask**设置为`Damageable`。'
- en: 'Within the `Player` class, we have an event system event triggered when the
    player’s health has fully diminished after taking too many plasma ball hits from
    the enemy hover bots:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Player`类中，当玩家在遭受过多来自敌方悬浮机器人的等离子球打击后健康值完全耗尽时，会触发一个事件系统事件：
- en: '[PRE28]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Our `GameManager` class will listen to the event and respond by setting the
    `_isConditionMetLose` condition variable for losing and responding accordingly.
    With `true` being passed as the Boolean value for the event, we use it to set
    the condition:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`GameManager`类将监听事件，并通过设置用于失败的`_isConditionMetLose`条件变量来相应地做出反应。当事件传递的布尔值为`true`时，我们使用它来设置条件：
- en: '[PRE29]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can use the individual event to update the UI, turn the passthrough off,
    or fade to black. However, the `GameManager` will respond to the condition change
    by ending the game:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用单个事件来更新UI，关闭穿透，或变为全黑。然而，`GameManager`将根据条件变化来结束游戏：
- en: '[PRE30]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: FSM refactor
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机（FSM）重构
- en: 'The best solution to keep track of our game states is, of course, a state pattern.
    We previously used a simple **finite state machine** (**FSM**) in our **EnemyController**
    class; you can also find it here. A refactor of the enum-based FSM was beyond
    the scope of what I had planned for the book, so I’ve left the refactor to you,
    but with a provided example using the **UnityHFSM** (**Unity Hierarchical Finite
    State Machine**) package available on GitHub here: [https://github.com/Inspiaaa/UnityHFSM?tab=readme-ov-file#simple-state-machine](https://github.com/Inspiaaa/UnityHFSM?tab=readme-ov-file#simple-state-machine).'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪我们的游戏状态的最佳解决方案当然是状态模式。我们之前在**EnemyController**类中使用了一个简单的**有限状态机（FSM**）；你也可以在这里找到它。基于枚举的FSM的重构超出了我为本书计划的范围，所以我将重构留给了你，但提供了一个使用GitHub上可用的**UnityHFSM（Unity分层有限状态机**）包的示例：[https://github.com/Inspiaaa/UnityHFSM?tab=readme-ov-file#simple-state-machine](https://github.com/Inspiaaa/UnityHFSM?tab=readme-ov-file#simple-state-machine)。
- en: In the project files provided by the book’s GitHub repo, inspect and evaluate
    the refactored **Assets/Scripts/Refactored/GameManager_HFSM** script for an example
    implementation compared to the enum-based **switch** statements in **GameManager**
    and implement it in your project.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在书中GitHub仓库提供的项目文件中，检查并评估重构后的**Assets/Scripts/Refactored/GameManager_HFSM**脚本，与**GameManager**中的基于枚举的**switch**语句进行比较，并在你的项目中实现它。
- en: Losing the battle is not fun, but if you don’t succeed… what’s the saying “*try,
    try again*?” I’m sure if you do, you will win. Let’s see how the win condition
    is wired; it’s really just like the lose condition – the global event system really
    makes this easy.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的战斗并不有趣，但如果你不成功……有句俗语说“*尝试，尝试再尝试*？”我相信如果你这样做，你将会赢。让我们看看胜利条件是如何连接的；它实际上就像失败条件一样——全局事件系统真的让这件事变得简单。
- en: Winning the battle
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 赢得战斗
- en: For our MR boss room battle, with enemy hover bots as the primary adversaries,
    the winning scenario is clearly defeating all waves of enemies, right? No. That’s
    not what we’ve laid the groundwork for here; as you already know, we win the game
    when we solve the puzzle of the control console slots and reenergize the reactor.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的MR老板房间战斗，以敌方悬浮机器人为主要对手，胜利的情景显然是击败所有波次的敌人，对吧？不。这里我们并没有为此打下基础；正如你所知，当我们解决控制台插槽的谜题并重新激活反应堆时，我们才赢得游戏。
- en: 'Since everything is already in place for reenergizing the reactor with a global
    event system event, we’re just going to add another listener to the `OnConsoleEnergized`
    event in `GameManager` to set the win condition variable, exactly like we did
    for losing:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一切都已经就绪，可以通过全局事件系统事件重新激活反应堆，我们只需向`GameManager`中的`OnConsoleEnergized`事件添加另一个监听器来设置胜利条件变量，就像我们为失败所做的那样：
- en: '[PRE31]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: And that’s it! Setting the game state to `State.GameOver` handles the rest!
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！将游戏状态设置为`State.GameOver`处理其余部分！
- en: By carefully setting up the game states and defining a clear path to victory,
    we create a rewarding gameplay loop that challenges players to develop strategies
    to overcome the game’s challenges and ultimately achieve success in their MR boss
    room battle.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 通过精心设置游戏状态并定义清晰的胜利路径，我们创造了一个有奖的游戏循环，挑战玩家制定策略来克服游戏挑战，并在他们的MR老板房间战斗中最终取得成功。
- en: In this section, we explored a basic set of boss room mechanics for our MR game.
    We learned how to integrate and solve a puzzle mechanic that players must figure
    out under pressure and introduced how to spawn waves of enemies equipped with
    projectile weaponry. Learning about the player’s laser pistol configuration allows
    for damaging and destroying the hover bots. Then, we further understood how to
    connect the win and lose conditions in the game manager state machine to complete
    the game design, emphasizing the strategic balance between solving puzzles and
    surviving.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了MR游戏中老板房间的基本机制。我们学习了如何集成和解决玩家在压力下必须解决的谜题机制，并介绍了如何生成装备有投射武器敌人的波次。了解玩家的激光手枪配置允许对悬浮机器人造成伤害并摧毁它们。然后，我们进一步了解了如何将游戏管理器状态机中的胜利和失败条件连接起来，以完成游戏设计，强调了解决谜题和生存之间的战略平衡。
- en: Summary
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we explored the Unity MR technologies that streamline development
    and empower developers to create immersive MR experiences. We took a dive into
    the design principles of crafting a captivating boss room while setting up our
    physical space with Quest devices and configuring Unity’s MR template to suit
    our needs. Furthermore, we gained insights into leveraging AR planes and components
    to manipulate AR visual elements and spawn virtual objects dynamically within
    our environment.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Unity MR技术，这些技术简化了开发过程，并赋予开发者创建沉浸式MR体验的能力。我们深入研究了制作吸引人的老板房间的设计原则，同时使用Quest设备设置我们的物理空间，并配置Unity的MR模板以满足我们的需求。此外，我们还了解了如何利用AR平面和组件来操纵AR视觉元素，并在我们的环境中动态生成虚拟对象。
- en: Additionally, we honed our skills in creating interactive Prefab variants and
    integrating shooting mechanics to support core gameplay. By enabling players to
    collect and place modules into control console slots, we deepened the XR interactive
    potential of our game world. Bringing together all the various MR elements, we
    crafted a compelling MR gaming experience.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们磨练了创建交互式Prefab变体和集成射击机制以支持核心游戏玩法的能力。通过允许玩家收集并将模块放入控制台插槽中，我们加深了游戏世界的XR交互潜力。将所有各种MR元素结合起来，我们制作了一个引人入胜的MR游戏体验。
- en: In the next chapter, we’ll see what it means to operate a published game by
    exploring Games as a Service, including Unity DevOps and LiveOps, look at safeguarding
    the investment you make in your projects through robust source code management
    and strategies for engaging players through in-game economies, and touch on some
    essentials of platform distribution. This overview will equip you with the tools
    and knowledge to effectively manage, maintain, expand, and distribute your finished
    games.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过探索“游戏即服务”（Games as a Service）、包括Unity DevOps和LiveOps，了解运营已发布游戏的意义。我们将探讨如何通过强大的源代码管理和吸引玩家参与游戏经济的策略来保护你在项目中的投资，并简要介绍平台分发的要点。这个概述将为你提供管理和维护、扩展以及分发你完成的游戏所需的工具和知识。
