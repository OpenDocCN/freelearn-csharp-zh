- en: '*Chapter 14*: Building HTTP APIs and Real-Time Services'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exposing an HTTP API endpoint is a fairly common way of allowing client applications
    to consume your application functionalities. Building HTTP APIs makes your application
    open to any client since almost all devices that connect to a network already
    implement the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about options to create HTTP APIs for your
    solutions. You will also see how ABP makes it easy to consume your HTTP APIs from
    client applications by using ABP''s dynamic and generated client-side proxies.
    Finally, we will explain how you can use Microsoft''s **SignalR** library in ABP
    applications to implement real-time server-client communication. Here is a list
    of topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Building HTTP APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming HTTP APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SignalR with ABP Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to follow the examples in this chapter, you need to have an IDE/editor
    that supports ASP.NET Core development. We will use the ABP CLI at some points,
    so you need to install the ABP CLI, as explained in [*Chapter 2*](B17287_02_Epub_AM.xhtml#_idTextAnchor026),
    *Getting Started with ABP Framework*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the example application from the following GitHub repository:
    [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).
    It contains some of the examples given in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Building HTTP APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will begin with ASP.NET Core's standard approach for creating
    HTTP APIs. Then we will see how ABP can automatically convert standard application
    services to HTTP API endpoints. But first, let's see how we can create API-only
    solutions with ABP Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an HTTP API project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create a new application or module with ABP Framework's startup solution
    templates, it already contains HTTP APIs for all the functionality provided by
    the application. However, it is also possible to create an HTTP API endpoint without
    an application UI if you want to.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `-u none` parameter when you create a new solution using ABP
    Framework, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`ApiDemo` is our solution name here. In this way, we have a solution with an
    HTTP API endpoint but without a UI. The following figure shows the solution opened
    in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – An HTTP API solution created by the ABP CLI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.01_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.1 – An HTTP API solution created by the ABP CLI
  prefs: []
  type: TYPE_NORMAL
- en: We should first run the `ApiDemo.DbMigrator` application to create the database,
    so the HTTP API properly works. To do that, right-click the `ApiDemo.DbMigrator`
    project, click the `ApiDemo.DbMigrator` project and execute the `dotnet run` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can run the `ApiDemo.HttpApi.Host` project to start the HTTP API application.
    The HTTP API application shows Swagger UI by default, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Swagger UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.02_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.2 – Swagger UI
  prefs: []
  type: TYPE_NORMAL
- en: Swagger UI is a very useful tool to explore and test our HTTP API endpoints.
    We can use the `admin`, and the default password is `1q2w3E*`), so we can also
    test the APIs that require authorization.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can use the `/api/identity/roles` endpoint to get a list of
    roles defined in the system. This endpoint requires authorization, so log in first
    with the `/api/identity/roles` endpoint under the **Role** group, click to expand
    it, click the **Try it out** button, then the **Execute** button to call the endpoint.
    When you call it, the server returns a JSON value as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, we've learned how to create and launch an HTTP API solution with ABP Framework.
    Now, let's see how we can add new APIs using ASP.NET Core's standard controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating ASP.NET Core controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASP.NET Core''s controllers provide a convenient infrastructure to create HTTP
    APIs. The following example exposes HTTP endpoints to get the product list and
    update a product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `ProductController` class is inherited from the `ControllerBase` class.
    It is suggested to inherit your API controller classes from the `ControllerBase`
    class instead of the `Controller` class since it contains some view-related functionality
    that is unnecessary for API Controllers. Alternatively, you can inherit your API
    controller classes from the `AbpControllerBase` class, which provides some common
    ABP services as pre-injected properties for you.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the `[ApiController]` attribute on top of the controller class enables
    ASP.NET Core's default API-specific behaviors (such as automatic HTTP 400 responses
    and attribute routing requirement), so it is also suggested.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the `[Route]` attribute defines the URL of the APIs while the
    `HttpGet` and `HttpPut` attributes determine the HTTP method associated with the
    API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP is 100% compatible with ASP.NET Core''s standard structures, so you can
    refer to Microsoft''s documentation to learn all the details of creating API Controllers:
    [https://docs.microsoft.com/en-us/aspnet/core/web-api](https://docs.microsoft.com/en-us/aspnet/core/web-api).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you implement layering in your solution, you generally find yourself creating
    controller classes, which wrap your application services. For example, assume
    that you have `IProductAppService`, which already implements the product-related
    use cases, and you want to expose its methods as HTTP API endpoints. The following
    example defines a controller that redirects all requests to the underlying application
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If we didn't use ABP Framework, we'd need to write such controllers to be able
    to define the route, HTTP method, and other HTTP-related details for the endpoint.
    However, ABP Framework can automatically expose your application services as HTTP
    API endpoints, as explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Auto API Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ABP''s Auto API Controller system converts your application services to API
    controllers by convention. To enable Auto API Controllers, we should configure
    `AbpAspNetCoreMvcOptions` as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That configuration code is located in the UI or HTTP API layer of the solution
    (the `ApiDemoHttpApiHostModule` class of the `options.ConventionalControllers.Create`
    method takes an `Assembly` object, finds all the application service classes inside
    that `Assembly`, and exposes them as controllers using pre-defined conventions.
    When you create a new ABP solution from the startup template, you already have
    that configuration inside your solution, so you don't need to configure it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that we have defined an application service as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the `ProductAppService` class is defined in the `ApiDemo.Application`
    project and the `IProductAppService` interface is defined in the `ApiDemo.Application.Contracts`
    project. We can run the application without any additional configuration to see
    the new HTTP API endpoints on Swagger UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Auto API Controller on Swagger UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.03_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.3 – Auto API Controller on Swagger UI
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP Framework configured ASP.NET Core so `ProductAppService` becomes a controller.
    ABP Framework determines the HTTP method automatically by the name of the related
    C# method. For example, methods starting with the `Get` prefix are considered
    HTTP GET methods. Routes are also automatically determined by convention. You
    can refer to the ABP documentation to learn about all the conventions and customization
    options for the HTTP method and route determination: [https://docs.abp.io/en/abp/latest/API/Auto-API-Controllers](https://docs.abp.io/en/abp/latest/API/Auto-API-Controllers).'
  prefs: []
  type: TYPE_NORMAL
- en: When to Define Controllers Manually
  prefs: []
  type: TYPE_NORMAL
- en: When you use ABP Framework, you generally don't need to define the API controllers
    manually. However, you can still write the controllers in a standard way if you
    want to do so. An advantage of writing manual controllers is that you can fully
    use HTTP layer capabilities to define and shape your APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP Framework converts all the application services to API controllers in the
    configured assembly. If you want to disable it for a specific application service,
    you can use the `[RemoteService]` attribute with the `false` parameter as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: ABP Framework also enables ASP.NET Core's API explorer feature for the application
    service. In this way, your API endpoints become discoverable and are shown on
    Swagger UI. If you want to expose the HTTP endpoint but disable the API explorer,
    you can set the `IsMetadataEnabled` parameter of the `[RemoteService]` attribute
    to `false`, for example, `[RemoteService(IsMetadataEnabled = false)]`.
  prefs: []
  type: TYPE_NORMAL
- en: As we've learned in this section, ABP can automate exposing your application
    services to remote clients, while you can still use your existing skills to create
    standard ASP.NET Core controllers whenever you need them. In the next section,
    we will explore the ways you consume your HTTP APIs from client applications.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming HTTP APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consuming your HTTP APIs from your client applications typically requires a
    lot of common and repetitive logic to apply. You deal with authorization, object
    serialization, exception handling, and more in every HTTP request to the server.
    ABP Framework can completely automate that process via dynamic and generated (static)
    client-side proxies.
  prefs: []
  type: TYPE_NORMAL
- en: We've already covered the practical usage of ABP's client-side proxy system
    in the *Consuming HTTP APIs* section of [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356),
    *Working with MVC/Razor Pages*, and in the *Consuming HTTP APIs* section of [*Chapter
    13*](B17287_13_Epub_AM.xhtml#_idTextAnchor407), *Working with the Blazor WebAssembly
    UI*. So, I won't repeat it here but will bring it all together and fill in the
    missing points.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with dynamic client proxies.
  prefs: []
  type: TYPE_NORMAL
- en: Using ABP's dynamic client-side proxies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dynamic proxy system allows us to consume server-side HTTP APIs with a simple
    configuration. The *dynamic* name states that the proxy code is generated dynamically
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'ABP''s dynamic client proxy system supports two types of client applications:
    .NET and JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: Using dynamic .NET client proxies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ABP''s startup solution separates the application layer into two projects.
    The project that ends with `Application.Contracts` contains the interfaces and
    `Application` contains the implementation of these interfaces. The following figure
    shows the `IProductAppService` interface and the `ProductAppService` class inside
    the `Application.Contracts` and the `Application` projects in an example solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – The application layer, separated into two projects'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.04_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.4 – The application layer, separated into two projects
  prefs: []
  type: TYPE_NORMAL
- en: 'Separating the contracts from the implementation has an advantage: we can reuse
    the `ApiDemo.Application.Contracts` project from a .NET client application without
    making the client application reference the implementations of the application
    services.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A .NET client application can reference the `ApiDemo.Application.Contracts`
    project and configure ABP''s dynamic .NET client proxy system to be able to consume
    the HTTP APIs, just like consuming a local service. The following example shows
    that configuration, which is done in a client application (that configuration
    exists in the `ApiDemoHttpApiClientModule` class of the `ApiDemo.HttpApi.Client`
    project):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `AddHttpClientProxies` method takes an `Assembly` and creates dynamic proxies
    for all the application service interfaces in that `Assembly`. Here, we pass the
    assembly of the `ApiDemo.Application.Contracts` project by using the module class
    inside it. When you create a new ABP solution, you will see that configuration
    in the `HttpApi.Client` project. So, any .NET client application that references
    the `HttpApi.Client` project can directly consume your HTTP APIs without any configuration.
  prefs: []
  type: TYPE_NORMAL
- en: With such a simple single configuration, we can inject any application service
    interface into the `ApiDemo.Application.Contracts` project and use it as we use
    a local service. See the *Consuming HTTP APIs* section of [*Chapter 13*](B17287_13_Epub_AM.xhtml#_idTextAnchor407),
    *Working with the Blazor WebAssembly UI*, for example usage in a Blazor WebAssembly
    client application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we configure and use the dynamic .NET client proxies, ABP does all the
    heavy logic and performs an HTTP request to the server for us. Surely, ABP should
    know the server''s root URL to make the request. We can define it in the `appsettings.json`
    file of the client application as shown in the following example (there is an
    example of how to do that inside the `ApiDemo.HttpApi.Client.ConsoleTestApp` project):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can understand from this example, we can actually define multiple server
    endpoints. In this way, a client application can consume APIs from more than one
    server. The `Default` configuration one is used by default. You can add a second
    remote service configuration as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you should specify the `remoteServiceConfigurationName` parameter to the
    `AddHttpClientProxies` method to map the configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add retry logic on failure to the dynamic client proxies. Please refer
    to the documentation for more configuration options: [https://docs.abp.io/en/abp/latest/API/Dynamic-CSharp-API-Clients](https://docs.abp.io/en/abp/latest/API/Dynamic-CSharp-API-Clients).'
  prefs: []
  type: TYPE_NORMAL
- en: ABP Framework provides a special API endpoint from the server application that
    exposes the API definition to the clients. This endpoint contains the mapping
    between the application service contracts and the HTTP API endpoints of the application.
    The URL of that endpoint is `/api/abp/api-definition` on the server. Client applications
    first read that API definition endpoint to learn how to make HTTP calls to the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: As you've seen, ABP makes it extremely easy to consume HTTP APIs from .NET clients.
    In the next section, we will look at consuming HTTP APIs in a JavaScript client.
  prefs: []
  type: TYPE_NORMAL
- en: Using dynamic JavaScript client proxies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like the .NET dynamic client proxies, ABP dynamically creates proxies to consume
    your HTTP API endpoints from JavaScript applications. ABP Framework provides a
    special endpoint that returns a JavaScript file that contains proxy functions
    for all of your HTTP API endpoints. The URL of the endpoint is `/Abp/ServiceProxyScript`.
    This URL is already added to the application layout by the current theme, so you
    can directly consume the HTTP APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is a part of the service proxy script endpoint that
    contains the proxy functions for the `ProductAppService` class that we previously
    created in the *Understanding the Auto API Controllers* section of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in that example, ABP Framework has created two JavaScript functions
    for the `ProductAppService` class''s methods. For example, we can call the `getList`
    function to get a list of the products, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It's that easy! Authorization, validation, exception handling, **CSRF** (**Cross-Site
    Request Forgery**), and the other details are handled by ABP Framework. The result
    value will be the product list (array) returned by the server. You can see the
    *Using dynamic client proxies* section of [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356),
    *Working with MVC/Razor Pages*, for more examples and information about this topic.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore an alternative way to use dynamic client
    proxies.
  prefs: []
  type: TYPE_NORMAL
- en: Using ABP's static (generated) client proxies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dynamic proxy system completely automates proxy generation to consume HTTP
    endpoints from the client applications. It generates code at runtime based on
    dynamically obtained endpoint configuration.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the static client proxy system (that comes with ABP v5.0)
    doesn't require obtaining the API definitions at runtime since it generates the
    client proxy code at development time. The disadvantage of the static proxy system
    is that you need to re-generate the client proxy code whenever a server API changes.
    However, static proxies are slightly faster than dynamic proxies since the code
    generation is done at development time and no runtime information is required.
  prefs: []
  type: TYPE_NORMAL
- en: In some scenarios, such as when your client consumes HTTP APIs of multiple microservices
    behind an API gateway, the dynamic client proxy system can't directly work because
    the API gateway cannot combine and return the API definitions of all microservices
    from a single endpoint. In such cases, using static client proxies that were generated
    at development time can save us.
  prefs: []
  type: TYPE_NORMAL
- en: In any case if you want to use the static client proxies, you use the ABP CLI
    to generate the client code. The following section shows how to use the ABP CLI
    to generate static C# client proxy code.
  prefs: []
  type: TYPE_NORMAL
- en: Generating static C# client proxies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to create static proxies, the client application/project should have
    a reference to the application service interfaces defined by the server because
    the client proxies implement the same interfaces and are used just like the dynamic
    proxies. So, in practice, the client application should reference the `Application.Contracts`
    project of the target application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server application should be running when we use the ABP CLI to generate
    the proxy classes since the ABP CLI gets the API definition from the server. Once
    the server is up and running, use the `generate-proxy` command in the root folder
    of the client application/project, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`https://localhost:44367` is the server application''s URL here. The `-t` parameter
    specifies the client language, which is `csharp` for this example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the newly added project files after running the
    `generate-proxy` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Generated client proxy files'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.05_B17287.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.5 – Generated client proxy files
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the ABP CLI adds the `app-generate-proxy.json` file, which contains
    the API definition obtained from the `https://localhost:44367/api/abp/api-definition`
    endpoint for this example. ABP Framework then uses this file to get information
    about the API endpoint and make proper HTTP calls.
  prefs: []
  type: TYPE_NORMAL
- en: The `ProductClientProxy.Generated.cs` file contains the proxy class, which implements
    the `IProductAppService` interface for this example. In this way, we can inject
    the `IProductAppService` interface into any class and use it just like a local
    service. ABP performs the necessary HTTP API calls for us.
  prefs: []
  type: TYPE_NORMAL
- en: '`ProductClientProxy.cs` is a partial class to add your additional methods and
    customize the class. The `ProductClientProxy.Generated.cs` file is re-generated
    whenever you execute the `generate-proxy` command, so your changes are overwritten
    if you edit that class. However, the `ProductClientProxy.cs` file can be safely
    edited since ABP won''t touch it again. It is left for you to customize the class.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will generate JavaScript proxies to consume HTTP APIs
    from a browser application.
  prefs: []
  type: TYPE_NORMAL
- en: Generating static JavaScript client proxies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ABP CLI can generate HTTP API client proxies for JavaScript clients, just
    like .NET clients. We can specify the `-t` parameter as `js` for JavaScript code
    generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The JavaScript client proxy system works on jQuery and is compatible with ABP's
    MVC/Razor Pages UI. We've already seen the usage of JavaScript client code generation
    in the *Using static client proxies* section of [*Chapter 12*](B17287_12_Epub_AM.xhtml#_idTextAnchor356),
    *Working with MVC/Razor Pages*. Please refer to that chapter to remember its usage.
  prefs: []
  type: TYPE_NORMAL
- en: Generating static Angular client proxies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While not covered in this book, ABP has a first-class Angular UI integration
    option. The ABP CLI''s `generate-proxy` command also works natively with Angular
    UI. You can specify the `-t` parameter as `ng` to generate TypeScript proxy code
    for Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The ABP CLI creates services and DTO classes on the Angular side, so you can
    directly inject proxies and consume the HTTP APIs without dealing with low-level
    HTTP details. Please refer to the ABP documentation to learn more about Angular
    client proxies: [https://docs.abp.io/en/abp/latest/UI/Angular/Service-Proxies](https://docs.abp.io/en/abp/latest/UI/Angular/Service-Proxies).'
  prefs: []
  type: TYPE_NORMAL
- en: Generating proxies for other client types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ABP provides client proxy generation for the client types it supports out of
    the box. It is suggested to use the ABP CLI's code generation for the supported
    client types. However, you may use another type of language, framework, or library
    on the client side and may want to generate the client proxies instead of manually
    writing them. In this case, you can use another tool that supports your platform
    since the ABP startup solution is compatible with Swagger/OpenAPI specifications.
    There are many tools around that can read the Swagger/OpenAPI specification and
    generate client-side proxy code for you. For example, the NSwag tool can generate
    client proxies for many different languages.
  prefs: []
  type: TYPE_NORMAL
- en: We've learned how to consume server-side HTTP APIs from our client applications
    with ABP Framework. In the next section, we will learn how to establish a real-time
    communication channel with the server using Microsoft's SignalR library.
  prefs: []
  type: TYPE_NORMAL
- en: Using SignalR with ABP Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building REST-style HTTP APIs is good to consume server-side functionalities
    from client applications. However, it is limited – only the client application
    can call server APIs, and the server cannot normally start an operation on the
    client. WebSocket technology makes it possible to establish a two-way communication
    channel between the browser and the server to send messages to each other independently.
    So, with WebSocket, the server can notify the browser, send data, and trigger
    an action on the application.
  prefs: []
  type: TYPE_NORMAL
- en: SignalR is a library by Microsoft that runs on WebSocket technology and simplifies
    the communication between the server and the client by abstracting WebSocket details.
    You can directly call the methods defined on the client from the server and vice
    versa.
  prefs: []
  type: TYPE_NORMAL
- en: ABP Framework does not add much value to SignalR since it is already easy to
    use. However, it provides a simple integration package that automates some common
    tasks for you. In the next two sections, we will see how to install and configure
    SignalR in your solutions. Let's start with ABP's server-side SignalR integration
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ABP SignalR integration package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Volo.Abp.AspNetCore.SignalR` is the NuGet package that adds the SignalR library
    to your server-side ABP application. You can install it using the ABP CLI. Open
    a command-line terminal in the root directory of the project where you want to
    add a server-side SignalR endpoint and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The ABP CLI will install the NuGet package and add ABP module dependency for
    you. It also adds SignalR to dependency injection and configures the hub endpoint.
    So, you don't need an additional configuration after the installation. The next
    sections explain how to create SignalR hubs and do additional configuration when
    you need to.
  prefs: []
  type: TYPE_NORMAL
- en: Creating hubs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SignalR hubs are used to create a high-level pipeline to handle client-server
    communication. You should define at least one hub to use SignalR. Creating a hub
    is pretty easy; just define a new class derived from the `Hub` base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'ABP automatically registers the hub to the dependency injection system and
    configures the endpoint mapping. The URL of this example hub will be `/signalr-hubs/messaging`.
    The hub URL starts with `/signalr-hubs/` and continues with the hub class name
    converted to *kebab-case* without the `Hub` suffix. You can use the `[HubRoute]`
    attribute on top of the hub class to specify a different URL, as shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As an alternative to the `Hub` class, you can inherit your hub from the `AbpHub`
    class. The `AbpHub` class provides some common services (such as `ICurrentUser`,
    `ILogger`, and `IAuthorizationService`) pre-injected as base properties, so you
    don't need to inject them manually.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring hubs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ABP automatically maps your hubs and does the basic configuration. If you want
    to customize the hub configuration, you can do it in the `ConfigureServices` method
    of your module class, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This example configures `MessagingHub`, sets a custom route, and changes the
    `LongPolling` options.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ABP SignalR integration package doesn't add much value but simplifies
    integrating and configuring the SignalR library on the server side of our ABP
    applications. In the next section, we will see ways of connecting to a SignalR
    hub from a client application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring SignalR clients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Connecting to a SignalR hub from a client application depends on your client
    type. In this section, I will explain how to install the SignalR client library
    to an ABP application with the ASP.NET Core MVC UI. Please refer to Microsoft''s
    documentation for other client types, such as TypeScript or .NET clients: [https://docs.microsoft.com/en-us/aspnet/core/signalr](https://docs.microsoft.com/en-us/aspnet/core/signalr).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install SignalR in an ABP application with the ASP.NET Core MVC UI, first,
    add the `@abp/signalr` NPM package to your web project with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This command will install the package and update the `package.json` file in
    the web project. You should then run the ABP CLI's `install-libs` command to copy
    SignalR's JavaScript file under your project's `wwwroot/libs` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation, you can use SignalR in your pages by importing SignalR''s
    JavaScript file. You can use ABP''s `abp-script` tag helper with the pre-defined
    bundle contributor for SignalR, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Using `SignalRBrowserScriptContributor` is the suggested approach since it always
    adds the script file from the right path with the right version, so you don't
    need to change it when you upgrade the SignalR package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using SignalR with ABP Framework is no different from using it in a regular
    ASP.NET Core application. So, please refer to Microsoft''s documentation if you
    are new to SignalR: [https://docs.microsoft.com/en-us/aspnet/core/signalr](https://docs.microsoft.com/en-us/aspnet/core/signalr).
    You can also find a fully working example in ABP''s official samples: [https://docs.abp.io/en/abp/latest/Samples/Index](https://docs.abp.io/en/abp/latest/Samples/Index).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've learned different methods for server-client communication
    with ABP Framework and ASP.NET Core. ABP Framework automates that communication
    wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: We started by creating REST-style HTTP APIs with the standard ASP.NET Core controllers
    and learned how ABP can automatically create such controllers using the application
    services.
  prefs: []
  type: TYPE_NORMAL
- en: We then explored various ways of consuming the HTTP APIs from different clients.
    It becomes very simple to call server-side APIs from a client application when
    you use the dynamic or static client proxies of ABP Framework. While you can always
    go your own way, using the fully integrated client proxies is the best way to
    consume your own HTTP APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how we can install SignalR in your ABP applications using the
    pre-built integration packages. SignalR, with the WebSocket technology, makes
    it possible to establish a two-way communication channel between the server and
    the client, so the server can also send messages to the client whenever it needs
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will learn about one of the most powerful structures
    of ABP Framework: modular application development.'
  prefs: []
  type: TYPE_NORMAL
