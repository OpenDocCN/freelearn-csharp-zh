<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>3. Learning Concurrency with Parallel Loops</title>
    <link href="epub.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content">
      <div class="chapter" title="Chapter&#160;3.&#160;Learning Concurrency with Parallel Loops">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch03"></a>Chapter&#160;3.&#160;Learning Concurrency with Parallel Loops</h1>
            </div>
          </div>
        </div>
        <p>In this chapter, we will cover:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">Creating a basic parallel for loop</li>
            <li class="listitem" style="list-style-type: disc">Creating a basic parallel foreach loop</li>
            <li class="listitem" style="list-style-type: disc">Breaking a parallel loop</li>
            <li class="listitem" style="list-style-type: disc">Stopping a parallel loop</li>
            <li class="listitem" style="list-style-type: disc">Cancelling a parallel loop</li>
            <li class="listitem" style="list-style-type: disc">Handling exceptions in a parallel loop</li>
            <li class="listitem" style="list-style-type: disc">Controlling the degree of parallelism in a loop</li>
            <li class="listitem" style="list-style-type: disc">Partitioning data in a parallel loop</li>
            <li class="listitem" style="list-style-type: disc">Using Thread Local Storage</li>
          </ul>
        </div>
        <div class="section" title="Introduction">
          <div class="titlepage">
            <div>
              <div>
                <h1 class="title" id="sigil_toc_id_5"><a id="ch03lvl1sec28"></a>Introduction</h1>
              </div>
            </div>
          </div>
          <p>Most developers frequently write sequential code in the form of loops where they are doing something to each of the items in a collection of data. Loops are often an ideal place to introduce parallelism, because most of the time, the items in the collections are not related to each other, and we usually want to perform the same independent operation on all the items in a collection. However, parallelism comes with overhead. The individual loop iterations must perform enough work to justify the overhead of parallelism.</p>
          <p>The <span class="strong"><strong>.NET 4.5 Parallel Extensions</strong></span>
<a id="id176" class="indexterm"></a> includes methods that simulate both parallel <code class="literal">For</code> and parallel <code class="literal">ForEach</code> loops, and both look very much like the loop syntax you already use for sequential loops. In fact, it is quite easy to change a sequential loop into a parallel loop which can complete faster on a computer with multiple cores.</p>
          <p>In this chapter, we will be taking a look at how to use parallel <code class="literal">For</code> and parallel <code class="literal">ForEach</code> loops in your programs.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Creating a basic parallel for loop">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch03lvl1sec29"></a>Creating a basic parallel for loop</h1>
            </div>
          </div>
        </div>
        <p>In this recipe, we will take a look at<a id="id177" class="indexterm"></a> the syntax of a basic parallel <code class="literal">for</code> loop and compare its performance against a sequential <code class="literal">for</code> loop.</p>
        <p>For our comparison we will create a console application with two methods. Both methods will loop over a very large array of numbers and use the <code class="literal">Math.Sqrt()</code> method to calculate the square root of each number in the array. One of our methods will use a sequential <code class="literal">for</code> loop to process the array, the other will use a parallel <code class="literal">for</code> loop.</p>
        <p>Our program will time both operations and will display the results to the console when both loops finish.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch03lvl2sec49"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's open up <a id="id178" class="indexterm"></a>Visual Studio and create some parallel loops. The steps for creating the parallel <code class="literal">for</code> loops are as follows:</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">ParallelFor</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your program class:<div class="informalexample"><pre class="programlisting">using System;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">First, let's implement the <code class="literal">Main</code> method of the program class. We are going to create a <code class="literal">StopWatch</code> object to perform the timing, create a large array of random numbers, and then call the methods to run the loops.<div class="informalexample"><pre class="programlisting">var stopWatch = new Stopwatch();
var random = new Random();
var numberList numberArray = Enumerable.Range(1, 10000000).OrderBy(i =&gt; random.Next(1, 10000000)).ToArray();
stopWatch.Start();
SequentialLoop(numberArraynumberList.ToArray());
stopWatch.Stop();
Console.WriteLine("Time in milliseconds for sequential loop: {0}", stopWatch.ElapsedMilliseconds.ToString());

stopWatch.Reset();
stopWatch.Start();
ParallelLoop(numberArraynumberList.ToArray());
stopWatch.Stop();
Console.WriteLine("Time in milliseconds for parallel loop: {0}", stopWatch.ElapsedMilliseconds.ToString());

Console.Write("Complete. Press &lt;ENTER&gt; to exit.");
Console.ReadKey();</pre>
</div></li>
              <li class="listitem">Next let's create <a id="id179" class="indexterm"></a>our <code class="literal">SequentialLoop</code> method<a id="id180" class="indexterm"></a> which, as you might have guessed, executes a sequential <code class="literal">for</code> loop that calculates the square root of each number in the array.<div class="informalexample"><pre class="programlisting">private static void SequentialLoop(Int32[] array)
{
    for (var i = 0; i &lt; array.Length; i++)
    {
        var temp = Math.Sqrt(array[i]);
    }
}</pre>
</div></li>
              <li class="listitem">Now we just need to create our <code class="literal">ParallelLoop</code> method which uses a parallel <code class="literal">for</code> loop to calculate the square root of each number in the array.<div class="informalexample"><pre class="programlisting">private static void ParallelLoop(Int32[] array)
{
    Parallel.For(0, array.Length, i =&gt;
    {
        var temp = Math.Sqrt(array[i]);
    });
}</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_03_01.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch03lvl2sec50"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>As you can see from<a id="id181" class="indexterm"></a> the preceding results, on my quad-core machine there were some performance improvements with the parallel loop, but not as much as you might have expected. It is possible that on your machine the sequential loop might have even outperformed the parallel loop. If this is the case, it probably means that the overhead of creating the threads and performing the context switches to execute the threads on the CPU outweighed the benefits of parallelizing the loop. As the chapter continues, we will look at how we can improve the performance of our loops a bit more. For now, we are just focusing on the basics of the parallel for loop syntax.</p>
          <p>In this recipe, we used the basic overload of the static <code class="literal">For</code> method of the <code class="literal">Parallel</code> class to create our loop. At this level the syntax looks very much like that of a sequential for loop.</p>
          <div class="informalexample">
            <pre class="programlisting">Parallel.For(int fromInclusive, int toExclusive, Action&lt;int&gt; body );</pre>
          </div>
          <p>The first two parameters forms the range the loop will iterate over. Note that <code class="literal">from</code> is an inclusive parameter and <code class="literal">to</code> is exclusive. So, if our first parameter is 0 and our second parameter is 10, our loop will iterate from 0 to 9.</p>
          <p>The third parameter is a delegate of type <code class="literal">Action&lt;int&gt;</code> which always returns <code class="literal">void</code>. In this recipe, we use a Lambda expression for the delegate.</p>
          <div class="informalexample">
            <pre class="programlisting">Parallel.For(0, array.Length, i =&gt;
{
    var temp = Math.Sqrt(array[i]);
});</pre>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Creating a basic parallel foreach loop">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch03lvl1sec30"></a>Creating a basic parallel foreach loop</h1>
            </div>
          </div>
        </div>
        <p>In this recipe we will take a look at the syntax of a basic parallel foreach loop and compare its performance against that of a sequential foreach loop.</p>
        <p>For our comparison, like the previous recipe, we will create a Console Application with two methods which both loop over a very large array of numbers and use the <code class="literal">Math.Sqrt()</code> method<a id="id182" class="indexterm"></a> to calculate<a id="id183" class="indexterm"></a> the square root of each number in the array. One of our methods will use a sequential foreach loop to process the array, the other will use a parallel foreach loop.</p>
        <p>Our program will time both operations and we will display the results to the console when both loops finish.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch03lvl2sec51"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's go to Visual <a id="id184" class="indexterm"></a>Studio and see how to create parallel for loops. The steps to create parallel ForEach loops are as follows:</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">ParallelForEach</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your program class:<div class="informalexample"><pre class="programlisting">using System;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">Let's start off by putting some code in the <code class="literal">Main</code> method of the program class to create a <code class="literal">StopWatch</code> object to perform the timing, create a large array of random numbers, and then call the two methods to run the loops.<div class="informalexample"><pre class="programlisting">var stopWatch = new Stopwatch();

var random = new Random()();
var numberList = Enumerable.Range(1, 10000000).OrderBy(i =&gt; random.Next(1, 10000000));
stopWatch.Start();
SequentialLoop(numberList);
stopWatch.Stop();
Console.WriteLine("Time in milliseconds for sequential loop: {0}", stopWatch.ElapsedMilliseconds.ToString());

stopWatch.Reset();
stopWatch.Start();
ParallelForLoop(numberList);
stopWatch.Stop();
Console.WriteLine("Time in milliseconds for parallel loop: {0}", stopWatch.ElapsedMilliseconds.ToString());

Console.Write("Complete. Press &lt;ENTER&gt; to exit.");
Console.ReadKey();</pre>
</div></li>
              <li class="listitem">Next we need<a id="id185" class="indexterm"></a> to create our <code class="literal">SequentialLoop</code> method<a id="id186" class="indexterm"></a> to execute a sequential <code class="literal">foreach</code> loop that calculates the square root of each number in the array.<div class="informalexample"><pre class="programlisting">private static void SequentialLoop(IEnumerable&lt;int&gt; numberList)
{
    foreach (var currentNumber in numberList)
    {
        var temp = Math.Sqrt(currentNumber);
    }
}</pre>
</div></li>
              <li class="listitem">Now let's create our <code class="literal">ParallelLoop</code> method which uses a parallel <code class="literal">ForEach</code> loop to calculate the square root of each number in the array.<div class="informalexample"><pre class="programlisting">private static void ParallelForLoop(IEnumerable&lt;int&gt; numberList)
{
    Parallel.ForEach(numberList, currentNumber =&gt;
    {
        var temp = Math.Sqrt(currentNumber);
    });
}</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_03_02.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch03lvl2sec52"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>This time the <a id="id187" class="indexterm"></a>sequential loop outperformed the parallel loop by a bit, at least on my machine.</p>
          <p>In this recipe, we used the basic overload of the static <code class="literal">ForEach</code> method of the <code class="literal">Parallel</code> class to create our loop:</p>
          <div class="informalexample">
            <pre class="programlisting">ForEach&lt;TSource&gt;(IEnumerable&lt;TSource&gt;, Action&lt;TSource&gt;)</pre>
          </div>
          <p>Basically, this is just a source that implements <code class="literal">IEnumerable&lt;T&gt;</code> and a delegate. In our case we used a Lambda expression for the delegate.</p>
          <div class="informalexample">
            <pre class="programlisting">Parallel.ForEach(numberList, currentNumber =&gt;
{
    var temp = Math.Sqrt(currentNumber);
});</pre>
          </div>
          <p>Other than the type of loop we used and the parameter types, the code in this project is very much like that of our parallel for loop recipe.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Breaking a parallel loop">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch03lvl1sec31"></a>Breaking a parallel loop</h1>
            </div>
          </div>
        </div>
        <p>Occasionally when writing loops, <a id="id188" class="indexterm"></a>we will want to break out of the loop under certain conditions. In a sequential loop we would accomplish this breakout with a C# <code class="literal">break</code> statement. However, a break statement is only valid when enclosed within an iteration statement like a foreach loop. When we run a parallel foreach, we are not running an iteration statement. It is actually a delegate running in a method.</p>
        <p>In this recipe we will we learn how to use a TPL class called <code class="literal">ParallelLoopState</code> to break out of a parallel<a id="id189" class="indexterm"></a> ForEach loop. <code class="literal">ParallelLoopState</code> is a class that allows concurrently running loop bodies to interact with each other. It also provides us with a way to break out of a loop. When the loop breaks or completes, we will check the completion status of our loop using the <code class="literal">ParallelLoopResult</code> structure.</p>
        <p>We are going to create a Console Application to download the contents of a book and split the individual words into a list of strings. We will then loop through the list of strings looking for a specific word. When we find the word we are looking for, we will use <code class="literal">ParallelLoopState</code> to break out of the loop.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch03lvl2sec53"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now let's take a look at how to cancel a parallel loop. The steps to cancel a parallel loop are as follows:</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">BreakALoop</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your program class:<div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">First, let's add some code to the <code class="literal">Main</code> method of our program class to use a <code class="literal">WebClient</code> to download the contents of the book and split the words of the book into a string array.<div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };
 var client = new WebClient();
const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";
client.Headers.Add("user-agent", headerText);
var words = client.DownloadString(@"http://www.gutenberg.org/files/2009/2009.txt");
 var wordList = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries).ToList();</pre>
</div></li>
              <li class="listitem">Next, let's create our loop. The loop needs to process the list of strings looking for the word "immutability". When we find it, use <code class="literal">ParallelLoopState.Break</code> to break out of the loop.<div class="informalexample"><pre class="programlisting">var loopResult = Parallel.ForEach(wordList, (currentWord,  loopState) =&gt;
{
    if (currentWord.Equals("immutability"))
    {
        Console.WriteLine(currentWord);
        loopState.Break();
    }
});</pre>
</div></li>
              <li class="listitem">We will finish<a id="id190" class="indexterm"></a> adding a couple of lines to display the loop iteration we broke on, the completion status of the loop, and wait for the user to exit.<div class="informalexample"><pre class="programlisting">Console.WriteLine("Loop LowestBreak Iteration : {0}", loopResult.LowestBreakIteration.ToString());
Console.WriteLine("Loop Completed : {0}", loopResult.IsCompleted.ToString());
Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_03_03.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch03lvl2sec54"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>In this recipe, we used a different overload of <code class="literal">Parallel.ForEach</code>. This overload takes an <code class="literal">Action</code> delegate with the source and a loop state parameter.</p>
          <div class="informalexample">
            <pre class="programlisting">ForEach&lt;TSource&gt;(IEnumerable&lt;TSource&gt;, Action&lt;TSource, ParallelLoopState&gt;)</pre>
          </div>
          <p>In the body of our<a id="id191" class="indexterm"></a> loop, we used the loop state parameter to cancel the loop.</p>
          <div class="informalexample">
            <pre class="programlisting">var loopResult = Parallel.ForEach(wordList, (currentWord,  loopState) =&gt;
{
    if (currentWord.Equals("immutability"))
    {
        Console.WriteLine(currentWord);
        loopState.Break();
    }
});</pre>
          </div>
          <p>Note that we didn't instantiate the <code class="literal">ParallelLoopState</code> parameter that we passed into the loop. It was created and provided to us by the <code class="literal">Parallel</code> class. We just have to change our Lambda expression to indicate that we want to use the loop state parameter.</p>
          <p>The <code class="literal">Parallel.ForEach</code> method<a id="id192" class="indexterm"></a> returns a <code class="literal">ParallelLoopResult</code> structure (<code class="literal">var loopResult</code>). This structure has a couple of very useful properties. One of which is <code class="literal">IsCompleted</code> that gets the loop completion status. A value of true indicates that all iterations of the loop were executed and the loop didn't receive a request to end prematurely. <code class="literal">LowestBreakIteration</code> gets the index of the lowest iteration from which <code class="literal">Break</code> was called.</p>
          <p>There is an important difference between breaking from a parallel loop and a sequential loop. When breaking a sequential loop, the break statement will immediately terminate the loop. <code class="literal">ParallelLoopState.Break</code> has a different behavior. What we are actually doing is signaling that we would like the loop terminated at the system's earliest convenience. The issue is that we are not processing a single element at a time. If we call <code class="literal">ParallelLoopState.Break</code> in one of our threads, other threads are likely to still be executing. Some code will continue to run for a short time after you request to terminate the loop.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Stopping a parallel loop">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch03lvl1sec32"></a>Stopping a parallel loop</h1>
            </div>
          </div>
        </div>
        <p>When you break from a parallel loop, the application will actually continue to process any elements of the collection that were found prior to the element that was being processed when the <code class="literal">ParallelLoopState.Break</code> method was called. Sometimes this behavior is not desirable <a id="id193" class="indexterm"></a>and we want to end the loop immediately, without processing any loop iterations that are currently running.</p>
        <p>In this recipe, we will look at how to use the <code class="literal">ParallelLoopState.Stop</code> method to request that the processing of elements terminate as soon as possible without guaranteeing that any other elements will be processed. We will again be using <code class="literal">WebClient</code> to download the contents of a book, and splitting the words into a sorted list of strings. We will loop through the<a id="id194" class="indexterm"></a> list looking for the word "immutability". When we find it, we will stop the loop.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch03lvl2sec55"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's start Visual Studio and see how to stop a parallel loop. The steps to stop a parallel loop are as follows:</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">StopALoop</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your program class:<div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">First, let's add some code to the <code class="literal">Main</code> method of our program class to use a <code class="literal">WebClient</code> to download the contents of the book, and split the words of the book into a string array.<div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/','"','(',')', '\u000A' };
var client = new WebClient();
const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";
client.Headers.Add("user-agent", headerText);
var words = client.DownloadString(@"http://www.gutenberg.org/files/2009/2009.txt");
var wordList = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries).Where(word =&gt; word.Length &gt; 5).ToList();
wordList.Sort();</pre>
</div></li>
              <li class="listitem">Next, let's create our loop. The loop needs to process the list of strings looking for the word "immutability". When we find it, use <code class="literal">ParallelLoopState.Stop</code> to stop the loop.<div class="informalexample"><pre class="programlisting">var loopResult = Parallel.ForEach(wordList, (currentWord, loopState) =&gt;
{
    if (!currentWord.Equals("immutability"))
        Console.WriteLine(currentWord);
    else
    {
        loopState.Stop();
        Console.WriteLine(currentWord);
        Console.WriteLine("Loop stopped: {0}", loopState.IsStopped.ToString());
    }
});</pre>
</div></li>
              <li class="listitem">We will <a id="id195" class="indexterm"></a>finish adding a couple of lines to display the loops' completion status and wait for user's input to exit.<div class="informalexample"><pre class="programlisting">Console.WriteLine("Loop Completed : {0}", loopResult.IsCompleted.ToString());
Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_03_04.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch03lvl2sec56"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>As in the previous<a id="id196" class="indexterm"></a> recipe, we used the overload of <code class="literal">Parallel.ForEach</code> that takes an <code class="literal">Action</code> delegate with the source and a loop state parameter.</p>
          <div class="informalexample">
            <pre class="programlisting">ForEach&lt;TSource&gt;(IEnumerable&lt;TSource&gt;, Action&lt;TSource, ParallelLoopState&gt;)</pre>
          </div>
          <p>In the body of our loop, we used the loop state parameter to stop the loop. We also used the <code class="literal">ParallelLoopState.IsStopped</code> property<a id="id197" class="indexterm"></a> to display the status of our loop.</p>
          <div class="informalexample">
            <pre class="programlisting">var loopResult = Parallel.ForEach(wordList, (currentWord, loopState) =&gt;
{
    if (!currentWord.Equals("immutability"))
        Console.WriteLine(currentWord);
    else
    {
        loopState.Stop();
        Console.WriteLine(currentWord);
        Console.WriteLine("Loop stopped: {0}", loopState.IsStopped.ToString());
    }
});</pre>
          </div>
          <p>As you can see<a id="id198" class="indexterm"></a> from the preceding results, the elements of the list that were currently in process when we stopped the loop, still get written to the console. However, <code class="literal">ParallelLoopState.Stop</code> does stop the loop more quickly than <code class="literal">ParallelLoopState.Break</code> and is better to use in a situation where you are searching for an element of a condition in the collection.</p>
          <p>Both <code class="literal">ParallelLoopState.Break</code> and <code class="literal">ParallelLoopState.Stop</code> behave differently from a break statement in a sequential loop. We are asking the application to process more than one thing at a time and we can no longer count on the sequence. It is easy to parallelize loops with the TPL, but it should be approached with caution because we can no longer rely on the order of the results.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Cancelling a parallel loop">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch03lvl1sec33"></a>Cancelling a parallel loop</h1>
            </div>
          </div>
        </div>
        <p>As we've seen in<a id="id199" class="indexterm"></a> previous recipes, to create a task that can be cancelled, you pass in a cancellation token from a <code class="literal">CancellationTokenSource</code> object. If you then make a call to the <code class="literal">CancellationTokenSource.Cancel</code> method, the token signals all of the tasks that use it should terminate. The linked tasks detect this signal via the token and stop their activity in a safe manner.</p>
        <p>Parallel loops support the same cancellation token mechanism as parallel tasks. In a parallel loop, you supply the <code class="literal">CancellationToken</code> to the method in the <code class="literal">ParallelOptions</code> parameter.</p>
        <p>This recipe will download the contents of a book and split the words into a list of strings. We will then use a parallel loop to iterate through the words writing each to the console. However, we will create a separate task that sleeps for a few seconds and then calls the <code class="literal">CancellationTokenSource.Cancel</code> method<a id="id200" class="indexterm"></a> which will cancel the loop.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch03lvl2sec57"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's create a Console Application in Visual Studio so that we can see how to break a loop. The steps are as follows:</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">BreakALoop</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the <a id="id201" class="indexterm"></a>following <code class="literal">using</code> directives to the top of your program class:<div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">First, in the <code class="literal">Main</code> method of the program class, let's create a <code class="literal">CancellationTokenSource</code> and then add the <code class="literal">CancellationToken</code> to a <code class="literal">ParallelOptions</code> object.<div class="informalexample"><pre class="programlisting">var tokenSource = new CancellationTokenSource();
var options = new ParallelOptions
{
    CancellationToken = tokenSource.Token
};</pre>
</div></li>
              <li class="listitem">Next, just below the previous lines, create a simple task that sleeps for a few seconds and then calls the <code class="literal">Cancel</code> method on the <code class="literal">CancellationTokenSource</code>.<div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
    Thread.Sleep(new TimeSpan(0,0,5));
    tokenSource.Cancel();
});</pre>
</div></li>
              <li class="listitem">Now create a <code class="literal">WebClient</code> to download the text of a book, and split the words from the book into a list of strings.<div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '"', '(', ')', '\u000A' };
var client = new WebClient();
const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";
client.Headers.Add("user-agent", headerText);
 var words = client.DownloadString(@"http://www.gutenberg.org/files/2009/2009.txt");
var wordList = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries).Where(word =&gt; word.Length &gt; 5).ToList();
wordList.Sort();</pre>
</div></li>
              <li class="listitem">Finally, let's create a simple parallel <code class="literal">foreach</code> loop that writes the strings to the console. The loop should be in a try/catch and we should be catching <code class="literal">OperationCancelledException</code> and <code class="literal">AggregateException</code>.<div class="informalexample"><pre class="programlisting">try
{
    var loopResult = Parallel.ForEach(wordList, options, (currentWord, loopState) =&gt; Console.WriteLine(currentWord));
    Console.WriteLine("Loop Completed : {0}", loopResult.IsCompleted.ToString());
}
catch (OperationCanceledException)
{
    Console.WriteLine("Operation Cancelled");
}
catch (AggregateException)
{
    Console.WriteLine("Operation Cancelled");
}
Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012,<a id="id202" class="indexterm"></a> press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_03_05.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch03lvl2sec58"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>In this recipe we are using another overload of the <code class="literal">Parallel.ForEach</code> method that accepts an <code class="literal">IEnumerable</code> source, a <code class="literal">ParallelOptions</code> object, and an <code class="literal">Action</code> delegate.</p>
          <div class="informalexample">
            <pre class="programlisting">ForEach&lt;TSource&gt;(IEnumerable&lt;TSource&gt;, ParallelOptions, Action&lt;TSource&gt;)</pre>
          </div>
          <p>The difference between cancelling a task and cancelling a parallel loop is how we pass in the <code class="literal">CancellationToken</code>. With a task, a <code class="literal">CancellationToken</code> is passed directly into the constructor of the task. For a parallel loop, we set the <code class="literal">CancellationToken</code> property of a <code class="literal">ParallelOptions</code>
<a id="id203" class="indexterm"></a> object with our <code class="literal">CancellationToken</code>, and then pass the <code class="literal">ParallelOptions</code> object into the parallel loop method.</p>
          <p>If the token that signals the cancellation is the same token that is set on the <code class="literal">ParallelOptions</code> instance, then the parallel loop will throw an <code class="literal">OperationCanceledException</code> on cancellation. If a different token causes cancellation, the loop will throw an <code class="literal">AggregateException</code> with an <code class="literal">OperationCanceledException</code> as an <code class="literal">InnerException</code>. Both should be handled in your <code class="literal">catch</code> blocks.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Handling exceptions in a parallel loop">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch03lvl1sec34"></a>Handling exceptions in a parallel loop</h1>
            </div>
          </div>
        </div>
        <p>When a sequential loop throws an <a id="id204" class="indexterm"></a>exception, the normal flow of the loop is interrupted. Control will be passed to a <code class="literal">catch</code> block or, if left unhandled, <a id="id205" class="indexterm"></a>the exception is passed to the .NET runtime, and the process is aborted.</p>
        <p>Parallel <code class="literal">For</code> and <code class="literal">ForEach</code> loops are similar in that they do not have any special mechanism to handle exceptions that might be thrown. It is up to us to handle any exceptions which might be thrown on one or multiple threads by wrapping all exceptions from the loop in an <code class="literal">AggregateException</code>.</p>
        <p>In this recipe, we will create a simple parallel <code class="literal">For</code> loop that loops through a range of numbers, writing the values to the console. If the number being processed is higher than a set number, we will throw a new <code class="literal">ArgumentException</code> which we will then store in a queue and later throw as part of an <code class="literal">AggregateException</code>.</p>
        <div class="section" title="Getting ready…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch03lvl2sec59"></a>Getting ready…</h2>
              </div>
            </div>
          </div>
          <p>For this recipe we need to turn off the Visual Studio 2012 Exception Assistant. The Exception Assistant appears whenever a runtime exception is thrown, and intercepts the exception before it gets to our handler.</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">To turn off the Exception Assistant, go to the <span class="strong"><strong>Debug</strong></span> menu and select <span class="strong"><strong>Exceptions</strong></span>.</li>
              <li class="listitem">Uncheck the<a id="id206" class="indexterm"></a> <span class="strong"><strong>User-unhandled</strong></span> checkbox next to <span class="strong"><strong>Common Language Runtime Exceptions</strong></span>.<div class="mediaobject"><img src="graphics/0225OT_03_10.jpg" alt="Getting ready…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch03lvl2sec60"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's take a look at <a id="id207" class="indexterm"></a>how to handle exceptions in parallel loops. The steps are as follows:</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">LoopExceptions</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your program class:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">In the <code class="literal">Main</code> method of the program class, create a try/catch block. The <code class="literal">catch</code> block should have some code for looping through <code class="literal">AggregateException.InnerExceptions</code> and displaying the wrapped exception messages to the console.<div class="informalexample"><pre class="programlisting">try
{
    // Parallel for loop           
}
catch (AggregateException aggregate)
{
    // Loop through the exceptions and display to console
    foreach (var ex in aggregate.InnerExceptions)
    {
      Console.WriteLine("An exception was caught:  {0}",ex.InnerException.Message);
    }
}

// Wait for user input before exiting
Console.ReadLine();</pre>
</div></li>
              <li class="listitem">Inside the <a id="id208" class="indexterm"></a><code class="literal">try</code> block, define a variable of type <code class="literal">ConcurrentCollection&lt;Exception&gt;</code>. This will be the container to hold our exceptions until we are ready to wrap them in an <code class="literal">AggregateException</code>.<div class="informalexample"><pre class="programlisting">var exceptionQueue = new ConcurrentQueue&lt;Exception&gt;();</pre>
</div></li>
              <li class="listitem">Finally, <a id="id209" class="indexterm"></a>let's create a simple parallel <code class="literal">ForEach</code> loop that loops from 0 to 100. If the loop encounters a number greater than 95, it should throw an <code class="literal">ArgumentException</code>. The body of the loop needs a try/catch block to catch the argument exception to enqueue it.<div class="informalexample"><pre class="programlisting">Parallel.For(0, 100, number =&gt;
{
    try
    {
        if (number &gt; 95)
        {
          throw new ArgumentException(String.Format("The number {0} is invalid. Must be smaller than 95.",number.ToString()));
        }
        Console.WriteLine(number.ToString());
    }
    catch (Exception ex)
    {
        exceptionQueue.Enqueue(ex);  
    }
    if(exceptionQueue.Count &gt; 0)
        throw new AggregateException(exceptionQueue);
});</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_03_06.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch03lvl2sec61"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>In this recipe, the <a id="id210" class="indexterm"></a>outer <code class="literal">catch</code> block handles <code class="literal">AggregateException</code> which can wrap many individual exception objects. Any one or all the actual<a id="id211" class="indexterm"></a> threads created by calling <code class="literal">Parallel.For</code> could throw an <code class="literal">AggregateException</code>. In our <code class="literal">catch</code> block, we need to loop through <code class="literal">AggregateException.InnerExceptions</code> to process individual exceptions that occurred.</p>
          <div class="informalexample">
            <pre class="programlisting">catch (AggregateException aggregate)
{
    foreach (var ex in aggregate.InnerExceptions)
    {
      Console.WriteLine("An exception was caught: {0}",ex.InnerException.Message);
    }
}</pre>
          </div>
          <p>We have also created a try/catch block in the body of the parallel loop. This <code class="literal">catch</code> block catches any type of exception thrown in the loop and simply enqueues it in a <code class="literal">ConcurrentQueue&lt;Exception&gt;</code>. <code class="literal">ConcurrentQueue&lt;T&gt;</code> is a thread-safe first-in-first-out collection that implements <code class="literal">IEnumerable&lt;T&gt;</code>. <code class="literal">AggregateException</code> has a constructor overload that accepts <code class="literal">IEnumerable&lt;Exception&gt;</code>, so we can wrap our exception collection in <code class="literal">AggregateException</code> by passing the <code class="literal">ConcurrentCollection</code> to the constructor.</p>
          <div class="informalexample">
            <pre class="programlisting">catch (Exception ex)
{
    exceptionQueue.Enqueue(ex);  
}
if(exceptionQueue.Count &gt; 0)
    throw new AggregateException(exceptionQueue);</pre>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Controlling the degree of parallelism in a loop">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch03lvl1sec35"></a>Controlling the degree of parallelism in a loop</h1>
            </div>
          </div>
        </div>
        <p>By default, <code class="literal">Parallel.For</code> and <code class="literal">Parallel.ForEach</code> utilize as many threads as the underlying thread scheduler will provide. Usually it is good enough to let the system manage how iterations of a <a id="id212" class="indexterm"></a>parallel loop are mapped to your computer's cores. Sometimes, however, you might want more control over the maximum number of threads that are used. For example, if you know that an algorithm you are using won't <a id="id213" class="indexterm"></a>scale beyond a certain number of cores; you might want to limit the cores used in order to avoid wasting cycles.</p>
        <p>The number of tasks created by <code class="literal">Parallel.For</code> and <code class="literal">Parallel.ForEach</code> is often greater than the number of available cores. However, you can limit the maximum number of tasks used concurrently by specifying the <a id="id214" class="indexterm"></a>
<code class="literal">MaxDegreeOfParallelism</code> property of a <code class="literal">ParallelOptions</code> object.</p>
        <p>In this recipe, we are going to create a large array of integers. We will then pass this array to a couple of parallel <code class="literal">For</code> loops. One loop will run with the default degree of parallelism, and the other will be limited to four threads. We will display the time it takes to run each loop to see if there is any performance difference between the two.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch03lvl2sec62"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Let's take a look at how we can control the degree of parallelism in a parallel loop. The steps are as follows:</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">DegreeOfParallelism</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your program class:<div class="informalexample"><pre class="programlisting">using System;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">First, in the program class, let's create a method named <code class="literal">DefaultParallelism</code> that takes an array of <code class="literal">Int32</code> as a parameter. The method calls <code class="literal">Parallel.For</code> and loops through the array calculating the square root of each element.<div class="informalexample"><pre class="programlisting">private static void DefaultParallelism(Int32[] array)
{
    Parallel.For(0, array.Length, i =&gt;
    {
        var temp = Math.Sqrt(array[i]);
    });
}</pre>
</div></li>
              <li class="listitem">Next, let's create another method named <code class="literal">LimitedParallelism</code> that takes the same type of <a id="id215" class="indexterm"></a>parameter. This method will also call <code class="literal">Parallel.For</code> and loop through the array calculating the<a id="id216" class="indexterm"></a> square root of each element. The only difference is that this method will also create a <code class="literal">ParallelOptions</code> object with the <code class="literal">MaxDegreeOfParallelism</code> property set to <code class="literal">4</code>.<div class="informalexample"><pre class="programlisting">private static void LimitedParallelism(Int32[] array)
{
    var options = new ParallelOptions()
    {
        MaxDegreeOfParallelism = 4
    };

    Parallel.For(0, array.Length, options, i =&gt;
    {
        var temp = Math.Sqrt(array[i]);
    });
}</pre>
</div></li>
              <li class="listitem">Finally, in the <code class="literal">Main</code> method, we need to create a large array of <code class="literal">Int32</code> and initialize the array elements to random numbers. We also need to set up a <code class="literal">StopWatch</code> object so we can capture some time and call the two methods.<div class="informalexample"><pre class="programlisting">static void Main()
{
    var stopWatch = new Stopwatch();

    var random = new Random();
    var numberList numberArray = Enumerable.Range(1, 1000000).OrderBy(i =&gt; random.Next(1, 1000000)).ToArray();

    stopWatch.Start();
    DefaultParallelism(numberListnumberArray.ToArray());
    stopWatch.Stop();
    Console.WriteLine("Time in milliseconds for default parallelism: {0}", stopWatch.ElapsedMilliseconds.ToString());

    stopWatch.Reset();
    stopWatch.Start();
    LimitedParallelism(numberList.ToArray());
    stopWatch.Stop();
    Console.WriteLine("Time in milliseconds for MaxDegreeOfParallelism: {0}", stopWatch.ElapsedMilliseconds.ToString());

    Console.Write("Complete. Press &lt;ENTER&gt; to exit.");
    Console.ReadKey();
}</pre>
</div></li>
              <li class="listitem">In Visual <a id="id217" class="indexterm"></a>Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar<a id="id218" class="indexterm"></a> to the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_03_07.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch03lvl2sec63"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>This recipe doesn't have an algorithm that benefits from controlling the degree of parallelism, but in certain long running loop bodies, the ThreadPool's heuristics will be unable to determine the right number of threads to utilize, and could end up injecting many more than is appropriate.</p>
          <p>The degree of parallelism is controlled by creating a <code class="literal">ParallelOptions</code> object and setting the <code class="literal">MaxDegreeOfParallelism</code> property<a id="id219" class="indexterm"></a>.</p>
          <div class="informalexample">
            <pre class="programlisting">var options = new ParallelOptions()
{
        MaxDegreeOfParallelism = 4
};</pre>
          </div>
          <p>Once created, the<a id="id220" class="indexterm"></a> <code class="literal">ParallelOptions</code> object can<a id="id221" class="indexterm"></a> be passed into one of the many overloads of <code class="literal">Parallel.For</code> or <code class="literal">Parallel.ForEach</code> that accept <code class="literal">ParallelOptions</code>.</p>
          <div class="informalexample">
            <pre class="programlisting">Parallel.For(0, array.Length, options, i =&gt;
{
    var temp = Math.Sqrt(array[i]);
});</pre>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Partitioning data in a parallel loop">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch03lvl1sec36"></a>Partitioning data in a parallel loop</h1>
            </div>
          </div>
        </div>
        <p>When creating a <code class="literal">Parallel.For</code> or <code class="literal">Parallel.ForEach</code> loops, we are effectively queuing up a delegate of work that will eventually be run on a ThreadPool worker thread. The amount of<a id="id222" class="indexterm"></a> time taken to create and swap out these delegate payloads can have a very adverse effect on performance, especially when we create loops with small delegate bodies.</p>
        <p>There is a default <code class="literal">Partitioner&lt;T&gt;</code> class that uses a default partitioning algorithm that takes into account the number of cores on your system and other factors, but default portioning may or may not yield the best results.</p>
        <p>The .NET 4.5 Parallel Extensions also allows us to create our own custom partitioning chunks so that the workload of a <code class="literal">Parallel.For</code> or <code class="literal">Parallel.ForEach</code> is broken up into of a size that we specify in our code. We are effectively creating a custom partitioning algorithm.</p>
        <p>In this recipe we are going to create three parallel loops that each iterate over a large array of integers. One of the loops will use no data partitioning, one will use the default partitioner, and one will use a custom partition. We will capture the time it takes each loop to iterate over the array and display the results.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch03lvl2sec64"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Now, let's see how we can partition data for a parallel loop. The steps are as follows:</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">PartitionData</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your program class:<div class="informalexample"><pre class="programlisting">using System;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">First, in the program class, let's create a method called <code class="literal">NoPartitioning</code> that takes an array <a id="id223" class="indexterm"></a>of integers as a parameter. As the name indicates, this method will use no partitioning and will just iterate over the elements in the array calculating the square root of each element.<div class="informalexample"><pre class="programlisting">private static void NoPartitioning(Int32[] numbers)
{
    Parallel.ForEach(numbers, currentNumber =&gt;
    {
       var temp = Math.Sqrt(currentNumber);
    });
}</pre>
</div></li>
              <li class="listitem">Next, we need to create a method called <code class="literal">DefaultPartition</code>. Like the other method, this one will take an array of integers as its parameter and will iterate over the array calculating the square root of each element in the array. This method will use the <code class="literal">Partitioner.Create</code> method<a id="id224" class="indexterm"></a> to create a partition for the data.<div class="informalexample"><pre class="programlisting">private static void DefaultPartitioning(Int32[] numbers)
{
    var partitioner = Partitioner.Create(numbers);
    Parallel.ForEach(partitioner, currentNumber =&gt;
    {
        var temp = Math.Sqrt(currentNumber);
    });
}</pre>
</div></li>
              <li class="listitem">Now let's create a method called <code class="literal">CustomPartitioning</code>. This method will use a different overload of <code class="literal">Partitioner.Create</code> which allows us to specify the range size we want to use.<div class="informalexample"><pre class="programlisting">private static void CustomPartitioning(Int32[] numbers)
{
    var partitioner = Partitioner.Create(0, numbers.Count(), 100000);
    Parallel.ForEach(partitioner, range =&gt;
    {
        for (var index = range.Item1; index &lt; range.Item2; index++)
        {
            var temp = Math.Sqrt(numbers[index]);
        }
    });
}</pre>
</div></li>
              <li class="listitem">Finally, in the <code class="literal">Main</code> method<a id="id225" class="indexterm"></a>, we need to create a large array of <code class="literal">Int32</code> and initialize the array elements<a id="id226" class="indexterm"></a> to random numbers. We also need to set up a <code class="literal">StopWatch</code> object so we can capture some time and call the three methods.<div class="informalexample"><pre class="programlisting">static void Main()
{
    var stopWatch = new Stopwatch();

    var random = new Random();
    var numberArray = Enumerable.Range(1, 10000000).OrderBy(i =&gt; random.Next(1, 10000000)).ToArray();
    stopWatch.Start();
    NoPartitioning(numberArray);
    stopWatch.Stop();
    Console.WriteLine("Time in milliseconds for no partitioning: {0}", stopWatch.ElapsedMilliseconds.ToString());

    stopWatch.Reset();
    stopWatch.Start();
    DefaultPartitioning(numberArray);
    stopWatch.Stop();
    Console.WriteLine("Time in milliseconds for default partitioning: {0}", stopWatch.ElapsedMilliseconds.ToString());

    stopWatch.Reset();
    stopWatch.Start();
    CustomPartitioning(numberArray);
    stopWatch.Stop();
    Console.WriteLine("Time in milliseconds for custom partitioning: {0}", stopWatch.ElapsedMilliseconds.ToString());

    Console.Write("Complete. Press &lt;ENTER&gt; to exit.");
    Console.ReadKey();
}</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_03_08.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch03lvl2sec65"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>As you can see from the <a id="id227" class="indexterm"></a>preceding screenshot, there was quite a performance improvement realized from using custom partitioning.</p>
          <p>In this recipe, the <a id="id228" class="indexterm"></a>
<code class="literal">NoPartitioning</code> method iterates through the array performing the <code class="literal">Math.Sqrt</code> operation on each element with no partitioning of the array at all. The body of the loop is handed to the <code class="literal">Parallel.ForEach</code> method as a delegate, and the body of a parallel loop is so small that the cost of the delegate invocation on each loop's iteration is very significant. As a result, the performance is not very good.</p>
          <p>In the <code class="literal">DefaultPartitioning</code> method<a id="id229" class="indexterm"></a>, we used one of the <code class="literal">Create</code> method overloads of the <code class="literal">Partitioner</code> class to create an <code class="literal">IEnumerable&lt;T&gt;</code> of range partitions over the source array. The benefit of doing this is that the delegate invocation cost is incurred only once per range, rather than once per element. As you can see, that resulted in a pretty nice performance improvement.</p>
          <div class="informalexample">
            <pre class="programlisting">private static void DefaultPartitioning(Int32[] numbers)
{
    var partitioner = Partitioner.Create(numbers);
    Parallel.ForEach(partitioner, currentNumber =&gt;
    {
        var temp = Math.Sqrt(currentNumber);
    });
}</pre>
          </div>
          <p>In the <code class="literal">CustomPartitioning</code> method, <a id="id230" class="indexterm"></a>we use a different overload of <code class="literal">Partitioner.Create</code> to create a custom partition that chunks a range that we specified.</p>
          <div class="informalexample">
            <pre class="programlisting">public static OrderablePartitioner&lt;Tuple&lt;int, int&gt;&gt; Create(
    int fromInclusive,
    int toExclusive,
    int rangeSize
)</pre>
          </div>
          <p>Basically we told the <a id="id231" class="indexterm"></a>partitioner to create a partition from 0 to <code class="literal">numbers.Count()</code> with a chunk size of 1,00,000. In other words, we partitioned the array into ten equal parts. The performance improvement was pretty substantial.</p>
          <p>The key lesson here is that the overhead of delegate invocation, particularly in loops with small bodies, can be very significant. Consider using either the default partitioning scheme, or a custom chunk partitioner to improve the performance of your parallel loops.</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Using Thread Local Storage">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch03lvl1sec37"></a>Using Thread Local Storage</h1>
            </div>
          </div>
        </div>
        <p>Computers are pretty good at counting. Sometimes we need to create loops that accumulate a running count of the occurrence of some piece data. How would we manage something like that when using <code class="literal">Parallel.For</code> or <code class="literal">Parallel.Foreach</code> loops? We could have any number of threads counting at the same time.</p>
        <p>What we need to accomplish<a id="id232" class="indexterm"></a> this is <span class="strong"><strong>Thread Local Storage</strong></span>. Thread Local Storage gives us the ability to store and retrieve states in each separate task that is created by a <code class="literal">Parallel.For</code> or <code class="literal">Parallel.ForEach</code> loop, and avoid the overhead of synchronizing accesses to a shared state variable.</p>
        <p>Thread Local Storage is a programming method that uses static memory local to a thread. This is sometimes needed because normally all threads in a process share the same address space. In other words, data in a static or global variable is normally always located at the same memory location, when referred to from the same process. TLS variables are on the call and are local to threads, because each thread has its own stack.</p>
        <p>In this recipe, we are going to see how we can use the thread-local variables to store the value of a word count in each thread created by <code class="literal">Parallel.ForEach</code> loop. After the loops finish, we will then write the final result only once to a shared variable.</p>
        <div class="section" title="How to do it…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch03lvl2sec66"></a>How to do it…</h2>
              </div>
            </div>
          </div>
          <p>Ok, let's take a look <a id="id233" class="indexterm"></a>at how we can use the Thread Local Storage in our parallel loops. The steps are as follows:</p>
          <div class="orderedlist">
            <ol class="orderedlist arabic">
              <li class="listitem">Start a new project using the <span class="strong"><strong>C# Console Application</strong></span> project template and assign <code class="literal">ThreadLocalStorage</code> as the <span class="strong"><strong>Solution name</strong></span>.</li>
              <li class="listitem">Add the following <code class="literal">using</code> directives to the top of your program class:<div class="informalexample"><pre class="programlisting">using System;
using System.Linq;
using System.Net;
using System.Threading;
using System.Threading.Tasks;</pre>
</div></li>
              <li class="listitem">First, let's add <a id="id234" class="indexterm"></a>some code to the <code class="literal">Main</code> method of the program<a id="id235" class="indexterm"></a> class to use <code class="literal">WebClient</code> to download the text of a book, and split the words of the book into an array of strings. Also, we will create an <code class="literal">integer</code> variable which will hold our word count.<div class="informalexample"><pre class="programlisting">char[] delimiters = { ' ', ',', '.', ';', ':', '-', '_', '/', '\u000A' };
var client = new WebClient();
const string headerText = "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)";
client.Headers.Add("user-agent", headerText);
var words = client.DownloadString(@"http://www.gutenberg.org/files/2009/2009.txt");
var wordList = words.Split(delimiters, StringSplitOptions.RemoveEmptyEntries).ToList();

//word count total
Int32 total = 0;</pre>
</div></li>
              <li class="listitem">Next, let's create a parallel <code class="literal">ForEach</code> loop<a id="id236" class="indexterm"></a> that takes an array of <code class="literal">String</code>, has an <code class="literal">Int32</code> thread-local variable, and passes its <code class="literal">Int32</code> result to an <code class="literal">Interlocked.Add</code> method.<a id="id237" class="indexterm"></a><div class="informalexample"><pre class="programlisting">Parallel.ForEach&lt;String, Int32&gt;(wordList, () =&gt; 0, 
    (word, loopstate, count) =&gt;  // method invoked on each iteration of loop
    {
        if (word.Equals("species"))
        {
            count++; // increment the count
        }
        return count;
    },(result)=&gt;Interlocked.Add(ref total, result));
 // executed when all loops have completed</pre>
</div></li>
              <li class="listitem">Let's finish up by displaying the result and waiting for user input.<div class="informalexample"><pre class="programlisting">Console.WriteLine("The word species occured {0} times.",total.ToString());
Console.ReadLine();</pre>
</div></li>
              <li class="listitem">In Visual Studio 2012, press <span class="emphasis"><em>F5</em></span> to run the project. You should see output similar to the following screenshot:<div class="mediaobject"><img src="graphics/0225OT_03_09.jpg" alt="How to do it…"/></div></li>
            </ol>
          </div>
        </div>
        <div class="section" title="How it works…">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title sigil_not_in_toc"><a id="ch03lvl2sec67"></a>How it works…</h2>
              </div>
            </div>
          </div>
          <p>Using a thread-local<a id="id238" class="indexterm"></a> variable in a parallel <code class="literal">ForEach</code> loop means that we have to use the <code class="literal">Parallel.ForEach</code> method overload that takes two type parameters and two function parameters. Our first parameter is the type of the elements in our source (<code class="literal">String</code>). The second parameter specifies the type of our thread-local variable (<code class="literal">Int32</code>). The third parameter is a <code class="literal">Func&lt;TSource, ParallelLoopState, TLocal, TLocal&gt;</code> delegate that is invoked on each loop iteration. The fourth parameter is an <code class="literal">Action&lt;T&gt;</code> delegate that the method will invoke when all loops are finished.</p>
          <div class="informalexample">
            <pre class="programlisting">ForEach&lt;TSource, TLocal&gt;(IEnumerable&lt;TSource&gt;, Func&lt;TLocal&gt;, Func&lt;TSource, ParallelLoopState, TLocal, TLocal&gt;, Action&lt;TLocal&gt;)</pre>
          </div>
          <p>In the body of our loop, the loop passes our input parameters to our function delegate. The parameters are the current element, a <a id="id239" class="indexterm"></a>
<code class="literal">ParallelLoopState</code> variable and the thread local variable.</p>
          <div class="informalexample">
            <pre class="programlisting">(word, loopstate, count) =&gt;  // method invoked on each iteration of loop
{
if (word.Equals("species"))
{
   count++; // increment the count
}
return count;
}</pre>
          </div>
          <p>After the loop completes, we return our thread-local variable and it gets passed to the <code class="literal">Action&lt;T&gt;</code> delegate where <a id="id240" class="indexterm"></a>we add it to our shared state variable using <code class="literal">Interlocked.Add()</code>:</p>
          <div class="informalexample">
            <pre class="programlisting">(result)=&gt;Interlocked.Add(ref total, result));</pre>
          </div>
        </div>
      </div>
    </div>
</body>
</html>