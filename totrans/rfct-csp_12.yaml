- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Code Analysis in Visual Studio
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio 中的代码分析
- en: Thus far, we’ve covered how to refactor our code in a safe, effective, reliable,
    and productive manner.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了如何以安全、有效、可靠和高效的方式重构我们的代码。
- en: 'In this chapter, we’ll determine areas of code that might need refactoring
    using code metrics and code analysis tools. Along the way, we’ll cover the following
    topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用代码度量工具和代码分析工具确定可能需要重构的代码区域。在这个过程中，我们将涵盖以下主题：
- en: Calculating code metrics in Visual Studio
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中计算代码度量
- en: Performing code analysis in Visual Studio
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中执行代码分析
- en: Exploring advanced code analysis tools
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索高级代码分析工具
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The starting code for this chapter is available from GitHub at [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    in the `Chapter12/Ch12BeginningCode` folder.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起始代码可在 GitHub 上找到，地址为 [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)，位于
    `Chapter12/Ch12BeginningCode` 文件夹中。
- en: Calculating code metrics in Visual Studio
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中计算代码度量
- en: Every codebase I’ve ever worked with has had a few maintainability hot spots.
    These are areas that are frequently changed, have a higher degree of complexity
    than other areas of code, and represent serious quality risks to the software
    project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经工作过的每个代码库都有一两个可维护性热点。这些区域经常更改，比代码的其他区域具有更高的复杂度，并且对软件项目代表严重的质量风险。
- en: These areas are usually some of the most critical to refactor and they tend
    to be easily discoverable using **code metrics**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些区域通常是重构中最关键的，并且它们通常很容易通过**代码度量**发现。
- en: Code metrics calculate a handful of useful statistics about every file, class,
    method, and property in your C# code. This lets you spot hot spots in your code
    that have significantly higher complexity or lower maintainability. Code metrics
    can even help you find classes that are too large and likely violate the Single
    Responsibility Principle (SRP) as we discussed in [*Chapter 8*](B21324_08.xhtml#_idTextAnchor173).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 代码度量计算了关于您 C# 代码中每个文件、类、方法和属性的几个有用的统计数据。这使您能够发现代码中的热点，这些热点的复杂度显著高于其他部分，或者可维护性较低。代码度量甚至可以帮助您找到太大且可能违反我们讨论过的单一职责原则（SRP）的类[*第
    8 章*](B21324_08.xhtml#_idTextAnchor173)。
- en: 'To calculate code metrics, open your solution in Visual Studio and then click
    the **Analyze** menu, followed by **Calculate Code Metrics**, and then **For Solution**,
    as shown in *Figure 12**.1*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算代码度量，请在 Visual Studio 中打开您的解决方案，然后点击**分析**菜单，接着点击**计算代码度量**，然后点击**针对解决方案**，如图
    *图 12*.1* 所示：
- en: '![Figure 12.1 – Calculating code metrics](img/B21324_12_1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – 计算代码度量](img/B21324_12_1.jpg)'
- en: Figure 12.1 – Calculating code metrics
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 计算代码度量
- en: 'This will open the **Code Metrics Results** pane, as shown in *Figure 12**.2*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开**代码度量结果**面板，如图 *图 12*.2* 所示：
- en: '![Figure 12.2 – Code Metrics Results](img/B21324_12_2.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 代码度量结果](img/B21324_12_2.jpg)'
- en: Figure 12.2 – Code Metrics Results
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 代码度量结果
- en: 'This pane displays a hierarchical view of your solution, along with the following
    six metrics:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此面板显示了解决方案的层次结构视图，以及以下六个度量：
- en: '**Lines of Source Code**: The number of lines of code for the class or method.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码行数**：类或方法的代码行数。'
- en: '**Lines of Executable Code**: The lines of source code that ignore blank lines
    and comments.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可执行代码行数**：忽略空白行和注释的源代码行数。'
- en: '`if` statement, loop, switch case, and similar type of branching instruction
    increases this by 1.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` 语句、循环、switch 语句和类似类型的分支指令会使此值增加 1。'
- en: '**Maintainability Index**: A calculated value based on cyclomatic complexity,
    lines of code, and the number of operations performed in a method. This value
    ranges from 0 to 100, indicating how maintainable your code is. Values from 0
    to 9 are bad, 10 to 20 are warning areas, and 21 and above are areas to watch.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性指数**：基于循环复杂度、代码行数和方法中执行的操作数计算得出的值。此值范围从 0 到 100，表示您的代码的可维护性。0 到 9 的值是坏的，10
    到 20 是警告区域，21 及以上是值得关注区域。'
- en: '`System.Object`, which all classes ultimately inherit from.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Object`，所有类最终都从中继承。'
- en: '**Class Coupling**: The number of other classes your code depends on.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类耦合**：您的代码所依赖的其他类的数量。'
- en: Each of these metrics is useful individually, but together, they tell a broader
    picture.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些度量中的每一个都是单独有用的，但结合起来，它们描绘了一个更全面的图景。
- en: The maintainability index gives you a quick metric for an area of code. Unlike
    other columns, which sum up values for all code in a class, namespace, or project,
    the maintainability index acts as an average, which can help you quickly drill
    into problem areas.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 维护性指数为你提供了一个代码区域的快速指标。与其他列不同，这些列汇总了类、命名空间或项目中的所有代码的值，而维护性指数则作为一个平均值，可以帮助你快速钻入问题区域。
- en: 'Cyclomatic complexity can identify areas that are hard to test or hard to understand
    since it identifies the number of distinct paths through a method. *Figure 12**.3*
    illustrates a cyclomatic complexity of the `CalculatePrice` method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 圈复杂度可以识别出难以测试或难以理解的地方，因为它确定了通过方法的不同路径数。*图12*.*3*展示了`CalculatePrice`方法的圈复杂度：
- en: '![Figure 12.3 – Calculating cyclomatic complexity](img/B21324_12_3.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 计算圈复杂度](img/B21324_12_3.jpg)'
- en: Figure 12.3 – Calculating cyclomatic complexity
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 计算圈复杂度
- en: Here, the `CalculatePrice` method has a cyclomatic complexity of 4\. All methods
    start with a cyclomatic complexity of 1, representing a single path through the
    method. Each branching statement, such as the `if` statements here, increments
    the cyclomatic complexity by 1, resulting in a total of 4.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`CalculatePrice`方法的圈复杂度为4。所有方法都以1的圈复杂度开始，代表方法中的单一路径。每个分支语句，如这里的`if`语句，都会将圈复杂度增加1，从而总共达到4。
- en: I find cyclomatic complexity to be generally useful and try to keep this as
    low as possible. Keep in mind that cyclomatic complexity is biased against methods
    that use `switch` statements since each `case` statement adds to the complexity.
    Simple `switch` statements with only a line or two of code are generally not hard
    to maintain, so treat cyclomatic complexity as only one indicator of code quality.
    Microsoft recommends a maximum cyclomatic complexity of 10 for each method, but
    in my experience, I tend to be happiest with a cyclomatic complexity of 7 or less.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现圈复杂度通常很有用，并试图将其保持在尽可能低。请记住，圈复杂度对使用`switch`语句的方法有偏见，因为每个`case`语句都会增加复杂性。只有一行或两行代码的简单`switch`语句通常不难维护，所以将圈复杂度视为代码质量的一个指标。微软建议每个方法的最大圈复杂度为10，但根据我的经验，我通常对7或更低的圈复杂度感到最满意。
- en: Depth of inheritance and class coupling can help you identify places where you
    may be over-using inheritance or have too high of coupling to other classes, as
    we covered in [*Chapter 8*](B21324_08.xhtml#_idTextAnchor173). Microsoft encourages
    a maximum depth of inheritance of 6 and a maximum class coupling of 9.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 继承深度和类耦合可以帮助你识别出你可能过度使用继承或与其他类耦合度过高的地方，正如我们在[*第8章*](B21324_08.xhtml#_idTextAnchor173)中讨论的那样。微软鼓励最大继承深度为6，最大类耦合度为9。
- en: The lines of code metrics are quite useful. I find that having many lines of
    code in a class is frequently one of the greatest signs that a class violates
    the SRP and needs to be refactored. Similarly, if a method is too large, it’s
    usually hard to understand, maintain, and test.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 代码行数指标非常有用。我发现，一个类中有很多行代码通常是它违反单一职责原则（SRP）并需要重构的最明显迹象之一。同样，如果一个方法太大，通常很难理解、维护和测试。
- en: I try to keep classes under 200 lines of code and methods to 20 lines or less.
    In both cases, I look for things I can pull out of the method or class and am
    hesitant to expand an already large class or method with new logic unless I can
    pull logic out of the code first.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我试图将类的代码行数控制在200行以下，方法控制在20行或更少。在这两种情况下，我都会寻找可以从中提取到方法或类中的内容，并且除非我能够先从代码中提取逻辑，否则我会犹豫是否要使用新逻辑扩展已经很大的类或方法。
- en: Keep in mind that these are general guidelines I’ve found generally effective.
    These are not concrete rules that you must always follow.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些都是我发现通常有效的通用指南。这些不是你必须始终遵循的具体规则。
- en: 'I encourage you to spend some time looking over code metrics for the sample
    code for this chapter or some code you maintain. In the case of the code for this
    chapter, I’m most concerned about the following methods:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你花些时间查看本章示例代码或你维护的代码的代码指标。就本章的代码而言，我最关心以下方法：
- en: '`BaggageCalculator.CalculatePrice` in the `Flight.Baggage` namespace has a
    maintainability index of 58, cyclomatic complexity of 4, and 26 lines of source
    code'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flight.Baggage`命名空间中的`BaggageCalculator.CalculatePrice`具有58的维护性指数、4的圈复杂度和26行源代码'
- en: '`FlightScheduler.Search`, which takes in a `FlightSearch` object in the `Flight.Scheduling`
    namespace, has a maintainability index of 48, a cyclomatic complexity of 9, a
    class coupling of 11, and 37 lines of source code'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlightScheduler.Search`，该函数接收`Flight.Scheduling`命名空间中的`FlightSearch`对象，其可维护性指数为48，循环复杂度为9，类耦合度为11，源代码行数为37'
- en: Both methods are flagged by the metrics because they have several `if` statements
    that they need to run. Neither method is very complex, but at the same time, if
    either needs to grow significantly more, I’d like to see refactorings like the
    ones we applied in [*Chapter 5*](B21324_05.xhtml#_idTextAnchor101) to move complexity
    out of these methods and into other objects.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都因具有多个`if`语句而被指标标记，但它们本身并不复杂。但如果其中任何一个需要显著增长，我希望看到像我们在[*第5章*](B21324_05.xhtml#_idTextAnchor101)中应用的那种重构，将复杂性从这些方法移至其他对象。
- en: Now that we’ve covered code metrics, let’s see how code analysis can give us
    another way of looking at our code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了代码指标，让我们看看代码分析如何为我们提供另一种看待代码的方式。
- en: Performing code analysis in Visual Studio
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Visual Studio中执行代码分析
- en: Microsoft knows that as C# and .NET changes, it can be very difficult to keep
    up with evolving standards in a broad and changing language.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 微软知道，随着C#和.NET的变化，跟上这种广泛且不断变化的语言的演变标准可能非常困难。
- en: To address this, Microsoft gave us tools beyond code metrics in the form of
    analyzers that inspect our C# code for issues. These analyzers look at our code
    and flag potential issues and optimizations. This helps ensure our code complies
    with standards and is secure, reliable, and maintainable.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，微软为我们提供了代码指标之外的工具，即分析器，这些分析器会检查我们的C#代码中的问题。这些分析器检查我们的代码，标记潜在的问题和优化。这有助于确保我们的代码符合标准，并且是安全、可靠和可维护的。
- en: Analyzing your solution using the default ruleset
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用默认规则集分析您的解决方案
- en: 'To see an analyzer in action, build this chapter’s solution in Visual Studio
    and notice the three warnings that appear in the **Output** pane, as shown in
    *Figure 12**.4*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看分析器的实际效果，请在Visual Studio中构建本章的解决方案，并注意**输出**窗格中出现的三个警告，如图*图12.4*所示：
- en: '![Figure 12.4 – An overview of the build results showing warnings](img/B21324_12_4.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – 显示警告的构建结果概述](img/B21324_12_4.jpg)'
- en: Figure 12.4 – An overview of the build results showing warnings
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 显示警告的构建结果概述
- en: These three lines represent separate compiler warnings for the CS8618 code analysis
    rule, which we’ll look at shortly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这三条线代表与CS8618代码分析规则相关的单独编译器警告，我们将在稍后查看。
- en: 'Before we do that, click on the **View** menu and then select **Error List**.
    You should see the same warnings formatted in an easier-to-read manner, as shown
    in *Figure 12**.5*:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，点击**视图**菜单，然后选择**错误列表**。你应该会看到以更易读的格式格式化的相同警告，如图*图12.5*所示：
- en: '![Figure 12.5 – An overview of the compiler warnings in Error List](img/B21324_12_5.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – 错误列表中编译警告的概述](img/B21324_12_5.jpg)'
- en: Figure 12.5 – An overview of the compiler warnings in Error List
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 错误列表中编译警告的概述
- en: If these warnings don’t show up, make sure the **Errors**, **Warnings**, and
    **Messages** buttons are checked, as shown in *Figure 12**.5*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些警告没有显示，请确保**错误**、**警告**和**消息**按钮被选中，如图*图12.5*所示。
- en: 'Since these warnings are all associated with `Airport.cs`, let’s review its
    code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些警告都与`Airport.cs`相关，让我们回顾一下它的代码：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When looking at this code in Visual Studio, you’ll see a “green squiggly” underneath
    each of these three properties. As shown in *Figure 12**.6*, hovering the mouse
    cursor over any of these “squigglies” shows details about the warning or suggestion:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Visual Studio中查看此代码时，你会在这三个属性下面看到“绿色波浪线”。如图*图12.6*所示，将鼠标悬停在任何一个“波浪线”上会显示警告或建议的详细信息：
- en: '![Figure 12.6 – The CS8618 compiler warning associated with the Name property](img/B21324_12_6.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – 与Name属性相关的CS8618编译器警告](img/B21324_12_6.jpg)'
- en: Figure 12.6 – The CS8618 compiler warning associated with the Name property
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 与Name属性相关的CS8618编译器警告
- en: In this case, the warning tells us that these three properties are non-nullable,
    meaning that they are declared as `string` instead of `string?`, as we discussed
    in [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209) when discussing nullability
    analysis.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，警告告诉我们这三个属性是非可空的，这意味着它们被声明为`string`而不是`string?`，正如我们在[*第10章*](B21324_10.xhtml#_idTextAnchor209)中讨论可空性分析时提到的。
- en: Since the default value for any `string` property in .NET is null and the `Airport`
    class doesn’t have any logic to initialize these three properties, the compiler
    warning is telling us that when `Airport` instances are created, they’ll have
    null values in properties we told it couldn’t be null!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 .NET 中任何 `string` 属性的默认值都是 null，并且 `Airport` 类没有初始化这些三个属性的任何逻辑，编译器警告告诉我们，当创建
    `Airport` 实例时，它们将在我们告诉它不能为 null 的属性中具有 null 值！
- en: Nullability analysis in .NET
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 中的可空性分析
- en: Remember that although strings are reference types and can be null, nullability
    analysis in C# indicates if a property is expected to have a null value at any
    point in time. Here, the `string` type indicator means that we never expect these
    properties to have a null value. On the other hand, a `string?` type indicator
    would indicate that we might expect null values. See [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209)
    for more information on nullability analysis in C#.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，尽管字符串是引用类型并且可以是 null，但 C# 中的可空性分析表明属性是否在任何时间点预期具有 null 值。在这里，`string` 类型指示符表示我们从不期望这些属性具有
    null 值。另一方面，`string?` 类型指示符将表示我们可能期望 null 值。参见 [*第 10 章*](B21324_10.xhtml#_idTextAnchor209)
    了解有关 C# 中可空性分析的更多信息。
- en: 'There are a few ways to address this compiler warning:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此编译器警告有几种方法：
- en: Default these properties to an empty string
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些属性的默认值设置为空字符串
- en: Change these properties to `string?` instead of `string`
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些属性更改为 `string?` 而不是 `string`
- en: Add a constructor that sets these properties to non-null values
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个构造函数来设置这些属性的非 null 值
- en: Mark these properties as `required` so that they must be set on creation
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些属性标记为 `required` 以确保它们在创建时必须设置
- en: 'As shown here, the simplest fix is to mark these properties as `required`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，最简单的修复方法是将这些属性标记为 `required`：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This resolves the three code analysis warnings, leaving two less severe suggestions
    for us to investigate, both dealing with the `Equals` method of `Airport`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了三个代码分析警告，留下了两个不那么严重的建议供我们调查，这两个建议都与 `Airport` 的 `Equals` 方法有关：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first warning is IDE0019, which suggests using pattern matching when declaring
    `otherAirport`. Thankfully, this analyzer provides a `Airport?` type reveals the
    **Use pattern matching** **Quick Action**, as shown in *Figure 12**.7*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个警告是 IDE0019，建议在声明 `otherAirport` 时使用模式匹配。幸运的是，这个 analyzer 提供了一个 `Airport?`
    类型，揭示了 **使用模式匹配** **快速操作**，如图 *图 12.7* 所示：
- en: '![Figure 12.7 – Applying the Use pattern matching refactoring](img/B21324_12_7.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7 – 应用 Use pattern matching 重构](img/B21324_12_7.jpg)'
- en: Figure 12.7 – Applying the Use pattern matching refactoring
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – 应用 Use pattern matching 重构
- en: 'Applying this refactoring resolves the suggestion and makes our code more concise:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 应用此重构解决了建议并使我们的代码更加简洁：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The last remaining warning is *IDE0059: Unnecessary assignment of a value to
    ‘otherName’*. This highlights that we’ve declared a variable and assigned a value
    to that variable but never used the variable after that point, as shown here with
    `otherName`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '最后剩下的警告是 *IDE0059: 对‘otherName’的不必要赋值*。这表明我们已声明了一个变量并给该变量赋值，但从那时起再也没有使用过该变量，如下面的
    `otherName` 所示：'
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Looking at this code, it’s a toss-up as to whether `otherName` should be included
    in the equality check or if the variable is simply not needed. In this case, you
    might ask a business stakeholder if an airport could ever have multiple names
    but be the same airport. If you get a “yes,” then the fix would be to remove the
    `otherName` variable, while a “no” would indicate that a `Name` check should be
    added to the `return` statement.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 看着这段代码，很难确定 `otherName` 是否应该包含在等价检查中，或者变量是否根本不需要。在这种情况下，你可能会询问业务利益相关者机场是否可能具有多个名称但仍然是同一个机场。如果你得到“是”的回答，那么修复方法将是删除
    `otherName` 变量，而“否”则表明应在 `return` 语句中添加 `Name` 检查。
- en: The correct fix for code issues is not always obvious without gathering more
    information about the business domain you’re modeling.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有收集更多关于你正在建模的业务领域信息的情况下，修复代码问题并不总是显而易见的。
- en: Configuring code analysis rulesets
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置代码分析规则集
- en: There are a large and growing number of analyzers in .NET and not every analyzer
    shares the same levels of importance. Because of this, Microsoft provides different
    sets of analyzers so that you can start with a small subset of the most useful
    ones and gradually expand into additional sets of analyzers as your maturity grows.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 中有大量且不断增长的 analyzers，并非每个 analyzer 都具有相同的重要性水平。因此，Microsoft 提供了不同的 analyzers
    集合，以便你可以从最有用的 analyzers 的小子集开始，随着成熟度的增长逐渐扩展到额外的 analyzers 集合。
- en: Let’s look at our code analysis settings for the `Chapter12` project by right-clicking
    on the `Chapter12` project in **Solution Explorer** and then selecting **Properties**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在**解决方案资源管理器**中右键单击**Chapter12**项目并选择**属性**来查看`Chapter12`项目的代码分析设置。
- en: This will open the properties view of the project. This view lists all configurable
    properties associated with the project and can be scrolled through from top to
    bottom or navigated using the navigation pane on the left-hand side.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开项目的属性视图。此视图列出了与项目关联的所有可配置属性，可以从顶部到底部滚动或使用左侧的导航窗格进行导航。
- en: 'Click on **Code Analysis** in the navigation pane; you should see the project’s
    code analysis settings, as shown in *Figure 12**.8*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航窗格中单击**代码分析**；您应该看到项目的代码分析设置，如图*图12.8*所示：
- en: '![Figure 12.8 – Code Analysis settings for the project](img/B21324_12_8.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8 – 项目的代码分析设置](img/B21324_12_8.jpg)'
- en: Figure 12.8 – Code Analysis settings for the project
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – 项目的代码分析设置
- en: As you can see from the **Run on build** setting, the compiler will analyze
    code every time the project is built.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从**运行构建**设置中看到的那样，编译器会在每次构建项目时分析代码。
- en: The exact set of analyzers used is controlled by the **Analysis level** setting,
    which defaults to **Latest** for new projects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的确切分析器集由**分析级别**设置控制，对于新项目默认为**最新**。
- en: 'There is a wide variety of analysis rulesets supported by Visual Studio, but
    let’s focus on the four rulesets that start with “Latest” as these are the most
    recent rulesets available, and the patterns in these rules will help you understand
    the other rules options. These options are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio支持多种分析规则集，但让我们关注以“最新”开头的四个规则集，因为这些是最新可用的规则集，这些规则集中的模式将帮助您了解其他规则选项。这些选项如下：
- en: '**Latest**: The default set of rules. This is a set of rules that is intended
    to be broadly applicable to any type of project.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最新**：默认的规则集。这是一个旨在适用于任何类型项目的规则集。'
- en: '**Latest Minimum**: Everything in **Latest** plus additional rules. This represents
    the minimum set of rules that Microsoft recommends using in a project.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最新最小**：**最新**中的所有内容加上额外的规则。这代表Microsoft推荐在项目中使用的最小规则集。'
- en: '**Latest Recommended**: Everything in **Latest Minimum** plus some additional
    rules. This contains a robust set of rules designed to help you maintain a business
    application that can run in any locale securely and reliably.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最新推荐**：**最新最小**中的所有内容加上一些额外的规则。这包含一套旨在帮助您维护在任何地区安全可靠运行的业务应用的健壮规则集。'
- en: '**Latest All**: All available rules are enabled. Not every rule may be relevant
    for the application you’re trying to build, but it maximizes your chances of building
    a robust and reliable application.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最新全部**：启用所有可用规则。并非每个规则都可能适用于您试图构建的应用程序，但它最大化了构建健壮和可靠应用程序的机会。'
- en: Let’s see what happens when we change our project from **Latest** to **Latest
    Recommended** and then build.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们把我们的项目从**最新**更改为**最新推荐**然后构建会发生什么。
- en: Responding to code analysis rules
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应代码分析规则
- en: After changing the project to use the **Latest Recommended** ruleset, three
    new warnings will appear, as shown in *Figure 12**.9:*
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在将项目更改为使用**最新推荐**规则集后，将出现三个新的警告，如图*图12.9*所示：
- en: '![Figure 12.9 – New compiler warnings after moving to a stricter ruleset](img/B21324_12_9.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图12.9 – 移动到更严格的规则集后的新编译器警告](img/B21324_12_9.jpg)'
- en: Figure 12.9 – New compiler warnings after moving to a stricter ruleset
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 – 移动到更严格的规则集后的新编译器警告
- en: 'Let’s start with the first warning. This corresponds to the `Flight` class,
    which is currently defined in only a few lines of code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个警告开始。这对应于`Flight`类，目前仅在几行代码中定义：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The CA1822 warning tells us *Member ‘BuildMessage’ does not access instance
    data and can be marked* *as static*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: CA1822警告告诉我们*成员‘BuildMessage’不访问实例数据，可以被标记* *为静态*。
- en: This analyzer is suggesting we make the `BuildMessage` method `static` because
    it doesn’t deal with any specific information from the overall `Flight` class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分析器建议我们将`BuildMessage`方法设置为`static`，因为它不处理`Flight`类的任何特定信息。
- en: In this case, making the method `static` could make it easier to test and allow
    the compiler to make a few performance optimizations as well.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将方法设置为`static`可能会使其更容易测试，并允许编译器进行一些性能优化。
- en: We could resolve this warning by performing the *Make method static* refactoring
    we covered in [*Chapter 4*](B21324_04.xhtml#_idTextAnchor072), but instead, let’s
    explore suppressing specific warnings.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行我们在 [*第4章*](B21324_04.xhtml#_idTextAnchor072) 中提到的 *将方法设为静态* 重构来解决这个问题，但相反，让我们来探讨如何抑制特定的警告。
- en: In this case, let’s say that we intend `BuildMessage` to deal with instance-specific
    properties at some point in the future, but haven’t gotten there yet. Because
    of this, we want the warning to go away without making the method static.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们假设我们打算在未来的某个时刻让 `BuildMessage` 处理实例特定的属性，但我们还没有做到这一点。正因为如此，我们希望警告消失，而不需要将方法设为静态。
- en: 'Use the `BuildMessage` method and then select the **Suppress or configure issues**
    submenu. From there, choose **Suppress CA1822**. This will reveal three different
    options for suppressing the issue, as shown in *Figure 12**.10*:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `BuildMessage` 方法，然后选择 **抑制或配置问题** 子菜单。从那里，选择 **抑制 CA1822**。这将显示抑制问题的三种不同选项，如图
    *图12.10* 所示：
- en: '![Figure 12.10 – Options for suppressing the code analysis warnings](img/B21324_12_10.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图12.10 – 抑制代码分析警告的选项](img/B21324_12_10.jpg)'
- en: Figure 12.10 – Options for suppressing the code analysis warnings
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 – 抑制代码分析警告的选项
- en: 'These options are as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项如下：
- en: '`#pragma` statements above and below your code to disable the code analysis
    warning temporarily'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的代码上方和下方使用 `#pragma` 语句来临时禁用代码分析警告
- en: '**in Suppression File**: This creates a separate file with code telling code
    analysis not to care about this specific issue for this specific method'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在抑制文件中**：这会创建一个包含代码的单独文件，告诉代码分析不要关心这个特定方法的具体问题'
- en: '`SuppressMessageAttribute` above the method, suppressing the code analysis
    issue'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法上方使用的 `SuppressMessageAttribute` 抑制代码分析问题
- en: All three of these approaches will suppress the issue, but all do so in different
    styles. I generally prefer to avoid preprocessor directives such as `#pragma`
    to have cleaner and more maintainable code. This leaves the suppression file and
    attribute approaches.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法都可以抑制问题，但它们以不同的方式做到这一点。我通常更喜欢避免预处理指令，如 `#pragma`，以获得更干净、更易于维护的代码。这留下了抑制文件和属性方法。
- en: The advantage of a suppression file is that code analysis suppressions do not
    clutter your source code and instead live in a separate file. However, that’s
    also their disadvantage. By hiding away suppressions in another file, you reduce
    the odds of resolving them in the future since they’re “out of sight, out of mind.”
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 抑制文件的优点是代码分析抑制不会使你的源代码杂乱，而是存在于一个单独的文件中。然而，这也是它们的缺点。通过将抑制隐藏在另一个文件中，你减少了在未来解决它们的可能性，因为它们是“眼不见，心不烦”。
- en: 'Using the `using` statement for `System.Diagnostic.CodeAnalysis` results in
    the following file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `using` 语句对 `System.Diagnostic.CodeAnalysis` 进行操作会产生以下文件：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `SuppressMessage` attribute above the method marks the category of the code
    analysis issue as “Performance.” Next, it names the individual analysis rule being
    suppressed before providing a justification.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法上方使用的 `SuppressMessage` 属性将代码分析问题的类别标记为“性能”。接下来，它命名了被抑制的个别分析规则，然后提供了一个理由。
- en: This justification is a string explaining to your coworkers (and future you)
    why you believe the code analysis rule should not be addressed at this time and
    should be excluded from the list of code analysis results.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解释是一个字符串，用于向你的同事（以及未来的你）说明你为什么认为代码分析规则现在不应被处理，并且应从代码分析结果列表中排除。
- en: I will never suppress a code analysis warning without providing a valid justification
    for the suppression. If a rule was important enough for someone to provide an
    analyzer for, it should either be resolved or I should have a valid justification
    for why I am choosing to ignore it. In case you were wondering, “I don’t feel
    like addressing it” is not a valid justification.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我绝不会在没有提供有效抑制理由的情况下抑制代码分析警告。如果一个规则重要到有人为其提供分析器，那么它应该被解决，或者我应该有一个有效的理由来解释我选择忽略它的原因。如果你在想，“我不想处理它”不是一个有效的理由。
- en: With the first warning out of the way, let’s look at the other two warnings
    together as they’re related.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决了第一个警告之后，让我们一起看看其他两个相关的警告。
- en: 'The first warning is CA1305, which is associated with the `DateHelpers` class,
    as shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个警告是 CA1305，它与 `DateHelpers` 类相关，如下所示：
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This warning states that the `ToString` call might result in a different result,
    depending on the user’s locale and language settings. My settings, as someone
    speaking English in the United States, may be different than someone running the
    same code with French as their primary locale.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个警告指出，`ToString`调用可能会根据用户的区域设置和语言设置产生不同的结果。我的设置，作为一个在美国说英语的人，可能不同于使用相同代码但以法语为主要区域设置的人。
- en: 'The next warning is on `BuildFlightIdentifier` in `CharterFlightInfo`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个警告是在`CharterFlightInfo`中的`BuildFlightIdentifier`：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This warning is complaining about a similar localization issue stating that
    the behavior of `StringBuilder.Append` could differ based on the user’s locale.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个警告抱怨一个类似本地化问题，指出`StringBuilder.Append`的行为可能会根据用户的区域设置而有所不同。
- en: Recommended rules versus minimum and default rules
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐规则与最小和默认规则
- en: 'These formatting rules are examples of rules that are not relevant to all projects.
    These rules are not enabled in the default or minimum rulesets for a reason: not
    all applications you create will need to behave consistently, regardless of where
    they’re running. If you’re building a hobby application or an application that
    runs only on a single server or in your office, this rule probably isn’t important
    for you. However, if you’re building something that is distributed throughout
    the globe to customers of all cultures, this is going to be a rule you care about.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些格式化规则是规则示例，这些规则并非对所有项目都相关。出于这个原因，这些规则在默认或最小规则集中没有启用：您创建的并非所有应用程序都需要在运行时保持一致。如果您正在构建一个爱好应用程序或仅在单个服务器或办公室运行的应用程序，这个规则可能对您来说并不重要。然而，如果您正在构建分布在全球范围内、面向所有文化背景的客户的应用程序，这将是一个您关心的规则。
- en: 'The fix for these two warnings is to provide an explicit culture that you want
    to be used when formatting strings. This changes our append code to the following
    line:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这两个警告的方法是提供一个显式的文化，您希望用于格式化字符串。这改变了我们的追加代码到以下行：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our date formatting code changes in a similar manner:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的日期格式化代码以类似的方式改变：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With these changes made, we are now free of code analysis warnings. Let’s finish
    this section by looking at a way of making sure we stay free of warnings.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些更改，我们现在不再有代码分析警告。让我们通过查看一种确保我们保持无警告的方法来完成本节。
- en: Treating warnings as errors
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将警告视为错误
- en: 'I’ve met many developers who treat warnings like they treat speed limits while
    driving: they ignore them and cruise by at unsafe speeds.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到过很多开发者，他们对待警告就像开车时对待速度限制一样：他们忽略它们，以不安全的车速驶过。
- en: There are a few ways of making sure developers ensure their code is free of
    warnings. Perhaps the easiest way of doing so is to tell the C# compiler to treat
    any warning as if it were a compiler error.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 确保开发者确保他们的代码没有警告的几种方法。也许最容易的方法就是告诉C#编译器将任何警告视为编译器错误。
- en: 'You can have the C# compiler treat all warnings as errors by right-clicking
    on the project and then selecting **Properties**, as we did before. From there,
    expand **Build** in the navigation pane and then click **Errors and warnings**.
    Once you do so, you should see something like *Figure 12**.11*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过右键单击项目并选择**属性**来让C#编译器将所有警告视为错误，就像我们之前做的那样。从那里，在导航窗格中展开**构建**，然后单击**错误和警告**。一旦这样做，您应该会看到类似*图12.11*的内容：
- en: '![Figure 12.11 – Configuring errors and warnings for a project](img/B21324_12_11.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图12.11 – 配置项目的错误和警告](img/B21324_12_11.jpg)'
- en: Figure 12.11 – Configuring errors and warnings for a project
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 – 配置项目的错误和警告
- en: You can check **Treat warnings as errors** to have all warnings result in errors.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择**将警告视为错误**，以便所有警告都导致错误。
- en: Since developers pay attention to things that stop their code from running at
    all, causing any warning to stop them from building their code will certainly
    get their attention! Be careful when using this as they may not be very happy
    about the severity of the interruption.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于开发者会关注那些完全阻止代码运行的问题，因此任何警告如果阻止他们构建代码肯定会引起他们的注意！在使用时请小心，因为他们可能不会对这种中断的严重性感到高兴。
- en: A less extreme option is to configure the **Treat specific warnings as errors**
    setting and include the identifiers of specific warnings you believe should always
    be addressed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不那么极端的选择是配置**将特定警告视为错误**设置，并包括您认为应该始终解决的特定警告标识符。
- en: For example, if we wanted to force developers to respond to suggestions of making
    methods `static` (CA1822), you could set the `$(WarningsAsErrors);NU1605;CA1822`;
    by doing so, any place where the warning occurred and was not suppressed would
    result in a compiler error.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想强制开发人员对将方法 `static`（CA1822）的建议做出响应，您可以通过设置 `$(WarningsAsErrors);NU1605;CA1822`
    来实现，这样做，任何发生警告且未被抑制的地方都会导致编译器错误。
- en: Now that we’ve covered the code analysis features of Visual Studio, let’s take
    a look at a pair of additional options in the form of third-party tools that work
    well with C# code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了 Visual Studio 的代码分析功能，让我们来看看另外一对与 C# 代码配合良好的第三方工具选项。
- en: Exploring advanced code analysis tools
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索高级代码分析工具
- en: The built-in code analysis and code metrics tools are very good for engineers
    wanting to pinpoint bad code and ensure code follows best practices for .NET projects,
    but they lack some enterprise-level features.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的代码分析和代码度量工具对于想要定位不良代码并确保代码遵循 .NET 项目的最佳实践工程师来说非常好，但它们缺少一些企业级功能。
- en: 'In this section, we’ll look at two different commercial analysis tools that
    I’ve found to provide additional value for .NET projects: **SonarCloud** and **NDepend**.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨两款不同的商业分析工具，我发现它们为 .NET 项目提供了额外的价值：**SonarCloud** 和 **NDepend**。
- en: I won’t be covering how to set up these tools as both tools have comprehensive
    documentation that I’ve provided links to in the *Further reading* section at
    the end of this chapter. Instead, we’ll focus on the types of insights that dedicated
    code analysis tools can give you beyond what’s available in Visual Studio.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会介绍如何设置这些工具，因为这两个工具都有全面的文档，我在本章末尾的 *进一步阅读* 部分提供了链接。相反，我们将专注于专门的代码分析工具可以提供的洞察力，这些洞察力超出了
    Visual Studio 中可用的内容。
- en: Tracking code metrics with SonarCloud and SonarQube
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SonarCloud 和 SonarQube 跟踪代码度量
- en: SonarCloud and SonarQube are a pair of commercial code analysis tools offered
    by SonarSource. Both products look at Git repositories containing code in a variety
    of popular programming languages and generate a series of recommendations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: SonarCloud 和 SonarQube 是由 SonarSource 提供的一对商业代码分析工具。这两个产品都会查看包含各种流行编程语言代码的 Git
    仓库，并生成一系列建议。
- en: The primary difference between SonarCloud and SonarQube is that SonarCloud is
    hosted on and analyzed by servers maintained by SonarSource while SonarQube is
    software you can install on your servers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: SonarCloud 和 SonarQube 之间的主要区别在于，SonarCloud 是由 SonarSource 维护的服务器上托管和分析的，而 SonarQube
    是你可以安装在你服务器上的软件。
- en: 'Both pieces of software can analyze code in Git repositories and provide heat
    maps of problem areas in your code in the areas of reliability, maintainability,
    security, and code duplication. These views give you a simple graphical representation
    of your code that helps easily flag problem areas, as shown in *Figure 12**.12*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这两款软件都可以分析 Git 仓库中的代码，并在可靠性、可维护性、安全性和代码重复方面的问题区域提供热图。这些视图为你提供了一个简单的图形表示，有助于轻松标记问题区域，如图
    *图 12.12* 所示：
- en: '![Figure 12.12 – SonarCloud analysis highlighting technical debt areas](img/B21324_12_12.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.12 – SonarCloud 分析突出技术债务区域](img/B21324_12_12.jpg)'
- en: Figure 12.12 – SonarCloud analysis highlighting technical debt areas
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.12 – SonarCloud 分析突出技术债务区域](img/B21324_12_12.jpg)'
- en: These tools have built-in analyzers that analyze your code and flag reliability,
    security, and performance issues for remediation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具内置了分析器，可以分析您的代码，并标记出需要修复的可靠性、安全性和性能问题。
- en: 'Once an issue has been flagged, you can use the web user interface shown in
    *Figure 12**.13* to assign it to a team member, add comments to it, or mark it
    as resolved or ignored:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦问题被标记，您可以使用图 *图 12.13* 中显示的网页用户界面将其分配给团队成员，添加注释，或将其标记为已解决或忽略：
- en: '![Figure 12.13 – Code analysis recommendations per line of code](img/B21324_12_13.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.13 – 每行代码的代码分析建议](img/B21324_12_13.jpg)'
- en: Figure 12.13 – Code analysis recommendations per line of code
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.13 – 每行代码的代码分析建议](img/B21324_12_13.jpg)'
- en: 'For me, SonarCloud and SonarQube have a few major selling points:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，SonarCloud 和 SonarQube 有几个主要的卖点：
- en: They help expose technical debt to non-developers in a very user-friendly way.
    An engineering manager or chief technology officer can look at the project in
    their web browser and get an understanding of the weak areas without ever having
    to install Visual Studio. This helps make technical debt transparent.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们以一种非常用户友好的方式帮助非开发人员暴露技术债务。工程经理或首席技术官可以在他们的网络浏览器中查看项目，并了解薄弱区域，而无需安装 Visual
    Studio。这有助于使技术债务透明化。
- en: Items flagged by SonarCloud and SonarQube tend to be worth investigating, perhaps
    even more so than items flagged by Visual Studio code analyzers.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 SonarCloud 和 SonarQube 标记的项目往往值得调查，甚至可能比由 Visual Studio 代码分析器标记的项目更值得。
- en: You tend to get a good result with these tools out of the box without needing
    additional configuration, though the configuration is available for customization
    should you wish to do so.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这些工具，您通常会获得良好的结果，无需额外配置，尽管配置可供您自定义。
- en: SonarCloud and SonarQube are commercial products that are priced based on the
    lines of code in your projects. SonarCloud is also freely available for any public
    GitHub repository.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: SonarCloud 和 SonarQube 是基于项目代码行数定价的商业产品。SonarCloud 还可以免费用于任何公共 GitHub 仓库。
- en: Since the code in this book is public on GitHub, you can see its code analysis
    results at [https://sonarcloud.io/summary/overall?id=IntegerMan_Refactoring-with-CSharp](https://sonarcloud.io/summary/overall?id=IntegerMan_Refactoring-with-CSharp).
    I’d also strongly recommend that you create an account and have SonarCloud analyze
    some open-source code you’ve written or are familiar with, just to walk through
    the setup and analysis process and see the recommendations it gives you.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书中的代码在 GitHub 上是公开的，您可以在 [https://sonarcloud.io/summary/overall?id=IntegerMan_Refactoring-with-CSharp](https://sonarcloud.io/summary/overall?id=IntegerMan_Refactoring-with-CSharp)
    上查看其代码分析结果。我还强烈建议您创建一个账户，并让 SonarCloud 分析您编写或熟悉的开源代码，以便熟悉设置和分析过程，并查看它给出的建议。
- en: While SonarCloud and SonarQube are not .NET-specific tools, I do find they work
    well with .NET projects, which is why they’re highlighted in this book.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SonarCloud 和 SonarQube 不是特定于 .NET 的工具，但我确实发现它们与 .NET 项目配合得很好，这就是为什么它们在这本书中被突出显示。
- en: 'Next, let’s look at a tool explicitly built for .NET and C# projects in particular:
    NDepend.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一个专门为 .NET 和 C# 项目构建的工具：NDepend。
- en: In-depth .NET analysis with NDepend
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NDepend 进行深入的 .NET 分析
- en: NDepend is a power tool designed to help architects and software engineers get
    the most out of their C# projects.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: NDepend 是一款专为帮助架构师和软件工程师从他们的 C# 项目中获得最大效益而设计的强大工具。
- en: NDepend can operate as a Visual Studio extension such as GitHub Copilot Chat,
    as a standalone application, or as a build agent integrated into an Azure DevOps
    build pipeline.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: NDepend 可以作为 Visual Studio 扩展（如 GitHub Copilot Chat）、独立应用程序或集成到 Azure DevOps
    构建管道中的构建代理运行。
- en: 'When NDepend runs its analysis, it produces an HTML report (pictured in *Figure
    12**.14*) and populates a dashboard view with the same information in Visual Studio:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当 NDepend 运行其分析时，它会生成一个 HTML 报告（如图 12.14 所示）并在 Visual Studio 的仪表板视图中填充相同的信息：
- en: '![Figure 12.14 – NDepend report showing code analysis results](img/B21324_12_14.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.14 – NDepend 报告显示代码分析结果](img/B21324_12_14.jpg)'
- en: Figure 12.14 – NDepend report showing code analysis results
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.14 – NDepend 报告显示代码分析结果
- en: This report highlights the number of code analysis rules violated by the project,
    the current unit test code coverage percentages, and how metrics have changed
    over time.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本报告突出了项目违反的代码分析规则数量、当前的单元测试代码覆盖率百分比以及指标随时间的变化情况。
- en: Try it out
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下
- en: You can view a sample NDepend report for this chapter in the [Chapter12/Ch12FinalCode/NDependOut/NDependReport.html](http://Chapter12/Ch12FinalCode/NDependOut/NDependReport.html)
    file in this book’s GitHub repository.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的 GitHub 仓库中的 [Chapter12/Ch12FinalCode/NDependOut/NDependReport.html](http://Chapter12/Ch12FinalCode/NDependOut/NDependReport.html)
    文件中查看本章的 NDepend 报告样本。
- en: If you and your engineering team are trying to answer questions such as “Are
    we getting better or worse?”, “What are our major problems?”, or “What areas need
    to be fixed the most?”, NDepend will help you with that.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您和您的工程团队正在尝试回答诸如“我们是在变得更好还是更差？”，“我们面临的主要问题是什么？”，或“哪些领域需要最迫切地修复？”等问题，NDepend
    将帮助您。
- en: Like SonarCloud, NDepend operates on a series of analyzers called “rules.” These
    rules are written using LINQ against a model representing your source code. The
    default rules ship with their source code included and can be customized to your
    team’s needs. You can also write your own rules – much as we’ll write our own
    Roslyn Analyzers in the next two chapters.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SonarCloud 类似，NDepend 在一系列称为“规则”的分析器上运行。这些规则使用 LINQ 对代表您源代码的模型进行编写。默认规则包含其源代码并提供自定义，以满足您团队的需求。您还可以编写自己的规则——就像我们在下一章中将要编写的
    Roslyn 分析器一样。
- en: These rules also allow you to compare how your code has changed since it was
    last baselined and estimate the amount of time it will take to resolve the technical
    debt they represent.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则还允许您比较自上次基准以来代码的变化情况，并估计解决它们所代表的技术债务所需的时间。
- en: NDepend’s strengths go past its primary report, rules list, and list of rules
    violations. The real strength of NDepend is in its data visualizations.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: NDepend 的优势不仅限于其主要报告、规则列表和规则违规列表。NDepend 的真正优势在于其数据可视化。
- en: 'The dependency matrix is what NDepend was originally known for and allows you
    to see a two-dimensional matrix of different namespaces and types, as shown in
    *Figure 12**.15*:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖矩阵是 NDepend 最初为人所知的功能，它允许您看到不同命名空间和类型的二维矩阵，如图 *12.15* 所示：
- en: '![Figure 12.15 – The NDepend dependency matrix](img/B21324_12_15.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.15 – NDepend 依赖矩阵](img/B21324_12_15.jpg)'
- en: Figure 12.15 – The NDepend dependency matrix
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.15 – NDepend 依赖矩阵
- en: This matrix helps you detect namespaces or types that are dependent on each
    other. When different types or namespaces are mutually dependent on each other,
    this typically represents incorrectly segmented software architecture, and NDepend
    makes this highly visible when violations are present.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个矩阵有助于您检测相互依赖的命名空间或类型。当不同类型或命名空间相互依赖时，这通常表示软件架构划分不当，并且当存在违规时，NDepend 会使其高度可见。
- en: NDepend’s visualizations don’t stop there, however. My favorite visualization
    built into NDepend is its heat view, which allows you to view types or methods
    inside your project in a hierarchical tree with different rectangles representing
    different types or methods.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，NDepend 的可视化并不止于此。我最喜欢的 NDepend 内置可视化是它的热视图，它允许您以分层树的形式查看项目中的类型或方法，其中不同的矩形代表不同的类型或方法。
- en: This view is similar to a tree map in data visualization tools, but each rectangle
    is colorized and sized based on various metrics calculated by NDepend. These metrics
    go well beyond the metrics Visual Studio calculates on its own and include things
    such as the lines of code, cyclomatic complexity, percentage of unit test coverage,
    or even the amount of comments in the file.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种视图类似于数据可视化工具中的树图，但每个矩形都是根据 NDepend 计算的各种指标着色和定制的。这些指标远远超出了 Visual Studio 自身计算的指标，包括代码行数、圈复杂度、单元测试覆盖率百分比，甚至文件中的注释数量。
- en: 'This heat map, pictured in *Figure 12**.16*, is the most intuitive way I’ve
    found of helping me zero in on potentially problematic code – and communicate
    problem areas visually to key stakeholders:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 12.16* 所示的此热图是我找到的帮我聚焦潜在问题代码的最直观方式——并且能够将问题区域直观地传达给关键利益相关者：
- en: '![Figure 12.16 – An NDepend heat map showing lines of code and cyclomatic complexity](img/B21324_12_16.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.16 – NDepend 热图显示代码行数和圈复杂度](img/B21324_12_16.jpg)'
- en: Figure 12.16 – An NDepend heat map showing lines of code and cyclomatic complexity
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.16 – NDepend 热图显示代码行数和圈复杂度
- en: 'NDepend also offers a dependency graph view. This graph allows you to see how
    assemblies, namespaces, types, methods, properties, events, and even fields interact
    with each other richly and interactively, as shown in *Figure 12**.17*:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: NDepend 还提供依赖关系图视图。此图允许您看到程序集、命名空间、类型、方法、属性、事件以及甚至字段如何丰富和交互式地相互交互，如图 *12.17*
    所示：
- en: '![Figure 12.17 – Namespace and type interactions within the Chapter12 project](img/B21324_12_17.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.17 – Chapter12 项目中的命名空间和类型交互](img/B21324_12_17.jpg)'
- en: Figure 12.17 – Namespace and type interactions within the Chapter12 project
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.17 – Chapter12 项目中的命名空间和类型交互
- en: This allows you to visualize your software architecture and communicate that
    architecture to others on your team. This is particularly handy when onboarding
    new developers.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这使您能够可视化您的软件架构，并将该架构传达给团队中的其他成员。这在欢迎新开发者加入时尤其方便。
- en: The graph view also allows you to spot problem areas such as types that depend
    on too many other types, different namespaces dependent on each other, and classes
    that likely violate the SRP.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图形视图还允许您发现问题区域，例如过度依赖其他类型的类型、相互依赖的不同命名空间，以及可能违反 SRP 的类。
- en: In my experience, NDepend takes some additional time to configure and investigate,
    but it represents a very effective way of visualizing, communicating, and navigating
    problem areas in your code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，NDepend 需要一些额外的时间来配置和调查，但它代表了一种非常有效的可视化、沟通和导航代码中问题区域的方法。
- en: Let’s finish this chapter by exploring code analysis at our fictional organization.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过探索我们虚构组织中的代码分析来结束本章。
- en: Case study – Cloudy Skies Airline
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究 – Cloudy Skies Airline
- en: Cloudy Skies Airlines knew they had a lot of technical debt and code issues,
    but they weren’t sure which areas they should prioritize. Each engineer had different
    opinions on what was most important. As you would expect, these opinions were
    usually influenced by what each engineer had worked on most recently.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Cloudy Skies Airlines知道他们有很多技术债务和代码问题，但不确定应该优先考虑哪些区域。每个工程师对什么最重要都有自己的看法。正如您所料，这些看法通常受每个工程师最近工作的内容的影响。
- en: To resolve this issue, engineering leadership turned to the data. They started
    analyzing the available code metrics in Visual Studio and cataloging where most
    code analysis warnings seemed to be located.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，工程领导转向数据。他们开始分析Visual Studio中可用的代码指标，并编制出大多数代码分析警告似乎所在的位置。
- en: Engineering management then compared the problem areas with the areas that had
    changed within the past 3 months and the areas the organization expects will need
    to change to support the team’s upcoming initiatives. This approach helped engineering
    management prioritize technical debt resolution in strategic areas that supported
    business objectives.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 工程管理随后将问题区域与过去3个月内发生变化的区域以及组织预期将需要改变以支持团队即将推出的计划的区域进行了比较。这种方法帮助工程管理优先考虑战略区域的技术债务解决方案，这些区域支持业务目标。
- en: 'To help resolve the backlog of warnings, developers were given a new mandate:
    each commit you make should not increase the number of active code analysis warnings.
    Decreasing the warning count or having it stay the same is fine, but increasing
    it will not be acceptable in code review.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决警告积压，开发人员被赋予了新的命令：您提交的每个提交都不应增加活动代码分析警告的数量。警告数量的减少或保持不变是可以接受的，但在代码审查中增加是不被接受的。
- en: This policy built additional awareness of code analysis warnings and the warnings
    were gradually reduced over time. Once the team got acclimated to paying attention
    to warnings, they moved to a larger code analysis ruleset. This caused a new series
    of warnings to come in, but those warnings helped identify potential or actual
    problems, as well as optimizations for the application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这项政策增加了对代码分析警告的认识，警告随着时间的推移逐渐减少。一旦团队习惯了关注警告，他们就转向了一个更大的代码分析规则集。这导致了一系列新的警告出现，但这些警告有助于识别潜在或实际的问题，以及应用程序的优化。
- en: To help provide insight into the health of its code, the organization is currently
    evaluating SonarCloud and NDepend to provide the team with a quality dashboard
    that will help them focus on key areas and ensure quality remains high going forward.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助提供代码健康状况的洞察，该组织目前正在评估SonarCloud和NDepend，为团队提供一个质量仪表板，帮助他们关注关键区域并确保质量持续保持高水平。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how code metrics and code analysis tools can help you
    spot problem areas in your code, follow best practices, and prioritize areas of
    technical debt. This will help you understand the issues you and your team struggle
    with. Once you know the areas you struggle with, you can focus on remediating
    them going forward. This also helps you prioritize areas of technical debt and
    communicate those areas to others.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了代码指标和代码分析工具如何帮助您发现代码中的问题区域，遵循最佳实践，并优先考虑技术债务的区域。这将帮助您了解您和您的团队所面临的挑战。一旦您知道了您所面临的挑战区域，您就可以专注于未来的修复工作。这也有助于您优先考虑技术债务的区域，并将这些区域传达给其他人。
- en: These built-in analyzers are incredibly handy and it turns out you can build
    some on your own. Over the next two chapters, we’ll do just that as we build our
    own code analyzer that can detect and automatically fix issues.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内置分析器非常实用，实际上您还可以自己构建一些。在接下来的两个章节中，我们将这样做，因为我们将构建自己的代码分析器，它可以检测并自动修复问题。
- en: Questions
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试您对本章知识的掌握：
- en: What are the areas you consider to be most problematic about your code?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您认为哪些区域是您代码中最有问题的地方？
- en: What do the code metrics say about these problem areas?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码指标对这些问题区域说了些什么？
- en: What is cyclomatic complexity and how is it calculated?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环复杂度是什么？它是如何计算的？
- en: What are the things you should consider when picking a code analysis ruleset?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择代码分析规则集时，您应该考虑哪些因素？
- en: Further reading
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find more information about code analysis at these URLs:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下URL中找到有关代码分析的更多信息：
- en: '*Code Metrics* *Values*: [https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values](https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码度量值*：[https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values](https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values)'
- en: '*Overview of .NET source code* *analysis*: [https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.NET源代码分析概述*：[https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview)'
- en: '*SonarCloud*: [https://www.sonarsource.com/products/sonarcloud/](https://www.sonarsource.com/products/sonarcloud/)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SonarCloud*：[https://www.sonarsource.com/products/sonarcloud/](https://www.sonarsource.com/products/sonarcloud/)'
- en: '*NDepend*: [https://www.ndepend.com/](https://www.ndepend.com/)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NDepend*：[https://www.ndepend.com/](https://www.ndepend.com/)'
