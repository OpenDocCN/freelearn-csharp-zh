<html><head></head><body>
  <div><h1 class="chapterNumber">2</h1>
    <h1 id="_idParaDest-25" class="chapterTitle">Crafting Scenes and Game Elements</h1>
    <p class="normal">In this chapter, we will develop some base knowledge of Unity in order to edit a project, and we will learn how to use several Unity Editor windows to manipulate our first scene and its objects. We will also learn how an object, or GameObject, is created and composed and how to manage complex scenes with multiple objects, using Hierarchies and Prefabs. Finally, we will review how we can properly save all our work to continue working on it later.</p>
    <p class="normal">Specifically, we will examine the following concepts in this chapter:</p>
    <ul>
      <li class="bulletList">Manipulating scenes</li>
      <li class="bulletList">GameObjects and components</li>
      <li class="bulletList">Understanding object Hierarchies</li>
      <li class="bulletList">Managing GameObjects using Prefabs</li>
      <li class="bulletList">Saving scenes and projects</li>
    </ul>
    <h1 id="_idParaDest-26" class="heading-1">Manipulating scenes</h1>
    <p class="normal">A <strong class="screenText">scene</strong> is one of the several <a id="_idIndexMarker030"/>types of files (also known as <strong class="keyWord">assets</strong>) in our project. Other types of files include scripts<a id="_idIndexMarker031"/> for code, audio files, 3D models, and textures, among others. A “scene” can be used for different things according to the type of project, but the most common use case is to separate your game into whole sections, with the most common ones being the following:</p>
    <ul>
      <li class="bulletList">The main menu</li>
      <li class="bulletList">Level 1, Level 2, Level 3, etc.</li>
      <li class="bulletList">A victory screen and a lose screen</li>
      <li class="bulletList">A splash screen and a loading screen</li>
    </ul>
    <p class="normal">In this section, we will cover the following concepts related to scenes:</p>
    <ul>
      <li class="bulletList">The purpose of a scene</li>
      <li class="bulletList">The <strong class="screenText">Scene</strong> view</li>
      <li class="bulletList">Adding our first GameObject to a scene</li>
      <li class="bulletList">Navigating the Scene view</li>
      <li class="bulletList">Manipulating GameObjects</li>
    </ul>
    <p class="normal">So, let’s take a look at each of these concepts.</p>
    <h2 id="_idParaDest-27" class="heading-2">The purpose of a scene</h2>
    <p class="normal">The idea of separating your game<a id="_idIndexMarker032"/> into scenes is so that Unity can process and load just the data needed for the scene. Let’s say<a id="_idIndexMarker033"/> you are in the main menu; in such a case, you will have only the textures, music, and objects that the main menu needs to be loaded in <strong class="keyWord">random-access memory</strong> (<strong class="keyWord">RAM</strong>), the device’s main memory. In that case, there’s no need for your game to have loaded the Level 10 boss if you don’t need it right now. That’s why loading screens exist, just to fill the time between unloading the assets needed in one scene and loading the assets needed in another. Maybe you are thinking that open-world games such as <em class="keystroke">Grand Theft Auto </em>don’t have loading screens while you roam around in the world, but they are actually loading and unloading chunks of the world in the background as you move, and those chunks are different scenes that are designed to be connected to each other.</p>
    <p class="normal">The difference between the main menu<a id="_idIndexMarker034"/> and a regular level scene is the objects (also known as <strong class="keyWord">GameObjects</strong> in Unity lingo) they have. In a menu, you will find objects such as backgrounds, music, buttons, and logos, and in a level, you will have the player, enemies, platforms, health boxes, and so on. So, the meaning of your scene depends on what GameObjects are put into it. But how can we create a scene? Let’s start with the Scene view.</p>
    <h2 id="_idParaDest-28" class="heading-2">The Scene view</h2>
    <p class="normal">When you open a Unity<a id="_idIndexMarker035"/> project, you will see the Unity Editor. It will be composed of several <strong class="keyWord">windows</strong> or <strong class="keyWord">panels</strong>, each one helping you to change <a id="_idIndexMarker036"/>different aspects of your game. In this chapter, we will look at the windows that help you create scenes. The Unity Editor is shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_01.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.1: The Unity Editor</p>
    <p class="normal">If you have ever programmed any kind of application before, you are probably used to having a starting function such as <code class="inlineCode">Main</code>, where you start writing code to create several objects needed for your app. If you were developing a game, you would probably create all the objects for the scene there. The problem with this approach is that in order to ensure all objects are created properly, you will need to run the program to see the results, and if something is misplaced, you will need to manually change the coordinates of the object, which is a slow and painful process. Luckily, in Unity, we have the Scene view, an example of which is shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_02.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.2: The Scene view</p>
    <p class="normal">This window is an implementation of the classic <strong class="keyWord">WYSIWYG</strong> (<strong class="keyWord">What You See Is What You Get</strong>) concept. Here, you can create objects<a id="_idIndexMarker037"/> and place them all over the scene, all through a scene previsualization where you can see how the scene<a id="_idIndexMarker038"/> will look when players play the game. However, before learning how to use this scene, we need to have an object in the scene, so let’s create our first object.</p>
    <h2 id="_idParaDest-29" class="heading-2">Adding our first GameObject to the scene</h2>
    <p class="normal">The project template we choose when creating<a id="_idIndexMarker039"/> the project comes with a blank scene ready<a id="_idIndexMarker040"/> to work with, but let’s create our own empty scene to see how to do it ourselves. To do that, you can simply use the <strong class="screenText">File | New Scene</strong> menu to create an empty new scene, as illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_03.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.3: Creating a new scene</p>
    <p class="normal">After clicking <strong class="screenText">New Scene</strong>, you will see<a id="_idIndexMarker041"/> a window to pick a scene template; here, select the <strong class="screenText">Basic (URP)</strong> template. A template defines<a id="_idIndexMarker042"/> which objects the new scene will have, and in this case, our template will come with a basic light and a camera, which will be useful for the scene we want to create. Once selected, just click the <strong class="screenText">Create</strong> button:</p>
    <figure class="mediaobject"><img src="img/B21361_02_04.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.4: Selecting the scene template</p>
    <p class="normal">Now that we have our empty scene, let’s add GameObjects to it. We will learn several ways of creating GameObjects throughout the book, but for now, let’s start using some basic templates Unity provides for us. In order to create them, we will need to open the <strong class="screenText">GameObject</strong> menu at the top of the Unity window, and it will show us several template categories, such as <strong class="screenText">3D Object</strong>, <strong class="screenText">2D Object</strong>, <strong class="screenText">Effects</strong>, and so on, as illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_05.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.5: Creating a cube</p>
    <p class="normal">Under the <strong class="screenText">3D Object</strong> category, we will see several 3D primitives such as <strong class="screenText">Cube</strong>, <strong class="screenText">Sphere</strong>, <strong class="screenText">Cylinder</strong>, and so on, and while using them is not as exciting as using beautiful, downloaded 3D models, remember that we are only prototyping<a id="_idIndexMarker043"/> our level at the moment. This is called <strong class="screenText">gray-boxing</strong>, which means that we will use lots of prototyping primitive shapes to model our level so that we can quickly test it, seeing if our idea is good enough to start the complex work of converting it to a final version.</p>
    <p class="normal">I recommend you pick the <strong class="screenText">Cube</strong> object<a id="_idIndexMarker044"/> to start because it is a versatile shape that can represent lots<a id="_idIndexMarker045"/> of objects. So, now that we have a scene with an object to edit, the first thing we need to learn to do with the Scene view is to navigate through the scene.</p>
    <h2 id="_idParaDest-30" class="heading-2">Navigating the Scene view</h2>
    <p class="normal">In order to manipulate a scene, we need<a id="_idIndexMarker046"/> to learn how to move through it to view the results from different perspectives. There are several ways to navigate the scene, so let’s start with the most common one, the first-person view. This view allows you to move through a scene using first-person-shooter-like navigation, using the mouse and the <em class="keystroke">WASD</em> keys. To navigate like this, you will need to press and hold the right mouse button, and while doing so, you can:</p>
    <ul>
      <li class="bulletList">Move the mouse to rotate the camera around its current position</li>
      <li class="bulletList">Press the <em class="keystroke">WASD</em> keys to move the position of the camera, always holding the right click</li>
      <li class="bulletList">You can also press <em class="keystroke">Shift</em> to move faster</li>
      <li class="bulletList">Press the <em class="keystroke">Q</em> and <em class="keystroke">E</em> keys to move up and down</li>
    </ul>
    <p class="normal">Another common way of moving is to click an object to select it (the selected object will have an orange outline), and then press the <em class="keystroke">F</em> key to focus on it, making the Scene view camera immediately move to a position where we can look at that object more closely. </p>
    <p class="normal">After that, we can press and hold the left <em class="keystroke">Alt </em>key on Windows, or <em class="keystroke">Option</em> on a Mac, along with the left mouse click, to finally start moving the mouse and “orbit” around the object. This will allow you to see the focused object from different angles to check if every part of it is properly placed, as demonstrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_06.png" alt="A picture containing screenshot, design  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.6: Selecting an object</p>
    <p class="normal">Now that we can move freely<a id="_idIndexMarker047"/> through the scene, we can start using the Scene view to manipulate GameObjects.</p>
    <h2 id="_idParaDest-31" class="heading-2">Manipulating GameObjects</h2>
    <p class="normal">Another use of the Scene view<a id="_idIndexMarker048"/> is to manipulate the locations of the objects. In order to do so, we first need to select<a id="_idIndexMarker049"/> an object, and then press the <strong class="keyWord">Transform</strong><strong class="screenText"> </strong>tool in the top-left corner of the Scene view. You can also press the <em class="keystroke">Y</em> key on the keyboard once an object is selected to activate the same Transform tool:</p>
    <figure class="mediaobject"><img src="img/B21361_02_07.png" alt="A close-up of a sign  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 2.7: The transformation tool</p>
    <p class="normal">This will show what is called the <strong class="keyWord">Transform</strong><strong class="screenText"> </strong>Gizmo over the selected object. A <strong class="keyWord">gizmo</strong> is a visual tool overlaid on top <a id="_idIndexMarker050"/>of the selected object, used to modify different<a id="_idIndexMarker051"/> aspects of it. In the case of the <strong class="keyWord">Transform Gizmo</strong>, it allows us to change the position, rotation, and scale of the object, as illustrated in <em class="keystroke">Figure 2.8</em>. Don’t worry if you don’t see the cube-shaped arrows outside the sphere—we will enable them in a moment:</p>
    <figure class="mediaobject"><img src="img/B21361_02_08.png" alt="A picture containing screenshot, circle, art  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.8: The Transform Gizmo</p>
    <p class="normal">Let’s start translating the object, which is accomplished <a id="_idIndexMarker052"/>by dragging the red, green, and blue arrows inside the gizmo’s sphere. While you do this, the object will move along the selected axis. An interesting concept to explore here is the meaning of the colors of these arrows. If you pay attention to the top-right area of the Scene view, you will see an axis Gizmo that serves as a reminder of those colors’ meaning, as illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_09.png" alt="A picture containing screenshot, design  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.9: The axis Gizmo</p>
    <p class="normal">Computer<a id="_idIndexMarker053"/> graphics use the classic 3D <strong class="keyWord">Cartesian coordinate system</strong> to represent objects’ locations. The red color is associated with the <em class="keystroke">x </em>axis of the object, green with the <em class="keystroke">y</em> axis, and blue with the <em class="keystroke">z</em> axis.</p>
    <p class="normal">But what does each axis mean? If you are used to another 3D authoring program like Maya, Blender, or 3DS Max, this can be<a id="_idIndexMarker054"/> different, but<a id="_idIndexMarker055"/> in Unity, the <em class="keystroke">z</em> axis represents the <strong class="keyWord">forward vector</strong>, which means that the arrow<a id="_idIndexMarker056"/> points along the front of the object; the <em class="keystroke">x</em> axis is the <strong class="keyWord">right vector</strong>, and the <em class="keystroke">y</em> axis represents the <strong class="keyWord">up vector</strong>.</p>
    <p class="normal">These directions are known as <strong class="keyWord">local</strong> coordinates, and that’s because every object <a id="_idIndexMarker057"/>can be rotated differently, meaning each object can point its forward, up, and right vectors elsewhere according to its orientation. The local coordinates will make more sense when used later in the <em class="keystroke">Understanding object hierarchies</em> section of the chapter, so bear<a id="_idIndexMarker058"/> with me on that, but it’s worth discussing <strong class="keyWord">global</strong><strong class="screenText"> </strong>coordinates now. The idea is to have a single origin point (the zero point) with a single set of forward, right, and up axes that are common across the scene. This way, when we say an object has a global position of <code class="inlineCode">5</code>,<code class="inlineCode">0</code>,<code class="inlineCode">0</code>, we know that we are referring to a position 5 meters along the global <em class="keystroke">x</em>-axis, starting from the global zero position. The global axes are the ones you see in the top-right axis gizmos previously mentioned.</p>
    <div><p class="normal">We just mentioned that a position (<code class="inlineCode">5</code>,<code class="inlineCode">0</code>,<code class="inlineCode">0</code>) would mean 5 meters along the <em class="italic">x</em>-axis, which implies that the Unity unit system is the meter. While several Unity systems like Physics and Audio follow this assumption (1 unit = 1 meter), it is not necessarily the mandatory unit system. There are several ways to change this and scale the world for convenience, but given that it is only necessary in specific scenarios, in this book, we will stick to the meter measuring system.</p>
    </div>
    <p class="normal">In order to be sure that we work with local<a id="_idIndexMarker059"/> coordinates, meaning we will move the object along its local axes, make sure the <strong class="screenText">Local</strong> mode is activated in the Scene view, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_10.png" alt="A screenshot of a phone  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 2.10: Switching pivot and local coordinates</p>
    <p class="normal">If the right button says <strong class="screenText">Global</strong> instead of <strong class="screenText">Local</strong>, just click it and select <strong class="screenText">Local</strong> from the drop-down options. By the way, try to keep the left button as <strong class="screenText">Pivot</strong>. If it says <strong class="screenText">Center</strong>, click and select <strong class="screenText">Pivot</strong>. The pivot of the object is not necessarily its center, and that depends entirely on the 3D model we use, and where the author of it specifies the object rotation center is located. For example, a car could have its pivot in the middle of its back wheels, so when we rotate, it will respect the real car’s rotation center. Editing based on the object’s pivot will simplify our understanding of how rotating via C# scripts will work later in <em class="keystroke">Chapter 6</em>. Also, now that we have enabled <strong class="screenText">Local</strong> coordinates, you should see the cube-shaped arrows seen in <em class="keystroke">Figure 2.8</em>; we will use them in a moment to scale the cube.</p>
    <p class="normal">I know—we are editing a cube, so there is no clear front or right side, but when you work with real 3D models such as cars and characters, they will certainly have those sides, and they must be properly aligned with those axes. If, by any chance in the future, you import a car into Unity and the front of the car points along the <em class="keystroke">x-</em>axis, you will need to align that model along the <em class="keystroke">z</em> axis because the code we will create to move our object will rely on that convention.</p>
    <p class="normal">Now, let’s use this <strong class="keyWord">Transform</strong><strong class="screenText"> </strong>Gizmo to rotate the object, using<a id="_idIndexMarker060"/> the three colored <a id="_idIndexMarker061"/>circles around it. If you click and drag, for example, the red circle, you will rotate the object along the <em class="keystroke">x-</em>axis. If you want to rotate the object horizontally, based on the color coding we previously discussed, you will probably pick the <em class="keystroke">x-</em>axis—the one that is used to move horizontally—but, sadly, that’s wrong. A good way to look at the rotation is like the accelerator of a motorcycle: you need to take it and roll it. If you rotate the <em class="keystroke">x-</em>axis like this, you will rotate the object up and down. So, in order to rotate horizontally, you would need to use the green circle or the <em class="keystroke">y</em> axis. The process is illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_11.png" alt="A picture containing screenshot, design, art  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.11: Rotating an object</p>
    <p class="normal">Finally, we have scaling, and we have two ways to accomplish that, one of them being through the gray cube at the center of the <strong class="keyWord">Transform</strong> Gizmo shown in <em class="keystroke">Figure 2.8</em>. This allows us to change the size of the object by clicking and dragging that cube. Now, as we want to prototype a simple level, sometimes we want to stretch the cube to create, for example, a column or a flat floor, and here’s where the second way comes in.</p>
    <p class="normal">If you click and drag the colored cubes in front of the translation arrows instead of the gray one in the center, you will see how our cube stretches over those axes, allowing you to change the shape of the object. If you don’t see those cube-shaped arrows, remember to enable <strong class="screenText">Local</strong> coordinates, as stated earlier in this section.</p>
    <p class="normal">The process of stretching is illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_12.png" alt="A picture containing screenshot, design  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.12: Scaling an object</p>
    <p class="normal"> Remember that you can also use<a id="_idIndexMarker062"/> the the same gray cube we had in the <strong class="keyWord">Transform</strong> Gizmo in the middle to scale all axes<a id="_idIndexMarker063"/> at the same time if desired. This is known as <strong class="keyWord">uniform scaling</strong></p>
    <p class="normal">Finally, something to consider here is that several objects can have the same scale values but different sizes, given how they were originally designed. <strong class="screenText">Scale</strong> is a multiplier we can apply to the original size of an object, so a building and a car both with scale <code class="inlineCode">1</code> make perfect sense; the relative size of one against the other seems correct. The main takeaway here is that scale is not size but a way to multiply it.</p>
    <p class="normal">Consider that scaling objects<a id="_idIndexMarker064"/> is usually a bad practice in many cases. In the final versions of your scene, you will use models with the proper size and scale, and they will be designed in a modular way so that you can plug them into each other. If you scale them, several bad things can happen, such as textures being stretched and becoming pixelated, and modules that no longer plug properly. There are some exceptions to this rule, such as placing lots of instances of the same tree in a forest and changing its scale slightly to simulate variation. Also, in the case of gray-boxing, it is perfectly fine to take cubes and change the scale to create floors, walls, ceilings, columns, and so on because, ultimately, those cubes will be replaced with real 3D models.</p>
    <p class="normal">Here’s a challenge! Create a room composed of a floor, three regular walls, and the fourth wall with a hole for a door (three cubes), and no need for a roof. In the next image, you can see how it should look:</p>
    <figure class="mediaobject"><img src="img/B21361_02_13.png" alt="A picture containing screenshot, design, water basin  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.13: Room task finished</p>
    <div><p class="normal"><strong class="keyWord">Memory</strong></p>
      <p class="normal">I remember when I started making games, I did most of my scenes with just boxes. While we will certainly do better in this book, there are still incredibly clever ways to use just that simple shape. Take, for example, the game <em class="italic">Thomas Was Alone</em>, which uses just boxes with clever lighting effects and looks beautiful.</p>
    </div>
    <p class="normal">Now that we can edit <a id="_idIndexMarker065"/>an object’s location, let’s see how we can edit all its other aspects.</p>
    <h1 id="_idParaDest-32" class="heading-1">GameObjects and components</h1>
    <p class="normal">We talked about our project<a id="_idIndexMarker066"/> being composed of <code class="inlineCode">assets</code> (the project’s files) and that a scene (which is a specific type of asset) is composed of GameObjects; so, how<a id="_idIndexMarker067"/> can we create an object? Through a composition of <strong class="keyWord">components</strong>.</p>
    <p class="normal">In this section, we will cover the following concepts related to components:</p>
    <ul>
      <li class="bulletList">Understanding components</li>
      <li class="bulletList">Manipulating components</li>
    </ul>
    <p class="normal">Let’s start by discussing what a component is.</p>
    <h2 id="_idParaDest-33" class="heading-2">Understanding components</h2>
    <p class="normal">A <strong class="keyWord">component</strong> is one of several pieces that make up a GameObject; each<a id="_idIndexMarker068"/> one is in charge of different features of the object. There are several components that Unity already includes that solve different tasks, such as playing a sound, rendering a mesh, applying physics, and so on; however, even though Unity has a large number of components, we will eventually need to create custom components sooner or later.</p>
    <p class="normal">In the next image, you can see what Unity shows us when we select a GameObject:</p>
    <figure class="mediaobject"><img src="img/B21361_02_14.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.14: The Inspector panel</p>
    <p class="normal">If we needed to guess <a id="_idIndexMarker069"/>what the <strong class="screenText">Inspector</strong> panel in the preceding screenshot does right now, we could say it shows all the properties of objects selected, either via the <strong class="screenText">Hierarchy</strong>, the menu where you can see all the objects that have already been placed within the current scene, or the Scene view, and allows us to configure those options to change the behavior of the object (i.e., the position and rotation, whether it will project shadows or not, and so on). </p>
    <p class="normal">That is true, but we are missing a key element: those properties don’t belong to the object; they belong to the components of the object. We can see some titles in bold before a group of properties, such as <strong class="screenText">Transform</strong> and <strong class="screenText">Box Collider</strong>, and so on. Those are the components of the object.</p>
    <p class="normal">In this case, our object has a <strong class="screenText">Transform</strong>, a <strong class="screenText">Mesh Filter</strong>, a <strong class="screenText">Mesh Renderer</strong>, and a <strong class="screenText">Box Collider</strong> component, so let’s review each one of those.</p>
    <p class="normal"><strong class="screenText">Transform</strong> just holds the position, rotation, and scale of the object, and by itself it does nothing—it’s just a point in our game—but as we add components to the object, that position starts to have more meaning. That’s because some components will interact with <strong class="screenText">Transform</strong> and other components, each one affecting the other.</p>
    <p class="normal">An example of these different components interacting with each other would be the case of <strong class="screenText">Mesh Filter</strong> and <strong class="screenText">Mesh Renderer</strong>, both of those being<a id="_idIndexMarker070"/> in charge of rendering a 3D model. <strong class="screenText">Mesh Renderer</strong> will render the 3D model, also known as mesh, specified by the <strong class="screenText">Mesh Filter</strong> in the position specified in the <strong class="screenText">Transform</strong> component, so <strong class="screenText">Mesh Renderer</strong> needs to get data from those other components and can’t work without them.</p>
    <p class="normal">Another example would be the <strong class="screenText">Box Collider</strong>. This represents the physics shape of the object, so when the physics calculates collisions between objects, it checks if that shape collides with other shapes, based on the position specified in the <strong class="screenText">Transform</strong> component.</p>
    <p class="normal">We will explore rendering and physics later in the book, but the takeaway from this section is that a GameObject is a collection of components, each component adding a specific behavior to our object, and each one interacting<a id="_idIndexMarker071"/> with the others to accomplish the desired task. To further reinforce this, let’s see how we can convert a cube into a sphere that will fall, due to gravity applied via physics.</p>
    <h2 id="_idParaDest-34" class="heading-2">Manipulating components</h2>
    <p class="normal">The tool to edit an object’s components <a id="_idIndexMarker072"/>is the <strong class="screenText">Inspector</strong>. It not only allows us to change the properties of our components but also lets us add and remove components. In this case, we want to convert a cube to a sphere, so we need to change several aspects of those components.</p>
    <p class="normal">We can start by changing the visual shape of the object, so we need to change the rendered model or <strong class="screenText">mesh</strong>. The component that specifies the mesh to be rendered is the <strong class="screenText">Mesh Filter</strong> component. If we look at it in the following figure, we can see a <strong class="screenText">Mesh</strong> property that says <strong class="screenText">Cube</strong>, with a little circle and a dot on its right:</p>
    <figure class="mediaobject"><img src="img/B21361_02_15.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.15: The Mesh Filter component</p>
    <p class="normal">If you don’t see a particular property, such as the <strong class="screenText">Mesh</strong> we just mentioned, try to click the triangle at the left of the component’s name. Doing this will expand and collapse all the component’s properties.</p>
    <p class="normal">If we click the button with a circle and a dot inside, the one at the right of the <strong class="screenText">Mesh</strong> property, the <strong class="screenText">Select Mesh</strong> window will pop up, allowing us to pick several <strong class="screenText">mesh</strong> options. In this case, select the <strong class="screenText">Sphere</strong> mesh. In the future, we will add more 3D models to our project so that the window will have more options.</p>
    <p class="normal">The mesh selector is shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_16.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.16: The mesh selector</p>
    <p class="normal">Okay—the object now looks like a sphere, but will it behave like a sphere? Let’s find out. In order to do so, we can add a component named <strong class="screenText">Rigidbody</strong> to our sphere, which will add physics to it. We will talk more about Rigidbody and physics later in <em class="chapterRef">Chapter 7</em>, <em class="italic">Collisions and Health: Detecting Collisions Accurately</em>, but for now, let’s stick to the basics.</p>
    <p class="normal">To add Rigidbody to our sphere, we need<a id="_idIndexMarker073"/> to click the <strong class="screenText">Add Component</strong> button at the bottom of the Inspector. It will show a <strong class="screenText">Component Selector</strong> window with lots of categories; in this case, we need to click on the <strong class="screenText">Physics</strong> category. The window will show all the <strong class="screenText">Physics</strong> components, and there we can find <strong class="screenText">Rigidbody</strong>. Another option would be to type <code class="inlineCode">Rigidbody</code> in the search box at the top of the window. The following screenshot illustrates how to add a component:</p>
    <figure class="mediaobject"><img src="img/B21361_02_17.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.17: Adding components</p>
    <p class="normal">If you hit the <strong class="screenText">Play</strong> button in the top-middle<a id="_idIndexMarker074"/> part of the editor, you can test your sphere physics using the <strong class="screenText">Game</strong> panel. That panel will be automatically focused when you hit <strong class="screenText">Play</strong> and will show you how the player will see the game. The playback controls are shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_18.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.18: Playback controls</p>
    <p class="normal">Here, you can just use the <strong class="screenText">Transform</strong> Gizmo to rotate and position your camera in such a way that it looks at our sphere. This is important, as one problem that can happen is that you might not see anything during <strong class="screenText">Play</strong> mode, which can happen if the game camera does not point to where our sphere is located. While you are moving, you can check the little preview in the bottom-right part of the <strong class="screenText">Scene</strong> window to check out the new camera perspective. That is the expected behavior if you have selected a camera. Another alternative would be to select the camera in the <strong class="screenText">Hierarchy</strong> and use the shortcut <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">F </em>(or <em class="keystroke">Command </em>+ <em class="keystroke">Shift</em> + <em class="keystroke">F</em> on a Mac). The camera preview is shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_19.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 2.19: The camera preview</p>
    <p class="normal">Now, to test if physics collisions<a id="_idIndexMarker075"/> are executing properly, let’s create a cube, scale it until it has the shape of a ramp, and put that ramp below our sphere, as shown here:</p>
    <figure class="mediaobject"><img src="img/B21361_02_20.png" alt="A picture containing screenshot, moon, sphere  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.20: Ball and ramp objects</p>
    <p class="normal">If you hit <strong class="screenText">Play</strong> now, you will see the sphere colliding<a id="_idIndexMarker076"/> with our ramp, but in a strange way. It looks like it’s bouncing, but that’s not the case. If you expand the <strong class="screenText">Box Collider</strong> component of our sphere, you will see that even if our object looks like a sphere, the green box gizmo shows us that our sphere is actually a box in the physics world, as illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_21.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.21: Object with a sphere graphic and box collider</p>
    <p class="normal">Nowadays, video cards (GPUs) can handle rendering highly detailed models (models with a high polygon count), but the physics system is executed in the <strong class="keyWord">central processing unit</strong> (<strong class="keyWord">CPU</strong>), and it needs to do complex calculations in order to detect collisions. To get a decent performance in our game, it needs to run at least 30 <strong class="keyWord">frames per second</strong> (<strong class="keyWord">FPS</strong>), the minimum accepted by the industry to provide a smooth experience. The physics system considers that and, hence, works using simplified collision shapes that may differ from the actual shape a player sees on the screen.</p>
    <p class="normal">That’s why we have <strong class="screenText">Mesh Filter</strong> and the different types of <strong class="screenText">Collider</strong> components separated—one handles the visual shape and the other the physics shape.</p>
    <p class="normal">Again, the idea of this section is not to deep-dive into those Unity systems, so let’s just move on for now. How can we solve the issue of our sphere appearing as a box? Simple: by modifying our components! In this case, the <strong class="screenText">Box Collider</strong> component already present in our cube GameObject can just represent a box physics shape, unlike <strong class="screenText">Mesh Filter</strong>, which supports any rendering shape. So, first, we need to remove it by right-clicking the component’s title and selecting the <strong class="screenText">Remove Component</strong> option, as illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_22.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.22: Removing components</p>
    <p class="normal">Now, we can again use the <strong class="screenText">Add Component</strong> menu to select a <strong class="screenText">Physics</strong> component, this time selecting the <strong class="screenText">Sphere Collider</strong> component. If you<a id="_idIndexMarker077"/> look at the <strong class="screenText">Physics</strong> components, you will see other types of colliders that can be used to represent other shapes, but we will look at them later in <em class="keystroke">Chapter 7</em>. </p>
    <p class="normal">The <strong class="screenText">Sphere Collider</strong> component can be seen in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_23.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.23: Adding a Sphere Collider component</p>
    <p class="normal">So, if you hit <strong class="screenText">Play</strong> now, you will see that our sphere not only looks like a sphere but also behaves like one. Remember: the main idea of this section of the book is understanding that, in Unity, you can create whatever object you want just by adding, removing, and modifying components, and we will be doing a lot of this throughout the book.</p>
    <p class="normal">Now, components are not the only thing needed<a id="_idIndexMarker078"/> in order to create objects. Complex objects may be composed of several sub-objects, so let’s see how that works.</p>
    <h1 id="_idParaDest-35" class="heading-1">Understanding object Hierarchies</h1>
    <p class="normal">Some complex objects<a id="_idIndexMarker079"/> may need to be separated into sub-objects, each one with its own components. Those sub-objects need to be somehow attached to the main object and work together to create the necessary object behavior.</p>
    <p class="normal">In this section, we will cover the following concepts related to objects:</p>
    <ul>
      <li class="bulletList">Parenting of objects</li>
      <li class="bulletList">Possible uses</li>
    </ul>
    <p class="normal">Let’s start by discovering how to create a parent-child relationship between objects.</p>
    <h2 id="_idParaDest-36" class="heading-2">Parenting of objects</h2>
    <p class="normal"><strong class="screenText">Parenting</strong> consists of making an object<a id="_idIndexMarker080"/> the child of another, meaning that those objects will be related to each other. One type of relationship that happens is a <strong class="screenText">Transform relationship</strong>, meaning that a child object will be affected by the parent’s <strong class="screenText">Transform</strong>. In simple terms, the child object will follow the parent, as if it is attached to it. For example, imagine a player with a hat on their head. The hat can be a child of the player’s head, making the hat follow the head while they are attached.</p>
    <p class="normal">In order to try this, let’s create a capsule that represents an enemy and a cube that represents the weapon of the enemy. Remember that in order to do so, you can use the <strong class="screenText">GameObject</strong> | <strong class="screenText">3D Object</strong> | <strong class="screenText">Capsule</strong> and <strong class="screenText">Cube</strong> options and then use the <strong class="screenText">Transform</strong> tool to modify them. An example of a capsule and a cube can be seen in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_24.png" alt="A picture containing screenshot  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.24: A capsule and a cube representing an enemy and a weapon</p>
    <p class="normal">If you move the enemy object (the capsule), the weapon (the cube) will keep its position, not following our enemy. So, to prevent that, we can simply drag the weapon to the enemy object in the <strong class="screenText">Hierarchy</strong> window, as illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_25.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 2.25: Parenting the cube weapon to the capsule character</p>
    <p class="normal">Now, if you move the enemy, you will see the gun moving, rotating, and being scaled along with it. So, basically, the gun <strong class="screenText">Transform</strong><strong class="screenText"><a id="_idIndexMarker081"/></strong> also has the effects of the enemy Transform component.</p>
    <p class="normal">Now that we have done some basic parenting, let’s explore other possible uses.</p>
    <h2 id="_idParaDest-37" class="heading-2">Possible uses</h2>
    <p class="normal">There are some other uses of parenting<a id="_idIndexMarker082"/> aside from creating complex objects. Another common usage for it is to organize the project Hierarchy. Right now, our scene is simple, but in time it will grow, so keeping track of all the objects will become difficult. To prevent this, we can create empty GameObjects (in <strong class="screenText">GameObject</strong> | <strong class="screenText">Create Empty</strong>) that only have the Transform component to act as containers, with objects put into them just to organize our scene. Try to use this with caution because this has a performance cost if you abuse it. Generally, having one or two levels of parenting when organizing a scene is fine, but more than that can have a performance hit. Consider that you can—and will—have deeper parenting for the creation of complex objects; the proposed limit is just for scene organization.</p>
    <p class="normal">To keep improving on our previous example, duplicate the enemy a couple of times all around the scene, create an empty GameObject, name it <code class="inlineCode">Enemies</code>, and drag all the enemies into it so that it will act as a container. This is illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_26.png" alt="A picture containing text, screenshot  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.26: Grouping enemies in a parent object</p>
    <p class="normal">Another common usage of parenting is to change the <strong class="screenText">pivot</strong> (or center) of an object. Right now, if we try to rotate our gun with the <strong class="screenText">Transform</strong> Gizmo, it will rotate around its center because the creator of that cube decided to put the center there. Normally, that’s okay, but let’s consider a case where we need to make the weapon aim at the point where our enemy is looking. In this case, we need to rotate the weapon around the weapon handle; so, in the case of this cube weapon, it would be the part of the handle that is closest to the enemy. The problem here is that we cannot change the center of an object, so one solution would be to create another “weapon” 3D model or mesh with another center, which will lead to lots of duplicated versions of the weapon if we consider other possible gameplay requirements such as a rotating weapon pickup. We can fix this easily using parenting.</p>
    <p class="normal">The idea is to create an empty GameObject and place it where we want the new pivot of our object to be. After that, we can simply drag our weapon inside this empty GameObject, and, from now on, consider the empty object as the actual weapon.</p>
    <p class="normal">If you rotate or scale this weapon container, you will see that the weapon mesh will apply those transformations around this container, so we can say the pivot of the weapon has changed (actually, it hasn’t, but our container simulates the change). The process<a id="_idIndexMarker083"/> is illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_27.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 2.27: Changing the Weapon pivot</p>
    <p class="normal">Now, let’s continue seeing different ways of managing GameObjects, using Prefabs this time.</p>
    <h1 id="_idParaDest-38" class="heading-1">Managing GameObjects using Prefabs</h1>
    <p class="normal">In the previous example, we created lots of copies<a id="_idIndexMarker084"/> of our enemy around the scene, but in doing so, we created<a id="_idIndexMarker085"/> a new problem. Let’s imagine we need to change our enemy and add a <strong class="screenText">Rigidbody</strong> component to it, but because we have several copies of the same object, we need to take them one by one and add the same component to all of them. Maybe later, we will need to change the mass of each enemy, so again, we need to go over each one of the enemies and make the change, and here we can start to see a pattern. One solution could be to select all the enemies using the <em class="keystroke">Ctrl</em> key (<em class="keystroke">Command</em> on a Mac) and modify all of them at once, but that solution won’t be of any use if we have enemy copies in other scenes. So, here is where Prefabs come in.</p>
    <p class="normal">In this section, we will cover the following concepts related to Prefabs:</p>
    <ul>
      <li class="bulletList">Creating Prefabs</li>
      <li class="bulletList">Prefab-instance relationship</li>
      <li class="bulletList">Prefab variants</li>
    </ul>
    <p class="normal">Let’s start by discussing how to create and use Prefabs.</p>
    <h2 id="_idParaDest-39" class="heading-2">Creating Prefabs</h2>
    <p class="normal"><strong class="screenText">Prefabs</strong> are a Unity tool that allows <a id="_idIndexMarker086"/>us to convert custom-made objects, such as our enemy, into an asset that defines how they can be created. We can use them to create new copies of our custom object easily, without needing to create its components and sub-objects all over again.</p>
    <p class="normal">In order to create a Prefab, you can simply drag your custom object from the <strong class="screenText">Hierarchy</strong> window to the project<strong class="screenText"> </strong>window, and after doing that, you will see a new asset in your project files. The project window is where you can navigate and explore all your project files; so, in this case, your Prefab is the first asset you ever created. </p>
    <p class="normal">Now, you can simply drag the Prefab from the project window into the scene to easily create new Prefab copies, as illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_28.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 2.28: Creating a Prefab</p>
    <p class="normal">Now, we have a little problem here. If you pay attention<a id="_idIndexMarker087"/> to the <strong class="screenText">Hierarchy</strong> window, you will see the original Prefab objects and all the new copies with their names in the color blue, while the enemies created before the Prefab will have their names in black. The blue color in a name means that the object is an <strong class="screenText">instance</strong> of a Prefab, meaning that the object was created based on a Prefab. We can select those blue-named objects and click the <strong class="screenText">Select</strong> button in the <strong class="screenText">Inspector</strong>, selecting the original Prefab that created that object. This is illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_29.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.29: Detecting Prefabs in the Hierarchy</p>
    <p class="normal">The problem here is that the non-blue copies of the enemy are not instances of the Prefab we just created. We can fix this by selecting all enemies, by clicking them in the Hierarchy window while pressing the <em class="italic">Ctrl</em> key (<em class="italic">Command</em> on a Mac), and then right-clicking on them to select the <strong class="screenText">Prefab </strong>|<strong class="screenText"> Replace...</strong> option. Finally, select the <code class="inlineCode">Enemy</code> Prefab in the <strong class="screenText">Select GameObject</strong> window that appeared to convert them to Prefab instances. This is a new feature available in the latest Unity versions.</p>
    <figure class="mediaobject"><img src="img/B21361_02_30.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.30: Converting regular GameObjects to Prefab instances</p>
    <div><p class="normal">You can also replace the original Prefab used by its instances with a different Prefab and convert a Prefab instance back to a regular GameObject. For more details, see the video at <a href="https://youtu.be/WOJzHz4sRyU">https://youtu.be/WOJzHz4sRyU</a> and the Unity<a id="_idIndexMarker088"/> documentation: <a href="https://docs.unity3d.com/Manual/UnpackingPrefabInstances.html">https://docs.unity3d.com/Manual/UnpackingPrefabInstances.html</a>.</p>
    </div>
    <p class="normal">Not having all enemy copies<a id="_idIndexMarker089"/> as Prefab instances didn’t seem to be a problem, but we will see why it was an issue in the next section of this chapter, where we will explore the relationship between the Prefabs and their instances.</p>
    <h2 id="_idParaDest-40" class="heading-2">Prefab-instance relationship</h2>
    <p class="normal">An instance of a Prefab, the GameObject<a id="_idIndexMarker090"/> that was created when dragging the Prefab to the scene, has a binding to it that helps to revert and apply changes easily between the Prefab and the instance. If you take a Prefab and make some modifications to it, those changes will be automatically applied to all instances across all the scenes in the project, so we can easily create a first version of the Prefab, use it all around the project, and then experiment with changes.</p>
    <p class="normal">To practice this, let’s say we want to add a <strong class="screenText">Rigidbody </strong>component to the enemies so that they can fall. In order to do so, we can<a id="_idIndexMarker091"/> simply double-click the Prefab file in the <strong class="screenText">Project</strong> panel and enter the <strong class="keyWord">Prefab Edit Mode</strong>, where we can edit the Prefab isolated from the rest of the scene.</p>
    <p class="normal">Here, we can simply take the Prefab root object (<strong class="screenText">Enemy</strong>, in our case) and add the <strong class="screenText">Rigidbody</strong> component to it. After that, we can simply click on the <strong class="screenText">Scenes</strong> button in the top-left part of the <strong class="screenText">Scene</strong> window to get back to the scene we were editing, and now, we can see that all the Prefab instances of the enemy have a <strong class="screenText">Rigidbody</strong> component, as illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_31.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.31: Prefab Edit Mode</p>
    <p class="normal">Now, what happens if we change a Prefab<a id="_idIndexMarker092"/> instance (the one in the scene) instead? Let’s say we want one specific enemy to fly, so they won’t suffer the effect of gravity. We can do that by simply selecting the specific Prefab and unchecking the <strong class="screenText">Use Gravity</strong> checkbox in the <strong class="screenText">Rigidbody</strong> component. After doing that, if we play the game, we will see that only that specific instance will float. That’s because changes to an instance of a Prefab become an <strong class="screenText">override</strong>, a set of differences the instance has compared to the original Prefab. We can see how the <strong class="screenText">Use</strong> <strong class="screenText">Gravity</strong> property is bold in the Inspector, and also has a blue bar displayed to its left, meaning it’s an override of the original Prefab value. Let’s take another object and change its <strong class="screenText">Scale</strong> property to make it bigger. Again, we will see how the <strong class="screenText">Scale</strong> property becomes bold, and a blue bar will appear to its left. The <strong class="screenText">Use Gravity</strong> checkbox can be seen in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_32.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.32: Use Gravity being highlighted as an override</p>
    <p class="normal">The overrides have precedence over the Prefab, so if we change<a id="_idIndexMarker093"/> the scale of the original Prefab, the one that has a scale override won’t change, keeping its own version of the scale, as illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_33.png" alt="A picture containing screenshot  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.33: One Prefab instance with a scale override</p>
    <p class="normal">We can easily locate all overrides of an instance using the <strong class="screenText">Overrides</strong> dropdown in the Inspector after selecting the Prefab instance (the one in the scene, outside <strong class="keyWord">Prefab Edit Mode</strong>) in the Hierarchy, locating all the changes our object has. It not only allows us to see all the overrides but also reverts any override we don’t want, applying the ones we do want. Let’s say we regretted the lack of gravity of that specific Prefab—no problem! We can just locate the override and revert it using the <strong class="screenText">Revert All</strong> button after clicking on the component with the override. The process is illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_34.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.34: Reverting a single override</p>
    <p class="normal">Also, let’s imagine that we really liked the new <a id="_idIndexMarker094"/>scale of that instance, so we want all instances to have that scale—great! We can simply select the specific override, hit the <strong class="screenText">Apply</strong> button, and then the <strong class="screenText">Apply All</strong> option; now, all instances will have that scale (except the ones with an override), as illustrated in the following screenshot:</p>
    <p class="normal"><img src="img/B21361_02_35.png" alt="" role="presentation"/></p>
    <p class="packt_figref">Figure 2.35: The Apply button</p>
    <p class="normal">Also, we have the <strong class="screenText">Revert All </strong>and <strong class="screenText">Apply All</strong> buttons, but use them with caution, because you can easily revert and apply changes that you are not aware of.</p>
    <p class="normal">So, as you can see, Prefabs are a really useful Unity tool to keep track of all similar objects and apply changes to all of them, and they also have specific instances with few variations. Talking about variations, there are other cases where you will want to have several instances of a Prefab with the same set of variations—for example, flying enemies and grounded enemies—but if you think about that, we will have the same problem we had when we didn’t use Prefabs, so we need to manually update those varied versions one by one.</p>
    <p class="normal">Here, we have two options: one is to create a brand new Prefab just to have another version with that variation. This leads to the problem that if we want all types of enemies to undergo changes, we need to manually apply the changes to each<a id="_idIndexMarker095"/> possible Prefab. The second option is to create a Prefab variant. Let’s review the latter.</p>
    <h2 id="_idParaDest-41" class="heading-2">Prefab variants</h2>
    <p class="normal">A <strong class="screenText">Prefab variant</strong> is a new Prefab that is created based<a id="_idIndexMarker096"/> on an existing one, so the new one <strong class="screenText">inherits</strong> the features of the base Prefab. This means that our new Prefab can have differences from the base one, but the features that they have in common are still connected.</p>
    <p class="normal">To illustrate this, let’s create a variation of the enemy Prefab that can fly: the flying enemy Prefab. In order to do that, we can select an existing <code class="inlineCode">enemy</code> Prefab instance in the <strong class="screenText">Hierarchy</strong> window, name it <code class="inlineCode">Flying Enemy</code>, and drag it again to the project window, and this time we will see a prompt, asking which kind of Prefab we want to create. This time, we need to choose <strong class="screenText">Prefab variant</strong>, as illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_36.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.36: Creating Prefab variants</p>
    <p class="normal">Now, we can enter the <strong class="keyWord">Prefab Edit Mode</strong> of the variant by double-clicking the new Prefab<a id="_idIndexMarker097"/> file created in the project panel. Then, add a cube as the jetpack of our enemy, and also uncheck the <strong class="screenText">Use Gravity</strong> property for the enemy. If we return to the scene, we will see that the variant instance has changed, and the base enemies haven’t changed. You can see this in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_02_37.png" alt="A picture containing design, art  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 2.37: A Prefab variant instance</p>
    <p class="normal">Now, imagine you want to add a hat to all our types of enemies. We can simply enter the <strong class="screenText">Prefab Edit Mode</strong> of the base enemy Prefab by double-clicking it and adding a cube as a hat. Now, we will see that change applied to all the enemies, because remember: the <strong class="screenText">Flying Enemy</strong> Prefab is a variant of the base enemy Prefab, meaning that it will inherit all the changes of that one.</p>
    <div><p class="normal">There’s also the concept of Nested Prefabs, which allows you to use prefabs inside prefabs to cleverly reuse prefabs’ pieces. For more info, see<a id="_idIndexMarker098"/> the Unity documentation here: <a href="https://docs.unity3d.com/Manual/NestedPrefabs.html">https://docs.unity3d.com/Manual/NestedPrefabs.html</a></p>
    </div>
    <p class="normal">We have created lots of content<a id="_idIndexMarker099"/> so far, but if our PC turns off for some reason, we will certainly lose it all, so let’s see how we can save our progress.</p>
    <h1 id="_idParaDest-42" class="heading-1">Saving scenes and projects</h1>
    <p class="normal">As in any other program, we need<a id="_idIndexMarker100"/> to save our progress. The difference here is that we don’t have just one giant file<a id="_idIndexMarker101"/> with all the project assets but also several files for each asset.</p>
    <p class="normal">Let’s start saving our progress by saving the scene, which is pretty straightforward. We can simply go to <strong class="screenText">File</strong> | <strong class="screenText">Save </strong>or press <em class="keystroke">Ctrl</em> + <em class="keystroke">S</em> (<em class="keystroke">Command</em> + <em class="keystroke">S</em> on a Mac). The first time we save our scene, a window will ask us where we want to save our file, and you can save it wherever you want inside the <code class="inlineCode">Assets</code> folder of our project, but never outside that folder; otherwise, Unity will not be capable of finding it as an asset in the project. That will generate a new asset in the project window: a scene file. </p>
    <p class="normal">In the following screenshot, you can see how I saved the scene, naming it <code class="inlineCode">test</code>, and now it shows up in the <strong class="screenText">Project</strong> panel:</p>
    <figure class="mediaobject"><img src="img/B21361_02_38.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 2.38: Scene files</p>
    <p class="normal">We can create a folder to save our scene in the <strong class="screenText">Save</strong> dialog, or, if you already saved the scene, you can create a folder using the <strong class="screenText">plus </strong>(<strong class="screenText">+</strong>) icon in the <strong class="screenText">Project</strong> window, and then click the <strong class="screenText">Folder</strong> option. Finally, drag the created scene to that folder. Now, if you create another scene with the <strong class="screenText">File</strong> | <strong class="screenText">New Scene</strong> menu option, you can get back to the previous scene just by double-clicking the scene asset in the project window. Try it!</p>
    <p class="normal">This only saved the scene, but any change in Prefabs and other kinds of assets are not saved with that option. Instead, if you want to save every change of the assets except scenes, you can use the <strong class="screenText">File</strong> | <strong class="screenText">Save Project</strong> option. It can be a little confusing, but if you want to save all your changes, you need to both save the scenes and the project, as saving just the project won’t save the changes to the scenes.</p>
    <p class="normal">Sometimes, the best way to be sure everything<a id="_idIndexMarker102"/> is saved is just by closing Unity, which is recommended when you try<a id="_idIndexMarker103"/> to move your project between computers or folders. This will show you a prompt to save the changes in the scene, and it will automatically save any change made to other assets, like Prefabs.</p>
    <h1 id="_idParaDest-43" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we had a quick introduction to essential Unity concepts. We reviewed the basic Unity windows and how we can use all of them to edit a full scene, from navigating it and creating premade objects (Prefabs) to manipulating them to create our own types of objects, using GameObjects and components. We also discussed how to use the <strong class="screenText">Hierarchy</strong> window to parent GameObjects to create complex object Hierarchies, as well as how to create Prefabs to reutilize and manipulate large amounts of the same type of objects. Finally, we discussed how we can save our progress.</p>
    <p class="normal">In the next chapter, we will learn about different tools like the Terrain system and ProBuilder to create the first prototype of our game’s level. This prototype will serve as a preview of where our scene will head, testing some ideas before going into full production.</p>
  </div>
  <div><h1 id="_idParaDest-44" class="heading-1">Learn more on Discord</h1>
    <p class="normal">Read this book alongside other users, Unity game development experts, and the author himself. Ask questions, provide solutions to other readers, chat with the author via Ask Me Anything sessions, and much more. Scan the QR code or visit the link to join the community:</p>
    <p class="normal"><a href="https://packt.link/unitydev">https://packt.link/unitydev</a></p>
    <p class="normal"><img src="img/QR_Code1498477041053909218.png" alt="" role="presentation"/></p>
  </div>
</body></html>