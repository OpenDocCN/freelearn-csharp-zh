<html><head></head><body>
		<div><h1 id="_idParaDest-319"><em class="italic"><a id="_idTextAnchor443"/>Chapter 15</em>: Working with Modularity</h1>
			<p>Let me state at the beginning of this chapter – modular application development is hard work! We want to split a large system into smaller modules and isolate them from each other. However, then we will have difficulties when integrating these modules and making them communicate with each other.</p>
			<p>One of the fundamental design goals of ABP Framework is modularity. It provides the necessary infrastructure to build truly modular systems.</p>
			<p>This chapter will start with what modularity means and the levels of modularity in the .NET platform. In the largest part of the chapter, we will explore the Payment module that I've built for the EventHub reference solution. We will learn how the module is structured, the key points of application module development, and how to install the module into the main application.</p>
			<p>This chapter consists of the following main topics:</p>
			<ul>
				<li>Understanding modularity</li>
				<li>Building the Payment module</li>
				<li>Installing the Payment module into EventHub</li>
			</ul>
			<h1 id="_idParaDest-320"><a id="_idTextAnchor444"/>Technical requirements</h1>
			<p>You can clone or download the source code of the EventHub project from GitHub: <a href="https://github.com/volosoft/eventhub">https://github.com/volosoft/eventhub</a>.</p>
			<p>If you want to follow the examples in this chapter, you need to have an IDE/editor that supports ASP.NET Core development.</p>
			<p>Finally, if you want to create modules with the ABP CLI, you should install it on your computer, as explained in the <em class="italic">Installing the ABP CLI</em> section of <a href="B17287_02_Epub_AM.xhtml#_idTextAnchor026"><em class="italic">Chapter 2</em></a>, <em class="italic">Getting Started with ABP Framework</em>.</p>
			<h1 id="_idParaDest-321"><a id="_idTextAnchor445"/>Understanding modularity</h1>
			<p>The term <strong class="bold">module</strong> is one of the <a id="_idIndexMarker958"/>most overused and overloaded concepts in the software industry. In this section, I want to explain what I mean by modularity in .NET and ABP Framework.</p>
			<p>Modularity is a software design technique to separate a large solution's code base into smaller, isolated modules that can then be developed independently. There are two main reasons <a id="_idIndexMarker959"/>behind modular application development:</p>
			<ul>
				<li><strong class="bold">Reducing complexity</strong>: Splitting a large code base into a smaller and isolated set of modules makes it easy to develop and maintain the solution.</li>
				<li><strong class="bold">Reusability</strong>: Building a module and reusing it across multiple applications reduces code duplication and saves time.</li>
			</ul>
			<p>In the next sections, I will discuss two different modularity levels from technical and design perspectives: class libraries (NuGet packages) and application modules. Let's begin with class libraries.</p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor446"/>Class libraries and NuGet packages</h2>
			<p>Most <a id="_idIndexMarker960"/>programming<a id="_idIndexMarker961"/> languages <a id="_idIndexMarker962"/>and<a id="_idIndexMarker963"/> frameworks have the concept of a module. In<a id="_idIndexMarker964"/> general, a module is a set of code files (classes and other resources) developed and shipped (deployed) together.</p>
			<p>A module provides some components and services for a larger application. A module may depend on other modules and can use the components and services provided by the dependent modules.</p>
			<p>In .NET, an assembly is a typical way to create a module. We can create a <strong class="bold">class library project</strong> and then use it within other libraries and applications. We can create NuGet packages for the class libraries and publish them on <a href="http://NuGet.org">NuGet.org</a> publicly. If the library is not public, we can host a private NuGet server in our own company. A NuGet package system makes it extremely easy to add a library to a project. There are thousands of packages already published on <a href="http://NuGet.org">NuGet.org</a>.</p>
			<p>ABP Framework itself is designed to be modular. It consists of hundreds of NuGet packages; each provides different infrastructure features for your applications. Some example packages are <code>Volo.Abp.Validation</code>, <code>Volo.Abp.Authorization</code>, <code>Volo.Abp.Caching</code>, <code>Volo.Abp.EntityFrameworkCore</code>, <code>Volo.Abp.BlobStoring</code>, <code>Volo.Abp.Auditing</code>, and <code>Volo.Abp.Emailing</code>. You can use any package you need in your application.</p>
			<p>You can refer to the <em class="italic">Understanding modularity</em> section of <a href="B17287_05_Epub_AM.xhtml#_idTextAnchor146"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring the ASP.NET Core and ABP Infrastructure</em> to learn about package-based ABP modules. The next <a id="_idIndexMarker965"/>section will <a id="_idIndexMarker966"/>discuss application<a id="_idIndexMarker967"/> modules, which <a id="_idIndexMarker968"/>typically consist of multiple packages (class library projects).</p>
			<h2 id="_idParaDest-323"><a id="_idTextAnchor447"/>Application modules</h2>
			<p>We can think<a id="_idIndexMarker969"/> of an application module as a vertical slice of an<a id="_idIndexMarker970"/> application. An application module has the <a id="_idIndexMarker971"/>following attributes:</p>
			<ul>
				<li>Defines some business objects (for example, aggregates, entities, and value objects)</li>
				<li>Implements business logic for the business objects it defines</li>
				<li>Provides database integration and mappings for the business objects</li>
				<li>Contains application services, data transfer objects, and HTTP APIs (controllers)</li>
				<li>Can have user interface components and pages related to the functionality it provides</li>
				<li>May need to add new items to the application menu, layout, or toolbars on the UI</li>
				<li>Publishes and consumes distributed events</li>
				<li>May have more features and other details you expect from a regular application</li>
			</ul>
			<p>There are several <em class="italic">isolation levels</em> for an application module based on your requirements and goals. Four common examples are listed here:</p>
			<ul>
				<li><strong class="bold">Tightly coupled modules</strong>: A module<a id="_idIndexMarker972"/> can be a part of <a id="_idIndexMarker973"/>a large monolith application with a single database. You can use that module's entities and services in other modules and perform database queries by joining the tables of that module. In this way, your modules become tightly coupled to each other.</li>
				<li><strong class="bold">Bounded contexts</strong>: A module can be a part of a large monolith application, but it hides its internal <a id="_idIndexMarker974"/>domain objects and database tables from other modules. Other modules can only use its integration services and subscribe to the events published by that module. They can't use the database tables of the module in SQL queries. The module may even use a different kind of DBMS for its specific requirements. That is the bounded context pattern in domain-driven design. Such a module is a good candidate to convert to a microservice if you want to convert your monolith application to a microservice solution in the future.</li>
				<li><strong class="bold">Generic modules</strong>: Generic modules are designed to be application-independent. They can<a id="_idIndexMarker975"/> be integrated into different kinds of applications. The application that uses the generic module can have some functionalities depending on that module, and it may need some integration code. A generic module may provide<a id="_idIndexMarker976"/> some options and customization points but doesn't make assumptions about the final application. Infrastructure modules, such as identity management and multi-language modules, fall into this category. Also, the Payment module, which is explained in the <em class="italic">Building the Payment module</em> section, is a generic module.</li>
				<li><strong class="bold">Plugin modules</strong>: A plugin module<a id="_idIndexMarker977"/> is a completely isolated and reusable application module. Other modules have no direct dependency on that module. You can easily add this module to or remove it from an existing solution without affecting the other modules and your application. If other modules need to use that module, they use some standard abstractions provided in a shared library. In this case, the module implements the abstractions and can be replaced by another module that implements the same abstractions. Even if the other modules use that module somehow, they can continue to work as expected when removing that module. That means the module should be optional and removable for the application.</li>
			</ul>
			<p>One of ABP Framework's main goals is to provide a convenient infrastructure to develop any kind of application module. It provides the necessary infrastructure details to build a truly modular <a id="_idIndexMarker978"/>system. It also provides some pre-built application modules you can directly reuse in your applications. Some examples are as follows:</p>
			<ul>
				<li>An <strong class="bold">account module</strong> provides<a id="_idIndexMarker979"/> authentication features, such as login, register, forgot password, and social login integrations.</li>
				<li>An <strong class="bold">identity module</strong> manages <a id="_idIndexMarker980"/>users, roles, and their permissions in your system.</li>
				<li>A <strong class="bold">tenant management</strong> module<a id="_idIndexMarker981"/> allows you to create and manage tenants in an SaaS/multi-tenant system.</li>
				<li>A <strong class="bold">CMS Kit</strong> module <a id="_idIndexMarker982"/>can be used to add fundamental <strong class="bold">Content Management System</strong> (<strong class="bold">CMS</strong>) features<a id="_idIndexMarker983"/> into your application, such as pages, tags, comments, and blogs.</li>
			</ul>
			<p>Account, identity, tenant management, and some other modules are pre-installed (as NuGet packages) when creating a new ABP solution.</p>
			<p>All pre-built modules are designed to be extensible and customizable. However, if you need to fully change a module based on your requirements, it is always possible to download the <a id="_idIndexMarker984"/>module's source code and include it in your solution.</p>
			<p>In the next section, we will see how to build a new application module with its own entities, services, and pages.</p>
			<h1 id="_idParaDest-324"><a id="_idTextAnchor448"/>Building the Payment module</h1>
			<p>You can already <a id="_idIndexMarker985"/>investigate the source code of the pre-built ABP modules to see how they are built and used in your application. I suggest it because you can see different implementation details of modular development. However, this section will explore the Payment module, which has been created as a simple yet real-world example for this book. It is used by the EventHub solution to receive payment when an organization wants to upgrade to a premium account. It is not possible to show the step-by-step development of that module in a book. We will investigate the fundamental points so that you can understand the module structure and build your own modules. Let's start with creating a new application module.</p>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor449"/>Creating a new application module</h2>
			<p>The ABP CLI's <code>new</code> <a id="_idIndexMarker986"/>command provides an <a id="_idIndexMarker987"/>option to create a new solution to build a reusable application module. See the following example:</p>
			<pre>abp new Payment -t module</pre>
			<p>I've specified to use the module template (<code>-t module</code>) with the module name as <code>Payment</code>. If you open the solution, you will see the solution structure, as shown in the following figure:</p>
			<div><div><img src="img/Figure_15.1_B17287.jpg" alt="Figure 15.1 – A fresh application module created by the ABP CLI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.1 – A fresh application module created by the ABP CLI</p>
			<p>The module startup template has too many projects because it supports multiple UI and database options and contains some test/demo projects. Let's eliminate some of the projects:</p>
			<ul>
				<li>The projects in the <code>host</code> folder are some demo applications to run the module in different architecture options. These projects are not parts of the module and are just for manual testing. We will install this module into the EventHub solution and test it there, so I deleted all host projects.</li>
				<li>I deleted the <code>Blazor.*</code> projects since my main UI will be MVC/Razor Pages.</li>
				<li>I deleted the MongoDB-related projects since I only want to support EF Core with my module.</li>
				<li>Finally, I deleted the <code>angular</code> folder (not shown in <em class="italic">Figure 15.1</em>) since I don't want an Angular UI for this module.</li>
			</ul>
			<p>After the<a id="_idIndexMarker988"/> cleanup, there are 12 projects in the module <a id="_idIndexMarker989"/>solution. Four of them are for unit and integration testing, so the module consists of eight projects that will be deployed. These eight projects are class library projects, so they can't be run individually. They need to be used by an executable application, such as EventHub:</p>
			<div><div><img src="img/Figure_15.2_B17287.jpg" alt="Figure 15.2 – The Payment module after the cleanup&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.2 – The Payment module after the cleanup</p>
			<p>This solution structure and layers were already explained in the <em class="italic">Structuring a .NET solution based on DDD</em> section of <a href="B17287_09_Epub_AM.xhtml#_idTextAnchor300"><em class="italic">Chapter 9</em></a>, <em class="italic">Understanding Domain-Driven Design</em>. So, I won't repeat it all here. However, we will change this structure because we want to provide <a id="_idIndexMarker990"/>multiple application layers for the<a id="_idIndexMarker991"/> Payment module.</p>
			<h2 id="_idParaDest-326"><a id="_idTextAnchor450"/>Restructuring the Payment module solution</h2>
			<p>We will install this<a id="_idIndexMarker992"/> Payment module to the EventHub solution. Remember from <a href="B17287_04_Epub_AM.xhtml#_idTextAnchor130"><em class="italic">Chapter 4</em></a>, <em class="italic">Understanding the Reference Solution</em>, that the EventHub solution has two UI applications:</p>
			<ul>
				<li>A public website that the end users of the system use to create and attend events. This application has an MVC/Razor Pages UI.</li>
				<li>An admin web application that is used by the administrative users of the EventHub system. This application is a Blazor WebAssembly application.</li>
			</ul>
			<p>To support the same architecture, we will provide two UI application layers for the Payment module:</p>
			<ul>
				<li>An application layer with the MVC/Razor Pages UI that is used by the EventHub public website. End users will make payments with that UI.</li>
				<li>An application layer with the Blazor WebAssembly UI that is used by the EventHub admin application. Administrative users will see the payment reports with that UI.</li>
			</ul>
			<p>The following figure shows the final Payment solution structure after I added the admin-side layers and <a id="_idIndexMarker993"/>organized the solution folders:</p>
			<div><div><img src="img/Figure_15.3_B17287.jpg" alt="Figure 15.3 – The Payment module solution with admin-side&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.3 – The Payment module solution with admin-side</p>
			<p>I added the <code>Payment.Admin.Application</code>, <code>Payment.Admin.Application.Contracts</code>, <code>Payment.Admin.Blazor</code>, <code>Payment.Admin.HttpApi</code>, and <code>Payment.Admin.HttpApi.Client</code> projects. I also added the <code>Payment.BackgroundServices</code> project to perform some periodic background workers.</p>
			<p>The solution folders reflect the overall structure – the <code>admin</code> application (with Blazor UI) and <code>www</code> (public) application (with MVC/Razor Pages UI). The <code>common</code> folder is used in both applications, so we share the same domain layer and database integration code.</p>
			<p>We've learned <a id="_idIndexMarker994"/>about the overall structure of the Payment solution. In the next section, you will learn the details of the payment process.</p>
			<h2 id="_idParaDest-327"><a id="_idTextAnchor451"/>Understanding the payment process</h2>
			<p>The only <a id="_idIndexMarker995"/>responsibility of the Payment module is to take a <a id="_idIndexMarker996"/>payment from the user. It internally uses PayPal as the payment gateway. The Payment module is generic and can be used by any kind of application. The application that uses the Payment module should include some integration logic that starts the payment process and handles the payment result. In this section, I will explain the process based on the EventHub integration.</p>
			<p>The EventHub application uses the Payment module to get a payment from a user to upgrade a free organization account to a premium organization account. As you can guess, premium organizations have more rights in the application.</p>
			<p>If you are the owner of an organization and visit the organization details page, you will see an <strong class="bold">Upgrade to Premium</strong> button on the page, as shown in the following figure:</p>
			<div><div><img src="img/Figure_15.4_B17287.jpg" alt="Figure 15.4 – The EventHub organization details page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.4 – The EventHub organization details page</p>
			<p>When you <a id="_idIndexMarker997"/>click <a id="_idIndexMarker998"/>on the <strong class="bold">Upgrade to Premium</strong> button, you are redirected to the pricing page:</p>
			<p class="figure-caption"><img src="img/Figure_15.5_B17287.png" alt="Figure 15.5 – The EventHub pricing page&#13;&#10;"/></p>
			<p class="figure-caption">Figure 15.5 – The EventHub pricing page</p>
			<p>Here, we can see<a id="_idIndexMarker999"/> the<a id="_idIndexMarker1000"/> account types and their differences. When we click the <strong class="bold">Upgrade to Premium</strong> button here, we are redirected to the pre-checkout page, which is defined by the Payment module:</p>
			<div><div><img src="img/Figure_15.6_B17287.jpg" alt="Figure 15.6 – The pre-checkout page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.6 – The pre-checkout page</p>
			<p>The pre-checkout <a id="_idIndexMarker1001"/>page is normally located inside the Payment module <a id="_idIndexMarker1002"/>and is developed to be application-independent. We can redirect the user to the pre-checkout page with a URL such as <code>/Payment/PreCheckout?paymentRequestId=3a002186-cb04-eb46-7310-251e45fc6aed</code>. However, we should first obtain a payment request ID using the <code>CreateAsync</code> method of the <code>IPaymentRequestAppService</code> service. This is done in the <code>Pages/Pricing.cshtml.cs</code> file of the <code>EventHub.Web</code> project.</p>
			<p>The EventHub application overrides the view (UI) part to make it fit better into EventHub's UI design. This is an example of customizing a module in a final application. The EventHub application defines <code>PreCheckout.cshtml</code> and <code>PostCheckout.cshtml</code> files under the <code>Pages/Payment</code> folder, as shown in the following figure:</p>
			<div><div><img src="img/Figure_15.7_B17287.jpg" alt="Figure 15.7 – Overriding the Payment module's checkout views&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.7 – Overriding the Payment module's checkout views</p>
			<p>They automatically<a id="_idIndexMarker1003"/> override the corresponding Payment<a id="_idIndexMarker1004"/> pages (because they are located exactly within the same path defined by the Payment module). These pages have no <code>.cshtml.cs</code> files here because we don't want to change the behavior of the page; we just want to change the view side.</p>
			<p>The following figure shows the main components and the flow used for the payment process:</p>
			<div><div><img src="img/Figure_15.8_B17287.jpg" alt="Figure 15.8 – The payment flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.8 – The payment flow</p>
			<p>When we click the <strong class="bold">Upgrade to Premium</strong> button on the Pricing page (in <em class="italic">Figure 15.5</em>), it redirects to the Checkout <a id="_idIndexMarker1005"/>page of the Payment module. When <a id="_idIndexMarker1006"/>we click the <strong class="bold">Checkout</strong> button (in <em class="italic">Figure 15.6</em>) on that page, we are redirected to PayPal, the payment system used and integrated by the Payment module. Once we complete the payment on PayPal, we are redirected back to the post-checkout page of the application, which shows a thank you message to the user.</p>
			<p>When a payment process succeeds, the Payment module publishes a distributed event named <code>PaymentRequestCompletedEto</code> (defined in the <code>Payment.Domain.Shared</code> project). The EventHub application subscribes to this event (with the <code>PaymentRequestEventHandler</code> class inside the <code>EventHub.Domain</code> project). It finds the user and organization related to the completed payment, upgrades the organization, and sends an email to thank the user for upgrading the account.</p>
			<p>There can be an error when returning from PayPal to our application in some rare cases, where we cannot know whether the payment process has succeeded. For such cases, the Payment module provides<a id="_idIndexMarker1007"/> a <code>PaymentRequestController</code> (in the <code>Payment.HttpApi</code> project). If the operation succeeds, the same <code>PaymentRequestCompletedEto</code> event is published so that the EventHub application can upgrade the organization account asynchronously.</p>
			<p>In the next section, we<a id="_idIndexMarker1008"/> will see how the Payment module provides <a id="_idIndexMarker1009"/>options to configure it.</p>
			<h2 id="_idParaDest-328"><a id="_idTextAnchor452"/>Providing configuration options</h2>
			<p>The Payment <a id="_idIndexMarker1010"/>module uses PayPal, so it needs the PayPal account information that the application must configure. It follows the options pattern (see the <em class="italic">Implementing the options pattern</em> section of <a href="B17287_05_Epub_AM.xhtml#_idTextAnchor146"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring the ASP.NET Core and ABP Infrastructure</em>) and provides the <code>PayPalOptions</code> class that can be configured by the application, as shown in the following example:</p>
			<pre>Configure&lt;PayPalOptions&gt;(options =&gt;
{
    options.ClientId = "...";
    options.Secret = "...";
});</pre>
			<p>We generally get the values from the configuration (the <code>appsettings.json</code> file). The Payment module can get the option values from the <code>Payment:PayPal</code> key if you've defined it, as in the following example:</p>
			<pre>"Payment": {
  "PayPal": {
    "ClientId": "...",
    "Secret": "...",
    "Environment": "Sandbox"
  }
}</pre>
			<p>This is made possible with the following code, located in the <code>PaymentDomainModule</code> class of the <code>Payment.Domain</code> project:</p>
			<pre>Configure&lt;PayPalOptions&gt;(configuration.GetSection("Payment:
                         PayPal"));</pre>
			<p>Getting the values from the configuration by default is a good practice.</p>
			<p>I've introduced the main points of the Payment module's structure. Its code base is not so different from a typical ABP application. You can explore its source code to understand how<a id="_idIndexMarker1011"/> it internally works. In the next section, we will see how it is installed in the EventHub application.</p>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor453"/>Installing the Payment module into EventHub</h1>
			<p>A module itself is <a id="_idIndexMarker1012"/>not a runnable project. It should be installed into a larger application and work as part of it. In this section, we will see how the Payment module is installed in the EventHub solution.</p>
			<h2 id="_idParaDest-330"><a id="_idTextAnchor454"/>Setting the project dependencies</h2>
			<p>The Payment <a id="_idIndexMarker1013"/>module consists of more than 10 projects in its solution (see <em class="italic">Figure 15.3</em>). Similarly, the EventHub solution has a lot of projects with three applications – the admin-side, the public, and the account (<code>IdentityServer</code>) applications.</p>
			<p>I want to integrate the Payment module into the EventHub solution in all layers. Typically, each layer of the EventHub solution should depend on (use) the corresponding layer of the Payment module. The following table shows all the dependencies of the EventHub projects to the Payment module projects:</p>
			<div><div><img src="img/Figure_15.9_B17287.jpg" alt="Figure 15.9 – EventHub and Payment module project dependencies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.9 – EventHub and Payment module project dependencies</p>
			<p>So, we should add project <a id="_idIndexMarker1014"/>references one by one. For example, we add the <code>Payment.Domain</code> project dependency to the <code>EventHub.Domain</code> project. This way, we can use Payment module entities in our application's domain layer.</p>
			<p>Visual Studio doesn't properly support adding a local project dependency to a project from outside of a solution (I call it an external project dependency). However, we can manually add <code>ProjectReference</code> elements into the <code>csproj</code> file of the target project. So, we can add the following line into the <code>EventHub.Domain.csproj</code> file:</p>
			<pre>&lt;ProjectReference Include=
    "..\..\modules\payment\src\Payment.Domain\Payment
     .Domain.csproj" /&gt;</pre>
			<p>When we add such an external project dependency, Visual Studio cannot automatically resolve it. We should open a command-line terminal and run the <code>dotnet restore</code> command. This command is only required when you add a new dependency or remove an existing dependency. In addition, if you want to build the EventHub solution with the Payment module, you can use the <code>dotnet build /graphBuild</code> command. While this is rarely needed, it can save the day when Visual Studio cannot resolve some types in the dependent module.</p>
			<p>Once we add a project reference, we should also add the ABP module dependency. The following code block shows the <code>PaymentDomainModule</code> dependency of the <code>EventHubDomainModule</code> class:</p>
			<pre>[DependsOn(
    ...,
    typeof(PaymentDomainModule)
)]
public class EventHubDomainModule : AbpModule
{ ... }</pre>
			<p>We should<a id="_idIndexMarker1015"/> manually set up all the project dependencies, as explained here. The next step is to configure the database tables for the Payment module.</p>
			<h2 id="_idParaDest-331"><a id="_idTextAnchor455"/>Configuring the database integration</h2>
			<p>The Payment module <a id="_idIndexMarker1016"/>needs some database tables to work properly. We can use the main EventHub database to store the Payment module's tables. With this approach, we will have a single database for the system. Alternatively, we can create a separate database for the Payment module so that we have two databases. The EventHub solution prefers the first approach since it is simpler to implement and manage. However, I will also show how we would implement the separate database approach. Let's begin with the single database approach.</p>
			<h3>Using a single database</h3>
			<p>In this section, I will <a id="_idIndexMarker1017"/>show you how we create the Payment tables in the main database of the EventHub application.</p>
			<p>The EventHub solution has an <code>EventHubDbContext</code> class inside the <code>EventHub.EntityFrameworkCore</code> project, which is the main class that maps the entities to the database tables. The Payment module defines a <code>ConfigurePayment</code> extension method that we call from the <code>OnModelCreating</code> method of our <code>DbContext</code> class to include the Payment database mapping model in our main database model (see the <code>EventHubDbContext</code> class in the <code>EventHub.EntityFrameworkCore</code> project):</p>
			<pre>protected override void OnModelCreating(ModelBuilder
                                        builder)
{
    base.OnModelCreating(builder);
    ...
    builder.ConfigurePayment(); // ADDED THIS LINE
    builder.ConfigureEventHub();
}</pre>
			<p>Here, <code>builder.ConfigurePayment()</code> is defined by the Payment module (in the <code>PaymentDbContextModelCreatingExtensions</code> class of the <code>Payment.EntityFrameworkCore</code> project). After adding this line inside the <code>OnModelCreating</code> method, we can add a new database migration to the EventHub solution using the following command in a command-line terminal (we run this command in the <code>root</code> folder of the <code>EventHub.EntityFrameworkCore</code> project):</p>
			<pre>dotnet ef migrations add Added_Payment_Module</pre>
			<p>This command creates a new migration file. Then, we can apply the new migration against the database using the following command:</p>
			<pre>dotnet ef database update</pre>
			<p>That's all. The Payment module will use the main EventHub database to store its data. This way, we will have a single database that contains all the tables of the application. In the next section, we will<a id="_idIndexMarker1018"/> discuss the separate database approach.</p>
			<h3>Using a separate database</h3>
			<p>In this section, we <a id="_idIndexMarker1019"/>will see how to change the EventHub solution to use a separate database for the Payment module. The EventHub solution uses PostgreSQL as the database provider. We will use Microsoft's SQL Server for the Payment module. This way, you will learn how to work with multiple database providers in a single application.</p>
			<p>I made the changes in a separate branch and <a id="_idIndexMarker1020"/>created a draft <strong class="bold">Pull Request</strong> (<strong class="bold">PR</strong>) on GitHub so that you can see all the changes:</p>
			<ul>
				<li>GitHub branch URL: <a href="https://github.com/volosoft/eventhub/tree/payment-sepr-db">https://github.com/volosoft/eventhub/tree/payment-sepr-db</a></li>
				<li>PR URL: <a href="https://github.com/volosoft/eventhub/pull/74">https://github.com/volosoft/eventhub/pull/74</a></li>
			</ul>
			<p>Here, I will point out the fundamental changes I've made. You can see the PR on GitHub for all the changes.</p>
			<p>To begin with, I've created a second <code>DbContext</code> class, named <code>EventHubPaymentDbContext</code>, in the <code>EventHub.EntityFrameworkCore</code> project to manage the database migrations:</p>
			<pre>[ReplaceDbContext(typeof(IPaymentDbContext))]
[ConnectionStringName(
    PaymentDbProperties.ConnectionStringName)]
public class EventHubPaymentDbContext
    : AbpDbContext&lt;EventHubPaymentDbContext&gt;,
    IPaymentDbContext
{
    public DbSet&lt;PaymentRequest&gt; PaymentRequests { get;
                                                   set; }
    public EventHubPaymentDbContext(
        DbContextOptions&lt;EventHubPaymentDbContext&gt; options) 
        : base(options)
    { }
    protected override void OnModelCreating(
        ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        modelBuilder.ConfigurePayment();
    }
}</pre>
			<p>This class<a id="_idIndexMarker1021"/> replaces <code>IPaymentDbContext</code> (defined by the Payment module) using the <code>[ReplaceDbContext]</code> attribute and implementing the <code>IPaymentDbContext</code> interface. It also declares the <code>[ConnectionStringName]</code> attribute to use the <code>Payment</code> connection string name instead of <code>Default</code> in the <code>appsettings.json</code> files. Finally, it calls the <code>modelBuilder.ConfigurePayment()</code> extension method of the Payment module to configure the database mappings.</p>
			<p>The Payment module <a id="_idIndexMarker1022"/>was designed to be independent of any specific <code>Volo.Abp.EntityFrameworkCore</code> package, which is DBMS-agnostic. Since I wanted to use a SQL Server database, I've added the <code>Volo.Abp.EntityFrameworkCore.SqlServer</code> package dependency to the <code>EventHub.EntityFrameworkCore</code> project. I also added <code>AbpEntityFrameworkCoreSqlServerModule</code> to the <code>DependsOn</code> attribute of the <code>EventHubEntityFrameworkCoreModule</code> class since ABP requires it.</p>
			<p>EF Core's command-line tool requires creating a <code>DbContext</code> factory class to create an instance of the related <code>DbContext</code> class when we run its commands. You can see the <code>EventHubPaymentDbContextFactory</code> class in the source code. It uses the <code>Payment</code> connection string and the <code>UseSqlServer</code> extension method to configure SQL Server as the database provider. With this change, we should add the <code>Payment</code> connection string in the <code>EventHub.DbMigrator</code> project's <code>appsettings.json</code> file:</p>
			<pre>"ConnectionStrings": {
  "Default": "Host=localhost;
              Database=EventHub;
              Username=root;
              Password=root;
              Port=5432",
  "Payment": "Server=(LocalDb)\\MSSQLLocalDB;
              Database=EventHubPayment;
              Trusted_Connection=True"
},</pre>
			<p>ABP will automatically<a id="_idIndexMarker1023"/> obtain the <code>Payment</code> connection string for the new <code>DbContext</code> class because it has the <code>ConnectionStringName</code> attribute (the value of <code>PaymentDbProperties.ConnectionStringName</code> is <code>Payment</code>). I also need to add the <code>Payment</code> connection string to all the <code>appsettings.json</code> files in which I have defined the <code>Default</code> connection string.</p>
			<p>I should register the new <code>EventHubPaymentDbContext</code> class to the dependency injection system and configure it. To do that, I've changed the <code>ConfigureServices</code> method of the <code>EventHubEntityFrameworkCoreModule</code> class, as follows:</p>
			<pre>public override void ConfigureServices(
    ServiceConfigurationContext context)
{
    context.Services.AddAbpDbContext&lt;EventHubDbContext&gt;(
        options =&gt;
    {
        options.AddDefaultRepositories();
    });
    context.Services.AddAbpDbContext&lt;
        EventHubPaymentDbContext&gt;();
    Configure&lt;AbpDbContextOptions&gt;(options =&gt;
    {
        options.UseNpgsql();        
        options.Configure&lt;EventHubPaymentDbContext&gt;(opts =&gt;
        {
            opts.UseSqlServer();
        });
    });
}</pre>
			<p>The <code>AddAbpDbContext&lt;EventHubPaymentDbContext&gt;()</code> call registers the new <code>DbContext</code> class. I<a id="_idIndexMarker1024"/> also added the <code>Configure&lt;EventHubPaymentDbContext&gt;(…)</code> block to use SQL Server for this <code>DbContext</code> class. Other <code>DbContext</code> classes will continue to use PostgreSQL (the <code>UseNpgsql()</code> call globally configures all <code>DbContext</code> classes).</p>
			<p>The <code>EventHub.DbMigrator</code> application executes database migrations for the main database. Now, we've got a second database and we want to change the <code>EventHub.DbMigrator</code> application so that it also executes database migrations for the Payment module's database. The change is simple; I've added the following code block inside the <code>EntityFrameworkCoreEventHubDbSchemaMigrator</code> class's <code>MigrateAsync</code> method:</p>
			<pre>await _serviceProvider
    .GetRequiredService&lt;EventHubPaymentDbContext&gt;()
    .Database
    .MigrateAsync();</pre>
			<p>This class is used by the <code>EventHub.DbMigrator</code> application while migrating the databases. So, by adding this code block, the new database is also migrated when I run the <code>EventHub.DbMigrator</code> application.</p>
			<p>As a final change, I will remove the Payment tables from the main EventHub database and the following line from the <code>EventHubDbContext</code> class:</p>
			<pre>builder.ConfigurePayment();</pre>
			<p>Then, I can use EF Core's command-line tool to create a database migration (in the <code>root</code> folder of the <code>EventHub.EntityFrameworkCore</code> project):</p>
			<pre>dotnet ef migrations add "Remove_Payment_From_Main_Database" --context EventHubDbContext</pre>
			<p>Differing from<a id="_idIndexMarker1025"/> standard usage, I added the <code>--context EventHubDbContext</code> parameter. I specify the <code>DbContext</code> type because there are two <code>DbContext</code> classes in the <code>EventHub.EntityFrameworkCore</code> project. Once it creates the migration (which drops the Payment tables), I can apply changes to the database using the following command:</p>
			<pre>dotnet ef database update --context EventHubDbContext</pre>
			<p>Now, the main database has no Payment tables. But we haven't created the payment database yet. To do that, I can use EF Core's command-line tool to create a database migration for the payment database (in the <code>root</code> folder of the <code>EventHub.EntityFrameworkCore</code> project):</p>
			<pre>dotnet ef migrations add "Initial_Payment_Database" --context EventHubPaymentDbContext --output-dir "MigrationsPayment"</pre>
			<p>This time, in addition to the <code>context</code> parameter that specifies the <code>EventHubPaymentDbContext</code> type, I set the <code>output-dir</code> parameter to specify the folder to create the migrations classes in it. The default folder name is <code>Migrations</code>, but this is used by the <code>EventHubDbContext</code> class, so I can't use it. I specify <code>MigrationsPayment</code> as the folder name. The following figure shows the new migration folder in the <code>EventHub.EntityFrameworkCore</code> project:</p>
			<div><div><img src="img/Figure_15.10_B17287.jpg" alt="Figure 15.10 – The migration folder for the Payment module&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.10 – The migration folder for the Payment module</p>
			<p>Now, I can use<a id="_idIndexMarker1026"/> the following command (in the <code>root</code> folder of the <code>EventHub.EntityFrameworkCore</code> project):</p>
			<pre>dotnet ef database update --context EventHubPaymentDbContexts</pre>
			<p>If I check the database, I can see the Payment module's table (it has a single database table):</p>
			<div><div><img src="img/Figure_15.11_B17287.jpg" alt="Figure 15.11 – The Payment module's table in its own database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.11 – The Payment module's table in its own database</p>
			<p>The separate database configuration is done. Now, the Payment module will use the new SQL Server database while the rest of the application will continue to work with the main PostgreSQL database.</p>
			<p class="callout-heading">Using DbMigrator</p>
			<p class="callout">I've used the <code>dotnet ef</code> command-line tool to update the database schema. However, we can also run the <code>DbMigrator</code> application to apply the changes to the databases. Since we've also changed the <code>EntityFrameworkCoreEventHubDbSchemaMigrator</code> class to support the second database, <code>DbMigrator</code> can migrate the database schemas for both databases.</p>
			<p>By creating new migration <code>DbContext</code> classes, as explained here, you can set up other modules to use their own databases. I added the new <code>DbContext</code> class in the same <code>EventHub.EntityFrameworkCore</code> project; however, we could create a new project for the new <code>DbContext</code> class and manage the migrations inside it. In that case, we don't need to specify the context and the <code>output-dir</code> parameters for the EF Core commands. However, I suggest <a id="_idIndexMarker1027"/>going with a single project to minimize the projects within the solution, as it already has a lot.</p>
			<h1 id="_idParaDest-332"><a id="_idTextAnchor456"/>Summary</h1>
			<p>In this chapter, I started by explaining what modularity means and what bounded context, tightly coupled, generic, and plugin modules are. We've learned how to create a new module using the ABP CLI.</p>
			<p>We then explored the structure of the Payment module and understood how it is integrated into the EventHub solution. We've learned the steps of manually installing the Payment module to the EventHub solution by setting up the project dependencies.</p>
			<p>Finally, we've seen two approaches to using the payment database tables. The single database approach is simple and shares the same database between the EventHub application and the Payment module. On the other hand, the separate database approach allows us to use a dedicated database for the payment tables, making it possible to use a different DBMS for the Payment module than the main application.</p>
			<p>I suggest checking the source code of the Payment module and the EventHub solutions to understand all the details of their structure. I also suggest you check the ABP documentation to understand modularity better and learn the best practices to build reusable, generic application modules: <a href="https://docs.abp.io/en/abp/latest/Best-Practices/Index">https://docs.abp.io/en/abp/latest/Best-Practices/Index</a>.</p>
			<p>In the next chapter, we will explore multi-tenancy, which is used to build SaaS applications.</p>
		</div>
	</body></html>