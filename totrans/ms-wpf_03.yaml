- en: Writing Custom Application Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will investigate application frameworks and the benefits
    that they can bring us. We find out the differences between providing this functionality
    via base classes and interfaces and also discover other ways to build functionality
    into our frameworks. We will then use this newfound knowledge to begin to construct
    our own application framework to streamline our future application development.
    The chapter will finish off by inspecting a variety of techniques to ensure that
    our applications maintain the essential Separation of Concerns that MVVM provides.
  prefs: []
  type: TYPE_NORMAL
- en: What is an application framework?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the simplest terms, an application framework is comprised of a library of
    classes that, together, provide the most common functionality required by an application.
    By using an application framework, we can vastly reduce the amount of work and
    time that is required to create the various parts of the application. In short,
    they support the future development of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In typical three-tier applications, the framework often extends through all
    layers of the application; the **Presentation Layer**, the **Business Layer**,
    and the **Data Access Layer**. In a WPF application using the MVVM pattern, we
    can, therefore, see aspects of the application framework in all three components
    of the pattern; the Models, the View Models, and the Views.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the obvious benefits of the reduced production times and effort involved
    in creating our application components, application frameworks also provide many
    additional benefits. Typical application frameworks promote reusability, which
    is one of the core aims of **Object-Oriented Programming** (**OOP**). They do
    this by providing generic interfaces and/or base classes that can be used to define
    the various application components.
  prefs: []
  type: TYPE_NORMAL
- en: By reusing these application framework interfaces and base classes, we also
    instill a sense of uniformity and consistency throughout the application. Furthermore,
    as these frameworks generally provide additional functionality, or services, the
    developers working on the application can save further time when requiring this
    particular functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Concepts like modularity, maintainability, testability, and extensibility can
    also be realized by using an application framework. These frameworks often come
    with the ability to run individual components independently of each other and
    this fits WPF and the MVVM pattern extremely well. Additionally, application frameworks
    can also supply patterns of implementation to further simplify the process of
    constructing new application components.
  prefs: []
  type: TYPE_NORMAL
- en: Different frameworks are created for different technologies and WPF already
    have a few publicly available. Some are relatively lightweight, like the **MVVM
    Light Toolkit** and the **WPF Application Framework** (**WAF**), while others
    are more heavyweight, like **Caliburn.Micro** and the now open source **Prism**.
    While it is likely that you may have used one or more of these frameworks at work,
    instead of investigating these in this chapter, we'll look at how to create our
    own lightweight custom framework, that will implement just the features that we
    need.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating common functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Probably the most commonly used interface in any WPF application would be the
    `INotifyPropertyChanged` interface, as it is required to correctly implement data
    binding. By providing an implementation of this interface in our base class, we
    can avoid having to repeatedly implement it in every single View Model class.
    It is, therefore, a great candidate for inclusion in our base class. There are
    a number of different ways to implement it depending on our requirements, so let''s
    take a look at the most basic first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In all forms of this implementation, we first need to declare the `PropertyChanged`
    event. This is the event that will be used to notify the various binding sources
    and targets of changes to the data bound values in our application. Note that
    this is the only requirement of the `INotifyPropertyChanged` interface. There
    is no `NotifyPropertyChanged` method that we have to implement, so you may well
    come across differently named methods that perform the same functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, without the method, just implementing the event would do nothing.
    The basic idea of this method is that as usual, we first check for `null`, and
    then raise the event, passing the raising class instance as the `sender` parameter
    and the name of the property that changed in the `PropertyChangedEventArgs`. We
    have already seen that the null conditional operator in C# 6.0 provides us with
    a shorthand notation for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the declared access modifier on this method is `protected`, to ensure
    that all View Models that derive from this base class will have access to it,
    while non-deriving classes will not. Furthermore, the method is also marked as
    `virtual`, so that the derived classes can override this functionality if required.
    In the View Models, this method would be called from a property like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'However, a new attribute was added in .NET 4.5, that gives us a shortcut to
    use with this implementation. The `CallerMemberNameAttribute` class enables us
    to automatically obtain the name of the method caller, or more specifically in
    our case, the name of the property that called the method. We can use it with
    an optional input parameter with a default value, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The calling property can then be simplified to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s worth noting at this point that in .NET 4.5.3, another improvement to
    calling the most basic implementation of this method was introduced. The `nameof`
    operator also enables us to avoid using strings to pass the property name, as
    passing strings can be error prone. This operator basically converts the name
    of a property, variable, or method to a string at compile time, so the end result
    is exactly the same as passing the string, but less error prone when renaming
    definitions. Using the preceding property as an example, let''s see how this operator
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also other tricks that we can employ too. For example, we often need
    to notify the Framework that more than one property value has changed at once.
    Visualize a scenario where we have two properties named `Price` and `Quantity`,
    and a third property named `Total`. As you can imagine, the value of the `Total`
    property will come from the calculation of the `Price` value multiplied by the
    `Quantity` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, this property has no setter, *so where should we call the* `NotifyPropertyChanged`
    *method from?* The answer is simple. We need to call it from *both* of the constituent
    property setters, as they can both affect the resulting value of this property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, we would have to call the `NotifyPropertyChanged` method once
    for each constituent property and once for the `Total` property. However, it is
    possible to rewrite our implementation of this method to enable us to pass multiple
    property names to it in a single call. For this, we can make use of the `params`
    keyword to enable any number of input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the `params` keyword, we need to declare an array type input parameter.
    However, this array merely holds the input parameters and we do not need to supply
    an array when calling this method. Instead, we provide any number of input parameters
    of the same type and they will be implicitly added to the array. Going back to
    our example, this enables us to call the method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We therefore have a variety of different ways to implement this method, depending
    on what suits our requirements. We can even add a number of overloads of the method
    to provide the users of our framework with more choices. We''ll see a further
    enhancement to this method later, but for now, let''s see what our `BaseViewModel`
    class might look like so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To summarize, we started with an interface that declared a single event. The
    interface itself provides no functionality and in fact, we as the implementers,
    have to provide the functionality, in the form of the `NotifyPropertyChanged`
    method and the calling of that method each time a property value changes. But
    the reward for doing this is that the UI controls are listening and responding
    to those events and so, by implementing this interface, we have gained this additional
    data binding capability.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can provide functionality in our application framework in a number
    of different ways. The two main ways are through the use of base classes and interfaces.
    The main difference between these two approaches relate to the amount of development
    that the users of our framework will have to accomplish in order to create the
    various application components.
  prefs: []
  type: TYPE_NORMAL
- en: When we use interfaces, we are basically supplying a contract that the developers
    will have to honor, by providing the implementation themselves. However, when
    we use base classes, we are able to provide that implementation for them. So generally,
    base classes provide ready-written functionality, whereas interfaces rely on the
    developers to provide some or all of that functionality for themselves.
  prefs: []
  type: TYPE_NORMAL
- en: We've just seen an example of implementing an interface in our View Model base
    class. Let's now take a look at what else we can encapsulate in our other framework
    base classes and compare the differences between providing features or functionality
    in base classes and interfaces. Let's turn our attention to our Data Model classes
    now.
  prefs: []
  type: TYPE_NORMAL
- en: In base classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen that in a WPF application, it is essential for us to have an implementation
    of the `INotifyPropertyChanged` interface in our View Model base class. Likewise,
    we will also need a similar implementation in our Data Model base class. Remember
    that when Data Models are mentioned here, we are discussing the business Model
    classes that are combined with the View Model properties and functionality from
    the second application structure example in [Chapter 1](b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml),
    *A Smarter Way of Working with WPF*.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these `DataModel` classes will need to extend their base class because
    they will all need to have access to its `INotifyPropertyChanged` implementation.
    As we progress through the chapters in this book, we will see more and more reasons
    why we need separate base classes for our Data Models and View Models. For example,
    let''s imagine that we want to provide these Data Models with some simple auditing
    properties and investigate what our base class might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see our auditing properties, along with the hidden `INotifyPropertyChanged`
    implementation that we saw earlier. For now, let's keep the implementation the
    same as that of the `BaseViewModel` class. Note that using this particular base
    class would result in all derived classes getting access to these properties,
    whether they needed them or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might then decide to declare another base class, so that we can have one
    that provides access to our implementation of the `INotifyPropertyChanged` interface
    and one that extends that base class and adds the new auditable properties shown
    earlier. In this way, all derived classes can make use of the `INotifyPropertyChanged`
    interface implementation and the classes that require the auditable properties
    as well can be derived from the second base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3683da7b-cf5e-4248-9817-6c312b354894.png)'
  prefs: []
  type: TYPE_IMG
- en: For this basic example, we seem to have solved our problem. If these auditable
    properties were the only properties that we wanted to provide to our derived classes,
    then this would not be such a bad situation. However, an average a framework will
    typically provide far more than this.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now imagine that we wanted to provide some basic undo capability. We'll
    see an example of this later in this chapter, but for now we'll keep this simple.
    Without actually specifying the required members of this new base class, let's
    just think about this first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a situation where we already have two different base classes and
    we want to provide some further functionality. *Where should we declare our new
    properties?* We could derive from either one, or indirectly, from both of the
    existing base classes, as shown in the following diagram, in order to create this
    new *synchronizable* base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb648ff4-7899-45fe-8384-951ca879067f.png)'
  prefs: []
  type: TYPE_IMG
- en: So now, we could have four different base classes that the developers, that
    use our framework could extend. There could be some confusion as to exactly which
    base class they need to extend, but overall, this situation is still just about
    manageable. However, imagine if we want to provide some additional properties
    or functionality in one or more levels of base class.
  prefs: []
  type: TYPE_NORMAL
- en: In order to enable every combination of functionality from these base classes,
    we could end up with as many as eight separate base classes. Each additional level
    of functionality that we provide will either double the total number of base classes
    that we have, or mean that the developers sometimes have to derive from a base
    class with functionality or properties that they do not require. Now that we have
    uncovered a potential problem of utilizing base classes, let's see if declaring
    interfaces can help with this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Through interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Going back to our auditing example, we could have declared these properties
    in an interface instead. Let''s see what this might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if a developer requires these properties, they can implement this interface
    as well as extending the Data Model base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de114e5f-d44f-454d-bf16-834b289774d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see an example of this in code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Initially then, it seems as though this could be a better way to go, but let's
    continue to investigate the same scenario that we looked at with the base classes.
    Let's now imagine that we want to provide the same basic undo capability using
    interfaces. We didn't actually investigate which members would be required for
    this, but it will require both properties and methods.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the interface approach starts to break down somewhat. We can ensure
    that implementers of our `ISynchronization` interface have particular properties
    and methods, but we have no control over their implementation of those methods.
    In order to provide the ability to undo changes, we need to provide the actual
    implementation of these methods, rather than just the required scaffolding.
  prefs: []
  type: TYPE_NORMAL
- en: If this was left up to the developers to implement each time they used the interface,
    they might not implement it correctly, or perhaps they might implement it differently
    in different classes and break the consistency of the application. Therefore,
    to implement some functionality, it seems as though we really do need to use some
    kind of base class.
  prefs: []
  type: TYPE_NORMAL
- en: However, we also have a third option that involves a mix of the two approaches.
    We could implement some functionality in a base class, but instead of deriving
    our Data Model classes from it, we could add a property of that type to them,
    so that they can still access its public members.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could then declare an interface that simply has a single property of the
    type of this new base class. In this way, we would be free to add the different
    functionality from different base classes to just the classes that require them.
    Let''s look at an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This `Auditable` class would have the same properties as those in the previous
    `IAuditable` interface shown in the preceding code. The new `IAuditable` interface
    would be implemented by the Data Model classes by simply declaring a property
    of type `Auditable` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It could be used by the framework, for example, to output the names of each
    user and when they were created into a report. In the following example, we use
    the **Interpolated Strings** syntax that was introduced in C# 6.0 for constructing
    our string. It''s like the `string.Format` method, but with the method call replaced
    with a `$` sign and the numerical format items replaced with their related values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Most interestingly, as this interface could be implemented by many different
    types of object, the preceding code could also be used with objects of different
    types. Note this slight difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It's worth pointing out this useful ability to work with objects of different
    types is not limited to interfaces. This can also be achieved just as easily with
    base classes. Imagine a View that enabled the end user to edit a number of different
    types of object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we added a property named `PropertyChanges`, that returned details of changed
    properties, into the `BaseSynchronizableDataModel` class that we will see later,
    in the *Constructing a custom application framework* section, we could use this
    very similar code to display a confirmation of the changes from each object back
    to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have a number of choices when it comes to encapsulating pieces of pre-packaged
    functionality into our Data Model classes. Each of these methods that we have
    investigated so far have strengths and weaknesses. If we're sure that we want
    some pre-written functionality in every one of our Data Model classes, like that
    of the `INotifyPropertyChanged` interface, then we can simply encapsulate it in
    a base class and derive all of our Model classes from that.
  prefs: []
  type: TYPE_NORMAL
- en: If we just want our Models to have certain properties or methods that can be
    called from other parts of the framework, but are not concerned with the implementation,
    then we can use interfaces. If we want some combination of the two ideas, then
    we can implement a solution using the two methods together. It is up to us to
    choose the solution that best fits the requirements in hand.
  prefs: []
  type: TYPE_NORMAL
- en: With Extension Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a further method of providing additional functionality to the developers
    of our application that was mentioned when investigating the application structures
    in the [Chapter 2](b799e8cf-97d3-44e5-927a-c02c42d343fc.xhtml), *Debugging WPF
    Applications*. It is through the use of Extension Methods. If you are not familiar
    with this amazing .NET feature, Extension Methods enable us to write methods that
    can be used on objects that we did not create.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, it's worth pointing out that we don't generally write Extension
    Methods for classes that we have declared. There are two main reasons for this.
    The first is that we created these classes and so we have access to their source
    code and can therefore simply declare new methods in these classes directly.
  prefs: []
  type: TYPE_NORMAL
- en: The second reason is that there will be a reference to our `Extensions` project
    added to most other projects, including our `DataModels` project, so that they
    can all take advantage of the extra capabilities. Therefore, we can't add references
    to any of our other projects into the `Extensions` project, because it would create
    circular dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are probably aware of Extension Methods already, although perhaps inadvertently,
    as most of the **LINQ** methods are Extension Methods. Once declared, they can
    be used just like the ordinary methods that were declared within the various classes
    that we are extending, although they are differentiated by having different icons
    in the Visual Studio IntelliSense display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b025a8dd-5545-49ef-9722-864eaca65af2.png)'
  prefs: []
  type: TYPE_IMG
- en: The basic principle when declaring them is to have a static class, where each
    method has an extra input parameter prefixed with the `this` keyword, that represents
    the object being extended. Note that this extra input parameter must be declared
    first in the parameter list and that it will not be visible in IntelliSense when
    calling the method on an instance of an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extension Methods are declared as static methods, but are typically called
    using instance method syntax. A simple example should help to clarify this situation.
    Let''s imagine that we want to be able to call a method on each item in a collection.
    In fact, we''ll see an example of this being used in our `BaseSynchronizableCollection`
    class later in this chapter, but now, let''s see how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see the `this` input parameter that specifies the instance of the
    target type that this Extension Method is called on. Remember that this won''t
    appear in the parameter list in IntelliSense in Visual Studio, unless it is called
    through the static class itself, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this method, we simply iterate through the collection items, calling
    the `Action` specified by the `action` input parameter and passing in each item
    as its parameter. After adding a `using` directive to the `CompanyName.ApplicationName.Extensions`
    namespace, let''s see how this method is more usually called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: So, you can now see the power of Extension Methods and the benefits that they
    can bring us. If some functionality that we want is not already provided by a
    certain class in the .NET Framework, then we can simply add it. Take this next
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an Extension Method that has been sorely missed from the existing LINQ
    Extension Methods. As with the other LINQ methods, this one also works on the
    `IEnumerable<T>` interface and, therefore, also any collection that extends it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's first look at the declaration of this method. We can see that our source
    collection will be of type `TSource`. Note that this is exactly the same as if
    the generic type parameter were named `T`, like in our other examples, except
    that this provides a little more detail as to the use of this type parameter.
    This naming has come from the `Enumerable.OrderBy<TSource, TKey>` method, where
    type `TSource` parameter represents our source collection.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we notice that the method name is suffixed by two generic type parameters;
    first, the `TSource` parameter, and then the `TKey` parameter. This is because
    we require two generic type parameters for the input parameter of type `Func<TSource,
    TKey>`. If you're not familiar with the `Func<T, TResult>` delegate, as Microsoft
    calls it, it simply encapsulates any method that has a single input parameter
    of type `T` and returns a value of type `TResult`, or, in our case, `TKey`.
  prefs: []
  type: TYPE_NORMAL
- en: '"*Why are we using this* `Func<T, TResult>` *delegate*?", I hear you asking.
    Well, it''s simple really; using this class, we can provide the developers with
    an object of the same type as those in the source collection and the ability to
    select a member of that class, in particular, the property that they want to perform
    the distinct query on. Before looking at the rest of this method, let''s see it
    in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Let's envisage that we had a collection of `User` objects that had all purchased
    items. This collection could contain the same `User` object more than once, if
    they purchased more than one item. Now, let's imagine that we wanted to compile
    a collection of unique users from the original collection, so as not to send multiple
    bills to people that ordered multiple items. This method would return a single
    member for each distinct `Id` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring back to the source code for this method, the `User` class represents
    the `TSource` parameter and this is shown in the Lambda expression in the example
    as the `u` input parameter. The `TKey` parameter is determined by the type of
    the class member that is selected by the developer, in this case, by the `Guid`
    `Id` value. This example could be written slightly differently to make it clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So, our `Func<TSource, TKey>` can be seen here, with a `User` input parameter
    and a `Guid` return value. Now, let's focus on the magic of our method. We see
    a `HashSet` of type `Guid` in our case being initialized. This type of collection
    is essential to this method, as it allows only unique values to be added.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we iterate through our source collection, of type `User` in this case,
    and attempt to add the relevant property value of each item in the collection
    into the `HashSet`. In our case, we're adding the values of the identities of
    each `User` object into this `HashSet`.
  prefs: []
  type: TYPE_NORMAL
- en: If the identity value is unique and the `HashSet<T>.Add` method returns `true`,
    we yield, or return that item from our source collection. The second and each
    subsequent time that a used `Id` value is read, it is rejected. This means that
    only the first items with unique identity values are returned from this method.
    Note that in this example, we are not interested in the purchases, but in the
    unique users that made them.
  prefs: []
  type: TYPE_NORMAL
- en: We've now managed to create our very own LINQ-style Extension Method. However,
    not all of our Extension Methods need to be so ground breaking. Often, they can
    be used to simply encapsulate some commonly used functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a way, we can use them as simple convenience methods. Take a look at the
    following example that is used in the *With Converters* section later in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we attempt to get the `FieldInfo` object that relates to the
    instance of the relevant enumeration provided by the `value` input parameter.
    If the attempt fails, we simply return the name of the particular instance. If
    we succeed however, we then use the `GetCustomAttributes` method of that object,
    passing the type of the `DescriptionAttribute` class, to retrieve an array of
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: If we have declared a value in the `DescriptionAttribute` of this particular
    enumeration instance, then it will always be the first item in the attribute array.
    If we have not set a value, then the array will be empty and we return the name
    of the instance instead. Note that as we used the base `Enum` class in this method,
    we are able to call this method on any enumeration type.
  prefs: []
  type: TYPE_NORMAL
- en: When creating these methods, it should be noted that there is no requirement
    to put them into separate classes that are split by type, as we have done here.
    There are no specified naming conventions either and, in fact, it is also totally
    viable to put all of your Extension Methods into a single class. However, if we
    have a large number of Extension Methods of a particular type, then it can help
    with maintenance to have this separation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, let''s take a look at one final example of these Extension
    Methods. One of the most useful traits of an Extension Method is the ability to
    add new or missing functionality to existing classes from the .NET Framework.
    For example, let''s see how we can replicate Linq and define a simple `Count`
    method for the `IEnumerable` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, this method requires little explanation. It literally just counts
    the number of items in the `IEnumerable` collection and returns that value. As
    simple as it is, it proves to be useful, as we'll see in a later example. Now
    that we have investigated Extension Methods, let's turn our attention to another
    way of building further abilities into our framework, this time focusing on the
    Views component.
  prefs: []
  type: TYPE_NORMAL
- en: In UI controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One another common way to include functionality in an application framework
    is to encapsulate it into custom controls. In doing so, we can expose the required
    functionality using Dependency Properties, while hiding the implementation details.
    This is also another great way to promote reusability and consistency throughout
    the application. Let''s take a look at a simple example of a `UserControl` that
    wraps the functionality of the `System.Windows.Forms.FolderBrowserDialog` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This simple `UserControl` just contains a textbox with its `Text` property data
    bound to the `FolderPath` Dependency Property that is declared in our control's
    code behind. Remember that it is perfectly acceptable to use the code behind of
    a `UserControl` for this purpose when using MVVM. Note that we have used a `RelativeSource`
    binding here because nothing has been set to this control's `DataContext` property.
    We'll find out much more about data binding in [Chapter 4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml),
    *Becoming Proficient with Data Binding*, but for now, let's continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may notice that we have attached a handler for the `PreviewMouseLeftButtonUp`
    event in the code behind and as no business-related code is being used there,
    this is also perfectly acceptable when using MVVM. The only other notable code
    here is that we set the `Cursor` property to show an arrow when users mouse over
    our control. Let''s now take a look at the code behind of the  `UserControl` and
    see how the functionality is encapsulated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We start with our `using` directives and see an example of a using alias directive.
    In this case, we don't want to add a normal `using` directive for the `System.Windows.Forms`
    assembly because it contains many UI-related classes that have names that clash
    with those in the required `System.Windows` assembly.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid these conflicts, we can create an alias for the single type that we
    are interested in using from that assembly. To clarify, Microsoft decided not
    to reinvent the wheel, or, in this case, the `FolderBrowserDialog` control, in
    the `System.Windows` assembly, and so we need to add a reference to the `System.Windows.Forms`
    assembly and use the one from there.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at this class, we see that much of this code is taken up with the declarations
    of the Dependency Properties of the control. We have the `FolderPath` property
    that will hold the file path of the folder that is selected from the `Windows.Forms`
    control, and the `OpenFolderTitle` property that will populate the title bar of
    the `FolderBrowserDialog` window when displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the `TextBox_PreviewMouseLeftButtonUp` event handler that handles
    the `PreviewMouseLeftButtonUp` event of the single `TextBox` element in our control.
    In this method, we first verify that the user is not selecting text from, or scrolling,
    the `TextBox` control and then, if `true`, we call the `ShowFolderPathEditWindow`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: In order to verify that the user is not selecting text, we simply check the
    length of the `SelectedText` property of the `TextBox` control. In order to confirm
    that the user is not scrolling the `TextBox` control, we compare the relative
    horizontal position of the user's click with the length of the `TextBox` element
    minus the width of its vertical scroll bar to ensure that their mouse is not over
    the scroll bar, if present.
  prefs: []
  type: TYPE_NORMAL
- en: The `ShowFolderPathEditWindow` method first prepares to display the `Windows.Forms`
    control. It sets the `defaultFolderPath` variable to either the current value
    of the `FolderPath` property, if one is set, or the current user's `Documents`
    folder, using the `Environment.GetFolderPath` method and the `Environment.SpecialFolder.MyDocuments`
    enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: It then calls the `ShowFolderBrowserDialog` method to launch the actual `FolderBrowserDialog`
    control and retrieve the selected folder path. If a valid folder path is selected,
    we set its value to the data bound `FolderPath` property directly, but note that
    we could have set it in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: It would be very easy to add an `ICommand` property to our control in order
    to return the selected folder path instead of using this direct assignment. This
    could be useful in cases where we don't want the data bound value to be set instantly;
    for example, if the control was used in a child window that needed a confirmation
    button to be clicked before the data bound value could be updated.
  prefs: []
  type: TYPE_NORMAL
- en: The `ShowFolderBrowserDialog` method wraps the use of the `FolderBrowserDialog`
    class in a `using` statement, to ensure that it is disposed of, once it has been
    used. It utilizes the `defaultFolderPath` variable and the `OpenFolderTitle` property
    when setting up the actual `FolderBrowserDialog` control. Note that this `OpenFolderTitle`
    property is simply here to demonstrate how we can expose the required properties
    from the `FolderBrowserDialog` element in our control. In this way, we can encapsulate
    the use of the `Windows.Forms` control and assembly within our control.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we could have added extra Dependency Properties to enable the users
    of our framework to have further control over the settings in the `FolderBrowserDialog`
    control. In this basic example, we simply hardcoded a positive value for the `FolderBrowserDialog.ShowNewFolderButton`
    property, but we could have exposed that as another property.
  prefs: []
  type: TYPE_NORMAL
- en: We could have also added a browse button and maybe even a clear button to clear
    the selected folder value. We could have then added additional `bool` Dependency
    Properties to control whether those buttons should be displayed or not. There
    are many other ways that we could improve this control, but it still demonstrates
    how we can encapsulate functionality into our Views components. We'll see another
    View-related way to capture little snippets of functionality in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: With converters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Converters are yet another way that we can package up useful functionality in
    our framework. We've already seen a useful example of the `IValueConverter` interface
    in [Chapter 2](b799e8cf-97d3-44e5-927a-c02c42d343fc.xhtml), *Debugging WPF Applications*,
    but while that was a very simple example, converters can actually be very versatile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Long before Microsoft introduced their `BooleanToVisibilityConverter` class,
    developers had to create their own versions. We often need to convert the `UIElement.Visibility`
    enumeration to or from a variety of different types, and so it is a good idea
    to start with a `BaseVisibilityConverter` class that can serve multiple converter
    classes. Let''s see what that entails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This converter requires one value to represent the visible value and as there
    is only one corresponding value in the `UIElement.Visibility` enumeration, that
    will clearly be the `Visibility.Visible` instance. It also requires a single value
    to represent the invisible value.
  prefs: []
  type: TYPE_NORMAL
- en: As such, we declare the `FalseVisibility` enumeration with the two corresponding
    values from the `UIElement.Visibility` enumeration and the `FalseVisibilityValue`
    property to enable users to specify which value should represent the false state.
    Note that the most commonly used `Visibility.Collapsed` value is set as the default
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users can set the `FalseVisibilityState` property when using the control and
    this sets the protected `FalseVisibilityValue` property internally. Finally, we
    see the indispensable `IsInverted` property that is optionally used to invert
    the result. Let''s see what our `BoolToVisibilityConverter` class looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We start by specifying the data types involved in the implementation of the
    converter in the `ValueConversion` attribute. This helps tools to know what types
    are being used in the converter, but also makes it clear to the users of our framework.
    Next, we extend our `BaseVisibilityConverter` base class and extend the required
    `IValueConverter` interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Convert` method, we first check the validity of our `value` input parameter,
    if valid, we convert it to a `bool` variable, taking the `IsInverted` property
    setting into consideration. We return the `DependencyProperty.UnsetValue` value
    for invalid input values. Finally, we resolve the output value from this `bool`
    variable to either the `Visibility.Visible` instance, or the value of the `FalseVisibilityValue`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ConvertBack` method, we also check the validity of our `value` input
    parameter first. We return the `DependencyProperty.UnsetValue` value for invalid
    input values again, otherwise we output a `bool` value that specifies whether
    the input parameter of type `Visibility` is equal to the `Visibility.Visible`
    instance, while again taking the value of the `IsInverted` property into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that use of the `IsInverted` property enables users to specify that elements
    should become visible when the data bound `bool` value is `false`. This can be
    incredibly useful when we want to have one object visible upon a certain condition
    and another object hidden dependent upon the same condition. We can declare two
    converters from this class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As stated, we often need to convert to and from the `UIElement.Visibility`
    enumeration from a variety of different types. Let''s now look at an example of
    a conversion to and from the `Enum` type. The principle is the same as the last
    example, where a single data bound value represents the `Visibility.Visible` instance
    and all other values represent the hidden or collapsed state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Again, we start by specifying the data types involved in the implementation
    of the converter in the `ValueConversion` attribute. In the `Convert` method,
    we first check the validity of our `value` input parameter, if valid, we convert
    it to the `string` representation of the value. This particular class uses the
    `parameter` input parameter to pass the specified enumeration instance that will
    represent the visible value, and so it is set to the `targetValue` variable as
    a `string`.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a `bool` value by comparing the current enumeration instance
    with the target instance. Once we have our `bool` value, the last two lines replicate
    those in the `BoolToVisibilityConverter` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `ConvertBack` method implementation is somewhat different. Logically speaking,
    we are unable to return the correct enumeration instance for a hidden visibility,
    as it could be any value except the visible value passed through the `parameter`
    input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: As such, we are only able to return that specified value if the element is visible
    and the `IsInverted` property is `false`, or if it is not visible and the `IsInverted`
    property is `true`. For all other input values, we simply return the `DependencyProperty.UnsetValue`
    property to state that there is no value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another incredibly useful thing that converters can do is to convert individual
    enumeration instances to particular images. Let''s look at an example that relates
    to our `FeedbackManager`, or, more accurately, the `Feedback` objects that get
    displayed. Each `Feedback` object can have a particular type that is specified
    by the `FeedbackType` enumeration, so let''s look at that first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this work, we obviously need a suitable image for each enumeration
    instance, except for the `None` instance. Our images will reside in a folder named
    Images in the root folder of the startup project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we start by specifying the data types involved in the converter
    in the `ValueConversion` attribute. In the `Convert` method, we use C# 6.0 Pattern
    Matching to check the validity of our `value` input parameter and to cast it to
    a `FeedbackType` instance, if valid. We then use that in a `switch` statement,
    to generate the relevant image name for each enumeration instance.
  prefs: []
  type: TYPE_NORMAL
- en: If an unknown instance is used, we return the `DependencyProperty.UnsetValue`
    value. In all other cases, we use String Interpolation to build up the full file
    path of the relevant image and then return it from the converter as the converted
    value. As the `ConvertBack` method in this converter has no valid use, it is not
    implemented and simply returns the `DependencyProperty.UnsetValue` value.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we specified type `ImageSource` in the `ValueConversion`
    attribute, but we returned a `string`. This is possible because XAML uses the
    relevant type converter to convert the `string` into an `ImageSource` object automatically
    for us. Exactly the same thing occurs when we set an `Image.Source` property with
    a `string` in XAML.
  prefs: []
  type: TYPE_NORMAL
- en: As with other parts of our framework, we can make our converters even more useful,
    when we combine functionality from other areas. In this particular example, we
    utilize one of the Extension Methods that was shown earlier in this chapter. To
    remind you, the `GetDescription` method will return the value of the `DescriptionAttribute`
    that is set on each enumeration instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DescriptionAttribute` enables us to associate any `string` value with
    each of our enumeration instances, so this is a great way to output a user-friendly
    description for each instance. An example of this would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, instead of displaying the names of the instances in a `RadioButton`
    control, for example, we could display the more humanized descriptions from these
    attributes. Let''s have a look at this converter class now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As we're now accustomed to doing, we start by specifying the data types used
    in the converter in the `ValueConversion` attribute. In the `Convert` method,
    we again check the validity of our `value` input parameter and return the `DependencyProperty.UnsetValue`
    value if it is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: If it is valid, we cast it to a `Enum` instance and then use the power of our
    Extension Method to return the value from each instance's `DescriptionAttribute`.
    In doing so, we are able to expose this functionality to our Views and to enable
    the users of our framework to utilize it directly from the XAML. Now that we have
    a general understanding of the various ways that we can encapsulate functionality
    into our framework, let's focus on starting construction of our base classes.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a custom application framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There will be different requirements for different components, but typically,
    the properties and functionality that we build into our Data Model base classes
    will be utilized and made more useful by our other base classes, so let's start
    by looking at the various Data Model base classes first.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that we need to decide is whether we want any of our Data Model base
    classes to be generic or not. The difference can be subtle, but important. Imagine
    that we want to add some basic undo functionality into a base class. One way that
    we can achieve this would be to add an object into the base class that represents
    the unedited version of the Data Model. In an ordinary base class, it would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In a generic base class, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this property more useful, we''ll need to add some further methods.
    First, we''ll see the non-generic versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at the generic versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The last few members of this base class would be the same for both versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We started with the `OriginalState` property which holds the unedited version
    of the Data Model. After that, we see the abstract `CopyValuesFrom` method that
    the developers will need to implement and we'll see an example of that implementation
    shortly. The `Clone` method simply calls the `CopyValuesFrom` method in order
    to perform a deep clone of the Data Model.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the abstract `PropertiesEqual` method that the developers will
    need to implement in order to compare each property in their classes with those
    from the `dataModel` input parameter. Again, we'll see this implementation shortly,
    but you may be wondering why we don't just override the `Equals` method, or implement
    the `IEquatable.Equals` method for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why we don't want to use either of those methods is because they,
    along with the `GetHashCode` method, are used by the WPF Framework in various
    places and they expect the returned values to be immutable. As our object's properties
    are very much mutable, they cannot be used to return the values for those methods.
    Therefore, we have implemented our own version. Now, let's return to the description
    of the remainder of this code.
  prefs: []
  type: TYPE_NORMAL
- en: The `HasChanges` property is the property that we would want to data bind to
    a UI control to indicate whether a particular object had been edited. The `Synchronize`
    method sets a deep clone of the current Data Model to the `originalState` field
    and, importantly, notifies the WPF Framework of a change to the `HasChanges` property.
    This is done because the `HasChanges` property has no setter of its own and this
    operation will affect its value.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important that we set a cloned version to the `originalState` field,
    rather than simply assigning the actual object reference to it. This is because
    we need to have a completely separate version of this object to represent the
    unedited version of the Data Model. If we simply assigned the actual object reference
    to the `originalState` field, then its property values would change along with
    the Data Model object and render it useless for this feature.
  prefs: []
  type: TYPE_NORMAL
- en: The `RevertState` method first checks that the Data Model has been synchronized
    and then copies the values back from the `originalState` field to the Model. Finally,
    it calls the `Synchronize` method to specify that this is the new, unedited version
    of the object and notifies the WPF Framework of a change to the `HasChanges` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as you can see, there are not many differences between these two versions
    of the base class. In fact, the differences can be seen more clearly in the implementation
    of the derived classes. Let''s now focus on their implementations of the example
    abstract methods, starting with the non-generic versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Before discussing this code, let''s first see the generic implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: At last, we can see the difference between using generic and non-generic base
    classes. Without using generics, we have to use base class input parameters, which
    will need to be cast to the appropriate type in each of the derived classes before
    we can access their properties. Attempting to cast inappropriate types causes
    Exceptions, so we generally try to avoid these situations.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when using a generic base class, there is no need to cast,
    as the input parameters are already of the correct type. In short, generics enable
    us to create type-safe Data Models and avoid duplicating type specific code. Now
    that we have seen the benefit of using generic classes, let's take a pause from
    generics for a moment and look at this base class a bit closer.
  prefs: []
  type: TYPE_NORMAL
- en: Some of you may have noticed that the only places where the WPF Framework is
    notified of changes to our `HasChanges` property is in the `Synchronize` and `RevertState`
    methods. However, in order for this functionality to work properly, we need to
    notify the framework every time the values of any properties are changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could rely on the developers to call the `NotifyPropertyChanged` method,
    passing the `HasChanges` property name each time they call it for each property
    that changes, but if they forgot to do this, it could lead to errors that could
    be difficult for them to track down. Instead, a better solution would be for us
    to override the default implementation of the `INotifyPropertyChanged` interface
    from the base class and notify changes to the `HasChanges` property for them each
    time it is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The first method will raise the `PropertyChanged` event, passing the name of
    the `HasChanges` property just once, regardless of how many property names were
    passed to the method. The second method also performs a check to ensure that it
    will refrain from raising the event with the `HasChanges` property name more than
    once, so these implementations remain efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our base class will work as expected and the `HasChanges` property will
    correctly update when other properties in the Data Model classes are changed.
    This technique can also be utilized in other scenarios; for example, when validating
    our property values, as we'll see later in [Chapter 9](549ddd97-63f4-4e6c-8df3-6455ede31a4c.xhtml),
    *Implementing Responsive Data Validation*. For now though, let's return to see
    what else we can achieve with generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another area where generics are often used relates to collections. I''m sure
    that you''re all aware that we tend to use the `ObservableCollection<T>` class
    in WPF applications because of its `INotifyCollectionChanged` and `INotifyPropertyChanged`
    implementations. It is customary, but not essential, to extend this class for
    each type of Data Model class that we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'However, instead of doing this, we can declare a `BaseCollection<T>` class
    that extends the `ObservableCollection<T>` class and adds further functionality
    into our framework for us. The users of our framework can then extend this class
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'One really useful thing that we can do is to add a generic property of type
    `T` into our base class, that which will represent the currently selected item
    in a data bound collection control in the UI. We could also declare some delegates
    to notify developers of changes to either selection or property values. There
    are so many shortcuts and helper methods that we can provide here, dependent on
    requirements, so it''s worth spending some time investigating this. Let''s take
    a look at a few possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: There's quite a lot to digest here, so let's go over each part carefully. We
    start with our private member of type `T` that will back our `CurrentItem` property.
    We then find a few overloads of the constructor that enable us to initialize our
    collection from either a collection, or any number of input parameters of the
    relevant type.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the `CurrentItem` property from [Chapter 1](b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml),
    *A Smarter Way of Working with WPF*, again, but now with some further context.
    If a class has subscribed to the `CurrentItemChanged` property, we will call the
    delegate from here, passing both the new and old values of the current item. The
    `IsEmpty` property is just an efficient convenience property for our developers
    to call when they need to know whether the collection has any content or not.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we see the collection delegates and the relevant property wrappers
    that enable the developers that will use our framework to make use of them. Next,
    we see the convenient `GetNewItem` and `AddEmptyItem` methods, which both generate
    a new item of the `T` generic type parameter, before returning or adding them
    to the collection, respectively. This is the reason that we needed to add the
    `new()` generic type constraint to the class definition; this type constraint
    specifies that the generic type used must have a parameterless constructor.
  prefs: []
  type: TYPE_NORMAL
- en: And now we reach the various `Add` methods of the collection; note that every
    way to add an item to the collection must be handled, so that we can attach our
    `Item_PropertyChanged` handler to the `PropertyChanged` event of each added item
    to ensure consistent behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We therefore call our `Add` methods from all other overloads and helper methods
    and call the base `Collection.Add` method from there. Note that we actually attach
    our handler inside the protected `InsertItem` method, as this overridden method
    is called from the `Add` methods in the `Collection` class.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, the protected `SetItem` method will be called by the `Collection`
    class when items are set using the index notation, so we must handle that too.
    Similarly, when items are removed from the collection, it is equally, if not more,
    important to remove the reference to our event handler from each object. Failing
    to do so can result in memory leaks, as the reference to the event handler can
    keep the Data Model objects from being disposed by the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: As such, we also need to handle every method of removing objects from our collection.
    To do this, we override a few more protected methods from the `Collection` base
    class. The `ClearItems` method will be called internally when users call the `Clear`
    method on our collection. Equally, the `RemoveItem` method will be called when
    users call any of the public removal methods, so it is the optimal place to remove
    our handler.
  prefs: []
  type: TYPE_NORMAL
- en: Skipping the `ResetCurrentItemPosition` method for now, at the bottom of the
    class, we reach the `Item_PropertyChanged` event handling method. If the item
    that has had the property changed is the current item in the collection, then
    we raise the `ItemPropertyChanged` delegate that is connected with the `CurrentItemPropertyChanged`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: For every property change notification, regardless of whether the item is the
    current item or not, we then raise the `INotifyPropertyChanged.PropertyChanged`
    event. This enables developers that use our framework to be able to attach a handler
    to the `PropertyChanged` event directly on our collections and to be able to discover
    when any property has been changed on any of the items in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: You may also have noticed a few places in the collection class code where we
    set the value of the `CurrentItem` property. The option chosen here is to always
    select the first item in the collection automatically, but it would be a simple
    change to have the last item selected instead, for example. As always, these kinds
    of details will depend on your specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of declaring these base collection classes is that we can utilize
    the properties and extend the functionality that is built into our base Data Model
    classes. Thinking back to the simple example of our `BaseSynchronizableDataModel`
    class, let's see what we could add into a new base collection class to improve
    this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can do this however, we need to be able to specify that the objects
    in our new collection have implemented the properties and methods from the `BaseSynchronizableDataModel`
    class. One option would be to declare our new collection class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in C#, we can only extend a single base class, while we are free to
    implement as many interfaces as we like. A more preferable solution would therefore
    be for us to extract the relevant synchronization properties from our base class
    into an interface, and then add that to our base class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then specify this new generic constraint on our new collection class
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that any other generic constraints that are placed on the `BaseSynchronizableDataModel`
    class will also need to be added to the `where T` part of this declaration. If,
    for example, we needed to implement another interface in the base class and we
    did not add the same constraint for the `T` generic type parameter in the base
    collection class, then we would get a compilation error when attempting to use
    instances of our base class as the `T` parameter. Let''s now look at this new
    base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: While remaining simple, this base collection class provides some powerful functionality.
    We start off with the class declaration, with its generic type constraints that
    are inherited from both our target `T` type classes and our `BaseCollection<T>`
    class. We've then implemented the constructor overloads and passed initialization
    duties straight to the base class.
  prefs: []
  type: TYPE_NORMAL
- en: Note that had we wanted to attach an additional level of event handlers to our
    collection items, we would follow the pattern from the base class, rather than
    calling the base class constructors in this way.
  prefs: []
  type: TYPE_NORMAL
- en: The `HasChanges` property can be used as a flag to detect whether any item in
    the collection has any changes or not. This would typically be tied to the `canExecute`
    parameter of a save command, so that the save button would become enabled when
    any item in the collection had been edited and disabled if the changes were undone.
  prefs: []
  type: TYPE_NORMAL
- en: The `AreSynchronized` property simply specifies whether the items in the collection
    have all been synchronized or not, but the real beauty of this class is in the
    `ChangedCollection` property. Using a simple LINQ filter, we return only the items
    from the collection that have changes. Imagine a scenario where we enable the
    user to edit multiple items at once. With this property, our developers could
    extract just the items that they need to save from the collection with zero effort.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this class provides one method to enable the synchronization of all
    of the items in the collection at once and another to undo the changes of all
    of the edited items in the collection likewise. Note the use of the custom `ForEach` Extension
    Method in these last two methods; if you remember from the earlier *With Extension
    Methods* section, it enables us to perform an action on each item in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Through the use of the properties and methods of our Data Model base classes
    by other parts of our framework, we are able to extend their functionality further.
    While building composite functionality from different components in this way is
    generally optional, it can also be necessary, as we'll see later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: The more common functionality that we can build into our application framework
    base classes, the less work the developers that use our framework will have to
    do when developing the application. However, we must plan carefully and not force
    the developers to have unwanted properties and methods in order to extend a particular
    base class that has some other functionality that they do want.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, there will be different requirements for different components. The
    Data Model classes will generally have more base classes than View Models because
    they play a bigger role than View Models. The View Models simply provide the Views
    with the data and functionality that they require. However, the Data Model classes
    contain the data, along with validation, synchronization, and possibly animation
    methods and properties. With this in mind, let's look again at the View Model
    base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen that we will need an implementation of the `INotifyPropertyChanged`
    interface in our base class, *but what else should we implement?* If every View
    will be providing some specific functionality, such as saving and deleting items
    for example, then we can also add commands straight into our base class and abstract
    methods that each derived View Model class will have to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, it is important to declare this command as being virtual, in case the
    developers need to provide their own, different implementation of it. An alternative
    to this arrangement would be to just add abstract properties for each command,
    so that the individual implementations would be completely up to the developers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: While on the subject of commands, you may remember our basic implementation
    of `ActionCommand` from [Chapter 1](b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml),
    *A Smarter Way of Working with WPF*. At this point, it is worth taking a short
    detour to investigate this further. Note that while the basic implementation shown
    works well most of the time, it can catch us out occasionally and we may notice
    that a button hasn't become enabled when it should have.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example of this. Imagine that we have a button in our UI that
    opens a folder for the user to view files from and is enabled when a certain condition
    is met in the `ICommand.CanExecute` method. Let's say that this condition is that
    the folder should have some content. After all, there's no point in opening an
    empty folder for the user.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's imagine that this folder will be filled when the user performs some
    other operation in the UI. The user clicks the button that starts this folder-filling
    function and the application begins to fill it. At the point that the filling
    function is complete and the folder now holds some content, the open folder button
    should become enabled, as its associated command's `CanExecute` condition is now
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, the `CanExecute` method won't be called at that point and why
    should it? The button and, indeed, the `CommandManager` class has no idea that
    this background process was occurring and that the condition of the `CanExecute`
    method has now been met. Luckily, we have a couple of options to address this
    situation.
  prefs: []
  type: TYPE_NORMAL
- en: One option is to raise the `CanExecuteChanged` event manually to make the data
    bound command sources recheck the output of the `CanExecute` method and update
    their enabled state accordingly. To do this, we could add another method into
    our `ActionCommand` class, but we would have to rearrange a few things first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current implementation doesn''t store any references to the event handlers
    that get attached to the `CanExecuteChanged` event. They''re actually being stored
    in the `CommandManager` class, as they''re just passed straight through for the
    `RequerySuggested` event to handle. In order to be able to raise the event manually,
    we''ll need to store our own references to the handlers and, to do that, we''ll
    need an `EventHandler` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll need to add the references to the handlers that get attached and
    remove those that get detached, while still passing references of them through
    to the `RequerySuggested` event of the `CommandManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The final change to our `ActionCommand` class is to add the method that we
    can call to raise the `CanExecuteChanged` event when we want the command sources
    of the UI controls to retrieve the new `CanExecute` value and update their enabled
    states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now able to raise the `CanExecuteChanged` event whenever we need to,
    although we''ll also need to change our use of the `ActionCommand` class to do
    so. Whereas previously, we were simply returning a new instance each time its
    getter was called, we''ll now need to keep a reference to each command that we
    want to have this ability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are unfamiliar with the `??` operator shown in the preceding code, it
    is known as the **null-coalescing operator** and simply returns the left-hand
    operand if it is not `null`, or the right-hand operand if it is. In this case,
    the right-hand operand will initialize the command and set it to the `saveCommand`
    variable. Then, to raise the event, we call the new `RaiseCanExecuteChanged` method
    on our `ActionCommand` instance when we have completed our operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: While our method is built into the `ActionCommand` class, at times we may not
    have access to the particular instance that we need to raise the event on. It
    should therefore be noted at this point that there is another, more direct way
    that we can get the `CommandManager` class to raise its `RequerySuggested` event.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, we can simply call the `CommandManager.InvalidateRequerySuggested`
    method. We should also be aware that these methods of raising the `RequerySuggested`
    event will only work on the UI thread, so care should be taken when using them
    with asynchronous code. Now that our short command-related detour is complete,
    let's return to take a look at what other common functionality we might want to
    put into our View Model base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have chosen to use generic base classes for our Data Models, then we
    can take advantage of that in our `BaseViewModel` class. We can provide generic
    methods that utilize members from these generic base classes. Let''s take a look
    at some simple examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see three simple methods that encapsulate more common functionality.
    Note that we must specify the same generic type constraints that are declared
    on our bass classes. Failure to do so would either result in compilation errors
    or us not being able to use our Data Model classes with these methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `AddNewDataTypeToCollection` and `InsertNewDataTypeToCollection` methods
    are almost identical and start by creating a new item of the relevant type using
    the `GetNewItem` method of our generic `BaseSynchronizableCollection` class. Next,
    we see another use for our `IAuditable` interface. In this case, we set the `CreatedOn`
    date of the new item if it implements this interface.
  prefs: []
  type: TYPE_NORMAL
- en: Because we declared the generic type constraint on the `T`-type parameter that
    specifies that it must be, or extend, the `BaseSynchronizableDataModel` class,
    we are able to call the `Synchronize` method to synchronize the new item. We then
    add the item to the collection and set it as the value of the `CurrentItem` property.
    Finally, both methods return the new item.
  prefs: []
  type: TYPE_NORMAL
- en: The last method performs the opposite action; it removes an item from the collection.
    Before doing so, it checks the item's position in the collection and sets the
    `CurrentItem` property to the next item if possible, or the next nearest item
    if the removed item was the last item in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we see how we can encapsulate commonly used functionality into our
    base class and save the users of our framework both time and effort in reimplementing
    this functionality in each View Model class. We can package up any common functionality
    that we require in this manner. Having now seen several examples of providing
    functionality in our base classes, let's now turn our attention to providing separation
    between the components of our framework.
  prefs: []
  type: TYPE_NORMAL
- en: Separating the Data Access Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve had a look at providing a variety of functionality through
    our base classes and interfaces, let''s investigate how we can provide the Separation
    of Concerns that is crucial when using the MVVM pattern. Once again, we turn to
    the humble interface to help us achieve this. Let''s view a simplified example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We start off with a very simple interface. Of course, real applications will
    have a great many more methods than this, but the principle is the same, regardless
    of the complexity of the interface. So here, we just have a `GetUser` and a `SaveUser`
    method that our `DataProvider` classes need to implement. Now, let''s look at
    the `ApplicationDataProvider` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This `ApplicationDataProvider` class uses some simple LINQ to SQL to query
    and update a database for the `User` specified by the `id` value provided. That
    means that this particular implementation of the interface requires a connection
    to a database. We want to avoid having this dependency when testing our application,
    so we''ll need another implementation of the interface to use for testing purposes.
    Let''s take a look at our mock implementation now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In this `MockDataProvider` implementation of the `IDataProvider` interface,
    we can see that the data is just manually mocked. In fact, it just returns the
    one single `User` from the `GetUser` method and always returns `true` from the
    `SaveUser` method, so it's fairly useless.
  prefs: []
  type: TYPE_NORMAL
- en: In a real-world application, we would either utilize a mocking framework, or
    manually mock up some more substantial testing data. Still, this will suffice
    for the point that we are focusing on here. Now that we've seen the classes involved,
    let's look at how they might be used.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that we have some sort of `DataController` class or classes that
    sit between the `IDataProvider` interface and the View Model classes. The View
    Model classes request data from the `DataController` class and, in turn, it requests
    data through the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'It therefore mirrors the methods of the interface and typically introduces
    some extra functionality, such as feedback handling for example. Let''s see what
    our simplified `DataController` class looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `DataController` class has a private member variable of
    type `IDataProvider`, which is populated in its constructor. It is this variable
    that is used to access the application data source. When the application is running,
    an instance of our `ApplicationDataProvider` class is used to instantiate the
    `DataController` class, and so our actual data source is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when we are testing our application, we can use an instance of our
    `MockDataProvider` class to instantiate the `DataController` class instead, thereby
    eliminating our dependency on the actual data source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In this way, we can swap out the code that provides the data for the View Models,
    while keeping the rest of the code unchanged. This enables us to test the code
    in the View Models without having to be connected to our actual data storage device.
    In the next section, we'll see better ways to initialize these classes, but for
    now, let's see what else our `DataController` class could do for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interfaces become more useful when they are used by parts of the application
    framework, other than the implementing classes. Apart from than defining some
    auditing properties and having the possibility of outputting their values, our
    earlier `IAuditable` interface example is not overly useful. We could however,
    extend its functionality further in our `DataController` class by automatically
    updating its values. We''ll need to add some more members to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We first need to add a property of type `User` that we will use to set the
    value of the current user of the application. This can be set as new users login
    to the application. Next, we need a method to update the "*updated*" values of
    our `IAuditable` interface. Again, we add a generic type constraint to ensure
    that only objects that implement our interface can be passed into this method.
    The result of this is that the developers that use our application framework can
    easily update these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We could add a similar method to set the "*created*" audit properties when
    adding new objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing this example, we could extend the constructor of our `DataController`
    class to accept a `User` input parameter that we can use to set our `CurrentUser`
    property with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then expose our data source to our View Models through their base
    class using a `CurrentUser` property in the `StateManager` class and the `DependencyManager`
    class that we''ll see in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, anything, that we need to do to the data coming from our application
    data source can be achieved in a single `DataController` class. However, if we
    require several different modifications, then we could alternatively create several
    controller classes and chain them together, with each performing their separate
    tasks in turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'As they could all implement the same methods, they could all potentially implement
    the same interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23988467-63fb-4345-b6a8-a037bc9ad54c.png)'
  prefs: []
  type: TYPE_IMG
- en: We'll see an example of this in [Chapter 10](506906a3-83cb-4b51-9ac5-3c00e650198a.xhtml),
    *Completing That Great User Experience*, but now that we have a good idea on how
    best to setup our application data source connections to provide the separation
    required by the MVVM pattern, we can focus on the next way of building functionality
    into our framework. Let's move on to discover how we can plug more complex and/or
    specialized functionality into our framework.
  prefs: []
  type: TYPE_NORMAL
- en: Providing services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The job of the base classes and interfaces in our application framework are
    to encapsulate functionality that is commonly used by our View Models and Data
    Models. When the required functionality is more complex, or when it involves particular
    resources, or external connections, we implement it in separate service, or manager
    classes. For the remainder of this book, we will refer to these as manager classes.
    In larger applications, these are typically provided in a separate project.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating them in a separate project enables us to reuse the functionality
    from these classes in our other applications. Which classes we use in this project
    will depend on the requirements of the application that we're building, but it
    will often include classes that provide the ability to send emails, to access
    the end user's hard drive, to export data in various formats, or to manage global
    application state for example.
  prefs: []
  type: TYPE_NORMAL
- en: We will investigate a number of these classes in this book, so that we have
    a good idea of how to implement our own custom manager classes. The most commonly
    used of these classes can normally be accessed directly from the base View Model
    class via properties. There are a few different ways that we can expose these
    classes to the View Models, so let's examine them.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a manager class is used often, and for short durations each time, we can
    expose a new instance of them each time, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if a manager class is required for the life of the application because
    it must remember a particular state or configuration, for example, then we typically
    use the `static` keyword in one way or another. The simplest option would be to
    declare a normal class, but expose it via a static property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: An alternative method of having one and only one instance of a class being instantiated
    and having it stay alive for as long as the application is running is for us to
    use the Singleton pattern. While it was all the rage twenty or so years ago, it
    has unfortunately recently fallen foul of more modern programming principles,
    such as the likes of SOLID, which states that each class should have a single
    responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Singleton pattern breaks this principle as it serves whatever purpose we
    design it for, but it is also responsible for instantiating itself and maintaining
    a single access point. Before discussing the merits and pitfalls of this pattern
    further, let''s take a look at how we might implement it in our manager class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Note that it can be implemented in a variety of ways, but this particular way
    uses lazy initialization, where the instance is not instantiated until it is first
    referenced via the `Instance` property. Using the `??` operator again, the `Instance`
    property getter can be read as "return the one and only instantiated instance
    if it is not `null`, or, if it is, instantiate the one and only instance and then
    return it." The significant part of this pattern is that as there is no public
    constructor and, therefore, the class cannot be externally instantiated, this
    property is the sinlgle way to access the internal object.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this is the very part that causes trouble for some developers, as
    this makes inheritance impossible with these classes. In our case though, we won''t
    need to extend our `StateManager` class, so that is not a concern for us. Others
    may point to the problem that exposing this Singleton class, as shown in the following
    code, will tightly couple it to the base View Model class that it is declared
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: While this is true, what harm is that with this class? Its purpose is to maintain
    the state of user settings, common or default values, and values for UI display
    and operation statuses. It contains no resources and no real reason to avoid using
    it when running unit tests, so in this case, the tight coupling is inconsequential.
    In this regard, the Singleton pattern continues to be a useful tool in the right
    situations, but we should certainly be aware of its pitfalls all the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if a particular manger class does utilize resources or creates some
    form of connection with the outside world, for example, like an `EmailManager`
    would, then we will need to create an interface for it to maintain our Separation
    of Concerns. Remember that interfaces enable us to disconnect the actual application
    components and replace them with mock components while testing. In these cases,
    we have to expose the functionality in the base classes slightly differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The general idea here is for us to have no direct contact with the manager class
    in hand, instead accessing its functionality through the interface methods and
    properties. By doing this, we are able to decouple the manager class from the
    View Models that use it and therefore enable them to be used independently of
    each other. Note that this is a very simple example of Dependency Injection.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency injection is a well-known design pattern that aids in decoupling
    various components of an application. If one class uses another class to perform
    some functionality internally, then the class that is internally used becomes
    a dependency of the class that uses it. It cannot achieve its objectives without
    it. In some cases, this is not a problem, but in others, it can represent a huge
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's imagine that we have a `FeedbackManager` class that is responsible
    for providing operational feedback to the end users. In that class, we have a
    `FeedbackCollection` instance that holds the `Feedback` objects that are currently
    being displayed to the current user. Here, the `Feedback` objects are a dependency
    of the `FeedbackCollection` instance and that, in turn, is a dependency of the
    `FeedbackManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: These objects are all tightly coupled, which is usually a bad thing in software
    development. However, they are also tightly related by necessity. A `FeedbackCollection`
    object would be useless without the `Feedback` objects, as would the `FeedbackManager`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: In this particular case, these objects require this coupling to make them useful
    together. This is called composition, where the individual parts form a whole,
    but do little on their own, so it really is no problem for them to be connected
    in this way.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, let's now contemplate the connection between our View Models
    and our DAL. Our View Models will definitely need access to some data, so it would
    at first seem to make sense to encapsulate a class in our View Models that provides
    the data that it requires.
  prefs: []
  type: TYPE_NORMAL
- en: While that would certainly work, it would unfortunately result in the DAL class
    becoming a dependent of the View Model class. Moreover, it would permanently couple
    our View Model component to the DAL and break the Separation of Concerns that
    MVVM provides. The kind of connection that we require in this situation is more
    like aggregation, where the individual parts are useful on their own.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, we want to be able to use the individual components separately
    and to avoid any tight coupling between them. Dependency Injection is a tool that
    we can use to provide this separation for us. In the absolute simplest terms,
    Dependency Injection is implemented through the use of interfaces. We've already
    seen some basic examples of this in the `DataController` class from the *Separating
    the Data Access Layer* section, and the `EmailManager` example from the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, they were very basic examples and there are a variety of ways of improving
    them. Many application frameworks will provide the ability for developers to use
    Dependency Injection to inject the dependencies into their classes and we can
    do the same with ours. In its simplest form, our `DependencyManager` class will
    simply need to register the dependencies and provide a way to resolve them when
    required. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that we are using the Singleton pattern again for this
    class. In this case, it again fits our requirements exactly. We want one, and
    only one, instance of this class to be instantiated and we want it to stay alive
    for as long as the application is running. When testing, it is used to inject
    our mock dependencies into the View Models, so it is part of the framework that
    enables our Separation of Concerns.
  prefs: []
  type: TYPE_NORMAL
- en: The `Count` property and the `ClearRegistrations` method are more useful for
    testing than when running the application and the real action goes on in the `Register`
    and `Resolve` methods. The `Register` method registers the interface type represented
    by the `S` generic type parameter, with the concrete implementation of that interface
    represented by the `T` generic type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: As the `S` generic type parameter must be an interface, an `ArgumentException`
    is thrown at runtime if the type parameter class supplied is not one. A further
    check is performed to ensure that the type specified by the `T` generic type parameter
    actually implements the interface specified by the `S` generic type parameter,
    and a further `ArgumentException` is thrown if the check fails.
  prefs: []
  type: TYPE_NORMAL
- en: The method then verifies the fact that the type parameter provided is not already
    in the `Dictionary` and adds it if it is unique in the collection. Therefore,
    in this particular implementation, we can only specify a single concrete implementation
    for each supplied interface. We could change this to either update the stored
    reference if an existing type was passed again, or even to store multiple concrete
    types for each interface. It all depends on the application requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Note the generic type constraint declared on this method that ensures that the
    type parameters will at least be classes. Unfortunately, there is no such constraint
    that would allow us to specify that a particular generic type parameter should
    be an interface. However, this type of parameter validation should be used where
    possible, as it helps the users of our framework to avoid using these methods
    with inappropriate values.
  prefs: []
  type: TYPE_NORMAL
- en: The `Resolve` methods use some simple reflection to return the concrete implementations
    of the interface types represented by the generic type parameters used. Again,
    note the generic type constraints declared by these two methods, that specify
    that the type used for type `T` parameter must be a class. This is to prevent
    the `Activator.CreateInstance` methods from throwing an `Exception` at runtime,
    if a type that could not be instantiated were used.
  prefs: []
  type: TYPE_NORMAL
- en: The first overload can be used for classes without any constructor parameters,
    and the second has an additional `params` input parameter to pass the parameters
    to use when instantiating classes that require constructor parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DependencyManager` class can be set up during application startup, using
    the `App.xaml.cs` file. To do this, we first need to find the following `StartupUri`
    property setting in the `Application` declaration at the top of the `App.xaml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to replace this `StartupUri` property setting with the following
    `Startup` property setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `App_Startup` is the name of the initialization method that
    we want to be called at startup. Note that as the WPF Framework is no longer starting
    the `MainWindow` class, it is now our responsibility to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'When we want to inject these dependencies into a View Model in the application
    at runtime, we could use the `DependencyManager` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The real beauty of this system is that when testing our View Models, we can
    register our mock manager classes instead. The same preceding code will then resolve
    the interfaces to their mock concrete implementations, thereby freeing our View
    Models from their actual dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve now seen the code that enables us to swap out our dependent classes
    with mock implementations when we are testing our application. However, we''ve
    also seen that not all of our manager classes will require this. So, what exactly
    represents a dependency? Let''s take a look at a simple example involving a UI
    popup message box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have an interface that declares a single method. This is the method
    that the developers will call from the View Model classes when they need to display
    a message box in the UI. It will use a real `MessageBox` object during runtime,
    but that uses a number of enumerations from the `System.Windows` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: We want to avoid interacting with these enumeration instances in our View Models,
    as that will require adding a reference to the `PresentationFramework` assembly
    and tie our View Models to part of our Views component.
  prefs: []
  type: TYPE_NORMAL
- en: We therefore need to abstract them from our interface method definition. In
    this case, we have simply replaced the enumerations from the `PresentationFramework`
    assembly with custom enumerations from our domain that merely replicate the original
    values. As such, there is little point in showing the code for these custom enumerations
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it''s never a good idea to duplicate code, it''s an even worse idea to
    add a UI assembly like the `PresentationFramework` assembly to our `ViewModels`
    project. By encapsulating this assembly within the `Managers` project and converting
    its enumerations, we can expose the functionality that we need from it without
    tying it to our View Models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: We start with our `using` directives and see further examples of using alias
    directives. In this case, we created some enumeration classes with the same names
    as those from the `System.Windows` namespace. To avoid the conflicts that we would
    have caused by adding a standard `using` directive for our `CompanyName.ApplicationName.DataModels.Enums`
    namespace, we add aliases to enable us to work with just the types from our namespace
    that we require.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, our `WindowManager` class simply converts the UI-related enumeration
    values to and from our custom enumerations, so that we can use the functionality
    of the message box, but not be tied to its implementation. Imagine a situation
    where we need to use this to output an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: When execution reaches this point, a message box will pop up, displaying an
    error message with an error icon and heading. The application will freeze at this
    point while waiting for user feedback and, if the user does not click a button
    on the popup, it will remain frozen indefinitely. If execution reaches this point
    during a unit test and there is no user to click the button, then our test will
    freeze indefinitely and never complete.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the `WindowManager` class is dependent upon having a user present
    to interact with it. Therefore, if the View Models used this class directly, they
    would also have the same dependency. Other classes might have a dependency on
    an email server, database, or other type of resource, for example. These are the
    types of classes that View Models should only interact with via interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'In doing so, we provide the ability to use our components independently from
    each other. Using our `IWindowManager` interface, we are able to use our `ShowMessageBox`
    method independently of the end users. In this way, we are able to break the user
    dependency and run our unit tests without them. Our mock implementation of the
    interface can simply return a positive response each time and the program execution
    can continue unheeded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This simple example shows another method of exposing functionality from a source
    to our View Models, but without it becoming a dependency. In this way, we can
    provide a whole host and variety of capabilities to our View Models, while still
    enabling them to function independently.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the knowledge and tools to build functionality into our application
    framework in many different ways, yet our probe into application frameworks is
    still not quite complete. One other essential matter is that of connecting our
    Views with our View Models. We'll need to decide how the users of our framework
    should do this, so let's look at some choices.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting Views with View Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In WPF, there are several ways to connect our Views to their data sources.
    We''ve all seen examples of the simplest method of a View setting its `DataContext`
    property to itself in its code behind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: However, this should only ever be used for quick demonstrations and never in
    our real-world applications. If we need to data-bind to properties declared in
    a View's code behind, let's say for a particular custom `UserControl`, then we
    should use `RelativeSource` bindings instead. We'll find out more about this in
    [Chapter 4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml), *Becoming Proficient
    with Data Binding*, but for now, let's continue looking at the alternative ways
    to connect the Views with their data sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next simplest method utilizes the data templating Model that is built into
    the WPF Framework. This topic will also be covered in much more detail in [Chapter
    4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml), *Becoming Proficient with Data
    Binding*, but, in short, a `DataTemplate` is used to inform the WPF Framework
    how we want it to render data objects of a particular type. The simple example
    shows how we could define the visual output of our `User` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `DataType` property specifies which type of object this
    relates to and therefore, which properties the containing XAML bindings have access
    to. Keeping it simple for now, we just output the name of each `User` in this
    `DataTemplate`. When we data-bind one or more `User` objects to a UI control that
    is within the scope of this `DataTemplate`, they will each be rendered by the
    WPF Framework as a `TextBlock` that specifies their name.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the rendering engine of the WPF Framework comes across a custom data object,
    it looks for a `DataTemplate` that has been declared for its type and, if it finds
    one, it renders the object according to the XAML contained within the relevant
    template. This means that we can create a `DataTemplate` for our View Model classes
    that simply specifies their related View classes as the rendering output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have specified that when the WPF Framework sees an instance
    of our `UserViewModel` class, it should render it as one of our `UserView` classes.
    At this point, it will set our View Model instance to the `DataContext` property
    of the related View implicitly. The only downside to this method is minimal, and
    is that we have to add a new `DataTemplate` to our `App.xaml` file for each of
    our View-View Model pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method of connection works View Model first, where we supply the View
    Model instance and the WPF Framework takes care of the rest. In these cases, we
    typically use a `ContentControl` that has its `Content` property data bound to
    a `ViewModel` property, which the application View Models are set to. The WPF
    Framework notes the type of the View Model that is set and renders it according
    to its specified `DataTemplate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This is the preferred version of View to View Model connections for many, as
    the WPF Framework is left to take care of most of the details. However, there
    is another way to construct these connections that adds a layer of abstraction
    to the process.
  prefs: []
  type: TYPE_NORMAL
- en: Locating View Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this method, we need to create interfaces for each of our View Models.
    It''s called View Model Location and it''s fairly similar to the Dependency Injection
    example that we have already seen. In fact, we could even use our existing `DependencyManager`
    to achieve a similar result. Let''s take a quick look at that first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we associate the `IUserViewModel` interface with the `UserViewModel`
    concrete implementation of that interface in some initialization code and later,
    resolve the dependency, before setting it as the View's `DataContext` value. After
    declaring our Views in the XAML, they automatically hook themselves up to their
    related View Models at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: This method of connecting Views to View Models works View first, where we declare
    the View and it instantiates its own View Model and sets its own `DataContext`.
    The downside with this method is that we have to create an interface for all of
    our View Models and register and resolve each of them using the `DependencyManager`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference between this implementation and that of a View Model Locator
    is that a locator provides a level of abstraction from our Singleton class, which
    enables us to indirectly instantiate our View Models from the XAML, without using
    the code behind. They also have a little extra specific functionality that enables
    dummy data to be used at design time. Let''s take a look at the simplest possible
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a very basic View Model Locator that simply locates a single
    View Model. It is important that this View Model class has an empty constructor
    so that it can be instantiated from the XAML. Let''s see how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: As a side note, you may have noticed that our `ViewModelLocator` class has been
    declared in the `Views` project. The location of this class is not very important,
    but it must have references to both the `ViewModels` and the `Views` projects,
    and this severely limits the number of projects in which it can reside. Typically,
    the only projects that will have access to the classes from both of these projects
    will be the `Views` project and the startup project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting back to our example, an instance of the `ViewModelLocator` class is
    declared in the View's `Resources` section and this will only work if we have
    a parameterless constructor (including the default parameterless constructor that
    is declared for us if we do not explicitly declare a constructor). Without a parameterless
    constructor, we will receive an error in the Visual Studio designer.
  prefs: []
  type: TYPE_NORMAL
- en: Our View sets its own `DataContext` property in XAML this time, using a binding path
    to the `UserViewModel` property from our `ViewModelLocator` resource. The property
    then utilizes our `DependencyManager` to resolve the concrete implementation of
    the `IUserViewModel` interface and return it for us.
  prefs: []
  type: TYPE_NORMAL
- en: There are other benefits to using this pattern as well though. One problem often
    faced by WPF developers is that the Visual Studio WPF Designer cannot resolve
    the interfaces that are used to back their concrete implementations, nor can it
    access the application data sources during design time. The result of this is
    that the designer does not typically display data items that cannot be resolved.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that we can do with our `ViewModelLocator` resource is to provide
    mock View Models that have dummy data returned from their properties that we can
    use to help visualize our Views as we construct them. To achieve this, we can
    make use of the `IsInDesignMode` Attached Property from the `DesignerProperties`
    .NET class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DependencyObject` object here is required by the Attached Property and,
    in fact, is the object that is being checked. As all objects supplied here would
    return the same value, we are free to use a new one each time. If we are concerned
    that this property will be called more frequently than the garbage collector,
    we could opt to use a single member instead, just for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we need a `DependencyObject` object just for this purpose, then
    we could simplify things further by extending our `ViewModelLocator` class from
    the `DependencyObject` class and use itself as the required parameter. Of course,
    this would mean that our class would inherit unwanted properties, so some might
    prefer to avoid doing this. Let''s see how we could use this property to provide
    the WPF Designer with mock data at design time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: If you look at our `UserViewModel` property, you'll see the value that we return
    is now dependent upon the value of the `IsDesignTime` property. If we are in design
    time, for example, when the View file is open in the WPF Designer, then the `MockUserViewModel`
    class will be returned. At runtime, however, the concrete implementation of our
    `IUserViewModel` interface that we registered with the `DependencyManager` will
    be returned instead.
  prefs: []
  type: TYPE_NORMAL
- en: The `MockUserViewModel` class will typically hardcode some mock data and return
    it from its properties when requested. In this manner, the WPF Designer will be
    able to visualize the data for the developers or designers while they build the
    Views.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, each View will require a new property in our locator class and we''ll
    need to copy this conditional operator statement from the preceding code for each.
    As always in OOP, there is a further abstraction that we could make to hide that
    implementation away from the developers that will use our framework. We could
    create a generic base class for our View Model Locator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: We start by declaring an abstract class that takes a generic type parameter,
    which represents the interface type of the View Model that we are trying to locate.
    Once again, note the generic type constraint declared on the generic type parameter
    that specifies that the type used must be a class. This is now required because
    this class calls the `Resolve` method of the `DependencyManager` class and that
    has the same constraint declared upon it.
  prefs: []
  type: TYPE_NORMAL
- en: We have two internal members of the relevant type of View Model interface that
    back the properties with the same names. There's one for our runtime View Model
    and one for our design time View Model. The third View Model property of the same
    type is the one that we will data-bind to from Views and it uses our `IsDesignTime`
    property to determine which View Model to return.
  prefs: []
  type: TYPE_NORMAL
- en: 'A nice touch in this class is that it does a lot of the connection work for
    the developers. They don''t need to concern themselves with the implementation
    of the `IsDesignTime` property, and this base class will even attempt to automatically
    resolve the concrete View Model dependency for the runtime View Model property.
    Therefore, the developer need only declare the following code for each View Model
    to take advantage of this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'It could be set up in the UI with very little difference to our original locator
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that although this should work automatically in newer versions of Visual
    Studio, you may need to provide a helping hand to the WPF Designer in older versions.
    The `mc:Ignorable` attribute specifies which XAML namespace prefixes encountered
    in a markup file may be ignored by an XAML processor and the `d` XAML namespace
    is used by the Designer, so we can specify a `DataContext` location to it directly
    at design time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: While there is a clear benefit to this arrangement, as always, we have to weigh
    up whether the cost of any such abstractions will be worth the benefits. For some,
    the cost of extracting an interface, declaring a mock version of it to use at
    design time, and creating a View Model Locator for each View Model will definitely
    be worth the benefit of designing Views that visualize their data.
  prefs: []
  type: TYPE_NORMAL
- en: For others, it simply won't be worth it. Each time we add a level of abstraction,
    we have more work to achieve to arrive at the same end goal. We need to decide
    whether each abstraction is viable in our own situations and build our application
    frameworks accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've now investigated the benefit of having an application framework and started
    constructing our own. We've discovered a variety of different ways to encapsulate
    our required functionality into our framework and know which situations to use
    each in. After exploring a number of manager classes, we have also begun to expose
    functionality from external sources, but without being tied to them.
  prefs: []
  type: TYPE_NORMAL
- en: We've managed to maintain and improve the Separation of Concerns that our application
    requires and should now be able to detach the various application components and
    run them independently of each other. We are also able to provide our View designers
    with mock data at design time, while maintaining loose coupling at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will thoroughly examine the essential topic of data
    binding, one of the very few requirements of the MVVM pattern. We'll comprehensively
    cover the wide variety of binding syntax, both long and short hand notation, discover
    why bindings fail to work at certain times, and get a better understanding of
    how to display our data exactly the way we want.
  prefs: []
  type: TYPE_NORMAL
