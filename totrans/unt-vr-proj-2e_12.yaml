- en: Social VR Metaverse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*That''s me, Linojon, the guy with a baseball cap in front, to the left!* Momentously,
    the following photo was captured during the eve of the metaverse on December 21,
    2014 at a live VRChat session. I had built a seasonally-themed world named GingerLand
    and invited my chatroom friends to visit during one of the weekly meetups. Then,
    someone suggested, "Hey, let''s take a group picture!" So, we all assembled on
    the front porch of my wintry cabin and said "Cheese!" The rest is history:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a4f0680-a02b-4481-8843-d4de41941b49.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For many people, the visceral experience of socially interacting live with
    other people in VR is at least as dramatic as the difference between using Facebook
    versus browsing a static website, or sharing Snapchats versus viewing an online
    photo album. It''s very personal and alive. If you''ve tried it out yourself,
    you know exactly what I mean. We''re now going to look at how social VR experiences
    can be implemented using Unity. There are many approaches, from building it from
    scratch to plugging into an existing social VR platform. In this chapter, we will
    discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to how multiplayer networking works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a multiplayer scene that runs in VR using the Unity Networking
    engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Oculus personalized avatars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and sharing a custom VRChat room
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the projects in this chapter are separate and not directly required
    by the other chapters in this book. If you decide to skip any of it or not save
    your work, that's OK.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplayer networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin any implementation, let's take a look at what multiplayer networking
    is all about and define some terms.
  prefs: []
  type: TYPE_NORMAL
- en: Networking services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider a situation where you are running a VR application that is connected
    over the internet to other players running the same application on their own VR
    rigs at the same time. When you move your first person view within the game, shoot
    things, or otherwise interact with the virtual environment, you expect the other
    players to see that, too. Their version of the game stays in sync with yours and
    vice versa. How does this work?
  prefs: []
  type: TYPE_NORMAL
- en: One instance of the running game acts as a host or server. Other players are
    concurrently connected to the same. When you move, your character's new position
    is shared with each of the other connections, which then updates your avatar's
    position in their own views. Similarly, when your game receives a changed position
    of another character, it is updated in your view. The faster, the better. That
    is, the shorter the delay (latency) between the *send* and *receive* messages
    and the corresponding screen updates, the more live, or real-time, the interaction
    feels.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplayer services should help you manage the sharing of the game's state
    between all active clients, the spawning of new players and objects, security
    considerations, as well as the management of low-level network connections, protocols,
    and quality of service (such as data rate and performance).
  prefs: []
  type: TYPE_NORMAL
- en: Networking is built as a series of API layers, where the low-level functions
    deal with details of the data transport and would be agnostic to the content of
    the data. Middle and higher layers provide increasingly aggregated features that
    also may be more directly helpful for the networking application. In our case,
    this is multiplayer gaming and social VR. Ideally, the high-level layer will provide
    all you need to implement multiplayer features into your games with minimal custom
    scripting, while offering access to other layers through a clean API in case you
    have special requirements.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of multiplayer services available, including Photon from
    Exit Games and platforms from Google, Facebook/Oculus, Apple, Microsoft, Amazon,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: The popular Photon Cloud service can be easily added using their free **Photon
    Unity Networking** (**PUN**) package from the Unity Asset Store (for more information,
    visit [https://www.assetstore.unity3d.com/#/content/1786](https://www.assetstore.unity3d.com/#/content/1786)).
    If you are interested in trying Photon with Unity, take a look their documentation
    and tutorial pages ([https://doc.photonengine.com/en-us/pun/current/demos-and-tutorials/photon-unity-and-networking-links](https://doc.photonengine.com/en-us/pun/current/demos-and-tutorials/photon-unity-and-networking-links)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity has its own built-in networking system, **Unity Networking** (**UNet**),
    which reduces the need for custom scripting and provides a feature-rich set of
    components and API that tightly integrate with Unity. There is a whole tutorial
    series on the Unity website ([https://unity3d.com/learn/tutorials/s/multiplayer-networking](https://unity3d.com/learn/tutorials/s/multiplayer-networking)),
    and it's what we will use in this chapter's project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The network architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key to networking is the client-server system architecture. We see this all
    around us in today's world; your web browser is a client and websites are hosted
    on a server. Your favorite music listening app is a client and its streaming service
    is a server. Similarly, each instance of your game, when connected to a network,
    is a client. It talks to a server, which communicates the status and control information
    between all the other game clients.
  prefs: []
  type: TYPE_NORMAL
- en: I say *server*, but it doesn't necessarily need to be a separate physical computer
    somewhere. It could be, but it's probably not. It's best to think of a client
    and server as *processes*: instances of a program or an application running somewhere.
    A **cloud server** is a virtual process that is accessible via the internet as
    a service.
  prefs: []
  type: TYPE_NORMAL
- en: A single app can sometimes act as both a client and a server at the same time.
    This latter case, where the server and client are one, is said to be running as
    a host. With Unity networking, games can be run as a client, a server, and/or
    as a host.
  prefs: []
  type: TYPE_NORMAL
- en: Even so, a public **IP** (**Internet Protocol**) address is needed for game
    instances to talk to one another. A lightweight relay server can provide this
    service with minimal resources.
  prefs: []
  type: TYPE_NORMAL
- en: Local versus server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unity, you can use scripting to create, or instantiate, new objects during
    gameplay. In a multiplayer situation, these objects need to be activated, or spawned,
    locally as well as on the network so that all the clients will know about it.
    A spawning system manages objects across all the clients.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to make a distinction between objects that are local player
    o*bjects* versus network ones. Local player objects are controlled by actions
    in your playing version of the game, on your client, rather than remotely.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in a first-person experience, you are the camera whereas other
    players see you as your avatar, and you would want security precautions; for example,
    to prevent others from hacking a game and changing your avatar.
  prefs: []
  type: TYPE_NORMAL
- en: Local player objects have local authority, that is, the player object is responsible
    for controlling itself, such as its own movement. Otherwise, when the creation,
    movement, and destruction of objects are not controlled by any player, the authority
    should reside on a server. Local authority is needed when individual players are
    driving gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, server authority is needed when game logic and random events
    are driving the gameplay. For example, when a game creates enemies at random locations,
    you'd want all the clients to get the same random locations. When a new player
    joins an ongoing game, the server helps create and set up objects that are active
    in the current gameplay. You wouldn't want an object to show up in its default
    position and then jump to a different current position as it's syncing with the
    other clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image from Unity documentation shows ways in which actions are
    performed across the network. The server makes **remote procedure calls** (**RPC**)
    to the client to spawn or update objects. The client sends **commands** to the
    server and affects actions, which then are communicated to all the remote clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d81af447-bdbf-426a-b0ba-6ace7f23b0f1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Image source: [https://docs.unity3d.com/Manual/class-NetworkBehaviour.html](https://docs.unity3d.com/Manual/class-NetworkBehaviour.html)
  prefs: []
  type: TYPE_NORMAL
- en: Real-time networking is an engineering discipline. Layered network architectures
    aim to simplify and shield you from brutally arcane details.
  prefs: []
  type: TYPE_NORMAL
- en: It all comes down to performance, security, and reliability. If you need to
    debug or optimize any of these in your multiplayer game, you may need to dig in
    your heels and gain a better understanding of what's going on under the hood.
    Refer to the next chapter, [Chapter 13](c938e975-93f3-4435-9d99-9f76bbbd0a98.xhtml), *Optimizing
    for Performance and Comfort*, for suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: The Unity networking system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Unity Networking** engine (**UNet**) includes a robust set of high-level
    component scripts that make it easy to add multiplayer capabilities to your games.
    Some of the more important components include *Network Identity*, *Network Behavior*,
    *Network Transform*, and *Network Manager*.
  prefs: []
  type: TYPE_NORMAL
- en: A good overview of Unity Networking and exposition of the concepts is the Unity
    Networking Concepts document ([http://docs.unity3d.com/Manual/UNetConcepts.html](http://docs.unity3d.com/Manual/UNetConcepts.html)).
  prefs: []
  type: TYPE_NORMAL
- en: The **Network Identity** component is required on each game object prefab that
    may be spawned (created) on clients. Internally, it provides a universally unique
    asset ID, and other parameters, so that objects can be unambiguously identified
    and spawned across the network.
  prefs: []
  type: TYPE_NORMAL
- en: The `NetworkBehaviour` class is derived from `MonoBehaviour` and provides network
    functionality to scripts. We'll be using it in the examples in this chapter. Details
    are documented at [http://docs.unity3d.com/Manual/class-NetworkBehaviour.html](http://docs.unity3d.com/Manual/class-NetworkBehaviour.html).
  prefs: []
  type: TYPE_NORMAL
- en: When you want to synchronize the movement and physics of objects, add a **Network
    Transform** component. It's like a shortcut for the more general `SyncVar` variable
    synchronization with additional intelligent interpolation for smoother movement
    between updates.
  prefs: []
  type: TYPE_NORMAL
- en: The **Network Manager** component is the glue that puts it all together. It
    handles the managing of connections, the spawning of objects across the network,
    and configuration.
  prefs: []
  type: TYPE_NORMAL
- en: When new player objects are spawned, you can specify a spawn position in the
    Network Manager component. Alternatively, you can add game objects to your scene
    and give them a *Network Start Position* component, which can be used by the spawning
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Nonplayer objects that can get spawned can also be set in the Network Manager
    spawn list. Additionally, the Network Manager component handles scene changes
    and provides debugging information.
  prefs: []
  type: TYPE_NORMAL
- en: Related to the Network Manager component is the matchmaking functionality, using
    Unity Cloud Services, which can be configured to match up players to make them
    come together and start a game at the same time-a multiplayer lobby manager where
    players can set themselves as ready for the game to start, among other useful
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a simple scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's jump right in and make our own multiplayer demo project. For instructional
    purposes, we'll start out with a very simple scene with a standard first-person
    camera and get the networking implemented. Then, we'll synchronize multiple players'
    avatars over the network. And then we'll share a game object, a bouncy ball, between
    players to play a game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scene environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get set up, we will make a new scene with a ground plane and a cube and
    create a basic first-person character. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene by navigating to File | New Scene. Then, File | Save Scene
    As... and name the scene `MultiPlayer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `Main Camera` and insert a copy of your `MeMyselfEye` prefab. Reset
    its Transform so it's positioned at the origin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new plane by navigating to GameObject | 3D Object | Plane, rename it
    `GroundPlane`, and reset its Transform using the Transform component's *gear*
    icon | Reset. Make the plane bigger by setting Scale to (`10, 1, 10`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make `GroundPlane` easier on the eyes. Drag your `Ground Material` onto the
    plane. If you need to create one, navigate to Assets | Create | Material, name
    it `Ground Material`, click on its Albedo color chip, and select a neutral color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To provide some context and orientation, we'll just add a cube. Navigate to
    GameObject | 3D Object | Cube, reset its Transform, and set its Position to the
    side, such as (`-2, 0.75, 1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the cube some color. Drag your `Red Material` onto the cube. If you need
    to create one, Navigate to Assets | Create | Material, name it `Red Material`,
    click on its Albedo color chip, and select a nice red, such as RGB (`240, 115,
    115`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating an Avatar head
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, you''ll need an avatar to represent yourself and your friends. Again,
    I''m going to keep this super simple so that we can focus on the fundamentals.
    Forget about a body for now. Just make a floating head with a face. Here''s what
    I did. Your mileage may vary. Just be sure that it''s facing forward (the positive
    Z direction):'
  prefs: []
  type: TYPE_NORMAL
- en: Create an avatar container. Navigate to GameObject | Create Empty, rename it
    `Avatar`, reset its Transform, and set its `Position` to the eye level, such as
    (`0, 1.4, 0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a sphere under the `Avatar` for the head (3D Object | Sphere), rename
    it `Head`, reset its transformation, and set Scale to (`0.5, 0.5, 0.5`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the head some color. Navigate to Assets | Create | Material, name it `Avatar
    Head Material`, click on its Albedo color chip, and select a nice red, such as
    RGB (`115, 115, 240`). Drag the `Avatar Head Material` onto the `Head`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The dude has got to be cool (and bald headed). We'll borrow a pair of Ethan's
    glasses and put them on the head. Navigate to GameObject | Create Empty, as a
    child of `Avatar`, rename it `Glasses`, reset its Transform, and set its Position
    to (`0, -5.6, 0.1`) and Scale (`4, 4, 4`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, while `Glasses` is selected, go to the `Project` pane, drill down into
    the `Assets/Standard Assets/Characters/ThirdPersonCharacter/ Models` folder, unfold
    the `Ethan` prefab, find the `EthanGlasses.fbx` file (the mesh file), and drag
    it into the Inspector panel*.* Be sure to select the fbx version of `EthanGlasses`,
    not the prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It has a mesh, but it needs a material. While `Glasses` is selected, go to the
    Project pane, find the `Assets/Standard Assets/Characters/ThirdPersonCharacter/Materials/`
    folder, find  ` EthanWhite`, and drag it into the Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows a version of mine (which also includes a mouth):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89e2e205-974f-47f8-82a2-e8efc8dc94bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When running as multiplayer, an instance of the avatar will get spawned for
    each connected player. So, we must first save the object as a prefab and remove
    it from the scene, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: With `Avatar` selected in the Hierarchy, drag it into your  Project `Assets/Prefabs`
    folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Avatar` again from the Hierarchy and delete it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: OK, now we should be ready to add multiplayer networking.
  prefs: []
  type: TYPE_NORMAL
- en: Adding multiplayer networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make the scene run as multiplayer, we need at a minimum a Network Manager
    component and we need to identify any objects that will get spawned using the
    Network Identity component.
  prefs: []
  type: TYPE_NORMAL
- en: Network Manager and HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll add the Network Manager component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Empty game object and name it `NetworkController`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Add Component | Network | Network Manager
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Add Component | Network | Network Manager HUD
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We added a Network Controller HUD which displays a simplistic default menu,
    in screen space, that Unity offers to select the runtime networking options (you
    can see it in the images that follow). It's for development. In a real project,
    you'll probably replace the default HUD with something more interesting. And for
    VR, you'll want to make yours in world space.
  prefs: []
  type: TYPE_NORMAL
- en: Network Identity and sync Transform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, add a Network Identity to the `Avatar` prefab. We will also add a Network
    Transform, which instructs the networking system to synchronize the player''s
    Transform values to the avatar instances on each client, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In Project Assets, select the `Avatar` prefab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to Add Component | Network | Network Identity
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the Local Player Authority checkbox is checked
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will now tell the `Avatar` to sync its Transform properties with all other
    players over the network, by adding an `Network Transform` component:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to Add Component | Network | Network Transform
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that Transform Sync Mode is set to Sync Transform
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And Rotation Axis is set to XYZ (full 3D)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Network Transform component is configured to share the actual Transform
    values with other player's instances of this object, including the full XYZ rotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, tell the `Network Manager` that our `Avatar` prefab represents players:'
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, select `NetworkController`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Inspector, unfold the Network Manager Spawn Info parameters so that you can
    see the Player Prefab slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Avatar` prefab from Project Assets onto the Player Prefab slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running as a host
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Click on the Play mode. As shown in the following screenshot, the screen comes
    up with the HUD start menu, which lets you select whether you wish to run and
    connect this game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e29b8521-b239-4f76-981e-5bdaba07b3a5.png)'
  prefs: []
  type: TYPE_IMG
- en: Choose LAN Host (press *H* on keyboard). This will initiate a server (default
    port `7777` on `localhost`) and spawn an `Avatar`. The avatar is positioned at
    a default location, (`0, 0, 0`). Also, it's not connected to the camera. So, it
    is more like a third-person view. As mentioned above, for VR you'll eventually
    want to modify this default HUD to run in World Space.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing to do is run a second instance of the game and see two spawned
    avatars in the scene. However, we wouldn't want them to overlap as both are positioned
    at the origin, so first we define a couple of spawn positions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding spawn positions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add a spawn position, you just need a game object with a Network Start Position
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to GameObject | Create Empty, rename it `Spawn1`, and set its Position
    to (`0, 1.4, 1`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to Add Component | Network | Network Start Position
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the object (Ctrl-D), rename it  `Spawn2`, and set its Position to
    (`0, 1.4, -1`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Hierarchy, select `NetworkController`. In Inspector,  Network Manager | Spawn
    Info | Player Spawn Method, select Round Robin
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have two different spawn locations. The Network Manager will choose one
    or the other when a new player joins the game.
  prefs: []
  type: TYPE_NORMAL
- en: Running two instances of the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A reasonable way to run two copies of the game on the same machine (`localhost`)
    is to build and run one instance as a separate executable and the other instance
    from the Unity Editor (the Play mode). Unfortunately, we cannot run both in VR.
    (Ordinarily, you can only run one VR device on a PC at a time, and one VR app
    on that device). So, we'll build one without VR, using a non-VR first-person controller,
    and run the editor version with VR enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a standard first-person character to the scene, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have the standard Characters assets package loaded, navigate to Assets | Import
    Package | Characters and choose Import
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `FPSController` in the Project `Assets /Standard Assets/Characters/FirstPersonCharacter/Prefabs/` folder
    and drag it into the scene
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset its Transform, and set it looking at the front of objects. Set Position to
    eye level, (`0, 1.4, 0`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `FPSController` selected, in the Inspector, on the First Person Controller component,
    set Walk Speed to `1`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable`MeMyselfEye`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It can also be helpful to modify the XR Settings in Player Settings, by adding
    the SDK named `None` to the top of this list. This will cause projects to build
    and run without VR hardware even if you forget to uncheck the Virtual Reality
    Supported checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the executable as usual. For standalone Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to File | Build Settings....
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the current scene is the only one checked in Scenes In Build. If
    it's not present, click on Add Open Scenes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: OpenPlayer Settings....
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under XR Settings, uncheck the Virtual Reality Supported checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Resolution and Presentation, check the Run In Background checkbox as true.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Build and Run, give it a name. Subsequently, you can launch the game
    by double-clicking after it's built.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enabling the Run In Background will permit the user input controls (keyboard
    and mouse) in each window when running the executables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the game in Unity Editor, we need to reverse some of these settings:'
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, disable `FPSController` and enable `MeMyselfEye`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Player Settings, check the Virtual Reality Supported checkbox and move your
    SDK to the top of the list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In one of your game windows, click on the Play mode and select LAN Host (H),
    like we did previously. Then, in the other window, select LAN Client (C). In each
    game, you should now see two instances of the avatar, one for each player, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60190bd5-d23d-4621-bcaf-884af4b0a034.png)'
  prefs: []
  type: TYPE_IMG
- en: If you want to run an instance of the game on a separate machine, enter the
    IP address of the host machine into the Client input field (for instance, `10.0.1.14`
    on my LAN) instead of `localhost`. If each machine has its own VR device, they
    can each run the corresponding MeMyselfEye prefab as applicable.
  prefs: []
  type: TYPE_NORMAL
- en: If you're running multiple instances of the project on a single machine, just
    set the LAN Client address to `localhost`. If you want to run on other machines
    on your network (including mobile devices), note the IP address of the LAN host
    machine and enter that value on the Client connections (for example, mine is `10.0.1.14`).
    A default value for this can even be added to your project's Network Manager component's
    Network Info | Network Address parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Associating Avatar with the first-person character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's not very interesting if the avatars don't move. That's the next piece of
    this puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: You might think that we should have parented the avatar object under the player
    camera, (`MeMyselfEye` or `FPSController` ) and saved it as a Prefab, and then
    told the Network Manager to use that for spawns. But then, you'd end up with multiple
    cameras in the scene and controller scripts listening on user input. Not good.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must have only one active player in the scene. Other players'' avatars get
    spawned but are not controlled here. In other words, when the local player (and
    only the local player) gets spawned, its avatar should become a child of the camera.
    To achieve this, we will write a script:'
  prefs: []
  type: TYPE_NORMAL
- en: In Project Assets, select `Avatar`, navigate to Add Component | New Script,
    and name it `AvatarMultiplayer`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open and edit the `AvatarMultiplayer.cs` script, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first thing you'll notice is that we need to include the `using UnityEngine.Networking`
    namespace to access the networking API. Then, the class `AvatarMultiplayer` is
    derived from `NetworkBehaviour`, which internally is derived from `MonoBehaviour`.
  prefs: []
  type: TYPE_NORMAL
- en: '`NetworkBehaviour` provides additional callback functions. We are going to
    use `OnStartLocalPlayer`, which gets called whenever the local player object is
    spawned. However, it is not called when the remote player objects are spawned.
    Its declaration requires the `override` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnStartLocalPlayer` is exactly what we want because only when a local player
    is spawned do we want to parent it to the camera. We access the current main camera
    object and make it the avatar''s parent (`transform.parent = camera.transform`).
    We also reset the avatar''s transform so that it''s centered at the camera''s
    position.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider improving the script to specify the actual game object you want to
    parent your avatar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run two instances of the game: Build & Run to execute one, and use the Play
    mode for the other. Control the player in one window, and it moves the avatar
    in the other. Wow! You can even launch more executables and have a party!'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the size and local position of your avatar, its model objects (such
    as eye glasses) may be visible from the first person camera and obstruct the view.
    You can hide them by disabling the child graphics. But then, for example, you
    wont see your own shadow (which I like). Another option is to shift the avatar
    graphics backwards to ensure they don't obstruct the camera's view. Either way,
    this can be done in this `AvatarMultiplayer` script. Likewise, if your game gives
    each avatar a body, or chair, or whatnot, the current player's instance may not
    need or want all those graphic detail to be following them around.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a matchmaking lobby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, connecting two or more players over the network requires you to know
    the IP address of the host instance of the game that is running, or simply `localhost`
    if they're all running on the same machine.
  prefs: []
  type: TYPE_NORMAL
- en: Unity Networking and Cloud Services includes a built-in networking lobby manager
    for matchmaking between online players. It lets you create and join online "rooms,"
    limited to a maximum number of players. Using the lobby feature is as easy as
    choosing Enable Match Maker in the Network HUD in your app. But first, you must
    subscribe to Unity Multiplayer cloud services (free, with limits for the number
    of concurrent users, based on your Unity license).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, first enable Unity Cloud Services for your app:'
  prefs: []
  type: TYPE_NORMAL
- en: Above Inspector, select the Cloud icon (indicated in the following screenshot)
    to open the Services window
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create or choose a Unity Project ID for this project. To create an ID, click Select
    Organization and choose your organization, and then click Create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Multiplayer to open the multiplayer services panel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From there, open the web-based dashboard, where you're asked to specify the
    Max Players Per Room. Enter `4` and press Save
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A configured Multiplayer Services panel is shown here, with the Cloud services
    icon highlighted for your reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4efeb373-190d-45a3-a550-4efb051b51f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After enabling the services in your project, you may need to rebuild the executable
    (File | Build And Run) and then, in the first instance of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: From the HUD menu choose Enable Match Maker (M)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in a name for your room
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Create Internet Match
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the second instance of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: From the HUD menu, also choose Find Internet Match
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your room should appear as a new button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose the Join: button for your room'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now run the multiplayer game across the internet, letting Unity Services
    negotiate the IP addresses and maximum connections per room.
  prefs: []
  type: TYPE_NORMAL
- en: This will get you started. Of course, you have full control of the networking
    lobby matchmaking, like other Unity Networking services. And you most likely will
    want to make your own GUI. For documentation, see the NetworkManager API ([https://docs.unity3d.com/ScriptReference/Networking.NetworkManager.html](https://docs.unity3d.com/ScriptReference/Networking.NetworkManager.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Consider starting with the example Network Lobby free asset from Unity ([https://assetstore.unity.com/packages/essentials/network-lobby-41836](https://assetstore.unity.com/packages/essentials/network-lobby-41836)).
    Unfortunately this asset is out of date and has bugs, but you can get it to work (read
    the comments). Or at least, reference it as an example when writing your own UI.
    Also, it is a screen space UI; for VR, you would need to modify it to be a world
    space canvas.
  prefs: []
  type: TYPE_NORMAL
- en: An example of HUD code that seems up to date can be found in this forum comment: [https://forum.unity.com/threads/networkmanagerhud-source.333482/#post-3308400](https://forum.unity.com/threads/networkmanagerhud-source.333482/#post-3308400)
  prefs: []
  type: TYPE_NORMAL
- en: Syncing objects and properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's play ball! Back in [Chapter 8](77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml),
    *Playing With Physics And Fire*, we implemented various ball games in VR. Now,
    we have the means to make a multiplayer one. We will make a game similar to the
    *Headshot* game, which uses your head as the paddle. But after this exercise,
    feel free to go and build multiplayer versions of the *Paddle Ball* and/or *Shooter
    Ball* games, which use a hand controller to hold and move a paddle to hit or deflect
    the ball.
  prefs: []
  type: TYPE_NORMAL
- en: Also, since the objective here is to focus on the multiplayer networking considerations,
    we will leave out some details covered in the earlier chapter, such as sound effects,
    particles, and object pooling.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the headshot ball game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll add the cube paddle to the Avatar head as the one and only Collider
    on the Avatar:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag a copy of the `Avatar` prefab into your Hierarchy for editing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each of its children (`Head, Glasses`), disable the Collider if present
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new cube child of `Avatar` (Create | 3D Object | Cube) and name it
    `CubePaddle`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset its Transform and set its Scale to (`0.5, 0.5, 0.5`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable the Cube's Mesh Renderer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the Avatar changes back to its prefab (click Apply in Inspector)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete it from Hierarchy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we''ll add a `GameController` object and a script that serves balls to
    the avatar at fixed intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Empty game object at the Hierarchy root named `GameController`, and
    reset its Transform
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Component | New Script and name it `BallServer`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the script and write it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this script, we play a new ball every 5 seconds. Each ball remains in the
    scene for 25 seconds (`interval * 5`). We use a coroutine, with `yield return
    new WaitForSeconds(interval)` to instantiate a new ball each interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also create a list of `colors` and randomly choose one for this player when
    the game starts. All balls instantiated by this player will be this color. Create
    the list of colors to pick from:'
  prefs: []
  type: TYPE_NORMAL
- en: On Ball Server component, unfold the Colors parameter
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set Size to `4` or higher
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define unique colors for each of the Element n color slots
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The GameController component will look similar to this in Inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a85e9964-4a9e-4a14-9207-cda2e5a5e12c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a bouncy ball. We''ll name it `NetworkBall` because in the next section
    we will share it across the network:'
  prefs: []
  type: TYPE_NORMAL
- en: Create 3D Object | Sphere, name it `NetworkBall`, and Scale (`0.5, ``0.5, 0.5`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On its Sphere Collider, assign the `Bouncy` physic material to the Material
    slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Rigidbody` component (Add Component | Physics | Rigidbody)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag `NetworkBall` into your Project Assets *Prefabs* folder to create a prefab,
    and delete the object from Hierarchy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a `NetworkBall` from *Prefabs* onto Ball Prefab slot of the GameController's
    BallServer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Play. Locally, you'll get served balls from above, and you can deflect
    them with your head, just like we did in [Chapter 8](77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml),
    *Playing with Physics and Fire*.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning the ball over the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Other players in our networked game need to see the same balls you do. There
    are several steps to getting this going:'
  prefs: []
  type: TYPE_NORMAL
- en: First, when we instantiate a ball locally, we need to tell the network to also
    spawn it for all the players
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the ball moves, is bounced or hit, its Transform must be updated for all
    the players
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the ball's life is done, it must be destroyed for all the players
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our present single-player version of the game, we instantiate new balls
    in the `BallServer` script. Let''s make it networked:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BallServer` script for editing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `using UnityEngine.Networking;` namespace at the top
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a call to `NetworkServer.Spawn(ball);` once we have an instance created
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we must register the `NetworkBall` prefab with the `NetworkManager` to
    inform it the prefab is spawnable:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `NetworkController` in Hierarchy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Inspector, unfold the Spawn Info parameters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click + in the Registered Spawnable Prefabs list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a copy of `NetworkBall` onto the spawnable prefab Game Object slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Network Manager component now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e932bb89-1992-48f0-bd5c-0790831b1735.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There''s one other thing that we did not handle yet: destroying ball instances.
    In the standalone version, we called `Destroy(ball, interval*5)` to destroy the
    ball after the given time. For network spawned objects, you will call `Network.Destroy(ball)` instead.
    However, there is not an equivalent version with a timer argument. You could write
    a countdown timer for it in BallServer, or use some other strategy for determining
    when its life cycle is complete and it can be destroyed (such as a DestroySelf
    script on the ball prefab itself) that runs locally.'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing the ball transform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unity Networking has a component to share this data between players,`Network
    Transform`, which we used earlier for syncing the Avatar head. Now, we''ll use
    it for the ball:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `NetworkBall` prefab in Project Assets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Component | Network Transform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the Transform Sync Mode is set to Sync Rigidbody/3D.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding Network Transform will add a Network Identity for you. Check its Local
    Player Authority checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Network Transform parameters for `NetworkBall` are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/942a0b77-a304-4b76-9d48-9c9bef6a66c4.png)'
  prefs: []
  type: TYPE_IMG
- en: Run two copies of your project now. *Voila!* When you connect the games on the
    network, the player's balls will be visible to all other players (*nsfw? Keep
    it clean guys*). The movement of each ball in the local game will control its
    transform on all the other game instances.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Unity is providing optimizations to limit the amount of data and frequency
    of updates while ensuring each player continues to see the same thing. For example,
    in the Network Transform, while you can sync an object's Transform position and
    rotation each update, you can also specify movement and velocity thresholds that
    signal when a sync is required. Perhaps more significant, you can choose what
    to sync. Instead of the Transform values themselves, you can sync changes in the
    Rigidbody physics (velocity, angular velocity, and so on), which happen much less
    often, and let each player's local game calculate the corresponding new Transform.
    This is the option we chose for the NetworkBall.
  prefs: []
  type: TYPE_NORMAL
- en: State variable synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we spawn an object over the network, it uses the prefab object we registered
    with the Network Manager. So the spawned balls all have the default color, not
    the one we set locally when the object was instantiated in BallServer. We'll use
    this as an opportunity to show how to synchronize other properties.
  prefs: []
  type: TYPE_NORMAL
- en: The example is a little contrived, but let's say we want the object color to
    be a state variable. (You could add others too, such as power, health, magic and
    so on.) We will write a script that tells the network to sync the properties across
    the network, if and when its value is changed.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler `[SyncVar]` attribute identifies the property we want to sync and
    sets up an *observer*. If we include a `hook`, that function will be called by
    the observer when the value changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the `NetworkBall` prefab, create a new script named `StateVariables` and
    write it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The class derives from `NetworkBehaviour`. We declare `color` with a `SyncVar`
    attribute. We provide a public setter function, `SetColor`, that can be called
    from other game objects as normal. Likewise, when the `color` variable is changed,
    it will be synchronized over the network. Remote copies running your game will
    call `OnColorChanged` to change that instance of the object too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need to modify the `BallServer` to set the color using this interface
    rather than modifying the material color directly. Modify the loop in the `DropBall`
    function to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now the server will not just spawn balls on the clients, but will then send
    its color property setting as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of live two-player HeadShot gameplay on our makeshift
    game court:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92b61774-5e4a-48c8-9426-aee68f71552f.png)'
  prefs: []
  type: TYPE_IMG
- en: Using this basic pattern, you could extend this script to set and sync other
    variables representing the state of individual objects (heath, power, and so on)
    or the game itself (score, who's turn it is to serve, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Advanced networking topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have only touched the surface of what you can do with networking. If this
    interests you, I recommend you look closely at the Unity manual and go through
    their tutorials too. As we mentioned at the beginning of this chapter, a good
    place to start is the Unity Networking Concepts document ([http://docs.unity3d.com/Manual/UNetConcepts.html](http://docs.unity3d.com/Manual/UNetConcepts.html)).
  prefs: []
  type: TYPE_NORMAL
- en: It's important to understand Peer-to-Peer versus Client-Server versus Dedicated
    Server networking architecture. As we've seen, by default Unity Networking is
    Client-Server, with a player as the host Server (the player is also its own Client).
    You also have the option of setting up with a dedicated server running Unity as
    a standalone player in headless mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other networking topics and issues include:'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing other serializable state variables ([https://docs.unity3d.com/Manual/UNetStateSync.html](https://docs.unity3d.com/Manual/UNetStateSync.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client custom spawn functions ([https://docs.unity3d.com/Manual/UNetCustomSpawning.html](https://docs.unity3d.com/Manual/UNetCustomSpawning.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawning and controlling non-player characters (NPC) from a server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further understanding when to use local player authority versus server authority
    ([https://answers.unity.com/questions/1440902/unet-local-player-authority.html](https://answers.unity.com/questions/1440902/unet-local-player-authority.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling Commands (client to server) versus  Remote Procedure Call (RPC) (server
    to client) ([https://docs.unity3d.com/Manual/UNetActions.html](https://docs.unity3d.com/Manual/UNetActions.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your own multiplayer lobby ([https://docs.unity3d.com/Manual/UNetLobby.html](https://docs.unity3d.com/Manual/UNetLobby.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing, debugging, and simulating networking conditions ([https://docs.unity3d.com/Manual/UNetManager.html](https://docs.unity3d.com/Manual/UNetManager.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking is not specifically a VR topic, but if you do embark on building
    a multiplayer networked VR application, you should spend time gaining an understanding
    of how data, messages, and commands are exchanged between client and server. VR
    includes its own unique networking challenges. The immediate, immersive experience
    of VR can amplify problems of latency, synchronization, and realism. We will also
    address some of these issues in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Options for voice chat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have two or more people in the same VR space, it is natural to want
    to speak with one another. Almost all VR devices have headphones and microphones
    so the hardware support is ubiquitous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Presently, Unity Networking does not support voice chat (VoIP). But there are
    other solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: Third-party packages such as *Dissonance Voice Chat* ([https://assetstore.unity.com/packages/tools/audio/dissonance-voice-chat-70078](https://assetstore.unity.com/packages/tools/audio/dissonance-voice-chat-70078))
    add voice chat over your existing network connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Photon Voice* ([https://assetstore.unity.com/packages/tools/audio/photon-voice-45848](https://assetstore.unity.com/packages/tools/audio/photon-voice-45848)). If
    you are already using **Photon Unity Networking** (**PUN**), this is the go-to
    package to use. If you are using Unity Network (UNet), then Photon Voice is not
    a great choice, or at least you''d need to establish separate connections for
    voice on the Photon network from your other networking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Oculus VoIP* ([https://developer.oculus.com/documentation/platform/latest/concepts/dg-cc-voip/](https://developer.oculus.com/documentation/platform/latest/concepts/dg-cc-voip/)).
    If you are using the Oculus OVR Utilities for Unity (see next topic), you can
    add the Oculus VoIP SDK and its sister package, Oculus Lipsync.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Oculus platform and avatars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is worthwhile, and fun, to mention at this point the rich platform networking
    tools provided by Oculus for their VR devices. As a Facebook organization, Oculus
    obviously has a keen interest in making VR an engaging social experience. With
    Oculus Platform SDK ([https://developer.oculus.com/documentation/platform/latest/concepts/book-plat-sdk-intro/](https://developer.oculus.com/documentation/platform/latest/concepts/book-plat-sdk-intro/)),
    each user can create and use a personalized identity and avatar across Oculus
    games and apps, and find and connect with friends, all with a respectable degree
    of security and authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Oculus Platform SDK Intro ([https://developer.oculus.com/documentation/platform/latest/concepts/book-plat-sdk-intro/](https://developer.oculus.com/documentation/platform/latest/concepts/book-plat-sdk-intro/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oculus Platform Getting Started Guide ([https://developer.oculus.com/documentation/platform/latest/concepts/book-pgsg/](https://developer.oculus.com/documentation/platform/latest/concepts/book-pgsg/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oculus Avatar Getting Started Guide ([https://developer.oculus.com/documentation/avatarsdk/latest/concepts/avatars-gsg-intro/](https://developer.oculus.com/documentation/avatarsdk/latest/concepts/avatars-gsg-intro/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along with the basic Unity integration SDK, the Oculus development ecosystem
    includes Oculus Rooms with match-making, 3D ambisonic audio, voice chat, lip sync,
    and their integrated Oculus Avatar system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 3](5f03c1ec-a1bc-4ec8-bf4b-dc7a4492aba4.xhtml), *VR Build and Run*,
    we included a section on *Building for Oculus Rift*, where you may have set up
    your scene to include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add `Oculus` SDK to the Virtual Reality SDKs in Player Settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import the *Oculus Integration package* from the Asset Store, which installs
    an OVR folder in your Project Assets ([https://assetstore.unity.com/packages/tools/integration/oculus-integration-82022](https://assetstore.unity.com/packages/tools/integration/oculus-integration-82022))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `OVRCameraRig` prefab instead of `Main Camera` in `MeMyselfEye`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oculus platform entitlement check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use the Oculus platform and cloud services, your app needs to be registered
    with Oculus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Register your app in the Developer Center in order to obtain an App ID, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In your browser, go to [https://dashboard.oculus.com/](https://dashboard.oculus.com/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Create New App and choose the device, GearVR or Oculus Rift
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a note of the App ID (copy into your clipboard), required to initialize
    the Platform SDK (if you need to revisit this page, it's located at Manage | your
    organization | your app | Getting Started API)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Test User by navigating to Manage | your organization | Settings |
    Test Users, and Add Test User
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now in Unity, we need to configure your settings so it will pass the entitlement
    checks:'
  prefs: []
  type: TYPE_NORMAL
- en: Select Oculus Platform | Edit Settings from the main menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste your App ID into the corresponding slot in Inspector
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the Unity Editor Settings, check the Use Standalone Platform checkbox,
    and enter the Test User Email and Password generated by Add Test User previously
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Setting Use Standalone Platform will bypass your credential''s entitlement
    checks on the Oculus server when running in the Unity Editor. But otherwise, you
    need to add code for this to your project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: On an object in your Hierarchy, such as `GameController`, create a script named
    `OculusEntitlementCheck`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write it as follows (derived from the Oculus docs):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Adding a local avatar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we''ll add the Oculus Avatar to the scene for the local player. There
    are two avatar prefabs in the Project `Assets/OvrAvatar` folder: one for the local
    user, which may show just the player''s hands in first-person view, and one for
    the remote players. Note that the Oculus avatars will not appear in your Unity
    Scene window until you press play, as they are procedurally generated and (ordinarily)
    require a connection to the Oculus cloud server:'
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, locate and unfold your `OVRCameraRig`. Notice it contains a child
    `TrackingSpace`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Project Assets `OvrAvatar/Content/Prefabs/` folder, drag the `LocalAvatar`
    into the Hierarchy as a child of `TrackingSpace`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Inspector, check the Start With Controllers checkbox
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the Show First Person checkbox
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Play. You can now see your hands and controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Adding remote avatars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Avatar SDK also uses the Oculus cloud services to get specific player''s
    avatar settings and preferences. Set the App ID for the Avatar SDK, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select Oculus Avatars | Edit Settings from the main menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste your App ID into the corresponding slot in Inspector
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This may not really be necessary right now if you''re OK with the default "blue"
    avatar, but we''ll need it for multiplayer networking. According to the Oculus
    docs:'
  prefs: []
  type: TYPE_NORMAL
- en: Note: You may ignore any **No Oculus Rift App ID** warnings you see during development.
    While an App ID is required to retrieve Oculus avatars for specific users, you
    can prototype and test experiences that make use of Touch and Avatars with just
    the default blue avatar.
  prefs: []
  type: TYPE_NORMAL
- en: To add other player's avatars, we'll use the Oculus RemoteAvatar prefab. We
    need to set it up for Unity Networking like we did previously with our handmade
    one, including a Network Identity and Network Transform.
  prefs: []
  type: TYPE_NORMAL
- en: In the Project Assets `OvrAvatar/Content/Prefabs/` folder, select the `RemoteAvatar`
    prefab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose  Add Component | Network | Network Identity
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the Local Player Authority checkbox is checked
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Add Component | Network | Network Transform
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set Transform Sync Mode to Sync Transform
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set Rotation Axis to XYZ (full 3D)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Network Manager` in Hierarchy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `RemoteAvatar` onto the Network Manager's Player Prefab slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can also modify the `AvatarMultiplayer` script we wrote previously, which
    moves the local player''s avatar under the player camera. In the present case,
    we don''t really want to render the remote avatar but we do want other players
    to sync its Transform values, so we''ll disable the rendering as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when two or more players join the same room, the players should be tracked
    and synchronized over the network. Here is a screen capture of an Oculus Avatar
    playing ball in our scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26671fd8-03af-4a84-a310-79854ddec6ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Building and sharing custom VRChat rooms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your goal is simpler, to build a virtual reality world and share it with
    others as a shared social experience, you can use one of a number of existing
    social VR platforms that provide the infrastructure and allow customization. Among
    the best, VRChat is the only one that lets you create custom worlds and personalized
    avatar rigs using Unity.
  prefs: []
  type: TYPE_NORMAL
- en: VRChat is built with Unity, and you can use Unity to make custom worlds and
    avatars. If you haven't tried it, download a copy of the client from Steam ([http://store.steampowered.com/app/438100/VRChat/](http://store.steampowered.com/app/438100/VRChat/))
    and play around with it.
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, VRChat requires the older Unity 5.6.3p1 version. (Download
    at [https://unity3d.com/unity/qa/patch-releases/5.6.3p1](https://unity3d.com/unity/qa/patch-releases/5.6.3p1).)
    Copy your project into a new folder before attempting to open it in an older version
    of Unity. You may get warnings, but go ahead. They're mostly pertaining to scripts
    and we will not be exporting scripts to VRChat.
  prefs: []
  type: TYPE_NORMAL
- en: To develop for VRChat requires you have an account on their site (not the same
    as your Steam account). Go to [https://www.vrchat.net/register](https://www.vrchat.net/register)
    to register.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing and building the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin, decide a scene to use in VRChat. Pick any Unity scene you want.
    It could be the `Diorama` playground that we used earlier in this book, the PhotoGallery
    from Chapter 9, *Making Interactive Spaces*, or something else.
  prefs: []
  type: TYPE_NORMAL
- en: Open the scene in Unity that you want to export.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save a copy to a new name, such as `VRChatRoom`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download the VRChat SDK from [http://www.vrchat.net/download/sdk](http://www.vrchat.net/download/sdk)
    and check the documentation at [https://docs.vrchat.com/](https://docs.vrchat.com/)
    for the latest instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the VRChat SDK package. Navigate to Assets | Import Package | Custom
    Package..., find your downloaded copy of `VRCSDK-*.package`, click on Open, and
    select Import
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the camera object (`Main Camera`, or `MeMyselfEye`, or whatever it is
    named)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Project `Assets/VRCSDK/Prefabs/World/` folder, add the `VRCWorld` prefab
    into the scene
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spawn points define where players enter the scene. `VRCWorld`, by default, acts
    as a spawn point itself, so you can just position this object in the scene. Or,
    create other Empty game objects, position them where you like, and add them to
    the Spawns list in the `VRCWorld` VRC_SceneDescriptor component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the other VRC_SceneDescriptor parameters. Explanations can be
    found in the documentation at [https://docs.vrchat.com/docs/vrc_scenedescriptor](https://docs.vrchat.com/docs/vrc_scenedescriptor).
    The VRC_SceneDescriptor inspector is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30760ecb-e49e-4ebd-ada8-c7b1ede9d926.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Continue to prepare your scene for VRChat as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to your VRChat account, via VRChat SDK | Settings
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to VRChat SDK | Show Build Control Panel and review the options there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Setup Layers button, if present, to add the layers required by VRChat
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Setup Collision Layer Matrix button, if present
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Enable 3D Spatialization button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you''re ready, you can test your world:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the Test | New Build button to begin building a new test world
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A local version of VRChat will open in a window
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you''re ready to publish the world in cyberspace:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the Publish | New Build button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted, enter the name, player capacity, description, and other information
    requested in the Game window in Unity
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The world will be uploaded to VRChat
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can manage your uploads via VRChat SDK | Manage Uploaded Content
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your uploaded world will be private. You can use it in VRChat and invite others
    to join you, but otherwise it is not public. To go public with your uploaded content,
    you must email a request to `support@vrchat.net`.
  prefs: []
  type: TYPE_NORMAL
- en: The VRC SDK provides a toolbox of components you can add to your scene, including
    pedestals, mirror reflections, YouTube videos, and even a combat system. To make
    your scene interactive, you can add your own scripts to objects with basic actions
    triggered by events in the world, including `OnSpawn`, `OnPickup`, `OnDrop`, and `OnAvatarHit`,
    to name just a few.
  prefs: []
  type: TYPE_NORMAL
- en: VRChat is one of the original social VR platforms and has proven itself with
    a strong community and longevity. It is a little rough around the edges but as
    an indie project, we have a great deal of respect and offer a lot of kudos! It
    is a good stable implementation that is community driven and welcomes user contributions
    of content.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about networking concepts and architecture and used
    some of the many features of Unity's own multiplayer networking system. We built
    a simple scene and an avatar, keeping in mind that the intent is to allow the
    avatar's head movement to be synchronized with the player's head-mounted display.
  prefs: []
  type: TYPE_NORMAL
- en: We then converted the scene to multiplayer, adding the Unity Network components,
    which simplifies the multiplayer implementation to just a handful of clicks. Having
    proven we can build a shared multiplayer experience with the avatars, we added
    a bouncy ball game object shared between players, providing the fundamentals for
    building a multiplayer networked game.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we took a quick spin of the Oculus Avatar SDKs, replacing our spherical
    avatars with full bodied personalized ones from the Oculus Platform ecosystem. Finally,
    we stepped through how easy it is to create a virtual room in VRChat by exporting
    a scene that you can share almost instantly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into the technical details of optimizing your
    VR projects to run smoothly and comfortably in VR. We will consider the different
    areas that affect performance and latency, from model polygon count, to Unity
    scripting, to bottlenecks on the CPU and GPU processors.
  prefs: []
  type: TYPE_NORMAL
