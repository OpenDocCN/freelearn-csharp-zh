- en: Adapting the Built-In Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The .NET Framework comes with a plethora of built-in controls that cover most
    real-world scenarios. And when we need something slightly different, we have seen
    that we can utilize the WPF styling and/or templating systems to adapt them to
    our requirements. However, there are also further ways of adjusting the built-in
    controls to suit our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Each .NET control has a number of methods, each named with the prefix `On`,
    for example, `OnInitialized`, or `OnApplyTemplate`. These are protected methods,
    that can be overridden in any custom class that extends a .NET control. They are
    called at certain points in the control's lifetime and enable us to change the
    default behavior of each control.
  prefs: []
  type: TYPE_NORMAL
- en: They enable us to do things as simple as starting a process as soon as a control
    has been initialized, or accessing a named control from a custom `ControlTemplate`,
    once it has been applied. But they can also be used to completely change the default
    behavior, or the look and feel of the control. In this chapter, we will investigate
    these methods and give examples of how they can be utilized to our advantage.
  prefs: []
  type: TYPE_NORMAL
- en: We will then examine further ways of customizing the built-in controls, by adjusting
    their default `ControlTemplate` and leveraging new uses from them, while maintaining
    or extending their existing functionality. In this chapter, we consider the built-in
    controls merely as a starting point for our requirements, and learn how to build
    upon them, keeping what we need and changing what we don't.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting protected methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each .NET control has several methods that enable developers that extend that
    control to either interact with, or alter its functionality. Note that these are
    not events, but protected methods, that are called at specific points throughout
    the control's lifetime. As we have already seen in *[Chapter 5](d5906090-c679-45d6-81cd-016d4337eb75.xhtml),
    Using the Right Controls for the Job*, each .NET control extends a number of base
    classes, with each providing certain additional functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way, each base class also provides a number of these protected
    methods, that enable us to interact with the control internally. In this chapter,
    we will also show how we can create our own methods that enable developers that
    extend our own control classes to adapt or extend their functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first take a look at the protected methods of the `Window` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that they are all marked with either the virtual or override
    keywords, indicating that they can be overridden in extending classes. Apart from
    the `ArrangeOverride` and `MeasureOverride` methods, that we discovered in *[Chapter
    5](d5906090-c679-45d6-81cd-016d4337eb75.xhtml), Using the Right Controls for the
    Job,* you should see that their names all start with the prefix `On`. This signifies
    that they are called upon some action having taken place.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `OnActivated` method is called when the `Window` becomes the
    active window on the computer, while the `OnDeactivated` method is called when
    the `Window` loses focus. These methods are usually used together to pause and
    resume animations, or other processes, while the `Window` is not in focus.
  prefs: []
  type: TYPE_NORMAL
- en: As expected, the `OnClosed` method is called upon the `Window` being closed
    and gives us a chance to dispose of any resources, or to save user preferences
    before closing the application. Conversely, The `OnClosing` method is called before
    the `Window` is closed and gives us a chance to cancel the close operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the `OnClosing` method would be a good method from which to display
    a dialog, asking the user to confirm the close operation. Let''s take a quick
    look at how we might achieve this in a class that extends the `Window` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this simple example, we override the `OnClosing` method and in it, we first
    call the base class method, to ensure that any base class routines are run as
    expected. We then display a message box to the user, asking them to confirm their
    close operation.
  prefs: []
  type: TYPE_NORMAL
- en: With the resulting value attained from the user via the message box buttons,
    we set the `Cancel` property of the `CancelEventArgs` object that is passed into
    the method. If the returned value is `Cancel`, the `Cancel` property is set to
    `true` and the close operation is canceled, otherwise, it is set to `false` and
    the application is closed.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the `Window` class now, we see the `OnLocationChanged` method,
    which is called whenever the `Window` is moved or resized in a manner that moves
    its top left corner. We could use this method to save the last position of the
    `Window`, so that it could be returned there the next time the user opened their
    application. However, this operation is more typically performed upon the user
    closing the application.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnSourceInitialized` method is called after the window source is created,
    but before it is shown and the `OnStateChanged` method is called when the `WindowState`
    property is changed. So you see, these methods provide us with opportunities to
    perform actions at specific points throughout each control's lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: Each base class adds its own collection of these protected methods for us to
    take advantage of, and ones of interest are overridden in the extending classes.
    Looking at the `Window` class declaration, we see that it extends the `ContentControl`
    class. Notice that its `OnContentChanged` method is marked with the `override`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because this method, which is actually declared in the `ContentControl`
    class, has been overridden in the `Window` class so that it could add its own
    code after the base class functionality has been executed. Let''s have a look
    at the source code for this method from the `Window` class. The comments in the
    source code have been removed for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The method starts by calling the base class version of the method, which is
    always a good practice unless we want to stop the existing functionality from
    being performed. Next, it calls the `SetIWindowService` method, which just sets
    the `Window` object to the `IWindowServiceProperty` Dependency Property, and then
    it checks if the `Window` has passed the loading stage or not.
  prefs: []
  type: TYPE_NORMAL
- en: If it has, then it calls the `PostContentRendered` method, which basically invokes
    the `OnContentRendered` method using the `Dispatcher` object. Otherwise, if the
    `_postContentRenderedFromLoadedHandler` variable is `false`, it attaches an event
    handler to the `Loaded` event and sets the variable to `true`, to ensure that
    it is not attached more than once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to our investigation now, we see that the `Window` class adds protected
    methods relating to the `Window` and the `ContentControl` class adds protected
    methods relating to the content of the control. Let''s see the protected methods
    of the `ContentControl` class now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the first two methods, which can be used to add a specified object
    or text string to the `ContentControl` element, the remaining four methods are
    all called in response to a change in the content, or the format of the content
    of the control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on now, the `ContentControl` class extends the `Control` class, which
    introduces the concept of the `ControlTemplate`. As such, it provides a protected
    `OnTemplateChanged` method, which is called when the `ControlTemplate` value is
    changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Control` class extends the `FrameworkElement` class, which provides framework-level
    methods and events. These include a mouse, keyboard, stylus, touch, and focus-related
    protected methods, along with several others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Perhaps by now you will have noticed that many of these method names relate
    closely to the names of events raised by each class. In fact, there is a .NET
    Framework programming guideline for having protected virtual methods that raise
    events, to allow derived classes to override the event invocation behavior and
    we'll see an example of this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When overriding these methods, we are therefore required to call the base class
    method in order to raise the corresponding event. When in doubt, it's usually
    best to call the base class version of the method to ensure that default functionality
    is not lost. However, it's good practice to view the base class method source
    code on the [www.referencesource.microsoft.com](http://www.referencesource.microsoft.com)
    website, to check if we need to call it or not.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering what the difference between handling the events and overriding
    the related protected methods is and there are a few answers to this, depending
    upon the method in question. The first thing to point out is that in order to
    override a protected method, we need to declare a subclass of the class that declares
    the method.
  prefs: []
  type: TYPE_NORMAL
- en: '*So, assuming that we already have a class that extends a base class, what
    are the differences?* For some methods, such as the `OnClosing` method that we
    explored, there is little difference. We could implement the same functionality
    in an event handler that is attached to the `Closing` event, although without
    the call to the base class method. In fact, this is the only real difference.'
  prefs: []
  type: TYPE_NORMAL
- en: When overriding the `OnClosing` method, we are in control of when or if the
    base class method is called. When handling the event, we have no control over
    this. So, if we need to perform some action before the base class routine is executed
    or if we want to stop it from executing, then we will need to override the `OnClosing`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: So, the appearance of the `OnClosing` method is there, purely for convenience,
    for us to be able to alter the default behavior of the `Closing` event. Other
    methods, however, such as the `OnContextMenuClosing` method, introduce a way for
    us to perform class-wide handling for the related events.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes though, we have no alternative to overriding these protected methods.
    Typically, these types of methods do not start with the prefix `On` and do not
    relate to any event. Occasionally, to perform a particular operation, we may need
    to extend a class, just so that we can provide a new implementation for one of
    these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example using the `GetLayoutClip` method from the `FrameworkElement`
    class that we just saw.
  prefs: []
  type: TYPE_NORMAL
- en: Clipping the layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the `TextBlock` class clips its textual content at its bounding
    rectangle, so that text does not leak out of it. Clipping is the process of cutting
    off a portion of the visible output of a control. *But what about if we want the
    text to extend its bounds?*
  prefs: []
  type: TYPE_NORMAL
- en: There is a property named `Clip`, that we typically use to adjust the visible
    portion of controls. However, this can only reduce what is already visible. It
    cannot increase the rendering space available to the control. Before we continue
    with our example, let's take a short detour to investigate this property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Clip` property, which is defined in the `UIElement` class, takes a `Geometry`
    object as its value. The object that we pass it can be created from any of the
    classes that extend the `Geometry` class, including the `CombinedGeometry` class.
    Therefore, the clipped object can be made into any shape. Let''s view a simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use an `EllipseGeometry` object to make a `Rectangle` element appear
    as a small bullet shape. It works by displaying all of the image pixels from the
    `Rectangle` element that lies within the oval boundary of the `EllipseGeometry`
    object and hiding all those that lie outside the boundary. Let''s take a look
    at the visual output of this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b3b1ba2-8602-4dae-9312-033e7c73e078.png)'
  prefs: []
  type: TYPE_IMG
- en: Returning to our previous example, the `TextBlock` class also clips its content
    in a similar way, but with a rectangle the size of the control, instead of an
    off-centered oval. Rather than using the `Clip` property, which provides the user
    with the same ability to clip the control as the other controls offer, it uses
    a protected method to ask for the `Geometry` object to use in the clipping process.
  prefs: []
  type: TYPE_NORMAL
- en: We could indeed return any geometric shape from this method, but it would not
    have the same visual effect as passing the shape to the `Clip` property would.
    For our example, we don't want to restrict the visible size of the control, but
    instead, remove the clipped area at the bounds of the control.
  prefs: []
  type: TYPE_NORMAL
- en: If we knew exactly what size we wanted to set the clipped range at, we could
    return a `Geometry` object of that size from the `GetLayoutClip` method. However,
    for our purposes, and to enable any of our custom `TextBlock` objects to leak
    endless text out of their bounds, we can simply return `null` from this method.
    Let's look at the difference between the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create our `BoundlessTextBlock` class by extending the `TextBlock`
    class. Probably, one of the easiest ways to do this in **Visual Studio** is to
    add a WPF User Control object into our Controls folder and then simply replace
    the word `UserControl` with the word `TextBlock` in both the XAML file and its
    associated code behind file. Failure to change both will result in a design-time
    error that complains that **Partial declarations of** ''**`BoundlessTextBlock`**''
    **must not specify different base classes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen from this example, our XAML file can be left remarkably empty,
    and for our requirements, we only need to override the single `GetLayoutClip`
    method in the code behind file. In this first example, we will return an `EllipseGeometry`
    object with the same size as the text block that will be used in the user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how we can use our new class. First, we need to define a XAML Namespace
    that maps to the CLR namespace where we saved the class. Next, for demonstration
    purposes, we wrap our `BoundlessTextBlock` object in a `Border` object, so that
    we can see its natural bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the visual output from this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64858898-4506-4b38-9503-07f8038db0cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the visual output from our `BoundlessTextBlock` object has
    been restricted to display only the pixels that lie within the `EllipseGeometry`
    object that was returned from the `GetLayoutClip` method. *But what will happen
    if we return an* `EllipseGeometry` *object that is larger than our custom text
    block?* Let''s find out, by returning this object instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, looking at the visual output of our `BoundlessTextBlock` object, we can
    see that the content of our custom text block now extends beyond its bounds, thanks
    to the `Border` object and the blue background:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9368f750-445e-4664-990f-a16f067a8d3e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, we can see that the clipping that is applied using the `Geometry` object
    that is returned from the `GetLayoutClip` method is not only unaffected by the
    control''s natural bounds, but in fact, can directly alter them. Returning to
    our original idea on this subject, if we want to totally remove the clipping at
    the control''s bounding edges, we can simply return `null` from this method instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the result of this change now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb9a6ae0-1df0-4509-9f03-e1ce24889ec7.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the text now reaches right out of the boundary of the containing
    `TextBlock` object, and continues until the end of the text value. Note that it
    would extend as long as the text string requires, if given enough space by its
    parent control(s).
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at another example of extending these classes to alter their functionality
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Altering default behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The developers of the `ItemsControl` class gave it a particular default behavior.
    They thought that any objects that extended the `UIElement` class would have their
    own UI container and so, should be displayed directly, rather than allowing them
    to be templated in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a method named `IsItemItsOwnContainer` in the `ItemsControl` class,
    which is called by the **WPF** Framework, to determine if an item in the `Items`
    collection is its own item container or not. Let''s first take a look at the source
    code of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that internally, this method just calls the `IsItemItsOwnContainerOverride`
    method, returning its value unchanged. Let''s take a look at the source code of
    that method now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see two things: The first is the default implementation that was just
    mentioned, where `true` is returned for all items that extend the `UIElement`
    class, and `false` for all other types. The second is that this method is marked
    as `virtual`, so we are able to extend this class and override the method to return
    a different value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at the crucial part of the `ItemsControl` class source code
    (without the comments), where our overridden method would be used. This excerpt
    is from the `GetContainerForItem` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With the default implementation, we see that `UIElement` items are cast to the
    type of `DependencyObject`, and set as the container, while a new container is
    created for items of all other types. Before overriding this method, let's see
    what effect the default behavior has, using an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aim of this example is to render a little hollow circle for each item in
    a collection. Think of a slide show, where these circles would represent the slides,
    or a page numbering or linking system. We, therefore, need a collection control
    containing some items and a `DataTemplate`, with which to define the circles.
    Let''s see the collection control with the items on their own first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We start with the resources, where we have declared an `ItemsPanelTemplate`,
    that is set to an instance of a `StackPanel`, with its `Orientation` property
    set to `Horizontal`. This will make the panel's items appear horizontally. We
    then added a basic `Style`, in which we set our common properties for the `Rectangle`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the markup, we have a `Grid` panel with two rows. In the first row, we have
    a `ListBox` named `ListBox`, with three colored `Rectangle` objects declared within
    its `Items` collection. Its `ItemsPanel` property is set to the `ItemsPanelTemplate`
    instance that we declared in the control''s `Resources` section. The second row
    is currently empty, but let''s see the visual output so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4a3615c-e68a-4350-a624-4b2a3db432b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, so good. We can see our three rounded rectangles in the `ListBox` control.
    Now, let''s add a `DataTemplate` into the `Resources` section and an `ItemsControl`
    element into the second row of the `Grid` panel, declaring it directly underneath
    the `ListBox` XAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that this `ItemsControl` element has its `ItemsSource` property data bound
    to the `Items` property from the `ListBox`, using an `ElementName` binding. Like
    the `ListBox` control, it also arranges its items horizontally, using the `ItemsPanelTemplate`
    resource. It also applies the new `DataTemplate` element that we just added into
    the `Resources` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this `DataTemplate`, we define a hollow gray `Ellipse` element to be rendered
    for each item in the collection, specifying its dimensions, spacing and stroke
    settings. Let''s take a look at the visual output of our example now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8094656d-d5f4-442e-81d2-d4f0811ec150.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have some unexpected results. Instead of rendering the small
    gray ellipses that we defined in the `DataTemplate`, the items in the `ItemsControl`
    display the actual items from the `ListBox`. Even worse than that, as each UI
    element can only be displayed in one location at any given point in time, the
    original items no longer even appear in the `ListBox`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may see an `ArgumentException` being thrown regarding this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*But why haven''t these objects been rendered as hollow circles in the second*
    `ListBox`*, according to our* `DataTemplate`*?* *Do you remember the* `IsItemItsOwnContainerOverride`
    *method that we investigated?* Well, that is the reason.'
  prefs: []
  type: TYPE_NORMAL
- en: The objects that are data-bound to the `ItemsControl`'s `ItemsSource` property
    extend the `UIElement` class, and so the `ItemsControl` class uses them as their
    own containers, rather than creating a new container and applying the item template
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: '*So, how do we change this default behavior?* That''s right, we need to extend
    the `ItemsControl` class and override the `IsItemItsOwnContainerOverride` method
    to always return `false`. In this way, a new container will always be created
    and the item template will always be applied. Let''s see how this would look in
    a new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here we have the very simple `ForcedContainerItemsControl` class, with its single
    overridden method, that always returns `false`. We need to do nothing else in
    this class, as we are happy to use the default behavior of the `ItemsControl`
    class for everything else.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that remains is for us to use our new class in our example. We start by
    adding a XAML Namespace for our `Controls` CLR Namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we replace the `ItemsControl` XAML with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the new visual output now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/576ab18e-5550-4f71-aa5e-9cb53c8bcadc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we see what we were originally expecting to see: a little hollow circle
    rendered for each item in the collection. The items in our custom `ItemsControl`
    have now all been generated a new container and had our template applied to them
    as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: '*But what if we need to make use of the selected item in this example?* The
    `ItemsControl` class has no concept of a selected item, so in this case, we would
    need to use a `ListBox` control in the second row of the `Grid` panel.'
  prefs: []
  type: TYPE_NORMAL
- en: However, note that the `ListBox` class has also overridden the `IsItemItsOwnContainerOverride`
    method, so that it does not suffer from this same problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, it will only use an item as a container if it is actually the correct
    container for this class; a `ListBoxItem`. Let''s see its overridden method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, if we need access to the `SelectedItem` property from the `ListBox`
    class, then we do not need to create our own extended class to override this method,
    and can instead use their standard implementation. To get the same visual output
    however, we would need some styles to hide the `ListBox`''s border and selected
    item highlights. Let''s see a basic example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We would also need to update our `EllipseDataTemplate` template to include
    a trigger to highlight the small `Ellipse` object when its related item is selected
    in the top `ListBox` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we''ll need to replace our `ForcedContainerItemsControl` element
    with a standard `ListBox` and apply our styles to it and its containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the application now, we see that the small hollow `Ellipse` objects
    become filled when their related item is selected in the top `ListBox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c9e7f03-1edb-4ed1-9a87-b3fd865b0c61.png)'
  prefs: []
  type: TYPE_IMG
- en: So, we've seen how we can override these protected methods to change the default
    behavior of the built-in controls. Let's now take a look at how we can build these
    protected methods into our own custom classes, so that they can affect the natural
    flow of a piece of our control's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Creating overridable methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing that we need to do is to define either an abstract or a virtual
    method in our base class. Note that the class would need to be abstract in order
    to declare an abstract method. Which one we chose will depend on if we want to
    leave the implementation up to the developers that use our code, or if we have
    some implementation that we need to put in the method ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example to clarify this. Here, we see a method from an abstract
    `BaseDragDropManager` class. It handles the `PreviewMouseMove` event on controls
    that are used as drag and drop sources, for example, on a `ListBox` from which
    an item is being dragged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `DragSourcePreviewMouseMove` method first performs a check
    to verify that a drag operation has been initiated by the user. It then calls
    the `OnDragSourcePreviewMouseMove` method, which is marked as `virtual`, which
    makes overriding it in derived classes optional.
  prefs: []
  type: TYPE_NORMAL
- en: The next line of the `DragSourcePreviewMouseMove` method checks the `Handled`
    property of the `MouseEventArgs` input parameter and if it has been set to `true`
    in the derived class, it returns execution to the caller, instead of continuing
    with the drag and drop operation. If the event has not been handled, then the
    `OnDragStart` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: This is the crucial bit that links the possible input from the derived classes.
    The only reason to override the `OnDragSourcePreviewMouseMove` method in an extending
    class is to set the `Handled` property of the `MouseEventArgs` input parameter
    to `true` and stop the drag and drop operation from starting, perhaps according
    to some information that the extending class has.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, the `OnDragStart` method is marked as `abstract`, requiring it to
    be overridden in all derived classes. This is the method that prepares the data
    for the drag and drop process, and is required to call the `StartDrag` method
    of the base class to start the operation, passing the prepared data.
  prefs: []
  type: TYPE_NORMAL
- en: In this particular example, our virtual method is left empty in the base class
    and there is no need to call it from the overridden method. More typically, the
    base class would contain a default implementation, which could be overridden in
    derived classes, but may require a call to the base class, in order to retain
    its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a .NET Framework programming guideline exists for raising base
    class events from derived classes. Ordinarily, derived classes cannot raise base
    class events and any attempts to do so will be met with a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution to this problem from the guidelines is to wrap the invocation
    of these events in a protected method in the base class, so it can be called or
    overridden in derived classes. Let''s add a custom `EventArgs` class and an event
    into our `AddressControl` control that demonstrates this guideline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a custom `EventArgs` class for our event. Then, we declare
    an event named `AddressChanged` and a protected virtual method that raises it,
    using the null conditional operator. This can be called directly from derived
    classes to raise the event, but also overridden, to add to or to stop the base
    class implementation from executing.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we update our `Address` property to call the invocation method, passing
    in the required previous and current `Address` objects. Note that we now also
    mark this property as `virtual`, so that derived classes can override it as well,
    to fully control how, when and if the event should be raised.
  prefs: []
  type: TYPE_NORMAL
- en: This is a far more preferable solution to declaring a virtual event and overriding
    it in a derived class, as the compiler does not always handle this situation as
    expected, due to some complicated event overriding rules, and we cannot always
    be certain which version of the event a subscriber will actually by subscribing
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a better understanding of these protected methods, let's take
    a look at what other kinds of things we can do by overriding them in derived classes.
    We will use an extended example that raises a number of problems, that we can
    fix by overriding a number of these protected base class methods.
  prefs: []
  type: TYPE_NORMAL
- en: Tailoring to attain our requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's imagine that we want to create an application that displays tabular data.
    This doesn't initially sound very complicated, but it is actually a very good
    example with which to demonstrate how to adapt the built-in .NET controls to fulfill
    our requirements. As we progress through this example, we will come across several
    potential problems and find out how to overcome each one in turn.
  prefs: []
  type: TYPE_NORMAL
- en: For this extended example, we will create a `Spreadsheet` control. As always,
    when creating new controls, we look at the existing controls, to see if any of
    them can provide us with a good starting point. The first control that springs
    to mind is the `Grid` panel, as it has rows, columns and therefore also cells,
    but the creation of all of the `RowDefinition` and `ColumnDefinition` objects
    could be cumbersome or problematic.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the `UniformGrid` panel, but as its name suggests, all of its
    cells are uniform, or the same size as each other, but this is not always the
    case in spreadsheets. We could potentially use an `ItemsControl` object and a
    custom `DataTemplate` to draw the borders and contents of each cell manually,
    *but could there be a better starting point?*
  prefs: []
  type: TYPE_NORMAL
- en: '*How about the* `DataGrid` *control?* It has rows, columns, and cells, and
    even draws the grid lines between the cells for us. It also has the concept of
    a selected cell, which could be useful if we wanted users to interact with our
    spreadsheet control. It has no numbers, letters, or selected cell markers in the
    grid axes, but we can extend the control to add these, so it seems like the best
    candidate for the job.'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that we need to do is to create a new class that extends the
    `DataGrid` class. As we saw earlier in this chapter, we can do this by adding
    a `UserControl` to our project and replacing the word `UserControl` with the word
    `DataGrid` in both the XAML file and its code behind file. Failure to change both
    will result in a design-time error that complains about mismatched classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our new `Spreadsheet` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The code behind is a simple affair, currently with no custom code in it. The
    XAML however, has a number of important properties set in it, so let''s see that
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For this implementation, we set the `AutoGenerateColumns` property to `False`,
    because we will be programmatically creating the columns of our spreadsheet control.
    In order to approximate a spreadsheet control, we also need to restrict the selection
    possibilities of our custom `DataGrid`.
  prefs: []
  type: TYPE_NORMAL
- en: As such, we set the `SelectionUnit` property to `Cell`, so that users select
    just the cell that they click on, rather than the whole row, which is the default
    selection behavior. In addition, to simplify this example, we also set the `SelectionMode`
    property to `Single`, the `IsReadOnly` property to `True` and the `RowHeight`
    property to `20`.
  prefs: []
  type: TYPE_NORMAL
- en: Our row and column headers will both be 26 pixels each, so we set the `RowHeaderWidth`
    and `ColumnHeaderHeight` properties to `26`. Note that we could set the row and
    column header dimensions in their relative styles instead, but we will need to
    reference these properties later, so it is important that we set them here. The
    next five properties, prefixed with `CanUser`, have also been set to `False`,
    to further shorten this example.
  prefs: []
  type: TYPE_NORMAL
- en: We then set both of the `HorizontalGridLinesBrush` and `VerticalGridLinesBrush`
    properties to the `GridlinesBrush` brush from the `Resources` section and the
    `BorderBrush` property to the `BorderBrush` brush. Note that we need to use a
    `DynamicResource` markup extension in these cases, because these brushes are defined
    after the `DataGrid` declaration, along with the rest of the resources, and the
    XAML parser would not be able to locate them with a standard `StaticResource`
    markup extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that it is essential that we remove the empty `Grid` panel that
    Visual Studio adds into each new `UserControl`. The reason is that any elements
    declared inside the `DataGrid` control are determined to be its items and we cannot
    simultaneously use both its `Items` property and its `ItemsSource` property, which
    we intend on using. If we use them both, we''ll see this exception being thrown
    at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let's move on now, to investigate how we can display data in our spreadsheet.
  prefs: []
  type: TYPE_NORMAL
- en: Populating with Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to get some data into our `Spreadsheet` control, we will need a class
    to represent each cell in the spreadsheet. Let''s take a look at a basic `Cell`
    class now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is a very straight forward class, with just three properties, a constructor
    to populate those properties, and an overridden `ToString` method. As usual, we
    extend our `BaseDataModel` class to provide us with access to the `INotifyPropertyChanged`
    interface. Note that in a real spreadsheet-based application, we would have many
    more properties in this class, to enable us to style and format the content appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now move on, to create our `SpreadsheetViewModel` and `SpreadsheetView`
    classes. In the `SpreadsheetViewModel` class, we populate a `DataTable` with some
    basic example data and we data bind that to our new `Spreadsheet` control in the
    `SpreadsheetView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this very simple View Model, we declare a single property of type `DataRowCollection`,
    to contain our spreadsheet data. Using this type enables us to easily populate
    our spreadsheet from a `DataTable` object, which we may have loaded from a database,
    or generated from an XML file, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the constructor, we programmatically initialize and populate a `DataTable`
    with example `Cell` objects and set its `Rows` property value to our `Rows` property.
    Let''s see how this `Rows` property is data-bound to our `Spreadsheet` control
    in the `SpreadsheetView` class now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Once again, this is a very simple class, with nothing other than a XAML Namespace
    declaration for our `Controls` project and one of our `Spreadsheet` controls,
    with its `ItemsSource` property data bound to the `Rows` property of our View
    Model. The code behind is even more bare, with no custom code in it at all. Also,
    remember to link our View and View Model together, using whichever method you
    prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can see any data in our `Spreadsheet` control, however, we will need
    to declare a `DataTemplate` to define how each cell should be rendered and programmatically
    set up our columns, in relation to the data-bound items. Let''s declare the required
    XAML Namespace in the XAML file and add the `DataTemplate` into the `Resources`
    section of our `Spreadsheet` control first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a horizontally centered `TextBlock` control, to output the contents
    of each cell. In a real-world application, we'd surround it with a `Border` element,
    to color the background of each cell and data bind to many more properties, to
    enable us to set different style and formatting settings for each cell. For this
    example, however, we'll keep it simple.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the subject of column generation now, remember that we do not know
    how many columns there will be in the incoming data, so we need to find a place
    to set them up programmatically. For this, we return to the protected base class
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking through the protected methods of the `DataGrid` class, we see a good
    candidate: the `OnItemsSourceChanged` method. This method will be called each
    time the `ItemsSource` value changes, so it''s an ideal place to initialize our
    spreadsheet columns when the data source changes.'
  prefs: []
  type: TYPE_NORMAL
- en: But our items are `DataRow` objects, with each `Cell` object being in a different
    location in its `ItemArray` collection. We need a way to use the array syntax
    to data bind each `Cell`, but the built-in column types don't have this functionality.
    As such, we will need to create a custom one and the `DataGridTemplateColumn`
    class is the best place to start.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can override this class to add a property named `Binding` of type `Binding`
    and use it to set the binding on the UI element that is generated for each cell.
    Looking through the protected methods in the `DataGridTemplateColumn` class, we
    find the `GenerateElement` method, which generates these UI elements. Let''s see
    this new `DataGridBoundTemplateColumn` class now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This is another simple class and, we start by extending the `DataGridTemplateColumn`
    class and declaring the aforementioned `Binding` property. We then override the
    `GenerateElement` method and in it, first call the base class implementation to
    generate the `FrameworkElement` object that relates to the current cell, passing
    the input parameters through unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: If the `Binding` property is not `null`, we then call the `SetBinding` method
    on the element, specifying the `ContentPresenter.ContentProperty` Dependency Property
    as the binding target and passing the `Binding` object from the `Binding` property
    through to connect with it. We end by simply returning the generated element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s return to the code behind of our `Spreadsheet` class, where we
    need to use our new `DataGridBoundTemplateColumn` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned previously, we override the `OnItemsSourceChanged` method to initialize
    our spreadsheet columns each time the data source changes. In it, we use C# 6.0
    Pattern Matching to verify that the `newValue` input parameter is not `null` and
    is of type `DataRowCollection`, before also checking that the collection has one
    or more rows in it.
  prefs: []
  type: TYPE_NORMAL
- en: If the `DataRowCollection` object is valid, then we cast the items in the `ItemArray`
    collection of its first row to an array of our custom type `Cell`. We only need
    to use the first row, because here, we are just setting up the columns, not the
    data. We then clear the columns of our spreadsheet control and find the `DataTemplate`
    named `CellTemplate` from the control's `Resources` section.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we iterate through the `Cell` objects in the array, adding a new `DataGridBoundTemplateColumn`
    element to the spreadsheet's `Columns` collection for each one. Each column element
    is initialized with a `Header`, taken from the `GetColumnName` method, the `CellTemplate`
    `DataTemplate`, the `Width` from the `Cell` object, and a `Binding` object.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `Binding` path is set to `$"[{i}]"`, which would translate to
    `"[0]"` for the first item for example, and represents the standard indexing notation.
    This would result in the binding path being set to the first item in each row
    of the data-bound collection, or put another way, each cell in the first column
    of our data source.
  prefs: []
  type: TYPE_NORMAL
- en: If the input value in the `GetColumnName` method is between 1 and 26, we add
    64 to it, before casting it to a `char` and then calling the `ToString` method
    on the result. The capital A character has the integer value of 65 in the ASCII
    table and so, this code has the effect of turning the index of the first 26 columns
    into the letters A to Z.
  prefs: []
  type: TYPE_NORMAL
- en: If the input value is more than `26` and is also an exact multiple of `26`,
    then we return the string concatenation of a recursive call to the `GetColumnName`
    method, passing in the factor of the input value when it is divided by `26`, with
    `1` subtracted from it, and the letter `Z`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If none of the `if` conditions are met, we return the result of two more recursive
    calls: the first passed value represents the factor of the input value when it
    is divided by 26 and the second represents the remainder of the input value when
    it is divided by 26.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In plain English, the first line outputs letters A to Z, while the second handles
    column identities that contain more than a single letter and end in the letter
    Z, and the third line handles all of the rest. Let''s see what we have when running
    the application so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fc648f4-48be-49de-966a-1cf54de2665e.png)'
  prefs: []
  type: TYPE_IMG
- en: Progressing toward the Target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*So, what changes do we need to make to the turn this* `DataGrid` *control
    into something that looks more like a spreadsheet?* We need to style it accordingly
    and to populate the row headers with numbers that identify each row. We also need
    to highlight the relevant row and column headers when a cell is selected and can
    implement an animated selection rectangle to highlight the selected cell, instead
    of using the default highlighting shown in the image.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s populate the row headers with numbers. There are several ways
    to achieve this, but I prefer to simply ask each row what its index is in a converter
    class and connect it to the row header via a data binding. Let''s see this converter
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is another simple class and, as usual, we start by specifying the data
    types involved in the converter in the `ValueConversion` attribute. In this case,
    our input will be `DataRow` objects and our output will be their integer row numbers.
    In the `Convert` method, we use Pattern Matching from C# 6.0 as a shortcut to
    validate that our input value is not `null` and is of the appropriate type and
    if suitable, to cast it to that type.
  prefs: []
  type: TYPE_NORMAL
- en: If the input is valid, we call the `GetIndex` method on the pre-cast `dataGridRow`
    variable, remembering to add 1 to the zero-based method result, before returning
    it from the converter. For all other input values, we return the `DependencyProperty.UnsetValue`
    value. As we will not need to convert any values in the other direction, we leave
    the `ConvertBack` method unimplemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we use this `converter` class now. First, we need to set up
    a XAML Namespace for our `Converters` CLR Namespace and create an instance of
    it in the control''s `Resources` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We are then able to use it in a data binding on the `Text` property of a `TextBlock`
    element in the `DataTemplate`, that is applied to the `RowHeaderTemplate` property
    in our custom `DataGrid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that the binding path is set to `.`, which as you may remember, sets it
    to the whole binding object. The `RelativeSource` binding sets the binding source
    to the first ancestor of the `TextBlock` of type `DataGridRow`, and so we pass
    the whole `DataGridRow` object through to the binding and therefore, also to the
    converter, as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that we must declare this `RowHeaderTemplate` property below the
    `Resources` section in the XAML file. Failure to do this will result in the following
    runtime error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Whereas sometimes we can fix these "reference not found" errors by using a `DynamicResource`
    markup extension instead of a `StaticResource` markup extension, it won't work
    in this case. This is because we can only use them on a `DependencyProperty` of
    a `DependencyObject` and the `Converter` property is not a `DependencyProperty`
    and the `Binding` class is not a `DependencyObject`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what our spreadsheet looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57f6f121-0eaa-4d6d-9e52-bf5083725d6f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As can be seen from the preceding image, we clearly need to add some styling
    to fix some issues and make it look more like a typical spreadsheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The only thing to note here are the first four `SolidColorBrush` objects that
    we declared. They are used by the .NET Framework to set the default selection
    colors for a number of the built-in controls. We can use them to change the default
    blue background and white text shown in the previous image. There are many more
    of these default colors to be found in the `SystemColors` class, so it's worth
    familiarizing yourself with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what our spreadsheet looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/968e19ba-f48e-47ac-9c51-fbeecc315929.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, our `Spreadsheet` control is starting to look more like a typical spreadsheet
    application, but we have no highlighting for our selected cell anymore. You may
    also notice that the row headers are not center-aligned horizontally, as our style
    suggests they should be.
  prefs: []
  type: TYPE_NORMAL
- en: This happens because, unlike the default `ControlTemplate` for the `DataGridColumnHeader`
    class, the default `ControlTemplate` for the `DataGridRowHeader` class does not
    map the `HorizontalContentAlignment` property to the `HorizontalAlignment` property
    on any internal elements within the template.
  prefs: []
  type: TYPE_NORMAL
- en: This might at first seem like an oversight on Microsoft's part, but it is actually
    because, in the default `ControlTemplate`, each `DataGridRowHeader` object has
    an additional control that displays the validation error to the right of the header
    content. With this extra control taking up the limited space, there is not enough
    space to horizontally center the row header.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this problem, we will need to alter the default `ControlTemplate`, to
    remove the control that displays the error template. Co-incidentally, we will
    also need to alter this template to be able to highlight the selected cell in
    the row header. Likewise, to highlight the selected cell in the column header,
    we will need to adjust the default `ControlTemplate` for the `DataGridColumnHeader`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting the selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s now move onto the task of highlighting the selected cell. Here, we will
    find out what is required to create a selection rectangle around the selected
    cell, that smoothly animates from selection to selection. But before that, let's
    investigate how we can also indicate which cell is selected in the axes of our
    spreadsheet control.
  prefs: []
  type: TYPE_NORMAL
- en: Indicating in the Axes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to highlight the currently selected cell in the row and column headers,
    we will need to update the two relating default `ControlTemplate` objects, as
    just described. But before we do that, we will need to declare two new `IValueConverter`
    classes as well. Let''s look at the row header converter class first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: For this converter, we extend the `IMultiValueConverter` interface, and in the
    `Convert` method, we first validate our values input parameter. If it is `null`,
    contains more or less than two objects, or if either of the contained objects
    are not non-`null` `DataRow` objects, we return `false`. If the input parameter
    is valid, we use C# 6.0 Pattern Matching to cast the two contained objects to
    the `DataRow` type.
  prefs: []
  type: TYPE_NORMAL
- en: The first represents the `DataRow` object that contains the currently selected
    cell and the second comes from the `DataRow` object to compare. We return `true`
    if the selected `DataRow` object equals the currently compared `DataRow` object
    and `false` for all others. You can think of this as each row header asking the
    converter in turn, if it is in the same `DataRow` object as the currently selected
    cell. The `ConvertBack` method is unrequired for our example and so, is left unimplemented.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now investigate the changes that we need to make to the default `ControlTemplate`
    for the `DataGridRowHeader` class. As described in *[Chapter 5](d5906090-c679-45d6-81cd-016d4337eb75.xhtml),
    Using the Right Controls for the Job*, in the *Modifying Existing Controls* section,
    we can create a copy of the default `ControlTemplate` from the Properties panel
    in Visual Studio. Note that if we do not already have a control of the correct
    type in our XAML file, we can simply declare one temporarily, select it, then
    continue with the process of template extraction as described, remembering to
    delete it afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'As this template is quite long, we won''t show it all here, instead highlighting
    just the areas that we need to change. The entire code will be available in the
    separate downloadable code bundle that comes with this book. Before we can use
    this template however, we need to add a reference to the `PresentationFramework.Aero`
    assembly to our project and a XAML Namespace for the `Microsoft.Windows.Themes`
    CLR Namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add an instance of our new converter class into our spreadsheet
    control''s `Resources` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to apply the template, we''ll need to add another `Setter` element
    into our `Style` for the `DataGridRowHeader` class, making sure that the template
    is declared before it in the XAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: After attaining a copy of the default `ControlTemplate` for the `DataGridRowHeader`
    class, we first named the `DataGridHeaderBorder` element `Border`, so that we
    could refer to it from the template's `Triggers` collection. We also set its `IsHitTestVisible`
    property to `False` to prevent selection from the row headers.
  prefs: []
  type: TYPE_NORMAL
- en: We then removed the control that displayed the validation error template and
    connected the `HorizontalAlignment` property of the internal `ContentPresenter`
    element with the `HorizontalContentAlignment` property of the parent `DataGridRowHeader`
    object via a `TemplateBinding` element, so that our style will actually center
    the header content, as previously expected.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we added a new `Rectangle` element, named `ColorSelectionBar`, and a `DataTrigger`
    object. The `Rectangle` element has its `Fill` property set to `Transparent`,
    so that it cannot initially be seen, and its `IsHitTestVisible` property set to
    `False`, to prevent users from being able to interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: We set its `VerticalAlignment` property to `Stretch`, so that it spans the full
    height of the row header, and its `HorizontalAlignment` property to `Right`, to
    ensure that it lies to the right of the header, out of the way of the row indicator.
    Finally, we set its top margin to `-1`, in order to extend it over the top border
    of the header, as it already extends over the bottom border by one pixel.
  prefs: []
  type: TYPE_NORMAL
- en: We then added a `DataTrigger` object into the `Triggers` collection, using a
    `MultiBinding` object to define its conditions. We assigned our `DataGridRowHeaderSelectionMultiConverter`
    instance to the `Converter` property of the `MultiBinding` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `MultiBinding` object has two bindings: one is the `DataRow`
    object that relates to the `CurrentCell` property of the `DataGrid` control and
    the other is set directly to the `DataRow` object that the template is applied
    to.'
  prefs: []
  type: TYPE_NORMAL
- en: When the converter returns `true`, we paint the `ColorSelectionBar` element
    and the header foreground with our `SelectionBrush` brush and the `Border` element,
    which represents the background of the row header, with the `SelectedBackgroundBrush`
    brush. This results in the row header of the selected cell being highlighted each
    time a cell is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now do the same for the column headers, starting with a look at the
    required `DataGridColumnHeaderSelectionMultiConverter` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We again extend the `IMultiValueConverter` interface, and in the `Convert` method,
    we start by checking the input values to ensure their validity for this converter.
    We validate that the `values` input parameter is not `null` and that it contains
    two non-`null` values, that are also not unset values. If any of these checks
    fail, we return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: If the `values` input parameter is valid, we call the `object.ToString` method
    on the two objects contained within it. The first value represents the text in
    the selected column header and the second represents the text in the column header
    to compare.
  prefs: []
  type: TYPE_NORMAL
- en: Every column header will call this converter in turn and if the column header
    to compare equals the selected column header, that signifies that it is the column
    that contains the selected cell and we return `true`, otherwise we return `false`.
    As the `ConvertBack` method is unrequired for this example, it is left unimplemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we alter the default `ControlTemplate` for the `DataGridColumnHeader`
    class, we will need to add a reference to our new `converter` class into our spreadsheet
    control''s `Resources` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see the edited template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Starting with the default `ControlTemplate` for the `DataGridColumnHeader` class,
    we again added a single UI element and a single `DataTrigger` object, with which
    to control its visibility, as we did with our custom `DataGridRowHeader` `ControlTemplate`.
    However, this template requires less alteration, as its header is already centered
    and we do not need to remove any elements.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, the `Rectangle` object named `ColorSelectionBar` is the new element.
    Note that we set its `Fill` property to `Transparent`, so that it cannot initially
    be seen. Remember that there is a column header on every column and we don't want
    them all to be highlighted at once.
  prefs: []
  type: TYPE_NORMAL
- en: We set the `Rectangle` element's `IsHitTestVisible` property to `False`, to
    prevent users from being able to interact with it. We set its `HorizontalAlignment`
    property to `Stretch`, so that it spans the full width of the column header, regardless
    of its size, and its `VerticalAlignment` property to `Bottom` to ensure that it
    lies at the bottom of the header, leaving space for the column identifier.
  prefs: []
  type: TYPE_NORMAL
- en: We set its left margin to `-1`, in order to extend it over the left border of
    the header, as it already extends over the right border by one pixel. In the `Triggers`
    section of the `ControlTemplate`, we added a `DataTrigger` object, with a `MultiBinding`
    object that has a reference to our `DataGridColumnHeaderSelectionMultiConverter`
    class set to its `Converter` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we have two `Binding` elements connected to it: one is set to the
    `Header` property of the currently selected `Column` object and the other is set
    directly to the `Content` property of the `DataGridColumnHeader` class. Each column
    header will call the converter in turn and if you remember, the column that contains
    the selected cell will result in the converter returning `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: When the `MultiBinding` object that is connected to this converter returns `true`,
    the `DataTrigger` `Setter` fills the header foreground and the `ColorSelectionBar`
    rectangle with the `SelectionBrush` resource and the background of the header
    with the `SelectedBackground` resource, highlighting the column header of the
    currently selected cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to apply this `ControlTemplate` object, we''ll also need to add a
    `Setter` element into our `Style` for the `DataGridColumnHeader` class, making
    sure that the template declaration is before the `Style` declaration in the XAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have made minimal changes to the two default `ControlTemplate`
    objects, yet we have managed to adapt them to our purposes. In this way, we are
    able to manipulate the built-in .NET controls, to further extend their original
    usefulness. Let''s see the visual output from this latest addition to our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce0be1cf-7f18-4517-98ee-9ecfb2dde47b.png)'
  prefs: []
  type: TYPE_IMG
- en: We now have a grid that is starting to look more like a typical spreadsheet
    application. Let's continue and add cell selection highlights for the users.
  prefs: []
  type: TYPE_NORMAL
- en: Emphasizing the Selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All that is left for us to do now is to implement the selection rectangle and
    the style for the Select All button in the top left corner of the control. We
    can accomplish both tasks by adjusting the default `ControlTemplate` for the `DataGrid`
    class. Let''s break this down into steps. First, we need to add a `ControlTemplate`
    for the Select All button into our `Resources` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have another very simple template, where we replace the default definition
    of a `Button` control with a basic triangle. It contains a `Border` element, that
    draws its right and bottom borders with the `DiagonalBorderGradient` brush that
    we added to the spreadsheet control's resources. It also paints the background
    of the `Button` control with our `BackgroundBrush` resource.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `Border` element, we declare a `Polygon` shape, which we fill with
    a gray brush. Its shape is determined by the values declared in its `Points` property,
    so it begins at `0,12`, continues to `12,12` , and `12,0`, before returning to
    `0,12`. Plotting these values on a graph would show a triangle and that is the
    shape that this `Polygon` element will render.
  prefs: []
  type: TYPE_NORMAL
- en: We align it to the bottom right of the `Border` element and set its `Stretch`
    property to `Uniform` to ensure that its aspect ratio is maintained throughout
    any changes of its size. Finally, we set its `Margin` property to space it away
    from the `Border` element's edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to apply the `SelectAllButtonControlTemplate` template to the
    Select All button and add a transparent `Canvas` element into the `ControlTemplate`
    for the `ScrollViewer` object that appears inside the default `ControlTemplate`
    for the `DataGrid` class. Let''s extract this from the default template and declare
    it in our `Resources` section too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We first set a width and height of 26 pixels on the Select All button, in line
    with the dimensions of our row and column headers. We then apply our `ControlTemplate`
    from the `Resources` section to it. We also removed the `Visibility` binding from
    the default template, as we won't be needing that in our example. Note that this
    button has no action in our example and is purely decorative.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we added the transparent `Canvas` control, that will display the selection
    rectangle, within a `Border` element. Note that we must add it after the required
    `PART_ScrollContentPresenter` named part, to ensure that the selection rectangle
    will appear above the cells in the Z plane. Also, notice that we must wrap it
    in an invisible `Border` element, so that we can clip its bounds. Try removing
    the `ClipToBounds` property and resize the control to be smaller as an experiment
    to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: We set the `Margin` property on the `Border` element to be `-2` in all directions,
    so that it can display the selection rectangle over and just outside the bounds
    of each cell. We, therefore, need to set the `Margin` property on the `Canvas`
    that draws the rectangle to `2` in all directions, to compensate for the border's
    negative margin.
  prefs: []
  type: TYPE_NORMAL
- en: We name the `Canvas` element, so that we can access it from the code behind,
    and set its `Background` property to `null`, which is slightly cheaper than setting
    it to `Transparent`. We then set the `IsHitTestVisible` property to `False`, to
    make it invisible to the users and their mouse cursors and center the origin of
    the render transform, which we will use to update the position of the `Canvas`
    element each time the containing `ScrollViewer` object is moved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see our simplified `ControlTemplate` for the `DataGrid` class now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We made a few changes to the default `ControlTemplate` for the `DataGrid` control.
    The first was to set the `CanContentScroll` property to `False` on the `ScrollViewer`
    element named `DG_ScrollViewer`, to make it scroll in physical units (pixels)
    instead of logical units (rows). The only other change was to replace its inline
    `ControlTemplate` object with a reference to the custom template that we added
    into the `Resources` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also remember to assign this custom `ControlTemplate` object to our
    spreadsheet control. This can be achieved in the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see our `Spreadsheet` control again, with all the latest changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c7201f5-8745-48c0-8415-b0f3ac0b159e.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the job is nearly complete. We now have the XAML all set up
    to display the selection rectangle, but we still need to programmatically position
    and animate it. First, we'll need to attain a reference to the `Scrollviewer`
    from our custom `DataGrid` template.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve this by overriding another method from the `DataGrid` base class.
    The `OnApplyTemplate` method is called whenever a `ControlTemplate` is applied,
    so it''s an ideal location to access the elements contained within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we call the `FindName` method on the `Spreadsheet` control's
    template, passing in the name of our `ScrollViewer` object and a reference to
    the spreadsheet, as the templated parent. We then cast the returned object to
    a `ScrollViewer`, using the `as` operator keyword, to avoid exceptions being thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Note that as this spreadsheet example is quite long, we have omitted the usual
    `null` checks, with regards to accessing the internal controls from the `ControlTemplate`
    elements. In a real-world application, these checks should always be implemented,
    as we can never be sure that our required elements will be in the template, because
    it may have been changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a reference to the `Canvas` panel that we will draw our selection
    rectangle on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the `SpreadsheetScrollViewer_ScrollChanged` event handler, we start by checking
    if the `selectionRectangleCanvas` private variable is `null`. If it is, we call
    the `GetCanvasReference` method, to attain a reference to it and to assign it
    to a private member variable.
  prefs: []
  type: TYPE_NORMAL
- en: In the `GetCanvasReference` method, we access the `ControlTemplate` object from
    the `Template` property of the `ScrollViewer` element that we previously stored
    a reference to. We call the `FindName` method on it, passing in the name of our
    `Canvas` object and a reference to the `ScrollViewer` element, as its templated
    parent.
  prefs: []
  type: TYPE_NORMAL
- en: We then assign the returned object, cast to the `Canvas` type, to the private
    `selectionRectangleCanvas` member variable and set a new `TranslateTransform`
    object to its `RenderTransform` property. We will use this to update the position
    of the `Canvas` element each time the containing `ScrollViewer` object's viewport
    is moved, and this will ensure that the selection rectangle will be scrolled,
    along with the spreadsheet.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we attain a reference to the `Canvas` element from this event handler
    only in an attempt to shorten this example. A far better solution would be to
    extend the `ScrollViewer` class and declare a `TemplateChanged` event, that passed
    a reference of the new template in a custom `EventArgs` class.
  prefs: []
  type: TYPE_NORMAL
- en: We could raise it from an overridden `OnApplyTemplate` method, as we did to
    access our `ScrollViewer` reference, and subscribe to it from our `Spreadsheet`
    class. The problem with our current implementation is that the `ScrollChanged`
    event is raised many times and each time, we check if we already have the reference
    and so a lot of CPU cycles will be wasted when scrolling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the current implementation now, let''s assign our event handler
    for the `ScrollChanged` event to the `ScrollViewer` in our custom template for
    the `DataGrid` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now investigate the code that is used to draw and animate the selection
    rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In the `UpdateSelectionRectangle` method, we first declare a duration of 150
    ms to use in our animations and check if the selection rectangle has been initialized
    or not. If it hasn't, we call the `InitializeSelectionRectangle` method, passing
    the `startPosition` and `endPosition` input parameters through. Let's examine
    this method before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: In the `InitializeSelectionRectangle` method, we initialize the `SelectionRectangle`
    element, with dimensions calculated from the two `Point` input parameters and
    default values for its stroke. We assign a new `TranslateTransform` object to
    its `RenderTransform` property, to enable its position to be manipulated in code.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `SetTop` and `SetLeft` Attached Properties of the `Canvas` class
    to position the rectangle in the top left corner of the `Canvas` panel, that we
    added into our custom `ControlTemplate` for the `ScrollViewer` class.
  prefs: []
  type: TYPE_NORMAL
- en: We end by adding the `SelectionRectangle` element into the `Children` collection
    of the `selectionRectangleCanvas` panel and setting the `isSelectionRectangleInitialized`
    variable to `true`, to ensure that this initialization code is only called once.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the `UpdateSelectionRectangle` method now, if the selection rectangle
    has already been initialized, then we animate its size, from the size of the previous
    cell to the size of the newly selected cell, using the `startPosition` and `endPosition`
    input parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We call the `BeginAnimation` method on the `SelectionRectangle` element for
    both its `WidthProperty` and `HeightProperty` dependency properties, so that the
    dimensions of the rectangle will smoothly animate from the size of the previously
    selected cell to the size of the new one.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we access the `TranslateTransform` instance from the `RenderTransform`
    property of the `SelectionRectangle` element and call the `BeginAnimation` method
    on it, for both the `Xproperty` and `Yproperty` Dependency Properties. This is
    what animates the position of the selection rectangle on the `Canvas` that we
    added into the `ScrollViewer` element's template.
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the horizontal position, we subtract the value of the `RowHeaderWidth`
    property, that we set earlier in the XAML class declaration, from the `X` property
    value of the `startPosition` input parameter and then add the value of the `HorizontalOffset`
    property of the `ScrollViewer` element.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, the vertical position is calculated from the `Y` property value of
    the `startPosition` input parameter, with the value of the `ColumnHeaderHeight`
    property subtracted from it and the value of the `VerticalOffset` property of
    the `ScrollViewer` element added to it.
  prefs: []
  type: TYPE_NORMAL
- en: All four animations share the same duration, that we declared at the start,
    so that they morph the dimensions and position of our selection rectangle in unison.
    They also all set a `HandoffBehavior` value of `Compose`, which basically provides
    smoother joins between consecutive animations. We'll discover more about this
    in *[Chapter 7](83362be0-c3e7-4f3c-89b9-74104ac23f5d.xhtml), Mastering Practical
    Animations,* but for now, we'll keep it simple.
  prefs: []
  type: TYPE_NORMAL
- en: So, our `UpdateSelectionRectangle` method is responsible for animating the selection
    rectangle between the previous and current cell selections, *but where is it called
    from?* That's right... we're going to call it from yet another overridden protected
    base class method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking through the protected base class methods of the `DataGrid` class, we
    find the `OnSelectedCellsChanged` method, which is called each time a user selects
    a new cell in our spreadsheet control, so it''s the perfect candidate. Let''s
    take a look at its implementation now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note that the base class version of this method is responsible for raising the
    `SelectedCellsChanged` event, so if we need that to happen, we should call it
    from this method. If we are ever in doubt if to call the base class version of
    a method that we're overriding, it's generally safer to do so, as we might lose
    some required functionality that it provides otherwise. As we do not require this
    event in this example however, we can safely omit the call to the base class method.
  prefs: []
  type: TYPE_NORMAL
- en: In our overridden `OnSelectedCellsChanged` method, we check that the `AddedCells`
    property of the `SelectedCellsChangedEventArgs` input parameter contains exactly
    one item. Note that in this example, it should only ever contain a single item,
    because we set the `SelectionMode` property to `Single` on our spreadsheet control,
    but it is always good practice to validate these things.
  prefs: []
  type: TYPE_NORMAL
- en: We then extract the single `DataGridCellInfo` object from the `AddedCells` property
    and return execution from the method if it is invalid. If it is valid, we call
    the `GetCellContent` method on its `Column` property, passing in its `Item` property,
    to access the cell content as a `FrameworkElement` object. This could benefit
    from a little more explanation.
  prefs: []
  type: TYPE_NORMAL
- en: The `Column` property contains the `DataGridBoundTemplateColumn` element that
    relates to the selected cell and likewise, the `Item` property holds the `DataRow`
    object that contains the selected cell. The returned `FrameworkElement` object
    represents the content of the `DataGridCell` element, which in our case is a `ContentPresenter`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Any UI elements that we declare in the `DataTemplate` element that is applied
    to the `DataGridBoundTemplateColumn`. The `CellTemplate` property can be accessed
    through this `ContentPresenter` object, by walking the visual tree. In our case,
    that is a simple `TextBlock` element. Returning to our code now, if this cell
    content is `null`, we return execution from the method.
  prefs: []
  type: TYPE_NORMAL
- en: If the cell content is valid, we cast its `Parent` property value to its actual
    type of `DataGridCell`. If this `DataGridCell` object is `null`, we also return
    execution from the method. If it is valid, we call its `TransformToAncestor` method,
    followed by the `Transform` method, to find its onscreen position, relative to
    the spreadsheet control.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the relative position to create the start point, or the top left
    corner, of the rectangle, by subtracting 3 pixels in each axis. This ensures that
    the rectangle will sit just outside the cell contents, overlapping it slightly.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we also use the relative position to create the endpoint, or the
    bottom right corner, of the rectangle, by adding the actual dimensions of the
    `DataGridCell` object to it. Finally, we call the `UpdateSelectionRectangle` method,
    to draw the selection rectangle, passing the calculated start and endpoints through.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our selection rectangle is working and smoothly animates from one selected
    cell to the next. However, on a bigger spreadsheet, you might notice that it won't
    scroll in line with the spreadsheet itself. This is because there is not yet a
    connection between its position and the horizontal and vertical offsets of the
    `ScrollViewer` that it is defined inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this issue, we will need to update the positional information on
    the `TranslateTransform` object, from the `Canvas` element that the selection
    rectangle is drawn on, each time the spreadsheet control is scrolled. Let''s see
    how we do this, by adding further code into our `SpreadsheetScrollViewer_ScrollChanged`
    event handler now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Skipping over the existing code that attained the reference to our selection
    rectangle `Canvas` panel, we access the `TranslateTransform` element, that we
    declared in the `GetCanvasReference` method, from its `RenderTransform` property.
    We then create a new `TranslateTransform` object, with the values coming from
    the original one, plus the distance scrolled in either direction, and set it back
    to the `RenderTransform` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we have to do this because the `TranslateTransform` element is immutable
    and cannot be altered. Therefore, we need to replace it with a new element instead
    of just updating its property values. Any attempts to modify it will result in
    a runtime exception being thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a final look at the visual output of our spreadsheet control now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82470a99-ef3b-49b0-b420-274a72fb2aff.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, we could continue to improve our spreadsheet control, perhaps by
    adding event handlers to detect changes to the size of the rows and columns when
    users resize them and update the selection rectangle accordingly. We could extend
    the `Cell` class, to add style and format properties, to style each cell and format
    the content.
  prefs: []
  type: TYPE_NORMAL
- en: We could add a formula bar or an alternative information panel to display formulas
    or further information from the cells when clicked on. We could implement multi-cell
    selection, or enable users to edit cell contents. But either way, hopefully, this
    extended example has now provided you with enough understanding to be able to
    undertake these kinds of advanced projects successfully yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we further investigated the built-in controls, paying particular
    attention to the polymorphic ability to override base class methods in derived
    classes. We first examined examples from the .NET Framework source code, before
    moving on to create our own examples that highlight this ability.
  prefs: []
  type: TYPE_NORMAL
- en: We continued, introducing extended examples, to help to fully understand the
    benefits that can be gained from using this method. Through these examples, we
    highlighted a number of problems, and learned how to overcome them each in turn,
    by extending the built-in controls and overriding particular base class methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a thorough look at the WPF animation system
    and discover how we can utilize it in everyday applications. We'll also find out
    a number of techniques to fine-tune animations to get that perfect effect and
    discover how we can build animation functionality right into our application framework.
  prefs: []
  type: TYPE_NORMAL
