- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refactoring at the Method Level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we covered improving individual lines of code. We’ll expand
    on those lessons to cover refactoring entire methods and solving issues with how
    code comes together to form larger methods that then interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw a little of this in [*Chapter 2*](B21324_02.xhtml#_idTextAnchor026)
    when we covered the extract method refactoring. However, in this chapter, we’ll
    expand our set of tools covering the basics of refactoring methods and then move
    into more advanced areas as we cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the flight tracker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring to functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing static methods and extension methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The starting code for this chapter is available from GitHub at [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    in the `Chapter04/Ch4BeginningCode` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the flight tracker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter’s code focuses largely on a single `FlightTracker` class intended
    to track and display the outgoing flights from a commercial airport for passengers
    in the terminal, as pictured in *Figure 4**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – FlightTracker displaying outbound flight statuses](img/B21324_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – FlightTracker displaying outbound flight statuses
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FlightTracker` class has a number of methods related to managing and displaying
    flights. It is supported by the `Flight` class which represents an individual
    flight in the system and the `FlightStatus` `enum` which represents all relevant
    statuses of a flight, as shown in the class diagram in *Figure 4**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – A class diagram showing FlightTracker and supporting classes](img/B21324_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – A class diagram showing FlightTracker and supporting classes
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll explore these pieces of code throughout this chapter, but for now, we
    need to understand that the key responsibilities of `FlightTracker` include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Tracking a list of flights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling new flights (adding them to the list)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marking flights as arrived, departed, or delayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying all flights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding a flight by its ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a fairly simple flight tracker class, but we’ll see a slightly more
    complicated version of one in the next chapter as we explore object-oriented refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let’s look at a few simple steps we can take to improve these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll explore a number of refactorings related to methods and
    their interactions. We’ll start by discussing the access modifier of a method.
  prefs: []
  type: TYPE_NORMAL
- en: Changing method access modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'During my time as a professional C# instructor, I noticed my students often
    tended to not think about the **access modifiers** they used in their code. Specifically,
    my students would usually do one of two things:'
  prefs: []
  type: TYPE_NORMAL
- en: They marked all methods as **public** by default unless someone (usually me)
    suggested they use a different access modifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They marked all methods as **private** by default (or omitted the access modifier
    entirely, defaulting to **private** anyway) until the compiler gave them an issue
    requiring them to make a method more accessible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both approaches are insufficient for a simple reason: we want to explicitly
    declare the visibility level of our methods. This way, whenever you read code,
    you are reminded explicitly by the access modifier what other code can access
    the code you’re working with. This is particularly useful when working with non-private
    methods that can be referenced outside of the class.'
  prefs: []
  type: TYPE_NORMAL
- en: Access modifiers
  prefs: []
  type: TYPE_NORMAL
- en: C# has several access modifiers as of C# 12 that govern what other areas can
    refer to your code. The current access modifiers are `public`, `private`, `protected`,
    `internal`, `protected internal`, `private internal`, and the new `file` access
    modifier that restricts access to something within a single source file. While
    these access modifiers all have their uses, I’m going to focus primarily on `public`
    and `private` in this section for simplicity’s sake.
  prefs: []
  type: TYPE_NORMAL
- en: If we mark a method as **public**, **protected**, or **internal**, there should
    be a good reason for that – typically related to the method being a primary way
    in which we intend for others to use our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `FlightTracker` class has a `public` method called `FindFlightById` that
    is used by most of the other methods in the class but nothing outside of the class.
    This method looks up the flight by `ID` and returns it if one is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Given these circumstances, you might make an explicit decision to mark the
    method as `private`, restricting its usage within this class, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By marking this method as `private`, you have greater freedom in the future
    to rename it, change how it works, modify its parameters, or remove it entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the access modifier is generally safe if nothing outside the class
    uses the method. Otherwise, this decision will cause compiler errors.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming methods and parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at three very similar methods for managing flights in `FlightTracker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Each of these methods takes in a `DateTime` and a flight identifier string.
    However, the naming of these parameters and even these methods are not incredibly
    consistent.
  prefs: []
  type: TYPE_NORMAL
- en: '`DelayFlight` calls its flight ID variable `fId` and its new departure time
    `newTime`. `MarkFlightArrived` uses `time` for the arrival time and `id` for the
    flight identifier. `MarkFlightDeparted` uses `id` but chose `t` to denote the
    departure time.'
  prefs: []
  type: TYPE_NORMAL
- en: While some of these naming choices are better than others on their own, the
    lack of naming consistency in methods within the same class can hurt other people’s
    ability to work effectively with your code. This can lead them to feel less confident
    in your abilities and can even introduce bugs from misunderstandings of what parameters
    or methods represent – all due to a lack of consistency.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, we can use the *rename parameter* refactoring to rename individual
    parameters to ensure consistency. This can be done by right-clicking on a parameter
    and selecting **Rename…** from the context menu, or pressing *Ctrl* + *R* twice
    with the parameter selected. See *Figure 4**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Activating the rename parameter refactoring via the context
    menu](img/B21324_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Activating the rename parameter refactoring via the context menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, type the new name you want to use for the parameter and press *Enter*
    to complete the change. See *Figure 4**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Renaming the parameter](img/B21324_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Renaming the parameter
  prefs: []
  type: TYPE_NORMAL
- en: While choosing your names, you’ll want to pick something that is clear and consistent
    with the terminology and names you use in your class already. Avoid very short
    and single-letter parameters wherever possible (excluding some cases, such as
    `x` and `y` for coordinates or other established usages of short parameter names).
  prefs: []
  type: TYPE_NORMAL
- en: In the case of this code, I chose to rename all the flight identifiers to `id`
    and chose to be more explicit about the names of the `DateTime` parameters to
    indicate what the parameter represented.
  prefs: []
  type: TYPE_NORMAL
- en: 'I also chose to use the same rename tool to rename the entire method of `DelayFlight`
    to `MarkFlightDelayed` to be more consistent with the other methods in this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Some of these names are perhaps a bit longer than I might like (particularly
    when trying to fit code onto a page in a book!), but clear parameter and method
    names can save a lot of confusion and even prevent certain bugs from occurring
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If the inconsistent ordering of parameters annoys you, don’t worry. We’ll fix
    parameter ordering later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s shift gears and talk about how methods can work together in tandem. First,
    we’ll look at an example of **overloading** and then an example of **chaining**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by looking at the `ScheduleNewFlight` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This method takes in four parameters representing flight information. It uses
    them to instantiate a `Flight` object, adds the flight to the private list of
    flights, and then returns the newly-created `Flight` object.
  prefs: []
  type: TYPE_NORMAL
- en: As the system grows, it’s reasonable to expect that someone might want to provide
    their own `Flight` object. To accommodate that, you can overload the `ScheduleNewFlight`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading
  prefs: []
  type: TYPE_NORMAL
- en: Overloading is where you offer a method with the same name as another method
    but a different set of types of parameters that can be accepted by the method.
    For example, you can have a method that takes in an `int` and another method that
    takes in two `strings`, but you can’t have two methods that both take in only
    a single `int`, even if the parameter names are different. From the compiler’s
    perspective, overloaded methods are entirely separate methods that just happen
    to have the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overloaded `ScheduleNewFlight` method that takes in a `Flight` object might
    look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Overloading the `ScheduleNewFlight` method is helpful because it helps people
    discover the different options for scheduling a flight based on Visual Studio’s
    suggestions, as shown in *Figure 4**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Visual Studio suggestions showing available overloads for ScheduleNewFlight](img/B21324_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Visual Studio suggestions showing available overloads for ScheduleNewFlight
  prefs: []
  type: TYPE_NORMAL
- en: By providing overloads, following standard conventions, and having consistent
    and predictable methods and parameters, you help others discover how to use your
    classes safely and effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have noticed a few lines of duplication between our two `ScheduleNewFlight`
    overloads. Let’s take a look at them side by side for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While this duplication is very minimal, I could see new requirements come in
    that would necessitate changing both places. For example, the business might require
    that whenever a new flight is scheduled, a log entry should be written, or perhaps
    a new `LastScheduleChange` property needs to be set to the current time.
  prefs: []
  type: TYPE_NORMAL
- en: When these types of changes occur, developers run the risk of introducing bugs
    unless they change all the affected areas. This means that code duplication, even
    minor code duplication such as this example, leads to additional work and additional
    sources of bugs if not every place with similar logic is updated.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that can help with this is **method chaining**. Method chaining is
    when one method calls another related method and has it accomplish its work for
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we can modify our first `ScheduleNewFlight` method to be responsible
    for creating a `Flight` object and then handing off that object to the other `ScheduleNewFlight`
    overload, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Not only is this less code, but if we ever need to alter what happens when a
    new flight is scheduled, we now only have one place to modify.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered some of the basics of refactoring methods, let’s look
    briefly at some parallels with **constructors**. After all, constructors are essentially
    a special type of method that gets called when an object is instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you think about the job of a constructor, its whole reason for being is
    to get the object into its correct initial position. Once the constructor completes,
    the object is generally considered ready for use by other code.
  prefs: []
  type: TYPE_NORMAL
- en: This means that constructors can be very handy for ensuring that certain pieces
    of information are in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, our `Flight` class is defined fairly minimally and only has the
    default constructor that .NET provides in the absence of any explicit constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: Flight.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The problem with our `Flight` class lacking any explicit constructor is that
    flights don’t make sense without some of these pieces of information.
  prefs: []
  type: TYPE_NORMAL
- en: While more recent versions of C# have given us things such as the `required`
    keyword, which we’ll explore in [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209),
    the classic approach to requiring some piece of information at object creation
    has been to make the constructor take it in as a parameter. To demonstrate this,
    let’s add a parameterized constructor next.
  prefs: []
  type: TYPE_NORMAL
- en: Generating constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we could manually write a constructor, Visual Studio gives us some great
    code generation tools, including a *generate* *constructor* refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this refactoring, select the class and open the **Quick Actions** menu.
    Then, select **Generate constructor…**, as shown in *Figure 4**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Generating a constructor](img/B21324_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Generating a constructor
  prefs: []
  type: TYPE_NORMAL
- en: 'This will open a dialog that will allow you to select what members get initialized
    from the constructor when creating a `Flight`, as shown in *Figure 4**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Selecting required members for the constructor](img/B21324_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Selecting required members for the constructor
  prefs: []
  type: TYPE_NORMAL
- en: In this case, I chose to make `Id`, `Destination`, and `DepartureTime` part
    of the constructor and left the others unchecked. I also unchecked the **Add null
    checks** checkbox to prevent the generated code from being too complex for this
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'This generated the following constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The resulting code correctly sets the required properties based on its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to, you could go back in and generate a new constructor with a
    different set of parameters, since classes can have any number of overloaded constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, we’ll add another constructor in the next section to illustrate this.
    However, for now, we have a problem we need to resolve in the form of a build
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Build error trying to instantiate a Flight instance](img/B21324_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Build error trying to instantiate a Flight instance
  prefs: []
  type: TYPE_NORMAL
- en: If you tried to build your project after adding the `Flight` constructor, you’ll
    see an error similar to that shown in *Figure 4**.8*. This “no argument given
    that corresponds to the required parameter” error exists because the `Flight flight
    = new()` code in `ScheduleNewFlight` is trying to invoke the default constructor
    for `Flight`, but that constructor no longer exists.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our constructor a moment ago, this didn’t move the `Flight` class
    from having no constructors to one constructor. Instead, we went from having .NET’s
    default constructor with no parameters to one constructor with the new parameters
    we generated, removing the default constructor entirely.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add the default constructor back manually by explicitly defining it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This constructor does nothing aside from allowing others to instantiate the
    class by providing no parameters to the constructor. As soon as you declare your
    own constructor, .NET no longer provides the default constructor for you.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this compiler error, we can either add a new constructor that takes in
    no parameters or we can adjust the `ScheduleNewFlight` code to use our new constructor
    instead of the default one that no longer exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since part of the intent of adding a new constructor is to require certain
    pieces of information at the time of object creation, it makes more sense to change
    `ScheduleNewFlight` to use the new constructor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: FlightTracker.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A nice side effect of doing this is that we no longer need to set those properties
    in the object initializer since the constructor does that for us.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, we saw how we can chain together overloaded methods to work together
    to reduce code duplication. I also hinted that constructors are really just special
    methods. When you have multiple constructors, they act exactly like overloaded
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: We can put all of these concepts together by **chaining constructors** together,
    so one constructor calls to the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at an example of *not* doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: Flight.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have two constructors for `Flight` that are nearly identical, except
    the second one also accepts a `status` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this isn’t an excessive amount of duplication, it can be avoided by chaining
    constructors together with `: this()` syntax, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the second `Flight` constructor starts out by calling the first
    constructor through its use of `: this`. Once that call completes, control will
    move back to the second constructor and it will execute the `Status =` `status;`
    line.'
  prefs: []
  type: TYPE_NORMAL
- en: Chaining constructors together adds a little complexity to your code, but it
    also reduces duplicated code while making it such that you can add new initialization
    logic in one place and multiple constructors can take advantage of the addition.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve explored the basics of methods and constructors, let’s talk about
    managing parameters. This is important because it is possible that poorly thought-out
    parameters can quickly reduce the maintainability of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a few common refactorings you’ll want to perform over the life
    of your methods.
  prefs: []
  type: TYPE_NORMAL
- en: Reordering parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you’ll realize that the order of parameters in a method doesn’t make
    as much sense as another arrangement might. At other times, you might notice that
    a few of your methods take in the same kinds of parameters, but with inconsistent
    ordering. In either case, you’ll find yourself wanting to reorder your method
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a practical example from the various `MarkX` methods we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: FlightTracker.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have three methods that all take in `string` and `DateTime` parameters,
    but their ordering is inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, looking at these three methods, you decide that the most intuitive
    order is to put the flight ID first and then the time component as the second
    parameter. This means that `MarkFlightDelayed` and `MarkFlightDeparted` are correct
    but `MarkFlightArrived` needs to be adjusted.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add, remove, and reorder parameters from the same refactoring dialog
    in Visual Studio by selecting the method you want to refactor and then choosing
    **Change signature…** from the **Quick Actions** menu, as shown in *Figure 4**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Triggering the Change signature… refactoring](img/B21324_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Triggering the Change signature… refactoring
  prefs: []
  type: TYPE_NORMAL
- en: 'This will bring up the **Change Signature** dialog (see *Figure 4**.10*) and
    allow you to use the up and down buttons in the upper right to reorder parameters
    until the order in the preview matches your expectations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Reordering parameters in the Change Signature dialog](img/B21324_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Reordering parameters in the Change Signature dialog
  prefs: []
  type: TYPE_NORMAL
- en: Once you are done, click **OK** and Visual Studio will update your method as
    well as everything that was called out to that method to use the revised parameter
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways of making which parameters a method requires more explicit
    using C#. One such way would be to use the **named arguments** feature of C# that
    allows you to specify method parameters by name followed by a colon, making the
    parameter usage explicit.
  prefs: []
  type: TYPE_NORMAL
- en: An example of using this to call our `MarkFlightArrived` method would be `MarkFlightArrived(arrivalTime:DateTime.Now,
    id:"MyId")`. Note that when using named arguments, you can specify arguments in
    whatever order you prefer. See the *Further reading* section for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Adding parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Occasionally, you’ll want to add a new parameter to your method. The most natural
    thing to do is generally to add the parameter to the end of the list of parameters.
    This, however, can have two downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: The new parameter might not make the most sense when added to the end of the
    list instead of earlier on in the sequence of parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually adding a parameter means you must now manually adjust anything that
    was calling your method and provide a new value for the parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at a practical example and see how the **Change Signature** dialog
    can help.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MarkFlightArrived` method currently finds the flight by its `Id` and then
    updates its arrival time and status to match the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let’s say we need to update this method to take in the gate that the plane should
    taxi to. While we could manually add it to the end of the parameter list, this
    would break every method that calls out to this method.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, that’s not a lot of places, since only the tests are calling this
    method.
  prefs: []
  type: TYPE_NORMAL
- en: FlightTrackerTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the *Change Signature* refactoring tools in Visual Studio provide
    a safer option when you click the **Add** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Adding a new gate parameter to MarkFlightArrived](img/B21324_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – Adding a new gate parameter to MarkFlightArrived
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Add Parameter** dialog is one of the more complex ones in Visual Studio,
    but all it really needs is the following few things:'
  prefs: []
  type: TYPE_NORMAL
- en: The parameter name and type that is being added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether this parameter is required or optional (more on this shortly)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value to use in places that are already calling the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, our new parameter is going to be a `string` named `gate`. Callers
    must provide a value and any existing callers should use the `"A4"` string for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: This use of `"A4"` may seem like a random string because it is. The only place
    using this method right now is a unit test where the gate really doesn’t matter
    for that test. If more places were using this method, I’d likely choose **Infer
    from context** or **Introduce undefined** **TODO variables**.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking **OK** will display the *Change Signature* dialog again with your new
    parameter listed, allowing you to reorder it as needed. Clicking **OK** in this
    dialog will add the parameter to your method and update your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This updates your method signature for `MarkFlightArrived` and the test calling
    your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With the new parameter in place, you can update the `MarkFlightArrived` method
    to use it to set the flight’s `Gate` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This workflow is a common one you’ll go through as you find yourself expanding
    methods to take in new parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see some ways to simplify method calls using optional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing optional parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re not a fan of the **Change Signature** dialog and would rather write
    the code yourself, you can always take advantage of optional parameters to safely
    add new parameters to the end of your parameter list.
  prefs: []
  type: TYPE_NORMAL
- en: With an optional parameter, you specify a default value. Places that call your
    method can either specify the value for this parameter or not pass any value at
    all. In cases where no value is passed, the default value will be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This only works with parameters at the end of your parameter list due to how
    optional parameters work in C#. Additionally, the compiler doesn’t allow certain
    types of default values such as new objects and certain literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to declare `gate` as optional and default to `"TBD"` (short for
    “to be determined”), your method would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The code calling your method could then be left in its prior state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, the code would compile, but “TBD” would be used for the gate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you could specify the value for `gate` manually by providing
    a value for that parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Optional parameters can be particularly nice not just for expanding methods,
    but also for providing common defaults that callers can customize if they want.
  prefs: []
  type: TYPE_NORMAL
- en: Removing parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currently, the code requires you to specify the gate whenever a new flight
    is scheduled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Let’s say that you decide that since gates are now assigned at arrival, you
    shouldn’t need to specify the `gate` when you schedule a new flight.
  prefs: []
  type: TYPE_NORMAL
- en: While you could go in and just remove the `gate` parameter from the code, this
    won’t update any methods that are calling that method and will result in compiler
    errors you must resolve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, you can use the **Change Signature** dialog, select the parameter
    you want to remove, and click **Remove**, as shown in *Figure 4**.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Removing the gate parameter from ScheduleNewFlight](img/B21324_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Removing the gate parameter from ScheduleNewFlight
  prefs: []
  type: TYPE_NORMAL
- en: When you click `gate` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this isn’t magic, and it will leave behind code that relied on that
    gate parameter or code that was put in place to get the value ready to pass into
    `ScheduleNewFlight`. Still, the refactoring does a remarkable job of cleaning
    up the method definition and the direct calls of that method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying the refactoring to remove the `gate` parameter results in a simpler
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’ve covered the basics of methods, constructors, and parameters,
    let’s get into the more adventuresome aspects of refactoring methods: working
    with functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring to functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll explore some aspects of refactoring related to **functional
    programming**. Functional programming is an approach to programming that focuses
    on functions and their interactions instead of purely on objects and classes.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming has become more popular over the last decade and that
    popularity has influenced the C# language with the addition of new forms of syntax.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore a few of the syntactical improvements related to functional programming
    and see how they can help make concise and flexible programs. While this is not
    a book about functional programming, we’ll still find ourselves exploring a few
    of these concepts in this section and [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209),
    *Defensive* *Coding Techniques*.
  prefs: []
  type: TYPE_NORMAL
- en: Using expression-bodied members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start dipping our toes into the waters of the more functional syntax, let’s
    take a look at the `FindFlightById` method in `FlightTracker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly, this is a very brief method with only a single statement. At the same
    time, this method takes up three lines of the screen. Since developers usually
    leave a blank line above and below each method, the existence of this simple method
    takes up five lines of the screen. These five lines can be a significant portion
    of the visible region of the screen, as shown in *Figure 4**.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – The visual footprint of a method with a single statement](img/B21324_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – The visual footprint of a method with a single statement
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can take advantage of expression-bodied members and convert our
    method to a single-line declaration using this new syntax by activating the **Use
    expression body for method** refactoring on the **Quick Actions** menu with the
    method selected, as shown in *Figure 4**.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Triggering the Use expression body for method refactoring^](img/B21324_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – Triggering the Use expression body for method refactoring^
  prefs: []
  type: TYPE_NORMAL
- en: 'This converts our code to the following, more concise format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This style only works for single-line implementations and it isn’t for everyone.
    However, if you use it for simple code, it helps reduce the “scrolling penalty”
    you face with many small methods in a larger file.
  prefs: []
  type: TYPE_NORMAL
- en: Passing functions as parameters with actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While expression-bodied members are less functional programming and more functional
    syntax, let’s shift gears and get a taste of what’s possible by thinking about
    methods as **actions** that you can store in variables and pass around to other
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we talk about *how* to do this, let’s explore *why* we’d want to do
    this by looking at our `MarkFlightX` methods in `FlightTracker`. We’ll start with
    the `MarkFlightDelayed` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This method does a few discrete things:'
  prefs: []
  type: TYPE_NORMAL
- en: It searches for a flight by its ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it finds the flight, it updates the properties on the flight and writes out
    the delay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the flight can’t be found, a warning is written to the console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On its own, this method is fine. Let’s look at `MarkFlightDeparted` now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Compare this method to the last one and you’ll see that there are few differences
    between them. The method still must find a flight by its ID, check to see whether
    the flight was found or not, and update the flight. The only difference in this
    method is what updates occur to the flight and what message gets written to the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s round out our look at these methods with a look at `MarkFlightArrived`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, the pattern repeats itself. The only major difference between these three
    methods is what happens if the flight is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thinking about it in that way, consider our logic with the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, `ApplyUpdateToFlight` is a placeholder for some method or function we
    could apply to the flight object. This is because the *action* we take turns out
    to be the only thing that varies here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, .NET has a class called an `Action` that can serve this very purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `updateAction` parameter represents a specific function that can be
    called. What function is it? We don’t know. The exact function will be provided
    by whoever called the `UpdateFlight` method – just like any other parameter.
  prefs: []
  type: TYPE_NORMAL
- en: However, because `updateAction` is defined as `Action<Flight>`, we know that
    the function takes in a single parameter of the `Flight` type, which is why we
    can provide that parameter to the function when we invoke it inside this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help the idea of `Action` syntax sink in a little more, let’s see a few
    other signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Action<int>` – A function taking in a single integer parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Action<string, bool>` – A function taking in a string and then a boolean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Action` – A function taking in no parameters at all'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that declaring the `Action` parameters makes a little more sense syntactically,
    let’s see how one of our old methods might be updated to use this new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `MarkFlightDelayed` method calls directly into the `UpdateFlight`
    method and provides an `Action<Flight>` in the form of the `(flight) => { }` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: When the `UpdateFlight` method runs, it checks to see whether the flight exists
    and, if it does, the method calls the arrow function we provided to actually update
    the flight.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the syntax of this is difficult, here’s a different way of representing
    the same thing, by using a local variable to hold the `Action<Flight>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It’s undoubtedly possible to have a happy and productive career as a developer
    without declaring an `Action` variable. However, I’ve found that when I’m able
    to think in terms of discrete `Actions`, it can open some very interesting and
    flexible solutions to problems.
  prefs: []
  type: TYPE_NORMAL
- en: Returning data from Actions with Funcs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we move on to talking about static and extension methods, let’s take
    a brief look at `Funcs`.
  prefs: []
  type: TYPE_NORMAL
- en: A `Action` in that it represents a *function* that can be invoked and potentially
    passed parameters. However, while `Actions` do not return any results, `Funcs`
    do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine a simple C# method that adds two numbers together and displays
    their result in an equation string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This method has a `void` return type, meaning it doesn’t return any value.
    As a result, it could be stored in an `Action` and invoked in that way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s look at a slightly different version of the `Add` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, `AddFunc` has a return type of `string`. Because the method no longer
    returns a void, it can no longer be considered an `Action` and is now considered
    a `Func` because it returns some value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, if we wanted to store a reference to this method, we’d need to
    do so in a `Func`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note that in addition to using a `Func` instead of an `Action`, we now have
    a third `Func` represents the return type of the `Func`. In the case of `myFunc`,
    the third generic type parameter indicates that `AddFunc` returns a `string`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Action` and `Func` are very closely related with the only significant difference
    being that `Func` returns a value. In practice, I tend to use `Action` when I
    want to accomplish something, such as in the earlier example of updating flights.
    On the other hand, I tend to use `Func` to determine when to do something or how
    to get a specific value I need.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I might declare a method that takes in a `Func<Flight, bool>`
    that it uses to determine whether a flight from a list of flights should be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This method calls the `shouldDisplay` Func for every flight in the list in order
    to determine whether it should be displayed. Flights only display if the `shouldDisplay`
    Func returns `true` for that flight.
  prefs: []
  type: TYPE_NORMAL
- en: 'This structure allows the same method to be used for different scenarios, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Listing upcoming flights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing delayed flights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing flights heading to a specific airport
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only difference between these is what the `shouldDisplay` parameter holds.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing static methods and extension methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we’ve explored some of the more functional aspects of method refactoring,
    let’s take a look at some of the features that helped revolutionize .NET: **static
    methods** and **extension methods**.'
  prefs: []
  type: TYPE_NORMAL
- en: Making methods static
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, your classes will have methods that don’t work directly with instance
    members (fields, properties, or non-static methods) of that class. For example,
    `FlightTracker` has a `Format` method that converts a `DateTime` to a string resembling
    “Wed Jul 12 23:14 PM”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Format` doesn’t rely on anything other than the parameters it is provided
    to calculate a result. Because of this, we can make `Format` a static method.
  prefs: []
  type: TYPE_NORMAL
- en: Static methods are methods associated with the class itself and not with an
    instance of the class. As a result, you don’t need to instantiate an instance
    of the class to call them. The C# compiler is also able to make occasional optimizations
    surrounding static code that can result in faster code.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, static methods can also be considered **pure methods** – that is
    to say, methods without direct side effects that always produce the same result
    when given the same input.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 4**.14*, you can mark a method as static by adding the
    `static` keyword after the access modifier or by choosing the **Make static**
    option on the **Quick** **Actions** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Moving a method to a static method](img/B21324_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – Moving a method to a static method
  prefs: []
  type: TYPE_NORMAL
- en: 'The static version of **Format** looks very similar and works almost identically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `Format` method can still be called simply with `Format(DateTime.Now)` as
    it could before, but adding static also allows you to call it from the class itself,
    such as `FlightTracker.Format(DateTime.Now)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Marking a method as static has a few advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler can make optimizations resulting in faster runtime performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code can call the static method without needing to instantiate the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The static method could be converted to an extension method, as we’ll see later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `static` keyword may seem like a great thing to use everywhere you can due
    to these added features. Unfortunately, `static` has some drawbacks as well. Marking
    a method as `static` also means it can no longer call non-`static` methods or
    access instance-level data.
  prefs: []
  type: TYPE_NORMAL
- en: There are certainly many uses for `static`, but it’s still something that many
    developers find distasteful or consider an anti-pattern in excess.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I find `static` is appropriate for “helper methods” and, in some
    cases, to simplify unit testing complex classes that can be complex to instantiate
    in testing scenarios. However, I draw the line at making fields `static` whenever
    possible, as `static` data can lead to many problems in developing and testing
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Moving static members to another type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, it doesn’t make sense for a static method to remain in the class
    it started in.
  prefs: []
  type: TYPE_NORMAL
- en: For example, our `Format` method takes any `DateTime` and returns a customized
    string appropriate to Cloudy Skies Airlines’ business needs. This logic is currently
    inside of the `FlightTracker` class, and yet is completely unrelated to tracking
    flights and could be useful to have in any number of places throughout their application.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, it makes sense to pull `Format` into a different class where
    other developers can more readily discover these formatting capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio provides a built-in refactoring for this. To use it, select a
    static method and open the **Quick Actions** menu, then click **Move static members
    to another type...**, as shown in *Figure 4**.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Moving static members to another type](img/B21324_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 – Moving static members to another type
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will be prompted to select the Type your static methods should be
    moved to. This can be the name of a new class if you don’t currently have a class
    suitable for this. For Cloudy Skies, there is no existing Type that should own
    this, so creating one named `DateHelpers` makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you will be asked to check or uncheck the static methods you
    want to move with an option to **Select Dependents** (see *Figure 4**.17*) and
    select any methods that your selected static methods call:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Selecting the destination type and the members to move](img/B21324_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 – Selecting the destination type and the members to move
  prefs: []
  type: TYPE_NORMAL
- en: Click **OK** to move your selected method and create a new class.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The current behavior of Visual Studio is to keep your method’s current access
    modifier and create the new static class as `internal`. This may introduce compiler
    errors if your method was `private`, as code at the old location will no longer
    be able to access your code. I recommend changing your static class and its methods
    to `public` to avoid issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the resulting **static class** after adjusting its modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a dedicated class just for “helper methods” associated with dates
    and times.
  prefs: []
  type: TYPE_NORMAL
- en: Static classes
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not familiar with static classes, a static class can only have static
    methods in it and cannot be instantiated or inherited from. Static classes are
    required for extension methods.
  prefs: []
  type: TYPE_NORMAL
- en: The refactoring we just performed also updated any code that was using the old
    `Format` method to point to `DateTimeHelpers.Format`. For example, in `FlightTracker`,
    the `MarkFlightArrived` method’s flight logging now says `Console.WriteLine($"{id}
    arrived` `at {DateHelpers.Format(arrivalTime)}.");`.
  prefs: []
  type: TYPE_NORMAL
- en: By pulling static members into their own dedicated type, we’ve created a home
    where date-related logic can live and help a wide variety of classes, and we’ve
    made our `FlightTracker` class more focused on its core job instead of being focused
    on date formatting as well as flight tracking.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this change has somewhat hurt the readability of our code because
    callers must now specify `DateHelpers.Format` instead of just `Format`. An extension
    method can help with this, as we’ll see next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating extension methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extension methods allow you to “extend” an existing Type by adding your own
    static methods that appear like they’re part of that Type.
  prefs: []
  type: TYPE_NORMAL
- en: 'That might sound intimidating, but if you’ve used LINQ, you’ve seen extension
    methods in action. Let’s look at the `FindFlightById` method in `FlightTracker`
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, `_flights` is defined as a `List<Flight>`. Given that the code to find
    a flight by its ID, it’s understandable to suspect that `List` must have a method
    called `FirstOrDefault`; however, it does not.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the `FirstOrDefault` method is not defined on the `List<T>` type in
    the `System.Collections.Generic` namespace, but rather is defined as an extension
    method in a static class called `Enumerable` in the `System.Linq` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, it is perfectly feasible to rewrite our code from earlier to
    explicitly use the `Enumerable` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: While this is perfectly valid code, nobody I’ve ever worked with writes code
    in this way because using `FirstOrDefault` as an extension method is far more
    intuitive and readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This highlights the key point of extension methods: *extension methods allow
    you to add new features to existing classes in a way that appears like those methods
    were present on the object to begin with*, resulting in more intuitive code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a method as an extension method, the following things must be true:'
  prefs: []
  type: TYPE_NORMAL
- en: The method must be static
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method must be inside a static class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first parameter of the method must start with the `this` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `DateHelpers` class and its `Format` method are both static, which means
    we can convert the method to an extension method by adding the `this` keyword
    to the method signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Moving a static method to an extension method doesn’t mean you have to use it
    as an extension method and so our previous code will still compile. However, in
    order to get the most value out of our extension method, we should update prior
    code to take advantage of its new syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take another look at the `MarkFlightArrived` method in `FlightTracker`.
    This time, if you delete the `DateFormatHelpers.Format(arrivalTime)`, instead
    write `arrivalTime.For`, and allow Visual Studio’s **IntelliSense** to suggest
    values, it will list your new extension method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18 – IntelliSense suggesting the new extension method](img/B21324_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.18 – IntelliSense suggesting the new extension method
  prefs: []
  type: TYPE_NORMAL
- en: Because `arrivalTime` is a `DateTime` and our extension method is built to work
    on any `DateTime`, the new `Format` method we wrote appears here on the `DateTime`
    type provided in .NET through the power of extension methods.
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting the call to `arrivalTime.Format()` has the correct effect of calling
    out to the extension method, resulting in a far more readable experience.
  prefs: []
  type: TYPE_NORMAL
- en: If you’d prefer, you can still call out to the `Format` method via `DateHelpers.Format(arrivalTime)`.
    Introducing an extension method just gives you another option for how your syntax
    is structured.
  prefs: []
  type: TYPE_NORMAL
- en: 'The downsides of extension methods are, primarily, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods require the use of static, which some teams avoid because
    it tends to spread throughout your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be confusing that you’re using an extension method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be confusing where the new extension methods are defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thankfully, Visual Studio allows you to go to the definition of any method,
    member, or type simply by holding *Ctrl* and clicking on the item you want to
    navigate to. Alternatively, you can select the identifier and press *F12* on your
    keyboard or right-click on it and choose **Go To Definition** to navigate to where
    the extension method is declared.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing and testing our refactored code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of this chapter, we took a repetitive `FlightTracker` class
    and restructured it to ensure that its method signatures were more consistent
    and that common logic was reused wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Refactored code
  prefs: []
  type: TYPE_NORMAL
- en: The final refactored code from this chapter is available in the [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    repository inside of the `Chapter04/Ch4RefactoredCode` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, we should ensure that all tests still pass by running the
    unit tests from the **Test** menu and then selecting the **Run All Tests** menu
    item.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how various methods, constructors, and parameter refactorings
    can be applied to keep your code orderly. We saw how overloading and chaining
    together methods and constructors gives you more options, while renaming, adding,
    removing, and reordering parameters helps ensure consistency.
  prefs: []
  type: TYPE_NORMAL
- en: Near the end of this chapter, we covered `Actions`, `Funcs`, static methods,
    and extension methods, and showed how thinking about your code in terms of small,
    reusable functions can help solve certain types of problems more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll cover object-oriented refactoring techniques and
    revisit our parameter refactorings in this chapter by exploring how large sets
    of parameters can be brought under control by extracting classes.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Are there any areas of your code where you seem to be confused more frequently
    by the parameter ordering or naming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you think of any places in your code where slightly different actions are
    performed based on the same or similar conditions? If so, does moving to use an
    `Action` or a `Func` make sense?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does your code have a set of “helper methods” that might make sense to make
    static and put into a static class? If so, would switching to extension methods
    improve your code elsewhere?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find more information about the materials discussed in this chapter
    at the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Refactor into pure* *functions*: [https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-pure-functions](https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-pure-functions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Action-Oriented* *C#*: [https://killalldefects.com/2019/09/15/action-oriented-c/](https://killalldefects.com/2019/09/15/action-oriented-c/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Refactor using an extension* *method*: [https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-extension-method](https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-extension-method)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Named and Optional* *Arguments*: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
