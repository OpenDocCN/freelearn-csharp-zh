- en: '*Chapter 6*: Working with the Data Access Infrastructure'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*: 与数据访问基础设施协同工作'
- en: Almost all business applications use a kind of database system. We typically
    implement data access logic to read data from and write data to a database. We
    also need to deal with database transactions to ensure consistency in the data
    source.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有业务应用程序都使用某种数据库系统。我们通常实现数据访问逻辑以从数据库中读取数据并向数据库写入数据。我们还需要处理数据库事务以确保数据源的一致性。
- en: In this chapter, we will learn how to work with the data access infrastructure
    of ABP Framework, which provides abstractions for data access by implementing
    **Repository** and **Unit of Work** (**UoW**) patterns. Repositories provide a
    standard way to perform common database operations for your **entities**. The
    UoW system automates database connections and transaction management to ensure
    a use case (typically, a **HyperText Transfer Protocol** (**HTTP**) request) is
    atomic; this means all operations done in the request are successful together
    or rolled back together in any error.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何与ABP框架的数据访问基础设施协同工作，该基础设施通过实现**仓储**和**工作单元**（**UoW**）模式来提供数据访问的抽象。仓储提供了一种标准方式来执行针对你的**实体**的常见数据库操作。UoW系统自动化数据库连接和事务管理，以确保用例（通常是**超文本传输协议**（**HTTP**）请求）是原子的；这意味着请求中执行的所有操作要么一起成功，要么在出现任何错误时一起回滚。
- en: You will see how to define your entities based on ABP Framework's pre-built
    base entity classes. Then, you will learn how to insert, update, delete, and query
    entities in the database using the repositories. You will also understand the
    UoW system to control transaction scopes in your application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将了解如何根据ABP框架预构建的基类定义你的实体。然后，你将学习如何使用仓储在数据库中插入、更新、删除和查询实体。你还将了解UoW系统，以控制应用程序中的事务作用域。
- en: ABP Framework can work with any database system, while it provides built-in
    integration packages with `DbContext` class, mapping your entities to database
    tables, implementing your repositories, and deploying different ways of loading
    related entities when you have an entity. You will also see how to use **MongoDB**
    as a second database provider option.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ABP框架可以与任何数据库系统协同工作，同时它提供了内置的`DbContext`类集成包，将你的实体映射到数据库表，实现你的仓储，并在拥有实体时部署不同的加载相关实体的方式。你还将了解如何使用**MongoDB**作为第二个数据库提供者选项。
- en: 'This chapter covers ABP''s fundamental data access infrastructure with the
    following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了ABP的基本数据访问基础设施，以下是一些主题：
- en: Defining entities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义实体
- en: Working with repositories
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与仓储协同工作
- en: EF Core integration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EF Core集成
- en: MongoDB integration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB集成
- en: Understanding the UoW system
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解UoW系统
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you want to follow and try the examples, you need to have an **integrated
    development environment** (**IDE**)/editor installed (for example, Visual Studio)
    to build ASP.NET Core projects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要跟随并尝试示例，你需要安装一个**集成开发环境**（**IDE**）/编辑器（例如，Visual Studio）来构建ASP.NET Core项目。
- en: 'You can download the code examples from the following GitHub repository: [https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从以下GitHub仓库下载代码示例：[https://github.com/PacktPublishing/Mastering-ABP-Framework](https://github.com/PacktPublishing/Mastering-ABP-Framework)。
- en: Defining entities
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义实体
- en: Entities are the main classes to define your domain model. If you are using
    a relational database, an entity is generally mapped to a database table. An **object-relational
    mapper** **(ORM)**, such as EF Core, provides abstractions to make you feel as
    though you are working with objects in your application code rather than database
    tables.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 实体是定义你的领域模型的主要类。如果你使用的是关系型数据库，实体通常映射到数据库表。**对象关系映射器**（**ORM**），如EF Core，提供抽象，让你感觉在应用程序代码中与对象协同工作，而不是与数据库表协同工作。
- en: ABP Framework standardizes defining entities by providing some interfaces and
    base classes. In the next sections, you will learn about ABP Framework's `AggregateRoot`
    and `Entity` base classes (and their variants), using single **primary keys**
    (**PKs**) and **composite PKs** (**CPKs**) with these classes and working with
    **globally unique identifier** (**GUID**) PKs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ABP框架通过提供一些接口和基类来标准化实体的定义。在接下来的章节中，你将了解ABP框架的`AggregateRoot`和`Entity`基类（及其变体），使用这些类使用单个**主键**（**PK**）和**复合主键**（**CPK**），以及与**全局唯一标识符**（**GUID**）PK协同工作。
- en: AggregateRoot classes
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AggregateRoot类
- en: An **aggregate** is a cluster of objects (entities and value objects) bound
    together by an aggregate root object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**聚合**是一组由聚合根对象绑定在一起的对象（实体和值对象）的集合。'
- en: Relational databases do not have a physical aggregate concept. Every entity
    is related to a separate database table, and an aggregate is spread into more
    than one table. You define relations with **foreign keys** (**FKs**). However,
    in document/object databases such as MongoDB, an aggregate is saved into a single
    collection by serializing it as a single document (a **JavaScript Object Notation**
    (**JSON**)-like object). The aggregate root is mapped to the collection, and sub-entities
    are serialized within the aggregate root object. That means sub-entities don't
    have their collections and are always accessed over the aggregate root.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库没有物理的聚合概念。每个实体都与一个单独的数据库表相关联，而聚合则分散在多个表中。你通过 **外键**（**FKs**）定义关系。然而，在文档/对象数据库（如
    MongoDB）中，聚合作为一个单独的文档（类似于 **JavaScript 对象表示法**（**JSON**）的对象）进行序列化并保存到单个集合中。聚合根映射到集合，子实体在聚合根对象中进行序列化。这意味着子实体没有自己的集合，并且总是通过聚合根进行访问。
- en: The Aggregate Concept
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合概念
- en: We will cover the aggregate concept in [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316),
    *DDD – The Domain Layer*, with all the details of this. For now, you can think
    of aggregate roots as the main (root) entities in your domain.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 10 章*](B17287_10_Epub_AM.xhtml#_idTextAnchor316)，*DDD – 领域层*中涵盖聚合概念，并详细介绍这一点。现在，你可以将聚合根视为你领域中的主要（根）实体。
- en: In ABP Framework, you can define main entities and aggregate roots, by deriving
    from one of the `AggregateRoot` classes. `BasicAggregateRoot` is the most simple
    class for defining your aggregate roots.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ABP 框架中，你可以通过从 `AggregateRoot` 类之一派生来定义主要实体和聚合根。`BasicAggregateRoot` 是定义聚合根的最简单类。
- en: 'The following example entity class is derived from the `BasicAggregateRoot`
    class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例实体类是从 `BasicAggregateRoot` 类派生出来的：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`BasicAggregateRoot` just defines an `Id` property as the PK and takes the
    PK type as the generic parameter. In this example, the PK type of `Form` is `Guid`.
    You can use any type as the PK (for example, `int`, `string`, and so on), as long
    as the underlying database provider supports it.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`BasicAggregateRoot` 仅定义了一个 `Id` 属性作为主键，并将主键类型作为泛型参数。在这个例子中，`Form` 的主键类型是 `Guid`。你可以使用任何类型作为主键（例如，`int`、`string`
    等），只要底层数据库提供程序支持即可。'
- en: 'There are some other base classes to derive your aggregate roots from, as detailed
    here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些其他的基础类，你可以从中派生出你的聚合根，具体如下：
- en: The `AggregateRoot` class has additional properties to support optimistic concurrency
    and object extension features.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AggregateRoot` 类具有额外的属性以支持乐观并发和对象扩展功能。'
- en: '`CreationAuditedAggregateRoot` inherits from the `AggregateRoot` class and
    adds `CreationTime` (`DateTime`) and `CreatorId` (`Guid`) properties to store
    creation audit information.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreationAuditedAggregateRoot` 类继承自 `AggregateRoot` 类，并添加了 `CreationTime` (`DateTime`)
    和 `CreatorId` (`Guid`) 属性以存储创建审计信息。'
- en: '`AuditedAggregateRoot` inherits from the `CreationAuditedAggregateRoot` class
    and adds `LastModificationTime` (`DateTime`) and `LastModifierId` (`Guid`) properties
    to store modification audit information.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuditedAggregateRoot` 类继承自 `CreationAuditedAggregateRoot` 类，并添加了 `LastModificationTime`
    (`DateTime`) 和 `LastModifierId` (`Guid`) 属性以存储修改审计信息。'
- en: '`FullAuditedAggregateRoot` inherits from the `AuditedAggregateRoot` class and
    adds `DeletionTime` (`DateTime`) and `DeleterId` (`Guid`) properties to store
    deletion audit information. It also adds `IsDeleted` (`bool`) by implementing
    the `ISoftDelete` interface, which makes the entity soft-delete.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FullAuditedAggregateRoot` 类继承自 `AuditedAggregateRoot` 类，并添加了 `DeletionTime`
    (`DateTime`) 和 `DeleterId` (`Guid`) 属性以存储删除审计信息。它还通过实现 `ISoftDelete` 接口添加了 `IsDeleted`
    (`bool`)，这使得实体可以进行软删除。'
- en: Optimistic Concurrency and Object Extension Features
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 乐观并发和对象扩展功能
- en: These topics are not covered in this book. Please check the ABP Framework documentation
    if you need to use them.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些主题在本书中没有涉及。如需使用，请查阅 ABP 框架文档。
- en: ABP automatically sets auditing properties. We will return to the audit logging
    and soft-delete topics in [*Chapter 8*](B17287_08_Epub_AM.xhtml#_idTextAnchor249),
    *Using the Features and Services of ABP*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 自动设置审计属性。我们将在 [*第 8 章*](B17287_08_Epub_AM.xhtml#_idTextAnchor249)，*使用 ABP
    的功能和服务*中返回审计日志和软删除主题。
- en: Entity classes
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体类
- en: '`Entity` base classes are similar to `AggregateRoot` classes, but they are
    used for sub-collection entities rather than main (root) entities. For example,
    the `Form` aggregate root example in the previous section has a collection of
    questions. The `Question` class is derived from the `Entity` class and is shown
    in the following code snippet:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entity`基类类似于`AggregateRoot`类，但它们用于子集合实体而不是主（根）实体。例如，上一节中的`Form`聚合根示例有一个问题集合。`Question`类是从`Entity`类派生的，并在以下代码片段中显示：'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As with the `AggregateRoot` class, the `Entity` class also defines an `Id` property
    of a given type. In this example, the `Question` entity also has a collection
    of options, where `Option` is another entity type.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与`AggregateRoot`类一样，`Entity`类也定义了一个给定类型的`Id`属性。在这个例子中，`Question`实体还有一个选项集合，其中`Option`是另一种实体类型。
- en: There are some other pre-defined base entity classes, such as `CreationAuditedEntity`,
    `AuditedEntity`, and `FullAuditedEntity`. They are similar to the audited aggregate
    root classes explained in the previous section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他预定义的基本实体类，例如`CreationAuditedEntity`、`AuditedEntity`和`FullAuditedEntity`。它们与上一节中解释的已审计聚合根类类似。
- en: Entities with CPKs
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有CPK的实体
- en: Relational databases support CPKs, whereby your PK consists of a combination
    of multiple values. Composite keys are especially useful for relation tables with
    **many-to-many** relations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库支持CPKs，其中您的PK由多个值的组合组成。复合键对于具有**多对多**关系的关联表特别有用。
- en: 'Assume that you want to set multiple managers for a form object and add a collection
    property to the `Form` class, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想为表单对象设置多个管理器，并将集合属性添加到`Form`类中，如下所示：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can then define a `FormManager` class deriving from the non-generic `Entity`
    class, like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以定义一个从非泛型的`Entity`类派生的`FormManager`类，如下所示：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you inherit from the non-generic `Entity` class, you have to implement
    the `GetKeys` method to return an array of the keys. In this way, ABP can use
    the CPK's value where it is needed. For this example, `FormId` and `UserId` are
    FKs to other tables, and they build the CPK of the `FormManager` entity.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从非泛型的`Entity`类继承时，您必须实现`GetKeys`方法以返回键的数组。这样，ABP可以在需要的地方使用CPK的值。例如，在这个例子中，`FormId`和`UserId`是其他表的FK，它们构成了`FormManager`实体的CPK。
- en: CPKs for Aggregate Roots
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合根的CPK
- en: '`AggregateRoot` classes also have non-generic versions for CPKs, while it is
    not so usual to set CPKs for aggregate root entities.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`AggregateRoot`类也有非泛型的CPK版本，而对于聚合根实体设置CPK并不常见。'
- en: The GUID PK
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GUID PK
- en: 'ABP mostly uses GUIDs as the PK type for pre-built entities. GUIDs are generally
    compared to auto-increment IDs (such as `int` or `long`, supported by relational
    databases). Here are some commonly known benefits of using GUIDs as the PK compared
    to auto-increment keys:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ABP主要使用GUIDs作为预建实体的PK类型。GUIDs通常与自增ID（如`int`或`long`，由关系型数据库支持）进行比较。以下是使用GUIDs作为PK与自增键相比的一些常见好处：
- en: GUIDs are naturally unique. This works well if you are building distributed
    systems, using a non-relational database, and need to split or merge tables or
    integrate external systems.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUIDs自然是唯一的。如果您正在构建分布式系统，使用非关系型数据库，并且需要拆分或合并表或集成外部系统，这效果很好。
- en: GUIDs can be generated on the client side without needing a database round trip.
    In this way, the client code can know the PK value before saving the entity.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUIDs可以在客户端生成，无需数据库往返。这样，客户端代码可以在保存实体之前知道PK值。
- en: GUIDs are impossible to guess, so they can be more secure in some cases (for
    example, if end users see the ID of an entity, they can't find the ID of another
    entity).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUIDs无法猜测，因此在某些情况下可以更安全（例如，如果最终用户看到实体的ID，他们无法找到另一个实体的ID）。
- en: 'GUIDs also have some disadvantages compared to auto-increment integer values,
    as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与自增整数值相比，GUIDs也有一些缺点，如下所示：
- en: A GUID is 16 bytes in the storage, higher than `int` (4 bytes) and `long` (8
    bytes).
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUID在存储中占用16字节，高于`int`（4字节）和`long`（8字节）。
- en: GUIDs are not sequential by nature, which causes performance problems on clustered
    indexes. However, ABP offers a solution to that problem.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUIDs在本质上不是顺序的，这会导致在聚类索引上出现性能问题。然而，ABP提供了解决这个问题的方案。
- en: ABP provides the `IGuidGenerator` service, which generates sequential `Guid`
    values by default. While it generates sequential values, the values generated
    by the algorithm are still safe to be universal and random. Generating a sequential
    value solves the clustered index performance problem.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ABP提供了`IGuidGenerator`服务，该服务默认生成顺序的`Guid`值。虽然它生成顺序值，但算法生成的值仍然是通用和随机的。生成顺序值解决了聚集索引性能问题。
- en: If you manually set the `Id` value of an entity, always use the `IGuidGenerator`
    service; never use `Guid.NewGuid()`. If you don't set the `Id` value for a new
    entity and insert it into the database using a repository, the repository automatically
    sets it using the `IGuidGenerator` service.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你手动设置实体的`Id`值，始终使用`IGuidGenerator`服务；永远不要使用`Guid.NewGuid()`。如果你没有为新的实体设置`Id`值并使用仓库将其插入数据库，仓库将自动使用`IGuidGenerator`服务设置它。
- en: GUID versus Auto-Increment
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: GUID与自增的比较
- en: GUID versus auto-increment PKs is a hot discussion in software development,
    and there is no clear winner. ABP works with any PK type, so you can make your
    own choice based on your requirements.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，GUID与自增PK的讨论很热烈，但没有明确的赢家。ABP与任何PK类型都兼容，因此你可以根据自己的需求做出选择。
- en: We have now learned the basics of entity definitions and will explore best practices
    for entities in [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316), *DDD
    – The Domain Layer*. But now, let's continue with the repositories to understand
    how to work with a database to persist our entities.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学习了实体定义的基础知识，并将探讨在[*第10章*](B17287_10_Epub_AM.xhtml#_idTextAnchor316)，*领域驱动设计
    - 领域层*中的实体最佳实践。但现在，让我们继续探讨仓库，了解如何与数据库一起工作以持久化我们的实体。
- en: Working with repositories
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与仓库一起工作
- en: The **Repository pattern** is a common approach to abstract the data access
    code from the other services of your application. In the next sections, you will
    learn how to use ABP Framework's generic repositories for your entities to query
    or manipulate data in the database using pre-defined repository methods. You will
    also see how to create custom repositories when you need to extend the generic
    repositories and add your own repository methods to encapsulate your data access
    logic.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**仓库模式**是一种常见的抽象数据访问代码的方法，从应用程序的其他服务中分离出来。在接下来的章节中，你将学习如何使用ABP框架的通用仓库为你的实体查询或操作数据库中的数据，使用预定义的仓库方法。你还将看到如何在需要扩展通用仓库并添加自己的仓库方法以封装你的数据访问逻辑时创建自定义仓库。'
- en: Integrating Database Providers
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 集成数据库提供者
- en: Database provider integration should be done to use repositories. We will do
    this in the *EF Core integration* and *MongoDB integration* sections of this chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用仓库，需要完成数据库提供者的集成。我们将在本章的*EF Core集成*和*MongoDB集成*部分完成此操作。
- en: Generic repositories
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用仓库
- en: 'Once you have an entity, you can directly inject and use the generic repository
    for that entity. Here is an example class that uses a repository:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一个实体，你可以直接注入并使用该实体的通用仓库。以下是一个使用仓库的示例类：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this example, we''ve injected `IRepository<Form, Guid>`, the default generic
    repository for the `Form` entity. Then, we''ve used the `GetListAsync` method
    to get a filtered list of forms from the database. The generic `IRepository` interface
    has two generic parameters: entity type (`Form`, in this example) and PK type
    (`Guid`, in this example).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们注入了`IRepository<Form, Guid>`，这是`Form`实体的默认通用仓库。然后，我们使用了`GetListAsync`方法从数据库中获取表单的筛选列表。通用的`IRepository`接口有两个泛型参数：实体类型（在本例中为`Form`）和PK类型（在本例中为`Guid`）。
- en: Repositories for Non-Aggregate Root Entities
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 非聚合根实体的仓库
- en: Generic repositories are only available for *aggregate root* entities by default
    because it is a best practice to access aggregates via aggregate root objects.
    However, it is possible to enable generic repositories for other entity types
    if you're using a relational database. We will see the configuration point in
    the *EF Core integration* section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，通用仓库仅适用于*聚合根*实体，因为这是一种最佳实践，通过聚合根对象访问聚合。然而，如果你使用的是关系数据库，你可以为其他实体类型启用通用仓库。我们将在*EF
    Core集成*部分看到配置点。
- en: Generic repositories provide many built-in methods to query, insert, update,
    and delete entities.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通用仓库提供了许多内置方法来查询、插入、更新和删除实体。
- en: Inserting, updating, and deleting entities
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入、更新和删除实体
- en: 'The following methods can be used to manipulate data in the database:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法可用于在数据库中操作数据：
- en: '`InsertAsync` is used to insert a new entity.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InsertAsync`用于插入新实体。'
- en: '`InsertManyAsync` is used to insert multiple entities in a single call.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InsertManyAsync`用于在一次调用中插入多个实体。'
- en: '`UpdateAsync` is used to update an existing entity.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateAsync`用于更新现有实体。'
- en: '`UpdateManyAsync` is used to update multiple entities in a single call.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateManyAsync`用于在一次调用中更新多个实体。'
- en: '`DeleteAsync` is used to delete an existing entity.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeleteAsync`用于删除现有实体。'
- en: '`DeleteManyAsync` is used to insert multiple entities in a single call.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeleteManyAsync`用于在一次调用中插入多个实体。'
- en: About Asynchronous Programming
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于异步编程
- en: All repository methods are asynchronous. As a general principle in .NET, it
    is strongly suggested to write your application code with the `async`/`await`
    pattern wherever possible, because in .NET, mixing asynchronous code with synchronous
    code leads to potential deadlock, timeout, and scalability problems in your application
    that are not easy to detect and resolve.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有仓库方法都是异步的。在.NET中，强烈建议尽可能使用`async`/`await`模式编写应用程序代码，因为在.NET中，将异步代码与同步代码混合会导致潜在的死锁、超时和可伸缩性问题，这些问题难以检测和解决。
- en: If you are using EF Core, these methods may not immediately perform an actual
    database operation because EF Core uses a change-tracking system. It saves changes
    only when you call the `DbContext.SaveChanges` method. ABP Framework's UoW system
    automatically calls the `SaveChanges` method when the current HTTP request successfully
    finishes. If you want to save changes into the database immediately, you can pass
    the `autoSave` parameter as `true` to the repository methods.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用EF Core，这些方法可能不会立即执行实际的数据库操作，因为EF Core使用更改跟踪系统。它仅在您调用`DbContext.SaveChanges`方法时保存更改。ABP框架的UoW系统会在当前HTTP请求成功完成后自动调用`SaveChanges`方法。如果您想立即将更改保存到数据库中，可以将`autoSave`参数传递给仓库方法并设置为`true`。
- en: 'The following example creates a new `Form` entity and immediately saves it
    to the database in the `InsertAsync` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在`InsertAsync`方法中创建一个新的`Form`实体，并将其立即保存到数据库中：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Even if you save changes into the database, the changes may not be visible yet,
    depending on the transaction isolation level, and will be rolled back if the current
    transaction fails. We will cover the UoW system in the *Understanding the UoW
    system* section of this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您将更改保存到数据库中，这些更改可能也不会立即可见，这取决于事务隔离级别，如果当前事务失败，则更改将被回滚。我们将在本章的*理解UoW系统*部分中介绍UoW系统。
- en: 'The `DeleteAsync` method has an extra overload to delete all the entities satisfying
    the given condition. The following example deletes all the draft forms in the
    database:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeleteAsync`方法有一个额外的重载版本，用于删除满足给定条件的所有实体。以下示例展示了如何删除数据库中所有草稿表单：'
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can also have a complex condition using logical operators such as `&&` and
    `||`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用逻辑运算符，如`&&`和`||`，来设置复杂条件。
- en: About Cancellation Tokens
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关于取消令牌
- en: All repository methods get an optional `CancellationToken` parameter. Cancellation
    tokens are used to cancel a database operation when needed. For example, if the
    user closes the browser window, there is no need to continue a long-running database
    query operation. Most of the time, you don't need to manually pass a cancellation
    token, since ABP Framework automatically captures and uses the cancellation token
    from the HTTP request when you don't explicitly pass it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所有仓库方法都接受一个可选的`CancellationToken`参数。取消令牌用于在需要时取消数据库操作。例如，如果用户关闭浏览器窗口，就没有必要继续长时间运行的数据库查询操作。大多数情况下，您不需要手动传递取消令牌，因为ABP框架在您没有明确传递取消令牌时，会自动捕获并使用HTTP请求中的取消令牌。
- en: Querying a single entity
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询单个实体
- en: 'The following methods can be used to fetch a single entity:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法可以用来获取单个实体：
- en: '`GetAsync`: Returns a single entity by its `Id` value or a predicate expression.
    Throws `EntityNotFoundException` if the requested entity was not found.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetAsync`：通过其`Id`值或谓词表达式返回单个实体。如果请求的实体未找到，则抛出`EntityNotFoundException`。'
- en: '`FindAsync`: Returns a single entity by its `Id` value or a predicate expression.
    Returns `null` if the requested entity was not found.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FindAsync`：通过其`Id`值或谓词表达式返回单个实体。如果请求的实体未找到，则返回`null`。'
- en: You should use the `FindAsync` method only if you have custom logic or fallback
    code, in case the given entity does not exist in the database. Otherwise, use
    `GetAsync`, which throws a well-known exception that causes the `404` status code
    to return to the client in an HTTP request.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有自定义逻辑或回退代码，并且给定的实体在数据库中不存在，则应仅使用`FindAsync`方法。否则，请使用`GetAsync`，它会在HTTP请求中抛出一个已知的异常，导致返回`404`状态码给客户端。
- en: 'The following example uses the `GetAsync` method to query a `Form` entity with
    its `Id` value:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用 `GetAsync` 方法查询具有其 `Id` 值的 `Form` 实体：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Both methods have overloads to pass a predicate expression to query an entity
    with a given condition. The following example uses the `GetAsync` method to get
    a `Form` entity with its unique name:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都有重载，可以传递一个谓词表达式来查询具有给定条件的实体。以下示例使用 `GetAsync` 方法获取具有其唯一名称的 `Form` 实体：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Use these overloads only if you are expecting a single entity. If your query
    returns multiple entities, then they throw `InvalidOperationException`. For example,
    if form names are always *unique* in your system, you can find a form by name,
    as in this example. However, if your query may return multiple entities, use querying
    methods that return a list of entities.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在你期望单个实体时使用这些重载。如果你的查询返回多个实体，则它们会抛出 `InvalidOperationException`。例如，如果你的系统中表单名称总是
    *唯一的*，你可以按名称查找表单，如下例所示。然而，如果你的查询可能返回多个实体，请使用返回实体列表的查询方法。
- en: Querying a list of entities
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询实体列表
- en: 'Generic repositories provide a lot of options to query entities from the database.
    The following methods can be used to get a list of entities directly:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通用存储库提供了许多从数据库查询实体的选项。以下方法可以直接用于获取实体列表：
- en: '`GetListAsync`: Returns all the entities or a list of entities satisfying the
    given condition'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetListAsync`：返回满足给定条件的所有实体或实体列表'
- en: '`GetPagedListAsync`: Used to query entities by paging'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetPagedListAsync`：用于分页查询实体'
- en: 'The following code block shows how to get a list of forms filtered by the given
    name:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块显示了如何通过给定的名称获取过滤后的表单列表：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I've passed a lambda expression to the `GetListAsync` method to get all the
    `Form` entities with the given `name` parameter's value contained in their names.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我已将一个 lambda 表达式传递给 `GetListAsync` 方法，以获取所有具有给定 `name` 参数值包含在其名称中的 `Form` 实体。
- en: These methods are simple but limited. If you want to write advanced queries,
    you can use **Language-Integrated Query** (**LINQ**) over the repositories.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法简单但有限。如果你想编写高级查询，你可以在存储库上使用 **语言集成查询**（**LINQ**）。
- en: Using LINQ over the repositories
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在存储库上使用 LINQ
- en: Repositories provide the `GetQueryableAsync()` method, which returns an `IQueryable<TEntity>`
    object. You can then use this object to perform LINQ on the entities in the database.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库提供了 `GetQueryableAsync()` 方法，它返回一个 `IQueryable<TEntity>` 对象。然后你可以使用此对象在数据库中的实体上执行
    LINQ。
- en: 'The following example uses a LINQ operation on the `Form` entities to get a
    list of forms filtered and ordered by their names:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用 LINQ 操作在 `Form` 实体上获取按名称过滤和排序的表单列表：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We've first obtained an `IQueryable<Form>` object, then written a LINQ query,
    and finally executed the query using the `IAsyncQueryableExecuter` service.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取了一个 `IQueryable<Form>` 对象，然后编写了一个 LINQ 查询，最后使用 `IAsyncQueryableExecuter`
    服务执行了查询。
- en: 'An alternative way to write the previous query could be using LINQ extension
    methods, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种编写先前查询的替代方法可以是使用 LINQ 扩展方法，如下所示：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Having an `IQueryable` object provides you with all the power of LINQ. You can
    even make joins between multiple `IQueryable` objects obtained from different
    repositories.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个 `IQueryable` 对象为你提供了 LINQ 的所有功能。你甚至可以在来自不同存储库的多个 `IQueryable` 对象之间进行连接。
- en: 'Using the `IAsyncQueryableExecuter` service may seem strange to you. You may
    expect to call the `ToListAsync` method directly on the query object, like so:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `IAsyncQueryableExecuter` 服务可能对你来说有些奇怪。你可能期望直接在查询对象上调用 `ToListAsync` 方法，如下所示：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Unfortunately, `ToListAsync` is an extension method defined by EF Core (or MongoDB,
    if you are using it) and located inside the `Microsoft.EntityFrameworkCore` NuGet
    package. If referencing that package from your application layer is not a problem
    for you, then you can directly use these asynchronous extension methods in your
    code. However, if you want to keep your application layer ORM-independent, ABP's
    `IAsyncQueryableExecuter` service provides the necessary abstraction.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`ToListAsync` 是由 EF Core（或如果你使用 MongoDB，则位于）定义的扩展方法，位于 `Microsoft.EntityFrameworkCore`
    NuGet 包内。如果你从应用程序层引用该包没有问题，那么你可以在代码中直接使用这些异步扩展方法。然而，如果你想保持应用程序层 ORM 依赖性，ABP 的
    `IAsyncQueryableExecuter` 服务提供了必要的抽象。
- en: IRepository async extension methods
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`IRepository` 异步扩展方法'
- en: 'ABP Framework provides all the standard async LINQ extension methods for the
    `IRepository` interface: `AllAsync`, `AnyAsync`, `AverageAsync`, `ContainsAsync`,
    `CountAsync`, `FirstAsync`, `FirstOrDefaultAsync`, `LastAsync`, `LastOrDefaultAsync`,
    `LongCountAsync`, `MaxAsync`, `MinAsync`, `SingleAsync`, `SingleOrDefaultAsync`,
    `SumAsync`, `ToArrayAsync`, and `ToListAsync`. You can directly use any of these
    methods on a repository object.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 框架为 `IRepository` 接口提供了所有标准的异步 LINQ 扩展方法：`AllAsync`, `AnyAsync`, `AverageAsync`,
    `ContainsAsync`, `CountAsync`, `FirstAsync`, `FirstOrDefaultAsync`, `LastAsync`,
    `LastOrDefaultAsync`, `LongCountAsync`, `MaxAsync`, `MinAsync`, `SingleAsync`,
    `SingleOrDefaultAsync`, `SumAsync`, `ToArrayAsync`, 和 `ToListAsync`。您可以直接在存储库对象上使用这些方法中的任何一个。
- en: 'The following example uses the `CountAsync` method to get a count of forms
    where the name starts with `"A"`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用 `CountAsync` 方法获取以 `"A"` 开头的表单的数量：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that these extension methods are only available on the `IRepository`
    interface. If you want to use queryable extensions, you should still follow the
    approach explained in the previous section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些扩展方法仅在 `IRepository` 接口上可用。如果您想使用可查询的扩展，您仍然应该遵循上一节中解释的方法。
- en: Generic repositories for entities with CPKs
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有复合主键（CPK）的实体的泛型存储库
- en: If your entity has a CPK, you can't use the `IRepository<TEntity, TKey>` interface,
    since it gets a single PK (`Id`) type. In this case, you can use the `IRepository<TEntity>`
    interface.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的实体有一个复合主键（CPK），您不能使用 `IRepository<TEntity, TKey>` 接口，因为它获取一个单一的主键（`Id`）类型。在这种情况下，您可以使用
    `IRepository<TEntity>` 接口。
- en: 'For example, you can use `IRepository<FormManager>` to get managers of a given
    form, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用 `IRepository<FormManager>` 获取给定表单的管理员，如下所示：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, I've used the `IRepository<FormManager>` interface to perform
    a query for the `FormManager` entities.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我使用了 `IRepository<FormManager>` 接口对 `FormManager` 实体执行查询。
- en: Repositories for Non-Aggregate Root Entities
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 非聚合根实体的存储库
- en: As stated in the *Generic repositories* section of this chapter, you can't use
    `IRepository<FormManager>` by default, since `FormManager` is not an aggregate
    root entity. You normally want to get the `Form` aggregate root and access its
    `Managers` collection to get the form managers. However, if you are using EF Core,
    you can create default generic repositories for entities that are not aggregate
    roots. See the *EF Core integration* section to learn how to do this.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章中“泛型存储库”部分所述，默认情况下不能使用 `IRepository<FormManager>`，因为 `FormManager` 不是一个聚合根实体。通常，您想要获取
    `Form` 聚合根并访问其 `Managers` 集合以获取表单管理器。但是，如果您使用 EF Core，可以为不是聚合根的实体创建默认的泛型存储库。请参阅“EF
    Core 集成”部分了解如何这样做。
- en: One limitation of generic repositories without the `TKey` generic argument is
    that they don't have methods that get `Id` parameters because they can't know
    the `Id` type. However, you can still use LINQ to write any type of query you
    need.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 没有提供 `TKey` 泛型参数的泛型存储库有一个限制，就是它们没有获取 `Id` 参数的方法，因为它们不知道 `Id` 的类型。然而，您仍然可以使用
    LINQ 编写任何需要的查询。
- en: Other generic repository types
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他泛型存储库类型
- en: 'You typically want to use the repository interfaces explained in the previous
    sections since they are the most feature-full repository types. However, there
    are some more limited repository types that can be useful in some scenarios, such
    as the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常想要使用上一节中解释的存储库接口，因为它们是最功能丰富的存储库类型。然而，还有一些更有限的存储库类型在某些场景中可能很有用，例如以下内容：
- en: '`IBasicRepository<TEntity, TPrimaryKey>` and `IBasicRepository<TEntity>` provide
    fundamental repository methods, but they don''t support LINQ and `IQueryable`
    functionalities. You can use these repositories if your underlying database provider
    doesn''t support LINQ or you don''t want to leak LINQ queries into your application
    layer. In this case, you probably need to write custom repositories by inheriting
    from these interfaces and implement your queries with custom methods.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IBasicRepository<TEntity, TPrimaryKey>` 和 `IBasicRepository<TEntity>` 提供了基本的存储库方法，但它们不支持
    LINQ 和 `IQueryable` 功能。如果您的底层数据库提供程序不支持 LINQ 或您不想将 LINQ 查询泄露到应用程序层，则可以使用这些存储库。在这种情况下，您可能需要通过继承这些接口并使用自定义方法实现查询来编写自定义存储库。'
- en: '`IReadOnlyRepository<TEntity, TKey>`, `IReadOnlyRepository<TEntity>`, `IReadOnlyBasicRepository<Tentity,
    TKey>`, and `IReadOnlyBasicRepository<TEntity, TKey>` provide methods to fetch
    data but do not include any methods to manipulate the database.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IReadOnlyRepository<TEntity, TKey>`, `IReadOnlyRepository<TEntity>`, `IReadOnlyBasicRepository<Tentity,
    TKey>`, 和 `IReadOnlyBasicRepository<TEntity, TKey>` 提供了获取数据的方法，但不包括任何操作数据库的方法。'
- en: Generic repository methods are enough for most cases. However, you may still
    need to add custom methods to your repositories.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通用仓库方法对于大多数情况已经足够。然而，您可能仍然需要向您的仓库中添加自定义方法。
- en: Custom repositories
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义仓库
- en: You can create custom repository interfaces and classes to access the underlying
    database provider **application programming interface** (**API**), encapsulate
    your LINQ expressions, call stored procedures, and so on.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建自定义仓库接口和类来访问底层数据库提供者的**应用程序编程接口**（**API**），封装您的LINQ表达式，调用存储过程，等等。
- en: 'To create a custom repository, first, define a new repository interface. Repository
    interfaces are defined in the `Domain` project that comes with the startup template.
    You can inherit from one of the generic repository interfaces to include the standard
    methods in your repository interface. The code is illustrated in the following
    snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个自定义仓库，首先，定义一个新的仓库接口。仓库接口在启动模板提供的`Domain`项目中定义。您可以从一个通用仓库接口继承以将标准方法包含在您的仓库接口中。以下代码片段展示了如何实现：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`IFormRepository` inherits from `IRepository<Form, Guid>` and adds a new method
    to get a list of forms with some filters. You can then inject `IFormRepository`
    into your services instead of the generic repository and use your custom methods.
    If you don''t want to include the standard repository methods, just derive your
    interface from the `IRepository` (without any generic argument) interface. This
    is an empty interface that is used to identify your interface as a repository.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`IFormRepository`继承自`IRepository<Form, Guid>`并添加了一个新方法来获取具有某些筛选条件的表单列表。然后，您可以将`IFormRepository`注入到您的服务中，而不是使用通用仓库，并使用您自定义的方法。如果您不想包含标准仓库方法，只需从`IRepository`（不带任何泛型参数）接口派生您的接口。这是一个空接口，用于标识您的接口作为仓库。'
- en: Surely, we must implement the `IFormRepository` interface somewhere in our application.
    ABP startup templates provide integration projects for the underlying database
    provider, so we can implement custom repository interfaces in the database integration
    project. We will implement that interface for EF Core and MongoDB in the next
    sections.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们必须在我们的应用程序的某个地方实现`IFormRepository`接口。ABP启动模板为底层数据库提供者提供了集成项目，因此我们可以在数据库集成项目中实现自定义仓库接口。在下一节中，我们将为EF
    Core和MongoDB实现该接口。
- en: EF Core integration
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EF Core集成
- en: Microsoft's EF Core is the de facto ORM for .NET, with which you can work with
    major database providers, such as SQL Server, Oracle, MySQL, PostgreSQL, and Cosmos
    DB. It is the default database provider when you create a new ABP solution using
    the ABP **command-line interface** (**CLI**).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的EF Core是.NET的事实上的ORM，您可以使用它与主要的数据库提供者一起工作，例如SQL Server、Oracle、MySQL、PostgreSQL和Cosmos
    DB。当您使用ABP **命令行界面**（**CLI**）创建新的ABP解决方案时，它是默认的数据库提供者。
- en: 'The startup template uses *SQL Server* by default. If you prefer another `-dbms`
    parameter while creating a new solution, like so:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 启动模板默认使用*SQL Server*。如果您在创建新解决方案时更喜欢另一个`-dbms`参数，如下所示：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`SqlServer`, `MySQL`, `SQLite`, `Oracle`, and `PostgreSQL` are directly supported.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`SqlServer`、`MySQL`、`SQLite`、`Oracle`和`PostgreSQL`直接支持。'
- en: Other Databases
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 其他数据库
- en: 'You can refer to ABP''s documentation to learn about up-to-date supported database
    options and how to switch to another database provider that the ABP CLI does not
    support out of the box: [https://docs.abp.io/en/abp/latest/Entity-Framework-Core-Other-DBMS](https://docs.abp.io/en/abp/latest/Entity-Framework-Core-Other-DBMS).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考ABP的文档来了解最新的支持数据库选项以及如何切换到ABP CLI默认不支持的另一个数据库提供者：[https://docs.abp.io/en/abp/latest/Entity-Framework-Core-Other-DBMS](https://docs.abp.io/en/abp/latest/Entity-Framework-Core-Other-DBMS)。
- en: In the next sections, you will learn how to configure the DBMS (although it
    is already done in the startup template), define a `DbContext` class, and register
    to the **dependency injection** (**DI**) system. Then, you will see how to map
    your entities to database tables, using Code First Migrations and creating custom
    repositories for your entities. Finally, we will explore different ways of loading
    related data for an entity.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何配置DBMS（尽管它已经在启动模板中完成），定义一个`DbContext`类，并将其注册到**依赖注入**（**DI**）系统中。然后，您将看到如何使用Code
    First Migrations将您的实体映射到数据库表中，为您的实体创建自定义仓库。最后，我们将探讨为实体加载相关数据的不同方法。
- en: Configuring the DBMS
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置DBMS
- en: 'We use `AbpDbContextOptions` to configure the DBMS in the `ConfigureServices`
    method of our module. The following example configures using SQL Server as the
    DBMS:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `AbpDbContextOptions` 在模块的 `ConfigureServices` 方法中配置 DBMS。以下示例配置使用 SQL
    Server 作为 DBMS：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Surely, the `UseSqlServer()` method call will be different if you've preferred
    a different DBMS. We don't need to set the connection string since it is automatically
    obtained from the `ConnectionStrings:Default` configuration. You can check the
    `appsettings.json` file in your project to see and change the connection string.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您选择了不同的 DBMS，`UseSqlServer()` 方法调用将会有所不同。我们不需要设置连接字符串，因为它会自动从 `ConnectionStrings:Default`
    配置中获取。您可以在项目的 `appsettings.json` 文件中查看并更改连接字符串。
- en: We've configured the DBMS but haven't defined a `DbContext` object, which is
    necessary to work with the database in EF Core.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了 DBMS，但尚未定义 `DbContext` 对象，这是在 EF Core 中与数据库工作所必需的。
- en: Defining DbContext
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 DbContext
- en: '`DbContext` is the main object in EF Core that you interact with the database.
    You normally create a class inheriting from `DbContext` to create your own `DbContext`.
    With ABP Framework, we are inheriting from `AbpDbContext` instead.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`DbContext` 是 EF Core 中您与之交互数据库的主要对象。您通常创建一个继承自 `DbContext` 的类来创建自己的 `DbContext`。在
    ABP 框架中，我们继承自 `AbpDbContext` 而不是 `DbContext`。'
- en: 'Here is an example of a `DbContext` class definition with ABP Framework:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 ABP 框架的 `DbContext` 类定义示例：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`FormsAppDbContext` inherits from `AbpDbContext<FormsAppDbContext>`. `AbpDbContext`
    is a generic class and takes the `DbContext` type as a generic parameter. It also
    forces us to create a constructor, as shown here. We can then add `DbSet` properties
    for our entities. It is essential to add `DbSet` properties since ABP can create
    default generic repositories only for the entities with `DbSet` properties defined.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormsAppDbContext` 继承自 `AbpDbContext<FormsAppDbContext>`。`AbpDbContext` 是一个泛型类，它将
    `DbContext` 类型作为泛型参数。它还强制我们创建一个构造函数，如下所示。然后我们可以为我们的实体添加 `DbSet` 属性。添加 `DbSet`
    属性是必要的，因为 ABP 只能为具有定义了 `DbSet` 属性的实体创建默认的泛型仓储。'
- en: Once we've defined `DbContext`, we should register it with the DI system to
    use it in our application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了 `DbContext`，我们就应该将其注册到 DI 系统中，以便在应用程序中使用它。
- en: Registering DbContext with DI
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 DbContext 注册到 DI
- en: 'The `AddAbpDbContext` extension method is used to register `DbContext` classes
    with the DI system. You can use this method inside the `ConfigureServices` method
    of your module (it is inside the `EntityFrameworkCore` project in the startup
    solution), as shown in the following code block:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `AddAbpDbContext` 扩展方法将 `DbContext` 类注册到 DI 系统中。您可以在模块的 `ConfigureServices`
    方法中使用此方法（它位于启动解决方案中的 `EntityFrameworkCore` 项目内），如下面的代码块所示：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`AddDefaultRepositories()` is used to enable default generic repositories for
    your entities related to that `DbContext`. It enables generic repositories only
    for aggregate root entities by default because, in `includeAllEntities` parameter
    to `true` if you want to use repositories for other entity types too, as illustrated
    here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `AddDefaultRepositories()` 启用与该 `DbContext` 相关的实体的默认泛型仓储。默认情况下，它只为聚合根实体启用泛型仓储，因为如果您想为其他实体类型也使用仓储，可以将
    `includeAllEntities` 参数设置为 `true`，如下所示：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With this option, you can inject the `IRepository` service for any entity in
    your application code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此选项，您可以在应用程序代码中注入任何实体的 `IRepository` 服务。
- en: The includeAllEntities Option in the Startup Template
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 启动模板中的 includeAllEntities 选项
- en: The ABP startup template sets the `includeAllEntities` option to `true` because
    developers working on relational databases are used to querying from all database
    tables. If you want to apply DDD principles strictly, you should always use the
    aggregate roots to access sub-entities. In this case, you can remove this option
    from the `AddDefaultRepositories` method call.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 启动模板将 `includeAllEntities` 选项设置为 `true`，因为从事关系数据库开发的开发者习惯于查询所有数据库表。如果您想严格应用
    DDD 原则，您应该始终使用聚合根来访问子实体。在这种情况下，您可以从 `AddDefaultRepositories` 方法调用中删除此选项。
- en: We've seen how to register the `DbContext` class. We can inject and use `IRepository`
    interfaces for all your entities in your `DbContext` class. However, we should
    first configure the EF Core mappings for the entities.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何注册 `DbContext` 类。我们可以在 `DbContext` 类中注入并使用所有实体的 `IRepository` 接口。然而，我们首先应该配置实体的
    EF Core 映射。
- en: Configuring entity mappings
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置实体映射
- en: 'EF Core is an object-to-relational mapper that maps your entities to database
    tables. We can configure the details of those mappings in two ways, as outlined
    here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 是一个对象关系映射器，它将你的实体映射到数据库表。我们可以通过以下两种方式配置这些映射的细节，如下所述：
- en: Using data annotation attributes on your entity class
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的实体类上使用数据注释属性
- en: Using Fluent API inside by overriding the `OnModelCreating` method
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过重写 `OnModelCreating` 方法使用 Fluent API
- en: Using data annotation attributes makes your domain layer EF Core-dependent.
    If that's not a problem for you, you can simply use these attributes by following
    EF Core's documentation. In this book, I will use the Fluent API approach.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据注释属性会使你的领域层依赖于 EF Core。如果你不介意这个问题，你可以简单地遵循 EF Core 的文档来使用这些属性。在这本书中，我将使用
    Fluent API 方法。
- en: 'To use the Fluent API approach, you can override the `OnModelCreating` method
    in your `DbContext` class, as shown in the following code block:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Fluent API 方法，你可以在你的 `DbContext` 类中重写 `OnModelCreating` 方法，如下面的代码块所示：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When you override the `OnModelCreating` method, always call `base.OnModelCreating()`
    since ABP also performs default configurations inside that method, necessary to
    properly use ABP features such as audit logs and data filters. Then, you can use
    the `builder` object to perform your configurations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重写 `OnModelCreating` 方法时，始终要调用 `base.OnModelCreating()`，因为 ABP 也会在该方法内部执行默认配置，这对于正确使用
    ABP 功能（如审计日志和数据过滤器）是必要的。然后，你可以使用 `builder` 对象来执行你的配置。
- en: 'For example, we can configure the mapping for the `Form` class defined in this
    chapter, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以配置本章中定义的 `Form` 类的映射，如下所示：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Calling the `b.ConfigureByConvention()` method is important here. It configures
    the base properties of your entity if it is derived from ABP's pre-defined `Entity`
    or `AggregateRoot` classes. The remaining configuration code is pretty clean and
    standard, and you can learn all the details from EF Core's documentation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在重写 `OnModelCreating` 方法时调用 `b.ConfigureByConvention()` 方法很重要。如果实体是从 ABP 预定义的
    `Entity` 或 `AggregateRoot` 类派生的，它将配置实体的基本属性。剩余的配置代码相当干净和标准，你可以从 EF Core 的文档中学习所有详细信息。
- en: 'Here is another example that configures a relation between entities:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个配置实体之间关系的示例：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this example, we are defining the relation between the `Form` and `Question`
    entities: a form can have many questions, while a question always belongs to a
    single form.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们正在定义 `Form` 和 `Question` 实体之间的关系：一个表可以有多个问题，而一个问题始终属于单个表。
- en: The configuration we've made ensures that EF Core knows how to read and write
    entities to the database tables. However, related tables in the database should
    also be available. You can definitely create a database and the tables inside
    it manually. Then, in every change to your entities, you manually reflect the
    related changes in the database schema. However, it is hard to keep your entities
    and database tables in sync in this way. It is also tedious and error-prone to
    make them all manual, especially when you have multiple environments (such as
    development and production).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的配置确保了 EF Core 知道如何读取和写入数据库表中的实体。然而，数据库中的相关表也应该可用。你当然可以手动创建数据库及其内部的表。然后，在实体发生每次变化时，你都需要手动在数据库架构中反映相关的更改。然而，以这种方式保持实体和数据库表的一致性是困难的。如果拥有多个环境（如开发和生产），手动进行所有这些操作既繁琐又容易出错。
- en: 'Fortunately, there is a better way: Code First Migrations. EF''s Code First
    Migrations system provides an efficient way to incrementally update the database
    schema to keep it in sync with your entity model. We''ve already used the Code
    First Migration system in [*Chapter 3*](B17287_03_Epub_AM.xhtml#_idTextAnchor044),
    *Step-By-Step Application Development*. You can refer to that chapter to learn
    how to add a new database migration and apply it in the database.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种更好的方法：Code First Migrations。EF 的 Code First Migrations 系统提供了一种有效的方法，可以增量更新数据库架构，使其与你的实体模型保持同步。我们已经在
    [*第 3 章*](B17287_03_Epub_AM.xhtml#_idTextAnchor044)，*逐步应用开发* 中使用了 Code First Migration
    系统。你可以参考该章节来学习如何添加新的数据库迁移并在数据库中应用它。
- en: Implementing custom repositories
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现自定义仓储
- en: We created an `IFormRepository` interface in the *Custom repositories* part
    of the *Working with repositories* section in this chapter. Now, it's time to
    implement this repository interface using EF Core.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章 *与仓储一起工作* 部分的 *自定义仓储* 部分创建了一个 `IFormRepository` 接口。现在，是时候使用 EF Core 来实现这个仓储接口了。
- en: 'You can implement the repository inside the EF Core integration project of
    your solution, like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的解决方案的 EF Core 集成项目中实现仓库，如下所示：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This class is derived from ABP''s `EfCoreRepository` class. In this way, we
    are inheriting all the standard repository methods. The `EfCoreRepository` class
    gets three generic parameters: the `DbContext` type, the entity type, and the
    PK type of the entity class.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是从 ABP 的 `EfCoreRepository` 类派生出来的。这样，我们就继承了所有标准仓库方法。`EfCoreRepository` 类获取三个泛型参数：`DbContext`
    类型、实体类型和实体类的 PK 类型。
- en: '`FormRepository` also implements `IFormRepository`, which defines a custom
    `GetListAsync` method. We get the `DbContext` instance to use all the power of
    the EF Core API in this method.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormRepository` 还实现了 `IFormRepository`，它定义了一个自定义的 `GetListAsync` 方法。我们在该方法中使用
    `DbContext` 实例来利用 EF Core API 的所有功能。'
- en: Tip about WhereIf
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 WhereIf 的提示
- en: Conditional filtering is a widely used pattern, and ABP provides a nice `WhereIf`
    extension method that can simplify our code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 条件过滤是一个广泛使用的模式，ABP 提供了一个很好的 `WhereIf` 扩展方法，可以简化我们的代码。
- en: 'We could rewrite the `GetListAsync` method, as shown in the following code
    block:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重写 `GetListAsync` 方法，如下面的代码块所示：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since we have the `DbContext` instance, we can use it to execute **Structured
    Query Language** (**SQL**) commands or stored procedures. The following method
    executes a raw SQL command to delete all draft forms:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有 `DbContext` 实例，我们可以使用它来执行 **结构化查询语言**（**SQL**）命令或存储过程。以下方法执行一个原始 SQL 命令来删除所有草稿表单：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Executing Stored Procedures and Functions
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 执行存储过程和函数
- en: You can refer to EF Core's documentation ([https://docs.microsoft.com/en-us/ef/core](https://docs.microsoft.com/en-us/ef/core))
    to learn how to execute stored procedures and functions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考 EF Core 的文档（[https://docs.microsoft.com/en-us/ef/core](https://docs.microsoft.com/en-us/ef/core)）来了解如何执行存储过程和函数。
- en: 'Once you implement `IFormRepository`, you can inject and use it instead of
    `IRepository<Form, Guid>`, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实现了 `IFormRepository`，你就可以注入并使用它，而不是使用 `IRepository<Form, Guid>`，如下所示：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This class uses the custom `GetListAsync` method of `IFormRepository`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类使用了 `IFormRepository` 的自定义 `GetListAsync` 方法。
- en: Even if you implement a custom repository class for the `Form` entity, it is
    still possible to inject and use default generic repositories (for example, `IRepository<Form,
    Guid>`) for that entity. This is a good feature, especially if you start with
    generic repositories, then decide to create a custom repository later. You don't
    have to change your existing code that uses the generic repository.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你为 `Form` 实体实现了自定义仓库类，仍然可以注入并使用该实体的默认泛型仓库（例如，`IRepository<Form, Guid>`）。这是一个很好的特性，特别是如果你从泛型仓库开始，然后决定稍后创建自定义仓库。你不需要更改使用泛型仓库的现有代码。
- en: 'One potential problem may occur if you override a base method from the `EfCoreRepository`
    class and customize it in your repository. In this case, the services that use
    the generic repository reference will continue to use the non-overridden method.
    To prevent this fragmentation, use the `AddRepository` method while registering
    your `DbContext` with DI, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在你的仓库中覆盖了 `EfCoreRepository` 类的基方法并进行了自定义，可能会出现一个潜在问题。在这种情况下，使用泛型仓库引用的服务将继续使用未覆盖的方法。为了防止这种碎片化，在将
    `DbContext` 注册到 DI 时使用 `AddRepository` 方法，如下所示：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With this configuration, the `AddRepository` method redirects generic repositories
    to your custom repository class.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置，`AddRepository` 方法将泛型仓库重定向到你的自定义仓库类。
- en: Loading related data
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载相关数据
- en: If your entity has navigation properties to other entities or has collections
    of other entities, then you'll frequently need to access those related entities
    while working with the main entity. For example, the `Form` entity introduced
    before has a collection of `Question` entities, and you may need to access the
    questions while working with a `Form` object.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的实体有指向其他实体的导航属性或具有其他实体的集合，那么在处理主实体时，你将经常需要访问这些相关实体。例如，之前引入的 `Form` 实体有一个
    `Question` 实体的集合，你可能需要在处理 `Form` 对象时访问这些问题。
- en: 'There are multiple ways to access related entities: **explicit loading**, **lazy
    loading**, and **eager loading**.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式访问相关实体：**显式加载**、**延迟加载**和**贪婪加载**。
- en: Explicit loading
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式加载
- en: Repositories provide `EnsurePropertyLoadedAsync` and `EnsureCollectionLoadedAsync`
    extension methods to load a navigation property or sub-collection explicitly.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库提供了 `EnsurePropertyLoadedAsync` 和 `EnsureCollectionLoadedAsync` 扩展方法来显式加载导航属性或子集合。
- en: 'For example, we can explicitly load the questions of a form, as shown in the
    following code block:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以显式地加载表单的问题，如下面的代码块所示：
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If we don't use `EnsureCollectionLoadedAsync` here, then the `form.Questions`
    collection might be empty. If we are not sure it is filled, we can use `EnsureCollectionLoadedAsync`
    to ensure it is loaded. The `EnsurePropertyLoadedAsync` and `EnsureCollectionLoadedAsync`
    methods do nothing if the related property or collection is already loaded, so
    calling them multiple times is not a problem for performance.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不在这里使用`EnsureCollectionLoadedAsync`，那么`form.Questions`集合可能会为空。如果我们不确定它是否已填充，我们可以使用`EnsureCollectionLoadedAsync`来确保它被加载。如果相关的属性或集合已经加载，`EnsurePropertyLoadedAsync`和`EnsureCollectionLoadedAsync`方法不会做任何事情，因此多次调用它们对性能没有问题。
- en: Lazy loading
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 懒加载
- en: 'Lazy loading is a feature of EF Core that loads related properties and collections
    when you first access them. Lazy loading is not enabled by default. If you want
    to enable it for your `DbContext`, follow these steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载是 EF Core 的一个功能，当你第一次访问它们时，它会加载相关的属性和集合。懒加载默认是禁用的。如果你想为你的`DbContext`启用它，请按照以下步骤操作：
- en: Install the `Microsoft.EntityFrameworkCore.Proxies` NuGet package in your EF
    Core layer.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 EF Core 层中安装`Microsoft.EntityFrameworkCore.Proxies` NuGet 包。
- en: 'Use the `UseLazyLoadingProxies` method while configuring `AbpDbContextOptions`,
    as follows:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置`AbpDbContextOptions`时使用`UseLazyLoadingProxies`方法，如下所示：
- en: '[PRE30]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Be sure that the navigation properties and collection properties are virtual
    in your entities, as shown here:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的实体中的导航属性和集合属性是虚拟的，如下所示：
- en: '[PRE31]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When you enable lazy loading, you don't need to use explicit loading anymore.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启用懒加载时，你不再需要使用显式加载。
- en: 'Lazy loading is a discussed concept of ORMs. Some developers find it useful
    and practical, while others suggest not using it in any way. I am drawn to not
    using it because it has some potential problems, such as these:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载是 ORMs 中讨论的一个概念。一些开发者认为它有用且实用，而另一些开发者建议根本不要使用它。我倾向于不使用它，因为它有一些潜在的问题，例如这些：
- en: Lazy loading can't use asynchronous programming because there is no way to access
    a property with the `async`/`await` pattern. So, it blocks the caller thread,
    which is a bad practice for throughput and scalability.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载不能使用异步编程，因为没有方法可以通过`async`/`await`模式访问属性。因此，它会阻塞调用线程，这对吞吐量和可扩展性来说是不良的做法。
- en: You may have a `1+N` loading problem if you forget to eager-load the related
    data before using a `foreach` loop. `1+N` loading means you query a list of entities
    from the database with a single database operation (`1`), then perform a loop
    that accesses a navigation property (or a collection) of these entities. In this
    case, it lazy-loads the related property for each loop (`N` = count of the queried
    entities in the first database operation). So, you make a `1+N` database call,
    which dramatically drops your application performance. You should eager-load the
    related entities in such cases so that you make a single database in total.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你忘记在使用`foreach`循环之前预先加载相关数据，你可能会遇到`1+N`加载问题。`1+N`加载意味着你通过单个数据库操作（`1`）从数据库中查询一系列实体，然后执行一个循环，访问这些实体的导航属性（或集合）。在这种情况下，它会为每个循环（`N`
    = 第一次数据库操作中查询到的实体的数量）懒加载相关的属性。因此，你进行了`1+N`次数据库调用，这会极大地降低你的应用程序性能。在这种情况下，你应该预先加载相关的实体，以便总共进行一次数据库调用。
- en: It makes it hard to predicate and optimize your code since you may not easily
    see when the related data is loaded from the database.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得对你的代码进行预测和优化变得困难，因为你可能不容易看到相关数据何时从数据库中加载。
- en: I suggest going for a more controlled approach and using eager loading wherever
    possible.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议采取更受控的方法，并在可能的情况下使用预加载。
- en: Eager loading
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预加载
- en: Eager loading is a way of loading related data while first querying the main
    entity.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 预加载是在首先查询主实体时加载相关数据的一种方式。
- en: 'Assume that you''ve created a custom repository method to load the related
    questions while getting a `Form` object from the database, as shown here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经创建了一个自定义仓库方法，在从数据库获取`Form`对象的同时加载相关的问题，如下所示：
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you create such custom repository methods, you can use the full EF Core API.
    However, if you are working with ABP's repositories and don't want to depend on
    EF Core in your application layer, you can't use EF Core's `Include` extension
    method (which is used to eager-load the related data). In this case, you have
    two options, which are discussed in the next sections.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了这样的自定义存储库方法，你可以使用完整的 EF Core API。然而，如果你正在使用 ABP 的存储库，并且不希望在应用程序层依赖于 EF
    Core，你不能使用 EF Core 的 `Include` 扩展方法（用于预加载相关数据）。在这种情况下，你有两种选择，下一节将讨论。
- en: IRepository.WithDetailsAsync
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`IRepository.WithDetailsAsync`'
- en: 'The `WithDetailsAsync` method of the `IRepository` returns an `IQueryable`
    instance by including the given properties or collections, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`IRepository` 的 `WithDetailsAsync` 方法通过包含给定的属性或集合，返回一个 `IQueryable` 实例，如下所示：'
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`WithDetailsAsync(f => f.Questions)` returns `IQueryable<Form>` with questions
    included, so we can safely loop through the `form.Questions` collection. `IAsyncQueryableExecuter`
    was explained before, in the *Generic repositories* section of this chapter. The
    `WithDetailsAsync` method can get more than one expression to include more than
    one property if you need it. `WithDetailsAsync` can''t be used if you need nested
    includes (the `ThenInclude` extension method in EF Core). In this case, create
    a custom repository method.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithDetailsAsync(f => f.Questions)` 返回包含问题的 `IQueryable<Form>`，因此我们可以安全地遍历
    `form.Questions` 集合。`IAsyncQueryableExecuter` 在本章的 *通用存储库* 部分中已经解释过。如果需要包含多个属性，`WithDetailsAsync`
    方法可以获取多个表达式。如果需要嵌套包含（EF Core 中的 `ThenInclude` 扩展方法），则不能使用 `WithDetailsAsync`。在这种情况下，创建一个自定义存储库方法。'
- en: The Aggregate pattern
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 聚合模式
- en: The Aggregate pattern will be covered in depth in [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316),
    *DDD – The Domain Layer*. However, to give a brief bit of information, an aggregate
    is considered a single unit; it is read and saved as a single unit with all sub-collections.
    That means you always load related questions while loading a form.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合模式将在[*第10章*](B17287_10_Epub_AM.xhtml#_idTextAnchor316)，*领域层*中进行深入探讨。然而，为了提供一些简要信息，聚合被认为是一个单一单元；它作为一个单元读取和保存，包括所有子集合。这意味着你始终在加载表单时加载相关的问题。
- en: 'ABP supports the aggregate pattern well and allows you to configure eager loading
    for an entity at a global point. We can write the following configuration inside
    the `ConfigureServices` method of our module class (in the `EntityFrameworkCore`
    project in your solution):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ABP很好地支持聚合模式，并允许你在全局点为实体配置预加载。我们可以在我们的模块类（在解决方案中的 `EntityFrameworkCore` 项目）的
    `ConfigureServices` 方法中编写以下配置：
- en: '[PRE34]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It is suggested to include all sub-collections. Once you configure the `DefaultWithDetailsFunc`
    method as shown, then the following will occur:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 建议包含所有子集合。一旦你配置了 `DefaultWithDetailsFunc` 方法，如下所示，那么以下情况将会发生：
- en: Repository methods that return a single entity (such as `GetAsync`) will eager-load
    related entities by default unless you explicitly disable that behaviour by specifying
    the `includeDetails` parameter to `false` on the method call.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回单个实体（例如 `GetAsync`）的存储库方法默认会预加载相关实体，除非你通过在方法调用中指定 `includeDetails` 参数为 `false`
    来显式禁用该行为。
- en: Repository methods that return multiple entities (such as `GetListAsync`) will
    allow the eager loading of related entities, while they will not eager-load by
    default.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回多个实体（例如 `GetListAsync`）的存储库方法将允许预加载相关实体，但默认情况下不会进行预加载。
- en: Here are some examples.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例。
- en: 'Get a single form with sub-collections included like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 获取包含子集合的单个表单如下：
- en: '[PRE35]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Get a single form without sub-collections like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 获取不带子集合的单个表单如下：
- en: '[PRE36]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Get a list of forms without sub-collections like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 获取不带子集合的表单列表如下：
- en: '[PRE37]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Get a list of forms with sub-collections included like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 获取包含子集合的表单列表如下：
- en: '[PRE38]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The Aggregate pattern simplifies your application code in most cases, while
    you can still fine-tune cases where you need performance optimization. Note that
    navigation properties (to other aggregates) are not used if you truly implement
    the Aggregate pattern. We will return to this topic again in [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316),
    *DDD – The Domain Layer*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合模式在大多数情况下简化了你的应用程序代码，同时你仍然可以针对需要性能优化的情况进行微调。请注意，如果你真正实现了聚合模式，则不会使用导航属性（到其他聚合）。我们将在[*第10章*](B17287_10_Epub_AM.xhtml#_idTextAnchor316)，*领域层*中再次讨论这个话题。
- en: We've covered the essentials of using EF Core with ABP Framework. The next section
    will explain MongoDB integration, the other built-in database provider of ABP
    Framework.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了使用 ABP 框架的 EF Core 的基本知识。下一节将解释 MongoDB 集成，这是 ABP 框架的另一个内置数据库提供程序。
- en: MongoDB integration
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB 集成
- en: MongoDB is a popular non-relational **document database**, which stores data
    in JSON-like documents rather than traditional row-/column-based tables.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是一种流行的非关系型 **文档数据库**，它以类似于 JSON 的文档形式存储数据，而不是传统的基于行/列的表。
- en: 'The ABP CLI provides an option to create new applications using MongoDB, as
    shown here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ABP CLI 提供了一个选项，可以创建使用 MongoDB 的新应用程序，如下所示：
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you want to check and change the database connection string, you can look
    at the `appsettings.json` file of your application.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要检查和更改数据库连接字符串，你可以查看应用程序的 `appsettings.json` 文件。
- en: The MongoDB Client Package
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 客户端包
- en: ABP uses the official `MongoDB.Driver` NuGet package for MongoDB integration.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 使用官方的 `MongoDB.Driver` NuGet 包来实现 MongoDB 集成。
- en: In the next chapters, you will learn how to work with ABP's `AbpMongoDbContext`
    class to define `DbContext` objects, perform object-mapping configurations, register
    `DbContext` objects with the DI system, and implement custom repositories when
    you want to extend the generic repositories for your entities.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将学习如何使用 ABP 的 `AbpMongoDbContext` 类来定义 `DbContext` 对象，执行对象映射配置，将 `DbContext`
    对象注册到 DI 系统中，并在需要扩展实体通用存储库时实现自定义存储库。
- en: We begin the MongoDB integration by defining a `DbContext` class.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过定义一个 `DbContext` 类来开始 MongoDB 集成。
- en: Defining DbContexts
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 DbContexts
- en: 'The MongoDB driver package doesn''t have a `DbContext` concept like EF Core
    does. However, ABP introduces the `AbpMongoDbContext` class to provide a standard
    way to define and configure MongoDB integration. We need to define a class deriving
    from the `AbpMongoDbContext` base class, as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 驱动程序包没有像 EF Core 那样的 `DbContext` 概念。然而，ABP 引入了 `AbpMongoDbContext` 类，以提供一个定义和配置
    MongoDB 集成的标准方式。我们需要定义一个从 `AbpMongoDbContext` 基类派生的类，如下所示：
- en: '[PRE40]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `MongoCollection` attribute sets the collection name on the database side.
    It is optional and uses the driver's default value if you don't specify it. Defining
    a collection property on the `FormsAppDbContext` class is required to use the
    default generic repositories.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`MongoCollection` 属性在数据库侧设置集合名称。它是可选的，如果你没有指定它，则使用驱动程序的默认值。在 `FormsAppDbContext`
    类上定义一个集合属性是使用默认泛型存储库所必需的。'
- en: Configuring object mappings
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置对象映射
- en: 'While the MongoDB C# driver is not an ORM, it still maps your entities to collections
    in the database, and you may want to customize the mapping configuration. In this
    case, override the `CreateModel` method in your `DbContext` class like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 MongoDB C# 驱动程序不是一个 ORM，但它仍然将你的实体映射到数据库中的集合，你可能想要自定义映射配置。在这种情况下，像这样覆盖你的 `DbContext`
    类中的 `CreateModel` 方法：
- en: '[PRE41]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example, I've configured MongoDB so that it ignores the `Description`
    property of the `Form` entity while saving and retrieving data. Please refer to
    the documentation of the `MongoDB.Driver` NuGet package to learn about all configuration
    options.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我已经配置了 MongoDB，使其在保存和检索数据时忽略 `Form` 实体的 `Description` 属性。请参阅 `MongoDB.Driver`
    NuGet 包的文档，了解所有配置选项。
- en: Registering DbContext with DI
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 DbContext 注册到 DI
- en: 'Once you create and configure your `DbContext` class, it is registered with
    the DI system in the `ConfigureServices` method of your module class (typically
    in the MongoDB integration project of your solution). The following code snippet
    illustrates this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建并配置了你的 `DbContext` 类，它就会在模块类的 `ConfigureServices` 方法中注册到 DI 系统中（通常在解决方案的
    MongoDB 集成项目中）。以下代码片段说明了这一点：
- en: '[PRE42]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`AddDefaultRepositories()` is used to enable default generic repositories for
    your entities related to that `DbContext`. You can then inject `IRepository<Form>`
    into your classes and start using your MongoDB database.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddDefaultRepositories()` 用于为与该 `DbContext` 相关的实体启用默认泛型存储库。然后，你可以将 `IRepository<Form>`
    注入到你的类中，并开始使用你的 MongoDB 数据库。'
- en: The `AddDefaultRepositories` method enables default repositories only for aggregate
    root entities (the entity classes derived from the `AggregateRoot` class). Set
    `includeAllEntities` to `true` to enable default repositories for all entity types.
    However, it is strongly suggested to apply the Aggregate pattern while working
    with MongoDB. The Aggregate pattern will be covered in depth in [*Chapter 10*](B17287_10_Epub_AM.xhtml#_idTextAnchor316),
    *DDD – The Domain Layer*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddDefaultRepositories`方法仅对聚合根实体（从`AggregateRoot`类派生的实体类）启用默认仓储。将`includeAllEntities`设置为`true`以启用所有实体类型的默认仓储。然而，在处理MongoDB时，强烈建议应用聚合模式。聚合模式将在[*第10章*](B17287_10_Epub_AM.xhtml#_idTextAnchor316)中深入探讨，*领域层
    – DDD*。'
- en: Default generic repositories are enough in most cases, but you may need to access
    the MongoDB API or abstract your queries into custom repository methods.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，默认的泛型仓储就足够了，但你可能需要访问MongoDB API或将查询抽象到自定义仓储方法中。
- en: Implementing custom repositories
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现自定义仓储
- en: We created an `IFormRepository` interface in the *Custom repositories* part
    of the *Working with repositories* section in this chapter. We can implement this
    repository interface using MongoDB.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章“与仓储一起工作”部分的“自定义仓储”部分创建了一个`IFormRepository`接口。我们可以使用MongoDB实现这个仓储接口。
- en: 'You can implement the repository inside the MongoDB integration project of
    your solution, like this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的解决方案的MongoDB集成项目中实现仓储，如下所示：
- en: '[PRE43]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `FormRepository` class is derived from ABP''s `MongoDbRepository` class.
    In this way, we are inheriting all the standard repository methods. The `MongoDbRepository`
    class gets three generic parameters: the `DbContext` type, the entity type, and
    the PK type of the entity class.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormRepository`类是从ABP的`MongoDbRepository`类派生的。这样，我们就继承了所有标准仓储方法。`MongoDbRepository`类获取三个泛型参数：`DbContext`类型、实体类型和实体类的PK类型。'
- en: 'The `FormRepository` class should implement the `GetListAsync` method defined
    by the `IFormRepository` interface, as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormRepository`类应实现由`IFormRepository`接口定义的`GetListAsync`方法，如下所示：'
- en: '[PRE44]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'I''ve used the LINQ API of the MongoDB driver in this example, but you can
    use alternative APIs by obtaining the `IMongoCollection` object, as illustrated
    in the following code snippet:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我使用了MongoDB驱动程序的LINQ API，但你可以通过获取`IMongoCollection`对象来使用其他API，如下面的代码片段所示：
- en: '[PRE45]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, you can inject `IFormRepository` instead of the generic `IRepository<Form,
    Guid>` repository into your services and use all the standard and custom repository
    methods.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将`IFormRepository`注入到你的服务中，而不是泛型的`IRepository<Form, Guid>`仓储，并使用所有标准和自定义仓储方法。
- en: 'Even if you implement a custom repository class for the `Form` entity, it is
    still possible to inject and use default generic repositories (such as `IRepository<Form,
    Guid>`) for that entity. If you implement a custom repository, it is suggested
    to use the `AddRepository` method on the `DbContext` registration code, as illustrated
    in the following code snippet:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 即使为`Form`实体实现了自定义仓储类，仍然可以为此实体注入和使用默认的泛型仓储（例如`IRepository<Form, Guid>`）。如果你实现了自定义仓储，建议在`DbContext`注册代码中使用`AddRepository`方法，如下面的代码片段所示：
- en: '[PRE46]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this way, generic default repositories will be redirected to your custom
    repository class. If you override a base method in your custom repository, they
    will also use your overload instead of the base method.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，泛型默认仓储将重定向到你的自定义仓储类。如果你在自定义仓储中重写了基类方法，它们也将使用你的重载而不是基类方法。
- en: We've learned how to use EF Core and MongoDB as the database provider. In the
    next section, we will understand the UoW system, making it possible to connect
    these databases and apply transactions.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用EF Core和MongoDB作为数据库提供者。在下一节中，我们将理解UoW系统，使其能够连接这些数据库并应用事务。
- en: Understanding the UoW system
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解UoW系统
- en: UoW is the main system that ABP uses to initiate, manage, and dispose of database
    connections and transactions. The UoW system is designed with the **Ambient Context
    pattern**. That means when we create a new UoW, it creates a scoped context that
    is participated by all the database operations performed in the current scope
    by sharing the same context and is considered a single transaction boundary. All
    the operations done in a UoW are committed (on success) or rolled back (on exception)
    together.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: UoW是ABP用来启动、管理和释放数据库连接和事务的主要系统。UoW系统是按照**环境上下文模式**设计的。这意味着当我们创建一个新的UoW时，它会创建一个范围上下文，该上下文由当前范围内执行的、共享相同上下文的全部数据库操作参与，并被视为一个单独的事务边界。在UoW中执行的所有操作要么（在成功时）提交，要么（在异常时）回滚。
- en: While you can manually create UoW scopes and control the transaction properties,
    most of the time, it works seamlessly just as you desire. However, it provides
    some options if you change the default behavior.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以手动创建UoW范围并控制事务属性，但大多数时候，它将无缝地按照你的期望工作。然而，如果你更改默认行为，它提供了一些选项。
- en: UoW and Database Operations
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: UoW和数据库操作
- en: All database operations must be performed in a UoW scope since UoW is the way
    to manage database connections and transactions in ABP Framework. Otherwise, you
    get an exception indicating that.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数据库操作必须在UoW范围内执行，因为UoW是管理ABP框架中数据库连接和事务的方式。否则，你会得到一个异常指示。
- en: In the next sections, you will gain an understanding of how the UoW system works
    and customize it by configuring the options. I will also explain how to manually
    control the UoW system when the conventional system doesn't work for your use
    case.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将了解UoW系统的工作原理以及如何通过配置选项来自定义它。我还会解释如何在传统系统不适合你的用例时手动控制UoW系统。
- en: Configuring UoW options
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置UoW选项
- en: With the default setup, in an ASP.NET Core application, an HTTP request is considered
    as the UoW scope. ABP starts a UoW at the beginning of the request and saves changes
    to the database if the request successfully finishes. It rolls back the UoW if
    the request fails because of an exception.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认设置下，在ASP.NET Core应用程序中，一个HTTP请求被视为UoW范围。ABP在请求开始时启动UoW，如果请求成功完成，则将更改保存到数据库。如果请求因异常失败，则回滚UoW。
- en: ABP determines database transaction usage based on the HTTP request type. HTTP
    `GET` requests don't create a database transaction. UoW works anyway but doesn't
    use a database transaction in this case. All other HTTP request types (`POST`,
    `PUT`, `DELETE`, and others) use a database transaction if you haven't configured
    them otherwise.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ABP根据HTTP请求类型确定数据库事务的使用。HTTP `GET`请求不创建数据库事务。UoW仍然工作，但在这种情况下不使用数据库事务。如果你没有其他配置，所有其他HTTP请求类型（`POST`、`PUT`、`DELETE`和其他）都将使用数据库事务。
- en: HTTP GET Requests and Transactions
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP GET请求和事务
- en: It is a best practice not to make database changes in `GET` requests. If you
    make multiple write operations in a `GET` request and somehow your request fails,
    your database state could be left in an inconsistent state because ABP doesn't
    create a database transaction for `GET` requests. In this case, either enable
    transactions for `GET` requests using `AbpUnitOfWorkDefaultOptions` or manually
    control the UoW, as described in the next section.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 不在`GET`请求中更改数据库是一个最佳实践。如果你在`GET`请求中执行多个写操作，并且请求以某种方式失败，你的数据库状态可能会处于不一致的状态，因为ABP不会为`GET`请求创建数据库事务。在这种情况下，你可以使用`AbpUnitOfWorkDefaultOptions`为`GET`请求启用事务，或者像下一节中描述的那样手动控制UoW。
- en: 'Use `AbpUnitOfWorkDefaultOptions` in the `ConfigureServices` method of your
    module (in the database integration project) if you want to change the UoW options,
    as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更改UoW选项，请在你的模块（数据库集成项目中）的`ConfigureServices`方法中使用`AbpUnitOfWorkDefaultOptions`，如下所示：
- en: '[PRE47]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`TransactionBehavior` can take the following three values:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransactionBehavior`可以取以下三个值：'
- en: '`Auto` (default): Automatically determines using database transactions (transactions
    are enabled for non-`GET` `HTTP` requests)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Auto` (默认): 自动确定是否使用数据库事务（非`GET` `HTTP`请求启用事务）'
- en: '`Enabled`: Always uses a database transaction, even for `HTTP` `GET` requests'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enabled`: 总是使用数据库事务，即使是`HTTP` `GET`请求'
- en: '`Disabled`: Never uses a database transaction'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Disabled`: 从不使用数据库事务'
- en: The `Auto` behavior is the default value and is suggested for most applications.
    `IsolationLevel` is only valid for relational databases. ABP uses the default
    value of the underlying provider if you don't specify it. Finally, the `Timeout`
    option allows you to set a default timeout value for transactions as milliseconds.
    If a UoW operation doesn't complete in the given timeout value, a timeout exception
    is thrown.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`Auto`行为是默认值，适用于大多数应用。`IsolationLevel`仅对关系型数据库有效。如果你没有指定，ABP将使用底层提供者的默认值。最后，`Timeout`选项允许你将事务的默认超时值设置为毫秒。如果UoW操作在给定超时值内未完成，将抛出超时异常。'
- en: In this section, we've learned how to configure the default options across all
    UoWs. It is also possible to configure these values for an individual UoW if you
    manually control it.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何配置所有UoW的默认选项。如果你手动控制，也可以为单个UoW配置这些值。
- en: Manually controlling the UoW
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动控制UoW
- en: For web applications, you rarely need to control the UoW system manually. However,
    for background workers or non-web applications, you may need to create UoW scopes
    yourself. You may also need to control the UoW system to create inner transaction
    scopes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Web应用，你很少需要手动控制UoW系统。然而，对于后台工作者或非Web应用，你可能需要自己创建UoW作用域。你可能还需要控制UoW系统以创建内部事务作用域。
- en: 'One way to create a UoW scope is to use the `[UnitOfWork]` attribute on your
    method, like this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 创建UoW作用域的一种方式是在你的方法上使用`[UnitOfWork]`属性，如下所示：
- en: '[PRE48]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The UoW system uses the Ambient Context pattern. If a surrounding UoW is already
    in place, your `UnitOfWork` attribute is ignored and your method participates
    in the surrounding UoW. Otherwise, ABP starts a new transactional UoW just before
    entering the `DoItAsync` method and commits the transaction if it doesn't throw
    an exception. The transaction is rolled back if that method throws an exception.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: UoW系统使用环境上下文模式。如果已经存在一个周围的UoW，你的`UnitOfWork`属性将被忽略，你的方法将参与周围的UoW。否则，ABP在进入`DoItAsync`方法之前启动一个新的事务性UoW，如果没有抛出异常，则提交事务。如果该方法抛出异常，则回滚事务。
- en: 'If you want to fine-control the UoW system, you can inject and use the `IUnitOfWorkManager`
    service, as shown in the following code block:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要精细控制UoW系统，你可以注入并使用`IUnitOfWorkManager`服务，如下面的代码块所示：
- en: '[PRE49]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In this example, we are starting a new transactional UoW scope with 15 seconds
    as the `timeout` parameter''s value. With this usage (`requiresNew: true`), ABP
    always starts a new UoW even if there is a surrounding UoW. Always call the `uow.CompleteAsync()`
    method if everything goes right. You can use the `uow.RollbackAsync()` method
    if you want to roll back the current transaction.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '在此示例中，我们以15秒作为`timeout`参数值的值启动一个新的事务性UoW作用域。使用此用法（`requiresNew: true`），即使存在周围的UoW，ABP也会始终启动一个新的UoW。如果一切顺利，始终调用`uow.CompleteAsync()`方法。如果你想回滚当前事务，可以使用`uow.RollbackAsync()`方法。'
- en: As mentioned before, UoW uses an ambient scope. You can access the current UoW
    anywhere in this scope, using the `IUnitOfWorkManager.Current` property. It can
    be `null` if there is no ongoing UoW.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，UoW使用环境作用域。你可以使用`IUnitOfWorkManager.Current`属性在任何此作用域中访问当前UoW。如果没有正在进行的UoW，它可以是`null`。
- en: 'The following code snippet uses the `SaveChangesAsync` method with the `IUnitOfWorkManager.Current`
    property:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段使用`SaveChangesAsync`方法与`IUnitOfWorkManager.Current`属性：
- en: '[PRE50]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We've saved all pending changes to the database. However, if that's a transactional
    UoW, these changes are also rolled back if you roll back the UoW or throw any
    exception in the UoW scope.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将所有挂起的更改保存到数据库中。然而，如果这是一个事务性UoW，如果你回滚UoW或在该作用域中抛出任何异常，这些更改也将被回滚。
- en: Summary
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've learned how to work with databases using ABP Framework.
    ABP standardizes to define entities by providing base classes. It also helps to
    automatically track change times and the users changing entities, when you derive
    from audited entity classes.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用ABP框架与数据库交互。ABP通过提供基类来标准化定义实体。它还帮助自动跟踪更改时间和更改实体的用户，当你从审计实体类派生时。
- en: The repository system provides the fundamental functionalities to read and write
    entities. You can use LINQ over the repositories for advanced querying possibilities.
    Also, you can create custom repository classes to work with the underlying data
    provider directly, hide complex queries behind simple repository interfaces, call
    stored procedures, and so on.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 仓储系统提供了读取和写入实体的基本功能。您可以使用LINQ在仓储上进行高级查询。此外，您还可以创建自定义仓储类，直接与底层数据提供程序一起工作，将复杂查询隐藏在简单的仓储接口后面，调用存储过程等。
- en: ABP is database-agnostic, but it provides integration packages with EF Core
    and MongoDB out of the box. ABP application startup templates come with one of
    these providers, whichever you prefer.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ABP是数据库无关的，但它提供了与EF Core和MongoDB的集成包，开箱即用。ABP应用程序启动模板包含这些提供程序之一，您可以选择您喜欢的。
- en: EF Core is the de facto ORM for the .NET platform, and ABP supports EF Core
    as a first-class citizen. The application startup template is fine-tuned to configure
    your mappings and manage your database schema migrations while supporting a modular
    application structure.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core是.NET平台上的事实上的ORM，ABP将其作为一等公民支持。应用程序启动模板经过精心调整，以配置您的映射并管理您的数据库模式迁移，同时支持模块化应用程序结构。
- en: Finally, the UoW system provides a seamless way to manage database connections
    and transactions for us. It keeps the application code clean by automating these
    repeating tasks for us.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，UoW系统为我们提供了一个无缝的方式来管理数据库连接和事务。它通过自动化这些重复性任务，使应用程序代码保持整洁。
- en: Data access is a core requirement for any business application, and it is essential
    to understand the details of it. The next chapter will continue with the cross-cutting
    concerns required for every application, such as authorization, validation, and
    exception handling.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 数据访问是任何业务应用的核心需求，理解其细节至关重要。下一章将继续介绍每个应用所需的横切关注点，例如授权、验证和异常处理。
