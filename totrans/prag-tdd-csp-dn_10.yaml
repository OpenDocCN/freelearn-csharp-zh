- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building an App with Repositories and Document DB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B18370_08_RN.xhtml#_idTextAnchor209), *Designing an Appointment
    Booking App*, we laid the technical specifications and the design decisions for
    building an appointment booking system for a barber salon called Heads Up Barbers.
    This chapter is a continuation of [*Chapter 8*](B18370_08_RN.xhtml#_idTextAnchor209),
    so I strongly advise you to be familiar with it first.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will implement the requirements in TDD style and will use the repository
    pattern with **Azure Cosmos DB**. The implementation will be applicable to other
    **document databases** aka **NoSQL** such as **MongoDB**, **Amazon DynamoDB**,
    **GCP Firestore**, and others.
  prefs: []
  type: TYPE_NORMAL
- en: If you are a fan of document DBs or you are using one at work, then this chapter
    is for you, while if you are using a relational database, then you might want
    to skip this chapter and go back to the previous chapter, [*Chapter 9*](B18370_09.xhtml#_idTextAnchor226).
    Both chapters, [*Chapter 9*](B18370_09.xhtml#_idTextAnchor226) and [*Chapter 10*](B18370_10.xhtml#_idTextAnchor245)
    have the same outcome, but they use different backend DB categories.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter assumes you are familiar with a document DB service and the idea
    behind document DBs, not necessarily Cosmos DB, as from a TDD perspective, the
    implementation between different DB products is almost identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Planning the code and the project structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the web APIs with TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answering frequently asked questions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have experienced the implementation of an
    end-to-end app using TDD with mocks and document DB backend. Also, you will witness
    the analysis process that precedes writing unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found at the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch10](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch10)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the project, you will need to have an instance of Cosmos DB installed.
    This can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Cosmos DB on the cloud under an Azure account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Cosmos DB Emulator**, which can be installed locally on Windows, Linux,
    and macOS and can run from Docker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation doesn’t use any advanced Cosmos feature, so feel free to
    use any Cosmos flavor. I have tested the application with Azure Cosmos DB Emulator
    on Windows locally. You can find more about it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/cosmos-db/local-emulator](https://docs.microsoft.com/en-us/azure/cosmos-db/local-emulator%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing the local emulator, you need to grab the connection string,
    which you can do by browsing to `https://localhost:8081/_explorer/index.xhtml`
    and copying the connection string from the **Primary Connection String** field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Finding Cosmos DB connection string ](img/Figure_10.1_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Finding Cosmos DB connection string
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the project, you have to set the connection string to your specific
    DB instance in `Uqs.AppointmentBooking.WebApi/AppSettings.json`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The connection string is pointing to `LocalMachine` and will connect to a database
    called `AppointmentBooking`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I am not concerned in this chapter regarding setting multiple environments,
    but you may want to create multiple `AppSettings` for different environments and
    change the connection string accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The previous DB configuration steps are optional. You can implement the requirements
    for this chapter without using a DB, but you won’t be able to run the project
    and interact with it in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Planning your code and project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B18370_08_RN.xhtml#_idTextAnchor209), *Designing an Appointment
    Booking App*, we planned our domain and analyzed what we needed to do. The project
    architecture will follow the classical three-tier applications of the client application
    (the website), business logic (the web APIs), and database (Cosmos DB). Let’s
    translate this into VS solutions and projects.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will create the solution and create the projects, and wire
    up the components.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing projects’ structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Get a group of senior developers to agree on one project structure, and you
    will end up with multiple structures! In this section, we will discuss a way of
    organizing your project structure that I have developed over the years.
  prefs: []
  type: TYPE_NORMAL
- en: Given that we are first going to build a website for the user and later a mobile
    app (not covered in this book), it makes sense to isolate the business logic to
    a web API project that can be shared by both the website and the mobile app. So,
    we will build a website project based on Blazor WebAssembly called `Uqs.AppointmentBooking.Website`.
  prefs: []
  type: TYPE_NORMAL
- en: The domain logic will be exposed as APIs, so we will create an ASP.NET API project
    for this one called `Uqs.AppointmentBooking.WebApi`.
  prefs: []
  type: TYPE_NORMAL
- en: The previous two projects needed to exchange data in an agreed structure called
    `Uqs.AppointmentBooking.Contracts`. This project will be referenced by both the
    website and the web API projects.
  prefs: []
  type: TYPE_NORMAL
- en: The web API project translates web requests into something we can understand
    in C#. In technical terms, this will manage our communication layer of HTTP with
    RESTful style APIs. So, the WebApi project will not contain business logic. The
    business logic will be in our domain project. We will create a domain project
    called `Uqs.AppointmentBooking.Domain`.
  prefs: []
  type: TYPE_NORMAL
- en: Your business logic will live in two places – the UI and the domain layer. The
    UI business logic will manage UI functionalities such as toggling dropdowns, blocking
    calendar days, responding to drag and drop, and disabling/enabling buttons, among
    others. This logic will live in the website project.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: UI frameworks such as Blazor and Angular act as standalone applications. These
    frameworks facilitate, by design, using a design pattern called **Model View View-Model**
    (**MVVM**), which makes dependency injection and, therefore, unit testing easy.
    However, unit testing the UI-specific elements (razor files in Blazor) requires
    a more specialized framework such as **bUnit**.
  prefs: []
  type: TYPE_NORMAL
- en: The language used in writing the code depends on the UI framework in use, such
    as Angular, React, and Blazor. In our implementation, we will have little code
    in the UI layer, so we will not be doing any UI unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: The sophisticated business logic will live in the domain layer, and we will
    be writing it following the concepts of TDD. So, we shall create a project that
    will hold our domain unit tests and call it `Uqs.AppointmentBooking.Domain.Tests.Unit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To put these projects into perspective and map them to our three-tier architecture,
    we can have the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The relationship between the projects and the application design
    ](img/Figure_10.2_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – The relationship between the projects and the application design
  prefs: []
  type: TYPE_NORMAL
- en: The previous diagram shows the functionality that each project provides to form
    the three-tier application. Let’s start by creating the VS solution structure.
  prefs: []
  type: TYPE_NORMAL
- en: Creating projects and configuring dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the boring inevitable part, creating the solution and the projects and
    then linking them together. In the following section, we will take the command
    line approach rather than the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I have added a text file, `create-projects.bat`, to the project source control
    that contains all the command lines, so you don’t have to write them manually.
    You can copy and paste this file to your desired directory, then, from your command
    line, execute the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the list of commands that will create your VS solution and
    its projects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From your OS console, navigate to the directory where you want to create your
    new solution and execute the following to create the solution file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute this to create the projects and notice that we are using a different
    template for each project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the projects to the solution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let’s set up dependencies between projects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And the last bit is adding the required NuGet packages to the project. The
    domain project will communicate with Cosmos DB using the Cosmos SDK from the `Microsoft.Azure.Cosmos`
    package. Add this library to the `Domain` project as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The unit testing project will require `NSubstitute` for mocking, so let’s add
    its NuGet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For visual inspection, you can open the solution file with VS, and it should
    look as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – A view of VS Solution Explorer ](img/Figure_10.3_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – A view of VS Solution Explorer
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, your solution structure should look similar.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the project structure is in place, we will modify the code.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the domain project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the domain analysis in [*Chapter 8*](B18370_08_RN.xhtml#_idTextAnchor209),
    *Designing an Appointment Booking App*, we have created a list of the domain objects.
    I will not go through them again; I will just create and add them to the `Domain`
    project under `DomainObjects`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Added domain objects ](img/Figure_10.4_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Added domain objects
  prefs: []
  type: TYPE_NORMAL
- en: 'These are just data structures with no business logic. Here is the source code
    of one of them, the `Customer` domain object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view the rest of the files in the chapter’s GitHub repository online.
    This is the interface of the previous class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`IEntity` is an interface that ensures every domain object that is going to
    be persisted to a document container has an `Id`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`Id` is a string as this is what a document DB is expecting and usually, but
    not necessarily, the string is a `GUID`.'
  prefs: []
  type: TYPE_NORMAL
- en: What is the relationship between our document containers and our domain objects?
  prefs: []
  type: TYPE_NORMAL
- en: Designing your containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I am assuming that you are familiar with the basics of document DBs, so I won’t
    be going into much detail. Let me start first by defining what a **container**
    is so that we have the same understanding across the chapter. A container is a
    storage unit that stores a similar document type. A container in a document DB
    shares similar characteristics to a table of a relational DB.
  prefs: []
  type: TYPE_NORMAL
- en: There are many schools and opinions regarding designing containers and the factors
    to take into consideration, but our focus in this book is TDD, so we shall keep
    this short and to the point. Obviously, designing in DDD, while it has some guidelines,
    is still a subjective process. It feels that our aggregate routes, `Service`,
    `Employee`, `Customer`, and `Appointment`, are direct contenders for becoming
    containers, so we will set them to be.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need a way for our domain services to interact with the database. This
    is done through the repository pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the repository pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our containers are now defined. We just need the mechanism of interacting with
    these containers. DDD employs the repository pattern for this purpose. Let’s shed
    some light on the role of the pattern and where it sits in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the repository pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The repository layer is code that knows how to interact with a database, it
    doesn’t matter what type of database is underlying (it doesn’t matter whether
    this is Cosmos, SQL Server, a text file, or others), document, relational, or
    others. The layer is meant to isolate the domain layer from understanding the
    specifics of the database. Instead, the domain services will only be concerned
    about what data to persist rather than how they will be persisted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next diagram shows the repository as the bottom layer in the domain layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – The repositories within DDD ](img/Figure_10.5_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – The repositories within DDD
  prefs: []
  type: TYPE_NORMAL
- en: You can see from the diagram that any domain object to be persisted in the database
    passes through the repositories layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The common practice of creating a repository is creating a repository per container.
    So, for our application, we will have four repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ServiceRepository`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CustomerRepository`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppointmentRepository`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EmployeeRepository`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given that we will have to unit test our implementation, our repositories need
    to be unit test-ready.
  prefs: []
  type: TYPE_NORMAL
- en: Repositories and unit testing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We suddenly started speaking about repositories in a chapter about TDD. The
    reason is that when you think of unit testing, the first thing that comes to mind
    is dependencies and how to isolate the database.
  prefs: []
  type: TYPE_NORMAL
- en: Repositories are the answer to this question, as they should provide the abstraction
    necessary to convert the database into an injectable dependency. You will see
    this clearly later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you have worked with a relational database using an **object-relational mapper**
    (**ORM**) such as **Entity Framework** or **NHibernate**, then you have probably
    not used the repository pattern directly as the ORM frameworks eliminate the need
    to use it.
  prefs: []
  type: TYPE_NORMAL
- en: You will see that our repositories will have interfaces that will allow them
    to be injection-ready. Enough of the theory and let me show you some code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the repository pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you have an idea about what repositories are, let’s start with an
    example. One of the repositories needed is `ServiceRepository`, which will interact
    with the Service repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – The Service repository ](img/Figure_10.6_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – The Service repository
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ServiceRepository` class contains methods for adding a service, deleting
    it and searching for a specific service, and more. Let’s pick a random method
    from the `GetActiveService` repository class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The method above uses Cosmos DB-specific code to access the database and returns
    a service by its ID.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the repository is implementing the `IServiceRepository` interface,
    which will become handy later during unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: There is plenty of repetition in how a repository interacts with a container.
    It stores a document, it reads a document, it deletes a document, it searches
    for a document, and so forth. So, we can create a small framework to embed these
    behaviors and reduce the repeated code.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing a repository pattern framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every time I’ve seen a project accessing a document DB, I notice that the developers
    create a small repository framework in advance to simplify the code. Here is an
    excerpt from a framework that I created to access Cosmos DB, the `CosmosRepository<T>`
    class, which is inherited by all repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code above provides the repository with the basic methods required to interact
    with the database, such as `AddItemAsync`.
  prefs: []
  type: TYPE_NORMAL
- en: Going into details about the specifics of Cosmos DB is beyond the scope of the
    book, but the code is easy to read and you can find the complete implementation
    in the `Uqs.AppointmentBooking.Domain/Repository` directory in the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created the repositories, for development purposes, we might
    need some test data to fill the pages with some meaningful data. We shall do this
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding seed data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Newly created DBs have empty containers, and the `seed` class is meant to pre-populate
    the tables with sample data.
  prefs: []
  type: TYPE_NORMAL
- en: I will not list the code here as it is outside the scope of the chapter, but
    you can look at the code in the `Domain` project in `Database/SeedData.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve just finished the setup for the `WebApi` project that is going to be consumed
    by the website, so let’s create the website next.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the website project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Phase I of this implementation includes creating a website to access the APIs
    to provide a UI for the user, which we did previously in this chapter by command
    line. However, website implementation is outside the scope of this chapter and
    the book, in general, as it is not related to TDD, so I will not be going through
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: Although, we are interested in one aspect – what does `Website` require from
    `WebApis`? We will need to understand this in order to build the required functionality
    in `WebApis` the TDD way.
  prefs: []
  type: TYPE_NORMAL
- en: We will answer this question bit by bit in the next section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we did the setup and configuration aspect of the project, and
    we have not done anything that is affected by TDD. You may have noticed that I
    referred you to the companion source code on multiple occasions, as I wanted to
    keep the focus on the next section while still providing you with the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the WebApis with TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build the WebApi project, we are going to look at each requirement from [*Chapter
    8*](B18370_08_RN.xhtml#_idTextAnchor209), *Designing an Appointment Booking App*,
    and provide the implementation that satisfies it using the TDD style.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements are all stated in terms of `Website` and its functionality,
    and they do not dictate how to build our APIs. `Website` will have to call `WebApis`
    for any business logic as it has no access to the DB and does UI-related business
    logic only.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will go through working in TDD mode, taking into consideration
    our persistence provider, the repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the first story
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first story in our requirement is very easy. The website is going to display
    all the available services that we have. Since the website will request this data
    from `WebApi` through a RESTful API call, the domain layer will have a service
    that will return this list. Let’s dig further if the website is to display this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – A UI of the requirements of Story 1 ](img/Figure_10.7_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – A UI of the requirements of Story 1
  prefs: []
  type: TYPE_NORMAL
- en: 'It will need to issue a RESTful call to the WebApi, which can look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This UI will require a few data properties that should be returned by this
    API. So, the fetched JSON can look like an array of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see where each part is used on the page, but maybe `ServiceId` is not
    very clear. It will be used to construct the URL of the *Select* hyperlink. So,
    we can now design the contract type that will render this JSON, which could look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This `record` contract will render the previous JSON code, and the full returned
    array contract could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can find these contract types and all the other contracts in the `Contract`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the first unit test via TDD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Thinking along the lines of DDD, we will have a domain service called `ServicesService`,
    which will handle retrieving all the available services. So, let’s have the structure
    of this service. We will create it in the `Domain` project under `Services`. Here
    is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing special here. I have just helped VS understand when I type
    `ServicesService`, it will guide me to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I have added the previous `ServicesService` class manually. Some TDD practitioners
    like to code-generate this file while they are writing their unit test rather
    than writing it first. Any method is fine as long as you are more productive.
    I chose to create the file first because sometimes VS creates this file in a different
    directory from where I intend to.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will create my unit tests class, which is called `ServicesServiceTests`,
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: I have added `IServiceRepository` immediately because I know that I am going
    to be dealing with the database in my unit tests and this interface is going to
    be my mocked dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I need to think of what I need from my service and build a unit test accordingly.
    The straightforward way to start is to pick the easiest scenario. If we have no
    barber service, then no service is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: I have decided in the test that there will be a method named `GetActiveServices`,
    and when this method is called, it will return a collection of active services.
    At this stage, the code doesn’t compile; as such, a method doesn’t exist. We have
    got our TDDs fail!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can instruct VS to generate this method, and then we can write the
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is getting, through the repository, all the available services, and since
    the repository is not mocked to return any service, an empty collection will return.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the test again, it will pass. This is our TDD test pass. There is
    no need for the refactor stage, as this is a simple implementation. Congratulations,
    you have finished your first test!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This test is simple, and it seems like a waste of time. However, this test is
    a valid test case, and it also helps us create our domain class and inject the
    right dependencies. Starting with a simple test helps to progress in steady steps.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the second unit test via TDD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second feature that we need to add is the ability to get active services.
    So, let’s start with this unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: What is interesting here is the way we are mocking the `GetActiveServices` repository
    method. The method is mocked to return an array of `Service` when the service
    calls it. This is how we have substituted the database for the relevant repository.
  prefs: []
  type: TYPE_NORMAL
- en: If you run this, it should pass from the first time without failure, so it is
    not going to fail then pass. It just happened to be this way. In this scenario,
    I would debug my code to see why the unit test passed without me implementing
    the code, and it is obvious the implementation code for the first unit test made
    was enough to cover the second scenario.
  prefs: []
  type: TYPE_NORMAL
- en: This was an easy requirement. In fact, all the stories are straightforward except
    story number 5\. We will not list the other stories here because they are similar,
    but you can find them in the companion source code. Instead, we will focus on
    story number 5 as its complexity matches a real-life production code and would
    reveal the main benefit of TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the fifth story (time management)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This story is about a time management system. It tries to manage the barbers’
    time fairly, taking rest time into consideration. If you take a moment to think
    about this story, it is a complex one with many edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: This story reveals the power of TDD as it will help you find a starting point
    and adds little incremental steps to build the requirement. When you finish, you
    will notice that you have automatically documented the story in the unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we will find a way to start with the easier-to-implement
    scenarios and climb up to more sophisticated test scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One gentle way to start our implementation that will make us think of the signature
    of the method is by checking the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Logically, to determine an employee’s availability, we need to know who this
    employee is by using `employeeId` and the length of the time required. The length
    can be acquired from the service by `serviceId`. A logical name for the method
    can be `GetAvailableSlotsForEmployee`. Our first unit test is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It doesn’t compile; it is a fail. Now create the method in `SlotsService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have the implementation in place, run the tests again, and they
    will pass. You can do the same for `employeeId` and follow what we did for `serviceId`.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the simplest scenario
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add the simplest possible business logic to start with. Let’s assume
    that the system has one employee called Tom. Tom has no shifts available in the
    system. Also, the system has one service only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can see how the repositories are being populated via mocking. This is how
    we set up our database and do the dependency injection. We were able to do this
    as `SlotsService` is accessing the database through the repositories and if the
    repositories are mocked, then we have replaced our database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the database with mocked repositories is a hot interview question
    that goes like *how do you clean the database after each unit test?*. This is
    a trick question, as you don’t interact with the database during the unit test
    and you mock your repositories instead. The question comes in multiple variations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will fail, as we have `null` returned by the method, whatever the input
    is. We need to continue adding bits of code to the solution. We can start with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is exactly what is required to pass the test. The test is
    green now.
  prefs: []
  type: TYPE_NORMAL
- en: Elevating the scenarios’ complexity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The rest of the unit tests follow the same way of elevating test scenario complexity
    slightly. Here are other scenarios you might want to add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous test is, in fact, multiple tests (because we are using `Theory`)
    with each `InlineData` elevating complexity. As usual, do the red then green to
    let it pass before adding another suite of tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is also a test with multiple `InlineData`. Obviously, we cannot fit all
    the code here, so please have a look in `SlotsServiceTests.cs` for the complete
    unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: As you start adding more test cases, whether by using `Theory` with `InlineData`
    or using `Fact`, you will notice that the code complexity in the implementation
    is going up. This is all right! Do you feel the readability is suffering? Then
    it is time to refactor.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have the advantage of unit tests protecting the code from being broken.
    Refactoring when the method is doing what you want it to do is part of the *Red-Green-Refactor*
    mantra. In fact, if you look at `SlotsService.cs`, I did refactor to improve readability
    by creating multiple private methods.
  prefs: []
  type: TYPE_NORMAL
- en: This story is complex, I will give you that. I could have picked an easier example,
    and everybody would be happy, but real-life code has ups and downs and varies
    in complexity, so I wanted to include one sophisticated scenario following the
    pragmatism theme of the book.
  prefs: []
  type: TYPE_NORMAL
- en: After this section, you might have some questions. I hope I am able to answer
    some of them below.
  prefs: []
  type: TYPE_NORMAL
- en: Answering frequently asked questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have written the unit tests and the associated implementation, let
    me explain the process.
  prefs: []
  type: TYPE_NORMAL
- en: Are these unit tests enough?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The answer to this question depends on your target coverage and your confidence
    that all cases are covered. Sometimes, adding more unit tests increases the future
    maintenance overhead, so with experience, you would strike the right balance.
  prefs: []
  type: TYPE_NORMAL
- en: Why didn’t we unit test the controllers?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The controllers should not contain business logic. We pushed all the logic to
    the services, then tested the services. What is left in the controllers is minimal
    code concerned with mapping different types to each other. Have a look at the
    controllers in `Uqs.AppointmentBooking.WebApi/Controllers` to see what I mean.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests excel in testing business logic or areas where there are conditions
    and branching. The controllers in the coding style that we chose do not have that.
  prefs: []
  type: TYPE_NORMAL
- en: The controllers should be tested but through a different type of test.
  prefs: []
  type: TYPE_NORMAL
- en: Why didn’t we unit test the repositories implementation?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The repositories contain specific code for Cosmos DB with minimal to no business
    logic. The code there is interacting with the SDK directly and testing it doesn’t
    prove anything, as you will be making assumptions (through test doubles) about
    the behavior of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes a repository contains a bit of business logic, such as `ServiceRepository`
    picking the active services only, rather than all services. It is still hard to
    test this logic as it is embedded in SQL-like syntax, which is hard to unit test.
  prefs: []
  type: TYPE_NORMAL
- en: On the contrary, testing your repositories expands your unit tests footprint
    in a negative way, which makes your code more brittle.
  prefs: []
  type: TYPE_NORMAL
- en: Some developers still unit test their repositories for code coverage purposes,
    but the mistake here is that code coverage is the combination of all types of
    tests and not just unit tests. Your repositories should be covered by a different
    type of test such as Sintegration testing.
  prefs: []
  type: TYPE_NORMAL
- en: Did we test the system enough?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No, we didn’t! We did the unit tests part. We have not tested the controllers
    or the boot of the system (the content of `Program.cs`) and other small bits of
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: We did not test them via unit tests, as they are not business logic. However,
    they need testing, but unit tests are not the best testing type to check for the
    quality of these areas. You can cover these by other types of testing such as
    integration, Sintegration, and system tests, as per our discussion in [*Chapter
    4*](B18370_04.xhtml#_idTextAnchor097), *Real Unit Testing with Test Doubles*.
  prefs: []
  type: TYPE_NORMAL
- en: We omitted testing some areas, how can we achieve high coverage?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some areas of the code are not unit tested, such as `Program.cs` and the controllers.
    If you are aiming for high code coverage, such as 90%, you might not achieve it
    via unit testing alone, as there is a good amount of code that went here.
  prefs: []
  type: TYPE_NORMAL
- en: Achieving coverage by unit tests alone is unfair, or the developers would start
    cheating by adding meaningless tests to boost coverage. These tests do more harm
    than good as they will create a maintenance overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Coverage calculation should include other types of tests, rather than relying
    on units alone. If this is the case, 90% is a realistic target and can lead to
    a high-quality product.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it is hard to configure a coverage meter tool to measure the sum of
    multiple test types, so in this case, it makes sense to lower your coding coverage
    target to maybe 80% or so. Because not all tests run locally, a local test coverage
    tool (such as *Fine Code Coverage*, which was discussed earlier, in [*Chapter
    6*](B18370_06.xhtml#_idTextAnchor140), *The FIRSTHAND Guidelines of TDD*), can
    only calculate the coverage for the locally executed tests.
  prefs: []
  type: TYPE_NORMAL
- en: So the short answer is your coverage should be made to include all your testing
    types, which takes some effort. Or you can reduce your coverage to unit test only
    and go for lower coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen implementing realistic stories by setting up the system with repositories
    and Cosmos DB, then building it a bit at a time by incrementally adding unit tests
    and increasing the complexity with every additional unit test.
  prefs: []
  type: TYPE_NORMAL
- en: We had to select multiple important scenarios to encourage you to examine the
    full source code. Otherwise, the pages will be filled with code.
  prefs: []
  type: TYPE_NORMAL
- en: If you have read and understood the code, then I assure you that this is the
    peak of the complexity, as other chapters should be easier to read and follow.
    So congratulations, you have made it through the hard part of this book! I trust
    you can now go ahead and start your TDD-based project with a document DB.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter ended with the implementation of a realistic project based on TDD.
    Hopefully, by understanding this part of the book, you are equipped to write your
    TDD-based project with a relational DB or a document DB.
  prefs: []
  type: TYPE_NORMAL
- en: The next part of the book goes about introducing unit tests to your project
    and organization, dealing with existing legacy code, and building a continuous
    integration system. I call that the fun part, where you take your TDD knowledge
    and expand it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Applying TDD to Your Projects'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how to build an application with TDD, we want to take the
    next step. In this part, we will cover how to combine unit testing with continuous
    integration, how to deal with legacy projects, and how to implement TDD in your
    organization. The following chapters are included in this part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18370_11.xhtml#_idTextAnchor265), *Implementing Continuous
    Integration with GitHub Actions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18370_12.xhtml#_idTextAnchor279), *Dealing with Brownfield
    Projects*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B18370_13_RN.xhtml#_idTextAnchor297), *The Intricacies of Rolling
    Out TDD*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
