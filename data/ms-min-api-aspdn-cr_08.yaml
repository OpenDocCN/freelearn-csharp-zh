- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Adding Authentication and Authorization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加身份验证和授权
- en: Any kind of application must deal with **authentication** and **authorization**.
    Often, these terms are used interchangeably, but they actually refer to different
    scenarios. In this chapter of the book, we will explain the difference between
    authentication and authorization and show how to add these features to a minimal
    API project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型的应用程序都必须处理**身份验证**和**授权**。通常，这些术语被交替使用，但实际上它们指的是不同的场景。在本章中，我们将解释身份验证和授权之间的区别，并展示如何将这些功能添加到最小化API项目中。
- en: 'Authentication can be performed in many different ways: using local accounts
    with external login providers, such as Microsoft, Google, Facebook, and Twitter;
    using Azure Active Directory and Azure B2C; and using authentication servers such
    as Identity Server and Okta. Moreover, we may have to deal with requirements such
    as two-factor authentication and refresh tokens. In this chapter, however, we
    will focus on the general aspects of authentication and authorization and see
    how to implement them in a minimal API project, in order to provide a general
    understanding of the topic. The information and samples that will be provided
    will show how to effectively work with authentication and authorization and how
    to customize their behaviors according to our requirements.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证可以通过多种方式执行：使用本地账户和外部登录提供者，如Microsoft、Google、Facebook和Twitter；使用Azure Active
    Directory和Azure B2C；以及使用身份验证服务器，如Identity Server和Okta。此外，我们可能还需要处理如双因素身份验证和刷新令牌等要求。然而，在本章中，我们将关注身份验证和授权的一般方面，并了解如何在最小化API项目中实现它们，以便提供一个对该主题的总体理解。提供的信息和示例将展示如何有效地处理身份验证和授权，以及如何根据我们的需求自定义它们的行为。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing authentication and authorization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍身份验证和授权
- en: Protecting a minimal API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护最小化API
- en: Handling authorization – roles and policies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理授权 - 角色和政策
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the examples in this chapter, you will need to create an ASP.NET Core
    6.0 Web API application. Refer to the *Technical requirements* section in [*Chapter
    2*](B17902_02.xhtml#_idTextAnchor023)*, Exploring Minimal APIs and Their Advantages*,
    for instructions on how to do so.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的示例，您需要创建一个ASP.NET Core 6.0 Web API应用程序。请参考[*第2章*](B17902_02.xhtml#_idTextAnchor023)*，探索最小化API及其优势*中的*技术要求*部分，了解如何创建应用程序的说明。
- en: 'If you’re using your console, shell, or Bash terminal to create the API, remember
    to change your working directory to the current chapter number: `Chapter08`.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用控制台、Shell或Bash终端创建API，请记住将工作目录更改为当前章节号：`Chapter08`。
- en: All the code samples in this chapter can be found in the GitHub repository for
    this book at [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter08](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter08).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码示例都可以在本书的GitHub仓库中找到，网址为[https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter08](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter08)。
- en: Introducing authentication and authorization
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍身份验证和授权
- en: As said at the beginning, the terms authentication and authorization are often
    used interchangeably, but they represent different security functions. Authentication
    is the process of verifying that users are who they say they are, while authorization
    is the task of granting an authenticated user permission to do something. So,
    authorization must always follow authentication.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如开头所述，术语身份验证和授权经常被交替使用，但它们代表不同的安全功能。身份验证是验证用户是否是他们所说的那人的过程，而授权是授予经过身份验证的用户执行某事的权限的任务。因此，授权必须始终跟在身份验证之后。
- en: 'Let’s think about the security in an airport: first, you show your ID to authenticate
    your identity; then, at the gate, you present the boarding pass to be authorized
    to board the flight and get access to the plane.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下机场的安全问题：首先，您需要出示身份证以验证您的身份；然后，在登机口，您需要出示登机牌以获得登机授权并进入飞机。
- en: Authentication and authorization in ASP.NET Core are handled by corresponding
    middleware and work in the same way in minimal APIs and controller-based projects.
    They allow the restriction of access to endpoints depending on user identity,
    roles, policies, and so on, as we’ll see in detail in the following sections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 中的身份验证和授权由相应的中间件处理，在最小化 API 和基于控制器的项目中工作方式相同。它们允许根据用户身份、角色、策略等限制对端点的访问，正如我们将在以下部分中详细了解的那样。
- en: You can find a great overview of ASP.NET Core authentication and authorization
    in the official documentation available at [https://docs.microsoft.com/aspnet/core/security/authentication](https://docs.microsoft.com/aspnet/core/security/authentication)
    and [https://docs.microsoft.com/aspnet/core/security/authorization](https://docs.microsoft.com/aspnet/core/security/authorization).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档中找到关于 ASP.NET Core 身份验证和授权的精彩概述，这些文档可在以下网址找到：[https://docs.microsoft.com/aspnet/core/security/authentication](https://docs.microsoft.com/aspnet/core/security/authentication)
    和 [https://docs.microsoft.com/aspnet/core/security/authorization](https://docs.microsoft.com/aspnet/core/security/authorization)。
- en: Protecting a minimal API
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护最小化 API
- en: Protecting a minimal API means correctly setting up authentication and authorization.
    There are many types of authentication solutions that are adopted in modern applications.
    In web applications, we typically use cookies, while when dealing with web APIs,
    we use methods such as an API key, basic authentication, and **JSON Web Token**
    (**JWT**). JWTs are the most commonly used, and in the rest of the chapter, we’ll
    focus on this solution.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 保护最小化 API 意味着正确设置身份验证和授权。现代应用程序中采用了许多类型的身份验证解决方案。在 Web 应用程序中，我们通常使用 cookies，而在处理
    Web API 时，我们使用 API 密钥、基本身份验证以及 **JSON Web Token**（**JWT**）等方法。JWT 是最常用的，在接下来的章节中，我们将重点介绍这个解决方案。
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A good starting point to understand what JWTs are and how they are used is available
    at [https://jwt.io/introduction](https://jwt.io/introduction).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 JWT 是什么以及如何使用的良好起点是 [https://jwt.io/introduction](https://jwt.io/introduction)。
- en: 'To enable authentication and authorization based on JWT, the first thing to
    do is to add the `Microsoft.AspNetCore.Authentication.JwtBearer` NuGet package
    to our project, using one of the following ways:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用基于 JWT 的身份验证和授权，首先需要将 `Microsoft.AspNetCore.Authentication.JwtBearer` NuGet
    包添加到我们的项目中，可以使用以下方法之一：
- en: '`Microsoft.AspNetCore.Authentication.JwtBearer` and click on **Install**.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore.Authentication.JwtBearer` 并点击 **安装**。'
- en: '**Option 2**: Open **Package Manager Console** if you’re inside Visual Studio
    2022, or open your console, shell, or Bash terminal, go to your project directory,
    and execute the following command:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项 2**：如果你在 Visual Studio 2022 中，请打开 **包管理器控制台**，或者打开你的控制台、shell 或 Bash 终端，转到你的项目目录，并执行以下命令：'
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we need to add authentication and authorization services to the service
    provider, so that they are available through dependency injection:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将身份验证和授权服务添加到服务提供程序中，以便它们可以通过依赖注入使用：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the minimum code that is necessary to add JWT authentication and authorization
    support to an ASP.NET Core project. It isn’t a real working solution yet, because
    it is missing the actual configuration, but it is enough to verify how endpoint
    protection works.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将 JWT 身份验证和授权支持添加到 ASP.NET Core 项目的最小代码。它还不是真正的解决方案，因为它缺少实际的配置，但它足以验证端点保护的工作方式。
- en: 'In the `AddAuthentication()` method, we specify that we want to use the `Authorization`
    HTTP header with the format `Authorization: Bearer <token>`. Then, we call `AddJwtBearer()`
    to tell ASP.NET Core that it must expect a bearer token in the JWT format. As
    we’ll see later, the bearer token is an encoded string generated by the server
    in response to a login request. After that, we use `AddAuthorization()` to also
    add authorization services.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `AddAuthentication()` 方法中，我们指定我们想要使用格式为 `Authorization: Bearer <token>` 的
    `Authorization` HTTP 标头。然后，我们调用 `AddJwtBearer()` 来告诉 ASP.NET Core 它必须期望一个 JWT
    格式的承载令牌。正如我们稍后将会看到的，承载令牌是服务器在响应登录请求时生成的编码字符串。之后，我们使用 `AddAuthorization()` 来添加授权服务。'
- en: 'Now, we need to insert authentication and authorization middleware in the pipeline
    so that ASP.NET Core will be instructed to check the token and apply all the authorization
    rules:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在管道中插入身份验证和授权中间件，以便 ASP.NET Core 将被指示检查令牌并应用所有授权规则：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Important Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We have said that authorization must follow authentication. This means that
    the authentication middleware must come first; otherwise, the security will not
    work as expected.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过，授权必须跟随认证。这意味着认证中间件必须首先执行；否则，安全机制将无法按预期工作。
- en: 'Finally, we can protect our endpoints using the `Authorize` attribute or the
    `RequireAuthorization()` method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`Authorize`属性或`RequireAuthorization()`方法来保护我们的端点：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The ability to specify an attribute directly on a lambda expression (as in the
    first endpoint of the previous example) is a new feature of C# 10.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例的第一个端点中，直接在lambda表达式中指定一个属性（如C# 10的新特性）。
- en: 'If we now try to call each of these methods using Swagger, we’ll get a `401
    unauthorized` response, which should look as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试使用Swagger调用这些方法中的每一个，我们将得到一个`401 unauthorized`响应，其外观应如下所示：
- en: '![Figure 8.1 – Unauthorized response in Swagger ](img/Figure_8.1_B17902.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – Swagger中的未授权响应](img/Figure_8.1_B17902.jpg)'
- en: Figure 8.1 – Unauthorized response in Swagger
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – Swagger中的未授权响应
- en: Note that the message contains a header indicating that the expected authentication
    scheme is `Bearer`, as we have declared in the code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，消息中包含一个标题，指示预期的认证方案是`Bearer`，正如我们在代码中所声明的。
- en: 'So, now we know how to restrict access to our endpoints to authenticated users.
    But our work isn’t finished: we need to generate a JWT bearer, validate it, and
    find a way to pass such a token to Swagger so that we can test our protected endpoints.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们知道了如何限制对端点的访问，只允许经过认证的用户。但我们的工作还没有完成：我们需要生成JWT载体，验证它，并找到一种方法将此类令牌传递给Swagger，以便我们可以测试受保护的端点。
- en: Generating a JWT bearer
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成JWT载体
- en: We have said that a JWT bearer is generated by the server as a response to a
    login request. ASP.NET Core provides all the APIs we need to create it, so let’s
    see how to perform this task.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过，JWT载体是由服务器在响应登录请求时生成的。ASP.NET Core提供了我们创建JWT载体的所有API，所以让我们看看如何执行这个任务。
- en: 'The first thing to do is to define the login request endpoint to authenticate
    the user with their username and password:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的事情是定义登录请求端点，使用用户名和密码来验证用户：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For the sake of simplicity, in the preceding example, we have used hardcoded
    values, but in a real application, we’d use, for example, **ASP.NET Core Identity**,
    the part of ASP.NET Core that is responsible for user management. More information
    on this topic is available in the official documentation at [https://docs.microsoft.com/aspnet/core/security/authentication/identity](https://docs.microsoft.com/aspnet/core/security/authentication/identity).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，在前面的示例中，我们使用了硬编码的值，但在实际应用中，我们会使用例如**ASP.NET Core Identity**，这是ASP.NET
    Core中负责用户管理的部分。有关此主题的更多信息，请参阅官方文档[https://docs.microsoft.com/aspnet/core/security/authentication/identity](https://docs.microsoft.com/aspnet/core/security/authentication/identity)。
- en: 'In a typical login workflow, if the credentials are invalid, we return a `400
    Bad Request` response to the client. If, instead, the username and password are
    correct, we can effectively generate a JWT bearer, using the classes available
    in ASP.NET Core:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的登录流程中，如果凭证无效，我们向客户端返回一个`400 Bad Request`响应。如果用户名和密码正确，我们可以使用ASP.NET Core中可用的类有效地生成JWT载体：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: JWT bearer creation involves many different concepts, but through the preceding
    code example, we’ll focus on the basic ones. This kind of bearer contains information
    that allows verifying the user identity, along with other declarations that describe
    the properties of the user. These properties are called **claims** and are expressed
    as string key-value pairs. In the preceding code, we created a list with a single
    claim that contains the username. We can add as many claims as we need, and we
    can also have claims with the same name. In the next sections, we’ll see how to
    use claims, for example, to enforce authorization.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: JWT载体的创建涉及许多不同的概念，但通过前面的代码示例，我们将关注基本概念。这种载体包含允许验证用户身份的信息，以及描述用户属性的其他声明。这些属性被称为**声明**，并以字符串键值对的形式表示。在前面的代码中，我们创建了一个包含用户名的单个声明的列表。我们可以添加我们需要的任何数量的声明，也可以有具有相同名称的声明。在下一节中，我们将看到如何使用声明，例如，来执行授权。
- en: Next in the preceding code, we defined the credentials (`SigningCredentials`)
    to sign the JWT bearer. The signature depends on the actual token content and
    is used to check that the token hasn’t been tampered with. In fact, if we change
    anything in the token, such as a claim value, the signature will consequentially
    change. As the key to sign the bearer is known only by the server, it is impossible
    for a third party to modify the token and sustain its validity. In the preceding
    code, we used `SymmetricSecurityKey`, which is never shared with clients.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，接下来我们定义了用于签名JWT承载的凭证（`SigningCredentials`）。签名取决于实际的令牌内容，并用于检查令牌是否被篡改。实际上，如果我们更改令牌中的任何内容，例如声明值，签名将相应地更改。由于承载签名的密钥只有服务器知道，第三方无法修改令牌并保持其有效性。在前面的代码中，我们使用了
    `SymmetricSecurityKey`，这个密钥永远不会与客户端共享。
- en: We used a short string to create the credentials, but the only requirement is
    that the key should be at least 32 bytes or 16 characters long. In .NET, strings
    are Unicode and therefore, each character takes 2 bytes. We also needed to set
    the algorithm that the credentials will use to sign the token. To this end, we
    have specified the `SecurityAlgorithms.HmacSha256` value. This algorithm is quite
    a common choice in these kinds of scenarios.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个简短的字符串来创建凭证，但唯一的要求是密钥至少为32字节或16个字符长。在.NET中，字符串是Unicode，因此每个字符占用2个字节。我们还需要设置凭证将用于签名令牌的算法。为此，我们指定了
    `SecurityAlgorithms.HmacSha256` 值。在这个场景中，这是一个相当常见的选项。
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information about the HMAC and the SHA256 hash function at
    [https://docs.microsoft.com/dotnet/api/system.security.cryptography.hmacsha256#remarks](https://docs.microsoft.com/dotnet/api/system.security.cryptography.hmacsha256#remarks).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://docs.microsoft.com/dotnet/api/system.security.cryptography.hmacsha256#remarks](https://docs.microsoft.com/dotnet/api/system.security.cryptography.hmacsha256#remarks)
    找到有关HMAC和SHA256哈希函数的更多信息。
- en: 'By this point in the preceding code, we finally have all the information to
    create the token, so we can instantiate a `JwtSecurityToken` object. This class
    can use many parameters to build the token, but for the sake of simplicity, we
    have specified only the minimum set for a working example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，在前面代码的这一部分，我们终于拥有了创建令牌所需的所有信息，因此我们可以实例化一个 `JwtSecurityToken` 对象。这个类可以使用许多参数来构建令牌，但为了简单起见，我们只为工作示例指定了最小集：
- en: '**Issuer**: A string (typically a URI) that identifies the name of the entity
    that is creating the token'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发行者**：一个字符串（通常是URI），用于标识创建令牌的实体的名称'
- en: '**Audience**: The recipient that the JWT is intended for, that is, who can
    consume the token'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受众**：JWT旨在接收的接收者，即谁可以消费令牌'
- en: The list of claims
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明的列表
- en: The expiration time of the token (in UTC)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令牌的过期时间（UTC时间）
- en: The signing credentials
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名凭证
- en: Tip
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: In the preceding code example, values used to build the token are hardcoded,
    but in a real-life application, we should place them in an external source, for
    example, in the `appsettings.json` configuration file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，用于构建令牌的值是硬编码的，但在实际应用中，我们应该将它们放置在外部源中，例如在 `appsettings.json` 配置文件中。
- en: You can find further information on creating a token at [https://docs.microsoft.com/dotnet/api/system.identitymodel.tokens.jwt.jwtsecuritytoken](https://docs.microsoft.com/dotnet/api/system.identitymodel.tokens.jwt.jwtsecuritytoken).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://docs.microsoft.com/dotnet/api/system.identitymodel.tokens.jwt.jwtsecuritytoken](https://docs.microsoft.com/dotnet/api/system.identitymodel.tokens.jwt.jwtsecuritytoken)
    找到有关创建令牌的更多信息。
- en: After all the preceding steps, we could create `JwtSecurityTokenHandler`, which
    is responsible for actually generating the bearer token and returning it to the
    caller with a `200 OK` response.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前面的步骤之后，我们可以创建 `JwtSecurityTokenHandler`，它负责实际生成承载令牌并将其以 `200 OK` 响应返回给调用者。
- en: 'So, now we can try the `login` endpoint in Swagger. After inserting the correct
    username and password and clicking the **Execute** button, we will get the following
    response:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们可以尝试Swagger中的 `login` 端点。在插入正确的用户名和密码并点击 **执行** 按钮后，我们将得到以下响应：
- en: '![Figure 8.2 – The JWT bearer as a result of the login request in Swagger ](img/Figure_8.2_B17902.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – Swagger中登录请求的结果JWT承载](img/Figure_8.2_B17902.jpg)'
- en: Figure 8.2 – The JWT bearer as a result of the login request in Swagger
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – Swagger中登录请求的结果JWT承载
- en: 'We can copy the token value and insert it in the URL of the site [https://jwt.ms](https://jwt.ms)
    to see what it contains. We’ll get something like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以复制令牌值并将其插入到网站的URL中 [https://jwt.ms](https://jwt.ms) 以查看其内容。我们会得到类似以下的内容：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In particular, we see the claims that have been configured:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们看到已经配置的声明：
- en: '`name`: The name of the logged user'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：登录用户的名称'
- en: '`exp`: The token expiration time, expressed in Unix epoch'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exp`：令牌过期时间，以 Unix 纪元表示'
- en: '`iss`: The issuer of the token'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iss`：令牌的发行者'
- en: '`aud`: The audience (receiver) of the token'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aud`：令牌的受众（接收者）'
- en: This is the raw view, but we can switch to the **Claims** tab to see the decoded
    list of all the claims, with a description of their meaning, where available.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是原始视图，但我们可以切换到 **Claims** 选项卡来查看所有声明的解码列表，以及它们的含义描述（如果有的话）。
- en: 'There is one important point that requires attention: by default, the JWT bearer
    isn’t encrypted (it’s just a Base64-encoded string), so everyone can read its
    content. Token security does not depend on the inability to be decoded, but on
    the fact that it is signed. Even if the token’s content is clear, it is impossible
    to modify it because in this case, the signature (which uses a key that is known
    only by the server) will become invalid.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的问题需要注意：默认情况下，JWT 持证人未加密（它只是一个 Base64 编码的字符串），因此任何人都可以读取其内容。令牌的安全性不取决于无法解码，而在于它是经过签名的。即使令牌的内容是透明的，也无法修改它，因为在这种情况下，签名（使用只有服务器才知道的密钥）将变得无效。
- en: So, it’s important not to insert sensitive data in the token; claims such as
    usernames, user IDs, and roles are usually fine, but, for example, we should not
    insert information related to privacy. To give a deliberately exaggerated example,
    we mustn’t insert a credit card number in the token! In any case, keep in mind
    that even Microsoft for Azure Active Directory uses JWT, with no encryption, so
    we can trust this security system.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不要在令牌中插入敏感数据是很重要的；例如，用户名、用户 ID 和角色这样的声明通常是安全的，但例如，我们不应插入与隐私相关的信息。为了给出一个故意夸张的例子，我们绝对不能在令牌中插入信用卡号码！在任何情况下，请记住，即使是微软的
    Azure Active Directory 也使用 JWT，没有加密，因此我们可以信任这个安全系统。
- en: In conclusion, we have described how to obtain a valid JWT. The next steps are
    to pass the token to our protected endpoints and instruct our minimal API on how
    to validate it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们已经描述了如何获取有效的 JWT。下一步是将令牌传递到我们的受保护端点，并指导我们的最小 API 如何验证它。
- en: Validating a JWT bearer
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证 JWT 持证人
- en: 'After creating the JWT bearer, we need to pass it in every HTTP request, inside
    the `Authorization` HTTP header, so that ASP.NET Core can verify its validity
    and allow us to invoke the protected endpoints. So, we have to complete the `AddJwtBearer()`
    method invocation that we showed earlier with the description of the rules to
    validate the bearer:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 JWT 持证人之后，我们需要在每次 HTTP 请求中将其传递，在 `Authorization` HTTP 标头内部，以便 ASP.NET Core
    可以验证其有效性并允许我们调用受保护的端点。因此，我们必须完成之前展示的 `AddJwtBearer()` 方法调用，并描述验证持证人的规则：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we added a lambda expression with which we defined the
    `TokenValidationParameter` object that contains the token validation rules. First
    of all, we checked the issuer signing key, that is, the signature of the token,
    as shown in the *Generating a JWT bearer* section, to verify that the JWT has
    not been tampered with. The security string that has been used to sign the token
    is required to perform this check, so we specify the same value (`mysecuritystring`)
    that we inserted during the login request.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一个 lambda 表达式，用它定义了包含令牌验证规则的 `TokenValidationParameter` 对象。首先，我们检查了发行者签名密钥，即令牌的签名，如
    *生成 JWT 持证人* 部分所示，以验证 JWT 是否被篡改。用于签名的安全字符串是执行此检查所必需的，因此我们指定了与登录请求期间插入的相同的值（`mysecuritystring`）。
- en: Then, we specify what valid values for the issuer and the audience of the token
    are. If the token has been emitted from a different issuer, or was intended for
    another audience, the validation fails. This is an important security check; we
    should be sure that the bearer has been issued by someone we expected to issue
    it and for the audience we want.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们指定令牌发行者和受众的有效值。如果令牌是由不同的发行者发出的，或者是为另一个受众准备的，验证将失败。这是一个重要的安全检查；我们应该确保持证人是由我们期望发行它的人发行的，并且是为我们想要的受众。
- en: Tip
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: As already pointed out, we should place the information used to work with the
    token in an external source, so that we can reference the correct values during
    token generation and validation, avoiding hardcoding them or writing their values
    twice.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如已经指出的，我们应该将用于处理令牌的信息放置在外部源中，这样我们就可以在令牌生成和验证期间引用正确的值，避免硬编码它们或重复写入它们的值。
- en: We don’t need to specify that we also want to validate the token expiration
    because this check is automatically enabled. A clock skew is applied when validating
    the time to compensate for slight differences in clock time or to handle delays
    between the client request and the instant at which it is processed by the server.
    The default value is 5 minutes, which means that an expired token is considered
    valid for a 5-minute timeframe after its actual expiration. We can reduce the
    clock skew, or disable it, using the `ClockSkew` property of the `TokenValidationParameter`
    class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要指定我们还想验证令牌过期，因为这个检查是自动启用的。在验证时间时应用时钟偏移，以补偿时钟时间的微小差异或处理客户端请求与服务器处理该请求的瞬间之间的延迟。默认值是5分钟，这意味着过期令牌在其实际过期后的5分钟时间内被视为有效。我们可以通过使用`TokenValidationParameter`类的`ClockSkew`属性来减少时钟偏移，或禁用它。
- en: Now, the minimal API has all the information to check the bearer token validity.
    In order to test whether everything works as expected, we need a way to tell Swagger
    how to send the token within a request, as we’ll see in the next section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最小化的API已经包含了检查携带令牌有效性的所有信息。为了测试是否一切按预期工作，我们需要一种方法告诉Swagger如何在请求中发送令牌，正如我们将在下一节中看到的。
- en: Adding JWT support to Swagger
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将JWT支持添加到Swagger
- en: We have said that the bearer token is sent in the `Authorization` HTTP header
    of a request. If we want to use Swagger to verify the authentication system and
    test our protected endpoints, we need to update the configuration so that it will
    be able to include this header in the requests.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过，携带令牌被发送在请求的`Authorization` HTTP头部中。如果我们想使用Swagger验证认证系统并测试我们的受保护端点，我们需要更新配置，使其能够将此头部包含在请求中。
- en: 'To perform this task, it is necessary to add a bit of code to the `AddSwaggerGen()`
    method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此任务，需要在`AddSwaggerGen()`方法中添加一些代码：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we defined how Swagger handles authentication. Using
    the `AddSecurityDefinition()` method, we described how our API is protected; we
    used an API key, which is the bearer token, in the header with the name `Authorization`.
    Then, with `AddSecurityRequirement()`, we specified that we have a security requirement
    for our endpoints, which means that the security information must be sent for
    every request.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了Swagger如何处理认证。使用`AddSecurityDefinition()`方法，我们描述了我们的API是如何受到保护的；我们使用了一个API密钥，即携带令牌，在名为`Authorization`的头部中。然后，通过`AddSecurityRequirement()`，我们指定了我们端点有一个安全要求，这意味着必须为每个请求发送安全信息。
- en: After adding the preceding code, if we now run our application, the Swagger
    UI will contain something new.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了前面的代码之后，如果我们现在运行我们的应用程序，Swagger UI 将包含一些新的内容。
- en: '![Figure 8.3 – Swagger showing the authentication features ](img/Figure_8.3_B17902.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – Swagger显示的认证功能](img/Figure_8.3_B17902.jpg)'
- en: Figure 8.3 – Swagger showing the authentication features
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – Swagger显示的认证功能
- en: 'Upon clicking the **Authorize** button or any of the padlock icons at the right
    of the endpoints, the following window will show up, allowing us to insert the
    bearer token:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**授权**按钮或端点右侧的任何锁形图标时，将显示以下窗口，允许我们插入携带令牌：
- en: '![Figure 8.4 – The window that allows setting the bearer token ](img/Figure_8.4_B17902.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 允许设置携带令牌的窗口](img/Figure_8.4_B17902.jpg)'
- en: Figure 8.4 – The window that allows setting the bearer token
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 允许设置携带令牌的窗口
- en: The last thing to do is to insert the token in the **Value** textbox and confirm
    by clicking on **Authorize**. From now on, the specified bearer will be sent along
    with every request made with Swagger.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的事情是将令牌插入到**值**文本框中，并通过点击**授权**来确认。从现在起，指定的携带者将随Swagger发出的每个请求一起发送。
- en: We have finally completed all the required steps to add authentication support
    to minimal APIs. Now, it’s time to verify that everything works as expected. In
    the next section, we’ll perform some tests.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于完成了添加到最小API的认证支持所需的所有步骤。现在，是时候验证一切是否按预期工作了。在下一节中，我们将进行一些测试。
- en: Testing authentication
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试认证
- en: As described in the previous sections, if we call one of the protected endpoints,
    we get a `401 Unauthorized` response. To verify that token authentication works,
    let’s call the `login` endpoint to get a token. After that, click on the `Bearer<space>`
    prefix. Now, we’ll get a `200 OK` response, meaning that we are able to correctly
    invoke the endpoints that require authentication. We can also try changing a single
    character in the token to again get the `401 Unauthorized` response, because in
    this case, the signature will not be the expected one, as described before. In
    the same way, if the token is formally valid but has expired, we will obtain a
    `401` response.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节所述，如果我们调用受保护的端点之一，我们会得到一个`401 未授权`响应。为了验证令牌认证是否工作，让我们调用`login`端点以获取令牌。之后，点击`Bearer<空格>`前缀。现在，我们将得到一个`200
    OK`响应，这意味着我们能够正确调用需要认证的端点。我们还可以尝试更改令牌中的一个字符，再次得到`401 未授权`响应，因为在这种情况下，签名将不会是预期的，如之前所述。同样，如果令牌形式上有效但已过期，我们也会得到一个`401`响应。
- en: 'As we have defined endpoints that can be reached only by authenticated users,
    a common requirement is to access user information within the corresponding route
    handlers. In [*Chapter 2*](B17902_02.xhtml#_idTextAnchor023), *Exploring Minimal
    APIs and Their Advantages*, we showed that minimal APIs provide a special binding
    that directly provides a `ClaimsPrincipal` object representing the logged user:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面定义了只能由认证用户访问的端点，一个常见的需求是在相应的路由处理程序中访问用户信息。在[*第2章*](B17902_02.xhtml#_idTextAnchor023)，*探索Minimal
    APIs及其优势*中，我们展示了Minimal APIs提供了一个特殊的绑定，该绑定直接提供了一个表示已登录用户的`ClaimsPrincipal`对象：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `user` parameter of the route handler is automatically filled with user
    information. In this example, we just get the name, which in turn is read from
    the token claims, but the object exposes many properties that allow us to work
    with authentication data. We can refer to the official documentation at [https://docs.microsoft.com/dotnet/api/system.security.claims.claimsprincipal.identity](https://docs.microsoft.com/dotnet/api/system.security.claims.claimsprincipal.identity)
    for further details.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 路由处理程序的`user`参数会自动填充用户信息。在这个例子中，我们只获取名称，该名称反过来是从令牌声明中读取的，但该对象公开了许多属性，使我们能够处理认证数据。我们可以参考[https://docs.microsoft.com/dotnet/api/system.security.claims.claimsprincipal.identity](https://docs.microsoft.com/dotnet/api/system.security.claims.claimsprincipal.identity)的官方文档以获取更多详细信息。
- en: This ends our overview of authentication. In the next section, we’ll see how
    to handle authorization.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对认证的概述。在下一节中，我们将看到如何处理授权。
- en: Handling authorization – roles and policies
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理授权 - 角色和政策
- en: Right after the authentication, there is the authorization step, which grants
    an authenticated user permission to do something. Minimal APIs provide the same
    authorization features as controller-based projects, based on the concepts of
    **roles** and **policies**.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在认证之后，紧接着是授权步骤，它授予认证用户执行某些操作的权限。Minimal APIs提供了与基于控制器的项目相同的授权功能，基于**角色**和**策略**的概念。
- en: 'When an identity is created, it may belong to one or more roles. For example,
    a user can belong to the `Administrator` role, while another can be part of two
    roles: `User` and `Stakeholder`. Typically, each user can perform only the operations
    that are allowed by their roles. Roles are just claims that are inserted in the
    JWT bearer upon authentication. As we’ll see in a moment, ASP.NET Core provides
    built-in support to verify whether a user belongs to a role.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个身份时，它可能属于一个或多个角色。例如，一个用户可以属于`管理员`角色，而另一个用户可以是两个角色：`用户`和`利益相关者`。通常，每个用户只能执行其角色允许的操作。角色只是在认证时插入到JWT载体中的声明。正如我们稍后将看到的，ASP.NET
    Core提供了内置支持来验证用户是否属于某个角色。
- en: While role-based authorization covers many scenarios, there are cases in which
    this kind of security isn’t enough because we need to apply more specific rules
    to check whether the user has the right to perform some activities. In such a
    situation, we can create custom policies that allow us to specify more detailed
    authorization requirements and even completely define the authorization logic
    based on our algorithms.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基于角色的授权覆盖了许多场景，但有些情况下这种安全措施是不够的，因为我们需要应用更具体的规则来检查用户是否有权执行某些活动。在这种情况下，我们可以创建自定义策略，使我们能够指定更详细的授权要求，甚至可以根据我们的算法完全定义授权逻辑。
- en: In the next sections, we’ll see how to manage both role-based and policy-based
    authorization in our APIs, so that we can cover all our requirements, that is,
    allowing access to certain endpoints only to users with specific roles or claims,
    or based on our custom logic.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到如何在我们的 API 中管理基于角色和基于策略的授权，以便我们可以覆盖所有要求，即仅允许具有特定角色或声明的用户或基于我们自定义逻辑的用户访问某些端点。
- en: Handling role-based authorization
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理基于角色的授权
- en: 'As already introduced, roles are claims. This means that they must be inserted
    in the JWT bearer token upon authentication, just like any other claims:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如已介绍，角色是声明。这意味着它们必须在认证时插入到 JWT 携带者令牌中，就像任何其他声明一样：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this example, we statically add two claims with name `ClaimTypes.Role`:
    `Administrator` and `User`. As said in the previous sections, in a real-world
    application, these values typically come from a complete user management system
    built, for example, with ASP.NET Core Identity.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们静态地添加了两个名为 `ClaimTypes.Role` 的声明：`Administrator` 和 `User`。正如前几节所述，在现实世界的应用中，这些值通常来自一个完整的用户管理系统，例如使用
    ASP.NET Core Identity 构建的系统。
- en: 'As in all the other claims, roles are inserted in the JWT bearer. If now we
    try to invoke the `login` endpoint, we’ll notice that the token is longer because
    it contains a lot of information, which we can verify using the [https://jwt.ms](https://jwt.ms)
    site again, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所有其他声明一样，角色被插入到 JWT 携带者中。如果我们现在尝试调用 `login` 端点，我们会注意到令牌变长了，因为它包含了很多信息，我们可以再次使用
    [https://jwt.ms](https://jwt.ms) 网站来验证这些信息，如下所示：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In order to restrict access to a particular endpoint only for users that belong
    to a given role, we need to specify this role as an argument in the `Authorize`
    attribute or the `RequireAuthorization()` method:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了仅允许属于特定角色的用户访问特定端点，我们需要在 `Authorize` 属性或 `RequireAuthorization()` 方法中将此角色指定为参数：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this way, only users who are assigned the `Administrator` role can access
    the endpoints. We can also specify more roles, separating them with a comma: the
    user will be authorized if they have at least one of the specified roles.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，只有被分配了 `Administrator` 角色的用户才能访问端点。我们还可以指定更多角色，用逗号分隔它们：如果用户至少有一个指定的角色，则他们将获得授权。
- en: Important Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Role names are case sensitive.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 角色名称是区分大小写的。
- en: 'Now suppose we have the following endpoint:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们有以下端点：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This method can only be consumed by a user who is assigned the `Stakeholder`
    role. However, in our example, this role isn’t assigned. So, if we use the previous
    bearer token and try to invoke this endpoint, of course, we’ll get an error. But
    in this case, it won’t be `401 Unauthorized`, but rather `403 Forbidden`. We see
    this behavior because the user is actually authenticated (meaning the token is
    valid, so no `401` error), but they don’t have the authorization to execute the
    method, so access is forbidden. In other words, authentication errors and authorization
    errors lead to different HTTP status codes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法只能由分配了 `Stakeholder` 角色的用户消费。然而，在我们的例子中，这个角色没有被分配。因此，如果我们使用之前的携带令牌并尝试调用此端点，当然我们会得到一个错误。但在这个情况下，它不会是
    `401 未授权`，而是 `403 禁止访问`。我们观察到这种行为是因为用户实际上是经过认证的（这意味着令牌是有效的，因此没有 `401` 错误），但他们没有执行方法的授权，因此访问被禁止。换句话说，认证错误和授权错误会导致不同的
    HTTP 状态码。
- en: 'There is another important scenario that involves roles. Sometimes, we don’t
    need to restrict endpoint access at all but need to adapt the behavior of the
    handler according to the specific user role, such as when retrieving only a certain
    type of information. In this case, we can use the `IsInRole()` method, which is
    available on the `ClaimsPrincipal` object:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的场景涉及到角色。有时，我们根本不需要限制端点的访问，但需要根据特定的用户角色调整处理器的行为，例如在检索特定类型的信息时。在这种情况下，我们可以使用
    `IsInRole()` 方法，该方法在 `ClaimsPrincipal` 对象上可用：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this endpoint, we only use the `Authorize` attribute to check whether the
    user is authenticated or not. Then, in the route handler, we check whether the
    user has the `Administrator` role. If yes, we just return a message, but we can
    imagine that administrators can retrieve all the available information, while
    normal users get only a subset, based on the values of the information itself.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在此端点中，我们只使用 `Authorize` 属性来检查用户是否经过认证。然后，在路由处理器中，我们检查用户是否有 `Administrator` 角色。如果有，我们只返回一条消息，但我们可以想象管理员可以检索所有可用的信息，而普通用户只能根据信息的值获取子集。
- en: As we have seen, with role-based authorization, we can perform different types
    of authorization checks in our endpoints, to cover many scenarios. However, this
    approach cannot handle all situations. If roles aren’t enough, we need to use
    authorization based on policies, which we will discuss in the next section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，通过基于角色的授权，我们可以在端点中执行不同类型的授权检查，以覆盖许多场景。然而，这种方法并不能处理所有情况。如果角色不足以满足需求，我们需要使用基于策略的授权，我们将在下一节中讨论。
- en: Applying policy-based authorization
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用基于策略的授权
- en: Policies are a more general way to define authorization rules. Role-based authorization
    can be considered a specific policy authorization that involves a roles check.
    We typically use policies when we need to handle more complex scenarios.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是定义授权规则的一种更通用的方式。基于角色的授权可以被视为涉及角色检查的特定策略授权。我们通常在需要处理更复杂场景时使用策略。
- en: 'This kind of authorization requires two steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种授权需要两个步骤：
- en: Defining a policy with a rule set
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义包含规则集的策略
- en: Applying a certain policy on the endpoints
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在端点上应用特定策略
- en: Policies are added in the context of the `AddAuthorization()` method, which
    we saw in the previous section, *Protecting a minimal API*. Each policy has a
    unique name, which is used to later reference it, and a set of rules, which are
    typically described in a fluent manner.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是在上一节中提到的`AddAuthorization()`方法上下文中添加的，即保护最小API。每个策略都有一个唯一的名称，用于稍后引用，以及一组规则，这些规则通常以流畅的方式描述。
- en: 'We can use policies when role authorization is not enough. Suppose that the
    bearer token also contains the ID of the tenant to which the user belongs:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当角色授权不足以满足需求时，我们可以使用策略。假设携带令牌的用户所属的租户ID也包含在内：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Again, in a real-world scenario, this value could come from a database that
    stores the properties of the user. Suppose that we want to only allow users who
    belong to a particular tenant to reach an endpoint. As `tenant-id` is a custom
    claim, ASP.NET Core doesn’t know how to use it to enforce authorization. So, we
    can’t use the solutions shown earlier. We need to define a custom policy with
    the corresponding rule:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在现实世界的场景中，这个值可能来自存储用户属性的数据库。假设我们只想允许属于特定租户的用户访问端点。由于`tenant-id`是一个自定义声明，ASP.NET
    Core不知道如何使用它来执行授权。因此，我们无法使用之前展示的解决方案。我们需要定义一个包含相应规则的定制策略：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we created a policy named `Tenant42`, which requires
    that the token contains the `tenant-id` claim with the value `42`. The `policy`
    variable is an instance of `AuthorizationPolicyBuilder` and exposes methods that
    allow us to fluently specify the authorization rules; we can specify that a policy
    requires certain users, roles, and claims to be satisfied. We can also chain multiple
    requirements in the same policy, writing, for example, something such as `policy.RequireRole(“Administrator”).RequireClaim(“tenant-id”)`.
    The full list of methods is available on the documentation page at [https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.authorization.authorizationpolicybuilder](https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.authorization.authorizationpolicybuilder).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为`Tenant42`的策略，该策略要求令牌包含值为`42`的`tenant-id`声明。`policy`变量是`AuthorizationPolicyBuilder`的一个实例，它公开了允许我们流畅地指定授权规则的方法；我们可以指定策略需要满足某些用户、角色和声明。我们还可以在同一个策略中链式添加多个要求，例如，可以编写`policy.RequireRole("Administrator").RequireClaim("tenant-id")`这样的代码。完整的方法列表可以在文档页面[https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.authorization.authorizationpolicybuilder](https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.authorization.authorizationpolicybuilder)上找到。
- en: 'Then, in the method we want to protect, we have to specify the policy name,
    as usual with the `Authorize` attribute or the `RequireAuthorization()` method:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们要保护的函数中，我们必须指定策略名称，就像通常使用`Authorize`属性或`RequireAuthorization()`方法一样：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we try to execute these preceding endpoints with a token that doesn’t have
    the `tenant-id` claim, or its value isn’t `42`, we get a `403 Forbidden` result,
    as happened with the role check.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用没有`tenant-id`声明或其值不是`42`的令牌执行这些前面的端点，我们将得到一个`403 Forbidden`的结果，就像角色检查发生时一样。
- en: 'There are scenarios in which declaring a list of allowed roles and claims isn’t
    enough: for example, we would need to perform more complex checks or verify authorization
    based on dynamic parameters. In these cases, we can use the so-called **policy
    requirements**, which comprise a collection of authorization rules for which we
    can provide custom verification logic.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些场景，仅仅声明允许的角色和声明是不够的：例如，我们需要执行更复杂的检查或根据动态参数验证授权。在这些情况下，我们可以使用所谓的**策略要求**，它包含一组授权规则，我们可以为这些规则提供自定义验证逻辑。
- en: 'To adopt this solution, we need two objects:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了采用这种解决方案，我们需要两个对象：
- en: A *requirement class* that implements the `IAuthorizationRequirement` interface
    and defines the requirement we want to manage
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个实现`IAuthorizationRequirement`接口并定义我们想要管理的需求的*要求类*
- en: A *handler class* that inherits from `AuthorizationHandler` and contains the
    logic to verify the requirement
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个继承自`AuthorizationHandler`并包含验证要求逻辑的*处理器类*
- en: Let’s suppose we don’t want users who don’t belong to the `Administrator` role
    to access certain endpoints during a maintenance time window. This is a perfectly
    valid authorization rule, but we cannot afford it using the solutions we have
    seen up to now. The rule involves a condition that considers the current time,
    so the policy cannot be statically defined.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们不想让不属于`Administrator`角色的用户在维护时间窗口期间访问某些端点。这是一个完全有效的授权规则，但我们不能使用我们迄今为止看到的解决方案来实现它。该规则涉及一个考虑当前时间的条件，因此策略不能静态定义。
- en: 'So, we start by creating a custom requirement:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先创建一个自定义要求：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The requirement contains the start and end times of the maintenance window.
    During this interval, we only want administrators to be able to operate.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要求包含维护窗口的开始和结束时间。在此期间，我们只希望管理员能够操作。
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`TimeOnly` is a new data type that has been introduced with C# 10 and allows
    us to store only only the time of the day (and not the date). More information
    is available at [https://docs.microsoft.com/dotnet/api/system.timeonly](https://docs.microsoft.com/dotnet/api/system.timeonly).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeOnly`是C# 10中引入的新数据类型，它允许我们只存储一天中的时间（而不是日期）。更多信息请参阅[https://docs.microsoft.com/dotnet/api/system.timeonly](https://docs.microsoft.com/dotnet/api/system.timeonly)。'
- en: Note that the `IAuthorizationRequirement` interface is just a placeholder. It
    doesn’t contain any method or property to be implemented; it serves only to identify
    that the class is a requirement. In other words, if we don’t need any additional
    information for the requirement, we can create a class that implements `IAuthorizationRequirement`
    but actually has no content at all.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`IAuthorizationRequirement`接口只是一个占位符。它不包含任何需要实现的方法或属性；它仅用于标识该类是一个要求。换句话说，如果我们不需要任何额外的信息来满足要求，我们可以创建一个实现`IAuthorizationRequirement`但没有内容的类。
- en: 'This requirement must be enforced, so it is necessary to create the corresponding
    handler:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个要求必须得到强制执行，因此有必要创建相应的处理器：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our handler inherits from `AuthorizationHandler<MaintenanceTimeRequirement>`,
    so we need to override the `HandleRequirementAsync()` method to verify the requirement,
    using the `AuthorizationHandlerContext` parameter, which contains a reference
    to the current user. As said at the beginning, if the user is not assigned the
    `Administrator` role, we check whether the current time falls in the maintenance
    window. If so, the user doesn’t have the right to access.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的处理器继承自`AuthorizationHandler<MaintenanceTimeRequirement>`，因此我们需要重写`HandleRequirementAsync()`方法来验证要求，使用`AuthorizationHandlerContext`参数，它包含对当前用户的引用。正如一开始所说的，如果用户没有被分配`Administrator`角色，我们检查当前时间是否在维护窗口内。如果是这样，用户没有访问权限。
- en: At the end, if the `isAuthorized` variable is `true`, it means that the authorization
    can be granted, so we call the `Succeed()` method on the `context` object, passing
    the requirement that we want to validate. Otherwise, we don’t invoke any method
    on the context, meaning that the requirement hasn’t been verified.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果`isAuthorized`变量为`true`，则表示授权可以被授予，因此我们在`context`对象上调用`Succeed()`方法，并传递我们想要验证的要求。否则，我们不在上下文中调用任何方法，这意味着要求尚未被验证。
- en: 'We haven’t yet finished implementing the custom policy. We still have to define
    the policy and register the handler in the service provider:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成自定义策略的实现。我们仍然需要定义策略并在服务提供程序中注册处理器：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, we defined a maintenance time window from midnight till
    4:00 in the morning. Then, we registered the handler as an implementation of the
    `IAuthorizationHandler` interface, which in turn is implemented by the `AuthorizationHandler`
    class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个从午夜到早上4:00的维护时间窗口。然后，我们将处理器注册为`IAuthorizationHandler`接口的实现，该接口反过来由`AuthorizationHandler`类实现。
- en: 'Now that we have everything in place, we can apply the policy to our endpoints:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了所有东西，我们可以将策略应用到我们的端点：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When we try to reach this endpoint, ASP.NET Core will check the corresponding
    policy, find that it contains a requirement, and scan all the registrations of
    the `IAuhorizationHandler` interface to see whether there is one that is able
    to handle the requirement. Then, the handler will be invoked, and the result will
    be used to determine whether the user has the right to access the route. If the
    policy isn’t verified, we’ll get a `403 Forbidden` response.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试访问此端点时，ASP.NET Core将检查相应的策略，发现其中包含一个要求，并扫描所有`IAuhorizationHandler`接口的注册，以查看是否存在能够处理该要求的处理器。然后，将调用处理器，并使用结果来确定用户是否有权访问路由。如果策略未经验证，我们将得到一个`403
    Forbidden`响应。
- en: We have shown how powerful policies are, but there is more. We can also use
    them to define global rules that are automatically applied to all endpoints, using
    the concepts of default and fallback policies, as we’ll see in the next section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了策略是多么强大，但还有更多。我们还可以使用它们来定义应用于所有端点的全局规则，使用默认和回退策略的概念，正如我们将在下一节中看到的。
- en: Using default and fallback policies
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用默认和回退策略
- en: Default and fallback policies are useful when we want to define global rules
    that must be automatically applied. In fact, when we use the `Authorize` attribute
    or the `RequireAuthorization()` method, without any other parameter, we implicitly
    refer to the default policy defined by ASP.NET Core, which is set to require an
    authenticated user.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要定义必须自动应用的全局规则时，默认和回退策略是有用的。实际上，当我们使用`Authorize`属性或`RequireAuthorization()`方法，并且没有其他参数时，我们隐式地引用ASP.NET
    Core定义的默认策略，该策略设置为需要认证用户。
- en: 'If we want to use different conditions by default, we just need to redefine
    the `DefaultPolicy` property, which is available in the context of the `AddAuthorization()`
    method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用默认的不同条件，我们只需重新定义`DefaultPolicy`属性，该属性在`AddAuthorization()`方法的上下文中可用：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We use `AuthorizationPolicyBuilder` to define all the security requirements,
    then we set it as a default policy. In this way, even if we don’t specify a custom
    policy in the `Authorize` attribute or the `RequireAuthorization()` method, the
    system will always verify whether the user is authenticated, and the bearer contains
    the `tenant-id` claim. Of course, we can override this default behavior by just
    specifying roles or policy names in the authorization attribute or method.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`AuthorizationPolicyBuilder`来定义所有安全要求，然后将其设置为默认策略。这样，即使我们没有在`Authorize`属性或`RequireAuthorization()`方法中指定自定义策略，系统也会始终验证用户是否已认证，以及携带者是否包含`tenant-id`声明。当然，我们只需在授权属性或方法中指定角色或策略名称即可覆盖此默认行为。
- en: 'A fallback policy, on the other hand, is the policy that is applied when there
    is no authorization information on the endpoints. It is useful, for example, when
    we want all our endpoints to be automatically protected, even if we forget to
    specify the `Authorize` attribute or just don’t want to repeat the attribute for
    each handler. Let us try and understand this using the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，回退策略是在端点没有授权信息时应用的策略。例如，当我们希望所有端点自动受到保护，即使我们忘记指定`Authorize`属性或者不想为每个处理器重复属性时，它是有用的。让我们通过以下代码来尝试理解这一点：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, `FallbackPolicy` becomes equal to `DefaultPolicy`. We
    have said that the default policy requires that the user be authenticated, so
    the result of this code is that now, all the endpoints automatically need authentication,
    even if we don’t explicitly protect them.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`FallbackPolicy`等于`DefaultPolicy`。我们说过默认策略要求用户必须认证，所以这段代码的结果是现在，所有端点自动需要认证，即使我们没有明确保护它们。
- en: This is a typical solution to adopt when most of our endpoints have restricted
    access. We don’t need to specify the `Authorize` attribute or use the `RequireAuthorization()`
    method anymore. In other words, now all our endpoints are protected by default.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在我们的大多数端点都有受限访问时采用的一种典型解决方案。我们不再需要指定`Authorize`属性或使用`RequireAuthorization()`方法。换句话说，现在所有我们的端点都默认受到保护。
- en: 'If we decide to use this approach, but a bunch of endpoints need public access,
    such as the `login` endpoint, which everyone should be able to invoke, we can
    use the `AllowAnonymous` attribute or the `AllowAnonymous()` method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定使用这种方法，但有一堆端点需要公开访问，例如`login`端点，每个人都应该能够调用，我们可以使用`AllowAnonymous`属性或`AllowAnonymous()`方法：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As the name implies, the preceding code will bypass all authorization checks
    for the endpoint, including the default and fallback authorization policies.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，前面的代码将绕过端点的所有授权检查，包括默认和回退授权策略。
- en: To deepen our knowledge of policy-based authentication, we can refer to the
    official documentation at [https://docs.microsoft.com/aspnet/core/security/authorization/policies](https://docs.microsoft.com/aspnet/core/security/authorization/policies).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要深化我们对基于策略的身份验证的了解，我们可以参考官方文档，网址为[https://docs.microsoft.com/aspnet/core/security/authorization/policies](https://docs.microsoft.com/aspnet/core/security/authorization/policies)。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Knowing how authentication and authorization work in minimal APIs is fundamental
    to developing secure applications. Using JWT bearer authentication roles and policies,
    we can even define complex authorization scenarios, with the ability to use both
    standard and custom rules.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 了解最小化API中的身份验证和授权工作原理对于开发安全的应用程序是基本的。使用JWT载体身份验证角色和政策，我们甚至可以定义复杂的授权场景，并能够使用标准和自定义规则。
- en: 'In this chapter, we have introduced basic concepts to make a service secure,
    but there is much more to talk about, especially regarding ASP.NET Core Identity:
    an API that supports login functionality and allows managing users, passwords,
    profile data, roles, claims, and more. We can look further into this topic by
    checking out the official documentation, which is available at [https://docs.microsoft.com/aspnet/core/security/authentication/identity](https://docs.microsoft.com/aspnet/core/security/authentication/identity).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使服务安全的基本概念，但还有更多内容要讨论，特别是关于ASP.NET Core Identity：一个支持登录功能并允许管理用户、密码、个人资料数据、角色、声明等的API。我们可以通过查看官方文档来进一步了解这个主题，该文档可在[https://docs.microsoft.com/aspnet/core/security/authentication/identity](https://docs.microsoft.com/aspnet/core/security/authentication/identity)找到。
- en: In the next chapter, we will see how to add multilanguage support to our minimal
    APIs and how to correctly handle applications that work with different date formats,
    time zones, and so on.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何为我们的最小化API添加多语言支持，以及如何正确处理使用不同日期格式、时区等的应用程序。
