- en: Design Patterns and .NET Core Implementation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式与.NET Core实现
- en: Design patterns can be defined as ready to use architectural solutions for common
    problems you encounter during software development. They are essential for understanding
    the .NET Core architecture and useful for solving ordinary problems that we face
    when designing any piece of software. In this chapter, we will look at the implementation
    of some design patterns. It is worth mentioning that this book doesn't explain
    all the known patterns we can use. The focus here is to explain the importance
    of studying and applying them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式可以被定义为针对你在软件开发过程中遇到的常见问题的现成架构解决方案。它们对于理解.NET Core架构至关重要，并且在解决我们在设计任何软件时面临的普通问题非常有用。在本章中，我们将探讨一些设计模式的实现。值得一提的是，这本书并没有解释我们可以使用的所有已知模式。这里的重点是解释研究和应用它们的重要性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding design patterns and their purpose
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解设计模式及其目的
- en: Understanding the available design patterns in .NET Core
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解.NET Core中可用的设计模式
- en: By the end of this chapter, you will have learned about some of the use cases
    from WWTravelClub that you can implement with design patterns.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将了解一些来自WWTravelClub的使用案例，你可以使用设计模式来实现。
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will require the following to complete this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以下内容来完成本章：
- en: Visual Studio 2017 or 2019 free Community Edition or better with all the database
    tools installed.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2017或2019免费社区版或更高版本，并安装了所有数据库工具。
- en: A free Azure account. The *Creating an Azure account* subsection of [Chapter
    1](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml), *Understanding the Importance
    of Software Architecture*, explains how to create one.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个免费的Azure账户。[第1章](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml)的*创建Azure账户*小节，*理解软件架构的重要性*，解释了如何创建一个。
- en: You can find the sample code for this chapter at [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch09](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch09).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch09](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch09)找到本章的示例代码。
- en: Understanding design patterns and their purpose
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解设计模式及其目的
- en: Being able to decide on the design of a system is challenging, and the responsibility
    associated with this task is enormous. As a software architect, we must always
    keep in mind that features such as great reusability, good performance, and good
    maintainability are key. This is where design patterns help and accelerate the
    design process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 能够决定系统的设计是一项挑战，与此任务相关的责任是巨大的。作为软件架构师，我们必须始终牢记，诸如高度可重用性、良好性能和良好可维护性等特性是关键。这就是设计模式帮助并加速设计过程的地方。
- en: 'As we mentioned previously, design patterns are solutions that have already
    been discussed and defined so that they can solve common software architectural
    problems. This approach grew in popularity after the release of the book *Design
    Patterns – Elements of Reusable Object-Oriented Software*, where the **Gang of
    Four** (**GoF**) divided these patterns into three types:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，设计模式是已经被讨论和定义的解决方案，以便它们可以解决常见的软件架构问题。这种做法在《设计模式 – 可重用面向对象软件的元素》一书发布后变得流行起来，其中**四人帮**（**GoF**）将这些模式分为三类：
- en: Creational
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建
- en: Structural
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构
- en: Behavioral
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为
- en: A little bit later, Uncle Bob introduced the SOLID principles to the developers
    community, giving us the opportunity to efficaciously organize functions and data
    structures of each system into classes. SOLID principles indicate how these classes
    should be connected. It is worth mentioning that, compared to the design patterns
    presented by GoF, SOLID principles don't deliver code recipes. Instead, they give
    you the basic principles to follow when you design your solutions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间后，Uncle Bob向开发者社区介绍了SOLID原则，这给了我们有效地将每个系统的函数和数据结构组织到类中的机会。SOLID原则指出了这些类应该如何连接。值得一提的是，与GoF提出的设计模式相比，SOLID原则并不提供代码配方。相反，它们为你提供了在设计解决方案时应该遵循的基本原则。
- en: As technologies and software problems change, more patterns are conceived. The
    advance of cloud computing has brought a bunch of them, all of which can be found
    at [https://docs.microsoft.com/azure/architecture/patterns/](https://docs.microsoft.com/azure/architecture/patterns/).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术和软件问题的变化，更多的模式被构思出来。云计算的进步带来了一大堆模式，所有这些都可以在[https://docs.microsoft.com/azure/architecture/patterns/](https://docs.microsoft.com/azure/architecture/patterns/)找到。
- en: 'The reason why you should always consider them is quite simple – as a software
    architect, you cannot spend time reinventing the wheel. However, there is another
    great reason for using them: you will find many patterns implemented in .NET Core.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终考虑它们的原因很简单——作为一个软件架构师，您不能花时间重新发明轮子。然而，使用它们的另一个很好的原因是：您会发现许多模式在.NET Core中得到了实现。
- en: In the next few subsections, we will cover some of the most well-known patterns.
    However, the idea of this chapter is to let you know that they exist and need
    to be studied so that you can accelerate and simplify your project. Moreover,
    each pattern with be presented with a C# code snippet so that you can easily implement
    them in your projects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个小节中，我们将介绍一些最著名的模式。然而，本章的目的是让您知道它们的存在并需要对其进行研究，以便您能够加速并简化您的项目。此外，每个模式都将通过一个C#代码片段进行展示，这样您就可以轻松地将它们应用到您的项目中。
- en: Builder pattern
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建者模式
- en: There are cases where you will have a complex object with different behaviors
    due to its configuration. Instead of setting this object up while using it, you
    may want to decouple its configuration from its usage, using a customized configuration
    already built. This way, you have different representations of the instances you
    are building. This is where you should use the Builder pattern.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您会拥有一个具有不同行为的复杂对象，这是由于其配置造成的。在您使用它的时候设置这个对象，您可能希望将其配置与其使用解耦，使用已经构建的定制配置。这样，您就有您正在构建的实例的不同表示。这就是您应该使用构建者模式的地方。
- en: 'The following class diagram shows the pattern that has been implemented for
    a scenario from this book''s use case. The idea behind this design choice is to
    simplify the way rooms from WWTravelClub are described:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类图显示了本书用例场景中实现的模式。这个设计选择背后的想法是简化WWTravelClub中房间描述的方式：
- en: '![](img/d7b5096e-d9e3-49f8-a384-606831fec9be.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d7b5096e-d9e3-49f8-a384-606831fec9be.png)'
- en: 'As shown in the following code, the code for this is implemented in a way where
    the configurations of the instances aren''t set in the main program. Instead,
    you just build the objects using the `Construct()` method. This example is simulating
    the creation of different room styles (a single room and a family room) in the
    WWTravelClub:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，这个实现是以一种方式进行的，其中实例的配置不是在主程序中设置的。相反，您只需使用`Construct()`方法构建对象。这个例子是在模拟WWTravelClub中不同房间风格（单个房间和家庭房间）的创建：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The result of this implementation is quite simple but clarifies the reason
    why you need to implement a pattern:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现的成果相当简单，但阐明了为什么您需要实现模式的原因：
- en: '![](img/9a770151-f3f3-4c83-b37e-a4effe5208ea.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a770151-f3f3-4c83-b37e-a4effe5208ea.png)'
- en: As soon as you have the implementation, evolving this code becomes simpler and
    easier. For example, if you need to build a different style of room, you just
    have to create the concrete builder for that and you will be able to use it. Fortunately,
    if you need to increase the configuration settings for the product, all the concrete
    classes you used previously will be defined in the Builder interface and stored
    there so that you can update them with ease.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了实现，代码的演进就变得简单和容易。例如，如果您需要构建不同风格的房间，您只需创建相应的具体构建者，然后您就可以使用它。幸运的是，如果您需要增加产品的配置设置，您之前使用的所有具体类都将定义在Builder接口中并存储在那里，这样您就可以轻松地更新它们。
- en: Factory pattern
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂模式
- en: The Factory pattern is really useful in situations where you have multiple objects
    from the same abstraction and you don't know which need to be created by the time
    you start coding. This means you will have to create the instance according to
    a certain configuration or according to where the software is living at the moment.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式在您有多个来自同一抽象的对象，并且您在开始编码时不知道哪个需要被创建的情况下非常有用。这意味着您将不得不根据某种配置或根据软件当前所在的位置来创建实例。
- en: 'For instance, let''s check out the WWTravelClub sample. Here, there''s a User
    Story that describes that this application will have customers from all over the
    world paying for their trips. However, in the real world, there are different
    payment services available for each country. The process of paying is similar
    for each country, but this system will have more than one payment service available.
    A good way to simplify this payment implementation is by using the Factory pattern.
    The following diagram shows the basic idea of its architectural implementation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看WWTravelClub示例。在这里，有一个用户故事描述了该应用程序将拥有来自世界各地的客户支付他们的旅行费用。然而，在现实世界中，每个国家都有不同的支付服务。支付过程在每个国家都是相似的，但这个系统将提供多个支付服务。简化这种支付实现的一个好方法是使用工厂模式。以下图表显示了其架构实现的初步概念：
- en: '![](img/94214e08-4bd1-45fc-9b37-fa26ce54fa97.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94214e08-4bd1-45fc-9b37-fa26ce54fa97.png)'
- en: 'Notice that, since you have an interface that describes what the Payment Service
    for the application is, you can use the factory to change the concrete class according
    to the services that are available:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于你有一个描述应用程序支付服务的接口，你可以使用工厂根据可用的服务来更改具体的类：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once again, the service's usage has been simplified due to the implemented pattern.
    If you were to use this code in a real-world application, you would change the
    instance's behavior by defining the service you need in the Factory.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于实现了模式，服务的使用已经简化。如果你要在实际应用中使用此代码，你将通过在工厂中定义所需的服务的实例来改变实例的行为。
- en: Singleton pattern
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式
- en: When you implement a Singleton in your application, you will have a single instance
    of the object implemented in the entire solution. This can be considered as one
    of the most used patterns in every application. The reason is simple – there are
    many use cases where you need some classes to have just one instance. Singletons
    solve this by providing a better solution than a global variable does.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在应用程序中实现单例时，你将在整个解决方案中实现该对象的单个实例。这可以被认为是每个应用程序中最常用的模式之一。原因很简单——有许多用例需要某些类只有一个实例。单例通过提供比全局变量更好的解决方案来解决这个问题。
- en: 'In the Singleton pattern, the class is responsible for creating and delivering
    a single object that will be used by the application. In other words, the Singleton
    class creates a single instance:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在单例模式中，类负责创建和提供单个对象，该对象将被应用程序使用。换句话说，单例类创建一个单例实例：
- en: '![](img/73659067-540d-4379-a698-9df3fe07fafa.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73659067-540d-4379-a698-9df3fe07fafa.png)'
- en: 'To do so, the object that''s created is `static` and is delivered in a static
    property or method. The following code implements the Singleton pattern, which
    has a `Message` property and a `Print()` method:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，创建的对象是`static`的，并通过静态属性或方法提供。以下代码实现了单例模式，它有一个`Message`属性和一个`Print()`方法：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Its usage is really simple – you just need to call the static property every
    time you need to use the Singleton object:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 其用法非常简单——你只需在需要使用单例对象时调用静态属性：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'One of the places where you may use this pattern is when you need to deliver
    the app configuration in a way that can be easily accessed from anywhere in the
    solution. For instance, let''s say you have some configuration parameters that
    are stored in a table that your app needs to query at several decision points.
    Instead of querying the configuration table directly, you can create a Singleton
    class to help you:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能使用此模式的一个地方是当你需要以易于从解决方案的任何地方访问的方式提供应用程序配置时。例如，假设你有一些配置参数存储在一个你的应用程序需要在几个决策点查询的表中。而不是直接查询配置表，你可以创建一个单例类来帮助你：
- en: '![](img/93719043-7e2b-43f3-9d1c-182662e4de97.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93719043-7e2b-43f3-9d1c-182662e4de97.png)'
- en: 'Moreover, you will need to implement a cache in this Singleton, thus improving
    the performance of the system, since you will be able to decide whether the system
    will check each configuration in the database every time it needs it or if the
    cache will be used. The following screenshot shows the implementation of the cache
    where the configuration is loaded every 5 seconds. The parameter that is being
    read in this case is just a random number:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还需要在这个单例中实现一个缓存，从而提高系统的性能，因为你可以决定系统是否每次需要配置时都检查数据库中的每个配置，或者是否使用缓存。以下截图显示了配置每5秒加载的缓存实现。在这种情况下正在读取的参数只是一个随机数：
- en: '![](img/f2dfb9f8-0240-451d-826b-9ae519f91d8b.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2dfb9f8-0240-451d-826b-9ae519f91d8b.png)'
- en: This is great for the application's performance. Besides, using parameters in
    several places in your code is simpler, since you don't have to create configuration
    instances everywhere in the code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于应用程序的性能来说非常好。此外，在代码的几个地方使用参数更简单，因为你不需要在代码的每个地方都创建配置实例。
- en: Proxy pattern
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理模式
- en: The Proxy pattern is used when you need to provide an object that controls access
    to another object. One of the biggest reasons why you should do this is related
    to the cost of creating the object that is being controlled. For instance, if
    the controlled object takes too long to be created or consumes too much memory,
    a proxy can be used to guarantee that the huge part of the object will only be
    created when it's required.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要提供一个控制对另一个对象访问的对象时，会使用代理模式。你应该这样做的一个最大的原因与被控制对象的创建成本有关。例如，如果被控制的对象创建时间过长或消耗过多内存，可以使用代理来确保对象的大部分只有在需要时才会被创建。
- en: 'The following class diagram shows the class diagram of a Proxy pattern''s implementation
    for loading pictures from the Room, but only when requested:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的类图显示了从Room加载图片的代理模式实现类图，但仅在请求时：
- en: '![](img/17bd01c8-99ca-44a8-8311-d618f50ae1d7.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17bd01c8-99ca-44a8-8311-d618f50ae1d7.png)'
- en: 'The client of this proxy will request its creation. Here, the proxy will only
    gather basic information (`Id`, `FileName`, and `Tags`) from the real object and
    won''t query `PictureData`. When `PictureData` is requested, the proxy will load
    it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代理的客户将请求其创建。在这里，代理将只从真实对象收集基本信息（`Id`、`FileName`和`Tags`），而不会查询`PictureData`。当请求`PictureData`时，代理将加载它：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If `PictureData` is requested again, since image data is already in place,
    the proxy will guarantee that image reloading will not be repeated. The following
    screenshot shows the result of running the preceding code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果再次请求`PictureData`，由于图像数据已经就绪，代理将确保不会重复加载图像。以下截图显示了运行前面代码的结果：
- en: '![](img/54cf03cd-511a-4ad9-9fa6-98d6444855e9.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54cf03cd-511a-4ad9-9fa6-98d6444855e9.png)'
- en: This technique can be referred to as another well-known pattern: **lazy loading**.
    In fact, the Proxy pattern is a way of implementing lazy loading. For instance,
    in Entity Framework Core 2.1, as discussed in [Chapter 6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml),
    *Interacting with Data in C# - Entity Framework Core*, you can turn on lazy loading
    using proxies. You can find out more about this at [https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading](https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可以被称为另一个众所周知的模式：**延迟加载**。实际上，代理模式是实现延迟加载的一种方式。例如，在Entity Framework Core
    2.1中，如[第6章](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml)“使用C#与数据交互 - Entity Framework
    Core”中讨论的那样，你可以使用代理来开启延迟加载。你可以在[https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading](https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading)了解更多信息。
- en: Command pattern
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令模式
- en: There are many cases where you need to execute a *command* that will affect
    the behavior of an object. The Command pattern can help you with this by encapsulating
    this kind of request in an object. The pattern also describes how to handle undo/redo
    support for the request.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你需要执行一个将影响对象行为的*命令*。命令模式可以通过封装这种请求在对象中来帮助你处理这个问题。该模式还描述了如何处理请求的撤销/重做支持。
- en: 'For instance, let''s imagine that, on the WWTravelClub website, the users have
    the ability to evaluate the packages by specifying whether they like, dislike,
    or even love them. The following class diagram is an example of what can be implemented
    to create this rating system with the Command pattern:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们想象在WWTravelClub网站上，用户有权限通过指定他们是否喜欢、不喜欢甚至热爱来评估套餐。下面的类图是使用命令模式创建此评分系统的示例：
- en: '![](img/69730dee-9393-4ae2-b992-7ba7e8fcbcc1.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/69730dee-9393-4ae2-b992-7ba7e8fcbcc1.png)'
- en: Notice the way this pattern works – if you need a different command, such as Hate,
    you don't need to change the code and classes that use the command. The Undo method
    can be added in a similar way to the Redo method. The full code sample for this
    is available in this book's GitHub repository.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这种模式的工作方式——如果你需要不同的命令，比如Hate，你不需要更改使用该命令的代码和类。可以通过类似的方式添加Undo方法到Redo方法。这个完整的代码示例可以在本书的GitHub仓库中找到。
- en: Publisher/Subscriber pattern
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布者/订阅者模式
- en: Providing information from an object to a group of other objects is common in
    all applications. The Publisher/Subscriber pattern is almost mandatory when there's
    a large volume of components (subscribers) that will receive a message containing
    the information that was sent by the object (publisher).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有应用程序中，从对象提供信息到一组其他对象是很常见的。当有大量组件（订阅者）将接收包含由对象（发布者）发送的信息的消息时，发布/订阅模式几乎是强制性的。
- en: 'The concept here is quite simple to understand and is shown in the following
    diagram:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的概念非常简单易懂，如下面的图示所示：
- en: '![](img/52ef2ea5-0ab4-4c21-8abe-e8ba22065fa3.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52ef2ea5-0ab4-4c21-8abe-e8ba22065fa3.png)'
- en: When you have an indefinite number of different possible subscribers, it is
    essential to decouple the component that broadcasts information from the components
    that consume it. The Publisher/Subscriber pattern does this for us.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有不定数量的不同可能的订阅者时，将广播信息的组件与消费它的组件解耦是至关重要的。发布/订阅模式为我们做到了这一点。
- en: Implementing this pattern is complex, since distributing environments isn't
    a trivial task. Therefore, it is recommended that you consider already existing
    technologies for implementing the Message Broker that connects the Input Channel
    to the Output Channels, instead of building it from scratch. Azure Service Bus
    is a reliable implementation of this pattern, so all you need to do is connect
    to it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个模式是复杂的，因为分布式环境不是一项简单任务。因此，建议您考虑现有的技术来实现连接输入通道到输出通道的消息代理，而不是从头开始构建。Azure
    Service Bus是这个模式的可靠实现，所以你只需要连接到它。
- en: RabbitMQ, which we mentioned in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml),
    *Applying a Microservice Architecture to Your Enterprise Application*, is another
    service that can be used to implement a Message Broker, but it is a lower-level
    implementation of the pattern and requires several related tasks, such as retries,
    in case errors have to be coded manually.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)中提到的RabbitMQ，*将微服务架构应用于您的企业应用*，是另一个可以用来实现消息代理的服务，但它是对该模式的低级实现，需要执行几个相关任务，例如重试，以防需要手动编码错误。
- en: Dependency Injection pattern
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入模式
- en: 'The Dependency Injection pattern is considered a good way to implement the
    Dependency Inversion principle. Besides, it forces all the other SOLID principles
    to be followed by the implementation. As we discussed at the beginning of this
    chapter, a way to keep the software''s structure strong and reliable is by following
    the SOLID design principles presented by Uncle Bob. These can be defined as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入模式被认为是实现依赖倒置原则的好方法。此外，它强制所有其他SOLID原则在实现中遵循。正如我们在本章开头讨论的，保持软件结构强大和可靠的一种方法是遵循Uncle
    Bob提出的SOLID设计原则。这些可以定义为如下：
- en: '**Single Responsibility**: A module or function should be responsible for a
    single purpose.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责**：模块或函数应该只负责单一目的。'
- en: '**Open-Closed**: A software artifact should be open for extension but closed
    for modification.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭原则**：软件工件应该对扩展开放，但对修改封闭。'
- en: '**Liskov Substitution**: The behavior of a program needs to remain unchanged
    when you substitute one of its components for another component that''s been defined
    by a supertype of the primer object.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换**：当你用初级对象的上类型定义的另一个组件替换程序中的一个组件时，程序的行为需要保持不变。'
- en: '**I****nterface Segregation**: Creating huge interfaces will cause dependencies
    to occur while you''re building concrete objects, but these are harmful to the
    system architecture.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离**：创建巨大的接口会在构建具体对象时产生依赖，但这些对系统架构是有害的。'
- en: '**Dependency Inversion**: The most flexible systems are the ones where object
    dependencies only refer to abstractions.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖倒置**：最灵活的系统是那些对象依赖仅指向抽象的系统。'
- en: This concept is quite simple. Instead of creating instances of the objects that
    the component depends on, you just need to define their dependencies, declare
    their interfaces, and enable the reception of the objects by *injection*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念很简单。你不需要创建组件所依赖的对象的实例，只需定义它们的依赖关系，声明它们的接口，并通过*注入*使对象接收功能。
- en: 'There are three ways to perform dependency injection:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法来实现依赖注入：
- en: Use the constructor of the class to receive the objects.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类的构造函数来接收对象。
- en: Tag some class properties to receive the objects.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记一些类属性以接收对象。
- en: Define an interface with a method to inject all the necessary components.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个带有注入所有必要组件的方法的接口。
- en: 'The following diagram shows the implementation of the Dependency Injection
    pattern:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了依赖注入模式的实现：
- en: '![](img/2489a07f-eb5f-42fd-9aaf-320472e5bc56.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2489a07f-eb5f-42fd-9aaf-320472e5bc56.png)'
- en: Apart from this, dependency injection can be used with an **Inversion of Control**
    (**IoC**) container. This container enables the automatic injection of dependencies
    whenever they are asked for. There are several IoC container frameworks available
    on the market, but with .NET Core, there is no need to use third-party software
    since it contains a set of libraries to solve this in the `Microsoft.Extensions.DependencyInjection` namespace.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，依赖注入还可以与**控制反转（Inversion of Control，IoC**）容器一起使用。这个容器可以在需要时自动注入依赖。市场上有多款
    IoC 容器框架可供选择，但在 .NET Core 中，由于它包含了 `Microsoft.Extensions.DependencyInjection`
    命名空间中解决此问题的库，因此无需使用第三方软件。
- en: 'This IoC container is responsible for creating and disposing of the objects
    that are requested. The implementation of dependency injection is based on Constructor
    types. There are three options for the injected component''s lifetime:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 IoC 容器负责创建和销毁请求的对象。依赖注入的实现基于构造函数类型。注入组件的生命周期有三种选项：
- en: '**Transient**: The objects are created each time they are requested.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瞬态（Transient）**：每次请求对象时都会创建对象。'
- en: '**Scoped**: The objects are created for each scope defined in the application. In
    a Web App, a *scope* is identified with a web request.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作用域（Scoped）**：为应用程序中定义的每个作用域创建对象。在一个 Web 应用中，*作用域* 与一个 Web 请求相关联。'
- en: '**Singleton**: Each object has the same application lifetime, so a single object
    is reused to serve all the requests for a given type.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例（Singleton）**：每个对象具有相同的应用程序生命周期，因此单个对象被重用来服务给定类型的所有请求。'
- en: The way you are going to use these options depends on the business rules of
    the project you are developing. You need to be careful in deciding the correct
    one, since the behavior of the application will change according to the type of
    object you are injecting.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你将如何使用这些选项取决于你正在开发的项目中的业务规则。在决定正确的选项时，你需要小心，因为应用程序的行为将根据你注入的对象类型而改变。
- en: Understanding the available design patterns in .NET Core
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 .NET Core 中可用的设计模式
- en: As we discovered in the previous sections, C# allows us to implement any of
    the aforementioned patterns. .NET Core provides many implementations in its SDK
    that follow all the patterns we've discussed, such as Entity Framework Core Proxy
    Lazy Loading. Another good example that's been available since .NET Core 2.1 is
    .NET Generic Host.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中所发现的，C# 允许我们实现上述任何一种模式。.NET Core 在其 SDK 中提供了许多遵循我们讨论的所有模式的实现，例如 Entity
    Framework Core 代理懒加载。另一个自 .NET Core 2.1 以来可用的好例子是 .NET Generic Host。
- en: In [Chapter 13](003ee8cb-5995-4364-8772-73d73df29cf8.xhtml), *Presenting ASP.NET
    Core MVC*, we will detail the hosting that's available for Web Apps in .NET Core.
    This web host helps us since the app's startup and lifetime management is set
    up alongside it. The idea of .NET Generic Host is to enable this pattern for applications
    that don't need HTTP implementation. With this Generic Host, any .NET Core program
    can have a Startup class where we can configure the Dependency Injection Engine.
    This can be really useful for creating multi-service apps.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 13 章](003ee8cb-5995-4364-8772-73d73df29cf8.xhtml)，*展示 ASP.NET Core MVC*
    中，我们将详细介绍 .NET Core 中为 Web 应用提供的托管服务。这个 Web 托管程序有助于我们，因为应用程序的启动和生命周期管理是与它一起设置的。.NET
    Generic Host 的想法是使这种模式适用于不需要 HTTP 实现的应用程序。使用这个通用宿主，任何 .NET Core 程序都可以有一个 Startup
    类，在其中我们可以配置依赖注入引擎。这对于创建多服务应用程序非常有用。
- en: 'You can find out more at .NET Generic Host at [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host),
    which contains some sample code. The code provided in this book''s GitHub repository
    is simpler, but it focuses on the creation of a console app that can run a service
    for monitoring. The great thing about this is the way the console app is set up
    to run, where the builder configures the services that will be provided by the
    application, and the way logging will be managed. This is shown in the following
    code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在.NET通用宿主[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host)中找到更多信息，其中包含一些示例代码。本书GitHub仓库中提供的代码更简单，但它专注于创建一个可以运行监控服务的控制台应用程序。关于这一点，控制台应用程序的设置方式很出色，其中建造者配置应用程序将提供的服务，以及日志管理的方式。以下代码展示了这一点：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code gives us an idea of how .NET Core uses design patterns. Using
    the Builder pattern, .NET Generic Host allows you to set the classes that will
    be injected as services. Apart from this, the Builder pattern helps you configure
    some other features, such as the way logs will be shown/stored. This configuration
    allows the services to inject `ILogger<out TCategoryName>` objects into any instance.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码让我们了解了.NET Core如何使用设计模式。使用建造者模式，.NET通用宿主允许您设置将被注入为服务的类。除此之外，建造者模式还帮助您配置一些其他功能，例如日志的显示/存储方式。这种配置允许服务将`ILogger<out
    TCategoryName>`对象注入到任何实例中。
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we understood why design patterns help with the maintainability
    and reusability of the parts of the system you are building. We also looked at
    some typical use cases and code snippets that you can use in your projects. Finally,
    we presented .NET Generic Host, which is a good example of how .NET uses design
    patterns to enable code reusability and enforce best practices. All this content
    will help you while architecting a new software or even maintaining an existing
    one, since design patterns are solutions already known for some real life problems
    in software development.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了为什么设计模式有助于提高您所构建的系统部分的维护性和可重用性。我们还探讨了您可以在项目中使用的典型用例和代码片段。最后，我们介绍了.NET通用宿主，这是.NET如何使用设计模式来实现代码重用和强制最佳实践的良例。所有这些内容都将帮助您在架构新的软件或维护现有软件时，因为设计模式是针对软件开发中一些现实生活问题的已知解决方案。
- en: In the next chapter, we will cover the domain-driven design approach. We will
    also learn how to use SOLID design principles so that we can map different domains
    to our software solutions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍领域驱动设计方法。我们还将学习如何使用SOLID设计原则，以便我们可以将不同的领域映射到我们的软件解决方案中。
- en: Questions
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are design patterns?
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是设计模式？
- en: What's the difference between design patterns and design principles?
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计模式和设计原则之间的区别是什么？
- en: When is it a good idea to implement the Builder pattern?
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下实现建造者模式是一个好主意？
- en: When is it a good idea to implement the Factory pattern?
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下实现工厂模式是一个好主意？
- en: When is it a good idea to implement the Singleton pattern?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下实现单例模式是一个好主意？
- en: When is it a good idea to implement the Proxy pattern?
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下实现代理模式是一个好主意？
- en: When is it a good idea to implement the Command pattern?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下实现命令模式是一个好主意？
- en: When is it a good idea to implement the Publisher/Subscriber pattern?
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下实现发布/订阅模式是一个好主意？
- en: When is it a good idea to implement the Dependency Injection pattern?
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下实现依赖注入模式是一个好主意？
- en: Further reading
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following are some books and websites where you can find out more regarding
    what was covered in this chapter:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些书籍和网站，您可以在其中找到更多关于本章所涵盖内容的信息：
- en: '*Clean Architecture: A Craftsman''s Guide to Software Structure and Design*, Martin,
    Robert C. Pearson Education, 2018.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《整洁架构：软件结构和设计的工匠指南》，Martin, Robert C. Pearson Education，2018。
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software*, Erica Gamma
    et al. Addison-Wesley, 1994.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《设计模式：可复用面向对象软件元素》，Erica Gamma 等。Addison-Wesley，1994。
- en: '*Design Principles and Design Patterns*, Robert C. Martin, 2000.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《设计原则与设计模式》，Robert C. Martin，2000。
- en: 'If you need to get more info about design patterns and architectural principles,
    please check these links:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要获取有关设计模式和架构原则的更多信息，请查看以下链接：
- en: '[https://www.packtpub.com/application-development/design-patterns-using-c-and-net-core-video](https://www.packtpub.com/application-development/design-patterns-using-c-and-net-core-video)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/design-patterns-using-c-and-net-core-video](https://www.packtpub.com/application-development/design-patterns-using-c-and-net-core-video)'
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles](https://docs.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles](https://docs.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles)'
- en: 'If you want to understand better the idea of generic hosts, follow this link:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更好地理解通用宿主的概念，请点击此链接：
- en: '[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host)'
- en: 'There is a very good explanation about service bus messaging in this link:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在此链接中有一个关于服务总线消息的非常好的解释：
- en: '[https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions](https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions](https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)'
- en: 'You can learn more about dependency injection checking these links:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下链接了解更多关于依赖注入的信息：
- en: '[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection)'
- en: '[https://www.martinfowler.com/articles/injection.html](https://www.martinfowler.com/articles/injection.html)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.martinfowler.com/articles/injection.html](https://www.martinfowler.com/articles/injection.html)'
