<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-168"><a id="_idTextAnchor367"/>9</h1>
<h1 id="_idParaDest-169"><a id="_idTextAnchor368"/>See in Action</h1>
<p>As you already know, algorithms are almost everywhere, and there are many types and classifications. They are supported by numerous data structures and some of them you learned while reading the previous chapters. After some theoretical parts, it is high time to keep on practicing, based on interesting examples. They are chosen from various types of algorithms, summarizing many subjects that you have got to know.</p>
<p>First, you will see how to calculate a given number from the <strong class="bold">Fibonacci series</strong> in a few variants that differ significantly in performance results, so you will get to know how you can optimize your code. Sometimes, even small changes can lead to huge performance improvements. Then, you will learn how to apply the greedy approach to solve the <strong class="bold">minimum coin change</strong> problem, as well as how to benefit from the divide-and-conquer algorithm to find the <strong class="bold">closest pair of points</strong> located on the two-dimensional surface. You will also see a beautiful <strong class="bold">fractal</strong> and the code that designs such graphics. The following examples will be related to applications of back-tracking with recursion to solve puzzles, namely <strong class="bold">rat in a maze</strong> and <strong class="bold">Sudoku</strong>. Coming closer to the end of the chapter, you will see how to apply a genetic algorithm to <strong class="bold">guess a title</strong> of this book, based on the rules of Darwinian theory of evolution and natural selection. The last example will be a brute-force algorithm for <strong class="bold">guessing a </strong><strong class="bold">secret password</strong>.</p>
<p>As you can see, there are a lot of interesting examples just ahead of you, so be ready to write quite a lot of code and solve these tasks together. Let’s start!</p>
<p>In this chapter, you will cover the following topics:</p>
<ul>
<li>The Fibonacci series</li>
<li>Minimum coin change</li>
<li>The closest pair of points</li>
<li>Fractal generation</li>
<li>Rat in a maze</li>
<li>A Sudoku puzzle</li>
<li>A title guess</li>
<li>A password guess</li>
</ul>
<h1 id="_idParaDest-170"><a id="_idTextAnchor369"/>The Fibonacci series</h1>
<p>As the first example, let’s take <a id="_idIndexMarker858"/>a look at calculating a given number from the <strong class="bold">Fibonacci series</strong>, using the following <strong class="bold">recursive</strong> function:</p>
<div><div><img alt="Figure 9.1 – A formula for calculating a number from the Fibonacci series" src="img/B18069_09_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – A formula for calculating a number from the Fibonacci series</p>
<p>Its interpretation is very simple:</p>
<ul>
<li><em class="italic">F(0)</em> is equal to 0</li>
<li><em class="italic">F(1)</em> is equal to 1</li>
<li><em class="italic">F(n)</em> is a sum of <em class="italic">F(n-1)</em> and <em class="italic">F(n-2)</em>, which means that this number is a sum of the two preceding ones</li>
</ul>
<p>As an example, <em class="italic">F(2)</em> is equal to the sum of <em class="italic">F(0)</em> and <em class="italic">F(1)</em>. Thus, it is equal to 1, while <em class="italic">F(3)</em> is equal to 2. It is worth mentioning that there are two base cases, namely for <em class="italic">n</em> equal to 0 and 1. For both of them, there is a specific value defined, namely 0 and 1.</p>
<p>The <strong class="bold">recursive</strong> implementation in the C# language is shown as follows:</p>
<pre class="source-code">
long <strong class="bold">Fibonacci</strong>(int n)
{
    if (n == 0) { return 0; }
    if (n == 1) { return 1; }
    return <strong class="bold">Fibonacci(n - 1)</strong> + <strong class="bold">Fibonacci(n - 2)</strong>;
}</pre> <p>As you see, the <code>Fibonacci</code> method calls itself twice with different values of parameters, namely smaller by 1 and 2 than the <code>n</code> parameter passed to the method. If you call the method passing <code>25,</code> you will receive 75025 as a result, as follows:</p>
<pre class="source-code">
long result = Fibonacci(25);</pre> <p>Keep in mind that the presented recursive version for calculating a value of the Fibonacci function is very inefficient and will be very slow for larger input numbers.</p>
<p>You can significantly <a id="_idIndexMarker859"/>improve its performance using <strong class="bold">dynamic programming</strong>, either with top-down or<a id="_idIndexMarker860"/> bottom-up approaches. First, let’s use the <strong class="bold">top-down approach</strong> with <strong class="bold">memoization</strong> to <strong class="bold">cache the calculated results</strong> for subproblems:</p>
<pre class="source-code">
<strong class="bold">Dictionary&lt;int, long&gt; cache = [];</strong>
long <strong class="bold">Fibonacci</strong>(int n)
{
    if (n == 0) { return 0; }
    if (n == 1) { return 1; }
    <strong class="bold">if (cache.ContainsKey(n)) { return cache[n]; }</strong>
    long result = Fibonacci(n - 1) + Fibonacci(n - 2);
    <strong class="bold">cache[n] = result;</strong>
    return result;
}</pre> <p>You use the <code>Dictionary</code> class as a cache, where keys are values of <code>n</code> passed to the <code>Fibonacci</code> method and values are the calculated results, namely <code>Fibonacci(n)</code>. Within the method, you add the check on whether the cache contains a key equal to <code>n</code>. If so, you do not perform further operations and simply return the value from the cache. If the cache does not have such a key yet, you use the same approach as in the case of the recursive version and add the calculated result to the cache just before returning the result.</p>
<p>Is it worth introducing such changes? Let’s see some numbers regarding execution time for the 50th number from the Fibonacci series. In the basic recursive version, it took more than 88 seconds on my <a id="_idIndexMarker861"/>machine. Introducing the top-down approach caused the same result received in... less than 1 millisecond. This solution is almost 100,000 times faster!</p>
<p>Now you know that dynamic programming can make a huge difference, let’s take a look at the <strong class="bold">bottom-up approach</strong> for the Fibonacci number calculation:</p>
<pre class="source-code">
long <strong class="bold">Fibonacci</strong>(int n)
{
    if (n == 0) { return 0; }
    if (n == 1) { return 1; }
    <strong class="bold">long a = 0;</strong>
    <strong class="bold">long b = 1;</strong>
    <strong class="bold">for (int i = 2; i &lt;= n; i++)</strong>
    <strong class="bold">{</strong>
        <strong class="bold">long result = a + b;</strong>
        <strong class="bold">a = b;</strong>
        <strong class="bold">b = result;</strong>
    <strong class="bold">}</strong>
    return b;
}</pre> <p>Here, a bigger modification is introduced because you replace recursion with iteration. However, the code is very simple, as it consists of only one <code>for</code> loop that iterates from 2 until the given number and calculates the sum of the two preceding values. Of course, there are separate <code>if</code> conditions for the 0 and 1 values of the <code>n</code> parameter.</p>
<p>And what about the performance in this case? Let’s compare calculating the 5,000th number from the Fibonacci series using both the top-down and bottom-down approaches. The top-down approach requires about 2 milliseconds, while the bottom-up still takes less than 1 millisecond<a id="_idIndexMarker862"/> on my laptop. Keep in mind that we are now talking about the 5,000th number from the Fibonacci series, and previously, the tests were made for only the 50th number. Incredible performance boost, isn’t it?</p>
<p class="callout-heading">Results can differ</p>
<p class="callout">The performance results are obtained on my computer and are calculated in a very simple way, even without repeating them several times. Of course, such results can be different in other circumstances, such as while using your machine. However, it is crucial to present some trend, not a precise result in milliseconds. This performance testing aims to show you a huge difference between a basic recursive version and any of the optimized versions with dynamic programming.</p>
<p>After the first example, let’s proceed to solving the minimum coin change problem.</p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor370"/>Minimum coin change</h1>
<p>The second example shown in this chapter presents a <strong class="bold">greedy algorithm</strong> to solve the <strong class="bold">minimum coin change</strong> problem, for <a id="_idIndexMarker863"/>finding the minimum number of coins to receive the amount specified as the input.</p>
<div><div><img alt="Figure 9.2 – ﻿Illustration of denominations in the case of the euro currency" src="img/B18069_09_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Illustration of denominations in the case of the euro currency</p>
<p>For example, for the coin system consisting of 1, 2, 5, 10, 20, 50, 100, 200, and 500 denominations, if you want to get a value of 158, you need to pick 5 coins, namely 100, 50, 5, 2, and 1. The greedy approach is very simple because you just <strong class="bold">pick the largest possible denomination not greater than the remaining amount</strong>. You perform this operation until the remaining amount is equal to 0. As you see, the algorithm does not care about the overall solution <a id="_idIndexMarker864"/>and tries to choose the best solution at each step.</p>
<p>The C#-based implementation is shown here:</p>
<pre class="source-code">
int[] den = [1, 2, 5, 10, 20, 50, 100, 200, 500];
List&lt;int&gt; coins = GetCoins(158);
coins.ForEach(Console.WriteLine);
List&lt;int&gt; <strong class="bold">GetCoins</strong>(int amount)
{
    List&lt;int&gt; coins = [];
    <strong class="bold">for (int i = den.Length - 1; i &gt;= 0; i--)</strong>
    <strong class="bold">{</strong>
        <strong class="bold">while (amount &gt;= den[i])</strong>
        <strong class="bold">{</strong>
            <strong class="bold">amount -= den[i];</strong>
            <strong class="bold">coins.Add(den[i]);</strong>
        <strong class="bold">}</strong>
    <strong class="bold">}</strong>
    return coins;
}</pre> <p>The most important role is performed by the <code>GetCoins</code> method, which takes one input, namely the amount to get. It returns a list of chosen coins. For example, if you call this method passing 158, you will see 100, 50, 5, 2, and 1 in the console.</p>
<p>That’s a quick example! Now, let’s proceed to something a bit more complex.</p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor371"/>Closest pair of points</h1>
<p>Another example is an algorithm to <strong class="bold">find the closest pair of points</strong> located on the two-dimensional surface. It is an interesting<a id="_idIndexMarker865"/> algorithmic problem that can be solved using the <strong class="bold">divide-and-conquer</strong> paradigm.</p>
<p>Each point is represented by <em class="italic">x</em> and <em class="italic">y</em> coordinates, with values starting from (<strong class="bold">0</strong>, <strong class="bold">0</strong>) in the top-left corner of the surface. To find the closest pair of points, you first sort all points according to the <em class="italic">x</em> coordinate, as shown in the following diagrams, marked from <strong class="bold">A</strong> to <strong class="bold">N</strong>:</p>
<div><div><img alt="Figure 9.3 – Diagrams of the algorithm to find the closest pair of points" src="img/B18069_09_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Diagrams of the algorithm to find the closest pair of points</p>
<p>Then, you divide the surface into two halves. You can do this by calculating half of the points count, namely 7 in our example, and taking the first 7 points as the left half and the next 7 points as the right half.</p>
<p>Here is a task for <strong class="bold">recursion</strong>, so you recursively find the closest points in both halves and store data as <em class="italic">r</em>l (points <strong class="bold">D</strong> and <strong class="bold">E</strong>) and <em class="italic">r</em>r (points <strong class="bold">I</strong> and <strong class="bold">K</strong>). You choose the closer pair by comparing such distances and store the result as <em class="italic">r</em>, namely points <strong class="bold">D</strong> and <strong class="bold">E</strong> in our case.</p>
<p>That’s not all – you also need to check the distance between points from the left and the right half, as presented in the preceding diagram, on the right. To do so, you get an array with data of all points that are closer to the middle point (in respect to the <em class="italic">x</em> coordinate only) than the <em class="italic">r</em> distance of the already found pair of points (<strong class="bold">D</strong> and <strong class="bold">E</strong> in our example). Then, you find the closest pair of points in this array (<strong class="bold">G</strong> and <strong class="bold">H</strong> in the example). Let’s name the result <em class="italic">s</em>. To complete the task, choose which pair, from <em class="italic">r</em> (<strong class="bold">D</strong> and <strong class="bold">E</strong>) and <em class="italic">s</em> (<strong class="bold">G</strong> and <strong class="bold">H</strong>), is closer. Then, just return the result (<strong class="bold">D</strong> and <strong class="bold">E</strong> in our case).</p>
<p>The most important part of the code is shown as follows:</p>
<pre class="source-code">
Result? <strong class="bold">FindClosestPair</strong>(Point[] points)
{
    if (points.Length &lt;= 1) { return null; }
    if (points.Length &lt;= 3) { return <strong class="bold">Closest</strong>(points); }
    int m = points.Length / 2;
    Result r = Closer(
        <strong class="bold">FindClosestPair</strong>(points.Take(m).ToArray())!,
        <strong class="bold">FindClosestPair</strong>(points.Skip(m).ToArray())!);
    Point[] strip = points.Where(p =&gt; Math.Abs(p.X
        - points[m].X) &lt; r.Distance).ToArray();
    return <strong class="bold">Closer</strong>(r, <strong class="bold">Closest</strong>(strip));
}</pre> <p>First, there is the base condition that terminates execution when the array of points is empty or contains only one<a id="_idIndexMarker866"/> element. Then, you check whether the number of points in the array is less than or equal to 3. If so, you choose the closest pair of points in the collection just by checking all possible variants. Otherwise, you choose an index of the middle point and call the method recursively for the left and right halves. Then, you get points from both halves that are close enough to the middle point, taking only <em class="italic">x</em> coordinates into account. Next, you calculate the distance between all points in the <code>strip</code> array to get the closest pair from it. Finally, you just return the closer pair of points.</p>
<p>As you see, the main part of the algorithm is pretty simple to implement and understand. So, let’s talk about the rest, starting with the <code>Point</code> definition:</p>
<pre class="source-code">
public record <strong class="bold">Point</strong>(int X, int Y)
{
    public float <strong class="bold">GetDistanceTo</strong>(Point p) =&gt;
        (float)Math.Sqrt(Math.Pow(X - p.X, 2)
            + Math.Pow(Y - p.Y, 2));
};</pre> <p>The <code>Result</code> record is presented here:</p>
<pre class="source-code">
public record <code>Closest</code> and <code>Closer</code>. The first one searches for the<a id="_idIndexMarker867"/> closest pair of points, and its code is shown here:</p>
<pre class="source-code">
Result <strong class="bold">Closest</strong>(Point[] points)
{
    Result result = new(points[0], points[0], double.MaxValue);
    for (int i = 0; i &lt; points.Length; i++)
    {
        for (int j = i + 1; j &lt; points.Length; j++)
        {
            double distance = points[i].GetDistanceTo(points[j]);
            if (distance &lt; result.Distance)
            {
                result = new(points[i], points[j], distance);
            }
        }
    }
    return result;
}</pre> <p>The <code>Closer</code> method is <a id="_idIndexMarker868"/>presented in the following code snippet:</p>
<pre class="source-code">
Result <strong class="bold">Closer</strong>(Result r1, Result r2) =&gt;
    r1.Distance &lt; r2.Distance ? r1 : r2;</pre> <p>Finally, let’s take a look at a way of calling the described method:</p>
<pre class="source-code">
List&lt;Point&gt; points =
[
    new Point(6, 45),   // A
    new Point(12, 8),   // B
    new Point(14, 31),  // C
    new Point(24, 18),  // D
    new Point(32, 26),  // E
    new Point(40, 41),  // F
    new Point(44, 6),   // G
    new Point(57, 20),  // H
    new Point(60, 35),  // I
    new Point(72, 9),   // J
    new Point(73, 41),  // K
    new Point(85, 25),  // L
    new Point(92, 8),   // M
    new Point(93, 43)   // N
];
<strong class="bold">points.Sort((a, b) =&gt; a.X.CompareTo(b.X));</strong>
<strong class="bold">Result? closestPair = FindClosestPair(points.ToArray());</strong>
if (closestPair != null)
{
    Console.WriteLine(
        "Closest pair: ({0}, {1}) and ({2}, {3})
         with distance: {4:F2}",
        <strong class="bold">closestPair.P1.X</strong>,
        <strong class="bold">closestPair.P1.Y</strong>,
        <strong class="bold">closestPair.P2.X</strong>,
        <strong class="bold">closestPair.P2.Y</strong>,
        <strong class="bold">closestPair.Distance</strong>);
}</pre> <p>You provide the collection of<a id="_idIndexMarker869"/> points, sort them by <em class="italic">x</em> coordinates, and call the <code>FindClosestPair</code> method, passing the whole array as a parameter. Finally, you show the following result in the console:</p>
<pre class="console">
Closest pair: (24, 18) and (32, 26) with distance: 11.31</pre> <p>So, you get the same result as received when you analyzed the example at the beginning of this section. Good work – congratulations!</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">The examples shown in this chapter are representatives of various popular algorithmic problems, which you can receive even during interviews while recruiting for a job as a developer. These topics are also popular on the internet. For example, you can find more information about the aforementioned approach to the <em class="italic">closest pair of points</em> problem and its implementation at <a href="https://www.geeksforgeeks.org/closest-pair-of-points-using-divide-and-conquer-algorithm/">https://www.geeksforgeeks.org/closest-pair-of-points-using-divide-and-conquer-algorithm/</a>. As <em class="italic">GeeksForGeeks</em> contains a huge number of various articles, you can also find entries there about some other problems mentioned in this chapter, together with some implementations, such as about the rat in a maze problem at <a href="https://www.geeksforgeeks.org/rat-in-a-maze/">https://www.geeksforgeeks.org/rat-in-a-maze/</a> and about the Sudoku puzzle at <a href="https://www.geeksforgeeks.org/sudoku-backtracking-7">https://www.geeksforgeeks.org/sudoku-backtracking-7</a>/.</p>
<p>In my opinion, coding can<a id="_idIndexMarker870"/> be understood as a kind of art. Similar to painters who paint beautiful paintings, developers can write beautiful code. So, while we are talking about art, let’s write beautiful code that will paint beautiful fractals!</p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor372"/>Fractal generation</h1>
<p>The <strong class="bold">recursion</strong> can be applied to many various<a id="_idIndexMarker871"/> algorithms, also related to computer graphics. For this reason, let’s take a look at another example – <strong class="bold">fractal generation</strong> creating interesting patterns, such as the following:</p>
<div><div><img alt="Figure 9.4 – An exemplary fractal generated using the recursive function" src="img/B18069_09_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – An exemplary fractal generated using the recursive function</p>
<p>It’s really beautiful, isn’t it? Can you see some tree patterns in this image? If not, let’s follow the bold line in the middle of the image (the tree <em class="italic">trunk</em>) and note that it is divided into two lines (<em class="italic">branches</em>), each rotated by a given degree. Then, follow one of these lines and see that it is divided <a id="_idIndexMarker872"/>according to the same rule. This process is applied further and further until the specified number of levels is reached.</p>
<p>The description of this recursive algorithm in the natural language is quite easy, so let’s take a look at code to calculate the coordinates of the start and end points of the following lines that together form the beautiful drawing. The code of the <code>AddLine</code> method is shown as follows:</p>
<pre class="source-code">
void AddLine(int level, float x, float y,
    float length, float angle)
{
    <strong class="bold">if (level &lt; 0) { return; }</strong>
    float endX = x + (float)(length * Math.Cos(angle));
    float endY = y + (float)(length * Math.Sin(angle));
    lines.Add(new(x, y, endX, endY));
    <strong class="bold">AddLine(level - 1, endX, endY, length * 0.8f,</strong>
        <strong class="bold">angle + (float)Math.PI * 0.3f);</strong>
    <strong class="bold">AddLine(level - 1, endX, endY, length * 0.6f,</strong>
        <strong class="bold">angle + (float)Math.PI * 1.7f);</strong>
}</pre> <p>The method takes a few parameters, namely the following:</p>
<ul>
<li>A level of pattern, starting with the non-negative number and leading to 0</li>
<li>The <em class="italic">x</em> and <em class="italic">y</em> coordinates of the start point</li>
<li>A length of the line</li>
<li>Its angle, provided in radians</li>
</ul>
<p>Within the method, you check the base<a id="_idIndexMarker873"/> condition, namely whether the level is smaller than 0. If not, you calculate <em class="italic">x</em> and <em class="italic">y</em> coordinates of the end point and add the line to the collection of lines (<code>lines</code>). At the end, you recursively call the <code>AddLine</code> method, passing different parameters. You decrease the level, pass the calculated end point coordinates as coordinates of a start point for the next line, decrease the length by 20% and 40% (depending on the branch), and also modify the angle.</p>
<p>It is worth noting that the preceding code uses the <code>Line</code> record, the code for which is as follows:</p>
<pre class="source-code">
record <strong class="bold">Line</strong>(float X1, float Y1, float X2, float Y2)
{
    public float <strong class="bold">GetLength</strong>() =&gt;
        (float)Math.Sqrt(Math.Pow(X1 - X2, 2)
            + Math.Pow(Y1 - Y2, 2));
}</pre> <p>The next part of the code is presented here:</p>
<pre class="source-code">
using System.Drawing;
using System.Drawing.Drawing2D;
const int maxSize = 1000;
List&lt;Line&gt; lines = [];
<code>maxSize</code>). Then, you prepare an empty list for the lines. In the last line, you call the <code>AddLine</code> method. You indicate that <code>14</code> levels of pattern will be added.</p>
<p class="callout-heading">The required NuGet package</p>
<p class="callout">As you use elements from the <code>System.Drawing</code> and <code>System.Drawing.Drawing2D</code> namespaces, it is necessary to install an additional NuGet package, namely <code>System.Drawing.Common</code>.</p>
<p>As soon as you have the collection of lines, you can calculate the minimum and maximum <em class="italic">x</em> and <em class="italic">y</em> coordinates, as well as the target <em class="italic">width</em> and <em class="italic">height</em>, as presented here:</p>
<pre class="source-code">
float xMin = lines.Min(l =&gt; Math.Min(l.X1, l.X2));
float xMax = lines.Max(l =&gt; Math.Max(l.X1, l.X2));
float yMin = lines.Min(l =&gt; Math.Min(l.Y1, l.Y2));
float yMax = lines.Max(l =&gt; Math.Max(l.Y1, l.Y2));
float size = Math.Max(xMax - xMin, yMax - yMin);
float factor = maxSize / size;
<strong class="bold">int width = (int)((xMax - xMin) * factor);</strong>
<strong class="bold">int height = (int)((yMax - yMin) * factor);</strong></pre> <p>The remaining part of code is related to printing the fractal on the bitmap:</p>
<pre class="source-code">
<strong class="bold">using Bitmap bitmap = new(width, height);</strong>
<strong class="bold">using Graphics graphics = Graphics.FromImage(bitmap);</strong>
graphics.Clear(Color.White);
graphics.SmoothingMode = SmoothingMode.AntiAlias;
<strong class="bold">using Pen pen = new(Color.Black, 1);</strong>
foreach (Line line in lines)
{
    pen.Width = line.GetLength() / 20;
    float sx = (line.X1 - xMin) * factor;
    float sy = (line.Y1 - yMin) * factor;
    float ex = (line.X2 - xMin) * factor;
    float ey = (line.Y2 - yMin) * factor;
<strong class="bold">    graphics.DrawLine(pen, sx, sy, ex, ey);</strong>
}
bitmap.Save($"{DateTime.Now:HH-mm-ss}.png");</pre> <p>Within the presented code, you create a new instance of the <code>Bitmap</code> class with the specified size, as well as <a id="_idIndexMarker875"/>prepare the <code>Graphics</code> object to draw on this bitmap. Then, you paint the whole bitmap with a white color, set anti-aliasing, and specify a black pen for drawing.</p>
<p>The preceding piece of code involves the <code>foreach</code> loop. Within it, you calculate a line width, as well as the start and end coordinates. The last line in the loop simply draws the line. Finally, you save the prepared bitmap in the working directory in the file, whose name is created <a id="_idIndexMarker876"/>based on the current time.</p>
<p class="callout-heading">Do you see warnings?</p>
<p class="callout">The prepared code shows some warnings in the IDE. They <a id="_idIndexMarker877"/>inform you about the availability of graphics-related features only on the Windows platform. You can hide such warnings by adding the line <code>#pragma warning disable CA1416</code> just before the preceding code, as well as adding the line <code>#pragma warning restore CA1416</code> just at the end. What’s more, if you want to also draw graphics on other platforms, you can use other available NuGet packages, such as <code>SkiaSharp</code>. I strongly encourage you to create this example with <code>SkiaSharp</code> as well.</p>
<p>That’s all! You can now adjust various parameters to paint beautiful fractals, even better than presented in the preceding figure. Some of the other results are shown here:</p>
<div><div><img alt="Figure 9.5 – Exemplary fractals generated using the recursive function" src="img/B18069_09_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Exemplary fractals generated using the recursive function</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">You can find a lot of content about fractals in the internet. However, an approach similar to presented here, is described at <a href="http://www.csharphelper.com/howtos/howto_curly_tree.html">http://www.csharphelper.com/howtos/howto_curly_tree.html</a>.</p>
<p>As soon as you are satisfied with the design of your fractal, let’s move to the next section, where you will <a id="_idIndexMarker878"/>solve the <em class="italic">rat in a </em><em class="italic">maze</em> puzzle.</p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor373"/>Rat in a maze</h1>
<p>Let’s continue our adventure with examples by <a id="_idIndexMarker879"/>solving the <strong class="bold">rat in a maze</strong> problem with a <strong class="bold">back-tracking algorithm</strong>. The diagram is shown as follows:</p>
<div><div><img alt="Figure 9.6 – ﻿Illustration of the ﻿rat in a ﻿maze example" src="img/B18069_09_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Illustration of the rat in a maze example</p>
<p>Let’s imagine that a rat is located in the top-left field on the board, which is marked as <strong class="bold">(0, 0)</strong> in the preceding figure, and we need to find a path to the exit, which is located in the bottom-right field and is marked as <strong class="bold">(7, 7)</strong>. Of course, some blocks are disabled (shown in gray) and the rat cannot go through them. To reach the target, the rat can go up, down, left, or right only using the available blocks.</p>
<p>You can solve this problem using the <strong class="bold">recursion</strong> to check possible paths leading the rat from the entry to the exit. If the currently calculated path does not reach the exit, you <strong class="bold">backtrack</strong> and try other variants.</p>
<p>The main part of the implementation is the <code>Go</code> method, as follows:</p>
<pre class="source-code">
bool <strong class="bold">Go</strong>(int row, int col)
{
    if (row == size - 1
        &amp;&amp; col == size - 1
        &amp;&amp; maze[row, col])
    {
        <strong class="bold">solution[row, col] = true;</strong>
        return true;
    }
    if (row &gt;= 0 &amp;&amp; row &lt; size
        &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; size
        &amp;&amp; maze[row, col])
    {
        if (solution[row, col]) { return false; }
        <strong class="bold">solution[row, col] = true;</strong>
        if (<strong class="bold">Go(row + 1, col)</strong>) { return true; }
        if (<strong class="bold">Go(row, col + 1)</strong>) { return true; }
        if (<strong class="bold">Go(row - 1, col)</strong>) { return true; }
        if (<strong class="bold">Go(row, col - 1)</strong>) { return true; }
        <strong class="bold">solution[row, col] = false;</strong>
        return false;
    }
    return false;
}</pre> <p>The method takes two<a id="_idIndexMarker880"/> parameters, namely <code>row</code> and <code>column</code>. It also uses three additional variables. The first is named <code>maze</code> and is a two-dimensional array representing the maze with available (filled with <code>true</code> values) and unavailable (<code>false</code>) fields for the rat. The second, namely <code>size</code>, stores the size of the maze, namely the number of rows, which is also equal to the number of columns. Another variable (<code>solution</code>) is similar to <code>maze</code>, but it stores the data of the currently checked path. The fields forming the solution are filled with <code>true</code> values, while others are filled with <code>false</code>.</p>
<p>At the beginning of the method, you check whether the rat already reached the exit. If so, you mark the final field as a part of the solution and return a value indicating that the rat completed its task and exited the maze. Otherwise, you check whether the rat is still within the maze and not <a id="_idIndexMarker881"/>on any unavailable field. If all of these conditions are met, you check whether this field is already a part of the path, and if so, you inform that this solution is incorrect.</p>
<p>If the rat is within the maze and on an available field that has not already been visited, you mark this field as a part of the solution and try to go down, right, up, and left by calling the <code>Go</code> method recursively. If none of these moves reaches the target (of course, also after the next steps), you indicate that the current field is not a part of the solution, which <a id="_idIndexMarker882"/>represents <strong class="bold">back-tracking</strong>. Then, you return a value indicating that the target has not been reached.</p>
<p>Next, take a look at the code that calls the <code>Go</code> method for the first time:</p>
<pre class="source-code">
int size = 8;
bool t = true;
bool f = false;
bool[,] maze =
{
    { <strong class="bold">t</strong>, f, <strong class="bold">t</strong>, f, f, <strong class="bold">t</strong>, <strong class="bold">t</strong>, <strong class="bold">t</strong> },
    { <strong class="bold">t</strong>, <strong class="bold">t</strong>, <strong class="bold">t</strong>, <strong class="bold">t</strong>, <strong class="bold">t</strong>, f, <strong class="bold">t</strong>, f },
    { <strong class="bold">t</strong>, <strong class="bold">t</strong>, f, <strong class="bold">t</strong>, <strong class="bold">t</strong>, f, <strong class="bold">t</strong>, <strong class="bold">t</strong> },
    { f, <strong class="bold">t</strong>, <strong class="bold">t</strong>, f, <strong class="bold">t</strong>, f, f, <strong class="bold">t</strong> },
    { f, <strong class="bold">t</strong>, <strong class="bold">t</strong>, <strong class="bold">t</strong>, <strong class="bold">t</strong>, <strong class="bold">t</strong>, <strong class="bold">t</strong>, <strong class="bold">t</strong> },
    { <strong class="bold">t</strong>, f, <strong class="bold">t</strong>, f, <strong class="bold">t</strong>, f, f, <strong class="bold">t</strong> },
    { <strong class="bold">t</strong>, <strong class="bold">t</strong>, <strong class="bold">t</strong>, <strong class="bold">t</strong>, <strong class="bold">t</strong>, <strong class="bold">t</strong>, <strong class="bold">t</strong>, <strong class="bold">t</strong> },
    { f, <strong class="bold">t</strong>, f, f, f, <strong class="bold">t</strong>, f, <strong class="bold">t</strong> }
};
bool[,] solution = new bool[size, size];
<code>Print</code> method:</p>
<pre class="source-code">
void Print()
{
    for (int row = 0; row &lt; size; row++)
    {
        for (int col = 0; col &lt; size; col++)
        {
            Console.Write(solution[row, col] ? "x" : "-");
        }
        Console.WriteLine();
    }
}</pre> <p>The result is shown here:</p>
<pre class="console">
x-------
x-------
xx------
-x------
-xx-----
--x-----
--xxxxxx
-------x</pre> <p>As we conclude this example, it is worth mentioning how the code is simple and short. Thus, you can define the solution to a problem in a clear way. However, keep in mind that if there is more than one path, an algorithm shows only one.</p>
<p>After helping the rat to find a<a id="_idIndexMarker884"/> path in a maze, let’s move on to the next example, where you will learn how to automatically solve a Sudoku puzzle.</p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor374"/>A Sudoku puzzle</h1>
<p>Have you ever solved <strong class="bold">Sudoku</strong>? It is a very <a id="_idIndexMarker885"/>popular game that requires you to <strong class="bold">fill empty cells of a 9x9 board with numbers from 1 to 9</strong>. However, <strong class="bold">each row, each column, and each 3x3 box must contain only unique numbers</strong>. An exemplary starting board and a solved one are shown as follows:</p>
<div><div><img alt="Figure 9.7 – An example of non-solved and solved Sudoku puzzles" src="img/B18069_09_7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – An example of non-solved and solved Sudoku puzzles</p>
<p>Now, you will learn how to solve Sudoku not with the usage of a pencil and a piece of paper but with an algorithm! You can perform this task using the <strong class="bold">back-tracking</strong> approach, trying to assign numbers to empty cells if, of course, they meet the conditions regarding unique numbers in each row, column, and box. If an entered number does not result in solving the whole puzzle, you assign another number and perform the check again. Let’s take a look at the most important part of the code:</p>
<pre class="source-code">
bool <strong class="bold">Solve</strong>()
{
    (int row, int col) = GetEmpty();
    <strong class="bold">if (row &lt; 0 &amp;&amp; col &lt; 0) { return true; }</strong>
    for (int i = 1; i &lt;= 9; i++)
    {
        <strong class="bold">if (IsCorrect(row, col, i))</strong>
        {
            <strong class="bold">board[row, col] = i;</strong>
            <strong class="bold">if (Solve()) { return true; }</strong>
            <strong class="bold">else { board[row, col] = 0; }</strong>
        }
    }
    return false;
}</pre> <p>At the beginning of the <code>Solve</code> method, you get coordinates of the first empty cell. If there are no empty cells, the <code>GetEmpty</code> method returns (<code>true</code>, indicating that the game is solved.</p>
<p>Otherwise, you iterate through all possible numbers (namely from 1 to 9), using the <code>for</code> loop. In each iteration, you check whether <a id="_idIndexMarker886"/>the number can be correctly entered in this cell, using the <code>IsCorrect</code> method, ensuring that the number is unique in a row, a column, and a box. If so, you enter this number into the cell and <code>Solve</code> method. If it returns <code>false</code>, indicating that this variant does not work, you backtrack by clearing the value entered in the cell, which means that it is empty and another variant needs to be used. If no variants lead to the solution, you return <code>false</code>.</p>
<p>The presented code uses two auxiliary methods, including <code>GetEmpty</code>, which searches for the first cell that is not already filled. Its code is as follows:</p>
<pre class="source-code">
(int, int) <strong class="bold">GetEmpty</strong>()
{
    for (int r = 0; r &lt; 9; r++)
    {
        for (int c = 0; c &lt; 9; c++)
        {
            if (board[r, c] == 0) { return (r, c); }
        }
    }
    return (-1, -1);
}</pre> <p>The second auxiliary method is named <code>IsCorrect</code> and ensures that after entering a provided number in a given cell (with a specified row and column), the board still meets the criteria of the Sudoku game. Its <a id="_idIndexMarker887"/>code is presented here:</p>
<pre class="source-code">
bool <strong class="bold">IsCorrect</strong>(int row, int col, int num)
{
    for (int i = 0; i &lt; 9; i++)
    {
        if (board[row, i] == num) { return false; }
        if (board[i, col] == num) { return false; }
    }
    int rs = row - row % 3;
    int cs = col - col % 3;
    for (int r = rs; r &lt; rs + 3; r++)
    {
        for (int c = cs; c &lt; cs + 3; c++)
        {
            if (board[r, c] == num) { return false; }
        }
    }
    return true;
}</pre> <p>At the beginning, you check whether values are unique in a given row and column. The remaining part checks whether a particular 3x3 box contains only unique numbers.</p>
<p>The exemplary code for<a id="_idIndexMarker888"/> launching the Sudoku solving algorithm is as follows:</p>
<pre class="source-code">
int[,] board = new int[,]
{
    { <strong class="bold">0</strong>, 5, <strong class="bold">0</strong>, 4, <strong class="bold">0</strong>, 1, <strong class="bold">0</strong>, <strong class="bold">0</strong>, 6 },
    { 1, <strong class="bold">0</strong>, <strong class="bold">0</strong>, 9, 5, <strong class="bold">0</strong>, 8, <strong class="bold">0</strong>, <strong class="bold">0</strong> },
    { 9, <strong class="bold">0</strong>, 4, <strong class="bold">0</strong>, 6, <strong class="bold">0</strong>, <strong class="bold">0</strong>, <strong class="bold">0</strong>, 1 },
    { 6, 2, <strong class="bold">0</strong>, <strong class="bold">0</strong>, <strong class="bold">0</strong>, 5, 3, <strong class="bold">0</strong>, 4 },
    { <strong class="bold">0</strong>, 9, <strong class="bold">0</strong>, <strong class="bold">0</strong>, 7, <strong class="bold">0</strong>, 2, <strong class="bold">0</strong>, 5 },
    { 5, <strong class="bold">0</strong>, 7, <strong class="bold">0</strong>, <strong class="bold">0</strong>, <strong class="bold">0</strong>, <strong class="bold">0</strong>, 8, 9 },
    { 8, <strong class="bold">0</strong>, <strong class="bold">0</strong>, 5, 1, 9, <strong class="bold">0</strong>, <strong class="bold">0</strong>, 2 },
    { 2, 3, <strong class="bold">0</strong>, <strong class="bold">0</strong>, <strong class="bold">0</strong>, 6, 5, <strong class="bold">0</strong>, 8 },
    { 4, 1, <strong class="bold">0</strong>, 2, <strong class="bold">0</strong>, 8, 6, <strong class="bold">0</strong>, <strong class="bold">0</strong> }
};
<code>Print</code> method:</p>
<pre class="source-code">
void <strong class="bold">Print</strong>()
{
    for (int r = 0; r &lt; 9; r++)
    {
        for (int c = 0; c &lt; 9; c++)
        {
            Console.Write($"{board[r, c]} ");
        }
        Console.WriteLine();
    }
}</pre> <p>The result is shown<a id="_idIndexMarker889"/> here:</p>
<pre class="console">
7 5 3 4 8 1 9 2 6
1 6 2 9 5 7 8 4 3
9 8 4 3 6 2 7 5 1
6 2 1 8 9 5 3 7 4
3 9 8 1 7 4 2 6 5
5 4 7 6 2 3 1 8 9
8 7 6 5 1 9 4 3 2
2 3 9 7 4 6 5 1 8
4 1 5 2 3 8 6 9 7</pre> <p>As you can see, a back-tracking algorithm can be successfully applied to solve both rat in a maze and Sudoku puzzles. You can achieve this goal with short and clear code that is also easy to understand. So, after these examples, let’s move on to the next section where you will see an interesting application of a genetic algorithm.</p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor375"/>Title guess</h1>
<p>It is high time to change a type of applied algorithm to a <strong class="bold">heuristic</strong> one, which has many applications and also subtypes. Here, we focus only on <strong class="bold">genetic algorithms</strong>, which are <strong class="bold">adaptive heuristic search algorithms</strong>. They are related to the Darwinian theory of evolution and natural selection. According to it, individuals in a population compete, and the <strong class="bold">population evolves to create next generations that are better suited to survive</strong>. The genetic algorithms <a id="_idIndexMarker890"/>operate on strings that evolve to receive possibly the highest value of <strong class="bold">fitness</strong>, complying with the <strong class="bold">rule of survival</strong> and <strong class="bold">passing on the genes of the fittest parents</strong>, also based on a <strong class="bold">randomized data exchange</strong>. The algorithm ends its operation when a suitable value of fitness is reached or when the maximum number of generations is reached.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">You can find a lot of content about genetic algorithms in the internet, such as in the article published at <a href="https://link.springer.com/article/10.1007/s11042-020-10139-6">https://link.springer.com/article/10.1007/s11042-020-10139-6</a>. The simple approach to a genetic algorithm, which is shown in this chapter, is based on the solution presented at <a href="https://www.geeksforgeeks.org/genetic-algorithms/">https://www.geeksforgeeks.org/genetic-algorithms/</a>.</p>
<p>Let's take a look at an example of a genetic algorithm application to guess the title of this book. The first part of the code is as follows:</p>
<pre class="source-code">
const string Genes = "abcdefghijklmnopqrstuvwxyz
    #ABCDEFGHIJKLMNOPQRSTUVWXYZ ";
const string Target = "C# Data Structures and Algorithms";
Random random = new();
int generationNo = 0;
<strong class="bold">List&lt;Individual&gt; population = [];</strong>
for (int i = 0; i &lt; 1000; i++)
{
    string chromosome = GetRandomChromosome();
    <strong class="bold">population.Add(new(chromosome,</strong>
<strong class="bold">        GetFitness(chromosome)));</strong>
}</pre> <p>First, you create an initial population, with 1,000 individuals. Each individual has a random chromosome, represented by a random string whose length is equal to the target string, which is a title of the book. Let’s go further:</p>
<pre class="source-code">
List&lt;Individual&gt; generation = [];
while (true)
{
    <strong class="bold">population.Sort((a, b) =&gt;</strong>
        <strong class="bold">b.Fitness.CompareTo(a.Fitness));</strong>
    <strong class="bold">if (population[0].Fitness == Target.Length)</strong>
    <strong class="bold">{</strong>
        <strong class="bold">Print();</strong>
        <strong class="bold">break;</strong>
    <strong class="bold">}</strong>
    generation.Clear();
    for (int i = 0; i &lt; 200; i++)
    {
        <strong class="bold">generation.Add(population[i]);</strong>
    }
    for (int i = 0; i &lt; 800; i++)
    {
        <strong class="bold">Individual p1 = population[random.Next(400)];</strong>
        <strong class="bold">Individual p2 = population[random.Next(400)];</strong>
        <strong class="bold">Individual offspring = Mate(p1, p2);</strong>
        <strong class="bold">generation.Add(offspring);</strong>
    }
    population.Clear();
    <strong class="bold">population.AddRange(generation);</strong>
    Print();
    generationNo++;
}</pre> <p>The most interesting part is located in the infinite <code>while</code> loop. Here, you sort the population from the best fitted to survive – that is, by fitness in decreasing order. To explain it in detail, fitness is equal to 0 when no chars in the chromosome string match the following chars in the target<a id="_idIndexMarker891"/> string. In turn, fitness is equal to 33 (i.e., the number of chars in the book title), when the chromosome string is equal to the target string. For this reason, if the first element from the population (namely the fittest) has a fitness equal to the target string length, it means that the solution is found, so you just print it and exit the loop.</p>
<p>Otherwise, you clear the list with data of a new generation and add 200 best-fitted individuals to it. This means that <strong class="bold">20% of the best-fitted individuals are moved automatically to the next generation</strong>. For the remaining 800 places in the new generation, you perform <strong class="bold">crossover</strong> and <strong class="bold">randomly choose parents, from 40% of the best-fitted individuals, to generate new individuals</strong>. Then, you replace the current population with the new generation and proceed to the next iteration.</p>
<p>It’s worth mentioning the <code>Individual</code> record, the code for which is as follows:</p>
<pre class="source-code">
record <code>Chromosome</code> and <code>Fitness</code>. The first stores the string adjusted in the evolution, while the other is the number indicating how this particular individual is fit to survive. Of course, a higher value is better.</p>
<p>The <code>Mate</code> method is used to generate a new individual using two parents:</p>
<pre class="source-code">
Individual <strong class="bold">Mate</strong>(Individual p1, Individual p2)
{
    string child = string.Empty;
    for (int i = 0; i &lt; Target.Length; i++)
    {
        float r = random.Next(101) / 100.0f;
        <strong class="bold">if (r &lt; 0.45f) { child += p1.Chromosome[i]; }</strong>
        <strong class="bold">else if (r &lt; 0.9f) { child += p2.Chromosome[i]; }</strong>
        <strong class="bold">else { child += GetRandomGene(); }</strong>
    }
    return new Individual(child, GetFitness(child));
}</pre> <p>The most interesting part of this method is the <code>for</code> loop in which the chromosome of the child is created, according to<a id="_idIndexMarker892"/> the following rules:</p>
<ul>
<li><strong class="bold">Approximately 45% of genes are taken from the </strong><strong class="bold">first parent</strong></li>
<li><strong class="bold">Approximately 45% of genes are taken from the </strong><strong class="bold">second parent</strong></li>
<li><strong class="bold">The remaining 10% </strong><strong class="bold">are randomized</strong></li>
</ul>
<p>And how can you get a random single gene or generate a random whole chromosome? You just take a look at the code:</p>
<pre class="source-code">
char <strong class="bold">GetRandomGene</strong>() =&gt; Genes[random.Next(Genes.Length)];
string <strong class="bold">GetRandomChromosome</strong>()
{
    string chromosome = string.Empty;
    for (int i = 0; i &lt; Target.Length; i++)
    {
        chromosome += GetRandomGene();
    }
    return chromosome;
}</pre> <p>The next necessary method is named <code>GetFitness</code>, which simply returns the number of characters that matches the target book title. Its code is as follows:</p>
<pre class="source-code">
int <strong class="bold">GetFitness</strong>(string chromosome)
{
    int fitness = 0;
    for (int i = 0; i &lt; Target.Length; i++)
    {
        <strong class="bold">if (chromosome[i] == Target[i]) { fitness++; }</strong>
    }
    return fitness;
}</pre> <p>Finally, let’s take a look at the <code>Print</code> method:</p>
<pre class="source-code">
void <strong class="bold">Print</strong>() =&gt; Console.WriteLine(
    $"Generation {generationNo:D2}:
    {population[0].Chromosome} / {population[0].Fitness}");</pre> <p>When you run the code, the<a id="_idIndexMarker893"/> best-fitted individual from each generation is presented, as shown in the following output:</p>
<pre class="console">
Generation 00: UvWvvtycVTYAsJYxXZpanLkj#rDrmDIEI / 4
Generation 01: sXDGuQQDPnbjpRvWZs evqRNlg#yiwIPL / 5
Generation 02: j#TvvtmKToXuTjxBegpaCLkmNsornzg R / 7
Generation 03: fZCUBIT QrnuzwuWTskTOf bezodQwhmM / 8
Generation 04: CyDwafZZpinLziuPgs yID AevGrGf bs / 9
Generation 05: C# ZaBawSWwLoturSXOcIq wLeSgQOhme / 12 (...)
Generation 10:  Sboats ttrDcterus Mnt jmvGrifhms / 17 (...)
Generation 15: C kData ltrCkteres entbAagorZthmD / 21 (...)
Generation 20: C#VDatahStrdcturessanU Al#orithmd / 26 (...)
Generation 25: CZ Data StrunturOs awd Algorithms / 29 (...)
Generation 30: C# Data Structures Qjd Algorithms / 31 (...)
Generation 35: C# Data Structures and Algorothms / 32 (...)
Generation 37: C# Data Structures and Algorithms / 33</pre> <p>Is this <em class="italic">magic</em>? No, it’s just the<a id="_idIndexMarker894"/> algorithm you wrote that manages the following generations and evolves the individuals, giving you the expected result.</p>
<h1 id="_idParaDest-177"><a id="_idTextAnchor376"/>A password guess</h1>
<p>As an example of a <strong class="bold">brute-force algorithm</strong>, let’s<a id="_idIndexMarker895"/> create a program to <strong class="bold">generate all possible passwords and trying to guess your secret one</strong>, which consists of small letters and digits only. The program starts with passwords of a length equal to 2 and proceeds until 8.</p>
<p>The first part of the code is presented here:</p>
<pre class="source-code">
using System.Diagnostics;
using System.Text;
const string secretPassword = "csharp";
<strong class="bold">int charsCount = 0;</strong>
<strong class="bold">char[] chars = new char[36];</strong>
for (char c = 'a'; c &lt;= 'z'; c++)
{
    chars[charsCount++] = c;
}
for (char c = '0'; c &lt;= '9'; c++)
{
    chars[charsCount++] = c;
}</pre> <p>First, you specify a secret password, which you will try to guess in the remaining part of the code. Then, you create an array with available characters, namely small letters and digits. At the end of this code snippet, the <code>charsCount</code> variable stores the number of available characters.</p>
<p>The most interesting part <a id="_idIndexMarker896"/>of the code is the <code>for</code> loop, where each iteration represents a particular length of a password, between two and eight chars. The code is presented here:</p>
<pre class="source-code">
for (int length = 2; length &lt;= 8; length++)
{
    Stopwatch sw = Stopwatch.StartNew();
    int[] indices = new int[length];
    for (int i = 0; i &lt; length; i++) { indices[i] = 0; }
    bool isCompleted = false;
    StringBuilder builder = new();
    long count = 0;
    while (!isCompleted)
    {
        builder.Clear();
        for (int i = 0; i &lt; length; i++)
        {
            builder.Append(chars[indices[i]]);
        }
        <strong class="bold">string guess = builder.ToString();</strong>
        <strong class="bold">if (guess == secretPassword)</strong>
        <strong class="bold">{</strong>
            <strong class="bold">Console.WriteLine("Found.");</strong>
        <strong class="bold">}</strong>
        count++;
        if (count % 10000000 == 0)
        {
            Console.WriteLine($" &gt; Checked: {count}.");
        }
        indices[length - 1]++;
        if (indices[length - 1] &gt;= charsCount)
        {
            for (int i = length - 1; i &gt;= 0; i--)
            {
                indices[i] = 0;
                indices[i - 1]++;
                if (indices[i - 1] &lt; charsCount) { break; }
                if (i - 1 == 0 &amp;&amp; indices[0] &gt;= charsCount)
                {
                    isCompleted = true;
                    break;
                }
            }
        }
    }
    sw.Stop();
    int seconds = (int)sw.ElapsedMilliseconds / 1000;
    Console.ForegroundColor = ConsoleColor.White;
    Console.WriteLine($"{length} chars: {seconds}s");
    Console.ResetColor();
}</pre> <p>The <code>indices</code> array has a length equal to the value of the <code>length</code> variable. Each item stores a current index from the <code>chars</code> array, indicating the char that is currently placed on the <em class="italic">i</em>-th location in the string. In each iteration of the <code>while</code> loop, you change values in the <code>indices</code> array until <a id="_idIndexMarker897"/>all possible combinations of the indices are used.</p>
<p>Furthermore, you save the guessed password in the <code>guess</code> variable, and here, it can be either printed on the console or hashed and compared with the hashed password that you want to guess. As this is only a demonstration of a brute-force algorithm, it does not stop its operation when the password is guessed. Thus, you can get more performance results and observe what impact the password length has on the required time for guessing.</p>
<p>As you can see, the brute-force approach is very simple, but what about performance? In the preceding code, you can see the usage of <code>Stopwatch</code>, so you can get some results. Generating all possible variants of a password consisting of two chars takes less than 1 millisecond. For three- and four-char passwords, the time is also very small, much less than 100 milliseconds. For five-char passwords, the time goes up to about two seconds, while generating passwords of a length equal to six chars takes almost a minute. If you add a mechanism to hash a password and compare it with the target hash, also taking into account that passwords can also contain capital letters and many other chars, the brute-force algorithm seems to be simply impractical in the case of longer passwords.</p>
<p>It is worth mentioning that<a id="_idIndexMarker898"/> the presented performance results were received on my computer and can be different on other devices. They are shown only to indicate a trend that as a password length increases, the time necessary to guess it is significantly longer with each added character. Thus, it is also a useful tip that you should always use a complicated password that contains small and capital letters, digits, and special characters. Of course, the length o<a id="_idTextAnchor377"/>f the password is also important.</p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor378"/>Summary</h1>
<p>You just completed the ninth chapter of this book, which examined data structures and algorithms in the context of the C# language. This time, we focused on practical examples of algorithms, with code snippets, detailed descriptions, and also brief indications of which types of algorithms the aforementioned examples belong to.</p>
<p>First, you learned how to implement a simple algorithm to calculate a given number from the <strong class="bold">Fibonacci series</strong> in three variants. You saw a simple recursive approach as well as top-down and bottom-up approaches to dynamic programming.</p>
<p>The next example showed the greedy approach to solve the <strong class="bold">minimum coin change</strong> problem. It was followed by the divide-and-conquer algorithm to find the <strong class="bold">closest pair of points</strong> located on a two-dimensional surface. The fourth example presented a recursive way of <strong class="bold">generating fractals</strong> and drawing them on a bitmap.</p>
<p>The following two examples were related to back-tracking algorithms to solve the <strong class="bold">rat in a maze</strong> and the <strong class="bold">Sudoku</strong> puzzles. These examples used recursion as well.</p>
<p>Another interesting approach involved a genetic algorithm as a subtype of a heuristic algorithm. It was used to <strong class="bold">guess the title of the book</strong>, with the rules of the Darwinian theory of evolution and natural selection.</p>
<p>The last example used a brute-force algorithm to <strong class="bold">guess a secret password</strong>, by checking all possible variants of passwords. You saw that with the increasing password length, the time necessary to guess it increased significantly.</p>
<p>Now, it is high time to proceed to the overall summary to take a look at all of the data structures that have been presented in the book so far. Let’s turn the page and proceed to the last chapter!</p>
</div>
</body></html>