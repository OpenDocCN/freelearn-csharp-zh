<html><head></head><body><div><p>&#13;
    <h1 class="chapterNumber">3</h1>&#13;
    <h1 id="_idParaDest-51" class="chapterTitle">Diving into Variables, Types, and Methods</h1>&#13;
    <p class="normal">The initial steps into any programming language are plagued with a fundamental issue—you can understand the words being typed out, but not the meaning behind them. Normally, this would be cause for a paradox, but programming is a special case. </p>&#13;
    <p class="normal">C# is not its own language; it's written in English. The discrepancy between the words you use every day and the code in Visual Studio comes from missing context, which is something that has to be learned all over again. You know how to say and spell the words used in C#, but what you don't know is where, when, why, and, most importantly, how they make up the syntax of the language. </p>&#13;
    <p class="normal">This chapter marks our departure from programming theory and the beginning of our journey into actual coding. We'll talk about accepted formatting, debugging techniques, and putting together more complex examples of variables and methods. There's a lot of ground to cover, but by the time you reach the last quiz, you'll be comfortable with the following high-level topics:</p>&#13;
    <ul>&#13;
      <li class="bullet">Writing proper C# </li>&#13;
      <li class="bullet">Debugging your code</li>&#13;
      <li class="bullet">Understanding variables</li>&#13;
      <li class="bullet">Introducing operators</li>&#13;
      <li class="bullet">Defining methods</li>&#13;
    </ul>&#13;
    <p class="normal">Let's get started!</p>&#13;
    <h1 id="_idParaDest-52" class="title">Writing proper C#</h1>&#13;
    <p class="normal">Lines of code function like sentences, meaning they need to have some sort of separating or ending <a id="_idIndexMarker095"/>character. Every line of C#, called a statement, <em class="italic">must</em> end with a semicolon to separate them for the code compiler to process.</p>&#13;
    <p class="normal">However, there's a catch that you need to be aware of. Unlike the written word we're all familiar with, a C# statement doesn't technically have to be on a single line; whitespace and newlines are ignored by the code compiler. For example, a simple variable could be written like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">public int FirstName = "Harrison";&#13;
</code></pre>&#13;
    <p class="normal">Alternatively, it could also be written as follows:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">public&#13;
int&#13;
FirstName&#13;
= &#13;
"Harrison";&#13;
</code></pre>&#13;
    <p class="normal">These two code snippets are both perfectly acceptable to Visual Studio, but the second option is highly discouraged in the software community as it makes code extremely hard to read. The idea is to write your programs as efficiently and clearly as possible.</p>&#13;
    <div>&#13;
      <p class="Information-Box--PACKT-">There will be times when a statement will be too long to reasonably fit on a single line, but those are few and far between. Just make sure that it's formatted in a way someone else could understand, and don't forget the semicolon. </p>&#13;
    </p>&#13;
    <p class="normal">The second formatting rule you need to drill into your coding muscle memory is the use of curly brackets or braces: <code class="Code-In-Text--PACKT-">{}</code>. Methods, classes, and interfaces all need a set of curly brackets after their declaration. We'll talk about each of these in-depth later on, but it's important to get the standard formatting in your head early on.</p>&#13;
    <p class="normal">The traditional practice in C# is to include each bracket on a new line, as shown in the following method:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">public void MethodName() &#13;
{&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">However, you might see the first curly bracket located on the same line as the declaration out in the wild. It's all down to personal preference:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">public void MethodName() {&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">While this isn't something to tear your hair out over, the important thing is to be consistent. In this book, we'll stick with "pure" C# code, which will always put each bracket on a <a id="_idIndexMarker096"/>new line, while C# examples that have to do with Unity and game development will often follow the second example.</p>&#13;
    <p class="normal">Good, consistent formatting style is paramount when starting in programming, but so is being able to see the fruits of your work. In the next section, we'll talk about how to print out variables and information straight to the Unity console.</p>&#13;
    <h1 id="_idParaDest-53" class="title">Debugging your code</h1>&#13;
    <p class="normal">While we're working through <a id="_idIndexMarker097"/>practical examples, we'll need a way to print out information and feedback to the <strong class="keyword">Console </strong>window in the Unity editor. The programmatic term for this <a id="_idIndexMarker098"/>is debugging, and both C# and Unity provide helper methods to make this process easier for developers. You already debugged your code from the last chapter, but we didn't go into much detail about how it actually works. Let's fix that.</p>&#13;
    <p class="normal">Whenever I ask you to debug or print something out, use one of the following methods:</p>&#13;
    <ul>&#13;
      <li class="bullet">For simple text or individual variables, use the standard <code class="Code-In-Text--PACKT-">Debug.Log()</code> method. The text needs to be inside a set of parentheses, and variables can be used directly with no added characters; for example:&#13;
        <pre class="programlisting code"><code class="hljs-code">Debug.Log("Text goes here.");&#13;
Debug.Log(CurrentAge);&#13;
</code></pre>&#13;
        <p class="bullet-para">This will produce the following in the <strong class="screenText">Console</strong> panel:</p>&#13;
        <figure class="mediaobject"><img src="img/B17573_03_01.png" alt="" width="637" height="122"/></figure>&#13;
      </li>&#13;
    </ul>&#13;
    <p class="packt_figref">Figure 3.1: Observing Debug.Log output</p>&#13;
    <ul>&#13;
      <li class="bullet">For more complex debugging, use <code class="Code-In-Text--PACKT-">Debug.LogFormat()</code>. This will let you place variables inside the printed text by using placeholders. These are marked with a pair of curly brackets, each <a id="_idIndexMarker099"/>containing an index. An index is a regular number, starting at 0 and increasing sequentially by 1. In the following example, the <code class="Code-In-Text--PACKT-">{0}</code> placeholder is replaced with the <code class="Code-In-Text--PACKT-">CurrentAge</code> value, <code class="Code-In-Text--PACKT-">{1}</code> with <code class="Code-In-Text--PACKT-">FirstName</code>, and so on:&#13;
        <pre class="programlisting code"><code class="hljs-code">Debug.LogFormat("Text goes here, add {0} and {1} as variable&#13;
   placeholders", CurrentAge, FirstName);&#13;
</code></pre>&#13;
        <p class="bullet-para">This will produce the following in the <strong class="screenText">Console</strong> panel:</p>&#13;
        <figure class="mediaobject"><img src="img/B17573_03_02.png" alt="" width="642" height="85"/></figure>&#13;
    <p class="packt_figref">Figure 3.2: Observing Debug.LogFormat output</p>&#13;
      </li>&#13;
    </ul>&#13;
&#13;
    <p class="normal">You might have noticed that we're using <strong class="keyword">dot notation</strong> in our debugging techniques, and you'd be right! Debug is the <a id="_idIndexMarker100"/>class we're using, and <code class="Code-In-Text--PACKT-">Log()</code> and <code class="Code-In-Text--PACKT-">LogFormat()</code> are different methods that we can use from that class. More on this at the end of this chapter.</p>&#13;
    <p class="normal">With the power of debugging under our belts, we can safely move on and do a deeper dive into how variables are declared, as well as the different ways that syntax can play out.</p>&#13;
    <h1 id="_idParaDest-54" class="title">Understanding variables</h1>&#13;
    <p class="normal">In the previous chapter, we saw how variables are written and touched on the high-level functionality that <a id="_idIndexMarker101"/>they provide. However, we're still missing the syntax that makes all of that possible. </p>&#13;
    <h2 id="_idParaDest-55" class="title">Declaring variables</h2>&#13;
    <p class="normal">Variables don't just appear at the top of a C# script; they have to be declared according to certain rules and <a id="_idIndexMarker102"/>requirements. At its most basic level, a variable statement needs to satisfy the following requirements:</p>&#13;
    <ul>&#13;
      <li class="bullet">The type of data the variable will store needs to be specified</li>&#13;
      <li class="bullet">The variable has to have a unique name</li>&#13;
      <li class="bullet">If there is an <a id="_idIndexMarker103"/>assigned value, it must match the specified type</li>&#13;
      <li class="bullet">The variable declaration needs to end with a semicolon</li>&#13;
    </ul>&#13;
    <p class="normal">The result of adhering to these rules is the following syntax:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">dataType UniqueName = value;&#13;
</code></pre>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">Variables need unique names to avoid conflicts with words that have already been taken by C#, which <a id="_idIndexMarker104"/>are called keywords. You can find the full list of protected keywords at <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/index">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/index</a>.</p>&#13;
    </p>&#13;
    <p class="normal">This is simple, neat, and efficient. However, a programming language wouldn't be useful in the long run if there was only one way of creating something as pervasive as variables. Complex applications and games have different use cases and scenarios, all of which have unique C# syntax.</p>&#13;
    <h3 id="_idParaDest-56" class="title">Type and value declarations</h3>&#13;
    <p class="normal">The most common <a id="_idIndexMarker105"/>scenario for creating variables is one that has all of the required information available <a id="_idIndexMarker106"/>when the declaration is made. For instance, if we knew a player's age, storing it would be as easy as doing the following:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">int CurrentAge = 32;&#13;
</code></pre>&#13;
    <p class="normal">Here, all of the basic requirements have been met:</p>&#13;
    <ul>&#13;
      <li class="bullet">A data type is specified, which is <code class="Code-In-Text--PACKT-">int</code> (short for integer)</li>&#13;
      <li class="bullet">A unique name is used, which is <code class="Code-In-Text--PACKT-">CurrentAge</code></li>&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">32</code> is an integer, which matches the specified data type</li>&#13;
      <li class="bullet">The statement ends with a semicolon</li>&#13;
    </ul>&#13;
    <p class="normal">However, there will be scenarios where you'll want to declare a variable without knowing its value right away. We'll talk about this topic in the following section.</p>&#13;
    <h3 id="_idParaDest-57" class="title">Type-only declarations</h3>&#13;
    <p class="normal">Consider another scenario—you know the type of data you want a variable to store and its name, but not its value. The value will be computed and assigned somewhere else, but you still need to <a id="_idIndexMarker107"/>declare the variable at the top of the script. This situation is perfect for a type-only declaration:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">int CurrentAge;&#13;
</code></pre>&#13;
    <p class="normal">Only the type (<code class="Code-In-Text--PACKT-">int</code>) and unique name (<code class="Code-In-Text--PACKT-">CurrentAge</code>) are defined, but the statement is still valid because we've followed the rules. With no assigned value, default values will be assigned according to the variable's type. In this case, <code class="Code-In-Text--PACKT-">CurrentAge</code> will be set to <code class="Code-In-Text--PACKT-">0</code>, which matches the <code class="Code-In-Text--PACKT-">int</code> type. As soon as the actual value of the variable becomes available, it can easily be set in a separate statement by referencing the variable name and assigning it a value:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">CurrentAge = 32;&#13;
</code></pre>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">You can find a complete list <a id="_idIndexMarker108"/>of all C# types and their default values at <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values</a>.</p>&#13;
    </p>&#13;
    <p class="normal">At this point, you might <a id="_idIndexMarker109"/>be asking why, so far, our variables haven't included the <code class="Code-In-Text--PACKT-">public</code> keyword, called an <em class="italic">access modifier</em>, which we saw in earlier scripting examples. The answer is that we didn't have the necessary foundation to talk about them with any clarity. Now that we have that foundation, it's time to revisit them in detail.</p>&#13;
    <h2 id="_idParaDest-58" class="title">Using access modifiers</h2>&#13;
    <p class="normal">Now that the basic syntax is no longer a mystery, let's get into the finer details of variable statements. Since we <a id="_idIndexMarker110"/>read code from left to right, it makes sense to begin our variable deep dive with the keyword that traditionally comes first—an access modifier.</p>&#13;
    <p class="normal">Take a quick look back at the variables we used in the preceding chapter in <code class="Code-In-Text--PACKT-">LearningCurve</code> and you'll see they had an extra keyword at the front of their statements: <code class="Code-In-Text--PACKT-">public</code>. This is the variable's access modifier. Think of it as a security setting, determining who and what can access the variable's information.</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">Any variable that isn't marked <code class="Code-In-Text--PACKT-">public</code> is defaulted to <code class="Code-In-Text--PACKT-">private</code> and won't show up in the Unity Inspector panel.</p>&#13;
    </p>&#13;
    <p class="normal">If you include a modifier, the updated syntax recipe we put together at the beginning of this chapter will look like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">accessModifier dataType UniqueName = value;&#13;
</code></pre>&#13;
    <p class="normal">While explicit access modifiers aren't necessary when declaring a variable, it's a good habit to get into <a id="_idIndexMarker111"/>as a new programmer. That extra word goes a long way toward readability and professionalism in your code.</p>&#13;
    <p class="normal">There are four main access modifiers available in C#, but the two you'll be working with most often as a beginner are the following:</p>&#13;
    <ul>&#13;
      <li class="bullet"><strong class="keyword">Public</strong>: This is <a id="_idIndexMarker112"/>available to any script without restriction.</li>&#13;
      <li class="bullet"><strong class="keyword">Private</strong>: This is only<a id="_idIndexMarker113"/> available in the class they're created in (which is called the containing class). Any variable without an access modifier defaults to private.</li>&#13;
    </ul>&#13;
    <p class="normal">The two advanced modifiers have the following characteristics:</p>&#13;
    <ul>&#13;
      <li class="bullet"><strong class="keyword">Protected</strong>: Accessible from <a id="_idIndexMarker114"/>their containing class or types derived from it</li>&#13;
      <li class="bullet"><strong class="keyword">Internal</strong>: Only <a id="_idIndexMarker115"/>available in the current assembly</li>&#13;
    </ul>&#13;
    <p class="normal">There are specific use cases for each of these modifiers, but until we get to the advanced chapters, don't worry about <strong class="keyword">protected</strong> and <strong class="keyword">internal</strong>.</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">Two combined <a id="_idIndexMarker116"/>modifiers also exist, but we won't be using them in this book. You can find more information about them at <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers</a>.</p>&#13;
    </p>&#13;
    <p class="normal">Let's try out some access modifiers of our own! Just like information in real life, some data needs to be protected or shared with specific people. If there's no need for a variable to be changed in the <strong class="screenText">Inspector</strong> window or accessed from other scripts, it's a good candidate for a private access modifier.</p>&#13;
    <p class="normal">Perform the following steps to update <code class="Code-In-Text--PACKT-">LearningCurve</code>:</p>&#13;
    <ol>&#13;
      <li class="numbered">Change the access <a id="_idIndexMarker117"/>modifier in front of <code class="Code-In-Text--PACKT-">CurrentAge</code> from <code class="Code-In-Text--PACKT-">public</code> to <code class="Code-In-Text--PACKT-">private</code> and save the file.</li>&#13;
      <li class="numbered">Go back into Unity, select the Main Camera, and take a look at what changed in the <code class="Code-In-Text--PACKT-">LearningCurve</code><em class="italic"> </em>section:<figure class="mediaobject"><img src="img/B17573_03_03.png" alt="" width="751" height="108"/></figure>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="packt_figref">Figure 3.3: LearningCurve script component attached to the Main Camera</p>&#13;
    <p class="normal">Since <code class="Code-In-Text--PACKT-">CurrentAge</code> is now private, it's no longer visible in the <strong class="screenText">Inspector</strong> window and can only be accessed within <a id="_idIndexMarker118"/>the <code class="Code-In-Text--PACKT-">LearningCurve</code> script in code. If we click play, the script will still work exactly as it did before.</p>&#13;
    <p class="normal">This is a good start on our journey into variables, but we still need to know more about what kinds of data they can store. This is where data types come in, which we'll look at in the next section.</p>&#13;
    <h2 id="_idParaDest-59" class="title">Working with types</h2>&#13;
    <p class="normal">Assigning a specific type to a <a id="_idIndexMarker119"/>variable is an important choice, one that trickles down into every interaction <a id="_idIndexMarker120"/>a variable has over its entire lifespan. Since C# is what's called a <em class="italic">strongly-typed</em> or <em class="italic">type-safe</em> language, every variable has to have a data type without <a id="_idIndexMarker121"/>exception. This means that there are specific rules when it comes to performing operations with certain types, and regulations when converting a given variable type into another. </p>&#13;
    <h3 id="_idParaDest-60" class="title">Common built-in types</h3>&#13;
    <p class="normal">All data types in C# trickle <a id="_idIndexMarker122"/>down (or <em class="italic">derive</em>, in programmatic terms) from a <a id="_idIndexMarker123"/>common ancestor: <code class="Code-In-Text--PACKT-">System.Object</code>. This hierarchy, called the <strong class="keyword">Common Type System</strong> (<strong class="keyword">CTS</strong>), means that different types have a lot of shared functionality. The following table lays out some of the most common data type options and the values they store:</p>&#13;
    <figure class="mediaobject"><img src="img/B17573_03_04.png" alt="" width="808" height="164"/></figure>&#13;
    <p class="packt_figref">Figure 3.4: Common data types for variables</p>&#13;
    <p class="normal">In addition to specifying the kind of value a variable can store, types contain added information about themselves, including the following:</p>&#13;
    <ul>&#13;
      <li class="bullet">Required storage space</li>&#13;
      <li class="bullet">Minimum and maximum values</li>&#13;
      <li class="bullet">Allowed operations</li>&#13;
      <li class="bullet">Location in memory</li>&#13;
      <li class="bullet">Accessible methods </li>&#13;
      <li class="bullet">Base (derived) type</li>&#13;
    </ul>&#13;
    <p class="normal">If this seems overwhelming, take a deep breath. Working with all of the types C# offers is a perfect example <a id="_idIndexMarker124"/>of using documentation over memorization. Pretty soon, using even the most complex custom types will feel like second nature.</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">You can find <a id="_idIndexMarker125"/>a complete list of all of the C# built-in types and their specifications at <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/index">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/index</a>.</p>&#13;
    </p>&#13;
    <p class="normal">Before the list of types becomes a sticking point, it's best to experiment with them. After all, the best way to learn something new is to use it, break it, and then learn to fix it.</p>&#13;
    <p class="normal">Go ahead and open up <code class="Code-In-Text--PACKT-">LearningCurve</code><em class="italic"> </em>and add a new variable for each type in the preceding chart from the <em class="italic">Common built-in types</em> section. The names and values you use are up to you; just make sure they're marked as public so we can see them in the Inspector window. If you <a id="_idIndexMarker126"/>need inspiration, take a look at my code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">public class LearningCurve : MonoBehaviour&#13;
{&#13;
    private int CurrentAge = 30;&#13;
    public int AddedAge = 1;&#13;
 &#13;
<strong class="hljs-slc">    </strong><strong class="hljs-keyword-slc">public</strong><strong class="hljs-slc"> </strong><strong class="hljs-built_in-slc">float</strong><strong class="hljs-slc"> Pi = </strong><strong class="hljs-number-slc">3.14f</strong><strong class="hljs-slc">;</strong>&#13;
<strong class="hljs-slc">    </strong><strong class="hljs-keyword-slc">public</strong><strong class="hljs-slc"> </strong><strong class="hljs-built_in-slc">string</strong><strong class="hljs-slc"> FirstName = </strong><strong class="hljs-string-slc">"Harrison"</strong><strong class="hljs-slc">;</strong>&#13;
<strong class="hljs-slc">    </strong><strong class="hljs-keyword-slc">public</strong><strong class="hljs-slc"> </strong><strong class="hljs-built_in-slc">bool</strong><strong class="hljs-slc"> IsAuthor = </strong><strong class="hljs-literal-slc">true</strong><strong class="hljs-slc">;</strong>&#13;
 &#13;
    // Start is called before the first frame update&#13;
    void Start()&#13;
    {&#13;
        ComputeAge(); &#13;
    }&#13;
 &#13;
    /// &lt;summary&gt;&#13;
    /// Time for action - adding comments&#13;
    /// Computes a modified age integer&#13;
    /// &lt;/summary&gt;&#13;
    void ComputeAge()&#13;
    {&#13;
        Debug.Log(CurrentAge + AddedAge);&#13;
    }&#13;
}&#13;
</code></pre>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">When dealing with string types, the actual text value needs to be inside a pair of double quotes, while float values need to end with a lowercase <code class="Code-In-Text--PACKT-">f</code>, as you can see with <code class="Code-In-Text--PACKT-">FirstName</code> and <code class="Code-In-Text--PACKT-">Pi</code>.</p>&#13;
    </p>&#13;
    <p class="normal">All our different variable types are now visible. Take note of the <code class="Code-In-Text--PACKT-">bool</code> variable that Unity displays as a checkbox (true is checked and false is unchecked).</p>&#13;
    <figure class="mediaobject"><img src="img/B17573_03_05.png" alt="" width="828" height="192"/></figure>&#13;
    <p class="packt_figref">Figure 3.5: LearningCurve script component with common variable types</p>&#13;
    <p class="normal">Remember, any variables you declare as private won't show up in the Inspector window. Before we move on to <a id="_idIndexMarker127"/>conversions, we need to touch on a common and powerful application of the string data type; namely, the creation of strings that have variables interspersed at will.</p>&#13;
    <p class="normal">While number types behave as you'd expect from grade school math, strings are a different story. It's possible to insert variables and literal values directly into text by starting with a <code class="Code-In-Text--PACKT-">$</code> character, which is called string interpolation. You've already used an interpolated string in your <code class="Code-In-Text--PACKT-">LogFormat()</code> debugging; adding the <code class="Code-In-Text--PACKT-">$</code> character lets you use them anywhere! </p>&#13;
    <p class="normal">Let's create a simple interpolated string of our own inside <code class="Code-In-Text--PACKT-">LearningCurve</code> to see this in action. Print out the interpolated string inside the <code class="Code-In-Text--PACKT-">Start()</code> method directly after <code class="Code-In-Text--PACKT-">ComputeAge()</code> is called:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">void Start()&#13;
{&#13;
    ComputeAge();&#13;
    <strong class="hljs-slc">Debug.Log(</strong><strong class="hljs-string-slc">$"A string can have variables like </strong><strong class="hljs-subst-slc">{FirstName}</strong><strong class="hljs-string-slc"> inserted directly!"</strong><strong class="hljs-slc">);</strong>&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Thanks to the <code class="Code-In-Text--PACKT-">$</code> character and curly brackets, the value of <code class="Code-In-Text--PACKT-">FirstName</code> is treated as a value and is printed out inside the interpolated string. Without this special formatting, the string would <a id="_idIndexMarker128"/>just include <code class="Code-In-Text--PACKT-">FirstName</code> as text instead of the variable value.</p>&#13;
    <figure class="mediaobject"><img src="img/B17573_03_06.png" alt="" width="827" height="157"/></figure>&#13;
    <p class="packt_figref">Figure 3.6: Console showing debug log output</p>&#13;
    <p class="normal">It's also possible to create interpolated strings using the <code class="Code-In-Text--PACKT-">+</code> operator, which we'll talk about in the <em class="italic">Introducing operators</em> section.</p>&#13;
    <h3 id="_idParaDest-61" class="title">Type conversions</h3>&#13;
    <p class="normal">We've already seen that variables can only hold values of their declared types, but there will be situations where you'll <a id="_idIndexMarker129"/>need to combine variables of different types. In programming terminology, these are called conversions, and they come in two main flavors:</p>&#13;
    <ul>&#13;
      <li class="bullet"><strong class="keyword">Implicit</strong> conversions take <a id="_idIndexMarker130"/>place automatically, usually when a smaller value will fit into another variable <a id="_idIndexMarker131"/>type without any rounding. For example, any integer can be implicitly converted into a <code class="Code-In-Text--PACKT-">double</code> or <code class="Code-In-Text--PACKT-">float</code> value without additional code:&#13;
        <pre class="programlisting code"><code class="hljs-code">int MyInteger = 3;&#13;
float MyFloat = MyInteger;&#13;
 &#13;
Debug.Log(MyInteger);&#13;
Debug.Log(MyFloat);&#13;
</code></pre>&#13;
        <p class="bullet-para">The output in the <strong class="screenText">Console</strong> pane can be seen in the following screenshot:</p>&#13;
        <figure class="mediaobject"><img src="img/B17573_03_07.png" alt="" width="752" height="142"/></figure>&#13;
      </li>&#13;
    </ul>&#13;
    <p class="packt_figref">Figure 3.7: Implicit type conversion debug log output</p>&#13;
    <ul>&#13;
      <li class="bullet"><strong class="keyword">Explicit</strong> conversions are needed when there is a risk of losing a variable's information during the conversion. For example, if we wanted to convert a <code class="Code-In-Text--PACKT-">double</code> value into <a id="_idIndexMarker132"/>an <code class="Code-In-Text--PACKT-">int</code> value, we would have to explicitly cast (convert) it <a id="_idIndexMarker133"/>by adding the destination type in parentheses before the value we want to convert.</li>&#13;
      <li class="bullet">This tells the compiler that we are aware that data (or precision) might be lost:&#13;
        <pre class="programlisting code"><code class="hljs-code">int ExplicitConversion = (int)3.14;&#13;
</code></pre>&#13;
        <p class="bullet-para">In this explicit conversion, <code class="Code-In-Text--PACKT-">3.14</code> would be rounded down to <code class="Code-In-Text--PACKT-">3</code>, losing the decimal values:</p>&#13;
        <figure class="mediaobject"><img src="img/B17573_03_08.png" alt="" width="751" height="99"/></figure>&#13;
      </li>&#13;
    </ul>&#13;
    <p class="packt_figref">Figure 3.8: Explicit type conversion debug log output</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">C# provides built-in methods for explicitly converting values to common types. For example, any type can be <a id="_idIndexMarker134"/>converted into a string value with the <code class="Code-In-Text--PACKT-">ToString()</code> method, while the <code class="Code-In-Text--PACKT-">Convert</code> class can handle more complicated conversions. You can find more info about these features under the <em class="italic">Methods</em> section at <a href="https://docs.microsoft.com/en-us/dotnet/api/system.convert?view=netframework-4.7.2">https://docs.microsoft.com/en-us/dotnet/api/system.convert?view=netframework-4.7.2</a>.</p>&#13;
    </p>&#13;
    <p class="normal">So far, we've learned that types have rules regarding their interactions, operations, and conversion, but how do we handle a situation where we need to store a variable of an unknown type? This might sound crazy, but think about a data-download scenario—you know the information is coming into your game, but you're not sure what form it will take. We'll discuss how to handle this in the following section.</p>&#13;
    <h3 id="_idParaDest-62" class="title">Inferred declarations</h3>&#13;
    <p class="normal">Luckily, C# can <em class="italic">infer</em> a variable's type from its assigned value. For example, the <code class="Code-In-Text--PACKT-">var</code> keyword can let the <a id="_idIndexMarker135"/>program know that the type of the data, <code class="Code-In-Text--PACKT-">CurrentAge</code>, needs to be determined by its value of <code class="Code-In-Text--PACKT-">32</code>, which is an integer:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><strong class="hljs-keyword-slc">var</strong> CurrentAge = 32;&#13;
</code></pre>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">While this is handy in certain situations, don't be suckered into the lazy programming habit of using inferred variable declarations for everything. This adds a lot of guesswork to your code, where it should be crystal clear.</p>&#13;
    </p>&#13;
    <p class="normal">Before we wrap up our <a id="_idIndexMarker136"/>discussion on data types and conversion, we do need to briefly touch on the idea of creating custom types, which we'll do next.</p>&#13;
    <h3 id="_idParaDest-63" class="title">Custom types</h3>&#13;
    <p class="normal">When we're talking about data <a id="_idIndexMarker137"/>types, it's important to understand early on that numbers and words (referred to as <em class="italic">literal values</em>) are not the only kinds of values a variable <a id="_idIndexMarker138"/>can store. For instance, a class, struct, or enumeration can be stored as variables. We will introduce these topics in <em class="chapterRef">Chapter 5</em>, <em class="italic">Working with Classes, Structs, and OOP</em>, and explore them in greater detail in <em class="chapterRef">Chapter 10</em>, <em class="italic">Revisiting Types, Methods, and Classes</em>.</p>&#13;
    <p class="normal">Types are complicated, and the only way to get comfortable with them is by using them. However, here are some important things to keep in mind:</p>&#13;
    <ul>&#13;
      <li class="bullet">All variables need to have a specified type (be it explicit or inferred)</li>&#13;
      <li class="bullet">Variables can only hold values of their assigned type (a <code class="Code-In-Text--PACKT-">string</code> value can't be assigned an <code class="Code-In-Text--PACKT-">int</code> variable)</li>&#13;
      <li class="bullet">If a variable needs to be assigned or combined with a variable of a different type, a conversion needs to take place (either implicit or explicit)</li>&#13;
      <li class="bullet">The C# compiler can infer a variable's type from its value using the <code class="Code-In-Text--PACKT-">var</code> keyword, but should only be used when the type isn't known when it's created</li>&#13;
    </ul>&#13;
    <p class="normal">That's a lot of nitty-gritty detail we've just jammed into a few sections, but we're not done yet. We still need to understand how naming conventions work in C#, as well as where the variables live in our scripts.</p>&#13;
    <h2 id="_idParaDest-64" class="title">Naming variables</h2>&#13;
    <p class="normal">Picking names for your variables might seem like an afterthought in light of everything we've learned about <a id="_idIndexMarker139"/>access modifiers and types, but it shouldn't be a straightforward choice. Clear and consistent naming conventions in your code will not only make it more readable but will also ensure that other developers on your team understand your intentions without having to ask.</p>&#13;
    <p class="normal">The first rule when it comes to naming a variable is that the name you give it should be meaningful; the second <a id="_idIndexMarker140"/>rule is that you use Pascal case. Let's take a common example from games and declare a variable to store a player's health:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">public int Health = 100;&#13;
</code></pre>&#13;
    <p class="normal">If you find yourself declaring a variable like this, alarm bells should be going off in your head. Whose health? Is it storing the maximum or minimum value? What other code will be affected when this value changes? These are all questions that should be easily answered by a meaningful variable name; you don't want to find yourself confused by your code in a week or a month.</p>&#13;
    <p class="normal">With that said, let's try to make this a bit better using a Pascal case name:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">public int MaxPlayerHealth = 100;&#13;
</code></pre>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">Remember, Pascal case starts each word in the variable name with an uppercase letter.</p>&#13;
    </p>&#13;
    <p class="normal">That's much better. With a little thought, we've updated the variable name with meaning and context. Since there is no technical limit in terms of how long a variable name can be, you might find yourself going overboard and writing out ridiculously descriptive names, which will give you problems just as much as a short, non-descriptive name would.</p>&#13;
    <p class="normal">As a general rule, make a variable name as descriptive as it needs to be—no more, no less. Find your style and stick to it.</p>&#13;
    <h2 id="_idParaDest-65" class="title">Understanding variable scope</h2>&#13;
    <p class="normal">We're getting to the end of our dive into variables, but there's still one more important topic we need to cover: scope. Similar to access modifiers, which determine which outside classes can grab <a id="_idIndexMarker141"/>a variable's information, the variable scope is the term used to describe where a given variable exists and its access point within its containing class. </p>&#13;
    <p class="normal">There are three main levels of variable scope in C#:</p>&#13;
    <ul>&#13;
      <li class="bullet"><strong class="keyword">Global</strong> scope refers to a variable that can be accessed by an entire program; in this case, a game. C# doesn't directly <a id="_idIndexMarker142"/>support global variables, but the concept is useful in certain cases, which we'll cover in <em class="chapterRef">Chapter 10</em>, <em class="italic">Revisiting Types, Methods, and Classes.</em></li>&#13;
      <li class="bullet"><strong class="keyword">Class</strong> or <strong class="keyword">member</strong> scope refers <a id="_idIndexMarker143"/>to a variable that is accessible anywhere in its containing class.</li>&#13;
      <li class="bullet"><strong class="keyword">Local</strong> scope refers to a <a id="_idIndexMarker144"/>variable that is only accessible inside the specific block of code it's created in.</li>&#13;
    </ul>&#13;
    <p class="normal">Take a look at the <a id="_idIndexMarker145"/>following screenshot. You don't need to put this into <code class="Code-In-Text--PACKT-">LearningCurve</code> if you don't want to; it's only for visualization purposes at this point:</p>&#13;
    <figure class="mediaobject"><img src="img/B17573_03_09.png" alt="" width="828" height="340"/></figure>&#13;
    <p class="packt_figref">Figure 3.9: Diagram of different scopes in the LearningCurve script</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">When we talk about code blocks, we're referring to the area inside any set of curly brackets. These brackets serve as a kind of visual hierarchy in programming; the farther right-indented they are, the deeper they are nested in the class.</p>&#13;
    </p>&#13;
    <p class="normal">Let's break down the class and local scope variables in the preceding screenshot:</p>&#13;
    <ul>&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">CharacterClass</code> is declared at the very top of the class, which means we can reference it by <a id="_idIndexMarker146"/>name anywhere inside <code class="Code-In-Text--PACKT-">LearningCurve</code>. You might hear this concept referred to as variable visibility, which is a good way of thinking about it.</li>&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">CharacterHealth</code> is declared inside the <code class="Code-In-Text--PACKT-">Start()</code> method, which means it is only visible inside that <a id="_idIndexMarker147"/>block of code. We can still access <code class="Code-In-Text--PACKT-">CharacterClass</code> from <code class="Code-In-Text--PACKT-">Start()</code> with no issue, but if we attempted to access <code class="Code-In-Text--PACKT-">CharacterHealth</code> from anywhere but <code class="Code-In-Text--PACKT-">Start()</code>, we would get an error. </li>&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">CharacterName</code> is in the same <a id="_idIndexMarker148"/>boat as <code class="Code-In-Text--PACKT-">CharacterHealth</code>; it can only be accessed from the <code class="Code-In-Text--PACKT-">CreateCharacter()</code> method. This was just to illustrate that there can be multiple, even nested, local scopes in a single class.</li>&#13;
    </ul>&#13;
    <p class="normal">If you spend enough time around programmers, you'll hear discussions (or arguments, depending on the time of day) about the best place to declare a variable. The answer is simpler than you might <a id="_idIndexMarker149"/>think: variables should be declared with their use in mind. If you have a variable that needs to be accessed throughout a class, make it a class variable. If you only need a variable in a specific section of code, declare it as a local variable.</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">Note that only class variables can be viewed in the Inspector window, which isn't an option for local or global variables.</p>&#13;
    </p>&#13;
    <p class="normal">With naming and scope in our toolbox, let's transport ourselves back to middle school math class and relearn how arithmetic operations work all over again!</p>&#13;
    <h1 id="_idParaDest-66" class="title">Introducing operators</h1>&#13;
    <p class="normal">Operator symbols in programming languages represent the <em class="italic">arithmetic</em>, <em class="italic">assignment</em>, <em class="italic">relational</em>, and <em class="italic">logical</em> functionality that types can perform. Arithmetic operators represent basic math <a id="_idIndexMarker150"/>functions, while assignment operators perform math and assignment functions together on a given value. Relational and logical operators evaluate conditions between multiple values, such as <em class="italic">greater than</em>, <em class="italic">less than</em>, and <em class="italic">equal to</em>.</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">C# also offers bitwise and miscellaneous operators, but these won't come into play for you until you're well on your way to creating more complex applications.</p>&#13;
    </p>&#13;
    <p class="normal">At this point, it only makes sense to cover arithmetic and assignment operators, but we'll get to relational and logical functionality when it becomes relevant in the next chapter.</p>&#13;
    <h2 id="_idParaDest-67" class="title">Arithmetic and assignments</h2>&#13;
    <p class="normal">You're already familiar with<a id="_idIndexMarker151"/> the arithmetic operator symbols <a id="_idIndexMarker152"/>from school:</p>&#13;
    <ul>&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">+</code> for addition</li>&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">-</code> for subtraction</li>&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">/</code> for division</li>&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">*</code> for multiplication</li>&#13;
    </ul>&#13;
    <p class="normal">C# operators follow the conventional order of operations, that is, evaluating parentheses first, then <a id="_idIndexMarker153"/>exponents, then multiplication, then division, then addition, and finally subtraction. For instance, the following equations will provide different results, even though they contain the same values and operators:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">5 + 4 - 3 / 2 * 1 = 8&#13;
5 + (4 - 3) / 2 * 1 = 5&#13;
</code></pre>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">Operators work the same when applied to variables as they do with literal values.</p>&#13;
    </p>&#13;
    <p class="normal">Assignment<a id="_idIndexMarker154"/> operators can be used as a shorthand replacement for any math operation by using any arithmetic <a id="_idIndexMarker155"/>and equals symbol together. For example, if we wanted to multiply a variable, you could use the following code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">int CurrentAge = 32;&#13;
CurrentAge = CurrentAge * 2;&#13;
</code></pre>&#13;
    <p class="normal">The second, alternative, way to do this is shown here:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">int CurrentAge = 32;&#13;
CurrentAge *= 2;&#13;
</code></pre>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">The equals symbol is also considered an assignment operator in C#. The other assignment symbols follow the same syntax pattern as our preceding multiplication example: <code class="Code-In-Text--PACKT-">+=</code>, <code class="Code-In-Text--PACKT-">-=</code>, and <code class="Code-In-Text--PACKT-">/=</code> for add and assign, subtract and assign, and divide and assign, respectively.</p>&#13;
    </p>&#13;
    <p class="normal">Strings are a special case when it comes to operators as they can use the addition symbol to create patchwork text, as follows:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">string FullName = "Harrison " + "Ferrone";&#13;
</code></pre>&#13;
    <p class="normal">This will produce the following when logged in to the <strong class="screenText">Console</strong> panel:</p>&#13;
    <figure class="mediaobject"><img src="img/B17573_03_10.png" alt="" width="825" height="111"/></figure>&#13;
    <p class="packt_figref">Figure 3.10: Using operators on strings</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">This approach tends to produce clunky code, making string interpolation the preferred method for putting together different bits of text in most cases.</p>&#13;
    </p>&#13;
    <p class="normal">Take note that arithmetic operators don't work on all data types. For example, the <code class="Code-In-Text--PACKT-">*</code> and <code class="Code-In-Text--PACKT-">/</code> operators don't work on string values, and none of these operators work on Booleans. Having learned that types have rules that govern what kind of operations <a id="_idIndexMarker156"/>and interactions they can have, let's give it a shot in <a id="_idIndexMarker157"/>practice in the next section.</p>&#13;
    <p class="normal">Let's do a little experiment: we'll try to multiply our <code class="Code-In-Text--PACKT-">string</code> and <code class="Code-In-Text--PACKT-">float</code> variables together, as we did earlier with our numbers:</p>&#13;
    <figure class="mediaobject"><img src="img/B17573_03_11.png" alt="" width="826" height="219"/></figure>&#13;
    <p class="packt_figref">Figure 3.11: Visual Studio incorrect type operation error message</p>&#13;
    <p class="normal">Look at Visual<a id="_idIndexMarker158"/> Studio and you'll see we've got an error message letting us know that a <code class="Code-In-Text--PACKT-">string</code> type and a <code class="Code-In-Text--PACKT-">float</code> type can't be multiplied. This error will also show up in the Unity <strong class="screenText">Console</strong>, and won't let the project build. </p>&#13;
    <figure class="mediaobject"><img src="img/B17573_03_12.png" alt="" width="827" height="303"/></figure>&#13;
    <p class="packt_figref">Figure 3.12: Console showing operator errors on incompatible data types</p>&#13;
    <p class="normal">Whenever you see this type of error, go back and inspect your variable types<a id="_idIndexMarker159"/> for incompatibilities.</p>&#13;
    <p class="normal">We must clean up this example, as the compiler won't allow us to run our game at this point. Choose between a pair of backslashes (<code class="Code-In-Text--PACKT-">//</code>) at the beginning of the line <code class="Code-In-Text--PACKT-">Debug.Log(FirstName*Pi)</code>, or delete it altogether.</p>&#13;
    <p class="normal">That's as far as we need to go in terms of variables and types for the moment. Be sure to test yourself on this chapter's quiz before moving on!</p>&#13;
    <h1 id="_idParaDest-68" class="title">Defining methods</h1>&#13;
    <p class="normal">In the previous chapter, we briefly touched on the role methods play in our programs; namely, that they store <a id="_idIndexMarker160"/>and execute instructions, just like variables store values. Now, we need to understand the syntax of method declarations and how they drive action and behavior in our classes.</p>&#13;
    <p class="normal">As with variables, method declarations have their basic requirements, which are as follows:</p>&#13;
    <ul>&#13;
      <li class="bullet">The type of data that will be returned by the method</li>&#13;
      <li class="bullet">A unique name, starting with a capital letter</li>&#13;
      <li class="bullet">A pair of parentheses following the method name</li>&#13;
      <li class="bullet">A pair of curly brackets marking the method body (where instructions are stored)</li>&#13;
    </ul>&#13;
    <p class="normal">Putting all of these rules together, we get a simple method blueprint:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">returnType UniqueName() &#13;
{ &#13;
    method body &#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Let's break down <a id="_idIndexMarker161"/>the default <code class="Code-In-Text--PACKT-">Start()</code> method in <code class="Code-In-Text--PACKT-">LearningCurve</code> as a practical example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">void Start() &#13;
{&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">In the preceding output, we can see the following:</p>&#13;
    <ul>&#13;
      <li class="bullet">The method starts with the <code class="Code-In-Text--PACKT-">void</code> keyword, which is used as the method's return type if it doesn't return any data.</li>&#13;
      <li class="bullet">The method has a unique name within the class. You can use the same name in different classes, but you should aim to always make your names unique no matter what.</li>&#13;
      <li class="bullet">The method has a pair of parentheses after its name to hold any potential parameters.</li>&#13;
      <li class="bullet">The method body is defined by a set of curly brackets.</li>&#13;
    </ul>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">In general, if you have a method that has an empty method body, it's good practice to delete it from the class. You always want to be pruning your scripts of unused code.</p>&#13;
    </p>&#13;
    <p class="normal">Like variables, methods can also have security levels. However, they can also have input parameters, both of which we'll be discussing next!</p>&#13;
    <h2 id="_idParaDest-69" class="title">Declaring methods</h2>&#13;
    <p class="normal">Methods can also have the same four access modifiers that are available to variables, as well as input parameters. Parameters are variable placeholders that can be passed into methods and accessed <a id="_idIndexMarker162"/>inside them. The number of input parameters you can use isn't limited, but each one needs to be separated by a comma, show its data type, and have a unique name.</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">Think of method parameters as variable placeholders whose values can be used inside the method body. </p>&#13;
    </p>&#13;
    <p class="normal">If we apply these <a id="_idIndexMarker163"/>options, our updated blueprint will look like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><strong class="hljs-function-slc">accessModifier</strong> returnType UniqueName(<strong class="hljs-params-slc">parameterType parameterName</strong>) &#13;
{ &#13;
    method body &#13;
}&#13;
</code></pre>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">If there is no explicit access modifier, the method defaults to private. A private method, like a private variable, cannot be called from other scripts.</p>&#13;
    </p>&#13;
    <p class="normal">To call a method (meaning to run or execute its instructions), we simply use its name, followed by a pair of parentheses, with or without parameters, and cap it off with a semicolon:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">// Without parameters&#13;
UniqueName();&#13;
// With parameters&#13;
UniqueName(parameterVariable);&#13;
</code></pre>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">Like variables, every method has a fingerprint that describes its access level, return type, and parameters. This is called its method signature. Essentially, a method's signature marks it <a id="_idIndexMarker164"/>as unique to the compiler so Visual Studio knows what to do with it.</p>&#13;
    </p>&#13;
    <p class="normal">Now that we understand how methods are structured, let's create one of our own.</p>&#13;
    <p class="normal">The <em class="italic">Methods are placeholders too </em>section in the previous chapter had you blindly copy a method called <code class="Code-In-Text--PACKT-">ComputeAge()</code> into <code class="Code-In-Text--PACKT-">LearningCurve</code> without you knowing what you were getting into. This time, let's <a id="_idIndexMarker165"/>purposefully create a method:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Declare a <code class="Code-In-Text--PACKT-">public</code> method with a void return type called <code class="Code-In-Text--PACKT-">GenerateCharacter():</code>&#13;
        <pre class="programlisting code"><code class="hljs-code">public void GenerateCharacter() &#13;
{&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Add a simple <code class="Code-In-Text--PACKT-">Debug.Log()</code> inside the new method and print out a character name from your favorite game or movie:&#13;
        <pre class="programlisting code"><code class="hljs-code">Debug.Log("Character: Spike");&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Call <code class="Code-In-Text--PACKT-">GenerateCharacter()</code> inside the <code class="Code-In-Text--PACKT-">Start()</code> method and hit play:&#13;
        <pre class="programlisting code"><code class="hljs-code">void Start()&#13;
{&#13;
    <strong class="hljs-slc">GenerateCharacter();</strong>&#13;
}&#13;
</code></pre>&#13;
        <p class="bullet-para">When the game <a id="_idIndexMarker166"/>starts up, Unity automatically calls <code class="Code-In-Text--PACKT-">Start()</code>, which, in turn, calls our <code class="Code-In-Text--PACKT-">GenerateCharacter()</code> method and prints the result to the Console window.</p>&#13;
      </li>&#13;
    </ol>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">If you have read enough documentation, you'll see different terminology related to methods. Throughout the rest of this book, when a method is created or declared, I'll refer to this as <strong class="keyword">defining</strong> a method. Similarly, I'll refer to running or executing a method as <strong class="keyword">calling</strong> that method.</p>&#13;
    </p>&#13;
    <p class="normal">The power of naming is integral to the entirety of the programming landscape, so it shouldn't be a surprise that we're going to revisit naming conventions for methods before moving on.</p>&#13;
    <h2 id="_idParaDest-70" class="title">Naming conventions</h2>&#13;
    <p class="normal">Like variables, methods<a id="_idIndexMarker167"/> need unique, meaningful names to distinguish them in code. Methods drive actions, so it's a good practice to name them with that in mind. For example, <code class="Code-In-Text--PACKT-">GenerateCharacter()</code> sounds like a command, which reads well when you call it in a script, whereas a name such as <code class="Code-In-Text--PACKT-">Summary()</code> is bland and doesn't paint a very clear picture of what the method will accomplish. Like variables, method names are written in Pascal case.</p>&#13;
    <h2 id="_idParaDest-71" class="title">Methods as logic detours</h2>&#13;
    <p class="normal">We've seen that lines of code execute sequentially in the order they're written, but bringing methods <a id="_idIndexMarker168"/>into the picture introduces a unique situation. Calling a method tells the program to take a detour into the method instructions, run them one by one, and then resume sequential execution where the method was called.</p>&#13;
    <p class="normal">Take a look at the following screenshot and see whether you can figure out in what order the debug logs <a id="_idIndexMarker169"/>will be printed out to the console:</p>&#13;
    <figure class="mediaobject"><img src="img/B17573_03_13.png" alt="" width="827" height="255"/></figure>&#13;
    <p class="packt_figref">Figure 3.13: Considering the order of debug logs</p>&#13;
    <p class="normal">These are the steps that occur:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1"><code class="Code-In-Text--PACKT-">Choose a character</code> prints out first because it's the first line of code.</li>&#13;
      <li class="numbered">When <code class="Code-In-Text--PACKT-">GenerateCharacter()</code> is called, the program jumps to line 23, prints out <code class="Code-In-Text--PACKT-">Character: Spike</code>, and then resumes execution at line 17.</li>&#13;
      <li class="numbered"><code class="Code-In-Text--PACKT-">A fine choice</code> prints out last, after all the lines in <code class="Code-In-Text--PACKT-">GenerateCharacter()</code> have finished running.</li>&#13;
    </ol>&#13;
    <figure class="mediaobject"><img src="img/B17573_03_14.png" alt="" width="827" height="199"/></figure>&#13;
    <p class="packt_figref">Figure 3.14: Console showing the output of character building code</p>&#13;
    <p class="normal">Now, methods in themselves wouldn't be very useful beyond simple examples like these if we couldn't add parameter values to them, which is what we'll do next.</p>&#13;
    <h2 id="_idParaDest-72" class="title">Specifying parameters</h2>&#13;
    <p class="normal">Chances are your methods aren't <a id="_idIndexMarker170"/>always going to be as simple as <code class="Code-In-Text--PACKT-">GenerateCharacter()</code>. To pass in additional information, we'll need to define parameters that our method can accept and work with. Every method parameter is an instruction and needs to have two things:</p>&#13;
    <ul>&#13;
      <li class="bullet">An explicit type</li>&#13;
      <li class="bullet">A unique name</li>&#13;
    </ul>&#13;
    <p class="normal">Does this sound familiar? Method parameters are essentially stripped-down variable declarations and perform the same function. Each parameter acts like a local variable, only accessible inside their specific method.</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">You can have as many parameters as you need. Whether you're writing custom methods or using built-in ones, the parameters that are defined are what the method requires to perform its specified task.</p>&#13;
    </p>&#13;
    <p class="normal">If parameters are the blueprint for the types of values a method can accept, then arguments are the values themselves. To break this down further, consider the following:</p>&#13;
    <ul>&#13;
      <li class="bullet">The argument that's passed into a method needs to match the parameter type, just like a variable type and its value</li>&#13;
      <li class="bullet">Arguments can be literal values (for instance, the number 2) or variables declared elsewhere in the class</li>&#13;
    </ul>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">Argument names and parameter names don't need to match to compile.</p>&#13;
    </p>&#13;
    <p class="normal">Now, let's move on and add some method parameters to make <code class="Code-In-Text--PACKT-">GenerateCharacter()</code> a bit more interesting.</p>&#13;
    <p class="normal">Let's update <code class="Code-In-Text--PACKT-">GenerateCharacter()</code> so that it can take in two parameters:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Add two method parameters: one for a character's name of the <code class="Code-In-Text--PACKT-">string</code> type, and another for a character's level of the <code class="Code-In-Text--PACKT-">int</code> type:&#13;
        <pre class="programlisting code"><code class="hljs-code">public void GenerateCharacter(string name, int level)&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Update <code class="Code-In-Text--PACKT-">Debug.Log()</code> so that it uses these new parameters:&#13;
        <pre class="programlisting code"><code class="hljs-code">Debug.LogFormat("Character: {0} - Level: {1}", name, level);&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Update the <code class="Code-In-Text--PACKT-">GenerateCharacter()</code> method call in <code class="Code-In-Text--PACKT-">Start()</code> with your arguments, which can be either <a id="_idIndexMarker171"/>literal values or declared variables:&#13;
        <pre class="programlisting code"><code class="hljs-code">int CharacterLevel = 32;&#13;
GenerateCharacter("Spike", CharacterLevel);&#13;
</code></pre>&#13;
        <p class="bullet-para">Your code should look like the following:</p>&#13;
        <figure class="mediaobject"><img src="img/B17573_03_15.png" alt="" width="749" height="256"/></figure>&#13;
    <p class="packt_figref">Figure 3.15: Updating the GenerateCharacter() method</p>&#13;
      </li>&#13;
    </ol>&#13;
&#13;
    <p class="normal">Here, we defined two parameters, <code class="Code-In-Text--PACKT-">name</code> (string) and <code class="Code-In-Text--PACKT-">level</code> (int), and used them inside the <code class="Code-In-Text--PACKT-">GenerateCharacter()</code> method, just like local variables. When we called the method inside <code class="Code-In-Text--PACKT-">Start()</code>, we added argument values for each parameter with corresponding types. In the preceding screenshot, you can see that using the literal string value in quotations produced the same result as using <code class="Code-In-Text--PACKT-">characterLevel</code>.</p>&#13;
    <figure class="mediaobject"><img src="img/B17573_03_16.png" alt="" width="623" height="103"/></figure>&#13;
    <p class="packt_figref">Figure 3.16: Console showing the output from method parameters</p>&#13;
    <p class="normal">Going even further with methods, you might be wondering how we can pass values from inside the method and back out again. This brings us to our next section on return values.</p>&#13;
    <h2 id="_idParaDest-73" class="title">Specifying return values</h2>&#13;
    <p class="normal">Aside from accepting<a id="_idIndexMarker172"/> parameters, methods can return values of any C# type. All of our previous examples have used the <code class="Code-In-Text--PACKT-">void</code> type, which doesn't return anything, but being able to write instructions and pass back computed results is where methods shine. </p>&#13;
    <p class="normal">According to our blueprints, method return types are specified after the access modifier. In addition to the type, the method needs to contain the <code class="Code-In-Text--PACKT-">return</code> keyword, followed by the return value. A return value can be a variable, a literal value, or even an expression, as long as it matches the declared return type.</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">Methods that have a return type of <code class="Code-In-Text--PACKT-">void</code> can still use the return keyword with no value or expression assigned. Once the line with the return keyword is reached, the method will stop executing. This is useful in cases where you want to avoid certain behaviors or guard against program crashes. </p>&#13;
    </p>&#13;
    <p class="normal">Next, add a return type to <code class="Code-In-Text--PACKT-">GenerateCharacter()</code> and learn how to capture it in a variable. Let's update the <code class="Code-In-Text--PACKT-">GenerateCharacter()</code> method so that it returns an integer:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Change the return type in the method declaration from <code class="Code-In-Text--PACKT-">void</code> to <code class="Code-In-Text--PACKT-">int</code>, and set the return value to <code class="Code-In-Text--PACKT-">level += 5</code> using the <code class="Code-In-Text--PACKT-">return</code> keyword:&#13;
        <pre class="programlisting code"><code class="hljs-code">public <strong class="hljs-built_in-slc">int</strong> GenerateCharacter(string name, int level)&#13;
{&#13;
        Debug.LogFormat("Character: {0} - Level: {1}", name, level);&#13;
 &#13;
        <strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> level += </strong><strong class="hljs-number-slc">5</strong><strong class="hljs-slc">;</strong>&#13;
}&#13;
</code></pre>&#13;
        <p class="bullet-para"><code class="Code-In-Text--PACKT-">GenerateCharacter()</code> will now return an integer. This is computed by adding <code class="Code-In-Text--PACKT-">5</code> to the level argument. We haven't specified how, or if, we want to use this return value, which means that right now, the script won't do anything new. </p>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="normal">Now, the question becomes: how do we capture and use the newly added return value? Well, we'll discuss that very topic in the following section.</p>&#13;
    <h2 id="_idParaDest-74" class="title">Using return values</h2>&#13;
    <p class="normal">When it comes to using return values, there are two approaches available:</p>&#13;
    <ul>&#13;
      <li class="bullet">Create a local variable to capture (store) the returned value.</li>&#13;
      <li class="bullet">Use the calling <a id="_idIndexMarker173"/>method itself as a stand-in for the returned value, using it just like a variable. The calling method is the actual line of code that fires the instructions, which, in our example, would be <code class="Code-In-Text--PACKT-">GenerateCharacter("Spike", CharacterLevel)</code>. You can even pass a calling method into another method as an argument if need be.</li>&#13;
    </ul>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">The first option is preferred in most programming circles for its readability. Throwing around method calls as variables can get messy fast, especially when we use them as arguments in other methods.</p>&#13;
    </p>&#13;
    <p class="normal">Let's give this a try in our code by capturing and debugging the return value that <code class="Code-In-Text--PACKT-">GenerateCharacter()</code> returns.</p>&#13;
    <p class="normal">We're going to use both ways of capturing and using return variables with two simple debug logs:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Create a new local variable in the <code class="Code-In-Text--PACKT-">Start</code> method of the <code class="Code-In-Text--PACKT-">int</code> type, called <code class="Code-In-Text--PACKT-">NextSkillLevel</code>, and assign it to the return value of the <code class="Code-In-Text--PACKT-">GenerateCharacter()</code> method call we already have in place:&#13;
        <pre class="programlisting code"><code class="hljs-code">int NextSkillLevel = GenerateCharacter("Spike", CharacterLevel);&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Add two debug logs, with the first printing out <code class="Code-In-Text--PACKT-">NextSkillLevel</code> and the second printing out a new calling method with argument values of your choice:&#13;
        <pre class="programlisting code"><code class="hljs-code">Debug.Log(NextSkillLevel);&#13;
Debug.Log(GenerateCharacter("Faye", CharacterLevel));&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Comment out the debug log inside <code class="Code-In-Text--PACKT-">GenerateCharacter()</code> with two forward slashes (<code class="Code-In-Text--PACKT-">//</code>) to make the console output less cluttered. Your code should look like the following:&#13;
        <pre class="programlisting code"><code class="hljs-code">//  Start is called before the first frame update&#13;
void Start()&#13;
{&#13;
    int CharacterLevel = 32;&#13;
    int NextSkillLevel = GenerateCharacter("Spike", CharacterLevel);&#13;
    Debug.Log(NextSkillLevel);&#13;
    Debug.Log(GenerateCharacter("Faye", CharacterLevel));&#13;
}&#13;
public int GenerateCharacter(string name, int level)&#13;
{&#13;
    // Debug.LogFormat("Character: {0} – Level: {1}", name, level);&#13;
    return level += 5;&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Save the file and <a id="_idIndexMarker174"/>hit play in Unity. To the compiler, the <code class="Code-In-Text--PACKT-">NextSkillLevel</code> variable and the <code class="Code-In-Text--PACKT-">GenerateCharacter()</code> method caller represent the same information, namely an integer, which is why both logs show the number <code class="Code-In-Text--PACKT-">37</code>:<figure class="mediaobject"><img src="img/B17573_03_17.png" alt="" width="553" height="138"/></figure>&#13;
    <p class="packt_figref">Figure 3.17: Console output from the character generation code</p>&#13;
      </li>&#13;
    </ol>&#13;
&#13;
    <p class="normal">That was a lot to take in, especially given the exponential possibilities of methods with parameters and return values. However, we'll ease off the throttle here for a minute and consider some of Unity's most common methods to catch a little breathing room.</p>&#13;
    <p class="normal">But first, see if you can handle a challenge in the next <em class="italic">Hero's trial</em>!</p>&#13;
    <h3 id="_idParaDest-75" class="title">Hero's trial – methods as arguments</h3>&#13;
    <p class="normal">If you're feeling brave, why not try creating a new method that takes in an <code class="Code-In-Text--PACKT-">int</code> parameter and simply <a id="_idIndexMarker175"/>prints it out to the console? No return type is necessary. When you've got that, call the method in <code class="Code-In-Text--PACKT-">Start</code>, pass in a <code class="Code-In-Text--PACKT-">GenerateCharacter</code> method call as its argument, and take a look at the output.</p>&#13;
    <h2 id="_idParaDest-76" class="title">Dissecting common Unity methods</h2>&#13;
    <p class="normal">We're now at a point where we can realistically discuss the most common default methods that come with <a id="_idIndexMarker176"/>any new Unity C# script: <code class="Code-In-Text--PACKT-">Start()</code> and <code class="Code-In-Text--PACKT-">Update()</code>. Unlike the methods we define ourselves, methods belonging to the <code class="Code-In-Text--PACKT-">MonoBehaviour</code> class are called automatically by the Unity engine according to their respective rules. In most cases, it's important to have at least one <code class="Code-In-Text--PACKT-">MonoBehaviour</code> method in a script to kick off your code. </p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">You can find a complete <a id="_idIndexMarker177"/>list of all available MonoBehaviour methods and their descriptions at <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html">https://docs.unity3d.com/ScriptReference/MonoBehaviour.html</a>. You can also find the order in which each method is executed at <a href="https://docs.unity3d.com/Manual/ExecutionOrder.html">https://docs.unity3d.com/Manual/ExecutionOrder.html</a>.</p>&#13;
    </p>&#13;
    <p class="normal">Just like stories, it's always a good idea to start at the beginning. So, naturally, we should take a look at every Unity script's first default method—<code class="Code-In-Text--PACKT-">Start()</code>.</p>&#13;
    <h3 id="_idParaDest-77" class="title">The Start method</h3>&#13;
    <p class="normal">Unity calls the <code class="Code-In-Text--PACKT-">Start()</code> method on the first frame where a script is enabled for the first time. Since <code class="Code-In-Text--PACKT-">MonoBehaviour</code> scripts are almost always attached to <em class="italic">GameObjects</em> in a scene, their attached scripts <a id="_idIndexMarker178"/>are enabled at the same time they are loaded when you hit play. In our project, <code class="Code-In-Text--PACKT-">LearningCurve</code><em class="italic"> </em>is attached to the <strong class="keyword">Main Camera</strong> <em class="italic">GameObject</em>, which<a id="_idIndexMarker179"/> means that its <code class="Code-In-Text--PACKT-">Start()</code> method runs when the main camera is loaded into the scene. <code class="Code-In-Text--PACKT-">Start()</code> is primarily used to set up variables or perform logic that needs to happen before <code class="Code-In-Text--PACKT-">Update()</code> runs for the first time.</p>&#13;
    <p>&#13;
      <p class="Information-Box--PACKT-">The examples we've worked on so far have all used <code class="Code-In-Text--PACKT-">Start()</code>, even though they weren't performing setup actions, which isn't normally the way it would be used. However, it only fires once, making it an excellent tool to use for displaying one-time-only information on the console.</p>&#13;
    </p>&#13;
    <p class="normal">Other than <code class="Code-In-Text--PACKT-">Start()</code>, there's one other major Unity method that you'll run into by default: <code class="Code-In-Text--PACKT-">Update()</code>. Let's familiarize ourselves with how it works in the following section before we finish off this chapter.</p>&#13;
    <h3 id="_idParaDest-78" class="title">The Update method</h3>&#13;
    <p class="normal">If you spend <a id="_idIndexMarker180"/>enough time looking at the sample <a id="_idIndexMarker181"/>code in the <a id="_idIndexMarker182"/>Unity Scripting Reference (<a href="https://docs.unity3d.com/ScriptReference/">https://docs.unity3d.com/ScriptReference/</a>), you'll notice that a vast majority of the code is executed using the <code class="Code-In-Text--PACKT-">Update()</code> method. As your game runs, the Scene window <a id="_idIndexMarker183"/>is displayed many times per second, which is called the frame rate or <strong class="keyword">frames per second </strong>(<strong class="keyword">FPS</strong>).</p>&#13;
    <p class="normal">After each frame is displayed, the <code class="Code-In-Text--PACKT-">Update()</code> method is called by Unity, making it one of the most executed <a id="_idIndexMarker184"/>methods in your game. This makes it ideal for detecting mouse and keyboard input or running gameplay logic.</p>&#13;
    <p class="normal">If you're curious about the FPS rating on your machine, hit play in Unity and click the <strong class="screenText">Stats</strong> tab in the upper-right<a id="_idIndexMarker185"/> corner of the <strong class="screenText">Game</strong> view:</p>&#13;
    <figure class="mediaobject"><img src="img/B17573_03_18.jpg" alt="" width="827" height="299"/></figure>&#13;
    <p class="packt_figref">Figure 3.18: Unity editor showing the Stats panel with graphics FPS count</p>&#13;
    <p class="normal">You'll be using the <code class="Code-In-Text--PACKT-">Start()</code> and <code class="Code-In-Text--PACKT-">Update()</code> methods in the lion's share of your initial C# scripts, so get acquainted with them. That being said, you've reached the end of this chapter with a pocketful of the most fundamental building blocks programming with C# has to offer.</p>&#13;
    <h1 id="_idParaDest-79" class="title">Summary</h1>&#13;
    <p class="normal">This chapter has been a fast descent from the basic theory of programming and its building blocks into the strata of real code and C# syntax. We've seen good and bad forms of code formatting, learned how to debug information in the Unity console, and created our first variables.</p>&#13;
    <p class="normal">C# types, access modifiers, and variable scope weren't far behind, as we worked with member variables in the Inspector window and started venturing into the realm of methods and actions.</p>&#13;
    <p class="normal">Methods helped us to understand written instructions in code, but more importantly, how to properly harness their power into useful behaviors. Input parameters, return types, and method signatures are all important topics, but the real gift they offer is the potential for new kinds of actions to be performed.</p>&#13;
    <p class="normal">You're now armed with the two fundamental building blocks of programming; almost everything you'll do from now on will be an extension or application of these two concepts.</p>&#13;
    <p class="normal">In the next chapter, we'll take a look at a special subset of C# types called collections, which can store groups of related data, and learn how to write decision-based code.</p>&#13;
    <h1 id="_idParaDest-80" class="title">Pop quiz – variables and methods</h1>&#13;
    <ol>&#13;
      <li class="numbered" value="1">What is the proper way to write a variable name in C#?</li>&#13;
      <li class="numbered">How do you make a variable appear in Unity's Inspector window?</li>&#13;
      <li class="numbered">What are the four access modifiers available in C#?</li>&#13;
      <li class="numbered">When are explicit conversions needed between types?</li>&#13;
      <li class="numbered">What are the minimum requirements for defining a method?</li>&#13;
      <li class="numbered">What is the purpose of the parentheses at the end of the method name?</li>&#13;
      <li class="numbered">What does a return type of <code class="Code-In-Text--PACKT-">void</code> mean in a method definition?</li>&#13;
      <li class="numbered">How often is the <code class="Code-In-Text--PACKT-">Update()</code> method called by Unity?</li>&#13;
    </ol>&#13;
    <h1 class="heading-1">JOIN us on Discord!</h1>&#13;
    <p class="normal">Read this book alongside other users, Unity/C# experts, and Harrison Ferrone. Ask questions, provide solutions to other readers, chat with the author via <em class="italic">Ask Me Anything sessions</em> and much more.</p>&#13;
<p class="normal">Join Now! </p>&#13;
    <p class="normal"><a href="https://packt.link/csharpunity2021">https://packt.link/csharpunity2021</a></p>&#13;
    <p class="normal"><img style="height: 8em; width: auto;" src="img/QR_Code_9781801813945.png" alt="" width="354" height="354"/></p>&#13;
  </div>&#13;
</div></body></html>