- en: Chapter 12. F# and OOP Principles/Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previous chapters were aimed at developing and honing your taste for the usage
    patterns of functional programming, paying very occasional attention to comparison
    with OOP arrangements. This chapter caters to those of you who have an OOP background
    and may be anxiously expecting for the book to begin meticulously porting each
    and every one of the of **23 original Gang of Four object-oriented design patterns**
    ([https://en.wikipedia.org/wiki/Design_Patterns](https://en.wikipedia.org/wiki/Design_Patterns)
    ), one by one into F#.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: I may disappoint you, as all topics covered so far indicate that staying with
    the functional-first facet of F# promoted by the book may make some of these patterns
    just irrelevant, intrinsic, or ubiquitous. In other words, the original patterns
    may morph into something much less fundamental compared to their role in the OOP
    world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: A similar transformation applies to OOP principles, collectively known as **SOLID**
    ([https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design))
    ). That is, from a functional programming standpoint, these principles may become
    either granted, irrelevant, or just respected, without much extra effort required
    from developers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this chapter is to briefly demonstrate some cases of the morphing
    outlined in the preceding paragraphs. In this chapter, we will take a look at
    the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: How OOP SOLID principles get morphed within the functional-first paradigm, and
    what exactly happens to each of these five pillars
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How some of the specific design patterns (Command, Template, Strategy) diminish
    in role, or just become simply equivalent to bits and pieces of the functional-first
    paradigm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I will not attempt to lay out an exhaustive, thorough review. In the end, this
    book aims to develop skills and techniques of the functional-first paradigm, not
    any other paradigms supported by F#.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Morphing SOLID principles
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's consider how the functional programming paradigm morphs the five basic
    principles of the object-oriented design known under this bold acronym of **SOLID**
    .
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Single Responsibility Principle
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The gist of **Single Responsibility Principle** ([https://en.wikipedia.org/wiki/Single_responsibility_principle](https://en.wikipedia.org/wiki/Single_responsibility_principle)
    ) ( **SRP** ), standing for the letter "S" in **SOLID** , in OOP terms is:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '*"There should never be more than one reason for a class to change"*'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In other words, if a class implementation is to be changed in response to two
    or more independent modifications to a functionality, this is an evidence of the
    **Single Responsibility Principle** ( **SRP** ) violation in its design. Following
    this principle in the OOP world entails designs consisting of many lean classes
    in lieu of fewer but bulkier classes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'If we consider a function as a degenerate case of class free of encapsulated
    data and having only the single method, then this is nothing but a quintessence
    of SRP applied. The following figure illustrates this transformation:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![Single Responsibility Principle](img/Image00060.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: Honoring Single Responsibility Principle in functional programming
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: When we program in idiomatic F#, we compose the functions of a single purpose
    together. In other words, SRP is naturally promoted and enforced in F#.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Open/Closed Principle
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Open/Closed Principle** ([https://en.wikipedia.org/wiki/Open/closed_principle](https://en.wikipedia.org/wiki/Open/closed_principle)
    ) ( **OCP** ), representing the letter "O" in **SOLID** , states that:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '*"software entities (classes, modules, functions, etc.) should be open for
    extension, but closed for modification"*'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the pure OOP realm, such a property is granted by **inheritance** , both
    by direct **implementation inheritance** (that is, substituting a superclass with
    its subclass) and by **polymorphic implementation** (that is, just another implementation
    of a given interface that keeps itself closed to a modification but is open to
    additionally implementing other interfaces). Both of these forms of OCP are near,
    clear, and dear to the OOP facet of F#; however, they are not idiomatic to any
    extent. The functional-first mechanisms of extension in idiomatic F# are type
    augmentation and composition. The following figure serves as a cheat sheet here,
    as we have devoted a fair amount of attention in the book to these extension methods:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Open/Closed Principle](img/Image00061.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: Honoring Open/Closed Principle in functional programming
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The figure above shows in a very compelling manner how simple, succinct, and
    to the point the extensibility mechanics is within the functional-first idioms.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Liskov Substitution Principle
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The letter "L" in **SOLID** comes from **Liskov Substitution Principle** ([https://en.wikipedia.org/wiki/Liskov_substitution_principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle)
    ) ( **LSP** ) that states:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '*"objects in a program should be replaceable with instances of their subtypes
    without altering the correctness of that program"*'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As formulated **LSP** is concerned purely with OOP inheritance, it does not
    seem related to idiomatic F#. Nevertheless, I would mention at least the following
    three F# functional-first idioms that strongly enforce this principle:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '**Referential transparency** : If a function is pure and produces a certain
    result given an argument of type `T` , then given the corresponding instance of
    type `S` that is a subtype of `T` as an argument, it must produce the identical
    result indeed'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**F# function argument type substitution** : Based on what has been discussed
    in the preceding bullet point, if we have a type `''S` that derives from type
    `''T` , then an instance of `''S` can be used as a substitute for the corresponding
    instance of `''T` ; so for the following function `f` : `''T -> ''R` , expression
    `f(''S())` *does not require any coercion* of the argument, as the following snippet
    demonstrates (`Ch12_1.fsx` ):'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Immutability** : If we have built a valid immutable instance of `''S` , it
    cannot anyhow be invalidated by using it as a substitute for the instance of `''T`
    by the virtue of its immutability'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface Segregation Principle
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Standing for the letter "I" in **SOLID** , **Interface Segregation Principle**
    ([https://en.wikipedia.org/wiki/Interface_segregation_principle](https://en.wikipedia.org/wiki/Interface_segregation_principle)
    ) ( **ISP** ) claims that:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '*"many client-specific interfaces are better than one general-purpose interface"*'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In other words, an interface that a client is linked with should not introduce
    dependencies that are not used by the client. The **ISP** is just SRP being applied
    to interfaces. Idiomatic F# fully supports ISP by statelessness and naturally
    segregated functions representing interfaces that contain exactly one method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Inversion Principle
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The letter " **D** " in **SOLID** stands for **Dependency Inversion Principle**
    ([https://en.wikipedia.org/wiki/Dependency_inversion_principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)
    ) ( **DIP** ) stating:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '*"depend upon abstractions, do not depend upon concretions"*'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following figure shows how **DIP** is achieved in OOP: if an instance of
    class `A` refers the instance of class `B` , this is a direct dependency violating
    DIP. This problem may be fixed by making an instance of class `A` dependent on
    the interface `IB` . So far, so good, but something must implement `IB` , right?
    Let it be the instance of class `B` , which is now a dependent of `IB` , so the
    inversion of dependency takes place.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easy to notice that in idiomatic F#, the role of dependency inversion
    plays a vanilla higher-order function: for example, function `f` has a parameter
    function, `g`  which is used in defining `f` . When `f` is called, any of the
    argument functions `a` , `b` , or `c` may play the role of `g` as long as their
    signatures conform to `g` :'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![Dependency Inversion Principle](img/Image00062.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: Honoring Dependency Inversion Principle in functional programming
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Diminishing patterns
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similarly to **SOLID** principles, many OOP design patterns in the context of
    idiomatic functional-first F# either diminish (sometimes to the extent of disappearing)
    or significantly morph. Let's take a quick look at some instances of such transformation.
    I will be using samples taken from the code base I authored, implementing payment
    applications for Jet.com. Samples are somewhat simplified to align with the book
    format.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The Command design pattern
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Command Design Pattern** ([https://en.wikipedia.org/wiki/Command_pattern](https://en.wikipedia.org/wiki/Command_pattern)
    ) in OOP stands for a behavioral design pattern where all the information required
    to perform an action at a later time is encapsulated in an object. But wait a
    minute; doesn't this exactly coincide with what a function is? That's right; almost
    any idiomatic F# pattern of dealing with a higher-order function to traverse a
    data structure while applying a lower-order function to each element can be considered
    an occurrence of the Command pattern. Mapping, folding, you name it - all fit
    into this category. Doing what the Command pattern prescribes is an ubiquitous
    idiom in functional-first F#.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider an example: an order flow of a merchant participating in an
    e-commerce marketplace consists of transactions, each representing either **sale**
    or **refund** . By taking any continuous sequence of elements of the order flow,
    its running balance can be found. Now, the factor that makes things more interesting
    is that some orders may be nullified during an established period of time since
    their introduction being canceled. We are charged with tracking a running total
    for the marketplace finance department.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The functional-first aspect of F# allows for a very clean, idiomatic solution.
    I begin with two core domain objects, representing order types and customer transactions,
    combining the order type and its cost of goods (`Ch12_2.fsx` ):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'I continue with two core functions accounting for the total based on the order
    type:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Equipped with this, it is time to define our **commands** in the pattern''s
    sense. Both `Order` and `Cancellation` will take a running total and a transaction
    and return a new running total adjusted accordingly (note that `Cancellation`
    mirrors `Order` in terms of the total):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'I''m done! Let me just demonstrate the built code in action by applying it
    to a sample order flow in FSI. The results are presented in the following screenshot,
    where a sequence of some `orderFlow` transactions is run through orders yielding
    `totalForward` of $271.86 and then through cancelation, eventually yielding the
    expected running total `totalBackward` of $0.00:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![The Command design pattern](img/Image00063.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: Command pattern as idiomatic F# folding
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The Template design pattern
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Template design pattern** ([https://en.wikipedia.org/wiki/Template_method_pattern](https://en.wikipedia.org/wiki/Template_method_pattern)
    ) in OOP defines a common skeleton of an algorithm or a program, of which components
    can be overwritten but the general structure stays unchanged. Again, achieving
    this effect following the route that has functions as first class objects is trivial.
    For example, passing functions as parameters will work nicely, so the pattern
    diminishes to non-existing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Idiomatic F# is even richer than this approach, allowing functions to cohesively
    keep participating in an interface and providing any of the concrete implementations
    in the form of an object expression.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 惯用 F# 的方法甚至比这更丰富，它允许函数连贯地参与接口，并以对象表达式的形式提供任何具体的实现。
- en: 'Let''s turn to a corresponding code sample taken from the enterprise codebase
    of Jet.com payment applications. The process of paying a partner participating
    in the Jet.com marketplace consists of three consecutive steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向从 Jet.com 支付应用程序的企业代码库中提取的相应代码示例。在 Jet.com 市场中参与支付的合作伙伴的支付过程包括三个连续的步骤：
- en: Obtaining payment requisites and the amount due based on the merchant ID.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据商户 ID 获取支付需求和应付金额。
- en: Formatting a payment for the use of a specific payment method.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 格式化特定支付方式的支付。
- en: Submitting payment advice to the bank for execution.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向银行提交支付建议以执行。
- en: 'The template keeps the preceding parts together, allowing you to change each
    of the pieces to the case at the same time. As shown in the previous example,
    I begin with defining a few core domain entities (`Ch12_3.fsx` ):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '模板将前面的部分保持在一起，允许你同时更改每个部分以适应情况。正如前一个示例所示，我首先定义了一些核心领域实体 (`Ch12_3.fsx` ):'
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, `PayBy` represents a specific payment instrument (`Check` /`ACH` /`Wire`
    ), formatted `Payment` is just a type abbreviation, `BankReqs` represents a merchant's
    bank requisites for the account to accept the deposited payment, and `Merchant`
    wires together the merchant ID and bank requisites.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`PayBy` 代表一种特定的支付工具（支票/`ACH`/电汇），格式化的 `Payment` 只是一个类型缩写，`BankReqs` 代表商户的银行要求，以便账户接受存入的支付，而
    `Merchant` 将商户 ID 和银行要求连接起来。
- en: 'Now I define the template as an interface that reflects parts of the payment
    process being cohesive (`Ch12_3.fsx` ):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我定义了一个模板作为接口，它反映了支付流程的部分连贯性 (`Ch12_3.fsx` ):'
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This piece is quite straightforward; `GetPaymentDue` retrieves the given merchant's
    requisites and payment amount due from the relevant persisted store, `FormatPayment`
    performs the required payment advice formatting, and `SubmitPayment` takes care
    of delivering the advice to Jet's bank. Note that I intentionally didn't specify
    the payment format here as this detail may be delayed for the implementation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分相当直接；`GetPaymentDue` 从相关持久存储中检索给定商户的要求和应付金额，`FormatPayment` 执行所需的支付建议格式化，而
    `SubmitPayment` 负责将建议交付给 Jet 的银行。请注意，我故意没有在这里指定支付格式，因为这个细节可能需要延迟到实现阶段。
- en: 'Then, here, I provide a specific (mock) implementation for `ITemplate` . Still,
    you can see that this arrangement allows plenty of flexibility; in particular,
    I made a specific payment instrument a parameter of the implementation (`Ch12_3.fsx`
    ):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，在这里，我为 `ITemplate` 提供了一个具体的（模拟）实现。尽管如此，你可以看到这种安排提供了很大的灵活性；特别是，我将特定的支付工具作为实现的一个参数
    (`Ch12_3.fsx` ):'
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, I wrap everything together into the function using the template (`Ch12_3.fsx`
    ):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我使用模板将所有内容封装到函数中 (`Ch12_3.fsx` ):'
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As usual, in order to see this code in action, I turn to FSI, presenting the
    results of running some mock payments in the following screenshot. I''ve omitted
    the complete script source from here for the sake of fitting the figure within
    a single book page:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，为了看到这段代码的实际效果，我转向 FSI，展示了以下截图中的模拟支付结果。出于使图示适应单页书的考虑，我省略了完整的脚本源代码：
- en: '![The Template design pattern](img/Image00064.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![模板设计模式](img/Image00064.jpg)'
- en: Template pattern disappearing in idiomatic F#
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 模板模式在 F# 中的惯用表达消失
- en: The Strategy pattern
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略模式
- en: The **Strategy pattern** ([https://en.wikipedia.org/wiki/Strategy_pattern](https://en.wikipedia.org/wiki/Strategy_pattern)
    ) is simply about adjusting the algorithm behavior in runtime by implementing
    a family of algorithms and using them interchangeably. Once again, what could
    suit this purpose better than a functional-first setting with functions as first-class
    language citizens?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**策略模式** ([https://en.wikipedia.org/wiki/Strategy_pattern](https://en.wikipedia.org/wiki/Strategy_pattern)
    ) 简单来说，就是通过实现一系列算法并在运行时相互替换来调整算法的行为。再次强调，还有什么比将函数作为一等公民的功能优先设置更适合这个目的呢？'
- en: To illustrate the use of the Strategy pattern, I will use just another use case
    from Jet.com's Payment system. In its shipping operations, Jet.com uses multiple
    carriers, and due to the significant volume of shipments, it processes carrier
    invoices electronically. The gist of this processing is the loading of invoices
    from each carrier into a staging data table, and then merging the contents of
    this data table with corresponding persistent stores in the **upsert** ([https://en.wikipedia.org/wiki/Merge_(SQL)](https://en.wikipedia.org/wiki/Merge_(SQL))
    ) manner.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'I approach the implementation of this **EDI** ([https://en.wikipedia.org/wiki/Electronic_data_interchange](https://en.wikipedia.org/wiki/Electronic_data_interchange)
    ) by outlining the implementation of the core behavior first (`Ch12_4.fsx` ):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding snippet indicates that the supported invoice formats are either
    `Excel` or `CSV` , and there are two generic functions available to load invoices,
    somehow delivered to a location in any acceptable format, into a data table, and
    to merge the filled data table with the existing contents of the corresponding
    persistent store.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good; these two functions may be made accessible via an interface
    whose implementation is to be specific for each of the supported carriers (`Ch12_4.fsx`
    ):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, I provide specific implementations of the preceding interface for two
    of the carriers Jet.com engages into order shipments, namely FedEX and LaserShip
    (`Ch12_4.fsx` ):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now stay with me; we have two objects of the `ILoadVendorInvoices` type, each
    encapsulating its own carrier specifics. However, we can use them uniformly for
    EDI, as shown in the following function (`Ch12_4.fsx` ):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Just beautiful; now we can use instances of `LoadFedex` and `LoadLasership`
    to switch the behavior of EDI processing exactly in a manner the Strategy pattern
    prescribes. Let''s turn to FSI for the demonstration. The following screenshot
    shows the results:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![The Strategy pattern](img/Image00065.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: Strategy pattern expressed using F# idioms
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter highlighted that the functional-first approach does not blindly
    contradicts principles and patterns of object-oriented programming. Sometimes
    it also supports and amplifies them.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: I'm going to devote the final chapter of this book to the subject of troubleshooting
    functional-first code, as it has certain specifics.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
