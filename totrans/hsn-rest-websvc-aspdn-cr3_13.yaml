- en: Implementing the RESTful HTTP Layer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现RESTful HTTP层
- en: In the previous chapter, we learned how to deal with the logic of our web service
    in the `Catalog.Domain` project. This chapter will walk you through the HTTP part
    of the web service and all the components inside the `Catalog.API` project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何在 `Catalog.Domain` 项目中处理我们网络服务的逻辑。本章将向您介绍网络服务的 HTTP 部分，以及 `Catalog.API`
    项目中的所有组件。
- en: 'We will also demonstrate how to implement and test the controller part of a
    web service. By the end of the chapter, you will be able to implement, test, and
    validate HTTP routes using ASP.NET Core. We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将演示如何实现和测试网络服务的控制器部分。到本章结束时，您将能够使用 ASP.NET Core 实现、测试和验证 HTTP 路由。我们将涵盖以下主题：
- en: Implementing the HTTP layer of a service
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现服务的 HTTP 层
- en: Carrying out tests using the tools provided by ASP.NET Core
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ASP.NET Core 提供的工具进行测试
- en: Improving the resilience of the HTTP layer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高HTTP层的弹性
- en: 'The code presented in this chapter is available from the following GitHub repository:
    [https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的代码可以从以下 GitHub 仓库获取：[https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3).
- en: Implementing the item controller
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现项目控制器
- en: 'This section focuses on building the routes to read, writing the catalog data,
    and exposing the functionalities we already built in the domain layer using the
    HTTP protocol. Our controller will include the verbs listed in the following routing
    table:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点介绍构建读取、写入目录数据和使用 HTTP 协议公开我们在领域层中已构建的功能的路线。我们的控制器将包括以下路由表中列出的动词：
- en: '| **Verb** | **Path** | **Description** |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| **动词** | **路径** | **描述** |'
- en: '| `GET` | `/api/items` | Retrieves all the items present in our catalog |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/items` | 获取我们目录中存在的所有项目 |'
- en: '| `GET` | `/api/items/{id}` | Retrieves the item with the corresponding ID
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/items/{id}` | 获取具有相应 ID 的项目 |'
- en: '| `POST` | `/api/items/` | Creates a new item by taking the body payload of
    the request |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/api/items/` | 通过请求体有效载荷创建一个新的项目 |'
- en: '| `PUT` | `/api/items/{id}` | Updates the item with the corresponding ID |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `/api/items/{id}` | 更新具有相应 ID 的项目 |'
- en: 'The preceding routes allow web service consumers to get, add, and update the
    `Item` entities. Before starting the implementation, let''s look at an overview
    of the solution schema that we are going to implement:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 上述路由允许网络服务消费者获取、添加和更新 `Item` 实体。在开始实现之前，让我们看一下我们将要实现的解决方案架构概述：
- en: '![](img/d956dbc7-7b0d-4763-90fd-f7fa25b3b59f.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d956dbc7-7b0d-4763-90fd-f7fa25b3b59f.png)'
- en: 'In [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml), *Building the Data
    Access Layer,* and [Chapter 9](f8ac60e1-e948-4435-b804-e3e4ff305510.xhtml), *Implementing
    the Domain Logic,* we implemented and tested, respectively, the `Catalog.Infrastructure`
    and `Catalog.Domain` projects. This chapter focuses on the `Catalog.API` project.
    We are going to build and test the action methods that will call the service layer
    built in the `Catalog.Domain` project. Let''s start by defining a new controller
    in the `Controllers` folder of our `Catalog.API` project, named `ItemController`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml)，*构建数据访问层* 和 [第 9 章](f8ac60e1-e948-4435-b804-e3e4ff305510.xhtml)，*实现领域逻辑*
    中，我们分别实现了并测试了 `Catalog.Infrastructure` 和 `Catalog.Domain` 项目。本章重点介绍 `Catalog.API`
    项目。我们将构建并测试将调用在 `Catalog.Domain` 项目中构建的服务层的动作方法。让我们首先在 `Catalog.API` 项目的 `Controllers`
    文件夹中定义一个新的控制器，命名为 `ItemController`：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `ItemController` class will reflect the routes that we defined earlier.
    We should note that we decorated the controller class with the `Route` and `ApiController`
    attributes: the first specifies the base URL of the controller and the second
    provides some utilities and conventions on the responses type produced by the
    action methods. The controller will also use the `IItemService` interface to query
    and write data on our data source. We can use the `IItemService` interface to
    the `ItemController` class via the constructor injection:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemController` 类将反映我们之前定义的路由。我们应该注意，我们使用 `Route` 和 `ApiController` 属性装饰了控制器类：第一个指定了控制器的基
    URL，第二个为动作方法产生的响应类型提供了一些实用工具和约定。控制器还将使用 `IItemService` 接口来查询和写入我们的数据源。我们可以通过构造函数注入将
    `IItemService` 接口用于 `ItemController` 类：'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code uses dependency injection to add the `IItemService` class
    as a dependency of the `ItemController` class. Once we have added the `IItemService`
    interface, we can proceed by implementing the action methods of the controller.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用依赖注入将 `IItemService` 类添加为 `ItemController` 类的依赖项。一旦我们添加了 `IItemService`
    接口，我们就可以通过实现控制器中的操作方法来继续进行。
- en: Implementing action methods
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现操作方法
- en: We have already dealt with action methods in [Chapter 5](deede298-fc20-4523-afa6-02ed2c0592fd.xhtml),
    *Web Service Stack in ASP.NET Core*. In the following implementation, we will
    use the `IItemService` interface in the action methods, as follows*:*
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [第 5 章](deede298-fc20-4523-afa6-02ed2c0592fd.xhtml) 中处理了操作方法，*ASP.NET
    Core 中的网络服务堆栈*。在以下实现中，我们将在操作方法中使用 `IItemService` 接口，如下所示：*
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Get` and `GetById` action methods perform read operations by referring
    to the `IItemService` interface and calling the `GetItemsAsync` and `GetItemAsync`
    methods of the underlying service layer, in this case the `IItemService` interface.
    Let''s proceed by using the same approach to implement the `Post` and `Put` action
    methods of the controller:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get` 和 `GetById` 操作方法通过引用 `IItemService` 接口并调用底层服务层（在这种情况下是 `IItemService`
    接口）的 `GetItemsAsync` 和 `GetItemAsync` 方法来执行读取操作。让我们继续使用相同的方法来实现控制器的 `Post` 和 `Put`
    操作方法：'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Post` and `Put` actions use `AddItemRequest` and `EditItemRequest`, respectively,
    to bind data from the HTTP request and pass it through the `IItemService` interface.
    Under the hood, the `IItemService` implementation refers to `IItemMapper` to get
    back an entity from the request type and send it through the `IItemRepository`
    implementation. With the help of the dependency injection, we can easily loose
    couple the dependency between the different components. We should also note that
    the `Post` action method uses the `CreatedAtAction()` method exposed by `ControllerBase`
    to retrieve the location of the created resource as part of the response. Once
    we have bound the `IItemService` APIs into the `ItemController` action method,
    we can continue by testing the implementation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Post` 和 `Put` 动作分别使用 `AddItemRequest` 和 `EditItemRequest` 来绑定来自 HTTP 请求的数据，并通过
    `IItemService` 接口传递。在底层，`IItemService` 实现引用 `IItemMapper` 来从请求类型获取实体，并通过 `IItemRepository`
    实现发送。借助依赖注入，我们可以轻松地将不同组件之间的依赖解耦。我们还应该注意，`Post` 操作方法使用 `ControllerBase` 提供的 `CreatedAtAction()`
    方法来检索创建资源的位置作为响应的一部分。一旦我们将 `IItemService` API 绑定到 `ItemController` 操作方法中，我们就可以继续测试实现。'
- en: Testing controllers using the WebApplicationFactory<T> class
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 WebApplicationFactory<T> 类测试控制器
- en: 'The ASP.NET Core Framework provides a way to perform *integration tests* using
    the `WebApplicationFactory<T>` class. This class allows us to create a new `TestServer`
    that emulates a real HTTP server in a separate process. Therefore, it is possible
    to test our `ItemController` by calling it through an `HttpClient` instance provided
    by the factory. It is essential to note that `WebApplicationFactory` is a generic
    class and that it accepts a `TEntryPoint` type, which is represented by the `Startup`
    class of our web service. Before proceeding with the implementation of the test
    class, let''s create a new project in the `tests` folder that will contain all
    tests related to the `Catalog.API` project. Therefore, we can execute the following
    commands inside the `tests` folder:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 框架提供了一个使用 `WebApplicationFactory<T>` 类执行 *集成测试* 的方法。这个类允许我们创建一个新的
    `TestServer`，它在一个单独的进程中模拟真实的 HTTP 服务器。因此，我们可以通过调用由工厂提供的 `HttpClient` 实例来测试我们的
    `ItemController`。需要注意的是，`WebApplicationFactory` 是一个泛型类，它接受一个 `TEntryPoint` 类型，这由我们的网络服务的
    `Startup` 类表示。在继续实现测试类之前，让我们在 `tests` 文件夹中创建一个新的项目，该项目将包含与 `Catalog.API` 项目相关的所有测试。因此，我们可以在
    `tests` 文件夹中执行以下命令：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding commands add a new `Catalog.API.Tests` project into the `tests`
    folder of the solution, which refers to the `Catalog.Fixtures` and `Catalog.API`
    projects. The project is included in the solution file of the project. The next
    section describes how to extend the `WebApplicationFactory` class in order to
    support the execution of the web service.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令在解决方案的 `tests` 文件夹中添加了一个新的 `Catalog.API.Tests` 项目，它引用了 `Catalog.Fixtures`
    和 `Catalog.API` 项目。该项目包含在项目的解决方案文件中。下一节将描述如何扩展 `WebApplicationFactory` 类以支持执行网络服务。
- en: Extending the WebApplicationFactory
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 WebApplicationFactory
- en: 'The `WebApplicationFactory` class exposes set properties and methods that are
    useful for configuring the instance of the `TestServer` and for creating the proper
    tests fixture for our controllers. In addition, it is possible to extend `WebApplicationFactory`
    by overriding the `ConfigureWebHost` method and substituting the behavior of the
    *dependency injection services* declared in the original `Startup` class of the
    `Catalog.API` project. The `WebApplicationFactory` class is part of the `Microsoft.AspNetCore.Mvc.Testing`
    package; therefore, it is necessary to add the NuGet package to the `Catalog.Fixture`
    project and to the Catalog.API.Tests project by running the following commands
    in the tests folder of the project:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebApplicationFactory`类公开了用于配置`TestServer`实例和为我们的控制器创建适当测试固定值的属性和方法。此外，可以通过覆盖`ConfigureWebHost`方法并替换`Catalog.API`项目原始`Startup`类中声明的*依赖注入服务*的行为来扩展`WebApplicationFactory`。`WebApplicationFactory`类是`Microsoft.AspNetCore.Mvc.Testing`包的一部分；因此，有必要通过在项目的测试文件夹中运行以下命令将NuGet包添加到`Catalog.Fixture`项目和`Catalog.API.Tests`项目：'
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s proceed by creating a new `InMemoryWebApplicationFactory` class inside
    the `Catalog.Fixtures` project. The class will be used by the test classes to
    instantiate a new `TestServer` object. Therefore, the next step is to create a
    new `InMemoryWebApplicationFactory` class that extends the `WebApplicationFactory`
    base class and overrides the `ConfigureWebHost` method to inject the custom *in*-*memory*
    database provider:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在`Catalog.Fixtures`项目中创建一个新的`InMemoryWebApplicationFactory`类。该类将由测试类用于实例化一个新的`TestServer`对象。因此，下一步是创建一个新的`InMemoryWebApplicationFactory`类，它扩展了`WebApplicationFactory`基类并覆盖了`ConfigureWebHost`方法以注入自定义的*内存*数据库提供程序：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding `InMemoryApplicationFactory` class implements the `ConfigureWebHost`
    method, and it initializes an in-memory database using the `UseInMemoryDatabase`
    extension method. It also inserts a new instance of the `TestCatalogContext` class
    in the `CatalogContext` service registered using the dependency injection. Therefore,
    the tests will use the same in-memory database infrastructure we already used
    for the test cases implemented in the `Catalog.Infrastructure.Tests` and `Catalog.Domain.Tests`
    projects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的`InMemoryApplicationFactory`类实现了`ConfigureWebHost`方法，并使用`UseInMemoryDatabase`扩展方法初始化内存数据库。它还在使用依赖注入注册的`CatalogContext`服务中插入`TestCatalogContext`类的新实例。因此，测试将使用我们在`Catalog.Infrastructure.Tests`和`Catalog.Domain.Tests`项目中实现的测试用例所使用的相同内存数据库基础设施。
- en: Additionally, the `InMemoryApplicationFactory` implementation creates a new
    scope that will be used to execute the `EnsureCreated` method. Thus, each new
    instance of `InMemoryApplicationFactory` will generate the database from the same
    snapshot of data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`InMemoryApplicationFactory`实现创建了一个新作用域，该作用域将用于执行`EnsureCreated`方法。因此，每个新的`InMemoryApplicationFactory`实例将生成来自相同数据快照的数据库。
- en: Finally, the entire implementation is executed in the context of the `ConfigureTestServices`
    method, which provides a way to override the dependency injection services defined
    in the `Startup` class of the `Catalog.API` project.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，整个实现都在`ConfigureTestServices`方法中执行，该方法提供了一种覆盖`Catalog.API`项目`Startup`类中定义的依赖注入服务的方法。
- en: As mentioned in [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml), *Building
    the Data Access Layer*, the in-memory database is not always the preferred alternative,
    for two reasons. First, it doesn't reflect a real relational database with real
    constraints on the data. Secondly, it is tricky to deal with in-memory databases
    when multiple test methods use the same instance, since they may generate inconsistent
    data. For this reason, we are creating a new instance, using the `UseInMemoryDatabase(Guid.NewGuid().ToString());`
    statement, for each test class. The `Guid.NewGuid()` instruction guarantees uniqueness
    between the instances. In real-world applications, another common approach is
    to create a new instance of a temporary data source and recreate it after each
    test.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第8章](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml)中所述，*构建数据访问层*，内存数据库并不总是首选的替代方案，有两个原因。首先，它不能反映具有真实数据约束的真实关系数据库。其次，当多个测试方法使用相同的实例时，处理内存数据库很棘手，因为它们可能会生成不一致的数据。因此，我们为每个测试类创建一个新的实例，使用`UseInMemoryDatabase(Guid.NewGuid().ToString());`语句。`Guid.NewGuid()`指令保证了实例之间的唯一性。在实际应用中，另一种常见的方法是创建一个临时数据源的新实例，并在每次测试后重新创建它。
- en: Testing a controller
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试控制器
- en: 'Once we have implemented the `InMemoryApplicationFactory` class, it is possible
    to utilize it by implementing the `IClassFixture` interface in our test classes.
    Therefore, let''s start by initializing a new `ItemControllerTests` class in the
    `Catalog.API.Tests` project:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们实现了 `InMemoryApplicationFactory` 类，就可以通过在测试类中实现 `IClassFixture` 接口来利用它。因此，让我们首先在
    `Catalog.API.Tests` 项目中初始化一个新的 `ItemControllerTests` 类：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `ItemControllerTests` class provides remarkable test coverage for the action
    methods. First of all, the test class implements the generic `IClassFixture` interface
    provided by the `xUnit.Sdk` package. The `IClassFixture` interface refers to the
    previously defined `InMemoryApplicationFactory<Startup>` and it injects the new
    instance of the `factory` class into the constructor of the test classes. Consequently,
    a new instance of the `factory` will be provided for each test class executed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemControllerTests` 类为操作方法提供了显著的测试覆盖率。首先，测试类实现了由 `xUnit.Sdk` 包提供的通用 `IClassFixture`
    接口。`IClassFixture` 接口引用了之前定义的 `InMemoryApplicationFactory<Startup>`，并将 `factory`
    类的新实例注入到测试类的构造函数中。因此，对于每个执行的测试类，都将提供一个 `factory` 的新实例。'
- en: 'Let''s take a look at the test methods that cover the get operation of `ItemController`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看覆盖 `ItemController` 获取操作的测试方法：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding implementation uses the `CreateClient` method provided by `InMemoryApplicationFactory<Startup>`
    to initialize a new `HttpClient` instance. Therefore, if we take the `get_by_id_should_return_item_data`
    method as an example, it uses the client to call the `/api/items/{id}` route and
    checks that the information returned is not `null`. We can proceed by testing
    the add item operation by adding the following test methods to the `ItemControllerTests`
    class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 之前实现的代码使用了由 `InMemoryApplicationFactory<Startup>` 提供的 `CreateClient` 方法来初始化一个新的
    `HttpClient` 实例。因此，如果我们以 `get_by_id_should_return_item_data` 方法为例，它使用客户端调用 `/api/items/{id}`
    路由，并检查返回的信息不是 `null`。我们可以通过向 `ItemControllerTests` 类中添加以下测试方法来继续测试添加项目操作：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Consequently, we can choose a similar approach for the `Put` action method
    implemented in the controller:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以为控制器中实现的 `Put` 操作方法选择类似的方法：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `add_should_create_new_record` test method and the `update_should_modify_existing_item`
    method adopt the corresponding approach to test the `Post` and `Put` requests
    and the corresponding action methods. In this case, we are using the same request
    objects we defined for the `ItemServiceTests` and `ItemRepositoryTests` classes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_should_create_new_record` 测试方法和 `update_should_modify_existing_item` 方法采用了相应的策略来测试
    `Post` 和 `Put` 请求以及相应的操作方法。在这种情况下，我们使用了为 `ItemServiceTests` 和 `ItemRepositoryTests`
    类定义的相同请求对象。'
- en: We can proceed by executing the previously implemented tests by running the
    `dotnet test` command in the solution folder, or by using the test runner of our
    preferred IDE. Later in this next subsection, we will look at how to optimize
    the initialization of the request and hold the test data at a unique point.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在解决方案文件夹中运行 `dotnet test` 命令或使用我们首选 IDE 的测试运行器来执行之前实现的测试。在接下来的下一小节中，我们将探讨如何优化请求的初始化并在一个独特的点保持测试数据。
- en: 'Using `IClassFixture` implies that the same `InMemoryApplicationFactory` instance
    will be shared by all the test methods. Therefore, we will have the same underlying
    data for every test method. If we want to keep the tests fully isolated, we can
    avoid the use of the class fixture and initialize a new `InMemoryApplicationFactory`
    instance in the constructor of the test class:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `IClassFixture` 意味着相同的 `InMemoryApplicationFactory` 实例将由所有测试方法共享。因此，每个测试方法将具有相同的基本数据。如果我们想完全隔离测试，我们可以避免使用类固定装置，并在测试类的构造函数中初始化一个新的
    `InMemoryApplicationFactory` 实例：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This approach also guarantees isolation between every single test method implemented
    in the test class. Furthermore, the constructor will provide a new instance every
    time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法还保证了测试类中每个测试方法之间的隔离。此外，构造函数将在每次调用时提供一个新实例。
- en: Next, let's have a look at how to load test data using xUnit data attributes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用 xUnit 数据属性来加载测试数据。
- en: Loading test data using xUnit data attributes
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 xUnit 数据属性加载测试数据
- en: 'The *xUnit* framework is the preferred choice for testing .NET applications
    and services. The framework also provides some utilities to extend its capabilities
    and to implement a more maintainable testing code. It is possible to extend the
    `DataAttribute` class exposed by the `xUnit.Sdk` namespace to perform custom operations
    inside our attributes. For example, let''s suppose that we create a new custom
    `DataAttribute` to load test data from a file, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*xUnit* 框架是测试 .NET 应用程序和服务的首选选择。该框架还提供了一些工具来扩展其功能并实现更易于维护的测试代码。可以扩展 `xUnit.Sdk`
    命名空间公开的 `DataAttribute` 类以在属性内部执行自定义操作。例如，假设我们创建了一个新的自定义 `DataAttribute` 来从文件中加载测试数据，如下所示：'
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this scenario, the implementation decorates the test method using the `LoadData`
    attribute, which is reading an `item` section from a file. Therefore, we will
    have a JSON file that contains all the test records, and we will use the `LoadData`
    attribute to load one of them. To customize the behavior for the `ItemControllerTests`
    class, we should create a new class and extend the `DataAttribute` class provided
    by xUnit:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，实现使用 `LoadData` 属性装饰测试方法，该属性从文件中读取一个 `item` 部分。因此，我们将有一个包含所有测试记录的 JSON
    文件，我们将使用 `LoadData` 属性加载其中之一。为了为 `ItemControllerTests` 类自定义行为，我们应该创建一个新的类并扩展由
    xUnit 提供的 `DataAttribute` 类：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `LoadDataAttribute` class overrides `GetData(MethodInfo testMethod);`,
    which is supplied by the `DataAttribute` class, and it returns the data utilized
    by the test methods. The implementation of the `GetData` method reads the content
    of the file defined by the `_filePath` attribute; it tries to serialize the content
    of the specified `section` of the file into a generic `object`. Finally, the implementation
    calls the `ToObject` method to convert the generic `JObject` into the type associated
    with the first parameter of the test method. The last step in the process is to
    create a new JSON file called `record-data.json` in the `Catalog.API.Tests` project.
    The file will contain the test data used by our tests:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadDataAttribute` 类重写了由 `DataAttribute` 类提供的 `GetData(MethodInfo testMethod);`
    方法，并返回测试方法使用的数据。`GetData` 方法的实现读取由 `_filePath` 属性定义的文件内容；它尝试将文件指定的 `section` 的内容序列化为一个泛型
    `object`。最后，实现调用 `ToObject` 方法将泛型 `JObject` 转换为与测试方法第一个参数关联的类型。该过程最后一步是在 `Catalog.API.Tests`
    项目中创建一个新的名为 `record-data.json` 的 JSON 文件。该文件将包含我们测试使用的测试数据：'
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The JSON snippet has the following fields: `item`, `artist`, and `genre`. The
    fields contain data related to the test entities. Therefore, we will use them
    to deserialize the data into the request models and into the entity types. Consequently,
    we can apply the `LoadData` attribute to the `ItemControllerTests` class in the
    following way:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 片段包含以下字段：`item`、`artist` 和 `genre`。这些字段包含与测试实体相关的数据。因此，我们将使用它们将数据反序列化到请求模型和实体类型中。因此，我们可以将
    `LoadData` 属性应用于以下方式的 `ItemControllerTests` 类：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, the test methods accept a `request` parameter of the `Item`, `EditItemRequest`,
    or `AddItemRequest` type, which will contain the data provided by the `record-data.json`
    file. Then, the object is serialized into the `request` parameter and sent using
    the `HttpClient` instance supplied by the `InMemoryApplicationFactory`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试方法接受一个 `Item`、`EditItemRequest` 或 `AddItemRequest` 类型的 `request` 参数，该参数将包含由
    `record-data.json` 文件提供的数据。然后，该对象被序列化为 `request` 参数，并通过 `InMemoryApplicationFactory`
    提供的 `HttpClient` 实例发送：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`LoadData` serializes the content defined in the `record-data.json` file into
    the `AddItemRequest` type. The request is then serialized as `StringContent` and
    posted using the HTTP client created by the factory. Finally, the method asserts
    that the resultant code is successful and the `Location` header is not `null`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadData` 将 `record-data.json` 文件中定义的内容序列化为 `AddItemRequest` 类型。然后，请求被序列化为
    `StringContent` 并通过工厂创建的 HTTP 客户端发送。最后，该方法断言结果代码是成功的，并且 `Location` 标头不是 `null`。'
- en: We can now verify the behavior of the `ItemController` class by executing the
    `dotnet test` command in the root of the solution, or by running the test runner
    provided by our preferred IDE.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过在解决方案根目录中执行 `dotnet test` 命令，或者通过运行我们首选 IDE 提供的测试运行器来验证 `ItemController`
    类的行为。
- en: In conclusion, now we are able to define the test data in a unique central JSON
    file. In addition to this, we can add as much data as we want by adding new sections
    to the JSON file. The next part of this section will focus on improving the resilience
    of the APIs by adding some existence checks and handling exceptions using filters.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，现在我们能够在一个独特的中央JSON文件中定义测试数据。除此之外，我们还可以通过向JSON文件添加新的部分来添加尽可能多的数据。本节接下来的部分将专注于通过添加一些存在性检查和处理异常使用过滤器来提高API的弹性。
- en: Improving the resilience of the API
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高API的弹性
- en: The previous sections show a possible implementation of `ItemController` class
    and how to test it using the tools provided by ASP.NET Core. In this section,
    we will learn how to improve the resilience of our service by performing some
    *restriction checks* on the information exposed by the `ItemController`. Additionally,
    we will look at how to present validation errors and how to paginate returned
    data. This section will apply the concepts explained in the previous chapters
    to the web service project.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节展示了`ItemController`类的可能实现以及如何使用ASP.NET Core提供的工具对其进行测试。在本节中，我们将学习如何通过在`ItemController`公开的信息上执行一些*限制检查*来提高我们服务的弹性。此外，我们还将探讨如何展示验证错误以及如何分页返回的数据。本节将应用前几章中解释的概念到Web服务项目中。
- en: Existence check
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存在性检查
- en: 'Let''s start by implementing the action filter that performs an existence check
    on the requested data. The filter will be used by the action methods that get
    or edit a single item. As seen in [Chapter 7](13fd7d18-3ebe-4f60-89ff-4666d1c9671a.xhtml),
    *Filter Pipeline*, we are going to implement the following filter:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先实现一个执行请求数据存在性检查的动作过滤器。该过滤器将被用于获取或编辑单个项的动作方法。如[第7章](13fd7d18-3ebe-4f60-89ff-4666d1c9671a.xhtml)中所述的*过滤器管道*，我们将实现以下过滤器：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The action filter resolves the `IItemService` interface in the constructor
    and uses the injected instance to verify the existence of the entity using the
    `id` present in the request. If the request contains a valid `Guid id`, and the
    `id` exists in our data source, the `OnActionExecutionAsync` method proceeds by
    calling the `await next()` method to continue the pipeline. Otherwise, it stops
    the pipeline and returns a `NotFoundObjectResult` instance. We can apply a filter
    to the action methods of `ItemController` by adding the `[ItemExists]` attribute:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 动作过滤器在构造函数中解析`IItemService`接口，并使用注入的实例通过请求中存在的`id`验证实体的存在。如果请求包含有效的`Guid id`，并且`id`存在于我们的数据源中，`OnActionExecutionAsync`方法将通过调用`await
    next()`方法继续管道。否则，它将停止管道并返回一个`NotFoundObjectResult`实例。我们可以通过添加`[ItemExists]`属性来将过滤器应用于`ItemController`的动作方法：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After applying the `ItemExists` attribute, the API will return 404 if the ID
    sent by the request doesn''t exist. We can also verify the logic implemented in
    the action filter by injecting a mock instance of the `IItemService` interface
    and making some assertions about the resulting response. In the following test
    class, we will use `Moq` to verify the call to the `next()` method. As a first
    step, we need to add `Moq` to the `Catalog.API.Tests` project by using the following
    command inside the project folder:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用了`ItemExists`属性后，如果请求发送的ID不存在，API将返回404。我们还可以通过注入`IItemService`接口的模拟实例并对结果响应进行一些断言来验证在动作过滤器中实现的逻辑。在下面的测试类中，我们将使用`Moq`来验证对`next()`方法的调用。作为第一步，我们需要在项目文件夹内使用以下命令将`Moq`添加到`Catalog.API.Tests`项目中：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Furthermore, we can proceed by defining the `ItemExistsAttributeTests` class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以继续定义`ItemExistsAttributeTests`类：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding `ItemExistsAttributeTests` class mocks the whole `IItemService`
    interface to simulate the response of the `GetItemAsync` method. Then, it initializes
    `ItemExistsAttribute` by injecting the mocked `IItemService` interface. Finally,
    it calls the `OnActionExecutionAsync` method exposed by the `filter` class and
    it combines the result with the `Verify` method provided by the `Moq` framework
    to check that the `ItemExistsFilter` class correctly calls the `next()` callback
    method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`ItemExistsAttributeTests`类中，我们模拟了整个`IItemService`接口以模拟`GetItemAsync`方法的响应。然后，它通过注入模拟的`IItemService`接口初始化`ItemExistsAttribute`。最后，它调用由`filter`类公开的`OnActionExecutionAsync`方法，并将其与`Moq`框架提供的`Verify`方法结合使用，以检查`ItemExistsFilter`类是否正确调用了`next()`回调方法。
- en: JSON-customized errors
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON自定义错误
- en: The customization and serialization of the exceptions is a helpful way to simplify
    *error handling* and improve the monitoring of the web service*.* These techniques
    are sometimes necessary for communicating exceptions to a client so that errors
    can be handled and managed. In general, while the *HTTP status code* provides
    summary information about the status of the request, the content of the response
    provides more detailed information about the error.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 异常的自定义和序列化是简化*错误处理*和改进Web服务监控的有用方法*.* 这些技术有时对于将异常传达给客户端以处理和管理错误是必要的。一般来说，虽然*HTTP状态码*提供了关于请求状态的摘要信息，但响应内容提供了关于错误的更详细信息。
- en: 'It is possible to extend the error handling behavior using filters. First of
    all, let''s create a new standard model that represents an error result:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用过滤器扩展错误处理行为是可能的。首先，让我们创建一个新的标准模型来表示错误结果：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding class is under the `Filters` folder structure. It contains an
    `EventId` attribute and a `DetailedMessage` of an `object` type. Secondly, we
    should continue by implementing a new filter that extends the `IExceptionFilter`
    interface. The filter will be triggered when an exception is raised, and it will
    modify the content of the response returned to the client:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类位于`Filters`文件夹结构下。它包含一个`EventId`属性和一个`DetailedMessage`，类型为`object`。其次，我们应该继续实现一个新的过滤器，该过滤器扩展了`IExceptionFilter`接口。当引发异常时，该过滤器将被触发，并将修改返回给客户端的响应内容：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code implements the `IExceptionFilter` interface. The class contains
    the definition of the constructor used to inject some of the dependencies of the
    filter. It also contains the `OnException` method, which initializes a new `JsonErrorPayload`
    object populated with the `eventId` field and the content of the message contained
    in the exception. Depending on the environment, take a look at the `IsDevelopment()`
    check; it also populates the resulting exception object with a detailed error
    message. Finally, the `OnException` method uses the `HttpContext`, defined as
    a parameter, to set the `HttpStatusCode.InternalServerError`, and to add `exceptionObject`
    previously created as a result of the execution. This approach guarantees to handle
    exception in a unique way, by centralizing the serialization and the resulting
    message format of all the errors returned by the web service.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码实现了`IExceptionFilter`接口。该类包含用于注入过滤器依赖项的一些构造函数的定义。它还包含`OnException`方法，该方法初始化一个新的`JsonErrorPayload`对象，该对象包含`eventId`字段和异常中包含的消息内容。根据环境，查看`IsDevelopment()`检查；它还向结果异常对象填充详细的错误消息。最后，`OnException`方法使用定义为参数的`HttpContext`来设置`HttpStatusCode.InternalServerError`，并添加之前创建的`exceptionObject`作为执行结果。这种方法保证了以独特的方式处理异常，通过集中序列化和所有由Web服务返回的错误的结果消息格式。
- en: Implementing pagination
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现分页
- en: Pagination is another essential feature of APIs. `Get` operations usually return
    a significant number of records and information. Sometimes, it is necessary to
    implement pagination to avoid a large response size.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 分页是API的另一个基本功能。`Get`操作通常返回大量记录和信息。有时，实现分页以避免大响应大小是必要的。
- en: If your APIs are exposed to external clients, it is essential to reduce the
    response size when possible. Additionally, it could be that the client stores
    information in the memory of a device, such as a smartphone or an IoT device,
    that has limited memory.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的API暴露给外部客户端，在可能的情况下减少响应大小是至关重要的。此外，客户端可能将信息存储在具有有限内存的设备内存中，例如智能手机或物联网设备。
- en: 'Let''s take a look at how to implement maintainable and reusable pagination
    in the `ItemController` class. First of all, we need to create a new pagination
    response model that represents the requested page. We can create a new `PaginatedItemResponseModel.cs`
    file in the `ResponseModels` folder inside the `Catalog.API` project, using the
    following content:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在`ItemController`类中实现可维护和可重用的分页。首先，我们需要创建一个新的分页响应模型来表示请求的页面。我们可以在`Catalog.API`项目中的`ResponseModels`文件夹内创建一个新的`PaginatedItemResponseModel.cs`文件，内容如下：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `PaginatedItemsResponseModel` function accepts a generic model, and it
    represents a paginated response type. It also implements some properties related
    to the page, such as `PageIndex`, `PageSize`, and `Total`. Additionally, it includes
    an `IEnumerable` interface that represents the records returned by the response.
    The next step is to change the `Get` action method that is already present in
    the `ItemController` class, as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`PaginatedItemsResponseModel`函数接受一个泛型模型，它表示分页响应类型。它还实现了与页面相关的某些属性，例如`PageIndex`、`PageSize`和`Total`。此外，它包括一个`IEnumerable`接口，表示响应返回的记录。下一步是更改`ItemController`类中已经存在的`Get`操作方法，如下所示：'
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We changed the `Get` action method to implement pagination. First of all, note
    that the method receives some parameters related to pagination: the `pageSize`
    and `pageIndex` parameters. Secondly, it executes `IItemService` to get the related
    records and performs a LINQ query to take only the elements of the selected page.
    Finally, it instantiates a new `PaginatedItemsResponseModel<ItemResponse>` with
    the metadata related to the page and the data, and returns the instance.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Get`操作方法更改为实现分页。首先，请注意，该方法接收一些与分页相关的参数：`pageSize`和`pageIndex`参数。其次，它执行`IItemService`以获取相关记录并执行LINQ查询以仅获取所选页面的元素。最后，它使用与页面和数据相关的元数据实例化一个新的`PaginatedItemsResponseModel<ItemResponse>`，并返回该实例。
- en: 'We can cover the implementation using the unit tests by changing the already
    existing `ItemsControllerTests` file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更改现有的`ItemsControllerTests`文件来使用单元测试来覆盖实现：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `should_get_item_using_pagination` test case uses the `InlineData` attribute
    to test some pagination routes. It calls the `Get` action method, serializes the
    result into a `PaginatedItemsResponseModel<ItemResponse>`, and, finally, it checks
    the results.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`should_get_item_using_pagination`测试用例使用`InlineData`属性来测试一些分页路由。它调用`Get`操作方法，将结果序列化为`PaginatedItemsResponseModel<ItemResponse>`，最后检查结果。'
- en: Although the pagination implementation technique examined in this chapter provides
    some performance benefits, it doesn't limit the interaction between our service
    and the database. To extend the performance benefits to the data source of the
    service as well, we should consider implementing an ad-hoc query to paginate data
    directly from our data source.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章中检查的分页实现技术提供了一些性能优势，但它并没有限制我们的服务与数据库之间的交互。为了将性能优势扩展到服务的数据源，我们应该考虑实现一个专门查询，直接从我们的数据源分页数据。
- en: In the next section, we will continue our journey by extending the APIs in order
    to also handle related entities. For now, notice that we are exposing the information
    of the `Item`, `Artist`, and `Genre` entities, without managing the related entities
    and we are not exposing any route to edit the `Artist` and `Genre` entities.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续我们的旅程，通过扩展API来处理相关实体。目前，请注意，我们正在暴露`Item`、`Artist`和`Genre`实体的信息，而不管理相关实体，并且我们没有暴露任何编辑`Artist`和`Genre`实体的路由。
- en: Exposing related entities
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露相关实体
- en: 'At the moment, the current implementation in the `Catalog.API` project allows
    us to read, and modify the `Item` entity and its relationship with the `Genre`
    and `Artist` entities. In this section, we will enable a client to list and add
    the `Genre` and `Artist` entities. Therefore, we will extend the APIs that allow
    a client to interact with these entities. This implementation requires us to act
    on the full stack of the web service; additionally, it involves the `Catalog.Infrastructure`,
    the `Catalog.Domain`, and the `Catalog.API` projects. Before we begin, let''s
    take a look at the routes we are going to implement:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`Catalog.API`项目中的当前实现允许我们读取和修改`Item`实体及其与`Genre`和`Artist`实体的关系。在本节中，我们将使客户端能够列出和添加`Genre`和`Artist`实体。因此，我们将扩展允许客户端与这些实体交互的API。此实现要求我们对整个网络服务栈采取行动；此外，它还涉及`Catalog.Infrastructure`、`Catalog.Domain`和`Catalog.API`项目。在我们开始之前，让我们看看我们将要实现的路由：
- en: '| **Verb** | **Path** | **Description** |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **动词** | **路径** | **描述** |'
- en: '| `GET` | `/api/artists` | Retrieves all the artists present in the database
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/artists` | 获取数据库中所有存在的艺术家 |'
- en: '| `GET` | `/api/artist/{id}` | Retrieves the artist with the corresponding
    ID |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/artist/{id}` | 获取具有相应ID的艺术家 |'
- en: '| `GET` | `/api/artist/{id}/items/` | Retrieves the items with the corresponding
    artist ID |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/artist/{id}/items/` | 获取与相应艺术家ID对应的物品 |'
- en: '| `POST` | `/api/artist/` | Creates a new artist and retrieves it |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/api/artist/` | 创建一个新的艺术家并检索它 |'
- en: 'In the same way, we will get the corresponding routes for the `Genre` entity
    as well:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将为`Genre`实体获取相应的路由：
- en: '| **Verb** | **Path** | **Description** |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **动词** | **路径** | **描述** |'
- en: '| `GET` | `/api/genre` | Retrieves all the genres present in the database |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/genre` | 获取数据库中存在的所有流派 |'
- en: '| `GET` | `/api/genre/{id}` | Retrieves the genre with the corresponding ID
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/genre/{id}` | 获取具有相应ID的流派 |'
- en: '| `GET` | `/api/genre/{id}/items/` | Retrieves the items with the corresponding
    genre ID |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/genre/{id}/items/` | 获取具有相应流派ID的项目 |'
- en: '| `POST` | `/api/genre/` | Creates a new genre and retrieves it |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/api/genre/` | 创建一个新的流派并获取它 |'
- en: 'The routes mentioned in the previous tables provide a way to interact with
    the `Genre` and `Artist` entities. The implementation of these features will follow
    the same approach used by the item entity we have seen in the previous sections.
    Before proceeding, we need to extend the `CatalogContext` class by adding the
    attributes that represent the `Artist` and `Genre` entities:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前表中提到的路由提供了一种与`Genre`和`Artist`实体交互的方式。这些功能的实现将遵循我们在前几节中看到的项实体所使用的相同方法。在继续之前，我们需要通过添加代表`Artist`和`Genre`实体的属性来扩展`CatalogContext`类：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now `CatalogContext` also handles the `Artists` and `Genres` entities through
    the use of the `modelBuilder.ApplyConfiguration` method. In the next subsection,
    we will extend the implementation of the data access layer through the use of
    the `Repositories` classes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`CatalogContext`也通过使用`modelBuilder.ApplyConfiguration`方法处理`Artists`和`Genres`实体。在下一个小节中，我们将通过使用`Repositories`类扩展数据访问层的实现。
- en: Extending the data access layer
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展数据访问层
- en: 'In order to extend our APIs with the related entities, we should start from
    the bottom of our stack. First of all, let''s spread the capabilities of the data
    access layer by adding the following interfaces in the `Repositories` folder of
    the `Catalog.Domain` project:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展我们的API以包含相关实体，我们应该从我们的堆栈底部开始。首先，让我们通过在`Catalog.Domain`项目的`Repositories`文件夹中添加以下接口来扩展数据访问层的功能：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Both the `IArtistRepository` and `IGenreRepository` interfaces reflect the
    routes initially defined in this section: the `GetAsync` method returns the list
    of the secondary entities, the `GetAsync(Guid id)` returns the single object,
    and the `Add` method allows us to create a new entity. We can now define the actual
    implementations of the specified interfaces. Likewise, the `ItemRepository` class
    implementations will be stored in the `Catalog.Infrastructure` project:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`IArtistRepository`和`IGenreRepository`接口反映了本节最初定义的路由：`GetAsync`方法返回次要实体的列表，`GetAsync(Guid
    id)`返回单个对象，而`Add`方法允许我们创建新实体。我们现在可以定义指定接口的实际实现。同样，`ItemRepository`类的实现将存储在`Catalog.Infrastructure`项目中：'
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code defines the `ArtistRepository` type and provides the implementation
    for the `IArtistRepository` interface. The class uses `CatalogContext` as a communication
    hub between our application and the SQL database. The `GetAsync` and `GetAsync(Guid
    id)` methods use the same pattern already implemented in the `ItemRepository`
    class to retrieve the information related to the required entities. Furthermore,
    the `Add` method refers to the `Artists` field exposed by `CatalogContext` to
    add a new artist. It is important to note that, in this case, the `Add` operation
    doesn't update the data source directly.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了`ArtistRepository`类型，并为`IArtistRepository`接口提供了实现。该类使用`CatalogContext`作为我们的应用程序和SQL数据库之间的通信中心。`GetAsync`和`GetAsync(Guid
    id)`方法使用已在`ItemRepository`类中实现的相同模式来检索与所需实体相关的信息。此外，`Add`方法引用了`CatalogContext`公开的`Artists`字段以添加新艺术家。需要注意的是，在这种情况下，`Add`操作并不直接更新数据源。
- en: 'Let''s proceed by defining the `GenreRepository` class:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过定义`GenreRepository`类来继续：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the same way as `ArtistRepository`, we are implementing the operations for
    querying and manipulating the `Genre` entities. Although the names of the methods
    and the implementations are quite similar, I have chosen to keep the repository
    interfaces separated and redefine each implementation separately. A quicker approach
    would be to create a generic class that represents the typical behavior of `ItemRepository`,
    `ArtistRepository`, and `GenreRepository`, but the generic repositories are not
    always the right choice. In addition to this, building the wrong abstraction is
    a lot more expensive than duplicating code, and building a unique generic repository
    for everything means tight coupling the entities.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `ArtistRepository` 类似，我们正在实现查询和操作 `Genre` 实体的操作。尽管方法和实现方式非常相似，但我选择保持存储库接口分离，并分别重新定义每个实现。一个更快的方法是创建一个代表
    `ItemRepository`、`ArtistRepository` 和 `GenreRepository` 典型行为的通用类，但通用存储库并不总是最佳选择。此外，构建错误抽象的成本远高于代码重复，为所有内容构建唯一的通用存储库意味着实体之间紧密耦合。
- en: Extending the test coverage
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展测试覆盖率
- en: 'As we did with the `ItemRepositoryTests` class, we can proceed by testing `ArtistRepository`
    and `GenreRepository` using the same approach. In [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml),
    *Building the Data Access Layer*, we defined `TestDataContextFactory`, which is
    part of the `Catalog.Fixtures` project. We can use this to instantiate an in-memory
    database for our test purposes:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 `ItemRepositoryTests` 类中所做的那样，我们可以通过使用相同的方法来测试 `ArtistRepository` 和 `GenreRepository`。在
    [第 8 章](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml) “构建数据访问层” 中，我们定义了 `TestDataContextFactory`，它是
    `Catalog.Fixtures` 项目的一部分。我们可以使用它来为测试目的实例化一个内存数据库：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The previous code explores a way to implement the tests for the `ArtistRepository`
    class. The `ArtistRepositoryTests` class extends `IClassFixture<CatalogContextFactory>`
    to retrieve an instance of the `CatalogContextFactory` type. The test methods
    use the `ContextInstance` attribute to retrieve a new catalog context and to initialize
    a new repository.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码探索了实现 `ArtistRepository` 类测试的方法。`ArtistRepositoryTests` 类扩展了 `IClassFixture<CatalogContextFactory>`
    以检索 `CatalogContextFactory` 类型的实例。测试方法使用 `ContextInstance` 属性来检索一个新的目录上下文并初始化一个新的存储库。
- en: They proceed by executing the method as a test and checking the results. It
    is important to notice that every test method uses the `LoadData` attribute in
    order to load the `artist` section of the `record-data.json` file. For brevity,
    I've omitted some of the test cases; however, the concept behind them is identical
    to what we have already seen, and it can be extended to the `GenreRepository`
    tests.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 他们通过执行方法作为测试并检查结果来继续。重要的是要注意，每个测试方法都使用 `LoadData` 属性来加载 `record-data.json` 文件的
    `artist` 部分。为了简洁，我省略了一些测试用例；然而，它们背后的概念与我们之前看到的相同，并且可以扩展到 `GenreRepository` 测试。
- en: Extending the IItemRepository interface
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 IItemRepository 接口
- en: 'Another step we can take to extend our web service project with the related
    entities is to implement two new methods to retrieve the items related to an artist
    or a genre in the `IItemRepository` interface: the `GetItemsByArtistIdAsync` and
    `GetItemsByGenreIdAsync` methods. Both of these methods can be used by the `GET
    /api/artists/{id}/items` and `GET /api/genre/{id}/items` routes to retrieve the
    items.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取的另一步是扩展我们的 Web 服务项目，以包含相关的实体，即在 `IItemRepository` 接口中实现两个新的方法来检索与艺术家或流派相关的项目：`GetItemsByArtistIdAsync`
    和 `GetItemsByGenreIdAsync` 方法。这两个方法都可以由 `GET /api/artists/{id}/items` 和 `GET /api/genre/{id}/items`
    路由使用来检索项目。
- en: 'Let''s proceed by adding the following methods to the `IItemsRepository` interface
    and implementing them in the corresponding implementation:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向 `IItemsRepository` 接口添加以下方法并在相应的实现中实现它们来继续：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code extends the `IItemRepository` interface and its implementation in
    order to include the functionalities to query the items using `ArtistId` and `GenreId`.
    Both methods retrieve data using the `Where` clause and by calling the `Include`
    statement to include the related entities in the result of the query. Once we
    have fully extended the repository layer, we can continue by also extending the
    service classes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码扩展了 `IItemRepository` 接口及其实现，以便包括使用 `ArtistId` 和 `GenreId` 查询项目的功能。这两个方法都使用
    `Where` 子句和调用 `Include` 语句来包含查询结果中的相关实体。一旦我们完全扩展了存储库层，我们还可以继续扩展服务类。
- en: Extending the capabilities of the service layer
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展服务层的功能
- en: 'The new `Catalog.Infrastructure` functionalities extend the `Catalog.Domain`
    project and expose `IArtistRepository` and `IGenreRepository` to the controllers
    of the API project. First of all, we should create a couple of new service classes
    in the `Catalog.Domain` project in order to query the underlying `Catalog.Infrastructure`
    layer. Let''s start by defining the `IArtistService` and `IGenreService` interfaces
    in the `Services` folder of the `Catalog.Domain` project:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`Catalog.Infrastructure`功能扩展了`Catalog.Domain`项目，并将`IArtistRepository`和`IGenreRepository`暴露给API项目的控制器。首先，我们应该在`Catalog.Domain`项目中创建几个新的服务类，以便查询底层的`Catalog.Infrastructure`层。让我们从在`Catalog.Domain`项目的`Services`文件夹中定义`IArtistService`和`IGenreService`接口开始：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code snippet contains the declarations of the `IArtistService`
    and `IGenreService` interfaces. For brevity, I've kept them in the same code snippet.
    Both interfaces define the methods in the lists, get the details, and then add
    a related entity. The `GetArtistsAsync()` and `GetGenreAsync()` methods can return
    the complete list of entities or a single entity, depending on whether the `request`
    parameter is specified or not. Additionally, it is possible to retrieve a list
    of `ItemResponse` by artist ID or genre ID using the `GetItemByArtistIdAsync`
    and `GetItemByGenreIdAsync` methods. Finally, we can add a new artist and genre
    using the `AddArtistAsync` and `AddGenreAsync` methods.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段包含了`IArtistService`和`IGenreService`接口的声明。为了简洁，我将它们保留在同一代码片段中。两个接口都定义了列表中的方法，获取详细信息，然后添加相关实体。`GetArtistsAsync()`和`GetGenreAsync()`方法可以根据是否指定`request`参数返回完整的实体列表或单个实体。此外，还可以使用`GetItemByArtistIdAsync`和`GetItemByGenreIdAsync`方法通过艺术家ID或流派ID检索`ItemResponse`列表。最后，我们可以使用`AddArtistAsync`和`AddGenreAsync`方法添加新的艺术家和流派。
- en: 'The preceding implementation also depends on the definition of the following
    request models:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现还依赖于以下请求模型的定义：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, the request classes define the allowed operation for the `Artist` and
    `Genre` entities. They are stored in the `Requests/Artist` and `Requests/Genre`
    folders, respectively. We can continue by implementing the concrete part of the
    `ArtistService` class, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，请求类定义了`Artist`和`Genre`实体的允许操作。它们分别存储在`Requests/Artist`和`Requests/Genre`文件夹中。我们可以继续实现`ArtistService`类的具体部分，如下所示：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding code defines the properties and the constructor of the `ArtistService`
    class. The implementation injects the `IArtistRepository`, `IItemRepository`,
    `IArtistMapper`, and `IItemMapper` dependencies. The `Repositories` classes will
    be used for communicating with the underlying data source of the application.
    On the other side, the mappers will be called to initialize and map the values
    sent as responses.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了`ArtistService`类的属性和构造函数。实现注入了`IArtistRepository`、`IItemRepository`、`IArtistMapper`和`IItemMapper`依赖项。`Repositories`类将被用于与应用程序底层数据源通信。另一方面，调用映射器来初始化和映射作为响应发送的值。
- en: 'Once we have defined the dependencies of the `ArtistService` class, we can
    proceed with the implementation of the core methods:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了`ArtistService`类的依赖关系，我们就可以继续实现核心方法：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The implementation represents the methods already defined in the `IArtistService`
    interface. It is quite easy to understand the purpose of the methods by looking
    at
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 实现表示在`IArtistService`接口中已定义的方法。通过查看
- en: their signatures.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的签名。
- en: The `GetAsync` method invokes the `IArtistRepository` dependency to map and
    retrieve the result in an `ArtistResponse` object. `GetItemByArtistIdAsync` executes
    the corresponding method with the same name defined in the `IItemRepository` interface.
    Finally, `AddArtistAsync` executes the `Add` method defined in the `IArtistRepository`
    interface and executes the `UnitOfWork.SaveChangesAsync` method to apply the changes
    to the data source, and then map the resulting data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetAsync`方法调用`IArtistRepository`依赖项来映射和检索结果，在`ArtistResponse`对象中。`GetItemByArtistIdAsync`执行在`IItemRepository`接口中定义的同名方法。最后，`AddArtistAsync`执行`IArtistRepository`接口中定义的`Add`方法，并执行`UnitOfWork.SaveChangesAsync`方法将更改应用到数据源，然后映射结果数据。'
- en: The same approach can be taken by the `GenreService` implementation class, which
    will depend on the `IGenreRepository` and `IGenreMapper` interfaces.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenreService`实现类也可以采用相同的方法，它将依赖于`IGenreRepository`和`IGenreMapper`接口。'
- en: 'You can find the implementation of the `GenreService` class in the official
    GitHub repository of the book: [https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的官方GitHub仓库中找到`GenreService`类的实现：[https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3)。
- en: 'Finally, we should also remember to include the definition of these interfaces
    in the `AddServices` extension method defined in the previous chapter, by incorporating
    the following changes:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还应该记得将之前章节中定义的`AddServices`扩展方法中的这些接口定义包括在内，通过以下更改：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: These changes register the `IArtistService` and `IGenreService` interfaces in
    order to be used by the controllers and the other dependencies of the application.
    In the next section, we will continue the implementation by adding some validation
    logic to the request models.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改注册了`IArtistService`和`IGenreService`接口，以便它们可以被控制器和其他应用程序依赖项使用。在下一节中，我们将继续实现，通过向请求模型添加一些验证逻辑来完成。
- en: Improving the validation mechanism
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进验证机制
- en: As we explained in the previous chapter, we are using the `FluentValidation`
    package to implement the validation mechanism of the web service. Since we have
    built the service interfaces to handle the `Artist` and `Genre` entities, it is
    now possible to improve the validation checks already present in the `AddItemRequestValidator`
    and `EditItemRequestValidator` classes. Now, we are going to implement the existence
    check for the `Artist`- and `Genre`-related entities.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中解释的，我们正在使用`FluentValidation`包来实现Web服务的验证机制。由于我们已经构建了服务接口来处理`Artist`和`Genre`实体，现在我们可以改进`AddItemRequestValidator`和`EditItemRequestValidator`类中现有的验证检查。现在，我们将实现`Artist`和`Genre`相关实体的存在检查。
- en: 'Let''s start by extending the implementation of the `AddItemRequestValidator`
    class:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从扩展`AddItemRequestValidator`类的实现开始：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `AddItemRequestValidator` class now injects the `IArtistService` and `IGenreService`
    interfaces using the constructor injection pattern. In addition to this, the validation
    class defines two methods, `ArtistExists` and `GenreExists`, which will be used
    to verify that the `ArtistId` and `GenreId` fields exist in the database by calling
    the `IArtistService` and `IGenreService` interface methods. Moreover, we can improve
    the validation rules by checking the existence of the related entities in the
    following way:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`AddItemRequestValidator`类使用构造函数注入模式注入了`IArtistService`和`IGenreService`接口。除此之外，验证类还定义了两个方法，`ArtistExists`和`GenreExists`，这些方法将通过调用`IArtistService`和`IGenreService`接口方法来验证`ArtistId`和`GenreId`字段是否存在于数据库中。此外，我们可以通过以下方式改进验证规则：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The new rules bind the `ArtistId` and `GenreId` fields with the `ArtistExists`
    and `GenreExists` methods, respectively. The same approach can be taken for the
    `EditItemRequestValidator` implementation, which will use the same pattern to
    validate the related entities. Therefore, we now need to extend the test classes
    in order to verify the new validation rules:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 新的规则将`ArtistId`和`GenreId`字段分别绑定到`ArtistExists`和`GenreExists`方法。同样的方法也可以用于`EditItemRequestValidator`的实现，它将使用相同的模式来验证相关实体。因此，我们现在需要扩展测试类以验证新的验证规则：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding code injects the `Mock<IArtistService>` and `Mock<IGenreService>`
    types into the validator class constructor in order to mock the behavior of the
    service layer and verify the logic of the validator class. It also uses the `ShouldHaveValidationErrorFor`
    method to check the expected response. The `ArtistExists` and `GenreExists` methods
    should throw a validation error in case the ID of one of the related entities
    is missing from the data source.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将`Mock<IArtistService>`和`Mock<IGenreService>`类型注入到验证类构造函数中，以模拟服务层的操作并验证验证类的逻辑。它还使用`ShouldHaveValidationErrorFor`方法来检查预期的响应。如果相关实体的ID缺失于数据源，`ArtistExists`和`GenreExists`方法应该抛出验证错误。
- en: Updating the dependencies in the Startup class
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新`Startup`类中的依赖项
- en: 'In the previous few sections, we created the `IArtistService` and `IGenreService`
    interfaces, and their corresponding implementations. Therefore, we want to update
    the dependency graph of the application. Although we have already called the `AddMappers`
    and `AddServices` extension methods of the `DependenciesRegistration` static class
    in the `ConfigureService` method, we need to update the dependencies in the following
    way:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的几个部分中，我们创建了 `IArtistService` 和 `IGenreService` 接口及其相应的实现。因此，我们想要更新应用程序的依赖图。尽管我们已经在
    `ConfigureService` 方法中调用了 `DependenciesRegistration` 静态类的 `AddMappers` 和 `AddServices`
    扩展方法，但我们需要以下方式更新依赖项：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We should also add `IArtistRepository` and `IGenreRepository` to the `ConfigureService`
    method:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该在 `ConfigureService` 方法中添加 `IArtistRepository` 和 `IGenreRepository`：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, the `ConfigureServices` method of the `Startup` class defines all the required
    dependencies used by our stack. We are currently able to resolve the dependency
    chain related to the `ArtistController` and `GenreController` classes, which we
    will define in the next section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Startup` 类的 `ConfigureServices` 方法定义了我们堆栈中所需的所有依赖项。我们目前能够解析与 `ArtistController`
    和 `GenreController` 类相关的依赖链，这些类我们将在下一节中定义。
- en: Adding the related controllers
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加相关控制器
- en: 'The `Catalog.Domain` project is now capable of handling requests related to
    the `Artist` and `Genre` entities through the logic we implemented in the `IArtistService`
    and `IGenreService` classes. Therefore, we can proceed by creating the controller
    layer to handle the incoming HTTP requests. Since we have different separate entities,
    we are going to implement the `ArtistController` and `GenreController` controller
    classes. Let''s first focus on `ArtistController`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Catalog.Domain` 项目能够通过我们在 `IArtistService` 和 `IGenreService` 类中实现的逻辑来处理与
    `Artist` 和 `Genre` 实体相关的请求。因此，我们可以通过创建控制器层来处理传入的 HTTP 请求。由于我们有不同的独立实体，我们将实现 `ArtistController`
    和 `GenreController` 控制器类。让我们首先关注 `ArtistController`：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The above code defines the initial signature of the `ArtistController` class:
    the implementation injects the `IArtistService` interface from the service layer
    in order to interact with the information stored in the database. We can proceed
    further, by defining the implementation of the `Get` and `GetById` action methods:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了 `ArtistController` 类的初始签名：实现注入了来自服务层的 `IArtistService` 接口，以便与存储在数据库中的信息进行交互。我们可以进一步定义
    `Get` 和 `GetById` 动作方法的实现：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding code shows the implementation of `ArtistController`, which corresponds
    to the `/api/artist` route. `ArtistController` uses `PaginatedItemsResponseModel`
    to retrieve the information related to all the artists. In the same way, we can
    use the `IAritstService` interface to execute the other operations and map them
    with the action methods:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码展示了 `ArtistController` 的实现，它对应于 `/api/artist` 路由。`ArtistController` 使用
    `PaginatedItemsResponseModel` 来检索所有艺术家的相关信息。同样地，我们可以使用 `IAritstService` 接口来执行其他操作，并将它们映射到动作方法：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding `ArtistController` class defines the following routes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `ArtistController` 类定义了以下路由：
- en: '| **Verb** | **Path** | **Description** |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| **动词** | **路径** | **描述** |'
- en: '| `GET` | `/api/artist` | Retrieves all the artists present in the database
    |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/artist` | 检索数据库中存在的所有艺术家 |'
- en: '| `GET` | `/api/artist/{id}` | Retrieves the artist with the corresponding
    *ID* |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/artist/{id}` | 获取具有相应 *ID* 的艺术家 |'
- en: '| `GET` | `/api/artist/{id}/items/` | Retrieves the items with the corresponding
    artist *ID* |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/artist/{id}/items/` | 获取具有相应艺术家 *ID* 的项目 |'
- en: '| `POST` | `/api/artist/` | Creates a new artist and retrieves it |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/api/artist/` | 创建一个新的艺术家并检索它 |'
- en: 'For each route, the *catalog service* will retrieve the corresponding data
    by executing the `IArtistService` interface methods. The `ArtistService` implementation
    will dispatch the request to the corresponding method of the repository implementations
    contained in the `Catalog.Infrastructure` project. Similar to `ItemController`,
    we can implement any additional validation behavior by using `FluentValidation`.
    For example, in the case of `AddArtistRequest`, we can proceed with the following
    implementation:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个路由，*目录服务* 将通过执行 `IArtistService` 接口方法来检索相应的数据。`ArtistService` 的实现将请求调度到包含在
    `Catalog.Infrastructure` 项目中的存储库实现对应的相应方法。类似于 `ItemController`，我们可以通过使用 `FluentValidation`
    来实现任何额外的验证行为。例如，在 `AddArtistRequest` 的情况下，我们可以进行以下实现：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the case of `AddArtistRequest`, we want to prevent the user from adding empty
    `ArtistName` fields. We can create an additional `AddArtistRequestValidator` class
    under the `Requests/Artist/Validator` path. The validator class contains only
    one rule related to the non-empty `ArtistName` field.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AddArtistRequest`的情况下，我们希望防止用户添加空的`ArtistName`字段。我们可以在`Requests/Artist/Validator`路径下创建一个额外的`AddArtistRequestValidator`类。验证类只包含一个与非空`ArtistName`字段相关的规则。
- en: 'The same implementation pattern can be also taken by the `GenreController`
    class. The following code defines the signature of the class implementation:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的实现模式也可以应用于`GenreController`类。以下代码定义了类实现的签名：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The code above injects the `IGenreService` interface using the *constructor
    injection* practice. Furthermore, we can proceed by creating the corresponding
    routes we defined for the `ArtistController` class:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用*构造函数注入*实践注入了`IGenreService`接口。此外，我们可以继续创建为`ArtistController`类定义的相应路由：
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The code above defines the `Get`, `GetById`, `GetItemById` and the `Post` action
    methods implemented in the `GenreController` class. Each action calls the underlying
    service layer in order to interact with the database. Although the implementation
    of the action methods is similar to the `ArtistController` class, I still keep
    the classes separate; therefore, the `Genre` and `Artist` entities can evolve
    separately without depending on each other.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在`GenreController`类中定义了`Get`、`GetById`、`GetItemById`和`Post`操作方法。每个操作都调用底层服务层以与数据库交互。尽管操作方法的实现与`ArtistController`类相似，但我仍然保持类分开；因此，`Genre`和`Artist`实体可以独立演变，而不相互依赖。
- en: Extending tests for the ArtistController class
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展`ArtistController`类的测试
- en: 'Once we expose the API routes through the `ArtistController` and `GenreController`
    classes, we are able to proceed by testing the revealed paths using the same approach
    that we used for `ItemController`. We should continue by creating a new `ArtistControllerTests`
    class in the `Catalog.API.Tests` project:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过`ArtistController`和`GenreController`类公开了API路由，我们就可以使用与`ItemController`相同的方法来测试这些公开的路径。我们应该继续在`Catalog.API.Tests`项目中创建一个新的`ArtistControllerTests`类：
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The preceding code describes the test case for the get paginated artist action
    method and the get by ID action method. Both use the same `InMemoryApplicationFactory`
    factory to set up the fake in-memory data source. It is also possible to combine
    additional tests to verify the add artist process*:*
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码描述了获取分页艺术家操作方法和按ID获取操作方法的测试用例。两者都使用相同的`InMemoryApplicationFactory`工厂来设置模拟的内存数据源。也可以结合额外的测试来验证添加艺术家过程：*
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The fixture class initializes a new `TestServer` instance for each test method
    and it provides a new `HttpClient` instance through the `CreateClient` method
    to test the routes exposed by the `ArtistController` class. The tests also use
    the `LoadData` attribute to get matching information about the testing records
    from the `record-data.json` file. A similar implementation approach can be taken
    to test the `GenreController` class action methods.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 固定类为每个测试方法初始化一个新的`TestServer`实例，并通过`CreateClient`方法提供一个新的`HttpClient`实例来测试`ArtistController`类公开的路由。测试还使用`LoadData`属性从`record-data.json`文件中获取有关测试记录的匹配信息。可以采用类似的实现方法来测试`GenreController`类的操作方法。
- en: A final overview
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终概述
- en: 'Finally, let''s take a look at a quick overview of the code structure we implemented
    in [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml), *Building the Data
    Access Layer*, [Chapter 9](f8ac60e1-e948-4435-b804-e3e4ff305510.xhtml), *Implementing
    the Domain Logic*, and this chapter. The following architecture schema illustrates
    the actual construction of the `Catalog.API` solution:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们快速概述一下我们在[第8章](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml)，*构建数据访问层*，[第9章](f8ac60e1-e948-4435-b804-e3e4ff305510.xhtml)，*实现领域逻辑*和本章中实现的代码结构。以下架构图展示了`Catalog.API`解决方案的实际构建：
- en: '![](img/ef6629e2-50a2-4aa8-8e6a-a66028bcd14a.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ef6629e2-50a2-4aa8-8e6a-a66028bcd14a.png)'
- en: Once the web service instance receives the client request, it dispatches the
    request to the corresponding action method of the controller. Following this,
    the action method executes the corresponding function exposed by the service classes
    defined in the `Catalog.Domain` project, which ships the request to the relevant
    repository defined in the `Catalog.Infrastructure` project, and then maps the
    entities with the request and response models.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Web 服务实例接收到客户端请求，它将请求调度到控制器的相应操作方法。随后，操作方法执行由 `Catalog.Domain` 项目中定义的服务类公开的相应功能，将请求发送到
    `Catalog.Infrastructure` 项目中定义的相关存储库，然后映射实体与请求和响应模型。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has covered various topics regarding the design and development
    of the `Catalog.API` project. Moreover, it has shown you how to build the routes
    of our APIs. The topics covered in this chapter are part of the core implementation
    of our web services; therefore, they provide all the knowledge that is necessary
    for exposing HTTP routes and handling requests and responses in .NET Core. In
    addition to this, the chapter also covered integration testing and implementation
    using the web factory tools provided by the framework.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了关于 `Catalog.API` 项目设计和开发的各个方面。此外，它还展示了如何构建我们的 API 路由。本章涵盖的主题是我们 Web 服务核心实现的一部分；因此，它们提供了在
    .NET Core 中公开 HTTP 路由和处理请求和响应所需的所有知识。除此之外，本章还涵盖了使用框架提供的 Web 工厂工具进行的集成测试和实现。
- en: In the next chapter, we will cover other additional topics about web services,
    such as how to implement a soft-delete approach to our data and how to use a **Hypermedia
    As The Engine Of Application State** (**HATEOAS**) approach. The chapter will
    also cover some .NET Core-related topics such as a brief introduction to and the
    best practices of asynchronous programming in .NET Core.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍关于 Web 服务的一些其他附加主题，例如如何实现数据软删除方法以及如何使用 **Hypermedia As The Engine
    Of Application State** （**HATEOAS**） 方法。本章还将涵盖一些与 .NET Core 相关的主题，例如对异步编程的简要介绍以及在
    .NET Core 中的最佳实践。
