- en: Chapter 10. Source Control and Other Tips
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章：源代码控制和其他技巧
- en: 'This chapter considers three main tips and tricks to script in C# or to work
    with scripts. These tips are themselves powerful and important but do not belong
    squarely in any of the previous chapters, which are divided mainly by subject
    matter. The tips are listed here in no particular order and their main justification
    for inclusion is based largely on their usefulness, and also because their documentation
    elsewhere is sparse and often inconclusive. Consequently, this chapter reads as
    a useful collection of did-you-know tips and tricks, which taken together, offer
    knowledge that is substantial and practical. The three tips cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章考虑了在C#中编写脚本或与脚本一起工作的三个主要技巧和窍门。这些技巧本身强大且重要，但它们并不完全属于之前的任何一章，这些章节主要按主题划分。这些技巧按无特定顺序列出，它们被包含在内的主要理由是基于它们的实用性，以及因为它们在其他地方的文档很少且往往结论不明确。因此，本章读起来像是一个有用的“你知道吗？”技巧和窍门的集合，这些技巧结合起来，提供了大量实用和实质性的知识。这三个技巧包括：
- en: Git revision control
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git版本控制
- en: Resource folders and externals files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源文件夹和外部文件
- en: Loading and saving games
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载和保存游戏
- en: Git – source control
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git – 源代码控制
- en: The term **source control** or **revision control** refers to any software aimed
    at making development in practice both simpler and safer for as many people as
    possible. In short, it allows you to track and undo changes to your files easily
    and quickly, as well as share these changes with others. Typically, software development
    (including game development) relies on two important facts or ingredients. First,
    it’s a collective effort where multiple developers work together as part of a
    team, either at the same physical location (such as an office) or across distant
    locations but sharing a virtual space (such as a virtual office, forum, or even
    e-mail). Second, during development, developers will tweak, edit, and make improvements
    to the source code. From these two seemingly simple facts comes a range of important
    needs that revision control aims to satisfy.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**源代码控制**或**版本控制**指的是旨在使尽可能多的人的开发实践既简单又安全的任何软件。简而言之，它允许您轻松快速地跟踪和撤销对文件的更改，并与其他人共享这些更改。通常，软件开发（包括游戏开发）依赖于两个重要的事实或要素。首先，它是一个集体努力，多个开发者作为团队的一部分共同工作，无论是在同一物理位置（如办公室）还是在遥远的位置，但共享一个虚拟空间（如虚拟办公室、论坛，甚至是电子邮件）。其次，在开发过程中，开发者将对源代码进行微调、编辑和改进。从这两个看似简单的事实中产生了修订控制旨在满足的一系列重要需求。
- en: 'These needs are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些需求如下：
- en: '**Collaboration**: When multiple developers work on coding the same project,
    they’ll usually need to share source files. They can send them back and forth
    through e-mail or other manual methods, but this makes coding difficult on a large
    scale and on long-term projects. It quickly becomes difficult to monitor the code
    changes over time and integrate or merge two sets of changes into one file.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作**：当多个开发者共同对同一项目进行编码时，他们通常需要共享源文件。他们可以通过电子邮件或其他手动方法来回传文件，但这使得在大规模和长期项目中编码变得困难。很快，监控代码随时间的变化以及将两组更改合并到一个文件中就会变得困难。'
- en: '**Reverting**: Sometimes, code changes and improvements turn out to be mistaken.
    A proposed edit or fix doesn’t always have the intended outcome and must be undone
    or reverted to the earlier state. You can keep copies of the earlier files yourself,
    but maintaining potentially many copies over time will be tedious and unnecessarily
    confusing.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回滚**：有时，代码更改和改进会被证明是错误的。提出的编辑或修复并不总是达到预期的效果，必须撤销或回滚到早期状态。您可以自己保留早期文件的副本，但随着时间的推移，维护可能许多副本将会变得繁琐且不必要地令人困惑。'
- en: '**Tracking changes and histories**: Often, you’ll need to keep track of who
    does what, especially when debugging. If someone makes a code edit, you’ll want
    to know who changed the code, why, and when. Again, you could manually maintain
    a logfile, writing in comments and entries to document the changed process, but
    this would be tedious and time consuming.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪更改和记录**：通常，您需要跟踪谁做了什么，尤其是在调试时。如果有人对代码进行了编辑，您会想知道谁更改了代码，为什么，以及何时更改。再次，您可以手动维护一个日志文件，通过注释和条目来记录更改过程，但这将会变得繁琐且耗时。'
- en: Revision control aims to solve the three main problems of collaboration, reversion,
    and tracking changes. Revision control software includes Git, Perforce, Microsoft
    Team Foundation Server, and others. This chapter specifically considers Git; it
    is widely used, free, cross-platform, and open source. Using Git, you can begin
    by configuring a special database, known as a **repository**, which can be either
    local (on your computer) or remote (via a network). Then, once configured, you
    can track and maintain all and any changes to your Unity projects, allowing you
    to revert to the earlier states of your project, if needed, and to share or collaborate
    with others. Let’s see how to configure Git for general use using a graphical
    user interface.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制旨在解决协作、回滚和跟踪更改的三个主要问题。版本控制软件包括 Git、Perforce、Microsoft Team Foundation Server
    等。本章特别考虑 Git；它被广泛使用，免费，跨平台，且开源。使用 Git，您可以首先配置一个特殊的数据库，称为 **仓库**，它可以是本地的（在您的计算机上）或远程的（通过网络）。然后，一旦配置完成，您就可以跟踪和维护您所有
    Unity 项目的任何更改，如果需要，可以回滚到项目的早期状态，并与他人共享或协作。让我们看看如何使用图形用户界面配置 Git 以进行通用使用。
- en: 'Step #1 – downloading'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '步骤 #1 – 下载'
- en: There are many ways to get up and running with Git for Unity projects. This
    chapter explores a combination of the official Git package alongside the frontend
    TortoiseGit. Using these two packages, developers can track and maintain all changes
    to their projects, whether working alone or in a team.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Unity 项目，有许多方法可以开始使用 Git。本章探讨了官方 Git 软件与前端 TortoiseGit 的结合使用。使用这两个软件包，开发者可以跟踪和维护他们项目的所有更改，无论是单独工作还是团队合作。
- en: 'To get started, download and install the official Git software, which is available
    at [http://git-scm.com/](http://git-scm.com/):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请下载并安装官方 Git 软件，该软件可在 [http://git-scm.com/](http://git-scm.com/) 获取：
- en: '![Step #1 – downloading](img/0655OT_10_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #1 – 下载](img/0655OT_10_01.jpg)'
- en: Downloading and installing Git
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下载和安装 Git
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Detailed information on using Git can be found in the free, online e-book, *Pro
    Git*, *Scott Chacon and Ben Straub*, *Apress*, available at [http://git-scm.com/book/en/v2](http://git-scm.com/book/en/v2).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用 Git 的详细信息可以在免费的在线电子书 *Pro Git* 中找到，作者是 *Scott Chacon 和 Ben Straub*，由 *Apress*
    出版，可在 [http://git-scm.com/book/en/v2](http://git-scm.com/book/en/v2) 获取。
- en: After Git is installed and downloaded, it’s useful to get TortoiseGit. This
    is not part of the original Git package but is an optional frontend component
    for Windows, which it allows you to integrate Git with the Windows shell as well
    as interact with Git through a GUI rather than the command line.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 安装并下载后，获取 TortoiseGit 是很有用的。这不是原始 Git 软件包的一部分，但它是 Windows 的一个可选前端组件，它允许您将
    Git 与 Windows 壳集成，并通过图形用户界面而不是命令行与 Git 交互。
- en: 'To download and install TortoiseGit, go to [https://code.google.com/p/tortoisegit/](https://code.google.com/p/tortoisegit/):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载和安装 TortoiseGit，请访问 [https://code.google.com/p/tortoisegit/](https://code.google.com/p/tortoisegit/)：
- en: '![Step #1 – downloading](img/0655OT_10_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #1 – 下载](img/0655OT_10_02.jpg)'
- en: Downloading and installing TortoiseGit
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下载和安装 TortoiseGit
- en: 'Step #2 – building a Unity project'
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '步骤 #2 – 构建 Unity 项目'
- en: 'The reason to install Git originally was to track and maintain changes to a
    Unity project, allowing you to revert them if needed, acting as a backup version
    in case anything happens to the original files, and to share changes with other
    developers. This depends, therefore, on whether you already have a Unity project
    to maintain. The next step, then, after installing both Git and TortoiseGit is
    to either create a new Unity project or to find an existing one that should be
    tracked. The following is the screenshot of the Unity project folder:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Git 的初衷是为了跟踪和维护 Unity 项目的更改，以便在需要时进行回滚，作为原始文件的备份版本，以及与其他开发者共享更改。因此，这取决于您是否已经有一个需要维护的
    Unity 项目。安装 Git 和 TortoiseGit 后的下一步是创建一个新的 Unity 项目或找到一个应该被跟踪的现有项目。以下是对 Unity
    项目文件夹的截图：
- en: '![Step #2 – building a Unity project](img/0655OT_10_03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #2 – 构建 Unity 项目](img/0655OT_10_03.jpg)'
- en: Viewing a Unity project folder
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Unity项目文件夹
- en: 'After finding a Unity project, open the project folder in Windows explorer
    to see the project files. If you don’t know or don’t remember the location of
    the folder, you could open it directly in explorer from the Unity Editor interface.
    To achieve this, right-click inside the Unity **Project** panel and select **Show
    in Explorer** from the context menu:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 找到 Unity 项目后，在 Windows 资源管理器中打开项目文件夹以查看项目文件。如果您不知道或记不起文件夹的位置，您可以直接从 Unity 编辑器界面打开它。为此，在
    Unity **项目**面板内右键单击，从上下文菜单中选择**在资源管理器中显示**：
- en: '![Step #2 – building a Unity project](img/0655OT_10_04.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #2 – 构建 Unity 项目](img/0655OT_10_04.jpg)'
- en: Accessing the project folder from the Unity interface
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Unity 界面访问项目文件夹
- en: 'Step #3 – configuring Unity for source control'
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '步骤 #3 – 配置 Unity 以进行源代码控制'
- en: Git works with both binary and text files, but it works best with text files.
    When working with Unity, the editor generates many metadata files for your project
    and the assets you import. By default, these files are hidden and are in a binary
    form, and they exist inside the Unity project folder. Some of the generated metafiles
    are specific only to the instance of Unity that runs on your computer, such as
    interface preferences, while other files pertain to assets and data that are part
    of the project, such as meshes, textures, and script files. To get the best results
    from Git, you’ll need to adjust Unity’s default behavior by making metafiles visible
    in the **Project** explorer, and also using text-based formats as opposed to binary
    formats. To achieve this, go to **Edit** | **Project Settings** | **Editor** from
    the menu bar.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Git 与二进制文件和文本文件都兼容，但与文本文件配合得最好。当使用 Unity 时，编辑器会为您项目和导入的资产生成许多元数据文件。默认情况下，这些文件是隐藏的，并以二进制形式存在，它们位于
    Unity 项目文件夹内。一些生成的元文件仅针对运行在您计算机上的 Unity 实例特定，例如界面首选项，而其他文件则与项目中的资产和数据相关，例如网格、纹理和脚本文件。为了从
    Git 获得最佳效果，您需要通过在 **项目**资源管理器中使元文件可见，并使用基于文本的格式而不是二进制格式来调整 Unity 的默认行为。为此，从菜单栏选择**编辑**
    | **项目设置** | **编辑器**。
- en: 'From here, use the object inspector to set the **Version Control** field to
    **Visible Meta Files** and the **Asset Serialization** field to **Force Text**:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，使用对象检查器将**版本控制**字段设置为**可见元文件**，将**资产序列化**字段设置为**强制文本**：
- en: '![Step #3 – configuring Unity for source control](img/0655OT_10_05.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #3 – 配置 Unity 以进行源代码控制](img/0655OT_10_05.jpg)'
- en: Configuring Unity for version control
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 Unity 以进行版本控制
- en: 'When these settings are changed, you will see a `.meta` file associated with
    each project asset, including scenes. In addition, the metafile will be in a human-readable
    text format, which can even be edited (though manual editing is not recommended).
    Have a look at the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些设置更改时，您将看到与每个项目资产（包括场景）关联的 `.meta` 文件。此外，元文件将以人类可读的文本格式存在，甚至可以编辑（尽管不建议手动编辑）。请看以下截图：
- en: '![Step #3 – configuring Unity for source control](img/0655OT_10_06.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #3 – 配置 Unity 以进行源代码控制](img/0655OT_10_06.jpg)'
- en: Viewing a scene asset (in text format) inside a text editor
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中查看场景资产（以文本格式）
- en: 'Step #4 – creating a Git repository'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '步骤 #4 – 创建 Git 仓库'
- en: 'The next phase, after creating and configuring a Unity project, is to create
    the Git database or repository itself that will track and maintain all changes
    to the Unity files. The repository can be either remote (hosted on a network or
    external computer) or local (hosted on the same computer). The repository will
    retain the original files and all the changes done to them over time, allowing
    you to revert to earlier versions of files, if required. The repository can also
    be shared and merged with other repositories for file sharing. This chapter considers
    only local repositories, so let’s create one now. To do this, open the Unity project
    folder (the root folder) and then right-click to show the Windows context menu.
    From the menu, choose **Git Init Here**:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和配置 Unity 项目后的下一阶段是创建 Git 数据库或仓库本身，该仓库将跟踪和维护 Unity 文件的所有更改。仓库可以是远程的（托管在网络上或外部计算机上）或本地的（托管在同一计算机上）。仓库将保留原始文件以及随时间对它们所做的所有更改，允许您在需要时回滚到文件的早期版本。仓库还可以与其他仓库共享和合并以进行文件共享。本章仅考虑本地仓库，因此现在让我们创建一个。为此，打开
    Unity 项目文件夹（根文件夹），然后右键单击以显示 Windows 上下文菜单。从菜单中选择**在此处初始化 Git**：
- en: '![Step #4 – creating a Git repository](img/0655OT_10_07.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #4 – 创建 Git 仓库](img/0655OT_10_07.jpg)'
- en: Creating a Git repository
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Git 仓库
- en: 'Once created, a new and hidden folder named `.git` will be generated. This
    folder features all the repository files for the project. The icons for files
    and folders will change to default red symbols, indicating that the files inside
    the project folder have not yet been added to the repository, so Git cannot track
    changes made to them (we’ll deal with this soon). This is shown in the following
    screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，将生成一个名为 `.git` 的新隐藏文件夹。这个文件夹包含项目的所有仓库文件。文件和文件夹的图标将变为默认的红色符号，表示项目文件夹内的文件尚未添加到仓库中，因此
    Git 无法跟踪对它们的更改（我们很快就会处理这个问题）。这在上面的截图中有显示：
- en: '![Step #4 – creating a Git repository](img/0655OT_10_08.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #4 – 创建 Git 仓库](img/0655OT_10_08.jpg)'
- en: Folders highlighted in red contain files not included in the Git repository
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 红色高亮的文件夹包含未包含在 Git 仓库中的文件
- en: 'Step #5 – ignoring files'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '步骤 #5 – 忽略文件'
- en: 'The Git repository is now created, ready to receive its first set of files
    (a *commit*). However, before adding them, there are some specific files and types
    that can safely be ignored. Unity features some project or system-specific files
    that are less project critical than user critical; that is, some files always
    contain only user interface preferences as well as read-only files, or temps,
    and other specific data that need not be added to the repository and can be safely
    ignored. To ignore these, we can create a `.gitignore` text file inside the project’s
    root folder and list all the files and folders to be ignored, as shown here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Git 仓库现在已创建，准备接收其第一组文件（一个 *提交*）。然而，在添加它们之前，有一些特定的文件和类型可以安全地忽略。Unity 具有一些项目或系统特定的文件，这些文件对项目的关键程度不如对用户的关键程度；也就是说，一些文件总是只包含用户界面首选项以及只读文件、临时文件和其他不需要添加到仓库且可以安全忽略的特定数据。要忽略这些文件，我们可以在项目的根文件夹内创建一个
    `.gitignore` 文本文件，并列出所有要忽略的文件和文件夹，如下所示：
- en: '![Step #5 – ignoring files](img/0655OT_10_09.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #5 – 忽略文件](img/0655OT_10_09.jpg)'
- en: Creating a Git ignore file to exclude specific file types from the repository
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Git 忽略文件以排除特定文件类型从仓库
- en: 'For Unity, this file (`.gitignore`) should look as follows. Be sure to put
    the file inside the root folder:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Unity，此文件（`.gitignore`）应如下所示。请确保将文件放在根文件夹内：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Step #6 – creating the first commit'
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '步骤 #6 – 创建第一个提交'
- en: The repository is now configured to receive the first set of Unity project files.
    To add these, right-click inside the root folder window, and from the context
    menu, go to **Git Commit** | **Master**. In Git, files are typically submitted
    not one by one but in batches. The **Commit** window allows you to select all
    files to commit.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库现在已配置好，以接收第一组 Unity 项目文件。要添加这些文件，在根文件夹窗口内右键单击，然后在上下文菜单中转到 **Git Commit** |
    **Master**。在 Git 中，文件通常是批量提交的，而不是逐个提交。**提交** 窗口允许你选择要提交的所有文件。
- en: 'Click on the **All** button to select all files in the folder and then assign
    a description in the **Message** field to the commit. The message should allow
    any user to understand the files that the commit contains. When ready, click on
    **OK** to commit the files:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **All** 按钮，选择文件夹中的所有文件，然后在 **Message** 字段中为提交分配一个描述。消息应该允许任何用户理解提交包含的文件。准备好后，点击
    **OK** 提交文件：
- en: '![Step #6 – creating the first commit](img/0655OT_10_10.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #6 – 创建第一个提交](img/0655OT_10_10.jpg)'
- en: Submitting the original project files
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 提交原始项目文件
- en: 'When the commit is completed, the file icons will turn green to indicate a
    file match, that is, to indicate that the files in the project folder are identical
    to those in the repository:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 提交完成后，文件图标将变为绿色，表示文件匹配，即表示项目文件夹中的文件与仓库中的文件相同：
- en: '![Step #6 – creating the first commit](img/0655OT_10_11.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #6 – 创建第一个提交](img/0655OT_10_11.jpg)'
- en: Files are up to date with the repository
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 文件与仓库保持最新
- en: 'Step #7 – changing files'
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '步骤 #7 – 修改文件'
- en: Git is supposed to be a complete file-tracking solution; this means that it
    should store not only your original files but all the subsequent changes and edits,
    allowing you to revert to any previous version.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Git 应该是一个完整的文件跟踪解决方案；这意味着它不仅应该存储你的原始文件，还应该存储所有后续的更改和编辑，允许你回滚到任何以前的版本。
- en: 'If you now return to Unity and change your files, adding new assets or editing
    the existing ones, the file icons inside the Windows explorer change to red again,
    indicating a mismatch between the local files and the repository files:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在返回 Unity 并修改你的文件，添加新资产或编辑现有的资产，Windows 资源管理器内的文件图标将再次变为红色，表示本地文件与仓库文件不匹配：
- en: '![Step #7 – changing files](img/0655OT_10_12.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #7 – 修改文件](img/0655OT_10_12.jpg)'
- en: Changing files
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 修改文件
- en: 'If you decide that your most recent changes were a mistake and you’d like to
    revert back to the changes made last, you can do this by right-clicking inside
    the project folder window and going to **TortoiseGit** | **Revert...** from the
    context menu:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定最近的变化是错误的，并且希望恢复到最后一次所做的更改，您可以通过在项目文件夹窗口内右键单击并从上下文菜单中选择**TortoiseGit**
    | **还原...**来实现：
- en: '![Step #7 – changing files](img/0655OT_10_13.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #7 – 修改文件](img/0655OT_10_13.jpg)'
- en: Reverting (undoing) recent changes
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 还原（撤销）最近的变化
- en: 'The **Revert** dialog will show, allowing you to select files for reversion.
    Select all the required files and then choose **OK**. Git will then restore all
    the selected files, overwriting the local versions with the latest versions from
    the repository:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示**还原**对话框，允许您选择要还原的文件。选择所有必要的文件，然后选择**确定**。Git将恢复所有选定的文件，用仓库中的最新版本覆盖本地版本：
- en: '![Step #7 – changing files](img/0655OT_10_14.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #7 – 修改文件](img/0655OT_10_14.jpg)'
- en: Select files to revert
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 选择要还原的文件
- en: On the other hand, you might not want to revert or undo the recent changes.
    Instead, you might have created a valid change; this should be added to the Git
    repo as the latest version of the files. If so, then simply recommit the files.
    Right-click inside the project folder window and, from the context menu, go to
    **Git Commit** | **Master**. Be sure to enter a new and descriptive message for
    the commit inside the **Message** field of the **Commit** dialog.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，您可能不想还原或撤销最近的变化。相反，您可能已经创建了一个有效的更改；这应该作为文件的最新版本添加到Git仓库中。如果是这样，那么只需重新提交文件。在项目文件夹窗口内右键单击，并从上下文菜单中选择**Git提交**
    | **主分支**。务必在**提交**对话框的**消息**字段中输入一个新且描述性的消息。
- en: 'Step #8 – getting files from the repo'
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '步骤 #8 – 从仓库获取文件'
- en: Once the original commit of all the files has been made, if you were to delete
    every file in the Unity folder either intentionally or accidentally, except for
    the `.git` and `.gitignore` files, you could still retrieve all the latest files
    again. This is because the Git repo contains the files.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有文件的原始提交已完成，如果您故意或意外地删除了Unity文件夹中的所有文件（除了`.git`和`.gitignore`文件），您仍然可以再次检索所有最新文件。这是因为Git仓库包含这些文件。
- en: '![Step #8 – getting files from the repo](img/0655OT_10_15.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #8 – 从仓库获取文件](img/0655OT_10_15.jpg)'
- en: You can retrieve deleted files in the project folder from the Git repo
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Git仓库的项目文件夹中恢复已删除的文件
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Of course, if you are really following along with the book by deleting your
    own files, make sure to keep a manual backup of them, in case anything goes wrong
    during testing!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您真的在按照书中的指示删除自己的文件，确保在测试过程中保留手动备份，以防万一出现问题！
- en: 'To achieve this, right-click inside the project folder window and navigate
    to **TortoiseGit** | **Switch/Checkout** from the context menu:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，请在项目文件夹窗口内右键单击，并从上下文菜单中选择**TortoiseGit** | **切换/检出**：
- en: '![Step #8 – getting files from the repo](img/0655OT_10_16.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #8 – 从仓库获取文件](img/0655OT_10_16.jpg)'
- en: Using the Switch/Checkout option to retrieve the latest files from the repo
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用切换/检出选项从仓库获取最新文件
- en: From the **Switch/Checkout** dialog, select the **Master** branch for the **Switch
    To** field.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从**切换/检出**对话框中，选择**主分支**作为**切换到**字段。
- en: 'You might also need to enable the **Force** check from the options (see the
    documentation for more details). Then, click on **OK** to retrieve the latest
    files. You will see the following screenshot once all the files are retrieved:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还需要从选项中启用**强制**复选框（请参阅文档以获取更多详细信息）。然后，单击**确定**以获取最新文件。一旦所有文件都检索到，您将看到以下截图：
- en: '![Step #8 – getting files from the repo](img/0655OT_10_17.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #8 – 从仓库获取文件](img/0655OT_10_17.jpg)'
- en: Retrieving the latest files with checkout
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用检出获取最新文件
- en: 'Alternatively, you might want to switch your project back to an earlier commit
    in the repo, retrieving not the latest files, but an earlier commit instead. To
    do this, first go to **Tortoise Git** | **Switch /Checkout** from the context
    menu to show the **Checkout** dialog. Then, from the **Switch To** group, enable
    the **Commit** radio box:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可能希望将项目切换回仓库中的较早提交，而不是获取最新文件，而是获取较早的提交。为此，首先从上下文菜单中选择**Tortoise Git** |
    **切换/检出**以显示**检出**对话框。然后，从**切换到**组中启用**提交**单选框：
- en: '![Step #8 – getting files from the repo](img/0655OT_10_18.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #8 – 从仓库获取文件](img/0655OT_10_18.jpg)'
- en: Enabling the Commit radio button to retrieve older commits
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 启用**提交**单选按钮以获取旧提交
- en: 'Click the browse button (**…**) next to the **Commit** field to display the
    repo commits available, and select the earlier version to switch to. Then, click
    on **OK** to exit the **Repo Commits** dialog, and click on **OK** again to confirm
    the checkout from the selected commit. The files from the selected commit will
    then be restored to the project folder. Remember that each commit has an author
    (for those working in teams), and this lets you get a picture of who has changed
    what:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **提交** 字段旁边的浏览按钮 (**…**) 以显示可用的仓库提交，并选择早期版本以切换到。然后，点击 **确定** 以退出 **仓库提交**
    对话框，并再次点击 **确定** 以确认从所选提交中检出。所选提交的文件将随后恢复到项目文件夹。记住，每个提交都有一个作者（对于团队工作的人来说），这让你可以了解谁更改了什么：
- en: '![Step #8 – getting files from the repo](img/0655OT_10_19.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #8 – 从仓库获取文件](img/0655OT_10_19.jpg)'
- en: Selecting older commits from the repo to restore
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从仓库中选择旧提交以恢复
- en: 'Step #9 – browsing the repo'
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '步骤 #9 – 浏览仓库'
- en: 'Sometimes, you’ll want to neither add nor retrieve files from the repository,
    but simply browse them to see what is there. You can do this quickly and easily
    using the Repo Browser tool, which is part of TortoiseGit. To access the tool,
    go to **TortoiseGit** | **Repo Browser** from the context menu:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能既不想从仓库中添加文件，也不想检索文件，只想浏览它们以查看内容。你可以通过使用 TortoiseGit 的一部分——仓库浏览器工具快速轻松地做到这一点。要访问此工具，从上下文菜单中选择
    **TortoiseGit** | **仓库浏览器**：
- en: '![Step #9 – browsing the repo](img/0655OT_10_20.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #9 – 浏览仓库](img/0655OT_10_20.jpg)'
- en: View the Repo Browser tool
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 查看仓库浏览器工具
- en: 'The Repo Browser tool allows you to preview the files and hierarchy from a
    GUI window:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库浏览器工具允许你从 GUI 窗口中预览文件和层次结构：
- en: '![Step #9 – browsing the repo](img/0655OT_10_21.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 #9 – 浏览仓库](img/0655OT_10_21.jpg)'
- en: Examining the files inside the repo
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 检查仓库内的文件
- en: Resources folder and external files
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源文件夹和外部文件
- en: 'Your games will frequently rely on external data loaded from files such as
    XML files, perhaps, for subtitles, localization, or level serialization. Have
    a look at the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你的游戏通常会依赖于从文件（如 XML 文件）加载的外部数据，例如，用于字幕、本地化或关卡序列化。请看以下截图：
- en: '![Resources folder and external files](img/0655OT_10_22.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![资源文件夹和外部文件](img/0655OT_10_22.jpg)'
- en: Printing a message loaded from an external text file asset that will compile
    with the project
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 打印从外部文本文件资产加载的消息，该消息将与项目一起编译
- en: In these cases, you want a specific range of abilities. The first one is the
    ability to dynamically load data from the file into memory in a way that Unity
    can parse and understand. The second is the ability to change and edit the file
    contents, even after importing it into Unity, and then have the effects of the
    changes update in the game without requiring code changes. The third is the ability
    to compile and distribute your standalone game with the file included as part
    of the main Unity build, rather than as a separate and editable file alongside
    the main executable. To elaborate further on the third point, you don’t usually
    want to distribute your game as a standalone build alongside separate and external
    files, such as XML files, which can be opened and edited by the gamer. Instead,
    as the developer, you want to edit and change the files from the Unity Editor,
    and you want the files themselves to be compiled and built into your final Unity
    standalone project, like other assets. You can achieve this using resource folders.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，你需要特定的功能范围。第一个是能够以 Unity 可以解析和理解的方式从文件中动态加载数据到内存中的能力。第二个是能够在将文件导入 Unity
    后更改和编辑文件内容，并且更改的效果可以在游戏中更新，而无需进行代码更改。第三个是能够将包含在主 Unity 构建中的文件编译和分发为独立游戏，而不是作为与主可执行文件分开的独立且可编辑的文件。进一步阐述第三点，你通常不想将游戏作为独立构建与单独的外部文件（如
    XML 文件）一起分发，这些文件可以被玩家打开和编辑。相反，作为开发者，你希望在 Unity 编辑器中编辑和更改文件，并且希望文件本身被编译并构建到你的最终
    Unity 独立项目中，就像其他资产一样。你可以使用资源文件夹来实现这一点。
- en: 'To use resource folders, create a folder named `resources` in the Unity project.
    A project can feature none, one, or more `resources` folders. Inside the folder,
    add all assets, such as text files that can be loaded by Unity at runtime:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用资源文件夹，在 Unity 项目中创建一个名为 `resources` 的文件夹。一个项目可以包含零个、一个或多个 `resources` 文件夹。在文件夹内，添加所有资产，例如可以被
    Unity 在运行时加载的文本文件：
- en: '![Resources folder and external files](img/0655OT_10_23.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![资源文件夹和外部文件](img/0655OT_10_23.jpg)'
- en: Adding external files to the resources folder
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将外部文件添加到资源文件夹
- en: 'Once a file is added to the `resources` folder, you can load it into memory
    with the `Resources.Load` function. See the following code sample 10-1, which
    loads a sample text asset into a UI text component:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件被添加到 `resources` 文件夹，您就可以使用 `Resources.Load` 函数将其加载到内存中。请参阅以下代码示例 10-1，它将一个示例文本资源加载到一个
    UI 文本组件中：
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on resource folders and the `Resources` class is available
    in the online Unity documentation at [http://docs.unity3d.com/ScriptReference/Resources.html](http://docs.unity3d.com/ScriptReference/Resources.html).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于资源文件夹和 `Resources` 类的信息可以在在线 Unity 文档中找到，网址为 [http://docs.unity3d.com/ScriptReference/Resources.html](http://docs.unity3d.com/ScriptReference/Resources.html)。
- en: AssetBundles and external files
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AssetBundles 和外部文件
- en: 'If you’re using Unity Pro and want to offer dynamic content to users, allowing
    gamers to **modify** (**mod**) game content, add their own assets, and add-ons,
    as well as support your own add-ons and plugins, then AssetBundles can be useful.
    AssetBundles let you package together many disparate Unity assets into a single,
    external file outside the main project, which can be loaded into any Unity project
    dynamically, either from a local file on disk or via the Internet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 Unity Pro，并希望向用户提供动态内容，允许玩家**修改**（**mod**）游戏内容，添加他们自己的资源，以及附加组件，以及支持您自己的附加组件和插件，那么
    AssetBundles 将非常有用。AssetBundles 允许您将许多不同的 Unity 资源打包成一个单独的外部文件，该文件位于主项目之外，可以动态地加载到任何
    Unity 项目中，无论是从磁盘上的本地文件还是通过互联网：
- en: '![AssetBundles and external files](img/0655OT_10_24.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![AssetBundles 和外部文件](img/0655OT_10_24.jpg)'
- en: Building AssetBundles from selected assets
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从所选资源构建 AssetBundles
- en: 'To get started, import the Unity asset bundle editor script to build AssetBundles
    easily from the **Project** panel. To do this, paste the following code sample
    10-2 into a C# script file located inside an `Editor` folder in your project;
    otherwise, you can download the script from: [http://docs.unity3d.com/ScriptReference/BuildPipeline.BuildAssetBundle.html](http://docs.unity3d.com/ScriptReference/BuildPipeline.BuildAssetBundle.html):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用，请将 Unity 资产包编辑器脚本导入到项目中，以便从 **项目** 面板轻松构建 AssetBundles；为此，将以下代码示例 10-2
    粘贴到项目 `Editor` 文件夹内的一个 C# 脚本文件中；否则，您可以从以下网址下载脚本：[http://docs.unity3d.com/ScriptReference/BuildPipeline.BuildAssetBundle.html](http://docs.unity3d.com/ScriptReference/BuildPipeline.BuildAssetBundle.html)：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To make an AssetBundle, select all the assets in the **Project** panel to be
    included in the bundle and then go to **Assets** | **Build AssetBundle from Selection**
    from the menu bar. Once selected, choose a location on your computer where the
    bundle should be saved.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 AssetBundle，请选择要包含在包中的所有资源，然后从菜单栏转到 **资产** | **从选择构建 AssetBundle**。一旦选择，请选择您计算机上保存包的位置。
- en: '![AssetBundles and external files](img/0655OT_10_25.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![AssetBundles 和外部文件](img/0655OT_10_25.jpg)'
- en: Selecting assets to be included in an AssetBundle
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 选择要包含在 AssetBundle 中的资源
- en: 'Then, to test the AssetBundle, create a new project or open a different project
    without the assets, and you can load them into your project at runtime using the
    `WWW` class. See the following code sample 10-3 for a sample script that downloads
    an AssetBundle from a local file, extracts a texture asset, and assigns it to
    the material of an attached mesh renderer component:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了测试 AssetBundle，创建一个新的项目或打开一个没有资源的不同项目，您可以在运行时使用 `WWW` 类将它们加载到您的项目中。请参阅以下代码示例
    10-3，它展示了如何从本地文件下载 AssetBundle，提取纹理资源，并将其分配给附加的网格渲染器组件的材料：
- en: '[PRE3]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is how the texture asset will look:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是纹理资源将呈现的样子：
- en: '![AssetBundles and external files](img/0655OT_10_26.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![AssetBundles 和外部文件](img/0655OT_10_26.jpg)'
- en: Loading a texture asset from an AssetBundle onto a mesh renderer
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从 AssetBundle 加载纹理资源到网格渲染器
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on AssetBundles can be found in the online Unity documentation
    at [http://docs.unity3d.com/Manual/AssetBundlesIntro.html](http://docs.unity3d.com/Manual/AssetBundlesIntro.html).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 AssetBundles 的信息可以在在线 Unity 文档中找到，网址为 [http://docs.unity3d.com/Manual/AssetBundlesIntro.html](http://docs.unity3d.com/Manual/AssetBundlesIntro.html)。
- en: Persistent data and saved games
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久数据和保存的游戏
- en: Allowing the gamer to save and load the state of their game is important for
    many games, especially longer duration games such as adventures, real-time strategies,
    and RPGs. In these cases, the game should allow the user to save and load game
    data to and from external files.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 允许玩家保存和加载游戏状态对于许多游戏来说很重要，尤其是持续时间较长的游戏，如冒险、实时策略和角色扮演游戏。在这些情况下，游戏应允许用户将游戏数据保存到和从外部文件中加载。
- en: 'This is achieved in Unity using data serialization via either XML or binary
    files:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中，通过 XML 或二进制文件的数据序列化来实现这一点：
- en: '![Persistent data and saved games](img/0655OT_10_27.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![持久化数据和保存游戏](img/0655OT_10_27.jpg)'
- en: Saving the Transform properties of an object to an XML file
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象的Transform属性保存到XML文件中
- en: '**Serialization** is the process of converting, or translating, data in memory
    (such as the state of a component on a `GameObject`) into a stream that can be
    written to a file and then loaded back from a file to recreate the component in
    memory, as it was when it was saved. The process of creating a save-game, therefore,
    is about first deciding which data must be saved and loaded (which is game specific)
    and then creating a new class to hold that data. Consider the following code sample
    10-4 (`ObjSerializer.cs`) that can be attached to any `GameObject` to serialize
    its Transform component (Translation, Rotation, and Scale) to and from an external
    file, both in the XML and binary formats. To achieve this, the `XmlSerializer`
    class is used to convert an object in memory to XML, and the BinaryFormatter converts
    an object in memory to a binary file. XML files are human-readable text files,
    while binary files cannot normally be read or understood by humans:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列化**是将内存中的数据（例如`GameObject`上的组件状态）转换为可以写入文件并从文件中重新加载以在内存中重新创建组件的流的进程。因此，创建保存游戏的过程首先是决定哪些数据必须保存和加载（这是游戏特定的），然后创建一个新的类来存储这些数据。考虑以下代码示例10-4（`ObjSerializer.cs`），它可以附加到任何`GameObject`上，以将Transform组件（平移、旋转和缩放）序列化和反序列化到外部文件，无论是XML格式还是二进制格式。为了实现这一点，使用了`XmlSerializer`类将内存中的对象转换为XML，而`BinaryFormatter`将内存中的对象转换为二进制文件。XML文件是可读的文本文件，而二进制文件通常不能被人类正常读取或理解：'
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A full example of loading and saving game data can be found in the book’s companion
    files in the `Chapter10/XML_and_Binary` folder.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 加载和保存游戏数据的完整示例可以在本书的配套文件中找到，位于`Chapter10/XML_and_Binary`文件夹中。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This final chapter considered three main tips of which, perhaps, the only underlying
    theme has been file management. The first tip considered Git version control,
    specifically, how the free and open source version control software allows us
    to track changes across a project as well as collaborate easily with other developers.
    The second tip concerned loading file data dynamically, first using internal project
    files inside a `resources` folder and then using AssetBundles. The latter options
    are especially useful for the creation of external assets that can be edited by
    both developers and gamers alike. The third and final tip demonstrated how in-game
    data can be saved to a file and then loaded back through serialization. Through
    serialization, users can save and restore game data, allowing them to resume playback
    at a later time.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本章考虑了三个主要的小贴士，其中可能唯一的主题是文件管理。第一个小贴士考虑了Git版本控制，特别是免费和开源的版本控制软件如何允许我们跟踪项目中的更改以及与其他开发者轻松协作。第二个小贴士涉及动态加载文件数据，首先使用`resources`文件夹内部的内部项目文件，然后使用AssetBundles。后者对于创建可以由开发者和玩家
    alike 编辑的外部资产特别有用。第三和最后一个小贴士演示了如何在游戏中将数据保存到文件中，然后通过序列化重新加载。通过序列化，用户可以保存和恢复游戏数据，允许他们在稍后时间继续播放。
