- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enhancing Data Display with Grids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll dive into data presentation within Blazor applications
    through the implementation of advanced grid functionalities. Starting with the
    essential task of refactoring traditional tables into more dynamic grid components,
    we’ll explore the significance of attaching interactive actions to various parts
    of a grid, such as buttons or links within cells, enhancing user engagement and
    operational efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also cover pagination techniques to manage large datasets effectively
    and explore infinite scrolling as a modern alternative to traditional pagination.
    Additionally, we’ll walk through creating a customizable grid, offering flexibility
    in adapting the grid to specific application needs. Lastly, we will discuss **QuickGrid**
    – a ready-to-use Blazor grid component with a predefined feature set and the quickest
    and simplest data-grid option you can leverage.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be equipped with the knowledge to enhance
    data display in your Blazor applications, improving the aesthetics and functionality
    of data presentation through the effective use of grids.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the recipes we will follow in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring a table to a grid component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching actions to parts of a grid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing sorting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing infinite scrolling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing QuickGrid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will maintain simplicity across all examples to facilitate understanding
    and learning. We will use the same dataset for all recipes, so you can see the
    impact of different technical aspects of working with grid components. No external
    tools will be required but the following basics:'
  prefs: []
  type: TYPE_NORMAL
- en: A modern IDE (that supports Blazor development)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET 9 installed on your development machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modern web browser (that supports WebAssembly)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Blazor project (where you’ll write code as you go along)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the code examples (and data samples) that you’ll see can be found in a
    dedicated GitHub repository at: [https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter04](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter04)
    . In each recipe that needs any samples, I will also point you to the directory
    where you can find them.'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring a table to a grid component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we’ll explore the fundamentals of developing a reusable grid
    component. Grids are a cornerstone in designing intuitive and organized user interfaces,
    enabling structured data display. Transitioning from using basic tables to implementing
    a reusable grid component is a strategic move toward achieving modular, maintainable,
    and scalable frontend architecture. Such a component can be adapted across different
    parts of an application, ensuring consistency and reducing redundancy in code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start from the basics and refactor an existing, standard HTML table to
    a componentized grid.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we dive into exploring grid and refactoring markup, let’s get the stage
    ready:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter04** / **Recipe01** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **Samples** and **HtmlGrid** files from the **Chapter04** / **Data**
    directory of the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to rebuild the standard HTML markup into a modular grid
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the **HtmlGrid** component. Rename **HtmlGrid** to **Grid** and convert
    it to a generic version by adding the **@typeparam** attribute at the top of the
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a **@code** section within the **Grid** component. Declare three critical
    parameters: **Header** and the generic **Data** and **Row** , allowing for dynamic
    content rendering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the table header cell markup to utilize the **Header** parameter, representing
    a flexible template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Revise the loop responsible for rendering the table body. Instead of a fixed
    dataset, iterate over the **Data** collection provided through the parameter.
    Similarly, replace static row cells with the **Row** template parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new routable **TicketManager** component and embed the newly modularized
    **Grid** component in the markup area. Leverage the provided **Tickets.All** sample
    data for the **Grid** data source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the **Header** markup for the embedded grid by extracting the header
    area from the original raw table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Construct the **Row** markup for the embedded grid by extracting the row markup
    from the original raw table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we begin implementing a modular grid by renaming **HtmlGrid**
    to **Grid** . Then, we convert the **Grid** component into a generic component
    by adding the **@typeparam T** attribute at the top. If you haven’t seen generic
    components before, we already explored that topic in [*Chapter 1*](B22020_01.xhtml#_idTextAnchor020)
    , in the *Making components generic* recipe. In *step 2* , we declare three required
    parameters. With a generic **Data** collection and a generic **Row** template,
    we enable the dynamic rendering of any objects as table rows. With **Header**
    , we can dynamically provide a table header setup without depending on any fixed
    layout. In *step 3* , we utilize the **Header** parameter to modularize the table’s
    **thead** content, effectively making the table header fully customizable. In
    *step 4* , we configure table body rendering. We iterate over the **Data** collection
    and leverage the type-aware **Row** template to render table rows dynamically
    with the provided template.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5* , we add a new routable **TicketManager** component. We showcase
    the new modularized **Grid** component, thereby embedding it into the **TicketManager**
    markup area. We utilize the **Tickets.All** dataset sample as the data source
    for the **Grid** instance. In *step 6* , we construct the **Header** markup by
    repurposing the original table header. In *step 7* , we do the same for the **Row**
    markup. However, with **Row** , there’s no need to implement a loop here – the
    **Grid** component already iterates over the provided dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Such a modularized approach not only simplifies the implementation but also
    ensures that the grid remains highly customizable and adaptable to various data
    types. We’ve effectively only simplified the loop mechanism to render grid rows,
    but it was important to showcase the thought process behind breaking the HTML
    table into modular pieces. Understanding that allows us to take the grid concept
    further in the following recipes.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While modularizing grids in Blazor applications enhances flexibility and reusability,
    you must consider the potential rendering overhead this introduces, especially
    with interactive grids. Every user interaction could activate the diffing algorithm
    (we touched upon diffing in [*Chapter 3*](B22020_03.xhtml#_idTextAnchor095) )
    and trigger re-rendering, which, depending on the complexity of your logic, might
    significantly affect performance. It’s essential that you find a balance in componentizing
    your grid – implement enough modularity to maintain flexibility without overcomplicating
    your components. Strategic API call placement and the judicious use of static
    **RenderFragment** instances can help manage performance impacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'An effective strategy to improve grid performance is leveraging the **@key**
    Blazor attribute. This attribute helps Blazor’s diffing algorithm to identify
    elements more efficiently, reducing unnecessary DOM updates by associating each
    grid row or component with a unique identifier. If we were to assume that we expect
    only row-level changes in our grid, then we could leverage the **Id** property
    of the **Ticket** object and attach **@key** in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When Blazor can correlate DOM elements with backing data objects, it can smartly
    decide when re-rendering is actually necessary and when it can skip updating certain
    parts of the DOM. By using the **@key** attribute, you not only enhance the rendering
    performance of your grids but also ensure a smoother user experience, particularly
    in data-intensive scenarios where the grid’s contents change frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching actions to parts of a grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interactive grids play a pivotal role in enhancing the user experience within
    frontend applications, allowing users to interact with and manipulate data in
    intuitive and efficient ways. By attaching actions to parts of a grid, you can
    significantly improve the grid’s functionality, paving the way for advanced features
    such as sorting, filtering, and dynamic data management. We explored how actions
    and events correlate in Blazor in [*Chapter 3*](B22020_03.xhtml#_idTextAnchor095)
    . In this recipe, you’ll learn about the techniques and best practices for integrating
    actionable elements within your grid components. Attaching actions effectively
    to grid parts not only enriches the user interface but also provides a seamless
    experience for users as they interact with your application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a table that allows you to attach an action to its columns that
    Blazor will execute when the user clicks on them and refactor the grid so it’s
    more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you dive into making columns and rows interactive, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter04** / **Recipe02** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **Grid** and **TicketManager** from the *Refactoring a table to a grid
    component* recipe or from the **Chapter04** / **Recipe01** directory in the GitHub
    repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **Samples** from the **Chapter04** / **Data** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement interactive table columns and rows, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new, generic **ColumnViewModel** class with **Label** , **Template**
    , and **OnSort** properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the **Grid** component and, below the **@typeparam** directive,
    add an attribute indicating that the generic type of the **Grid** component should
    cascade to descendant components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **@code** block of the **Grid** component, remove the **Row** parameter
    and rename the **Header** parameter to **ChildContent** . You already have the
    **Data** collection that you will also need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the parameters, initialize a **Columns** collection, with objects of
    type **ColumnViewModel** , and implement an **AddColumn()** method, allowing you
    to add a new column to the internal collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, at the end of the **@code** block, override the **OnAfterRender()**
    lifecycle method to ensure Blazor re-renders **Grid** when the rendering of all
    the nested components completes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move to the **Grid** markup and replace the existing table header with a loop
    constructing column headers based on the objects in the **Columns** collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within the **Grid** markup, in the table body area, nest another **foreach**
    loop where you render each column template for all elements in the **Data** collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete the markup, add a **CascadingValue** markup to share the current
    **Grid** instance with all the nested components it might contain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new, generic **Column** component, with a **@code** block where you
    intercept a cascading reference to the **Grid** instance and allow passing **Label**
    , **ChildContent** , and **OnSort** parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still in the **@code** block of the **Column** component, override the **OnInitialized()**
    lifecycle method to convert **Column** parameters to **ColumnViewModel** and pass
    the **model** instance to the parent **Grid** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the **TicketManager** component and initialize an **@code** block
    to implement a **Sort()** placeholder method, where you just log the intention:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **TicketManager** markup, replace the no longer compatible **Grid**
    content with columns rendered with the help of the **Column** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, enhance the **TicketManager** component to render in **InteractiveWebAssembly**
    mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *step 1* , we create a generic **ColumnViewModel** class. **ColumnViewModel**
    contains three properties: **Label** , representing the title of the column; **Template**
    , representing the markup to be rendered for each data point in the column; and
    **OnSort** , a callback to trigger sorting when a user clicks on the column header.
    Using **ColumnViewModel** , you can simplify the definition of a column in the
    grid without passing all the column properties explicitly.'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , we navigate to the **Grid** component and perform some refactoring
    to make its construction more dynamic. While the **Grid** component is already
    generic, we will work with cascading values next and want Blazor to automatically
    propagate these values type down the component tree. To achieve this descendant
    sharing, we leverage the **CascadingTypeParameter** attribute. **CascadingTypeParameter**
    allows a generic type to be shared across the component tree. Instead of passing
    the generic type **"T"** as a string, we use the **nameof()** method, achieving
    the same result while maintaining compile-time validation.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3* , we change the parameters required by **Grid** . We remove the
    **Row** parameter, as we will move the data point template into **ColumnViewModel**
    . With the **Grid** component now requiring only one **RenderFragment** parameter,
    we rename **Header** to **ChildContent** to simplify the grid’s construction later.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4* , we add a **Columns** collection that will serve as a container
    for the grid columns we will render. To populate that collection, we expose an
    **AddColumn()** method, which accepts a **ColumnViewModel** object and adds it
    to **Columns** .
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5* , we override the **OnAfterRender()** lifecycle method of the **Grid**
    component. This instructs Blazor to re-render the **Grid** component immediately
    after the initial render completes. This might seem counter-intuitive now, but
    it will make more sense when we implement the **Column** component later.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6* , we adjust the **Grid** markup to comply with the changes in the
    **@code** block. As we’ve removed the **Header** parameter, we rebuild the table
    header area. We reconstruct the **thead** content by explicitly embedding **tr**
    tags and rendering the **Label** properties of columns from the **Columns** collection.
    We also attach the declared sorting action of each column to the **@onclick**
    event of each **th** element. You attach actions to grid elements the same as
    any other HTML element.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7* , we reconstruct the table body. We replace the **Row** reference
    (which we’ve removed) with explicit **tr** tags inside the loop iterating over
    the **Data** collection. Inside each **tr** , we nest another loop, instructing
    Blazor to render each **Data** element using the template from the **Template**
    property of the current column.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 8* , we complete the **Grid** markup by constructing a **CascadingValue**
    area, where we share the current grid instance with nested components. We will
    also need the **Column** component to understand this part, so we will implement
    it next.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 9* , we create a generic **Column** component, which will be the primary
    construction element for the grid. The **Column** component intercepts the **Grid**
    instance where it is rendered and requires **Label** and **ChildContent** parameters.
    The **Label** parameter defines the column title, while **ChildContent** represents
    a template for the data point belonging to that column. This markup will be rendered
    for each element of the **Data** collection in the grid. We also declare one optional
    parameter, **OnSort** , allowing the attachment of sorting behavior triggered
    by clicking the column header.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 10* , we complete the **Column** implementation by overriding the **OnInitialized()**
    lifecycle method, where we convert the incoming parameters into a **ColumnViewModel**
    object that we then register in the **Grid** component using the previously implemented
    **AddColumn()** method. The **Column** component is markupless by design – it
    doesn’t render any markup explicitly. Instead, it registers the row template and
    column definition directly in the **Grid** instance, which knows how to construct
    the table markup from those details.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 11* , we navigate to the **TicketManager** component. First, we initialize
    a **@code** block where we implement a **Sort()** method – a behavior placeholder
    that only logs an operation intention (we will implement the sorting in a separate
    step).
  prefs: []
  type: TYPE_NORMAL
- en: In *step 12* , we reconstruct the grid content, leveraging the **Column** component.
    As all grid elements are generic and the **Grid** component cascades the generic
    parameter type downwards, we can access the **Ticket** properties with a **context**
    reference. Knowing this, we build the first column with a **Tariff** title and
    declare that for each data point, we want to render the value of the **Tariff**
    property of the current element. We also declare that the **OnSort** callback
    exposed by **Column** will trigger the **Sort()** method on the **Tariff** property.
    For the second column, we duplicate these steps for the **Price** property.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 13* , since we expect the grid to be interactive, we declare that the
    **TicketManager** component will render in **InteractiveWebAssembly** mode.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with the entire implementation in place, it will be easier to understand
    the rendering of the enhanced **Grid** component. As you can see, the **Column**
    component we use to construct the grid doesn’t carry any markup, so it will be
    fully transparent in the DOM. However, **Column** still requires cascading access
    to the **Grid** instance, which is why we put all the customizable **Grid** content
    in the **CascadingValue** tags in *step 8* . With that, each **Column** instance
    can register the render template it carries directly within the **Grid** instance,
    so it is rendered together with the **Grid** markup. This is also why we’ve overridden
    the **OnAfterRender()** lifecycle method of the **Grid** component in *step 5*
    . We must re-render the table markup after the initial render of the grid and
    after all the **Column** instances register their payload within the **Grid**
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some scenarios, you might need to attach actions to entire grid rows and
    specific grid cells. When a row overlaps a cell, you will face **event bubbling**
    . When an event, such as a mouse click or key press, occurs in the browser, it
    propagates (or bubbles) from the target element through its ancestors, resulting
    in unwanted behavior in parent elements listening for the same event. With Blazor’s
    **@onEvent:stopPropagation** attribute, you can prevent this propagation, ensuring
    that only the intended event handler executes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, we allow users to display ticket details when they click
    on a table row and add a ticket to the cart when they click on the cell with the
    price. We’ve attached the desired event handlers to the **tr** and **td** elements.
    Additionally, we’ve attached the **@onclick:stopPropagation** attribute to **td**
    with a price. Now, we prevent the click event from propagating to the parent row.
    As a result, when the user clicks the cell, Blazor executes only the **AddToCart()**
    handler and omits the **ShowTicketDetails()** handler. With **@onclick:stopPropagation**
    , we ensure that the click event is handled solely by the cell and does not affect
    the surrounding row element.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pagination refers to dividing content into separate pages, which is particularly
    crucial for tables and grids displaying large datasets. This approach improves
    the readability and navigability of data and significantly enhances performance
    by reducing the volume of data loaded and rendered at any given time. Pagination
    is often required in tables and grids to manage large amounts of data efficiently,
    preventing overwhelming users with too much information at once and ensuring that
    the application remains responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a simple pagination to the grid.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we dive in, ensure that you do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter04** / **Recipe03** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **Column** , **ColumnViewModel** , **Grid** , and **TicketManager** from
    the *Attaching actions to parts of a grid* recipe or the **Chapter04** / **Recipe02**
    directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **Samples** from the **Chapter04** / **Data** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add pagination to your **Grid** component, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new **PaginateEventArgs** record with **Page** and **Size** properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new **Paginator** component and initialize a **@code** block with two
    required parameters: a **Paginate** callback with **PaginateEventArgs** and **DataSize**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the parameters, initialize variables defining the pagination state: **TotalPages**
    , **CurrentPage** , and **PageSize** with default initial values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next to the state variables, override the **OnInitialized()** lifecycle method
    and calculate the **TotalPages** value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within the **@code** block, implement a **LoadAsync()** method, invoking
    the **Paginate** callback with the current pagination state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the loading method, define a **NextAsync()** method to enable the forward
    navigation of data pages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, next to the forward navigation, implement a **PreviousAsync()**
    method to handle backward navigation of data pages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Complete the **@code** block by overriding the **OnAfterRenderAsync()** lifecycle
    method and load the initial data page, after the first render:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move to the **Paginator** markup area and construct a container with two **button**
    elements for page navigation and an **input** field to display the **CurrentPage**
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the **Grid** component and, within the **@code** block, initialize
    a generic **Set** collection to persist currently displayed data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next to the **Set** initialization, implement a **LoadAsync()** method, accepting
    a **PaginationEventArgs** parameter, that takes a slice of data from the **Data**
    collection based on the incoming pagination state details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Jump to the **Grid** component markup and update the loop generating table
    rows to iterate over the **Set** collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within the **Grid** markup, under the table, embed the **Paginator**
    component, attaching the **LoadAsync()** method to its **Paginate** callback and
    passing the size of the **Data** collection as the **DataSize** parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we create a **PaginateEventArgs** record with **Page** and **Size**
    properties representing the currently visible page and the size of each page a
    user is viewing. Having these details allows us to fetch data in expected batches
    effectively. As we expect **PaginateEventArgs** to represent a pagination event,
    it makes sense to make the object immutable, so we declare it as a **record**
    object. To simplify the **PaginateEventArgs** initialization, we also leverage
    the primary constructor rather than the legacy one and explicit property declaration.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , we introduce a **Paginator** component to encapsulate the grid
    pagination logic. First, we initialize a **@code** block within **Paginator**
    . We declare a **Paginate** callback that returns **PaginateEventArgs** to communicate
    page navigation changes. We also declare a **DataSize** parameter. Knowing the
    amount of data to paginate allows us to improve the pagination experience by setting
    the maximum page a user can reach.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 3* , we initialize three state properties: **TotalPages** , indicating
    where the pagination navigator should stop; **CurrentPage** , indicating the current
    page a user is viewing; and **PageSize** , defining how many elements we allow
    to load per page. For **CurrentPage** , we set the initial value to **1** since
    we naturally start from the first page. We also fix **PageSize** to **5** , allowing
    us to focus on the pagination behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4* , we override the **OnInitialized()** lifecycle method of **Paginator**
    to calculate the **TotalPages** value based on the incoming **DataSize** parameter
    and the **PageSize** variable. We implement the simplest arithmetic calculation
    that always rounds up to the next whole number, whenever the division of **DataSize**
    and **PageSize** is an odd number, indicating that the last page is not full.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5* , we implement a **LoadAsync()** method, which is central to the
    pagination request communication. Every time Blazor invokes **LoadAsync()** ,
    we create a **PaginationEventArgs** instance from the current value of **CurrentPage**
    and **PageSize** variables and asynchronously pass it to the **Paginate** callback
    for the callback consumer to interpret.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6* , we construct the first part of the **Paginator** navigation capabilities
    by implementing a **NextAsync()** method. **NextAsync()** allows the user to fetch
    the next page of data – we check whether the user is already on the last available
    page to prevent further navigation; if not, we increment **CurrentPage** and invoke
    the **LoadAsync()** method.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7* , we construct the **NextAsync()** counterpart, **PreviousAsync()**
    . The **PreviousAsync()** method allows the user to navigate backward and fetch
    the previous dataset. To prevent the user from navigating too far back, we check
    whether **CurrentPage** is already the first available page. If not, we decrease
    **CurrentPage** and invoke **LoadAsync()** .
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we must cover is the initial loading of data. In *step 8* , we
    override the **OnAfterRenderAsync()** lifecycle method of **Paginator** . After
    the first render, we invoke **LoadAsync()** to instruct Blazor to load the defined
    initial page with the specified number of elements.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 9* , we build the **Paginator** markup. We construct a primitive bar
    with two buttons allowing navigation back and forth using **PreviousAsync()**
    and **NextAsync()** respectively. We also add a disabled input field displaying
    the current page based on the **CurrentPage** variable.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 10* , we move to the **Grid** component and enhance it to comply with
    **Paginator** and pagination. First, we focus on the **@code** block and declare
    a generic **Set** collection to store the currently fetched dataset.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 11* , we implement a **LoadAsync()** method that consumes **PaginateEventArgs**
    and reacts to the **Paginator** callback. Inside **LoadAsync()** , we use **LINQ
    methods** to load only the required elements from **Data** . We use the **Skip()**
    method to skip elements the user has already seen. Since the **Paginator** component
    starts the page count from **1** while collection indexing starts from **0** ,
    we reduce the **args.Page** value by **1** and then multiply it by **args.Size**
    to get the number of elements to omit from the start of the **Data** collection.
    Then, we use a **Take()** method to fetch the desired amount of elements.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 12* , we jump to the **Grid** markup, locate the loop where we iterate
    over **Data** elements, and update the loop to work with **Set** .
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in *step 13* , we embed the **Paginator** component into the **Grid**
    markup. We attach the **LoadAsync()** method to the **Paginate** callback and
    count the **Data** elements to provide the required **DataSize** parameter.
  prefs: []
  type: TYPE_NORMAL
- en: With very little code, we have arrived at a fully functional and generic pagination
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Grid loading with a functional pagination bar](img/B22020_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Grid loading with a functional pagination bar'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the pagination implementation, we have some methods returning **Task** that
    we didn’t declare as **async** but rather returned the **Task.CompletedTask**
    object. This approach is beneficial when we don’t perform asynchronous operations
    inside the method but must adhere to an asynchronous method signature. Returning
    **Task.CompletedTask** is more efficient in such scenarios because we avoid the
    overhead of the async state machine that the compiler generates for **async**
    methods. By not awaiting **Task** and simply returning **Task.CompletedTask**
    , we minimize unnecessary performance costs associated with task scheduling and
    context switching.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we also saw the LINQ methods in action. LINQ methods could fill
    a book on their own, so if you’d like to explore that topic, head over to [https://learn.microsoft.com/en-us/dotnet/csharp/linq/](https://learn.microsoft.com/en-us/dotnet/csharp/linq/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Implementing sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we dive into organizing data within grids by arranging rows
    based on column values. Sorting allows users to easily navigate and analyze data
    by prioritizing it according to relevant criteria, such as alphabetical order,
    numerical values, dates, or custom parameters. This capability becomes increasingly
    important in applications dealing with extensive datasets, where locating specific
    information or understanding data trends can become cumbersome without effective
    sorting mechanisms. By introducing sorting functionalities, developers can significantly
    improve the user experience, offering intuitive interactions and insights into
    the data presented.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s enhance the grid with sorting functionality that users can trigger by
    clicking on the grid column headers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we explore sorting in a grid, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter04** / **Recipe04** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **Column** , **ColumnViewModel** , **Grid** , **PaginateEventArgs** , **Paginator**
    , and **TicketManager** from the *Implementing pagination* recipe or from the
    **Chapter04** / **Recipe04** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **Samples** from the **Chapter04** / **Data** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to add sorting to a grid:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **ColumnViewModel** class and replace the **OnSort** callback
    with a **Property** delegate, encapsulating the logic to select a property from
    a generic model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go to the **@code** block of the **Column** component and replace the **OnSort**
    parameter with a **Property** delegate parameter, allowing you to pass a property
    selector from a generic model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still in the **Column** component, fix the implementation of the overridden
    **OnInitialized()** method by updating the **ColumnViewModel** construction to
    utilize the **Property** parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move to the **Grid** component. At the end of the **@code** block, declare
    variables to persist the current sorting column and order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the sorting state variables, add a **PaginatorRef** variable to allow
    referencing the **Paginator** component from within the **Grid** code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Complete the **@code** block of the **Grid** component, by implementing a **SortAsync()**
    method, allowing you to dynamically sort the **Data** collection based on the
    **Property** selector set for each **ColumnViewModel** column object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **Grid** markup, replace the delegate attached to the table column headers
    with the newly implemented **SortAsync()** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within the **Grid** markup, locate the **Paginator** instance and attach
    its reference to the **PaginatorRef** variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the **TicketManager** component and fix the **Column** instances
    by passing in the **Property** selector and defining the **Ticket** properties
    to sort on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we update the **ColumnViewModel** class and replace the **OnSort**
    callback with a generic **Func<T, object>** . **Func<T, object>** is a delegate
    that represents a method returning an object from a given type, **T** . We use
    **Func<T, object>** as a selector for the property to sort by and name it **Property**
    intuitively.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , we jump to the **Column** component to update the **Grid** building
    block with the same logic as we did for **ColumnViewModel** . Inside the **@code**
    block of **Column** , we replace the **OnSort** callback with the **Func<T, object>**
    parameter. In *step 3* , we fix the mapping in the overridden **OnInitialized()**
    method to pass the sorting property selector into the **ColumnViewModel** constructor
    and consequently into the **Grid** instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 4* , we navigate to the **Grid** component and implement the backing
    logic for the sorting feature. First, we declare two variables representing the
    current state of the sorting: **_currentSortColumn** , indicating which sorting
    property is currently selected, and an **_isAsc** flag, implying whether the sorting
    order is ascending or descending.'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5* , we introduce a **PaginatorRef** variable of type **Paginator**
    . It might look a bit confusing at first glance. Using a component as a variable
    in your C# code in Blazor allows you to interact with the component’s public API.
    Furthermore, with the **@ref** attribute, you can capture a reference to the rendered
    component and leverage its methods and properties. But **@ref** has one major
    limitation – the reference is only populated after the component rendering completes.
    Since Blazor’s rendering process is asynchronous, any attempt to use the reference
    immediately after component initialization may fail because the reference might
    not yet be available. Therefore, you must ensure that you access the **@ref**
    bound reference only after the component render cycle completes.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6* , we implement a **SortAsync()** method, the center of our sorting
    logic. The **SortAsync()** method requires a **ColumnViewModel** object to define
    the sorting to perform. First, we determine the sorting order by checking whether
    the current sorting column label matches the one selected by the user. If they
    match, it indicates the user is trying to invert the sorting order, so we flip
    the current value of **_isAsc** . Otherwise, we set it to ascending order, as
    expected for the initial behavior. Next, we leverage a generic **Comparison**
    C# object. The **Comparison<T>** delegate represents a comparison method that
    compares two objects of the same type. We build the **comparer** delegate using
    a lambda expression that compares the **left** and **right** objects in the collection
    using the default **Comparer** . The **Comparer<T>** class provides a way to compare
    two objects and returns an integer indicating their relative order. By checking
    **_isAsc** , we can negate the comparison result to arrive easily at a descending
    order. With the **comparer** instance in place, we use the **Sort()** LINQ extension
    method on the **Data** collection to reshuffle the elements according to our logic.
    Finally, we update the current sorting column reference with the latest **column.Label**
    value and invoke the **LoadAsync()** method exposed by the **PaginatorRef** object
    to reload the dataset with the new sorting.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7* , we jump to the **Grid** markup, locate the table header area where
    we render each table column header, and attach the **SortAsync()** method to the
    **@onclick** event handler with the current **column** reference. In *step 8*
    , we scroll down to where we constructed the **Paginator** instance and, with
    the help of the **@ref** attribute, attach the **Paginator** instance to the **PaginatorRef**
    variable we have in the code part of the component.
  prefs: []
  type: TYPE_NORMAL
- en: After all the sorting enhancements, the **TicketManager** component is no longer
    compatible. In *step 9* , we move to the **TicketManager** markup and update the
    **Column** instances by declaring the **Property** delegate with a lambda expression
    for each column we render.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing infinite scrolling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In user experience trends, there’s a shift from traditional pagination to a
    more dynamic and seamless infinite scrolling approach. **Virtualize** , integrated
    into the Blazor framework, was designed to enhance the user interface by loading
    content on-demand as users scroll through the page. It smartly manages resources
    by only rendering items in the viewport and fetching additional content as needed,
    significantly improving performance and user experience, especially in applications
    dealing with large datasets. By implementing infinite scrolling with the **Virtualize**
    component, you can offer a smoother, more engaging interaction pattern, eliminating
    the need for manual page navigation and making content exploration effortless.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s construct a simple grid and implement infinite scrolling, leveraging the
    **Virtualize** component.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To simplify the grid itself and focus on the infinite scrolling implementation,
    we will not leverage any grid markup built in prior recipes but rather start from
    scratch. But before you dive in, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter04** / **Recipe05** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **Samples** from the **Chapter04** / **Data** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Navigate to the **Program** file of your application and register the **TicketsApi**
    service, from **Samples** , in the application dependency injection container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to add infinite scrolling to a grid:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a generic **Grid** component using the **typeparam** attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the **@code** block of the **Grid** component, declare three required
    parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The three parameters are:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Provider** – delegate that encapsulates data fetching'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Header** – **RenderFragment** for the table header template'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Row** – generic **RenderFragment** for the table row template'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Below the parameters, implement a **LoadAsync()** method to handle dynamic
    data loading; accepting **ItemsProviderRequest** as input and returning a generic
    **ItemsProviderResult** object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move to the **Grid** component’s markup area and construct a table: embed the
    **Header** template within the **<thead>** tags and for the **<tbody>** section,
    utilize the **Virtualize** component, linking it to the **LoadAsync()** method
    via its **ItemsProvider** parameter, and pass the **Row** template as its **ChildContent**
    parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a routable **TicketManager** component. Set **TicketManager** to render
    in **InteractiveWebAssembly** mode and inject **TicketsApi** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the **TicketManager** markup, incorporate the newly created **Grid**
    component. Attach the **Tickets.GetAsync()** method to the **Provider** parameter
    and define the **Header** and **Row** templates for rendering **Ticket** properties
    within the grid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we create a generic **Grid** component that serves as the foundation
    for dynamically displaying data in a tabular format with infinite scrolling capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , we declare a few required parameters within the **Grid** component.
    **Header** and **Row** , of type **RenderFragment** , enable the customization
    of the table’s header and facilitate the dynamic rendering of table rows. Additionally,
    we specify a **Provider** delegate to encapsulate the logic for fetching data.
    We intentionally designed **Provider** to match the **ItemsProvider** signature
    required by the **Virtualize** component, ensuring compatibility and seamless
    integration.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3* , we implement a **LoadAsync()** method that plays a pivotal role
    in fetching data in response to the user’s scroll actions. It accepts an **ItemsProviderRequest**
    parameter and returns an **ItemsProviderResult<T>** object to enable the **Virtualize**
    component continuous population of the grid as users scroll through the content.
    **ItemsProviderRequest** provides the current state of scrolling, exposing **StartIndex**
    , which defines from which index the next data batch should start. To construct
    the **ItemsProviderResult<T>** response, we need a subset of new objects to render
    and a total number of objects in the collection. The **Virtualize** component
    uses that total to safely stop data fetching and avoid throwing an indexing exception.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4* , we set up the **Grid** markup. We add a **<table>** structure
    where we place the **Header** template within **<thead>** tags and utilize the
    **Virtualize** component within the **<tbody>** tags. By attaching the **LoadAsync()**
    method as the **ItemsProvider** parameter and including the **Row** template as
    the **Virtualize** component **ChildContent** , the grid dynamically renders additional
    rows of data, creating an infinite scrolling effect.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the usage of the **Grid** component, in *step 5* , we introduce
    a routable **TicketManager** component. We set **TicketManager** to render in
    **InteractiveWebAssembly** mode and inject **TicketsApi** as we will need it as
    the data source. In *step 6* , we integrate the **Grid** component into the **TicketManager**
    markup, with **Tickets.GetAsync** serving as the data provider and **Header**
    and **Row** templates specified to display the properties of the **Ticket** objects.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Utilizing the **Virtualize** component in your Blazor applications brings forth
    a multitude of benefits that enhance both performance and user experience:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, **Virtualize** dramatically improves performance and reduces memory
    usage when dealing with large datasets. This efficiency gain comes from its rendering
    approach, where only a visible subset of items is rendered at any given time,
    reducing the overall load on the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, the simplicity offered by **Virtualize** cannot be overstated. You
    can implement sophisticated infinite scrolling functionalities with minimal code,
    as the component abstracts the complexities of item virtualization and automatic
    event handling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, **Virtualize** provides remarkable flexibility, enabling seamless integration
    with a wide array of data sources. This flexibility is especially beneficial for
    applications requiring real-time data fetching, as you can tailor the **ItemsProvider**
    delegate to suit specific data fetching logic, ensuring that applications remain
    responsive and up to date with the latest information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing QuickGrid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we’ll explore a powerful component now embedded directly into
    the Blazor framework – **QuickGrid** . QuickGrid simplifies the creation and management
    of dynamic, data-driven grids in Blazor applications, offering out-of-the-box
    functionalities such as sorting, pagination, and filtering. This component stands
    out for its ease of implementation and high performance in presenting and manipulating
    large datasets thanks to the baked-in virtualization. QuickGrid eliminates the
    need for additional NuGet packages, streamlining development processes and reducing
    project complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through the essentials of QuickGrid and showcase how simple it is
    to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we explore the QuickGrid implementation, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter04** / **Recipe06** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **Samples** from the **Chapter04** / **Data** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Navigate to the **Program** file of your application and register the **TicketsApi**
    service, from **Samples** , in the application dependency injection container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To render a grid utilizing QuickGrid, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **.csproj** configuration file of your project and add the
    **Microsoft.AspNetCore.Components.QuickGrid** package to your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new routable **TicketManager** component, with a reference to the
    **QuickGrid** package, that renders in **InteractiveWebAssembly** mode, and inject
    the **TicketApi** service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **@code** block of the **TicketManager** component, introduce a **Pagination**
    variable of type **PaginationState** to configure data pagination of the **QuickGrid**
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **TicketManager** markup, construct the **QuickGrid** component with
    nested **PropertyColumn** components to define the data columns and integrate
    a **Paginator** component to manage data pagination:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we navigate to the configuration file of the project (the one
    with a **.csproj** extension) and add the **Microsoft.AspNetCore.Components.QuickGrid**
    package into the project. QuickGrid is officially a part of the Blazor ecosystem
    but isn’t included in the Blazor project by default.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , we create a new routable **TicketManager** component, where we
    will put **QuickGrid** to the test. As the grid will be interactive, we declare
    **TicketManager** to render in **InteractiveWebAssembly** mode. We also include
    a **using** directive, referencing the **QuickGrid** namespace. And lastly, we
    inject the **TicketsApi** service to have a data source for the grid.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3* , we initialize the **@code** block of the **TicketManager** component
    where we construct an instance of a **Pagination** variable and set its **ItemsPerPage**
    property. **QuickGrid** requires a **PaginationState** object to enable the pagination.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in *step 4* , we embed **QuickGrid** in the **TicketManager** markup.
    We attach the **Tickets.Get()** method and the **Pagination** object to **QuickGrid**
    ’s **Items** and **Pagination** parameters respectively. Next, we construct grid
    columns using **PropertyColumn** components. We specify properties to render with
    a delegate and enable sorting by setting the **Sortable** parameter accordingly.
    For the **Price** column, we additionally set the **Format** parameter. The **QuickGrid**
    component will automatically apply this formatting to all prices in that column.
    Lastly, we incorporate a **Paginator** component that we link to the same **Pagination**
    variable as the **QuickGrid** Instance. **Paginator** exposes the pagination UI
    to the user and executes navigation requests directly on **QuickGrid** .
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, we get a fully functional, optimized, and feature-rich grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: Grid with sortable columns and pagination rendered with QuickGrid](img/B22020_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Grid with sortable columns and pagination rendered with QuickGrid'
  prefs: []
  type: TYPE_NORMAL
