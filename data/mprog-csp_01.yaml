- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: How Can Metaprogramming Benefit You?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元编程如何对你有益？
- en: So, what is **metaprogramming** and why should you care? If you picked up this
    book hoping to learn about programming in the **metaverse**, you’re about to become
    very disappointed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是**元编程**，为什么你应该关心？如果你拿起这本书希望学习关于**元宇宙**编程的知识，你很快就会非常失望。
- en: Metaprogramming is all about code treating other code as data. This could be
    just to understand and reason about the code, or actually create new code based
    on metadata implicitly through structure or explicitly added.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程全部关于代码将其他代码视为数据。这可能只是为了理解和推理代码，或者实际上基于元数据通过结构或显式添加来隐式地创建新代码。
- en: “But why should I care about that,” you might ask? “Isn’t it just enough to
    write the code and get it shipped?” In this chapter, we will look into the concrete
    benefits you can get from doing metaprogramming and how it can benefit you daily.
    We will also provide tips on how it can increase productivity and remove tedious
    tasks we developers tend to have to do.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: “但我为什么要关心这些呢？”你可能会问，“难道仅仅编写代码并交付就足够了吗？”在本章中，我们将探讨从进行元编程中可以获得的实际好处，以及它如何使你日常受益。我们还将提供有关如何提高生产力和消除我们开发者往往必须做的繁琐任务的技巧。
- en: 'The main objective of this chapter is to introduce you to metaprogramming and
    examples of use cases. In doing this, we’ll see some of the building blocks .NET
    has for metaprogramming. In this chapter, we’ll cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是向你介绍元编程及其用例示例。在这个过程中，我们将了解.NET为元编程提供的构建块。在本章中，我们将涵盖以下主题：
- en: Reasoning about your code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对你的代码进行推理
- en: Removing manual structures and processes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除手动结构和流程
- en: By the end of this chapter, you should have some good ideas and inspiration
    for how metaprogramming can benefit you. You should have also gained insight into
    what metaprogramming is all about.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对元编程如何对你有益有一些很好的想法和灵感。你也应该对元编程的实质有所了解。
- en: Reasoning about your code
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对你的代码进行推理
- en: The software industry is very young. In the last 20-30 years, we’ve seen a dramatic
    increase in its usage.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 软件行业非常年轻。在过去的20-30年里，我们看到了其使用的显著增长。
- en: Today, software is engraved into every aspect of our lives – our work, our transportation,
    and in our homes, down to the smart light bulbs many of us have installed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，软件已经融入我们生活的方方面面——我们的工作、我们的交通，以及我们的家庭，甚至包括我们许多人安装的智能灯泡。
- en: With the breadth of applications and users using the software we make, there
    are expectations from the software. Users today expect far more from software
    than they did 20 years ago. And since software is so engraved in our lives, we
    are far more vulnerable, which makes it a risk factor.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们制作的软件的应用范围和用户众多，软件有相应的期望。今天的用户对软件的期望远高于20年前。由于软件在我们的生活中如此根深蒂固，我们变得更加脆弱，这使其成为一个风险因素。
- en: In this section, we’ll discuss why you, as a developer, should care about metaprogramming.
    We’ll go through the developer concerns, how we can do some nifty automation,
    and cover some of the basics around metaprogramming.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论为什么作为开发者的你应该关心元编程。我们将探讨开发者的关注点，如何进行一些巧妙的自动化，并介绍元编程的一些基础知识。
- en: Developer concerns
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发者关注点
- en: For us developers, we have a lot of different aspects to cover to guarantee
    the success of our software.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们开发者来说，我们需要涵盖很多不同的方面来保证我们软件的成功。
- en: End users have high expectations of great user experiences, and they expect
    to be put in the pit of success. We also need to be empathetic to the different
    types of users our system will have and make sure it is accessible to everyone.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户对优秀的用户体验有很高的期望，他们希望被置于成功的顶峰。我们还需要对我们的系统将拥有的不同类型的用户表示同情，并确保它对每个人都是可访问的。
- en: Our systems need to maintain the integrity of their data and help the end users
    do the right thing. To do this, we need to validate all the input according to
    what we expect or what our data model requires. In addition, we need to have business
    rules that enforce the integrity of the system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统需要保持其数据的完整性，并帮助最终用户做正确的事情。为此，我们需要根据我们期望的或我们的数据模型要求的来验证所有输入。此外，我们还需要有强制执行系统完整性的业务规则。
- en: The data is also something we want to protect, so security plays an important
    role. Users need to be authenticated and we also want to make sure the user has
    the correct authorization to perform the different tasks of the system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数据也是我们想要保护的东西，因此安全性扮演着重要的角色。用户需要进行身份验证，我们还想确保用户有执行系统不同任务的正确授权。
- en: We must also make sure that our systems don’t have security flaws that would
    allow hackers to breach the system. The input from users also needs to be sanitized,
    to prevent malicious attacks through things such as **SQL injection**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须确保我们的系统没有安全漏洞，否则黑客可以入侵系统。用户的输入也需要被清理，以防止通过诸如**SQL注入**之类的恶意攻击。
- en: For our software to be available to our users, we need to have it running somewhere,
    on an on-premises server or servers with a hosting partner, or in the cloud, be
    it physical or virtual. This means we need to think about how we package the software
    and then how we get it onto the running environment.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的软件对用户可用，我们需要确保它在某处运行，无论是在本地服务器上还是在托管合作伙伴的服务器上，或者在云中，无论是物理的还是虚拟的。这意味着我们需要考虑如何打包软件，然后如何将其部署到运行环境中。
- en: Once it is running, we have to make sure it runs all the time and doesn’t have
    any downtime; our users rely on it. For this, we want to consider having more
    than one instance of the system running so that it can fail over to a second instance
    if the primary one goes down.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行，我们必须确保它始终运行，没有停机时间；我们的用户依赖于它。为此，我们希望考虑运行多个系统实例，以便在主实例出现故障时可以切换到第二个实例。
- en: We also need to make sure that the environment it is running in can handle the
    number of users it is targeting.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保运行环境能够处理它所针对的用户数量。
- en: Instead of just having a fail-over instance, we can scale out horizontally and
    have a load balancing mechanism spreading the users across the different instances
    we have. This makes our system a distributed system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅要有故障转移实例，还可以水平扩展并有一个负载均衡机制，将用户分散到我们拥有的不同实例中。这使得我们的系统成为一个分布式系统。
- en: 'Those are a lot of different concerns. Ideally, you want to have different
    people doing different aspects of the job, but this is not always the case (depending
    on the size of the organization, as well as its culture). Today, you’ll often
    see in job ads that companies are looking for *full stack developers*. In many
    cases, this could mean the expectations are that you need to work with all of
    the following aspects:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是很多不同的关注点。理想情况下，你希望有不同的人做不同方面的工作，但这种情况并不总是如此（取决于组织的规模以及其文化）。今天，你经常在招聘广告中看到公司正在寻找*全栈开发者*。在许多情况下，这可能意味着期望你需要与以下所有方面合作：
- en: '**User experience**: This is all about the interaction, flows, and how it all
    feels'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户体验**：这关乎交互、流程以及整体的感觉'
- en: '**Accessibility**: This involves creating empathetic software that is accessible
    to those with disabilities'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可访问性**：这涉及到创建对残疾人友好的同理心软件'
- en: '**Frontend code**: This is the layout, styling, and necessary logic to make
    the user experience come to life'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端代码**：这是布局、样式以及使用户体验生动起来的必要逻辑'
- en: '**Backend code**: This is for creating the glue that represents the domain
    we’re working in'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后端代码**：这是为了创建代表我们正在工作的领域的粘合剂'
- en: '**Data modeling**: This is how we store the data and model it for the usage
    we need'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据建模**：这是我们如何存储数据以及如何为我们需要的用途建模'
- en: '**Authentication and authorization**: This is for making sure users are authenticated
    and the proper authorization policies are applied to the different features'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证和授权**：这是为了确保用户已经通过身份验证，并且对不同的功能应用了适当的授权策略'
- en: '**Security**: This makes the application robust from any attacks and protects
    the data'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：这使得应用程序能够抵御任何攻击并保护数据'
- en: '**DevOps**: This involves delivering features to production in a timely fashion
    without any ceremony'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DevOps**：这涉及到及时地将功能交付到生产环境中，而不需要任何仪式'
- en: Automation
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化
- en: Being humans, we make mistakes and we forget things. Sometimes, this has some
    really bad outcomes, such as systems going down, or worse, such as being breached
    by hackers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 作为人类，我们会犯错，会忘记事情。有时，这会有一些非常糟糕的结果，比如系统崩溃，或者更糟的是，被黑客入侵。
- en: Luckily, computers are good at doing what they’re told and repeating it endlessly.
    They never complain and don’t make mistakes. This means there are great opportunities
    for streamlining a lot of our work. As the industry has matured over the years,
    we have seen improved workflows and tooling that can help us achieve what we aim
    to achieve, often taking away tedious and time-consuming tasks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，计算机擅长执行它们被告诉的事情并且无限重复。它们从不抱怨，也不犯错误。这意味着我们有大量工作流程简化的机会。随着行业多年的成熟，我们看到了改进的工作流程和工具，这些可以帮助我们实现我们的目标，通常可以消除繁琐和耗时的工作。
- en: A great example of automation is what has happened in the last decade in cloud
    computing. Before this, we had to set up physical hardware and often had manual
    routines for getting our software onto that hardware. This has completely changed
    into us being able to spin up anything our hearts desire with a few clicks, connect
    it to some continuous deployment software that will build our software, and automatically
    get it onto the running environment. All this can be achieved in minutes, rather
    than hours or days.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化的一个绝佳例子是过去十年云计算领域所发生的变化。在此之前，我们必须设置物理硬件，并且通常需要手动流程将我们的软件部署到该硬件上。这一切已经完全改变，我们现在只需点击几下就能启动我们想要的一切，将其连接到一些持续部署软件，它会构建我们的软件，并自动将其部署到运行环境中。所有这些都可以在几分钟内完成，而不是几个小时或几天。
- en: Metaprogramming
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元编程
- en: Where am I going with all this? Wasn’t this book supposed to be about something
    called metaprogramming?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我为什么要讲这么多？这本书不是应该讲关于元编程的内容吗？
- en: Metaprogramming is all about additional information surrounding your code. This
    information is sometimes implicit – that is, it’s already there. Sometimes, however,
    it needs to be added explicitly or deliberately by you, as a developer.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程全部关于围绕你的代码的附加信息。这些信息有时是隐含的——也就是说，它已经存在。然而，有时它需要你作为开发者明确或故意地添加。
- en: The computer that runs the software only understands the machine language instructions
    laid out in memory for the CPU to execute. For us humans, this is less than intuitive.
    Early on, we came up with languages that would help us write something more friendly
    and we could reason about more easily. This started with the **assembly language**
    and, later, higher-level languages that would compile down to assembly language.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 运行软件的计算机只理解存储在内存中并为CPU执行准备的机器语言指令。对我们人类来说，这不太直观。早期，我们发明了可以帮助我们编写更友好、更容易推理的语言。这始于**汇编语言**，后来是能够编译成汇编语言的高级语言。
- en: With this tooling in place, we gained the ability to not just translate from
    one language into another, but also to reason about what was going on with our
    code. In 1978, Stephen C. Johnson, from Bell Labs, came up with what he called
    **lint** – a static code analysis tool that could be used to reason about C code
    and detect potential issues with it. Today, this is common with most programming
    languages. For web development in **JavaScript** or **TypeScript**, we could typically
    add tools such as **ESLint** to our build pipelines to do this. With **C#**, we
    have this built into the compiler, and with the Roslyn compiler, it is completely
    extensible with our own custom rules, something we will cover in [*Chapter 17*](B19418_17.xhtml#_idTextAnchor299),
    *Static* *Code Analysis*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些工具，我们获得了不仅仅是将一种语言翻译成另一种语言的能力，还可以推理我们的代码中正在发生的事情。1978年，贝尔实验室的Stephen C. Johnson提出了他称之为**lint**的工具——一个静态代码分析工具，可以用来推理C代码并检测其潜在问题。如今，这已成为大多数编程语言的常见做法。对于**JavaScript**或**TypeScript**的Web开发，我们通常可以在构建管道中添加像**ESLint**这样的工具来完成这项工作。对于**C#**，这已经内置到编译器中，并且使用Roslyn编译器，它可以完全通过我们自己的自定义规则进行扩展，这一点我们将在[*第17章*](B19418_17.xhtml#_idTextAnchor299)，*静态代码分析*中介绍。
- en: For programming languages such as **C**/**C++** that compile down to something
    that runs natively on the CPU, we’re limited to what we can reason about at the
    compile level. However, with programming languages such as Java or C#, often referred
    to as managed languages, we’re now running code in a managed environment. The
    code we write compiles down to an intermediate language that will be translated
    on the fly while running. These languages then carry information with them about
    the code we wrote – this is known as **metadata**. This lets us treat our programs
    or others as data at runtime and allows us to reason about the code; we can even
    discover code at runtime.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像**C**/**C++**这样的编程语言，它们编译成在CPU上本地运行的代码，我们在编译级别上所能推理的有限。然而，对于像Java或C#这样的编程语言，通常被称为托管语言，我们现在在托管环境中运行代码。我们编写的代码编译成中间语言，在运行时会被即时翻译。这些语言携带有关我们编写的代码的信息——这被称为**元数据**。这使得我们可以在运行时将我们的程序或他人视为数据，并允许我们推理代码；我们甚至可以在运行时发现代码。
- en: With C#, from *version 1*, we could add additional information and more metadata.
    Through the use of C# **attributes**, we could adorn things such as types, properties
    on types, and methods with additional information. This information would carry
    through to the running program and is something we can use to reason about our
    software.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从*C#的*第一个版本开始，我们可以添加额外的信息和更多的元数据。通过使用C# **特性**，我们可以给类型、类型上的属性和方法添加额外的信息。这些信息会传递到运行程序中，我们可以用它来对软件进行推理。
- en: 'For instance, with attributes, we can now add additional information that we
    can reason about both at compile time and runtime. We can do things such as marking
    properties on an object with validation information, such as **[Required]**:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于属性，我们现在可以添加额外的信息，我们可以在编译时和运行时对其进行分析。我们可以做诸如在对象上标记验证信息，例如**[必需]**：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code represents what is needed to register a person. All the properties
    that we required have the **[Required]** attribute as metadata.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码表示注册一个人所需的内容。我们需要的所有属性都有**[必需]**属性作为元数据。
- en: Now that we have added metadata to the code, we can take concrete actions based
    on it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将元数据添加到代码中，我们可以根据它采取具体行动。
- en: Removing manual structure and process
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除手动结构和流程
- en: Adding explicit metadata is great for visibility and makes it very explicit
    in the code for the type of metadata that has been added. However, this metadata
    is not actionable on its own. This means that there is nothing that will inherently
    deal with it – for instance, a property is required, as we’ve seen.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 添加显式元数据对于可见性很好，并且使代码中添加的元数据类型非常明确。然而，这些元数据本身是不可执行的。这意味着没有什么是固有的来处理它——例如，我们看到的属性是必需的。
- en: This metadata gives us the power to not only reason about the metadata surrounding
    our code but put it into action. We can build our systems in a way that leverages
    this information to make decisions for us, or we could automate tedious tasks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种元数据使我们能够不仅对围绕我们的代码的元数据进行推理，而且将其付诸行动。我们可以构建我们的系统，使其利用这些信息为我们做出决策，或者我们可以自动化繁琐的任务。
- en: One of the most common things I’ve seen throughout my career is what I call
    **recipe-driven development**. Code bases tend to settle on a certain structure
    and a certain set of things developers need to do when creating features in it.
    These *recipes* are then often written down as a part of the documentation for
    the code base and something everyone has to read and make sure they follow. This
    is not necessarily a bad thing, and I think all code bases have this to some degree.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的整个职业生涯中，我见到的最常见的事情是我称之为**步骤驱动开发**。代码库往往会固定一种结构，并且在创建其中的功能时，开发者需要执行一系列特定的操作。这些*步骤*通常被记录为代码库文档的一部分，每个人都需要阅读并确保遵循。这并不一定是一件坏事，我认为所有代码库都有这种程度的情况。
- en: Taking a step back, there might be some potential to improve our productivity
    and have to write less code. The recipes and patterns could be formalized and
    automated. The main reason for doing so is that following recipes can be error-prone.
    We can forget to do something or do it wrong or maybe even mix up the ordering
    of steps.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 退一步，可能会有一些潜在的改进我们的生产力和减少代码量的机会。这些步骤和模式可以被形式化和自动化。这样做的主要原因是因为遵循步骤可能会出错。我们可能会忘记做某事或者做错，甚至可能混淆步骤的顺序。
- en: 'Imagine that you have an API and that for every action, you have the following
    recipe:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个API，并且对于每个操作，你都有以下步骤：
- en: Check if the user is authorized
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查用户是否有权限
- en: Check if all the input is valid
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查所有输入是否有效
- en: Check for malicious input (for example, SQL injection)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查恶意输入（例如，SQL注入）
- en: Check if the action is allowed by the domain logic, typically business-specific
    rules
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查操作是否被域逻辑允许，通常是特定于业务的规则
- en: Perform the business logic
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行业务逻辑
- en: Return the correct HTTP status code and result, depending on whether or not
    we’re successful
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据是否成功返回正确的HTTP状态码和结果
- en: Those are a lot of concerns mixed into one place. At this point, you’re probably
    thinking that this is not how we do things in modern **ASP.NET** API development.
    And that is correct – they are typically split into concerns and things such as
    the SQL injection handled by the pipeline.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是在同一个地方混合了很多关注点。在这个时候，你可能认为这不是我们在现代**ASP.NET** API开发中做事的方式。这是正确的——它们通常被分成关注点和像SQL注入这样的管道处理的事情。
- en: Important note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We’ll revisit how ASP.NET leverages metaprogramming to make the developer experience
    it offers in [*Chapter 3*](B19418_03.xhtml#_idTextAnchor041), *Demystifying through
    Existing* *Real-World Examples*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第3章*](B19418_03.xhtml#_idTextAnchor041)“通过现有*现实世界示例*去神秘化”中重新审视ASP.NET如何利用元编程来提供开发者体验。
- en: Even though these things might not be in the same method and spread out, they
    are still concerns we have to be aware of, and a recipe would then still state
    that these things would need to be done. Often, they are repetitive and could
    potentially be optimized for an improved developer experience and also reduce
    the risk of fatal errors in the system.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这些事情可能不在同一种方法中且分散开来，它们仍然是我们必须注意的问题，因此食谱会明确指出这些事情需要被执行。通常，它们是重复的，并且有可能被优化以提高开发者的体验，同时降低系统发生致命错误的风险。
- en: Maintaining software
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件维护
- en: Another aspect of this type of repetitive code is that all code we add to our
    system is code we need to maintain. Building out a feature might not take that
    long, but chances are the code needs to be maintained for years to come. It might
    not be maintained by you, but by others on the team or a successor to you. So,
    we should be optimizing our code bases for maintenance first. Getting features
    out the door in a timely fashion is expected of us, but if we don’t consider the
    maintenance of the code, we, as the owners of the code, will suffer when it needs
    to be maintained.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重复代码的另一个方面是，我们添加到系统中的所有代码都需要维护。构建一个功能可能不会花费太多时间，但很可能会需要多年维护。可能不是由你维护，而是由团队中的其他人或你的继任者维护。因此，我们应该首先优化我们的代码库以适应维护。及时推出功能是我们所期望的，但如果我们不考虑代码的维护，作为代码的所有者，当需要维护时，我们将遭受痛苦。
- en: Maintenance is not just about keeping the code working and delivering on its
    promise. It’s also about its ability to change and adapt to new requirements,
    whether business or technical. The very beginning of a project is when you know
    the least about it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 维护不仅仅是保持代码正常运行并履行其承诺。它还关乎其适应和适应新需求的能力，无论是业务需求还是技术需求。项目的初期正是你对它了解最少的时候。
- en: So, planning for this is super hard and would require us to be able to predict
    the future. But we can write our code in a way that would make it more adaptable
    to change.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为此进行规划非常困难，需要我们能够预测未来。但我们可以编写代码，使其更适应变化。
- en: Instead of repeating all this code all over the place, we could put metadata
    into our code that we could leverage. This is typically what ASP.NET supports
    – for instance, for authorization with the **[Authorize]** attribute for controllers.
    It would require a specific policy to be fulfilled, such as the user having to
    be in a role. If our system has a deliberate structure for our features, you might
    find natural groupings of features belonging to specific roles. We could then
    reason about this structure by looking at the namespace metadata on the type and
    putting in the correct authorization rules. For developers, you replaced the need
    for an explicit piece of information and made it implicit through the structure.
    This may seem like a small thing, but throughout the lifetime of the code base,
    this type of mindset can have a huge impact on productivity and maintainability.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在所有地方重复所有这些代码，我们可以在代码中放入元数据，我们可以利用这些数据。这通常是ASP.NET所支持的——例如，对于控制器的授权，使用**[Authorize]**属性。它需要满足特定的策略，例如用户必须处于某个角色。如果我们的系统为我们的功能有明确的结构，你可能会发现属于特定角色的功能自然分组。然后我们可以通过查看类型上的命名空间元数据并设置正确的授权规则来推理这种结构。对于开发者来说，你通过结构替换了显式信息的需求，使其变得隐式。这看起来可能是一件小事，但整个代码库的生命周期中，这种思维方式可以对生产力和可维护性产生巨大影响。
- en: Generating code
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码生成
- en: With C#, we can go even further than just reasoning about code and making decisions
    based on what we find – we can generate code. Code generation can take place at
    compile time if we have all the information we need or are pushed to the runtime
    level. This opens up a lot more flexibility and gives us a vast amount of power.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C#，我们可以比仅仅推理代码和基于我们找到的内容做出决策更进一步——我们可以生成代码。如果拥有所有必要的信息或被推到运行时级别，代码生成可以在编译时进行。这提供了更多的灵活性，并赋予我们巨大的力量。
- en: As an example, if you’ve ever worked with XAML-based frontend technology such
    as **Windows Presentation Foundation** (**WPF**) or **Universal Windows Platform**
    (**UWP**) and have used data binding, you have probably come across the **INotifyPropertyChanged**
    interface. Its purpose is to enable the view controls so that you’re notified
    when the value of a property has changed on an instance of an object in the view
    to which it is bound.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你曾经使用过基于 XAML 的前端技术，如 **Windows Presentation Foundation** (**WPF**) 或 **Universal
    Windows Platform** (**UWP**)，并使用过数据绑定，你可能已经遇到过 **INotifyPropertyChanged** 接口。它的目的是使视图控件能够通知你，当绑定到视图的对象的属性值发生变化时。
- en: 'Let’s say you have an object representing a person:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个表示人的对象：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let’s say we want to make this notification appear whenever one of the
    properties changes. Using the **INotifyPropertyChanged** interface for binding
    purposes, the object would need to expand into the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要在任何一个属性发生变化时显示这个通知。使用用于绑定目的的 **INotifyPropertyChanged** 接口，对象需要扩展为以下内容：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, creating a property is now very tedious. Imagine having all
    the properties of an object do this. This easily becomes code that is hard to
    read, and there's more code to maintain, and it’s not adding any business value
    to your code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，创建属性现在变得非常繁琐。想象一下，如果对象的所有属性都这样做。这很容易变成难以阅读的代码，需要维护的代码更多，而且这并没有给你的代码增加任何业务价值。
- en: This can be improved upon thanks to the latest version of the C# compiler.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过最新的 C# 编译器版本得到改进。
- en: Microsoft rewrote the C# compiler a few years back. The compiler was given the
    name Roslyn. There were a couple of reasons they rewrote the compiler, with one
    being that they wanted to have the compiler itself be written in C# – a proof
    of the maturity of the language and the .NET runtime Also, as part of the move
    from Microsoft to open source, having a rewrite and doing it in the open and leaving
    the old license model behind made more sense. But the most important reason in
    my opinion was to make it more extensible, and not just for Microsoft themselves,
    but everyone.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，微软重写了 C# 编译器。编译器被命名为 Roslyn。他们重写编译器有几个原因，其中之一是他们希望编译器本身是用 C# 编写的——这是语言和
    .NET 运行时成熟度的证明。此外，作为微软向开源转变的一部分，重写并在公开环境中进行，放弃旧的许可模式更有意义。但在我看来，最重要的原因是使其更具可扩展性，而不仅仅是针对微软自身，而是针对所有人。
- en: 'Part of this extensibility is what is called Roslyn code generation. With it,
    we could go and make this code very close to the original. Let’s imagine we introduce
    some metadata in the form of an **[Bindable]** attribute and we create a compiler
    extension that makes all private fields into properties that are needed for **InotifyPropertyChanged**.
    Here, our object would look like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可扩展性的一部分被称为 Roslyn 代码生成。有了它，我们可以使代码非常接近原始代码。让我们假设我们引入了一些元数据，形式为 **[Bindable]**
    属性，并创建了一个编译器扩展，将所有私有字段转换为需要的 **InotifyPropertyChanged** 属性。在这里，我们的对象看起来是这样的：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We could also do this at runtime. However, at runtime, we are limited to what
    has been compiled and can’t change the type. So, the approach would be slightly
    different. Instead of changing the existing type, we would need to create a new
    type that inherits from the original type and then extend it. This would require
    us to make the original properties **virtual** for us to override them in a generated
    type:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在运行时做这件事。然而，在运行时，我们受限于已编译的内容，无法更改类型。因此，方法会有所不同。我们不会更改现有类型，而是需要创建一个新的类型，它继承自原始类型并对其进行扩展。这要求我们将原始属性设置为
    **virtual**，以便在生成的类型中覆盖它们：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For this to work, we would need a factory that knows how to create these objects.
    We would call this when we needed an instance of it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这可行，我们需要一个工厂，它知道如何创建这些对象。我们需要在需要其实例时调用它。
- en: With great power also comes great responsibility, and it needs to be a very
    deliberate choice to go down this path. We’ll cover this in [*Chapter 18*](B19418_18.xhtml#_idTextAnchor323),
    *Caveats and* *Final Words.*
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 权力越大，责任也越大，而且选择走这条路需要非常谨慎。我们将在 [*第18章*](B19418_18.xhtml#_idTextAnchor323) 中讨论，*注意事项和*
    *结语*。
- en: We will cover the Roslyn extensibility in more depth in [*Chapter 15*](B19418_15.xhtml#_idTextAnchor250),
    *Roslyn* *Compiler Extensions*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第15章*](B19418_15.xhtml#_idTextAnchor250) 中更深入地讨论 Roslyn 可扩展性，*Roslyn
    编译器扩展*。
- en: Compile time safety
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译时安全性
- en: There are also times when we must add certain metadata for the system to work.
    This is a candidate for writing a code analyzer for the Roslyn compiler. The analyzer
    would figure out what’s missing and let the developer know as soon as possible,
    providing a tight feedback loop rather than the developer having to discover the
    problem at runtime.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们也必须添加某些元数据以使系统正常工作。这将是为 Roslyn 编译器编写代码分析器的候选任务。分析器将找出缺少的内容，并尽快通知开发者，从而提供一个紧密的反馈循环，而不是让开发者必须在运行时发现这个问题。
- en: 'An example of this is in a platform I work on called **Cratis** ([https://cratis.io](https://cratis.io)),
    an event sourcing platform. For all the events being persisted, we require a unique
    identifier that represents the type of event. This is added as an attribute for
    the event:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我工作的一个名为 **Cratis** ([https://cratis.io](https://cratis.io)) 的平台上，这是一个事件源平台。对于所有被持久化的事件，我们都需要一个唯一标识符来表示事件的类型。这个标识符作为事件的属性被添加：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When calling the **Append()** method on the event log, the type has to be associated
    with the unique identifier. If there is no association between an event type and
    the .NET type, the **Append()** method will throw an exception. This is a great
    opportunity to perform a compile-time check of anything being sent to the **Append()**
    method and to check whether or not the type of the object has the **[****EventType]**
    attribute.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当在事件日志上调用 **Append()** 方法时，类型必须与唯一标识符相关联。如果事件类型与 .NET 类型之间没有关联，**Append()**
    方法将抛出异常。这是一个在编译时检查发送到 **Append()** 方法的任何内容以及检查对象类型是否具有 **[****EventType]** 属性的绝佳机会。
- en: We will revisit all this in [*Chapter 17*](B19418_17.xhtml#_idTextAnchor299),
    *Static* *Code Analysis*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第17章*](B19418_17.xhtml#_idTextAnchor299)，*静态代码分析* 中重新回顾所有这些内容。
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Hopefully, you now know of the great potential of metaprogramming. It is very
    powerful. This comes with great responsibility – the balance of code you don’t
    see that magically gets added either at compile time or runtime versus the explicitness
    in every code file is a hard one. From my experience, new developers coming into
    a code base with a lot of implicit automation can run into trouble and might end
    up not trusting the magic.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在已经了解了元编程的巨大潜力。它非常强大。这伴随着巨大的责任——在编译时间或运行时神秘添加的代码与每个代码文件中的明确性之间的平衡是困难的。根据我的经验，新开发者进入一个有很多隐式自动化的代码库时可能会遇到麻烦，并可能最终不相信这种魔法。
- en: But after a while, once they get used to it, they tend to want more magic. The
    benefits are clear once you have experience with them, but it might be a bit scary
    at first. To remedy this, you should communicate the automation you have. That
    will at least make it adhere more to the *principle of* *least surprise*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但过了一段时间后，一旦他们习惯了，他们往往想要更多的魔法。一旦你有了经验，这些好处是显而易见的，但一开始可能会有些可怕。为了解决这个问题，你应该沟通你所拥有的自动化。这样至少会让它更符合
    *最小惊讶原则*。
- en: In the next chapter, we will dive into more concrete concepts of metaprogramming
    and look at what’s behind the concepts. We’ll become familiar with how the .NET
    runtime sees code and the metadata it produces and how this can be leveraged in
    a running application. Finally, we’ll learn how to extend this metadata.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨元编程的更具体的概念，并探讨这些概念背后的内容。我们将熟悉 .NET 运行时如何看待代码以及它产生的元数据，以及如何在运行中的应用程序中利用这些数据。最后，我们将学习如何扩展这些元数据。
