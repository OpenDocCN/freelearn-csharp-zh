- en: Chapter 1. Core UI – Messages, Menus, Scores, and Timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a "Hello World" UI text message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a digital clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a digital countdown timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a message that fades away
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a perspective 3D text message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating UI Buttons to move between scenes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing images inside panels and changing panel depths via buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying the value of an interactive UI Slider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a countdown timer graphically with a UI Slider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a radar to indicate the relative locations of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating UIs with the Fungus open-source dialog system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting custom mouse cursor images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input Fields component for text entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Toggles and radio buttons via Toggle Groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A key element contributing to the entertainment and enjoyment of most games
    is the quality of the visual experience, and an important part of this is the
    **User Interface** (**UI**). UI elements involve ways for the user to interact
    with the game (such as buttons, cursors, text boxes, and so on), as well as ways
    for the game to present up-to-date information to the user (such as the time remaining,
    current health, score, lives left, or location of enemies). This chapter is filled
    with UI recipes to give you a range of examples and ideas for creating game UIs.
  prefs: []
  type: TYPE_NORMAL
- en: The big picture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every game is different, and so this chapter attempts to fulfill two key roles.
    The first aim is to provide step-by-step instructions on how to create a wide
    range of the **Unity 5** UI elements and, where appropriate, associate them with
    game variables in code. The second aim is to provide a rich illustration of how
    UI elements can be used for a variety of purposes, so that you can get good ideas
    about how to make the Unity 5 UI set of controls deliver the particular visual
    experience and interactions for the games that you are developing.
  prefs: []
  type: TYPE_NORMAL
- en: The basic UI elements can provide static images and text to just make the screen
    look more interesting. By using scripts, we can change the content of these images
    and text objects, so that the players' numeric scores can be updated, or we can
    show stickmen images to indicate how many lives the player has left, and so on.
    Other UI elements are interactive, allowing users to click on buttons, choose
    options, enter text, and so on. More sophisticated kinds of UI can involve collecting
    and calculating data about the game (such as percentage time remaining or enemy
    hit damage; or the positions and types of key GameObjects in the scene, and their
    relationship to the location and orientation of the player), and then displaying
    these values in a natural, graphical way (such as progress bars or radar screens).
  prefs: []
  type: TYPE_NORMAL
- en: 'Core GameObjects, components, and concepts relating to Unity UI development
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Canvas**: Every UI element is a child to a **Canvas**. There can be multiple
    **Canvas** GameObjects in a single scene. If a **Canvas** is not already present,
    then one will automatically be created when a new UI GameObject is created, with
    that UI object childed to the new **Canvas** GameObject.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EventSystem**: An **EventSystem** GameObject is required to manage the interaction
    events for UI controls. One will automatically be created with the first UI element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Panel**: UI objects can be grouped together (logically and physically) with
    UI **Panels**. **Panels** can play several roles, including providing a GameObject
    parent in the **Hierarchy** for a related group of controls. They can provide
    a visual background image to graphically relate controls on the screen, and they
    can also have scripted resize and drag interactions added, if desired.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual UI** controls: The visible UI controls themselves include **Button**,
    **Image**, **Text**, **Toggle**, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interaction UI** controls: These are non-visible components that are added
    to GameObjects; examples include Input Field and Toggle Group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Rect Transform** component: UI GameObjects can exist in a different space
    from that of the 2D and 3D scenes, which cameras render. Therefore, UI GameObjects
    all have the special **Rect Transform** component, which has some different properties
    to the scene''s GameObject **Transform** component (with its straightforward *X*/*Y*/*Z*
    position, rotation, and scale properties). Associated with **Rect Transforms**
    are pivot points (reference points for scaling, resizing, and rotations) and anchor
    points. Read more about these core features below.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sibling Depth**: The bottom-to-top display order (what appears on the top
    of what) for a UI element is determined initially by their sequence in the **Hierarchy**.
    At designtime, this can be manually set by dragging GameObjects into the desired
    sequence in the **Hierarchy**. At runtime, we can send messages to the **Rect
    Transforms** of GameObjects to dynamically change their **Hierarchy** position
    (and therefore, the display order), as the game or user interaction demands. This
    is illustrated in the *Organizing images inside panels and changing panel depths
    via buttons* recipe in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows how there are four main categories of UI controls,
    each in a **Canvas** GameObject and interacting via an **EventSystem** GameObject.
    UI Controls can have their own **Canvas**, or several UI controls can be in the
    same **Canvas**. The four categories are: static (display-only) and interactive
    UI controls, non-visible components (such as ones to group a set of mutually exclusive
    radio buttons), and C# script classes to manage UI control behavior through logic
    written in the program code. Note that UI controls that are not a child or descendent
    of a **Canvas** will not work properly, and interactive UI controls will not work
    properly if the **EventSystem** is missing. Both the **Canvas** and **EventSystem**
    GameObjects are automatically added to the Hierarchy as soon as the first UI GameObject
    is added to a scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The big picture](img/1362OT_01_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: UI **Rect Transforms** represents a rectangular area rather than a single point,
    which is the case for scene GameObject **Transforms**. **Rect Transforms** describe
    how a UI element should be positioned and sized relatively to its parent. **Rect
    Transforms** have a width and height that can be changed without affecting the
    local scale of the component. When the scale is changed for the **Rect Transform**
    of a UI element, then this will also scale font sizes and borders on sliced images,
    and so on. If all four anchors are at the same point, then resizing the **Canvas**
    will not stretch the **Rect Transform.** It will only affect its position. In
    this case, we'll see the **Pos X** and **Pos Y** properties, and the **Width**
    and **Height** of the rectangle. However, if the anchors are not all at the same
    point, then **Canvas** resizing will result in a stretching of the element's rectangle.
    So instead of the **Width**, we'll see the values for **Left** and **Right**—the
    position of the horizontal sides of the rectangle to the sides of the **Canvas**,
    where the **Width** will depend on the actual **Canvas** width (and the same for
    **Top/Bottom/Height**).
  prefs: []
  type: TYPE_NORMAL
- en: Unity provides a set of preset values for pivots and anchors, making the most
    common values very quick and easy to assign to an element's **Rect Transform**.
    The following screenshot shows the 3 x 3 grid that allows you quick choices about
    left, right, top, bottom, middle, horizontal, and vertical values. Also, the extra
    column on the right offers horizontal stretch presets, and the extra row at the
    bottom offers vertical stretch presets. Using the *SHIFT* and *ALT* keys sets
    the pivot and anchors when a preset is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: '![The big picture](img/1362OT_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Unity manual provides a very good introduction to the **Rect Transform.**
    In addition, Ray Wenderlich''s two-part Unity UI web tutorial also presents a
    great overview of the **Rect Transform**, pivots, and anchors. Both parts of Wenderlich''s
    tutorial make great use of animated GIFs to illustrate the effect of different
    values for pivots and anchors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.unity3d.com/Manual/UIBasicLayout.html](http://docs.unity3d.com/Manual/UIBasicLayout.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.raywenderlich.com/78675/unity-new-gui-part-1](http://www.raywenderlich.com/78675/unity-new-gui-part-1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three **Canvas** render modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Screen Space – Overlay**: In this mode, the UI elements are displayed without
    any reference to any camera (there is no need for any **Camera** in the scene).
    The UI elements are presented in front of (overlaying) any sort of camera display
    of the scene contents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Screen Space – Camera**: In this mode, the **Canvas** is treated as a flat
    plane in the frustum (viewing space) of a **Camera** scene —where this plane is
    always facing the camera. So, any scene objects in front of this plane will be
    rendered in front of the UI elements on the **Canvas**. The **Canvas** is automatically
    resized if the screen size, resolution, or camera settings are changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**World Space**: In this mode, the **Canvas** acts as a flat plane in the frustum
    (viewing space) of a **Camera** scene—but the plane is not made to always face
    the **Camera**. How the **Canvas** appears is just as with any other objects in
    the scene, relative to where (if anywhere) in the camera''s viewing frustum the
    **Canvas** plane is located and oriented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we have focused on the **Screen Space – Overlay** mode. But
    all these recipes can equally be used with the other two modes as well.
  prefs: []
  type: TYPE_NORMAL
- en: Be creative! This chapter aims to act as a launching pad of ideas, techniques,
    and reusable **C#** scripts for your own projects. Get to know the range of Unity
    UI elements, and try to work smart. Often, a UI element exists with most of the
    components that you may need for something in your game, but you may need to adapt
    it somehow. An example of this can be seen in the recipe that makes a UI Slider
    non-interactive, instead using it to display a red-green progress bar for the
    status of a countdown timer. See this in the *Displaying a countdown timer graphically
    with a UI Slider* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a "Hello World" UI text message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first traditional problem to be solved with a new computing technology is
    often to display the *Hello World* message. In this recipe, you'll learn to create
    a simple UI Text object with this message, in large white text with a selected
    font, and in the center of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying a "Hello World" UI text message](img/1362OT_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the font that you need in a folder named `Fonts`
    in the `1362_01_01` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display a **Hello World** text message, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the provided `Fonts` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Hierarchy** panel, add a **UI** | **Text** GameObject to the scene
    – choose menu: **GameObject** | **UI** | **Text**. Name this GameObject **Text-hello**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Alternatively, use the **Create** menu immediately below the **Hierarchy**
    tab, choosing menu: **Create** | **UI** | **Text**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Ensure that your new **Text-hello** GameObject is selected in the **Hierarchy**
    panel. Now, in the **Inspector**, ensure the following properties are set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Text** set to read `Hello World`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Font** set to `Xolonium-Bold`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Font size** as per your requirements (large—this depends on your screen—try
    `50` or `100`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alignment** set to horizontal and vertical center'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Horizontal** and **Vertical Overflow** set to `Overflow`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Color** set to white'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the **Inspector** panel with these settings:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1362OT_01_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now, in the **Rect Transform**, click on the **Anchor Presets** square icon,
    which should result in several rows and columns of preset position squares appearing.
    Hold down *SHIFT* and *ALT* and click on the center one (row **middle** and column
    **center**).![How to do it...](img/1362OT_01_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your **Hello World** text will now appear, centered nicely in the **Game** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have added a new **Text-hello** GameObject to a scene. A parent **Canvas**
    and UI **EventSystem** will also have been automatically created.
  prefs: []
  type: TYPE_NORMAL
- en: You set the text content and presentation properties, and use the **Rect Transform**
    anchor presets to ensure that whatever way the screen is resized, the text will
    stay horizontally and vertically centered.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are some more details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Styling substrings with Rich Text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each separate UI **Text** component can have its own color, size, boldness
    styling, and so on. However, if you wish to quickly add some highlighting style
    to a part of a string to be displayed to the user, the following are examples
    of some of the HTML-style markups that are available without the need to create
    separate UI **Text** objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Embolden text with the "`b`" markup: `I am <b>bold</b>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Italicize text with the "`i`" markup: `I am <i>italic</i>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set the text color with hex values or a color name: `I am <color=green>green
    text</color>, but I am <color=#FF0000>red</color>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Learn more from the Unity online manual **Rich Text** page at: [http://docs.unity3d.com/Manual/StyledText.html](http://docs.unity3d.com/Manual/StyledText.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Displaying a digital clock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether it is the real-world time, or perhaps an in-game countdown clock, many
    games are enhanced by some form of clock or timer display. The most straightforward
    type of clock to display is a string composed of the integers for hours, minutes,
    and seconds, which is what we'll create in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the kind of clock we will be creating in this
    recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying a digital clock](img/1362OT_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the font that you need in a folder named `Fonts`
    in the `1362_01_01` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a digital clock, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the provided `Fonts` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** panel, add a **UI** | **Text** game object to the scene
    named **Text-clock**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that GameObject **Text-clock** is selected in the **Hierarchy** panel.
    Now, in **Inspector**, ensure that the following properties are set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Text** set to read as `time goes here` (this placeholder text will be replaced
    by the time when the scene is running.)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Font type** set to `Xolonium Bold`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Font Size** set to `20`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alignment** set to horizontal and vertical center'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Horizontal** and **Vertical Overflow** settings set to **Overflow**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Color** set to white'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, in the **Rect Transform**, click on the **Anchor Presets** square icon,
    which will result in the appearance of several rows and columns of preset position
    squares. Hold down *SHIFT* and *ALT* and click on the **top** and column **center**
    rows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a folder named `Scripts` and create a C# script class called `ClockDigital`
    in this new folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With GameObject **Text-clock** selected in the **Hierarchy** panel, drag your
    `ClockDigital` script onto it to add an instance of this script class as a component
    to GameObject **Text-clock**, as shown in the following screenshot:![How to do
    it...](img/1362OT_01_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you run the scene, you will now see a digital clock, showing hours, minutes,
    and seconds, at the top-center part of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You added a **Text** GameObject to a scene. You have added an instance of the
    `ClockDigital` C# script class to that GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that as well as the standard two C# packages (`UnityEngine` and `System.Collections`)
    that are written by default for every new script, you have added the `using` statements
    for two more C# script packages, `UnityEngine.UI` and `System`. The UI package
    is needed, since our code uses UI `Text` object; and the `System` package is needed,
    since it contains the `DateTime` class that we need to access the clock on the
    computer where our game is running.
  prefs: []
  type: TYPE_NORMAL
- en: There is one variable, `textClock`, which will be a reference to the `Text`
    component, whose text content we wish to update in each frame with the current
    time in hours, minutes, and seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The `Start()` method (executed when the scene begins) sets the `textClock` variable
    to be a reference to the `Text` component in the GameObject, to which our scripted
    object has been added.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that an alternative approach would be to make `textClock` a `public` variable.
    This will allow us to assign it via drag-and-drop in the **Inspector** panel.
  prefs: []
  type: TYPE_NORMAL
- en: The `Update()`method is executed in every frame. The current time is stored
    in the `time` variable, and strings are created by adding leading zeros to the
    number values for the hours, minutes, and seconds properties of variable `time`.
  prefs: []
  type: TYPE_NORMAL
- en: This method finally updates the `text` property (that is, the letters and numbers
    that the user sees) to be a string, concatenating the hours, minutes, and seconds
    with colon separator characters.
  prefs: []
  type: TYPE_NORMAL
- en: The `LeadingZero(…)`method takes as input an integer and returns a string of
    this number with leading zeros added to the left, if the value was less than 10.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: The Unity tutorial for animating an analogue clock
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unity has published a nice tutorial on how to create 3D objects, and animate
    them through C# script to display an analogue clock at [https://unity3d.com/learn/tutorials/modules/beginner/scripting/simple-clock](https://unity3d.com/learn/tutorials/modules/beginner/scripting/simple-clock).
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a digital countdown timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe will show you how to display a digital countdown clock shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying a digital countdown timer](img/1362OT_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe adapts the previous one. So, make a copy of the project for the
    previous recipe, and work on this copy.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the script that you need in a folder named
    `Scripts` in the `1362_01_03` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a digital countdown timer, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Inspector** panel, remove the scripted component, `ClockDigital,` from
    GameObject **Text-clock**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `DigitalCountdown` C# script class containing the following code,
    and add an instance as a scripted component to GameObject **Text-clock**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you run the scene, you will now see a digital clock counting down from
    30\. When the countdown reaches zero, the message **countdown has finished** will
    be displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You added a **Text** GameObject to a scene. You have added an instance of the
    `DigitalCountdown` C# script class to that GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: There is one variable, `textClock`, which will be a reference to the `Text`
    component, whose text content we wish to update in each frame with a time remaining
    message (or a timer complete message). Then, a call is made to the `CountdownTimerReset(…)`
    method, passing an initial value of 30 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The `Start()` method (executed when the scene begins) sets the `textClock` variable
    to find the `Text` component in the GameObject where our scripted object has been
    added.
  prefs: []
  type: TYPE_NORMAL
- en: The `Update()` method is executed in every frame. This method initially sets
    the `timerMessage` variable to a message, stating that the timer has finished
    (the default message to display). Then the seconds remaining are tested to be
    greater than zero. And if so, then the message variable has its contents changed
    to display the integer (whole) number of the seconds remaining in the countdown—retrieved
    from the `CountdownTimerSecondsRemaining()` method. This method finally updates
    the `text` property (that is, the letters and numbers that the user sees) to be
    a string with a message about the remaining seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The `CountdownTimerReset(…)` method records the number of seconds provided,
    and the time the method was called.
  prefs: []
  type: TYPE_NORMAL
- en: The `CountdownTimerSecondsRemaining()` method returns an integer value of the
    number of seconds remaining.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a message that fades away
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we want a message to display just for a certain time, and then fade
    away and disappear, which will appear as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a message that fades away](img/1362OT_01_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe adapts the first recipe in this chapter, so make a copy of that
    project to work on for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the script that you need in a folder named
    `Scripts` in the `1362_01_04` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display a text message that fades away, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the provided C# script class called `CountdownTimer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that GameObject **Text-hello** is selected in the **Hierarchy** tab.
    Then, attach an instance of the `CountdownTimer` C# script class as a component
    of this GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class, `FadeAway`, containing the following code, and add
    an instance as a scripted component to the GameObject **Text-hello**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you run the scene, you will now see that the message on the screen slowly
    fades away, disappearing after 5 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An instance of the provided `CountdownTimer` script class was added as a component
    to the GameObject **Text-hello**.
  prefs: []
  type: TYPE_NORMAL
- en: You added to the GameObject **Text-hello** an instance of the scripted class,
    `FadeAway`. The `Start()`method caches references to the `Text` and `CountdownTimer`
    components in the `countdownTimer` and `textUI` variables. Then, it calls the
    `StartFading(…)`method, passing in the number 5, so that the message will have
    faded to invisible after 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The `StartFading(…)` method starts this timer scripted component to countdown
    to the given number of seconds. It also sets the `fading` Boolean flag variable
    to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Update()` method, in each frame, tests if the `fading` variable is `true`.
    If it is true, then the alpha (transparency) component of the color of the **Text-hello**
    object is set to a value between 0.0 and 1.0, based on the proportion of the time
    remaining in the `CountdownTimer` object. Finally, if the proportion of time remaining
    is less than a very small value (0.01), then the `fading` variable is set to `false`
    (to save the processing work since the text is now invisible).
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a perspective 3D text message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity provides an alternative way to display text in 3D via the `TextMesh` component.
    While this is really suitable for a text-in-the-scene kind of situation (such
    as billboards, road signs, and generally wording on the side of 3D objects that
    might be seen close up), it is quick to create, and is another way of creating
    interesting menus or instructions scenes, and the like.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, you''ll learn how to create a scrolling 3D text, simulating
    the famous opening credits of the movie **Star Wars**, which looks something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying a perspective 3D text message](img/1362OT_01_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the fonts that you need in a folder named
    `Fonts`, and the text file that you need in a folder named `Text`, in the `1362_01_04`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display perspective 3D text, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 3D project (this ensures that we start off with a **Perspective**
    camera, suitable for the 3D effect that we want to create).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to mix 2D and 3D scenes in your project, you can always manually
    set any camera's **Camera Projection** property to **Perspective** or **Orthographic**
    via the **Inspector** panel.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the **Hierarchy** panel, select the **Main Camera** item, and, in the **Inspector**
    panel, set its properties as follows: **Camera Clear Flags** to **solid color**,
    **Field of View** to **150**. Also set the **Background color** to black.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the provided `Fonts` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Hierarchy** panel, add a **UI** | **Text** game object to the scene
    – choose menu: **GameObject** | **UI** | **Text**. Name this GameObject as `Text-star-wars`.
    Set its **Text Content** as Star Wars (with each word on a new line). Then, set
    its **Font** to `Xolonium Bold`, and its **Font Size** to `50`. Use the anchor
    presets in **Rect Transform** to position this UI **Text** object at the top center
    of the screen.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Hierarchy** panel, add a **3D Text** game object to the scene – choose
    menu: **GameObject** | **3D Object** | **3D Text**. Name this GameObject `Text-crawler`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Inspector** panel, set the **Transform** properties for GameObject
    **Text-crawler** as follows: **Position** (`0`, `-300`, `-20`), **Rotation** (`15`,
    `0`, `0`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Inspector** panel, set the **Text Mesh** properties for GameObject
    **Text-crawler** as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the content of the provided text file, `star_wars.txt,` into **Text**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set **Offset Z** = `20`, **Line Spacing** = `0.8`, and **Anchor** = Middle center
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set **Font Size** = `200`, **Font** = `SourceSansPro-BoldIt`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the scene is made to run, the Star Wars story text will now appear nicely
    squashed in 3D perspective on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have simulated the opening screen of the movie *Star Wars*, with a flat
    UI **Text** object title at the top of the screen, and 3D **Text Mesh** with settings
    that appear to be disappearing into the horizon with 3D perspective 'squashing'.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: We have to make this text crawl like it does in the movie
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With a few lines of code, we can make this text scroll in the horizon just
    as it does in the movie. Add the following C# script class, `ScrollZ,` as a component
    to GameObject **Text-crawler**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In each frame via the `Update()` method, the position of the 3D text object
    is moved in the direction of this GameObject's local up-direction.
  prefs: []
  type: TYPE_NORMAL
- en: Where to learn more
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Learn more about 3D Text and Text Meshes in the Unity online manual at [http://docs.unity3d.com/Manual/class-TextMesh.html](http://docs.unity3d.com/Manual/class-TextMesh.html).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NOTE: An alternative way of achieving perspective text like this would be to
    use a Canvas with render mode World Space.'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many cases where we wish to display an image onscreen, including logos,
    maps, icons, splash graphics, and so on. In this recipe, we will display an image
    at the top of the screen, and make it stretch to fit whatever width that the screen
    is resized to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows Unity displaying an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying an image](img/1362OT_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the image that you need in a folder named
    `Images` in the `1362_01_06` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display a stretched image, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 3D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 3D projects will, by default, import images as a **Texture**, and 2D projects
    will import images as **Sprite (2D and UI)**. Since we're going to use a **RawImage**
    UI component, we need our images to be imported as textures.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set the Game panel to a 400 x 300 size. Do this via menu: **Edit** | **Project
    Settings** | **Player**. Ensure that the **Resolution** | **Default is Full Screen**
    setting check is unchecked, and the width/height is set to 400 x 300\. Then, in
    the **Game** panel, select **Stand Alone (400 x 300)**. This will allow us to
    test the stretching of our image to a width of 400 pixels.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the provided folder, which is called `Images`. In the **Inspector** tab,
    ensure that the `unity5_learn` image has **Texture Type** set to **Texture**.
    If it does not, then choose **Texture** from the drop-down list, and click on
    the **Apply** button. The following screenshot shows the **Inspector** tab with
    the **Texture** settings:![How to do it...](img/1362OT_01_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** panel, add a **UI** | **RawImage** GameObject to the scene
    named **RawImage-unity5**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you wish to *prevent* the distortion and stretching of an image, then use
    the UI **Sprite** GameObject instead, and ensure that you check the **Preserve
    Aspect** option, in its **Image (Script)** component, in the **Inspector** panel.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ensure that the GameObject **RawImage-unity5** is selected in the **Hierarchy**
    panel. From your **Project** folder (`Images`), drag the `unity5_learn` image
    into the **Raw Image (Script)** public property **Texture**. Click on the **Set
    Native Size** button to preview the image before it gets stretched, as shown:![How
    to do it...](img/1362OT_01_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, in **Rect Transform**, click on the **Anchor Presets** square icon, which
    will result in several rows and columns of preset position squares appearing.
    Hold down *SHIFT* and *ALT* and click on the **top row** and the **stretch column**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The image will now be positioned neatly at the top of the **Game** panel, and
    will be stretched to the full width of 400 pixels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have ensured that an image has **Texture Type** set to **Texture**. You
    added a **UI RawImage** control to the scene. The **RawImage** control has been
    made to display the `unity5_learn` image file.
  prefs: []
  type: TYPE_NORMAL
- en: The image has been positioned at the top of the **Game** panel, and using the
    anchor and pivot presets, it has made the image stretch to fill the whole width,
    which we set to 400 pixels via the **Player** settings.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some details that you don''t want to miss:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Sprites and UI Image components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you simply wish to display non-animated images, then **Texture** images and
    UI **RawImage** controls are the way to go. However, if you want more options
    on how an image should be displayed (such as tiling, and animation), then the
    UI **Sprite** control should be used instead. This control needs image files to
    be imported as the **Sprite (2D and UI) type**.
  prefs: []
  type: TYPE_NORMAL
- en: Once an image file has been dragged into the UI **Image** control's **Sprite**
    property, additional properties will be available, such as **Image Type**, options
    to preserve aspect ratio, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with Sprites and UI Image components](img/1362OT_01_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An example of tiling a Sprite image can be found in the *Revealing icons for
    multiple object pickups by changing the size of a tiled image* recipe in [Chapter
    2](ch02.html "Chapter 2. Inventory GUIs"), *Inventory GUIs*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating UI Buttons to move between scenes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As well as scenes where the player plays the game, most games will have menu
    screens, which display to the user messages about instructions, high scores, the
    level they have reached so far, and so on. Unity provides the UI **Buttons** to
    make it easy to offer users a simple way to indicate their choice of action on
    such screens.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll create a very simple game consisting of two screens,
    each with a button to load the other one, similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating UI Buttons to move between scenes](img/1362OT_01_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a button-navigable multi-scene game, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the current (empty) scene, naming it **page1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a UI **Text** object positioned at the top center of the scene, containing
    text `Main Menu / (page 1)` in a large font size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a UI **Button** to the scene positioned in the middle center of the screen.
    In the **Hierarchy** panel, click on the show children triangle to display the
    UI **Text** child of this button GameObject. Select the **Text** button-child
    GameObject, and in the **Inspector** panel for the **Text** property of the **Text
    (Script)** component, enter the button text called `goto page 2`, as shown here:![How
    to do it...](img/1362OT_01_30.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the current scene to the build, choosing menu: **File** | **Build Settings…**.
    Then, click on the **Add Current** button so that the **page1** scene becomes
    the first scene on the list of **Scenes in the Build**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We cannot tell Unity to load a scene that has not been added to the list of
    scenes in the build. We use the `Application.LoadLevel(…)`code to tell Unity to
    load the scene name (or numeric index) that is provided.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a C# script class, `MenuActions,` containing the following code, and
    add an instance as a scripted component to the **Main Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ensure that the **Button** is selected in the **Hierarchy** and click on the
    plus sign "**+**" button at the bottom of the **Button (Script)** component, in
    the **Inspector view**, to create a new **OnClick** event handler for this button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Main Camera** from the **Hierarchy** over the **Object** slot—immediately
    below the menu saying **Runtime Only**. This means that when the **Button** receives
    an **OnClick** event, we can call a public method from a scripted object inside
    the **Main Camera**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, select the **MENU_ACTION_GotoPage()** method from the **MenuActions** drop-down
    list (initially showing **No Function**). Type `page2` (the name of the scene
    we want to be loaded when this button is clicked) in the text box, below the method's
    drop-down menu. This **page2** string will be passed to the method when the button
    receives an **OnClick** event message, as shown here:![How to do it...](img/1362OT_01_31.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the current scene, create a new empty scene, and then save this new scene
    as **page2**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the similar steps for this scene. Add a **UI Text** GameObject, displaying
    the text **Instructions / (page 2)** in a large font size. Add a UI **Button,**
    showing the **goto page 1 text.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the current scene to the build (so now, both **page1** and **page2** will
    be listed in the build).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an instance of `MenuActions` script class to the **Main Camera**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Button** in the **Hierarchy** panel, and add an **On Click** event
    handler, which will pass the **MENU_ACTION_GotoPage()** method the string **page1**
    (the name of the scene we want to be loaded when this button is clicked).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you run the **page1 scene,** you will be presented with your **Main Menu**
    text and a button, which when clicked, makes the game load the **page2 scene**.
    On scene **page2,** you'll have a button to take you back to **page1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have created two scenes, and added both of them to the game build. Each
    scene has a button, which when clicked (when the game is playing), makes Unity
    load the (named) other scene. This is made possible because when each button is
    clicked, it runs the `MENU_ACTION_GotoPage(…)`method from the scripted `MenuActions`
    component inside the **Main Camera**. This method inputs a text string of the
    name of the scene to be loaded, so that the button in the **page1 scene** gives
    the string name of **page2** as the scene to be loaded, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: When a UI **Button** is added to the **Hierarchy** panel, a child UI **Text**
    object is also automatically created, and the content of the **Text** property
    of this UI **Text** child is the text that the user sees on the button.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Visual animation for the button mouse-over
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several ways in which we can visually inform the user that the button
    is interactive when they move their mouse cursor over it. The simplest is to add
    a color tint that will appear when the mouse is over the button—this is the default
    **Transition**. With the **Button** selected in the **Hierarchy**, choose a tint
    color (for example, red), for the **Highlighted Color** property of the **Button
    (Script)** component, in the **Inspector** tab, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visual animation for the button mouse-over](img/1362OT_01_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another form of visual **Transition** to inform the user of an active button
    is **Sprite Swap**. In this case, properties for different images for **Targeted**/**Highlighted**/**Pressed**/**Disabled**
    are available in the **Inspector** tab. The default **Targeted Graphic** is the
    built-in Unity **Button (image)** – this is the grey rounded rectangle default
    when GameObjects buttons are created. Dragging in a very different-looking image
    for the **Highlighted Sprite** is an effective alternative to set a color hint.
    We have provided a `rainbow.png` image with the project for this recipe that can
    be used for the **Button** mouse over **Highlighted Sprite**. The following screenshot
    shows the button with this rainbow background image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visual animation for the button mouse-over](img/1362OT_01_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Animating button properties on mouse over
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, animations can be created for dynamically highlighting a button to
    the user, for example, a button might get larger when the mouse is over it, and
    then it might shrink back to its original size when the mouse pointer is moved
    away. These effects are achieved by choosing the **Animation** option for the
    **Transition** property, and by creating an animation controller with triggers
    for the **Normal**, **Highlighted**, **Pressed** and **Disabled** states. To animate
    a button for enlargement when the mouse is over it (the highlighted state), do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector Button (Script)** component, set the **Transition** property
    to **Animation**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Auto Generate Animation** button (just below the **Disabled Trigger**
    property) for the **Button (Script)** component, as shown here:![Animating button
    properties on mouse over](img/1362OT_01_41.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the new controller by naming it **button-animation-controller**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the **Button** GameObject is selected in the **Hierarchy**. Then,
    in the **Animation** panel, select the **Highlighted** clip from the drop-down
    menu, as shown here:![Animating button properties on mouse over](img/1362OT_01_42.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Animation** panel, click on the red **record** circle button, and then
    click on the **Add Property** button, choosing to record changes to the **Rect
    Transform** | **Scale** property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two key frames will have been created, delete the second one at **1:00** (since
    we don't want a "bouncing" button), as shown in the following screenshot .![Animating
    button properties on mouse over](img/1362OT_01_43.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the first key frame at **0:00** (the only one now!). Then, in the **Inspector**
    view, set the *X* and *Y* scale properties of the **Rect Transform** component
    to (`1.2`, `1.2`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click on the red **record** circle button for the second time to end
    the recording of the animation changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and run your scene, and you will see that the button smoothly animates
    to get larger when the mouse is over it, and then smoothly returns to its original
    size when the mouse is moved away.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following web pages offer video and web-based tutorials on UI animations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Unity button transitions tutorial is available at:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://unity3d.com/learn/tutorials/modules/beginner/ui/ui-transitions](http://unity3d.com/learn/tutorials/modules/beginner/ui/ui-transitions)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Ray Wenderlich''s tutorial (part 2), including the button animations, is available
    at:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.raywenderlich.com/79031/unity-new-gui-tutorial-part-2](http://www.raywenderlich.com/79031/unity-new-gui-tutorial-part-2)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Organizing images inside panels and changing panel depths via buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UI **Panels** are provided by Unity to allow UI controls to be grouped and moved
    together, and also to visually group elements with an **Image** background (if
    desired). The **sibling depth** is what determines which UI elements will appear
    above or below others. We can see the sibling depth explicitly in the **Hierarchy**,
    since the top-to-bottom sequence of UI GameObjects in the **Hierarchy** sets the
    sibling depth. So, the first item has a depth of 1, the second has a depth of
    2, and so on. The UI GameObjects with larger sibling depths (further down the
    **Hierarchy**) appear above the UI GameObjects with lower sibling depths.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll create three UI panels, each showing a different playing
    card image. We'll also add four triangle arrangement buttons to change the display
    order (move to bottom, move to top, move up one, and move down one).
  prefs: []
  type: TYPE_NORMAL
- en: '![Organizing images inside panels and changing panel depths via buttons](img/1362OT_01_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the images that you need in a folder named
    `Images` in the `1362_01_08` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the UI **Panels** whose layering can be changed by the user-clicking
    buttons, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new UI **Panel** named `Panel-jack-diamonds`. Position it in the middle-center
    part of the screen, and size it 200 pixels wide by 300 pixels high. Uncheck the
    **Image (Script)** component for this panel (since we don't want to see the default
    semi-transparent rectangular grey background image of a panel).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new UI **Image**, and child this image to **Panel-jack-diamonds**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the **Panel-jack-diamonds** image at center-middle, and size it to
    200 x 300\. Drag the **Jack-of-diamonds** playing card image into the **Source
    Image** property, for the **Image (Script)** component in the **Inspector** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a UI **Button** named **Button-move-to-front**. Child this button to
    **Panel-jack-diamonds**. Delete the **Text** child GameObject of this button (since
    we'll use an icon to indicate what this button does).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Size the **Button-move-to-front** button to 16 x 16, and position it top-center
    of the player card image, so that it can be seen at the top of the playing card.
    Drag the `icon_move_to_front` arrangement triangle icon image into the **Source
    Image** property, for the **Image (Script)** component, in the **Inspector** view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the **Button-move-to-front** button is selected in the **Hierarchy**.
    Then, click on the plus sign (**+**) at the bottom of the **Button (Script)**
    component, in the **Inspector** view to create a new **OnClick** event handler
    for this button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag **Panel-jack-diamonds** from the **Hierarchy** over the **Object** slot
    (immediately below the menu saying **Runtime Only**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, select the **RectTransform.SetAsLastSibling** method from the drop-down
    function list (initially showing **No Function**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This means that when the **Button** receives an **OnClick** event, the **RectTransform**
    of the **Panel** will be sent the **SetAsLastSibling** message – this will move
    the **Panel** to the bottom of the GameObjects in the **Canvas**, and therefore
    will move this **Panel** in front of all other GameObjects in the **Canvas**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1362OT_01_35.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Repeat *step 2*; create a second **Panel** with a move-to-front button. Name
    this second Panel **Panel-2-diamonds**, then move and position it slightly to
    the right of **Panel-jack-diamonds**, allowing both the move-to-front buttons
    to be seen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your scene and run the game. You will be able to click the move-to-front
    button on either of the cards to move that card's panel to the front. If you run
    the game with the Game panel not maximized, you'll actually see the panels changing
    order in the list of the children of the **Canvas** in the **Hierarchy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You've created two UI **Panels**, each panel containing an image of a playing
    card and a button whose action will make its parent panel move to the front. The
    button's action illustrates how the **OnClick** function does not have to be the
    calling of a public method of a scripted component of an object, but it can be
    sending a message to one of the components of the targeted GameObject—in this
    instance we send the **SetAsLastSibling** message to the **RectTransform** of
    the **Panel** in which the **Button** is located.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Moving up or down by just one position, using scripted methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While the Rect Transform offers a useful **SetAsLastSibling** (move to front)
    and **SetAsFirstSibling** (move to back), and even **SetSiblingIndex** (if we
    knew exactly what position in the sequence to type in), there isn''t a built-in
    way to make an element move up or down, just a single position in the sequence
    of GameObjects in the **Hierarchy** panel. However, we can write two straightforward
    methods in C# to do this, and we can add buttons to call these methods, providing
    full control of the top-to-bottom arrangement of the UI controls on the screen.
    To implement four buttons (move-to-front/move-to-back/up one/down one), do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a C# script class called `ArrangeActions`, containing the following
    code, and add an instance as a scripted component to each of your **Panels**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a second button to each card panel, this time, using the arrangement triangle
    icon image called `icon_move_to_front`, and set the **OnClick** event function
    for these buttons to **SetAsFirstSibling**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add two further buttons to each card panel with the up and down triangle icon
    images: `icon_down_one` and `icon_up_one`. Set the **OnClick** event handler function
    for the down-one buttons to call the `MoveDownOne()` method, and set the functions
    for the up-one buttons to call the `MoveUpOne()` method.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy one of the panels to create a third card (this time showing the Ace of
    diamonds). Arrange the three cards so that you can see all four buttons for at
    least two of the cards, even when those cards are at the bottom (see the screenshot
    at the beginning of this recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene and run your game. You will now have full control over the layering
    of the three card panels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Displaying the value of an interactive UI Slider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe illustrates how to create an interactive UI **Slider**, and execute
    a C# method each time the user changes the **Slider value**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the value of an interactive UI Slider](img/1362OT_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a UI Slider and display its value on the screen, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a UI Text GameObject to the scene with a Font size of `30` and placeholder
    text such as `slider value here` (this text will be replaced with the slider value
    when the scene starts).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Hierarchy** panel, add a **UI** | **Slider** game object to the scene—choose
    the menu: **GameObject** | **UI** | **Slider**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** tab, modify settings for the **Rect Transform** to position
    the slider on the top-middle part of the screen and the text just below it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** tab, set the **Min Value** of the slider to `0`, the **Max
    Value** to `20`, and check the **Whole Numbers** checkbox, as shown here:![How
    to do it...](img/1362OT_01_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class called `SliderValueToText`, containing the following
    code, and add an instance as a scripted component to the GameObject called **Text**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ensure that the **Text** GameObject is selected in the **Hierarchy**. Then,
    in the **Inspector** view, drag the **Slider** GameObject into the public **Slider
    UI** variable slot for the `Slider Value To Text (Script)` scripted component,
    as shown here:![How to do it...](img/1362OT_01_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the **Slider** GameObject is selected in the **Hierarchy**. Then,
    in the **Inspector** view, drag the **Text** GameObject into the public **None
    (Object)** slot for the **Slider (Script)** scripted component, in the section
    for **On Value Changed (Single)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You have now told Unity to which object a message should be sent each time the
    slider is changed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1362OT_01_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: From the drop-down menu, select **SliderValueToText** and the `ShowSliderValue()`
    method, as shown in the following screenshot. This means that each time the slider
    is updated, the `ShowSliderValue()`method, in the scripted object, in GameObject
    **Text** will be executed.![How to do it...](img/1362OT_01_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you run the scene, you will now see a slider. Below it, you will see a
    text message in the `Slider value = <n>` form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each time the slider is moved, the text value shown will be (almost) instantly
    updated. The values should range from `0` (the leftmost of the slider) to `20`
    (the rightmost of the slider).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The update of the text value on the screen probably won't be instantaneous,
    as in happening in the same frame as the slider value is moved, since there is
    some computation involved in the slider deciding that an **On Value Changed**
    event message needs to be triggered, and then looking up any methods of objects
    that are registered as event handlers for such an event. Then, the statements
    in the object's method need to be executed in sequence. However, this should all
    happen within a few milliseconds, and should be sufficiently fast enough to offer
    the user a satisifyingly responsive UI for interface actions such as changing
    and moving this slider.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have added to the **Text** GameObject a scripted instance of the `SliderValueToText`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The `Start()` method, which is executed when the scene first runs, sets the
    variable to be a reference to the **Text** component inside the **Slider** item.
    Next, the `ShowSliderValue()` method is called, so that the display is correct
    when the scene begins (the initial slider value is displayed).
  prefs: []
  type: TYPE_NORMAL
- en: 'This contains the `ShowSliderValue()` method, which gets the value of the slider.
    It updates the text displayed to be a message in the form: `Slider value = <n>`.'
  prefs: []
  type: TYPE_NORMAL
- en: You created a **UI Slider** GameObject, and set it to be whole numbers in the
    0-20 range.
  prefs: []
  type: TYPE_NORMAL
- en: You added to the **UI Slider** GameObject's list of **On Value Changed** event
    listeners the `ShowSliderValue()` method of the `SliderValueToText` scripted component.
    So, each time the slider value changes, it sends a message to call the `ShowSliderValue()`
    method, and so the new value is updated on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a countdown timer graphically with a UI Slider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many cases where we wish to inform the player of the proportion of
    time remaining, or at the completion of some value at a point in time, for example,
    a loading progress bar, the time or health remaining compared to the starting
    maximum, how much the player has filled up their water bottle from the fountain
    of youth, and so on. In this recipe, we'll illustrate how to remove the interactive
    'handle' of a **UI Slider**, and change the size and color of its components to
    provide us with an easy-to-use, general purpose progress/proportion bar. In this
    recipe, we'll use our modified slider to graphically present to the user how much
    time remains for a countdown timer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying a countdown timer graphically with a UI Slider](img/1362OT_01_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe adapts the previous one. So, make a copy of the project for the
    previous recipe, and work on this copy to follow this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the script and images that you need in the
    folders named `Scripts` and `Images` in the `1362_01_10` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a digital countdown timer with a graphical display, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the **Text** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `CountdownTimer` script and the `red_square` and `green_square` images
    to this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the **Slider** GameObject is selected in the **Hierarchy** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deactivate the **Handle Slide Area** child GameObject (by unchecking it)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll see the "drag circle" disappear in the **Game** panel (the user will
    not be dragging the slider, since we want this slider to be display-only), as
    shown in the following screenshot:![How to do it...](img/1362OT_01_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Background** child:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `red_square` image into the **Source Image** property of the **Image
    (Script)** component in the **Inspector** view
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Select the **Fill** child:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `green_square` image into the **Source Image** property of the **Image
    (Script)** component in the **Inspector** tab
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Select the **Fill Area** child:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Rect Transform** component, use the **Anchors** preset position of
    **left-middle**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set **Width** to 155 and **Height** to 12, as shown here:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1362OT_01_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Ensure that the **Slider** GameObject is selected in the **Hierarchy**. Then,
    attach an instance of C# script class called `CountdownTimer` as a component of
    this GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class called `SliderTimerDisplay` containing the following
    code, and add an instance as a scripted component to the **Slider** GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run your game and you will see the slider move with each second, revealing more
    and more of the red background to indicate the time remaining.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You hid the **Handle Slide Area** child so that **Slider** is for display only,
    and cannot be interacted with by the user. The **Background** color of the **Slider**
    was set to red, so that, as the counter goes down, more and more red is revealed—warning
    the user that the time is running out. The **Fill** of the **Slider** was set
    to green, so that the proportion remaining is displayed in green (the more green
    it becomes, the larger the value of the slider/timer).
  prefs: []
  type: TYPE_NORMAL
- en: An instance of the provided `CountdownTimer` script class was added as a component
    to the Slider. The `ResetTimer(…)` method records the number of seconds provided
    and the time the method was called. The `GetProportionRemaining()` method returns
    a value from 0.0-1.0, representing the proportion of the seconds remaining (1.0
    being all seconds, 0.5 half the seconds, and 0.0 meaning that no seconds are left).
  prefs: []
  type: TYPE_NORMAL
- en: You have added to the **Slider** GameObject an instance of the `SliderTimerDisplay`
    scripted class. The `Start()` method calls the `SetupSlider()` and `SetupTimer()`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetupSlider()` method sets the `sliderUI` variable to be a reference to
    the **Slider** component, and sets up this slider mapped to float (decimal) values
    between `0.0` and `1.0`.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetupTimer()` method sets the `countdownTimer` variable to be a reference
    for the **CountdownTimer** component, and starts this timer scripted component
    to count down from 30 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: In each frame, the `Update()`method sets the slider value to the float returned
    by calling the `GetProportionRemaining()`method from the running timer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Try to work with floats between 0.0-1.0 whenever possible.**'
  prefs: []
  type: TYPE_NORMAL
- en: Integers could have been used, setting the Slider min to 0 and max to 30 (for
    30 seconds). However, changing the total number of seconds would then also require
    the Slider settings to be changed. In most cases working with a float proportion
    between 0.0 and 1.0 is the more general-purpose and reusable approach to adopt.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a radar to indicate the relative locations of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A radar displays the locations of other objects relative to the player, usually
    based on a circular display, where the center represents the player, and each
    graphical 'blip' indicates how far away and what relative direction objects are
    to the player. Sophisticated radar displays will display different categories
    of objects with different colored or shaped 'blip' icons.
  prefs: []
  type: TYPE_NORMAL
- en: In the screenshot, we can see 2 red square 'blips', indicating the relative
    position of the 2 red cube GameObjects tagged `Cube` near the player, and a yellow
    circle 'blip' indicating the relative position of the yellow sphere GameObject
    tagged `Sphere`. The green circle radar background image gives the impression
    of an aircraft control tower radar or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying a radar to indicate the relative locations of objects](img/1362OT_01_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the images that you need in a folder named
    `Images` in `1362_01_11`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a radar to show the relative positions of the objects, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new 3D project by importing the following standard assets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Environment**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Characters**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cameras**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a terrain by navigating to the **Create** | **3D Object** | **Terrain**
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Size the terrain 20 x 20, positioned at (-10, 0, -10)—so that its center is
    at (0, 0, 0), as shown in the following figure:![How to do it...](img/1362OT_01_47.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Texture paint your terrain with the **SandAlbedo** option, as shown here:![How
    to do it...](img/1362OT_01_48.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Standard Assets** folder in the **Project** panel, drag the prefab
    **ThirdPersonController** into the scene and position it at (0, 1, 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tag this **ThirdPersonController** GameObject called **Player**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the **Main Camera** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Standard Assets** folder in the **Project** panel, drag the prefab
    **Multi-PurposeCameraRig** into the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With **Multi-PurposeCameraRig** selected in the **Hierarchy**, drag the **ThirdPersonController**
    GameObject into the **Target** property of the **Auto Cam (Script)** public variable
    in the **Inspector** tab, as shown in the following screenshot:![How to do it...](img/1362OT_01_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the provided folder known as `Images`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** panel, add a **UI** | **RawImage** GameObject to the scene
    named **RawImage-radar**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the **RawImage-radar** GameObject is selected in the **Hierarchy**
    panel. From your **Project** `Images` folder, drag the `radarBackground` image
    into the **Raw Image (Script)** public property **Texture**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, in **Rect Transform** position **RawImage-radar** at the top-left part
    using the **Anchor Presets** item. Then set the width and height to 200 pixels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another new UI **RawImage** named **RawImage-blip**. Assign the `yellowCircleBlackBorder`
    texture. Tag the **Blip** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Project** panel, create a new empty prefab named **blip-sphere**, and
    drag the **RawImage-blip** GameObject into this prefab to store all its properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, change the texture of **RawImage-blip** to `redSquareBlackBorder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, create a new empty prefab named **blip-cube**, and drag
    the **RawImage-blip** GameObject into this prefab to store all its properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the **RawImage-blip** GameObject from the **Hierarchy** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class called `Radar,` containing the following code, and
    add an instance as a scripted component to the **RawImage-radar** GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create two cubes—tagged **Cube**, textured with a red image called **icon32_square_red**.
    Position each away from the player's character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a sphere—tagged **Sphere**, textured with a red image called **icon32_square_yellow**.
    Position this away from the cubes and the player's character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run your game. You will see two red squares and one yellow circle on the radar,
    showing the relative positions of the red cubes and yellow sphere. If you move
    too far away, then the blips will disappear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This radar script scans 360 degrees all around the player, and only considers
    straight line distances in the X-Z plane. So, the distances in this radar are
    not affected by any height difference between the player and target GameObjects.
    The script can be adapted to ignore targets whose height is more than some threshold
    different to the player's height. Also, as presented, this recipe radar *sees*
    through everything, even if there are obstacles between the player and the target.
    The recipe can be extended to not show obscured targets through the user of the
    ray-casting techniques. See the Unity scripting reference for more details about
    ray-casting at [http://docs.unity3d.com/ScriptReference/Physics.Raycast.html](http://docs.unity3d.com/ScriptReference/Physics.Raycast.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A radar background is displayed on the screen. The center of this circular image
    represents the position of the player's character. You have created two prefabs;
    one for red square images to represent each red cube found within the radar distance,
    and one for yellow circles to represent yellow sphere GameObjects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Radar` C# script class has been added to the radar UI Image GameObject.
    This class defines four public variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`insideRadarDistance`: This value defines the maximum distance that an object
    may be from the player to still be included on the radar (objects further than
    this distance will not be displayed on the radar).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blipSizePercentage`: This public variable allows the developer to decide how
    large each ''blip'' will be, as a proportion of the radar''s image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rawImageBlipCube` and `rawImageBlipSphere`: These are references to the prefab
    UI **RawImages** that are to be used to visually indicate the relative distance
    and position of cubes and spheres on the radar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since there is a lot happening in the code for this recipe, each method will
    be described in its own section.
  prefs: []
  type: TYPE_NORMAL
- en: The Start() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Start()` method caches a reference to the **Transform** component of the
    player's character (tagged as **Player**). This allows the scripted object to
    know about the position of the Player's character in each frame. Next, the width
    and height of the radar image are cached—so, the relative positions for 'blips'
    can be calculated, based on the size of this background radar image. Finally,
    the size of each blip (width and height) is calculated, using the `blipSizePercentage`
    public variable.
  prefs: []
  type: TYPE_NORMAL
- en: The Update() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Update()` method calls the `RemoveAllBlips()` method, which removes any
    old **RawImage** UI GameObjects of cubes and spheres that might currently be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `FindAndDisplayBlipsForTag(…)`method is called twice. First, for the
    objects tagged **Cube**, to be represented on the radar with the `rawImageBlipCube`
    prefab and then again for objects tagged **Sphere**, to be represented on the
    radar with the `rawImageBlipSphere` prefab. As you might expect, most of the hard
    work for the radar is to be performed by the `FindAndDisplayBlipsForTag(…)` method.
  prefs: []
  type: TYPE_NORMAL
- en: The FindAndDisplayBlipsForTag(…) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method inputs two parameters: the string tag for the objects to be searched
    for; and a reference to the **RawImage** prefab to be displayed on the radar for
    any such tagged objects within the range.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the current position of the player''s character is retrieved from the
    cached player transform variable. Next, an array is constructed, referring to
    all GameObjects in the scene that have the provided tag. This array of GameObjects
    is looped through, and for each GameObject, the following actions are performed:'
  prefs: []
  type: TYPE_NORMAL
- en: The position of the target GameObject is retrieved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The distance from this target position to the player''s position is calculated,
    and if this distance is within the range (less than or equal to `insideRadarDistance`),
    then three steps are now required to get the blip for this object to appear on
    the radar:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The normalized position of the target is calculated by calling `NormalisedPosition(…)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The position of the blip on the radar is then calculated from this normalized
    position by calling `CalculateBlipPosition(…)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the **RawImage** blip is displayed by calling `DrawBlip(…)` and passing
    the blip position and the reference to the **RawImage** prefab that is to be created
    there
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The NormalisedPosition(…) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `NormalisedPosition(…)` method inputs the player's character position and
    the target GameObject position. It has the goal of outputting the relative position
    of the target to the player, returning a Vector3 object with a triplet of *X*,
    *Y*, and *Z* values. Note that since the radar is only 2D, we ignore the *Y*value
    of target GameObjects. So, the *Y*value of the Vector3 object returned by this
    method will always be 0\. So, for example, if a target was at exactly the same
    location as the player, the returned *X*, *Y*, *Z* Vector3 object would be (0,
    0, 0).
  prefs: []
  type: TYPE_NORMAL
- en: Since we know that the target GameObject is no further from the player's character
    than `insideRadarDistance`, we can calculate a value in the -1 … 0 … +1 range
    for the *X* and *Z* axis by finding the distance on each axis from the target
    to the player, and then dividing it by `insideRadarDistance`. An *X* value of
    -1 means that the target is fully to the left of the player (at a distance that
    is equal to `insideRadarDistance`), and +1 means it is fully to the right. A value
    of 0 means that the target has the same *X* position as the player's character.
    Likewise, for -1 … 0 … +1 values in the *Z-axis* (this axis represents how far,
    in front or behind us an object, is located, which will be mapped to the vertical
    axis in our radar).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this method constructs and returns a new Vector3 object, with the calculated
    *X* and *Z* normalized values, and a *Y* value of zero.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The normalized position**'
  prefs: []
  type: TYPE_NORMAL
- en: A *normalized* value is one that has been simplified in some way, so the context
    has been abstracted away. In this recipe, what we are interested in is where an
    object is relative to the player. So, our normal form is to get a value of the
    *X* and *Z* position of a target in the -1 to +1 range for each axis. Since we
    are only considering GameObject within out `insideRadarDistance` value, we can
    map these normalized target positions directly onto the location of the radar
    image in our UI.
  prefs: []
  type: TYPE_NORMAL
- en: The CalculateBlipPosition(…) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we calculate `angleToTarget`: the angle from (0, 0, 0) to our normalized
    target position.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we calculate `anglePlayer`: the angle the player''s character is facing.
    This recipe makes use of the **yaw** angle of the rotation, which is the rotation
    about the *Y-axis*—that is, the direction that a character controller is facing.
    This can be found in the *Y* component of a GameObject''s `eulerAngles` component
    of its transform. You can imagine looking from above and down at the character
    controller, and see what direction they are facing—this is just what we are trying
    to display graphically with the compass.'
  prefs: []
  type: TYPE_NORMAL
- en: Our desired radar angle (the `angleRadarDegrees` variable) is calculated by
    subtracting the player's direction angle from the angle between target and player,
    since a radar displays the relative angle from the direction that the player is
    facing, to the target object. In mathematics, an angle of zero indicates an *east*
    direction. To correct this, we need to also subtract 90 degrees from the angle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The angle is then converted into radians, since this is required for the Unity
    trigonometry methods. We then multiply the `Sin()` and `Cos()` results by our
    normalized distances to calculate the *X* and *Y* values respectively (see the
    following figure):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The CalculateBlipPosition(…) method](img/1362OT_01_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our final position values need to be expressed as pixel lengths, relative to
    the center of the radar. So, we multiply our `blipX` and `blipY` values by half
    the width and the height of the radar; note that we multiply only with half the
    width, since these values are relative to the center of the radar.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: In this figure, alpha is the angle between player and target object,
    ''a'' is the adjacent side, ''h'' is the hypotenuse and ''o'' is the side opposite
    the angle.'
  prefs: []
  type: TYPE_NORMAL
- en: We then add half the width and height of the radar image to the `blipX`/`Y`
    values. So, these values are now positioned relative to the center.
  prefs: []
  type: TYPE_NORMAL
- en: Finally a new **Vector2** object is created and returned, passing back these
    final calculated *X* and *Y* pixel values for the position of our blip icon.
  prefs: []
  type: TYPE_NORMAL
- en: The DrawBlip() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `DrawBlip()` method takes the input parameters of the position of the blip
    (as a `Vector2` *X*, *Y* pair), and the reference to the **RawImage** prefab to
    be created at that location on the radar.
  prefs: []
  type: TYPE_NORMAL
- en: A new GameObject is created from the prefab, and is parented to the radar GameObject
    (of which the scripted object is also a component). A reference is retrieved to
    the **Rect Transform** of the new **RawImage** GameObject that has been created
    for the 'blip'. Calls to the Unity **RectTransform** method, `SetInsetAndSizeFromParentEdge(…),`
    result in the blip GameObject being positioned at the provided horizontal and
    vertical locations over the radar image, regardless of where in the **Game** panel
    the background radar image has been located.
  prefs: []
  type: TYPE_NORMAL
- en: Creating UIs with the Fungus open-source dialog system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than constructing your own UI and interactions from scratch each time,
    there are plenty of UI and dialogue systems available for Unity. One powerful,
    free, and open source dialog system is called **Fungus**, which uses a visual
    flowcharting approach to dialog design.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll create a very simple, two-sentence dialogue, to illustrate
    the basics of Fungus. The following screenshot shows the Fungus-generated dialog
    for the first sentence ('**Hello, how are you**') and the interactive button (a
    triangle inside a circle) the user clicks to progress to the next piece of dialog
    (in the bottom-right part of the rectangle).
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating UIs with the Fungus open-source dialog system](img/1362OT_01_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a two-sentence dialog using Fungus, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the latest version of the Fungus **unitypackage** from the FungusGames
    website [http://www.fungusgames.com/](http://www.fungusgames.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Unity 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the Fungus **unitypackage** by navigating to **Assets** | **Import Package**
    | **Custom Package...**, and then navigating to your downloaded file location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Fungus **Flowchart** GameObject by choosing menu: **Tools** |
    **Fungus** | **Create** | **Flowchart**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Display and dock the Fungus **Flowchart** window panel by choosing menu: **Tools**
    | **Fungus** | **Flowchart Window**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There will be a block in the **Flowchart** Window. Click on this block to select
    it (a green border appears around the block to indicate that it is selected),
    and then in the **Inspector** panel, change the name of this block to **Start**,
    as shown in the following screenshot:![How to do it...](img/1362OT_01_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each **Block** in a Flowchart follows a sequence of commands. So, we are now
    going to create a sequence of commands to display two sentences to the user when
    the game runs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The sequence of **Commands** in a **Block**
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Each **Block** in a **Flowchart** follows a sequence of **Commands**, so to
    display two sentences to the user when the game runs, we need to create a sequence
    of two **Say** commands in the **Inspector** panel properties for our **Block**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ensure that the **Start** block is still selected in the **Flowchart** panel.
    Now, click on the plus **+**' button at the bottom section of the **Inspector**
    panel to display the menu of **Commands**, and select the **Narrative** | **Say**
    command, as shown here:![How to do it...](img/1362OT_01_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since we only have one command for this block, that command will automatically
    be selected (highlighted green) in the top-half part of the **Inspector** view.
    The bottom half of the **Inspector** view presents the properties for the currently
    selected **Command**, as shown in the following screenshot. In the bottom-half
    part of the **Inspector** view, for the **Story Text** property, enter the text
    of the question that you wish to be presented to the user: `How are you today?`![How
    to do it...](img/1362OT_01_26.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create another **Say Command**, and type the following for its **Story
    Text** property: `Very well thank you.`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you run the game, the user will first be presented with the **How are
    you today?** text (hearing a clicking noise as each letter is *typed* on screen).
    After the user clicks on the ''continue'' triangle button (at the bottom-right
    part of the dialog window), they will then be presented with the second sentence:
    **Very well thank you.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have created a new Unity project, and imported the Fungus asset package,
    containing the Fungus Unity menus, windows and commands, and also the example
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: You have added a **Fungus Flowchart** to your scene with a single **Block**
    that you have named **Start**. Your block starts to execute when the game begins
    (since the default for the first block is to be executed upon receiving the **Game
    Started** event).
  prefs: []
  type: TYPE_NORMAL
- en: In the **Start** block, you added a sequence of two **Say Commands**. Each command
    presents a sentence to the user, and then waits for the continue button to be
    clicked before proceeding to the next **Command**.
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen, the Fungus system handles the work of creating a nicely presented
    panel to the user, displaying the desired text and continue button. Fungus offers
    many more features, including menus, animations, control of sounds and music,
    and so on, details of which can be found by exploring their provided example projects,
    and their websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://fungusgames.com/](http://fungusgames.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/FungusGames/Fungus](https://github.com/FungusGames/Fungus)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting custom mouse cursor images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cursor icons are often used to indicate the nature of the interaction that
    can be done with the mouse. Zooming, for instance, might be illustrated by a magnifying
    glass. Shooting, on the other hand, is usually represented by a stylized target.
    In this recipe, we will learn how to implement custom mouse cursor icons to better
    illustrate your gameplay—or just to escape the Windows, OSX, and Linux default
    GUI. The following screenshot shows a custom magnifying glass mouse cursor when
    the use''s mouse pointer hovers over a **Button**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting custom mouse cursor images](img/1362OT_01_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the images that you'll need in a folder named
    `IconsCursors` in the `1362_01_13` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make a custom cursor appear when the mouse is over a GameObject, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Directional Light** item to the scene by navigating to **Create** |
    **Light** | **Directional light**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a 3D **Cube** to the scene, scaled to (5, 5, 5). Because it was created
    as a 2D project the cube will appear as a grey square in the **Game** panel (2D
    projects have an orthographic camera, so we won't see perspective effects).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the provided folder called `IconsCursors`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Ensure that each image in this folder has been imported as **Texture Type Cursor**.
    If they are not, then select this type for each image and click on the **Apply**
    button in the **Inspector** view.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a C# script class called `CustomCursorPointer`, containing the following
    code, and add an instance as a scripted component to the **Cube** GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Event methods `OnMouseEnter()` and `OnMouseExit()` have been purposely declared
    as `public`. This will allow these methods to also be called from UI GameObjects
    when they receive the `OnPointerEnterExit` events.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the **Cube** item selected in the **Hierarchy** panel, drag the `CursorTarget`
    image into the public **Cursor Texture 2D** variable slot in the **Inspector**
    panel for the **Customer Cursor Pointer (Script)** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the current scene, and add it to the **Build**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You will not be able to see the custom cursors in the Unity Editor. You must
    build your game application, and you'll see the custom cursors when you run the
    build app.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Build your project. Now, run your built application, and when the mouse pointer
    moves over the grey square of the **Cube**, it will change to the custom `CursorTarget`
    image that you chose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have added a scripted object to a cube that will tell Unity to change the
    mouse pointer when an **OnMouseEnter** message is received—that is, when the user's
    mouse pointer moves over the part of the screen where the cube is being rendered.
    When an **OnMouseExit** event is received (the users mouse pointer is no longer
    over the cube part of the screen), the system is told to go back to the operating
    system default cursor. This event should be received within a few milliseconds
    of the user's mouse exiting from the collider.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Custom cursors for mouse over UI controls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unity 5 UI controls do not receive the **OnMouseEnter** and **OnMouseExit**
    events. They can respond to the **PointerEnter/Exit** events, but this requires
    adding the **Event Trigger** components. To change the mouse pointer when the
    mouse moves over a UI element, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a UI **Button** to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an instance of the C# script class called `CustomCursorPointer` to the button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With **Button** selected in the **Hierarchy panel**, drag the `CursorZoom` image
    into the public **Cursor Texture 2D** variable slot in the **Inspector** panel
    for the **Customer Cursor Pointer (Script)** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Inspector** view**,** add an **Event Triggers** component to the **Button**.
    Choose menu: **Add Component** | **Event** | **Event Trigger**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Pointer Enter** event to your **Event Trigger** component, click on
    the plus (**+**) button to add an event handler slot, and drag the **Button**
    GameObject into the **Object** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Function** drop-down menu, choose **CustomCursorPointer** and then
    choose the **OnMouseEnter** method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We have added an Event Handler so that when the **Button** receives a **Pointer
    Enter** (mouse over) event, it will execute the **OnMouseEnter()** method of the
    **CustomCursorPointer** scripted object inside the **Button**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a **Pointer Exit** event to your **Event Trigger** component, and make it
    call the `OnMouseExit()`method from **CustomCursorPointer** when this event is
    received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the current scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build your project. Now, run your built application and when the mouse pointer
    moves over the **Button,** it will change to the custom `CursorZoom` image that
    you chose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input Fields component for text entry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While many times we just wish to display non-interactive text messages to the
    user, there are times (such as name entry for high scores) where we wish that
    the user was able to enter text or numbers into our game. Unity provides the **Input
    Field** UI component for this purpose. In this recipe, we'll create a simple text
    input UI by making use of the default Button image and text GameObjects, and we'll
    add a script to respond to each new value of the input field.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can, of course, create a working text input quicker than this recipe''s
    method by choosing menu: **Create | UI | Input Field**, which creates a GameObject
    containing an Input Field component, child text, and placeholder GameObjects,
    as shown in the following screenshot. However, by following the steps in this
    recipe, you''ll learn the interrelationships between the different interface elements,
    because you''ll be creating these connections manually from the deconstructed
    parts of the UI Button GameObject.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Input Fields component for text entry](img/1362OT_01_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a promoted text input box to the user with faint placeholder text,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** view, change the background of the **Main Camera** to solid
    white.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **UI Button** to the scene. Delete the **Button (Script)** component of
    the **Button** GameObject (since it won't be a button, it will be an interactive
    text input by the time we are finished with it!).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the **Text** child GameObject of the **Button** component to **Text-placeholder**.
    Uncheck the **Rich Text** option, change the text to **Enter name…**, change the
    **Alignment** in **Left** and **Top**, and in the **Rect Transform**, set **Left**
    to `4` and **Top** to `7`.![How to do it...](img/1362OT_01_38.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate **Text-placeholder by** naming the copy **Text-prompt**. Change the
    **Text** of this GameObject to **Name:**, and set its **Left** position to `-50`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate **Text-placeholder** again, naming this new copy **Text-input**. Delete
    all of the content of the **Text** property of this new GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Text-placeholder** in the **Hierarchy,** and we will now make the placeholder
    text mostly transparent. Set the **A** (alpha) **Color** value of the **Text (Script)**
    component of this GameObject to a value that is about a quarter of its maximum
    value (e.g. 64).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **Text-input** in the **Hierarchy,** and add an **Input Field** component
    by choosing menu: **Add Component** | **UI** | **Input Field**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Text-input** GameObject into the **Text Component** property of **Input
    Field**, and drag the **Text-placeholder** GameObject into the **Placeholder**
    property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and run your scene. You now have a working text input UI for your user.
    When there is no text content, the faint placeholder text will be displayed. As
    soon as any characters have been typed, the placeholder will be hidden and the
    characters typed will appear in black text. Then, if all the characters are deleted,
    the placeholder will appear again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core of interactive text input in Unity is the responsibility of the **Input
    Field** component. This needs a reference to a UI **Text** GameObject. To make
    it easier to see where the text can be typed, we have made use of the default
    rounded rectangle image that Unity provides when a **Button** GameObject is created.
    **Buttons** have both an **Image** component and a **Text** child GameObject.
    So, two items that we need can be acquired very easily by creating a new **Button,**
    and simply by removing the **Button (Script)** component.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are usually three **Text** GameObjects involved with the user text input:
    the static prompt text (in our recipe, for example, the **Name:** text); then
    the faint placeholder text, reminding users where and what they should type; and
    finally the text object (with the font and color settings and so on) that is actually
    displayed to the user, showing the characters as they type.'
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, a **Text-Input Input Caret** GameObject is created—displaying the
    blinking vertical line to inform the user where their next letter will be typed.
    Note that the **Content Type** of the **Input Field (Script)**, in the **Inspector**,
    can be set to several specific types of text input, including e-mail addresses,
    integer or decimal numbers only, or the password text (where an asterisk is displayed
    for each entered character).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Executing a C# method to respond each time the user changes the input text content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having interactive text on the screen isn't of much use unless we can retrieve
    the text entered to use in our game logic, and we may need to know each time the
    user changes the text content and act accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add code and events to respond each time the text content has been changed
    by the user, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an instance of the C# script class called `DisplayChangedTextContent` to
    the **Text-input** GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add an **End Edit (String)** event to the list of event handlers for the **Input
    Field (Script)** component. Click on the plus (**+**) button to add an event handler
    slot, and drag the **Text-input** GameObject into the **Object** slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Function** drop-down menu, choose **DisplayChangedTextContent** and
    then choose the **PrintNewValue** method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and run the scene. Each time the user types in new text and then presses
    *Tab* or *Enter*, the **End Edit** event will fire, and you'll see a new content
    text message printed in the **Console** window by our script, as shown in the
    following screenshot:![Executing a C# method to respond each time the user changes
    the input text content](img/1362OT_01_36.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Toggles and radio buttons via Toggle Groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users make choices, and often, these choices are either to have one of two available
    options (for example, sound on or off), or sometimes to choose one of several
    possibilities (for example, difficulty level easy/medium/hard). Unity UI **Toggles**
    allows users to turn options on and off; and when combined with **Toggle Groups**,
    they restrict choices to one of the group of items. In this recipe, we'll first
    explore the basic **Toggle**, and a script to respond to a change in values. Then
    in the *There's More* section, we'll extend the example to illustrate **Toggle
    Groups**, and styling these with round images to make them look more like traditional
    radio buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the button''s status changes are logged
    in the **Console** panel when the scene is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Toggles and radio buttons via Toggle Groups](img/1362OT_01_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the images that you'll need in a folder named
    `UI Demo Textures` in the `1362_01_15` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display an on/off UI Toggle to the user, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** panel, change the **Background** color of the **Main Camera**
    to white.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add **UI Toggle** to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `First Class` as **Text** for the **Label** child GameObject of the **Toggle**
    GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an instance of the C# script class called `ToggleChangeManager` to the
    **Toggle** GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the **Toggle** GameObject selected, add an **On Value Changed** event to
    the list of event handlers for the **Toggle (Script)** component, click on the
    plus (+) button to add an event handler slot, and drag **Toggle** into the **Object**
    slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Function** drop-down menu, choose **ToggleChangeManager** and then
    choose the **PrintNewToggleValue** method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and run the scene. Each time you check or uncheck the **Toggle** GameObject,
    the **On Value Changed** event will fire, and you'll see a new text message printed
    into the Console window by our script, stating the new Boolean true/false value
    of the **Toggle**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create a Unity UI **Toggle** GameObject, it comes with several child
    GameObjects automatically—**Background**, **Checkmark**, and the text **Label**.
    Unless we need to style the look of a **Toggle** in a special way, all that is
    needed is simply to edit the text **Label** so that the user knows what option
    or feature that this **Toggle** is going to turn on/off.
  prefs: []
  type: TYPE_NORMAL
- en: The C# scripted class called `ToggleChangeManager's` method called `Start()`
    gets a reference to the **Toggle** component in the GameObject, where the script
    instance is located. When the game is running, each time the user clicks on the
    **Toggle** to change its value, an **On Value Changed** event is fired. We then
    register the `PrintNewToggleValue()`method, which is supposed to be executed when
    such an event occurs. This method retrieves, and then prints out to the **Console**
    panel the new Boolean true/false value of the **Toggle**.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Adding more Toggles and a Toggle Group to implement mutually-exclusive radio
    buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Unity UI **Toggles** are also the base components, if we wish to implement
    a group of mutually-exclusive options in the style of radio buttons. To create
    such a group of related choices, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `UI Demo Textures` folder into the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the C# script class `ToggleChangeManager` component from the **Toggle**
    GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the **Toggle** GameObject as **Toggle-easy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the **Label** text to **Easy**, and tag this GameObject with a new tag
    called **Easy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Background** child GameObject of **Toggle-easy**, and in the **Image
    (Script)** component, drag the `UIToggleBG` image into the **Source Image** property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the **Is On** property of the **Toggle (Script)** component is checked,
    and then select the **Checkmark** child GameObject of **Toggle-easy**. In the
    **Image (Script)** component, drag the `UIToggleButton` image into the **Source
    Image** property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Of the three choices (easy, medium, and hard) that we'll offer to the user,
    we'll set the easy option to be the one that is supposed to be initially selected.
    Therefore, we need its **Is On** property to be checked, which will lead to its
    'checkmark' image being displayed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To make these **Toggles** look more like radio buttons, the background of each
    is set to the circle image of `UIToggleBG`, and the checkmark (which displays
    the **Toggles** that are on) is filled with the circle image called `UIToggleButton`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Duplicate the **Toggle-easy** GameObject, naming the copy **Toggle-medium**.
    Set its **Rect Transform** property **Pos Y** to `-25` (so, this copy is positioned
    below the easy option), and uncheck the **Is On** property of the **Toggle (Script)**
    component. Tag this copy with a new tag called **Medium**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the **Toggle-medium** GameObject, naming the copy **Toggle-hard**.
    Set its **Rect Transform** property **Pos Y** to `-50` (so this copy is positioned
    below the medium option). Tag this copy with a new tag called **Hard**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an instance of the C# script class called `RadioButtonManager` to the **Canvas**
    GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the **Toggle-easy** GameObject selected, add an **On Value Changed** event
    to the list of event handlers for the **Toggle (Script)** component. Click on
    the plus (**+**) button to add an event handler slot, and drag the **Canvas**
    GameObject into the Object slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Function** drop-down menu, choose **RadioButtonManager**, and then
    choose the **PrintNewGroupValue** method. In the **Toggle** parameter slot, which
    is initially `None (Toggle)`, drag the **Toggle-easy** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the same for the **Toggle-medium** and **Toggle-hard** GameObjects—so each
    **Toggle** object calls the `PrintNewGroupValue(…)`method of a C# scripted component
    called `RadioButtonManager` in the **Canvas** GameObject, passing itself as a
    parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and run the scene. Each time you check one of the three radio buttons,
    the **On Value Changed** event will fire, and you'll see a new text message printed
    into the **Console** window by our script, stating the tag of whichever **Toggle**
    (radio button) was just set to true (**Is On**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following screenshot shows how the value corresponding to the selected radio
    button is logged to the **Console** panel when the scene is running:![Adding more
    Toggles and a Toggle Group to implement mutually-exclusive radio buttons](img/1362OT_01_40.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have introduced recipes demonstrating a range of Unity 5
    UI components, and illustrated how the same components can be used in different
    ways (such as an interactive slider being used to display the status of a countdown
    timer). One set of UI components in many games are those that communicate to the
    user what they are carrying (or yet to pick up). We have dedicated another chapter
    in this book to inventories in [Chapter 2](ch02.html "Chapter 2. Inventory GUIs"),
    *Inventory GUIs*, which provides many inventory recipes and additional UI controls,
    such as adding interactive scroll bars.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some suggestions for further reading, tutorials, and resources to
    help you continue your learning of UI development in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about the Unity UI on manual pages at [http://docs.unity3d.com/Manual/UISystem.html](http://docs.unity3d.com/Manual/UISystem.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work through the Unity UI tutorial videos at [https://unity3d.com/learn/tutorials/topics/user-interface-ui](https://unity3d.com/learn/tutorials/topics/user-interface-ui).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ray Wenderlich's great tutorial on Unity UI development at [http://www.raywenderlich.com/78675/unity-new-gui-part-1](http://www.raywenderlich.com/78675/unity-new-gui-part-1).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unity''s documentation pages about designing UI for multiple resolutions: [http://docs.unity3d.com/Manual/HOWTO-UIMultiResolution.html](http://docs.unity3d.com/Manual/HOWTO-UIMultiResolution.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Games need fonts in a style to match the gameplay and theme. Here are some
    of the sources of free personal/commercial fonts suitable for many games:'
  prefs: []
  type: TYPE_NORMAL
- en: All the fonts at FontSquirrel are 100% free for commercial use. They are available
    at [http://www.fontsquirrel.com/](http://www.fontsquirrel.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See each font for individual license at the DaFont website. Many people ask
    for a donation if these are used for commercial purposes. For more information,
    check out [http://www.dafont.com/xolonium.font](http://www.dafont.com/xolonium.font).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See each font for individual licenses available on the Naldz Graphics blog at
    [http://naldzgraphics.net/textures/](http://naldzgraphics.net/textures/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1001 Free Fonts (for personal use) are available at [http://www.1001freefonts.com/index.php](http://www.1001freefonts.com/index.php).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
