- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Advanced C# Concepts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级C#概念
- en: As we journey deeper into the realm of C# programming, it becomes apparent that
    the language, under its seemingly straightforward facade, harbors a wealth of
    advanced functionalities designed to address complex software development needs.
    This chapter delves into these sophisticated facets of C#, equipping you with
    the knowledge to craft efficient, flexible, and robust applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们深入C#编程的领域，很明显，这种语言在其看似简单的表面之下，隐藏着丰富的先进功能，旨在解决复杂的软件开发需求。本章深入探讨C#的这些复杂方面，为你提供知识，让你能够构建高效、灵活和健壮的应用程序。
- en: From the intricacies of collections and the power of **Language Integrated Query**
    (**LINQ**) to the nuances of asynchronicity, we’ll embark on an enlightening expedition
    that transcends basic programming constructs. We’ll explore the realm of delegates
    and lambdas, unravel the mysteries of garbage collection, and tread the intricate
    paths of multithreading and concurrency.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从集合的复杂性和**语言集成查询（LINQ**）的力量到异步性的细微差别，我们将踏上一次启迪人心的探险，超越基本的编程结构。我们将探索委托和lambda的世界，揭开垃圾回收的神秘面纱，踏过多线程和并发的复杂路径。
- en: 'While these topics might initially seem daunting, remember that mastering them
    is what separates a novice programmer from a seasoned developer. By the end of
    this chapter, you’ll be well versed in the following areas:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些主题最初可能看起来令人畏惧，但请记住，掌握它们是区分新手程序员和资深开发者的关键。到本章结束时，你将精通以下领域：
- en: Efficiently manipulating data using collections and LINQ
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集合和LINQ高效地操作数据
- en: Debugging your code effectively and gracefully handling exceptions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效调试代码并优雅地处理异常
- en: Enhancing user experience through asynchronous programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过异步编程提升用户体验
- en: Harnessing the power of delegates, events, and lambda expressions for more streamlined
    and adaptive code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用委托、事件和lambda表达式来构建更流畅和适应性强的代码
- en: Crafting reusable code with generics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型构建可重用代码
- en: Mastering the complexities of multithreading and ensuring smooth concurrent
    operations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握多线程的复杂性并确保平滑的并发操作
- en: Optimizing performance by understanding and managing garbage collection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过理解和管理垃圾回收来优化性能
- en: Ready to elevate your C# expertise? Let’s embark on this exciting journey!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 准备提升你的C#技能？让我们踏上这段激动人心的旅程吧！
- en: Working with collections and LINQ
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与集合和LINQ一起工作
- en: In the vast landscape of C# programming, **collections** stand as foundational
    structures, serving as versatile containers for data. But what if we could query
    and manipulate these collections with the elegance and power akin to database
    operations? Enter **LINQ**. This section unveils the synergy of collections and
    LINQ, guiding you through the art of efficiently organizing, querying, and manipulating
    datasets. Whether you’re dealing with a simple list of items or complex nested
    structures, the combined prowess of collections and LINQ will transform the way
    you handle data in C#. Prepare to explore techniques that will not only elevate
    your coding prowess but also dramatically enhance the efficiency and clarity of
    your applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#编程的广阔领域中，**集合**作为基础结构，作为数据的多功能容器。但如果我们能够以类似数据库操作的方式查询和操作这些集合会怎样呢？这就是**LINQ**的用武之地。本节揭示了集合和LINQ的协同作用，引导你通过高效组织、查询和操作数据集的艺术。无论你是在处理简单的项目列表还是复杂的嵌套结构，集合和LINQ的结合将改变你在C#中处理数据的方式。准备好探索那些不仅会提升你的编码能力，而且会极大地提高你应用程序的效率和清晰度的技术。
- en: What are the key differences between the “IEnumerable” and “ICollection” interfaces?
    When is it optimal to use each?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “IEnumerable”和“ICollection”接口之间的关键区别是什么？何时使用每个接口是最优的？
- en: 'Both `IEnumerable` and `ICollection` are interfaces in the .NET Framework designed
    for handling collections of data, but they serve different purposes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable`和`ICollection`都是.NET Framework中用于处理数据集合的接口，但它们有不同的用途：'
- en: '**IEnumerable** provides the basic capability to iterate over a collection.
    It exposes an enumerator, which supports a simple iteration over a non-generic
    collection. Essentially, if you only need to enumerate over items, **IEnumerable**
    is sufficient.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IEnumerable** 提供了遍历集合的基本能力。它暴露了一个枚举器，支持对非泛型集合进行简单遍历。本质上，如果你只需要枚举项，**IEnumerable**
    就足够了。'
- en: '**ICollection** extends **IEnumerable** and provides additional methods for
    manipulating the size of the collection and for adding, removing, and checking
    the existence of elements in the collection.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ICollection**扩展了**IEnumerable**，并提供了用于操作集合大小以及添加、删除和检查集合中元素存在性的额外方法。'
- en: 'In practice, do the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，请执行以下操作：
- en: Use **IEnumerable** when you simply want to iterate over a collection without
    needing to modify it
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你只想迭代集合而不需要修改它时，请使用**IEnumerable**。
- en: Use **ICollection** when you need to manipulate the collection itself, such
    as adding or removing items
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要操作集合本身时，例如添加或删除项目，请使用**ICollection**。
- en: How does the “deferred execution” principle work in LINQ, and how does it impact
    performance?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LINQ中的“延迟执行”原则是如何工作的，它如何影响性能？
- en: '`foreach` loop or converting the results with methods such as `ToList()` or
    `ToArray()`. This can enhance performance by avoiding unnecessary computations.
    However, it’s important to manage the moment when the data is actually *materialized*
    – that is, fetched and loaded into memory. Materializing the data too early can
    sometimes consume more resources, especially when the data source is substantial,
    such as a database. You might want to append more conditions or filters to the
    query before deciding to materialize the results to optimize resource usage and
    performance.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`foreach`循环或使用`ToList()`或`ToArray()`等方法转换结果。这可以通过避免不必要的计算来提高性能。然而，管理数据实际*实体化*的时刻很重要——即，检索并加载到内存中。过早地实体化数据有时会消耗更多资源，尤其是在数据源很大时，例如数据库。在决定实体化结果之前，你可能想要在查询中添加更多条件或过滤器，以优化资源使用和性能。
- en: What are the primary differences between the “Where” and “Select” LINQ methods,
    and when is it best to use each?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “Where”和“Select”LINQ方法的主要区别是什么，何时最好使用每个方法？
- en: 'Both `Where` and `Select` are extension methods provided by LINQ, but they
    serve different purposes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Where**和**Select**都是LINQ提供的扩展方法，但它们有不同的用途：'
- en: '**Where**: This method is used for filtering collections based on a given predicate.
    It returns a new collection that includes only those elements that satisfy a specified
    condition.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Where**：此方法用于根据给定的谓词过滤集合。它返回一个新的集合，仅包含满足指定条件的元素。'
- en: '**Select**: This method is used for projecting or transforming the elements
    of a collection. It returns a new collection with elements that have been transformed
    based on a specified function or projection.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Select**：此方法用于投影或转换集合的元素。它返回一个新的集合，其中包含根据指定的函数或投影已转换的元素。'
- en: 'In practice, do the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，请执行以下操作：
- en: Use **Where** when you want to filter a collection and retain only those elements
    that meet certain criteria
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想过滤集合并仅保留满足某些标准的元素时，请使用**Where**。
- en: Use **Select** when you want to transform the elements of a collection, such
    as extracting a specific property or converting the data in some way
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Select**当你想要转换集合中的元素时，例如提取特定的属性或以某种方式转换数据
- en: What are the differences between the “All” and “Any” LINQ methods, and how do
    they behave when applied to an empty collection?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “All”和“Any”LINQ方法之间的区别是什么，它们在应用于空集合时如何表现？
- en: 'Both `All` and `Any` are LINQ methods used to evaluate collections against
    specific criteria. Here are their differences:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 两者**All**和**Any**都是用于评估集合是否满足特定标准的LINQ方法。以下是它们的区别：
- en: '**All**: Checks if every element in the collection satisfies a particular condition.
    Use **All** when you need to ensure that all elements of a collection meet a specific
    criterion.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**All**：检查集合中的每个元素是否都满足特定条件。当需要确保集合的所有元素都满足特定标准时，请使用**All**。'
- en: '**Any**: Checks if at least one element in the collection satisfies a particular
    condition. Use **Any** when you need to determine if there are any elements that
    fulfill a specific criterion.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Any**：检查集合中是否至少有一个元素满足特定条件。当需要确定是否存在满足特定标准的元素时，请使用**Any**。'
- en: 'When the collection is empty, the following happens:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当集合为空时，以下情况发生：
- en: '**All**: Always returns **true** because there are no elements that would violate
    the condition. This might seem counter-intuitive, but in the absence of any elements
    to check, it defaults to **true**.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**All**：始终返回**true**，因为没有元素会违反条件。这可能会显得反直觉，但在没有元素进行检查的情况下，它默认为**true**。'
- en: '**Any**: Always returns **false** since there are no elements present to satisfy
    the condition.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Any**：始终返回**false**，因为没有元素可以满足条件。'
- en: For instance, if you want to verify that all numbers in a list are positive,
    you’d use `All`. If you’re going to check if there’s a negative number in the
    list, you’d use `Any`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想验证列表中的所有数字都是正数，你会使用`All`。如果你要检查列表中是否有负数，你会使用`Any`。
- en: What distinguishes “FirstOrDefault” from “SingleOrDefault”, and when do these
    methods return “null”?
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “FirstOrDefault”与“SingleOrDefault”有什么区别，以及这些方法在什么情况下返回“null”？
- en: 'Both `FirstOrDefault` and `SingleOrDefault` are used to retrieve an element
    from a collection, but they serve slightly different purposes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`FirstOrDefault`和`SingleOrDefault`都用于从集合中检索元素，但它们服务于稍微不同的目的：'
- en: '**FirstOrDefault**: Returns the first element that matches a condition or the
    first element if no condition is specified. If no matching element is found, it
    returns the default value (typically **null** for reference types).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FirstOrDefault**：返回满足条件的第一个元素或如果没有指定条件则返回第一个元素。如果没有找到匹配元素，则返回默认值（通常为引用类型的**null**）。'
- en: '**SingleOrDefault**: Returns the only element that matches a condition but
    throws an exception if there’s more than one matching element. If no elements
    match the condition, it returns the default value.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SingleOrDefault**：返回满足条件的唯一元素，但如果存在多个匹配元素则抛出异常。如果没有元素匹配条件，则返回默认值。'
- en: 'In terms of returning `null`, the following applies:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 关于返回`null`，以下规则适用：
- en: For reference types, both methods return **null** when no matching elements
    are found in the collection
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于引用类型，当在集合中找不到匹配元素时，两种方法都返回**null**。
- en: However, for value types (such as **int** and **double**), they would return
    the default value of the type (such as **0** for **int**)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，对于值类型（如**int**和**double**），它们将返回类型的默认值（例如**int**的默认值为**0**）。
- en: What are the primary collection types in .NET you consider, and what are their
    key differences?
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你认为 .NET 中的主要集合类型有哪些，它们的关键区别是什么？
- en: '.NET provides several primary collection types:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 提供了几个主要的集合类型：
- en: '**List<T>**: A dynamic array of elements. It maintains order and allows duplicate
    elements.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**List<T>**：元素的动态数组。它保持顺序并允许重复元素。'
- en: '**Dictionary<TKey, TValue>**: A collection of key-value pairs. It does not
    have a defined order, and keys must be unique.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dictionary<TKey, TValue>**：键值对的集合。它没有定义的顺序，且键必须是唯一的。'
- en: '**HashSet<T>**: A set of unique elements. It does not maintain any specific
    order.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HashSet<T>**：唯一元素的集合。它不维护任何特定顺序。'
- en: '**Queue<T>**: A collection supporting **First-In-First-Out** (**FIFO**) operations.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Queue<T>**：支持**先进先出**（**FIFO**）操作的集合。'
- en: '**Stack<T>**: A collection supporting **Last-In-First-Out** (**LIFO**) operations.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Stack<T>**：支持**后进先出**（**LIFO**）操作的集合。'
- en: What are the differences between “List<T>” and “Dictionary<TKey”, “TValue>”?
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “List<T>”与“Dictionary<TKey, TValue>”之间有什么区别？
- en: The primary distinction between `List<T>` and `Dictionary<TKey, TValue>` lies
    in how you access elements. In `List<T>`, elements are accessed by their index,
    whereas in `Dictionary<TKey, TValue>`, elements are accessed by their key.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>`与`Dictionary<TKey, TValue>`之间的主要区别在于访问元素的方式。在`List<T>`中，通过索引访问元素，而在`Dictionary<TKey,
    TValue>`中，通过键访问元素。'
- en: How can you optimize the execution of LINQ queries when dealing with large datasets?
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何优化处理大数据集时 LINQ 查询的执行？
- en: 'Optimizing LINQ queries, especially with substantial datasets, can be achieved
    through several approaches:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几种方法可以优化 LINQ 查询，特别是对于大量数据集：
- en: Utilize *deferred execution* whenever possible, ensuring that queries are only
    executed when the result is genuinely required. This avoids unnecessary computations.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能地使用**延迟执行**，确保查询仅在真正需要结果时才执行。这样可以避免不必要的计算。
- en: Choose the most efficient collection type tailored for your specific use case,
    as the underlying data structure can impact performance.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据你的特定用例选择最有效的集合类型，因为底层的数据结构可能会影响性能。
- en: Limit the size of the resulting dataset when feasible using methods such as
    **Take** to avoid processing more data than necessary.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当可能时，使用如**Take**等方法限制结果数据集的大小，以避免处理比必要更多的数据。
- en: Avoid or judiciously use nested queries. They can lead to performance issues
    due to multiple rounds of data retrieval or computations.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免或谨慎使用嵌套查询。它们可能导致性能问题，因为需要进行多轮数据检索或计算。
- en: Use methods such as **ToArray** or **ToList** to materialize results into memory
    if you anticipate multiple operations on the data. This can prevent repeated execution
    of the same LINQ query.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果预期对数据进行多次操作，请使用**ToArray**或**ToList**等方法将结果实体化到内存中。这可以防止重复执行相同的LINQ查询。
- en: What are the key differences between the “IEnumerable” and “IQueryable” interfaces?
    Explain their implementation and usage scenarios.
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “IEnumerable”和“IQueryable”接口之间的关键区别是什么？解释它们的实现和使用场景。
- en: '`IEnumerable` and `IQueryable` are two primary interfaces representing collections
    in .NET. This is what they do:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable`和`IQueryable`是表示.NET中集合的两个主要接口。这是它们的作用：'
- en: '**IEnumerable**: Operates at the object level in memory. When you execute LINQ
    queries against an **IEnumerable** interface, operations are performed in memory.
    It’s suitable for working with in-memory collections such as arrays or lists.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IEnumerable**：在内存对象级别操作。当你对**IEnumerable**接口执行LINQ查询时，操作是在内存中执行的。它适用于处理内存中的集合，如数组或列表。'
- en: '**IQueryable**: Designed for interacting with external data sources (for example,
    databases). Queries made with **IQueryable** get translated into queries specific
    to the data source (such as SQL for relational databases). This interface allows
    for deferred execution and **out-of-memory** (**OOM**) data querying, making it
    efficient for large datasets, especially in databases.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IQueryable**：设计用于与外部数据源（例如，数据库）交互。使用**IQueryable**制作的查询被转换为针对数据源（如关系数据库的SQL）特定的查询。此接口允许延迟执行和**内存外**（**OOM**）数据查询，这使得它对于大型数据集，尤其是在数据库中，效率更高。'
- en: 'The main distinction between these two interfaces lies in the execution location:
    `IEnumerable` processes data in memory. Meanwhile, `IQueryable` allows the construction
    of an expression tree that can be translated into a query suitable for an external
    data source, such as SQL for databases. Then, it sends the parsed query for processing
    to the data source and fetches the results as `IEnumerable`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个接口之间的主要区别在于执行位置：`IEnumerable`在内存中处理数据。而`IQueryable`允许构建一个可以转换为适合外部数据源（如数据库的SQL）的查询的表达树。然后，它将解析的查询发送到数据源进行处理，并将结果作为`IEnumerable`检索。
- en: What’s the key difference between an array and “List<T>” in C#? When is it optimal
    to use each of these structures?
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中数组和“List<T>”之间的关键区别是什么？在什么情况下使用这些结构是最优的？
- en: The primary distinction lies in flexibility and size. Arrays have a fixed size
    once defined, while `List<T>` can dynamically resize as elements are added or
    removed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于灵活性和大小。数组一旦定义就具有固定的大小，而`List<T>`可以随着元素的添加或删除动态调整大小。
- en: Arrays are typically faster for indexed access compared to other data structures,
    and they can be more memory-efficient since there’s no overhead associated with
    storing additional metadata or maintaining unused capacity, which is often the
    case with lists. Arrays are particularly suitable when the number of items is
    known upfront and remains constant, as they cannot dynamically resize as lists
    can.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他数据结构相比，数组通常在索引访问方面更快，并且由于没有与存储额外元数据或维护未使用容量相关的开销，因此它们可以更节省内存。当项目数量已知且保持不变时，数组尤其适合，因为它们不能像列表那样动态调整大小。
- en: On the other hand, `List<T>` provides a host of useful methods for manipulation
    and can grow or shrink as needed. It’s an optimal choice when the collection size
    is uncertain or if you need the added functionality and methods that `List<T>`
    provides over arrays.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`List<T>`提供了一系列有用的方法用于操作，可以根据需要增长或缩小。当集合大小不确定或需要`List<T>`相对于数组提供的额外功能和方法时，它是一个最佳选择。
- en: In essence, while arrays are more lightweight and efficient for static collections,
    `List<T>` offers more versatility for dynamic collections.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，虽然数组对于静态集合来说更轻量级和高效，但`List<T>`为动态集合提供了更多的灵活性。
- en: In which scenarios should one prefer “HashSet<T>” over “List<T>”?
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在哪些场景下应该优先选择“HashSet<T）”而不是“List<T)”？
- en: '`HashSet<T>` maintains a collection of unique elements and is optimized for
    operations that require fast lookups, insertions, and deletions, as well as ensuring
    uniqueness. Use `HashSet<T>` when you need to prevent duplicates or when frequent
    lookup operations are carried out.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSet<T>`维护一组唯一的元素，并针对需要快速查找、插入和删除操作以及确保唯一性的操作进行了优化。当需要防止重复或频繁执行查找操作时，使用`HashSet<T>`。'
- en: On the other hand, `List<T>` is an ordered collection that can contain duplicates
    and is useful when the order of elements matters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`List<T>`是一个有序集合，可以包含重复元素，当元素顺序很重要时很有用。
- en: The choice between the two largely depends on the specific use case and the
    operations you intend to perform more frequently.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种选择之间的区别在很大程度上取决于具体的用例和您打算更频繁执行的操作。
- en: What is the key distinction between “LinkedList<T>” and “List<T>” in C#? In
    which scenarios is it optimal to use “LinkedList<T>”?
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在C#中，“LinkedList<T>”和“List<T>”之间的关键区别是什么？在哪些场景下使用“LinkedList<T>”是最优的？
- en: '`LinkedList<T>` is a doubly linked list, where each node has references to
    the previous and next nodes. In contrast, `List<T>` is a dynamic array. The fundamental
    difference lies in how the data is stored and how it can be modified. `LinkedList<T>`
    is optimal for insertion and deletion operations in the middle of the list, given
    its node-based structure, which allows for efficient node addition or removal
    without shifting other elements. Conversely, `List<T>` is efficient for indexed
    access due to its array-backed nature.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList<T>`是一个双链表，其中每个节点都有对前一个和下一个节点的引用。相比之下，`List<T>`是一个动态数组。基本区别在于数据存储方式和修改方式。`LinkedList<T>`由于其基于节点的结构，在列表中间进行插入和删除操作时是最优的，这允许高效地添加或删除节点而不需要移动其他元素。相反，`List<T>`由于其数组支持的性质，在索引访问方面效率较高。'
- en: When frequent insertions or deletions are expected, especially in the middle
    of a collection, `LinkedList<T>` can be more efficient. However, if the primary
    operations involve indexed access or if the collection size remains relatively
    static, `List<T>` might be a better choice.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当预期频繁插入或删除，尤其是在集合中间时，`LinkedList<T>`可能更高效。然而，如果主要操作涉及索引访问或集合大小相对静态，`List<T>`可能是一个更好的选择。
- en: What does “Dictionary<TKey, TValue>” represent in C#, and what are typical scenarios
    for its use?
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “Dictionary<TKey, TValue>”在C#中代表什么？它的典型用例有哪些？
- en: '`Dictionary<TKey, TValue>` in C# is a collection of key-value pairs where the
    keys are unique. This data structure allows fast lookups, insertions, and deletions
    based on keys. Typical scenarios for its use include storing configuration settings,
    caching data, and scenarios where you need to quickly retrieve a value associated
    with a unique key, such as a lookup table or a dictionary.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的`Dictionary<TKey, TValue>`是一个键值对集合，其中键是唯一的。这种数据结构允许基于键进行快速查找、插入和删除。其典型用例包括存储配置设置、缓存数据和需要快速检索与唯一键关联的值的场景，例如查找表或字典。
- en: What are immutable collections in C#? What are their advantages and disadvantages?
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中的不可变集合是什么？它们有什么优点和缺点？
- en: Immutable collections in C# are collections that cannot be modified after they
    are created. Instead of modifying them directly, any operation that would change
    the collection returns a new instance of the collection with the desired changes.
    Advantages of using immutable collections include thread safety (since there’s
    no risk of another thread modifying the collection unexpectedly) and the assurance
    that the data remains unchanged throughout its life cycle. On the downside, they
    can be less performant than mutable counterparts, especially when frequent modifications
    are needed, as each modification results in a new collection being created. This
    can also lead to increased memory usage.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的不可变集合是在创建后不能被修改的集合。而不是直接修改它们，任何会改变集合的操作都会返回一个新的集合实例，其中包含所需的变化。使用不可变集合的优点包括线程安全（因为没有风险其他线程意外修改集合）以及确保数据在其生命周期内保持不变。然而，它们可能比可变集合性能差，尤其是在需要频繁修改时，因为每次修改都会创建一个新的集合。这也可能导致内存使用增加。
- en: As we conclude our discussion on collections and LINQ in C#, you are now better
    prepared to handle data with increased efficiency and flexibility in your C# endeavors.
    The knowledge acquired here lays a solid foundation for tackling complex data-related
    tasks in your upcoming projects.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们结束对C#中集合和LINQ的讨论，你现在将更好地准备在C#项目中以更高的效率和灵活性处理数据。在这里获得的知识为你在即将到来的项目中处理复杂的数据相关任务奠定了坚实的基础。
- en: Next, we venture into the vital realms of exception handling and debugging in
    C#. These skills are pivotal in enhancing the robustness of your applications,
    aiding in swift error identification and resolution. Stay tuned for insights and
    strategies to navigate through errors and exceptions adeptly in the next segment.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨C#中异常处理和调试的重要领域。这些技能对于增强应用程序的健壮性、帮助快速识别和解决问题至关重要。请关注下一部分，我们将提供关于如何熟练地处理错误和异常的见解和策略。
- en: Exception handling and debugging
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理和调试
- en: Every software, regardless of its complexity, is susceptible to unexpected behaviors
    and errors. Navigating through these unforeseen challenges requires a robust set
    of tools and techniques, and this is where exception handling and debugging come
    into play. This section delves deep into the intricacies of identifying, understanding,
    and resolving anomalies in your C# code. From gracefully managing unexpected scenarios
    using exception handling to probing your code with the precision of a surgeon
    through debugging, we’ll equip you with the skills to ensure your applications
    run smoothly and efficiently. Embrace the journey of turning pitfalls into learning
    opportunities and ensuring the resilience and reliability of your software solutions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 任何软件，无论其复杂程度如何，都容易受到意外行为和错误的影响。应对这些未预见的挑战需要一套强大的工具和技术，这就是异常处理和调试发挥作用的地方。本节深入探讨了在C#代码中识别、理解和解决异常的复杂性。从优雅地使用异常处理来管理意外场景，到像外科医生一样精确地检查你的代码，我们将为你提供确保应用程序平稳高效运行的技能。拥抱将陷阱转化为学习机会，并确保你的软件解决方案具有弹性和可靠性的旅程。
- en: What’s the difference between using “throw” and “throw ex” inside a “catch”
    block?
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在“catch”块中使用“throw”和“throw ex”之间有什么区别？
- en: When you use `throw` without any argument, you’re essentially rethrowing the
    current exception, preserving the original stack trace. This allows for easier
    debugging as you maintain the information about where the exception was originally
    thrown. On the other hand, when you use `throw ex`, you reset the stack trace
    to the current `catch` block, potentially losing valuable information about where
    and how the exception originated. Therefore, in general, it’s recommended to use
    `throw` by itself within a `catch` block if you intend to rethrow the caught exception.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`throw`而不带任何参数时，你实际上是在重新抛出当前异常，保留原始堆栈跟踪。这有助于更容易地进行调试，因为你保留了有关异常最初抛出位置的信息。另一方面，当你使用`throw
    ex`时，你会将堆栈跟踪重置为当前的`catch`块，可能会丢失有关异常起源位置和方式的重要信息。因此，通常建议在`catch`块中使用`throw`本身来重新抛出捕获的异常。
- en: What are the primary types of exceptions in C# and under what conditions do
    they typically arise?
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中的主要异常类型有哪些，以及它们通常在什么条件下出现？
- en: 'C# features a wide variety of exception types to cater to different exceptional
    scenarios. Here are a few key ones:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: C#提供各种异常类型，以适应不同的异常场景。以下是一些关键类型：
- en: '**ArgumentNullException**: This is thrown when an argument passed to a method
    is **null** when a non-null value is expected'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ArgumentNullException**: 当一个方法期望非空值但传入的参数为**null**时，会抛出此异常'
- en: '**ArgumentOutOfRangeException**: This occurs when an argument’s value is outside
    the permissible range'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ArgumentOutOfRangeException**: 当一个参数的值超出允许的范围时，会发生此情况'
- en: '**DivideByZeroException**: This is thrown when there’s an attempt to divide
    by zero'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DivideByZeroException**: 当尝试除以零时，会抛出此异常'
- en: '**InvalidOperationException**: This arises when the state of an object doesn’t
    permit a particular operation'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**InvalidOperationException**: 当一个对象的状态不允许执行特定操作时，会出现此情况'
- en: '**FileNotFoundException**: This occurs when a file that’s being attempted to
    be accessed doesn’t exist'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FileNotFoundException**: 当尝试访问的文件不存在时，会发生此异常'
- en: '**StackOverflowException**: This is thrown when there’s a stack overflow due
    to excessive recursion or other reasons'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**StackOverflowException**: 当由于过度递归或其他原因导致堆栈溢出时，会抛出此异常'
- en: '**NullReferenceException**: This occurs when you try to access a member on
    an object reference that is **null**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NullReferenceException**: 当你尝试访问一个对象引用的成员，而这个对象引用是**null**时，会发生此异常'
- en: What does the “finally” block do in a “try-catch” structure, and are there scenarios
    where it might not execute?
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在“try-catch”结构中，“finally”块的作用是什么，以及是否存在可能不会执行的场景？
- en: The `finally` block ensures that the code inside it gets executed regardless
    of whether an exception was thrown in the preceding `try` or `catch` blocks. This
    is particularly useful for cleanup operations, such as closing files or database
    connections.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`块确保无论在先前的`try`或`catch`块中是否抛出了异常，其中的代码都会被执行。这对于清理操作特别有用，例如关闭文件或数据库连接。'
- en: In most cases, the `finally` block will execute. However, there are rare circumstances,
    such as program termination or catastrophic exceptions (for example, `StackOverflowException`
    or a process termination), where the `finally` block might not get executed because
    these critical errors can disrupt the normal flow of program execution, and the
    app will stop, leaving no opportunity for the `finally` block to run.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`finally`块将执行。然而，在罕见的情况下，例如程序终止或灾难性异常（例如`StackOverflowException`或进程终止），`finally`块可能不会执行，因为这些关键错误可能会破坏程序执行的正常流程，应用程序将停止，没有机会运行`finally`块。
- en: What is an “inner exception”, and how can it be used to improve debugging?
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “内部异常”是什么，以及如何利用它来改进调试？
- en: An **inner exception** refers to a previous exception that led to the current
    exception being thrown. It’s especially useful when the current exception arises
    as a result of another exception. By examining the inner exception, developers
    can trace back to the root cause of a problem, providing a clearer picture of
    the sequence of events leading up to the final exception. This can be invaluable
    during debugging, as it helps pinpoint the primary source of the issue and, potentially,
    cascading failures that led to the current state. When throwing a custom exception,
    you can include the original exception as the inner exception, preserving this
    chain of causality.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部异常**指的是导致当前异常抛出的先前异常。当当前异常是另一个异常的结果时，它特别有用。通过检查内部异常，开发者可以追溯到问题的根本原因，为导致最终异常的事件序列提供一个更清晰的画面。这在调试过程中非常有价值，因为它有助于确定问题的主要来源，以及可能导致当前状态的级联失败。当抛出自定义异常时，你可以将原始异常作为内部异常包含在内，从而保留这种因果关系链。'
- en: What is a “stack trace”, and how can it be beneficial in tracing exceptions?
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “堆栈跟踪”是什么，它如何有助于跟踪异常？
- en: A **stack trace** provides a snapshot of the method call sequence leading up
    to the point where an exception was thrown. It essentially shows the hierarchy
    of method calls that the application went through before encountering the exception.
    This can be instrumental for developers as it offers insights into the execution
    flow and context in which the exception occurred. By analyzing the stack trace,
    developers can often pinpoint the exact location and reason for the exception,
    making debugging and resolving the issue more efficient.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆栈跟踪**提供了从抛出异常的点开始的方法调用序列的快照。它本质上显示了应用程序在遇到异常之前经历的方法调用层次结构。这对于开发者来说非常有用，因为它提供了关于异常发生时的执行流程和上下文的见解。通过分析堆栈跟踪，开发者通常可以确定异常的确切位置和原因，使调试和解决问题更加高效。'
- en: What is the essence of a “conditional breakpoint” in Visual Studio, and when
    is it beneficial to use?
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Visual Studio中，“条件断点”的本质是什么，以及在什么情况下使用它是有益的？
- en: A `true`. This is particularly useful in scenarios where an issue arises only
    in certain circumstances or with specific data. By using a conditional breakpoint,
    developers can efficiently debug complex problems without having to manually pause
    and inspect the program state multiple times.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`true`。这在问题仅在特定情况下或与特定数据出现时特别有用。通过使用条件断点，开发者可以有效地调试复杂问题，而无需手动多次暂停和检查程序状态。
- en: How can we handle or avoid an “unhandled exception”?
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们如何处理或避免“未处理的异常”？
- en: 'An `catch` block. To prevent this, do the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`catch`块。为了防止这种情况，请执行以下操作：
- en: Surround potential exception-throwing code with appropriate **try**-**catch**
    blocks, ensuring that you are catching specific exception types or a general exception
    if necessary.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可能抛出异常的代码用适当的**try**-**catch**块包围，确保你正在捕获特定的异常类型，或者在必要时捕获一般异常。
- en: Utilize global exception handlers, such as **AppDomain.UnhandledException**
    for .NET Framework applications or **TaskScheduler.UnobservedTaskException** to
    handle exceptions from unobserved tasks. This provides a safety net, ensuring
    that any uncaught exceptions are still addressed in some manner.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用全局异常处理程序，例如.NET Framework应用程序中的**AppDomain.UnhandledException**或**TaskScheduler.UnobservedTaskException**来处理未观察到的任务的异常。这提供了一个安全网，确保任何未捕获的异常都以某种方式得到解决。
- en: Always validate and sanitize inputs, and be aware of potential exception sources
    such as I/O operations, database access, and third-party library calls.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是验证和清理输入，并注意潜在的异常来源，如I/O操作、数据库访问和第三方库调用。
- en: What is the difference between “Debug” and “Release” configurations?
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “Debug”和“Release”配置之间有什么区别？
- en: In Visual Studio, the two primary build configurations are `Debug` and `Release`.
    The `Debug` configuration is tailored for code debugging. It usually includes
    additional debugging information, doesn’t apply certain compiler optimizations,
    and might have different code paths (such as more verbose logging) enabled by
    using preprocessor directives. This ensures that the debugging experience is seamless,
    allowing developers to step through code, inspect variables, and use breakpoints
    effectively.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中，两个主要的构建配置是`Debug`和`Release`。`Debug`配置针对代码调试而定制。它通常包括额外的调试信息，不应用某些编译器优化，并且可能通过使用预处理器指令启用不同的代码路径（例如更详细的日志记录）。这确保了调试体验的流畅性，允许开发者逐步执行代码、检查变量并有效地使用断点。
- en: On the other hand, the `Release` configuration is optimized for the final deployment
    of the application. The code is compiled with full optimization, removing any
    debugging information, which leads to better performance and often a smaller binary
    size. Additionally, certain debug-specific code paths might be excluded, ensuring
    that the final product is lean and efficient.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Release`配置针对应用程序的最终部署进行了优化。代码以完全优化编译，移除了任何调试信息，这导致了更好的性能和通常更小的二进制文件大小。此外，某些特定的调试代码路径可能被排除，确保最终产品精简高效。
- en: Understanding and choosing the right configuration is essential as it can significantly
    impact both the performance and behavior of the application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 理解和选择正确的配置至关重要，因为它可以显著影响应用程序的性能和行为。
- en: How can one deliberately trigger an exception?
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何故意触发一个异常？
- en: You can use the `throw` keyword to programmatically generate an exception. For
    instance, executing `throw new Exception("Test exception");` will raise an exception
    with a `"Test exception"` message. Deliberately triggering exceptions can be useful
    in situations where you want to enforce certain conditions or validate assumptions
    in your code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`throw`关键字以编程方式生成异常。例如，执行`throw new Exception("Test exception");`将引发一个带有`"Test
    exception"`消息的异常。故意触发异常在需要强制执行某些条件或验证代码中的假设的情况下可能很有用。
- en: What’s the distinction between using “Assert” and “Throw” in unit test development
    and debugging?
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在单元测试开发和调试中，使用“Assert”和“Throw”有什么区别？
- en: '`Assert` is primarily used to validate conditions that are expected to be true
    at specific points in the code. If the condition is not met, an assertion failure
    typically halts the execution, alerting the developer of the discrepancy, especially
    during debugging sessions. It’s a tool to ensure code correctness and assumptions
    during development.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assert`主要用于验证在代码的特定点预期为真的条件。如果条件未满足，断言失败通常会停止执行，提醒开发者存在差异，尤其是在调试会话期间。它是确保开发过程中代码正确性和假设的工具。'
- en: On the other hand, `Throw` is employed to raise exceptions, indicating error
    conditions or unexpected scenarios. These exceptions can be caught and handled
    further up the call stack.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Throw`用于引发异常，指示错误条件或意外场景。这些异常可以被捕获并在调用堆栈的更高层进一步处理。
- en: 'While both can be used to identify and address issues, their primary purposes
    and usage contexts differ: `Assert` is more about validating code logic during
    development, whereas `Throw` is about handling exceptional runtime scenarios.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两者都可以用于识别和解决问题，但它们的主要目的和使用场景不同：`Assert`更多地与开发期间验证代码逻辑有关，而`Throw`则与处理异常运行时场景有关。
- en: How should one handle exceptions in “Task”? What’s the difference between “async
    void” and “async Task” in the context of error handling?
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应该如何处理“Task”中的异常？在错误处理的上下文中，“async void”和“async Task”有什么区别？
- en: When dealing with exceptions in `Task`, there are several approaches. One can
    use the `ContinueWith` method on a task to handle exceptions, or use the `await`
    keyword and wrap the awaited task inside a `try`-`catch` block to catch any exceptions
    it might throw.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理`Task`中的异常时，有几种方法。可以在任务上使用`ContinueWith`方法来处理异常，或者使用`await`关键字，并在`try`-`catch`块中包装等待的任务来捕获可能抛出的任何异常。
- en: The distinction between `async void` and `async Task` methods is crucial when
    it comes to exception handling. `async void` methods don’t return a task, so exceptions
    thrown from such methods get thrown directly into the thread pool. This can lead
    to unobserved exceptions which, at best, could crash the application if not caught,
    and at worst, might silently fail without any indication to the developer. `async
    Task`, on the other hand, returns a task that encapsulates the operation, and
    exceptions can be observed and handled by awaiting the task or inspecting its
    result.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在异常处理方面，`async void`和`async Task`方法之间的区别至关重要。`async void`方法不返回任务，因此从这些方法抛出的异常会直接进入线程池。这可能导致未观察到的异常，最坏的情况下，如果没有捕获，可能会无声地失败，而开发者没有任何提示。另一方面，`async
    Task`返回一个封装操作的任务，异常可以通过等待任务或检查其结果来观察和处理。
- en: As we conclude our deep dive into exception handling and debugging in C#, a
    segment where we mastered the craft of diagnosing and rectifying code discrepancies,
    we are poised to step into the dynamic domain of asynchronous programming with
    `async` and `await`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们深入探讨C#中的异常处理和调试，一个我们掌握了诊断和纠正代码差异技巧的领域，我们即将步入异步编程的动态领域，使用`async`和`await`。
- en: The upcoming section promises to bolster your C# programming capabilities, unlocking
    the potential for simultaneous operations and paving the way for more responsive
    and efficient code execution. Let’s seamlessly transition from becoming adept
    at troubleshooting errors to harnessing the power of concurrency and parallelism
    inherent in modern C#. Gear up for an enthralling learning curve ahead!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将增强您的C#编程能力，解锁同时操作的可能性，为更响应和高效的代码执行铺平道路。让我们无缝地从精通错误调试过渡到利用现代C#中固有的并发和并行性。准备好迎接一个令人着迷的学习曲线吧！
- en: Asynchronous programming with async and await
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`async`和`await`进行异步编程
- en: In today’s fast-paced digital world, responsiveness is paramount. Users demand
    applications that are quick, smooth, and most importantly, non-blocking. Enter
    the realm of `async` and `await` keywords. This section illuminates the transformative
    power of asynchronous operations in enhancing application performance and responsiveness.
    We’ll journey through the mechanics of executing tasks concurrently without stalling
    the main thread, ensuring a seamless user experience. By mastering `async` and
    `await`, you’ll unlock the potential to perform complex operations behind the
    scenes, letting your applications remain swift and user-centric. Dive in to harness
    the future of efficient coding and elevate your applications to new heights of
    efficiency and interactivity.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今快节奏的数字世界中，响应性至关重要。用户需要快速、流畅的应用程序，最重要的是，非阻塞。进入`async`和`await`关键字的领域。本节揭示了异步操作在提高应用程序性能和响应性方面的变革力量。我们将探索在不阻塞主线程的情况下并发执行任务的技术，确保无缝的用户体验。通过掌握`async`和`await`，您将解锁在幕后执行复杂操作的可能性，让您的应用程序保持快速和以用户为中心。加入我们，利用高效编码的未来，将您的应用程序提升到新的效率和交互高度。
- en: What is the purpose of the “async” and “await” keywords in C#?
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “async”和“await”关键字在C#中的目的是什么？
- en: The `async` and `await` keywords in C# are used to denote and execute asynchronous
    operations, allowing for non-blocking code execution. The `async` keyword indicates
    that a method may contain asynchronous code, while `await` is used to asynchronously
    wait for a task to complete without freezing the main thread. This enables writing
    more responsive applications, especially when dealing with I/O-bound operations
    or long-running computations.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的`async`和`await`关键字用于表示和执行异步操作，允许非阻塞代码执行。`async`关键字表示一个方法可能包含异步代码，而`await`用于异步等待任务完成，而不会冻结主线程。这使您可以编写更响应的应用程序，尤其是在处理I/O密集型操作或长时间运行的计算时。
- en: What’s the main difference between multithreading and asynchronous programming?
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线程和异步编程之间的主要区别是什么？
- en: '`event` loop to handle non-blocking operations efficiently.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`event`循环来高效地处理非阻塞操作。
- en: What does an “async” method return?
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “async”方法返回什么？
- en: An `async` method can return `void`, `Task`, `Task<T>`, or `ValueTask<T>`. However,
    it’s generally recommended to avoid returning `void` from `async` methods, except
    in event handlers, because it makes error handling difficult; exceptions thrown
    in an `async` `void` method can’t be caught by the caller, leading to unhandled
    exceptions, which can crash the application. Returning `Task` or `Task<T>` allows
    the caller to await its completion or chain other continuations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法可以返回`void`、`Task`、`Task<T>`或`ValueTask<T>`。然而，通常建议避免从异步方法返回`void`，除非是在事件处理器中，因为这会使错误处理变得困难；在异步`void`方法中抛出的异常无法被调用者捕获，导致未处理的异常，这可能导致应用程序崩溃。返回`Task`或`Task<T>`允许调用者等待其完成或链式其他延续。
- en: What pitfalls can arise from the careless use of “async” and “await”?
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不谨慎使用“async”和“await”可能会出现哪些陷阱？
- en: 'Careless use of `async` and `await` can lead to several issues:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 不谨慎地使用`async`和`await`可能导致几个问题：
- en: '**Deadlocks**: Especially when mixing synchronous and asynchronous code'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**死锁**：尤其是在混合同步和异步代码时'
- en: '**Thread starvation**: Over-relying on the thread pool can lead to situations
    where all threads are consumed, causing delays in processing'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程饥饿**：过度依赖线程池可能导致所有线程都被消耗，从而造成处理延迟'
- en: '**Performance overheads**: Unnecessary usage can introduce performance overheads'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能开销**：不必要的使用可能会引入性能开销'
- en: '**Debugging complexity**: Asynchronous code can be more challenging to debug
    due to its non-linear execution flow'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试复杂性**：由于非线性的执行流程，异步代码可能更难以调试'
- en: What is a “deadlock” in the context of asynchronous programming, and how can
    it be avoided?
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在异步编程的背景下，“死锁”是什么，以及如何避免？
- en: 'In the context of asynchronous programming, a **deadlock** occurs when asynchronous
    code inadvertently gets blocked waiting for another operation to complete, which
    in turn is waiting for the original operation. This creates a situation where
    neither operation can proceed. Deadlocks often arise when mixing synchronous and
    asynchronous code or when awaiting tasks inappropriately. To avoid deadlocks,
    follow these guidelines:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步编程的背景下，当异步代码无意中阻塞等待另一个操作完成，而该操作又正在等待原始操作时，就会发生**死锁**。这种情况导致两个操作都无法继续进行。死锁通常在混合同步和异步代码或不适当地等待任务时出现。为了避免死锁，请遵循以下指南：
- en: Avoid synchronously waiting on asynchronous methods (for example, avoid using
    **.Result** or **.Wait()**)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在异步方法上同步等待（例如，避免使用**.Result**或**.Wait()**）
- en: Use **ConfigureAwait(false)** judiciously to prevent marshaling the continuation
    back to the original context, which can be a source of deadlocks, especially in
    UI applications
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适度使用**ConfigureAwait(false)**以防止将延续操作回传到原始上下文，这可能是死锁的来源，尤其是在UI应用程序中。
- en: How does asynchrony impact the call stack?
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步如何影响调用栈？
- en: Asynchrony can fragment the call stack into several segments. When asynchronous
    methods are invoked, they return almost immediately, often before the work is
    complete. This means the traditional call stack might not represent the full sequence
    of execution, complicating debugging. Tools such as the **Tasks** window in Visual
    Studio can help developers understand the state and flow of asynchronous operations.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 异步可以将调用栈分割成几个部分。当调用异步方法时，它们几乎立即返回，通常在任务完成之前。这意味着传统的调用栈可能无法代表完整的执行序列，从而使得调试变得复杂。Visual
    Studio中的**任务**窗口等工具可以帮助开发者理解异步操作的状态和流程。
- en: What’s the difference between “Task”, “Task<T>”, and “ValueTask<T>”?
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “Task”、“Task<T>”和“ValueTask<T>”之间有什么区别？
- en: 'Let’s have a look at what the differences between these types are:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些类型之间的区别：
- en: '**Task** represents an asynchronous operation that doesn’t return a value.
    It’s essentially a promise that some work will be completed in the future.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Task**表示一个不返回值的异步操作。它本质上是一个承诺，表示将来会完成一些工作。'
- en: '**Task<T>** represents an asynchronous operation that returns a value of type
    **T** upon completion.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Task<T>**表示一个在完成时返回类型为**T**的值的异步操作。'
- en: '**ValueTask<T>** is a newer type optimized for scenarios where the result might
    be available synchronously, potentially avoiding heap allocation. It’s particularly
    useful for high-performance scenarios to reduce overhead, but it should be used
    with care as misuse can introduce subtle bugs or decrease performance.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ValueTask<T>**是一个针对可能同步提供结果的场景进行优化的新类型，可能避免堆分配。它在高性能场景中特别有用，可以减少开销，但应谨慎使用，因为误用可能会引入微妙的错误或降低性能。'
- en: How can multiple asynchronous operations be executed concurrently and awaited
    for their completion?
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何并发执行多个异步操作并等待它们的完成？
- en: You can use `Task.WhenAll()` to execute multiple asynchronous operations concurrently
    and await their completion. This method returns a single `Task` object that completes
    when all of the provided tasks have been completed. It’s a way to initiate several
    tasks at once and then continue execution when all of those tasks are done.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `Task.WhenAll()` 来并发执行多个异步操作并等待它们的完成。此方法返回一个单独的 `Task` 对象，当所有提供的任务都完成时，该对象将完成。这是一种同时启动多个任务，然后在所有这些任务完成后继续执行的方法。
- en: What issues might arise when using asynchronous methods in class constructors
    or finalizers?
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在类构造函数或终结器中使用异步方法可能会引发哪些问题？
- en: 'A few issues may arise, such as the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现一些问题，例如以下情况：
- en: Using asynchronous methods in constructors can complicate object initialization
    since constructors can’t return a **Task** object. This means you can’t call **await**
    an asynchronous method directly inside a constructor, making it challenging to
    perform asynchronous operations during object initialization.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构造函数中使用异步方法可能会使对象初始化变得复杂，因为构造函数不能返回一个 **Task** 对象。这意味着您不能在构造函数中直接调用异步方法，这使得在对象初始化期间执行异步操作变得具有挑战性。
- en: Using asynchronous methods in finalizers may lead to a problem because the object
    might get garbage collected before the asynchronous operation completes. Finalizers
    are not meant to have asynchronous code, and doing so can lead to unpredictable
    behavior.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终结器中使用异步方法可能会导致问题，因为对象可能在异步操作完成之前被垃圾回收。终结器不打算包含异步代码，这样做可能会导致不可预测的行为。
- en: How are exceptions handled in asynchronous methods?
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步方法中如何处理异常？
- en: Exceptions in asynchronous methods can be handled using standard `try`-`catch`
    blocks. However, it’s important to note that exceptions might not be thrown until
    the task becomes *faulted*. This means that the exception will be thrown at the
    point where you call `await` for the task. If an exception occurs in an awaited
    asynchronous method, it will propagate to the calling method, just as with synchronous
    code. It’s also worth noting that if multiple exceptions are thrown by concurrent
    tasks awaited with `Task.WhenAll()`, all exceptions will be bundled into an `AggregateException`
    exception.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法中的异常可以使用标准的 `try`-`catch` 块来处理。然而，需要注意的是，异常可能不会在任务变为 *faulted* 之前抛出。这意味着异常将在您调用
    `await` 为任务时抛出。如果在等待的异步方法中发生异常，它将像同步代码一样传播到调用方法。还值得注意的是，如果 `Task.WhenAll()` 等待的并发任务抛出多个异常，所有异常都将捆绑成一个
    `AggregateException` 异常。
- en: What is “synchronization context” in asynchronous programming, and what is its
    significance?
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步编程中的“同步上下文”是什么，它的重要性是什么？
- en: '**Synchronization context** represents the environment in which asynchronous
    operations run. It ensures that asynchronous code can interact correctly with
    environments that have specific requirements, such as UI threads in Windows Forms
    or WPF applications. This is crucial to ensure that operations interacting with
    the UI are executed on the appropriate thread. In essence, synchronization context
    acts as a bridge between asynchronous code and its execution context, allowing
    for thread-safe updates to UI or other thread-specific resources.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步上下文**表示异步操作运行的环境。它确保异步代码可以正确地与具有特定要求的环境交互，例如 Windows Forms 或 WPF 应用程序中的
    UI 线程。这对于确保与 UI 交互的操作在适当的线程上执行至关重要。本质上，同步上下文充当异步代码与其执行上下文之间的桥梁，允许对 UI 或其他线程特定资源进行线程安全的更新。'
- en: How does “ConfigureAwait” work, and why is there a recommendation to use “ConfigureAwait(false)”?
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “ConfigureAwait”是如何工作的，为什么建议使用“ConfigureAwait(false)”？
- en: '`ConfigureAwait` allows developers to specify whether or not to return the
    execution to the original *synchronization context* after an asynchronous operation
    completes. Using `ConfigureAwait(false)` indicates that the continuation code
    shouldn’t run in the original context, potentially preventing deadlocks and improving
    performance, especially in library code. This ensures that the asynchronous method
    does not attempt to marshal the continuation back to the original context, which
    might be unnecessary or even detrimental.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigureAwait` 允许开发者在异步操作完成后指定是否将执行返回到原始 *同步上下文*。使用 `ConfigureAwait(false)`
    表示延续代码不应在原始上下文中运行，这可能会防止死锁并提高性能，尤其是在库代码中。这确保了异步方法不会尝试将延续操作回传到原始上下文，这可能是不必要的，甚至是有害的。'
- en: What is “task continuation”, and how is it used?
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “任务延续”是什么，它是如何使用的？
- en: '`Task` instance completes. It’s often used via methods such as `ContinueWith`
    on a `Task` instance, allowing developers to chain operations without nesting
    callbacks. Continuations can be useful to define the logic that should run after
    an asynchronous operation without blocking the thread, making it easier to sequence
    asynchronous operations or handle results.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 实例完成。它通常通过在 `Task` 实例上使用 `ContinueWith` 等方法来使用，允许开发者在无需嵌套回调的情况下链式操作。延续操作可以用来定义在异步操作之后应该运行的逻辑，而不阻塞线程，这使得序列化异步操作或处理结果变得更加容易。'
- en: How do asynchronous methods interact with threads?
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步方法如何与线程交互？
- en: Asynchronous methods don’t inherently spawn new threads. Instead, they use mechanisms
    to execute code asynchronously on the current thread, leveraging the thread pool
    for compute-bound operations when necessary. The key benefit of asynchronous methods
    is that they allow potentially blocking operations, such as I/O-bound work, to
    yield control, freeing up the current thread to perform other tasks. This leads
    to more efficient use of system resources, especially in scenarios where many
    operations might be waiting on external factors such as network responses or file
    reads.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法本身不会生成新线程。相反，它们使用机制在当前线程上异步执行代码，在必要时利用线程池进行计算密集型操作。异步方法的关键优势是它们允许可能阻塞的操作，如
    I/O 密集型工作，释放控制权，从而让当前线程执行其他任务。这导致了对系统资源的更有效利用，尤其是在许多操作可能正在等待外部因素（如网络响应或文件读取）的场景中。
- en: What is “TaskCompletionSource” in the context of asynchronous operations?
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在异步操作中，“TaskCompletionSource”是什么意思？
- en: '`TaskCompletionSource` provides a way to manually control the completion of
    a task. It’s particularly useful in scenarios where you need to integrate asynchronous
    code with other asynchronous mechanisms that don’t natively use the `Task` pattern.
    Essentially, with `TaskCompletionSource`, you have the ability to directly set
    the result, exception, or cancellation state of its associated task.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskCompletionSource` 提供了一种手动控制任务完成的方式。它在需要将异步代码与其他不原生使用 `Task` 模式的异步机制集成的场景中特别有用。本质上，使用
    `TaskCompletionSource`，您可以直接设置其关联任务的结果、异常或取消状态。'
- en: What is a “cancellation token”, and how is it used?
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “取消令牌”是什么，它是如何使用的？
- en: A **cancellation token** provides a mechanism to request the cancellation of
    an ongoing operation. It’s typically passed into an asynchronous method, which
    can periodically check the token to see if a cancellation has been requested,
    allowing the operation to gracefully terminate early. This is especially important
    for long-running operations where you want to give the user or calling code the
    ability to interrupt and stop the operation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**取消令牌** 提供了一种请求取消正在进行的操作的方式。它通常传递给异步方法，异步方法可以定期检查令牌以查看是否已请求取消，从而允许操作优雅地提前终止。这对于长时间运行的操作尤为重要，您希望用户或调用代码能够中断并停止操作。'
- en: What’s the difference between “Parallel” from TPL and “async/await”?
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TPL 中的“Parallel”和“async/await”之间的区别是什么？
- en: '`Parallel` is designed for parallel execution of code across multiple threads,
    focusing on CPU-bound operations that can be executed concurrently. It’s about
    optimizing CPU usage by distributing computations over multiple cores.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel` 是为跨多个线程并行执行代码而设计的，专注于可以并发执行的 CPU 密集型操作。它是通过在多个核心上分配计算来优化 CPU 使用率。'
- en: On the other hand, `async/await` is designed for the non-blocking execution
    of code, particularly for I/O-bound operations. It’s about improving responsiveness
    and scalability by allowing a thread to perform other tasks while waiting for
    a long-running operation to complete.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`async/await` 是为了代码的非阻塞执行而设计的，尤其是针对 I/O 密集型操作。它通过允许线程在等待长时间运行的操作完成时执行其他任务，从而提高响应性和可伸缩性。
- en: What are Parallel loops in TPL, and how to control them?
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TPL 中的并行循环是什么，如何控制它们？
- en: 'In TPL, there are two main `Parallel` loops: `Parallel.For` and `Parallel.ForEach`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TPL 中，有两个主要的 `Parallel` 循环：`Parallel.For` 和 `Parallel.ForEach`。
- en: You can control the number of threads by using `ParallelOptions` and setting
    `MaxDegreeOfParallelism`. The default value of `MaxDegreeOfParallelism` is set
    to `-1`, indicating that TPL automatically decides the number of threads to use,
    typically based on the number of processor cores. However, you can modify this
    value to limit the maximum number of threads. This can be useful in scenarios
    where tasks are resource-intensive and you don’t want to overload the system.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `ParallelOptions` 并设置 `MaxDegreeOfParallelism` 来控制线程数。`MaxDegreeOfParallelism`
    的默认值设置为 `-1`，表示 TPL 自动决定要使用的线程数，通常基于处理器核心的数量。然而，你可以修改此值以限制最大线程数。这在任务资源密集型且你不想过载系统的情况下可能很有用。
- en: 'To manage loops, you can use the `Break()` and `Stop()` methods, as outlined
    here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理循环，你可以使用 `Break()` 和 `Stop()` 方法，如下所述：
- en: '**Break()**: The **Break()** method indicates the need to cease the current
    iteration’s execution.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Break()**：`Break()` 方法表示需要停止当前迭代的执行。'
- en: 'Here’s an example:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是一个示例：
- en: '[PRE0]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, `Parallel.For` processes numbers from `0` to `9`.
    If it encounters the number `5`, it uses `Break()` to halt further processing
    in the iteration.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的示例中，`Parallel.For` 处理从 `0` 到 `9` 的数字。如果它遇到数字 `5`，它将使用 `Break()` 停止迭代中的进一步处理。
- en: '**Stop()**: The **Stop()** method halts execution as quickly as possible. This
    method is essential for controlling the loop’s state.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Stop()**：`Stop()` 方法尽可能快地停止执行。此方法对于控制循环状态至关重要。'
- en: 'Here’s an example:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是一个示例：
- en: '[PRE8]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding example, if you’re processing a large list of data and encounter
    a critical error, you can use `Stop()` to immediately cease processing.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的示例中，如果你正在处理大量数据并遇到关键错误，你可以使用 `Stop()` 立即停止处理。
- en: How to use Parallel.ForEachAsync, and what is the difference between it and
    Parallel.ForEach?
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用 Parallel.ForEachAsync，以及它与 Parallel.ForEach 之间的区别是什么？
- en: '`Parallel.ForEach` is a synchronous method used for executing iterations in
    parallel.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.ForEach` 是一个用于并行执行迭代的同步方法。'
- en: '`Parallel.ForEachAsync` supports asynchronous operations within iterations.
    This is useful when you need to perform asynchronous requests or operations with
    waiting times, such as interactions with databases or web services.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.ForEachAsync` 支持迭代中的异步操作。这在需要执行异步请求或具有等待时间的操作（如与数据库或 Web 服务的交互）时很有用。'
- en: 'Here’s an example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例：
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, `Parallel.ForEachAsync` allows each item in the data
    collection to be processed asynchronously, which is beneficial for tasks that
    involve latency, such as database queries or calls to web services.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`Parallel.ForEachAsync` 允许数据集中的每个项目异步处理，这对于涉及延迟的任务（如数据库查询或对 Web 服务的调用）是有益的。
- en: When is it appropriate to call an asynchronous function without using await,
    and how does this affect execution?
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在什么情况下，不使用 await 调用异步函数是合适的，这如何影响执行？
- en: You can invoke an asynchronous function without `await` if you do not need to
    wait for its completion before moving to the next line of code. However, this
    can lead to issues such as untracked errors and difficulties in managing thread
    execution. The method’s execution continues irrespective of the state of the asynchronous
    operation, potentially leading to unpredictable behavior, especially if it affects
    shared resources or the application’s state.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要在移动到下一行代码之前等待异步函数的完成，你可以不使用 `await` 来调用异步函数。然而，这可能会导致未跟踪的错误和管理线程执行困难的问题。方法执行将继续，不受异步操作状态的影响，这可能导致不可预测的行为，尤其是如果它影响了共享资源或应用程序的状态。
- en: Also, an asynchronous function can be called without `await` when you need to
    initiate several asynchronous tasks simultaneously. However, without `await`,
    you cannot catch exceptions that might occur during task execution, and the result
    of the operation will be ignored.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当需要同时启动多个异步任务时，异步函数可以在不使用 `await` 的情况下被调用。然而，没有 `await`，你无法捕获任务执行过程中可能发生的异常，并且操作的结果将被忽略。
- en: 'Here are some examples:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些示例：
- en: 'Here, it’s ignoring the result:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里，它是在忽略结果：
- en: '[PRE16]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, it’s running tasks in parallel:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里，它是在并行运行任务：
- en: '[PRE17]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the second example, `ProcessDataAsync` initiates several asynchronous tasks
    in parallel and waits for their completion using `Task.WhenAll`. This approach
    is useful for efficiently processing multiple tasks concurrently.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，`ProcessDataAsync` 并行启动了几个异步任务，并使用 `Task.WhenAll` 等待它们的完成。这种方法对于高效地并发处理多个任务非常有用。
- en: What are “asynchronous streams” in C# 8.0, and how can “IAsyncEnumerable” transform
    real-time data processing?
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 C# 8.0 中，“异步流”是什么，以及“`IAsyncEnumerable`”如何转换实时数据处理？
- en: Introduced in C# 8.0, `await foreach`. `IAsyncEnumerable` is an interface that
    facilitates creating data streams that can be read asynchronously. This is particularly
    beneficial when dealing with large data streams or data sources that produce data
    asynchronously. It provides a way to process data as it becomes available, rather
    than waiting for the entire dataset, making it especially valuable for real-time
    applications.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 8.0 中引入的 `await foreach`。`IAsyncEnumerable` 是一个接口，它便于创建可以异步读取的数据流。当处理大型数据流或异步产生数据的源时，这特别有益。它提供了一种按数据可用性处理数据的方法，而不是等待整个数据集，这使得它在实时应用中特别有价值。
- en: How can you use “SemaphoreSlim” for asynchronous synchronization of resource
    access?
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何使用“`SemaphoreSlim`”进行异步资源访问同步？
- en: '`SemaphoreSlim` offers a `WaitAsync` method, which allows for asynchronously
    obtaining a semaphore. This is advantageous when you need to limit concurrent
    access to a shared resource in asynchronous code without blocking the executing
    thread. By using `SemaphoreSlim`, you can ensure that a limited number of tasks
    can access a particular resource or section of code at the same time, providing
    a mechanism for throttling or controlling access.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`SemaphoreSlim` 提供了一个 `WaitAsync` 方法，允许异步获取信号量。这在需要在不阻塞执行线程的情况下，异步限制对共享资源的并发访问时非常有用。通过使用
    `SemaphoreSlim`，你可以确保有限数量的任务可以同时访问特定的资源或代码段，从而提供了一种节流或控制访问的机制。'
- en: What is “asynchronous disposal” in C# 8.0 with the use of “IAsyncDisposable”?
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 C# 8.0 中使用“`IAsyncDisposable`”时，“异步释放”是什么意思？
- en: '`IAsyncDisposable` interface introduces the `DisposeAsync()` method, which
    can be implemented to perform asynchronous cleanup operations. This is particularly
    beneficial for resources that require asynchronous interactions for their disposal,
    such as network streams or database connections. By allowing asynchronous disposal,
    resources can be released more efficiently, and it helps prevent potential deadlocks
    or blocking scenarios, especially in contexts that heavily rely on asynchronous
    operations.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`IAsyncDisposable` 接口引入了 `DisposeAsync()` 方法，可以用来执行异步清理操作。这对于需要异步交互来释放的资源特别有益，例如网络流或数据库连接。通过允许异步释放，资源可以更有效地被释放，并有助于防止潜在的死锁或阻塞场景，尤其是在高度依赖异步操作的环境中。'
- en: 'As we conclude our journey through the dynamic world of asynchronous programming
    with `async` and `await`, where we unlocked the potential of parallel operations
    and enhanced code efficiency, we now stand at the threshold of another significant
    topic: delegates, events, and lambda expressions.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过使用 `async` 和 `await` 完成对异步编程动态世界的探索之旅，解锁了并行操作潜力并提高了代码效率时，我们现在站在另一个重要主题的门槛上：委托、事件和
    lambda 表达式。
- en: The forthcoming section promises to further enhance your proficiency in C#,
    offering insights into the powerful programming constructs that enable event-driven
    programming and functional programming styles. Prepare yourself to delve deep
    into the intricacies of delegates and experience the responsiveness facilitated
    by events and the concise code enabled by lambda expressions, as we continue to
    expand our C# programming horizons.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分承诺将进一步提高你在 C# 中的熟练度，提供关于强大的编程结构的信息，这些结构使得事件驱动编程和函数式编程风格成为可能。准备好深入探索委托的复杂性，体验事件带来的响应性以及
    lambda 表达式带来的简洁代码，随着我们继续扩展 C# 编程视野。
- en: Delegates, events, and lambda expressions
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理、事件和 lambda 表达式
- en: Peeling back the layers of C# reveals a sophisticated tapestry of mechanisms
    designed to facilitate advanced coding patterns and techniques. Central to this
    are **delegates**, **events**, and **lambda expressions**. This section delves
    deep into these constructs, shedding light on their intertwined relationships
    and essential roles in the .NET ecosystem. Delegates empower developers to encapsulate
    methods as first-class entities, providing a foundation for events and fostering
    dynamic method invocation. Events, in turn, offer a robust communication system,
    allowing objects to interact seamlessly without rigid dependencies. Meanwhile,
    lambda expressions infuse elegance and brevity, enabling concise function definitions
    on the fly. Together, these three pillars form the backbone of many modern programming
    patterns in C#. Embark on this exploration to discover how you can harness their
    combined potential, crafting flexible, maintainable, and expressive code with
    ease.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 撕开 C# 的层，可以看到一系列旨在促进高级编码模式和技术的机制。其中最重要的是 **代理**、**事件**和 **lambda 表达式**。本节深入探讨这些结构，揭示了它们相互交织的关系以及在
    .NET 生态系统中的基本作用。代理使开发者能够将方法封装为第一类实体，为事件提供基础，并促进动态方法调用。事件反过来提供了一个强大的通信系统，允许对象无缝交互，而无需严格的依赖。同时，lambda
    表达式注入了优雅和简洁，允许即时进行简洁的函数定义。这三个支柱共同构成了 C# 中许多现代编程模式的基础。开始这次探索，了解如何利用它们的组合潜力，轻松构建灵活、可维护和具有表现力的代码。
- en: What are “event accessors” in C#, and how can they customize subscription or
    unsubscription logic?
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 中的“事件访问器”是什么，它们如何自定义订阅或取消订阅逻辑？
- en: In C#, `add` and `remove` methods that define custom actions for subscribing
    to or unsubscribing from an event, respectively. They grant developers the capability
    to incorporate additional logic or validation when working with events. For example,
    you might want to limit the number of subscribers to an event or log every subscription.
    Customizing these accessors provides greater control over event behavior and interactions.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，`add` 和 `remove` 方法分别定义了订阅或取消订阅事件的自定义操作。它们赋予开发者在工作与事件一起时添加额外逻辑或验证的能力。例如，你可能想要限制事件的订阅者数量或记录每个订阅。自定义这些访问器提供了对事件行为和交互的更多控制。
- en: How does .NET implement lambda expressions at the compilation level? Do they
    become actual methods of a class?
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET 在编译级别如何实现 lambda 表达式？它们是否成为类的实际方法？
- en: During compilation, lambda expressions are transformed into either anonymous
    methods or class methods, depending on their usage context. If a lambda captures
    only local variables, it might be represented as a static method. However, if
    it captures variables from its surrounding scope (closure), the compiler generates
    a special class to hold these captured variables, and the lambda becomes a method
    of this generated class. This transformation ensures that the lambda functionality
    is preserved while integrating seamlessly with the .NET type system.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译过程中，lambda 表达式根据其使用上下文被转换为匿名方法或类方法。如果 lambda 只捕获局部变量，它可能表示为静态方法。然而，如果它捕获其周围作用域中的变量（闭包），编译器将生成一个特殊的类来保存这些捕获的变量，并且
    lambda 成为该生成类的成员方法。这种转换确保了 lambda 功能的保留，同时与 .NET 类型系统无缝集成。
- en: What are the primary differences between lambda expressions and expression trees,
    and what opportunities does working with expression trees provide?
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: lambda 表达式和表达式树之间的主要区别是什么，与表达式树一起工作提供了哪些机会？
- en: While lambda expressions are functional constructs that can be executed directly,
    expression trees represent code as a structured data format. In other words, while
    lambdas execute logic, expression trees describe logic. Expression trees allow
    for the introspection, modification, or even dynamic generation of code at runtime.
    This capability is especially beneficial for scenarios such as **object-relational
    mapping** (**ORM**) systems, where one might want to convert LINQ queries into
    SQL queries, or for building custom compilers or interpreters.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 lambda 表达式是可直接执行的函数式结构，但表达式树将代码表示为结构化数据格式。换句话说，虽然 lambda 执行逻辑，但表达式树描述逻辑。表达式树允许在运行时进行代码的反射、修改或动态生成。这种能力在诸如
    **对象关系映射**（ORM）系统等场景中特别有益，在这些场景中，可能需要将 LINQ 查询转换为 SQL 查询，或者用于构建自定义编译器或解释器。
- en: Why can “multicast delegates” be problematic in modern applications, and what
    alternatives exist?
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么“多播代理”（multicast delegates）在现代应用程序中可能会出现问题，有哪些替代方案？
- en: '**Multicast delegates** allow multiple handlers to respond to a single event.
    This can introduce complexities in management and debugging and can lead to unexpected
    side effects if not handled correctly. It becomes challenging to ensure the order
    of execution or handle exceptions thrown by individual delegate targets. An alternative
    is the use of events or the **Observer** pattern, which provides more structured
    and controlled ways to notify multiple subscribers.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**多播代理**允许多个处理程序响应单个事件。这可能会在管理和调试中引入复杂性，并且如果处理不当，可能会导致意外的副作用。确保执行顺序或处理个别委托目标抛出的异常变得具有挑战性。一种替代方案是使用事件或**观察者模式**（Observer
    pattern），它提供了更结构化和受控的方式来通知多个订阅者。'
- en: How can one dynamically create functions based on lambda expressions at runtime?
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在运行时根据lambda表达式动态创建函数？
- en: By using expression trees (`Expression<TDelegate>`), one can dynamically construct,
    modify, and compile lambda expressions at runtime. Expression trees represent
    code as data and can be transformed or inspected before being compiled into executable
    code using the `Compile` method.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用表达式树（`Expression<TDelegate>`），可以在运行时动态构造、修改和编译lambda表达式。表达式树将代码表示为数据，可以在使用`Compile`方法编译成可执行代码之前进行转换或检查。
- en: What is understood by “closure” in the context of lambda expressions and anonymous
    methods, and how does it affect captured variables?
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在lambda表达式和匿名方法的情况下，“闭包”（closure）指的是什么，它如何影响捕获的变量？
- en: A **closure** in the context of lambda expressions and anonymous methods refers
    to the ability of these constructs to *capture* and retain access to variables
    from their enclosing scope. The captured variables are stored in a way that they
    remain accessible and mutable even after the method in which they were declared
    has finished executing. This can lead to unexpected behaviors if not understood
    correctly, especially in multithreaded environments, where closures can introduce
    shared state across threads.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda表达式和匿名方法的情况下，“闭包”（closure）指的是这些构造能够*捕获*并保留对其封装作用域中变量的访问能力。捕获的变量以某种方式存储，即使在声明它们的函数执行完毕后，它们仍然可访问和可修改。如果不正确理解，这可能会导致意外的行为，尤其是在多线程环境中，闭包可能会在线程之间引入共享状态。
- en: What can be the consequences if one of the event subscribers throws an exception
    during the event invocation? How does it impact other subscribers of that event,
    and what approaches can be employed for the graceful handling of such scenarios?
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果事件订阅者在事件调用期间抛出异常，可能会产生什么后果？这将对该事件的其它订阅者产生什么影响，以及可以采用哪些方法来优雅地处理此类场景？
- en: If one of the event subscribers throws an exception during its execution, the
    subsequent subscribers in the invocation list won’t be executed. This means that
    other subscribers might miss the event notification. To mitigate this, one can
    invoke each delegate in the event’s invocation list separately, wrapped in a `try`-`catch`
    block. This ensures that an exception in one subscriber does not prevent the others
    from being invoked. Handling exceptions appropriately also ensures that the main
    logic isn’t interrupted unexpectedly.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件订阅者在执行过程中抛出异常，调用列表中的后续订阅者将不会执行。这意味着其他订阅者可能会错过事件通知。为了减轻这种情况，可以单独调用事件调用列表中的每个委托，并在`try`-`catch`块中包装。这确保了一个订阅者中的异常不会阻止其他订阅者的调用。适当地处理异常还可以确保主逻辑不会意外中断。
- en: What’s the difference between delegates and events, and how do they interoperate?
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理（delegates）和事件（events）之间的区别是什么，它们是如何交互的？
- en: While delegates are essentially type-safe function pointers that can point to
    one or more methods, events are a mechanism that allows a class to notify other
    classes or objects when something of interest occurs. Events use delegates behind
    the scenes to maintain a list of subscribers and to specify the signature of methods
    that can handle the event. In essence, events encapsulate delegates, adding an
    extra layer of protection and ensuring that only the owning class can raise an
    event.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 委托（delegates）本质上是一种类型安全的函数指针，可以指向一个或多个方法，而事件（events）是一种机制，允许一个类在发生感兴趣的事情时通知其他类或对象。事件在幕后使用委托来维护订阅者列表并指定可以处理事件的方法的签名。本质上，事件封装了委托，增加了一层额外的保护，并确保只有拥有类的对象可以引发事件。
- en: How can lambda expressions be used in C#, and what are their advantages over
    delegates?
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: lambda表达式在C#中如何使用，它们与委托相比有什么优势？
- en: Lambda expressions in C# are concise representations of anonymous methods using
    a clear and succinct syntax. They are often used with LINQ queries and other scenarios
    where short, inline methods are desirable. The primary advantages of lambda expressions
    over traditional delegate syntax are brevity and clarity. Lambda expressions provide
    a more readable and compact way to define inline methods without the need for
    explicit delegate instantiation.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的lambda表达式是使用清晰简洁的语法表示匿名方法的简洁表示。它们通常与LINQ查询和其他需要短小内联方法的场景一起使用。与传统的委托语法相比，lambda表达式的主要优势是简洁和清晰。lambda表达式提供了一种更易于阅读和紧凑的方式来定义内联方法，而无需显式创建委托实例。
- en: What is the difference between “Func<T>”, “Action<T>”, and “Predicate<T>” in
    C#, and when should each be used?
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在C#中，“Func<T>”，“Action<T>”和“Predicate<T）”之间的区别是什么，以及何时应该使用每个？
- en: 'In C#, `Func<T>` is used for delegates that return a value, `Action<T>` for
    delegates that don’t return a value, and `Predicate<T>` for delegates that return
    a Boolean value. Specifically, do the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，`Func<T>`用于返回值的委托，`Action<T>`用于不返回值的委托，`Predicate<T>`用于返回布尔值的委托。具体来说，请执行以下操作：
- en: Use **Func** when you need to compute or retrieve a result
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要计算或检索结果时使用**Func**
- en: Use **Action** when you want to perform an operation or action without expecting
    a return value
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想执行一个操作或动作而不期望返回值时使用**Action**
- en: Use **Predicate** when you want to evaluate a condition and get a **true** or
    **false** result, typically for filtering or checking conditions
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想评估一个条件并得到**true**或**false**的结果时使用**Predicate**，通常用于过滤或检查条件
- en: What challenges might arise when working with events, and how can they be mitigated?
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在处理事件时可能会出现哪些挑战，以及如何减轻这些挑战？
- en: 'Working with events in C# presents several challenges, such as the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中处理事件会带来一些挑战，例如以下这些：
- en: '**Memory leaks**: If subscribers don’t unsubscribe from events, it can lead
    to memory leaks, especially if the publisher has a longer lifetime than the subscriber'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存泄漏**：如果订阅者没有取消订阅事件，可能会导致内存泄漏，特别是如果发布者的生命周期比订阅者长'
- en: '**Multithreading Issues**: Accessing events from multiple threads can introduce
    race conditions, a situation where two or more threads attempt to modify shared
    data simultaneously, leading to unpredictable and erroneous outcomes'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多线程问题**：从多个线程访问事件可以引入竞争条件，即两个或多个线程同时尝试修改共享数据的情况，导致不可预测和错误的结果'
- en: '**Exception handling**: If one subscriber’s handler throws an exception, it
    might prevent other handlers from executing'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常处理**：如果某个订阅者的处理程序抛出异常，可能会阻止其他处理程序执行'
- en: 'To mitigate these challenges, follow these guidelines:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这些挑战，请遵循以下指南：
- en: Always unsubscribe from events when they’re no longer needed
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不再需要时，始终取消订阅事件
- en: Use thread-safe methods to invoke events
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程安全的方法来调用事件
- en: Wrap individual event invocations in **try**-**catch** blocks to ensure one
    handler’s exception doesn’t block others
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单个事件调用包裹在**try**-**catch**块中，以确保一个处理程序的异常不会阻止其他处理程序
- en: As we wrap up our segment on delegates, events, and lambda expressions, where
    we immersed ourselves in the exploration of event-driven programming and the concise
    syntax of lambda expressions, we are about to venture into another cornerstone
    of C# programming – using generic classes, methods, and interfaces to create reusable
    code.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们结束关于委托、事件和lambda表达式的部分，我们沉浸在对事件驱动编程和lambda表达式简洁语法的探索中，我们即将进入C#编程的另一个基石——使用泛型类、方法和接口来创建可重用代码。
- en: The upcoming section will be your gateway to mastering the art of crafting versatile
    and reusable code structures in C#, promoting code reusability and type safety.
    Brace yourself to delve into the world of generics, where we will learn to create
    flexible yet type-safe code, a step toward becoming proficient in sophisticated
    programming with C#.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将是你掌握制作灵活且可重用代码结构的C#艺术的门户，这将促进代码重用和类型安全。准备好深入泛型的世界，我们将学习如何创建灵活且类型安全的代码，这是成为熟练的C#复杂编程的步骤之一。
- en: How to use generic classes, methods, and interfaces to create reusable code
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用泛型类、方法和接口来创建可重用代码
- en: At the heart of efficient and robust programming lies the ability to write code
    that stands the test of time, adapts to diverse scenarios, and minimizes redundancy.
    **Generics**, introduced in C#, represent a quantum leap toward this ideal. This
    section introduces the powerful world of generics, enabling developers to define
    **classes**, **methods**, and **interfaces** with a type-safe, scalable, and reusable
    approach. Rather than committing to a specific data type, generics allow for a
    more abstract and versatile coding style, ensuring that you can cater to a wide
    array of requirements without the burden of excessive code repetition. Through
    a deep dive into generic classes, methods, and interfaces, you will gain insights
    into creating code structures that not only meet the demands of the present but
    are also well equipped to evolve with future needs. Embrace generics and unlock
    a world where flexibility and type safety coexist harmoniously, paving the way
    for truly adaptable solutions.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 高效且健壮的编程的核心在于编写能够经受时间考验、适应各种场景并最小化冗余的代码。在C#中引入的**泛型**代表了向这一理想迈进的一大步。本节介绍了泛型的强大世界，使开发者能够以类型安全、可扩展和可重用的方式定义**类**、**方法**和**接口**。泛型允许你不必局限于特定的数据类型，从而实现更抽象和灵活的编码风格，确保你能够满足广泛的业务需求，而无需承担大量代码重复的负担。通过深入研究泛型类、方法和接口，你将获得创建满足当前需求且能够适应未来需求的代码结构的见解。拥抱泛型，开启一个灵活性和类型安全和谐共存的全新世界，为真正可适应的解决方案铺平道路。
- en: What is the purpose of generics in C#, and what advantages do they offer over
    using the “object” base type?
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中泛型的用途是什么，它们与使用“object”基类型相比提供了哪些优势？
- en: 'Generics in C# provide a way to define classes, interfaces, and methods that
    operate on typed parameters while maintaining type safety and performance. Compared
    to using the `object` type, generics offer the following advantages:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的泛型提供了一种定义类、接口和方法的方式，这些类、接口和方法在操作类型参数的同时保持类型安全和性能。与使用`object`类型相比，泛型提供了以下优势：
- en: '**Type safety**: Generics ensure that you are working with the correct data
    type, eliminating the risk of runtime type errors'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型安全**：泛型确保你正在使用正确的数据类型，消除了运行时类型错误的风险'
- en: '**Performance**: With generics, there’s no need for boxing or unboxing when
    dealing with value types, leading to more efficient operations'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：使用泛型时，在处理值类型时无需装箱或拆箱，从而实现更高效的运算'
- en: '**Code reusability**: Generics allow you to write a piece of code that works
    with different data types, reducing code duplication'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码复用性**：泛型允许你编写可以与不同数据类型一起工作的代码片段，从而减少代码重复'
- en: '**Elimination of type casting**: With generics, explicit type casting is reduced,
    making the code cleaner and more readable'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消除类型转换**：使用泛型时，显式类型转换减少，使代码更简洁、更易读'
- en: How do you define a generic class, and how does it differ from a standard class?
    How can you set constraints on generic type parameters?
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何定义一个泛型类，它与标准类有何不同？你如何对泛型类型参数设置约束？
- en: A generic class is defined using type parameters, typically denoted by angle
    brackets (`<T>`). While a standard class works with specific data types, a generic
    class can work with any data type, based on the type parameter provided at the
    time of instantiation. For instance, `List<int>` and `List<string>` are instances
    of the generic `List<T>` class but work with `int` and `string` types, respectively.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类使用类型参数定义，通常用尖括号（`<T>`）表示。虽然标准类与特定数据类型一起工作，但泛型类可以与任何数据类型一起工作，这取决于实例化时提供的类型参数。例如，`List<int>`和`List<string>`是泛型`List<T>`类的实例，但分别使用`int`和`string`类型。
- en: 'Constraints on generic type parameters can be set using the `where` keyword.
    This allows you to limit the types that can be used as arguments for generics
    based on inheritance hierarchy, interfaces, or constructors. For example, `class
    MyGenericClass<T> where T : MyClass, new(),` ensures that `T` is or inherits from
    `MyClass` and has a parameterless constructor.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '可以使用`where`关键字设置泛型类型参数的约束。这允许你根据继承层次结构、接口或构造函数限制用作泛型参数的类型。例如，`class MyGenericClass<T>
    where T : MyClass, new(),`确保`T`是或继承自`MyClass`，并且有一个无参数的构造函数。'
- en: Can generics integrate with other key features of C# such as delegates or attributes?
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型能否与其他C#关键特性集成，如委托或属性？
- en: 'Yes – generics can be combined with various features in C#, such as the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 是的——泛型可以与C#中的各种功能结合使用，例如以下内容：
- en: '**Delegates**: You can define generic delegates, which can point to methods
    of various types'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**委托**：你可以定义通用委托，它可以指向各种类型的函数'
- en: '**Events**: Events can be based on generic delegates'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：事件可以基于通用委托'
- en: '**Attributes**: While you can’t create a generic attribute class, you can apply
    attributes to generic constructs'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：虽然你不能创建通用属性类，但你可以将属性应用于通用构造'
- en: How are covariance and contravariance applied to generic interfaces and delegates
    in C#?
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 C# 中，协变和逆协变是如何应用于通用接口和委托的？
- en: 'In C#, **covariance** and **contravariance** provide flexibility in assigning
    and using generic types with interfaces and delegates in the following ways:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，**协变**和**逆协变**为使用接口和委托的泛型类型提供了灵活性，以下是如何进行分配和使用的方式：
- en: '**Covariance** (**out** keyword): Enables you to use a more derived type than
    originally specified. For example, you can assign an object of **IEnumerable<Derived>**
    to a variable of **IEnumerable<Base>**.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协变**（**out** 关键字）：允许你使用比最初指定的更派生的类型。例如，你可以将 **IEnumerable<Derived>** 的对象赋值给
    **IEnumerable<Base>** 类型的变量。'
- en: '**Contravariance** (**in** keyword): Allows for a less derived type. This is
    commonly seen with delegates.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逆协变**（**in** 关键字）：允许使用比派生类型更少的类型。这在委托中很常见。'
- en: For instance, an interface can be defined as `IInterface<out T>` for covariance
    or `IInterface<in T>` for contravariance.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个接口可以定义为 `IInterface<out T>` 以实现协变或 `IInterface<in T>` 以实现逆协变。
- en: What are the characteristics of static fields and methods in generic classes
    compared to standard classes?
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与标准类相比，通用类中的静态字段和方法有哪些特点？
- en: In generic classes, static fields and methods are unique. For each type specialization
    of a generic class, there’s a separate set of static fields. This means that `MyClass<int>`
    and `MyClass<string>` will each have their own distinct instances of static fields.
    This behavior differs from non-generic classes, where there’s only one set of
    static fields shared across all instances of the class.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在通用类中，静态字段和方法是唯一的。对于通用类的每个类型特化，都有一个单独的静态字段集。这意味着 `MyClass<int>` 和 `MyClass<string>`
    将各自拥有它们自己的静态字段实例。这种行为与非通用类不同，非通用类只有一个静态字段集，该字段集被类中的所有实例共享。
- en: What does a “generic type extension method” mean, and how is it applied?
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “通用类型扩展方法”是什么意思，它是如何应用的？
- en: 'A `this` keyword before the generic type parameter in the method signature,
    as in the following example:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法签名中的通用类型参数之前有一个 `this` 关键字，如下例所示：
- en: '[PRE28]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By using such extension methods, developers can enhance the functionality of
    existing types in a clean and modular way, benefiting from the flexibility and
    type safety provided by generics.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这样的扩展方法，开发者可以以干净和模块化的方式增强现有类型的功能，并从泛型提供的灵活性和类型安全中受益。
- en: Can we inherit from generic type classes? What are the nuances of this process?
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们能否从通用类型类中继承？这个过程的细微差别是什么？
- en: 'Yes – you can inherit from generic type classes. When inheriting, you can do
    the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 是的——你可以从通用类型类中继承。在继承时，你可以做以下操作：
- en: 'You can specify a concrete type for the base generic class; for example, **class
    Derived : Base<int> { }**'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '你可以为基通用类指定具体类型；例如，**class Derived : Base<int> { }**'
- en: 'Alternatively, you can maintain the generic nature in the derived class: **class
    Derived<T> : Base<T> { }**'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '或者，你可以在派生类中保持通用性：**class Derived<T> : Base<T> { }**'
- en: It’s important to be aware of any type constraints placed on the base generic
    class, as these will also apply to the derived class.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意对基通用类施加的类型约束，因为这些也将应用于派生类。
- en: What compilation mechanism is used for generic types? Is separate machine code
    generated for each specialized type?
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用类型使用了什么编译机制？是否为每个特殊类型生成单独的机器代码？
- en: In .NET, generic types are compiled into a single template in `int`, `double`),
    separate code is generated for each type to ensure optimized performance. However,
    for reference types, the same code is shared, making the process more memory-efficient.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，通用类型被编译成一个单独的模板（例如 `int`、`double`），为每个类型生成单独的代码以确保优化性能。然而，对于引用类型，相同的代码被共享，这使得过程更加内存高效。
- en: As we conclude our exploration of generics classes, methods, and interfaces,
    where we harnessed the power of adaptable and type-safe code structures, we are
    gearing up to delve into the sophisticated realm of multithreading, creating and
    managing threads, synchronization primitives, and handling thread synchronization
    and communication.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索泛型类、方法和接口的探索中，我们利用了可适应和类型安全的代码结构的力量之后，我们正准备深入探讨多线程的复杂领域，创建和管理线程、同步原语，并处理线程同步和通信。
- en: In the forthcoming section, brace yourself to uncover the intricacies of multithreading
    in C#, a pivotal skill in developing robust and efficient applications. Anticipate
    gaining hands-on experience in creating and coordinating threads adeptly, embracing
    synchronization primitives, and navigating the complexities of thread synchronization
    and communication. Let’s forge ahead, equipped to tackle the challenges and opportunities
    that multithreaded programming in C# presents!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，准备好揭开 C# 中多线程的复杂性，这是开发健壮和高效应用程序的关键技能。期待获得创建和协调线程的实践经验，掌握同步原语，并应对线程同步和通信的复杂性。让我们继续前进，准备好应对
    C# 多线程编程带来的挑战和机遇！
- en: Multithreading – Creating and managing threads, synchronization primitives,
    and handling thread synchronization and communication
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程 – 创建和管理线程、同步原语，以及处理线程同步和通信
- en: In today’s world of multi-core processors and demands for seamless user experiences,
    the art of multithreading has become an indispensable part of a developer’s toolkit.
    This section ventures into the intricate realm of multithreading, offering a comprehensive
    guide to creating, managing, and coordinating threads in C#. Beyond the simple
    creation of threads, you’ll delve into the nuances of synchronization primitives,
    ensuring that your multithreaded applications operate without glitches or data
    inconsistencies.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今多核处理器和无缝用户体验需求的世界中，多线程的艺术已经成为开发者工具箱中不可或缺的一部分。本节将深入探讨多线程的复杂领域，提供创建、管理和协调 C#
    中线程的全面指南。除了简单的线程创建之外，你还将深入了解同步原语的细微差别，确保你的多线程应用程序运行无故障或数据不一致。
- en: But threading isn’t just about execution; it’s also about communication. We’ll
    explore how threads can communicate effectively, ensuring smooth data transfer
    and task coordination. As you navigate through this section, you’ll discover the
    balance between maximizing performance through concurrent operations and maintaining
    the integrity and reliability of your applications. Welcome to the world of multithreading,
    where speed and coordination come together to supercharge your applications.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 但线程不仅仅是关于执行；它还关乎通信。我们将探讨线程如何有效地进行通信，确保数据传输和任务协调的顺畅。当你浏览这一节时，你会发现通过并发操作最大化性能与保持应用程序的完整性和可靠性之间的平衡。欢迎来到多线程的世界，在这里速度和协调相结合，为你的应用程序提供强大的动力。
- en: How can one create a thread in C#, and what are the primary methods for its
    initiation?
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在 C# 中创建一个线程，以及其主要启动方法是什么？
- en: 'In C#, threads can be created using the `Thread` class from the `System.Threading`
    namespace. Once you’ve instantiated a thread, you can initiate it using the `Start()`
    method. Here’s an example:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，可以使用 `System.Threading` 命名空间中的 `Thread` 类来创建线程。一旦实例化了一个线程，你可以使用 `Start()`
    方法来启动它。以下是一个示例：
- en: '[PRE29]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, `MyFunction` is the method you want to run on a separate thread. It’s
    worth noting that while creating threads this way provides granular control, for
    many scenarios, TPL offers a higher-level and more efficient approach to parallel
    execution.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`MyFunction` 是你希望在单独的线程上运行的方法。值得注意的是，虽然以这种方式创建线程提供了细粒度控制，但对于许多场景，TPL 提供了一种更高级和更高效的并行执行方法。
- en: What synchronization primitives are available in C# for managing resource access?
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 中有哪些同步原语可用于管理资源访问？
- en: 'C# provides various synchronization primitives to control access to shared
    resources and ensure data safety in a multithreaded environment. These include
    the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了各种同步原语来控制对共享资源的访问并确保在多线程环境中的数据安全。这些包括以下内容：
- en: '**Monitor**: Often used implicitly with the **lock** keyword to acquire a lock
    on an object'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监视器（Monitor）**：通常与 **lock** 关键字隐式使用来获取对象的锁'
- en: '**Mutex**: Similar to **Monitor** but can be used across multiple processes,
    ensuring inter-process synchronization'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互斥锁（Mutex）**：类似于**监视器（Monitor）**，但可以在多个进程间使用，确保进程间同步'
- en: '**Semaphore**: Controls access to a resource by multiple threads by limiting
    the number of simultaneous accesses'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号量**：通过限制同时访问的数量来控制多个线程对资源的访问'
- en: '**ReaderWriterLock** and **ReaderWriterLockSlim**: Allow multiple threads to
    read shared data, but only one to write, optimizing scenarios with frequent reads
    and occasional writes'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读写锁（ReaderWriterLock）**和**读写锁精简版（ReaderWriterLockSlim）**：允许多个线程读取共享数据，但只允许一个线程写入，优化了频繁读取和偶尔写入的场景'
- en: '**lock** statement: A shorthand for **Monitor.Enter** and **Monitor.Exit**,
    providing a block-based scope for acquiring and releasing a lock'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**lock**语句：**Monitor.Enter**和**Monitor.Exit**的简写，提供了一个基于块的获取和释放锁的作用域'
- en: What’s the difference between Monitor, Mutex, and Semaphore when it comes to
    thread synchronization?
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当涉及到线程同步时，监视器（Monitor）、互斥锁（Mutex）和信号量（Semaphore）之间有什么区别？
- en: 'Let’s see the differences between these mechanisms:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些机制之间的区别：
- en: '**Monitor**: It allows a thread to acquire a lock on an object and is typically
    used via a **lock** statement in C#. It’s the fastest synchronization mechanism
    but operates only within a single process. It’s best suited for short-lived locks
    where contention is low.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监视器**：允许线程获取对象的锁，通常通过C#中的**lock**语句使用。它是最快的同步机制，但仅在单个进程中操作。它最适合低争用短生命周期的锁。'
- en: '**Mutex**: Functions similar to **Monitor** but can be used across multiple
    processes. This means if you have several applications that need to synchronize
    access to a shared resource, a **Mutex** mechanism can be employed. It’s more
    heavyweight than a **Monitor** mechanism and has a performance overhead due to
    its cross-process capabilities.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互斥锁（Mutex）**：类似于**监视器（Monitor）**的功能，但可以在多个进程中使用。这意味着如果你有多个需要同步访问共享资源的应用程序，可以使用**互斥锁**机制。它比**监视器**机制更重，由于跨进程功能，它有性能开销。'
- en: '**Semaphore**: It’s a signaling mechanism that controls access by multiple
    threads to a shared resource. Unlike **Monitor** and **Mutex**, which are binary
    locks (locked/unlocked), a **Semaphore** mechanism has a count, limiting the number
    of threads that can access a resource or group of resources concurrently. It’s
    useful when you have a pool of resources and you want to limit the number of simultaneous
    accesses – for instance, in scenarios such as limiting concurrent database connections.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号量（Semaphore）**：是一种控制多个线程访问共享资源的信号机制。与**监视器（Monitor）**和**互斥锁（Mutex）**不同，它们是二进制锁（锁定/解锁），**信号量**机制有一个计数，限制可以同时访问资源或资源组的线程数量。当你有一组资源并且想要限制同时访问的数量时很有用——例如，在限制并发数据库连接的场景中。'
- en: What is a “deadlock” in multithreading, and how can it be avoided?
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是多线程中的“死锁”，以及如何避免它？
- en: 'A **deadlock** in multithreading occurs when two or more threads are locked
    in a state where each thread is waiting for another to release a resource, creating
    a standstill where no thread can proceed. This effectively halts the execution
    of the threads involved. To avoid deadlocks, consider the following strategies:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程中的**死锁**发生在两个或更多线程处于一种状态，每个线程都在等待另一个线程释放资源，从而形成一个停滞状态，没有任何线程可以继续执行。这实际上阻止了涉及线程的执行。为了避免死锁，可以考虑以下策略：
- en: '**Lock ordering**: Always acquire locks in a consistent, predetermined order.
    If all threads follow the same order when acquiring locks, circular waiting (a
    key condition for deadlocks) can be avoided.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锁顺序**：始终以一致、预定的顺序获取锁。如果所有线程在获取锁时遵循相同的顺序，就可以避免循环等待（死锁的关键条件）。'
- en: '**Lock timeouts**: Use timeouts when attempting to acquire a lock. If a thread
    cannot obtain all the necessary locks within a certain time frame, it can release
    any locks it has acquired and retry.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锁超时**：在尝试获取锁时使用超时。如果线程在特定时间内无法获取所有必要的锁，它可以释放它所获取的任何锁并重试。'
- en: '**Deadlock detection**: Have mechanisms in place to detect deadlocks. This
    can be complex and may not be suitable for all scenarios, but in systems where
    deadlocks can have significant impacts, detection and recovery mechanisms are
    essential.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**死锁检测**：有机制来检测死锁。这可能很复杂，可能不适合所有场景，但在死锁可能产生重大影响的系统中，检测和恢复机制是必不可少的。'
- en: How can “ThreadPool” help manage threads more efficiently than manually creating
    threads?
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “ThreadPool”如何比手动创建线程更有效地管理线程？
- en: '`ThreadPool` manages a pool of worker threads, providing an efficient mechanism
    for executing short-lived tasks in the background. Benefits include the following:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPool`管理一组工作线程，提供了一种在后台高效执行短期任务的有效机制。其优点包括以下：'
- en: '**Reduced overhead**: **ThreadPool** minimizes the overhead associated with
    thread creation and destruction by reusing threads'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**降低开销**：**ThreadPool** 通过重用线程最小化了与线程创建和销毁相关的开销。'
- en: '**Optimized resource utilization**: **ThreadPool** dynamically adjusts the
    number of threads in the pool based on the workload, ensuring optimal utilization
    of system resources'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化资源利用**：**ThreadPool** 根据工作负载动态调整池中的线程数量，确保系统资源的最佳利用。'
- en: '**Ease of use**: **ThreadPool** simplifies parallel execution by abstracting
    away thread management details, allowing developers to focus on task execution
    logic'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易用性**：**ThreadPool** 通过抽象线程管理细节简化了并行执行，使开发者能够专注于任务执行逻辑。'
- en: What does “Task” represent in C#, and how does it differ from a regular thread?
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 C# 中，“Task”代表什么，它与常规线程有何不同？
- en: '`Task` in C# represents an asynchronous operation. It provides a higher-level
    abstraction over threads and offers several benefits:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的 `Task` 代表异步操作。它提供了比线程更高层次的抽象，并提供了几个好处：
- en: '**Asynchronous programming**: With the use of **async** and **await** keywords,
    **Task** makes it simpler to write asynchronous code'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步编程**：使用 **async** 和 **await** 关键字，**Task** 使编写异步代码变得更加简单。'
- en: '**Resource management**: A **Task** instance may run on a thread from the **ThreadPool**,
    optimizing thread utilization and management'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理**：一个 **Task** 实例可能在一个 **ThreadPool** 的线程上运行，优化线程利用和管理。'
- en: '**Composability**: Tasks can be easily composed, allowing for the creation
    of chains of asynchronous operations'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可组合性**：任务可以轻松组合，允许创建异步操作的链。'
- en: '**Exception handling**: **Task** provides a centralized way to handle exceptions
    in asynchronous code'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常处理**：**Task** 提供了一种集中处理异步代码中异常的方法。'
- en: The primary difference from a regular thread is that a `Task` instance abstracts
    the underlying threading details and provides a richer API for representing asynchronous
    computations, while a thread represents a single execution path in a program.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规线程的主要区别在于，`Task` 实例抽象了底层的线程细节，并为表示异步计算提供了更丰富的 API，而线程代表程序中的单个执行路径。
- en: How can you ensure safe data exchange between threads?
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何确保线程之间安全的数据交换？
- en: 'Ensuring safe data exchange between threads is crucial for data consistency
    and system stability. Here’s how it can be achieved:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 确保线程之间安全的数据交换对于数据一致性和系统稳定性至关重要。以下是实现方法：
- en: '**Synchronization primitives**: Use synchronization mechanisms such as **lock**,
    **Mutex**, **Semaphore**, and **ReaderWriterLock** to ensure that only one thread
    accesses shared resources at a time.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步原语**：使用同步机制，如 **lock**、**Mutex**、**Semaphore** 和 **ReaderWriterLock**，以确保一次只有一个线程访问共享资源。'
- en: '**Concurrent collections**: Utilize thread-safe collections, such as **ConcurrentDictionary**,
    **BlockingCollection**, or **ConcurrentQueue**, which are designed to handle concurrent
    access without the need for additional synchronization.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发集合**：利用线程安全的集合，例如 **ConcurrentDictionary**、**BlockingCollection** 或 **ConcurrentQueue**，这些集合设计用于处理并发访问，无需额外的同步。'
- en: '**Immutable data structures**: Use immutable objects that can’t be modified
    after they’re created. Since they can’t change state, they can be shared safely
    among multiple threads.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变数据结构**：使用创建后不可修改的不可变对象。由于它们无法改变状态，它们可以在多个线程之间安全地共享。'
- en: '**volatile keyword**: In scenarios where you need to ensure that a particular
    field is always read from the main memory location (and not cached), you can use
    the **volatile** keyword.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**volatile 关键字**：在需要确保特定字段始终从主内存位置（而不是缓存）读取的场景中，可以使用 **volatile** 关键字。'
- en: How do “async” and “await”help create asynchronous code without directly managing
    threads?
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “async”和“await”如何帮助创建异步代码而不直接管理线程？
- en: '`async` and `await` provide a means to write asynchronous code that appears
    synchronous in structure. When you use `await`, the method’s execution is paused,
    freeing up the executing thread to return to the thread pool until the awaited
    asynchronous operation completes. This approach allows for efficient resource
    utilization without the intricacies of direct thread management. Essentially,
    they abstract the complexities of asynchronous programming, enabling developers
    to focus on logic rather than concurrency mechanisms.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`和`await`提供了一种编写结构上看似同步的异步代码的方法。当你使用`await`时，方法的执行被暂停，释放执行线程返回线程池，直到等待的异步操作完成。这种方法允许高效地利用资源，而不必直接管理线程的复杂性。本质上，它们抽象了异步编程的复杂性，使开发者能够专注于逻辑而不是并发机制。'
- en: What is “thread-local storage” in C#, and how is it used?
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中的“线程局部存储”是什么，它是如何使用的？
- en: '`ThreadStatic` attribute or the `ThreadLocal<T>` class. TLS is particularly
    useful for scenarios where thread-specific contextual information or state needs
    to be stored without interference from other threads.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadStatic`属性或`ThreadLocal<T>`类。TLS在需要存储线程特定上下文信息或状态而不受其他线程干扰的场景中特别有用。'
- en: What are the main approaches and best practices recommended when working with
    multithreading in C#?
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在使用C#进行多线程工作时，推荐的主要方法和最佳实践有哪些？
- en: 'Some recommended approaches and best practices include the following:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 一些推荐的方案和最佳实践包括以下内容：
- en: '**Use synchronization primitives**: Always use synchronization mechanisms such
    as **lock**, **Mutex**, **Semaphore**, and **ReaderWriterLock** when accessing
    shared resources to prevent race conditions'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用同步原语**：在访问共享资源时，始终使用同步机制，如**lock**、**Mutex**、**Semaphore**和**ReaderWriterLock**，以防止竞态条件。'
- en: '**Minimize lock contention**: Avoid holding locks for extended periods, especially
    when performing I/O operations or other blocking tasks'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化锁竞争**：避免长时间持有锁，尤其是在执行I/O操作或其他阻塞任务时。'
- en: '**Leverage built-in libraries**: Utilize **ThreadPool** or **Task** for asynchronous
    operations instead of manually creating and managing threads'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用内置库**：使用**ThreadPool**或**Task**进行异步操作，而不是手动创建和管理线程。'
- en: '**Beware of race conditions and deadlocks**: Understand common pitfalls and
    scenarios that lead to these issues and actively work to prevent them'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警惕竞态条件和死锁**：了解导致这些问题的常见陷阱和场景，并积极采取措施防止它们。'
- en: '**Embrace asynchronicity**: Use the **async/await** paradigm for operations
    that might block a thread, such as I/O or network requests'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拥抱异步性**：对于可能阻塞线程的操作，如I/O或网络请求，使用**async/await**范式。'
- en: '**Testing**: Regularly test multithreaded code under various conditions, including
    stress and load tests, to uncover potential concurrency issues'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：定期在各种条件下测试多线程代码，包括压力和负载测试，以揭示潜在的并发问题。'
- en: What is the role of “memory barriers” or “fences” in multithreaded C# code?
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在多线程C#代码中，“内存屏障”或“栅栏”的作用是什么？
- en: '**Memory barriers** or **fences** are mechanisms that ensure a specific order
    of memory operations in a multithreaded environment. They prevent certain operations
    from being reordered by the compiler or the processor. This ensures that specific
    operations are executed before or after the barrier as intended, maintaining the
    integrity and consistency of data across threads. They play a crucial role in
    scenarios where the order of operations is critical for correct program behavior.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存屏障**或**栅栏**是确保在多线程环境中内存操作特定顺序的机制。它们防止编译器或处理器重新排序某些操作。这确保了特定操作在屏障之前或之后按预期执行，保持跨线程数据的一致性和完整性。它们在操作顺序对正确程序行为至关重要的场景中起着关键作用。'
- en: When is it most effective to apply “SpinLock”?
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时应用“自旋锁”最有效？
- en: '`SpinLock` is a lock primitive that actively *spins* or busy-waits, rather
    than putting the thread to sleep, when waiting for a lock to be released. It is
    most effective in scenarios where the lock hold times are expected to be very
    short, and the overhead of suspending and resuming a thread (context switching)
    would be more expensive than the short busy-wait. It’s particularly useful in
    high-performance scenarios, where threads are expected to acquire locks almost
    immediately.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpinLock`是一种锁原语，在等待锁释放时，它积极地**自旋**或忙等待，而不是使线程休眠。它在预期锁持有时间非常短且挂起和恢复线程（上下文切换）的开销比短暂的忙等待更昂贵的情况下最有效。它在高性能场景中特别有用，其中线程预计几乎可以立即获取锁。'
- en: What is the purpose of the “volatile” keyword in multithreaded C# code, and
    how does it interact with compiler optimization?
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在多线程 C# 代码中，“volatile” 关键字的用途是什么，它与编译器优化如何交互？
- en: The `volatile` keyword in C# indicates to the compiler that a field can be accessed
    simultaneously by multiple threads. This prevents certain compiler optimizations
    on that field to ensure proper visibility and ordering of reads and writes. Essentially,
    it guarantees that any read or write operation to a `volatile` variable will always
    interact directly with main memory, rather than using cached data. This ensures
    that all threads will observe the most recent value of the variable, providing
    a memory barrier-like behavior to prevent unexpected results due to compiler or
    hardware optimizations.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的 `volatile` 关键字表示该字段可以被多个线程同时访问。这防止了编译器对该字段进行某些优化，以确保读取和写入的正确可见性和顺序。本质上，它保证了任何对
    `volatile` 变量的读取或写入操作都将直接与主内存交互，而不是使用缓存数据。这确保了所有线程都将观察到变量的最新值，提供类似内存屏障的行为，以防止由于编译器或硬件优化而产生意外结果。
- en: What are the primary distinctions between the “BlockingCollection”, “ConcurrentBag”,
    “ConcurrentQueue”, and “ConcurrentStack”collections?
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “BlockingCollection”、“ConcurrentBag”、“ConcurrentQueue” 和 “ConcurrentStack” 集合之间的主要区别是什么？
- en: 'Let’s take a look at the different collections:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看不同的集合：
- en: '**BlockingCollection**: This is a wrapper around other collections, providing
    blocking and bounding capabilities. It’s useful for scenarios where you want to
    control the rate of data flow between producer and consumer threads.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BlockingCollection**: 这是对其他集合的包装，提供了阻塞和边界能力。它在需要控制生产者和消费者线程之间数据流速率的场景中非常有用。'
- en: '**ConcurrentBag**: A thread-safe, unordered collection optimized for scenarios
    where each thread frequently adds and removes items.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ConcurrentBag**: 这是一个线程安全的无序集合，针对每个线程频繁添加和删除项的场景进行了优化。'
- en: '**ConcurrentQueue**: A thread-safe FIFO collection.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ConcurrentQueue**: 这是一个线程安全的先进先出（FIFO）集合。'
- en: '**ConcurrentStack**: A thread-safe LIFO collection.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ConcurrentStack**: 这是一个线程安全的后进先出（LIFO）集合。'
- en: What is the purpose of “ThreadLocal<T>”, and what are its advantages and drawbacks?
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “ThreadLocal<T>” 的用途是什么，它有哪些优点和缺点？
- en: '`ThreadLocal<T>` provides a way to create data that is local to the thread
    it’s accessed from, ensuring each thread has its own unique value.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadLocal<T>` 提供了一种创建线程局部数据的方式，确保每个线程都有自己的唯一值。'
- en: 'Its advantages include the following:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 其优点包括以下：
- en: '**Data isolation**: Ensures that data is isolated between threads, reducing
    the need for synchronization'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据隔离**：确保数据在线程之间隔离，减少了对同步的需求'
- en: '**Performance**: Access to thread-local data is generally faster than shared
    data with locks'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：访问线程局部数据通常比带有锁的共享数据更快'
- en: 'Its drawbacks include the following:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 其缺点包括以下：
- en: '**Increased memory usage**: Each thread having its own instance can lead to
    higher memory consumption'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加的内存使用**：每个线程都有自己的实例可能会导致更高的内存消耗'
- en: '**Potential memory leaks**: If threads are not terminated correctly or if **ThreadLocal**
    instances are not disposed of properly, it can lead to memory leaks'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**潜在的内存泄漏**：如果线程没有正确终止，或者如果 **ThreadLocal** 实例没有正确处置，可能会导致内存泄漏'
- en: What does “starvation” mean in the context of multithreaded programming?
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在多线程编程的上下文中，“饥饿”是什么意思？
- en: '**Starvation** in multithreading refers to a situation where one or more threads
    are perpetually unable to access a resource or execute because other threads are
    continuously monopolizing the resource or CPU. This can lead to reduced system
    throughput, unresponsiveness, or even total application stall. Starvation often
    arises in systems where thread prioritization is mishandled or where certain threads
    are deprioritized to the extent that they rarely or never get to execute.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**多线程中的饥饿**指的是一个或多个线程始终无法访问资源或执行，因为其他线程持续垄断资源或 CPU。这可能导致系统吞吐量降低、无响应，甚至完全的应用程序停滞。饥饿通常出现在线程优先级处理不当的系统或某些线程被降级到很少或从未执行的程度。'
- en: How does “CancellationToken” assist in managing the execution of threads and
    tasks?
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “CancellationToken” 如何帮助管理线程和任务的执行？
- en: '`CancellationToken` provides a mechanism to request the cancellation of threads,
    tasks, or asynchronous operations. It enables the following:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`CancellationToken` 提供了一种请求取消线程、任务或异步操作的方式。它允许以下操作：'
- en: '**Cooperative cancellation**: Tasks and threads can periodically check the
    token to see if a cancellation has been requested, allowing them to exit gracefully'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作取消**：任务和线程可以定期检查令牌，以查看是否已请求取消，从而允许它们优雅地退出'
- en: '**Safe termination**: Ensures that long-running operations can be terminated
    in a controlled manner without causing data corruption or other issues'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全终止**确保长时间运行的操作可以以受控的方式终止，而不会导致数据损坏或其他问题'
- en: '**Reactivity**: Enables applications to be more responsive by canceling tasks
    in response to external events or changes in state, such as user requests or timeouts'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反应性**：通过对外部事件或状态变化（如用户请求或超时）的响应取消任务，使应用程序能够更加响应'
- en: How do atomic operations, such as the methods in the “Interlocked class”, facilitate
    synchronization in multithreaded code?
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子操作，如“Interlocked”类中的方法，如何促进多线程代码中的同步？
- en: 'The methods in the `Interlocked` class provide atomic operations for variables,
    ensuring that the operations are completed without being interrupted by other
    threads. This offers the following benefits:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`Interlocked`类中的方法为变量提供原子操作，确保操作在没有被其他线程中断的情况下完成。这提供了以下好处：'
- en: '**Safety**: Interlocked methods allow for safe updates to variables in a multithreaded
    environment without the need for locks'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：互斥方法允许在多线程环境中安全地更新变量，而无需使用锁'
- en: '**Performance**: Atomic operations are often faster than using locks, especially
    when contention is low'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：原子操作通常比使用锁更快，尤其是在竞争低时'
- en: '**Consistency**: Interlocked methods guarantee that the data remains consistent
    even when accessed by multiple threads concurrently'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：互斥方法保证即使在多个线程并发访问时，数据也保持一致'
- en: Interlocked classes are commonly used for operations such as incrementing counters,
    swapping values, or updating shared data in a thread-safe manner.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥类通常用于如增加计数器、交换值或以线程安全的方式更新共享数据等操作。
- en: What is meant by non-blocking calls in multithreaded programming, and why are
    they considered advantageous compared to blocking calls?
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在多线程编程中，所说的非阻塞调用是什么意思，为什么它们被认为比阻塞调用更有优势？
- en: '**Non-blocking calls** do not halt the execution of a thread while waiting
    for a resource or a response. This means the thread can continue performing other
    tasks or operations concurrently. Their advantages include the following:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**非阻塞调用**不会在等待资源或响应时停止线程的执行。这意味着线程可以继续执行其他任务或操作。它们的优点包括以下内容：'
- en: '**Resource efficiency**: Non-blocking calls enable optimal system resource
    utilization since the thread can perform other tasks while waiting'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源效率**：非阻塞调用使系统能够优化资源利用，因为线程可以在等待时执行其他任务'
- en: '**Responsiveness**: Applications remain responsive, especially in I/O-bound
    operations or network calls, as they don’t get stuck waiting'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**：应用程序保持响应，尤其是在I/O密集型操作或网络调用中，因为它们不会陷入等待状态'
- en: '**Scalability**: Non-blocking operations often lead to more scalable systems,
    especially when dealing with high concurrency, as threads aren’t left idle'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：非阻塞操作通常导致更可伸缩的系统，尤其是在处理高并发时，因为线程不会被闲置'
- en: In contrast, **blocking calls** pause the execution of a thread until it obtains
    the required resource or response, potentially leading to inefficient resource
    use and reduced application responsiveness.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，**阻塞调用**会暂停线程的执行，直到它获得所需的资源或响应，这可能导致资源使用效率低下和应用程序响应速度降低。
- en: Why does the traditional “lock” mechanism not work for asynchronous operations?
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么传统的“lock”机制不适用于异步操作？
- en: The traditional `lock` mechanism blocks the executing thread while it waits
    for the lock to be released. In the context of asynchronous operations, using
    such a blocking mechanism can lead to deadlocks, especially if the locked resource
    is accessed later by the same logical flow but on a different thread. Additionally,
    using `lock` in asynchronous code can increase the strain on the thread scheduler
    since threads might be blocked asynchronously. Instead of efficiently freeing
    up the thread to handle other tasks, it remains blocked, diminishing the benefits
    of asynchronicity.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的`lock`机制在等待锁释放时会阻塞执行线程。在异步操作的情况下，使用这种阻塞机制可能导致死锁，特别是如果锁定资源稍后被同一逻辑流程但在不同线程上访问。此外，在异步代码中使用`lock`会增加线程调度器的负担，因为线程可能会异步阻塞。不是有效地释放线程以处理其他任务，它保持阻塞，减少了异步性的好处。
- en: How can synchronization be ensured in asynchronous methods? What primitives
    can be used for this purpose?
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在异步方法中确保同步？可以使用哪些原语来实现此目的？
- en: 'Synchronization in asynchronous methods can be achieved using certain synchronization
    primitives designed for asynchronous operations. These include the following:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法中的同步可以使用为异步操作设计的某些同步原语来实现。以下是一些包括的内容：
- en: '**SemaphoreSlim**: Supports both synchronous and asynchronous locking, making
    it useful for scenarios where you might have mixed synchronous and asynchronous
    code'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SemaphoreSlim**：支持同步和异步锁定，在可能混合同步和异步代码的场合很有用'
- en: '**AsyncLock**: While not part of the .NET Framework itself, patterns such as
    **AsyncLock** (often implemented using **SemaphoreSlim**) can provide a lock-like
    mechanism for asynchronous code'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AsyncLock**：虽然不是 .NET Framework 本身的一部分，但像 **AsyncLock**（通常使用 **SemaphoreSlim**
    实现）这样的模式可以为异步代码提供类似锁的机制'
- en: '**Mutex** and **ReaderWriterLockSlim**: While these synchronization primitives
    are traditionally associated with thread synchronization, they can also be judiciously
    employed in specific asynchronous scenarios to ensure safe and correct program
    execution'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mutex** 和 **ReaderWriterLockSlim**：虽然这些同步原语传统上与线程同步相关联，但也可以在特定的异步场景中谨慎使用，以确保程序执行的安全和正确'
- en: Using these primitives allows for mutual exclusion in asynchronous code without
    blocking threads, ensuring resources are accessed safely and efficiently.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些原语可以在不阻塞线程的情况下实现异步代码的互斥，确保资源安全有效地访问。
- en: How does “Task.Yield()” interact with the task scheduler, and what is its use?
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “Task.Yield()”如何与任务调度器交互，它的用途是什么？
- en: '`Task.Yield()` is an asynchronous method that immediately yields control back
    to the task scheduler. This allows the scheduler to process other waiting tasks
    before resuming the current one. Its primary uses include the following:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task.Yield()` 是一个异步方法，它立即将控制权交回给任务调度器。这允许调度器在恢复当前任务之前处理其他等待的任务。其主要用途包括以下：'
- en: '**Fairness**: Ensures that long-running or tightly looping tasks don’t monopolize
    a thread, giving other tasks a chance to execute'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公平性**：确保长时间运行或紧密循环的任务不会独占线程，给其他任务执行的机会'
- en: '**Responsiveness**: Can be used to keep the UI responsive by allowing rendering
    or other UI tasks to run'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**：可以通过允许渲染或其他 UI 任务运行来保持 UI 的响应性'
- en: '**Advanced scenarios**: Useful in specific scenarios where fine-grained control
    over task execution order is required'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级场景**：在需要精细控制任务执行顺序的特定场景中很有用'
- en: This method introduces a scheduled point of asynchrony in the code, momentarily
    yielding the current task’s execution and allowing other pending tasks to proceed,
    thereby promoting a more responsive and interleaved execution of operations.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在代码中引入了一个异步点的预定位置，暂时放弃当前任务的执行，允许其他挂起的任务继续进行，从而促进操作更响应和交织的执行。
- en: How does C#’s memory model impact multithreading, and what key features of this
    model are important to understand?
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 的内存模型如何影响多线程，以及该模型的关键特性有哪些是重要的？
- en: 'C#’s memory model defines the order and visibility guarantees of memory operations
    across multiple threads. Key features to understand include the following:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: C# 的内存模型定义了跨多个线程的内存操作的顺序和可见性保证。以下是需要理解的关键特性：
- en: '**Order guarantees**: Within a single thread, C# guarantees a consistent order
    of execution, known as sequential consistency. However, when observed from multiple
    threads, operations might appear out of order unless proper synchronization is
    used.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序保证**：在单个线程中，C# 保证执行的一致顺序，称为顺序一致性。然而，从多个线程观察时，操作可能看起来顺序混乱，除非使用适当的同步。'
- en: '**Memory barriers**: These are implicit or explicit operations that prevent
    reordering and ensure memory visibility across threads. For instance, the **volatile**
    keyword and operations such as **Thread.MemoryBarrier()** introduce barriers.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存屏障**：这些是防止重排序并确保跨线程内存可见性的隐式或显式操作。例如，**volatile** 关键字和如 **Thread.MemoryBarrier()**
    这样的操作引入了屏障。'
- en: '**Volatile reads/writes**: The **volatile** keyword ensures that reads and
    writes to a field occur directly and are not cached, ensuring real-time visibility
    across threads.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易失性读取/写入**：**volatile** 关键字确保对字段的读取和写入是直接发生的，并且不会被缓存，确保跨线程的实时可见性。'
- en: '**Atomicity**: Some operations in C# are atomic (such as reading/writing a
    reference or most built-in numeric types), but compound operations (for example,
    increment) are not atomic unless specifically synchronized.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**: 在C#中，某些操作是原子的（例如读取/写入引用或大多数内置数值类型），但复合操作（例如增量操作）如果不是特别同步，则不是原子的。'
- en: As we draw a close to our intensive journey through this section, where we mastered
    the intricate landscape of concurrent programming in C#, we are poised to venture
    into the vital sphere of *garbage collection*. In this upcoming section, we will
    demystify the mechanisms of memory management in C#, focusing on the automated
    process of garbage collection that helps to reclaim memory occupied by objects
    that are no longer in use. Prepare to delve into the nuances of this essential
    system component, gaining insights that will empower you to develop applications
    with optimized memory usage and enhanced performance. Let’s continue to deepen
    our understanding of the sophisticated world of C# programming!
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们结束对这一章节的深入探索，在这一章节中我们掌握了C#并发编程的复杂领域，我们即将进入至关重要的*垃圾回收*领域。在接下来的章节中，我们将揭开C#内存管理机制的秘密，重点关注垃圾回收的自动化过程，该过程有助于回收不再使用的对象占用的内存。准备好深入探索这个关键系统组件的细微差别，获得能够帮助你开发具有优化内存使用和提升性能的应用程序的见解。让我们继续深化对C#编程复杂世界的理解！
- en: Garbage collection
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: As developers, we allocate memory for objects, data structures, and various
    other components, but what happens to this memory when it’s no longer in use?
    Enter the realm of the **garbage collector** (**GC**) – a silent guardian of memory
    management in the .NET ecosystem. This section will introduce you to the intricacies
    of the garbage collection process, elucidating how C# and .NET ensure efficient
    utilization and reclamation of memory resources. Delving deeper, you’ll learn
    about the inner workings of the GC, its generations, and how it identifies and
    cleans up unreferenced objects. While the GC operates mostly behind the scenes,
    understanding its behavior and mechanisms can be crucial for optimizing application
    performance, especially for resource-intensive applications. Journey with us as
    we demystify the GC, providing you with tools and knowledge to keep your applications
    running smoothly and efficiently.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们为对象、数据结构和各种其他组件分配内存，但当这些内存不再使用时会发生什么？进入垃圾回收器（**GC**）的领域——它是.NET生态系统内存管理的无声守护者。本节将向您介绍垃圾回收过程的复杂性，阐明C#和.NET如何确保内存资源的有效利用和回收。深入了解，您将了解GC的内部工作原理、其代际以及它如何识别和清理无引用对象。虽然GC主要在幕后操作，但了解其行为和机制对于优化应用程序性能至关重要，尤其是对于资源密集型应用程序。随着我们揭开GC的秘密，我们将为您提供工具和知识，以保持您的应用程序平稳高效地运行。
- en: What is the primary difference between the stack and heap in the context of
    memory management and garbage collection in C#?
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在C#的内存管理和垃圾回收的背景下，栈和堆之间的主要区别是什么？
- en: The stack is used for storing local variables, method execution details, and
    controlling program flow. It operates in a LIFO manner, and memory is automatically
    reclaimed when the method or block of code exits. The heap, on the other hand,
    is used for storing dynamically allocated memory such as objects. Memory on the
    heap is managed by the GC in C#. Objects in the heap exist until the GC determines
    that they are no longer reachable and reclaims the memory.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 栈用于存储局部变量、方法执行细节和控制程序流程。它以LIFO（后进先出）的方式操作，当方法或代码块退出时，内存会自动回收。另一方面，堆用于存储动态分配的内存，例如对象。在C#中，堆上的内存由垃圾回收器（GC）管理。堆上的对象存在，直到GC确定它们不再可达，并回收内存。
- en: How does .NET recognize that an object has no active references and is ready
    for garbage collection?
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET如何识别一个对象没有活动引用，并准备好进行垃圾回收？
- en: .NET uses a mark-and-sweep algorithm for garbage collection. Initially, all
    objects on the heap are considered *unreachable*. Starting with root objects (for
    example, global and static objects, local variables on the stack, and CPU registers),
    the GC traces and marks each object that is accessible. After the marking phase,
    any object that remains unmarked is considered **garbage** and is a candidate
    for collection. These unreachable objects are then swept or collected, freeing
    up the memory they occupied.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: .NET使用标记-清除算法进行垃圾回收。最初，堆上的所有对象都被认为是*不可达的*。从根对象开始（例如，全局和静态对象、堆栈上的局部变量和CPU寄存器），GC跟踪并标记每个可访问的对象。在标记阶段之后，任何未标记的对象都被认为是**垃圾**，是收集的候选对象。这些不可达的对象随后被清除或收集，释放它们占用的内存。
- en: Why are generations in garbage collection important, and how do they function?
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾回收中的代为什么重要，它们是如何工作的？
- en: '`0`, `1`, and `2`. Let’s take a closer look at these:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`0`、`1`和`2`。让我们更详细地看看这些：'
- en: '**Generation 0 (Gen 0)**: Contains short-lived objects, such as temporary variables.
    Collecting this generation is fast and occurs frequently.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第0代（Gen 0）**：包含短生命周期的对象，例如临时变量。收集这一代对象速度快且发生频率高。'
- en: '**Generation 1 (Gen 1)**: Acts as a buffer between short-lived objects and
    long-lived objects.'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第1代（Gen 1）**：在短生命周期对象和长生命周期对象之间充当缓冲区。'
- en: '**Generation 2 (Gen 2)**: Contains long-lived objects.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第2代（Gen 2）**：包含长生命周期对象。'
- en: The idea behind this approach is that most objects are short-lived. By collecting
    Gen 0 frequently, the GC can efficiently reclaim memory from short-lived objects
    without having to scan older generations. Objects that survive a collection are
    promoted to the next generation, and the GC checks older generations less frequently.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法背后的理念是大多数对象都是短生命周期的。通过频繁收集Gen 0，GC可以有效地从短生命周期对象中回收内存，而无需扫描更旧的代。在收集中存活的对象会被提升到下一代，GC会减少对旧代进行检查的频率。
- en: What is the difference between the “Finalize” and “Dispose” methods in memory
    management?
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理中“Finalize”和“Dispose”方法之间的区别是什么？
- en: 'Both `Finalize` and `Dispose` methods are mechanisms to release unmanaged resources,
    but they serve different purposes and are used in different contexts:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 两者`Finalize`和`Dispose`方法都是释放未管理资源的机制，但它们服务于不同的目的，并在不同的上下文中使用：
- en: '**Finalize**: The **Finalize** method is called by the GC before it reclaims
    the memory occupied by an object. It’s defined in the object’s destructor and
    is intended to release unmanaged resources that the object might be holding. However,
    relying on finalization has its pitfalls as you can’t predict when the GC will
    run, making it non-deterministic.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Finalize**：在GC回收对象占用的内存之前，会调用**Finalize**方法。它定义在对象的析构函数中，旨在释放对象可能持有的未管理资源。然而，依赖于最终化有其缺陷，因为您无法预测GC何时运行，这使得它是非确定性的。'
- en: '**Dispose**: The **Dispose** method is a part of the **IDisposable** interface.
    When implemented, it provides a deterministic way to release both managed and
    unmanaged resources. Typically, you’d call the **Dispose** method explicitly or
    use the object inside a **using** statement in C#, ensuring that **Dispose** gets
    called when the object goes out of scope. Using **Dispose** allows for timely
    resource cleanup, ensuring that resources such as file handles, database connections,
    and so on are released as soon as they are no longer needed.'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dispose**：**Dispose**方法是**IDisposable**接口的一部分。当实现时，它提供了一种确定性的方式来释放托管和非托管资源。通常，您会显式调用**Dispose**方法或在C#中使用对象在**using**语句中，确保当对象超出作用域时调用**Dispose**。使用**Dispose**允许及时清理资源，确保文件句柄、数据库连接等资源在不再需要时立即释放。'
- en: How can you signal to the GC about the need for a garbage collection?
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您如何向GC发出进行垃圾回收的需求信号？
- en: You can explicitly request the GC to perform a collection using the `GC.Collect()`
    method. However, it’s important to note that manually invoking garbage collection
    is usually discouraged. The GC is optimized to run at optimal times based on the
    application’s memory consumption patterns. Forcing a collection can disrupt these
    optimizations and potentially degrade performance.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`GC.Collect()`方法显式请求GC执行收集。然而，需要注意的是，手动调用垃圾回收通常是不被鼓励的。GC已优化，根据应用程序的内存消耗模式在最佳时间运行。强制收集可能会破坏这些优化并可能降低性能。
- en: What does “memory leak” mean in .NET, and how can garbage collection assist
    in detecting it?
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在.NET中，“内存泄漏”是什么意思，垃圾回收如何帮助检测它？
- en: A **memory leak** in .NET refers to situations where objects remain in memory
    even though they are no longer needed or accessible. While the GC is designed
    to automatically reclaim memory occupied by unreachable objects, it can’t free
    objects that still have active references. Therefore, even if an object is no
    longer in use but still has references pointing to it (for example, due to event
    handlers or static collections), it will not be collected, leading to memory leaks.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中的**内存泄漏**指的是对象在不再需要或可访问的情况下仍然保留在内存中的情况。虽然GC旨在自动回收不可达对象占用的内存，但它无法释放仍然有活动引用的对象。因此，即使对象不再使用，但仍然有引用指向它（例如，由于事件处理器或静态集合），它也不会被收集，从而导致内存泄漏。
- en: How can weak references help prevent objects from being locked by the GC?
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱引用如何帮助防止对象被GC锁定？
- en: Weak references allow you to hold a reference to an object without preventing
    that object from being collected by the GC. This can be useful when you want to
    maintain a cache or temporary reference to an object but don’t want that reference
    to be the sole reason the object remains in memory. When the only existing references
    to an object are weak references, the object becomes eligible for garbage collection.
    By using the `WeakReference` class in .NET, you can access the target object if
    it’s still in memory, but you don’t prevent the GC from collecting it when necessary.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 弱引用允许你在不阻止GC收集该对象的情况下持有对该对象的引用。这在你想保持对对象的缓存或临时引用，但又不想让这个引用成为对象保留在内存中的唯一原因时非常有用。当对象仅有的现有引用是弱引用时，该对象就符合垃圾收集的条件。通过使用.NET中的`WeakReference`类，你可以访问目标对象，如果它仍在内存中，但你不会阻止GC在必要时收集它。
- en: What is the purpose of the “GC.KeepAlive()”method, and when should it be used?
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “GC.KeepAlive()”方法的目的是什么，何时应该使用它？
- en: The `GC.KeepAlive()` method ensures that a specified object remains *alive*
    and is not collected by the GC until the method call. This can be useful for preventing
    premature garbage collection, especially for objects with significant finalization
    logic. For example, if an object holds a resource such as a file handle or network
    connection and its finalizer releases that resource, using `GC.KeepAlive()` can
    prevent the finalizer from running prematurely.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`GC.KeepAlive()`方法确保指定的对象在方法调用期间保持*活跃*，不会被GC收集。这可以用于防止过早的垃圾收集，特别是对于具有显著终结逻辑的对象。例如，如果一个对象持有资源，如文件句柄或网络连接，并且其终结器释放了该资源，使用`GC.KeepAlive()`可以防止终结器提前运行。'
- en: How do GC modes of operation (for example, workstation and server) influence
    its activity?
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GC的操作模式（例如，工作站和服务器）如何影响其活动？
- en: 'The GC in .NET operates in different modes to optimize for different scenarios:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中的垃圾回收器（GC）在不同的模式下运行，以优化不同的场景：
- en: '**Workstation mode**: Typically used for single-threaded applications or applications
    running on a single-core machine. It does not utilize parallelism for garbage
    collection and is designed to be less intrusive, prioritizing application responsiveness.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作站模式**：通常用于单线程应用程序或运行在单核机器上的应用程序。它不利用并行性进行垃圾收集，旨在减少干扰，优先考虑应用程序的响应性。'
- en: '**Server mode**: Optimized for multi-core systems and uses parallel garbage
    collection to maximize throughput. It’s suitable for server applications where
    performance and scalability are essential.'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器模式**：针对多核系统优化，并使用并行垃圾收集以最大化吞吐量。它适用于性能和可扩展性至关重要的服务器应用程序。'
- en: These modes adjust the GC’s behavior to better match the expected application
    workload and hardware.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式调整GC的行为，以更好地匹配预期的应用程序工作负载和硬件。
- en: What’s the difference between the Large Object Heap and the regular heap, and
    how does it impact garbage collection?
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大型对象堆与常规堆之间的区别是什么，它如何影响垃圾收集？
- en: 'The **Large Object Heap** (**LOH**) is a special heap in .NET’s memory management
    used to store objects that are 85,000 bytes or larger. The primary differences
    between LOH and a regular heap are set out here:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '**大型对象堆（LOH**）是.NET内存管理中的一个特殊堆，用于存储85,000字节或更大的对象。LOH与常规堆的主要区别如下：'
- en: LOH is not compacted as frequently as regular heaps. Compacting large objects
    can be performance-intensive.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LOH不像常规堆那样频繁地进行压缩。压缩大对象可能会对性能产生较大影响。
- en: Objects in LOH are collected during a Gen 2 garbage collection.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LOH中的对象在Gen 2垃圾收集期间被收集。
- en: Because of these characteristics, it’s essential to be cautious when allocating
    large objects frequently, as it can lead to memory fragmentation and increased
    Gen 2 collections.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些特性，频繁分配大对象时必须谨慎，因为这可能导致内存碎片化和Gen 2收集增加。
- en: What impact do pinned objects have on the operation of the GC, and what is the
    Pinned Object Heap?
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁定对象对GC操作有什么影响，什么是锁定对象堆？
- en: '**Pinned** objects are objects that the GC is instructed not to move during
    a memory compaction phase. This is essential when the memory address of an object
    needs to remain constant, typically when interfacing with native code. Pinned
    objects can disrupt the efficient compaction of memory and lead to fragmentation.
    The **Pinned Object Heap** (**POH**), introduced in .NET 5, is a dedicated segment
    for storing pinned objects, ensuring that they don’t interfere with regular heaps
    and providing more efficient management of pinned objects.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '**锁定**对象是GC被指示在内存压缩阶段不移动的对象。当对象的内存地址需要保持恒定时，这是必要的，通常是在与原生代码接口时。锁定对象可能会干扰内存的有效压缩并导致碎片化。在.NET
    5中引入的**锁定对象堆**（**POH**）是一个专门用于存储锁定对象的段，确保它们不会干扰常规堆，并提供更有效的锁定对象管理。'
- en: How does the presence of finalizers in objects impact the garbage collection
    process?
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象中存在终结器如何影响垃圾收集过程？
- en: Objects with finalizers complicate the garbage collection process because they
    require two garbage collection cycles for their complete cleanup. In the first
    cycle, when the object is detected as unreachable, its finalizer is called. The
    object is then moved to a list of finalized objects. Only in a subsequent garbage
    collection cycle is the object actually reclaimed. This means objects with finalizers
    stay in memory longer, which can potentially lead to increased memory usage if
    not managed correctly.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 带有终结器的对象会复杂化垃圾收集过程，因为它们需要两个垃圾收集周期才能完成清理。在第一个周期中，当对象被检测为不可达时，其终结器会被调用。然后，对象被移动到已终结对象列表中。只有在随后的垃圾收集周期中，对象才会真正被回收。这意味着带有终结器的对象在内存中停留的时间更长，如果不正确管理，可能会导致内存使用增加。
- en: How does the GC handle objects that are frequently created and destroyed (for
    instance, in a loop)?
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GC如何处理频繁创建和销毁的对象（例如，在循环中）？
- en: The GC employs generational collection. Objects that are frequently created
    and likely to be short-lived are placed in the younger generation (Gen 0). The
    idea is that it’s more efficient to collect from this generation (Gen 0) frequently,
    as many objects will become unreachable quickly. When garbage collection occurs
    for this generation, only a subset of the heap (the younger generation) is considered,
    making the process faster. Objects that survive multiple collections are promoted
    to older generations, which are collected less frequently.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: GC采用代收集。频繁创建且可能短暂存活的对象被放置在年轻代（Gen 0）。其理念是，从这一代（Gen 0）频繁收集更有效率，因为许多对象会很快变得不可达。当进行这一代的垃圾收集时，只考虑堆的一个子集（年轻代），这使得过程更快。存活多次收集的对象会被提升到较老的代，这些代收集的频率较低。
- en: How does the usage of unmanaged resources impact the GC, and how can one ensure
    their proper disposal?
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非托管资源的使用如何影响GC，以及如何确保它们得到适当的处理？
- en: '**Unmanaged** resources, such as file handles, database connections, or native
    memory, are not managed by the .NET GC. If not handled properly, they can lead
    to resource leaks. To ensure their proper disposal, follow these guidelines:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '**非托管**资源，如文件句柄、数据库连接或原生内存，不由.NET GC管理。如果不妥善处理，它们可能导致资源泄漏。为确保它们得到适当的处理，请遵循以下指南：'
- en: '**Implement the IDisposable interface**: This allows you to provide a **Dispose**
    method where you can release unmanaged resources.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现IDisposable接口**：这允许你提供一个**Dispose**方法，在其中你可以释放非托管资源。'
- en: '**Use a using statement**: This ensures that the **Dispose** method is called
    automatically when the object goes out of scope.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用using语句**：这确保了当对象超出作用域时，**Dispose**方法会自动被调用。'
- en: '**Use finalizers**: In situations where developers might forget to call **Dispose**,
    a finalizer (**~ClassName** method) can be used to release resources. However,
    relying solely on finalizers can introduce delays in resource cleanup, so it’s
    recommended to use them as a backup to the **Dispose** method.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用终结器**：在开发者可能忘记调用**Dispose**的情况下，可以使用终结器（**~ClassName**方法）来释放资源。然而，仅依赖终结器可能会引入资源清理的延迟，因此建议将其作为**Dispose**方法的备份使用。'
- en: Summary
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we embarked on a detailed journey through the intricate realms
    of C# programming, initiating a deep dive into collections and LINQ to foster
    adept data structure management. This was closely followed by a study of robust
    error management through exception handling and debugging, setting the stage for
    the exploration of dynamic asynchronous programming with `async` and `await`.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始了一段详细的旅程，深入 C# 编程的复杂领域，通过深入研究集合和 LINQ 来培养熟练的数据结构管理能力。紧接着，我们通过异常处理和调试来研究健壮的错误管理，为探索使用
    `async` 和 `await` 的动态异步编程奠定了基础。
- en: The narrative further unfolded to reveal the essentials of event-driven programming
    through delegates, events, and lambda expressions, paving the way to the versatile
    world of generics for crafting reusable and type-safe code. As we navigated toward
    the latter sections, readers could immerse themselves in the complexities of multithreading,
    offering insights into concurrent programming and efficient memory management
    through garbage collection.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 故事进一步展开，揭示了事件驱动编程的精髓，通过委托、事件和 lambda 表达式，为构建可重用和类型安全的代码的泛型世界铺平了道路。随着我们向章节的后半部分前进，读者可以沉浸在多线程的复杂性中，了解并发编程和通过垃圾回收进行高效内存管理的见解。
- en: This chapter serves as a precursor to [*Chapter 5*](B20871_05.xhtml#_idTextAnchor242),
    *Fundamentals Governing Maintainable and Efficient C# Programming*, in which readers
    will further enhance their expertise, equipped with a deepened understanding and
    refined skill set acquired from the exploration of advanced concepts delineated
    in this chapter.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 本章作为[第5章](B20871_05.xhtml#_idTextAnchor242)《指导可维护和高效 C# 编程的基本原理》的序言，读者将在其中进一步深化他们的专业知识，通过探索本章中阐述的高级概念，获得更深入的理解和精炼的技能集。
- en: Additional reading
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加阅读
- en: '*Parallel Programming and Concurrency with C# 10 and .NET 6*, by Alvin Ashcraft'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用 C# 10 和 .NET 6 进行并行编程和并发》*，作者 Alvin Ashcraft'
- en: '[https://www.packtpub.com/product/parallel-programming-and-concurrency-with-c-10-and-net-6/9781803243672](https://www.packtpub.com/product/parallel-programming-and-concurrency-with-c-10-and-net-6/9781803243672)'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/product/parallel-programming-and-concurrency-with-c-10-and-net-6/9781803243672](https://www.packtpub.com/product/parallel-programming-and-concurrency-with-c-10-and-net-6/9781803243672)'
- en: '*50 Algorithms Every Programmer Should Know - Second Edition*, by Imran Ahmad'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《程序员必知的50个算法 - 第二版》*，作者 Imran Ahmad'
- en: '[https://www.packtpub.com/product/50-algorithms-every-programmer-should-know-second-edition/9781803247762](https://www.packtpub.com/product/50-algorithms-every-programmer-should-know-second-edition/9781803247762)'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/product/50-algorithms-every-programmer-should-know-second-edition/9781803247762](https://www.packtpub.com/product/50-algorithms-every-programmer-should-know-second-edition/9781803247762)'
- en: Advanced C# Concepts
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 高级 C# 概念
- en: Multithreading – Creating and managing threads, synchronization primitives,
    and handling thread synchronization and communication
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程 – 创建和管理线程，同步原语，处理线程同步和通信
- en: Multithreading – Creating and managing threads, synchronization primitives,
    and handling thread synchronization and communication
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程 – 创建和管理线程，同步原语，处理线程同步和通信
- en: Multithreading – Creating and managing threads, synchronization primitives,
    and handling thread synchronization and communication
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程 – 创建和管理线程，同步原语，处理线程同步和通信
- en: Multithreading – Creating and managing threads, synchronization primitives,
    and handling thread synchronization and communication
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程 – 创建和管理线程，同步原语，处理线程同步和通信
