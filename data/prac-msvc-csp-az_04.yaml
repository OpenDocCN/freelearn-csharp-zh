- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Creating Libraries for Client Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为客户端应用程序创建库
- en: With the updates from the last chapter, the Game API is available to use – including
    access to the database. In this chapter, we’ll create a .NET library that can
    be used by all .NET client applications to access the service. Instead of the
    need to create HTTP requests with every client application, we create a library
    that can be shared.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上一章的更新，游戏API现在可供使用——包括对数据库的访问。在本章中，我们将创建一个.NET库，该库可以被所有.NET客户端应用程序用来访问服务。我们不需要为每个客户端应用程序创建HTTP请求，而是创建一个可以共享的库。
- en: 'In this chapter, you’ll do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将执行以下操作：
- en: Create a library to send HTTP requests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个发送HTTP请求的库
- en: Create a client console application to play a game using the library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用库创建一个客户端控制台应用程序来玩游戏
- en: Use the Microsoft Kiota tool to generate code based on the OpenAPI document
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Microsoft Kiota工具根据OpenAPI文档生成代码
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found in the GitHub repository at [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure).
    The source code folder `ch04` contains the code samples for this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub仓库[https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure)中找到。源代码文件夹`ch04`包含本章的代码示例。
- en: The service implementation from the previous chapter is stored in the `server`
    folder. There’s just a small change to the previous chapter with the models. The
    models contain annotations (`Required`, `MinLength`, and `MaxLength` attributes).
    This information shows up in the OpenAPI document and can be used on creating
    the client. You can use the file `Chapter04.server.sln` to open and run the solution.
    You need to start the service when running the client application. Based on your
    preference, you need to configure SQL Server or Azure Cosmos DB as discussed in
    the previous chapter. You can also use the in-memory repository instead so that
    you don’t need to have a database running. Change the configuration with the `appsettings.json`
    file based on your needs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章的服务实现存储在`server`文件夹中。与上一章相比，模型只有细微的改动。模型包含注解（`Required`、`MinLength`和`MaxLength`属性）。这些信息会出现在OpenAPI文档中，并在创建客户端时使用。你可以使用`Chapter04.server.sln`文件打开并运行解决方案。在运行客户端应用程序时，你需要启动服务。根据你的偏好，你需要配置SQL
    Server或Azure Cosmos DB，如前一章所述。你也可以使用内存中的存储库，这样你就不需要运行数据库。根据你的需求，使用`appsettings.json`文件更改配置。
- en: 'The new code is in the `client` folder. Here, you will find these projects:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码在`client`文件夹中。在这里，你可以找到以下项目：
- en: '`Codebreaker.GameApis.Client`: This is the new library that includes custom
    models and the `GamesClient` class, which sends HTTP requests to the service'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GameApis.Client`：这是一个包含自定义模型和`GamesClient`类的库，该类向服务发送HTTP请求'
- en: '`Codebreaker.Client.Console`: This is a new console application that references
    the client library and can be used to play the game'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.Client.Console`：这是一个新的控制台应用程序，它引用客户端库，可以用来玩游戏'
- en: '`Codebreaker.GamesApis.Kiota`: This is a client library that can be used as
    an alternative to `Codebreaker.GameApis.Client` with generated code'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GamesApis.Kiota`：这是一个客户端库，可以用作`Codebreaker.GameApis.Client`的替代品，并使用生成的代码'
- en: '`Codebreaker.Kiota.Console`: This is a console application that uses the Kiota
    client library'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.Kiota.Console`：这是一个使用Kiota客户端库的控制台应用程序'
- en: Creating a library to create HTTP requests
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个创建HTTP请求的库
- en: With a microservices team, a good practice is when the team is not only responsible
    to develop the complete service including the database access code, but also at
    least one of the client applications. With traditional development teams, client
    and server development is often spread across different teams. The issue with
    that is that the client and service are best created in collaboration. Creating
    the client, you’ll find answers missing from the services API. Here, a fast communication
    between the client and service developers helps.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个微服务团队中，一个好的做法是团队不仅负责开发包括数据库访问代码在内的完整服务，而且至少负责一个客户端应用程序。在传统的开发团队中，客户端和服务器开发通常分散在不同的团队中。问题在于客户端和服务最好是在协作中创建。创建客户端时，你会发现服务API中缺少答案。在这里，客户端和服务开发者之间的快速沟通有助于解决问题。
- en: Creating a library for the client allows us to reuse this functionality from
    all .NET clients; you can create clients with any .NET client technology, such
    as Blazor, WinUI, .NET MAUI, and others. In this chapter, we will just create
    a console application, but you can find clients using Blazor, WinUI, .NET MAUI,
    WPF, and Platform Uno in the GitHub organization at [https://github.com/codebreakerapp](https://github.com/codebreakerapp).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为客户端创建库允许我们从所有.NET客户端重用此功能；您可以使用任何.NET客户端技术创建客户端，例如Blazor、WinUI、.NET MAUI以及其他技术。在本章中，我们将仅创建一个控制台应用程序，但您可以在GitHub组织[https://github.com/codebreakerapp](https://github.com/codebreakerapp)中找到使用Blazor、WinUI、.NET
    MAUI、WPF和Platform Uno的客户端。
- en: 'To create the library to be used by client applications, we do the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建供客户端应用程序使用的库，我们执行以下操作：
- en: Create a library with multi-targeting support to support different .NET versions
    with the clients
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个支持多目标平台的库以支持不同.NET版本的客户端
- en: Inject the `HttpClient` with the main class the client interacts with.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`HttpClient`注入与客户端交互的主类中。
- en: Send HTTP requests to the games service.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向游戏服务发送HTTP请求。
- en: Create a NuGet package for easier use.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个NuGet包以方便使用。
- en: Creating a library with multi-targeting support
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建支持多目标平台的库
- en: 'We create the library for the client using the `dotnet` CLI:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`dotnet` CLI创建客户端库：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With this library, we need the model types for the data to transfer between
    the client and the service and a client class that does the HTTP requests to invoke
    the services API.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个库，我们需要模型类型以在客户端和服务之间传输数据，以及一个执行HTTP请求以调用服务API的客户端类。
- en: 'To support clients using different .NET versions, the library is configured
    with multi-targeting support:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持使用不同.NET版本的客户端，库被配置为支持多目标：
- en: Codebreaker.GameAPIs.Client/Codebreaker.GameAPIs.Client.csproj
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Client/Codebreaker.GameAPIs.Client.csproj
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Instead of the default entry, `TargetFramework`, an `s` is appended to contain
    a list of frameworks. With multiple frameworks added, multiple binaries are added
    when creating a NuGet package. It might be okay for you to create a library with
    .NET 6, which can also be used from .NET 7 and .NET 8 clients. Using multiple
    frameworks you can create optimized code based on the client version.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与默认入口`TargetFramework`不同，我们附加了一个`s`以包含框架列表。添加多个框架时，创建NuGet包时会添加多个二进制文件。对于您来说，创建一个可以由.NET
    7和.NET 8客户端使用的.NET 6库可能是可以的。使用多个框架，您可以基于客户端版本创建优化后的代码。
- en: 'An optimization is shown with the following code snippet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了优化示例：
- en: Codebreaker.GameAPIs.Client/Models/CreateGameRequest.cs
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Client/Models/CreateGameRequest.cs
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Generic attributes are new since C# 11\. The generic type of the `JsonStringEnumConverter`
    is new with .NET 8\. This generic version supports Native AOT compilation. The
    older version and the non-generic `JsonStringEnumConverter` uses reflection. Using
    the C# preprocessor directive `#if` and the predefined symbol `NET8_0_OR_GREATER`,
    different code gets compiled based on the framework version.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型属性是C# 11中引入的新特性。`JsonStringEnumConverter`的泛型类型从.NET 8开始引入。这个泛型版本支持原生AOT编译。较旧版本和非泛型的`JsonStringEnumConverter`使用反射。使用C#预处理器指令`#if`和预定义符号`NET8_0_OR_GREATER`，根据框架版本编译不同的代码。
- en: The models are mainly the same between the client and the service. Here, you
    might choose to move the models from the service-only library to a common library
    that is referenced both from the client and service applications. However, with
    client technologies, you might have other requirements based on validating and
    change notification. With the models of the client library, you can implement
    the interface `INotifyPropertyChanged`, which is used by different client technologies
    to update the user interface automatically if a change is notified. Later in this
    chapter, we’ll also create a library from the OpenAPI document created in [*Chapter
    2*](B21217_02.xhtml#_idTextAnchor031), which can be another reason not to create
    a shared library.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务之间的模型主要相同。在这里，您可能会选择将模型从仅服务库移动到被客户端和服务应用程序共同引用的通用库。然而，基于客户端技术，您可能还有其他基于验证和变更通知的要求。对于客户端库的模型，您可以实现`INotifyPropertyChanged`接口，该接口被不同的客户端技术用于在变更通知时自动更新用户界面。在本章的后面部分，我们还将从在[*第2章*](B21217_02.xhtml#_idTextAnchor031)中创建的OpenAPI文档创建库，这可能是不创建共享库的另一个原因。
- en: '`CreateGameRequest` is the class we need to send the request when starting
    the game:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateGameRequest`是我们启动游戏时需要发送请求的类：'
- en: Codebreaker.GameAPIs.Client/Models/CreateGameRequest.cs
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Client/Models/CreateGameRequest.cs
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `CreateGameRequest` contains the properties `GameType` and `PlayerName`,
    which are required to start the game. The `GamesQuery` class is used to send different
    query parameters to retrieve a filtered list of games based on the query:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateGameRequest` 包含 `GameType` 和 `PlayerName` 属性，这些属性是开始游戏所必需的。`GamesQuery`
    类用于发送不同的查询参数，以根据查询检索过滤后的游戏列表：'
- en: Codebreaker.GameAPIs.Client/Models/GamesQuery.cs
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Client/Models/GamesQuery.cs
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `AsUrlQuery` method converts the properties of the record to create HTTP
    query parameters as specified with the games API service and returns the combined
    query string. You might think about adding this method to the `Game` class. The
    `Game` class just defines the structure of the data representing a game. The `GamesQuery`
    class controls how its data can be converted into a URL query string.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsUrlQuery` 方法将记录的属性转换为根据游戏 API 服务指定的 HTTP 查询参数，并返回组合的查询字符串。你可能考虑将此方法添加到 `Game`
    类中。`Game` 类仅定义表示游戏的 数据结构。`GamesQuery` 类控制其数据如何转换为 URL 查询字符串。'
- en: Additionally, `CreateGameResponse`, `UpdateGameRequest`, `UpdateGameResponse`,
    `Game`, and `Move` are needed with this library. Check these types with the GitHub
    repo.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`CreateGameResponse`、`UpdateGameRequest`、`UpdateGameResponse`、`Game` 和 `Move`
    是使用此库所必需的。请使用 GitHub 仓库检查这些类型。
- en: Injecting the HttpClient class
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入 `HttpClient` 类
- en: The `GamesClient` class we create next is used to send requests to the games
    service. To use the `HttpClient` class, an object of this class can be injected.
    With the application using the library, this `HttpClient` needs to be configured
    with the base address (in [*Chapter 9*](B21217_09.xhtml#_idTextAnchor216), this
    will be extended with authentication).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来创建的 `GamesClient` 类用于向游戏服务发送请求。要使用 `HttpClient` 类，可以注入此类的对象。在使用库的应用程序中，此
    `HttpClient` 需要配置基本地址（在 [*第 9 章*](B21217_09.xhtml#_idTextAnchor216)，这将扩展到身份验证）。
- en: 'The implementation of the constructor of the `GamesClient` class is shown in
    the following code snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了 `GamesClient` 类构造函数的实现：
- en: Codebreaker.GameAPIs.Client/GamesClient.cs
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Client/GamesClient.cs
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With the constructor of the `GamesClient`, the injected `HttpClient` instance
    is assigned to a variable, and `JsonOptions` is configured. ASP.NET Core maps
    properties on JSON serialization to lowercase. With the options as defined here,
    casing is ignored, so the lowercase map is transferred to uppercase properties.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GamesClient` 的构造函数中，注入的 `HttpClient` 实例被分配给一个变量，并配置了 `JsonOptions`。ASP.NET
    Core 将 JSON 序列化时的属性映射到小写。根据这里定义的选项，忽略大小写，因此小写映射被传输到大写属性。
- en: Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t create a new instance of the `HttpClient` class with every request. Instead,
    injecting the client will shift the responsibility to creating instances to the
    calling application. With the dependency injection container, we’ll configure
    the `HttpClient` to be created from a factory.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在每次请求时创建新的 `HttpClient` 类实例。相反，注入客户端将创建实例的责任转移到调用应用程序。使用依赖注入容器，我们将配置 `HttpClient`
    以从工厂创建。
- en: Sending HTTP requests
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送 HTTP 请求
- en: Let’s send some requests to the service to retrieve information about games,
    start games, and set moves.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向服务发送一些请求以检索有关游戏、开始游戏和设置移动的信息。
- en: 'The first methods are used to retrieve game information:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的方法用于检索游戏信息：
- en: Codebreaker.GameAPIs.Client/GamesClient.cs
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Client/GamesClient.cs
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `GetGameAsync` method retrieves one game passing the identifier of the game.
    `GetGamesAsync` uses the previously created `GamesQuery` to create the URI for
    the service to send the HTTP GET request. `GetFromJsonAsync` is an extension method
    for the `HttpClient` class to send an HTTP GET request, checks for a successful
    status code using `EnsureSuccessStatusCode` with `HttpResponseMessage` (which
    throws an `HttpRequestException` if not successful), and uses the `System.Text.Json`
    deserializer to deserialize the stream from the response. When the `game-id` passed
    was not found, we want to return `null` instead of throwing an exception so this
    exception is caught.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetGameAsync` 方法通过传递游戏的标识符检索一个游戏。`GetGamesAsync` 使用先前创建的 `GamesQuery` 来创建用于发送
    HTTP GET 请求的服务 URI。`GetFromJsonAsync` 是 `HttpClient` 类的一个扩展方法，用于发送 HTTP GET 请求，使用
    `EnsureSuccessStatusCode` 与 `HttpResponseMessage` 检查成功状态码（如果失败则抛出 `HttpRequestException`），并使用
    `System.Text.Json` 反序列化器从响应流中反序列化。当传递的 `game-id` 未找到时，我们希望返回 `null` 而不是抛出异常，因此捕获此异常。'
- en: 'Sending a request to start a game is implemented with the `StartGameAsync`
    method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `StartGameAsync` 方法实现启动游戏的请求：
- en: Codebreaker.GameAPIs.Client/GamesClient.cs
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Client/GamesClient.cs
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `StartGamesAsync` method sends an HTTP POST request after creating the
    data that should be sent with the HTTP body: `CreateGameRequest`. After receiving
    a success response, the `ReadFromJsonAsync` extension method deserializes the
    returned HTTP body and returns the methods result using a tuple.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartGamesAsync` 方法在创建应该随 HTTP 主体一起发送的数据后发送一个 HTTP POST 请求：`CreateGameRequest`。在收到成功响应后，`ReadFromJsonAsync`
    扩展方法反序列化返回的 HTTP 主体，并使用元组返回方法的结果。'
- en: 'To send a games move, the game is updated using an HTTP PATCH request:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送游戏移动，使用 HTTP PATCH 请求更新游戏：
- en: Codebreaker.GameAPIs.Client/GamesClient.cs
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Client/GamesClient.cs
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Sending an HTTP PATCH request is very similar to sending a POST request: the
    `UpdateGameRequest` object is created to send this JSON-serialized information
    to the server. Receiving the result, the body is deserialized to an `UpdateGameResponse`
    object.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 发送 HTTP PATCH 请求与发送 POST 请求非常相似：创建 `UpdateGameRequest` 对象以将此 JSON 序列化的信息发送到服务器。接收结果后，将主体反序列化为
    `UpdateGameResponse` 对象。
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: With REST APIs, a HTTP PUT request is usually used to update a resource, while
    HTTP PATCH is used for a partial update. Here, the game resource is updated, but
    not by sending the complete game and just some partial data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 REST API，通常使用 HTTP PUT 请求更新资源，而 HTTP PATCH 用于部分更新。在这里，游戏资源被更新，但不是通过发送完整的游戏，而是只发送一些部分数据。
- en: Creating a NuGet Package
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 NuGet 包
- en: 'To create a NuGet package from the library, you can use the `dotnet` CLI:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从库中创建 NuGet 包，您可以使用 `dotnet` CLI：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To see the content of the NuGet package, you can rename it to `zip`. For easy
    use of this package, you can add it to a shared folder and configure the Visual
    Studio NuGet Package manager to reference this folder. You can also publish the
    package to Azure DevOps Artifacts. Referencing this, you can create a `nuget.config`
    file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 NuGet 包的内容，您可以将其重命名为 `zip`。为了方便使用此包，您可以将其添加到共享文件夹中，并配置 Visual Studio NuGet
    包管理器以引用此文件夹。您还可以将包发布到 Azure DevOps Artifacts。通过引用此，您可以创建一个 `nuget.config` 文件：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With the generated `nuget.config` file, you need to specify the shared folder
    or the link to your Azure DevOps Artifacts feed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成的 `nuget.config` 文件，您需要指定共享文件夹或您的 Azure DevOps Artifacts 源的链接。
- en: 'This is a `nuget.config` file created using `dotnet new` with one additional
    entry for a custom feed:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 `dotnet new` 创建的 `nuget.config` 文件，并添加了一个自定义源条目：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With this NuGet configuration file, the entry `<clear />` removes all the default
    feeds. The `nuget` key with the first `add` element references the default feed
    of the NuGet server. Similarly, you can add custom feeds with other keys and links
    to the package feeds on the server.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此 NuGet 配置文件，`<clear />` 条目删除了所有默认源。带有第一个 `add` 元素的 `nuget` 键引用了 NuGet 服务器的默认源。同样，您可以使用其他键和链接添加自定义源到服务器上的包源。
- en: For the Codebreaker solution, you can look for the NuGet package `Cninnovation.Codebreaker.Client`,
    which is available on the NuGet server. After making NuGet packages available
    on NuGet, a readme file, a license, and some more metadata should be added to
    the package. See further readings for more information.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Codebreaker 解决方案，您可以在 NuGet 服务器上查找 `Cninnovation.Codebreaker.Client` NuGet
    包。在 NuGet 上提供 NuGet 包后，应在包中添加一个说明文件、许可证和一些其他元数据。有关更多信息，请参阅进一步阅读。
- en: Creating a client application
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建客户端应用程序
- en: 'Having the library in place, let’s create a client application. A simple console
    application fulfils the purpose to play the game. With the sample application
    of this chapter, the NuGet packages `Microsoft.Extensions.Hosting`, `Microsoft.Extensions.Http.Resiliency`,
    and `Spectre.Console.Cli` are added. Navigate to the folder of the solution file
    before invoking these commands:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在库已经就绪的情况下，让我们创建一个客户端应用程序。一个简单的控制台应用程序可以满足玩游戏的目的。在使用这些命令之前，请导航到解决方案文件的文件夹：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`Microsoft.Extensions.Hosting` will be used for a dependency injection container
    and configuration support and `Microsoft.Extensions.Http.Resilience` is the package
    offering an `HttpClientFactory`. Of course, the library created previously needs
    to be referenced as well.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Hosting` 将用于依赖注入容器和配置支持，而 `Microsoft.Extensions.Http.Resiliency`
    是提供 `HttpClientFactory` 的包。当然，之前创建的库也需要被引用。'
- en: To interact with the user, you can use simple `Console.ReadLine` and `Console.WriteLine`
    statements. With the sample application available in the books GitHub repo, the
    NuGet package `Spectre.Console.Cli` is used. Just check the source code for more
    information.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要与用户交互，可以使用简单的`Console.ReadLine`和`Console.WriteLine`语句。在书中GitHub仓库提供的示例应用程序中，使用了NuGet包`Spectre.Console.Cli`。只需检查源代码以获取更多信息。
- en: Configuring the dependency injection container
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置依赖注入容器
- en: 'The top-level statements of the application are shown with the following code
    snippet:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的最高级语句如下所示：
- en: Codebreaker.Console/Program.cs
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Console/Program.cs
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `CreateApplicationBuilder` of the `Host` class configures the dependency
    injection container and has default configuration for the application configuration
    providers and the logging providers. The `AddHttpClient` extension method is implemented
    with the HttpClient factory. Here, the generic method overload is used to specify
    the `GamesClient` class that will receive the `HttpClient` injected as specified
    with the `configureClient` lambda expression. The `BaseAddress` of the `HttpClient`
    is configured to have the `GamesApiUrl` configuration value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Host`类的`CreateApplicationBuilder`配置了依赖注入容器，并为应用程序配置提供者和日志提供者提供了默认配置。`AddHttpClient`扩展方法使用HttpClient工厂实现。在这里，使用泛型方法重载指定了将接收通过`configureClient`lambda表达式指定的`HttpClient`注入的`GamesClient`类。`HttpClient`的`BaseAddress`配置为具有`GamesApiUrl`配置值。'
- en: 'For the configuration, we create the `appsettings.json` configuration file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于配置，我们创建了一个`appsettings.json`配置文件：
- en: Codebreaker.Console/appsettings.json
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Console/appsettings.json
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `GamesApiUrl` key is configured to contain the address of the Games API
    service. To not mess up logging with the console output for the game play, the
    log level is configured to only log warning, error, and critical error messages.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`GamesApiUrl`键配置为包含游戏API服务的地址。为了不将游戏播放的控制台输出与日志混淆，日志级别配置为仅记录警告、错误和关键错误消息。'
- en: Interacting with the user
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与用户交互
- en: 'The interaction with the user and the invocation of the service happens via
    the `Runner` class. Here, the previously created `GamesClient` is injected into
    the primary constructor:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与用户交互和服务调用是通过`Runner`类实现的。在这里，之前创建的`GamesClient`被注入到主要构造函数中：
- en: Codebreaker.Console/Runner.cs
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.Console/Runner.cs
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `RunAsync` method first asks the user what to do next. The main options
    are to play a game, to show the status of a single game, to show a list of games,
    or to delete a game. This code snippet makes use of the `Inputs` class, which
    in turn uses the `AnsiConsole` class from the mentioned NuGet package `Spectre.Console.Cli`.
    With this, you get a nice console user interface, as shown in *Figure 4**.1*,
    with easy selections. Depending on what you used for interacting with the user,
    your user interface might look different.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`RunAsync`方法首先询问用户下一步要做什么。主要选项是玩游戏、显示单个游戏的状态、显示游戏列表或删除游戏。此代码片段使用了`Inputs`类，该类又使用了来自提到的NuGet包`Spectre.Console.Cli`的`AnsiConsole`类。通过这种方式，您可以得到一个如图4**.1*所示的漂亮的控制台用户界面，具有简单的选择。根据您用于与用户交互的方式，您的用户界面可能看起来不同。'
- en: To run a game, first start the server before starting the client. With the client,
    select **Play** (*Figure 4**.1*).
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行游戏，首先在启动客户端之前启动服务器。使用客户端，选择**Play**（*图4**.1*）。
- en: '![Figure 4.1 – Console output to select a main task](img/B21217_04_01.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 控制台输出以选择主任务](img/B21217_04_01.jpg)'
- en: Figure 4.1 – Console output to select a main task
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 控制台输出以选择主任务
- en: Next, select a game type (*Figure 4**.2*), for example, **Game6x4**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择游戏类型（*图4**.2*），例如，**Game6x4**。
- en: '![Figure 4.2 – Selecting the game type](img/B21217_04_02.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 选择游戏类型](img/B21217_04_02.jpg)'
- en: Figure 4.2 – Selecting the game type
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 选择游戏类型
- en: Enter a player name (*Figure 4**.3*) and enter all the colors needed for a single
    move.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入玩家名称（*图4**.3*）并输入单次移动所需的所有颜色。
- en: '![Figure 4.3 – Entering the name and selecting the colors depending on the
    game type](img/B21217_04_03.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 输入名称并根据游戏类型选择颜色](img/B21217_04_03.jpg)'
- en: Figure 4.3 – Entering the name and selecting the colors depending on the game
    type
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 输入名称并根据游戏类型选择颜色
- en: '*Figure 4**.4* shows the result of the move (here with three colors correct
    but in the wrong positions) and the start of the next move. Repeat this until
    you solve the codes.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*图4**.4*显示了移动的结果（这里用三种颜色正确但位置错误）和下一个移动的开始。重复此操作直到解决代码。'
- en: '![Figure 4.4 – Moving the result and the next move](img/B21217_04_04.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 移动结果和下一步操作](img/B21217_04_04.jpg)'
- en: Figure 4.4 – Moving the result and the next move
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 移动结果和下一步操作
- en: 'The result of a successful move is shown in *Figure 4**.5*:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 成功移动的结果在 *图 4.5* 中显示：
- en: '![Figure 4.5 – Game results](img/B21217_04_05.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 游戏结果](img/B21217_04_05.jpg)'
- en: Figure 4.5 – Game results
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 游戏结果
- en: From there, you can repeat this to play another game or query for the list of
    games. From the list of games, you can get a game identifier and query for a single
    game passing the identifier.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，您可以重复此操作来玩另一场游戏或查询游戏列表。从游戏列表中，您可以获取游戏标识符并查询单个游戏，通过传递标识符。
- en: Using Microsoft Kiota to create a client
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Microsoft Kiota 创建客户端
- en: Running the API service generating the OpenAPI document (this was done in [*Chapter
    2*](B21217_02.xhtml#_idTextAnchor031)), we can leverage this information, and
    create the client code automatically. With the sample code of this chapter, the
    OpenAPI document is stored with the file `gamesapi-swagger.json`, which you can
    reference without starting the service.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 运行生成 OpenAPI 文档的 API 服务（这是在 [*第 2 章*](B21217_02.xhtml#_idTextAnchor031) 中完成的），我们可以利用这些信息，并自动创建客户端代码。本章的示例代码中，OpenAPI
    文档存储在文件 `gamesapi-swagger.json` 中，您可以在不启动服务的情况下引用它。
- en: 'One option with Visual Studio is to use **Add** | **Connected Client** and
    add a service reference to an OpenAPI document. But this option (at the time of
    this writing) has some limitations:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 的一个选项是使用 **添加** | **连接客户端** 并将服务引用添加到 OpenAPI 文档。但这个选项（在撰写本文时）有一些限制：
- en: It still uses the Newtonsoft Json serializer, whereas the new `System.Text.Json`
    one is faster and uses less memory
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它仍然使用 Newtonsoft Json 序列化器，而新的 `System.Text.Json` 序列化器更快且占用内存更少
- en: The client implementation makes use of strings instead of streams, which can
    result in objects in the large object heap
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端实现使用字符串而不是流，这可能导致大对象堆中的对象
- en: As you’ve seen in this chapter, creating a custom library to create HTTP requests
    is not that hard and can be optimized for your own domain.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在本章中看到的，创建一个用于创建 HTTP 请求的自定义库并不难，并且可以针对您的领域进行优化。
- en: 'But now there’s another option that should be considered: Microsoft Kiota(https://learn.microsoft.com/openapi/kiota/).
    Microsoft Kiota is a command-line tool that offers code generation from the OpenAPI
    for several languages including Java, PHP, Python, Typescript, C#, and many others.
    Let’s give this a chance.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在还有一个应该考虑的选项：Microsoft Kiota(https://learn.microsoft.com/openapi/kiota/)。Microsoft
    Kiota 是一个命令行工具，它为包括 Java、PHP、Python、TypeScript、C# 在内的多种语言提供从 OpenAPI 生成代码的功能。让我们试一试。
- en: Installing Kiota
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Kiota
- en: Kiota is available as a `dotnet` tool. We install this tool as part of the new
    library for another class library project.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Kiota 作为 `dotnet` 工具提供。我们将此工具作为新库的一部分安装到另一个类库项目中。
- en: 'The library is created with the following commands. Run these commands from
    the `solution` folder:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建库。请在 `solution` 文件夹中运行这些命令：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Using Kiota, we also need to add some Kiota NuGet packages for different serializers
    and a Kiota HTTP client library. The Kiota tool is installed with the project:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kiota，我们还需要为不同的序列化器和 Kiota HTTP 客户端库添加一些 Kiota NuGet 包。Kiota 工具与项目一起安装：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Generating Code with Kiota
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Kiota 生成代码
- en: 'After the Kiota tool is installed, we can generate the code using the OpenAPI
    document `gamesapi-swagger.json`. This file is available in the `ch04` folder:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 Kiota 工具后，我们可以使用 OpenAPI 文档 `gamesapi-swagger.json` 生成代码。此文件位于 `ch04` 文件夹中：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using these options, source code is generated using the referenced OpenAPI document
    `gamesapi-swagger.json`, the generated files are stored in the subdirectory `codebreaker`,
    C# is used for the code generation, the main class to do the HTTP requests is
    named `GamesAPIClient`, and the namespace for all the generated code is `Codebreaker.Client`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些选项，将使用引用的 OpenAPI 文档 `gamesapi-swagger.json` 生成源代码，生成的文件存储在子目录 `codebreaker`
    中，代码生成使用 C# 语言，执行 HTTP 请求的主要类命名为 `GamesAPIClient`，所有生成的代码的命名空间为 `Codebreaker.Client`。
- en: Note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Looking at the generated code, you’ll see that Kiota-generated code is not using
    the same coding convention as used in this book or as the .NET team is using.
    For example, the opening of curly braces is done in the same line as the method
    name, which is a convention used with many JavaScript programs. If you use Visual
    Studio, you can easily change this with the complete program using the context
    menu in Solution Explorer, navigating to **Analyze and Code Cleanup** | **Run
    Code Cleanup**. You might need to configure your preferences with code cleanup
    first.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 查看生成的代码，你会发现 Kiota 生成的代码并没有使用与本书或 .NET 团队使用的相同的编码约定。例如，花括号的打开与方法名在同一行，这是许多 JavaScript
    程序中使用的约定。如果你使用 Visual Studio，你可以通过在解决方案资源管理器中的上下文菜单中导航到 **分析并清理代码** | **运行代码清理**
    来轻松地使用整个程序更改此约定。你可能需要首先配置代码清理的首选项。
- en: The types created using Kiota are the models (using the `schemas` within OpenAPI)
    and request builders (using the `paths` where the requests are defined). Check
    the book repository for the generated code files.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kiota 创建的类型是模型（使用 OpenAPI 中的 `schemas`）和请求构建器（使用定义请求的 `paths`）。请检查书籍仓库以获取生成的代码文件。
- en: Exploring the Kiota-generated models
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索 Kiota 生成的模型
- en: 'For all the requests and responses and all the types specified within the schemas,
    Kiota generates classes in the `Models` directory. Let’s have a look at the `CreateGameRequest`
    class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有请求、响应以及 schemas 中指定的所有类型，Kiota 在 `Models` 目录中生成类。让我们看看 `CreateGameRequest`
    类：
- en: Codebreaker.GamesAPIs.KiotaClient/codebreaker/Models/CreateGameRequest.cs
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GamesAPIs.KiotaClient/codebreaker/Models/CreateGameRequest.cs
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The model types implement the `IParsable` interface. This is not the `System.IParsable`
    interface, but a version from the Kiota library in the namespace `Microsoft.Kiota.Abstractions.Serialization`.
    This interface defines instance members `GetFieldDeserializers` and `Serialize`.
    With this, Kiota offers an abstraction layer, which allows for the use of different
    serializers.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 模型类型实现了 `IParsable` 接口。这不是 `System.IParsable` 接口，而是来自 `Microsoft.Kiota.Abstractions.Serialization`
    命名空间中的 Kiota 库的版本。此接口定义了实例成员 `GetFieldDeserializers` 和 `Serialize`。通过这种方式，Kiota
    提供了一个抽象层，允许使用不同的序列化器。
- en: Another important aspect that needs mentioning is that all the properties of
    the model types are declared to be nullable. While EF Core supports nullability
    to map non-nullable members to be required in the database, this annotation is
    not used when generating the OpenAPI document using the minimal APIs. Adding the
    `Required` attribute to the models on the server adds `required`. Other annotations
    such as `MaxLength` and `MinLength` are mapped as well with `maxLength` and `minLength`,
    as you can see with `gamesapi-swagger.json`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要提及的重要方面是，所有模型类型的属性都被声明为可空的。虽然 EF Core 支持可空性，可以将非可空成员映射到数据库中的必填项，但在使用最小
    API 生成 OpenAPI 文档时，这个注解并未被使用。在服务器上的模型上添加 `Required` 属性会增加 `required`。其他注解，如 `MaxLength`
    和 `MinLength`，也被映射为 `maxLength` 和 `minLength`，正如你在 `gamesapi-swagger.json` 中所看到的。
- en: However, many APIs don’t pay attention to nullability. With the OpenAPI definition
    too, it’s also not exlpicitly specified how strict nullability should be enforced.
    Depending on the context where the model is used, information can still be left
    out from the server, and the data is not sent.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多 API 并没有注意可空性。在 OpenAPI 定义中，也没有明确指定如何强制执行严格的可空性。根据模型使用的上下文，信息仍然可能从服务器中遗漏，并且数据没有被发送。
- en: 'Here is a discussion about the Kiota implementation: https://github.com/microsoft/kiota/issues/2594'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于 Kiota 实现的讨论：[https://github.com/microsoft/kiota/issues/2594](https://github.com/microsoft/kiota/issues/2594)
- en: With the next major version of the OpenAPI specification, this might change.
    With the decisions made for the current Kiota implementation, Kiota is on the
    safe side to declare all the model properties as nullable, but this also means
    that we need to check for `null`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 随着下一个主要版本的 OpenAPI 规范，这可能会改变。对于当前 Kiota 实现所做的决策，Kiota 可以安全地将所有模型属性声明为可空的，但这同时也意味着我们需要检查
    `null`。
- en: Exploring the Kiota-generated request builders
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索 Kiota 生成的请求构建器
- en: 'The goal of request builders is to easily create requests. Let’s look at some
    of the generated code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请求构建器的目标是轻松创建请求。让我们看看一些生成的代码：
- en: Codebreaker.GamesAPIs.KiotaClient/codebreaker/GamesAPIClient.cs
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GamesAPIs.KiotaClient/codebreaker/GamesAPIClient.cs
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All the request builders derive from the base class, `BaseRequestBuilder`. The
    `GamesApiClient` class, where the name was specified with the code generation,
    is the request builder that needs to be initiated to communicate with the Games
    API. In the constructor, you can see default serializers and deserializers configured.
    Here, Kiota gives another flexibility.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有请求构建器都继承自基类 `BaseRequestBuilder`。通过代码生成指定名称的 `GamesApiClient` 类是需要初始化以与 Games
    API 通信的请求构建器。在构造函数中，可以看到配置了默认的序列化和反序列化器。在这里，Kiota 提供了更多的灵活性。
- en: 'The `Games` property of `GamesApiClient` returns another request builder: `GamesRequestBuilder`.
    This builder is in the `GamesRequestBuilder.cs` source file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`GamesApiClient` 的 `Games` 属性返回另一个请求构建器：`GamesRequestBuilder`。此构建器位于 `GamesRequestBuilder.cs`
    源文件中：'
- en: Codebreaker.GamesAPIs.KiotaClient/codebreaker/Games/GamesRequestBuilder.cs
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GamesAPIs.KiotaClient/codebreaker/Games/GamesRequestBuilder.cs
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This request builder is then used to invoke requests of the games API. Methods
    implemented by this request builder are `GetAsync` and `PostAsync`. The `GetAsync`
    method is used to retrieve a list of games with query parameters. `PostAsync`
    sends a POST request with the generated `CreateGameRequest` model.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此请求构建器随后用于调用游戏 API 的请求。此请求构建器实现的方法有 `GetAsync` 和 `PostAsync`。`GetAsync` 方法用于通过查询参数检索游戏列表。`PostAsync`
    使用生成的 `CreateGameRequest` 模型发送 POST 请求。
- en: To get a single game, update a game by sending a game move, and delete a game,
    the games API needs a game identifier. With Kiota, this is solved by offering
    an indexer with `GamesRequestBuilder`, which in turn returns another request builder,
    `GameItemsRequestBuilder`. Here, a fluent API can be used to pass a game identifier
    and invoke the `GetAsync` and `PutAsync` methods.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取单个游戏、通过发送游戏移动更新游戏以及删除游戏，游戏 API 需要一个游戏标识符。通过 Kiota，这是通过提供 `GamesRequestBuilder`
    的索引器来解决的，它反过来返回另一个请求构建器 `GameItemsRequestBuilder`。在这里，可以使用流畅的 API 传递游戏标识符并调用 `GetAsync`
    和 `PutAsync` 方法。
- en: Let’s implement another console application to use this generated code in the
    next section.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现另一个控制台应用程序以使用此生成的代码。
- en: Using the Kiota-generated code
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Kiota 生成的代码
- en: The Kiota-generated code is used with the console application `Codebreaker.KiotaConsole`.
    With big parts, the code of this application is similar to the console application
    from before. Mainly the invocations to the service, which are done with the `Runner`
    class, are now replaced and the dependency injection container configuration is
    changed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Kiota 生成的代码与控制台应用程序 `Codebreaker.KiotaConsole` 一起使用。在大部分部分，该应用程序的代码与之前的控制台应用程序类似。主要的变化是，使用
    `Runner` 类对服务的调用现在被替换，并且依赖注入容器配置已更改。
- en: 'The HttpClient factory is no longer registered with the DI container, as shown
    in the following code snippet:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: HttpClient 工厂不再注册到 DI 容器中，如下代码片段所示：
- en: Codebreaker.KiotaConsole/Program.cs
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.KiotaConsole/Program.cs
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Other than removing the code for the `HttpClient` configuration, the base address
    is now configured to supply values for the `RunnerOptions` class. This class just
    defines the `GamesApiUrl` property to specify the base address for the games service.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了移除 `HttpClient` 配置的代码外，现在基本地址被配置为为 `RunnerOptions` 类提供值。该类仅定义了 `GamesApiUrl`
    属性以指定游戏服务的基地址。
- en: 'The constructor of the `Runner` class where the options are passed is shown
    in the next code snippet:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Runner` 类的构造函数，其中传递了选项，将在下一个代码片段中展示：'
- en: Codebreaker.KiotaConsole/Runner.cs
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.KiotaConsole/Runner.cs
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With the implementation of the `Runner` constructor, the `GamesAPIClient` class
    is instantiated. This class receives `HttpClientRequestAdapter`, which has the
    base address of the service configured. The constructor of `HttpClientRequestAdapter`
    receives an object implementing the `IAuthenticationProvider` interface. Here,
    `AnonymousAuthenticationProvider` is used as no authentication is needed. Kiota
    offers various authentication providers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 `Runner` 构造函数时，实例化了 `GamesAPIClient` 类。该类接收配置了服务基本地址的 `HttpClientRequestAdapter`。`HttpClientRequestAdapter`
    的构造函数接收一个实现 `IAuthenticationProvider` 接口的对象。在这里，使用 `AnonymousAuthenticationProvider`
    因为不需要认证。Kiota 提供了各种认证提供者。
- en: 'Sending a GET request with query parameters to get a list of games, you invoke
    the `GetAsync` method of `GamesRequestBuilder`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送带有查询参数的 GET 请求以获取游戏列表，你将调用 `GamesRequestBuilder` 的 `GetAsync` 方法：
- en: Codebreaker.KiotaConsole/Runner.cs
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.KiotaConsole/Runner.cs
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `Games` property returns the generated `GamesRequestBuilder`, which allows
    us to invoke the `GetAsync` method passing query parameters. Kiota offers its
    own `Date` type within the `Microsoft.Kiota.Abstractions` namespace, which represents
    the date-only part of `DateTime`. Today, .NET offers `DateOnly`, but this type
    is not available with .NET Standard 2.0, which is also supported by Kiota.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Games`属性返回生成的`GamesRequestBuilder`，这允许我们通过传递查询参数来调用`GetAsync`方法。Kiota在`Microsoft.Kiota.Abstractions`命名空间内提供了自己的`Date`类型，它代表`DateTime`的仅日期部分。今天，.NET提供了`DateOnly`类型，但这个类型在.NET
    Standard 2.0中不可用，而Kiota也支持.NET Standard 2.0。'
- en: 'Starting a game is done by sending a POST request, as shown in the next snippet:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 开始游戏是通过发送POST请求来完成的，如下面的代码片段所示：
- en: Codebreaker.KiotaConsole/Runner.cs
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.KiotaConsole/Runner.cs
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Starting the game, the user input for the player name and the game type are
    assigned to the `CreateGameRequest` object. This model type is then passed with
    the invocation of the `PostAsync` method to start a game and to receive `CreateGameResponse`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 开始游戏时，玩家名称和游戏类型的用户输入被分配给`CreateGameRequest`对象。然后，通过调用`PostAsync`方法来启动游戏并接收`CreateGameResponse`，将此模型类型传递。
- en: 'Retrieving a single game passing the game identifier is shown in the next code
    snippet:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了通过传递游戏标识符获取单个游戏：
- en: Codebreaker.KiotaConsole/Runner.cs
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.KiotaConsole/Runner.cs
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Retrieving a single game, updating the game with a HTTP PATCH request, and deleting
    a game with the HTTP DELETE request all need the game identifier as the query
    parameter. To use this, Kiota offers an indexer passing `game-id` and continuing
    with a fluent API. To retrieve a single game, the `GetAsync` method is used. Patching
    and deleting games are very similar.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 获取单个游戏、使用HTTP PATCH请求更新游戏以及使用HTTP DELETE请求删除游戏都需要将游戏标识符作为查询参数。为了使用这个功能，Kiota提供了一个传递`game-id`并继续使用流畅API的索引器。要获取单个游戏，使用`GetAsync`方法。修补和删除游戏非常相似。
- en: With this information, you can use the Kiota-generated code and write the implementation
    to update the game by sending a game move with the `PostAsync` method.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些信息，你可以使用Kiota生成的代码，并编写实现来通过发送游戏移动来使用`PostAsync`方法更新游戏。
- en: Using the new client, you can run the game in the same way as shown before!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的客户端，你可以以之前展示的方式运行游戏！
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Working through this chapter, you’ll have a running client console application
    to run the game. We used the `HttpClient` class to send requests to the games
    service. To reuse this with different client technologies, we created a library.
    For efficient use of the `HttpClient` class, you learned to use the HttpClient
    factory.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章内容的过程中，你将拥有一个运行中的客户端控制台应用程序来运行游戏。我们使用了`HttpClient`类向游戏服务发送请求。为了能够与不同的客户端技术重用这一功能，我们创建了一个库。为了高效地使用`HttpClient`类，你学习了如何使用HttpClient工厂。
- en: Instead of implementing the models on your own, you learned using Microsoft
    Kiota to create code from the OpenAPI definition. With your own scenarios, you
    can now decide what’s the best option for you.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是自己实现模型，你学习了使用Microsoft Kiota从OpenAPI定义创建代码。在你的自己的场景中，你现在可以决定对你来说最好的选项是什么。
- en: Before reading the next chapter, you can reuse this newly created library and
    create clients of your choice such as Blazor, WinUI, or .NET MAUI. While these
    frameworks are outside of the scope of this book, you can check [https://github.com/codebreakerapp](https://github.com/codebreakerapp)
    for more clients available.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读下一章之前，你可以重用这个新创建的库，并创建你选择的客户端，例如Blazor、WinUI或.NET MAUI。虽然这些框架超出了本书的范围，但你可以在[https://github.com/codebreakerapp](https://github.com/codebreakerapp)查看更多可用的客户端。
- en: No matter what client you implement, before diving into the next chapter, it’s
    well deserved to play one more game—this time with your own created client application.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你实现什么客户端，在深入下一章之前，玩一次游戏是值得的——这次是用你自己的客户端应用程序。
- en: In the next chapter, the focus will be on the services again; we’ll host the
    service application (and another service) with a Docker container. This new service
    will also use the HTTP client created in this chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将再次关注服务；我们将使用Docker容器托管服务应用程序（以及另一个服务）。这个新的服务也将使用本章创建的HTTP客户端。
- en: Further reading
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following links:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章讨论的主题，你可以参考以下链接：
- en: '`HttpClient` guidelines: https://learn.microsoft.com/dotnet/fundamentals/networking/http/httpclient-guidelines'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient`指南：https://learn.microsoft.com/dotnet/fundamentals/networking/http/httpclient-guidelines'
- en: 'NuGet packages best practices: https://learn.microsoft.com/nuget/create-packages/package-authoring-best-practices'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NuGet 包的最佳实践：[https://learn.microsoft.com/nuget/create-packages/package-authoring-best-practices](https://learn.microsoft.com/nuget/create-packages/package-authoring-best-practices)
- en: 'The large object heap on Windows systems: https://learn.microsoft.com/dotnet/standard/garbage-collection/large-object-heap'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 系统上的大对象堆：[https://learn.microsoft.com/dotnet/standard/garbage-collection/large-object-heap](https://learn.microsoft.com/dotnet/standard/garbage-collection/large-object-heap)
- en: 'Microsoft Kiota documentation: [https://learn.microsoft.com/openapi/kiota/](https://learn.microsoft.com/openapi/kiota/)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Kiota 文档：[https://learn.microsoft.com/openapi/kiota/](https://learn.microsoft.com/openapi/kiota/)
- en: 'Kiota GitHub repository: [https://github.com/microsoft/kiota](https://github.com/microsoft/kiota)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kiota GitHub 仓库：[https://github.com/microsoft/kiota](https://github.com/microsoft/kiota)
- en: 'Part 2: Hosting and Deploying'
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：托管和部署
- en: This part focuses on essential aspects of hosting and deploying microservices.
    You will begin by gaining a comprehensive understanding of Docker fundamentals,
    such as creating Dockerfiles, building Docker images using the .NET CLI, and running
    Docker containers with .NET Aspire on your development environment. You will then
    proceed to publish Docker images to the Azure Container Registry, deploy them
    to the Azure Container Apps environment (based on Kubernetes), and incorporate
    Azure services like Azure App Configuration and Azure Key Vault.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分重点介绍托管和部署微服务的基本方面。你将首先全面了解 Docker 基础知识，例如创建 Dockerfile、使用 .NET CLI 构建 Docker
    镜像以及在开发环境中使用 .NET Aspire 运行 Docker 容器。然后，你将继续将 Docker 镜像发布到 Azure 容器注册库，部署到 Azure
    容器应用环境（基于 Kubernetes），并整合 Azure 服务，如 Azure 应用配置和 Azure 密钥保管库。
- en: Throughout this part, you will utilize Azure resources for local application
    execution, deploy applications to Azure using the Azure Developer CLI, and establish
    GitHub Actions for automated deployment to Azure upon code updates in the repository.
    To ensure seamless operation in both on-premises and Azure environments, authentication
    will be implemented with Azure Active Directory B2C and Microsoft Entra, alongside
    ASP.NET Core Identities.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，你将利用 Azure 资源进行本地应用程序执行，使用 Azure 开发者 CLI 将应用程序部署到 Azure，并在代码库更新时通过 GitHub
    Actions 自动部署到 Azure。为确保在本地和 Azure 环境中无缝运行，将实现 Azure Active Directory B2C 和 Microsoft
    Entra 进行身份验证，同时使用 ASP.NET Core Identities。
- en: 'This part has the following chapters:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B21217_05.xhtml#_idTextAnchor110), *Containerization of Microservices*'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第五章*](B21217_05.xhtml#_idTextAnchor110), *微服务的容器化*'
- en: '[*Chapter 6*](B21217_06.xhtml#_idTextAnchor137), *Microsoft Azure for Hosting
    Applications*'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第六章*](B21217_06.xhtml#_idTextAnchor137), *在 Microsoft Azure 上托管应用程序*'
- en: '[*Chapter 7*](B21217_07.xhtml#_idTextAnchor162)*, Flexible Configuration*'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第七章*](B21217_07.xhtml#_idTextAnchor162)*，灵活的配置*'
- en: '[*Chapter 8*](B21217_08.xhtml#_idTextAnchor183)*, CI/CD – Publishing with GitHub
    Actions*'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第八章*](B21217_08.xhtml#_idTextAnchor183)*，使用 GitHub Actions 进行 CI/CD 发布*'
- en: '[*Chapter 9*](B21217_09.xhtml#_idTextAnchor216)*, Authentication and Authorization
    with Services and Clients*'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第九章*](B21217_09.xhtml#_idTextAnchor216)*，使用服务和客户端进行身份验证和授权*'
