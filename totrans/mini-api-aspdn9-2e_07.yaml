- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency Injection in Minimal APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any software project, developers rarely craft the application entirely from
    scratch. At some level, generic libraries and toolsets will be absorbed into the
    application to accelerate and optimize the project. **ASP.NET** as a framework
    is no different. In fact, it requires that developers take on dependencies; third-party
    or independently created code that plays a key role in the smooth running of the
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The result is a (hopefully) finely tuned and well-designed architecture, formed
    of modules and components, some of which run code that was written by developers
    on the project, and the rest being more generic, boilerplate code that was written
    and pre-compiled before the project started.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping track of dependencies is one of the classic problems facing software
    developers, and the problems that arise from this can progress to a point that
    results in what the industry refers to as **dependency hell** – a nightmarish
    scenario in which developers are retracing their steps, trying to figure out where
    a dependency was introduced, and finding ways that they can overcome the challenge
    of conflicting dependencies across a potentially massive code base.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency injection** ( **DI** ) is a way of standardizing and simplifying
    the experience of consuming dependencies in software projects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding DI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring DI in minimal APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DI best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have improved your understanding of DI principles,
    as well as the benefits they can bring to minimal APIs and ASP.NET projects in
    general.
  prefs: []
  type: TYPE_NORMAL
- en: You will also have gained practical experience in the configuration of DI containers
    and registration of services.
  prefs: []
  type: TYPE_NORMAL
- en: Let us start by improving our understanding of DI.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DI started out as a design pattern in software development, aimed at centralizing
    common dependencies and making them available to consumers in a consistent manner.
  prefs: []
  type: TYPE_NORMAL
- en: Using this approach, common development tasks such as testing, swapping out
    dependencies, modification of dependency logic, centralization of dependencies,
    and so on, can be easily achieved through one straightforward system.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, .NET made DI more of a feature rather than just a design pattern.
    In ASP.NET, there is a robust DI toolset that is simple to use and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Developers can register their dependencies in a centralized location, making
    them available to *inject* into the constructors of classes as arguments when
    they are instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: With DI, dependencies live within a *container* , making them centrally available
    to consuming classes. But what is a container?
  prefs: []
  type: TYPE_NORMAL
- en: The DI container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the startup of your application, dependencies are registered in the container.
    The **container** is simply a group of dependencies that have been registered
    for DI. Each of the dependencies has a lifetime specification that defines how
    they are instantiated when injected into a consuming class. We’ll explore dependency
    lifetimes in more detail later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When a class that has a dependency is instantiated, it reaches out to the container,
    which takes care of the business of resolving the dependency and instantiating
    it according to the lifetime setting that was configured when the dependency was
    registered.
  prefs: []
  type: TYPE_NORMAL
- en: It might sound like this is an extra layer of complexity for something as simple
    as using a class within another, but there is good reason for mandating the use
    of DI as a best practice. Let us explore this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The case for DI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Think back to your career to date as a software engineer. Whether you’re still
    at the beginning, or you’ve been doing this for a while, you may have spent considerable
    time *newing up* dependencies in the form of classes.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say you’re building an API endpoint that needs to reach into a SQL database.
    (I’m deliberately not using Entity Framework for this example for simplicity.)
    You may have already created a class that abstracts away the specifics (we’ll
    call it **SqlHelper** ), such as creating an instance of **SqlConnection** , opening
    the connection, building **SqlCommand** , and so on. What do you think you’ll
    need to do each time you realize that you need this **SqlHelper** class?
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you’ll notice is that you have to create a new instance of
    **SqlHelper** at any point that the need for interaction with your SQL Server
    arises. On the face of it, this sounds harmless enough, but from a design perspective,
    it’s problematic. Let’s look at the potential pitfalls of this approach a little
    more closely:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tight coupling** : Without DI, you create a concrete implementation of **SqlHelper**
    each time you use it. Whenever you have a concrete implementation of a class,
    you run the risk of being forced to change each class that consumes it if you
    need to significantly change **SqlHelper** . This means that your consuming classes
    become tightly coupled to **SqlHelper** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Difficulties in testing** : Being able to mock dependencies is critical to
    effective testing. Without DI, you will have to be more hands-on in ensuring that
    dependencies are properly instantiated, mocked, and then accessible for each test.
    The added need for manual instantiation increases the potential for mistakes in
    setting up the tests. This is problematic because it can make your tests unreliable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource management issues** : When dependencies are using resources as **SqlHelper**
    is (it will have a connection to a SQL Server), there is always the risk that
    those resources are not managed effectively. In the case of something like a SQL
    connection, spinning up a lot of these connections over time without adequate
    disposal could exhaust the connections, leading to performance issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Violation of single responsibility, open-closed principle, Liskov substitution,
    interface segregation principle, dependency inversion principle (SOLID) principles**
    : We’ve not yet explored SOLID principles in this book, but they are an important
    part of any object-oriented software system. One of the guiding principles of
    SOLID is *single responsibility* , in which we are expected to ensure that classes
    have a primary responsibility. In the case of a class consuming **SqlHelper**
    , their primary responsibility is to the logic that is requesting or manipulating
    data. Forcing the class to instantiate **SqlHelper** means you’re giving it a
    new responsibility; a responsibility of managing its own dependencies. DI removes
    this added responsibility, simply passing the dependencies into the class when
    the class is constructed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hopefully, this breakdown has painted a picture of how not using DI can make
    your code base inconsistent and messy. Now, let us explore how DI is achieved
    in ASP.NET.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring DI in minimal APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As standard, ASP.NET offers a way for us to declare that a class we have created
    can be registered as a service. Converting a class into a service means it can
    be reused via DI. For example, say you’ve got a piece of logic that calculates
    overtime pay for any given employee. That logic is the same, but you’ll need it
    in many other areas of the code base. To avoid writing the same logic again, it’s
    obvious that you would simply call on the same logic, but as we’ve already discussed,
    creating a new instance of the class to get to this logic whenever you need it
    is messy; so, by registering the class as a service, we can cleanly inject it
    into any other class that needs it.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, DI allows us to control the life cycle of the service when it is injected.
    In essence, we can dictate how the dependency is instantiated on each injection
    and how long it should exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three built-in lifetime options in ASP.NET:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Singleton** : The service is created once, as a single instance. This instance
    is then shared across the code base. This can be useful when you need to maintain
    state on a global scale. Logging is a good use case for this, as all log entries
    can be channeled through one single service that has access to the relevant output
    resource. For example, a logging service that creates logs in a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scoped** : The service is created once for every incoming request. This means
    that when a client makes a request to the API, a service is created when needed
    and that instance is in use for the duration of the request. This is ideal when
    you need to manage state within a request. It is also favorable if you do not
    want to share the same service between different requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transient** : The service has an instance created every time it is injected.
    This means that regardless of the request being made to the API, each time a service
    is injected, that service will be a new instance. This is ideal for scenarios
    where state does not need to be maintained.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s set up a new minimal API project to use as an example of how we can benefit
    from DI.
  prefs: []
  type: TYPE_NORMAL
- en: Please note, if you haven’t read them already, refer to the first two chapters
    to understand how you can create a new minimal API project. This will allow you
    to follow along with the examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a scoped DI project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our new API project, we’re going to use the example of an order-processing
    API. It will contain a series of products or services that can be put together
    to create an order.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need models to represent products and orders. Create two classes,
    **Product** and **Order** . In the first code, we create the **Product** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we create the **Order** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We need to be able to refer to a collection of available products. Ordinarily,
    we would store this information in a database and then use either **SqlConnection**
    or an **Object Relational Mapping** ( **ORM** ) framework, such as Microsoft’s
    Entity Framework, to access the database, mapping the data to the models ( **Product**
    and **Order** ) we’ve created. However, database connections are not within the
    scope of this chapter and will be covered later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, and for simplicity, we will simply create a JSON file containing an
    array of objects that can be read into the project as text and deserialized into
    the strongly typed object, **Product** . I’ve created an example of five products
    that can be saved in JSON format, in the following code. Feel free to copy my
    examples or create your own. Whatever you do, save the products in a file called
    **Products.json** in an accessible location. Ensure that each project is a JSON
    object contained within a single JSON array and that the values you use match
    the data types of the properties in **Product** ; otherwise, it will not be possible
    to deserialize the JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s create a means of bringing these objects into memory when they are
    needed. (Again, not the most efficient example as we’re not using a database,
    but we will be covering database usage later in the book.)
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we’ll do this by creating a class, called **ProductRepository**
    . This class can be used to access a list of objects of type **Product** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the **ProductRepository** class as per the example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this is a very simple class that just holds a list of **Product**
    . We need to somehow populate this list with the JSON objects we’ve saved as text.
    We could very easily just fetch the items when we instantiate the class, but we
    want to do this using an injected service, so we’ll come back to **ProductRepository**
    shortly. Before that, let’s create a service that will have the responsibility
    of retrieving the products from the text file. We’ll call it **ProductRetrievalService**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This simple service reads the contents of the JSON file and uses the **JsonSerializer**
    class found within **System.Text.Json** to convert, or deserialize, the JSON content
    into the strongly typed **Product** type, putting each **Product** into the list.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions on C:/
  prefs: []
  type: TYPE_NORMAL
- en: If you have trouble writing or reading from **C:/** , you may not have permission
    to do so. You can work around this by creating a folder in a location to which
    you do have read/write permissions, and then change the path in the code to match
    the new one.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the products have been retrieved. This means that we can simply
    call **LoadProducts()** and we will always get the latest data. However, how do
    we access **ProductRetrievalService** to do this? Our **ProductRepository** class
    will need this logic in order to populate its **Product** list.
  prefs: []
  type: TYPE_NORMAL
- en: Here is where DI becomes useful. We can inject an instance of **ProductRetrievalService**
    any time we use **ProductRepository** . To make this possible, we first need to
    register **ProductRetreivalService** as a service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates registration of this service for DI within
    **Program.cs** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By adding **ProductRetrievalService** as a scoped service, an instance will
    be created for the duration of the incoming request. Now that it is registered,
    we can inject **ProductRetrievalService** into **ProductRepository** when we instantiate
    it, via its constructor. Let us look at an example of this in an API endpoint
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new HTTP **GET** method, mapped onto the **getProductById** route,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The endpoint takes an integer parameter in the form of the product ID. We can
    now use this to get the product with the matching ID. First things first, let’s
    add a new instance of **ProductRepository** to the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a **ProductRepository** instance now, which has a list of **Product**
    , but this list is empty. We need to modify **ProductRepository** to inject **ProductRetreivalService**
    , to populate that list. The following code shows an example of how the service
    can be injected into **ProductRepository** via the constructor before being used
    to populate the products held within a **List<Product>** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, we should be able to use some logic in the endpoint to get the relevant
    product from **ProductRepository** . However, we have a problem. If we try to
    instantiate a new instance of **ProductRepository** in the endpoint, we will see
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we see an error is that we have changed the way **ProductRepository**
    is instantiated. It now requires a **ProductRetrievalService** to be passed as
    an argument to the constructor, but how are we supposed to get hold of this?
  prefs: []
  type: TYPE_NORMAL
- en: This is where minimal APIs allow us to, within an endpoint, take advantage of
    services registered within the DI container.
  prefs: []
  type: TYPE_NORMAL
- en: '**ProductRetreivalService** can be passed as an argument within the parameters
    we pass into the lambda expression within the body of the endpoint. This makes
    it the same as the ID parameter passed in by the client, except it’s not coming
    from the client, it’s coming from the DI container.'
  prefs: []
  type: TYPE_NORMAL
- en: To make this possible, you need to prefix the **ProductRetrievalService** argument
    with an attribute that indicates that it was injected. This attribute is **[FromServices]**
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Injecting **ProductRetrievalService** with this attribute will now allow us
    to pass the required **ProductRetrievalService** to the constructor of **ProductRepository**
    , as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is also worth noting that the instance of **ProductRepository** we created
    in this example could itself be injected into the class using DI.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to our next example now.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a singleton DI project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at another example, but this time, we’ll use a different life cycle
    for the dependency. In this use case, we will create an endpoint for creating
    an order. The incoming **Order** object will have a list of **Product** that can
    be used to submit a new customer order into the system. However, we also need
    to establish a delivery date.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To avoid repeating ourselves, we can for this example, simply use a collection
    such as **List<DateTime>** rather than feeding them in from a JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine that there is a feed of upcoming available dates that are centrally
    managed. We could create a service that has the available context to be able to
    choose the next available date. This decouples the logic from the endpoint and
    can be reused in other endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code shows an example of this kind of service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This service allows requests to get the next available date, throwing an exception
    if there is no date available. We have a queue to hold the available dates so
    they can be removed as they are retrieved to ensure that the same date is not
    offered twice.
  prefs: []
  type: TYPE_NORMAL
- en: We also must consider thread safety here. You could have multiple requests all
    trying to get an available date, which is very likely to lead to a race condition,
    where two requests end up dequeuing the same available date. To avoid this, we
    are using **ConcurrentQueue** , which will handle the business of ensuring thread
    safety between requests.
  prefs: []
  type: TYPE_NORMAL
- en: We now need to register this as a service that can be injected into the endpoint
    that posts the order. With multiple requests in mind, we want to ensure that all
    requests are retrieving dates from the same list. Therefore, we will register
    the service using **AddSingleton()** , which will ensure that only one instance
    of the service is used between threads and requests during injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the service has been registered in this way, **Program.cs** should look
    like the code shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that the API has our second service registered, it is time to create the
    endpoint for creating an order.
  prefs: []
  type: TYPE_NORMAL
- en: Seeing as we are creating a new record, we should use a **POST** method to achieve
    our goal. The **POST** method will take in a JSON object, which is implicitly
    parsed into an **Order** object within the endpoint parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we indicate that we are injecting **DeliveryDateBookingService**
    into the request.
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, we can complete the endpoint by adding the relevant logic
    to the body of the lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The endpoint with logic for fetching the next delivery date is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Whilst we created a repository for **Product** , we have not yet created one
    for **Order** . Furthermore, we did not demonstrate saving entities to their respective
    repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of logic will be covered later in the book as we explore design patterns
    (such as the repository pattern) and data sources, but for now, here is an example
    of how you can save the new order in the preceding endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an **OrderRetreivalService** class so we stay consistent in using a
    service to retrieve entities (as we did for products):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Register **OrderRetrievalService** as a scoped service in the DI container
    within **Program.cs** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an **OrderRespository** class that follows the same style as **ProductRespository**
    . The added difference is that a **SaveOrder()** method is added to allow for
    saving the **Order** from the **POST** endpoint. Also, the collection being used
    to hold the orders is **ConcurrentQueue<Order>** rather than a list. This is because
    we expect orders to be saved from multiple concurrent requests and we need to
    allow for thread safety:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Register **OrderRepository** as a singleton service in **Program.cs** so that
    we can always add to it on a single instance regardless of how many requests are
    saving orders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The **POST** endpoint can now be updated to inject **OrderRepository** and
    to use it for saving the incoming order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that you have some experience creating dependencies as services and registering
    them for injection, let’s go over some basic best practices for using DI in minimal
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: DI best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DI is integral to most ASP.NET projects, and minimal APIs are often particularly
    reliant on them. As a result, it’s important to ensure that we are following best
    practices when it comes to dependencies and the methods of accessing them.
  prefs: []
  type: TYPE_NORMAL
- en: There are some simple rules of thumb when it comes to implementing DI in minimal
    APIs. We look at these rules in the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding the service locator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is an anti-pattern in minimal APIs known as the **service locator pattern**
    . In this pattern, instead of explicitly injecting your dependency, you inject
    **IServiceProvider** containing the dependency, and then you fish the service
    out of it within the body of your method or function.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the service locator pattern is shown in the following code, in
    which the **POST** method we made for creating orders is altered to use **IServiceProvider**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A significant drawback to this practice is that it makes the code harder to
    read. It is less obvious from the parameter that you are injecting specific services,
    and you have to write extra lines of code to get the service of **IServiceProvider**
    .
  prefs: []
  type: TYPE_NORMAL
- en: It also makes it more difficult to write unit tests for your endpoints, because
    it is less clear which objects you need to instantiate for mocking.
  prefs: []
  type: TYPE_NORMAL
- en: Probably the most destructive aspect of this anti-pattern is the potential for
    runtime failures to be hard to diagnose. When injecting **IServiceProvider** ,
    the compiler doesn’t know if the service you actually need is registered, whereas
    if you attempt to explicitly inject your service and it isn’t registered, it will
    become apparent much more quickly, allowing for easier debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Registering services with an extension method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can make your code more readable by creating an extension method on **IServiceCollection**
    . This means that within **Program.cs** , you can register all your services with
    just one line of code or group your services together in an appropriate way and
    register each group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how you can write such an extension method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After implementing the extension method, you can simply write the following
    in **Program.cs** to register all services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using sensible service lifetimes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When registering services, it is important to consider the lifetime you are
    assigning to them. Here are some examples of when you would use each service lifetime:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transient** : Use this lifetime if your service is lightweight, stateless,
    and is only to be used for a short period of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scoped** : Use this lifetime when your service must maintain state within
    a single request, and the state needs to be unique to the current request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton** : Use this lifetime when your service must maintain state across
    the whole application. It is also useful for situations where you need to create
    heavy services that are costly to create. Creating them once reduces the overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the effort to follow best practices when creating and managing dependencies
    is a long-term investment, and is a selfless act, ensuring that the code base
    is easy to maintain for other developers in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s summarize what we’ve covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started the chapter by exploring DI from a high level, gaining an understanding
    of the benefits it brings to minimal APIs by encouraging good design, loose coupling,
    and reusability across the code base.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at how dependencies can be created in the form of services, before
    being registered for injection, using the example of an order processing API.
  prefs: []
  type: TYPE_NORMAL
- en: It was demonstrated that parameter attributes can be used within a minimal API
    endpoint to inject services into the scope of an endpoint’s execution, and we
    covered the various lifetimes available to services when they are registered.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, some best practices were outlined, helping you to ensure that your
    use of DI is productive, efficient, sustainable, and testable, whilst also being
    easy to read for other developers who may be less familiar with the project.
  prefs: []
  type: TYPE_NORMAL
- en: DI is a fundamental aspect of not only minimal APIs but software engineering
    in general. Having a good grounding in it will be essential for your success as
    a developer.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we also used some pretty unorthodox methods of storing and
    reading in data for use within the example API endpoints. There is good reason
    for this. Normally, we would use more standardized data sources to host and retrieve
    entities, which is something we are going to explore in detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
