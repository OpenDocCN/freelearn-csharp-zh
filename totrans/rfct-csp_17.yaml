- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Agile Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we’ll talk about refactoring as part of an *agile* team,
    succeeding with larger refactoring efforts, recovering when things go wrong, and
    incorporating deployment strategies to help make sure they don’t go wrong again.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to win many small refactoring battles with small pieces of offending
    code but lose the overall “war” when you can’t address large-scale design issues.
    This chapter explores how to continue to fight and win the smaller refactoring
    battles with your code from sprint to sprint. We will also cover the larger strategic
    battle of making sure your application has the right design – and correct it to
    something better when it doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring in an agile environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Succeeding with agile refactoring strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accomplishing large-scale refactorings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recovering when refactoring goes wrong
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying large-scale refactorings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring in an agile environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all development teams I work with use some form of **agile software development**
    to manage work over time in the form of short sprints, including any refactoring
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll cover the basics of agile workflows and how refactoring
    can fit into this type of environment. This is important because if refactoring
    work can’t fit into an agile workflow, refactoring simply won’t happen.
  prefs: []
  type: TYPE_NORMAL
- en: Key elements of agile teams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Agile software development was officially codified in the *Manifesto for Agile
    Software Development* (commonly called the *Agile Manifesto*) and flows from the
    following core preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Individuals and interactions** over processes and tools'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Working software** over comprehensive documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customer collaboration** over contract negotiation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Responding to change** over following a plan'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following these guiding principles, the exact “flavor” of agile differs from
    team to team, but most teams adopt the following key components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sprints**: Work is conducted during fixed-duration periods called sprints.
    These range anywhere from 1 to 4 weeks, but 2 weeks is the norm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User stories**: Work is tracked in the form of work items or user stories.
    Many teams require that any code change be associated with at least one work item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backlogs**: The work for each sprint is taken from a prioritized backlog
    of user stories the team has previously reviewed and refined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exact details, roles, and names of things may vary from organization to
    organization, but these truths generally apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process creates an iterative and cyclical process where the team works
    on the work items the business considers the most important in one sprint while
    prioritizing and refining items for the following sprint, as shown in *Figure
    17**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1 – The cycle of agile software development](img/B21324_17_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.1 – The cycle of agile software development
  prefs: []
  type: TYPE_NORMAL
- en: Agile is currently the best methodology we’ve found for software engineering
    in a business setting, but it does pose some unique obstacles to refactoring.
    See the *Further reading* section at the end of this chapter for additional resources
    on agile.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding obstacles to refactoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Agile is good for getting teams working on items that are important to the business
    and working through a prioritized backlog. Unfortunately, agile may not be the
    best development modality for proactive refactoring work.
  prefs: []
  type: TYPE_NORMAL
- en: Most organizations require all code changes to be associated with at least one
    user story and developers are expected to be working on user stories when they
    have spare capacity.
  prefs: []
  type: TYPE_NORMAL
- en: This leaves engineers in a conundrum where they know the areas of code that
    need to be refactored and have the technical skills and knowledge to refactor
    them, yet it is not acceptable within the boundaries of their teams for them to
    proactively improve code outside the bounds of an assigned user story.
  prefs: []
  type: TYPE_NORMAL
- en: This causes technical debt to pile up and eventually decays the team’s velocity
    by slowing down work items. This also results in a greater number of bugs being
    introduced because the team has not been allowed to proactively manage the risk
    inherent in their legacy code.
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t to say that agile is bad. Agile is the best process we’ve found so
    far to manage work in software engineering teams; however, it has some limitations
    that must be solved to help organizations achieve both short-term and long-term
    success.
  prefs: []
  type: TYPE_NORMAL
- en: Succeeding with agile refactoring strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ongoing refactoring is important in an agile environment, so let’s talk about
    some ways of making sure code gets refactored regularly.
  prefs: []
  type: TYPE_NORMAL
- en: Dedicated work items for refactoring efforts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that every line of code you and your team write should deliver business
    value, including your refactoring efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring focuses on delivering value to the business by addressing known
    areas of technical risk and improving the speed the team can achieve in the future
    on related work in the targeted area.
  prefs: []
  type: TYPE_NORMAL
- en: Given these facts, it makes sense that refactoring efforts should be represented
    inside a sprint as user stories. Just as one developer might get a user story
    about integrating with a new external system for a partner, another developer
    might get a user story to refactor and establish additional tests around the data
    access layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 15*](B21324_15.xhtml#_idTextAnchor316), we discussed tracking
    technical debt in a risk register. I didn’t make it explicit in that chapter,
    but you can use the same system that tracks your user stories to track your known
    technical risks as a specialized type of user story, such as the one shown in
    *Figure 17**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.2 – A technical debt item in Azure DevOps](img/B21324_17_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.2 – A technical debt item in Azure DevOps
  prefs: []
  type: TYPE_NORMAL
- en: These technical debt user stories should look just like normal user stories
    and have the same degree of polish and refinement. However, these user stories
    should have a different type or a property with a different value so that you
    can identify technical debt items in your backlog and sprints.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, it should be the responsibility of the developers on the team
    to write up these technical debt items and not the product owner, though the team
    will still need to walk the product owner through what the item is, the rough
    amount of effort needed to remediate it, and the risk the change is looking to
    resolve.
  prefs: []
  type: TYPE_NORMAL
- en: Healthy agile teams should take a mixture of short-term and long-term items,
    with technical debt items typically falling in the long-term bucket.
  prefs: []
  type: TYPE_NORMAL
- en: There may be times when you cannot do anything but short-term work and there
    may be times when you work with a product owner that doesn’t understand the risk
    present in your technical debt. The suggestions from [*Chapter 15*](B21324_15.xhtml#_idTextAnchor316)
    may help with this, but sometimes, there won’t be an easy answer.
  prefs: []
  type: TYPE_NORMAL
- en: In these times, you may need to shift to a strategy of refactoring any code
    that changes.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring code as it changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the technical debt I’ve addressed over my career has come from the conscious
    decision to refactor any code I touch.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach of refactoring code that changes has several key benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It ensures the areas that are changed most frequently get refactored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since I’m working in that area anyway, I know I will be testing the code in
    question. This means that these testing efforts will help catch any issues that
    might be addressed as part of refactoring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not require the overhead of separate user stories for small, trivial
    refactoring efforts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In my experience, making it part of your policy to clean up and test the code
    around the areas you touch results in a much cleaner codebase over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach has its limitations: when you are making a minor change in one
    area of code and the code needs serious refactoring efforts, it is typically irresponsible
    to expand the scope of your work item beyond a certain point.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, some refactoring efforts cannot be achieved within the context
    of a single sprint and need more strategic thought and planning behind them.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring sprints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One concept I’ve encountered once or twice has been the idea of a **refactoring
    sprint**. A refactoring sprint follows the mentality of crop rotation in farming.
  prefs: []
  type: TYPE_NORMAL
- en: I’m no farmer, but my understanding of crop rotation is that you can use a field
    for several seasons, but over time, that field starts to lose the nutrient values
    from the soil and becomes less productive as years go on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To combat this, farmers learned to leave these fields fallow and not grow anything
    in them for a time, as shown in *Figure 17**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.3 – Rotating crops over several years](img/B21324_17_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.3 – Rotating crops over several years
  prefs: []
  type: TYPE_NORMAL
- en: Applied to agile development, you might spend several sprints working on normal
    work items, but after a handful of sprints, you introduce a refactoring sprint
    where the team’s effort goes into refactoring the areas of code that concern the
    team the most.
  prefs: []
  type: TYPE_NORMAL
- en: In refactoring sprints, the development team can take on larger-scale efforts
    than they might otherwise try as part of a standard sprint.
  prefs: []
  type: TYPE_NORMAL
- en: This also has the side effect of re-energizing your developers and getting them
    ready for another sequence of sprints around a key long-term business objective.
  prefs: []
  type: TYPE_NORMAL
- en: In practicality, I’m not sure how well these sprints work regularly, but I’ve
    seen teams benefit from them tremendously in special scenarios. These refactoring
    sprints can be used to tackle larger problems or as a way of recharging the team
    after a major initiative is completed. I’ve also seen these sprints used as a
    way of keeping the team engaged during holiday seasons.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring sabbaticals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most teams I’ve worked with simply can’t afford to have all their developers
    work primarily on refactoring efforts, even for a single sprint.
  prefs: []
  type: TYPE_NORMAL
- en: Teams like this may want to take the idea of a refactoring sprint and scale
    it down so that it applies to just a single team member.
  prefs: []
  type: TYPE_NORMAL
- en: I call this concept a **refactoring sabbatical**, where the developer effectively
    splits off of the team for a short time to work on a refactoring project, only
    to rejoin the larger team in the next sprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a future sprint, another developer gets to spend a sprint working on refactoring
    efforts while others work on traditional work items, as shown in *Figure 17**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.4 – A rotating developer sabbatical over several sprints](img/B21324_17_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.4 – A rotating developer sabbatical over several sprints
  prefs: []
  type: TYPE_NORMAL
- en: Under this model, the refactoring efforts the developer wants to take on should
    be pre-approved, reviewed, and tested by other developers on the team.
  prefs: []
  type: TYPE_NORMAL
- en: The developer on “sabbatical” should still be available for questions and work
    on emergency items. The only major change is that their work for a sprint is self-directed
    toward known refactoring goals.
  prefs: []
  type: TYPE_NORMAL
- en: This has some of the same morale-boosting effects as a refactoring sprint but
    on a smaller scale. This also helps prevent teams from over-relying on any one
    person on the team, because people rotate into and out of sabbaticals frequently.
  prefs: []
  type: TYPE_NORMAL
- en: While this model may see success in small and medium-sized refactorings, it
    is less effective in large-scale refactorings. We’ll discuss ways of succeeding
    with larger refactorings next.
  prefs: []
  type: TYPE_NORMAL
- en: Accomplishing large-scale refactorings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my experience, successfully performing large-scale refactorings is one of
    the hardest challenges in all of software engineering.
  prefs: []
  type: TYPE_NORMAL
- en: I define large-scale refactoring as something on the scale of replacing an application
    or a major architectural layer of an application. Moving an application from one
    database technology to another, replacing a REST API with a gRPC API, upgrading
    from Web Forms to Blazor, or replacing your entire service layer are all examples
    of this.
  prefs: []
  type: TYPE_NORMAL
- en: Why large refactorings are difficult
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These projects are challenging because they typically take longer than a single
    sprint to accomplish and must meet feature parity with software that has been
    developed over the years.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, software engineering projects are notoriously hard to accurately
    estimate, which is one of the reasons developers prefer agile software development
    over more traditional project management methodologies such as **waterfall**.
    Delays in software development projects can be difficult to predict and manifest
    in the form of unexpected technical obstacles, such as previously unknown limitations
    of other components or platforms or subtle bugs slowing development.
  prefs: []
  type: TYPE_NORMAL
- en: Because of these factors, large refactoring efforts are significantly harder
    to achieve than medium refactoring efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Once completed, the results of these efforts can be daunting to move into production
    environments as well because they represent such a large change. Later in this
    chapter, we’ll talk about a few ways of reducing this risk, but the decision to
    replace or upgrade major parts of your application is not one without quality
    risks.
  prefs: []
  type: TYPE_NORMAL
- en: This problem gets even more pronounced when teams choose to completely rewrite
    or replace software projects instead of refactoring them.
  prefs: []
  type: TYPE_NORMAL
- en: The rewrite trap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rewrites take all the problems of large refactoring efforts and multiply them
    by a factor of at least 10.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, you are replacing an application that has been used for some
    time and typically has a significant number of active users and established features.
  prefs: []
  type: TYPE_NORMAL
- en: It can be a struggle to re-implement years’ worth of features while keeping
    up with production bugs and other short-term work that must happen to keep the
    business running smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: When a team is actively working on a rewrite, they usually see little value
    in targeted refactorings of the current system they’re working on replacing. This
    means that if a rewrite is canceled or put on hold, the team gets no value out
    of their investment and still has a legacy system that needs to be supported.
  prefs: []
  type: TYPE_NORMAL
- en: Since software projects are hard to estimate and manage, rewrites frequently
    take much longer than you expect them to. During this time, your engineers are
    working primarily on the rewrite, which takes capacity away from other initiatives.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that a rewrite usually provides no intrinsic value to the business
    or the users until it is active in a production environment and people are working
    with it live. This is why so few rewrite projects succeed.
  prefs: []
  type: TYPE_NORMAL
- en: You can remediate this by offering early previews of a partial rewrite, but
    this is not always possible and may not be the best user experience if important
    features are not present yet in the rewrite.
  prefs: []
  type: TYPE_NORMAL
- en: Lessons from the ship of Theseus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s a thought experiment about the Greek hero Theseus that is relevant to
    refactoring software.
  prefs: []
  type: TYPE_NORMAL
- en: In this thought experiment, **the ship of Theseus**, our hero, Theseus, sets
    sail on a long journey by sea. Throughout his long voyages, the crew gradually
    replaced pieces of the ship with spare materials and materials they made or found
    on their voyages. This continued for some time until there wasn’t a single piece
    of the original ship left in his ship as he returned home.
  prefs: []
  type: TYPE_NORMAL
- en: This thought experiment asks whether the ship that came home is the same, and
    if it isn’t, when did it stop being that ship?
  prefs: []
  type: TYPE_NORMAL
- en: While these are interesting philosophical questions, the concept is relevant
    to software engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Using refactoring, we can replace the “planks” of our virtual “ship” as technical
    debt takes hold in various areas. As we gradually refactor the components that
    need it the most, we continually evolve our software to stay relevant over time.
  prefs: []
  type: TYPE_NORMAL
- en: This is why I view refactoring code as you write code as a critically important
    practice in software engineering. Technical debt is an inescapable reality of
    software and you must keep it in mind with every change you make by doing what
    you can to prevent it from taking hold and paying down existing debt areas through
    refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Gradual refactoring only goes so far. Progressive refactoring may help keep
    your virtual “boat” afloat, but it won’t turn a rowboat into a cruise liner or
    submarine.
  prefs: []
  type: TYPE_NORMAL
- en: Put more clearly, refactoring won’t help you move from an antiquated technology
    to a more modern one. Let’s look at a tool that might help with that.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading projects with.NET Upgrade Assistant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As new versions of .NET come out and new technologies emerge within the .NET
    ecosystem, keeping up can be a challenge.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this, Microsoft introduced **.NET Upgrade Assistant**, which helps
    you safely upgrade and modernize your applications. At the time of writing, this
    tool has been useful with projects written with the following technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ASP.NET**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Universal Windows** **Platform** (**UWP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows Communication** **Foundation** (**WCF**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows Forms**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows Presentation** **Foundation** (**WPF**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET Upgrade Assistant can be installed either as a global tool or as a Visual
    Studio extension, as shown in *Figure 17**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.5 – Installing.NET Upgrade Assistant in Visual Studio](img/B21324_17_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.5 – Installing.NET Upgrade Assistant in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: Once the extension has been installed, you will be able to right-click on a
    project in **Solution Explorer** and choose **Upgrade**.
  prefs: []
  type: TYPE_NORMAL
- en: From there, you’ll be able to configure a set of options on your project that
    will vary based on the technologies you use. You’ll also be able to configure
    the scope of the upgrade attempt and include and exclude files of your choosing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the upgrade runs, you’ll see a list of projects and files that were updated
    and see details in the log, as shown in *Figure 17**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.6 – .NET Upgrade Assistant in action](img/B21324_17_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.6 – .NET Upgrade Assistant in action
  prefs: []
  type: TYPE_NORMAL
- en: You should make sure your project is properly backed up and in source control
    before attempting an upgrade and you may need to resolve certain issues yourself,
    but this tool can be very useful for starting an upgrade in an automated manner.
  prefs: []
  type: TYPE_NORMAL
- en: For applications that can’t be easily upgraded with .NET Upgrade Assistant,
    you may need some more creative strategies, which we’ll talk about next.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring and the strangler fig pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 2004, Martin Folwer introduced the **strangler fig pattern** to the software
    community in a post he titled *StranglerFigApplication*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this post, Martin Fowler describes how certain fig trees, such as the Banyan
    Tree pictured in *Figure 17**.7*, wrap themselves around other trees and gradually
    replace the structure of the other tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.7 – Photo of a banyan tree by Ankit Bhattacharjee](img/B21324_17_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.7 – Photo of a banyan tree by Ankit Bhattacharjee
  prefs: []
  type: TYPE_NORMAL
- en: Over time, this strangler fig assumes more and more of the structure of the
    tree and it effectively becomes a whole new tree.
  prefs: []
  type: TYPE_NORMAL
- en: In this metaphor, the tree would be the legacy application you’re trying to
    replace while the various vines from the strangler fig represent your rewrite.
  prefs: []
  type: TYPE_NORMAL
- en: Under this model, you’re not trying to rewrite the entire application and replace
    it with a freshly rewritten application.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you take a single **vertical slice** of the application encompassing
    a core set of features and behaviors and you make a new implementation of them
    in a new technology. This might be a web page or a set of API endpoints, depending
    on what you’re writing.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve rewritten this capability in your new technology, you redirect traffic
    for that one area from the old application to the new application. This allows
    you to ship parts of your new application to users incrementally, validate things
    in production, and then take on another vertical slice of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Technical details
  prefs: []
  type: TYPE_NORMAL
- en: There are a few technologies that can help achieve this goal of replacing vertical
    slices of an application. Azure API Management can help direct web traffic to
    an appropriate endpoint in API Management. I’ve also seen people succeed with
    **Yet Another Reverse Proxy** (**YARP**) for these efforts. Links to both can
    be found in the *Further* *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: As you expand your rewrite and validate it works, you can remove portions of
    the original application so that you no longer need to maintain them.
  prefs: []
  type: TYPE_NORMAL
- en: For areas that your new application doesn’t support yet, you can have it link
    back to existing areas on the old application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The strangler fig approach has some key advantages compared to a full rewrite:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows you to iteratively deliver your rewrite in stages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It works better in an agile environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps validate risk areas early instead of waiting for the full rewrite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows you to remove replaced code from the original if you’d like
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be rolled out in parallel with the original as a preview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perhaps the biggest benefit of this pattern is that its success chance is significantly
    higher than attempting a total rewrite.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s talk about what to do when refactoring isn’t as successful.
  prefs: []
  type: TYPE_NORMAL
- en: Recovering when refactoring goes wrong
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, despite your best efforts, refactoring efforts will fail. It may
    be due to gaps in your tests or mistaken assumptions about new technologies, but
    a certain percentage of your refactoring attempts will fail.
  prefs: []
  type: TYPE_NORMAL
- en: The impact of failed refactorings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Failed refactorings can be both frustrating and a serious challenge to future
    refactoring work. After all, a significant barrier to refactoring is the belief
    that legacy code is so brittle that touching it will break it. When you change
    code and it breaks, you make it harder to change code in the future.
  prefs: []
  type: TYPE_NORMAL
- en: When refactoring fails, you sometimes get to make a quick patch to address the
    issue you introduced. In this case, the code is refactored and service gets restored,
    but you’ve lost some of the team’s trust.
  prefs: []
  type: TYPE_NORMAL
- en: Other times, failures in refactoring result in code getting rolled back to the
    previous version before you refactored it. Sometimes, you’ll get to make changes,
    add additional tests, and retry this refactoring, while other times, the team
    will decide that the refactoring is too dangerous to try again and you’ll lose
    your shot at improving the code for some time.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, this conversation boils down to how much the business trusts you
    to not make mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Mistakes in software development will happen because people are imperfect and
    make mistakes, assume things without realizing them, and don’t know everything.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing safety in agile environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What you want to do as a technologist is create an environment where mistakes
    are infrequent and can easily and safely be caught before they reach production
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are certain things you can do to reduce the odds of breaking software
    when refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing**: Unit tests, manual tests, and having your peers test your code
    in a different environment can help you catch many mistakes and some assumptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code review**: Teams that review changes before they ship to integration
    and production environments can catch bad assumptions, mistakes, and poor coding
    practices. Code review is also an opportunity for teams to share knowledge and
    techniques, as well as share knowledge of the codebase across the dev team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code analysis**: Using the documented best practices in .NET and adhering
    to your team’s standards, as we talked about in *Part 3* of this book, can prevent
    issues the team has encountered before from recurring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated tests**: Testing is so important I put it on here twice, but this
    time, I’m stressing that any change getting merged into a release branch needs
    to have automated tests run against it and pass before it can move on. This ensures
    that tests are reliably and repeatably run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Active monitoring**: Regular monitoring of error and warning logs can help
    you detect problems early in production and staging environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Be honest and transparent when an issue occurs and follow this sequence of
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Confirm that the issue exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understand the issue enough to resolve it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resolve the issue and restore service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine how you could have prevented the issue from occurring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you look at a bug getting past your defensive practices as a way of improving
    your processes and identifying gaps, it becomes a learning opportunity for your
    team.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, these learning opportunities do come with a penalty of lost trust
    from others due to the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve found that openly and honestly communicating the following things helps
    encourage understanding and somewhat heal lost trust:'
  prefs: []
  type: TYPE_NORMAL
- en: The steps your team took to verify the item wouldn’t cause issues before release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nature of the bug and how it got past your team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What you did to resolve it and restore service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What you’re doing to ensure that things like it won’t be issues in the future
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach treats everyone with respect, shares understanding, provides opportunities
    for questions and suggestions, and assures them that the quality of the application
    is important to you and your team.
  prefs: []
  type: TYPE_NORMAL
- en: Before we close this chapter and this book as a whole, let’s talk about some
    helpful practices you may want to consider when deploying software.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying large-scale refactorings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s talk about some ways of deploying code that can help you catch any issues
    that slip through before they become major problems.
  prefs: []
  type: TYPE_NORMAL
- en: Using feature flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Feature flags** are configuration settings that control whether features
    are active.'
  prefs: []
  type: TYPE_NORMAL
- en: When you push out new code that includes a new capability, that code doesn’t
    have to be immediately available. You can deploy as usual with the new feature
    area disabled in the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’re confident the rest of the software is working as intended, you can
    enable the new feature. If the feature winds up having issues, you can quickly
    disable it by flipping the feature flag back to its inactive state.
  prefs: []
  type: TYPE_NORMAL
- en: While feature flags are helpful when you’re releasing actual features, you can
    also use them with major refactoring efforts. For example, a feature flag might
    govern whether the system uses `LegacyBookingSystem` or `RevisedBookingSystem`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Feature flag libraries pair nicely with A/B testing libraries such as Scientist
    .NET, which we covered in [*Chapter 9*](B21324_09.xhtml#_idTextAnchor189).
  prefs: []
  type: TYPE_NORMAL
- en: Popular feature flag tools include **Azure App Configuration** and **Launchdarkly**,
    but Microsoft also offers an open-source feature management library called **.NET**
    **Feature Management**.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Feature Management is surprisingly capable and integrates directly into
    your .NET applications, though it lacks some of the web monitoring capabilities
    a commercial software product might have.
  prefs: []
  type: TYPE_NORMAL
- en: Feature flags add complexity to your application but give you options for when
    your features go live. This lets you enable a feature, evaluate it for correctness
    in a production environment, and then either disable it, patch any issues observed,
    or leave it on.
  prefs: []
  type: TYPE_NORMAL
- en: Phased rollouts and blue/green deployments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Phased rollouts** or **blue/green deployments** take the idea of feature
    flags to a different level. In this model, you have distinct sets of servers,
    typically referred to as blue and green environments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a blue/green deployment, you might start with 100% of your users using one
    environment. During this time, you patch the other server with your new update
    and verify that it appears to be running correctly, as shown in *Figure 17**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.8 – Users using the blue environment while the green one is being
    updated](img/B21324_17_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.8 – Users using the blue environment while the green one is being
    updated
  prefs: []
  type: TYPE_NORMAL
- en: Once you’re sure the new server is operational and running without issue, you
    can start diverting a percentage of your users onto the new server.
  prefs: []
  type: TYPE_NORMAL
- en: 'This subset of users represents real production traffic and can be used to
    monitor the behavior of your new release with a minimal set of users, as shown
    in *Figure 17**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.9 – The blue environment running most users while a subset of users
    are on green](img/B21324_17_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.9 – The blue environment running most users while a subset of users
    are on green
  prefs: []
  type: TYPE_NORMAL
- en: If the new environment starts to have issues, you can quickly move users off
    of that server and onto the old one, then take the new environment offline for
    maintenance until you’ve addressed the issues and are ready to try again.
  prefs: []
  type: TYPE_NORMAL
- en: Caution
  prefs: []
  type: TYPE_NORMAL
- en: When migrating to a new revision and then rolling back to the old one, you must
    take special care to ensure any database migrations still work appropriately.
    Tools such as Entity Framework’s up-and-down scripts can help with this.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the new environment performs without issues, you can gradually “drain” users
    from the old environment onto the new environment. Eventually, your old environment
    will be empty and can be taken offline until the next deployment, as shown in
    *Figure 17**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.10 – The green environment handles all traffic and the blue one
    goes offline](img/B21324_17_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.10 – The green environment handles all traffic and the blue one goes
    offline
  prefs: []
  type: TYPE_NORMAL
- en: The next time a deployment occurs, the roles will reverse and users will move
    from the green environment to the blue environment once the blue environment is
    updated to the next version.
  prefs: []
  type: TYPE_NORMAL
- en: This sounds complex, and to some extent it is, but a lot of this complexity
    can be automated and managed by your cloud provider. For example, Azure provides
    blue/green deployments in many of its services, as detailed in the *Further* *reading*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve migrated over to a blue/green deployment model, the complexity becomes
    largely irrelevant, and instead, blue/green deployment becomes another tool in
    your quality toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: The value of continuous integration and continuous delivery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of this added complexity in the form of deployment and feature management
    sounds intimidating at first, but this level of maturity helps teams perform at
    very high levels and reduces the impact of any failures on the end users.
  prefs: []
  type: TYPE_NORMAL
- en: This complexity can be a problem, but thankfully, **continuous integration and
    continuous delivery** (**CI/CD**) can help manage it.
  prefs: []
  type: TYPE_NORMAL
- en: '**CI** is about verifying the correctness of your software any time it changes.
    This means running code analysis, unit tests, and any other checks you need to
    do any time a change is about to be merged into an integration branch.'
  prefs: []
  type: TYPE_NORMAL
- en: '**CD** focuses on automating the deployment of software applications in a repeatable
    and reliable manner. Instead of deployments being done from one specialized developer’s
    machine, deployments are done using an automated script that is typically run
    in a cloud environment. Continuous delivery allows you to ship your software in
    a repeatable and reliable manner to whatever environment you want.'
  prefs: []
  type: TYPE_NORMAL
- en: Some interpretations of CI/CD also include **Infrastructure as Code** (**IaC**)
    through tools such as **Terraform** or **Bicep**. IaC is used to configure cloud
    environments that have the same resources, security privileges, and configuration
    settings based on an IaC script. This means that deployments can be used to create
    missing cloud resources and secure resources, and generally make it easier for
    your team to create new environments consistently.
  prefs: []
  type: TYPE_NORMAL
- en: When you put these tools and processes together, you get a well-defined and
    automated pipeline that checks new code for correctness, runs tests to ensure
    that the change doesn’t break anything, and can deploy changes to whatever environment
    you’d like – all without the possibility of human error in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a broad enough library of unit and integration tests, CI/CD allows
    you to deploy at whatever pace you’re comfortable with and is how some teams can
    deploy hundreds of times a day if they want to.
  prefs: []
  type: TYPE_NORMAL
- en: This degree of process maturity gives teams the freedom to innovate at a rapid
    pace. These added safety nets of quality checks and automation further support
    refactoring efforts by taking the fear out of making the changes needed to keep
    your software clean and healthy.
  prefs: []
  type: TYPE_NORMAL
- en: Case study – Cloudy Skies Airlines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we close this book, let’s take a final look at our case study company: Cloudy
    Skies Airlines.'
  prefs: []
  type: TYPE_NORMAL
- en: Cloudy Skies started with unmaintainable systems they were afraid to touch for
    fear of introducing critical bugs. They carried out a systematic review of the
    technical debt in their codebase and the quality issues the team had encountered
    in the past year.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the team was able to prioritize a list of key areas of technical
    debt and identify critical areas lacking unit tests. Cloudy Skies carried out
    several refactoring sprints to address the most critical areas first, putting
    a heavy emphasis on expanding their unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Once the quality hotspots were largely addressed, Cloudy Skies went back to
    a standard agile development cadence but allocated about 30% of their work each
    sprint toward paying down technical debt.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the systems Cloudy Skies used were out of date, but Cloudy Skies was
    able to use .NET Upgrade Assistant to quickly modernize most of them.
  prefs: []
  type: TYPE_NORMAL
- en: For applications that could not be easily upgraded, development teams began
    following the strangler fig pattern to build a new application to cover vertical
    slices of the old application and tools such as YARP to route traffic to the new
    application where possible.
  prefs: []
  type: TYPE_NORMAL
- en: All of this was supported by a culture of trust and transparency and modern
    application management processes through feature flags and CI/CD.
  prefs: []
  type: TYPE_NORMAL
- en: While it will be some time before the developers are fully proud of their code,
    Cloudy Skies is heading in the right direction. The team has regained the respect
    of the larger organization and the added stability and agility is helping the
    business steer toward sunny horizons.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the unique challenges of refactoring in an agile
    environment and strategies for including refactoring work inside agile sprints.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at ways of accomplishing large-scale refactorings and how to
    respond when things don’t go as planned.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also touched on some deployment and automation processes that can
    reduce the impact of issues on end users and minimize the risk of human error
    through feature flags, blue/green deployments, and CI/CD practices.
  prefs: []
  type: TYPE_NORMAL
- en: Toward more sustainable software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book took you on a journey from the nature of technical debt to the procedures
    of refactoring. We talked about how to safely test and structure your software
    and how to evaluate code for best practices, prioritize, and communicate technical
    debt.
  prefs: []
  type: TYPE_NORMAL
- en: We also talked about how the C# language and features of Visual Studio support
    you in this journey toward more sustainable software development.
  prefs: []
  type: TYPE_NORMAL
- en: Every year our world changes a little as Microsoft unveils new C# preview features
    at the beginning of the year and releases them near the end.
  prefs: []
  type: TYPE_NORMAL
- en: These capabilities give us a wide range of capabilities to tackle the development
    problems of today and tomorrow, but the reality is that software development continues
    to change.
  prefs: []
  type: TYPE_NORMAL
- en: Software and software development grows more complex each year. Meanwhile, many
    teams are stuck maintaining yesterday’s code.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t have to be this way. You can modernize your software, and you can
    do it in an agile and responsible way while serving the needs of your business
    and its customers.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve been writing software in some shape or form for over 35 years now. New
    developers assume that more experience results in fewer mistakes. While this has
    some truth to it, I’ve personally found that the more experience I get, the less
    I trust my ability to not make mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Make room for yourself – and others – to make mistakes. Mistakes will happen
    and bugs will reach production, but when they do, you need to learn from them.
  prefs: []
  type: TYPE_NORMAL
- en: It is my sincere hope that you have learned something new from every chapter.
    Moreover, I want you to emerge from this book with hope – hope that your code
    can be a source of joy to you, or at least be less afraid to change.
  prefs: []
  type: TYPE_NORMAL
- en: Through the practices outlined in this book, I believe that you and your team
    can reach a better place through successfully refactoring with C#.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can technical debt be paid down inside of an agile setting?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are large rewrites hard? What processes can help with this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What variances do you see right now in how you deploy and test software?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find more information about the materials from this chapter at these
    URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Manifesto for Agile Software Development*: *StranglerFigApplication* *Post*:
    [https://martinfowler.com/bliki/StranglerFigApplication.html](https://martinfowler.com/bliki/StranglerFigApplication.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*YARP*: [https://github.com/microsoft/reverse-proxy](https://github.com/microsoft/reverse-proxy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Azure API* *Management*: [https://learn.microsoft.com/en-us/azure/api-management/api-management-key-concepts](https://learn.microsoft.com/en-us/azure/api-management/api-management-key-concepts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Overview of the.NET Upgrade* *Assistant*: [https://learn.microsoft.com/en-us/dotnet/core/porting/upgrade-assistant-overview](https://learn.microsoft.com/en-us/dotnet/core/porting/upgrade-assistant-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.NET Feature* *Management*: [https://github.com/microsoft/FeatureManagement-Dotnet](https://github.com/microsoft/FeatureManagement-Dotnet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Blue-Green Deployment in Azure Container* *Apps*:[https://learn.microsoft.com/en-us/azure/container-apps/blue-green-deployment](https://learn.microsoft.com/en-us/azure/container-apps/blue-green-deployment)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Vertical* *Slices:* [https://deviq.com/practices/vertical-slices](https://deviq.com/practices/vertical-slices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
