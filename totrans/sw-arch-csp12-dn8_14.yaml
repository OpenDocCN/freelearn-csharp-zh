- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Microservices with .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 11*, *Applying a Microservice Architecture to Your Enterprise Application*,
    you learned the theory and basic concepts of microservices. In this chapter, you
    will learn how to put into practice those general concepts and tools to implement
    microservices in .NET. This way, you will have a practical understanding of how
    high-level architectural decisions translate into concrete .NET code.
  prefs: []
  type: TYPE_NORMAL
- en: The focus of this chapter is on worker microservices; that is, microservices
    that are not part of the public interface of your application. Other kinds of
    microservices will be focused on in other chapters. Worker microservices process
    jobs that are not connected to a specific user. They somehow prepare the data
    that will be used by frontend microservices to satisfy all user requests. They
    are the assembly line of each application, so their design priorities are efficiency
    in both communication and local processing, together with protocols that ensure
    data coherence and fault tolerance.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn how to implement a frontend service in *Chapter 18*, *Implementing
    Frontend Microservices with ASP.NET Core*, after having learned about techniques
    for implementing a presentation layer in *Chapter 17*, *Presenting ASP.NET Core*.
    Other techniques for implementing presentation layers are described in *Chapter
    19, Client Frameworks: Blazor*, while techniques for implementing public APIs
    will be discussed in *Chapter 15*, *Applying Service-Oriented Architectures with
    .NET*.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explains the structure of a .NET microservice and discusses the
    options for exchanging messages and serializing .NET data structures. In particular,
    we will put into practice a lot of concepts analyzed in *Chapter 11*, *Applying
    a Microservice Architecture to Your Enterprise Application*, such as the concept
    of Generic Host, the techniques for ensuring reliable communication (exponential
    retry, etc.), forward communication, and idempotency of messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, in this chapter, you will learn about the following subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: Communication and data serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing worker microservices with ASP.NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing microservices with .NET worker services and message brokers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each point will be discussed in depth, and the reader can find further practical
    details in the section *A worker microservice with ASP* *.NET core* of *Chapter
    21, Case Study*, which describes in detail three complete implementations of worker
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The first section of the chapter discusses the main coordination and queuing
    problems that arise in microservices communication and how to solve them with
    either message brokers or custom permanent queues. These topics are fundamental
    in the design of efficient and fault-tolerant communication, which, in turn, are
    essential requirements for ensuring coherent behavior and low response times of
    the overall application.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining sections include examples of how to implement the same microservice
    with two different techniques. The techniques in the second section are based
    on the ASP.NET Core implementation of gRPC and an SQL Server-based permanent queue.
    It is worth pointing out that this technique requires HTTP/2\. The example in
    the third section shows how to use message brokers and two serialization techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'Message brokers are fundamental for three main reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: They take care of most of the communication overhead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They support the publisher/subscriber pattern, which promotes the independence
    of communicating microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All main cloud providers offer message broker services. The example uses **RabbitMQ**,
    but RabbitMQ can be replaced by **Azure Service Bus**,the message broker offered
    by Azure. The chapter also explains the pros and cons of different serialization
    techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the free Visual Studio 2022 Community edition or better
    with all database tools installed. The code for this chapter is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).
  prefs: []
  type: TYPE_NORMAL
- en: Experimenting with message brokers also requires the installation of the RabbitMQ
    message broker (version 3.9 or higher), which in turn requires the previous installation
    of a 64-bit version of Erlang. An adequate Erlang version for RabbitMQ 3.9 can
    be downloaded from [https://github.com/erlang/otp/releases/download/OTP-24.0.6/otp_win64_24.0.6.exe](https://github.com/erlang/otp/releases/download/OTP-24.0.6/otp_win64_24.0.6.exe).
    The RabbitMQ Windows installer can be downloaded from [https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.9.5/rabbitmq-server-3.9.5.exe](https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.9.5/rabbitmq-server-3.9.5.exe).
    We recommend you launch both installations from an administrative account.
  prefs: []
  type: TYPE_NORMAL
- en: Three complete examples of worker microservices are in the *A worker microservice
    with ASP.NET core* and *A worker microservice based on RabbitMQ* sections of *Chapter
    21, Case Study*. Each of them exemplifies a technique described in this chapter
    and shows an alternative way of collecting travel statistics in the case study
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Communication and data serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As explained in the *Microservice design principles* subsection of *Chapter
    11*, *Applying a Microservice Architecture to Your Enterprise Application*, requests
    to a microservices-based application can’t cause long chains of recursive microservices
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, each call adds both a wait time and a communication time to the actual
    processing time, thus leading to unacceptable levels of overall response time,
    as shown in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Shape, circle  Description automatically generated](img/B19820_14_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: Tree of blocking RPC calls'
  prefs: []
  type: TYPE_NORMAL
- en: Messages **1-6** are triggered by a request to the **A** microservice and are
    sent in sequence, so their processing times sum up to the response time. Moreover,
    once sent, message **1** from microservice **A** remains blocked until it receives
    the last message (**6**); that is, it remains blocked for the whole lifetime of
    the overall recursive communication process.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice **B** remains blocked twice, waiting for an answer to a request
    it issued. The first time is during the **2-3** communication and then the second
    is during the **4-5** communication. To sum up, **Remote Procedure Calls** (**RPCs**)
    involve high response times and a waste of microservices computation time.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why microservices avoid blocking recursive RPCs and prefer a data-driven
    approach that starts from the leaves of the procedure calls tree. Put simply,
    tree nodes, instead of waiting for requests from their parent nodes, send pre-processed
    data to all their possible callers each time their private data changes, as shown
    in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19820_14_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: Data-driven asynchronous communication'
  prefs: []
  type: TYPE_NORMAL
- en: Both communications labeled **1** are triggered when the data of the **C**/**D**
    microservices changes, and they may occur in parallel. Moreover, once a communication
    is sent, each microservice can return to its job without waiting for a response.
    Finally, when a request arrives at microservice **A**, **A** already has all the
    data it needs to build the response with no need to interact with other microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In general, microservices based on the data-driven approach pre-process data
    and send it to whichever other service might be interested. This way, each microservice
    already contains pre-computed data it can use to respond immediately to user requests
    with no need for further request-specific communications.
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, as new data becomes available, each microservice does its
    job and then sends the results to all interested microservices with asynchronous
    communications; that is, a microservice doesn’t wait for any acknowledgment from
    its recipients. Asynchronous communication is a must since each communication
    act usually triggers other communication acts recursively for the recipient, so
    we can’t block the whole tree of microservices until the final acknowledgment
    arrives from all the tree leaves, as in the case of RPC.
  prefs: []
  type: TYPE_NORMAL
- en: However, while being the only acceptable option for high-traffic microservices,
    the data-driven approach is more difficult to implement. In particular, the absence
    of acknowledgments creates complex coordination problems that increase the application
    development and testing time. We will discuss how to face coordination problems
    later on in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Here it is just worth stating the following rule of thumb.
  prefs: []
  type: TYPE_NORMAL
- en: Use the data-driven approach for all high-traffic worker microservices, but
    for services with shorter request-response cycles and experiencing low to moderate
    amounts of requests, use utilizing RPC (Remote Procedure Call).
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, actual applications mix efficient short-path RPC calls with the data-driven
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Another point that is worth mentioning is communication security. When security
    is needed, and communication relies on an underlying TCP/IP connection, we can
    simply use TLS/SSL (the same protocol used by HTTPS connections). However, in
    this case, since we are speaking of communications among servers, so there is
    no actual client, it is common that both communicating microservices authenticate
    each other with private key certificates, and then agree on a cryptographic protocol
    and key to secure their TLS/SS communication. .NET furnishes all tools for negotiating
    a TLS/SSL connection based on reciprocal authentication based on servers.
  prefs: []
  type: TYPE_NORMAL
- en: However, when all microservices are part of the same private network, it is
    common to secure just the communication in/out of this private network and not
    secure all the intranet communications, both to simplify the design of the overall
    communication strategy and to save the performance cost of encryption.
  prefs: []
  type: TYPE_NORMAL
- en: Another typical optimization of inter-application communications is the usage
    of binary serialization, which produces shorter messages and requires less bandwidth
    and less processing time. In fact, for instance, representing an integer within
    an object with a binary serialization costs about 4 bytes, that is, basically
    the same number of bytes needed to store it in the computer memory (there is a
    small overhead, for protocol-handling metadata), while representing the same integer
    as a text requires a byte for each digit, plus the bytes needed for the field
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Binary serialization is discussed in detail in the next subsection. Then, also,
    RPC- and data-driven asynchronous communication will be analyzed in dedicated
    subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Efficient and flexible binary serialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serialization is the process of transforming data in a way that they can be
    sent on a communication channel, or stored in a file. Therefore, the way data
    are serialized has a strong impact on the quantity of data that will be sent.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET echo system contains several fast, platform-specific binary serializers,
    which are able to produce compact, short messages with very low computational
    costs. In the *Implementing microservices with .NET worker services and message
    brokers* section, we will test one of the fastest, the *Binaron* package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, efficient binary serializers suffer from a couple of well-known
    problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Since the most performant binary serializers are tied to a specific platform,
    they are not interoperable. Thus, for instance, the Java binary format is not
    compatible with the .NET binary format. This constraint creates problems when
    your application microservices are heterogeneous and use different technologies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If one uses the same platform-specific, in-memory binary format, adding/removing
    properties to/from an object breaks compatibility. Thus, a microservice that uses
    an old version of a class is not able to de-serialize data created with a newer
    version of the same class. This constraint creates dependencies between the microservices’
    CI/CD cycles because when a microservice changes to meet new requirements, it
    causes recursive changes in all other microservices that communicate with it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Chapter 15*, *Applying Service-Oriented Architectures with .NET*, we will
    see that the JSON format was widely adopted because it avoids these two problems
    since it is not tied to any specific language/runtime, and added properties can
    simply be ignored, while removed properties are handled by assigning default values.
  prefs: []
  type: TYPE_NORMAL
- en: The **ProtoBuf** binary format was conceived to ensure the same JSON serialization/deserialization
    advantages for binary formats.
  prefs: []
  type: TYPE_NORMAL
- en: ProtoBuf achieves interoperability by defining abstract elementary types and
    their binary representations. Then, each framework takes care of converting its
    native types to/from them. Elementary types are combined into complex structures
    called **messages**, which represent classes.
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility between different versions of the same message is ensured by assigning
    a unique integer number to each property. This way, when a message is de-serialized
    into an object, just the integers that mark the property of the given message
    version are searched in the serialized data and de-serialized. When a property
    number is not found in the serialized data, the default value is taken for the
    associate property. This way, ProtoBuf messages have the same serialization/deserialization
    advantages as JSON objects. In a few words compatibility among different versions
    is ensured if the developer doesn’t change the number associated with each property.
    The developer can also remove properties, but without assigning their numbers
    to new properties, because these numbers have the purpose of naming (with very
    short names) all fields. The receiver uses these integer names to restore the
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: There are also other serialization proposals similar to ProtoBuf. Some of them
    also ensure better performance, but at the moment, ProtoBuf, which was created
    by Google, is the de facto standard for interoperable binary communication.
  prefs: []
  type: TYPE_NORMAL
- en: ProtoBuf messages are defined in `.proto` files and are then compiled into code
    in the target language by language-specific tools. The section that follows describes
    the ProtoBuf data description language.
  prefs: []
  type: TYPE_NORMAL
- en: The ProtoBuf language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each `.proto` file starts with a declaration of the version of ProtoBuf. At
    the moment, the highest available version is `proto3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Since .NET SDK will generate classes out of ProtoBuf definitions, then, if
    the target language is .NET, you can specify the namespace where you generate
    all the .NET classes corresponding to the ProtoBuf types defined in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can import definitions contained in other `.proto` files, with one
    or more `import` declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The above definition imports the definition of the `TimeStamp` type, which encodes
    both the `DateTime` and `DateTimeOffset` .NET types. `TimeStamp` is not a ProtoBuf
    simple type but is defined in a standard ProtoBuf types library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can scope all message definitions to a `package` to avoid name
    collisions. ProtoBuf packages have the same role as a .NET namespace but are not
    automatically converted into .NET namespaces during .NET code generation, since
    .NET namespaces are specified with the `option C#` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Each `.proto` file can contain several message definitions. Here is an example
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each property is specified by the property type followed by the property name,
    and then by the unique integer associated with that property. Property names must
    be in camel case, but they are converted to Pascal case during .NET code generation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a new version of `PurchaseMessage` is created, compatibility with the past
    version can be maintained by not reusing the integers assigned to the properties
    of the old version, and by removing just unused properties, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The new version of `PurchaseMessage` doesn’t contain properties `2` and `3`,
    but it contains the new `reseller` property, marked with the new `7` integer.
    The `Reseller` type is defined by another message that can be contained either
    in the same `.proto` file or an imported file.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, compatibility is maintained just with clients that don’t use the removed
    properties, while clients directly affected by the changes must be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Collections are represented by prefixing the name of the collection element
    type with the `repeated` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Repeated data are translated into the `Google.Protobuf.Collections.RepeatedField<T>`
    .NET type, which implements `IList<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries are represented with the `map<T1, T2>` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Messages can be nested in other messages, in which case they generate classes
    defined in other .NET classes during code generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define `enum` types that translate directly to .NET `enum` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to define messages with conditional content. This is useful
    for sending either a response or error information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a microservice receives a .NET object of the `ResponseMessage` type, it
    can process it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The table below summarizes all the ProtoBuf simple types and their equivalent
    .NET types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **.NET types** | **Protobuf types** |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | `double` |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | `float` |'
  prefs: []
  type: TYPE_TB
- en: '| `string` | `string` |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| `ByteString` | `bytes` |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | `int32, sint32, sfixed32` |'
  prefs: []
  type: TYPE_TB
- en: '| `uint` | `uint32, fixed32` |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | `int64, sint64, sfixed64` |'
  prefs: []
  type: TYPE_TB
- en: '| `ulong` | `uint64, fixed64` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 14.1: Mapping Protobuf Simple Types to .NET Equivalents'
  prefs: []
  type: TYPE_NORMAL
- en: The `ByteString` .NET type is defined in the `Google.Protobuf` namespace contained
    in the `Google.Protobuf` NuGet package. It can be converted to `byte[]` with its
    `.ToByteArray()` method. A `byte[]` object can be converted into a `ByteString`
    with the `ByteString.CopyFrom(byte[] data)` static method.
  prefs: []
  type: TYPE_NORMAL
- en: '`int32`, `sint32`, and `sfixed32` encode .NET `int`. Now, `sint32` is convenient
    when the integer is more likely to be negative, while the `sfixed32` type is convenient
    when the integer is likely to contain more than 28 bits. Similar considerations
    apply to `uint32` and `fixed32`.'
  prefs: []
  type: TYPE_NORMAL
- en: The same criteria apply to 64-bit integers, but in this case, the threshold
    for the convenience of `sfixed64` and `fixed64` is 56 bits.
  prefs: []
  type: TYPE_NORMAL
- en: ProtoBuf simple types are not nullable. This means that they can’t have a null
    value, and if no value is assigned to them, they take a default value. The default
    value of a `string` is an empty `string`, while the default value of a `ByteString`
    is an empty `ByteString`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need nullable types, you must include a predefined `.proto` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a table that details the correspondence between .NET nullable simple
    types and ProtoBuf nullable wrappers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **.NET types** | **ProtoBuf types** |'
  prefs: []
  type: TYPE_TB
- en: '| `double?` | `google.protobuf.DoubleValue` |'
  prefs: []
  type: TYPE_TB
- en: '| `float?` | `google.protobuf.FloatValue` |'
  prefs: []
  type: TYPE_TB
- en: '| `string?` | `google.protobuf.StringValue` |'
  prefs: []
  type: TYPE_TB
- en: '| `bool?` | `google.protobuf.BoolValue` |'
  prefs: []
  type: TYPE_TB
- en: '| `ByteString?` | `google.protobuf.BytesValue` |'
  prefs: []
  type: TYPE_TB
- en: '| `int?` | `google.protobuf.Int32Value` |'
  prefs: []
  type: TYPE_TB
- en: '| `uint?` | `google.protobuf.UInt32Value` |'
  prefs: []
  type: TYPE_TB
- en: '| `long?` | `google.protobuf.Int64Value` |'
  prefs: []
  type: TYPE_TB
- en: '| `ulong?` | `google.protobuf.UInt64Value` |'
  prefs: []
  type: TYPE_TB
- en: Table 14.2
  prefs: []
  type: TYPE_NORMAL
- en: '`DateTime`, `DateTimeOffset`, and `TimeSpan` have no direct equivalent in ProtoBuf,
    but the `Google.Protobuf.WellKnownTypes` namespace contained in the `Google.Protobuf`
    NuGet package contains the `Timestamp` type, which maps from/to `DateTime` and
    `DateTimeOffset`, and the `Duration` type, which maps from/to `TimeSpan`. The
    mapping is completely analogous to that of `ByteString`. Thus, for instance, a
    `Duration` is obtained from a `TimeSpan` with the `Duration.FromTimeSpan` static
    method, while a `Duration` is transformed into a `TimeSpan` by calling its `.ToTimeSpan`
    instance method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage of `Duration` and `Timestamp` in `.proto` files is shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Please notice that usage needs the import of predefined `.proto` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, there is no equivalent to the .NET `decimal` type, but it will
    probably be introduced in the next version. However, you can encode decimals with
    two integers, one for the integer part and the other for the decimal part, with
    a message like the one in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add implicit conversion to the .NET `decimal`, with a partial class
    that combines with another partial class, which is automatically generated from
    the `.proto` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have described almost completely the ProtoBuf data description language.
    The only missing subject is the representation of variable/unknown types, which
    are rarely used. However, the *Further reading* section contains a link to the
    official documentation. The next section explains how to serialize and de-serialize
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: ProtoBuf serialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An object tree can be serialized as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WriteTo` method needs a stream so create an in-memory stream. After, we
    create a byte array from the stream with `ToArray`, which ensures that the stream
    buffer is actually written into the stream before attempting the extraction of
    the byte array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, since `ParseFrom` also needs a stream, we generate a stream from the message
    bytes.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection describes the usage of RPC in microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Efficient and flexible RPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The RPC approach can be adopted in some application microservices with good
    results if the following conditions are met:'
  prefs: []
  type: TYPE_NORMAL
- en: The chain of recursive calls is very short, usually just one call without recursive
    calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low communication latency and high channel bandwidth. This condition is met
    by intranet communications that take place on high-speed Ethernet within the same
    data center.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is serialized quickly and in a very size-efficient format. This condition
    is met by any efficient binary serializer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long chains of recursive calls are avoided whenever RPC is used just to queue
    a request and to receive confirmation that the request has been correctly queued,
    without waiting for any processing result. In this case, RPC is used to simulate
    an asynchronous communication with reception confirmation. If this is the case,
    all of these conditions are easily met whenever all communicating microservices
    are part of the same **local area network** (**LAN**) where all computers are
    connected with high-speed physical connections.
  prefs: []
  type: TYPE_NORMAL
- en: On the contrary, when the communicating microservices are geographically distributed
    and are part of a WAN instead of a LAN, waiting for confirmation of the reception
    of an RPC message might be unacceptable for high-traffic microservices. In this
    case, it is better to rely on message brokers that support completely asynchronous
    communications.
  prefs: []
  type: TYPE_NORMAL
- en: The gRPC protocol brings all the advantages of ProtoBuf to RPC since, by default,
    it is based on ProtoBuf. gRPC/ProtoBuf is a binary protocol that works over an
    HTTP/2 connection. It is worth pointing out that gRPC can’t work with HTTP versions
    less than 2\. In the remainder of the chapter, we will always assume that gRPC
    uses ProtoBuf.
  prefs: []
  type: TYPE_NORMAL
- en: 'gRPC uses `.proto` files, but together with data, gRPC `.proto` files also
    define services with their RPC methods. Here is a service definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Each service is introduced by the `service` keyword, while each method is introduced
    by the `rpc` keyword. Each service specifies an input message and an output message.
    If either of these two messages is empty, we can use the predefined `google.protobuf.Empty`
    message, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`.proto` files can be used to generate both server code and client code. In
    client code, each service is translated into a proxy class with the same methods
    declared in the service. Each of the proxy methods automatically invokes the remote
    service method and returns its result.'
  prefs: []
  type: TYPE_NORMAL
- en: The server code, instead, translates each service into an abstract class, whose
    virtual methods correspond to methods declared in the service. The developer is
    responsible for inheriting from this abstract class and providing implementations
    for all service methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is an example of how to inherit from a similar class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Each method receives both the input message and a context object. Since gRPC
    services use ASP.NET Core infrastructure, the context object furnishes access
    to the request `HttpContext` through `context.GetHttpContext()`.
  prefs: []
  type: TYPE_NORMAL
- en: An ASP.NET Core application is enabled to gRPC with `builder.Services.AddGrpc()`
    and by declaring each service with something like `app.MapGrpcService<CounterService>();`.
  prefs: []
  type: TYPE_NORMAL
- en: More details on both gRPC servers and clients will be given while discussing
    the example in the *A worker microservice with ASP.NET core* section of *Chapter
    21, Case Study*.
  prefs: []
  type: TYPE_NORMAL
- en: Services can receive as input and return continuous streams of data, where a
    long-term connection between the client and server is established. However, the
    usage of streams in microservices is not common since microservices are ephemeral
    processes that are frequently shut down and moved from one processing node to
    another by orchestrators, so long-term connections are not easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a service that accepts and returns a stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Each input stream is passed as an argument to the .NET implementation of the
    method. If the method returns a stream, the .NET implementation of the method
    must return a `Task`, and also the output stream is passed as an argument to the
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'On the client side, both input and output streams are available in the `call`
    object that is returned when the proxy method is called without awaiting it, as
    shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `CompleteAsync()` method closes the request stream, declaring that the input
    is finished.
  prefs: []
  type: TYPE_NORMAL
- en: More practical details on the client usage are given in the example in the *A
    worker microservice with ASP.NET core* section of *Chapter 21, Case Study*, while
    the *Further reading* section contains a link to the .NET gRPC official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection describes how to implement data-driven asynchronous communication.
  prefs: []
  type: TYPE_NORMAL
- en: Reliable data-driven asynchronous communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Non-blocking communication must necessarily rely on non-volatile queues to
    decouple the sender thread from the receiving thread. Decoupling can be achieved
    with just one queue on each communication path, but sometimes additional queues
    improve performance and increase CPU usage. Queues, can be placed in three places:
    within the microservice that sends the message, within the microservice that receives
    the message, or outside both microservices using dedicated services known as message
    brokers. by using dedicated queuing services called **message brokers**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Service Bus**, which we described in the *.NET communication facilities*
    subsection of *Chapter 11*, *Applying a Microservice Architecture to Your Enterprise
    Application*, is a message broker that, like most message brokers, offers queuing
    services and publisher/subscriber communication. In this chapter, we will also
    describe **RabbitMQ**, which offers queuing services and publisher/subscriber
    communication that is broadly similar to **Azure Service Bus** **topics**. Since
    it is easier to debug code that uses a local instance of RabbitMQ, often it is
    convenient to use RabbitMQ during development and then move to Azure Service Bus.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Queues decouple the sender and receiver but do not ensure that messages are
    not lost. In the *Resilient task execution* section of *Chapter 11,* we have already
    discussed strategies for achieving reliable communication. Here we give more practical
    details for preventing message losses with confirmations and timeouts:'
  prefs: []
  type: TYPE_NORMAL
- en: Queues must be stored on permanent storage; otherwise, their content can be
    lost if the processes controlling them either crash or are shut down.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a confirmation that the message was successfully inserted in the queue doesn’t
    arrive within a timeout time, the source assumes that the message was lost and
    retries the operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a message is extracted from a queue, it remains blocked and inaccessible
    to other consumers. If a confirmation that the message has been successfully processed
    arrives within a timeout time, the message is removed from the queue; otherwise,
    it is unblocked and becomes available again to other consumers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All confirmations can be handled asynchronously with the exception of the insertion
    in the first queue of a communication path. In fact, if the sending code doesn’t
    remain blocked waiting for the confirmation but moves to further processing and
    the message is lost, there is no way to resend the message, since the message
    cannot be taken from any other queue.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, sometimes microservices that use a message broker also have
    an internal queue. More specifically, the main microservice thread produces all
    messages and stores them in a local queue that can be implemented with a database
    table. Another thread takes care of extracting messages from this queue and sending
    them to the message broker.
  prefs: []
  type: TYPE_NORMAL
- en: Messages that are removed from the local queue are blocked and removed only
    when an asynchronous confirmation arrives from the message broker. This technique
    is used in the example of *Chapter 18*, *Implementing Frontend Microservices with
    ASP.NET Core*. The main advantage of the local queue is that confirmation from
    a local queue usually arrives faster because there is less concurrency with other
    threads/processes (don’t forget that each microservice should have a private database/permanent
    storage), so the blocking time is more acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a queue inside each receiver is a viable alternative to message brokers.
    The main advantage of private queues is that the process that handles the queue
    is not shared among several microservices, so all queue operations are faster.
    In particular, the confirmation of each insertion is immediate, so the sender
    can use a blocking RPC call to send the message. However, this simple solution
    has the following disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no way to implement the publisher/subscriber pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just one microservice instance can extract messages from the queue. Therefore,
    microservices can’t be scaled horizontally. Limited vertical scaling can be achieved
    by increasing the number of processor cores and by processing queue messages with
    parallel threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A similar approach can be efficiently implemented with gRPC and ASP.NET Core
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The sender sends the message to a gRPC method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The gRPC method just enqueues the message and immediately returns a confirmation
    to the sender.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An ASP.NET Core hosted process takes care of extracting the messages from the
    queue and passing them to several parallel threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a message is passed to a thread, it remains blocked and inaccessible. It
    is removed only after the thread confirms that the message has been successfully
    processed. If, instead, a thread reports a failure, the corresponding message
    is unblocked so it can be passed to another thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ASP.NET Core threads take care of the necessary input parallelism. Some horizontal
    parallelism can be achieved by using load balancers and several web servers. However,
    in this case, either all the web servers use the same database, thus increasing
    the concurrency on the queue, or we use several sharded databases.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is described in more detail in the example in the *Implementing
    worker microservices with ASP.NET core* section. As we will see, it is simple
    to implement and ensures good response time, but due to its limited scalability,
    it is adequate just for small or medium-sized applications with low to medium
    traffic.
  prefs: []
  type: TYPE_NORMAL
- en: If, for some reason, either an insertion in a queue or the processing of a message
    extracted by a queue requires more time than the timeout time, the operation is
    repeated so that the same message is processed twice. Therefore, messages must
    be idempotent, meaning processing them once or several times must have the same
    effect. Record updates and deletions are intrinsically idempotent since repeating
    an update or a deletion several times doesn’t change the result, but record additions
    are not.
  prefs: []
  type: TYPE_NORMAL
- en: Idempotency can always be forced by assigning a unique identifier to messages
    and then storing the identifiers of the already processed messages. This way,
    each incoming message can be discarded when its identifier is found among the
    identifiers of the already processed messages. We will use this technique in all
    examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Queues, confirmations, and message resends ensure that requests to a single
    microservice are safely processed, but how can we handle requests that involve
    several cooperating microservices? We will discover that in the next subsection.
    There, we will explain how distributed microservices can coordinate and reach
    agreements to yield coherent behavior with only the help of asynchronous communication.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Everyone knows what a database transaction is: several records are modified
    one after the other, but if a single action fails, all previous modifications
    are also undone before aborting the transaction. That is, either all operations
    succeed or they fail simultaneously.'
  prefs: []
  type: TYPE_NORMAL
- en: A distributed transaction does the same job, but in this case, the records are
    not part of a single database but are distributed among the databases associated
    with several cooperating microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The reliable data-driven communication techniques described so far are the building
    blocks for solving more complex cooperation problems.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s suppose that a user operation triggers processing and storage in several
    related microservices. The user operation can be considered successfully completed
    only if all involved processing/storage operations succeed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, if a single processing/storage operation also fails for some fundamental
    reason, retrying the failed operation doesn’t help. Think, for instance, of a
    purchase that fails because the user has not got enough funds to complete the
    payment: the only way out is to undo all the operations that have already been
    performed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, similar situations must be handled in a transactional way; either
    all operations are performed, or no operation is performed. Transactions that
    span several microservices are known as **distributed transactions**. In theory,
    **distributed transactions** can be handled with the following two-stage protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first stage, all operations are executed, each one in the scope of a
    local transaction (for instance, within the scope of each microservice database
    transaction). The success or failure of each operation is then returned to a transaction
    coordinator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the second stage, the transaction coordinator informs all microservices of
    the success or failure of the overall operation. In the case of failure, all local
    transactions are rolled back; otherwise, they are committed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When using asynchronous messages, confirmations may arrive after quite a large
    amount of time and may interleave with other transactions performed on the same
    resources. Therefore, having all local resources blocked by a local transaction
    during a possibly time-consuming distributed transaction is not acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, microservices transactions use the **saga** pattern: all local
    operations are performed without opening a local transaction, and in the case
    of failure, they are compensated by other operations that undo the initial operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Undoing a database insertion is quite easy since it is enough to remove the
    added item, but undoing modifications and deletes is quite difficult and requires
    the storage of additional information. The general solution to this problem is
    storing records that represent all database changes in a table. These records
    can be used to compute a compensation operation or to restore the previous database
    state starting from a reference database state. We already discussed this storage
    technique, which is called **event sourcing**, in the *Event sourcing* section
    of *Chapter 7*, *Understanding the Different Domains in Software Solutions*. Just
    to recap, and in a few words, each database stores not only the actual state but
    also the history of all changes up to a certain previous time.
  prefs: []
  type: TYPE_NORMAL
- en: When a saga transaction is undone, if other saga transactions depend on the
    undone changes, we must also undo them. For instance, suppose that an accepted
    purchase order depends on the funds uploaded by a user on an e-commerce platform.
    Then, if the funds upload transaction is undone, the purchase must also be undone.
  prefs: []
  type: TYPE_NORMAL
- en: In order to avoid similar chain reactions when a saga transaction is undone,
    often new transactions are accepted only if they depend on changes that took place
    before a certain safety interval. Thus, for instance, uploaded funds are made
    available only after, say, 5-10 minutes, because it is very unlikely that a transaction
    will be undone after more than 5-10 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Saga transactions may use two fundamental techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Orchestration**: When the transaction starts, an orchestrator component is
    created that takes care of sending the necessary messages to all involved microservices
    and receiving their success/failure messages. This technique is easy to implement
    but creates dependencies between the software lifetimes of the involved microservices
    since the orchestrator must depend on the details of all microservices involved
    in the saga. Moreover, this technique may have poor performance since the orchestrator
    becomes a bottleneck.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Choreography**: There is no centralized control of the transaction but each
    microservice is invoked by a different sending microservice and forwards the success/failure
    messages it receives to other communication neighbors. Choreography overcomes
    the disadvantages of orchestration but it is more difficult to implement and test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following table summarizes the pros and cons of the two techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Code maintainability** | **Difficulties in designing and debugging**
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Choreography** | Good | Quite high |'
  prefs: []
  type: TYPE_TB
- en: '| **Orchestration** | Low | No particular difficulty |'
  prefs: []
  type: TYPE_TB
- en: 'Table 14.3: Pros and cons of choreography and orchestration'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing worker microservices with ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to avoid blocking the caller’s synchronous request for too much time,
    an ASP.NET Core-based solution requires the implementation of an internal queue
    where it can store all received messages. This way, when a message is received,
    it is immediately enqueued without processing it, so that a “received” response
    can be immediately returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the application level needs a repository interface that handles
    the queue. Here is a possible definition of this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QueueItem` is a class that contains all request information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Enqueue` adds a new message to the queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Top` returns the first `n` queue items without removing them from the queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dequeue` removes the first `n` messages from the queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual implementation of the preceding interface can be based on a database
    table, or any other storage media.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application level can be implemented with an ASP.NET Core gRPC project
    that organizes all the gRPC stuff for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_14_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: Creating a gRPC Server project'
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual request processing is performed by a worker-hosted service that
    runs in parallel with the ASP.NET Core pipeline. It is implemented with the hosted
    services we discussed in the *Using generic hosts* section of *Chapter 11*, *Applying
    a Microservice Architecture to Your Enterprise Application*. It is worth recalling
    that hosted services are implementations of the `IHostedService` interface defined
    in the dependency injection engine as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Being defined in the dependency injection engine, they are automatically injected
    services in their constructors. Hosted services are used to execute parallel threads
    that run independently of the remainder of the application. Usually, they are
    not defined by directly implementing the `IHostedService` interface, but by inheriting
    from the abstract `BackgroundService` class and overriding its `Task ExecuteAsync(CancellationToken
    token)` abstract method.
  prefs: []
  type: TYPE_NORMAL
- en: The `ExecuteAsync` method usually contains an endless loop that exits only when
    the application is shut down. This endless loop defines the behavior of a worker-hosted
    service that repeats a certain task. In our case, the task to repeat is the continuous
    extraction and processing of `N` items from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a possible implementation of our hosted service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The class constructor is not injected with the specific services it needs but
    instead has the `IServiceProvider` that can be used to get any service defined
    in the dependency injection engine. The reason for this choice is that it will
    launch several threads (one for each of the `N` messages extracted from the queue),
    and, in general, different threads can’t share the same service instance.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is caused by services with a session scope. Usually, these services
    are not designed to be thread-safe since the single session-scoped instance used
    throughout a whole ASP.NET Core request is never shared among parallel threads.
    However, we are not going to use our services from within the usual ASP.NET Core
    pipeline but from within parallel threads launched by our hosted service. Therefore,
    we need a different session scope for each parallel thread.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the right way to process is to use `IServiceProvider` to create each necessary
    scope and then use each scope to get a different instance for each parallel thread.
  prefs: []
  type: TYPE_NORMAL
- en: The inner `while` loop runs until the queue is empty, then the worker thread
    sleeps for 100 milliseconds and then tries the inner loop again to see if in the
    meantime some new message reached the queue.
  prefs: []
  type: TYPE_NORMAL
- en: When the application is shut down, the `stoppingToken` `CancellationToken` is
    signaled and both loops exit, so that the whole `ExecuteAsync` method exits and
    the worker thread dies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the content of the inner loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A session scope surrounds the whole code since we need a unique instance of
    `IMessageQueue` to manipulate the queue.
  prefs: []
  type: TYPE_NORMAL
- en: The code tries to extract `N` messages from the queue. If no message is found,
    `queueEmpty` is set to `true`, so that the inner loop exits; otherwise, a `for`
    loop creates a separate task for each extracted request and inserts it in the
    `tasks` array.
  prefs: []
  type: TYPE_NORMAL
- en: Then, `Task.WhenAll` awaits all tasks. Finally, `queue.Dequeue` removes from
    the queue all not-null requests returned from the tasks. Since a not-null request
    is returned only in the case of successful processing, `queue.Dequeue` removes
    just the successfully processed requests.
  prefs: []
  type: TYPE_NORMAL
- en: The `toExecute` method performs the actual request processing that depends on
    the specific application.
  prefs: []
  type: TYPE_NORMAL
- en: A complete example containing all details and a step-by-step guide to its practical
    implementation is described in the *A worker microservice with ASP.NET Core* section
    of *Chapter 21, Case Study*. The complete source code of the example is contained
    in the folder associated with this chapter in the book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: The next section shows you how to modify the code of this example to use queued
    communication based on the **RabbitMQ** message broker.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing microservices with .NET worker services and message brokers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section explains the modifications needed to use a message broker instead
    of gRPC communication with an internal queue. This kind of solution is usually
    more difficult to test and design but allows for better horizontal scaling.
  prefs: []
  type: TYPE_NORMAL
- en: The message broker used in the code is **RabbitMQ**. However, we could also
    replace it with **Azure Service Bus** using the code available in the GitHub repository
    associated with the book. The next subsection explains how to install RabbitMQ
    on your development machine. We used RabbitMQ to give the reader the opportunity
    to install and study it, since Azure Service Bus needs less configuration and
    is immediately ready to use. In an actual production system, one might choose
    RabbitMQ, just so you are not tied to a specific cloud provider, because while
    Azure Service Bus is available just on Azure, RabbitMQ can be installed in any
    cloud or on-premises environment.
  prefs: []
  type: TYPE_NORMAL
- en: Installing RabbitMQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before installing **RabbitMQ,** you need to install **Erlang** from the link
    given in the *Technical requirements* section. Just download and execute the installer
    from an administrative account. After that, you can download and install RabbitMQ
    from the link in the *Technical requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: If installation is successful, you should find a service called **RabbitMQ**
    among your machine’s Windows services. If either you don’t find it or it is not
    running, restart your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Administrative commands can be issued to RabbitMQ from the command prompt, which
    you can find in the **RabbitMQ Server** Windows menu folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also enable a web-based administrative UI. Let’s open the RabbitMQ
    command prompt and issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Then, go to `http://localhost:15672`. You will be prompted for a username and
    password. Initially, they are both set to **guest**. From there, you may inspect
    all active connections and channels and all communication queues that have been
    created. The queues page contains all queues that have been defined. By clicking
    on each of them, you move to a queue-specific page where you can inspect the queue
    content and perform various operations on the specific queue.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection contains a short survey of RabbitMQ features.
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Natively, RabbitMQ supports the AMQP asynchronous message protocol, which is
    one of the most used asynchronous protocols, the other being MQTT, which has a
    specific syntax for the publisher/subscriber pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Support for MQTT can be added with a plugin, but RabbitMQ has facilities for
    implementing easily a publisher/subscriber pattern on top of AMQP. Moreover, RabbitMQ
    offers several tools to support scalability, disaster recovery, and redundancy,
    so it fulfills all requirements to be a first-class actor in cloud and microservices
    environments. More specifically, it supports data replication like most SQL and
    NoSQL databases and also supports cooperation among several servers based on sophisticated
    and flexible techniques. For lack of space, in this section, we will describe
    just RabbitMQ’s basic operations, but the reader can find more details in the
    tutorials and documentation of RabbitMQ’s official website: [https://www.rabbitmq.com/](https://www.rabbitmq.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ messages must be prepared in binary format since RabbitMQ messages
    must be just an array of bytes. Therefore, we need to serialize .NET objects with
    a binary formatter before sending them. In the example in this section, we will
    test both the ProtoBuf serializer and a fast .NET-specific serializer called *Binaron*.
    It might also be possible to use a JSON serializer to ensure better compatibility
    if there are compatibility issues among microservices implemented with different
    frameworks by different teams, and/or if there are legacy microservices. It is
    worth recalling that JSON is usually more compatible but less efficient, while
    binary formats are less compatible. ProtoBuf tries to solve the binary compatibility
    issue by defining a universal binary language, but it is not an official standard
    but a de facto standard.
  prefs: []
  type: TYPE_NORMAL
- en: Messages are not sent directly to queues, but to other entities called **exchanges**
    that route them to queues. Exchanges are AMQP-specific concepts, and are RabbitMQ’s
    way of configuring complex communication protocols like the publisher/subscriber
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_14_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: RabbitMQ exchanges'
  prefs: []
  type: TYPE_NORMAL
- en: 'To adequately define the exchange routing strategy, we can implement several
    patterns. More specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: When we use a default exchange, the message is sent to a single queue and we
    can implement asynchronous direct calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we use a `fanout` exchange, the exchange will send the message to all queues
    that subscribe to that exchange. This way, we can implement the publisher/subscriber
    pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also a `topic` exchange that enhances the publisher/subscriber pattern
    by enabling the matching of several events with wildcard chars. However, it is
    not usually needed in microservices for enterprise applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our examples will describe just direct calls, but the *Further reading* section
    contains a link to RabbitMQ tutorials that show examples of publisher/subscriber
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: The next section explains how to modify the code in the previous section to
    use RabbitMQ-based direct communication.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing internal queues with RabbitMQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As previously discussed, in high-traffic WAN networks also receiving a synchronous
    received-message acknowledgment has an unacceptable performance impact, so no
    RPC protocol can be used. Moreover, often microservices use the publisher/subscriber
    pattern to achieve the best decoupling. In these cases, using a message broker
    is a MUST. Finally, having all queues handled by a unique scalable broker enables
    the independent and easy scaling of the communication resources. This capability
    is fundamental for optimizing the performance of applications made of hundreds
    or thousands of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up, there are cases where message brokers are a MUST or are at least
    the best choice. Therefore, in this section, we will show how to use them by transforming
    the previous project so that it uses RabbitMQ instead of gRPC and internal queues.
  prefs: []
  type: TYPE_NORMAL
- en: Unluckily this transformation requires a complete restructuration of the microservice
    project. We can save business and data layers but we need to move from an ASP.NET
    Core project to a different project template called **Worker Service**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, let’s replace the ASP.NET Core project with a **Worker Service**
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_14_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: Setup Process for a gRPC Server Project in ASP.NET Core'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need the gRPC services anymore, but we need ProtoBuf because RabbitMQ
    works with binary messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Worker Service project automatically scaffolds a hosted service (hosted
    services were discussed in detail in the *Using generic hosts* section of *Chapter
    11, Applying a Microservice Architecture to Your Enterprise Application*). However,
    the `ExecuteAsync` method of this hosted service must be a little bit different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Inside the main loop, if an exception is thrown, it is intercepted by the empty
    `catch`. Since the two `using` statements are left, both the connection and channel
    are disposed of. Therefore, after the exception, a new loop is executed that creates
    a new fresh connection and a new channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Intercepting exceptions is fundamental for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, it avoids the microservice crash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enables a complete reset of all client objects involved in the communication
    with the RabbitMQ server that might be damaged by the error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows an error logging that, in the actual production environment, is the
    basic monitoring tool. For simplicity, error logging is not shown in the code
    snippets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `using` statement body, we ensure that our queue exists, and then set
    `prefetch` to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring queues exist and creating them if they don’t exist is better than relying
    on a single microservice for creating them since this approach avoids introducing
    complex dependencies and maintenance challenges related to the sequence in which
    microservices will run.
  prefs: []
  type: TYPE_NORMAL
- en: Setting `prefetch` to `1` causes each server to extract just one message at
    a time, which ensures a fair distribution of the load among all servers. However,
    setting `prefetch` to `1` might not be convenient when each server runs several
    equal parallel threads to process the incoming messages since it sacrifices thread
    usage optimization in favor of fair distribution of messages among servers. As
    a consequence, threads that could successfully process further messages (after
    the first) might remain idle, thus possibly wasting processor cores available
    on each server machine.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define a `message received` event handler. `BasicConsume` starts the
    actual message reception. With `autoAck` set to `false`, when a message is read
    from the queue, it is not removed but just blocked, so it is not available to
    other servers that read from the same queue. The message is actually removed when
    a confirmation that it has been successfully processed is sent to RabbitMQ. We
    can also send a failure confirmation, in which case the message is unblocked and
    becomes available for processing again.
  prefs: []
  type: TYPE_NORMAL
- en: If no confirmation is received, the message remains blocked till the connection
    and channel are disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: Since `BasicConsume` is non-blocking, the `Task.Delay` after it blocks until
    the cancellation token is signaled. In any case, after 1 second `Task.Delay` unblocks
    and both the connection and the channel are replaced with fresh ones. This prevents
    non-confirmed messages from remaining blocked forever.
  prefs: []
  type: TYPE_NORMAL
- en: Making instructions like `BasicConsume` non-blocking prevents a thread from
    wasting processor cores by remaining blocked while waiting for an event. Instead,
    the thread is put in sleeping mode by instructions like `Task.Delay`, thus freeing
    up all its resources and its assigned processor core, which, this way, can be
    assigned to another parallel thread that was waiting for a free core for its execution.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the code inside the “message received” event. This is the place
    where the actual message processing takes place.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, the code verifies if the application is being shut down, in
    which case it disposes of the channel and connection and returns without performing
    any further operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, a session scope is created to access all session-scoped dependency injection
    services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the case that an exception is thrown during the message processing, a `Nack`
    message is sent to RabbitMQ to inform it that the message processing failed. `ea.DeliveryTag`
    is a tag that uniquely identifies the message. The second argument set to `false`
    informs RabbitMQ that the `Nack` is just for the message identified by `ea.DeliveryTag`
    that doesn’t also involve all other messages waiting for confirmation from this
    server. Finally, the last argument set to `true` asks RabbitMQ to requeue the
    message whose processing failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `try` block, there is the actual message processing. Its first step
    is the message deserialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, there is the actual application-dependent message processing. If
    this processing fails, we must send a `Nack`; otherwise, we must send an `Ack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The full code of a complete example is in the `GrpcMicroServiceRabbitProto`
    subfolder of the `ch15` folder in the GitHub repository of this book. A detailed
    description of this example is in the *A worker microservice based on RabbitMQ*
    section of *Chapter 21*, *Case Study*.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter describes service-oriented architecture and how to implement
    it with ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we analyzed various options for efficient internal microservices
    communication. We explained the importance of a binary serialization that is interoperable
    and that ensures compatibility with previous message versions, and we described
    ProtoBuf in detail.
  prefs: []
  type: TYPE_NORMAL
- en: We analyzed the limits of RPC communication and why data-driven communication
    must be preferred. Then, we focused on how to achieve reliable asynchronous communication
    and efficient distributed transactions.
  prefs: []
  type: TYPE_NORMAL
- en: After having described the conceptual problems and techniques of reliable asynchronous
    communication, we looked at two architectures. The first one was based on gRPC,
    ASP.NET Core, and internal queues, and the second one was based on message brokers
    like RabbitMQ and .NET worker services.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter explained, using practical examples, how to implement all the communication
    protocols that have been discussed and the architectural options for implementing
    worker microservices that are available in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why are queues so important in microservices communication?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we recall another `.proto` file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we represent a `TimeSpan` in the ProtoBuf language?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of ProtoBuf and gRPC over other binary options?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of using message brokers instead of internal queues?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it acceptable to use a blocking gRPC call to enqueue a message in a recipient
    queue?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we enable `.proto` file code generation in a .NET project file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do I send a message on a RabbitMQ channel with the official .NET client?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you ensure that a message sent on a RabbitMQ channel is safely saved
    on disk using the official .NET client?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official .NET documentation on ProtoBuf can be found here: [https://docs.microsoft.com/it-it/aspnet/core/grpc/protobuf?view=aspnetcore-6.0](https://docs.microsoft.com/it-it/aspnet/core/grpc/protobuf?view=aspnetcore-6.0).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The .NET documentation on gRPC is here: [https://docs.microsoft.com/it-it/aspnet/core/grpc/?view=aspnetcore-6.0](https://docs.microsoft.com/it-it/aspnet/core/grpc/?view=aspnetcore-6.0).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official Google documentation on the whole ProtoBuf language is here: [https://developers.google.com/protocol-buffers/docs/proto3](https://developers.google.com/protocol-buffers/docs/proto3).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Complete tutorials on RabbitMQ can be found here: [https://www.rabbitmq.com/tutorials/tutorial-two-dotnet.html](https://www.rabbitmq.com/tutorials/tutorial-two-dotnet.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The complete documentation for RabbitMQ is here: [https://www.rabbitmq.com/](https://www.rabbitmq.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code175081751210902046.png)'
  prefs: []
  type: TYPE_IMG
