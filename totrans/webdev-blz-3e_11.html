<html><head></head><body>
<div><h1 class="chapterNumber">11</h1>
<h1 class="chapterTitle" id="_idParaDest-197">Managing State – Part 2</h1>
<p class="normal">In this chapter, we continue to look at managing state. Most applications manage state in some form.</p>
<p class="normal">A state<a id="_idIndexMarker447"/> is simply information that is persisted in some way. It can be data stored in a database, session states, or even something stored in a URL.</p>
<p class="normal">The user state<a id="_idIndexMarker448"/> is stored in memory either in the web browser or on the server. It contains the component hierarchy and the most recently rendered UI (render tree). It also contains the values or fields and properties in the component instances as well as the data stored in service instances in dependency injection.</p>
<p class="normal">If we make JavaScript calls, the values we set are also stored in memory. Blazor Server relies on the circuit (SignalR connection) to hold the user state, and Blazor WebAssembly relies on the browser’s memory. But when we have a mix of both states, state management becomes a bit trickier. If we reload the page, the circuit and the memory will be lost. The same goes for switching pages; if there are no more <code class="inlineCode">InteractiveServer</code> components on the page, the SignalR connection will be terminated and the state lost. Managing state is not about handling connections or connection issues but rather how we can keep the data even if we reload the web browser.</p>
<p class="normal">Saving state between page navigations or sessions improves the user experience and could be the difference between a sale and no sale. Imagine reloading the page and all your items in the shopping cart are gone; the chances are you won’t shop there again.</p>
<p class="normal">Now imagine returning to a page a week or month later and all those things are still there.</p>
<p class="normal">In this chapter, we will cover the following topics:</p>
<ul>
<li class="bulletList">Storing data on the server side</li>
<li class="bulletList">Storing data in the URL</li>
<li class="bulletList">Implementing browser storage</li>
<li class="bulletList">Using an in-memory state container service</li>
<li class="bulletList">State management frameworks</li>
<li class="bulletList">Root-level cascading values</li>
</ul>
<p class="normal">We have already talked about and even implemented some of these things. Let’s take this opportunity to recap the things we have already talked about, as well as introduce some new techniques.</p>
<h1 class="heading-1" id="_idParaDest-198">Technical requirements</h1>
<p class="normal">Make sure you have followed the previous chapters or use the <code class="inlineCode">Chapter10</code> folder as a starting point.</p>
<p class="normal">You can find the source code for this chapter’s end result a<a href="https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter11">t https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter</a>11.</p>
<p class="normal">If you are jumping into this chapter using the code from GitHub, make sure you have added <code class="inlineCode">Auth0</code> account information in the <code class="inlineCode">Settings</code> files. You can find the instructions in <em class="chapterRef">Chapter 8</em>, <em class="italic">Authentication and Authorization</em>.</p>
<h1 class="heading-1" id="_idParaDest-199">Storing data on the server side</h1>
<p class="normal">There<a id="_idIndexMarker449"/> are many<a id="_idIndexMarker450"/> different ways in which to store data on the server side. The only thing to remember is that Blazor WebAssembly (or <code class="inlineCode">InteractiveWebAssembly</code>) will always need an API. Blazor Server (or <code class="inlineCode">InteractiveServer</code>) doesn’t need an API since we can access the server-side resources directly.</p>
<p class="normal">I have had discussions with many developers regarding APIs or direct access, which all boils down to what you intend to do with the application. If you are building a Blazor Server application and have no interest in moving to Blazor WebAssembly, I would probably go for direct access, as we have done in the <code class="inlineCode">MyBlog</code> project.</p>
<p class="normal">I would not do direct database queries in the components, though. I would keep them in an API, just not a Web API. As we have seen, exposing those API functions in an API, as we did in <em class="chapterRef">Chapter 7</em>, <em class="italic">Creating an API</em>, does not require a lot of steps. We can always start with direct server access and move to an API if we want to.</p>
<p class="normal">When it comes to storing data, we can save it in Blob storage, key-value storage, a relational database, a document database, table storage, and so on.</p>
<p class="normal">There is<a id="_idIndexMarker451"/> no end to the<a id="_idIndexMarker452"/> possibilities. If .NET can communicate with the technology, we will be able to use it.</p>
<h1 class="heading-1" id="_idParaDest-200">Storing data in the URL</h1>
<p class="normal">At first glance, this option might sound horrific but it’s not. Data, in <a id="_idIndexMarker453"/>this case, can be the blog post ID or the page number if we use paging. Typically, the things you want to save in the URL are things you want to be able to link to later on, such as blog posts in our case.</p>
<p class="normal">To read a parameter from the URL, we use the following syntax:</p>
<pre class="programlisting code"><code class="hljs-code">@page "/posts/{PageNumber:int}"
</code></pre>
<p class="normal">The URL is <code class="inlineCode">posts</code> followed by the page number (for paging through blog posts) of the post.</p>
<p class="normal">To find that particular route, <code class="inlineCode">PageNumber</code> must be an integer; otherwise, the route won’t be found.</p>
<p class="normal">We also need a <code class="inlineCode">public</code> parameter with the same name:</p>
<pre class="programlisting code"><code class="hljs-code">[Parameter]
public int PageNumber{ get; set; }
</code></pre>
<p class="normal">If we store data in the URL, we need to make sure to use the <code class="inlineCode">OnParametersSet</code> or <code class="inlineCode">OnParametersSetAsync</code> method; otherwise, the data won’t get reloaded if we change the parameter. If the parameter changes, Blazor won’t run <code class="inlineCode">OnInitializedAsync</code> again.</p>
<p class="normal">This is why our <code class="inlineCode">post.razor</code> component loads the things that change based on the parameter in the URL in <code class="inlineCode">OnParametersSet</code>, and loads the things that are not affected by the parameter in <code class="inlineCode">OnInitializedAsync</code>.</p>
<p class="normal">We can use optional parameters by specifying them as nullable, like this:</p>
<pre class="programlisting code"><code class="hljs-code">@page "/post/{PageNumber:int?}"
</code></pre>
<p class="normal">So this route would match “<code class="inlineCode">/post/</code>" and “<code class="inlineCode">/post/42</code>", for example.</p>
<h2 class="heading-2" id="_idParaDest-201">Route constraints</h2>
<p class="normal">When we specify what type the parameter should be, this is called<a id="_idIndexMarker454"/> a <strong class="keyWord">route constraint</strong>. We add a constraint so the match will only happen if the parameter value can be converted into the type we specified.</p>
<p class="normal">The following constraints are available:</p>
<ul>
<li class="bulletList"><code class="inlineCode">bool</code></li>
<li class="bulletList"><code class="inlineCode">datetime</code></li>
<li class="bulletList"><code class="inlineCode">decimal</code></li>
<li class="bulletList"><code class="inlineCode">float</code></li>
<li class="bulletList"><code class="inlineCode">guid</code></li>
<li class="bulletList"><code class="inlineCode">int</code></li>
<li class="bulletList"><code class="inlineCode">long</code></li>
</ul>
<p class="normal">The URL elements will be converted in to a <strong class="keyWord">C#</strong> object. Therefore, it’s important to use an invariant culture when adding them to a URL. string is not part of the list because that is the default behavior.</p>
<h2 class="heading-2" id="_idParaDest-202">Using a query string</h2>
<p class="normal">So far, we have only talked about routes that are specified in the <code class="inlineCode">page</code> directive, but we can also read data from the query string.</p>
<p class="normal"><code class="inlineCode">NavigationManager</code> gives us access to the URI, so by using this code, we can access the query string parameters:</p>
<pre class="programlisting code"><code class="hljs-code">@inject NavigationManager Navigation
@code{
var query = new Uri(Navigation.Uri).Query;
}
</code></pre>
<p class="normal">We won’t dig deeper into this, but now we know that it is possible to access query string parameters if we need to.</p>
<p class="normal">We can also access the <code class="inlineCode">query</code> parameter using an attribute like this:</p>
<pre class="programlisting code"><code class="hljs-code">[Parameter, SupplyParameterFromQuery(Name = "parameterName")]
public string ParameterFromQuery { get; set; }
</code></pre>
<p class="normal">This syntax is a bit nicer to work with.</p>
<p class="normal">Having data in the URL does not really mean storing the data. If we navigate to another page, we need to make sure to include the new URL; otherwise, it would be lost. We can use the browser storage instead if we want to store data that we don’t need to include every time in the URL.</p>
<h1 class="heading-1" id="_idParaDest-203">Implementing browser storage</h1>
<p class="normal">The browser has a <a id="_idIndexMarker455"/>bunch of different ways of storing data in the web browser. They are handled differently depending on what type we use. <strong class="keyWord">Local storage</strong> is <a id="_idIndexMarker456"/>scoped to the user’s browser window. The data will still be saved if the user reloads the page or even closes the web browser.</p>
<p class="normal">The data is also shared across<a id="_idIndexMarker457"/> tabs. <strong class="keyWord">Session storage</strong> is scoped to the <strong class="keyWord">Browser</strong> tab; if you reload the tab, the data will be saved, but if you close the tab, the data will be lost. <code class="inlineCode">SessionsStorage</code> is, in a way, safer to use because we avoid risks with bugs that may occur due to multiple tabs manipulating the same values in storage.</p>
<p class="normal">To be able to access the browser storage, we need to use JavaScript. Luckily, we won’t need to write the code ourselves.</p>
<p class="normal">In .NET 5, Microsoft introduced <strong class="keyWord">Protected Browser Storage</strong>, which uses data protection in ASP.NET Core and is not available <a id="_idIndexMarker458"/>in WebAssembly. We can, however, use an open-source library called <code class="inlineCode">Blazored.LocalStorage</code>, which can be used by both Blazor Server and Blazor WebAssembly.</p>
<p class="normal">But we are here to learn new things, right?</p>
<p class="normal">So, let’s implement an interface so that we can use both versions in our app, depending on which hosting model we are using. There is a problem with this implementation. If we are running in <code class="inlineCode">AutoMode</code>, the state will not be shared between the different hosting models. The solution is to stick to <code class="inlineCode">Blazored.LocalStorage</code> in both implementations. But to show the difference between the implementations, we will do both in this case. Please note that this is stored in clear text on the user’s computer, so be careful with what you store.</p>
<h2 class="heading-2" id="_idParaDest-204">Creating an interface</h2>
<p class="normal">First, we <a id="_idIndexMarker459"/>need an interface that can read and write to storage:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">SharedComponents</code> project, create a new folder called <code class="inlineCode">Interfaces</code>.</li>
<li class="numberedList">In the new folder, create a new class called <code class="inlineCode">IBrowserStorage.cs</code>.</li>
<li class="numberedList">Replace the content in the file with the following code:
        <pre class="programlisting code"><code class="hljs-code">namespace SharedComponents.Interfaces;
public interface IBrowserStorage
{
    Task&lt;T?&gt; GetAsync&lt;T&gt;(string key);
    Task SetAsync(string key, object value);
    Task DeleteAsync(string key);
}
</code></pre>
</li>
</ol>
<p class="normal">Now we have an interface containing <code class="inlineCode">get</code>, <code class="inlineCode">set</code>, and <code class="inlineCode">delete</code> methods.</p>
<h2 class="heading-2" id="_idParaDest-205">Implementing Blazor Server (InteractiveServer)</h2>
<p class="normal">For Blazor Server, we will use<a id="_idIndexMarker460"/> protected<a id="_idIndexMarker461"/> browser storage:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">BlazorWebApp</code> project, add a new folder called <code class="inlineCode">Services</code>.</li>
<li class="numberedList">In the new folder, create a new class called <code class="inlineCode">BlogProtectedBrowserStorage.cs</code>.
    <p class="normal">(I realize the naming is overkill, but it will be easier to tell the Blazor Server and the Blazor WebAssembly implementation apart because we will soon create another one.)</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="3">Open the new file and add the following <code class="inlineCode">using</code> statements:
        <pre class="programlisting code"><code class="hljs-code">using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage;
using SharedComponents.Interfaces;
</code></pre>
</li>
<li class="numberedList">Replace the class with this one:
        <pre class="programlisting code"><code class="hljs-code">public class BlogProtectedBrowserStorage : IBrowserStorage
{
    ProtectedSessionStorage Storage { get; set; }
    public BlogProtectedBrowserStorage(ProtectedSessionStorage storage)
    {
        Storage = storage;
    }
    public async Task DeleteAsync(string key)
    {
        await Storage.DeleteAsync(key);
    }
    public async Task&lt;T?&gt; GetAsync&lt;T&gt;(string key)
    {
        var value = await Storage.GetAsync&lt;T&gt;(key);
        return value.Success ? value.Value : default(T);
    }
    public async Task SetAsync(string key, object value)
    {
        await Storage.SetAsync(key, value);
    }
}
</code></pre>
<p class="normal">The <code class="inlineCode">BlogProtectedBrowserStorage</code> class implements the <code class="inlineCode">IBrowserStorage</code> interface for protected browser storage. We inject a <code class="inlineCode">ProtectedSessionStorage</code> instance and implement the <code class="inlineCode">set</code>, <code class="inlineCode">get</code>, and <code class="inlineCode">delete</code> methods.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">In <code class="inlineCode">Program.cs</code>, add the following namespaces:
        <pre class="programlisting code"><code class="hljs-code">using SharedComponents.Interfaces;
using BlazorWebApp.Services;
</code></pre>
</li>
<li class="numberedList">Add the<a id="_idIndexMarker462"/> following just<a id="_idIndexMarker463"/> beneath the line ending with <code class="inlineCode">.AddInteractiveWebAssemblyComponents();</code>:
        <pre class="programlisting code"><code class="hljs-code">builder.Services.AddScoped&lt;IBrowserStorage,BlogProtectedBrowserStorage&gt;();
</code></pre>
</li>
</ol>
<p class="normal">We are configuring Blazor to return an instance of <code class="inlineCode">BlogProtectedBrowserStorage</code> when we inject <code class="inlineCode">IBrowserStorage</code>.</p>
<p class="normal">This is the same as we did with the API. We inject different implementations depending on the platform.</p>
<h2 class="heading-2" id="_idParaDest-206">Implementing WebAssembly (InteractiveWebAssembly)</h2>
<p class="normal">For Blazor <a id="_idIndexMarker464"/>WebAssembly, we <a id="_idIndexMarker465"/>will use <code class="inlineCode">Blazored.SessionStorage</code>:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">BlazorWebApp.Client</code><strong class="keyWord"> </strong>project, add a <code class="inlineCode">NuGet</code> reference to <code class="inlineCode">Blazored.SessionStorage</code>.</li>
<li class="numberedList">Add a new folder called <code class="inlineCode">Services</code>.</li>
<li class="numberedList">In the new folder, create a new class called <code class="inlineCode">BlogBrowserStorage.cs</code>.</li>
<li class="numberedList">Open the new file and replace the content with the following code:
        <pre class="programlisting code"><code class="hljs-code">using Blazored.SessionStorage;
using SharedComponents.Interfaces;
namespace BlazorWebApp.Client.Services;
public class BlogBrowserStorage : IBrowserStorage
{
    ISessionStorageService Storage { get; set; }
    public BlogBrowserStorage(ISessionStorageService storage)
    {
        Storage = storage;
    }
    public async Task DeleteAsync(string key)
    {
        await Storage.RemoveItemAsync(key);
    }
    public async Task&lt;T?&gt; GetAsync&lt;T&gt;(string key)
    {
        return await Storage.GetItemAsync&lt;T&gt;(key);
    }
    public async Task SetAsync(string key, object value)
    {
        await Storage.SetItemAsync(key, value);
    }
}
</code></pre>
<p class="normal">The implementations of <code class="inlineCode">ProtectedBrowserStorage</code> and <code class="inlineCode">Blazored.SessionStorage</code> are pretty similar to one another. The names of the methods are different but the parameters are the same.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">In the <code class="inlineCode">Program.cs</code> file, add the following namespaces:
        <pre class="programlisting code"><code class="hljs-code">using Blazored.SessionStorage;
using SharedComponents.Interfaces;
using BlazorWebApp.Client.Services;
</code></pre>
</li>
<li class="numberedList">Just above <code class="inlineCode">await builder.Build().RunAsync();</code> add the following:
        <pre class="programlisting code"><code class="hljs-code">builder.Services.AddBlazoredSessionStorage();
builder.Services.AddScoped&lt;IBrowserStorage, BlogBrowserStorage&gt;();
</code></pre>
</li>
</ol>
<p class="normal">The <code class="inlineCode">AddBlazoredSessionStorage</code> extension method hooks up everything so that we can start<a id="_idIndexMarker466"/> using the browser session <a id="_idIndexMarker467"/>storage.</p>
<p class="normal">Then we add our configuration for <code class="inlineCode">IBrowserStorage</code>, just as we did with the server, but in this case, we return <code class="inlineCode">BlogBrowserStorage</code> when we ask the dependency injection for <code class="inlineCode">IBrowserStorage</code>.</p>
<h2 class="heading-2" id="_idParaDest-207">Implementing the shared code</h2>
<p class="normal">We also need to implement <a id="_idIndexMarker468"/>some code that calls the services we just created:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">SharedComponents</code> project, open <code class="inlineCode">Pages/Admin/BlogPostEdit.razor</code>. We are going to make a couple of changes to the file.</li>
<li class="numberedList">Inject <code class="inlineCode">IBrowserStorage</code>:
        <pre class="programlisting code"><code class="hljs-code">@inject SharedComponents.Interfaces.IBrowserStorage _storage
</code></pre>
</li>
<li class="numberedList">Since we can only run JavaScript calls when doing an action (like a click) or in the <code class="inlineCode">OnAfterRender</code> method, let’s create an <code class="inlineCode">OnAfterRenderMethod</code>:
        <pre class="programlisting code"><code class="hljs-code">protected override async Task OnAfterRenderAsync(bool firstRender)
{
    if (firstRender &amp;&amp; string.IsNullOrEmpty(Id))
    {
        var saved = await _storage.GetAsync&lt;BlogPost&gt;("EditCurrentPost");
        if (saved != null)
        {
           Post = saved;
   StateHasChanged();
        }
    }
    await base.OnAfterRenderAsync(firstRender);
}
</code></pre>
<p class="normal">When we load the component and the <code class="inlineCode">Id</code> is <code class="inlineCode">null</code>, this means we are editing a new file, and then we can check whether we have a file saved in browser storage.</p>
<p class="normal">This<a id="_idIndexMarker469"/> implementation can only have one file in the drafts and only saves new posts. If we were to edit an existing post, it would not save those changes.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4">We need our <code class="inlineCode">UpdateHTML</code> method to become async. Change the method to look like this:
        <pre class="programlisting code"><code class="hljs-code">protected async Task UpdateHTMLAsync()
{
    if (!string.IsNullOrEmpty(Post.Text))
    {
        markDownAsHTML = Markdig.Markdown.ToHtml(Post.Text, pipeline);
        if (string.IsNullOrEmpty(Post.Id))
        {
            await _storage.SetAsync("EditCurrentPost", Post);
        }
    }
}
</code></pre>
</li>
<li class="numberedList">If <code class="inlineCode">Id</code> on the blog post is <code class="inlineCode">null</code>, we will store the post in the browser storage. Make sure to change all the references from <code class="inlineCode">UpdateHTML</code> to <code class="inlineCode">UpdateHTMLAsync</code>.
    <p class="normal">Make sure to await the call as well in the <code class="inlineCode">OnParametersSetAsync</code> method like this:</p>
<pre class="programlisting code"><code class="hljs-code">await UpdateHTMLAsync();
</code></pre></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="6">There is <a id="_idIndexMarker470"/>one problem with this implementation: we are currently prerendering our components. When we are prerendering, no connection is made to the web browser. There is no state to retrieve. Simply put, we need to disable the prerendering on this component to make it work. So, let’s do that!</li>
<li class="numberedList">Change <code class="inlineCode">@rendermode InteractiveServer</code> to:
        <pre class="programlisting code"><code class="hljs-code">@rendermode @(new InteractiveServerRenderMode(prerender: false))
</code></pre>
</li>
</ol>
<p class="normal">We are done. Now it’s time to test the implementation:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Run the project by pressing <em class="keystroke">Ctrl</em> + <em class="keystroke">F5</em>.</li>
<li class="numberedList">Log in to the site (so we can access the admin tools).</li>
<li class="numberedList">Click <strong class="screenText">Blog posts</strong> followed by <strong class="screenText">New blog post</strong>.</li>
<li class="numberedList">Type anything in the boxes, and as soon as we type something in the text area, it will save the post to storage.</li>
<li class="numberedList">Click <strong class="screenText">Blog posts</strong> (so we navigate away from our blog post).</li>
<li class="numberedList">Click <strong class="screenText">New blog post</strong> and all the information will still be there.</li>
<li class="numberedList">Press <em class="italic">F12</em> to see the browser developer tools. Click <strong class="screenText">Application</strong> | <strong class="screenText">Session storage</strong> | <strong class="screenText">https://localhost:portnumber</strong>.
    <p class="normal">You should see one post with the key <code class="inlineCode">EditCurrentPost</code>, and the value of that post should be an encrypted string, as seen in <em class="italic">Figure 11.1</em>:</p>
<figure class="mediaobject"><img alt="Figure 11.1 – The encrypted protected browser storage " src="img/B21849_11_01.png"/></figure>
<p class="packt_figref">Figure 11.1: The encrypted protected browser storage</p>
<p class="normal">Let’s test Blazor WebAssembly (InteractiveWebAssembly) next.</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="8">Open the <code class="inlineCode">EditPost.razor</code> file again and change <code class="inlineCode">@rendermode @(new InteractiveServerRenderMode(prerender: false))</code> to:
        <pre class="programlisting code"><code class="hljs-code">@rendermode @(new InteractiveWebAssemblyRenderMode(prerender: false))
</code></pre>
</li>
<li class="numberedList">You <a id="_idIndexMarker471"/>might need to clean and rebuild your project to make this work.</li>
<li class="numberedList">Log in to the site (so we can access the admin tools).</li>
<li class="numberedList">Click <strong class="screenText">Blog posts</strong> and then <strong class="screenText">New blog post</strong>. You may notice that there is a delay between loading the page and the components showing up. This is the initial WebAssembly load time to get everything started.</li>
<li class="numberedList">Type anything in the boxes, and as soon as we type something in the text area, it will save the post to storage.</li>
<li class="numberedList">Click <strong class="screenText">Blog posts</strong> (so we navigate away from our blog post).</li>
<li class="numberedList">Click <strong class="screenText">New blog post</strong> and all the information should still be there.</li>
<li class="numberedList">Press <em class="keystroke">F12</em> to see the browser developer tools. Click <strong class="screenText">Application</strong> | <strong class="screenText">Session storage</strong> | <strong class="screenText">https://localhost:portnumber</strong>.</li>
</ol>
<p class="normal">You should see one post with the key <code class="inlineCode">EditCurrentPost</code>, and the value of that post should be a JSON string, as seen in <em class="italic">Figure 11.2</em>.</p>
<p class="normal">If we were to <a id="_idIndexMarker472"/>change the data in the storage, it would also change in the application, so keep in mind that this is plain text, and the end user can manipulate the data:</p>
<figure class="mediaobject"><img alt="Figure 11.2 – Browser storage that is unprotected " src="img/B21849_11_02.png"/></figure>
<p class="packt_figref">Figure 11.2: Browser storage that is unprotected</p>
<p class="normal">Now, we have implemented protected browser storage for Blazor Server and session storage for Blazor WebAssembly. The way we can mix and match the hosting model where we need it is a really amazing power of .NET 8.</p>
<p class="normal">We only have one way left to go through, so let’s make it the most fun.</p>
<h1 class="heading-1" id="_idParaDest-208">Using an in-memory state container service</h1>
<p class="normal">When it comes to<a id="_idIndexMarker473"/> in-memory state containers, we simply use dependency injection to keep the instance of the service in memory for the predetermined time (scoped, singleton, or transient).</p>
<p class="normal">In <em class="chapterRef">Chapter 4</em>, <em class="italic">Understanding Basic Blazor Components</em>, we discussed how the scope of dependency injections differs from Blazor Server and Blazor WebAssembly. The big difference for us in this section is the fact that Blazor WebAssembly runs inside the web browser and doesn’t have a connection to the server or other users.</p>
<p class="normal">To show how the in-memory state works, we will do something that might seem a bit overkill for a blog but it will be cool to see. When we edit our blog post, we will update all the web browsers connected to our blog in real time (I did say overkill).</p>
<p class="normal">We will have to implement that a bit differently, depending on the host. Let’s start with Blazor Server.</p>
<h2 class="heading-2" id="_idParaDest-209">Implementing real-time updates on Blazor Server</h2>
<p class="normal">The implementation for<a id="_idIndexMarker474"/> Blazor Server can also be used for Blazor WebAssembly. Since WebAssembly is running in our browser, it would only notify the users connected to the site, which would be just you. But it might be good to know that the same thing works in Blazor Server as well as Blazor WebAssembly:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">SharedComponents</code> project, in the <code class="inlineCode">Interfaces</code> folder, create an interface called <code class="inlineCode">IBlogNotificationService.cs</code>.</li>
<li class="numberedList">Add the following code:
        <pre class="programlisting code"><code class="hljs-code">using Data.Models;
namespace SharedComponents.Interfaces;
public interface IBlogNotificationService
{
    event Action&lt;BlogPost&gt;? BlogPostChanged;
    Task SendNotification(BlogPost post);
}
</code></pre>
<p class="normal">We have an action that we can subscribe to when the blog post is updated and a method we can call when we update a post.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="3">In the <code class="inlineCode">Services</code> folder in the <code class="inlineCode">BlazorWebServer</code> project, add a new class called <code class="inlineCode">BlazorServerBlogNotificationService.cs</code>.
    <p class="normal">It might seem unnecessary to give the class a name that includes <code class="inlineCode">BlazorServer</code>, but it makes sure we can easily tell the classes apart.</p>
<p class="normal">Replace the<a id="_idIndexMarker475"/> content with the following code:</p>
<pre class="programlisting code"><code class="hljs-code">using SharedComponents.Interfaces;
using Data.Models;
namespace BlazorServer.Services;
public class BlazorServerBlogNotificationService : IBlogNotificationService
{
    public event Action&lt;BlogPost&gt;? BlogPostChanged;
    public Task SendNotification(BlogPost post)
    {
        BlogPostChanged?.Invoke(post);
        return Task.CompletedTask;
    }
}
</code></pre>
<p class="normal">The code is pretty straightforward here. If we call <code class="inlineCode">SendNotification</code>, it will check whether anyone is listening for the <code class="inlineCode">BlogPostChanged</code> action and whether to trigger the action.</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4">In <code class="inlineCode">Program.cs</code>, add the dependency injection:
        <pre class="programlisting code"><code class="hljs-code">builder.Services.AddSingleton&lt;IBlogNotificationService, BlazorServerBlogNotificationService&gt;();
</code></pre>
<p class="normal">Whenever we ask for an instance of the <code class="inlineCode">IBlogNotificationService</code> type, we will get back an instance of <code class="inlineCode">BlazorServerBlogNotificationService</code>.</p>
<p class="normal">We add this dependency injection as a singleton. I can’t stress this enough. When using Blazor Server, this will be the same instance for <em class="italic">ALL</em> users, so we must be careful when we use <code class="inlineCode">Singleton</code>.</p>
<p class="normal">In this case, we want the service to notify all the visitors of our blog that the blog post has changed.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">In the <code class="inlineCode">SharedComponents</code> project, open <code class="inlineCode">Post.razor</code>.</li>
<li class="numberedList">Add the following code at the top (or close to the top) of the page:
        <pre class="programlisting code"><code class="hljs-code">@using SharedComponents.Interfaces
@inject IBlogNotificationService _notificationService
@implements IDisposable
</code></pre>
<p class="normal">We add dependency injection for <code class="inlineCode">IBlogNotificationService</code> and we also need to implement <code class="inlineCode">IDisposable</code> to prevent any memory leaks.</p>
<p class="normal">At the top of the <code class="inlineCode">OnInitializedAsync</code> method, add the following:</p>
<pre class="programlisting code"><code class="hljs-code">_notificationService.BlogPostChanged += PostChanged;
</code></pre>
<p class="normal">We added a listener to the event so we know when we should update the information.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="7">We also need<a id="_idIndexMarker476"/> the <code class="inlineCode">PostChanged</code> method, so add this code:
        <pre class="programlisting code"><code class="hljs-code">private async void PostChanged(BlogPost post)
{
    if (BlogPost?.Id == post.Id)
    {
        BlogPost = post;
        await InvokeAsync(()=&gt;this.StateHasChanged());
    }
}
</code></pre>
<p class="normal">If the parameter has the same ID as the post we are currently viewing, then replace the content with the post in the event and call <code class="inlineCode">StateHasChanged</code>.</p>
<p class="normal">Since this is happening on another thread, we need to call <code class="inlineCode">StateHasChanged</code> using <code class="inlineCode">InvokeAsync</code> so that it runs on the UI thread.</p>
<p class="normal">We also need to stop listening to the updates by implementing the <code class="inlineCode">Dispose</code> method. Add the following:</p>
<pre class="programlisting code"><code class="hljs-code">void IDisposable.Dispose()
{
    _notificationService.BlogPostChanged -= PostChanged;
}
</code></pre>
<p class="normal">We remove<a id="_idIndexMarker477"/> the event listener to prevent any memory leaks.</p>
<p class="normal">The <code class="inlineCode">Post</code> component is currently a static rendered component. We don’t have any interactivity, so let’s enable that.</p>
<p class="normal">Add this to the component:</p>
<pre class="programlisting code"><code class="hljs-code">@rendermode InteractiveServer
</code></pre>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="8">In the <code class="inlineCode">SharedComponents</code> project, open the <code class="inlineCode">Pages/Admin/BlogPostEdit.Razor</code> file.</li>
<li class="numberedList">When we make changes to our blog post, we need to send a notification as well. At the top of the file, add the following:
        <pre class="programlisting code"><code class="hljs-code">@using SharedComponents.Interfaces
@inject IBlogNotificationService _notificationService
</code></pre>
<p class="normal">We add a namespace and inject our notification service.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="10">In the <code class="inlineCode">UpdateHTMLAsync</code> method, add the following just under the <code class="inlineCode">!string.IsNullOrEmpty(Post.Text)</code> <code class="inlineCode">if</code> statement:
        <pre class="programlisting code"><code class="hljs-code">await _notificationService.SendNotification(Post);
</code></pre>
<p class="normal">Every time we change something, it will now send a notification that the blog post has changed. I do realize that it would make more sense to do this when we save a post, but it makes for a much cooler demo.</p>
<p class="normal">Let’s start with testing <code class="inlineCode">InteractiveServer</code>. In <code class="inlineCode">BlogPortEditPage.razor</code>, change <code class="inlineCode">@rendermode @(new InteractiveWebAssemblyRenderMode(prerender: false))</code> to:</p>
<pre class="programlisting code"><code class="hljs-code">@rendermode @(new InteractiveServerRenderMode(prerender: false))
</code></pre>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="11">Run the project by pressing <em class="keystroke">Ctrl</em> + <em class="keystroke">F5</em>.</li>
<li class="numberedList">Copy the URL and open another web browser. We should now have two web <a id="_idIndexMarker478"/>browser windows open showing us the blog.</li>
<li class="numberedList">In the first window, open a blog post (doesn’t matter which one), and in the second window, log in and edit the same blog post.</li>
</ol>
<p class="normal">When we change the text of the blog post in the second window, the change should be reflected in real time in the first window.</p>
<p class="normal">I am constantly amazed how a feature that would be a bit tricky to implement without using Blazor only requires 10 steps (not counting the test), and if we didn’t prepare for the next step, it would take even fewer steps.</p>
<p class="normal">Next, we will implement the same feature for Blazor WebAssembly, but Blazor WebAssembly runs inside the user’s web browser. There is no real-time communication built in, as with Blazor Server.</p>
<h2 class="heading-2" id="_idParaDest-210">Implementing real-time updates on Blazor WebAssembly</h2>
<p class="normal">We already have a lot of things<a id="_idIndexMarker479"/> in place. We only need to add a real-time messaging system. Since SignalR is both easy to implement and awesome, let’s use that.</p>
<p class="normal">The first time I used SignalR, my first thought was, “Wait, it can’t be that easy. I must have forgotten something, or something must be missing”. Hopefully, we will have the same experience now.</p>
<p class="normal">Let’s see whether that still holds true today:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">BlazorWebApp</code> project, add a new folder called <code class="inlineCode">Hubs</code>.</li>
<li class="numberedList">In the new folder, create a class called <code class="inlineCode">BlogNotificationHub.cs</code>.</li>
<li class="numberedList">Replace the code with the following:
        <pre class="programlisting code"><code class="hljs-code">using Data.Models;
using Microsoft.AspNetCore.SignalR;
namespace BlazorWebApp.Hubs;
public class BlogNotificationHub : Hub
{
    public async Task SendNotification(BlogPost post)
    {
        await Clients.All.SendAsync("BlogPostChanged", post);
    }
}
</code></pre>
<p class="normal">The class inherits from the <code class="inlineCode">Hub</code> class. There is a method called <code class="inlineCode">SendNotification</code>. Keep that name in mind; we will come back to that.</p>
<p class="normal">We call <code class="inlineCode">Clients.All.SendAsync</code>, which means we will send a message called <code class="inlineCode">BlogPostChanged</code> with the content of a blog post.</p>
<p class="normal">The <a id="_idIndexMarker480"/>name <code class="inlineCode">BlogPostChanged</code> is also important, so keep that in mind as well.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4">In the <code class="inlineCode">Program.cs</code> file, add the following:
        <pre class="programlisting code"><code class="hljs-code">builder.Services.AddSignalR();
</code></pre>
<p class="normal">This adds SignalR. We already have access to SignalR since this project is a mix of hosting models.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">Add the following namespace:
        <pre class="programlisting code"><code class="hljs-code">using BlazorWebApp.Hubs;
</code></pre>
</li>
<li class="numberedList">Just above <code class="inlineCode">app.MapRazorComponents&lt;App&gt;()</code>, add:
        <pre class="programlisting code"><code class="hljs-code">app.MapHub&lt;BlogNotificationHub&gt;("/BlogNotificationHub");
</code></pre>
<p class="normal">Here, we configure what URL <code class="inlineCode">BlogNotificationHub</code> should use. In this case, we are using the same URL as the name of the hub.</p>
<p class="normal">The URL here is also important. We will use that in just a bit.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="7">In the <code class="inlineCode">BlazorWebApp.Client</code>, add a reference to the <code class="inlineCode">Microsoft.AspNetCore.SignalR.Client NuGet</code> package.</li>
<li class="numberedList">In the <code class="inlineCode">Services</code> folder, create a class called <code class="inlineCode">BlazorWebAssemblyBlogNotificationService.cs</code>.
    <p class="normal">In this file, we will implement the SignalR communication.</p></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="9">Add the following namespaces:
        <pre class="programlisting code"><code class="hljs-code">using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.SignalR.Client;
using Data.Models;
using SharedComponents.Interfaces;
</code></pre>
</li>
<li class="numberedList">Add this class:
        <pre class="programlisting code"><code class="hljs-code">public class BlazorWebAssemblyBlogNotificationService : IBlogNotificationService, IAsyncDisposable
{
    public BlazorWebAssemblyBlogNotificationService(NavigationManager navigationManager)
    {
        _hubConnection = new HubConnectionBuilder()
        .WithUrl(navigationManager.ToAbsoluteUri("/BlogNotificationHub"))
        .Build();
        _hubConnection.On&lt;BlogPost&gt;("BlogPostChanged", (post) =&gt;
        {
            BlogPostChanged?.Invoke(post);
        });
        _hubConnection.StartAsync();
    }
    private readonly HubConnection _hubConnection;
    public event Action&lt;BlogPost&gt;? BlogPostChanged;
        
    public async Task SendNotification(BlogPost post)
    {
        await _hubConnection.SendAsync("SendNotification", post);
    }
    public async ValueTask DisposeAsync()
    {
        await _hubConnection.DisposeAsync();
    }
}
</code></pre>
<p class="normal">A lot is <a id="_idIndexMarker481"/>happening here. The class is implementing <code class="inlineCode">IBlogNotificationService</code> and <code class="inlineCode">IAsyncDisposable</code>.</p>
<p class="normal">In the constructor, we use dependency injection to get <code class="inlineCode">NavigationManager</code> so we can figure out the URL to the server.</p>
<p class="normal">Then, we configure the connection to the hub. Then, we specify the URL to the hub; this should be the same as we specified in <em class="italic">step 7</em>.</p>
<p class="normal">Now, we can configure the hub connection to listen for events. In this case, we listen for the <code class="inlineCode">BlogPostChanged</code> event, the same name we specified in <em class="italic">step 3</em>. When someone sends the event, the method we specify will run.</p>
<p class="normal">The method, in this case, triggers the event we have in <code class="inlineCode">IBlogNotificationService</code>. Then, we start the connection. Since the constructor can’t be async, we won’t await the <code class="inlineCode">StartAsync</code> method.</p>
<p class="normal"><code class="inlineCode">IBlogNotificationService</code> also implements the <code class="inlineCode">SendNotification</code> method, and we trigger the event with the same name on the hub, which will result in the hub sending the <code class="inlineCode">BlogPostChanged</code> event to all connected clients.</p>
<p class="normal">The last thing we do is make sure that we dispose of the hub connection.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="11">In<a id="_idIndexMarker482"/> the <code class="inlineCode">Program.cs </code>file, we need to configure dependency injection. Just above <code class="inlineCode">await builder.Build().RunAsync();</code>, add the following:
        <pre class="programlisting code"><code class="hljs-code">builder.Services.AddSingleton&lt;IBlogNotificationService, BlazorWebAssemblyBlogNotificationService&gt;();
</code></pre>
</li>
<li class="numberedList">This is where things get a bit tricky, since we have different implementations depending on whether we’re using InteractiveServer or InteractiveWebAssembly. We need to make sure to run it in the same way both for <code class="inlineCode">EditPost</code> and the <code class="inlineCode">Post</code> component. In a mixed scenario like this, it is a better option to always implement it with a SignalR connection because then we can use the same implementation regardless of the hosting model. In the <code class="inlineCode">SharedComponents</code> project, open <code class="inlineCode">Pages/Admin/BlogPostEdit.razor</code> and change <code class="inlineCode">@rendermode @(new InteractiveServerRenderMode(prerender: false))</code> to:
        <pre class="programlisting code"><code class="hljs-code">@rendermode @(new InteractiveWebAssemblyRenderMode(prerender: false)).
</code></pre>
<p class="normal">You might need to clean and rebuild the solution to make it work.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="13">Open <code class="inlineCode">Post.razor</code> and do the same thing; change <code class="inlineCode">@rendermode InteractiveServer</code> to:
        <pre class="programlisting code"><code class="hljs-code">@rendermode InteractiveWebAssembly.
</code></pre>
<p class="normal">Now, it’s time to carry out testing, run the project by pressing <em class="keystroke">Ctrl</em> + <em class="keystroke">F5</em>.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="14">Copy the URL and open another web browser. We should now have two web browser <a id="_idIndexMarker483"/>windows open showing us the blog.</li>
<li class="numberedList">In the first window, open a blog post (it doesn’t matter which one), and in the second window, log in and edit the same blog post.</li>
</ol>
<p class="normal">When we change the text of the blog post in the second window, the change should be reflected in real time in the first window.</p>
<p class="normal">In <em class="italic">13</em> steps (not counting testing), we have implemented real-time communication between the server and client, a Blazor WebAssembly client with .NET code running inside the web browser.</p>
<p class="normal">And no JavaScript!</p>
<h2 class="heading-2" id="_idParaDest-211">State management frameworks</h2>
<p class="normal">Speaking of JavaScript, in the <a id="_idIndexMarker484"/>JavaScript framework world of Angular, React, and so on, there are frameworks we can use to manage state (<strong class="keyWord">Redux</strong> and <strong class="keyWord">ngRX</strong>, to name a couple). This is the case for Blazor as well. Very simply, we <a id="_idIndexMarker485"/>have a<a id="_idIndexMarker486"/> state that we can change using methods; if the state changes, the components that are listening to that change will be notified.</p>
<p class="normal">There are a bunch of frameworks like that for Blazor. I have personally never used a framework but instead built a <code class="inlineCode">Singleton</code> service and connected my components to that (basically what these frameworks do).</p>
<p class="normal">Check out Fluxor or Blazor-State if you want to dive deeper into that. There is another way to share state between components, which is called root-level cascading values.</p>
<h1 class="heading-1" id="_idParaDest-212">Root-level cascading values</h1>
<p class="normal">Root-level cascading values are a new <a id="_idIndexMarker487"/>feature in .NET 8. This is a great way to share state not only between components but also between different render modes. It will automatically add a cascading value; we have already used this feature, and then we added <code class="inlineCode">AddCascadingAuthenticationState()</code>, which uses the root-level cascading value in the background.</p>
<p class="normal">This does not share the value between InteractiveServer and InteractiveWebAssembly, though, but gives us a way to share the state between components without using dependency injection.</p>
<p class="normal">The really nice <a id="_idIndexMarker488"/>thing is that if the value changes, it will automatically change the parameter and trigger a rerender of the component. No special code is needed inside the component. But subscribing to value changes does have a cost, so be careful with how many things you use with root-level cascading values.</p>
<p class="normal">Usage could look something like this: </p>
<pre class="programlisting code"><code class="hljs-code">@(Preferences?.DarkTheme)
@code {
    [CascadingParameter(Name = "Preferences")]
    public Preferences Preferences { get; set; }
}
</code></pre>
<p class="normal">And in <code class="inlineCode">Program.cs</code>:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddCascadingValue&lt;Preferences&gt;(sp =&gt;
{
    var preferences = new Preferences { DarkTheme = true };
    var source = new CascadingValueSource&lt;Preferences&gt;("Preferences", preferences, isFixed: false);
    return source;
});
</code></pre>
<p class="normal">It is possible to update the values by calling the <code class="inlineCode">NotifyChangedAsync</code> method on <code class="inlineCode">CascadingValueSource</code>. An implementation could look something like this:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddCascadingValue&lt;Preferences&gt;(sp =&gt;
{
    var preferences = new Preferences { DarkTheme = true };
    var source = new CascadingValueSource&lt;Preferences&gt;("Preferences", preferences, isFixed: false);
    if (preferences is INotifyPropertyChanged changed)
        changed.PropertyChanged += (sender, args) =&gt; source.NotifyChangedAsync();
    return source;
});
</code></pre>
<p class="normal">Here, we are<a id="_idIndexMarker489"/> using the <code class="inlineCode">INotifyPropertyChanged</code> interface to call <code class="inlineCode">NotifyChangedAsync</code> when we change the property. On GitHub, you can find a full example of this if you want to play further with it.</p>
<h1 class="heading-1" id="_idParaDest-213">Summary</h1>
<p class="normal">In this chapter, we learned how we can handle state in our application and how we can use local storage to store data, both encrypted and not. We looked at different ways of doing that, and we also made sure to include SignalR to be able to use real-time communication with the server.</p>
<p class="normal">Almost all applications need to save data in some form. Perhaps it can be settings or preferences. The things we covered in the chapter are the most common ones, but we should also know that there are many open-source projects we can use to persist state. I personally prefer the components to load state from a database when needed be self-contained, and not have to rely on state coming or being somewhere else. This approach has served me well in the past.</p>
<p class="normal">In the next chapter, we will take a look at debugging. Hopefully, you haven’t needed to know how to debug yet!</p>
</div>
</body></html>