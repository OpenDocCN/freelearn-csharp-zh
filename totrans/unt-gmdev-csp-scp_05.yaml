- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Mastering Unity’s API – Physics, Collisions, and Environment Interaction Techniques
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握Unity的API - 物理学、碰撞和环境交互技术
- en: Building on foundational Unity scripting, we explore the extensive capabilities
    of Unity’s **application programming interface** (**API**) (which is a set of
    protocols and tools that allows different software applications to communicate
    and interact with one another), unlocking advanced features to enhance your game’s
    functionality. This chapter covers accessing and manipulating game components—key
    for dynamic development. You’ll learn physics-based interactions for realistic
    gameplay, manage transitions and settings for immersive environments, and use
    advanced API functions for complex mechanics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity脚本的基础之上，我们探索了Unity的**应用程序编程接口（API**）的广泛功能（它是一组协议和工具，允许不同的软件应用程序相互通信和交互），解锁高级功能以增强游戏的功能。本章涵盖了访问和操作游戏组件——这对于动态开发至关重要。您将学习基于物理的交互以实现逼真的游戏玩法，管理沉浸式环境中的过渡和设置，并使用高级API函数实现复杂机制。
- en: Key techniques include transforming GameObjects and using **raycasting** for
    object interaction. Practical examples and best practices provide insights into
    efficient, safe API usage, making your game development modular and reusable.
    This streamlined approach prepares you to create engaging, responsive game environments,
    paving the way for complex game development.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 关键技术包括转换GameObject和使用**射线投射**进行对象交互。实际示例和最佳实践提供了关于高效、安全API使用的见解，使您的游戏开发模块化和可重用。这种简化的方法使您为创建引人入胜、响应迅速的游戏环境做好准备，为复杂游戏开发铺平道路。
- en: 'In this chapter, we’ll cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Accessing game components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问游戏组件
- en: Utilizing physics and collisions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用物理和碰撞
- en: Managing game scenes and environments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理游戏场景和环境
- en: Advanced API features
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级API功能
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To effectively follow this chapter, ensure you have the following installed:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地跟随本章，请确保您已安装以下内容：
- en: '**Unity Hub**: This manages Unity installations and project versions.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity Hub**：用于管理Unity安装和项目版本。'
- en: '**Unity Editor**: The main platform for developing and building your Unity
    projects.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity编辑器**：开发并构建您的Unity项目的平台。'
- en: '**Integrated development environment (IDE)**: Used for editing and managing
    C# code. Recommended IDEs include Microsoft Visual Studio or JetBrains Rider,
    both of which integrate well with Unity for comprehensive coding and debugging.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成开发环境（IDE）**：用于编辑和管理C#代码。推荐的IDE包括Microsoft Visual Studio或JetBrains Rider，它们都与Unity集成良好，用于全面的编码和调试。'
- en: 'You can find the examples/files related to this chapter here: [https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter05](https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter05)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到与本章相关的示例/文件：[https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter05](https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter05)
- en: Accessing game components
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问游戏组件
- en: This section introduces the core concepts of Unity’s API, essential for manipulating
    game components. We’ll start with interacting with and modifying GameObjects and
    their transforms. Through examples, you’ll learn to adjust position, rotation,
    and scale, animating your game world dynamically. We emphasize best practices
    to ensure your API interactions are efficient, safe, and modular. This foundational
    guide equips you with the skills to confidently manipulate game elements and create
    engaging experiences.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了Unity API的核心概念，这对于操作游戏组件至关重要。我们将从与GameObject及其变换交互和修改开始。通过示例，您将学习如何调整位置、旋转和缩放，使您的游戏世界动态动画化。我们强调最佳实践以确保您的API交互高效、安全且模块化。这本基础指南使您能够自信地操作游戏元素并创建引人入胜的体验。
- en: Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: In C#, a `NullReferenceException`, which occur when attempting to access members
    of a null object. This can be done using the `if` statement, such as if (`obj
    != null`), to ensure the object is not null before accessing its properties or
    methods. Additionally, C# 6.0 introduced the null-conditional operator, `?.`,
    which allows for more concise and readable null checks by safely accessing members
    only if the object is not null.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，`NullReferenceException`会在尝试访问空对象的成员时发生。这可以通过使用`if`语句，例如`if (obj != null)`，来确保在访问其属性或方法之前对象不是空的。此外，C#
    6.0引入了空条件运算符`?.`，它通过安全地访问成员（只有当对象不是空时）来允许更简洁和可读的空检查。
- en: Introduction to Unity’s API and component system
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity API 和组件系统的简介
- en: 'Exploring Unity’s API unveils a robust system crucial to game development.
    It serves as a bridge for developers to intricately control and manipulate game
    elements. Unity’s component-based architecture is at the core, enabling a modular
    and intuitive approach where developers build complex behaviors from simple, reusable
    components. Key elements such as `Transform`, `Rigidbody`, and `Collider` are
    fundamental building blocks in Unity’s design, allowing for diverse game object
    construction and interaction:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 探索 Unity 的 API 揭示了一个对游戏开发至关重要的强大系统。它为开发者提供了一个桥梁，使他们能够细致地控制和操作游戏元素。Unity 的基于组件的架构是其核心，它允许开发者通过简单、可重用的组件构建复杂的行为，从而实现模块化和直观的方法。`Transform`、`Rigidbody`
    和 `Collider` 等关键元素是 Unity 设计中的基本构建块，允许构建多样化的游戏对象和交互：
- en: '`Transform` component controls an object’s position, rotation, and scale in
    the game world, serving as the cornerstone for any spatial manipulation.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Transform` 组件控制游戏世界中对象的位置、旋转和缩放，是任何空间操作的基础。'
- en: '`Rigidbody` adds physics properties to objects, allowing them to respond to
    gravity and forces, making your game feel more dynamic and real.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rigidbody` 为对象添加物理属性，使它们能够响应重力和力，使您的游戏感觉更加动态和真实。'
- en: '`Collider`, on the other hand, defines the shape of an object for collision
    detection, enabling objects to interact with each other through physical contact
    or proximity.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，`Collider` 定义了对象的形状以进行碰撞检测，使对象能够通过物理接触或接近来相互交互。
- en: 'In *Figure 5**.1*, `Capsule` is selected in the Unity Editor’s **Hierarchy**
    window. This game object’s information appears in the **Inspector** window. There
    are five attached components: **Transform**, **Capsule (Mesh Filter)**, **Mesh
    Renderer**, **Capsule Collider**, and **Rigidbody**.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5*.1 中，`Capsule` 在 Unity 编辑器的 **层次结构** 窗口中被选中。该游戏对象的信息显示在 **检查器** 窗口中。有五个附加组件：**Transform**、**Capsule
    (Mesh Filter)**、**Mesh Renderer**、**Capsule Collider** 和 **Rigidbody**。
- en: '![Figure 5.1 – Capsule selected in the Unity Editor’s Hierarchy window](img/B22128_05_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 在 Unity 编辑器的层次结构窗口中选中的胶囊](img/B22128_05_01.jpg)'
- en: Figure 5.1 – Capsule selected in the Unity Editor’s Hierarchy window
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 在 Unity 编辑器的层次结构窗口中选中的胶囊
- en: Unity’s API and its component-based architecture are essential for game development,
    providing a framework to manipulate game objects. Key components such as `Transform`,
    `Rigidbody`, and `Collider` allow developers to control an object’s behavior and
    physical attributes. This approach streamlines development and enhances creativity.
    We’ll focus on using the `Transform` component to adjust position, rotation, and
    scale, demonstrating through examples how to animate objects effectively. This
    sets the foundation for further customization and interaction in your game world.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 的 API 和其基于组件的架构对于游戏开发至关重要，它提供了一个框架来操作游戏对象。`Transform`、`Rigidbody` 和 `Collider`
    等关键组件允许开发者控制对象的行为和物理属性。这种方法简化了开发并增强了创造力。我们将重点介绍使用 `Transform` 组件来调整位置、旋转和缩放，并通过示例展示如何有效地动画化对象。这为您在游戏世界中的进一步定制和交互奠定了基础。
- en: Working with Transform and Renderer components
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Transform 和 Renderer 组件一起工作
- en: This section on Unity focuses on using the `Transform` component to manipulate
    GameObjects, a key skill for developers. We’ll guide you through modifying an
    object’s position, rotation, and scale with step-by-step examples. Additionally,
    we’ll explore dynamically changing components such as materials and textures.
    This comprehensive approach enhances your technical skills and enriches your game
    environments.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点介绍使用 `Transform` 组件来操作 GameObjects，这是开发者的一项关键技能。我们将通过逐步示例指导您修改对象的位置、旋转和缩放。此外，我们还将探索动态更改组件，如材质和纹理。这种全面的方法可以增强您的技术技能并丰富您的游戏环境。
- en: In *Figure 5**.2*, the `Transform` component is visible in the **Inspector**
    window. It displays the 3D values for **Position**, **Rotation**, and **Scale**.
    The values shown can be changed in the **Inspector** window or through C# programming.
    It is important to note that if the given game object is a child of another game
    object, then these values are relative to the game object’s parent.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5*.2 中，`Transform` 组件在 **检查器** 窗口中可见。它显示了 **位置**、**旋转** 和 **缩放** 的 3D 值。这些值可以在
    **检查器** 窗口中或通过 C# 编程进行更改。需要注意的是，如果给定的游戏对象是另一个游戏对象的子对象，那么这些值是相对于游戏对象父对象的。
- en: '![Figure 5.2 – The Transform component visible in the Inspector window](img/B22128_05_2.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 在检查器窗口中可见的 Transform 组件](img/B22128_05_2.jpg)'
- en: Figure 5.2 – The Transform component visible in the Inspector window
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 检查器窗口中可见的 Transform 组件
- en: Diving deep into Unity’s transformative capabilities, we begin to understand
    the essential role of a GameObject’s `Transform` component. This component is
    the key to manipulating an object’s physical presence within the game world. Through
    the `Transform` component, developers can programmatically adjust an object’s
    position, rotation, and scale, thereby controlling its location, orientation,
    and size in the 3D space.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解 Unity 的变换能力，我们开始理解 GameObject 的 `Transform` 组件的基本作用。这个组件是操纵游戏世界中对象物理存在的关键。通过
    `Transform` 组件，开发者可以编程地调整对象的位置、旋转和缩放，从而控制其在 3D 空间中的位置、朝向和大小。
- en: 'To start, let’s consider the task of moving a GameObject. By accessing the
    `Transform` component’s `` `position` `` property in a script, we can change where
    the object appears in the game world. For instance, to move an object forward
    by *one unit* (in Unity, one unit is a meter), we could use the following C# code
    snippet:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑移动 GameObject 的任务。通过在脚本中访问 `Transform` 组件的 `position` 属性，我们可以改变对象在游戏世界中的位置。例如，要使对象向前移动一个单位（在
    Unity 中，一个单位是一米），我们可以使用以下 C# 代码片段：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Rotation is another critical aspect of object manipulation. Unity allows developers
    to rotate GameObjects around their axes. For example, to rotate an object 90 degrees
    around its y-axis, we might write the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转是对象操作中的另一个关键方面。Unity 允许开发者围绕对象的轴旋转 GameObject。例如，要围绕对象的 y 轴旋转 90 度，我们可能会编写以下代码：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, adjusting an object’s scale can significantly impact the visual dynamics
    of the game. To double the size of a GameObject, the following line of code could
    be employed:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调整对象的缩放可以显著影响游戏的视觉动态。要使 GameObject 的尺寸加倍，可以使用以下代码行：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These examples illustrate how to programmatically adjust a GameObject’s transform
    properties, allowing developers to create dynamic game environments where objects
    move, rotate, and scale in sync with the game’s logic.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例说明了如何以编程方式调整 GameObject 的变换属性，使开发者能够创建动态的游戏环境，其中对象可以与游戏逻辑同步移动、旋转和缩放。
- en: 'Building on these basics, developers can also alter visual properties by changing
    materials and textures. Materials in Unity determine an object’s appearance—color,
    shininess, and transparency—and can be modified to react to game events or player
    actions. For instance, to change an object’s material color to red, you might
    use this C# code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些基础知识的基础上，开发者还可以通过更改材质和纹理来改变视觉属性。在 Unity 中，材质决定了对象的外观——颜色、光泽度和透明度——并且可以修改以对游戏事件或玩家动作做出反应。例如，要将对象的材质颜色更改为红色，你可能使用以下
    C# 代码：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Textures add detail to the surfaces of objects, giving them a more realistic
    or stylized look. Unity allows you to dynamically apply textures to objects, enabling
    scenarios such as changing a character’s outfit or updating a billboard’s advertisement
    in-game. To change a GameObject’s texture, you would first need a reference to
    the new texture and then apply it to the object’s material, as shown in the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理为对象的表面增添了细节，使它们看起来更加逼真或具有风格化。Unity 允许你动态地将纹理应用于对象，实现诸如更改角色的服装或更新游戏中的广告牌广告等场景。要更改
    GameObject 的纹理，你首先需要一个对新纹理的引用，然后将它应用到对象的材质上，如下所示：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can also manipulate component properties for various effects, such as adjusting
    a `Light` component’s intensity to simulate day-night cycles or changing a Particle
    System’s emission rate for player feedback. Combining these with `Transform` manipulations
    enhances interactivity and dynamics in game worlds. Unity’s ability to programmatically
    change properties at runtime fosters creativity and immersion.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以操纵组件属性以产生各种效果，例如调整 `Light` 组件的强度来模拟昼夜循环，或者改变粒子系统的发射率以提供玩家反馈。将这些与 `Transform`
    操作结合使用可以增强游戏世界中的交互性和动态性。Unity 在运行时能够以编程方式更改属性的能力促进了创造性和沉浸感。
- en: The power of Unity’s API extends from simple positional adjustments to dynamic
    visual modifications such as materials and textures, enhancing both visual appeal
    and realism. It’s vital to implement these changes efficiently and safely, focusing
    on developing modular and reusable code. This approach ensures optimal performance
    and extensibility, providing a robust foundation for scalable game development.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的API功能从简单的位置调整到动态视觉修改，如材质和纹理，增强了视觉吸引力和现实感。高效和安全地实施这些更改至关重要，专注于开发模块化和可重用的代码。这种方法确保了最佳性能和可扩展性，为可扩展的游戏开发提供了坚实的基础。
- en: Best practices for API usage
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API使用的最佳实践
- en: Exploring Unity’s API underscores the importance of best practices for efficient
    and safe usage, crucial for smooth game operation and future scalability. This
    section focuses on strategies for enhancing code modularity and reusability, such
    as crafting generic scripts. We address common pitfalls, offering insights into
    maintaining performance and ensuring project extensibility. Navigating Unity’s
    API involves potential challenges that require disciplined development, with a
    focus on efficient and safe API usage vital for the game’s current performance
    and future growth. Emphasizing best practices is essential for the longevity and
    success of any Unity project.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 探索Unity的API强调了高效和安全使用最佳实践的重要性，这对于游戏的平稳运行和未来的可扩展性至关重要。本节重点介绍增强代码模块化和可重用性的策略，例如制作通用脚本。我们解决常见的陷阱，提供有关维护性能和确保项目可扩展性的见解。导航Unity的API涉及潜在挑战，需要纪律性的开发，而关注高效和安全的API使用对于游戏当前性能和未来增长至关重要。强调最佳实践对于任何Unity项目的长期成功至关重要。
- en: 'Let’s take a look at some most recommended best practices:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些最推荐的最佳实践：
- en: '**Emphasis on modularity and reusability in code**: A key practice is focusing
    on modularity and reusability in code. By writing generic scripts, they can be
    reused across various components and projects, saving time and reducing errors.
    For example, a movement script for one character can be adapted for others, and
    an environmental interaction script can be used on multiple objects with unique
    responses. This approach leverages well-tested code and enhances efficiency.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码模块化和可重用性强调**：一个关键实践是关注代码的模块化和可重用性。通过编写通用脚本，它们可以在各种组件和项目中重复使用，节省时间并减少错误。例如，一个角色的移动脚本可以适应其他角色，而环境交互脚本可以用于多个具有独特响应的对象。这种方法利用了经过良好测试的代码并提高了效率。'
- en: Furthermore, the pursuit of modularity leads naturally to the adoption of design
    patterns such as **model-view-controller** (**MVC**) or **entity component system**
    (**ECS**), which further enhance the organization and flexibility of the code
    base. Such patterns facilitate the separation of game logic from presentation
    and data, making the code base easier to navigate, debug, and expand.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，追求模块化自然地导致采用如**模型-视图-控制器**（**MVC**）或**实体组件系统**（**ECS**）等设计模式，这进一步增强了代码库的组织和灵活性。这些模式促进了游戏逻辑与展示和数据的分离，使得代码库更容易导航、调试和扩展。
- en: '`Update()` functions, which can lead to performance bottlenecks. Awareness
    and avoidance of these pitfalls are key to maintaining the smooth operation of
    your game.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update()`函数可能导致性能瓶颈。意识到并避免这些陷阱对于保持游戏的平稳运行至关重要。'
- en: '**Adhering to the principle of scalability**: Lastly, the principle of scalability
    must be woven into the fabric of every Unity project from the outset. Scalability
    refers to the ability of a game to handle growth, whether in terms of content,
    features, or player base, without requiring a complete overhaul. This involves
    not just writing scalable code but also making architectural decisions that anticipate
    future expansion. Scalable code refers to code that is designed and written in
    such a way that it can easily accommodate future growth and changes. Whether it’s
    planning for additional levels, characters, or features, the ability to extend
    your game without a complete overhaul is invaluable.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遵循可扩展性原则**：最后，可扩展性原则必须从一开始就融入每个Unity项目的结构中。可扩展性指的是游戏处理增长的能力，无论是内容、功能还是玩家基础的增长，而无需进行全面的重构。这不仅仅涉及编写可扩展的代码，还包括做出能够预测未来扩展的架构决策。可扩展的代码是指设计和编写方式使其能够轻松适应未来增长和变化的代码。无论是计划额外的关卡、角色或功能，无需全面重构就能扩展游戏的能力是无价的。'
- en: By adhering to these best practices, developers can ensure that their Unity
    projects are not only effective and efficient in the short term but also poised
    for growth and innovation in the long run. This holistic approach to development
    lays a solid foundation for robust, dynamic, and scalable game development, ensuring
    that your Unity projects stand the test of time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些最佳实践，开发者可以确保他们的Unity项目不仅在短期内有效和高效，而且在长期内也做好了增长和创新的准备。这种整体开发方法为稳健、动态和可扩展的游戏开发奠定了坚实的基础，确保你的Unity项目经得起时间的考验。
- en: Our journey through Unity’s API has laid a solid foundation, beginning with
    an introduction to how game objects and components interact to shape gameplay.
    We’ve delved into the intricacies of modifying an object’s spatial attributes—position,
    rotation, and scale—and expanded our skills to dynamically alter visual properties
    such as materials and textures. Alongside these practical skills, we’ve underscored
    the importance of best practices in API usage, highlighting the need for modular,
    reusable code and strategies to sidestep common pitfalls, ensuring both optimal
    performance and project scalability. As we move forward, we’ll build on this groundwork
    by exploring the physics engine, engaging with physics-based interactions, and
    mastering collision detection techniques to enhance game interactivity and responsiveness,
    all while maintaining a commitment to the principles that ensure a seamless and
    immersive gaming experience.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过Unity的API之旅已经打下了一个坚实的基础，从介绍游戏对象和组件如何交互以塑造游戏玩法开始。我们深入研究了修改对象的空间属性——位置、旋转和缩放——的复杂性，并扩展了我们的技能，以动态地改变视觉属性，如材质和纹理。在这些实用技能的基础上，我们强调了在API使用中最佳实践的重要性，强调了需要模块化、可重用代码和策略来规避常见陷阱，确保最佳性能和项目可扩展性。随着我们继续前进，我们将通过探索物理引擎、参与基于物理的交互和掌握碰撞检测技术来增强游戏交互性和响应性，同时保持对确保无缝和沉浸式游戏体验的原则的承诺。
- en: Utilizing physics and collisions
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用物理和碰撞
- en: Exploring Unity’s physics engine enhances game development by simulating real-world
    physics, adding realism to the environment. We start with understanding `Rigidbody`,
    `Collider`, and **Physics Material**, which work together to mimic gravity and
    friction. We then focus on physics-based interactions such as jumping and pushing
    objects to improve gameplay. Further, we introduce raycasting for advanced collision
    detection and interaction. Finally, we discuss best practices for managing physics
    and collisions to ensure games are realistic and perform smoothly for a seamless
    player experience.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 探索Unity的物理引擎通过模拟现实世界的物理，为环境增添了现实感。我们首先理解`Rigidbody`、`Collider`和**Physics Material**，它们共同模拟重力和摩擦。然后，我们专注于基于物理的交互，如跳跃和推动物体以改善游戏玩法。此外，我们引入了光线投射以进行高级碰撞检测和交互。最后，我们讨论了管理物理和碰撞的最佳实践，以确保游戏真实且运行流畅，为玩家提供无缝体验。
- en: Introduction to Unity’s physics engine
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity物理引擎简介
- en: Exploring Unity’s `Rigidbody`, `Collider`, and `Physic Material` replicate gravity
    and friction, grounding objects in realistic physics. The **Physics Layer** concept
    optimizes these simulations within the game environment.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 探索Unity的`Rigidbody`、`Collider`和`Physic Material`可以复制重力和摩擦，使物体在现实物理中稳固。**物理层**概念优化了游戏环境中的这些模拟。
- en: Unity’s efforts to improve the engine’s speed involved collaboration with mathematician
    Stephen Wolfram from the University of Illinois, enhancing its efficiency and
    capability.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Unity为了提高引擎的速度，与伊利诺伊大学的数学家Stephen Wolfram合作，提高了其效率和功能。
- en: At its core, Unity’s physics engine uses sophisticated algorithms and mathematical
    models to animate virtual environments, making objects move and interact in realistic
    ways. This engine is pivotal in creating immersive and interactive game experiences.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Unity的物理引擎使用复杂的算法和数学模型来动画虚拟环境，使物体以现实的方式移动和交互。这个引擎在创建沉浸式和交互式游戏体验方面至关重要。
- en: Rigidbody, Collider, and Physics Material
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rigidbody、Collider和Physics Material
- en: 'Central to Unity’s physics simulation are three pivotal components: `Rigidbody`,
    `Collider`, and Physics Material. Let us take a look at each in detail:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的物理模拟的核心是三个关键组件：`Rigidbody`、`Collider`和Physics Material。让我们详细看看每个组件：
- en: '`Rigidbody` component is essential for dynamics in game objects, allowing them
    to respond to forces such as gravity and move realistically. It enables dynamic
    actions, from characters jumping across platforms to vehicles speeding on tracks.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rigidbody`组件对于游戏对象中的动力学至关重要，允许它们对重力等力做出反应，并实现逼真的运动。它使动态动作成为可能，从角色在平台上跳跃到车辆在轨道上高速行驶。'
- en: '![Figure 5.3 – The Rigidbody component visible in the Inspector window](img/B22128_05_3.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 在检查器窗口中可见的Rigidbody组件](img/B22128_05_3.jpg)'
- en: Figure 5.3 – The Rigidbody component visible in the Inspector window
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 在检查器窗口中可见的Rigidbody组件
- en: '`Collider` component defines an object’s shape for collision detection. It
    acts as an invisible boundary that triggers responses upon contact with other
    colliders, from preventing players from walking through walls to simulating projectile
    impacts. Colliders vary in shape and size to match their objects, enhancing collision
    accuracy.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collider`组件定义了对象的形状以进行碰撞检测。它作为一个不可见的边界，在与其他碰撞体接触时触发响应，从防止玩家穿过墙壁到模拟投射物的撞击。碰撞体在形状和大小上有所不同，以匹配它们的对象，从而提高碰撞的准确性。'
- en: '![Figure 5.4 – The Collider component visible in the Inspector window](img/B22128_05_4.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 在检查器窗口中可见的Collider组件](img/B22128_05_4.jpg)'
- en: Figure 5.4 – The Collider component visible in the Inspector window
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 在检查器窗口中可见的Collider组件
- en: '**Physics Material**: Physics Material further refines the interaction between
    colliding objects by defining surface properties such as friction and bounciness.
    By adjusting these properties, developers can control how objects slide, roll,
    or bounce off each other, adding another layer of realism to the game environment.
    A slippery ice surface, for example, can be simulated by reducing friction on
    a Physics Material, while a bouncy ball’s behavior can be replicated by increasing
    its bounciness parameter.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理材质**：物理材质通过定义表面属性（如摩擦和弹性）进一步细化了碰撞对象的交互。通过调整这些属性，开发者可以控制对象如何滑动、滚动或相互弹跳，为游戏环境增加另一层现实感。例如，可以通过减少物理材质上的摩擦来模拟光滑的冰面，而通过增加弹性参数可以复制弹跳球的动作。'
- en: The Unity physics engine takes into consideration the game object’s `Rigidbody`,
    `Collider`, and Physics Material to determine how it will react to other game
    objects and gravity. As shown in *Figure 5**.5*, a circle is racing toward another
    circle, and when they hit, Unity calculates the physical forces acting on both
    circles as if they existed in the real world.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的物理引擎考虑了游戏对象的`Rigidbody`、`Collider`和物理材质，以确定它将如何对其他游戏对象和重力做出反应。如图*图5.5*所示，一个圆正朝着另一个圆飞驰，当它们相撞时，Unity计算作用在两个圆上的物理力，就像它们存在于现实世界中一样。
- en: '![Figure 5.5 – A game object’s interaction with another object and gravity
    considering its Rigidbody, Collider, and Physics Material](img/B22128_05_5.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 考虑到游戏对象的Rigidbody、Collider和物理材质，与另一个对象和重力的交互](img/B22128_05_5.jpg)'
- en: Figure 5.5 – A game object’s interaction with another object and gravity considering
    its Rigidbody, Collider, and Physics Material
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 考虑到游戏对象的Rigidbody、Collider和物理材质，与另一个对象和重力的交互
- en: Next, let’s explore how Unity’s physics engine manages object interactions with
    the Physics Layer feature.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索Unity的物理引擎如何通过物理层功能管理对象之间的交互。
- en: Physics Layer
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 物理层
- en: Unity’s physics engine introduces the **Physics Layer** feature, allowing developers
    to categorize objects into layers and define their interactions, optimizing physics
    calculations and game performance. For instance, decorative objects that do not
    interact with the player can be placed in a separate layer to exclude them from
    physics calculations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的物理引擎引入了**物理层**功能，允许开发者将对象分类到不同的层并定义它们的交互，优化物理计算和游戏性能。例如，不与玩家交互的装饰性对象可以放置在单独的一层中，以排除它们从物理计算中。
- en: This engine provides a robust toolkit for simulating real-world physics, enhancing
    game interactivity and realism through components such as `Rigidbody`, `Collider`,
    and Physics Material. The Physics Layer feature further refines performance by
    managing how different object layers interact.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此引擎提供了一套强大的工具集，用于模拟现实世界的物理，通过`Rigidbody`、`Collider`和物理材质等组件增强游戏交互性和现实感。物理层功能通过管理不同对象层之间的交互进一步优化性能。
- en: Exploring Unity’s physics engine reveals its capability to accurately simulate
    physical phenomena and optimize game mechanics. As we advance, we’ll focus on
    practical applications of these principles in game interactions, such as manipulating
    gravity and understanding collision dynamics, to create responsive and engaging
    game environments.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 探索 Unity 的物理引擎揭示了其准确模拟物理现象和优化游戏机制的能力。随着我们不断进步，我们将关注这些原则在游戏交互中的实际应用，例如操纵重力和理解碰撞动力学，以创建响应式和引人入胜的游戏环境。
- en: Physics-based interactions
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于物理的交互
- en: Mastering physics-based mechanics is crucial for engaging game experiences in
    Unity. This begins with foundational concepts such as applying forces and using
    gravity to animate the game world, leading to complex interactions. Practical
    examples include jumping dynamics, pushing mechanics, and projectile motion, providing
    insights into animating virtual environments. Additionally, the critical role
    of collision detection, involving trigger and non-trigger colliders, is emphasized,
    highlighting its importance in creating interactive and responsive environments
    where actions significantly enhance gameplay.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中，掌握基于物理的机制对于创造引人入胜的游戏体验至关重要。这始于基础概念，例如应用力量和使用重力来动画化游戏世界，进而导致复杂的交互。实际例子包括跳跃动力学、推动机制和抛射运动，为动画虚拟环境提供了见解。此外，强调碰撞检测的关键作用，包括触发和非触发碰撞体，突出其在创建交互式和响应式环境中的重要性，其中动作显著增强了游戏玩法。
- en: 'Proficiency in Unity’s physics involves understanding real-world physics emulation
    through forces and gravity manipulation, essential for animating game objects.
    For example, launching a character into a leap or moving objects across the scene
    involves applying a force to the `Rigidbody` component, making movements feel
    real and tangible. Here’s a simple example of a C# script for a `jump` command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 精通 Unity 的物理涉及通过力量和重力的操作来模拟现实世界的物理，这对于动画化游戏对象至关重要。例如，将角色抛入跳跃或将物体移动到场景中涉及对 `Rigidbody`
    组件应用力量，使动作感觉真实和有形。以下是一个简单的 C# 脚本示例，用于 `jump` 命令：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The previous block sets the `jumpForce` (how much force to apply for a jump),
    `rb` (the `Rigidbody` component), and `isGrounded` (a Boolean that records that
    the player is on the ground) variables.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码块设置了 `jumpForce`（跳跃时应用的力量），`rb`（`Rigidbody` 组件），以及 `isGrounded`（一个记录玩家是否站在地面的布尔值）变量。
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `Start` method, the `rb` variable is assigned to the player’s `Rigidbody`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Start` 方法中，`rb` 变量被分配给玩家的 `Rigidbody`：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'During the `Update` method, the script checks whether the space key is pressed
    and the player is grounded. If both conditions are true, it applies an upward
    force to make the player jump. The force is applied as an impulse, which is a
    sudden and immediate push:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Update` 方法期间，脚本检查空格键是否被按下且玩家是否站在地面上。如果这两个条件都为真，则应用向上的力量使玩家跳跃。力量以冲量的形式应用，即突然和立即的推动：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding script, the `isGrounded` variable is used to ensure the player
    can only jump when standing on the ground, preventing them from jumping mid-air.
    The `OnCollisionEnter2D` and `OnCollisionExit2D` methods are used to detect when
    the player is touching the ground.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的脚本中，`isGrounded` 变量用于确保玩家只能在站在地面上时跳跃，防止他们在空中跳跃。`OnCollisionEnter2D` 和 `OnCollisionExit2D`
    方法用于检测玩家是否接触地面。
- en: '**Projectile motion** is another common gameplay mechanic where physics plays
    a crucial role. By applying an initial force at an angle, objects can be made
    to follow a parabolic trajectory, simulating the motion of a thrown or launched
    projectile. Here’s a snippet that might be used to launch a projectile:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**抛射运动**是另一种常见的游戏机制，其中物理起着关键作用。通过在角度上应用初始力量，可以使物体沿着抛物线轨迹运动，模拟抛出或发射物体的运动。以下是一个可能用于发射抛射体的代码片段：'
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding script calculates a launch direction based on the specified angle
    and applies a force to the projectile in that direction.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本根据指定的角度计算发射方向，并在此方向上对抛射体应用力量。
- en: 'Furthermore, collision detection is integral to physics-based gameplay, allowing
    objects to interact with one another in believable ways. Unity provides two primary
    types of colliders: **trigger colliders** and **non-trigger** (or **solid**) **colliders**.
    Trigger colliders don’t physically block objects but instead fire events when
    an object enters, stays, or exits the collider area, ideal for detecting player
    interactions with areas of interest or collectibles. Non-trigger colliders, on
    the other hand, are used for physical interactions, such as walking on platforms
    or bumping into walls.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，碰撞检测对于基于物理的游戏至关重要，它允许对象以可信的方式进行交互。Unity 提供了两种主要的碰撞体类型：**触发碰撞体**和**非触发**（或**固体**）**碰撞体**。触发碰撞体不会物理上阻挡对象，而是在对象进入、停留在或离开碰撞体区域时触发事件，非常适合检测玩家与感兴趣区域或可收集物品的交互。另一方面，非触发碰撞体用于物理交互，例如在平台上行走或撞到墙上。
- en: 'Handling collision events in Unity is straightforward with the `OnTriggerEnter`,
    `OnTriggerStay`, `OnTriggerExit`, `OnCollisionEnter`, `OnCollisionStay`, and `OnCollisionExit`
    methods. For instance, to detect when a player picks up a collectible item marked
    with a trigger collider, one might use the following script:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `OnTriggerEnter`、`OnTriggerStay`、`OnTriggerExit`、`OnCollisionEnter`、`OnCollisionStay`
    和 `OnCollisionExit` 方法在 Unity 中处理碰撞事件非常简单。例如，为了检测玩家捡起带有触发碰撞体的可收集物品时，可能会使用以下脚本：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding script, the `OnTriggerEnter2D` method is used to detect when
    the player’s collider intersects with a collectible’s trigger collider, allowing
    the game to respond by removing the collectible and possibly updating the player’s
    score.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的脚本中，使用 `OnTriggerEnter2D` 方法来检测玩家的碰撞体是否与可收集物品的触发碰撞体相交，允许游戏通过移除可收集物品并可能更新玩家的分数来做出响应。
- en: Understanding and utilizing Unity’s physics principles enables developers to
    create rich, interactive game environments. By applying forces and manipulating
    gravity, actions such as jumping and pushing objects come to life, enhancing the
    realism of gameplay. Effective management of collisions through trigger and non-trigger
    colliders is essential for responsive interactions. In the next section, we’ll
    explore a different collision detection with raycasting.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 理解并利用 Unity 的物理原理使开发者能够创建丰富的交互式游戏环境。通过应用力和操纵重力，跳跃和推动物体等动作变得生动，增强了游戏玩法的真实感。通过触发和非触发碰撞体有效地管理碰撞对于响应式交互至关重要。在下一节中，我们将探讨使用光线投射的不同碰撞检测方法。
- en: Advanced collision detection with raycasting
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用光线投射的高级碰撞检测
- en: '`BoxCollider`, `SphereCollider`, `CapsuleCollider`, and `MeshCollider`. This
    method supports precise object detection within the game environment and enables
    a multitude of interactions. It enhances gameplay by enabling accurate line-of-sight
    detection, crucial for stealth and strategy, and refines shooting mechanics for
    responsive combat. Additionally, raycasting’s utility extends to creating interactive
    3D UI elements, demonstrating its versatility in gameplay and UI/UX design.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoxCollider`、`SphereCollider`、`CapsuleCollider` 和 `MeshCollider`。此方法支持在游戏环境中进行精确的对象检测，并启用多种交互。它通过启用精确的视线检测来增强游戏玩法，这对于潜行和策略至关重要，并改进了射击机制，使其对战斗反应灵敏。此外，光线投射的实用性还扩展到创建交互式
    3D UI 元素，展示了它在游戏玩法和 UI/UX 设计中的多功能性。'
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Besides raycasting, Unity offers **linecasting**. Linecasting in Unity detects
    objects along a line between two points, useful for checking lines of sight or
    obstacles. Physics.Linecast(startPoint, endPoint, out RaycastHit hit) identifies
    whether any colliders intersect the line, aiding in **artificial intelligence**
    (**AI**) visibility, bullet paths, and collision detection.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 除了光线投射，Unity 还提供了**线投射**。Unity 中的线投射检测两点之间的线上的对象，这对于检查视线或障碍物非常有用。`Physics.Linecast(startPoint,
    endPoint, out RaycastHit hit)` 方法用于确定是否有任何碰撞体与线相交，这有助于**人工智能**（**AI**）的可见性、子弹轨迹和碰撞检测。
- en: 'In practice, raycasting emits a ray from a source in a specified direction,
    interacting with different types of colliders to facilitate diverse functionalities.
    For example, in stealth games, it’s used for line-of-sight detection to determine
    whether obstacles block an enemy’s view of the player. In shooting mechanics,
    it helps ascertain the impact points of bullets, enabling realistic physics and
    damage calculations. Moreover, in 3D UIs, raycasting can detect intersections
    with UI elements, enhancing interaction within the game’s environment. Here’s
    how raycasting is typically implemented in Unity for shooting mechanics:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，射线投射从源点沿指定方向发射射线，与不同类型的碰撞体交互，以实现各种功能。例如，在潜行游戏中，它用于视线检测，以确定障碍物是否阻挡了敌人对玩家的视线。在射击机制中，它有助于确定子弹的击中点，实现逼真的物理和伤害计算。此外，在
    3D 用户界面中，射线投射可以检测与 UI 元素的交点，增强游戏环境中的交互。以下是 Unity 中射击机制中通常实现的射线投射方法：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As developers optimize game physics for performance and realism, adopting best
    practices in physics management becomes crucial. This includes using physics layers
    to streamline computations, adjusting the physics timestep for consistent outcomes,
    and considering non-physics methods for certain interactions to maintain performance,
    ensuring a smooth and engaging player experience.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开发者为了性能和逼真度优化游戏物理，采用物理学管理的最佳实践变得至关重要。这包括使用物理层来简化计算，调整物理时间步长以实现一致的结果，以及考虑某些交互的非物理方法以保持性能，确保流畅且吸引人的玩家体验。
- en: Best practices in physics and collision management
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理学和碰撞管理的最佳实践
- en: In Unity game development, optimizing physics and collision management is crucial
    for balancing performance with realism. Best practices include using physics layers
    to reduce unnecessary calculations, fine-tuning the physics timestep for stable
    and consistent simulations, and incorporating non-physics techniques for specific
    interactions to maintain performance. These strategies aim to harmonize the fidelity
    of physical simulations with gameplay fluidity, ensuring a smooth and immersive
    player experience. Adhering to these practices helps create technically sound
    and enjoyable games by preventing performance issues without sacrificing the realism
    offered by physics interactions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 游戏开发中，优化物理和碰撞管理对于平衡性能与逼真度至关重要。最佳实践包括使用物理层来减少不必要的计算，微调物理时间步长以实现稳定和一致的模拟，以及结合特定的非物理技术以保持性能。这些策略旨在将物理模拟的保真度与游戏流畅性相协调，确保流畅且沉浸式的玩家体验。遵循这些实践有助于通过防止性能问题而不牺牲物理交互提供的逼真度，从而创建技术合理且令人愉悦的游戏。
- en: 'Let’s learn about a few:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一些：
- en: '**Efficiently using Physics Layers**: Unity allows developers to assign game
    objects to different physics layers, which can then interact selectively with
    each other. By organizing objects into these layers wisely, you can significantly
    reduce unnecessary physics calculations. For example, decorative elements that
    don’t need to interact with the player or other game objects can be placed on
    a separate layer that doesn’t calculate collisions, thus saving on processing
    power.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效使用物理层**：Unity 允许开发者将游戏对象分配到不同的物理层，这些层可以相互选择性地交互。通过明智地将对象组织到这些层中，可以显著减少不必要的物理计算。例如，不需要与玩家或其他游戏对象交互的装饰元素可以放置在单独的层上，该层不计算碰撞，从而节省处理能力。'
- en: '**Adjusting the physics timestep**: The physics timestep in Unity determines
    how often the physics engine updates. While a smaller timestep can increase the
    accuracy of simulations, it also requires more processing power. It’s crucial
    to find a balance that maintains stable and realistic physics interactions without
    overburdening the CPU. Adjusting the timestep in Unity’s time settings can help
    achieve smoother simulations, especially in physics-intensive games.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调整物理时间步长**：Unity 中的物理时间步长决定了物理引擎更新的频率。虽然较小的步长可以提高模拟的准确性，但它也要求更多的处理能力。找到平衡点，以保持稳定和逼真的物理交互，同时不过度负担
    CPU，至关重要。在 Unity 的时间设置中调整时间步长可以帮助实现更平滑的模拟，尤其是在物理密集型游戏中。'
- en: '**Employing non-physics-based methods for certain interactions**: Not all interactions
    in a game need to rely on the physics engine. In some cases, using non-physics-based
    methods for interactions, such as simple distance checks for collision detection
    in certain scenarios, can be more performance-friendly while still providing a
    satisfactory outcome. This approach is particularly useful in games where the
    number of objects and interactions can lead to significant performance overheads
    if managed solely through physics.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用基于非物理方法的特定交互**：并非游戏中所有的交互都需要依赖于物理引擎。在某些情况下，使用基于非物理方法的交互，例如在特定场景中进行简单的距离检查以进行碰撞检测，可以更友好地提高性能，同时仍然提供令人满意的结果。这种方法在对象和交互数量可能导致通过物理引擎管理时产生显著性能开销的游戏中尤其有用。'
- en: '**Balancing physical accuracy with gameplay**: While striving for realistic
    physics simulations can enhance the immersion and feel of a game, it’s important
    to remember that gameplay should always come first. In some cases, overly accurate
    physics can detract from the fun and playability of the game. Developers must
    balance physical realism with gameplay mechanics to ensure that the game remains
    engaging and accessible to players.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平衡物理精度与游戏玩法**：虽然追求逼真的物理模拟可以增强游戏的沉浸感和感觉，但重要的是要记住，游戏玩法始终应该是首要的。在某些情况下，过于精确的物理模拟可能会损害游戏的乐趣和可玩性。开发者必须平衡物理现实主义与游戏机制，以确保游戏对玩家来说既吸引人又易于接触。'
- en: By adhering to best practices in physics management, developers can effectively
    balance performance with realistic interactions in Unity, creating games that
    are both efficient and immersive. This balance ensures a smooth and engaging player
    experience. Unity’s physics engine offers extensive possibilities for enhancing
    gameplay with realistic physics, such as gravity, collision detection, and precise
    object interaction through raycasting.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循物理管理的最佳实践，开发者可以在Unity中有效地平衡性能与真实交互，创建既高效又沉浸式的游戏。这种平衡确保了流畅且引人入胜的玩家体验。Unity的物理引擎提供了广泛的可能性，可以通过现实物理效果增强游戏玩法，例如重力、碰撞检测以及通过光线投射进行精确的对象交互。
- en: This foundational understanding paves the way for mastering scene management,
    crucial for controlling scene transitions and adjusting environmental settings
    to improve game flow and atmosphere while maintaining optimization and enhancing
    the overall player experience.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基础理解为掌握场景管理铺平了道路，这对于控制场景转换和调整环境设置以改善游戏流程和氛围至关重要，同时保持优化并提升整体玩家体验。
- en: Managing game scenes and environments
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理游戏场景和环境
- en: In the intricate tapestry of game development within Unity, mastering the art
    of scene management and environmental adjustments stands as a cornerstone for
    crafting compelling narratives and seamless gameplay experiences. This encompasses
    a holistic understanding of how to adeptly manage scene transitions, including
    the nuances of loading and unloading scenes, coupled with the strategic manipulation
    of environmental settings to evoke the desired mood and enhance gameplay dynamics.
    Through a step-by-step exploration, coupled with practical examples, developers
    can grasp the essence of effective scene and environment management. Adhering
    to best practices in this domain not only ensures optimal performance but also
    elevates the player’s immersion and interaction with the game world, making it
    an indispensable skill set for any Unity developer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity游戏开发错综复杂的织锦中，掌握场景管理和环境调整的艺术是构建引人入胜的故事和无缝游戏体验的基石。这包括对如何巧妙地管理场景转换的全面理解，包括加载和卸载场景的细微差别，以及战略性地操纵环境设置以唤起所需的心情并增强游戏动态。通过逐步探索和实际示例，开发者可以掌握有效场景和环境管理的精髓。遵循该领域的最佳实践不仅确保了最佳性能，还提升了玩家与游戏世界的沉浸感和互动性，这对于任何Unity开发者来说都是不可或缺的技能集。
- en: Introduction to scene management in Unity
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity中场景管理的简介
- en: Unity’s **scene management** system is essential for organizing game elements
    such as levels, menus, and UI screens, ensuring efficient gameplay flow and resource
    management. This system allows developers to divide the game into distinct, manageable
    scenes, each dedicated to a specific part of the game. This segmentation aids
    in focusing on individual sections without the complexity of handling the entire
    game, enhancing workflow, and optimizing performance by loading only necessary
    assets.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的**场景管理**系统对于组织游戏元素（如关卡、菜单和UI屏幕）至关重要，确保高效的玩法流程和资源管理。该系统允许开发者将游戏划分为独立的、可管理的场景，每个场景都专注于游戏的一个特定部分。这种分割有助于专注于单个部分，而不必处理整个游戏的复杂性，从而提高工作效率，并通过仅加载必要的资源来优化性能。
- en: The logical separation into scenes helps maintain clarity and facilitates smoother
    transitions between different game states, improving the overall game structure
    and quality. Looking ahead, we’ll delve into using Unity’s `SceneManager` to achieve
    seamless scene transitions, including dynamic loading and unloading, smooth transitions
    with loading screens, asynchronous loading to boost performance, and strategies
    to preserve game state and player progress across scenes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将逻辑分割成场景有助于保持清晰度，并促进不同游戏状态之间的平滑过渡，从而提高整体游戏结构和质量。展望未来，我们将深入探讨使用Unity的`SceneManager`实现无缝场景过渡，包括动态加载和卸载、带有加载界面的平滑过渡、异步加载以提升性能，以及跨场景保持游戏状态和玩家进度的策略。
- en: Controlling scene transitions
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制场景过渡
- en: In the realm of game development, mastering the art of controlling `SceneManager`
    to dynamically manage the loading and unloading of scenes, ensuring a fluid gameplay
    flow. From detailed, step-by-step instructions on crafting smooth transitions
    between scenes with the aid of loading screens, to the implementation of asynchronous
    loading for optimal performance, this subsection covers all bases. It also delves
    into effective methods for passing data between scenes, a crucial aspect for preserving
    game state and player progression, thereby maintaining continuity and immersion
    throughout the game.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发领域，掌握控制`SceneManager`以动态管理场景的加载和卸载的艺术，确保流畅的游戏玩法流程至关重要。本节涵盖了从使用加载界面创建场景间平滑过渡的详细、分步指南，到实现异步加载以优化性能的所有方面。它还深入探讨了在场景间传递数据的有效方法，这对于保持游戏状态和玩家进度至关重要，从而在整个游戏过程中保持连贯性和沉浸感。
- en: Controlling scene transitions is a critical component of game development in
    Unity, directly impacting the fluidity and quality of the player’s experience.
    Unity’s `SceneManager` is a powerful tool that facilitates the dynamic loading
    and unloading of scenes, making transitions smooth and virtually seamless. This
    functionality is essential, especially in games with multiple levels, menus, and
    dynamic content that require frequent scene changes. Unity also provides `asyncLoad.progress`,
    which reports as a percentage of the progress of the scene transition. This can
    be captured to render a progress bar. In most situations, scenes load so quickly
    that this isn’t a useful feature.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中控制场景过渡是游戏开发的关键组成部分，直接影响玩家的流畅性和体验质量。Unity的`SceneManager`是一个强大的工具，它促进了场景的动态加载和卸载，使过渡变得平滑且几乎无缝。这种功能对于具有多个关卡、菜单和需要频繁场景变化的游戏内容至关重要。Unity还提供了`asyncLoad.progress`，它以百分比的形式报告场景过渡的进度。这可以捕获以渲染进度条。在大多数情况下，场景加载如此之快，以至于这不是一个有用的功能。
- en: 'To begin with, let’s discuss how to use Unity’s `SceneManager` to load a new
    scene. The `SceneManager.LoadScene` method is straightforward and can be used
    to load a scene by name or index as specified in the `"GameLevel"`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论如何使用Unity的`SceneManager`来加载新场景。`SceneManager.LoadScene`方法简单直接，可以用来通过在`"GameLevel"`中指定的名称或索引加载场景：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For games that require smooth transitions without jarring cuts, implementing
    loading screens is a common practice. A loading screen can provide visual feedback
    during the loading process, improving the overall user experience. This can be
    achieved by first loading a **loading** scene that contains the loading UI, followed
    by asynchronously loading the **target** scene in the background.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要平滑过渡且无突兀剪辑的游戏，实现加载界面是一种常见做法。加载界面可以在加载过程中提供视觉反馈，从而提升整体用户体验。这可以通过首先加载包含加载界面的**加载**场景，然后异步在后台加载**目标**场景来实现。
- en: '`SceneManager.LoadSceneAsync` method is used for this purpose, allowing the
    next scene to load in the background. Here’s how you can implement asynchronous
    scene loading when loading a new scene:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SceneManager.LoadSceneAsync`方法来实现这一目的，允许在后台加载下一个场景。以下是实现异步场景加载的示例：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Maintaining game state and player progress through scene transitions is another
    critical aspect. This can be managed by storing data in a persistent object that
    is not destroyed when loading a new scene, using Unity’s `DontDestroyOnLoad` method,
    or by utilizing global variables stored in a singleton manager class. Data such
    as player scores, inventory items, or game progress can be passed between scenes
    using these methods to ensure continuity. Here’s how this `DontDestroyOnLoad`
    method can be implemented:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过场景转换维护游戏状态和玩家进度是另一个关键方面。这可以通过在加载新场景时不会销毁的持久对象中存储数据来实现，使用Unity的`DontDestroyOnLoad`方法，或者通过利用存储在单例管理类中的全局变量。玩家得分、库存物品或游戏进度等数据可以通过这些方法在场景之间传递，以确保连续性。以下是实现`DontDestroyOnLoad`方法的示例：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In conclusion, mastering scene transitions in Unity involves a combination of
    using `SceneManager` for dynamic scene loading, implementing loading screens for
    a better user experience, utilizing asynchronous loading to enhance performance,
    and employing data management techniques to maintain continuity across scenes.
    By following these guidelines and utilizing the provided C# examples, developers
    can create smooth and engaging transitions that contribute significantly to the
    overall quality of the gameplay experience.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，掌握Unity中的场景转换需要结合使用`SceneManager`进行动态场景加载、实现加载屏幕以获得更好的用户体验、利用异步加载来提高性能以及采用数据管理技术以保持场景间的连续性。通过遵循这些指南并使用提供的C#示例，开发者可以创建平滑且引人入胜的转换，这对游戏体验的整体质量有重大贡献。
- en: Having explored the intricacies of controlling scene transitions in Unity, from
    the dynamic loading and unloading of scenes to ensuring smooth transitions with
    loading screens and asynchronous loading, we’re now equipped to further enhance
    the player’s immersion into the game world. The next step in crafting a captivating
    game experience lies in adjusting environmental settings. We’ll delve into the
    art of manipulating lighting, skyboxes, and the Terrain Editor, which can affect
    mood and gameplay dynamics. Additionally, we’ll explore how environmental elements
    can be dynamically scripted to evolve in response to gameplay events, such as
    the shifting hues of lighting to signify the passage of time to deepen the narrative
    impact, seamlessly bridging the technical prowess of scene management with the
    creative artistry of environment design.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了Unity中控制场景转换的复杂性之后，从动态加载和卸载场景到确保通过加载屏幕和异步加载实现平滑转换，我们现在已经准备好进一步增强玩家对游戏世界的沉浸感。在制作引人入胜的游戏体验的下一步中，关键在于调整环境设置。我们将深入研究操控光照、天空盒和地形编辑器这一艺术，这些可以影响氛围和游戏动态。此外，我们还将探讨如何动态地编写环境元素脚本，使其能够根据游戏事件进行演变，例如，通过改变光照的色调来象征时间的流逝，从而加深叙事影响，无缝地将场景管理的技术实力与环境设计的创意艺术结合在一起。
- en: Adjusting environmental settings
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整环境设置
- en: Adjusting environmental settings in Unity allows developers to create immersive
    and dynamic game worlds. Techniques such as modifying lighting, integrating skyboxes,
    and using the Terrain Editor significantly influence the game’s mood and dynamics,
    enhancing player immersion. This section will explore how environmental elements
    not only set the stage but also respond dynamically to gameplay events, such as
    day-to-night transitions, adding realism and interactivity.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中调整环境设置允许开发者创建沉浸式和动态的游戏世界。修改光照、集成天空盒和使用地形编辑器等技术显著影响游戏的情绪和动态，增强玩家的沉浸感。本节将探讨环境元素不仅设定了舞台，而且还能动态地响应游戏事件，如昼夜转换，增加真实感和互动性。
- en: 'Lighting is key to crafting immersive environments, which sets the emotional
    tone and highlights important game areas. Unity’s **lighting** system supports
    dynamic changes, such as simulating daylight transitions or enhancing dramatic
    effects, to enrich the gaming experience. For example, a script might adjust the
    intensity and color of a Directional Light to mimic the sun’s movement, creating
    a realistic time-of-day effect:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 照明是打造沉浸式环境的关键，它设定了情感基调并突出了重要的游戏区域。Unity的**照明**系统支持动态变化，例如模拟日光过渡或增强戏剧性效果，以丰富游戏体验。例如，一个脚本可能会调整方向光的强度和颜色来模拟太阳的运动，从而创建一个逼真的时间变化效果：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Skybox` component can be dynamically changed to reflect different environments
    or times of day, adding to the game’s realism and variety.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Skybox`组件可以动态更改，以反映不同的环境或一天中的不同时间，从而增加游戏的真实性和多样性。'
- en: Unity’s **Terrain Editor** is another powerful tool in the environmental toolkit,
    enabling the creation of vast, open landscapes with intricate details. With the
    ability to sculpt, paint, and add foliage, the Terrain Editor allows for the customization
    of game worlds to match the envisioned setting perfectly. Beyond static landscapes,
    you can script environmental elements such as trees swaying in the wind or interactively
    deform terrain in real time, reacting to player actions or events.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的**地形编辑器**是环境工具包中的另一个强大工具，它能够创建广阔、开阔且细节丰富的景观。通过雕刻、绘画和添加植被，地形编辑器允许对游戏世界进行定制，以完美匹配预想的场景。除了静态景观之外，你还可以编写脚本以实现环境元素，如随风摇曳的树木或实时交互性地形变形，这些元素可以响应玩家的动作或事件。
- en: 'For example, to create a simple interaction where the terrain deforms upon
    a player’s position, you might consider a script attached to the player that modifies
    the terrain height at the player’s location:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了创建一个简单的交互，在地形上玩家位置处变形，你可能需要考虑将脚本附加到玩家上，以修改玩家位置的地形高度：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The initial section of this script defines the variables to be used: `terrain`
    (the actual terrain in use in the game), `terrainData` (a Unity data type that
    describes a terrain), and `originalHeightMap` (a float array that will hold the
    various heights of the terrain).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的前部分定义了将要使用的变量：`terrain`（游戏中实际使用的地形）、`terrainData`（一个Unity数据类型，用于描述地形）和`originalHeightMap`（一个浮点数组，将存储地形的各种高度）。
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Start()` method fetches `terrainData` from the game’s terrain. It then
    retrieves and stores the original height map of the entire terrain at the start
    of the game.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()`方法从游戏的地形中获取`terrainData`。然后，它在游戏开始时检索并存储整个地形的高度图。'
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Update()` method continuously tracks the player’s position during each
    frame and converts it into integer coordinates that correspond to a position on
    the terrain grid. It then deforms the terrain at this specific grid location by
    setting the height at that point to a new value (`0.5` in this case), modifying
    the terrain directly underneath where the player is currently located.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()`方法在每一帧中持续跟踪玩家的位置，并将其转换为整数坐标，这些坐标对应于地形网格上的一个位置。然后，它通过将该点的海拔高度设置为新的值（在这个例子中是`0.5`），在玩家当前所在位置下方直接修改地形。'
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This Unity script, `Terrain Deformer`, dynamically alters the terrain’s height
    based on the player’s position during gameplay. Upon starting, it captures the
    original terrain heights for later restoration. During each frame update, it adjusts
    the terrain height directly beneath where the player is positioned, simulating
    real-time terrain deformation. The script ensures the terrain returns to its initial
    state when it is no longer active, maintaining the original landscape integrity.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Unity脚本`Terrain Deformer`在游戏过程中根据玩家的位置动态改变地形的高度。启动时，它捕获原始的地形高度以供后续恢复。在每一帧更新期间，它直接调整玩家所在位置下方的地形高度，模拟实时地形变形。该脚本确保当它不再活跃时，地形返回到初始状态，保持原始景观的完整性。
- en: Adjusting environmental settings in Unity is crucial for crafting immersive
    worlds that react to player interactions and game events, such as time of day.
    By skillfully manipulating lighting, skyboxes, and terrain, developers can create
    dynamic environments that reflect the game’s narrative. Scripting these elements
    enhances realism and makes each player’s experience unique. As we shift focus
    from crafting to optimization, it’s vital to adopt best practices for scene management.
    Techniques such as occlusion culling, adjusting **level of detail** (**LOD**)
    settings, and balancing static and dynamic objects are essential for smooth performance
    across devices, ensuring an optimal blend of visual quality and efficiency.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中调整环境设置对于制作能够对玩家交互和游戏事件（如一天中的时间）做出反应的沉浸式世界至关重要。通过巧妙地操作光照、天空盒和地形，开发者可以创建出反映游戏叙事的动态环境。对这些元素进行脚本编写可以增强现实感，并使每位玩家的体验都独一无二。当我们从制作转向优化时，采用场景管理的最佳实践至关重要。例如，使用遮挡剔除、调整**细节级别**（**LOD**）设置以及平衡静态和动态对象等技术对于确保跨设备流畅的性能、实现视觉质量和效率的最佳组合至关重要。
- en: Best practices for scene and environment optimization
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景和环境优化的最佳实践
- en: In optimizing game environments for enhanced performance, it’s essential to
    focus on efficient scene management and the strategic use of optimization techniques.
    This includes employing occlusion culling to reduce unnecessary rendering, adjusting
    LOD settings for better resource management, and differentiating between static
    and dynamic game objects to optimize performance. These practices are key to balancing
    high visual quality with smooth performance, ensuring an optimal gaming experience
    across various devices.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化游戏环境以提高性能时，关注高效的场景管理和优化技术的战略使用至关重要。这包括使用遮挡剔除来减少不必要的渲染、调整LOD设置以实现更好的资源管理，以及区分静态和动态游戏对象以优化性能。这些实践对于平衡高视觉质量和流畅性能至关重要，确保在各种设备上提供最佳的游戏体验。
- en: 'Optimizing game environments is a crucial step in the development process to
    ensure that players experience smooth gameplay across a variety of devices, without
    compromising on visual quality. Implementing efficient scene and environment management
    practices can significantly enhance performance while maintaining the immersive
    qualities of the game world. Here are a few best practices:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 优化游戏环境是开发过程中的关键步骤，以确保玩家在各种设备上都能体验到流畅的游戏体验，同时不牺牲视觉质量。实施高效的场景和环境管理实践可以显著提高性能，同时保持游戏世界的沉浸感。以下是一些最佳实践：
- en: '**Occlusion culling**: Occlusion culling enhances performance by not rendering
    objects hidden from the camera, significantly reducing draw calls and boosting
    frame rates. Unity’s built-in system allows developers to configure occlusion
    culling in the project settings, tailoring it to suit their game’s needs.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遮挡剔除**：遮挡剔除通过不渲染摄像机看不到的对象来提高性能，显著减少绘制调用并提高帧率。Unity内置系统允许开发者配置项目设置中的遮挡剔除，以适应他们游戏的需求。'
- en: '**LOD settings**: LOD reduces 3D model complexity based on distance from the
    camera, lightening the processing load while maintaining visual quality. In Unity,
    LOD groups automate model switching to optimize performance without compromising
    aesthetics.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LOD设置**：LOD根据与摄像机的距离减少3D模型的复杂性，减轻处理负担的同时保持视觉质量。在Unity中，LOD组自动切换模型以优化性能，而不会影响美观。'
- en: '**Using static and dynamic game objects**: Understanding when to use static
    versus dynamic objects is crucial for optimization. Static objects such as buildings,
    trees, and street furniture, which do not move or change during gameplay, can
    be batched by Unity to reduce draw calls, enhancing performance. Conversely, dynamic
    objects such as characters, vehicles, and animated props, which are subject to
    change, are treated differently by the engine. Strategically marking objects as
    static in the Unity Editor can lead to significant performance gains, especially
    in scenes with a high number of stationary elements. Note that this setting is
    frequently found in a game object’s **Inspector** window.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用静态和动态游戏对象**：了解何时使用静态对象与动态对象对于优化至关重要。静态对象，如建筑、树木和街道家具，在游戏过程中不会移动或改变，可以被Unity批处理以减少绘制调用，从而提高性能。相反，动态对象，如角色、车辆和动画道具，由于会发生变化，因此引擎会以不同的方式处理。在Unity编辑器中战略性地标记对象为静态可以带来显著的性能提升，尤其是在具有大量静止元素的场景中。请注意，此设置通常可以在游戏对象的**检查器**窗口中找到。'
- en: Balancing optimization techniques is crucial for creating games that both look
    great and perform well across various hardware. Developers need to continuously
    test and adjust settings to achieve the optimal mix of visual quality and performance.
    Managing game scenes and environments in Unity is essential for ensuring seamless
    gameplay and immersive atmospheres, including optimizing environmental settings
    for mood and dynamics.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 平衡优化技术对于创建外观出色且在各种硬件上表现良好的游戏至关重要。开发者需要持续测试和调整设置，以实现视觉质量和性能的最佳组合。在Unity中管理游戏场景和环境对于确保无缝游戏体验和沉浸式氛围至关重要，包括优化环境设置以适应情绪和动态。
- en: Moving forward, we will explore Unity’s advanced API features, including networking,
    AI, and complex game mechanics. This will equip developers with the skills to
    implement sophisticated features efficiently while maintaining performance and
    scalability.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 未来，我们将探索Unity的高级API功能，包括网络、AI和复杂游戏机制。这将使开发者能够高效地实现复杂功能，同时保持性能和可扩展性。
- en: Advanced API features
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级API功能
- en: Exploring advanced API features in Unity expands the scope of game development,
    allowing creators to enhance their games with complex functionalities such as
    networking, AI, and sophisticated mechanics. This exploration includes practical
    examples and best practices for implementing these features effectively while
    optimizing performance and ensuring project extensibility. This journey not only
    boosts developers’ technical skills but also improves the interactivity and immersion
    of their games.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 探索Unity的高级API功能可以扩大游戏开发的范围，让创作者能够通过复杂的网络、AI和高级机制等功能来增强他们的游戏。这包括实施这些功能的实际示例和最佳实践，同时优化性能并确保项目可扩展性。这次旅程不仅提升了开发者的技术技能，还提高了他们游戏的交互性和沉浸感。
- en: Exploring Unity’s advanced API capabilities
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索Unity的高级API功能
- en: Delving into Unity’s advanced API functionalities opens up vast opportunities
    for developers to enhance gameplay. These capabilities allow for the creation
    of complex multiplayer networks, lifelike AI for **non-player characters** (**NPCs**),
    and intricate game mechanics through advanced scripting. This introduction previews
    the extensive potential these features offer for transforming game design and
    enriching player interaction.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 深入研究Unity的高级API功能为开发者提供了大量机会来增强游戏体验。这些功能允许创建复杂的多人网络、逼真的**非玩家角色**（NPC）AI以及通过高级脚本实现的复杂游戏机制。本介绍预览了这些功能为改变游戏设计和丰富玩家交互提供的广泛潜力。
- en: 'Unity’s advanced API is pivotal for developers aiming to craft immersive, complex
    games that captivate players. Central to this are networking features that connect
    players globally and AI that bring characters to life. For instance, a basic networked
    player movement might begin with a script like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于旨在制作吸引玩家、沉浸式且复杂的游戏的开发者来说，Unity的高级API至关重要。这其中包括连接全球玩家的网络功能和使角色栩栩如生的AI。例如，基本的网络玩家移动可能从一个像这样的脚本开始：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding snippet leverages Unity’s `` `NetworkBehaviour` `` to differentiate
    between the local player and others in a networked game, ensuring that each player
    controls only their avatar.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段利用Unity的`NetworkBehaviour`来区分网络游戏中本地玩家和其他玩家，确保每个玩家只能控制自己的角色。
- en: 'AI is another domain where Unity’s API shines, allowing the creation of NPCs
    with behaviors that range from simple patrolling to complex decision-making processes.
    Using Unity’s AI tools, such as the `NavMesh` system, developers can script NPCs
    to navigate the game world intelligently. Consider the following example for a
    basic enemy AI that follows the player:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: AI是Unity API大放异彩的另一个领域，它允许创建具有从简单巡逻到复杂决策过程行为的NPC。使用Unity的AI工具，例如`NavMesh`系统，开发者可以为NPC编写脚本，使其在游戏世界中智能导航。以下是一个基本敌人AI的示例，该AI会跟随玩家：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code snippet utilizes Unity’s `NavMeshAgent` to enable an NPC
    to pursue the player, showcasing the potential for creating engaging enemy behaviors.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使用Unity的`NavMeshAgent`使NPC能够追逐玩家，展示了创建引人入胜的敌人行为潜力。
- en: 'Furthermore, advanced scripting opens the door to intricate game mechanics
    that can significantly enhance gameplay. Whether it’s a complex inventory system,
    a crafting mechanic, or an interactive dialogue system, Unity’s API provides the
    tools necessary to bring these ideas to life. For instance, a basic inventory
    system might include a script to add items:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，高级脚本打开了一扇通往复杂游戏机制的大门，这些机制可以显著增强游戏体验。无论是复杂的库存系统、制作机制，还是交互式对话系统，Unity的API提供了将这些想法实现为现实所需的工具。例如，一个基本的库存系统可能包括一个添加物品的脚本：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding example demonstrates how a simple inventory system can be implemented,
    allowing players to collect and store items within the game.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例演示了如何实现一个简单的库存系统，允许玩家在游戏中收集和存储物品。
- en: Unity’s advanced API capabilities offer a vast landscape of possibilities for
    game developers, from networking for multiplayer experiences to AI for NPCs and
    beyond. These features not only broaden the scope of what can be achieved with
    advanced scripting but also underscore the importance of creating dynamic and
    engaging gameplay experiences that resonate with players. As we venture deeper
    into the realm of game development, the subsequent section will provide a detailed
    exploration of how to harness these advanced functionalities. Through in-depth
    examples and step-by-step guides, developers will learn to implement sophisticated
    game features such as a multiplayer framework, intelligent NPC behaviors, and
    realistic physics interactions, applying the advanced concepts discussed earlier
    to enrich their game development projects with complex and captivating gameplay
    elements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的高级API功能为游戏开发者提供了广阔的可能性，从多人游戏体验的网络到NPC的AI以及更多。这些功能不仅拓宽了高级脚本可以实现的范围，而且强调了创建动态和吸引人的游戏体验的重要性，这些体验能够与玩家产生共鸣。随着我们深入游戏开发领域，下一节将详细探讨如何利用这些高级功能。通过深入示例和逐步指南，开发者将学习如何实现复杂的游戏功能，如多人游戏框架、智能NPC行为和逼真的物理交互，将之前讨论的高级概念应用于丰富他们的游戏开发项目，增加复杂和吸引人的游戏元素。
- en: Implementing sophisticated game features
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现复杂的游戏功能
- en: Exploring sophisticated game features with Unity’s advanced APIs enables developers
    to create complex, nuanced gameplay experiences. This section offers detailed
    examples and guides on advanced functionalities, from setting up multiplayer frameworks
    to animating the game world with AI-driven NPCs and immersive physics. By applying
    these concepts, developers can enhance the technical quality and interactive appeal
    of their games, making them more memorable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Unity的高级API探索复杂的游戏功能，使开发者能够创建复杂、细腻的游戏体验。本节提供了详细的示例和指南，涵盖了高级功能，从设置多人游戏框架到使用AI驱动的NPC和沉浸式物理动画游戏世界。通过应用这些概念，开发者可以提升游戏的技术质量和互动吸引力，使游戏更加令人难忘。
- en: 'Using Unity’s advanced APIs, developers can transcend traditional game design
    limits by creating immersive, interactive experiences. A key feature is multiplayer
    functionality, enabled through Unity’s networking layer. For example, establishing
    a basic multiplayer setup involves initializing a network manager and creating
    networked player objects for interaction in a shared environment:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Unity的高级API，开发者可以通过创建沉浸式、交互式的体验超越传统的游戏设计限制。一个关键特性是多人游戏功能，通过Unity的网络层启用。例如，建立基本的多人设置涉及初始化网络管理器并创建用于在共享环境中交互的网络化玩家对象：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding script sample demonstrates how to instantiate player objects on
    the server, allowing players to join the game and move around in the same environment.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本示例演示了如何在服务器上实例化玩家对象，允许玩家加入游戏并在相同的环境中移动。
- en: 'Advancing further into the realm of AI, intelligent enemy behaviors can significantly
    enhance the challenge and depth of a game. Using Unity’s AI algorithms, such as
    the `NavMesh` system for pathfinding, developers can script enemies that can chase
    the player or patrol designated areas:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在AI领域进一步深入，智能敌人行为可以显著增强游戏的挑战性和深度。使用Unity的AI算法，例如用于路径查找的`NavMesh`系统，开发者可以编写脚本，使敌人能够追逐玩家或巡逻指定区域：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding example illustrates a basic AI enemy setup where the enemy character
    uses `NavMeshAgent` to patrol between multiple points. The `Start` method initializes
    the patrol by setting the first patrol point as the destination. The `Update`
    method checks whether the enemy has reached the current patrol point and sets
    the next patrol point as the new destination, creating a predictable yet engaging
    patrol behavior.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例说明了基本AI敌人设置，其中敌人角色使用`NavMeshAgent`在多个点之间巡逻。`Start`方法通过设置第一个巡逻点为目标来初始化巡逻。`Update`方法检查敌人是否到达了当前的巡逻点，并将下一个巡逻点设置为新的目标，从而创建了一种可预测但引人入胜的巡逻行为。
- en: 'Incorporating advanced physics simulations into a game can add an extra layer
    of realism and interactivity. Unity’s physics engine allows for the simulation
    of complex environmental interactions, such as objects being affected by forces
    or believably colliding with one another:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将高级物理模拟引入游戏可以增加额外的现实感和交互性。Unity的物理引擎允许模拟复杂的环境交互，例如物体受到力的作用或相互碰撞得令人信服：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding script applies a force to a `Rigidbody` component, simulating
    the effect of physical forces on game objects. Such physics-based interactions
    can significantly contribute to the game’s realism, making the world feel more
    alive and responsive to the player’s actions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本向`Rigidbody`组件施加力，模拟物理力对游戏对象的影响。这种基于物理的交互可以显著提高游戏的真实感，使世界感觉更加生动并对玩家的动作做出反应。
- en: Through these examples, it becomes clear how Unity’s advanced APIs can be leveraged
    to implement sophisticated game features, from multiplayer setups and AI behaviors
    to complex physics interactions. These elements, when skillfully integrated into
    a game, can greatly enhance the gameplay experience, making it more engaging and
    dynamic for players.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些示例，可以清楚地看到Unity的高级API如何被利用来实现复杂游戏功能，从多人设置和AI行为到复杂的物理交互。当这些元素巧妙地整合到游戏中时，可以极大地提升游戏体验，使游戏对玩家来说更加吸引人和动态。
- en: Diving into Unity’s advanced APIs to implement sophisticated game features such
    as multiplayer setups, AI behaviors, and physics simulations showcases the potential
    for creating dynamic and engaging gameplay. As we shift focus towards mastering
    advanced development in Unity, we’ll emphasize best practices for leveraging these
    complex functionalities. Key considerations include optimizing performance, ensuring
    efficient network and AI operations, and managing advanced physics interactions,
    all while maintaining a modular and maintainable game architecture to support
    future development and scalability.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 深入Unity的高级API以实现复杂的游戏功能，如多人设置、AI行为和物理模拟，展示了创建动态和吸引人的游戏的可能性。随着我们转向掌握Unity的高级开发，我们将强调利用这些复杂功能的最佳实践。关键考虑因素包括优化性能、确保高效的网络和AI操作，以及管理高级物理交互，同时保持模块化和可维护的游戏架构以支持未来的开发和可扩展性。
- en: Best practices for advanced development
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级开发的最佳实践
- en: 'Mastering advanced development in Unity requires adhering to best practices
    that optimize the use of Unity’s API features and ensure project scalability.
    Key areas include optimizing network communication to reduce multiplayer game
    latency and enhancing AI for NPCs without causing performance issues by using
    efficient pathfinding and decision-making processes. Managing complex physics
    interactions is also crucial, particularly for games requiring realism, by applying
    physics calculations judiciously and using simplified colliders for complex objects.
    These practices ensure advanced features enhance game performance and support
    future development. Consider the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中掌握高级开发需要遵循最佳实践，以优化Unity API功能的利用并确保项目可扩展性。关键领域包括优化网络通信以减少多人游戏延迟，以及通过使用高效的路径寻找和决策过程来增强NPC的AI，而不会因性能问题而受到影响。管理复杂的物理交互也非常关键，特别是对于需要现实感的游戏，通过明智地应用物理计算和使用简化的碰撞器来处理复杂对象。这些实践确保高级功能可以提升游戏性能并支持未来的开发。考虑以下方面：
- en: '**Modular design**: Structure your game components in a way that allows for
    individual parts to be updated or replaced without affecting the whole system.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化设计**：以允许单独部分更新或替换而不影响整个系统的方式构建游戏组件。'
- en: '**Efficient resource management**: Be mindful of memory and processing power,
    especially when dealing with high-resolution textures, complex models, and extensive
    game worlds.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效资源管理**：在处理高分辨率纹理、复杂模型和广泛的游戏世界时，注意内存和处理能力。'
- en: '**Scalable game architecture**: Plan your game’s architecture to accommodate
    future expansions, updates, and optimizations easily.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展的游戏架构**：规划游戏架构以轻松适应未来的扩展、更新和优化。'
- en: '**Continuous testing and profiling**: Regularly test your game’s performance
    across different devices and use profiling tools to identify and address bottlenecks.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续测试和性能分析**：定期测试游戏在不同设备上的性能，并使用性能分析工具来识别和解决瓶颈。'
- en: Adhering to these best practices not only enhances the quality and performance
    of your game but also ensures that it remains adaptable and scalable, ready to
    evolve with player expectations and technological advancements.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些最佳实践不仅提高了游戏的质量和性能，还确保了游戏能够适应和扩展，随时准备随着玩家期望和技术进步而发展。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have delved deep into mastering Unity’s API, presenting
    an essential journey through the mechanics of accessing and manipulating game
    components, a critical skill set for any developer looking to infuse their games
    with dynamic and interactive elements. The chapter meticulously covers the implementation
    of physics-based interactions, offering insights into creating gameplay that mirrors
    the realism and immersion of the physical world. Additionally, it navigates through
    the intricacies of scene management and environmental adjustments, crucial for
    crafting captivating game environments that engage players. With a focus on advanced
    API functionalities, the guide paves the way for developers to introduce sophisticated
    features and mechanics into their games, expanding the scope of what can be achieved
    within the Unity engine.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入掌握了 Unity 的 API，呈现了一条通过访问和操作游戏组件的机制的基本旅程，这对于任何希望将动态和交互元素融入游戏的开发者来说是一项关键技能。本章详细介绍了基于物理的交互的实现，提供了创建与物理世界真实性和沉浸感相匹配的游戏玩法的方法。此外，它还探讨了场景管理和环境调整的复杂性，这对于制作吸引玩家的游戏环境至关重要。专注于高级
    API 功能，本指南为开发者铺平了道路，使他们能够将复杂的功能和机制引入他们的游戏，扩大在 Unity 引擎内所能实现的范围。
- en: As we transition from the comprehensive exploration of Unity’s API and its potential
    to revolutionize game functionality, in the next chapter, we shift focus toward
    the power of data structures in Unity. The upcoming chapter promises to unlock
    new dimensions in game development, highlighting the use of arrays, lists, dictionaries,
    and HashSets for efficient organization and manipulation of game data. It emphasizes
    the strategic selection and application of these structures to manage complex
    game elements and mechanics, laying a solid foundation for advanced and efficient
    game design. Through practical examples and best practices, developers will learn
    to harness these data structures to refine and enhance game mechanics, marking
    another step forward in the journey of game development mastery.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们从全面探索 Unity 的 API 及其革命性游戏功能潜力的阶段过渡到下一章，我们将焦点转向 Unity 中数据结构的力量。即将到来的章节承诺将解锁游戏开发的新维度，突出使用数组、列表、字典和
    HashSets 来高效组织和操作游戏数据。它强调战略性地选择和应用这些结构来管理复杂的游戏元素和机制，为高级和高效的游戏设计打下坚实基础。通过实际示例和最佳实践，开发者将学会利用这些数据结构来精炼和增强游戏机制，标志着游戏开发掌握之旅的又一步前进。
