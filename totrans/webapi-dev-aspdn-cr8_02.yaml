- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Getting Started with ASP.NET Core Web APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core Web API入门
- en: '**ASP.NET Core** is a cross-platform, open-source web application framework
    for building modern, cloud-enabled web applications and APIs. It is primarily
    used with the C# programming language. ASP.NET Core provides features to help
    you build web apps in various ways – for example, through ASP.NET MVC, web APIs,
    Razor Pages, Blazor, and so on. This book will mainly cover web APIs. In this
    chapter, we will learn how to build a simple REST web API with ASP.NET Core.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**ASP.NET Core**是一个跨平台、开源的Web应用程序框架，用于构建现代、云支持的Web应用程序和API。它主要用于与C#编程语言一起使用。ASP.NET
    Core提供了一些功能，帮助你以各种方式构建Web应用程序 - 例如，通过ASP.NET MVC、Web API、Razor Pages、Blazor等。本书将主要涵盖Web
    API。在本章中，我们将学习如何使用ASP.NET Core构建一个简单的REST Web API。'
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Setting up the development environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: Creating a simple REST web API project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的REST Web API项目
- en: Building and running the project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和运行项目
- en: Understanding the MVC pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解MVC模式
- en: '**Dependency** **injection** (**DI**)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入**(**DI**)'
- en: Introduction to minimal APIs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小API简介
- en: This chapter will provide you with the necessary information to create a basic
    REST web API project with ASP.NET Core. By the end of this chapter, you should
    have a better understanding of the steps required to create your first ASP.NET
    Core web API project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为你提供创建基本REST Web API项目所需的必要信息，使用ASP.NET Core。到本章结束时，你应该对创建第一个ASP.NET Core
    Web API项目所需的步骤有更好的理解。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You are expected to know the basic concepts of **.NET Framework** or **.NET
    Core**, and **object-oriented programming** (**OOP**). You should also have a
    basic understanding of the **C#** programming language. If you are not familiar
    with these concepts, you can refer to the following resources:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 预期你应了解**.NET Framework**或**.NET Core**的基本概念，以及**面向对象编程**(**OOP**)。你还应具备对**C#**编程语言的基本理解。如果你不熟悉这些概念，可以参考以下资源：
- en: '**.NET** **fundamentals**: [https://learn.microsoft.com/en-us/dotnet/fundamentals/](https://learn.microsoft.com/en-us/dotnet/fundamentals/)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET** **基础**: [https://learn.microsoft.com/en-us/dotnet/fundamentals/](https://learn.microsoft.com/en-us/dotnet/fundamentals/)'
- en: '**C#**: [https://learn.microsoft.com/en-us/dotnet/csharp/](https://learn.microsoft.com/en-us/dotnet/csharp/)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C#**: [https://learn.microsoft.com/en-us/dotnet/csharp/](https://learn.microsoft.com/en-us/dotnet/csharp/)'
- en: '**OOP (****C#)**: [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/oop](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/oop)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OOP (****C#)**: [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/oop](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/oop)'
- en: The code examples in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter2](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter2).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可以在[https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter2](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter2)找到。
- en: Setting up the development environment
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: .NET Core is fully cross-platform and can run on Windows, Linux, and macOS,
    so you can use any of these platforms to develop ASP.NET Core applications. The
    code samples in this book are written on Windows 11\. However, you can run the
    same code on Linux and macOS.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core完全跨平台，可以在Windows、Linux和macOS上运行，因此你可以使用这些平台中的任何一个来开发ASP.NET Core应用程序。本书中的代码示例是在Windows
    11上编写的。然而，你可以在Linux和macOS上运行相同的代码。
- en: There are also several IDEs available for ASP.NET Core, such as Visual Studio,
    **Visual Studio Code** (**VS Code**), Visual Studio for Mac, and Rider. In this
    book, we will mainly use VS Code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ASP.NET Core，也有几个IDE可供选择，例如Visual Studio、**Visual Studio Code** (**VS Code**)、Visual
    Studio for Mac和Rider。在这本书中，我们将主要使用VS Code。
- en: Why not Visual Studio?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不使用Visual Studio？
- en: Visual Studio is a powerful IDE for the .NET platform. It provides a bunch of
    tools and features to elevate and enhance every stage of software development.
    However, VS Code is more lightweight and is open-source and cross-platform. We
    will use VS Code to understand the concepts of ASP.NET Core, then migrate to Visual
    Studio to use its rich features. If you are familiar with Visual Studio or any
    other IDE, feel free to use it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio是.NET平台的强大IDE。它提供了一系列工具和功能，以提升和增强软件开发每个阶段的体验。然而，VS Code更轻量级，且开源且跨平台。我们将使用VS
    Code来理解ASP.NET Core的概念，然后迁移到Visual Studio以使用其丰富的功能。如果你熟悉Visual Studio或任何其他IDE，请随意使用。
- en: 'Here is a list of software, SDKs, and tools you need to install:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一份你需要安装的软件、SDK 和工具列表：
- en: '**VS** **Code**: [https://code.visualstudio.com/download](https://code.visualstudio.com/download)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VS Code**：[https://code.visualstudio.com/download](https://code.visualstudio.com/download)'
- en: '**.NET 8** **SDK**: [https://dotnet.microsoft.com/en-us/download](https://dotnet.microsoft.com/en-us/download)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET 8 SDK**：[https://dotnet.microsoft.com/en-us/download](https://dotnet.microsoft.com/en-us/download)'
- en: Both VS Code and the .NET 8 SDK are cross-platform, so please choose the correct
    one for your OS. When you install VS Code, please make sure you check the **Add
    to** **PATH** option.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 和 .NET 8 SDK 都是跨平台的，所以请根据你的操作系统选择正确的版本。当你安装 VS Code 时，请确保勾选 **添加到**
    **PATH** 选项。
- en: If you use Windows, you may want to install **Windows Terminal** to run the
    command line. Windows Terminal is available for Windows 10 and above, and it provides
    a better user experience. But it is optional because you can also use the command
    line directly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Windows，你可能想安装 **Windows Terminal** 来运行命令行。Windows Terminal 可用于 Windows
    10 及以上版本，并提供更好的用户体验。但它是可选的，因为你也可以直接使用命令行。
- en: Configuring VS Code
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 VS Code
- en: 'Strictly speaking, VS Code is a code editor. It cannot recognize all the coding
    languages. Therefore, you’ll need to install some extensions to support your development
    workflow. You can browse and install extensions by clicking on the **Extensions**
    icon in the **Activity** bar on the left-hand side of the VS Code interface. Then,
    you will see a list of the most popular extensions on the VS Code Marketplace:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，VS Code 是一个代码编辑器。它不能识别所有编程语言。因此，你需要安装一些扩展来支持你的开发工作流程。你可以在 VS Code 界面左侧的活动栏中点击
    **扩展** 图标来浏览和安装扩展。然后，你将看到 VS Code 市场中最受欢迎的扩展列表：
- en: '![Figure 2.1 – The C# Dev Kit extension for VS Code](img/B18971_02_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – VS Code 的 C# 开发工具包扩展](img/B18971_02_01.jpg)'
- en: Figure 2.1 – Overview of the C# Dev Kit extension for VS Code
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – VS Code 的 C# 开发工具包扩展概述
- en: 'You need to install this extension to support .NET development:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装此扩展以支持 .NET 开发：
- en: '**C# Dev Kit**: This is the official C# extension for VS Code provided by Microsoft.
    When you install C# Dev Kit, the following extensions will automatically be installed:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C# 开发工具包**：这是由 Microsoft 提供的官方 VS Code C# 扩展。当你安装 C# 开发工具包时，以下扩展将自动安装：'
- en: '**C# extension**: This extension provides C# language support powered by OmniSharp'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C# 扩展**：此扩展通过 OmniSharp 提供了 C# 语言支持'
- en: '**IntelliCode for C# Dev Kit**: This extension provides AI-assisted IntelliSense
    for C#'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IntelliCode for C# 开发工具包**：此扩展为 C# 提供了 AI 辅助的 IntelliSense 功能'
- en: '**.NET Runtime Install Tool**: This extension provides a unified way to install
    local, private versions of the .NET runtime'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET 运行时安装工具**：此扩展提供了一种统一的方式来安装本地、私有版本的 .NET 运行时'
- en: The C# Dev Kit extension provides a lot of features to help you develop .NET
    applications. Press *Ctrl* + *Shift* + *P* (on Windows) or *Command* + *Shift*
    + *P* (on macOS) to open the Command Palette, then type `.net` to see the commands
    provided by the C# Dev Kit extension. You can use these commands to create new
    projects, generate assets for build and debug, run tests, and more.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: C# 开发工具包扩展提供了许多功能，帮助你开发 .NET 应用程序。按 *Ctrl* + *Shift* + *P*（在 Windows 上）或 *Command*
    + *Shift* + *P*（在 macOS 上）打开命令面板，然后输入 `.net` 以查看 C# 开发工具包扩展提供的命令。你可以使用这些命令创建新项目、生成构建和调试资源、运行测试等。
- en: 'You can also install the following extensions to improve your productivity:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以安装以下扩展来提高你的生产力：
- en: '**EditorConfig for VS Code**: This extension provides EditorConfig support
    for VS Code. EditorConfig helps teams of multiple developers maintain consistent
    coding styles when working on the same project across various editors and IDEs.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VS Code 的 EditorConfig 扩展**：此扩展为 VS Code 提供了 EditorConfig 支持。EditorConfig
    帮助多个开发者在各种编辑器和 IDE 中维护一致的编码风格，当他们在同一项目上工作时。'
- en: '**GitHub Copilot**: GitHub Copilot is your AI pair programmer. You can get
    code suggestions in real-time based on your context and comments in VS Code. This
    extension is not free, but you can try it for free for 30 days. If you are a student,
    a teacher, or a maintainer of a popular open-source project, you can get it for
    free.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub Copilot**：GitHub Copilot 是你的 AI 代码伴侣。你可以在 VS Code 中根据上下文和注释实时获取代码建议。此扩展并非免费，但你可以在
    30 天内免费试用。如果你是学生、教师或知名开源项目的维护者，你可以免费获得它。'
- en: To configure EditorConfig, you can create a file named `.editorconfig` in the
    root folder of the project. You can find a sample EditorConfig file at [https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/code-style-rule-options](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/code-style-rule-options).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置EditorConfig，您可以在项目的根文件夹中创建一个名为`.editorconfig`的文件。您可以在[https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/code-style-rule-options](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/code-style-rule-options)找到示例EditorConfig文件。
- en: Checking the .NET SDK
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查.NET SDK
- en: 'Once you install the .NET SDK, you can check the version by running the following
    command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了.NET SDK，您可以通过运行以下命令来检查版本：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should be able to see the version number as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够按以下方式看到版本号：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Microsoft releases new versions of .NET SDKs frequently. If you encounter a
    different version number, that is acceptable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 微软经常发布新的.NET SDK版本。如果您遇到不同的版本号，这是可以接受的。
- en: 'You can list all available SDKs by running the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令列出所有可用的SDK：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding command will list all the available SDKs on your machine. For
    example, it may show the following output if have multiple .NET SDKs installed:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将列出您机器上所有可用的SDK。例如，如果您安装了多个.NET SDK，它可能会显示以下输出：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Multiple versions of .NET SDKs can be installed at the same time. We can specify
    the version of the .NET SDKs in the project file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可以同时安装多个.NET SDK版本。我们可以在项目文件中指定.NET SDK的版本。
- en: Which version of the SDKs should I use?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该使用哪个版本的SDK？
- en: Every Microsoft product has a lifecycle. .NET and .NET Core provides **Long-term
    support** (**LTS**) releases that get 3 years of patches and free support. When
    this book was written, .NET 7 is still supported, until May 2024\. Based on Microsoft's
    policy, even numbered releases are LTS releases. So .NET 8 is the latest LTS release.
    The code samples in this book are written with .NET 8.0.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Microsoft产品都有其生命周期。.NET和.NET Core提供**长期支持**（**LTS**）版本，这些版本将获得3年的补丁和免费支持。当本书编写时，.NET
    7仍在支持中，直到2024年5月。根据微软的政策，偶数版本是LTS版本。因此，.NET 8是最新LTS版本。本书中的代码示例是用.NET 8.0编写的。
- en: To learn more about .NET support policies, please visit [https://dotnet.microsoft.com/en-us/platform/support/policy](https://dotnet.microsoft.com/en-us/platform/support/policy).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于.NET支持策略的信息，请访问[https://dotnet.microsoft.com/en-us/platform/support/policy](https://dotnet.microsoft.com/en-us/platform/support/policy)。
- en: We are now prepared to start developing ASP.NET Core applications. Let’s get
    to work!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好开始开发ASP.NET Core应用程序。让我们开始工作吧！
- en: Creating a simple REST web API project
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建简单的REST Web API项目
- en: In this section, we will use the **.NET command-line interface** (**.NET CLI**)
    to create a basic web API project and see how it works.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用**.NET命令行界面**（**.NET CLI**）创建一个基本的Web API项目并查看其工作方式。
- en: The .NET CLI is a command-line tool that helps you to create, develop, build,
    run, and publish .NET applications. It is included in the .NET SDK.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: .NET CLI是一个命令行工具，它帮助您创建、开发、构建、运行和发布.NET应用程序。它包含在.NET SDK中。
- en: 'You have multiple ways to run .NET CLI commands. The most common way is to
    run the command in the terminal window or command prompt. Also, you can run the
    command in VS Code directly. VS Code provides an integrated terminal that starts
    at the root of your workspace. To open the terminal in VS Code, you can do any
    one of the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您有多种方式来运行.NET CLI命令。最常见的方式是在终端窗口或命令提示符中运行命令。此外，您还可以在VS Code中直接运行命令。VS Code提供了一个集成终端，它从工作区的根目录开始。要在VS
    Code中打开终端，您可以执行以下任何一项操作：
- en: Press *Ctrl* + *`* (on Windows) or *Command* + *`* (on macOS) to open the terminal
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按*Ctrl* + *`*（在Windows上）或*Command* + *`*（在macOS上）打开终端
- en: Use the **View** | **Terminal** menu item to open the terminal
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**视图** | **终端**菜单项打开终端
- en: 'From the Command Palette, use the **View: Toggle Terminal** command to open
    the terminal'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令面板，使用**视图：切换终端**命令打开终端
- en: 'In the terminal, navigate to a folder where you want to create the project,
    then create a web API project by running the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，导航到您想要创建项目的文件夹，然后通过运行以下命令创建一个Web API项目：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding commands create a new web API project and open it in VS Code.
    `dotnet new` provides many options to create various types of projects, such as
    web APIs, console apps, class libraries, and so on.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令创建了一个新的Web API项目并在VS Code中打开它。`dotnet new`提供了许多选项来创建各种类型的项目，例如Web API、控制台应用程序、类库等。
- en: 'There are some options we can use to specify the project:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些选项来指定项目：
- en: '`-n|--name <OUTPUT_NAME>`: The name for the created output. If not specified,
    the name of the current directory is used.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-n|--name <OUTPUT_NAME>`: 创建输出的名称。如果未指定，则使用当前目录的名称。'
- en: '`-o|--output <OUTPUT_PATH>`: The output path for the created project. If not
    specified, the current directory is used.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-o|--output <OUTPUT_PATH>`: 创建项目的输出路径。如果未指定，则使用当前目录。'
- en: '`-controllers|--use-controllers`: Indicates whether to use controllers for
    actions. If not specified, the default value is `false`.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-controllers|--use-controllers`: 指示是否为操作使用控制器。如果未指定，则默认值是 `false`。'
- en: '`-minimal|--use-minimal-apis`: Indicates whether to use minimal APIs. The default
    value is `false`, but the `-controllers` option will override the `-minimal` option.
    If neither `-controllers` nor `-minimal` is specified, the default value of the
    `-controllers` option, which is `false`, will be used, so a minimal API will be
    created.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-minimal|--use-minimal-apis`: 指示是否使用最小 API。默认值是 `false`，但 `-controllers` 选项会覆盖
    `-minimal` 选项。如果没有指定 `-controllers` 或 `-minimal`，则使用 `-controllers` 选项的默认值 `false`，因此将创建最小
    API。'
- en: Important note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Since .NET 6.0, ASP.NET Core 6.0 provides a new way to create web API projects,
    which is called `--``use-controllers` option.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 自 .NET 6.0 以来，ASP.NET Core 6.0 提供了一种创建 Web API 项目的全新方式，称为 `--use-controllers`
    选项。
- en: 'To learn more about the `dotnet new` command, check this page: [https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new).
    We will introduce more details on the `dotnet` command in the following sections.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 `dotnet new` 命令的信息，请查看此页面：[https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new](https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new)。我们将在接下来的章节中介绍
    `dotnet` 命令的更多细节。
- en: 'When you use VS Code to open the project, the C# Dev Kit extension can create
    a solution file for you. This feature makes VS Code more friendly to C# developers.
    You can see the following structure in the Explorer view:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 VS Code 打开项目时，C# Dev Kit 扩展可以为你创建一个解决方案文件。这个特性使得 VS Code 对 C# 开发者更加友好。你可以在资源管理器视图中看到以下结构：
- en: The reason is that VS 2022 will create a sln file for the project, but .NET
    CLI does not. When using VS Code to open the project, the C# DevKit will create
    the sln file. I think it's worth mentioning it here.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是 VS 2022 会为项目创建一个 sln 文件，但 .NET CLI 不会。当使用 VS Code 打开项目时，C# DevKit 会创建 sln
    文件。我认为在这里提一下是有意义的。
- en: The C# Dev Kit extension provides a new feature, the solution explorer, which
    is located at the bottom. This feature is especially useful when working with
    multiple projects in one solution. You can drag and drop the **SOLUTION EXPLORER**
    to the top to make it more visible.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: C# Dev Kit 扩展提供了一项新功能，即解决方案资源管理器，它位于底部。这个特性在处理一个解决方案中的多个项目时特别有用。你可以将 **SOLUTION
    EXPLORER** 拖放到顶部以使其更易于查看。
- en: 'When you use VS Code to open the project, the C# Dev Kit extension can create
    a solution file for you. This feature makes VS Code more friendly to C# developers.
    You can see the following structure in the Explorer view:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 VS Code 打开项目时，C# Dev Kit 扩展可以为你创建一个解决方案文件。这个特性使得 VS Code 对 C# 开发者更加友好。你可以在资源管理器视图中看到以下结构：
- en: '![Figure 2.2 – The solution explorer and the folder structure](img/B18971_02_02.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 解决方案资源管理器和文件夹结构](img/B18971_02_02.jpg)'
- en: Figure 2.2 – The solution explorer and the folder structure
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 解决方案资源管理器和文件夹结构
- en: Next, we can start to build and run the project.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以开始构建和运行项目。
- en: Building and running the project
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行项目
- en: In this section, we will learn how to build and run the project and introduce
    some useful tools to help you test the APIs. To make it compatible with all platforms,
    we will use .NET CLI commands to build and run the project. We will also learn
    how to debug the project in VS Code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何构建和运行项目，并介绍一些有用的工具来帮助测试 API。为了使其与所有平台兼容，我们将使用 .NET CLI 命令来构建和运行项目。我们还将学习如何在
    VS Code 中调试项目。
- en: Building the project
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建项目
- en: 'The easiest way to build and run the project is to use the `dotnet` command.
    You can run the following command to build the project:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行项目的最简单方法是使用 `dotnet` 命令。你可以运行以下命令来构建项目：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding command will build the project and its dependencies and generate
    a set of binaries. You can find these binaries in the `bin` folder. The `bin`
    folder is the default output folder for the `dotnet build` command. You can use
    the `--output` option to specify the output folder. However, it is recommended
    to use the default `bin` folder. The binaries are some `.``dll` extension.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将构建项目和其依赖项，并生成一组二进制文件。您可以在 `bin` 文件夹中找到这些二进制文件。`bin` 文件夹是 `dotnet build`
    命令的默认输出文件夹。您可以使用 `--output` 选项指定输出文件夹。但是，建议使用默认的 `bin` 文件夹。这些二进制文件是一些 `.dll` 扩展名的文件。
- en: 'You might see the following popups when you use VS Code to open the project:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 VS Code 打开项目时，您可能会看到以下弹出窗口：
- en: '![Figure 2.3 – VS Code prompts to restore dependencies](img/B18971_02_03.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – VS Code 提示恢复依赖项](img/B18971_02_03.jpg)'
- en: Figure 2.3 – VS Code prompts to restore dependencies
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – VS Code 提示恢复依赖项
- en: 'This is because VS Code inspects that the project is a .NET project, and it
    is trying to restore the dependencies. You can click the **Restore** button to
    restore the dependencies. Similarly, if you see other prompts from VS Code to
    add assets to debug the project, please select **Yes** in the dialog:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 VS Code 会检查项目是否为 .NET 项目，并尝试恢复依赖项。您可以点击**恢复**按钮来恢复依赖项。同样，如果您看到 VS Code
    提示添加资产以调试项目，请在对话框中选中**是**：
- en: '![Figure 2.4 – VS Code prompts to add required assets to build and debug](img/B18971_02_04.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – VS Code 提示添加构建和调试所需的资产](img/B18971_02_04.jpg)'
- en: Figure 2.4 – VS Code prompts to add required assets to build and debug
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – VS Code 提示添加构建和调试所需的资产
- en: Some commands, such as `dotnet build`, `dotnet run`, `dotnet test`, and `dotnet
    publish`, will implicitly restore dependencies. So don't worry if you missed out
    on these prompts.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一些命令，如 `dotnet build`、`dotnet run`、`dotnet test` 和 `dotnet publish`，将隐式恢复依赖项。所以如果您错过了这些提示，请不要担心。
- en: If no errors or warnings are shown, that means the build is successful.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有显示错误或警告，则表示构建成功。
- en: Running the project
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行项目
- en: 'You can run the following command to run the project:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行以下命令来运行项目：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `dotnet run` command is a convenient way of running the project from the
    source code. Keep in mind that it is useful in development, but not for production.
    The reason is that if the dependencies are outside of the shared runtime, the
    `dotnet run` command will resolve the dependencies from the NuGet cache. To run
    the application in production, you need to create a deployment package with the
    `dotnet publish` command and deploy it. We will explore the deployment process
    in future chapters.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotnet run` 命令是从源代码运行项目的便捷方式。请注意，它在开发中很有用，但不适用于生产。原因是如果依赖项不在共享运行时之外，`dotnet
    run` 命令将从 NuGet 缓存中解析依赖项。要在生产中运行应用程序，您需要使用 `dotnet publish` 命令创建部署包并将其部署。我们将在未来的章节中探讨部署过程。'
- en: 'You should be able to see the following output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够看到以下输出：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There is a link in the output, such as `http://localhost:5247`. The port number
    was randomly generated when we created the project. In a browser, navigate to
    `http://localhost:<your_port>/swagger`. You will see the web API documentation
    with **Swagger UI**, which offers a web-based UI to provide information and tools
    to interact with the API. You can use Swagger UI to test APIs:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中有一个链接，例如 `http://localhost:5247`。端口号是在我们创建项目时随机生成的。在浏览器中，导航到 `http://localhost:<your_port>/swagger`。您将看到带有
    **Swagger UI** 的 Web API 文档，它提供了一个基于 Web 的 UI，以提供信息和工具来与 API 交互。您可以使用 Swagger
    UI 测试 API：
- en: '![Figure 2.5 – Swagger UI](img/B18971_02_05.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – Swagger UI](img/B18971_02_05.jpg)'
- en: Figure 2.5 – Swagger UI
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – Swagger UI
- en: The API project is now running! You can see the web API template provides a
    `/WeatherForecast` endpoint. If you navigate to the `http://localhost:5247/WeatherForecast`
    link in the browser, you will see the API response.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: API 项目现在正在运行！您可以看到 Web API 模板提供了一个 `/WeatherForecast` 端点。如果您在浏览器中导航到 `http://localhost:5247/WeatherForecast`
    链接，您将看到 API 响应。
- en: 'To support HTTPS, you may need to trust the HTTPS development certificate by
    running the following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要支持 HTTPS，您可能需要运行以下命令以信任 HTTPS 开发证书：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You will see a dialog if the certificate was not previously trusted. Select
    **Yes** to trust the development certificate:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果证书之前未被信任，您将看到一个对话框。选择**是**以信任开发证书：
- en: '![Figure 2.6 – Installing the certificate for local development](img/B18971_02_06.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 为本地开发安装证书](img/B18971_02_06.jpg)'
- en: Figure 2.6 – Installing the certificate for local development
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 为本地开发安装证书
- en: Please note that the preceding command does not work on Linux. See your Linux
    distribution documentation for more details.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的命令在Linux上不起作用。有关更多详细信息，请参阅您的Linux发行版文档。
- en: Changing the port number
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改端口号
- en: 'The port number is defined in the `launchSettings.json` file in the `Properties`
    folder. You can change the port number by editing the file. Based on the convention,
    when the web API project was created, a port from `5000` to `5300` will be selected
    for HTTP, and from `7000` to `7300` for HTTPS. Here is an example of the `launchSettings.json`
    file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 端口号定义在`Properties`文件夹中的`launchSettings.json`文件中。您可以通过编辑文件来更改端口号。根据惯例，当创建Web
    API项目时，HTTP将选择从`5000`到`5300`的端口号，HTTPS则从`7000`到`7300`。以下是`launchSettings.json`文件的示例：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can update the port number here. Just keep in mind that the port number
    should be unique on your machine to avoid conflicts.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处更新端口号。但请记住，端口号应在您的机器上唯一，以避免冲突。
- en: Hot Reload
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 热重载
- en: When you use `dotnet run` to run the project, if you change the code, you need
    to stop the project and start it again. If your project is complicated, it takes
    time to stop and restart. To speed up development, you can use the `dotnet watch`
    command to enable the Hot Reload feature.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`dotnet run`运行项目时，如果更改代码，则需要停止项目并重新启动。如果您的项目很复杂，停止和重新启动需要花费时间。为了加快开发速度，您可以使用`dotnet
    watch`命令启用热重载功能。
- en: '.NET Hot Reload is a feature that allows you to apply code changes to a running
    app without restarting the app. It was first provided with .NET 6\. Instead of
    using `dotnet run`, you can use `dotnet watch` to activate Hot Reload in development.
    Once you update the code, the web browser will automatically refresh the page.
    However, Hot Reload does not support all code changes. In some cases, `dotnet
    watch` will ask you if you want to restart the application. There are some options:
    `Yes`, `No`, `Always`, and `Never`. Choose the appropriate option for the code
    change you want to apply, as shown next:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: .NET热重载是一种允许您在不重新启动应用程序的情况下将代码更改应用于正在运行的应用程序的功能。它最初在.NET 6中提供。您可以使用`dotnet watch`而不是`dotnet
    run`来在开发中激活热重载。一旦更新代码，网页将自动刷新。但是，热重载不支持所有代码更改。在某些情况下，`dotnet watch`将询问您是否想要重新启动应用程序。有一些选项：`是`、`否`、`总是`和`从不`。根据您想要应用的代码更改选择合适的选项，如下所示：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The API project is now running, and we can start to test the API.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: API项目现在正在运行，我们可以开始测试API。
- en: Testing the API endpoint
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试API端点
- en: The browser can send a `GET` request easily, but it is not as simple for `POST`
    endpoints. There are various ways to call the API for testing purposes, such as
    Swagger UI, Postman, and other tools. In this section, we will introduce some
    tools you can use in the development stage.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器可以轻松发送`GET`请求，但对于`POST`端点来说并不简单。有各种方法可以用于测试目的调用API，例如Swagger UI、Postman和其他工具。在本节中，我们将介绍一些您可以在开发阶段使用的工具。
- en: Swagger UI
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swagger UI
- en: We introduced how to use SwaggerHub to design APIs in [*Chapter 1*](B18971_01.xhtml#_idTextAnchor012).
    From version 5.0, ASP.NET Core enables OpenAPI support by default. It uses the
    `Swashbuckle.AspNetCore` NuGet package, which provides the Swagger UI to document
    and test the APIs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第一章*](B18971_01.xhtml#_idTextAnchor012)中介绍了如何使用SwaggerHub设计API。从5.0版本开始，ASP.NET
    Core默认启用OpenAPI支持。它使用`Swashbuckle.AspNetCore` NuGet包，该包提供了Swagger UI来文档化和测试API。
- en: 'We can use Swagger UI to test the API directly. Expand the first `/WeatherForecast`
    API in Swagger UI and click the **Try it out** button. You will see an **Execute**
    button. Click the button, and you will see the following response:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Swagger UI直接测试API。在Swagger UI中展开第一个`/WeatherForecast` API，然后点击**Try it
    out**按钮。您将看到一个**Execute**按钮。点击该按钮，您将看到以下响应：
- en: '![Figure 2.7 – Testing an endpoint in Swagger UI](img/B18971_02_07.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 在Swagger UI中测试端点](img/B18971_02_07.jpg)'
- en: Figure 2.7 – Testing an endpoint in Swagger UI
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 在Swagger UI中测试端点
- en: '*Figure 2**.7* demonstrates that the API is functioning correctly and is providing
    the expected response. To learn more about Swagger and OpenAPI, you can check
    the following links:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.7*演示了API正在正确运行并提供了预期的响应。要了解更多关于Swagger和OpenAPI的信息，您可以查看以下链接：'
- en: '**Swagger**: [https://swagger.io/](https://swagger.io/)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swagger**：[https://swagger.io/](https://swagger.io/)'
- en: '**OpenAPI**: [https://www.openapis.org/](https://www.openapis.org/)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenAPI**：[https://www.openapis.org/](https://www.openapis.org/)'
- en: '**SmartBear**: [https://www.smartbear.com/](https://www.smartbear.com/)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SmartBear**：[https://www.smartbear.com/](https://www.smartbear.com/)'
- en: Postman
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Postman
- en: '**Postman** is a powerful API platform for building and using APIs. It is widely
    used by many individual developers and organizations. You can download it here:
    [https://www.postman.com/downloads/](https://www.postman.com/downloads/).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**Postman** 是一个强大的API平台，用于构建和使用API。它被许多个人开发者和组织广泛使用。您可以从这里下载：[https://www.postman.com/downloads/](https://www.postman.com/downloads/).'
- en: 'Click the `http://localhost:5247/WeatherForecast` as the URL. Then, click the
    **Send** button. You will see the response next:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `http://localhost:5247/WeatherForecast` 作为URL。然后，点击 **发送** 按钮。您将看到以下响应：
- en: '![Figure 2.8 – Using Postman to call the API](img/B18971_02_08.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 使用Postman调用API](img/B18971_02_08.jpg)'
- en: Figure 2.8 – Using Postman to call the API
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 使用Postman调用API
- en: 'Postman provides a rich set of features to test APIs. To learn more about Postman,
    check the official documentation: [https://learning.postman.com/docs/getting-started/introduction/](https://learning.postman.com/docs/getting-started/introduction/).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Postman提供了一组丰富的功能来测试API。要了解更多关于Postman的信息，请查看官方文档：[https://learning.postman.com/docs/getting-started/introduction/](https://learning.postman.com/docs/getting-started/introduction/).
- en: HttpRepl
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HttpRepl
- en: '`GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `OPTIONS`, and `PATCH` HTTP verbs.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`、`POST`、`PUT`、`DELETE`、`HEAD`、`OPTIONS` 和 `PATCH` HTTP动词。'
- en: 'To install HttpRepl, you can use the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装HttpRepl，您可以使用以下命令：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After the installation, you can use the following command to connect to our
    API:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以使用以下命令连接到我们的API：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`<ROOT URL>` is the base URL of the web API, such as the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ROOT URL>` 是Web API的基本URL，例如以下所示：'
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After the connection is built, you can use the `ls` or `dir` command to list
    the endpoints, such as the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 连接建立后，您可以使用 `ls` 或 `dir` 命令列出端点，例如以下所示：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding command shows the `WeatherForecast` endpoint supports a `GET`
    operation. Then, we can use the `cd` command to navigate to the endpoint, such
    as the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令显示 `WeatherForecast` 端点支持 `GET` 操作。然后，我们可以使用 `cd` 命令导航到端点，例如以下所示：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we can use the `get` command to test the endpoint, such as the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `get` 命令测试端点，例如以下所示：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output looks like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '![Figure 2.9 – Output of HttpRepl](img/B18971_02_09.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – HttpRepl的输出](img/B18971_02_09.jpg)'
- en: Figure 2.9 – Output of HttpRepl
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – HttpRepl的输出
- en: To disconnect, press *Ctrl* + *C* to exit.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要断开连接，请按 *Ctrl* + *C* 退出。
- en: You can find more information about HttpRepl at [https://docs.microsoft.com/en-us/aspnet/core/web-api/http-repl/](https://docs.microsoft.com/en-us/aspnet/core/web-api/http-repl/).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://docs.microsoft.com/en-us/aspnet/core/web-api/http-repl/](https://docs.microsoft.com/en-us/aspnet/core/web-api/http-repl/)
    找到有关HttpRepl的更多信息。
- en: Thunder Client
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Thunder Client
- en: 'If you prefer to do everything in VS Code, **Thunder Client** is a great tool
    for testing APIs. Thunder Client is a lightweight REST API client extension for
    VS Code, allowing users to test their APIs without having to leave VS Code. This
    makes it an ideal choice for developers who want to streamline their workflow:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢在VS Code中完成所有操作，**Thunder Client** 是测试API的绝佳工具。Thunder Client是VS Code的一个轻量级REST
    API客户端扩展，允许用户在无需离开VS Code的情况下测试他们的API。这使得它成为希望简化工作流程的开发者的理想选择：
- en: '![Figure 2.10 – The Thunder Client extension for VS Code](img/B18971_02_10.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – VS Code的Thunder Client扩展](img/B18971_02_10.jpg)'
- en: Figure 2.10 – The Thunder Client extension for VS Code
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – VS Code的Thunder Client扩展
- en: 'After the installation, click the **Thunder Client** icon on the **Action**
    bar. From the sidebar, click the **New Request** button. The following UI will
    be shown:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，点击 **动作栏** 上的 **Thunder Client** 图标。从侧边栏中，点击 **新建请求** 按钮。以下UI将显示：
- en: '![Figure 2.11 – Testing the API with Thunder Client](img/B18971_02_11.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – 使用Thunder Client测试API](img/B18971_02_11.jpg)'
- en: Figure 2.11 – Testing the API with Thunder Client
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 使用Thunder Client测试API
- en: 'To learn more about Thunder Client, visit their GitHub page: [https://github.com/rangav/thunder-client-support](https://github.com/rangav/thunder-client-support).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Thunder Client的信息，请访问他们的GitHub页面：[https://github.com/rangav/thunder-client-support](https://github.com/rangav/thunder-client-support).
- en: Using .http files in VS 2022
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在VS 2022中使用.http文件
- en: 'If you use Visual Studio 2022, you can use the `.http` file to test the API.
    The `.http` file is a text file that contains definitions of HTTP requests. The
    latest ASP.NET Core 8 template project provides a default `.http` file. You can
    find it in the `MyFirstApi` folder. The content of the file is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Visual Studio 2022，您可以使用 `.http` 文件来测试API。`.http` 文件是一个包含HTTP请求定义的文本文件。最新的ASP.NET
    Core 8模板项目提供了一个默认的 `.http` 文件。您可以在 `MyFirstApi` 文件夹中找到它。文件的内容如下：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first line defines a variable named `MyFirstApi_HostAddress` with the value
    of the root URL of the API. The second line defines a `GET` request to the `/weatherforecast`
    endpoint. The third line defines an `Accept` header. In this case, it accepts
    the `application/json` content type. Open this file in Visual Studio 2022, and
    you will see the **Send Request** button on the left side of the request. Click
    the button, and you will see the response as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了一个名为`MyFirstApi_HostAddress`的变量，其值为 API 的根 URL。第二行定义了一个对`/weatherforecast`端点的`GET`请求。第三行定义了一个`Accept`头。在这种情况下，它接受`application/json`内容类型。在
    Visual Studio 2022 中打开此文件，你将在请求的左侧看到**发送请求**按钮。点击该按钮，你将看到以下响应：
- en: '![Figure 2.12 – Using the .http file to test the API in Visual Studio 2022](img/B18971_02_12.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – 使用 .http 文件在 Visual Studio 2022 中测试 API](img/B18971_02_12.jpg)'
- en: Figure 2.12 – Using the .http file to test the API in Visual Studio 2022
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – 使用 .http 文件在 Visual Studio 2022 中测试 API
- en: However, when this book was written, the `.http` files lacked some features,
    such as environment variables. Also, this feature is only available in Visual
    Studio 2022, so we will not use it in this book. But if you are interested in
    exploring this feature further, please refer to the Microsoft docs at [https://learn.microsoft.com/en-us/aspnet/core/test/http-files](https://learn.microsoft.com/en-us/aspnet/core/test/http-files)
    for more information.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当这本书编写时，`.http`文件缺少一些功能，例如环境变量。此外，此功能仅在 Visual Studio 2022 中可用，因此我们不会在本书中使用它。但如果你对进一步探索此功能感兴趣，请参阅
    Microsoft 文档[https://learn.microsoft.com/en-us/aspnet/core/test/http-files](https://learn.microsoft.com/en-us/aspnet/core/test/http-files)以获取更多信息。
- en: We have introduced some tools to test APIs. Let's now learn how to debug APIs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了一些用于测试 API 的工具。现在让我们学习如何调试 API。
- en: Debugging
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试
- en: VS Code has a built-in debugging feature that allows you to debug code. Unlike
    Visual Studio, it needs a `launch.json` configuration for debugging. When you
    open an ASP.NET Core project in VS Code, it will prompt you to add some assets.
    If you choose `launch.json` file in the `.``vscode` folder.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 具有内置的调试功能，允许你调试代码。与 Visual Studio 不同，它需要一个`launch.json`配置来进行调试。当你打开
    VS Code 中的 ASP.NET Core 项目时，它将提示你添加一些资产。如果你选择`.vscode`文件夹中的`launch.json`文件。
- en: 'If you missed it, you can add it manually from the Debug view:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你错过了它，你可以从调试视图中手动添加：
- en: '![Figure 2.13 – Creating a launch.json file from the Debug view](img/B18971_02_13.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – 从调试视图创建 launch.json 文件](img/B18971_02_13.jpg)'
- en: Figure 2.13 – Creating a launch.json file from the Debug view
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – 从调试视图创建 launch.json 文件
- en: 'If you cannot see the buttons in *Figure 2**.13*, you can open the Command
    Palette by pressing *Ctrl* + *Shift* + *P* (on Windows) or *Command* + *Shift*
    + *P* (on macOS), then type `.net` and choose `launch.json` file in the `.``vscode`
    folder:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到图 2.13 中的按钮，你可以通过按*Ctrl* + *Shift* + *P*（在 Windows 上）或*Command* + *Shift*
    + *P*（在 macOS 上）打开命令面板，然后输入`.net`，在`.vscode`文件夹中选择`launch.json`文件：
- en: '![Figure 2.14 – Generating a launch.json file from the Command Palette](img/B18971_02_14.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – 从命令面板生成 launch.json 文件](img/B18971_02_14.jpg)'
- en: Figure 2.14 – Generating a launch.json file from the Command Palette
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – 从命令面板生成 launch.json 文件
- en: 'The content of the default `launch.json` configuration is shown next:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下面显示了默认的`launch.json`配置内容：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This file specifies the configuration for debugging. Some important attributes
    are described next:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件指定了调试的配置。以下是一些重要属性的描述：
- en: The `program` attribute specifies the path to the executable file
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`program`属性指定可执行文件的路径'
- en: The `args` attribute specifies the arguments to pass to the executable file
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args`属性指定传递给可执行文件的参数'
- en: The `cwd` attribute specifies the working directory
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cwd`属性指定工作目录'
- en: The `env` attribute specifies the environment variables
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env`属性指定环境变量'
- en: We do not need to change anything in this file now.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们不需要在这个文件中做任何更改。
- en: 'Set up a breakpoint in the app. For example, we can set a breakpoint in the
    `Get()` method in the `WeatherForecastController.cs` file by clicking in the left
    margin of the code window. Once the breakpoint is set, you will see a red dot
    before the line number in the left margin:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中设置一个断点。例如，我们可以在`WeatherForecastController.cs`文件中的`Get()`方法上设置一个断点，通过点击代码窗口左侧的空白边缘来实现。一旦设置了断点，你将在左侧空白边缘的行号前看到一个红色圆点：
- en: '![Figure 2.15 – Setting up a breakpoint in VS Code](img/B18971_02_15.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – 在 VS Code 中设置断点](img/B18971_02_15.jpg)'
- en: Figure 2.15 – Setting up a breakpoint in VS Code
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – 在 VS Code 中设置断点
- en: 'To debug the app, open the **Debug** view by selecting the **Debugging** icon
    on the left-side menu. Make sure you choose the correct debugging configuration
    from the drop-down menu. For this case, please select **.NET Core Launch (web)**.
    Then, select the green arrow at the top of the pane:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试应用程序，通过在左侧菜单中选择**调试**图标打开**调试**视图。确保你从下拉菜单中选择正确的调试配置。对于这个案例，请选择**.NET Core
    启动（Web）**。然后，选择面板顶部的绿色箭头：
- en: '![Figure 2.16 – Debugging the API in VS Code](img/B18971_02_16.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16 – 在 VS Code 中调试 API](img/B18971_02_16.jpg)'
- en: Figure 2.16 – Debugging the API in VS Code
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – 在 VS Code 中调试 API
- en: 'Send a request from any of the tools in the previous section, and you will
    see the program execution stops when it reaches the breakpoint, as shown next:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一节中的任何工具发送请求，你将看到程序在到达断点时停止执行，如下所示：
- en: '![Figure 2.17 – Hitting the breakpoint in VS Code](img/B18971_02_17.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.17 – 在 VS Code 中命中断点](img/B18971_02_17.jpg)'
- en: Figure 2.17 – Hitting the breakpoint in VS Code
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – 在 VS Code 中命中断点
- en: The **Locals** section of the **VARIABLES** window will display the values of
    variables that are defined in the current context.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量**窗口的**局部**部分将显示当前上下文中定义的变量的值。'
- en: You can also type a variable in the **DEBUG CONSOLE** window to check the value
    directly. To execute the next step, you can use the control toolbar at the top
    of the VS Code window. You can run the code line by line to monitor its execution.
    It is helpful if we need to know how the program works.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在**调试控制台**窗口中输入一个变量来直接检查其值。要执行下一步，你可以使用 VS Code 窗口顶部的控制工具栏。你可以逐行运行代码以监控其执行。如果我们需要了解程序的工作原理，这会很有帮助。
- en: Now we have learned how to build, run, and test APIs, it is time to look at
    the code of APIs.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何构建、运行和测试 API，是时候看看 API 的代码了。
- en: Understanding the MVC pattern
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 MVC 模式
- en: 'ASP.NET Core MVC is a rich framework for building web applications with the
    **Model-View-Controller** (**MVC**) design pattern. The MVC pattern enables web
    applications to separate the presentation from the business logic. An ASP.NET
    Core web API project follows the basic MVC pattern, but it does not have views,
    so it only has a Model layer and a Controller layer. Let’s look at this in a bit
    more detail:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC 是一个丰富的框架，用于使用 **模型-视图-控制器**（**MVC**）设计模式构建 Web 应用程序。MVC 模式使
    Web 应用程序能够将表示层与业务逻辑分离。ASP.NET Core Web API 项目遵循基本的 MVC 模式，但没有视图，因此它只有模型层和控制器层。让我们更详细地看看：
- en: '**Models**: Models are classes that represent the data that is used in the
    application. Normally, the data is stored in a database.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：模型是表示应用程序中使用的数据的类。通常，数据存储在数据库中。'
- en: '`Controllers` folder. *Figure 2**.18* shows an example of the MVC pattern in
    an web API project. However, the view layer is not included in the web API project.
    The request from the client will be mapped to the controller, and the controller
    will execute the business logic and return the response to the client.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`控制器`文件夹。*图 2**.18* 展示了一个在 Web API 项目中 MVC 模式的示例。然而，视图层不包括在 Web API 项目中。客户端的请求将被映射到控制器，控制器将执行业务逻辑并将响应返回给客户端。'
- en: '![Figure 2.18 – The MVC pattern](img/B18971_02_18.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18 – MVC 模式](img/B18971_02_18.jpg)'
- en: Figure 2.18 – The MVC pattern
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 – MVC 模式
- en: Next, we will look at the code of the model and the controller in an ASP.NET
    Core web API project.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看 ASP.NET Core Web API 项目中模型和控制器代码。
- en: The model and the controller
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型和控制器
- en: In the ASP.NET Core template project, you can find a file named `WeatherForecast.cs`.
    This file is a model. It is a pure C# class that represents a data model.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 模板项目中，你可以找到一个名为 `WeatherForecast.cs` 的文件。这是一个模型。它是一个纯 C# 类，表示数据模型。
- en: The controller is the `WeatherForecastController.cs` file located in the `Controllers`
    folder. It contains the business logic.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器位于 `Controllers` 文件夹中的 `WeatherForecastController.cs` 文件。它包含业务逻辑。
- en: 'It looks like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像这样：
- en: '[PRE19]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The constructor of the controller class has a parameter named `ILogger<WeatherForecastController>
    logger`. This parameter is used to log messages. It is injected with DI by the
    ASP.NET Core framework. We will talk about DI in the next section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器类的构造函数有一个名为 `ILogger<WeatherForecastController> logger` 的参数。该参数用于记录消息。它由
    ASP.NET Core 框架通过依赖注入（DI）注入。我们将在下一节中讨论 DI。
- en: This class has an `[ApiController]` attribute that indicates that it is a web
    API controller. It also has a `[Route("[controller]")]` attribute that indicates
    the URL of the controller.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此类有一个 `[ApiController]` 属性，表示它是一个Web API控制器。它还有一个 `[Route("[controller]")]`
    属性，表示控制器的URL。
- en: The `Get()` method has a `[HttpGet(Name = "GetWeatherForecast")]` attribute
    that indicates the name of the endpoint, and the `Get()` method is a `GET` operation.
    This method returns a list of weather forecasts as the response.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get()` 方法有一个 `[HttpGet(Name = "GetWeatherForecast")]` 属性，它指示端点的名称，`Get()`
    方法是一个 `GET` 操作。此方法返回一个包含天气预报的列表作为响应。'
- en: Note that the `[Route("[controller]")]` attribute is marked on the controller
    class. It means the path of the controller is `/WeatherForecast`. Currently, there
    is no `[Route]` attribute on the `Get()` method. We will learn more about routing
    in future sections.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`[Route("[controller]")]` 属性标记在控制器类上。这意味着控制器的路径是 `/WeatherForecast`。目前，`Get()`
    方法上没有 `[Route]` 属性。我们将在未来的章节中了解更多关于路由的内容。
- en: We should now have a basic understanding of how ASP.NET Core web API works.
    The client sends the request to the web API, and the request will be mapped to
    the controller and the method. The controller will execute the business logic
    and return the response. We can use some methods to get, save, update, and delete
    data from the database in the controllers.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该对ASP.NET Core Web API的工作原理有一个基本的了解。客户端向Web API发送请求，请求将被映射到控制器和方法。控制器将执行业务逻辑并返回响应。我们可以在控制器中使用一些方法从数据库中获取、保存、更新和删除数据。
- en: Next, let us create a new API endpoint by adding a new model and controller.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过添加新的模型和控制器来创建一个新的API端点。
- en: Creating a new model and controller
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新的模型和控制器
- en: 'In [*Chapter 1*](B18971_01.xhtml#_idTextAnchor012), we showed an example REST
    API on [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts).
    It returns a list of posts, as shown next:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第1章*](B18971_01.xhtml#_idTextAnchor012)，我们展示了 [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)
    上的一个示例REST API。它返回一个帖子列表，如下所示：
- en: '[PRE20]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let us implement a similar API. First, we need to create a new model. Create
    a new folder named `Models` in the project. Then, create a new file named `Post.cs`
    in the `Models` folder:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个类似的API。首先，我们需要创建一个新的模型。在项目中创建一个名为 `Models` 的新文件夹。然后，在 `Models` 文件夹中创建一个名为
    `Post.cs` 的新文件：
- en: '[PRE21]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: File-scoped namespace declaration
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 文件作用域命名空间声明
- en: From C# 10, you can use a new form of namespace declaration, as shown in the
    previous code snippet, which is called a file-scoped namespace declaration. All
    the members in this file are in the same namespace. It saves space and reduces
    indentation.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 10 开始，你可以使用一种新的命名空间声明形式，如前一个代码片段所示，这被称为文件作用域命名空间声明。此文件中的所有成员都在同一个命名空间中。这节省了空间并减少了缩进。
- en: Nullable reference types
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 可空引用类型
- en: 'You may be wondering why we assign an empty string to the `Title` and `Body`
    properties. This is because the properties are of type `string`. If we do not
    initialize the property, the compiler will complain:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们将 `Title` 和 `Body` 属性赋值为空字符串。这是因为这些属性的类型是 `string`。如果我们不初始化属性，编译器将会报错：
- en: '`Non-nullable property ''Title'' must contain a non-null value when exiting
    constructor. Consider declaring the property` `as nullable.`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`不可为空的属性 ''Title'' 在构造函数退出时必须包含一个非空值。考虑将属性声明为可空的。`'
- en: By default, the ASP.NET Core web API project template enabled the `<Nullable>enable</Nullable>`
    in the `<``PropertyGroup>` section.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，ASP.NET Core Web API项目模板在 `<PropertyGroup>` 部分启用了 `<Nullable>enable</Nullable>`。
- en: Nullable reference types were introduced in C# 8.0\. They can minimize the likelihood
    of errors that cause the runtime to throw a `System.NullReferenceException` error.
    For example, if we forget to initialize the `Title` property, we may get a `System.NullReferenceException`
    error when we try to access a property of it, such as `Title.Length`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 可空引用类型是在 C# 8.0 中引入的。它们可以最小化导致运行时抛出 `System.NullReferenceException` 错误的错误可能性。例如，如果我们忘记初始化
    `Title` 属性，当我们尝试访问它的属性时，比如 `Title.Length`，可能会得到 `System.NullReferenceException`
    错误。
- en: With this feature enabled, any variable of a reference type is considered to
    be non-nullable. If you want to allow a variable to be nullable, you must append
    the type name with the `?` operator to declare the variable as a nullable reference
    type; for example, `public string Title? { get; set; }`, which explicitly marks
    the property as nullable.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此功能后，任何引用类型的变量都被视为不可为空。如果您想允许变量为可空，必须使用 `?` 运算符将类型名称附加到变量声明中，以将其声明为可空引用类型；例如，`public
    string Title? { get; set; }`，这明确地将属性标记为可空。
- en: To learn more about this feature, see [https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references](https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于此功能的信息，请参阅 [https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references](https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references)。
- en: 'Next, create a new file named `PostController.cs` in the `Controllers` folder.
    You can manually add it, or install the `dotnet-aspnet-codegenerator` tool to
    create it. To install the tool, run the following commands from the project folder:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `Controllers` 文件夹中创建一个名为 `PostController.cs` 的新文件。您可以手动添加它，或者安装 `dotnet-aspnet-codegenerator`
    工具来创建它。要安装该工具，请在项目文件夹中运行以下命令：
- en: '[PRE22]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding commands install a NuGet package required for scaffolding. The
    `dotnet-aspnet-codegenerator` tool is a scaffolding engine that is used to generate
    code.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令安装了用于脚手架的必需的 NuGet 包。`dotnet-aspnet-codegenerator` 工具是一个脚手架引擎，用于生成代码。
- en: 'Then, run the following command to generate a controller:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令来生成控制器：
- en: '[PRE23]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding command generates an empty controller. The `-name` option specifies
    the name of the controller. The `-api` option indicates that the controller is
    an API controller. The `-outDir` option specifies the output directory. Update
    the content of the controller as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令生成一个空控制器。`-name` 选项指定了控制器的名称。`-api` 选项表示控制器是一个 API 控制器。`-outDir` 选项指定了输出目录。按照以下内容更新控制器的内容：
- en: '[PRE24]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Target-typed new expressions
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 目标类型的新表达式
- en: 'When we create a new `List` instance of a specific type, we will normally use
    code like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个特定类型的 `List` 实例时，我们通常会使用如下代码：
- en: '`var list =` `new List<Post>`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`var list =` `new List<Post>`'
- en: '`{`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`{`'
- en: '`new Post() { Id = 1, UserId = 1, Title = "Post1", Body = "The first` `post."
    },`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`new Post() { Id = 1, UserId = 1, Title = "Post1", Body = "The first` `post."
    },`'
- en: '`};`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`};`'
- en: When the list is declared as `List<Post>`, the type is known, so it is not necessary
    to use `new Post()` here when adding new elements. The type specification can
    be omitted for constructors, such as `new()`. This feature was introduced in C#
    9.0.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当列表声明为 `List<Post>` 时，类型已知，因此在添加新元素时不需要使用 `new Post()`。对于构造函数，例如 `new()`，可以省略类型指定。这个特性是在
    C# 9.0 中引入的。
- en: The controller is named `PostsController`. The convention is the resource name
    with the `Controller` suffix. It is marked with the `ApiController` attribute,
    which indicates that the controller is a web API controller. It also has a `[Route("api/[controller]")]`
    attribute that indicates the URL of the controller. `[controller]` is like a placeholder,
    which will be replaced with the name of the controller in the routing. So, the
    route of this controller is `/api/posts`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的名称为 `PostsController`。约定是资源名称加上 `Controller` 后缀。它带有 `ApiController` 属性，表示该控制器是一个
    Web API 控制器。它还有一个 `[Route("api/[controller]")]` 属性，表示控制器的 URL。`[controller]` 作为一个占位符，将在路由中替换为控制器的名称。因此，此控制器的路由是
    `/api/posts`。
- en: In this controller, we have a method named `GetPosts()`. This method returns
    a list of posts as the response. The method is marked with the `[HttpGet]` attribute,
    which indicates that this method is a `GET` operation. It does not have any route
    template, because it will match `/api/posts`. For other methods, we can use the
    `[Route("[action]")]` attribute to specify the route template.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在此控制器中，我们有一个名为 `GetPosts()` 的方法。该方法返回一个帖子列表作为响应。该方法带有 `[HttpGet]` 属性，表示这是一个
    `GET` 操作。它没有任何路由模板，因为它将匹配 `/api/posts`。对于其他方法，我们可以使用 `[Route("[action]")]` 属性来指定路由模板。
- en: The return type of the `GetPosts()` method is `ActionResult<IEnumerable<Post>>`.
    ASP.NET Core can automatically convert the object to JSON and return it to the
    client in the response message. Also, it can return other HTTP status codes, such
    as `NotFound`, `BadRequest`, `InternalServerError`, and so on. We will see more
    examples later.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetPosts()` 方法的返回类型是 `ActionResult<IEnumerable<Post>>`。ASP.NET Core 可以自动将对象转换为
    JSON 并将其作为响应消息返回给客户端。它还可以返回其他 HTTP 状态码，例如 `NotFound`、`BadRequest`、`InternalServerError`
    等。我们将在稍后看到更多示例。'
- en: If you run `dotnet run` or `dotnet watch`, then navigate to Swagger UI, such
    as `https://localhost:7291/swagger/index.html`, you will see the new API listed.
    The API is accessible at `/api/posts`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行`dotnet run`或`dotnet watch`，然后导航到Swagger UI，例如`https://localhost:7291/swagger/index.html`，你将看到列出的新API。API可通过`/api/posts`访问。
- en: Currently, the `/api/posts` endpoint returns a hardcoded list of posts. Let
    us update the controller to return a list of posts from a service.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`/api/posts`端点返回一个硬编码的帖子列表。让我们更新控制器以从服务返回帖子列表。
- en: Creating a service
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建服务
- en: 'Create a `Services` folder in the project. Then, create a new file named `PostService.cs`
    in the `Services` folder, as shown next:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中创建一个`Services`文件夹。然后，在`Services`文件夹中创建一个名为`PostService.cs`的新文件，如下所示：
- en: '[PRE25]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `PostsService` class is a simple demo service that manages the list of posts.
    It has methods to create, update, and delete posts. To simplify the implementation,
    it uses a static field to store the list of posts. This is just for demonstration
    purposes; please do not use this in production.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostsService`类是一个简单的演示服务，用于管理帖子列表。它有创建、更新和删除帖子的方法。为了简化实现，它使用静态字段来存储帖子列表。这只是为了演示目的；请勿在生产环境中使用。'
- en: Next, we will follow the API design to implement CRUD operations. You can review
    the *REST-based API design* section of the previous chapter.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将遵循API设计来实现CRUD操作。你可以回顾上一章的*基于REST的API设计*部分。
- en: Implementing a GET operation
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现获取操作
- en: 'The design for the `viewPost()` operation is as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewPost()`操作的实现设计如下：'
- en: '| **Operation name** | **URL** | **HTTP method** | **Input** | **Response**
    | **Description** |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| **操作名称** | **URL** | **HTTP方法** | **输入** | **响应** | **描述** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| `viewPost()` | `/``posts/{postId}` | `GET` | PostId | Post, 200 | View a
    post detail |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `viewPost()` | `/posts/{postId}` | `GET` | PostId | 帖子，200 | 查看帖子详情 |'
- en: Table 2.1 – The design for the `viewPost()` operation
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 – `viewPost()`操作的实现设计
- en: 'Update the `PostController` class as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式更新`PostController`类：
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the constructor method of the controller, we initialize the `_postsService`
    field. Note that we use the `new()` constructor to create an instance of the service.
    That means the controller is coupled with the `PostsService` class. We will see
    how to decouple the controller and the service in the next chapter.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器的构造方法中，我们初始化了`_postsService`字段。请注意，我们使用`new()`构造函数来创建服务的一个实例。这意味着控制器与`PostsService`类耦合在一起。我们将在下一章中看到如何解耦控制器和服务。
- en: Then, create a `GetPost()` method that returns a post with the specified ID.
    It has a `[HttpGet("{id}")]` attribute to indicate the URL of the operation. The
    URL will be mapped to `/api/posts/{id}`. `id` is a placeholder, which will be
    replaced with the ID of the post. Then, `id` will be passed to the `GetPost()`
    method as a parameter.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`GetPost()`的方法，该方法返回具有指定ID的帖子。它有一个`[HttpGet("{id}")]`属性来指示操作的URL。URL将被映射到`/api/posts/{id}`。`id`是一个占位符，它将被帖子的ID替换。然后，`id`将被作为参数传递给`GetPost()`方法。
- en: If the post is not found, the method will return a `NotFound` response. ASP.NET
    Core provides a set of built-in response messages, such as `NotFound`, `BadRequest`,
    `InternalServerError`, and so on.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到帖子，该方法将返回一个`NotFound`响应。ASP.NET Core提供了一套内置的响应消息，例如`NotFound`、`BadRequest`、`InternalServerError`等。
- en: If you call the API now, it will return `NotFound` because we have not created
    a post.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在调用API，它将返回`NotFound`，因为我们还没有创建帖子。
- en: Implementing a CREATE operation
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现创建操作
- en: 'The design for the `createPost()` operation is as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`createPost()`操作的实现设计如下：'
- en: '| **Operation name** | **URL** | **HTTP method** | **Input** | **Response**
    | **Description** |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| **操作名称** | **URL** | **HTTP方法** | **输入** | **响应** | **描述** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| `createPost()` | `/``posts` | `POST` | Post | Post, 201 | Create a new post
    |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `createPost()` | `/posts` | `POST` | 帖子 | 帖子，201 | 创建一个新的帖子 |'
- en: Table 2.2 – The design for the `createPost()` operation
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.2 – `createPost()`操作的实现设计
- en: 'Create a new method named `CreatePost()` in the controller. As the controller
    has been mapped to `api/posts`, we do not need to specify the route of this method.
    The content of the method is as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器中创建一个名为`CreatePost()`的新方法。由于控制器已映射到`api/posts`，我们不需要指定此方法的路由。该方法的内容如下：
- en: '[PRE27]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When we call this endpoint, the `post` object will be serialized in the JSON
    format that is attached to the `POST` request body. In this method, we can get
    the post from the request and then call the `CreatePost()` method in the service
    to create a new post. Then, we will return the built-in `CreatedAtAction`, which
    returns a response message with the specified action name, route values, and post.
    For this case, it will call the `GetPost()` action to return the newly created
    post.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用这个端点时，`post` 对象将以 JSON 格式序列化，并将其附加到 `POST` 请求体中。在这个方法中，我们可以从请求中获取帖子，然后调用服务中的
    `CreatePost()` 方法来创建一个新的帖子。然后，我们将返回内置的 `CreatedAtAction`，它返回一个包含指定操作名称、路由值和帖子的响应消息。对于这种情况，它将调用
    `GetPost()` 操作来返回新创建的帖子。
- en: Now, we can test the API. For example, we can send a `POST` request in Thunder
    Client.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试 API。例如，我们可以在 Thunder Client 中发送一个 `POST` 请求。
- en: 'Change the method to `POST`. Use the following JSON data as the body:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法改为 `POST`。使用以下 JSON 数据作为正文：
- en: '[PRE28]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Click the `201 Created`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 `201 Created`：
- en: '![Figure 2.19 – Sending a POST request](img/B18971_02_19.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.19 – 发送 POST 请求](img/B18971_02_19.jpg)'
- en: Figure 2.19 – Sending a POST request
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19 – 发送 POST 请求
- en: 'Then, send a `GET` request to the `api/posts/1` endpoint. We can get a response
    like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，向 `api/posts/1` 端点发送一个 `GET` 请求。我们可以得到如下响应：
- en: '![Figure 2.20 – Sending a GET request](img/B18971_02_20.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.20 – 发送 GET 请求](img/B18971_02_20.jpg)'
- en: Figure 2.20 – Sending a GET request
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 – 发送 GET 请求
- en: Please note that the post we created is stored in the memory of the service.
    Because we have not provided a database to store the data, if we restart the application,
    the post will be lost.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们创建的帖子存储在服务的内存中。因为我们没有提供数据库来存储数据，如果我们重新启动应用程序，帖子将会丢失。
- en: Next, let us see how to implement an update operation.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何实现更新操作。
- en: Implementing an UPDATE operation
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 UPDATE 操作
- en: 'The design for the `updatePost()` operation is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`updatePost()` 操作的设计如下：'
- en: '| **Operation name** | **URL** | **HTTP method** | **Input** | **Response**
    | **Description** |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **操作名称** | **URL** | **HTTP 方法** | **输入** | **响应** | **描述** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| `updatePost()` | `/``posts/{postId}` | `PUT` | Post | Post, 200 | Update
    a new post |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `updatePost()` | `/posts/{postId}` | `PUT` | Post | Post, 200 | 更新一个新的帖子
    |'
- en: Table 2.3 – The design for the `updatePost()` operation
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.3 – `updatePost()` 操作的设计
- en: 'Create a new `UpdatePost()` method in the controller, as shown next:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器中创建一个新的 `UpdatePost()` 方法，如下所示：
- en: '[PRE29]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This method has a `[HttpPut("{id}")]` attribute to indicate that it is a `PUT`
    operation. Similarly, `id` is a placeholder, which will be replaced with the ID
    of the post. In the `PUT` request, we should attach the serialized content of
    the post to the request body.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法有一个 `[HttpPut("{id}")]` 属性，表示这是一个 `PUT` 操作。同样，`id` 是一个占位符，它将被帖子的 ID 替换。在
    `PUT` 请求中，我们应该将帖子的序列化内容附加到请求体中。
- en: 'This time, let us test the API with HttpRepl. Run the following command to
    connect to the server:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，让我们使用 HttpRepl 测试 API。运行以下命令来连接到服务器：
- en: '[PRE30]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You will see this output:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE31]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we can update the `GetPosts()` method as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以更新 `GetPosts()` 方法如下：
- en: '[PRE32]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have implemented `GET`, `POST`, and `PUT` operations. Next, you can try to
    implement the `DeletePost()` method using the `DELETE` operation by yourself.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了 `GET`、`POST` 和 `PUT` 操作。接下来，你可以尝试自己使用 `DELETE` 操作实现 `DeletePost()` 方法。
- en: Dependency injection
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'In the preceding example of the controller, there is a `_postsService` field
    that is initialized in the constructor method of the controller by using the `new()`
    constructor:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的控制器示例中，有一个在控制器构造方法中使用 `new()` 构造函数初始化的 `_postsService` 字段：
- en: '[PRE33]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That says the `PostsController` class depends on the `PostsService` class, and
    the `PostsService` class is a dependency of the `PostsController` class. If we
    want to replace `PostsService` with a different implementation to save the data,
    we have to update the code of `PostsController`. If the `PostsService` class has
    its own dependencies, they must also be initialized by the `PostsController` class.
    When the project grows larger, the dependencies will become more complex. Also,
    this kind of implementation is not easy to test and maintain.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `PostsController` 类依赖于 `PostsService` 类，而 `PostsService` 类是 `PostsController`
    类的依赖。如果我们想用不同的实现来保存数据替换 `PostsService`，我们必须更新 `PostsController` 的代码。如果 `PostsService`
    类有自己的依赖项，它们也必须由 `PostsController` 类初始化。当项目变得更大时，依赖项将变得更加复杂。此外，这种实现不易于测试和维护。
- en: '**Dependency injection** (**DI**) is one of the most well-known design patterns
    in the software development world. It helps decouple classes that depend on each
    other. You may find the following terms being used interchangeably: **Dependency
    Inversion Principle** (**DIP**), **Inversion of Control** (**IoC**), and DI. These
    terms are commonly confused even though they are related. You can find multiple
    articles and blog posts that explain them. Some say they are the same thing, but
    some say not. What are they?'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**（DI）是软件开发世界中最为知名的设计模式之一。它有助于解耦相互依赖的类。你可能发现以下术语被交替使用：**依赖倒置原则**（DIP）、**控制反转**（IoC）和DI。尽管它们之间有关联，但这些术语通常会被混淆。你可以找到许多文章和博客文章来解释它们。有些人说它们是同一件事，但有些人说不是。它们究竟是什么？'
- en: Understanding DI
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解DI
- en: 'The Dependency Inversion Principle is one of the *SOLID* principles in **object-oriented**
    (**OO**) design. It was defined by Robert C. Martin in his book *Agile Software
    Development: Principles, Patterns, and Practices*, *Pearson*, in 2002\. The principle
    states, “*high-level modules should not depend on low-level modules; both should
    depend on abstractions. Abstractions should not depend on details. Details should
    depend* *upon abstractions*.”'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖倒置原则是面向对象（OO）设计中的*SOLID*原则之一。它在Robert C. Martin的2002年出版的《敏捷软件开发：原则、模式和最佳实践》*Pearson*一书中被定义。该原则指出，“*高层模块不应依赖于低层模块；两者都应依赖于抽象。抽象不应依赖于细节。细节应依赖于抽象*。”
- en: In the preceding controller, we said `PostsController` depends on `PostsService`.
    The controller is the high-level module, and the service is the low-level module.
    When the service is changed, the controller must be changed as well. Keep in mind
    that the term *inversion* does not mean that the low-level module will depend
    on the high level. Instead, both of them should depend on abstractions that expose
    the behavior needed by high-level modules. If we invert this dependency relationship
    by creating an interface for the service, both the controller and the service
    will depend on the interface. The implementation of the service can change as
    long as it respects the interface.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的控制器中，我们提到`PostsController`依赖于`PostsService`。控制器是高层模块，而服务是低层模块。当服务发生变化时，控制器也必须随之改变。请注意，术语*反转*并不意味着低层模块将依赖于高层。相反，两者都应依赖于暴露给高层模块所需行为的抽象。如果我们通过为服务创建一个接口来反转这种依赖关系，那么控制器和服务都将依赖于该接口。只要服务实现尊重接口，其实现可以改变。
- en: '**IoC** is a programming principle that inverts the flow of control in an application.
    In traditional programming, custom code is responsible for instantiating objects
    and controlling the execution of the main function. IoC inverts the flow of control
    as compared to traditional control flow. With IoC, the framework does the instantiation,
    calling custom or task-specific code.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**IoC**（控制反转）是一种编程原则，它反转了应用程序中的控制流。在传统的编程中，自定义代码负责实例化对象和控制主函数的执行。与传统的控制流相比，IoC反转了控制流。使用IoC时，框架负责实例化，调用自定义或任务特定的代码。'
- en: 'It can be used to differentiate a framework from a class library. Normally,
    the framework calls the application code, and the application code calls the library.
    This kind of IoC is sometimes referred to as the Hollywood principle: “*Don’t
    call us, we’ll* *call you*.”'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以用来区分框架和类库。通常，框架调用应用程序代码，而应用程序代码调用库。这种类型的IoC有时被称为好莱坞原则：“*别给我们打电话，我们会* *给你打电话*。”
- en: IoC is related to DIP, but it is not the same. DIP concerns decoupling dependencies
    between high-level modules and low-level modules through shared abstractions (interfaces).
    IoC is used to increase the modularity of the program and make it extensible.
    There are several technologies to implement IoC, such as **Service Locator**,
    DI, the template method design pattern, the strategy design pattern, and so on.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: IoC与DIP相关，但它不是同一件事。DIP关注通过共享抽象（接口）解耦高层模块和低层模块之间的依赖关系。IoC用于增加程序的模块化并使其可扩展。有几种技术可以实现IoC，例如**服务定位器**、DI、模板方法设计模式、策略设计模式等等。
- en: DI is a form of IoC. This term was coined by Martin Fowler in 2004\. It separates
    the concerns of constructing objects and using them. When an object or a function
    (the client) needs a dependency, it does not know how to construct it. Instead,
    the client only needs to declare the interfaces of the dependency, and the dependency
    is injected into the client by external code (an injector). It makes it easier
    to change the implementation of the dependency. It is often similar to the strategy
    design pattern. The difference is that the strategy pattern can use different
    strategies to construct the dependency, while DI typically only uses a single
    instance of the dependency.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入（DI）是一种控制反转（IoC）的形式。这个术语由马丁·福勒（Martin Fowler）在2004年提出。它将构建对象和使用对象的关注点分离。当一个对象或函数（客户端）需要依赖项时，它不知道如何构建它。相反，客户端只需要声明依赖项的接口，然后由外部代码（注入器）将依赖项注入到客户端。这使得更改依赖项的实现变得更加容易。它通常类似于策略设计模式。不同之处在于，策略模式可以使用不同的策略来构建依赖项，而DI通常只使用依赖项的单个实例。
- en: 'There are three main types of DI:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: DI主要有三种类型：
- en: '**Constructor injection**: The dependencies are provided as parameters of the
    client’s constructor'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数注入**：依赖项作为客户端构造函数的参数提供'
- en: '**Setter injection**: The client exposes a setter method to accept the dependency'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置器注入**：客户端公开一个设置器方法以接受依赖项'
- en: '**Interface injection**: The dependency’s interface provides an injector method
    that will inject the dependency into any client passed to it'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口注入**：依赖项的接口提供了一个注入方法，该方法将依赖项注入到传递给它的任何客户端'
- en: As you can see, these three terms are related, but there are some differences.
    Simply put, DI is a technique for achieving IoC between classes and their dependencies.
    ASP.NET Core supports DI as a first-class citizen.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这三个术语是相关的，但也有一些区别。简单来说，DI是一种在类及其依赖项之间实现IoC的技术。ASP.NET Core将DI作为一等公民支持。
- en: DI in ASP.NET Core
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASP.NET Core中的DI
- en: 'ASP.NET Core uses constructor injection to request dependencies. To use it,
    we need to do the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core使用构造函数注入来请求依赖项。要使用它，我们需要做以下几步：
- en: Define interfaces and their implementations.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义接口及其实现。
- en: Register the interfaces and the implementations to the service container.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将接口及其实现注册到服务容器中。
- en: Add services as the constructor parameters to inject the dependencies.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将服务作为构造函数参数添加以注入依赖项。
- en: You can download the example project named `DependencyInjectionDemo` from the
    folder `samples/chapter2/ DependencyInjectionDemo/DependencyInjectionDemo` in
    the chapter's GitHub repository.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从章节的GitHub仓库中`samples/chapter2/ DependencyInjectionDemo/DependencyInjectionDemo`文件夹下载名为`DependencyInjectionDemo`的示例项目。
- en: 'Follow the steps below to use DI in ASP.NET Core:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在ASP.NET Core中使用DI：
- en: 'First, we will create an interface and its implementation. Copy the `Post.cs`
    file and the `PostService.cs` file from the previous `MyFirstApi` project to the
    `DependencyInjectionDemo` project. Create a new interface named `IPostService`
    in the `Service` folder, as shown next:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个接口及其实现。将`Post.cs`文件和`PostService.cs`文件从上一个`MyFirstApi`项目复制到`DependencyInjectionDemo`项目中。在`Service`文件夹中创建一个名为`IPostService`的新接口，如下所示：
- en: '[PRE34]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You may also need to update the namespace of the `Post` class and the `PostService`
    class.
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可能还需要更新`Post`类和`PostService`类的命名空间。
- en: 'Next, we can register the `IPostService` interface and the `PostService` implementation
    to the service container. Open the `Program.cs` file, and you will find that an
    instance of `WebApplicationBuilder` named builder is created by calling the `WebApplication.CreateBuilder()`
    method. The `CreateBuilder()` method is the entry point of the application. We
    can configure the application by using the builder instance, and then call the
    `builder.Build()` method to build the `WebApplication`. Add the following code:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以将`IPostService`接口和`PostService`实现注册到服务容器中。打开`Program.cs`文件，你会找到一个名为`builder`的`WebApplicationBuilder`实例，它是通过调用`WebApplication.CreateBuilder()`方法创建的。`CreateBuilder()`方法是应用程序的入口点。我们可以使用builder实例来配置应用程序，然后调用`builder.Build()`方法来构建`WebApplication`。添加以下代码：
- en: '[PRE35]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding code utilizes the `AddScoped()` method, which indicates that the
    service is created once per client request and disposed of upon completion of
    the request.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码使用了`AddScoped()`方法，这表示服务会在每个客户端请求时创建一次，并在请求完成后销毁。
- en: 'Copy the `PostsController.cs` file from the previous `MyFirstApi` project to
    the `DependencyInjectionDemo` project. Update the namespace and the `using` statements.
    Then, update the constructor method of the controller as follows:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PostsController.cs`文件从先前的`MyFirstApi`项目复制到`DependencyInjectionDemo`项目。更新命名空间和`using`语句。然后，更新控制器的构造方法如下：
- en: '[PRE36]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding code uses the `IPostService` interface as the constructor parameter.
    The service container will inject the correct implementation into the controller.
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码使用`IPostService`接口作为构造函数参数。服务容器将正确的实现注入到控制器中。
- en: 'DI has four roles: services, clients, interfaces, and injectors. In this example,
    `IPostService` is the interface, `PostService` is the service, `PostsController`
    is the client, and `builder.Services` is the injector, which is a collection of
    services for the application to compose. It is sometimes referred to as a DI container.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: DI有四个角色：服务、客户端、接口和注入器。在这个例子中，`IPostService`是接口，`PostService`是服务，`PostsController`是客户端，而`builder.Services`是注入器，它是一个用于应用程序组合的服务集合。有时它被称为DI容器。
- en: The `PostsController` class requests the instance of `IPostService` from its
    constructor. The controller, which is the client, does not know where the service
    is, nor how it is constructed. The controller only knows the interface. The service
    has been registered in the service container, which can inject the correct implementation
    into the controller. We do not need to use the `new` keyword to create an instance
    of the service. That says the client and the service are decoupled.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostsController`类从其构造函数请求`IPostService`的实例。控制器（客户端）不知道服务在哪里，也不知道它是如何构建的。控制器只知道接口。服务已在服务容器中注册，可以将其正确的实现注入到控制器中。我们不需要使用`new`关键字来创建服务的实例。这意味着客户端和服务是解耦的。'
- en: 'This DI feature is provided in a NuGet package called `Microsoft.Extensions.DependencyInjection`.
    When an ASP.NET Core project is created, this package is added automatically.
    If you create a console project, you may need to install it manually by using
    the following command:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这个依赖注入（DI）功能是由一个名为`Microsoft.Extensions.DependencyInjection`的NuGet包提供的。当创建ASP.NET
    Core项目时，此包会自动添加。如果你创建的是控制台项目，你可能需要手动使用以下命令安装它：
- en: '[PRE37]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If we want to replace the `IPostService` with another implementation, we can
    do so by registering the new implementation to the service container. The code
    of the controller does not need to be changed. That is one of the benefits of
    DI.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想用另一个实现替换`IPostService`，我们可以通过将新的实现注册到服务容器中来实现。控制器的代码不需要更改。这就是依赖注入（DI）的一个好处。
- en: Next, let us discuss the lifetime of services.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论服务的作用域。
- en: DI lifetimes
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DI生命周期
- en: 'In the previous example, the service is registered using the `AddScoped()`
    method. In ASP.NET Core, there are three lifetimes when the service is registered:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，服务是通过`AddScoped()`方法注册的。在ASP.NET Core中，当服务注册时，有三个生命周期：
- en: '**Transient**: A transient service is created each time it is requested and
    disposed of at the end of the request.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Transient**: 每次请求时都会创建一个短暂服务，并在请求结束时销毁。'
- en: '**Scoped**: In web applications, a scope means a request (connection). A scoped
    service is created once per client request and disposed of at the end of the request.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scoped**: 在Web应用程序中，作用域意味着一个请求（连接）。作用域服务在每次客户端请求时创建，并在请求结束时销毁。'
- en: '**Singleton**: A singleton service is created the first time it is requested
    or when providing the implementation instance to the service container. All subsequent
    requests will use the same instance.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Singleton**: 单例服务在第一次请求或提供实现实例到服务容器时创建。所有后续请求都将使用相同的实例。'
- en: 'To demonstrate the difference between these lifetimes, we will use a simple
    demo service:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这些生命周期之间的差异，我们将使用一个简单的演示服务：
- en: 'Create a new interface named `IDemoService` and its implementation named `DemoService`
    in the `Services` folder, as shown next:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Services`文件夹中创建一个新的接口`IDemoService`及其实现`DemoService`，如下所示：
- en: 'IDemoService.cs:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 'IDemoService.cs:'
- en: '[PRE38]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'DemoService.cs:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 'DemoService.cs:'
- en: '[PRE39]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The implementation will generate an ID and a time when it was created, and output
    it when the `SayHello()` method is called.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 实现将在调用`SayHello()`方法时生成一个ID和一个创建时间，并将其输出。
- en: 'Then, we can register the interface and the implementation to the service container.
    Open the `Program.cs` file and add the code as follows:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以将接口和实现注册到服务容器中。打开`Program.cs`文件，并添加以下代码：
- en: '[PRE40]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a controller named `DemoController.cs`. Now, we can add the service
    as constructor parameters to inject the dependency:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `DemoController.cs` 的控制器。现在，我们可以将服务作为构造函数参数添加以注入依赖项：
- en: '[PRE41]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For this example, if you test the `/demo` endpoint, you will see the GUID value
    and the creation time in the output change every time:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，如果你测试 `/demo` 端点，你将看到输出中的 GUID 值和创建时间每次都会变化：
- en: '[PRE42]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can change the lifetime to `AddSingleton()`, as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将生命周期更改为 `AddSingleton()`，如下所示：
- en: '[PRE43]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The GUID values and the creation time values will be the same for all requests:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有请求，GUID 值和创建时间值都将相同：
- en: '[PRE44]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As the `DemoController` class only requests the `IDemoService` interface once
    for each request, we cannot differentiate the behavior between `scoped` and `transient`
    services. Let us look at a more complex example.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `DemoController` 类在每个请求中只对 `IDemoService` 接口请求一次，因此我们无法区分 `scoped` 和 `transient`
    服务之间的行为。让我们来看一个更复杂的例子。
- en: 'You can find the example code in the `DependencyInjectionDemo` project. There
    are three interfaces along with their implementations:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在 `DependencyInjectionDemo` 项目中找到示例代码。有三个接口及其实现：
- en: '[PRE45]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `Program.cs` file, we can register them to the service container as
    follows:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，我们可以将它们注册到服务容器中，如下所示：
- en: '[PRE46]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, create a controller named `LifetimeController.cs`. The code is shown
    next:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个名为 `LifetimeController.cs` 的控制器。代码如下：
- en: '[PRE47]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In this example, `ScopedService` has two dependencies: `ITransientService`
    and `ISingletonService`. So, when `ScopedService` is created, it will ask for
    the instances of these dependencies from the service container. On the other hand,
    the controller also has dependencies: `IScopedService`, `ITransientService`, and
    `ISingletonService`. When the controller is created, it will ask for these three
    dependencies. That means `ITransientService` and `ISingletonService` will be needed
    twice for each request. But let us check the output of the following requests:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`ScopedService` 有两个依赖项：`ITransientService` 和 `ISingletonService`。因此，当
    `ScopedService` 被创建时，它将从服务容器中请求这些依赖项的实例。另一方面，控制器也有依赖项：`IScopedService`、`ITransientService`
    和 `ISingletonService`。当控制器被创建时，它将请求这三个依赖项。这意味着 `ITransientService` 和 `ISingletonService`
    在每个请求中都需要两次。但让我们检查以下请求的输出：
- en: '[PRE48]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We can see that in each request, `ScopedService` was created once, while `ITransientService`
    was created twice. In both requests, `SingletonService` was created only once.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在每个请求中，`ScopedService` 只被创建了一次，而 `ITransientService` 被创建了两次。在这两个请求中，`SingletonService`
    只被创建了一次。
- en: Group registration
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组注册
- en: 'As the project grows, we may have more and more services. If we register all
    services in `Program.cs`, this file will be very large. For this case, we can
    use group registration to register multiple services at once. For example, we
    can create a service group named `LifetimeServicesCollectionExtensions.cs`:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目的增长，我们可能会有越来越多的服务。如果我们把所有服务都注册在 `Program.cs` 中，这个文件将会变得非常大。在这种情况下，我们可以使用组注册一次注册多个服务。例如，我们可以创建一个名为
    `LifetimeServicesCollectionExtensions.cs` 的服务组：
- en: '[PRE49]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This is an extension method for the `IServiceCollection` interface. It is used
    to register all services at once in the `Program.cs` file:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个针对 `IServiceCollection` 接口的扩展方法。它用于在 `Program.cs` 文件中一次性注册所有服务：
- en: '[PRE50]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this way, the `Program.cs` file will be smaller and easier to read.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，`Program.cs` 文件将会更小，也更易于阅读。
- en: Action injection
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动作注入
- en: 'Sometimes, one controller may need many services but may not need all of them
    for all actions. If we inject all the dependencies from the constructor, the constructor
    method will be large. For this case, we can use action injection to inject dependencies
    only when needed. See the following example:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一个控制器可能需要很多服务，但可能不是所有的动作都需要所有这些服务。如果我们从构造函数中注入所有依赖项，构造函数方法将会很大。在这种情况下，我们可以使用动作注入，只在需要时注入依赖项。以下是一个示例：
- en: '[PRE51]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `[FromServices]` attribute enables the service container to inject dependencies
    when needed without using constructor injection. However, if you find that a service
    needs a lot of dependencies, it may indicate that the class has too many responsibilities.
    Based on the **Single Responsibility Principle** (**SRP**), consider refactoring
    the class to split the responsibilities into smaller classes.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`[FromServices]` 属性允许服务容器在需要时注入依赖项，而不使用构造函数注入。然而，如果你发现某个服务需要很多依赖项，这可能表明该类承担了过多的责任。根据**单一职责原则**（**SRP**），考虑重构该类，将责任拆分到更小的类中。'
- en: Keep in mind that this kind of action injection only works for actions in the
    controller. It does not support normal classes. Additionally, since ASP.NET Core
    7.0, the `[FromServices]` attribute can be omitted as the framework will automatically
    attempt to resolve any complex type parameters registered in the DI container.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这种动作注入只适用于控制器中的动作。它不支持普通类。此外，自 ASP.NET Core 7.0 以来，可以省略 `[FromServices]`
    属性，因为框架将自动尝试解决 DI 容器中注册的任何复杂类型参数。
- en: Keyed services
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 键控服务
- en: ASP.NET Core 8.0 introduces a new feature known as keyed services, or named
    services. This feature allows developers to register services with a key, allowing
    them to access the service with that key. This makes it easier to manage multiple
    services that implement the same interface within an application, as the key can
    be used to identify and access the service.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 8.0 引入了一个名为键控服务或命名服务的新特性。这个特性允许开发者使用键来注册服务，从而可以使用该键访问服务。这使得在应用程序中管理实现相同接口的多个服务变得更加容易，因为键可以用来识别和访问服务。
- en: 'For example, we have a service interface named `IDataService`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有一个名为 `IDataService` 的服务接口：
- en: '[PRE52]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This `IDataService` interface has two implementations: `SqlDatabaseService`
    and `CosmosDatabaseService`:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `IDataService` 接口有两个实现：`SqlDatabaseService` 和 `CosmosDatabaseService`：
- en: '[PRE53]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can register them to the service container using different keys:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用不同的键将它们注册到服务容器中：
- en: '[PRE54]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, we can inject the service by using the `FromKeyedServices` attribute:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `FromKeyedServices` 属性来注入服务：
- en: '[PRE55]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `FromKeyedServices` attribute is used to inject the service by using the
    specified key. Test the API with HttpRepl, and you will see the output as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `FromKeyedServices` 属性可以通过指定的键注入服务。使用 HttpRepl 测试 API，你会看到以下输出：
- en: '[PRE56]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The keyed services can be used to register singleton or transient services
    as well. Just use the `AddKeyedSingleton()` or `AddKeyedTransient()` method respectively;
    for example:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 键控服务也可以用来注册单例或瞬态服务。只需分别使用 `AddKeyedSingleton()` 或 `AddKeyedTransient()` 方法；例如：
- en: '[PRE57]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It is important to note that if an empty string is passed as the key, a default
    implementation for the service must be registered with a key of an empty string,
    otherwise the service container will throw an exception.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，如果传递了一个空字符串作为键，则必须使用空字符串的键注册服务的默认实现，否则服务容器将抛出异常。
- en: Microsoft releases new versions of .NET SDKs frequently. If you encounter a
    different version number, that is acceptable.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 微软经常发布新的 .NET SDK 版本。如果你遇到不同的版本号，这是可以接受的。
- en: The preceding command will list all the available SDKs on your machine. For
    example, it may show the following output if have multiple .NET SDKs installed.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将列出你机器上所有可用的 SDK。例如，如果你安装了多个 .NET SDK，它可能会显示以下输出。
- en: Important note
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Every Microsoft product has a lifecycle. .NET and .NET Core provides **Long-term
    support** (**LTS**) releases that get 3 years of patches and free support. When
    this book was written, .NET 7 is still supported, until May 2024\. Based on Microsoft’s
    policy, even numbered releases are LTS releases. So .NET 8 is the latest LTS release.
    The code samples in this book are written with .NET 8.0.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微软产品都有其生命周期。.NET 和 .NET Core 提供了 **长期支持**（**LTS**）版本，这些版本将获得 3 年的补丁和免费支持。当这本书编写时，.NET
    7 仍然在支持中，直到 2024 年 5 月。根据微软的政策，偶数版本是 LTS 版本。因此，.NET 8 是最新的 LTS 版本。本书中的代码示例是用 .NET
    8.0 编写的。
- en: 'When you use VS Code to open the project, the C# Dev Kit extension can create
    a solution file for you. This feature makes VS Code more friendly to C# developers.
    You can see the following structure in the Explorer view:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 VS Code 打开项目时，C# Dev Kit 扩展可以为你创建一个解决方案文件。这个特性使得 VS Code 对 C# 开发者更加友好。你可以在资源管理器视图中看到以下结构：
- en: It uses the `Swashbuckle.AspNetCore` NuGet package, which provides the Swagger
    UI to document and test the APIs.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 `Swashbuckle.AspNetCore` NuGet 包，该包提供了 Swagger UI 来文档化和测试 API。
- en: 'Follow the steps below to use DI in ASP.NET Core:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在 ASP.NET Core 中使用依赖注入：
- en: We can see that in each request, `ScopedService` was created once, while `ITransientService`
    was created twice. In both requests, `SingletonService` was created only once.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在每次请求中，`ScopedService` 只被创建了一次，而 `ITransientService` 被创建了两次。在这两次请求中，`SingletonService`
    只被创建了一次。
- en: Using primary constructors to inject dependencies
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用主构造函数注入依赖项
- en: 'Beginning with .NET 8 and C# 12, we can use the primary constructor to inject
    dependencies. A primary constructor allows us to declare the constructor parameters
    directly in the class declaration, instead of using a separate constructor method.
    For example, we can update the `PostsController` class as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 从 .NET 8 和 C# 12 开始，我们可以使用主要构造函数来注入依赖。主要构造函数允许我们直接在类声明中声明构造函数参数，而不是使用单独的构造函数方法。例如，我们可以更新
    `PostsController` 类如下：
- en: '[PRE58]csharppublic class PostsController(IPostService postService) : ControllerBase'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE58]csharppublic class PostsController(IPostService postService) : ControllerBase'
- en: '{'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // No need to define a private field to store the service
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: // 无需定义私有字段来存储服务
- en: // No need to define a constructor method
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: // 无需定义构造函数方法
- en: '}'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE59]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You can find a sample named `PrimaryConstructorController.cs` in the `Controller`
    folder of the `DependencyInjectionDemo` project.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `DependencyInjectionDemo` 项目的 `Controller` 文件夹中找到一个名为 `PrimaryConstructorController.cs`
    的示例。
- en: When using the primary constructor in a class, note that the parameters passed
    to the class declaration cannot be used as properties or members. For example,
    if a class declares a parameter named `postService` in the class declaration,
    it cannot be accessed as a class member using `this.postService` or from external
    code. To learn more about the primary constructor, please refer to the documentation
    at https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/instance-constructors#primary-constructors.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 当在类中使用主要构造函数时，请注意传递给类声明的参数不能用作属性或成员。例如，如果一个类在类声明中声明了一个名为 `postService` 的参数，则不能使用
    `this.postService` 或外部代码来访问它。有关主要构造函数的更多信息，请参阅 https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/instance-constructors#primary-constructors
    的文档。
- en: Primary constructors can save us from writing fields and constructor methods.
    So, we’ll use them in the following examples.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 主要构造函数可以让我们避免编写字段和构造函数方法。因此，我们将在下面的示例中使用它们。
- en: Do not use `new` to create service B, otherwise, service A will be tightly coupled
    with service B.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用 `new` 来创建服务 B，否则服务 A 将与服务 B 紧密耦合。
- en: Resolving a service when the app starts
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用启动时解析服务
- en: 'If we need a service in the `Program.cs` file, we cannot use constructor injection.
    For this situation, we can resolve a scoped service for a limited duration at
    app startup, as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `Program.cs` 文件中需要一个服务，我们不能使用构造函数注入。对于这种情况，我们可以在应用启动时为有限时间解析作用域服务，如下所示：
- en: '[PRE60]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The preceding code creates a scope and resolves the `IDemoService` service from
    the service container. Then, it can use the service to do something. After the
    scope is disposed of, the service will be disposed of as well.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个作用域，并从服务容器中解析了 `IDemoService` 服务。然后，它可以使用该服务进行某些操作。作用域释放后，服务也将被释放。
- en: DI tips
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DI 小贴士
- en: 'ASP.NET Core uses DI heavily. The following are some tips to help you use DI:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 严重依赖 DI。以下是一些使用 DI 的技巧：
- en: When designing your services, make the services as stateless as possible. Do
    not use static classes and members unless you have to do so. If you need to use
    a global state, consider using a singleton service instead.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设计服务时，尽量使服务无状态。除非必须，不要使用静态类和成员。如果你需要使用全局状态，考虑使用单例服务。
- en: Carefully design dependency relationships between services. Do not create a
    cyclic dependency.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细设计服务之间的依赖关系。不要创建循环依赖。
- en: Do not use `new` to create a service instance in another service. For example,
    if service A depends on service B, the instance of service B should be injected
    into service A with DI. Do not use `new` to create service B, otherwise, service
    A will be tightly coupled with service B.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在另一个服务中使用 `new` 来创建服务实例。例如，如果服务 A 依赖于服务 B，则应使用 DI 将服务 B 的实例注入到服务 A 中。不要使用
    `new` 来创建服务 B，否则服务 A 将与服务 B 紧密耦合。
- en: Use a DI container to manage the lifetime of services. If a service implements
    the `IDisposable` interface, the DI container will dispose of the service when
    the scope is disposed of. Do not manually dispose of it.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DI 容器来管理服务的生命周期。如果一个服务实现了 `IDisposable` 接口，当作用域被释放时，DI 容器将释放该服务。不要手动释放它。
- en: When registering a service, do not use `new` to create an instance of the service.
    For example, `services.AddSingleton(new ExampleService());` registers a service
    instance that is not managed by the service container. So, the DI framework will
    not be able to dispose of the service automatically.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在注册服务时，不要使用 `new` 来创建服务的实例。例如，`services.AddSingleton(new ExampleService());`
    会注册一个不由服务容器管理的服务实例。因此，依赖注入框架将无法自动释放该服务。
- en: Avoid using the service locator pattern. If DI can be used, do not use the `GetService()`
    method to obtain a service instance.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用服务定位器模式。如果可以使用依赖注入，不要使用 `GetService()` 方法来获取服务实例。
- en: You can learn more about the DI guidelines at [https://docs.microsoft.com/zh-cn/dotnet/core/extensions/dependency-injection-guidelines](https://docs.microsoft.com/zh-cn/dotnet/core/extensions/dependency-injection-guidelines).
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://docs.microsoft.com/zh-cn/dotnet/core/extensions/dependency-injection-guidelines](https://docs.microsoft.com/zh-cn/dotnet/core/extensions/dependency-injection-guidelines)
    上了解更多关于依赖注入指南的信息。
- en: Why there is no configuration method for the logger in the template project?
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么模板项目中没有为日志提供配置方法？
- en: ASP.NET Core provides a built-in DI implementation for the logger. When the
    project was created, logging was registered by the ASP.NET Core framework. Therefore,
    there is no configuration method for the logger in the template project. Actually,
    there are more than 250 services that are automatically registered by the ASP.NET
    Core framework.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 为日志提供内置的依赖注入实现。当项目创建时，日志是由 ASP.NET Core 框架注册的。因此，模板项目中没有为日志提供配置方法。实际上，ASP.NET
    Core 框架自动注册了250多个服务。
- en: Can I use third-party DI containers?
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用第三方依赖注入容器吗？
- en: It is highly recommended that you use the built-in DI implementation in ASP.NET
    Core. But if you need any specific features that it does not support, such as
    property injection, `Func<T>` support for lazy initialization, and so on, you
    can use third-party DI containers, such as *Autofac* ([https://autofac.org/](https://autofac.org/)).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您使用 ASP.NET Core 中的内置依赖注入实现。但如果您需要它不支持的一些特定功能，例如属性注入、`Func<T>` 支持懒加载等，您可以使用第三方依赖注入容器，例如
    *Autofac* ([https://autofac.org/](https://autofac.org/))。
- en: Introduction to minimal APIs
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小 API 简介
- en: In the previous section, *Creating a simple web API project*, we created a simple
    web API project using the `dotnet new webapi -n MyFirstApi -controllers` command.
    The `-controllers` option (or `--use-controllers`) indicates that the project
    will use controller-based routing. Alternatively, the `-minimal` or `--use-minimal-apis`
    option can be used to create a project that uses minimal APIs. In this section,
    we will introduce minimal APIs.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节“创建简单的 Web API 项目”中，我们使用 `dotnet new webapi -n MyFirstApi -controllers`
    命令创建了一个简单的 Web API 项目。`-controllers` 选项（或 `--use-controllers`）表示项目将使用基于控制器的路由。或者，可以使用
    `-minimal` 或 `--use-minimal-apis` 选项来创建一个使用最小 API 的项目。在本节中，我们将介绍最小 API。
- en: Minimal APIs is a new feature introduced in ASP.NET Core 6.0\. It is a new way
    to create APIs without using controllers. Minimal APIs are designed to be simple
    and lightweight with minimal dependencies. They are a good choice for small projects
    or prototypes, and also for projects that do not need the full features of controllers.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 最小 API 是 ASP.NET Core 6.0 中引入的新功能。它是一种不使用控制器创建 API 的新方法。最小 API 设计得简单轻量，依赖最少。它们是小型项目或原型以及不需要控制器完整功能的项目的良好选择。
- en: 'To create a minimal API project, we can use the following command:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建最小 API 项目，我们可以使用以下命令：
- en: '`dotnet new webapi -n` `MinimalApiDemo -minimal`'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotnet new webapi -n MinimalApiDemo -minimal`'
- en: 'There is no `Controllers` folder in the project. Instead, you can find the
    following code in the `Program.cs` file:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 项目中没有 `Controllers` 文件夹。相反，你可以在 `Program.cs` 文件中找到以下代码：
- en: '[PRE61]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The preceding code uses the `MapGet()` method to map the `GET` request to the
    `/weatherforecast` endpoint. The `MapGet()` method is an extension method of the
    `IEndpointRouteBuilder` interface. This interface is used to configure the endpoints
    in the application. Its extension method, `MapGet()`, returns an `IEndpointConventionBuilder`
    interface that allows us to use fluent APIs to configure the endpoint by using
    other extension methods, such as `WithName()` and `WithOpenApi()`. The `WithName()`
    method is used to set the name of the endpoint. The `WithOpenApi()` method is
    used to generate an OpenAPI document for the endpoint.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用 `MapGet()` 方法将 `GET` 请求映射到 `/weatherforecast` 端点。`MapGet()` 方法是 `IEndpointRouteBuilder`
    接口的一个扩展方法。该接口用于配置应用程序中的端点。其扩展方法 `MapGet()` 返回一个 `IEndpointConventionBuilder` 接口，允许我们使用流畅的API通过其他扩展方法（如
    `WithName()` 和 `WithOpenApi()`）来配置端点。`WithName()` 方法用于设置端点的名称。`WithOpenApi()`
    方法用于为端点生成 OpenAPI 文档。
- en: Creating a simple endpoint
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的端点
- en: 'Let us create a new `/posts` endpoint that supports CRUD operations. First,
    add the following code to the end of the `Program.cs` file to define a `Post`
    class:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的 `/posts` 端点，该端点支持 CRUD 操作。首先，将以下代码添加到 `Program.cs` 文件末尾，以定义一个 `Post`
    类：
- en: '[PRE62]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Add the following code to the `Program.cs` file:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `Program.cs` 文件中：
- en: '[PRE63]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The preceding code defines five endpoints:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码定义了五个端点：
- en: '`GET /posts`: Get all posts'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /posts`: 获取所有帖子'
- en: '`POST /posts`: Create a new post'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /posts`: 创建一个新的帖子'
- en: '`GET /posts/{id}`: Get a post by ID'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /posts/{id}`: 通过ID获取帖子'
- en: '`PUT /posts/{id}`: Update a post by ID'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT /posts/{id}`: 通过ID更新帖子'
- en: '`DELETE /posts/{id}`: Delete a post by ID'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE /posts/{id}`: 通过ID删除帖子'
- en: We use the `WithTags` extension method to group these endpoints into a tag named
    `Posts`. In this example, a list is used to store the posts. In a real-world application,
    we should use a database to store the data.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `WithTags` 扩展方法将这些端点分组到一个名为 `Posts` 的标签中。在这个例子中，使用列表来存储帖子。在实际应用中，我们应该使用数据库来存储数据。
- en: Using DI in minimal APIs
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在最小API中使用依赖注入（DI）
- en: 'Minimal APIs support DI as well. You can find the `IPostService` interface
    and its `PostService` implementation in the `Services` folder. Here is an example
    of using DI in minimal APIs:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 最小API也支持依赖注入（DI）。您可以在 `Services` 文件夹中找到 `IPostService` 接口及其 `PostService` 实现。以下是在最小API中使用依赖注入的示例：
- en: '[PRE64]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the preceding code, the `IPostService` interface is used as a parameter of
    the action method. The DI container will inject the correct implementation into
    the action method. You can run the project and test the endpoints. It should have
    the same behavior as the controller-based project.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`IPostService` 接口被用作动作方法的参数。DI 容器将正确的实现注入到动作方法中。您可以运行项目并测试端点。它应该与基于控制器的项目具有相同的行为。
- en: What is the difference between minimal APIs and controller-based APIs?
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小API与基于控制器的API之间的区别是什么？
- en: Minimal APIs are simpler than controller-based APIs, allowing us to map endpoints
    to methods directly. This makes minimal APIs a good choice for quickly creating
    simple APIs or demo projects. However, minimal APIs do not support the full range
    of features that controllers provide, such as model binding, model validation,
    and so on. These features may be added in the future. Therefore, we will mainly
    use controller-based APIs and not discuss minimal APIs in detail in this book.
    If you want to learn more about minimal APIs, please refer to the official documentation
    at [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis).
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 最小API比基于控制器的API更简单，允许我们直接将端点映射到方法。这使得最小API成为快速创建简单API或演示项目的良好选择。然而，最小API不支持控制器提供的全部功能，例如模型绑定、模型验证等。这些功能可能会在未来添加。因此，我们将主要使用基于控制器的API，并在本书中不详细讨论最小API。如果您想了解更多关于最小API的信息，请参阅官方文档[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis)。
- en: Summary
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a simple web API project and introduced how to run
    the project locally and call the APIs with different clients. We implemented basic
    CRUD operations using an in-memory list. Also, we explained how to use DI in ASP.NET
    Core. We explored the lifetime of services and learned some tips. In addition,
    we introduced minimal APIs. In the next chapter, we will delve further into the
    built-in components of ASP.NET Core.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个简单的Web API项目，并介绍了如何在本地运行项目以及如何使用不同的客户端调用API。我们使用内存列表实现了基本的CRUD操作。此外，我们还解释了如何在ASP.NET
    Core中使用依赖注入（DI）。我们探讨了服务生命周期并学习了一些技巧。另外，我们介绍了最小API。在下一章中，我们将进一步探讨ASP.NET Core的内置组件。
