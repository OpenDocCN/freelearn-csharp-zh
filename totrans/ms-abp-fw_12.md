# *第 9 章*：理解领域驱动设计

ABP 框架项目的主要目标是介绍一种应用程序开发架构方法，并提供必要的基础设施和工具，以最佳实践实施该架构。

**领域驱动设计**（**DDD**）是 ABP 框架架构提供的核心部分之一。ABP 的启动模板基于 DDD 原则和模式分层。ABP 的实体、仓储、领域服务、领域事件、规范以及许多其他概念都直接映射到 DDD 的战术模式。

由于 DDD 是 ABP 应用程序开发架构的核心部分，因此本书有一个专门的章节，*第 3 部分*，*实施领域驱动设计*，其中包含三个章节，专门介绍 DDD。在本书中，我将侧重于实际实施细节，而不是 DDD 的理论、战略方法和概念。示例将主要基于在 [*第 4 章*](B17287_04_Epub_AM.xhtml#_idTextAnchor130)，*理解参考解决方案* 中介绍的 *EventHub* 项目。此外，我还会展示一些 *EventHub* 项目没有适当示例的场景的不同示例。

接下来的两章将向您展示实施 DDD 的明确规则和具体代码示例，以帮助您学习如何使用 ABP 框架实施 DDD。

然而，在本章的第一部分，我们将一般性地探讨 DDD，并按以下顺序探讨后续章节中的核心技术概念：

+   介绍 DDD

+   基于 DDD 构建.NET解决方案

+   处理多个应用程序

+   理解执行流程

+   DDD 的常见原则

# 技术要求

您可以从 GitHub 克隆或下载 *EventHub* 项目的源代码：[https://github.com/volosoft/eventhub](https://github.com/volosoft/eventhub)。

如果您想在本地开发环境中运行解决方案，您需要一个 IDE/编辑器（如 Visual Studio）来构建和运行 ASP.NET Core 解决方案。此外，如果您想创建 ABP 解决方案，您需要安装 ABP CLI，如 [*第 2 章*](B17287_02_Epub_AM.xhtml#_idTextAnchor026)，*开始使用 ABP 框架* 中所述。

# 介绍 DDD

在我们介绍实现细节之前，让我们定义 DDD 的核心概念和构建块。让我们从 DDD 的定义开始。

## 什么是领域驱动设计？

DDD 是一种针对复杂需求的软件开发方法，其中将软件的实现与不断发展的模型相连接。

DDD适用于复杂领域和大型应用程序。在简单、短期存在的**创建、读取、更新、删除**（**CRUD**）应用程序的情况下，通常不需要遵循所有DDD原则。幸运的是，ABP不会强迫你在每个应用程序中实施所有DDD原则；你可以只使用最适合你应用程序的原则。然而，在复杂应用程序中遵循DDD原则和模式有助于你构建一个灵活、模块化和易于维护的代码库。

DDD关注核心领域逻辑，而不是基础设施细节，这些细节通常与业务代码隔离。

实施领域驱动设计（DDD）与**面向对象编程**（**OOP**）原则密切相关。本书不涵盖这些基本原理，但仍然，对OOP以及**单一职责、开闭原则、里氏替换原则、接口隔离原则和依赖倒置原则**（**SOLID**）的良好理解将有助于你在塑造和组织代码库以及实际实施DDD时。

现在我们已经提供了这个简要的定义，我们可以探索DDD的基本层。

## DDD层

分层是组织软件解决方案以减少复杂性和提高可重用性的常见原则。DDD提供了一个四层模型来帮助你组织业务逻辑，并将基础设施从业务逻辑中抽象出来，如下面的图所示：

![图9.1 – DDD的层

](img/Figure_9.01_B17287.jpg)

图9.1 – DDD的层

上述图显示了层及其关系：

+   **领域层**包含基本业务对象，并实现了解决方案的核心、用例无关的、可重用的领域逻辑。这一层不依赖于任何其他层，但所有其他层直接或间接地依赖于它。

+   **应用层**实现了应用程序的用例。用例通常是用户通过UI执行的操作。**应用层**使用**领域层**的对象来执行这些用例。

+   **表示层**包含应用程序的UI组件，例如Web应用程序的视图、JavaScript和CSS文件。它不直接使用**领域层**或数据库对象。相反，它使用**应用层**。通常，对于在UI上执行的所有用例/操作，**应用层**都有一个相应的功能/方法。

+   **基础设施层**依赖于所有其他层，并实现了这些层定义的抽象。它有助于优雅地将业务逻辑与第三方库和系统（如数据库或缓存提供者）分离。

该模型中的每一层都有其职责，并包含各种构建块，这些构建块将在下一节中介绍。

## 构建块

从技术角度来看，领域驱动设计（DDD）主要与通过关注你正在工作的领域来设计你的业务代码相关。业务逻辑被分为两层——领域层和应用层。其他层（表示层和基础设施层）被视为实现细节，应根据你使用的特定技术的最佳实践来实现，例如Entity Framework。

领域层通过以下基本构建块来实现核心领域逻辑：

+   `事件`和`组织`实体。

+   **值对象**: 值对象是另一种业务对象。值对象通过其状态（属性）来识别，并且没有标识符。这意味着如果两个值对象的属性都相同，则认为它们是相同的。值对象通常比实体简单，并且通常作为不可变对象实现。例如，我们可以创建地址、货币或日期等值对象。

+   EventHub解决方案中的`事件`实体是事件聚合的根实体，它包含跟踪和会话作为子集合。

+   **仓储**: 仓储是一个类似于集合的接口，由领域层和应用层用来访问持久化系统。它隐藏了数据库提供者的复杂性，使其从业务代码中分离出来。

+   **领域服务**: 领域服务是一个无状态的服务（类），它实现了核心业务规则。它对于实现依赖于多个聚合类型（因此这些聚合中的任何一个都不应负责实现该逻辑）或外部服务的领域逻辑非常有用。领域服务获取/返回领域对象，通常由应用服务或其他领域服务消费。

+   **规范**: 规范是一个命名、可重用、可测试和可组合的过滤器，它应用于业务对象，根据特定的业务规则来选择它们。

+   **领域事件**: 领域事件是一种以松耦合方式通知其他服务在发生特定领域事件时的方式。它在实现跨多个聚合的副作用时非常有用。

应用层通过以下构建块来实现应用的使用案例：

+   **应用服务**: 应用服务是一个无状态的服务（类），它实现了应用的使用案例。它通常获取和返回数据传输对象，并且其方法被表示层使用。它使用和编排领域层对象以执行特定的使用案例。一个使用案例通常被实现为一个事务性（原子）过程。

+   **数据传输对象（DTO**）: DTO用于在表示层和应用层之间传输数据（状态）。它不包含任何业务逻辑。

+   **工作单元**（**UOW**）：UOW 是一个事务边界。UOW 中的所有状态变化（通常是数据库操作）都必须实现为原子操作，在成功时一起提交，在失败时一起回滚。

看到整体图景并熟悉 DDD 的核心构建块非常重要，这就是为什么我在这里简要介绍了它们。在接下来的几章中，我们将实际使用它们并了解它们的实现细节。然而，在本章中，我将继续从整体图景出发，解释 ABP 如何将层和构建块放入 .NET 解决方案中。

# 根据 DDD 结构化 .NET 解决方案

到目前为止，我们已经介绍了基于 DDD 的软件解决方案的层和核心构建块。在本节中，我们将学习如何根据 DDD 对 .NET 解决方案进行分层。我将从最简单的解决方案结构开始。然后，我将解释 ABP 的启动解决方案模板是如何演变成其当前结构的。最后，您将了解为什么 ABP 启动解决方案内部有那么多项目，以及每个项目的目的。

## 创建一个简单的基于 DDD 的 .NET 解决方案

让我们从零开始，通过在我们的 .NET 解决方案中创建四个项目来保持事情简单，如下截图所示：

![图 9.2 – Visual Studio 中基于 DDD 的简单 .NET 解决方案

](img/Figure_9.02_B17287.jpg)

图 9.2 – Visual Studio 中基于 DDD 的简单 .NET 解决方案

假设我们正在构建一个 **客户关系管理**（**CRM**）解决方案，**Acme** 是我们的公司名称，而 **Crm** 是本例中的产品名称。我为每个层创建了一个单独的 C# 项目。.NET 项目完美地适应层，因为它们可以将代码库物理地分离到不同的包中。项目中的一个类/类型可以直接使用同一项目中的其他类/类型。然而，一个类/类型不能使用另一个项目中的类/类型，除非您通过引用其他项目显式定义依赖关系。

*图 9.2* 展示了 Visual Studio 中解决方案中的项目以及这些项目之间的依赖关系：

![图 9.3 – 简单基于 DDD 的 .NET 解决方案的项目依赖关系

](img/Figure_9.03_B17287.jpg)

图 9.3 – 简单基于 DDD 的 .NET 解决方案的项目依赖关系

在前面的图中，实线表示开发时依赖（项目引用），而虚线表示运行时依赖。我将在本节后面解释这种差异。

要理解这些依赖关系，我们需要知道这些项目可能包含哪些类型的组件。我们在 *构建块* 部分中看到了哪些组件位于领域和应用层。在这里，我将提到一些包含在该 CRM 解决方案项目中的示例组件：

+   `Product`类（聚合根实体）和`IProductRepository`接口（存储库抽象）。`Product`类代表一个产品，并具有一些属性，如`Id`、`Name`和`Price`。`IProductRepository`有一些方法用于对产品执行数据库操作，例如`Insert`、`Delete`和`GetList`。

+   `CrmDbContext`类（EF Core数据上下文），它将`Product`实体映射到数据库表。它还包含`EfProductRepository`类，该类实现了`IproductRepository`接口。

+   `ProductAppService`（应用程序服务），以及一些用于创建、更新、删除和获取产品列表的方法。此服务内部使用`IProductRepository`接口和`Product`实体（领域对象）。

+   `Products.cshtml`页面（以及一个相关的JavaScript文件），它用于在UI上渲染产品数据，并允许您管理（创建、编辑和删除）产品。它内部使用`ProductAppService`来执行实际操作。

现在我们已经了解了这些项目的目的和内容，让我们看看为什么这些项目有这些依赖项：

+   **Acme.Crm.Domain**没有依赖项。一般来说，领域层具有最小依赖性，并且从基础设施细节中抽象出来。

+   将`Product`类映射到数据库表，并实现了`IProductRepository`接口。

+   使用`IProductRepository`存储库和`Product`实体来执行用例。

+   最后，`ProductAppService`).

**Acme.Crm.Web**项目还有一个依赖项：它引用了**Acme.Crm.Infrastructure**项目。它不直接使用该项目中的任何类，因此不需要直接依赖。然而，**Acme.Crm.Web**也是运行应用程序的项目，应用程序在运行时需要基础设施层来使用数据库。在*将托管与UI分离*这一节中，我们将讨论一种替代结构，以便您可以消除这个依赖项。

这是一种基于DDD的解决方案的最小化分层。在下一节中，我们将使用该解决方案并解释ABP的启动解决方案是如何演变的。

## ABP启动解决方案的演变

ABP的启动解决方案比*图9.2*中显示的解决方案更复杂。以下截图显示了使用ABP启动模板创建的相同解决方案，但这次使用的是`abp new Acme.Crm` CLI命令：

![图9.4 – 使用ABP启动模板创建的CRM解决方案

](img/Figure_9.04_B17287.jpg)

图9.4 – 使用ABP启动模板创建的CRM解决方案

让我们解释一下这个解决方案是如何从上一节中解释的四个项目解决方案中演变而来的。

### 介绍EntityFrameworkCore项目

最小化 DDD 解决方案包含 **Acme.Crm.Infrastructure** 项目，该项目假定实现所有基础设施抽象和集成。另一方面，ABP 解决方案有一个专门的 Entity Framework Core 集成项目（**Acme.Crm.EntityFrameworkCore**），因为我们认为为这样的主要依赖创建单独的项目是好的，尤其是对于数据库集成。

基础设施层可以拆分为多个项目。ABP 启动模板没有这样的主要依赖。唯一的 Infrastructure 项目是 **Acme.Crm.EntityFrameworkCore** 项目。如果您的解决方案增长，您可以创建额外的基础设施项目。

通过这个变更，最初的基于 DDD 的最小化解决方案将如下所示：

![图 9.5 – 介绍 Entity Framework Core 集成项目]

![图片](img/Figure_9.05_B17287.jpg)

图 9.5 – 介绍 Entity Framework Core 集成项目

这个变更微不足道。它可以被认为是将 **Acme.Crm.Infrastructure** 项目的名称更改为 **Acme.Crm.EntityFrameworkCore**。下一节将介绍一个新的项目到解决方案中。

### 介绍应用程序合约

目前，**Acme.Crm.Application** 项目包含应用程序服务类。因此，**Acme.Crm.Web** 项目引用 **Acme.Crm.Application** 项目以使用这些服务。

这种设计有一个问题：**Acme.Crm.Web** 项目间接引用了 **Acme.Crm.Domain** 项目（通过 **Acme.Crm.Application** 项目）。这暴露了领域层中的业务对象（如实体、领域服务和存储库）给表示层，打破了抽象和真正的分层。

ABP 启动模板将应用层拆分为两个项目：

+   `IProductAppService` 和相关的 DTO（例如 `ProductCreationDto`）。

+   `ProductAppService`。

为应用程序服务引入（接口）合约有两个重要的优点：

+   UI 层（此处为 **Acme.Crm.Web** 项目）可以依赖服务合约，而不依赖于实现，因此不依赖于领域层。

+   您可以将 **Acme.Crm.Application.Contracts** 项目与客户端应用程序共享，以便依赖相同的接口并重用相同的 DTO 类，而无需共享您的业务层。

EventHub 引用解决方案（在第 [*第 4 章*](B17287_04_Epub_AM.xhtml#_idTextAnchor130)，*理解参考解决方案*）利用了这种设计，并在 UI 和 HTTP API 应用程序之间重用了 **Application.Contracts** 项目。这样，它可以轻松地设置一个分层架构，其中应用层和表示层托管在不同的应用程序中，但共享服务合约。

通过分离应用程序合约项目，当前解决方案的结构将类似于以下图示：

![图 9.6 – 介绍应用程序合约项目]

![图 9.06_B17287.jpg](img/Figure_9.06_B17287.jpg)

图 9.6 – 介绍应用合同项目

使用这种新的设计，项目依赖关系图将如下所示：

![图 9.7 – 应用合同项目的项目依赖关系

![图 9.07_B17287.jpg](img/Figure_9.07_B17287.jpg)

图 9.7 – 应用合同项目的项目依赖关系

**Acme.Crm.Web** 项目现在只依赖于 **Acme.Crm.Application.Contracts** 项目，并且应该始终使用应用服务接口来执行用户交互。

**Acme.Crm.Web** 项目仍然依赖于 **Acme.Crm.Application** 和 **Acme.Crm.EntityFrameworkCore** 项目，因为我们需要在运行时使用它们。我用虚线画出了这些依赖关系，以表明这些项目依赖关系在理想设计中不应存在，但现在却是必要的。我将在 *将托管与 UI 分离* 部分解释我们如何消除这些依赖关系。

将应用合同与实现分离带来了一些小问题，我们将在下一节中解决。

### 介绍域共享项目

一旦我们将合同分离出来，我们就不能再在合同项目中使用域层的对象，因为它们没有对域层的引用，如前节所示。乍一看这似乎不是一个问题。我们无论如何都不应该使用这些实体和其他业务对象在应用服务合同中 – 我们应该使用 DTO。然而，我们仍然可能想要重用域项目中定义的一些类型或值。

例如，我们可能想在 DTO 类中重用 `ProductType` 枚举，或者依赖于产品名称最大长度的相同常量值。我们不希望重复这样的代码部分，但我们也不能从 **Acme.Crm.Application.Contracts** 项目中添加对 **Acme.Crm.Domain** 项目的引用。解决方案是引入一个新的项目来声明这样的类型和值。

我们将把这个新项目命名为 **Acme.Crm.Domain.Shared**，因为这个项目将是域层的一部分，并与解决方案的其他部分共享。实际上，这个项目不会包含很多类型，但我们仍然不想重复这些类型。

随着 **Acme.Crm.Domain.Shared** 项目的引入，新的解决方案结构如下所示：

![图 9.8 – 介绍域共享项目

![图 9.08_B17287.jpg](img/Figure_9.08_B17287.jpg)

![图 9.8 – 介绍域共享项目

以下图表显示了解决方案中项目之间的依赖关系：

![图 9.09 – 域共享项目的项目依赖关系](img/Figure_9.09_B17287.jpg)

![图 9.09_B17287.jpg](img/Figure_9.09_B17287.jpg)

图 9.9 – 域共享项目的项目依赖关系

新的 **Acme.Crm.Domain.Shared** 项目被 **Acme.Crm.Domain** 和 **Acme.Crm.Application.Contracts** 项目使用。这样，直接或间接地，解决方案中的所有其他项目都可以使用该新项目中的类型。

到目前为止，ABP 启动解决方案的基本层已经完成。然而，如果你查看 *图 9.4*，你会看到 ABP 启动解决方案还有三个额外的项目。我们将在接下来的小节中讨论这些内容。

### 介绍 HTTP API 层

在 *图 9.4* 中，你可以看到 ABP 启动解决方案有两个与 HTTP 相关的项目。

首先，**Acme.Crm.HttpApi** 项目包含解决方案的 API 控制器（即 REST API）。这个项目是在分离 API 和 UI 的想法下引入的，这样可以更好地组织和开发解决方案。

将 HTTP API 层作为一个类库项目分离，通过允许它们被重用，使得一些高级场景成为可能。EventHub 解决方案通过在 UI 层（在该解决方案中 UI 和 HTTP API 在不同的应用程序中托管）中使用 HTTP API 层作为代理来利用这种分离。参见 [*第 4 章*](B17287_04_Epub_AM.xhtml#_idTextAnchor130) *理解参考解决方案* 的 *主网站* 和 *主 HTTP API* 部分，了解它是如何工作的。

第二个与 HTTP API 相关的项目是 **Acme.Crm.HttpApi.Client**。这是一个类库项目，在这个示例解决方案中未使用，但在更高级的场景中可以使用。你可以从客户端应用程序（可以是你的应用程序或第三方 .NET 客户端）中使用这个库来轻松消费你的 HTTP API。它使用 ABP 的动态 C# 客户端代理系统，正如将在 [*第 14 章*](B17287_14_Epub_AM.xhtml#_idTextAnchor429) *构建 HTTP API 和实时服务* 中解释的那样。大多数时候，你不需要对这个项目进行任何更改，但它 *自动* 工作。EventHub 解决方案使用这种技术从 UI 应用程序执行 HTTP API 请求。

通过为 HTTP API 层添加两个新项目，我们现在在解决方案中拥有八个项目，如下截图所示：

![图 9.10 – 将 HTTP API 项目添加到解决方案中

](img/Figure_9.10_B17287.jpg)

图 9.10 – 将 HTTP API 项目添加到解决方案中

下面的图表显示了添加这些新项目后的新依赖关系图（这次，我已经从项目名称中移除了 `Acme.Crm.` 前缀，以便它们适合图表）：

![图 9.11 – HTTP API 层的项目依赖关系

](img/Figure_9.11_B17287.jpg)

图 9.11 – HTTP API 层的项目依赖关系

**Acme.Crm.HttpApi**和**Acme.Crm.HttpApi.Client**项目依赖于**Acme.Crm.Application.Contracts**项目，因为服务器和客户端共享相同的契约（应用程序服务接口）。**Acme.Crm.Web**项目依赖于**Acme.Crm.HttpApi**项目，因为它在运行时提供API。这个示例解决方案在运行时只有一个应用程序。你可以回顾一下在[*第4章*](B17287_04_Epub_AM.xhtml#_idTextAnchor130)中提供的EventHub解决方案结构，以在具有多个运行时应用程序的更复杂环境中查看这些项目。

丢弃HTTP API层

并非每个应用程序都需要有HTTP API（即REST API）。在这种情况下，你甚至可以从解决方案中移除这个项目。此外，如果你愿意，你可以将你的API控制器移动到**Acme.Crm.Web**项目，并丢弃**Acme.Crm.HttpApi**项目。

下一节将解释解决方案中的最后一个项目。

### 理解数据库迁移项目

在*图9.4*中，还有一个名为**Acme.Crm.DbMigrator**的额外项目。这是一个控制台应用程序，可以用来将EF Core代码首先迁移应用到数据库中。它是一个实用程序应用程序，不是基本解决方案的一部分，因此在这里不需要调查其细节。

解决方案中的测试项目

除了这九个项目之外，在`test`文件夹下还有六个更多项目。它们是为每个层分别配置的单元/集成测试项目。其中之一（**Acme.Crm.HttpApi.Client.ConsoleTestApp**）演示了如何使用**Acme.Crm.HttpApi.Client**项目来消费HTTP API。你可以自行探索它们。

这些都是ABP启动解决方案中的所有项目。提供的解决方案结构是架构模型，随后是所有预构建的官方ABP应用程序模块。这种模型由于其灵活性和模块化，使得在各种场景中重用应用程序模块成为可能。

在下一节中，我们将讨论一个可以用来将托管与UI应用程序分离的额外项目。

## 将托管与UI分离

在*图9.11*中展示的架构模型中有一个令人烦恼的事情是，**Web**项目引用了**Application**和**EntityFramework**项目。**Web**项目中的任何页面/类都没有直接使用这些项目中的类。然而，由于**Web**项目是运行应用程序的项目，我们需要引用这些项目以使它们在运行时可用。

这种结构本身并没有太大问题，只要你没有不小心将你的域名和数据层对象泄露到表示层（Web层）。然而，如果你担心，并且不想为这些运行时依赖项设置开发时间依赖项，你可以在下面的屏幕截图中添加一个额外的项目，**Acme.Crm.Web.Host**：

![图 9.12 – 添加单独的托管项目

![图片](img/Figure_9.12_B17287.jpg)

图 9.12 – 添加单独的托管项目

通过这个变更，`Startup.cs`、`Program.cs` 和 `appsettings.json` 文件。`Acme.Crm.Web.Host` 项目通过在运行时将所有项目组合在一起，负责托管。它不包含任何应用 UI 页面或组件。

我认为这个设计更好。它优雅地从 UI 层提取托管配置细节，移除了运行时依赖，并使其更加专注。然而，我们没有在 ABP 启动模板中分离托管应用，因为大多数开发者已经觉得 ABP 启动模板很复杂（与单项目 ASP.NET Core 启动模板相比）。这是因为其中有很多项目，我们不想再添加一个。我相信，具有多个项目且每个项目代码更少的解决方案，比所有内容都在一个地方的单个项目方案更好。

你可以在本书的 GitHub 仓库中找到具有单独托管项目的解决方案，网址为 [https://github.com/PacktPublishing/Mastering-ABP-Framework/tree/main/Samples/Chapter-09/SeparateHosting](https://github.com/PacktPublishing/Mastering-ABP-Framework/tree/main/Samples/Chapter-09/SeparateHosting)，并探索提供的结构。

在本节中，你了解了 ABP 启动模板中每个项目的角色，因此在开发你的解决方案时应该更加得心应手。在下一节中，我们将从 DDD 视角简要回顾 EventHub 引用解决方案。

# 处理多个应用

因此，我们已经了解了 ABP 启动解决方案中每个项目的目的。这是一个良好架构的软件解决方案的良好起点。它正确设置了层，只有一个领域层和一个应用层（由单个 Web 应用使用）。然而，在现实世界中，软件解决方案可能更复杂。你可能有多个应用（在同一个系统上）或者可能需要将领域分成多个子领域以降低每个子领域的复杂性。

DDD 解决方案处理复杂软件设计。将业务逻辑分离成领域逻辑和应用逻辑的主要目的是，在解决方案中有多个应用时，正确组织你的代码库。当你有多个应用时，你会有多个应用层。这些层中的每一个都实现了相关应用的应用特定业务逻辑，同时通过使用相同的领域层，仍然共享相同的核心领域逻辑。

*EventHub* 项目（在[*第4章*](B17287_04_Epub_AM.xhtml#_idTextAnchor130)，*理解参考解决方案*)有两个Web应用程序。其中一个是供最终用户使用的网站。另一个是管理员（后台）应用程序，供系统管理员使用。这些应用程序具有不同的用户界面、不同的用例、不同的授权规则以及不同的性能、本地化、缓存和扩展需求。将这些差异分离到两个应用程序层有助于我们将这些特定于应用程序的业务和基础设施需求相互隔离。这些应用程序共享我们不希望在应用程序之间重复的核心业务逻辑。这意味着两个应用程序层使用相同的领域层，如下面的图所示：

![Figure 9.13 – EventHub – multiple application layers and a single domain layer

![img/Figure_9.13_B17287.jpg]

图9.13 – EventHub – 多个应用程序层和单个领域层

当我们拥有多个应用程序时，在应用程序和领域层之间分离业务逻辑变得更加重要。将领域逻辑泄漏到应用程序层会导致其重复。另一方面，将特定于应用程序的逻辑放置在领域层会使你耦合不同应用程序的业务逻辑，并编写许多条件语句以使领域层可用于这些应用程序。这两种情况都会使你的代码库出现错误且难以维护。

领域逻辑与应用程序逻辑的分离很重要。在理解领域层和应用层构建块之后，我们将在[*第11章*](B17287_11_Epub_AM.xhtml#_idTextAnchor340)，*DDD – 应用程序层*中回到这个话题。但在那之前，让我们继续从大局出发，了解在基于DDD的应用程序中如何执行Web请求。

# 理解执行流程

我们已经介绍了许多构建块及其描述，以及这些构建块如何在.NET解决方案的层中放置。在本节中，我们将探讨在基于DDD分层的一个典型Web应用程序中如何执行HTTP请求。以下图显示了层的实际操作：

![Figure 9.14 – Execution flow through the layers

![img/Figure_9.14_B17287.jpg]

图9.14 – 通过层的执行流程

一个请求从客户端应用程序发起。客户端可以是一个期望获取HTML页面（及其CSS/JavaScript文件）的浏览器，或者是一个数据结果（例如JSON）。在这种情况下，Razor页面可以处理请求并返回一个HTML页面。如果发起请求的应用程序是另一种类型的客户端（例如控制台应用程序），你可能需要从HTTP API（API控制器）端点响应请求并返回一个纯数据结果。

MVC页面（在表示层）处理UI逻辑，可能执行一些数据转换，并将实际操作委托给应用层中应用程序的一个方法。应用服务可能接受一个DTO，实现用例逻辑，并将结果DTO返回给表示层。

应用服务内部使用领域对象（实体、存储库、领域服务等）来协调业务操作。业务操作应该是一个工作单元。这意味着它应该是原子的。在一个用例（通常是应用程序方法）中的所有数据库操作都应该一起提交或回滚。

表示层和应用层通常实现横切关注点，例如授权、验证、异常处理、缓存、审计日志等。

正如您在前几章中学到的，ABP框架为所有这些横切关注点提供了一个完整的架构，并在可能的情况下自动化它们。它还提供了适当的基类和实用的约定，以帮助您构建业务组件，并使用最佳实践实现DDD。

作为本章的最后一部分，我们将在下一节中看到DDD的一些常见原则。

# 理解通用原则

DDD关注的是您如何设计业务代码。它关心状态变化以及业务对象之间的交互——如何创建一个实体，如何通过应用（甚至强制）业务规则和约束来更改其属性，以及如何保持数据的有效性和完整性。

DDD不关心报告或大量查询。您可以使用报告工具的强大功能为您的应用程序创建酷炫的仪表板。您可以充分利用底层数据库提供商的功能以实现高性能。您甚至可以在另一个数据库提供商中复制数据，用于只读报告目的。您可以自由地做任何事情，只要您不将基础设施细节与业务代码混合。所有这些是我们作为开发者应该关心的问题，但DDD并不关心。

DDD也不关心基础设施细节；您应该使用适当的抽象来隔离业务代码与这些细节。其中两个抽象特别重要，因为它们在您的代码库中占据了很大的空间：表示技术和数据库提供商。在接下来的几节中，我将解释这两个原则，并讨论我们是否需要实现它们。

## 数据库提供商独立性

在基于DDD的软件解决方案中抽象数据库集成是一种良好的实践。在理论上，您的领域和应用层应该是数据库和甚至ORM独立的。这个建议背后有一些很好的理由。如果您实施它，以下情况将会发生：

+   您的数据库提供商（ORM或DBMS）在未来可能会发生变化，而不会影响您的业务代码。这使得您的业务代码具有更长的生命周期。

+   通过在仓储后面隐藏数据访问逻辑，你的领域层和应用层将更加专注于业务代码。

+   你可以更有效地模拟数据库层以进行自动化测试。

ABP 启动模板遵循这一原则——它不包含来自领域和应用层的数据库提供者引用。ABP 框架已经提供了实现仓储模式的简单基础设施。ABP 启动模板还附带数据库层，该层使用内存数据库实例进行自动化测试。

这两个原因中的最后一个是重要的，并且很容易与 ABP 框架一起应用。然而，第一个原因并不那么容易。一开始，当你将数据访问逻辑放在仓储后面时，你可能觉得你的业务代码是 ORM/数据库无关的。然而，事情并不那么简单。让我们假设你目前正在使用 EF Core 和 SQL Server（一个关系型数据库）来设计你的业务代码和实体，以便你可以轻松地切换到 MongoDB（一个文档数据库）。如果你想实现这一点，你必须考虑以下因素：

+   你不能假设你有 EF Core 的变更跟踪系统，因为 MongoDB .NET 驱动程序不提供该功能。因此，你应该始终在业务逻辑的末尾手动更新已更改的实体。

+   你不能将导航或集合属性添加到实体中，这些属性是其他聚合的类型。你必须严格实现聚合模式（如将在[*第 10 章*](B17287_10_Epub_AM.xhtml#_idTextAnchor316)，*领域层 DDD*中解释），并尊重聚合边界。这种限制深刻地影响了你的实体设计和在实体上工作的业务代码。

正如你所见，要实现数据库无关性，在设计实体时需要小心，这会影响你的代码库。

你可能会想，你需要它吗？你将来会更改数据库提供者吗？如果你以后更改，你需要付出多少努力？这比使它数据库无关的努力要多吗？即使你尝试这样做，它将真正实现数据库无关（你可能不知道在尝试切换之前）？

所有 ABP 预构建的应用程序模块都设计为独立于数据库提供者，相同的业务代码在 EF Core 和 MongoDB 上都能运行。这是必要的，因为它们是可重用模块，不能假设有数据库提供者。另一方面，最终应用程序可以做出这种假设。我仍然建议将数据访问代码隐藏在仓储后面，ABP 使这一点变得非常简单。然而，如果你想要使用 EF Core 依赖项，我看不到有什么问题。

## 展示技术无关

UI 框架是软件行业中最为动态的系统。有大量的替代方案，趋势的方法和工具正在迅速变化。将您的业务代码与 UI 代码耦合将是一个糟糕的主意。

实施这一原则更为重要且相对容易，尤其是在使用 ABP 框架的情况下。ABP 启动模板自带了适当的分层。ABP 框架提供了许多抽象，您可以在应用程序和领域层中使用，而无需依赖于 ASP.NET Core 或任何其他 UI 框架。

# 摘要

在本关于 DDD 的第一章中，我们探讨了四个基本层以及这些层中的核心构建块。ABP 启动模板比这四层结构更为复杂。您学习了启动模板是如何通过一次改变而逐步演变的，并且理解了这些改变背后的原因。

关于 DDD，您了解到业务逻辑被分为两层：应用层和领域层。我们讨论了如何通过引用 EventHub 示例解决方案来处理共享相同领域逻辑的多个应用程序。

然后，我们了解了在典型的基于 DDD 的软件中，HTTP 请求是如何执行并通过各层的。最后，我们讨论了如何将应用程序和领域层与基础设施细节（尤其是数据库提供者和 UI 框架）隔离开来。

本章旨在展示 DDD 的整体图景和基本概念。下一章将专注于实现领域层构建块，例如聚合、仓储和领域服务。
