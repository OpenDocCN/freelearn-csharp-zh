["```cs\nint numTests = 1000000;\nTestComponent test;\nusing (new CustomTimer(\"GetComponent(string)\", numTests)) {\n  for (var i = 0; i < numTests; ++i) {\n    test = (TestComponent)GetComponent(\"TestComponent\");\n  }\n}\n\nusing (new CustomTimer(\"GetComponent<ComponentName>\", numTests)) {\n  for (var i = 0; i < numTests; ++i) {\n    test = GetComponent<TestComponent>();\n  }\n}\n\nusing (new CustomTimer(\"GetComponent(typeof(ComponentName))\", numTests))  {\n  for (var i = 0; i < numTests; ++i) {\n    test = (TestComponent)GetComponent(typeof(TestComponent));\n  }\n}\n```", "```cs\n// Use this for initialization\nvoid Start () {\n\n}\n\n// Update is called once per-frame\nvoid Update () {\n\n}\n```", "```cs\npublic class EmptyClassComponent : MonoBehaviour {\n}\n\npublic class EmptyCallbackComponent : MonoBehaviour {\n  void Update () {}\n}\n```", "```cs\nvoid\\s*Update\\s*?\\(\\s*?\\)\\s*?\\n*?\\{\\n*?\\s*?\\}\n```", "```cs\nvoid TakeDamage() {\n\n  Rigidbody rigidbody = GetComponent<Rigidbody>();\n  Collider collider = GetComponent<Collider>();\n  AIControllerComponent ai = GetComponent<AIControllerComponent>();\n  Animator anim = GetComponent<Animator>();\n\n  if (GetComponent<HealthComponent>().health < 0) {\n    rigidbody.enabled = false;\n    collider.enabled = false;\n    ai.enabled = false;\n    anim.SetTrigger(\"death\");\n  }\n}\n```", "```cs\nprivate HealthComponent _healthComponent;\nprivate Rigidbody _rigidbody;\nprivate Collider _collider;\nprivate AIControllerComponent _ai;\nprivate Animator _anim;\n\nvoid Awake() {\n  _healthComponent = GetComponent<HealthComponent>();\n  _rigidbody = GetComponent<Rigidbody>();\n  _collider = GetComponent<Collider>();\n  _ai = GetComponent<AIControllerComponent>();\n  _anim = GetComponent<Animator>();\n}\n\nvoid TakeDamage() {\n  if (_healthComponent.health < 0) {\n    _rigidbody.detectCollisions = false;\n    _collider.enabled = false;\n    _ai.enabled = false;\n    _anim.SetTrigger(\"death\");\n  }\n}\n```", "```cs\nvoid Update() {\n  ProcessAI();\n}\n```", "```cs\nprivate float _aiProcessDelay = 0.2f;\nprivate float _timer = 0.0f;\n\nvoid Update() {\n  _timer += Time.deltaTime;\n  if (_timer > _aiProcessDelay) {\n    ProcessAI();\n    _timer -= _aiProcessDelay;\n  }\n}\n```", "```cs\nvoid Start() {\n  StartCoroutine(ProcessAICoroutine ());\n}\n\nIEnumerator ProcessAICoroutine () {\n  while (true) {\n    ProcessAI();\n    yield return new WaitForSeconds(_aiProcessDelay);\n  }\n}\n```", "```cs\nvoid Start() {\n  InvokeRepeating(\"ProcessAI\", 0f, _aiProcessDelay);\n}\n```", "```cs\nif (gameObject != null) {\n  // do stuff with gameObject\n}\n```", "```cs\nif (!System.Object.ReferenceEquals(gameObject, null)) {\n  // do stuff with gameObject\n}\n```", "```cs\nfor (int i = 0; i < listOfObjects.Count; ++i) {\n  if (listOfObjects[i].tag == \"Player\") {\n    // do something with this object\n  }\n}\n```", "```cs\nvoid Update() {\n\n  int numTests = 10000000;\n\n  if (Input.GetKeyDown(KeyCode.Alpha1)) {\n    for(int i = 0; i < numTests; ++i) {\n      if (gameObject.tag == \"Player\") {\n        // do stuff\n      }\n    }\n  }\n\n  if (Input.GetKeyDown(KeyCode.Alpha2)) {\n    for(int i = 0; i < numTests; ++i) {\n      if (gameObject.CompareTag (\"Player\")) {\n        // do stuff\n      }\n    }\n  }\n}\n```", "```cs\nprivate bool _positionChanged;\nprivate Vector3 _newPosition;\n\npublic void SetPosition(Vector3 position) {\n  _newPosition = position;\n  _positionChanged = true;\n}\n\nvoid FixedUpdate() {\n  if (_positionChanged) {\n    transform.position = _newPosition;\n    _positionChanged = false;\n  }\n}\n```", "```cs\nusing UnityEngine;\nusing System.Collections.Generic;\n\nclass EnemyManagerComponent : MonoBehaviour {\n  List<GameObject> _enemies = new List<GameObject>();\n\n  public void AddEnemy(GameObject enemy) {\n    if (!_enemies.Contains(enemy)) {\n      _enemies.Add(enemy);\n    }\n  }\n\n  public void KillAll() {\n    for (int i = 0; i < _enemies.Count; ++i) {\n      GameObject.Destroy(_enemies[i]);\n    }\n    _enemies.Clear();\n  }\n}\n```", "```cs\npublic void CreateEnemies(int numEnemies) {\n  for(int i = 0; i < numEnemies; ++i) {\n    GameObject enemy = (GameObject)GameObject.Instantiate(_enemyPrefab, \n                       5.0f * Random.insideUnitSphere, \n                       Quaternion.identity);\n    string[] names = { \"Tom\", \"Dick\", \"Harry\" };\n    enemy.name = names[Random.Range(0, names.Length)];\n    GameObject enemyManagerObj = GameObject.Find(\"EnemyManager\");\n    enemyManagerObj.SendMessage(\"AddEnemy\", \n                                enemy, \n                                SendMessageOptions.DontRequireReceiver);\n  }\n}\n```", "```cs\npublic void CreateEnemies(int numEnemies) {\n  GameObject enemyManagerObj = GameObject.Find(\"EnemyManager\");\n  EnemyManagerComponent enemyMgr = enemyManagerObj.GetComponent<EnemyManagerComponent>();\n  string[] names = { \"Tom\", \"Dick\", \"Harry\" };\n\n  for(int i = 0; i < numEnemies; ++i) {\n    GameObject enemy = (GameObject)GameObject.Instantiate(_enemyPrefab, \n                        5.0f * Random.insideUnitSphere, \n                        Quaternion.identity);\n    enemy.name = names[Random.Range(0, names.Length)];\n    enemyMgr.AddEnemy(enemy);\n  }\n}\n```", "```cs\nusing UnityEngine;\n\npublic class EnemyCreatorComponent : MonoBehaviour {\n  [SerializeField] private int _numEnemies;\n  [SerializeField] private GameObject _enemyPrefab;\n  [SerializeField] private EnemyManagerComponent _enemyManager;\n\n  void Start() {\n    for (int i = 0; i < _numEnemies; ++i) {\n      CreateEnemy();\n    }\n  }\n\n  public void CreateEnemy() {\n    _enemyManager.CreateEnemy(_enemyPrefab); \n  }\n}\n```", "```cs\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic static class StaticEnemyManager {\n  private static List<Enemy> _enemies;\n\n  public static void CreateEnemy(GameObject prefab) {\n    string[] names = { \"Tom\", \"Dick\", \"Harry\" };\n    GameObject enemy = GameObject.Instantiate(prefab, 5.0f * \n    Random.insideUnitSphere, Quaternion.identity);\n    Enemy enemyComp = enemy.GetComponent<Enemy>();\n    enemy.gameObject.name = names[Random.Range(0, names.Length)];\n    _enemies.Add(enemyComp);\n  }\n\n  public static void KillAll() {\n    for (int i = 0; i < _enemies.Count; ++i) {\n      _enemies[i].Die();\n      GameObject.Destroy(_enemies[i].gameObject);\n    }\n    _enemies.Clear();\n  }\n}\n```", "```cs\nprivate static List<Enemy> _enemies = new List<Enemy>();\n```", "```cs\nstatic StaticEnemyManager() {\n  _enemies = new List<Enemy>();\n  // more complicated initialization activity goes here\n}\n```", "```cs\nusing UnityEngine;\n\npublic class EnemyCreatorCompanionComponent : MonoBehaviour {\n  [SerializeField] private GameObject _enemyPrefab;\n\n  public void CreateEnemy() {\n    StaticEnemyManager.CreateEnemy(_enemyPrefab);\n  }\n}\n```", "```cs\nusing UnityEngine;\n\npublic class SingletonComponent<T> : MonoBehaviour where T : SingletonComponent<T> {\n  private static T __Instance;\n\n  protected static SingletonComponent<T> _Instance {\n    get {\n      if(!__Instance) {\n        T[] managers = GameObject.FindObjectsOfType(typeof(T)) as T[];\n        if (managers != null) {\n          if (managers.Length == 1) {\n            __Instance = managers[0];\n            return __Instance;\n          } else if (managers.Length > 1) {\n            Debug.LogError(\"You have more than one \" + \n                            typeof(T).Name + \n                            \" in the Scene. You only need \" + \n                            \"one - it's a singleton!\");\n            for(int i = 0; i < managers.Length; ++i) {\n              T manager = managers[i];\n              Destroy(manager.gameObject);\n            }\n          }\n        }\n        GameObject go = new GameObject(typeof(T).Name, typeof(T));\n        __Instance = go.GetComponent<T>();\n        DontDestroyOnLoad(__Instance.gameObject);\n      }\n      return __Instance;\n    }\n    set {\n      __Instance = value as T;\n    }\n  }\n}\n```", "```cs\npublic class EnemyManagerSingletonComponent : SingletonComponent< EnemyManagerSingletonComponent > {\n  public static EnemyManagerSingletonComponent Instance {\n    get { return ((EnemyManagerSingletonComponent)_Instance); }\n    set { _Instance = value; }\n  }\n\n  public void CreateEnemy(GameObject prefab) {\n    // same as StaticEnemyManager\n  }\n\n  public void KillAll() {\n    // same as StaticEnemyManager\n  }\n}\n```", "```cs\nprivate bool _alive = true;\nvoid OnDestroy() { _alive = false; }\nvoid OnApplicationQuit() { _alive = false; }\n```", "```cs\npublic static bool IsAlive {\n  get {\n    if (__Instance == null)\n      return false;\n    return __Instance._alive;\n  }\n}\n```", "```cs\npublic class SomeComponent : MonoBehaviour {\n  void OnDestroy() {\n    if (MySingletonComponent.IsAlive) {\n        MySingletonComponent.Instance.SomeMethod();\n    }\n  }\n}\n```", "```cs\npublic class Message {\n  public string type;\n  public Message() { type = this.GetType().Name; }\n}\n```", "```cs\npublic delegate bool MessageHandlerDelegate(Message message);\n```", "```cs\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class MessagingSystem : SingletonComponent<MessagingSystem> {\n  public static MessagingSystem Instance {\n    get { return ((MessagingSystem)_Instance); }\n    set { _Instance = value; }\n  }\n\n  private Dictionary<string,List<MessageHandlerDelegate>> _listenerDict = new Dictionary<string,List<MessageHandlerDelegate>>();\n\n  public bool AttachListener(System.Type type, MessageHandlerDelegate handler) {\n    if (type == null) {\n      Debug.Log(\"MessagingSystem: AttachListener failed due to having no \" + \n                \"message type specified\");\n      return false;\n    }\n\n    string msgType = type.Name;\n    if (!_listenerDict.ContainsKey(msgType)) {\n      _listenerDict.Add(msgType, new List<MessageHandlerDelegate>());\n    }\n\n    List<MessageHandlerDelegate> listenerList = _listenerDict[msgType];\n    if (listenerList.Contains(handler)) {\n      return false; // listener already in list\n    }\n\n    listenerList.Add(handler);\n    return true;\n  }\n}\n```", "```cs\nprivate Queue<Message> _messageQueue = new Queue<Message>();\n\npublic bool QueueMessage(Message msg) {\n  if (!_listenerDict.ContainsKey(msg.type)) {\n    return false;\n  }\n  _messageQueue.Enqueue(msg);\n  return true;\n}\n```", "```cs\nprivate const int _maxQueueProcessingTime = 16667;\nprivate System.Diagnostics.Stopwatch timer = new System.Diagnostics.Stopwatch();\n\nvoid Update() {\n  timer.Start();\n  while (_messageQueue.Count > 0) {\n    if (_maxQueueProcessingTime > 0.0f) {\n      if (timer.Elapsed.Milliseconds > _maxQueueProcessingTime) {\n         timer.Stop();\n         return;\n      }\n    }\n\n    Message msg = _messageQueue.Dequeue();\n    if (!TriggerMessage(msg)) {\n      Debug.Log(\"Error when processing message: \" + msg.type);\n    }\n  }\n}\n```", "```cs\npublic bool TriggerMessage(Message msg) {\n  string msgType = msg.type;\n  if (!_listenerDict.ContainsKey(msgType)) {\n    Debug.Log(\"MessagingSystem: Message \\\"\" + msgType + \"\\\" has no listeners!\");\n    return false; // no listeners for message so ignore it\n  }\n\n  List<MessageHandlerDelegate> listenerList = _listenerDict[msgType];\n\n  for(int i = 0; i < listenerList.Count; ++i) {\n    if (listenerList[i](msg)) {\n      return true; // message consumed by the delegate\n    }\n    return true;\n  }  \n}\n```", "```cs\npublic class CreateEnemyMessage : Message {}\n\npublic class EnemyCreatedMessage : Message {\n\n  public readonly GameObject enemyObject;\n  public readonly string enemyName;\n\n  public EnemyCreatedMessage(GameObject enemyObject, string enemyName) {\n    this.enemyObject = enemyObject;\n    this.enemyName = enemyName;\n  }\n}\n```", "```cs\npublic class EnemyCreatorComponent : MonoBehaviour {\n  void Update() {\n    if (Input.GetKeyDown(KeyCode.Space)) {\n      MessagingSystem.Instance.QueueMessage(new CreateEnemyMessage()); \n    }\n  }\n}\n```", "```cs\n\npublic class EnemyManagerWithMessagesComponent : MonoBehaviour {\n  private List<GameObject> _enemies = new List<GameObject>();\n  [SerializeField] private GameObject _enemyPrefab;\n\n  void Start() {\n    MessagingSystem.Instance.AttachListener(typeof(CreateEnemyMessage), \n                                            this.HandleCreateEnemy);\n  }\n\n  bool HandleCreateEnemy(Message msg) {\n    CreateEnemyMessage castMsg = msg as CreateEnemyMessage;\n    string[] names = { \"Tom\", \"Dick\", \"Harry\" };\n    GameObject enemy = GameObject.Instantiate(_enemyPrefab, \n                       5.0f * Random.insideUnitSphere, \n                       Quaternion.identity);\n    string enemyName = names[Random.Range(0, names.Length)];\n    enemy.gameObject.name = enemyName;\n    _enemies.Add(enemy);\n    MessagingSystem.Instance.QueueMessage(new EnemyCreatedMessage(enemy, \n                                                                  enemyName));\n    return true;\n  }\n}\n\npublic class EnemyCreatedListenerComponent : MonoBehaviour {\n  void Start () {\n    MessagingSystem.Instance.AttachListener(typeof(EnemyCreatedMessage), \n                                            HandleEnemyCreated);\n  }\n\n  bool HandleEnemyCreated(Message msg) {\n    EnemyCreatedMessage castMsg = msg as EnemyCreatedMessage;\n    Debug.Log(string.Format(\"A new enemy was created! {0}\", \n                            castMsg.enemyName));\n    return true;\n  }\n}\n```", "```cs\npublic bool DetachListener(System.Type type, MessageHandlerDelegate handler) {\n  if (type == null) {\n    Debug.Log(\"MessagingSystem: DetachListener failed due to having no \" + \n              \"message type specified\");\n    return false;\n  }\n\n  string msgType = type.Name;\n\n  if (!_listenerDict.ContainsKey(type.Name)) {\n    return false;\n  }\n\n  List<MessageHandlerDelegate> listenerList = _listenerDict[msgType];\n  if (!listenerList.Contains (handler)) {\n    return false;\n  }\n  listenerList.Remove(handler);\n  return true;\n}\n```", "```cs\nvoid OnDestroy() {\n  if (MessagingSystem.IsAlive) {\n    MessagingSystem.Instance.DetachListener(typeof(EnemyCreatedMessage), \n                                            this.HandleCreateEnemy);\n  }\n}\n```", "```cs\nvoid OnBecameVisible() { enabled = true; }\nvoid OnBecameInvisible() { enabled = false; }\n```", "```cs\nvoid OnBecameVisible() { gameObject.SetActive(true); }\nvoid OnBecameInvisible() { gameObject.SetActive(false); }\n```", "```cs\n[SerializeField] GameObject _target;\n[SerializeField] float _maxDistance;\n[SerializeField] int _coroutineFrameDelay;\n\nvoid Start() {\n  StartCoroutine(DisableAtADistance());\n}\n\nIEnumerator DisableAtADistance() {\n  while(true) {\n    float distSqrd = (transform.position - _target.transform.position).sqrMagnitude;\n    if (distSqrd < _maxDistance * _maxDistance) {\n      enabled = true;\n    } else {\n      enabled = false;\n    }\n\n    for (int i = 0; i < _coroutineFrameDelay; ++i) {\n      yield return new WaitForEndOfFrame();\n    }\n  }\n}\n```", "```cs\nfloat distance = (transform.position – other.transform.position).Distance();\nif (distance < targetDistance) {\n  // do stuff\n}\n```", "```cs\nfloat distanceSqrd = (transform.position – other.transform.position).sqrMagnitude;\nif (distanceSqrd < (targetDistance * targetDistance)) {\n  // do stuff\n}\n```", "```cs\npublic interface IUpdateable {\n  void OnUpdate(float dt);\n}\n```", "```cs\npublic class UpdateableComponent : MonoBehaviour, IUpdateable {\n  public virtual void OnUpdate(float dt) {}\n}\n```", "```cs\nvoid Start() {\n  GameLogic.Instance.RegisterUpdateableObject(this);\n}\n\nvoid OnDestroy() {\n  if (GameLogic.Instance.IsAlive) {\n    GameLogic.Instance.DeregisterUpdateableObject(this);\n  }\n}\n```", "```cs\nvoid Start() {\n  GameLogic.Instance.RegisterUpdateableObject(this);\n  Initialize();\n}\n\nprotected virtual void Initialize() {\n  // derived classes should override this method for initialization code, and NOT reimplement Start()\n}\n```", "```cs\npublic class GameLogicSingletonComponent : SingletonComponent<GameLogicSingletonComponent> {\n  public static GameLogicSingletonComponent Instance {\n    get { return ((GameLogicSingletonComponent)_Instance); }\n    set { _Instance = value; }\n  }\n\n  List<IUpdateable> _updateableObjects = new List<IUpdateable>();\n\n  public void RegisterUpdateableObject(IUpdateable obj) {\n    if (!_updateableObjects.Contains(obj)) {\n      _updateableObjects.Add(obj);\n    }\n  }\n\n  public void DeregisterUpdateableObject(IUpdateable obj) {\n    if (_updateableObjects.Contains(obj)) {\n      _updateableObjects.Remove(obj);\n    }\n  } \n\n  void Update()\n  {\n    float dt = Time.deltaTime;\n    for (int i = 0; i < _updateableObjects.Count; ++i) {\n      _updateableObjects[i].OnUpdate(dt);\n    }\n  }\n}\n```"]