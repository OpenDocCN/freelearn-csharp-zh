- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Middleware Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: APIs are collections of commands that can be triggered on request. When a request
    is received, we can execute logic that is bespoke to the use case of that request.
    However, a request does not instantly hit our endpoints as soon as it is received.
    There is a pipeline that is first traversed before our logic can be executed and
    the request is eventually returned to the client. This pipeline is called the
    middleware pipeline, and it is a feature set within ASP.NET that allows us to
    extend our APIs in a way that separates concerns, optimizes performance, and promotes
    reusability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring middleware pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing custom middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You are encouraged to write and extend the code examples shown in this chapter
    to improve your practical understanding. However, if you wish to gain access to
    the source code, you can obtain it from the following GitHub link: [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Middleware** as a concept was introduced to ASP.NET in ASP.NET Core. Replacing
    the older HTTP pipeline model, which used HTTP modules and HTTP handlers, it offers
    a simpler and more flexible way to manage the way HTTP requests are handled by
    APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: If you think of an API application as a pipeline with requests traveling through
    it, the concept becomes more straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware is a component that sits on the pipeline before a request is handled
    by an endpoint. It is executed on every request and is part of a sequence, with
    components executing in the order in which they were registered.
  prefs: []
  type: TYPE_NORMAL
- en: Each middleware component has a role to play, with the ability to affect the
    request irrespective of the endpoint it has requested. Each middleware component
    can be built in, such as routing, for example, or custom middleware, written for
    specific purposes such as logging or authentication, to name a couple.
  prefs: []
  type: TYPE_NORMAL
- en: Once a middleware component has completed its work, it passes the request to
    the next middleware component in the pipeline, until all middleware components
    have been traversed. Then the request can hit the endpoint holding the code written,
    which has logic specific to that endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware progression
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that while it is true that middleware components pass requests
    on to each other in a chain, they only do this unless there is a reason for the
    request to be terminated, with an exception being returned. Depending on the context,
    a middleware pipeline can end prematurely by design.
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen in the previous chapters, endpoints must send some form of
    response to their clients. Once request handling has been completed, endpoints
    then send the response back to the client via the middleware pipeline, where it
    travels once again through each middleware component in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a visualization of an example request pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: An example middleware pipeline flow](img/B20968_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: An example middleware pipeline flow'
  prefs: []
  type: TYPE_NORMAL
- en: Middleware is a very important aspect of not just minimal APIs but ASP.NET in
    general, with widespread use in web API and MVC projects. It provides developers
    with a way of registering custom behavior at the application level, as a design
    pattern that decouples this behavior from endpoint-specific logic.
  prefs: []
  type: TYPE_NORMAL
- en: For example, there are certain logs that might need to be captured every time
    a request is received. This could be a log stating that a resource such as a SQL
    database was accessed as part of a request, or an error log if the request should
    not have been made.
  prefs: []
  type: TYPE_NORMAL
- en: It would be inefficient to include the logging code in every endpoint as they
    are written, and the developer would have to remember to include the logic to
    capture the log message. This is, as you can imagine, not sustainable and is a
    violation of the **don’t repeat yourself** ( **DRY** ) principle. Using a logging
    middleware component means that the required log messages will be captured every
    time a request is received, and it only has to be configured once.
  prefs: []
  type: TYPE_NORMAL
- en: This is not to say that middleware components *must* be general in their execution.
    They are classes or methods like any other and have access to the incoming request
    in the form of an **HttpContext** object. As a result, they can scrutinize the
    request just like an endpoint can and execute any custom logic applicable to that
    request before the endpoint is reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a basic example of a middleware component that is created as
    a class. The component simply writes to the console before calling the next component
    in the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This middleware class has a constructor that receives an object of type **RequestDelegate**
    when the class is instantiated. This delegate is a representation of the next
    middleware component in the pipeline. The **_next()** delegate can be used to
    call the next middleware component and continue the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how the pipeline passes control flow between each component is
    critical, but it’s worth nothing if we don’t know how to build our own components.
    We’ll now move on to explore how you can create and configure middleware within
    your pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring middleware pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can structure a middleware component in different ways depending on its
    purpose. The previous example demonstrated the creation of a simple middleware
    component using a class. Let’s explore this type of component in more detail before
    looking at other ways of building and registering them.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Middleware classes need to have an **Invoke** or **InvokeAsync** method so that
    they can be triggered when it is their turn. Notice how, in the example we saw
    in the previous section, we have a method called **_next()** , passing in the
    **HttpContext** object that the same method received. This is where the middleware
    component calls the next component in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve created a middleware component, you will need to add it to the pipeline.
    In a minimal API, the setup of the API takes place in **Program.cs** , with the
    creation of a **WebApplication** object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember in the previous chapters when we created an instance of **WebApplication**
    and called it **app** ? This **app** object has a method called **UseMiddleware<T>()**
    . This allows us to tell the **WebApplication** object that it should use a middleware
    component of a specific type. If we wanted to register our **MySuperSimpleMiddleware**
    class as middleware, we would do it before we start the **WebApplication** object
    with **app.Run()** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that the middleware has been added to our **WebApplication** object. it
    will be invoked within the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Writing middleware in a class has its advantages and disadvantages. On one hand,
    it might make sense to use a class to be keep middleware tidy and decoupled from
    the **WebApplication** object. You might also want to use a factory design pattern
    to produce and register appropriate middleware classes. On the other hand, the
    use of a class may be overkill. After all, we are building *minimal APIs* , where,
    most of the time, it is favorable to keep logic small and simple.
  prefs: []
  type: TYPE_NORMAL
- en: In the spirit of minimalism, there is an alternative to middleware classes in
    the form of inline middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Inline middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a lot simpler than using classes. When creating middleware inline, we
    create and register the component with our **WebApplication** object in one block
    of code. Once again, considering our instance of **WebApplication** called **app**
    , we will still be passing in an **HTTPContext** object and **RequestDelegate**
    object, but instead of a constructor, private field, and **InvokeAsync()** method,
    everything will happen inside the body of the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at how we could rewrite **MySuperSimpleMiddlewareClass** into an
    inline middleware component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we add **app.UseMiddleware<MySuperSimpleMiddlewareClass>()**
    with the much more generic **app.Use()** . Instead of specifying a type, we are
    now passing an asynchronous anonymous function that will be registered to the
    pipeline. The body of the lambda expression shown in the example is the equivalent
    of **InvokeAsync()** found within **MySuperSimpleMiddlewareClass** .
  prefs: []
  type: TYPE_NORMAL
- en: Just like before, we are writing a console message on the incoming request,
    followed by a call to the **RequestDelegate** , object which passes to the next
    component. We then have another console message, which will be executed on the
    request response as it travels back through the pipeline on its way to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of registering middleware inline is its consistency with the endpoints
    you create. If you were to register small middleware components in this way, before
    constructing endpoints by mapping them onto the **WebApplication** object, your
    project would indeed be minimal in the way minimal APIs were designed to be.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered the basics of configuring pipelines in the previous section,
    but there are some pitfalls that you should be aware of to ensure you are getting
    the benefits of middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we discussed in the first part of the chapter, middleware resides as a sequence
    of components within a pipeline in which a request travels between the client
    and server.
  prefs: []
  type: TYPE_NORMAL
- en: This sequence of components is linear, meaning that the order in which individual
    components are executed is critical, depending on their respective goals.
  prefs: []
  type: TYPE_NORMAL
- en: The order of execution is determined by the order in which the components are
    registered, and how they are registered is determined by the way they are constructed
    – that is, class-based or as inline middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these components can modify the request and the response within the
    pipeline. As you can imagine, this makes it easy to produce unexpected results
    if caution is not taken. For example, as part of your pipeline, you may need to
    add a field to the payload. This is fine, but if you have another middleware component
    within the pipeline that references that new field, you have created a dependency
    between components.
  prefs: []
  type: TYPE_NORMAL
- en: If the component that references the new field was to be registered before the
    component that created it, the pipeline would hit an exception because a property
    that does not yet exist will have been referenced.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when writing middleware, it is essential that you verify that the
    request is hitting each component in the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and run the project containing these middleware examples. You will
    see the order in which the middleware is executing in the logs shown in the **Output**
    tab accessible from the bottom left of the window in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Default middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are built-in middleware components that ASP.NET automatically registers
    for minimal API projects depending on the way they have been configured.
  prefs: []
  type: TYPE_NORMAL
- en: If the hosting environment is set to **Development** , **UseDeveloperExceptionPage**
    middleware will be registered. This component displays a page showing error responses
    from the pipeline when they occur, which is very useful for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: The routing that we depend on and worked with in the previous chapter is itself
    a middleware. It is added automatically by ASP.NET if endpoints exist. ASP.NET
    will not add it automatically if you add **UseRouting()** manually.
  prefs: []
  type: TYPE_NORMAL
- en: After **UseRouting** , ASP.NET will also add **UseAuthentication** if **IAuthenticationSchemeProvider**
    is detected in the service provider. Like **UseRouting** , if you add the component
    manually, ASP.NET will skip adding **UseAuthentication** . The same is true for
    **UseAuthorization()** with **IAuthorizationSchemeProvider** . Most default middleware
    will not be noticed by the developer unless there is a need to override it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explored middleware as a concept, we should move on to discuss
    how we can extend minimal APIs by writing our own custom middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing custom middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom middleware is any middleware component that either you have written yourself
    or is not part of the default middleware components registered by ASP.NET.
  prefs: []
  type: TYPE_NORMAL
- en: Custom middleware affords us a lot of flexibility in the way we extend the functionality
    of our API outside of request endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of custom middleware might be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logging middleware** : Capture events and store logs as requests are received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error-handling middleware** : Have specific ways that errors are treated
    within the pipeline'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validation middleware** : Check that data is in a specific state on receipt
    or response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request-timing middleware** : Record the time a request takes for the purposes
    of monitoring and telemetry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IP-blocking middleware** : Check the IP address of the request’s remote host
    and check to see if it is in the ban list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s write some custom middleware using the example of logging. In this example,
    we’ll keep things simple and minimal by writing the middleware as an inline middleware
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open **Program.cs** and start by creating a new blank middleware component;
    that is to say, create a **Use()** method receiving an **HttpContext** object
    and a **RequestDelegate** object with nothing in the body of the accompanying
    lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a blank canvas for a simple middleware component, we can add some
    logic to log some content. In this example, we’re going to log the content to
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: The question is, *what* do we want to log?
  prefs: []
  type: TYPE_NORMAL
- en: The useful thing about having the request passed into the component as a **HttpContext**
    instance, is that we can access the individual properties of the request via this
    object. This means we can access the target HTTP method, the target route, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by logging some content from the request as it is received, before
    passing the control flow on to the next component in the pipeline. To do this,
    update the body of the lambda expression so that it reflects this updated example
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now our middleware is accessing data from the request and using string interpolation,
    arranging the data into a string that can be logged to the console. This gives
    our API the benefit of being auditable (easy to track and review historical events)
    and easier to maintain. On top of this, because we’ve used a custom middleware,
    we’ve not had to repeat ourselves by writing the same log for each endpoint we
    create.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the middleware components on the pipeline don’t just execute for the
    incoming request. The outgoing response also traverses the middleware pipeline
    in reverse on its way back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to log the contents of the response to the console as it travels
    back through the pipeline, we could simply add another **Console.WriteLine()**
    statement underneath our call to **next()** . The **Response** member of the **HttpContex**
    t object should provide us with up-to-date data for the outgoing response, which
    we can log, as in the example shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As a reminder, this was an inline middleware component, meaning that it was
    created using a lambda expression in **Program.cs** . For the sake of consistency,
    here is an example of how the same middleware component could be written in a
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the **Program** class would look after registering the class-based
    middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Logging is a straightforward example of middleware’s ability to take action
    before routes are hit. For more complex use cases, it might be necessary to **short-circuit**
    the pipeline. This would stop other components in the pipeline from executing
    and can be easily achieved by omitting the call to the **RequestDelegate** object.
  prefs: []
  type: TYPE_NORMAL
- en: Short-circuiting is simple enough, but what if our middleware has a level of
    complexity that means it might have to block routing from taking place? This would
    mean the middleware stops the request from reaching the intended endpoint, or
    any endpoints at all.
  prefs: []
  type: TYPE_NORMAL
- en: To understand this concept further, we need to look at a style of middleware
    component called **terminal middleware** .
  prefs: []
  type: TYPE_NORMAL
- en: Terminal middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classic middleware components such as the ones we have worked with in this chapter
    all have one thing in common – the requests that pass through them on the pipeline
    will eventually reach an endpoint, and then the endpoint will handle sending the
    requests back through the pipeline to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are scenarios where we would not want a request to reach the
    endpoint. For example, if we had implemented a banned IP list, in which IP addresses
    for malicious or suspicious hosts were listed, we would want to achieve the following
    with middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the IP address of the remote host sending the request
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine whether the IP address is on the list of banned IPs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is a banned IP address, send a response back to the client from the middleware,
    stating that the host is forbidden from proceeding further
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s write our own middleware component that checks incoming IP addresses and
    blocks the request from going any further if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a *scaffold* of a middleware class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: At the moment, our middleware doesn’t do anything, other than simply passing
    control to the next component in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking back at the three goals of our IP-blocking middleware, the first goal
    is to identify the IP address of the requesting host. This information can be
    retrieved from the **HttpContext** object as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to identify whether the requesting IP address is a banned IP.
    To do this, we need to add a collection to store the banned list, and then a check
    against the incoming IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a private **HashSet<string>** field under the **RequestDelegate** field.
    We’ll use this as our banned list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This list can be passed to the middleware when it is registered via its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the constructor to reflect this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all that remains is to act against the offending request. We can write
    messages into the response to the client via the **HttpContext** object. Here,
    we can include a message to inform the client that their IP address is blocked.
    Following this, we can use a **return** statement to stop the request in its tracks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once all these changes have been added, we will have a fully functioning custom
    middleware class that is able to detect banned IP addresses for incoming requests
    and block them from reaching the endpoints we’ve configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your **IPBlockingMiddleware** class should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding middleware example, we have a constructor parameter in the
    form of a list of blocked IPs. This means that when registering the middleware
    in **Program.cs** , the list would have to be created beforehand, and then passed
    in during registration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You could test the **IPBlocking** functionality by adding the loopback address
    to the blacklist. This should return a response with a **403** status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Gradually, we’re starting to introduce more complex logic into our minimal API
    with custom and default middleware components. As complexity increases, so does
    the probability that errors will occur. As we know, all potential errors must
    be handled to maintain system continuity.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware can also be used to achieve this. Let’s explore how we can write
    a component that catches and handles unexpected behavior and errors that may occur
    within the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors within the middleware pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will stick with a class-based middleware component structure,
    as it offers a clean structure with types that can be swapped out as needed. (This
    is more of a personal preference than good practice.)
  prefs: []
  type: TYPE_NORMAL
- en: A dedicated error handling component can be useful, as it ensures that you are
    always able to review and address errors as they occur, rather than facing the
    problematic and often embarrassing situation where an unhandled exception crashes
    the application completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a basic exception-handling middleware component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice how, in this code, the **try catch** block in **InvokeAsync()** doesn’t
    do much at all in the **try** body. It simply passes execution to the next component.
    This is because this middleware will be the first component in the pipeline to
    be registered. It is the first because we are not interested in handling errors
    at the first component in the pipeline, but we are for all other components. By
    placing our logic in the **catch** body, any errors that happen later in the pipeline
    will *bubble up* to this component and be caught, allowing us to handle them and
    then update the response to the client accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: It also covers us for the handling of any exceptions during the execution of
    middleware components on the return journey (the response) as the flow of execution
    is heading back toward this component. As the component was the first to be registered,
    it will be the last to execute on the return journey.
  prefs: []
  type: TYPE_NORMAL
- en: In the **catch** statement, we can do whatever is needed to handle the exception.
    In this example, we simply write the value of the caught exception’s **Message**
    field to the console. Then we set the status code of the request to **500 INTERNAL
    SERVER ERROR** and write a message into the response. All of this happens via
    the **HttpContext** object that travels through the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to force one of these exceptions to see an example of the output,
    you could create a dedicated example endpoint that simply throws an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Calling this endpoint while in **Debug** mode will display the exception details
    in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: Exception details shown in the browser for debugging purposes](img/B20968_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Exception details shown in the browser for debugging purposes'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ve delved deep into the intricacies of middleware and pipeline
    customization in minimal APIs. By understanding the concepts and practical implementations
    of middleware, we’ve laid the groundwork for creating more robust, maintainable,
    and flexible API applications. Let’s summarize the key points and skills we’ve
    covered.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the essential role that middleware plays in the
    ASP.NET Core minimal APIs. Middleware components are pivotal in the request-response
    lifecycle, enabling developers to handle key areas of a system such as logging,
    authentication, error handling, and more.
  prefs: []
  type: TYPE_NORMAL
- en: We started by introducing the concept of middleware and explaining how it fits
    into the overall architecture of minimal APIs. Middleware components act as intermediaries
    that can inspect, modify, or terminate HTTP requests and responses. This modular
    approach promotes a clean separation of concerns and enhances the maintainability
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we delved into configuring middleware pipelines, illustrating how the
    order of middleware registration affects the processing of requests. Middleware
    components are executed in the order they are added to the pipeline, and the response
    travels back through the pipeline in reverse order. This sequential processing
    model is critical for ensuring that each middleware component functions correctly
    and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to implementing custom middleware, providing examples such
    as logging and IP blocking. These examples demonstrated how custom middleware
    can be tailored to meet specific application requirements.
  prefs: []
  type: TYPE_NORMAL
- en: We highlighted the importance of error-handling middleware, showing how it can
    be used to catch and manage exceptions centrally, thereby simplifying error management
    and improving application robustness.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware is a fantastic way of extending the functionality of minimal APIs,
    but they are useless if their requests don’t have data that can be reviewed, manipulated,
    and transformed. In the next chapter, we’ll explore how data traveling through
    an API can be mapped for it to be processed optimally and accurately.
  prefs: []
  type: TYPE_NORMAL
