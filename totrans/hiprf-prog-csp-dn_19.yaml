- en: '*Chapter 16*: Asynchronous Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*：异步编程'
- en: In this chapter, you will learn about the `async`, `await`, and `WhenAll`. You
    will also learn about different return types and extract the required results.
    Plus, you will learn how to correctly cancel asynchronous operations and perform
    asynchronous file reading and writing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习关于`async`、`await`和`WhenAll`的内容。你还将了解不同的返回类型并提取所需的结果。此外，你将学习如何正确地取消异步操作以及执行异步文件读写。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: '**Understanding the TAP model**: In this section, we provide a high-level overview
    of the TAP model.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解TAP模型**：在本节中，我们提供了一个关于TAP模型的概述。'
- en: '`Task.Run`) and asynchronously.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Run`)并异步执行。'
- en: '`GetAwaiter.GetResult()`, `.Result`, and `.Wait` for both `Task` and `ValueTask`.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetAwaiter.GetResult()`、`.Result`和`.Wait`对于`Task`和`ValueTask`都适用。'
- en: '**Canceling asynchronous operations**: In this section, we write code that
    demonstrates asynchronous task cancellation.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**取消异步操作**：在本节中，我们将编写演示异步任务取消的代码。'
- en: '**Writing files asynchronously**: In this section, we write text to a file
    asynchronously.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步写入文件**：在本节中，我们将异步地向文件中写入文本。'
- en: '**Reading files asynchronously**: In this section, we read text from a file
    asynchronously.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步读取文件**：在本节中，我们将异步地从文件中读取文本。'
- en: 'After completing this chapter, you will be skilled in the following areas:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将在以下领域具备技能：
- en: Understanding the TAP model
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解TAP模型
- en: Processing web resources asynchronously
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步处理网络资源
- en: Writing files asynchronously
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步写入文件
- en: Reading files asynchronously
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步读取文件
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You'll need Visual Studio to work on the code presented in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要Visual Studio来处理本章中展示的代码。
- en: All code from this chapter is placed on GitHub at [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH16](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH16).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都放置在GitHub上，地址为[https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH16](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH16)。
- en: Understanding the TAP model
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解TAP模型
- en: 'Before we begin, it is worth noting that there are three different models for
    dealing with asynchronous programming. These are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，值得注意的是，处理异步编程有三种不同的模型。具体如下：
- en: The **Asynchronous Programming Model** (**APM**)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步编程模型**（**APM**）'
- en: The **Event-Based Asynchronous Pattern** (**EAP**) model
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于事件的异步模式**（**EAP**）模型'
- en: The **Task Parallelism Library** (**TPL**)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务并行库**（**TPL**）'
- en: APM uses `BeginMethod` to start the asynchronous process and `EndMethod` to
    complete the asynchronous process. EAP uses `MethodAsync` to start an asynchronous
    process, `CancelAsync` to handle the cancellation of an asynchronous operation,
    and a completed event handler to handle the completed asynchronous operation.
    Both these ways of performing asynchronous operations were replaced by TPL in
    C# 4.5.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: APM使用`BeginMethod`启动异步过程，使用`EndMethod`完成异步过程。EAP使用`MethodAsync`启动异步过程，使用`CancelAsync`处理异步操作的取消，以及使用完成的事件处理器处理完成的异步操作。这两种执行异步操作的方式在C#
    4.5中被TPL所取代。
- en: TPL uses the `async` and `await` pattern. Asynchronous method names are suffixed
    with `async`. An asynchronous method usually returns an awaitable `Task` or `Task<Result>`.
    From .NET 4.5 onwards, you are advised to use TPL instead of using APM and EAP.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TPL使用`async`和`await`模式。异步方法名称以`async`结尾。异步方法通常返回一个可等待的`Task`或`Task<Result>`。从.NET
    4.5开始，建议使用TPL而不是使用APM和EAP。
- en: TAP's foundation types are the `System.Thread.Tasks` namespace, and the `Task`
    and `Task<Tresult>` classes via asynchronous operations. Microsoft advises that
    you should use TAP when starting new projects.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: TAP的基础类型是`System.Thread.Tasks`命名空间，以及通过异步操作提供的`Task`和`Task<Tresult>`类。Microsoft建议在开始新项目时使用TAP。
- en: Naming, parameters, and return types
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名、参数和返回类型
- en: An asynchronous method using the TAP model prefixes the method signature with
    `async Task` for void methods, or `async Task<Tresult>`, `async ValueTask`, or
    `async ValueTask<Tresult>` for methods that return a value. The name of an asynchronous
    method that does not return a value should begin with a verb such as `Begin` or
    `Process`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TAP模型的异步方法在方法签名前缀为`async Task`（对于无返回值的方法），或`async Task<Tresult>`、`async ValueTask`或`async
    ValueTask<Tresult>`（对于返回值的方法）。不返回值的异步方法名称应以动词开头，如`Begin`或`Process`。
- en: TAP method parameters should match and be in the same order as the parameters
    of synchronous counterpart methods. You should avoid entirely using `out` and
    `ref` parameters that are exempt from this rule. If you need to return data, use
    `Tresult` returned by `Task<Tresult>`. Use data structures to accommodate multiple
    return types. It is also worth considering adding cancellation tokens to TAP methods
    as parameters even if synchronous method counterparts don't have such tokens.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: TAP方法参数应与同步对应方法的参数匹配，并且顺序相同。您应避免完全使用免于遵守此规则的`out`和`ref`参数。如果您需要返回数据，请使用`Task<Tresult>`返回的`Tresult`。使用数据结构来适应多种返回类型。还值得考虑将取消令牌添加到TAP方法参数中，即使同步方法对应者没有这样的令牌也是如此。
- en: Combinator methods that work with multiple tasks where the intent is clear do
    not have to follow this naming pattern. `WhenAll` and `WhenAny` are examples of
    combinator methods.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当意图明确时，与多个任务一起工作的组合方法不必遵循此命名模式。`WhenAll`和`WhenAny`是组合方法的例子。
- en: Initiating asynchronous operations
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动异步操作
- en: You may wish to perform some synchronous tasks, such as validation and preparing
    the asynchronous operation for execution, at the start of an asynchronous method.
    If so, you are advised to keep these tasks to the minimum, and the time they take
    should be minimal. The reason is that such methods may be invoked from **User
    Interface** (**UI**) threads, and you don't want to cause your applications to
    hang or freeze momentarily.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望在异步方法开始时执行一些同步任务，例如验证和准备异步操作以执行。如果是这样，建议将这些任务保持到最小，并且它们所需的时间应尽可能短。原因是这些方法可能从**用户界面**（**UI**）线程调用，您不希望导致您的应用程序挂起或暂时冻结。
- en: Another reason for keeping synchronous operations to the minimum and for spending
    minimal time within asynchronous operations is that when you run concurrent asynchronous
    methods, long-running synchronous operations can and do decrease the benefits
    of concurrency.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将同步操作保持到最小，并在异步操作中花费最短时间的原因之一是，当您运行并发异步方法时，长时间运行的同步操作会降低并发的好处。
- en: Sometimes, it can take longer to prepare and launch an asynchronous operation
    than it can take to complete the same operation synchronously. In these situations,
    you can run the method synchronously and return a task.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，准备和启动异步操作所需的时间可能比同步完成相同操作所需的时间更长。在这些情况下，您可以同步运行该方法并返回一个任务。
- en: Exceptions
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: Usage errors, such as passing `null` arguments, are the only errors that should
    be raised in asynchronous methods. You can prevent asynchronous methods from raising
    usage errors by modifying the calling code to ensure that erroneous arguments
    are not passed into the asynchronous methods. All other types of exceptions and
    errors should be assigned to the task being returned. Normally, one exception
    is returned by one task. But when there are multiple operations represented by
    a single task, multiple exceptions may be returned by a single task.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用错误，如传递`null`参数，是异步方法中应该抛出的唯一错误。您可以通过修改调用代码来防止异步方法抛出使用错误，确保错误参数不会传递到异步方法中。所有其他类型的异常和错误应分配给返回的任务。通常，一个任务返回一个异常。但当单个任务表示多个操作时，单个任务可能会返回多个异常。
- en: Optional cancellation
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选取消
- en: Cancellation of asynchronous method implementers and consumers is optional.
    An asynchronous method that can be canceled, exposes an overload method that accepts
    a `CancellationToken` that is named `cancellationToken` by convention.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法实现者和消费者的取消是可选的。可以取消的任务公开了一个接受名为`cancellationToken`的`CancellationToken`的重载方法。
- en: Cancellation requests are monitored by the asynchronous operation. When a cancellation
    request is received, it may be honored. If cancellation results in unfinished
    work, a task in the `Canceled` state is returned with no available result and
    no exceptions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 异步操作的取消请求被监控。当收到取消请求时，可能会被接受。如果取消导致未完成的工作，将返回一个`Canceled`状态的任务，没有可用的结果和没有异常。
- en: The `Canceled` state is a completed task state, as are `RanToCompletion` and
    `Faulted`. When a task's state is either `Canceled`, `RanToCompletion`, or `Faulted`,
    the `IsCompleted` property returns `true`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canceled`状态是一个已完成的任务状态，`RanToCompletion`和`Faulted`也是如此。当一个任务的状态是`Canceled`、`RanToCompletion`或`Faulted`时，`IsCompleted`属性返回`true`。'
- en: Continuations will continue to be scheduled and executed when a task is canceled
    unless the `NotOnCancelled` continuation option is specified. If this option is
    specified, then continuations will not be scheduled or executed when a task is
    canceled.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当任务被取消时，除非指定了`NotOnCancelled`延续选项，否则延续将继续被安排和执行。如果指定了此选项，则在任务被取消时，延续将不会被安排或执行。
- en: Asynchronous code waiting for canceled tasks via language features will continue
    to run but will receive an `OperationCanceledException` or one of its derivatives.
    And code that is blocked synchronously waiting on tasks through methods like `Wait`
    and `WaitAll` will continue to run with an exception.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过语言功能等待取消任务的异步代码将继续运行，但将接收到`OperationCanceledException`或其派生异常。而通过`Wait`和`WaitAll`等方法同步阻塞等待任务的代码将继续运行，并抛出异常。
- en: 'TAP methods should return a `Canceled` task when a cancellation token has requested
    cancellation before the TAP method that accepts the token has been called. During
    the execution of an asynchronous operation, cancellation requests can be ignored.
    When returning a task, you will normally return the task with one of three states:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当取消令牌在接受该令牌的 TAP 方法被调用之前请求取消时，TAP 方法应返回一个`Canceled`任务。在异步操作执行期间，可以忽略取消请求。在返回任务时，通常返回具有以下三种状态之一的任务：
- en: '`Canceled`: The operation has ended as a result of a cancellation request.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Canceled`：操作因取消请求而结束。'
- en: '`RanToCompletion`: A cancellation was requested but the operation was completed
    and produced a result.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RanToCompletion`：请求取消操作已完成并生成了结果。'
- en: '`Faulted`: A cancellation was requested that resulted in the generation of
    an exception.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Faulted`：请求取消导致生成了异常。'
- en: If you are coding an asynchronous method and want to enable the operation to
    be canceled first and foremost, then there is no need to produce an overload method
    devoid of a `CancellationToken`. If you are coding an asynchronous method that
    cannot be canceled, then you do not have to provide an overload method that accepts
    a `CancellationToken`. These guidelines help the caller to know whether or not
    the target method can be canceled. When a method that accepts a `CancellationToken`
    is called by a consumer that has no desire to cancel the method call, `None` can
    be passed in for the `CancellationToken` argument, as this is functionally equivalent
    to the default `CancellationToken`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写异步方法，并希望首先启用操作可取消，则不需要生成一个没有`CancellationToken`的重载方法。如果你正在编写无法取消的异步方法，则不需要提供接受`CancellationToken`的重载方法。这些指南有助于调用者了解目标方法是否可取消。当调用接受`CancellationToken`的方法的消费者没有取消方法调用的意愿时，可以将`None`传递给`CancellationToken`参数，因为这功能上等同于默认的`CancellationToken`。
- en: Optional Progress Reporting
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选进度报告
- en: When asynchronous operations are running as part of a UI procedure, it can be
    beneficial to provide progress updates. This helps the end user to know that the
    program is still working.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当异步操作作为 UI 流程的一部分运行时，提供进度更新可能是有益的。这有助于最终用户知道程序仍在运行。
- en: The `IProgress<T>` interface is used to handle progress and is passed into an
    asynchronous method as a parameter that is conventionally called `progress`. Passing
    this interface into an asynchronous method can help prevent race conditions that
    can occur when event handlers are incorrectly registered once the operation has
    started, which can lead to missed updates. Another reason for passing in an interface
    is that consuming code can support various progress implementations. Only provide
    an `IProgress<T>` interface when progress notifications are supported by the TAP
    implementation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`IProgress<T>`接口用于处理进度，并将其作为名为`progress`的参数传递给异步方法。将此接口传递给异步方法可以帮助防止在操作开始后错误注册事件处理器时可能发生的竞争条件，这可能导致更新丢失。将接口传递的另一个原因是，消费代码可以支持各种进度实现。只有当
    TAP 实现支持进度通知时，才提供`IProgress<T>`接口。'
- en: An example that fits well with progress updates is the `FindFilesAsync` method,
    which returns a list of files meeting a particular search pattern. In this scenario,
    you could provide the percentage of work completed along with the current set
    of partial results. The information would be provided by some data type that is
    specific to your API. Such data types are conventionally suffixed with `ProgressInfo`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与进度更新很好地匹配的示例是 `FindFilesAsync` 方法，该方法返回满足特定搜索模式的文件列表。在这种情况下，您可以提供已完成的工作百分比以及当前的中间结果集。这些信息将由特定于您的
    API 的某些数据类型提供。这些数据类型通常以 `ProgressInfo` 后缀结尾。
- en: TAP methods that provide a progress parameter should allow no progress reporting
    by allowing the progress parameter to be `null`. Progress should be reported to
    the `Progress<T>` object that implements the `IProgress<T>` interface synchronously.
    This enables the asynchronous method to quickly provide progress. Consumers can
    then determine how and where they want to handle the information provided by the
    progress update.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 提供进度参数的 TAP 方法应允许不进行进度报告，通过允许进度参数为 `null`。进度应同步报告给实现 `IProgress<T>` 接口的 `Progress<T>`
    对象。这使异步方法能够快速提供进度。消费者可以确定他们想要如何以及在哪里处理进度更新提供的信息。
- en: The `ProgressChanged` event is exposed by instances of the `Progress<T>` class.
    This event is raised every time a progress update is reported by the asynchronous
    operation. When a `Progress<T>` object is instantiated, the `ProgressChanged`
    event is raised on the captured `SynchronizationContext` object. A default context
    that targets the thread pool is used when there is no synchronization context
    available.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgressChanged` 事件由 `Progress<T>` 类的实例公开。每次异步操作报告进度更新时都会触发此事件。当 `Progress<T>`
    对象被实例化时，`ProgressChanged` 事件在捕获的 `SynchronizationContext` 对象上触发。如果没有可用同步上下文，则使用针对线程池的目标上下文作为默认上下文。'
- en: You can either register handlers for this event as you would any other event,
    and you can also provide the `Progress<T>` constructor with a single handler,
    for convenience. The single handler behaves the same as an event handler for the
    `ProgressChanged` event. During the execution of event handlers, delays to asynchronous
    operations are avoided by raising progress updates asynchronously.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像注册任何其他事件的处理程序一样注册此事件的处理程序，并且您还可以向 `Progress<T>` 构造函数提供一个处理程序，以方便起见。单个处理程序的行为与
    `ProgressChanged` 事件的处理器相同。在执行事件处理器期间，通过异步地发出进度更新来避免对异步操作的延迟。
- en: Now that we have a high-level understanding of the task-based asynchronous pattern,
    in the next section, we will look at `async`, `await`, and `Task`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对基于任务的异步模式有了高级别的理解，在下一节中，我们将探讨 `async`、`await` 和 `Task`。
- en: async, await, and Task
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: async、await 和 Task
- en: In this section, we will be looking at the performance differences between running
    methods synchronously, using `Task.Run`, and asynchronously. An asynchronous method
    is identified by the `async` keyword.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨同步运行方法、使用 `Task.Run` 和异步运行方法之间的性能差异。异步方法通过 `async` 关键字来标识。
- en: The `await` keyword informs the runtime to wait at the specified line until
    the current task has been completed. It can only be used with a method that is
    prefixed with the `async` keyword.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`await` 关键字通知运行时在指定行等待，直到当前任务完成。它只能与前面带有 `async` 关键字的方法一起使用。'
- en: The `System.Threading.Tasks` namespace. A task encapsulates threading in order
    to maximize the use of multiple cores on computer hardware.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Threading.Tasks` 命名空间。任务封装了线程，以便最大化利用计算机硬件的多核。'
- en: Let's write a simple project to benchmark three different ways of calling a
    method. We will call the method synchronously using `Task.Run`, and asynchronously
    using `async/await`. We will be using `BenchmarkDotNet` to see how each method
    call type performs. We aim to show the performance advantage of using asynchronous
    calls over synchronous and `Task.Run` calls.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的项目来基准测试调用方法的三种不同方式。我们将使用 `Task.Run` 同步调用该方法，并使用 `async/await` 异步调用。我们将使用
    `BenchmarkDotNet` 来查看每种方法调用类型的性能。我们的目标是展示使用异步调用相对于同步和 `Task.Run` 调用的性能优势。
- en: 'We perform the following steps to write our little program:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行以下步骤来编写我们的小程序：
- en: Start a new .NET 6.0 console application and call it `CH16_AsynchronousProgramming`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的 .NET 6.0 控制台应用程序，并将其命名为 `CH16_AsynchronousProgramming`。
- en: Add the `BenchmarkDotNet` NuGet package.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `BenchmarkDotNet` NuGet 包。
- en: 'Add a new class called `Benchmarks`, and in that class add the following method:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Benchmarks` 的新类，并在该类中添加以下方法：
- en: '[PRE0]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This method is our worker method. All it does is increment the `y` variable
    by one for ten iterations.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法是我们的工作方法。它所做的只是将`y`变量增加1，重复十次。
- en: 'Add the `SynchronousMethod` to the class:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SynchronousMethod`添加到类中：
- en: '[PRE1]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This method calls the `LengthyTask` method synchronously and is a benchmark.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法同步调用`LengthyTask`方法，并作为一个基准测试。
- en: 'Add the `TaskMethod` to the class:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`TaskMethod`添加到类中：
- en: '[PRE2]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This method runs the `LengthyTask` method as a new `Action`, which is queued
    to run on the `ThreadPool`. A `Task` or `Task<Tresult>` handle is returned for
    that method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将`LengthyTask`方法作为一个新的`Action`运行，该`Action`被排队在`ThreadPool`上运行。该方法返回一个`Task`或`Task<Tresult>`句柄。
- en: 'Add the `AsynchronousTaskMethod` to the class:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AsynchronousTaskMethod`添加到类中：
- en: '[PRE3]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method runs the `LengthyTask` method as an action using `Task.Run` asynchronously,
    and await the completion of the method before it continues.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法以异步方式使用`Task.Run`运行`LengthyTask`方法，并在继续之前等待方法完成。
- en: 'Our benchmark class is now complete. So, in the `Program.cs` file, replace
    the code with the following:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经完成了基准测试类。因此，在`Program.cs`文件中，将代码替换为以下内容：
- en: '[PRE4]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code will run our benchmarks and produce a report for us.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将运行我们的基准测试并为我们生成报告。
- en: Make sure that the project is set to `Release` build.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保项目设置为`Release`构建。
- en: Build the project.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目。
- en: Open a command window and execute the compiled executable file called `CH16_AsynchronousProgramming.exe`
    in the `bin\Release\net6.0` folder.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令窗口，并在`bin\Release\net6.0`文件夹中执行名为`CH16_AsynchronousProgramming.exe`的编译后的可执行文件。
- en: 'The benchmarks should start running, and once complete, you should see a report
    like the one shown in *Figure 16.1*:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基准测试应该开始运行，一旦完成，您应该看到一个类似于*图16.1*所示的报告：
- en: '![Figure 16.1 – The BenchmarkDotNet report for our CH16_AsynchronusProgramming
    Project'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.1 – BenchmarkDotNet报告，针对我们的CH16_AsynchronusProgramming项目'
- en: '](img/B16617_Figure_16.1.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_16.1.jpg)'
- en: Figure 16.1 – The BenchmarkDotNet report for our CH16_AsynchronusProgramming
    Project
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 – BenchmarkDotNet报告，针对我们的CH16_AsynchronusProgramming项目
- en: As you can see in *Figure 16.1*, running the `LengthyTask` method synchronously
    took `7.3220 ns` to complete. Using `Task.Run` took the longest time to run at
    `112.4494 ns`. And the fastest way to run the code was asynchronously, which only
    took `0.9982ns` to complete.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在*图16.1*中可以看到，同步运行`LengthyTask`方法耗时`7.3220 ns`完成。使用`Task.Run`运行耗时最长，为`112.4494
    ns`。而运行代码最快的方式是异步，只需`0.9982ns`即可完成。
- en: We can clearly see from those times that there is a clear performance benefit
    to running our code asynchronously, as it takes less overall time for our code
    to complete.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这些时间中清楚地看到，运行我们的代码异步确实有明显的性能优势，因为我们的代码完成所需的总时间更少。
- en: In the next section, we will compare the performance of `await` with `GetAwaiter.GetResult()`,
    `.Result`, and `.Wait`. We will cover both `Task` and `ValueTask`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将比较`await`与`GetAwaiter.GetResult()`、`.Result`和`.Wait`的性能。我们将涵盖`Task`和`ValueTask`。
- en: Benchmarking GetAwaiter.GetResult(), .Result, and .Wait for both Task and ValueTask
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对Task和ValueTask的GetAwaiter.GetResult()、.Result和.Wait进行基准测试
- en: In this section, we will be writing some code to benchmark the `GetAwaiter.GetResult()`,
    `.Result`, and `.Wait` methods to see which method is best for obtaining the return
    value for both a `Task` and a `ValueTask`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一些代码来基准测试`GetAwaiter.GetResult()`、`.Result`和`.Wait`方法，以查看哪种方法最适合获取`Task`和`ValueTask`的返回值。
- en: 'At [https://github.com/dotnet/BenchmarkDotNet/issues/236](https://github.com/dotnet/BenchmarkDotNet/issues/236),
    the `BenchmarkDotNet` maintainer called *adamsitnik* wrote in reply to *@i3arnon*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://github.com/dotnet/BenchmarkDotNet/issues/236](https://github.com/dotnet/BenchmarkDotNet/issues/236)，`BenchmarkDotNet`的维护者*adamsitnik*回复了*@i3arnon*：
- en: '*"@i3arnon Thanks for the hint! I have measured* `.Result` *vs* `.Wait` *vs*
    `GetAwaiter.GetResult()` *and it seems that for* `Tasks` *the* `GetAwaiter.GetResult()`
    *is also the fastest way to go. On the other hand, for* `ValueTask` *it was much
    more slower so I stayed with* `.Result` *for VT*."'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: “@i3arnon 谢谢提示！我已经测量了`.Result`与`.Wait`与`GetAwaiter.GetResult()`的比较，对于`Tasks`来说，`GetAwaiter.GetResult()`似乎也是最快的方式。另一方面，对于`ValueTask`来说，它要慢得多，所以我继续使用`.Result`来处理VT。”
- en: And so, from the code that we will be writing, we should see that `.Result`
    should provide us with the best performance when working with a `ValueTask`. And
    `GetAwaiter.GetResult()` should give us the best performance when working with
    a `Task`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从我们将要编写的代码中，我们应该看到`.Result`在处理`ValueTask`时应该提供给我们最佳的性能。而`GetAwaiter.GetResult()`在处理`Task`时应该提供给我们最佳的性能。
- en: 'We will now start writing our code. Please complete the following tasks in
    the `CH16_AsynchronousProgramming` project that we started in the previous section:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开始编写我们的代码。请在上一节中开始的 `CH16_AsynchronousProgramming` 项目中完成以下任务：
- en: Open the `CH16_AsynchronousProgramming` project.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `CH16_AsynchronousProgramming` 项目。
- en: Open the `Benchmarks` class.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Benchmarks` 类。
- en: 'Add the following method that returns an `int`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下返回 `int` 的方法：
- en: '[PRE5]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code, we are incrementing the `y` variable and returning the result.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们增加 `y` 变量并返回结果。
- en: 'Add the `GetAwaiterGetResult` method:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `GetAwaiterGetResult` 方法：
- en: '[PRE6]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method benchmarks the time taken to return an `int` from a method using
    `GetAwaiter().GetResult()`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法基准测试了使用 `GetAwaiter().GetResult()` 从方法返回 `int` 所花费的时间。
- en: 'Add the `Result` method:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `Result` 方法：
- en: '[PRE7]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method benchmarks the time taken to await the return of `int` from a method.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法基准测试了等待方法返回 `int` 所花费的时间。
- en: 'Add the `Wait` method:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `Wait` 方法：
- en: '[PRE8]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This method runs a lengthy task and waits for it to finish before continuing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法运行一个长时间的任务，并在它完成之前等待。
- en: 'Add the `GetAwaiter` method:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `GetAwaiter` 方法：
- en: '[PRE9]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method gets an awaiter used to await the task completion.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法获取一个用于等待任务完成的等待者。
- en: 'Build the project and run the executable via the command line. You should see
    a summary report like the one shown in *Figure 16.2*:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并通过命令行运行可执行文件。你应该会看到一个类似于 *图 16.2* 所示的总结报告：
- en: '![Figure 16.2 – The BenchmarkDotNet summary report for this section''s methods'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 16.2 – 本节方法的 BenchmarkDotNet 总结报告]'
- en: '](img/B16617_Figure_16.2.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 16.2 – 本节方法的 BenchmarkDotNet 总结报告]'
- en: Figure 16.2 – The BenchmarkDotNet summary report for this section's methods
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.2 – 本节方法的 BenchmarkDotNet 总结报告
- en: As we can see from these results, when returning a value from a `Task`, the
    `GetAwaiterGetResult` method operates much faster than the `Result` method. And
    when executing a long-running `Task`, the `GetAwaiter` method operates much more
    quickly than the `Wait` method.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些结果中我们可以看出，当从 `Task` 返回值时，`GetAwaiterGetResult` 方法比 `Result` 方法运行得快得多。并且当执行长时间运行的
    `Task` 时，`GetAwaiter` 方法比 `Wait` 方法运行得更快。
- en: In the next section, we will look at how we can speed up our code asynchronously
    when awaiting multiple tasks by using `WhenAll`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何通过使用 `WhenAll` 来加快我们异步等待多个任务时的代码。
- en: Using async, await, and WhenAll
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 async、await 和 WhenAll
- en: In this section, we will write some example code that demonstrates the use of
    `async`, `await`, and `WhenAll` and the effect on execution time.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一些示例代码，演示 `async`、`await` 和 `WhenAll` 的使用及其对执行时间的影响。
- en: If you have multiple tasks that are being executed in a method and you `await`
    each task, your code will work asynchronously, and the execution time will be
    expensive. You can circumvent this time expense with improved performance by using
    `WhenAll` to `await` all completed tasks before continuing. In the code we will
    be writing, you will see how `WhenAll` reduces the time taken to execute two asynchronous
    methods within a function when compared to awaiting each task in turn.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个方法中执行多个任务，并且对每个任务都使用 `await`，你的代码将以异步方式工作，执行时间将会很长。你可以通过使用 `WhenAll` 在继续之前等待所有完成的任务来避免这种时间开销，从而提高性能。在我们将要编写的代码中，你将看到
    `WhenAll` 如何减少在函数内部执行两个异步方法所需的时间，与逐个等待每个任务相比。
- en: 'Let''s work our way through the following tasks:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步完成以下任务：
- en: 'In the `Benchmarks` class still, add the following asynchronous method, which
    waits `300` milliseconds before returning an `int`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Benchmarks` 类中，添加以下异步方法，该方法等待 `300` 毫秒然后返回一个 `int`：
- en: '[PRE10]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `TaskOne` method is the first of our methods that will be run by our benchmarks.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskOne` 方法是我们将要由基准测试运行的方法之一。'
- en: 'Add the second of our asynchronous methods:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加我们的第二个异步方法：
- en: '[PRE11]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `TaskTwo` method waits for `300` milliseconds and then returns a `string`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskTwo` 方法等待 `300` 毫秒然后返回一个 `string`。'
- en: 'Firstly, we will benchmark running asynchronous tasks synchronously:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将基准测试同步运行异步任务：
- en: '[PRE12]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we have two tasks and we `await` them both to complete before continuing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个任务，我们需要等待它们都完成后再继续。
- en: 'Now, we''ll add our method that will utilize `WhenAll`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个方法，它将利用 `WhenAll`：
- en: '[PRE13]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this method, we create our two tasks, then we pass them into the `WhenAll`
    method as parameters. We do not continue until all tasks are complete.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，我们创建了我们的两个任务，然后将它们作为参数传递给 `WhenAll` 方法。我们不会继续，直到所有任务都完成。
- en: 'Build and run your executable via the command line. You should see something
    like *Figure 16.3*:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过命令行构建和运行您的可执行文件。您应该会看到类似 *图 16.3* 的内容：
- en: '![Figure 16.3 – The results of synchronous and asynchronous execution of multiple
    asynchronous calls'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 16.3 – 多个异步调用的同步和异步执行结果'
- en: '](img/B16617_Figure_16.3.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_16.3.jpg)'
- en: Figure 16.3 – The results of synchronous and asynchronous execution of multiple
    asynchronous calls
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3 – 多个异步调用的同步和异步执行结果
- en: As you can see from the results of our benchmarking, using `WhenAll` executes
    multiple asynchronous tasks much faster than when you await them in turn. In the
    next section, we will look at canceling asynchronous tasks.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的基准测试结果中可以看出，使用 `WhenAll` 执行多个异步任务比依次等待它们要快得多。在下一节中，我们将探讨如何取消异步任务。
- en: Canceling asynchronous operations
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消异步操作
- en: In this section, we will look at how we can cancel long-running asynchronous
    operations. Sometimes a task will take longer than it should do. A good example
    of this is fetching data from a website when it goes down. Asynchronous operations
    can take a long time before they are reset by the server due to something like
    `Error 404`, `Error 401`, or `Error 500` for example. And so, it pays to have
    the ability to cancel an asynchronous operation after a set period to prevent
    wasting an end user's time.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何取消长时间运行的自异步操作。有时一个任务会花费比预期更长的时间。一个很好的例子是在网站宕机时从网站获取数据。由于像 `Error
    404`、`Error 401` 或 `Error 500` 这样的原因，异步操作可能需要很长时间才能由服务器重置。因此，在设置的时间后取消异步操作以防止浪费最终用户的时间是很有用的。
- en: 'The code we will write will return the text from a website URL. We will assign
    a very short timeout. This timeout will cancel the task that is responsible for
    returning the website text. Follow these steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的代码将从网站 URL 返回文本。我们将分配一个非常短的超时时间。这个超时将取消负责返回网站文本的任务。按照以下步骤操作：
- en: Open the `CH16_AsynchronousProgramming` project, and add a new class called
    `TaskCancellation`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `CH16_AsynchronousProgramming` 项目，并添加一个名为 `TaskCancellation` 的新类。
- en: Add the `using System.Text;` statement.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `using System.Text;` 语句。
- en: 'Add the following two member variables:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下两个成员变量：
- en: '[PRE14]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `_website` variable holds the URL of the website whose page text we will
    be returning. And the `CancellationTokenSource` will be used to signal to a `CancellationToken`
    that it should be cancelled.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`_website` 变量持有我们将返回其页面文本的网站的 URL。`CancellationTokenSource` 将用于向 `CancellationToken`
    发送取消信号。'
- en: 'Add the following method:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法：
- en: '[PRE15]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we declare a method that returns a `HttpClient` for our HTTP request.
    The `MaxResponseContentBufferSize` sets the number of bytes to buffer when reading
    the response content.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明一个方法，该方法返回用于我们的 HTTP 请求的 `HttpClient`。`MaxResponseContentBufferSize`
    设置在读取响应内容时缓冲的字节数。
- en: 'Now add the `ReturnWebsiteTextAsync` method:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加 `ReturnWebsiteTextAsync` 方法：
- en: '[PRE16]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this method, we declare `HttpResponseMessage`, which awaits an asynchronous
    task that returns the contents of a web page. The response is then read and converted
    into a byte array. This byte array is then transformed into an ASCII string and
    returned.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，我们声明 `HttpResponseMessage`，它等待一个异步任务，该任务返回网页的内容。然后读取响应并将其转换为字节数组。然后，这个字节数组被转换成
    ASCII 字符串并返回。
- en: 'Now add the `Start` method:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加 `Start` 方法：
- en: '[PRE17]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the `Start` method, we write a console message that states the task has started.
    We then set the cancellation time of `cancellationTokenSource` to 30 seconds,
    which is 3000 milliseconds. Then we `await` the call to the `ReturnWebsiteTextAsync`.
    If the process times out after the set timeout period, an `OperationCanceledException`
    is raised, which outputs a message to the console. Finally, `cancellationTokenSource`
    is disposed of and a console message is an output stating that the task is finished.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Start` 方法中，我们写入一个控制台消息，表明任务已开始。然后我们将 `cancellationTokenSource` 的取消时间设置为 30
    秒，即 3000 毫秒。然后我们 `await` 调用 `ReturnWebsiteTextAsync`。如果在设置的超时时间后进程超时，将引发 `OperationCanceledException`，它将在控制台输出一条消息。最后，`cancellationTokenSource`
    被释放，并输出一条控制台消息，表明任务已完成。
- en: 'Comment out the benchmark running code in the `Program.cs` file, and add the
    following line:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中注释掉基准运行代码，并添加以下行：
- en: '[PRE18]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Run the project and try it several times with different timeout periods to test
    the code completing successfully and returning text, and to test the operation
    timing out and raising an exception.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行项目，并尝试使用不同的超时时间多次运行，以测试代码成功完成并返回文本，以及测试操作超时并引发异常。
- en: Running this code through a couple of times with timeouts of `3000` and `30000`
    will present an operation timeout exception and display the web page text, respectively.
    As you can see if you run the code yourself, it is very easy to write asynchronous
    tasks that are canceled after a set period.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几次运行此代码并设置超时为`3000`和`30000`，将分别呈现操作超时异常并显示网页文本。正如你自己运行代码时可以看到的，编写在设定时间段后取消的任务的异步任务是很容易的。
- en: In the next section, we will be writing code that shows how to write files asynchronously.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将编写代码来展示如何异步地写入文件。
- en: Writing files asynchronously
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步写入文件
- en: In this section, we will write text to a file asynchronously. Scenarios where
    asynchronous file writing can be useful include writing large volumes of text
    and data to files that will not be read immediately.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将异步地将文本写入文件。异步文件写入可能有用的场景包括将大量文本和数据写入不会立即读取的文件。
- en: 'Use the following steps to write our code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤来编写我们的代码：
- en: On your `C:\` drive, add a folder called `Temp` if one does not already exist.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`C:\`驱动器上，如果您还没有创建一个名为`Temp`的文件夹，请添加一个。
- en: Open the `CH16_AsynchronousProgramming` project.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`CH16_AsynchronousProgramming`项目。
- en: Add a class called `FileReadWriteAsync`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`FileReadWriteAsync`的类。
- en: 'Add the following method:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法：
- en: '[PRE19]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `WriteTextAsync` method, we declare a file path for a text file and a
    variable that contains the text to be written to the file. The text to be written
    gets converted into a byte array. A writable asynchronous file stream is then
    opened in append mode. Then we write the text to the file stream and close it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WriteTextAsync`方法中，我们声明一个文本文件的文件路径和一个包含要写入文件的文本的变量。要写入的文本被转换为字节数组。然后以追加模式打开一个可写的异步文件流。然后我们将文本写入文件流并关闭它。
- en: In the next section, we continue in this class as we add our asynchronous read
    method that shows how to read a file asynchronously.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续在本节课中添加我们的异步读取方法，展示如何异步地读取文件。
- en: Reading files asynchronously
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步读取文件
- en: In this section, we will read text from a file asynchronously. We will be building
    upon the code from the previous section that writes the text to a file asynchronously.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将异步地从文件中读取文本。我们将基于上一节中写入文本到文件的代码进行构建。
- en: 'The following steps will add our asynchronous read method and update the `Program.cs`
    file to run our asynchronous code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将添加我们的异步读取方法并更新`Program.cs`文件以运行我们的异步代码：
- en: 'In the `FileReadWriteAsync` class, add the following method:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FileReadWriteAsync`类中，添加以下方法：
- en: '[PRE20]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we define the path of the file that we need to read. Then we open a file
    stream in read mode with read access. Next, we define `StringBuilder` and byte
    array that will act as our buffer to store read data. We then read the stream
    until the read has been completed. During each iteration of the read, we read
    the text from the file, encode it into Unicode, and then append it to `StringBuilder`.
    Then, once the loop has finished and exits, we return the string from the method.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了需要读取的文件的路径。然后我们以读取模式打开一个文件流，具有读取访问权限。接下来，我们定义`StringBuilder`和字节数组，它们将作为我们的缓冲区来存储读取的数据。然后我们读取流，直到读取完成。在每次读取迭代中，我们从文件中读取文本，将其编码为Unicode，然后将其追加到`StringBuilder`。然后，一旦循环完成并退出，我们从方法中返回字符串。
- en: Open the `Program.cs` class.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Program.cs`类。
- en: 'Comment out the following lines:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉以下行：
- en: '[PRE21]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We won't be needing these lines when we run our code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，我们不需要这些行。
- en: 'Add the following lines of code:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码行：
- en: '[PRE22]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this code, we call our methods that write text to a file asynchronously,
    read the text asynchronously into a variable, and then print the contents of the
    variable to the console.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们调用将文本异步写入文件的方法，异步地将文本读取到变量中，然后将变量的内容打印到控制台。
- en: 'Run the code, and you should see something like *Figure 16.3*:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，你应该会看到类似于*图16.3*的内容：
- en: '![Figure 16.4 – The result of our asynchronous write and read code'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 16.4 – 我们异步写入和读取代码的结果]'
- en: '](img/B16617_Figure_16.4.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16617_Figure_16.4.jpg]'
- en: Figure 16.4 – The result of our asynchronous write and read code
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4 – 我们异步写入和读取代码的结果
- en: As you can see from the screenshot, we have successfully written text asynchronously
    to a file, asynchronously read it from that file, and printed the contents to
    the console window.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如从截图所示，我们已经成功地将文本异步写入文件，从该文件异步读取，并将内容打印到控制台窗口。
- en: In the next section, we will summarize what we have learned in this chapter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将总结本章所学的内容。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we began with a high-level overview of the task-based asynchronous
    pattern. Things we covered were naming, parameters, return types, initializing
    asynchronous operations, exceptions, and optionally providing ways to report progress
    updates and cancel operations. We saw that we can have asynchronous operations
    that allow cancellation, and those that don't allow cancellation. Plus, we learned
    that when a cancellation has been requested, the cancellation will either go ahead
    or be ignored. Completed tasks can have a completed state of `Canceled`, `RanToCompletion`,
    or `Faulted`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们从基于任务的异步模式的高级概述开始。我们涵盖了命名、参数、返回类型、初始化异步操作、异常，以及可选地提供报告进度更新和取消操作的方法。我们了解到，我们可以有允许取消的异步操作，以及不允许取消的异步操作。此外，我们还了解到，当请求取消时，取消请求要么继续进行，要么被忽略。已完成的任务可以具有`已取消`、`已运行完成`或`已出错`的完成状态。
- en: We then benchmarked three different ways of calling a method synchronously,
    using `Task.Run`, and asynchronously. Using `Task.Run` took the longest time,
    followed by running the method synchronously, and running the method asynchronously
    was by far the quickest way to run the method.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对三种不同的同步调用方法、使用`Task.Run`和异步调用进行了基准测试。使用`Task.Run`花费的时间最长，其次是同步运行方法，而异步运行方法是运行该方法的最快方式。
- en: Then we benchmarked `GetAwaiter.GetResult()`, `Result`, and `Wait` for both
    `Task` and `TaskValue`. We saw that when returning a value from a `Task`, the
    `GetAwaiterGetResult` method operates much faster than the `Result` method. And
    when executing a long-running `Task`, the `GetAwaiter` method operates much more
    quickly than the `Wait` method.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对`GetAwaiter.GetResult()`、`Result`和`Wait`方法在`Task`和`TaskValue`上的性能进行了基准测试。我们发现，当从`Task`返回值时，`GetAwaiterGetResult`方法比`Result`方法运行得快得多。而在执行长时间运行的`Task`时，`GetAwaiter`方法比`Wait`方法运行得更快。
- en: Next, we looked at cancelling asynchronous operations. We coded an example that
    obtains the text from a website and outputs the text to the console. If the operation
    fails to complete within a set period of time, then it is cancelled.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了取消异步操作。我们编写了一个示例，从网站获取文本并将文本输出到控制台。如果操作在设定的时间内未能完成，则取消操作。
- en: In the final two sections, we wrote some code to demonstrate the writing and
    reading of text and data asynchronously.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两个部分中，我们编写了一些代码来演示文本和数据异步的读写。
- en: To complete this chapter, there are some questions for you to answer to see
    how well you have retained what you have read and some further reading on asynchronous
    programming.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一章，有一些问题供你回答，以检验你对所读内容的掌握程度，以及一些关于异步编程的进一步阅读材料。
- en: Thank you for purchasing this book. I hope you have enjoyed reading it, and
    that you have learned plenty of ways to improve your own code. Happy coding!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您购买这本书。希望您喜欢阅读它，并且学到了许多改进您自己代码的方法。祝您编码愉快！
- en: Questions
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does TAP stand for?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TAP代表什么？
- en: What parameter type identifies that an asynchronous operation can be canceled?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种参数类型标识异步操作可以被取消？
- en: What parameter type is passed into an asynchronous task to provide progress
    updates?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将哪种参数类型传递给异步任务以提供进度更新？
- en: Explain `async`, `await`, and `Task`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释`async`、`await`和`Task`。
- en: How do you cancel an asynchronous operation?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何取消异步操作？
- en: How do you report on an asynchronous operation's progress?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何报告异步操作进度？
- en: Further reading
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Asynchronous programming; APM vs EAP: [https://stackoverflow.com/questions/11276314/asynchronous-programming-apm-vs-eap](https://stackoverflow.com/questions/11276314/asynchronous-programming-apm-vs-eap)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程；APM与EAP的比较：[https://stackoverflow.com/questions/11276314/asynchronous-programming-apm-vs-eap](https://stackoverflow.com/questions/11276314/asynchronous-programming-apm-vs-eap)
- en: 'Asynchronous programming: [https://docs.microsoft.com/en-us/dotnet/csharp/async](https://docs.microsoft.com/en-us/dotnet/csharp/async)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程：[https://docs.microsoft.com/en-us/dotnet/csharp/async](https://docs.microsoft.com/en-us/dotnet/csharp/async)
- en: 'Introduction to async programming in C#: [https://auth0.com/blog/introduction-to-async-programming-in-csharp/](https://auth0.com/blog/introduction-to-async-programming-in-csharp/)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#中异步编程的介绍：[https://auth0.com/blog/introduction-to-async-programming-in-csharp/](https://auth0.com/blog/introduction-to-async-programming-in-csharp/)
- en: 'The performance characteristics of async methods in C#: [https://devblogs.microsoft.com/premier-developer/the-performance-characteristics-of-async-methods/](https://devblogs.microsoft.com/premier-developer/the-performance-characteristics-of-async-methods/)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 中异步方法的性能特性：[https://devblogs.microsoft.com/premier-developer/the-performance-characteristics-of-async-methods/](https://devblogs.microsoft.com/premier-developer/the-performance-characteristics-of-async-methods/)
- en: 'Exception Handling (Task Parallel Library): [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/exception-handling-task-parallel-library](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/exception-handling-task-parallel-library)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理（任务并行库）：[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/exception-handling-task-parallel-library](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/exception-handling-task-parallel-library)
