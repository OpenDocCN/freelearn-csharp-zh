<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-128"><a id="_idTextAnchor212"/>6</h1>
<h1 id="_idParaDest-129"><a id="_idTextAnchor213"/>SOLID Principles, from Code to Systems</h1>
<p>Starting from this chapter, we are going to step away from the theoretical part and, while we are not yet starting to code (this will start in <a href="B21293_13.xhtml#_idTextAnchor470"><em class="italic">Chapter 13</em></a>), we will start applying the theory to designing a small information system made of several applications. We will decompose the different functions, show how they help produce business process outcomes and create the software behind these functions. To do so, we will design the different components and the API contracts for the services involved, and think of how the data should be designed and governed. And in <a href="B21293_13.xhtml#_idTextAnchor470"><em class="italic">Chapter 13</em></a>, we will use all of this design phase to actually implement the sample information system.</p>
<p>Of course, this information system will be reduced in perimeter and complexity, but the exercise has been designed to include most of the important decisions that should be made. You will find strict responsibility separation, nice separation between processes and functions, decoupling of the service through APIs, standardization of the contracts, best-of-breed approach, adapting the software stack to the functions desired, independence between the software and the hardware, and lots of other principles.</p>
<p>In this chapter, we will start designing our demonstration system by thinking of the functions it should expose. To do so, we will <a id="_idIndexMarker318"/>use the <strong class="bold">SOLID principles</strong>, extending them to information systems. SOLID is the acronym composed of the first letters of the five essential principles of software development, which are the following:</p>
<ul>
<li><strong class="bold">Single responsibility</strong> states that one module should only do one thing</li>
<li><strong class="bold">Open/closed</strong> differentiates between open to evolution and closed to modification</li>
<li><strong class="bold">Liskov’s</strong> principle explains how substitution should work</li>
<li><strong class="bold">Interface segregation</strong> follows with how contracts should be strongly aligned to business functions</li>
<li>Finally, <strong class="bold">dependency inversion</strong> deals with coupling and how it should be done, at the inverse of what seems natural in most cases</li>
</ul>
<p>It happens that these <a id="_idIndexMarker319"/>principles, often applied to software applications, actually apply to every software system and constitute a great way to design their different modules. We will thus use them to design our sample information system. But first, we need to describe the business requirements for this system<a id="_idTextAnchor214"/>.</p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor215"/>Describing the sample information system requirements</h1>
<p>Before any<a id="_idIndexMarker320"/> kind of analysis, we will imagine what the system owner would want from it. Of course, as we explained, time is a very important constraint in information systems design, which has a long life, and we will simulate the fact that we do not know everything about the requirements at first. In particular, the last chapters of the book will simulate the fact that new requirements arise for the imaginary company owning the information system, and explain how the system will adapt to it. This point is particularly important because the main goal of this book is to show how a system should be created or adapted so that its evolution is simpler in time.</p>
<p>To make the exercise as realistic as possible, while keeping it simple for it to be contained in a single book, we will imagine the company, the users of the information system, their business, the data they manipulate, and so on. This is what we are going to do in this first sectio<a id="_idTextAnchor216"/>n.</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor217"/>The company and its business</h2>
<p>The <a id="_idIndexMarker321"/>company, which we will call <strong class="bold">DemoEditor</strong> for this<a id="_idIndexMarker322"/> purpose, would be an editing company that contracts with individual authors for the writing of books and then sells these books. We will imagine that this is quite a small company (less than 50 persons) and that its current information system is extremely reduced, mostly composed of a standard Office 365 organization providing them with email capability, basic SharePoint document management, an externalized website, and lots of internal functions being implemented through Excel workbooks.</p>
<p>While this remains a comfortable situation, because the information system has not turned into a spaghetti dish due to a long accumulation of point-to-point interoperations, degradation of legacy software applications, and so on, it still shows signs of inefficacy. The multiple copies of the Excel workbooks make it difficult for the employees<a id="_idIndexMarker323"/> to have a clear view of the pool of authors and the state of the writing of the books. Also, as the process of writing is not uniform, the director of the company complains about not being able to find clear statistics about global advances or delays in book delivery.</p>
<p>The business is mostly about finding the right subjects for the market, choosing the right author, following up on the writing of the books, and organizing the right sales pro<a id="_idTextAnchor218"/>cess.</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor219"/>The users and actors of the information system</h2>
<p>The<a id="_idIndexMarker324"/> 50 persons are, mostly, book editors. Then come the sales team, a bit of administration, and the director. For this simple example, we will consider that all the printing and distribution of the books is outsourced to another company and that DemoEditor concentrates only on the editing process.</p>
<p>The book editors’ job is to find authors, find book subjects, and match the right author to the right book. Then, they follow the writing process and make sure that the quality is there.</p>
<p>Then, it is up to the sales team and their job is to find indirect customers, which means libraries or book-selling organizations, as DemoEditor does not sell directly to readers. This means that commercial people actually sell the books by numbers, and not by units. Though we will not deal much with this part in our demo software system, it would be important in a real situation.</p>
<p>Finally, the director needs to keep numbers in check through reporting and statistics coming from the sales team and the editors. The smooth running of the company heavily depends on the right deadlines for the book as much as the quality of the writing, the match between the subject and the author, and the expectations of readers and book-selling companies. This means that the director has to measure all of these indicators, and the information system is of course expected to provide them. Asking editors or salespersons to fill in Excel sheets every week does not make sense, as this is time lost for their real<a id="_idTextAnchor220"/> jobs.</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor221"/>Data manipulation</h2>
<p>As<a id="_idIndexMarker325"/> you may have imagined, DemoEditor’s information system will have to manipulate data about authors, books, and sales, plus some additional statistics drawn from these primary data. The author will be known by their identity, a little contact information, maybe their bank coordinates to pay them royalties, and certainly information on their skills. Books will be registered with business-wide reference numbers, their titles, their summaries, and other information about the content. Sales will basically be the number of books sold to booksellers, with the associated date and maybe sales conditions.</p>
<p>Reporting data will be everything that can be used to apply business intelligence by the director on sales, authors, and books: how many books are sold for each category, what the time trend of selling them is, how many editions authors can work on for a given book before sales slow down and the novelty effect does not work anymore, who is their best salesperson, which bookseller returns the least number of books or reorders some the quickest, and so on. The reporting data is definitely bound to time, and not only by the fact that reports evolve in time, but also by the fact that reports should show the movements of business in time as well as geograph<a id="_idTextAnchor222"/>ically.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor223"/>The stakes of the information system for the company</h2>
<p>DemoEditor is a<a id="_idIndexMarker326"/> small company, which means that employees can “fill the gaps” and do a little bit of everything. While this is an advantage in some cases, meaning that they are agile and adaptive, it also means that they do not tend to do things in an industrial, repeatable way. Excel spreadsheets may be copied over and spread out in different versions all over the company instead of a unique, reference version being kept on the network. Also, data sales are spread around the different salespersons because they tend to be competitive toward each other and it is thus difficult to homogenize quantity discounts (the price is fixed) as well as customer listings.</p>
<p>As the commercial pipe is not very formal, some leads become prospects and then customers without the salesperson being able to really give statistics on how long and how much effort this takes them. The director really has a hard time knowing whether the company would sell more if they hired more salespersons. The choice of authors for the right books is also an issue. Generally, the editors have a good grasp on the market and know quite well which subjects should be written about. But the pool of competent authors is quite restricted and the authors are mostly known for the books they have already written. Most of the time, the editors do not know which other technologies these experts know about and there have been times when a book has been contracted to a new <a id="_idIndexMarker327"/>author, after taking a lot of time to find them, only for the editor to realize a few weeks later that one of the good authors who’s already written several books for DemoEditor actually had the right skills for the new project. An updated, shared, and efficient knowledge of author competencies is important for De<a id="_idTextAnchor224"/>moEditor.</p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor225"/>The situation as seen by the person put in charge of improving the system</h2>
<p>You are<a id="_idIndexMarker328"/> asked by the director to come and help with the information system. Everyone in the company knows IT could be more efficient and help them better but, as they say, they are not specialists in it. Since there was no internal IT guy, they did as best as they could, but they realized the “do it yourself” spirit of a small company can only go so far, and they had to get someone to give some structure. The director is also anxious about increasing the size of the company before this effort is done; otherwise, it may add more problems than growth.</p>
<p>As the business processes go on and the budget is not extensible, you are tasked with “<em class="italic">changing the wheel while the car is running</em>.” There may be some small stops in the IT system, but not for long periods. The data has got to be cleaned but the databases of authors and books have got to remain available along the way since they are everyday tools for most of the company’s employees. The director does not care much about its reporting being unavailable, or even destroyed, since it is not very useful at the moment and most of the numbers were false anyway.</p>
<p>In the next chapters, we will put ourselves in the skin of an engineer asked to carry out this foundational task and design the different components of the renewed IT system, and decide how its services should operate and what business domains should be designed. After that, we will implement all this and progressively transform the information system. But for now, we have to transform the theory learned in the previous chapters into principles that will guide us along the way. SOLID principles are a great set of principles that apply <a id="_idTextAnchor226"/>perfectly.</p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor227"/>SOLID principles and application to systems of whatever scale</h1>
<p>SOLID principles<a id="_idIndexMarker329"/> are important principles that apply to software applications, but they happen to also apply very well to software systems in general, so we will be able to use them to structure our project. We are going to explain the five principles one by one, together with how they apply to the transformation requested by DemoEditor and the design of its new information system. As this is a book about information systems and not software development, even though we will eventually build some implementations, I will not describe the principles from the coding point of view, but only briefly their main idea and, with more details, their translation into syst<a id="_idTextAnchor228"/>ems design.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor229"/>Single responsibility principle</h2>
<p>This<a id="_idIndexMarker330"/> principle states that a class, or in our case, a module of an information system, should do one and only one thing. This is quite wide as a definition but it can be narrowed down a bit by stating that an entity should have only one business reason to change. If the same class should be upgraded when there are changes in the author’s management and the book’s management, there is a problem regarding this single responsibility principle and the class should be decomposed into at least two smaller ones.</p>
<p>This principle is obviously easy to translate into an information system where it applies directly to modules, whether they are services, components, or other grains of entire systems (we will come back to the management of granularity in the next chapter). Each entity in the system should do one thing and only one. If this is observed from the point of view of the software applications composing the system, that means that each application should be in charge of only one business domain of the system. Since we manage authors, books, sales, and so on, we should indeed find one application for each of these. This notion of a business domain is not very precise for now but again, we will come to this in a future chapter, namely <a href="B21293_09.xhtml#_idTextAnchor318"><em class="italic">Chapter 9</em></a>, detailing the <strong class="bold">domain-driven design</strong> approach <a id="_idIndexMarker331"/>and the concepts of domain and bounded context.</p>
<p>For now, let’s just agree that a business domain needs its own application. If you are thinking microservices, yes, this is the track we are going to follow but bear with me, as this “micro” qualification is not always necessary and we would rather talk about “services” (with a clearer definition in <a href="B21293_08.xhtml#_idTextAnchor271"><em class="italic">Chapter 8</em></a>).</p>
<p>This<a id="_idIndexMarker332"/> first principle may sound very simple (and it is in its expression), but its implication can be very profound. To give just one example of the complexities we will have to deal with in our sample application, let’s unroll the case where a service depends on another, like in the case of the relationship of the “author of a book.” As said before, author and book management are two separate responsibilities. But how should we deal with the relationships between both? Is it another service? In any case, when someone reads a book entity from the service, how should the author of the book be retrieved and displayed? We can ask the same question the other way around: if someone calls the API on a given author, how should we display the list of books this author has participated in writing?</p>
<p>Diving into this last scenario is useful to get a better grasp of the concept of responsibility. Imagine that there are two separate services, each with its own database since they are supposed to be independent. Now, a user calls the API with a <code>GET</code> word on a particular book, let’s say <code>https://demoeditor.org/api/books/123456</code>. The module is indeed responsible for sending the book title, ISBN/EAN number, and some other attributes of the book. How about the information about the author? This is where the principle of responsibility helps to draw the line. The editors would tell you that, most of the time, when they get the information about the book, they need to know the author, but only by their identifier and some main data, such as their first and last name. This is the responsibility of the book service. And if you ask your product owners again (the editors, as they are the ones who will be using the information system), and they need some more data, they will turn to the <code>/api/authors</code> service to get it, using, of course, the identifier provided by the initial answer from the <code>/api/books</code> service. Thus, that data is the only responsibility of the second service.</p>
<p>Each reader who knows about the principles of good database design is certainly suffocating already, considering that this approach necessitates data duplication. Indeed, since <code>/api/authors</code> is responsible for the whole data for the authors, including of course their first name and last name, that means that, if <code>/api/books</code> is responsible for providing, upon request, the identifier, first name, and last name of the author of the given book, the rule of non-duplication is broken! And this is where the concept of responsibility is interesting and should be dug into deeper. How about considering the following share of responsibilities?</p>
<p>The <code>/api/authors</code> service is responsible for providing always up-to-date data about an author, including their first name and last name. This means that it is the reference source of truth for the authors: anyone who needs the latest, best-so-far information about an<a id="_idIndexMarker333"/> author should turn to this service, which will be responsible for providing it on time. Since it is the reference for this data, the service would certainly provide it with a value date, as the data may change over time. For example, an author could change their last name after getting married; this should be tracked by the author service, as it is responsible for the data about authors and their integrity.</p>
<p>The <code>/api/books</code> service is responsible for providing the same service for books, which means the same level of engagement on the book title, identifiers, and so on. But when talking about the author of a book, this is a relationship to another reference service, so the only data it is responsible for in terms of service is to point at the right entity in the other service. And this raises two interesting questions.</p>
<p>The first one is functional: is the link supposed to simply point to a given author, or is it supposed to point to the value of an author <em class="italic">at a given point in time</em>? This necessitates answering some business rules: if an author gets married between the first and second editions of a book, should the author’s name as it appears on the book change? And if so, how should the registered copyright be adjusted? And is the same true for a simple reprint of the original edition of the book?</p>
<p>The second one is more technical: if the book service stores the link to the author service and the latter is not available when needed, what happens? If a copy of the “usual” data (first name and last name) has been stored in the book service, no problem since it is now <em class="italic">independent</em> of the second one. But this comes back to the functional question again: if the name should not be changed on the book after an author gets married, no problem, and it is even better, as the local copy will prevent the difficulty of reaching the author’s service with the date of value to retrieve the “old” data. And if the name should evolve, it may be better to temporarily fall back on the old one rather than providing just the machine-readable identifier; only editors would know…</p>
<p>I hope this example, though complex, has shown you what we mean by the word <em class="italic">responsibility</em>. It is admittedly complex but, remember, everything we talked about was linked to business complexity and is not accidental. Indeed, talking about value date and the importance of history in reference to data management may sound overly complex because it is not very often dealt with in current information systems. But this is a real problem and this lack of reflecting on the actual functional reality is a problem as it prevents reflecting all business rules! That does not mean that the software that will be constructed based on this reflection will take all this complexity into account. In a true Agile way, you will certainly start with something very simple. But this deep understanding <a id="_idIndexMarker334"/>of the functional complexity ensures that the software will be easy to evolve in the future and that you will not be stuck at some point of implementation because the software is not aligned wi<a id="_idTextAnchor230"/>th the business.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor231"/>Open/closed principle</h2>
<p>The <strong class="bold">open/closed principle</strong> starts <a id="_idIndexMarker335"/>with a paradox in<a id="_idIndexMarker336"/> its very expression, which makes it strange at first sight: how can a module be open and closed at the same time? The comprehension of this principle is very important to create systems that will evolve because it states what should remain closed and what should be open to change for this evolution to work as smoothly as possible.</p>
<p>When applied to object-oriented programming, the open/closed principle states that a class should be open to extension, but closed to modification. Encapsulation and private members are used to prevent any instance in the program from modifying directly the state of another instance; otherwise, it would be very difficult to follow what happens when executing the program. Even debugging would be complicated if there is no way to track what class modifies the state of another one. This is why a class keeps its members private and only opens some public functions to allow only some changes in its state, in a way that is controlled by its own code, following its own rules. This is the closed part of the principle.</p>
<p>But a class, in general, is not marked as <code>final</code> to let another class inherit from it and specialize the functions that are marked as <code>virtual</code>. The inheriting class can also add some data members, in addition to accessing the one from the inherited class that is marked as <code>protected</code> (or, of course, <code>public</code>). Again, the class controls what can be overridden and what cannot, but at least it is open to an extension of its behavior by another class. This is the open part of the principle.</p>
<p>Applying this principle to information systems does not imply a big change in reflection, as the services replace the classes, and the techniques to extend or protect only vary from the practical point of view. If we continue with examples where services are REST APIs, we can draw a parallel between the members of a class and the data that is persisted by the implementation of an API contract: nothing but the service can modify this data, as only the implementation has access to the persistence used (a database or anything else). Of course, some API methods may allow some specific modifications to be carried from <a id="_idIndexMarker337"/>the API clients, but the API implementation controls this and applies business rules to ensure the modification is carried as it wants (or maybe rejected, by the way). This is <a id="_idIndexMarker338"/>the closed part of the principle applied to a module of information systems, and it is quite obvious in its resemblance to the application in a class.</p>
<p>The implementation of the open part of the principle on an API is trickier, as the behavior of an API can be extended in many ways:</p>
<ul>
<li>One of the ways to do so is to create an API that will extend the initial API contract. Mechanisms exist in the OpenAPI grammar to implement polymorphism and it is also possible to aggregate types in such a way that the new one contains the initial type and all its content.</li>
<li>Another way is to create an API that replaces the exposition of the old implementation, but still relies on it for all the standard data, and then provides its own data in addition. If done carefully, the extended API may even be fully compatible with the initial API contract, since it only adds new data (and if it just passes the initial data without changing any behavior, it even complies with the Liskov substitution principle, which we will see shortly).</li>
<li>A third option is to use an API gateway to expose the updated contract and implement the mixing of data coming from the original API and the additional data coming from another service dedicated to its storing and manipulation. This approach is a bit closer to the principle of inheritance.</li>
</ul>
<p>These three approaches are schematized as follows:</p>
<div><div><img alt="Figure 6.1 – Open/closed﻿ approaches to APIs" src="img/Figure_6.1_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Open/closed<a id="_idTextAnchor232"/> approaches to APIs</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor233"/>Liskov substitution principle</h2>
<p>The <code>Display</code>, that would implement a <code>print</code> function that sends black text on a white paper (through a printer, a screen, or anything else; no importance here). Let’s now suppose that a class called <code>ColorDisplay</code> specializes in the <code>Display</code> class and proposes a new function signature called <code>print</code> again, but accepts a parameter named <code>color</code> that allows the user to specify any color they want. How should the parameterless <code>print</code> function behave? The inheriting class will certainly point to its new and improved <code>print</code> function. And in this case, what should be the default color passed to this function? If you answer “black, of course,” you know what the Liskov substitution principle is about not surprising the user of a class, and ensuring them that the behavior is as expected.</p>
<p>The same goes<a id="_idIndexMarker341"/> for services inside a modular information system. Again, we will use APIs, as this is the standard way to decompose modules in such a system. When an API contract is provided to you, it states what method can be called, with which verbs, and through which URL; it also states the exact name of the attributes that you can send or that you will receive. But you may very well respect the letter of the contract API without respecting its spirit and this is what the Liskov substitution principle is about.</p>
<p>Let’s<a id="_idIndexMarker342"/> translate our previous example from object-oriented programming into API services, and imagine one can use version 1.0 of <code>/api/print</code> to process some text that will be sent to the device in black color. If using version 1.1 of an <code>/api/print</code> API, with the support of <code>/api/print?color=[HEX-VALUE]</code>, we will definitely expect that pointing our old client to the new API results in the production of black text. In terms of the stream between the API contract and its implementation, this can be pictured as the following:</p>
<div><div><img alt="Figure 6.2﻿ – Liskov substitution" src="img/Figure_6.2_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2<a id="_idTextAnchor234"/> – Liskov substitution</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor235"/>Interface segregation principle</h2>
<p>The <code>Rectangle</code> class implements the <code>IShape</code> interface. This means that <code>Rectangle</code> would have to implement the <code>getSurface</code> and <code>getPerimeter</code> methods but also some methods such as <code>drawShape</code> and so on. If the only interesting thing in the program is to compute the mathematical characteristics of shapes, then the right approach would be to split <code>IShape</code> into <code>IGeometricalShape</code> and <code>IDrawableShape</code> (i.e., segregate the interfaces) for the classes to implement only the interface they need.</p>
<p>The same goes <a id="_idIndexMarker345"/>for API contracts. To come back to our book service, it is better to separate two contracts, one for the book characteristics and one for the book sales characteristics, even if the same implementation will expose the two interfaces, one behind <code>/api/books</code> and the other behind <code>/api/books/sales</code>, rather than force the implementation of all functions by the use of only one contract.</p>
<p>Though it is <a id="_idIndexMarker346"/>always possible (and more acceptable in an API than in a class) to respond with a <code>NotImplemented</code> message, the separation into two interfaces also makes it easier to introduce versions. If the sales interface was not correctly defined in version 1.0 and a major, backward-compatible rewrite is necessary, it will be possible to continue exposing the book’s characteristics (potentially used by most of the clients) without any change.</p>
<p class="callout-heading">Note</p>
<p class="callout"><strong class="bold">Backward compatibility</strong> is the <a id="_idIndexMarker347"/>quality of a new version of an API where all calls used in the previous version work exactly with the same result on the new one.</p>
<p>The interface segregation even makes it possible (and easy) to expose three API contracts, namely <code>/api/books</code>, <code>/api/books/sales</code>, and <code>/api/books/sales/v2</code>:</p>
<div><div><img alt="Figure 6.3 – Interface segregation" src="img/Figure_6.3_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Interface segregation</p>
<p>Though quite obvious in the explanation, this principle is sadly often forgotten in existing APIs. This is particularly so because editors tend to provide functions in the frameworks that generate the OpenAPI contract from the implementation, instead of following the contract-first approach (which is admittedly more complicated, but the only one that leads to proper, business-aligned APIs). Since the contract is automatically generated from the whole source code, the generators do not make any difference between the different methods and resources and produce a single, monolithic contract that does not respect the interf<a id="_idTextAnchor236"/>ace segregation principle.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor237"/>Dependency inversion approach</h2>
<p>The <strong class="bold">dependency inversion approach</strong> is named as such because it goes against the usual way of<a id="_idIndexMarker348"/> thinking about dependency. Imagine <a id="_idIndexMarker349"/>that we have a reporting module and another module that provides the data to be used for reporting purposes. Naturally, we tend to think that the reporting module should depend on the data module in technical terms because this is how it works from the functional point of view. This is a rare case where aligning the technical design directly with the functional concepts is not good enough. If we want to ensure low coupling, we have to make one more step and add some indirection to a common interface that both of the services will depend on:</p>
<ul>
<li>Just like the <code>Data</code> class would implement <code>IData</code>, the <code>/api/data</code> service should implement the API contract defined in the data OpenAPI file.</li>
<li>And like the <code>Reporting</code> class would use the <code>IData</code> source (and not directly the <code>Data</code> implementation) to prevent hard coupling, the <code>/api/reporting</code> service would not directly call the <code>/api/data</code> service but the URL provided to it by configuration, providing that it implements the data OpenAPI contract. In object-oriented programming, this will typically be done by injection. In a service, depending on the orchestration mechanism, this can be realized through an API gateway, the ingress exposition, or even a (more complicated) service mesh.</li>
</ul>
<p>The following diagram has already been used in <a href="B21293_03.xhtml#_idTextAnchor069"><em class="italic">Chapter 3</em></a>, but it is particularly relevant here, as it shows visually the dependency inversion principle in information systems: instead of a dependency of one software module on another, each of the two modules working together points at the same business contract definition (which is purely functional), one to implement it, the other to consume it:</p>
<div><div><img alt="Figure 6.4 – Coupling on the four layers diagram" src="img/Figure_6.4_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Coupling on the four layers diagram</p>
<p>Let’s<a id="_idIndexMarker350"/> move on <a id="_idIndexMarker351"/>to the next section where we’ll<a id="_idTextAnchor238"/> analyze the SOLID principle.</p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor239"/>Critical analysis of SOLID</h1>
<p>Though<a id="_idIndexMarker352"/> I have realized in time (certainly like many others) that the SOLID principles apply almost as well to information systems as to object-oriented classes and interfaces, some parts deserve discussion. Indeed, like for any other<a id="_idIndexMarker353"/> principle, a strict, not thoughtful, application may lead to problems. And even when the principles apply well to a given context, they may have strong side effects that make them ultimately more harmful than helpful. The necessary measured approach has led to lots of polemics and you must be carefu<a id="_idTextAnchor240"/>l in handling these principles.</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor241"/>Limits of the separation of responsibilities</h2>
<p>The <a id="_idIndexMarker354"/>first (and maybe most important) principle, namely the one about separation of responsibilities, is sometimes hard – perhaps impossible in some cases – to apply to services or high-level modules of an application. With classes, there is always the possibility to decompose a class without much impact on the whole application, once compiled. Services and modules do not present this ease of composition because they come with additional constraints such as exposition, endpoints, coding interfaces, documentation, integration subsystems, and so on. All this takes a toll on the decomposition, and<a id="_idIndexMarker355"/> this is the reason why people who are not careful with microservices and decompose them too much in their systems end up spending more time evolving them than if they had stayed on a monolith architecture. I am not going to talk again about granularity because the subject was already developed in the previous chapters, but this is clearly something that must be pondered and can limit the reach of the principle of separation of responsibilities, or at least its depth.</p>
<p>Another difficulty is not linked to how deeply you can separate the responsibilities, but how intricate some of them are sometimes, even at a relatively high level. This is, for example, a huge difficulty in “micro-frontend” architectures, and I am not talking about the problem associated with how “micro” the frontend component is. The simple fact that visual components present functions, but also have a visual impact, is a huge difficulty in making them independent. This is what is exposed, for example, in <a href="https://jonhilton.net/good-blazor-components/">https://jonhilton.net/good-blazor-components/</a>: by delegating the content of a Blazor component to another sub-component (in the example of the article, using the <code>ChildContext</code> property to include a <code>Card</code> instance), you indeed externalize the responsibility of displaying the inner part of a visual component. But that does not mean it will not have an impact, as the rendering of the subcomponent will necessarily have an impact on the one above it. Indeed, either the container fixes a size for the child and then takes responsibility for its display, or the container – in a purely responsive design manner – lets the child component adapt its display. In this case, its own size will be impacted by its child, which also ruins the independence that was supposed to be achieved by the principle of separation of responsibilities.</p>
<p>The intellectual solution for this is to consider that each component has the responsibility for its content, but not for its display and that this is the responsibility of the display engine in the browser. It may not be very satisfying because it comes back to a single point of execution for the whole frontend, which we were trying to make modular and easy to evolve, but at least the low coupling between the components has been achieved, though on a limited perimeter. This is one of the many compromises one will have to make when designing information <a id="_idTextAnchor242"/>systems and modular applications.</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor243"/>About the polemics on monoliths</h2>
<p>This chapter <a id="_idIndexMarker356"/>may be a good place to talk about the long-held discussion about “going back to monoliths,” a reaction to the drawbacks of microservices that have been very much observed in the discussions of the communities of software architects. In summary, the microservice approach is considered harmful and some people recommend going back to monolith applications. This is sadly another example of how polarized debates are nowadays, because both approaches (and the huge spectrum between them) have value, depending on your needs.</p>
<p>No one serious has ever pretended microservices were the best solution for every architecture. In fact, right from the beginning, most articles explaining the approach insisted that they were only adapted to some specific circumstances (high volumes, frequent modification of the application, clear cut between teams in charge of different modules, and so on). However, some people did not take this into account and now complain that microservices were not the right fit for their case. Even worse, in a binary and not very thought-out reaction, they discard the whole principle of microservices and advertise a so-called “return to the monolith.” Any sensible engineer in this case would simply spot the well-known pendulum movement where one extreme chases another one. And the solution in this case is not in either of them or continuously balancing between one and the other, but simply reaching the nice equilibrium between them.</p>
<p>In the case of software applications, what do we call a monolith? An application made of a single process? No, otherwise that would mean that even the smallest application such as <code>cd</code> or <code>exit</code> should be considered as such. The term has been coined precisely to describe single applications that were in charge of too many business features, which made them too heavy to have a nice evolution or fit the use they were designed for.</p>
<p>The situation talked about in the articles on the so-called death of microservice architecture and going back to monolith simply do not talk about the right subject, which is the granularity of services. Sure, the very small grain of microservices did not satisfy their information system needs. But that simply means the grain was too fine. Going back to the coarsest grain one can have (the monolith) simply displays a lack of depth in the comprehension of the problem. An engineer approach to this would be to search for the right granularity of the services. As said in <a href="https://codeopinion.com/biggest-scam-in-software-dev-best-practices/">https://codeopinion.com/biggest-scam-in-software-dev-best-practices/</a>, the choice is not only between “Amazon is doing it, so let’s do it” and “we are not Amazon so we should not do it” – knowledge of the business and analysis of the context only will tell you where you should place yourself between the two.</p>
<p>It just happens<a id="_idIndexMarker357"/> that there is an existing design method called domain-driven design that is the perfect method to find out the right granularity of services for an information system. It also relates strongly to the principles of business/IT alignment, as it states how business domains can be cut into internally cohesive, externally low-coupled modules. Everything we will be doing in the design of our demo application will be an illustration of this research of the right granularity, base<a id="_idTextAnchor244"/>d on the business functional needs.</p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor245"/>Beware of unintended coupling</h2>
<p>One last piece <a id="_idIndexMarker358"/>of advice on the separation of responsibilities (this first principle is definitely causing lots of discussions!): once you have established a clear cut of responsibilities based on the <strong class="bold">business capability map</strong>, you<a id="_idIndexMarker359"/> are not done with the separation of responsibilities, as it is very easy to recreate coupling afterward in the technological transformation of the functions.</p>
<p>I will give one simple example of such a problem because it is very representative of the trap I described. Imagine we create our demo application with an API for the books, an API for the book sales (possibly exposed under the same URL, but still independent in terms of contract), and an API for the authors. The director of the company may want, at some point, a report on how the geographical origin of the authors impacts the localization of their sales (maybe an author from Brittany will sell more in their region because their network of contacts is denser around them? Or perhaps it has no impact? Anyway, this might be interesting to analyze). This is a common issue with microservices, which are supposed to have their own persistence. In this case, how can we make links between data, just like we were creating <code>join</code> operations when we added a single database? One of the standard approaches is to add a collecting data structure that gathers, indexes, and aggregates data from all the microservices and proposes a dedicated <code>/api/reporting</code> service with its own API contract.</p>
<p>This service of course presents a level of coupling toward its source, but this can be made a lower level of coupling, for example, by keeping a local cache or mixing a subscribe approach to the data changes with a direct collection under a lower frequency to ensure that no signal has been lost and the data is reset at a controlled frequency. Also, it presents interesting functions that none of the atomic data services provide, such as indexing, the capacity of dynamic aggregation, and <a id="_idIndexMarker360"/>so on. <strong class="bold">GraphQL</strong> is a nice protocol to expose such services, and <a id="_idIndexMarker361"/>they integrate very well in a <strong class="bold">Command Query Responsibility </strong><strong class="bold">Segregation</strong> architecture.</p>
<p>However, there<a id="_idIndexMarker362"/> might be an unintended coupling if the atomic service not only provides data for this reporting service but also starts consuming atomic data from it. And this can happen very quickly because the performance boost of an indexing engine is very appealing to developers. The problem is that this causes a circular functional dependency, which is already quite a problem, but also a higher level of coupling since, once this dependency is created, the atomic data service becomes suddenly coupled to each of the other ones. Of course, the coupling may remain low, but nonetheless, a link has been created and this is – in most cases I have seen – a real pain to come into the system.</p>
<p>If you really need fast aggregated reads in an atomic service, you have to deal with this internally, by adding indexes on the dedicated persistency, for example. This may sound complicated if you see this nice indexing engine right on the other side of the service wall, but this is the price to pay to keep your system free from coupling and easy to evolve in time. Again, this is a compromise and if the architect decides the functional coupling is not a problem, you may save time by doing so. But this has to be a conscious (and documented) compromise.</p>
<div><div><img alt="﻿Figure 6.5 – Reducing coupling strength" src="img/Figure_6.5_B21293.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor246"/>Figure 6.5 – Reducing coupling strength</p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor247"/>Wrapping up before going back to the demo</h1>
<p>In this chapter, we have learned about the SOLID principles that can be applied to information systems (and not only object-oriented programming, as they were initially aimed at); the single responsibility principle and the interface segregation principle have been used to start a definition of the different API contracts we will need for our demo application. The open/closed principle will help to keep this API grammar free to evolve, and its evolution will have to follow the Liskov substitution principle for the system to evolve satisfyingly. Finally, dependency inversion has been demonstrated as the core principle behind contract-first API and the capacity to align the software implementations on the business-oriented functions, which is the main goal we seek in this book.</p>
<p>In the next chapter, we will go one step further in the design of our demo application by defining its different components. This will help us to draw a perimeter of the first version we want to create in this book, but also to define more clearly the different parts of the application using a method that adapts to the depth of decomposition.</p>
</div>
</body></html>