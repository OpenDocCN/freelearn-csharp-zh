- en: Optimizing Your Art Assets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化您的艺术资产
- en: Art is a famously subjective discipline, dominated by personal opinion and preference.
    It can be challenging to say whether, and why, one piece of art is better than
    another. Oftentimes, our opinions won't be able to find a complete consensus.
    The technical aspects behind art assets that support a game's artistry can also
    be very subjective. Multiple workarounds can be implemented to improve performance,
    but these tend to result in a loss of quality for the sake of speed. If we're
    trying to reach peak performance, then we must consult with our team members whenever
    we decide to make any changes to our art assets, as it is primarily a balancing
    act, which can be an art form in itself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术是一个著名的具有主观性的学科，由个人意见和偏好主导。很难说一件艺术品是否比另一件更好，以及为什么更好。很多时候，我们的意见无法达成完全一致。支持游戏艺术性的艺术资产背后的技术方面也可能非常主观。可以实施多种解决方案来提高性能，但这些通常会导致为了速度而牺牲质量。如果我们试图达到最佳性能，那么在决定对艺术资产进行任何更改时，我们必须咨询团队成员，因为这主要是一个平衡行为，这本身也可以是一种艺术形式。
- en: Whether we're trying to minimize our runtime memory footprint, keep the smallest
    possible executable size, maximize loading speed, or maintain consistency in frame
    rate, there are plenty of options to explore. Some methods are clearly always
    ideal, but most require a little more care and forethought before being adopted,
    as they would result in reduced quality or could increase the chances of developing
    bottlenecks in other subsystems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是在尝试最小化运行时内存占用、保持尽可能小的可执行文件大小、最大化加载速度，还是保持帧率的稳定性，都有许多选项可以探索。一些方法显然总是理想的，但大多数方法在采用之前需要更多的关注和预先思考，因为它们可能会导致质量下降或增加其他子系统出现瓶颈的可能性。
- en: 'In this chapter, we will explore how to improve performance for the following
    asset types:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何提高以下资产类型的性能：
- en: Audio files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频文件
- en: Texture files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理文件
- en: Mesh and animation files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格和动画文件
- en: Asset bundles and resources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资产包和资源
- en: In each case, we will investigate how Unity stores, loads, and manipulates these
    assets both during application build time and runtime. We will also examine our
    options in the event of performance issues, and what we can do to avoid behavior
    that might generate performance bottlenecks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，我们将研究Unity在应用构建时间和运行时如何存储、加载和处理这些资产。我们还将检查在性能问题发生时的选项，以及我们可以采取哪些措施来避免可能产生性能瓶颈的行为。
- en: Audio
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频
- en: As a framework, Unity can be used to build anything from small applications
    that require only a handful of sound effects and a single background track to
    huge role-playing games that need millions of lines of spoken dialog, music tracks,
    and ambient sound effects. Regardless of the actual scope of the application,
    audio files are often a significant contributor to the application size after
    it is built (sometimes called its *disk footprint*). Moreover, many developers
    are surprised to find that runtime audio processing can turn into a significant
    source of CPU and memory consumption.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种框架，Unity 可以用来构建任何东西，从只需要少量音效和一条背景音乐的简单应用，到需要数百万行对话、音乐轨道和环境音效的庞大角色扮演游戏。无论应用的实际范围如何，音频文件在构建完成后通常都是应用大小的一个重要组成部分（有时也称为其
    *磁盘占用*）。此外，许多开发者惊讶地发现，运行时音频处理可以变成CPU和内存消耗的一个重大来源。
- en: 'Audio is often neglected on both sides of the gaming industry: developers tend
    not to commit many resources to it until the last minute and users rarely pay
    attention to it. Nobody notices when audio is handled well, but we all know what
    lousy audio sounds like—it''s instantly recognizable, jarring, and guaranteed
    to draw unwanted attention. This makes it crucial not to sacrifice too much audio
    clarity in the name of performance.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 音频在游戏行业的两个层面都常常被忽视：开发者往往直到最后一刻才投入资源，而用户很少关注它。当音频处理得当的时候，没有人会注意到，但我们都知道糟糕的音频是什么样的——它立刻就能辨认出来，令人不快，并且肯定会引起不必要的注意。这使得在性能的名义上牺牲过多的音频清晰度变得至关重要。
- en: Audio bottlenecks can come from a variety of sources. Excessive compression,
    too much audio manipulation, too many active audio components, inefficient memory
    storage methods, and access speeds all lead to poor memory and CPU performance.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 音频瓶颈可能来自各种来源。过度的压缩、过多的音频处理、过多的活跃音频组件、不高效的内存存储方法以及访问速度都会导致内存和CPU性能下降。
- en: Fortunately, you can learn to avoid such issues with just a little effort and
    understanding. In the following sections, we will learn some useful tricks to
    save us from a user experience disaster. We will learn how to choose among the
    different audio loading options, how to choose the right audio format for our
    game, and some other relevant performance tweaks.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，只需一点努力和理解，你就可以学会避免这些问题。在接下来的章节中，我们将学习一些有用的技巧，以帮助我们避免用户体验灾难。我们将学习如何在不同音频加载选项中进行选择，如何为我们的游戏选择正确的音频格式，以及一些其他相关的性能调整。
- en: Importing audio files
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入音频文件
- en: When we select an imported audio file in the Project window, the Inspector window
    will reveal multiple Import Settings. These settings dictate everything from loading
    behavior, compression behavior, quality, sample rate, and (in later versions of
    Unity) whether to support ambisonic audio (multichannel audio, which combines
    tracks via spherical harmonics to create more realistic audio experiences).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在项目窗口中选择导入的音频文件时，检查器窗口将显示多个导入设置。这些设置决定了从加载行为、压缩行为、质量、采样率，以及（在Unity的后续版本中）是否支持环绕声音频（多声道音频，通过球谐函数组合轨道以创建更真实的音频体验）等各个方面。
- en: Many of the audio import options can be configured on a per-platform basis,
    allowing us to customize behavior between different target platforms.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 许多音频导入选项可以根据平台进行配置，使我们能够在不同的目标平台之间自定义行为。
- en: Loading audio files
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载音频文件
- en: 'The following are the three settings that dictate how an audio file is loaded:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何加载音频文件的三种设置：
- en: Preload Audio Data
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预加载音频数据
- en: Load In Background
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后台加载
- en: Load Type
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载类型
- en: '![](img/37aa4295-17e2-481c-97b0-0d03f5de0d70.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/37aa4295-17e2-481c-97b0-0d03f5de0d70.png)'
- en: What we see when we look at an imported file in the inspector.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器中查看导入文件时，我们所看到的内容。
- en: 'Our audio files are initially packaged as binary data files that are bundled
    with our application, which reside on the hard disk of the device (although in
    some cases they are downloaded from somewhere on the internet). *Loading* audio
    data simply means pulling it into main memory (RAM) so that it can be later processed
    by audio decoders, which then convert the data into audio signals to our headphones
    or speakers. However, how loading happens will vary enormously based on the previous
    three settings, which are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的音频文件最初是以二进制数据文件的形式打包的，这些文件与应用程序捆绑在一起，位于设备的硬盘上（尽管在某些情况下它们是从互联网上的某个地方下载的）。**加载**音频数据简单地说就是将其拉入主内存（RAM），以便它可以稍后由音频解码器处理，解码器然后将数据转换为音频信号，传递到我们的耳机或扬声器。然而，加载的方式将根据前三个设置而有很大差异，如下所示：
- en: The first setting, Preload Audio Data, determines whether audio data will be
    automatically loaded during scene initialization or at a later time.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个设置，**预加载音频数据**，决定了音频数据是否会在场景初始化期间或稍后自动加载。
- en: When the loading of audio data does occur, the second setting, Load In Background,
    determines whether this activity blocks the main thread until it is finished or
    loads it asynchronously in the background.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当音频数据的加载发生时，第二个设置，**在后台加载**，决定了这项活动是否会在完成之前阻塞主线程，或者异步地在后台加载。
- en: Finally, the Load Type setting defines what kind of data gets pulled into memory
    and how much data gets pulled at a time.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，**加载类型**设置定义了将哪种类型的数据拉入内存，以及每次拉入多少数据。
- en: All three of these settings can have a dramatically negative effect on performance
    if they are not used wisely.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用不当，这三个设置都可能对性能产生严重影响。
- en: The typical use case of an audio file is to assign it to the AudioClip property
    of an `AudioSource` component, which will wrap it in an `AudioClip` object. We
    can then trigger playback via `AudioSource.Play()` or `AudioSource.PlayOneShot()`.
    Each audio clip assigned in this way would be loaded into memory during scene
    initialization as the scene contains immediate references to these files, which
    it must resolve before they are needed. This is the default behavior when Preload
    Audio Data is enabled.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 音频文件的典型用途是将它分配给`AudioSource`组件的`AudioClip`属性，这将把它包裹在一个`AudioClip`对象中。然后我们可以通过`AudioSource.Play()`或`AudioSource.PlayOneShot()`触发播放。以这种方式分配的每个音频剪辑都会在场景初始化期间加载到内存中，因为场景包含对这些文件的直接引用，它必须在需要之前解决这些引用。这是在启用预加载音频数据时的默认行为。
- en: 'Disabling Preload Audio Data tells the Unity engine to skip audio file asset
    loading during scene initialization, which defers loading activity to the first
    moment it is needed—that is, when `Play()` or `PlayOneShot()` are called. Disabling
    this option will speed up scene initialization, but it also means that the first
    time we play the file, the CPU will need to immediately access the disk, retrieve
    the file, load it into memory, decompress it, and play it. This is a synchronous
    operation and will block the main thread until it is completed. We can prove this
    with a simple test:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用“预加载音频数据”会告诉Unity引擎在场景初始化期间跳过音频文件资产的加载，将加载活动推迟到第一次需要的时候——即调用`Play()`或`PlayOneShot()`时。禁用此选项将加快场景初始化速度，但这也意味着我们第一次播放文件时，CPU需要立即访问磁盘，检索文件，将其加载到内存中，解压缩它，然后播放。这是一个同步操作，并且将在完成之前阻塞主线程。我们可以通过一个简单的测试来证明这一点：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we add an `AudioSource` object to our scene, assign a large audio file to
    it, and assign it to the `_source` field of the `PreloadAudioDataTest` component,
    we can press the spacebar and take a look at a printout of how long the `Play()` function
    took to complete. A simple test of this code against a 10-MB audio file with Preload
    Audio Data enabled will reveal that the call was practically instantaneous; however,
    disabling Preload Audio Data, applying the changes to the file, and repeating
    the test shows that it takes significantly longer (around 700 ms on a desktop
    PC with an Intel i5 3570K). This completely blows past our budget for a single
    frame, so to use this toggle responsibly, we will need to load the majority of
    our audio assets into memory ahead of time.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在场景中添加一个`AudioSource`对象，将其分配给一个大型音频文件，并将其分配给`PreloadAudioDataTest`组件的`_source`字段，我们可以按空格键并查看`Play()`函数完成所需的时间。对这个代码进行一个简单的测试，使用一个10-MB的音频文件并启用预加载音频数据，将显示调用几乎是瞬间的；然而，禁用预加载音频数据，应用对文件所做的更改，并重复测试将显示它需要更长的时间（在配备Intel
    i5 3570K的桌面PC上大约为700毫秒）。这完全超出了我们单帧的预算，因此为了负责任地使用这个切换，我们需要在事先将大部分音频资产加载到内存中。
- en: This can be achieved by calling `AudioClip.LoadAudioData()` (which can be acquired
    through an `AudioSource` component's `clip` property). However, this activity
    will still block the main thread for the same amount of time it takes to load
    it in the previous example, and so loading our audio file will still cause frame
    drops, regardless of whether we choose to load it ahead of time. Data can also
    be unloaded through  `AudioClip.UnloadAudioData()`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过调用`AudioClip.LoadAudioData()`（可以通过`AudioSource`组件的`clip`属性获取）来实现。然而，这项活动仍然会阻塞主线程，所需的时间与上一个例子中加载它的时间相同，因此无论我们选择提前加载还是不加载，加载我们的音频文件仍然会导致帧率下降。数据也可以通过`AudioClip.UnloadAudioData()`卸载。
- en: This is where the Load In Background option comes in. This changes audio loading
    into an asynchronous task, which means that loading will not block the main thread.
    With this option enabled, the actual call to  `AudioClip.LoadAudioData()` will
    complete instantly, but keep in mind that the file won't be ready to play until
    loading completes on a separate thread. We can double-check an `AudioClip` component's
    current loading state through the `AudioClip.loadState` property. If Load In Background
    is enabled and we call `AudioSource.Play()` without loading the data first, Unity
    will still require the file to be loaded into memory before it can be played,
    and so there will be a delay between when we called `AudioSource.Play()` and when
    the audio file begins playback. This risks introducing jarring behavior if we
    try to access a sound file before it is fully loaded, causing it to be out of
    sync with other tasks, such as animations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是“在后台加载”选项的作用所在。这个选项将音频加载改为异步任务，这意味着加载不会阻塞主线程。启用此选项后，对`AudioClip.LoadAudioData()`的实际调用将立即完成，但请注意，文件将在单独的线程上加载完成后才能播放。我们可以通过`AudioClip.loadState`属性来双重检查`AudioClip`组件当前的加载状态。如果启用“在后台加载”，并且我们在没有先加载数据的情况下调用`AudioSource.Play()`，Unity仍然需要在播放之前将文件加载到内存中，因此当我们调用`AudioSource.Play()`和音频文件开始播放之间会有延迟。如果我们试图在文件完全加载之前访问声音文件，这可能会引入令人不快的操作，导致它与其他任务（如动画）不同步。
- en: Modern games typically implement convenient stopping points in levels to perform
    tasks such as loading or unloading audio data—for example, an elevator between
    floors, or long corridors where minimal action is taking place. Solutions involving
    custom loading and unloading of audio data via these methods would need to be
    tailor-made to the particular game, depending on when audio files are required,
    how long they're needed for, how scenes are put together, and how players traverse
    them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '现代游戏通常在关卡中实现方便的停止点以执行加载或卸载音频数据等任务——例如，楼层之间的电梯或发生最小动作的长走廊。涉及通过这些方法进行自定义加载和卸载音频数据解决方案需要根据特定游戏量身定制，具体取决于何时需要音频文件、需要多长时间、场景如何组合以及玩家如何穿越它们。 '
- en: This can require a significant number of special case changes, testing, and
    asset management tweaks, so it is recommended that you save this approach as a
    *nuclear option* to be used late in production, in the event that all other techniques
    have not succeeded as well as we hoped.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要大量的特殊情况更改、测试和资产管理调整，因此建议您将此方法保存为*终极选项*，在所有其他技术未能达到预期效果时，在生产后期使用。
- en: 'Finally, there is the Load Type option, which dictates how audio data loads
    when it occurs. There are three options available:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有加载类型选项，它决定了音频数据加载时的方式。有三个选项可供选择：
- en: Decompress On Load
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载时解压缩
- en: Compressed In Memory
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存中压缩
- en: Streaming
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流式传输
- en: 'These three options are explained in detail in the following list:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表中详细解释了这三个选项：
- en: 'Decompress On Load: This setting compresses the file on disk to save space
    and decompresses it into memory when it is first loaded. This is the standard
    method of loading an audio file and should be used in most cases. It takes some
    time to decompress the file, which leads to a little extra overhead during loading,
    but reduces the amount of work required when the audio file is played.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载时解压缩：此设置在磁盘上压缩文件以节省空间，并在首次加载时将其解压缩到内存中。这是加载音频文件的标准方法，在大多数情况下应使用。解压缩文件需要一些时间，这会导致加载时产生一些额外的开销，但减少了播放音频文件时所需的工作量。
- en: 'Compressed In Memory: This setting copies the compressed file straight from
    disk into memory when it is loaded. It will only decompress the audio file during
    runtime when it is being played. This will sacrifice runtime CPU when the audio
    clip is played, but improves loading speed and reduces runtime memory consumption
    while the audio clip remains dormant. Hence, this option is best used for very
    large audio files that are used relatively frequently, or if we''re incredibly
    bottlenecked on memory consumption and are willing to sacrifice some CPU cycles
    to play the audio clip.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩内存中：此设置在加载时直接将压缩文件从磁盘复制到内存中。它仅在运行时播放音频文件时进行解压缩。当音频剪辑播放时，这会牺牲运行时的CPU资源，但可以提高加载速度并减少音频剪辑处于休眠状态时的运行内存消耗。因此，此选项最适合经常使用的非常大的音频文件，或者如果我们对内存消耗有极大的瓶颈，并且愿意牺牲一些CPU周期来播放音频剪辑。
- en: 'Streaming: Finally, this setting (also known as *Buffered*) will load, decode,
    and play files on the fly at runtime by gradually pushing the file through a small
    buffer where only one small piece of the overall file is present in memory at
    a time. This method uses the least amount of memory for a particular audio clip,
    but the largest amount of runtime CPU. Since each instance of playback of the
    file will need to generate its buffer, this setting comes with the unfortunate
    drawback of referencing the audio clip more than once, which leads to multiple
    copies of the same audio clip in memory that must all be processed separately,
    resulting in a runtime CPU cost if used recklessly. Consequently, this option
    is best reserved for single-instance audio clips that play regularly and never
    need to overlap with other instances of themselves or even with other streamed
    audio clips—for example, this setting is best used with background music and ambient
    sound effects that need to be played during the majority of a scene''s lifetime.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流式传输：最后，这个设置（也称为*缓冲*）将在运行时动态加载、解码和播放文件，通过逐渐将文件推入一个只有一小部分文件在内存中存在的小缓冲区。这种方法对特定音频剪辑使用的内存最少，但运行时CPU使用量最大。由于每个文件的播放实例都需要生成其缓冲区，因此这个设置带来了不幸的缺点，即需要多次引用音频剪辑，导致内存中存在多个相同的音频剪辑副本，这些副本都必须单独处理，从而在使用不当的情况下产生运行时CPU成本。因此，此选项最好保留用于单实例音频剪辑，这些音频剪辑经常播放，并且永远不会需要与其他实例或甚至与其他流式传输音频剪辑重叠——例如，此设置最好用于在场景大部分生命周期内需要播放的背景音乐和环境音效。
- en: So, let's recap. The default case, with Preload Audio Data enabled, Load In
    Background disabled, and a Load Type of Decompress On Load, causes a long scene
    loading time, but ensures that every audio clip we reference in the scene is ready
    immediately when we need it. There will be no loading delays when the audio clip
    is needed, and the audio clip will play back the moment we call `Play()`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们回顾一下。默认情况下，启用预加载音频数据，禁用后台加载，以及加载类型为“加载时解压缩”，会导致场景加载时间较长，但确保我们在需要时场景中引用的每个音频剪辑都立即准备好。当需要音频剪辑时，不会有加载延迟，并且音频剪辑将在我们调用`Play()`时立即播放。
- en: A good compromise to improve scene loading time is to enable Load In Background
    for audio clips we won't need until later, but this should not be used for audio
    clips we need shortly after scene initialization. We then control when our audio
    data is loaded manually through `AudioClip.LoadAudioData()` and `AudioClip.UnloadAudioData()`.
    We should be willing to use all of these methods in a single scene to reach optimal
    performance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高场景加载时间，一个良好的折衷方案是对于之后才需要的音频剪辑启用“在后台加载”，但不应为此类在场景初始化后不久就需要音频剪辑的情况使用。然后我们可以通过手动调用`AudioClip.LoadAudioData()`和`AudioClip.UnloadAudioData()`来控制音频数据的加载时间。我们应该愿意在单个场景中使用所有这些方法以达到最佳性能。
- en: Encoding formats and quality levels
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码格式和质量级别
- en: 'Unity supports three general case encoding formats for audio clips, which are
    determined by the Compression Format option when we view an audio clip''s properties
    in the Inspector window:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Unity支持三种通用的音频剪辑编码格式，这些格式由我们在检查器窗口中查看音频剪辑属性时的“压缩格式”选项确定：
- en: Compressed (the actual text for this option can appear differently, depending
    on the platform)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩（此选项的实际文本可能因平台而异）
- en: PCM
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PCM
- en: ADPCM
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ADPCM
- en: The audio files we import into the Unity engine can be one of many popular audio
    file formats, such as Ogg Vorbis, MPEG-3 (MP3), and Wave, but the actual encoding
    that is bundled into the executable will be converted into a different format.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入Unity引擎的音频文件可以是许多流行的音频文件格式之一，如Ogg Vorbis、MPEG-3（MP3）和Wave，但实际打包到可执行文件中的编码将被转换为不同的格式。
- en: The compression algorithm used with the Compressed setting will depend on the
    platform being targeted. Standalone applications and other nonmobile platforms
    will convert the file into Ogg Vorbis format, whereas mobile platforms use MP3.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用压缩设置的压缩算法将取决于目标平台。独立应用程序和其他非移动平台将文件转换为Ogg Vorbis格式，而移动平台使用MP3。
- en: There are a few platforms that always use a specific type of compression, such
    as HEVAG for the PS Vita, XMA for Xbox One, and AAC for WebGL.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有些平台始终使用特定的压缩类型，例如PS Vita的HEVAG、Xbox One的XMA和WebGL的AAC。
- en: Statistics are provided in the Inspector window for the currently selected format
    in the area following the Compression Format option, giving you an idea of how
    much disk space the compression is saving. Note that the first value displays
    the original file size and the second displays the size cost on disk. How much
    memory the audio file will consume at runtime once loaded will be determined by
    how efficient the chosen compression format is—for example, the Ogg Vorbis compression
    will generally decompress to about ten times its compressed size, whereas ADPCM
    will decompress to about four times the compressed size.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 统计数据在“检查器”窗口中提供，位于“压缩格式”选项之后，为您提供了压缩节省磁盘空间的大致想法。请注意，第一个值显示原始文件大小，第二个值显示磁盘上的大小。音频文件在加载后运行时将消耗多少内存将由所选压缩格式的效率决定——例如，Ogg
    Vorbis压缩通常可以解压缩到其压缩大小的约十倍，而ADPCM可以解压缩到其压缩大小的约四倍。
- en: The cost savings displayed in the Inspector window for an audio file only apply
    for the currently selected platform and most recently used settings. Ensure that
    the editor is switched to the correct platform in File | Build Settings, and that
    you click on Apply after making changes in order to see the actual cost savings
    (or cost inflation) for the current configuration. This is particularly important
    for WebGL applications since the AAC format generally leads to very inflated audio
    file sizes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 检查器窗口中显示的音频文件成本节省仅适用于当前选定的平台和最近使用的设置。请确保在“文件”|“构建设置”中将编辑器切换到正确的平台，并在更改后点击“应用”，以查看当前配置的实际成本节省（或成本膨胀）。这对于WebGL应用程序尤为重要，因为AAC格式通常会导致音频文件大小大幅膨胀。
- en: The encoding/compression format used can have a dramatic effect on the quality,
    file size, and memory consumption of the audio file during runtime, and only the
    Compressed setting gives us the ability to alter the quality without affecting
    the sampling rate of the file. Meanwhile, the PCM and ADPCM settings do not provide
    this luxury, and we're stuck with whatever file size those compression formats
    decide to give us—that is, unless we're willing to reduce audio quality for the
    sake of file size by reducing the sampling rate.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所使用的编码/压缩格式对音频文件在运行时的质量、文件大小和内存消耗有显著影响，只有压缩设置允许我们在不影响文件采样率的情况下调整质量。同时，PCM和ADPCM设置不提供这种便利，我们只能接受这些压缩格式决定的文件大小——也就是说，除非我们愿意为了文件大小而降低音频质量，减少采样率。
- en: 'In the following table, you can take a glance at the differences and use cases
    for each format:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在下表中，您可以快速了解每种格式的区别和使用场景：
- en: '| **Format** | **Lossless** | **Size** | **Quality** | **Usage** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **格式** | **无损** | **大小** | **质量** | **用途** |'
- en: '| **PCM** | Yes | Large | High | Very short sound effects that require a lot
    of clarity where any compression would otherwise distort the experience. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **PCM** | 是 | 大 | 高 | 非常短的声音效果，需要很高的清晰度，任何压缩都会扭曲体验。 |'
- en: '| **ADPCM** | No | Very Small | Poor | Compression results in a fair amount
    of noise, and therefore it is used for short sound effects with a lot of chaos,
    such as explosions, collisions, and impact sounds. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **ADPCM** | 否 | 非常小 | 差 | 压缩会产生相当多的噪声，因此它用于具有大量混乱的短声音效果，例如爆炸、碰撞和冲击声。 |'
- en: '| **Compressed** | No | Small/Medium | Variable | This consumes more CPU for
    decoding and should be used in most cases. This option allows us to customize
    the resulting quality level of the compression algorithm to tweak the quality
    against the file size. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **压缩** | 否 | 小/中 | 可变 | 这会消耗更多的CPU解码资源，因此在大多数情况下应使用。此选项允许我们自定义压缩算法的结果质量级别，以调整质量与文件大小的平衡。
    |'
- en: Do not forget that any additional audio effects applied to the file at runtime
    will not play through the editor in *Edit Mode*, so any changes should be thoroughly
    tested through the application in *Play Mode*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '请记住，在运行时应用于文件的任何额外音频效果在*编辑模式*中都不会通过编辑器播放，因此任何更改都应该通过*播放模式*中的应用程序彻底测试。 '
- en: Now that we have a better understanding of audio file formats, loading methods,
    and compression modes, let's explore some approaches that we can use to improve
    performance by tweaking audio behavior.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对音频文件格式、加载方法和压缩模式有了更好的理解，让我们探讨一些可以通过调整音频行为来提高性能的方法。
- en: Audio performance enhancements
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频性能提升
- en: In this section, we explore some other small but important enhancements you
    can add to your game's sound architecture to improve the overall player experience.
    We will see why it is important to minimize the audio sources in a scene, in which
    situation we should prefer mono sounds over stereo sounds, when we should prefer
    streaming over preloading, and much more.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些其他的小但重要的增强功能，您可以将它们添加到游戏的声音架构中，以改善整体玩家体验。我们将了解为什么在场景中减少音频源很重要，在什么情况下我们应该优先选择单声道声音而不是立体声音响，我们应该在什么情况下优先选择流式传输而不是预加载，以及更多。
- en: Minimizing active audio source count
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化活动音频源数量
- en: Since each actively playing audio source consumes a particular amount of CPU,
    it stands to reason that we can save CPU cycles by disabling redundant audio sources
    in our scene. One approach is to limit how many instances of an audio clip can
    be played simultaneously. This involves sending audio playback requests through
    an intermediary that controls our audio sources in such a way that it puts a hard
    cap on how many instances of an audio clip can be played simultaneously.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个正在播放的音频源都会消耗特定的 CPU 资源，因此我们可以通过在场景中禁用冗余音频源来节省 CPU 循环。一种方法是通过一个中介发送音频播放请求，该中介以这种方式控制我们的音频源，从而对可以同时播放的音频剪辑实例数设置一个硬上限。
- en: 'Almost every audio management asset available in the Unity Asset Store implements
    an audio-throttling feature of some kind (often known as *audio pooling*), and
    for good reason: it''s the best trade-off in minimizing excessive audio playback
    with the least cost in quality—for example, having 20 footstep sounds playing
    simultaneously won''t sound too much different to playing 10 of them simultaneously,
    and is less likely to become distracting by being too loud. For this reason, and
    because these tools often provide many more subtle performance-enhancing features,
    it is recommended that you use a preexisting solution rather than rolling out
    your own, as there is a lot of complexity to consider from audio file types, stereo/3D
    audio, layering, compression, filters, cross-platform capability, efficient memory
    management, and so on.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在 Unity Asset Store 中可用的所有音频管理资源都实现了某种形式的音频节流功能（通常称为 *音频池化*），这有很好的理由：这是在最小化过度音频播放的同时，以最低的质量成本进行权衡的最佳方案——例如，同时播放
    20 个脚步声听起来不会与同时播放 10 个有太大区别，并且不太可能因为声音太大而分散注意力。因此，出于这个原因，并且因为这些工具通常提供许多更细微的性能增强功能，建议您使用现有的解决方案，而不是自己开发，因为需要考虑的复杂性很多，包括音频文件类型、立体声/3D
    音频、分层、压缩、过滤器、跨平台能力、高效内存管理等等。
- en: When it comes to ambient sound effects, they still need to be placed at specific
    locations in the scene to make use of the logarithmic volume effect, which gives
    it a pseudo-3D effect, so an audio pooling system would probably not be an ideal
    solution. Limiting playback on ambient sound effects is best achieved by reducing
    the total number of audio sources. The best approach is to either remove some
    of them or reduce them down to one larger, louder audio source. Naturally, this
    approach affects the quality of the user experience since it would appear that
    the sound is coming from a single source and not multiple sources; therefore,
    it should be used with care.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到环境音效时，它们仍然需要放置在场景中的特定位置，以便利用对数音量效果，这给它带来一种伪 3D 效果，因此音频池化系统可能不是理想的解决方案。限制环境音效的播放最佳方法是通过减少音频源的总数。最佳方法是移除其中一些，或将它们减少到一个更大、更响亮的音频源。自然地，这种方法会影响用户体验的质量，因为看起来声音似乎来自单个源而不是多个源；因此，应谨慎使用。
- en: Enabling Force to Mono for 3D sounds
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 3D 声音启用强制单声道
- en: Enabling the Force to Mono setting on a stereo audio file will mix together
    the data from both audio channels into a single channel, saving 50 percent of
    the file's total disk and memory space usage effectively. Enabling this option
    is generally not a good idea for some 2D sound effects, where the stereo effect
    is often used to create a specific audio experience; however, we can enable this
    option for some good space savings on 3D positional audio clips, where the two
    channels are effectively identical. These audio source types will let the direction
    between the audio source and the player determine how the audio file gets played
    into the left/right ear, and playing a stereo effect in this case is generally
    meaningless.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在立体声音频文件上启用“强制单声道”设置会将两个音频通道的数据混合到一个通道中，从而有效地节省50%的文件总磁盘和内存空间使用量。对于一些立体声音效，其中立体声效果通常用于创造特定的音频体验，启用此选项通常不是一个好主意；然而，我们可以为一些3D位置音频剪辑启用此选项，在这些剪辑中，两个通道实际上是相同的。这些音频源类型将允许音频源和玩家之间的方向决定音频文件如何播放到左右耳朵，在这种情况下播放立体声效果通常是没有意义的。
- en: Forcing 2D sounds (sounds that play into the player's ears at full volume, regardless
    of distance/direction to the audio source) to mono might also make sense if there
    is no need for a stereo effect.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要立体声效果，将2D声音（无论距离/方向如何，都以全音量播放到玩家的耳朵中的声音）强制转换为单声道可能也有意义。
- en: Resampling to lower frequencies
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重采样到更低频率
- en: Resampling imported audio files to lower frequencies will reduce the file size
    and runtime memory footprint. This can be achieved by setting an audio file's
    Sample Rate Setting to Override Sample Rate, at which point we can configure the
    sample rate through the Sample Rate option. Some files require high sample rates
    to sound reasonable, such as files with high pitches and most music files; however,
    lower settings can reduce the file's size without noticeable quality degradation
    in most cases. Most use a 22,050 Hertz sampling rate for sources that involve
    human speech and classical music; some sound effects may be able to get away with
    even lower frequency values. However, each sound effect will be affected by this
    setting in a unique way, so it would be wise to spend some time running a few
    tests before we finalize our decision on the sampling rate.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将导入的音频文件重采样到更低频率将减小文件大小和运行时内存占用。这可以通过将音频文件的采样率设置设置为“覆盖采样率”来实现，此时我们可以通过采样率选项配置采样率。一些文件需要高采样率才能听起来合理，例如高音调文件和大多数音乐文件；然而，在大多数情况下，较低的设置可以减小文件大小，而不会引起明显的质量下降。大多数使用22,050赫兹的采样率用于涉及人类语音和古典音乐的源；一些音效可能能够以更低的频率值逃脱。然而，每个音效都会以独特的方式受到此设置的影响，因此在最终决定采样率之前，花一些时间进行一些测试是明智的。
- en: Considering all compression formats
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑所有压缩格式
- en: Each of the Compressed, PCM, and ADPCM compression formats have their own benefits
    and drawbacks, as explained previously. It's possible to make some compromises
    in memory footprint, disk footprint, CPU usage, and audio quality using different
    encoding formats for different files where appropriate. We should be willing to
    use all of them in the same application and come up with a system that works for
    the kinds of audio files we're using so that we don't need to treat each file
    individually; otherwise, we would need to do a prohibitive amount of testing to
    ensure that audio quality hasn't been degraded for each file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，压缩、PCM和ADPCM压缩格式各自都有其优势和劣势。根据不同文件的需要，使用不同的编码格式可以在内存占用、磁盘占用、CPU使用率和音频质量方面做出一些妥协。我们应该愿意在同一个应用程序中使用所有这些格式，并制定一个适用于我们使用的音频文件类型的系统，这样我们就不需要单独处理每个文件；否则，我们需要进行大量的测试以确保每个文件的音频质量没有下降。
- en: Being cautious of streaming
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谨慎对待流媒体
- en: The upside of the Streaming loading type is a low runtime memory cost, since
    a small buffer is allocated and the file is continuously pushed through it like
    a data queue. This can seem quite appealing, but streaming files from the disk
    should be restricted to large, single-instance files only, as it requires runtime
    hard disk access, which is one of the slowest forms of data access available to
    us (second only to pulling a file through a network). Layered or transitioning
    music clips may run into major hiccups using the Streaming option, at which point
    it would be wise to consider using a different Load Type and control loading/unloading
    manually.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 流式加载类型的优点是运行时内存成本低，因为分配了一个小的缓冲区，文件就像数据队列一样连续通过它。这看起来相当吸引人，但应该仅将磁盘上的流式文件限制在大型单实例文件上，因为它需要运行时硬盘访问，这是我们可用的最慢的数据访问形式之一（仅次于通过网络拉取文件）。使用流式选项，分层或过渡的音乐片段可能会遇到严重的故障，这时考虑使用不同的加载类型并手动控制加载/卸载将是明智的。
- en: We should also avoid streaming more than one file at a time, as it's likely
    to inflict a lot of cache misses on the disk that will interrupt gameplay. This
    is why this option is primarily used for background music/ambient sound effects,
    since we only need one at a time.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该避免同时流式传输多个文件，因为这很可能会在磁盘上造成大量的缓存未命中，从而中断游戏玩法。这就是为什么这个选项主要用于背景音乐/环境声音效果，因为我们一次只需要一个。
- en: Applying filter effects through mixer groups to reduce duplication
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过混音组应用过滤器效果以减少重复
- en: Filter effects can be used to modify the sound effect playing through an audio
    source, and can be accomplished through `FilterEffect` components. Each individual
    filter effect will cost a certain amount of both memory and CPU, and can be a
    good way to achieve disk space savings while maintaining a lot of variety in audio
    playback since one file could be tweaked by a different set of filters to generate
    completely different sound effects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用过滤器效果来修改通过音频源播放的声音效果，并且可以通过`FilterEffect`组件实现。每个单独的过滤器效果都会消耗一定量的内存和CPU，这是一种在保持音频播放大量多样性的同时实现磁盘空间节省的好方法，因为一个文件可以通过不同的过滤器集进行调整，从而生成完全不同的声音效果。
- en: Because of the additional overhead, overusing filter effects in our scene can
    result in dire consequences in performance. A better approach is to make use of
    Unity's audio mixer utility (Window | Audio | Audio Mixer) to generate common
    filter effect templates that multiple audio sources can reference to minimize
    the amount of memory overhead.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于额外的开销，在场景中过度使用过滤器效果可能会导致性能严重下降。更好的方法是利用Unity的音频混音实用工具（窗口 | 音频 | 音频混音）来生成多个音频源可以引用的常用过滤器效果模板，以最小化内存开销。
- en: The official tutorial on audio mixers at [https://learn.unity.com/tutorial/audio-mixing](https://learn.unity.com/tutorial/audio-mixing) covers
    the topic in excellent detail.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://learn.unity.com/tutorial/audio-mixing](https://learn.unity.com/tutorial/audio-mixing)的官方教程中，对音频混音的主题进行了详尽的介绍。
- en: Using remote content streaming responsibly
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负责任地使用远程内容流式传输
- en: It is possible to dynamically load game content via the web through Unity, which
    can be an effective means of reducing an application's disk footprint since fewer
    data files need to be bundled into the executable. This also provides a means
    to present dynamic content using web services to determine what is presented to
    the user at runtime. Asset streaming can be accomplished through the `UnityWebRequest`
    class in Unity 2017 and later.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Unity，可以动态加载游戏内容，这可以是一种有效的方法来减少应用程序的磁盘占用，因为需要捆绑到可执行文件中的数据文件更少。这也提供了一种使用网络服务来确定在运行时向用户展示什么内容的方法。在Unity
    2017及以后的版本中，可以通过`UnityWebRequest`类实现资产流式传输。
- en: The `UnityWebRequest` class makes use of the new HLAPI and LLAPI networking
    layers. This class provides various utilities to download and access what are
    primarily text files. Multimedia-based requests should go through the `UnityWebRequestMultimedia`
    helper class. So, if an `AudioClip` is requested, we should call `UnityWebRequestMultimedia.GetAudioClip()` to
    create the request and `DownloadHandlerAudioClip.GetContent()` to retrieve it
    once the download is complete.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnityWebRequest`类使用了新的HLAPI和LLAPI网络层。这个类提供了各种工具来下载和访问主要是文本文件的内容。基于多媒体的请求应通过`UnityWebRequestMultimedia`辅助类进行。因此，如果请求`AudioClip`，我们应该调用`UnityWebRequestMultimedia.GetAudioClip()`来创建请求，并在下载完成后使用`DownloadHandlerAudioClip.GetContent()`来检索它。'
- en: This new version of the API is designed to be more efficient at storing and
    providing the data we requested, and so reacquiring an `AudioClip` multiple times
    through `DownloadHandlerAudioClip.GetContent()` will not lead to additional allocations.
    Instead, it will merely return a reference to the originally downloaded `AudioClip`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API的新版本旨在在存储和提供我们请求的数据方面更加高效，因此通过`DownloadHandlerAudioClip.GetContent()`多次重新获取`AudioClip`不会导致额外的分配。相反，它只会返回对最初下载的`AudioClip`的引用。
- en: Consider using audio module files for background music
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑使用音频模块文件作为背景音乐
- en: Audio module files, also known as **tracker modules**, are an excellent means
    of saving a significant amount of space without any noticeable quality loss. Supported
    file extensions in Unity are `.it`, `.s3m`, `.xm`, and `.mod`. Unlike the common
    audio formats, which are read like streams of bits that must be decoded at runtime
    to generate a specific sound, tracker modules contain lots of small, high-quality
    samples and organize the entire track similar to a music sheet, defining when,
    where, how loud, with what pitch, and with what special effects each sample should
    be played with. This can provide significant size savings while maintaining high-quality
    sampling, so if the opportunity is available for us to make use of tracker module
    versions of our music files, then it is worth exploring.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 音频模块文件，也称为**跟踪模块**，是一种在不损失明显质量的情况下节省大量空间的绝佳方式。Unity支持以下文件扩展名：`.it`、`.s3m`、`.xm`和`.mod`。与常见的音频格式不同，这些格式像位流一样被读取，必须在运行时解码以生成特定的声音，而跟踪模块包含大量的小型、高质量样本，并像乐谱一样组织整个曲目，定义每个样本何时、何地、如何响亮、以何种音高以及使用何种特殊效果播放。这可以在保持高质量采样的同时提供显著的尺寸节省，因此，如果我们有机会使用音乐文件的跟踪模块版本，那么探索它是值得的。
- en: Texture files
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理文件
- en: 'The terms *texture* and *sprite* often get confused in game development, so
    it''s worth making the distinction: a texture is simply an image file, a big list
    of color data telling the interpreting program what color each pixel of the image
    should be, whereas a sprite can be seen as the 2D equivalent of a mesh—it defines
    how and where the image will appear in the game scene. Usually, a sprite is just
    a single *quad* (a pair of triangles combined to make a rectangular mesh) that
    renders flat against the current camera.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，*纹理*和*精灵*这两个术语经常被混淆，所以值得明确区分：纹理只是一个图像文件，一个包含颜色数据的大列表，告诉解释程序图像的每个像素应该是什么颜色，而精灵可以看作是网格的2D等价物——它定义了图像将在游戏场景中如何以及在哪里出现。通常，精灵只是一个单一的*四边形*（一对三角形组合成一个矩形网格），它以平面的方式渲染到当前相机上。
- en: There are also things called sprite sheets, which are large collections of individual
    images contained within a larger texture file, commonly used to contain the animations
    of a 2D character. These files can be split apart by tools, such as Unity's Sprite
    Atlas tool, to form individual textures for the character's animated frames.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 同样还有一些被称为精灵图集的东西，它们是包含在更大的纹理文件中的大量单个图像集合，通常用于包含2D角色的动画。这些文件可以通过工具如Unity的精灵图集工具分割开来，以形成角色动画帧的单独纹理。
- en: Of course, you can render a 2D sprite in a 3D environment; however, in essence,
    a sprite is still a 2D element in the same way a playing card is still a flat
    card, even when it is used to build a house of cards.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以在3D环境中渲染2D精灵；然而，本质上，精灵仍然是一个2D元素，就像扑克牌即使用来搭建纸牌屋也仍然是平面的卡片一样。
- en: Both meshes and sprites use textures to render an image onto its surface. Texture
    image files are typically generated in tools such as Adobe Photoshop or GIMP and
    then imported into our project in much the same way as audio files. At runtime,
    these files are loaded into memory, pushed to the GPU's VRAM, and rendered by
    a shader over the target sprite or mesh during a given draw call.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 网格和精灵都使用纹理在表面渲染图像。纹理图像文件通常在Adobe Photoshop或GIMP等工具中生成，然后以与音频文件相同的方式导入到我们的项目中。在运行时，这些文件被加载到内存中，推送到GPU的VRAM中，并在给定的绘制调用期间由着色器渲染到目标精灵或网格上。
- en: Texture compression formats
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理压缩格式
- en: Much like audio files, Unity will import texture files with a default list of
    settings that tend to keep things simple and work okay in the general case, but
    there are many import settings available, allowing us to improve a texture's quality
    and performance with some custom tweaking. Of course, making changes is just as
    likely to reduce quality and performance if we blindly make changes without fully
    understanding the internal processes going on.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与音频文件类似，Unity将以默认设置列表导入纹理文件，这些设置通常使事情保持简单，并在一般情况下表现良好，但有许多导入设置可供选择，允许我们通过一些自定义调整来提高纹理的质量和性能。当然，如果我们盲目地做出更改而不完全理解内部过程，那么做出更改同样可能导致质量和性能的降低。
- en: 'The first option is the file''s Texture Type. This setting will determine what
    other options are available, particularly under the Advanced dropdown. Not all
    importing options are available to all types, so it is best to configure this
    option for the texture''s intended purpose, whether it is set to Normal Map, Sprite,
    Lightmap, and so on, as this will reveal the options appropriate for that type:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是文件的纹理类型。此设置将确定其他可用的选项，尤其是在高级下拉菜单下。并非所有导入选项都适用于所有类型，因此最好根据纹理的预期用途配置此选项，无论是设置为正常贴图、精灵、光照贴图等，因为这将揭示适合该类型的选项：
- en: '![](img/6d0b6b2d-afb7-4ade-9d9b-380415c75309.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d0b6b2d-afb7-4ade-9d9b-380415c75309.png)'
- en: 'Similar to audio files, we can import texture files in multiple common formats
    (such as `.jpg` and `.png`), but the actual compression format built into the
    application could be one of many different texture compression formats ideally
    suited for GPUs of the given platform. These formats represent different ways
    of organizing the texture''s color information, which includes the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与音频文件类似，我们可以导入多种常见的纹理文件格式（如`.jpg`和`.png`），但应用程序中实际嵌入的压缩格式可能是许多不同的纹理压缩格式之一，这些格式非常适合给定平台的GPU。这些格式代表了组织纹理颜色信息的不同方式，包括以下内容：
- en: Different numbers of bits used to represent each channel (the more bits that
    are used, the more colors that can be represented)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于表示每个通道的不同位数（使用的位数越多，可以表示的颜色就越多）
- en: Different numbers of bits per channel (for example, the red channel may use
    more bits than the green channel)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个通道不同的位数（例如，红色通道可能比绿色通道使用更多的位数）
- en: Different total number of bits used for all channels (more bits naturally mean
    larger textures and more disk and memory consumption)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有通道使用的总位数不同（位数越多，自然意味着更大的纹理和更多的磁盘和内存消耗）
- en: Whether or not an alpha channel is included
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否包含alpha通道
- en: Perhaps the most important, different ways of packing the data together, which
    can allow for efficient memory access for the GPU (or incredibly inefficient access
    if the wrong packing type is chosen!)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也许最重要的是，数据打包的不同方式，这可以允许GPU（或如果选择了错误的打包类型，则可能非常低效）进行高效的内存访问！
- en: 'The simple way of altering compression is to use the Compression texture import
    option to select one of the following options:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 修改压缩的简单方法是使用压缩纹理导入选项来选择以下选项之一：
- en: None
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无
- en: Low Quality
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低质量
- en: Normal Quality
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常质量
- en: High Quality
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高质量
- en: Selecting None means that no compression will be applied. In this case, the
    final texture will still change the format from the file type we imported, but
    it will select a format that makes no attempt at compression, and so we should
    see little or no quality loss at the expense of large texture files. The other
    three settings will pick a compression format, which, again, will vary depending
    on the platform, and Unity will try to pick a compression format that matches
    the option. For instance, selecting Low Quality will mean that Unity picks a compression
    format that greatly reduces the texture size, but will generate some compression
    artifacts, whereas selecting High Quality will consume more memory with much larger
    texture sizes and minimal artifacts. Again, this is an automatic selection made
    by Unity.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“无”表示不会应用压缩。在这种情况下，最终的纹理仍然会从导入的文件类型转换为格式，但它将选择一种不尝试压缩的格式，因此我们应该看到在牺牲大纹理文件的情况下，质量损失很小或没有。其他三个设置将选择一个压缩格式，这同样会根据平台而变化，Unity将尝试选择与选项匹配的压缩格式。例如，选择“低质量”意味着Unity将选择一个大大减少纹理大小的压缩格式，但会产生一些压缩伪影，而选择“高质量”将消耗更多内存，具有更大的纹理大小和最少的伪影。再次强调，这是Unity自动做出的选择。
- en: The exact formats Unity picks for each platform for each of these Compression settings
    can be found at [https://docs.unity3d.com/Manual/class-TextureImporterOverride.html](https://docs.unity3d.com/Manual/class-TextureImporterOverride.html).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 为每个平台以及这些压缩设置选择的精确格式可以在[https://docs.unity3d.com/Manual/class-TextureImporterOverride.html](https://docs.unity3d.com/Manual/class-TextureImporterOverride.html)找到。
- en: The exact compression format Unity chooses can be overridden, although the available
    options vary per platform since practically every platform has its own custom
    formats that work best for it. If we click on one of the platform-specific tabs
    beside the Default tab (just above the Max Size option), we will expose the settings
    for a specific platform and can choose the exact compression format we want Unity
    to use.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 选择的精确压缩格式可以被覆盖，尽管由于实际上每个平台都有自己的最佳自定义格式，因此可用的选项因平台而异。如果我们点击默认选项卡（位于最大尺寸选项上方）旁边的特定平台选项卡之一，我们将暴露特定平台的设置，并可以选择
    Unity 要使用的确切压缩格式。
- en: There is also the Crunch Compression setting, which will apply an additional
    level of lossy compression on top of the DXT compression format. This option is
    only revealed if the other compression settings result in a DXT level of compression.
    This setting can save even more space at the cost of potentially glaring compression
    artifacts, depending on the Compressor Quality setting.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有 Crunch Compression 设置，它将在 DXT 压缩格式之上应用额外的有损压缩级别。此选项仅在其他压缩设置导致 DXT 压缩级别时才会显示。此设置可以在牺牲可能显眼的压缩伪影的情况下节省更多空间，具体取决于压缩质量设置。
- en: Several of a texture's import settings are fairly mundane, such as determining
    whether the file contains an alpha channel, how to wrap the texture at its extents,
    the filtering method, and the maximum possible resolution of the file (a global
    limit so that we don't accidentally overscale the texture beyond its original
    size on certain platforms). However, there are several other interesting options
    in these import settings, which we will cover in other sections where appropriate.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理的几个导入设置相当普通，例如确定文件是否包含 alpha 通道，如何在其边缘包裹纹理，过滤方法，以及文件的最大可能分辨率（一个全局限制，以防止我们意外地将纹理放大超过其原始大小，在某些平台上）。然而，在这些导入设置中还有一些其他有趣的选择，我们将在适当的部分中介绍。
- en: Texture performance enhancements
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理性能提升
- en: Let's explore some changes that we can make to our texture files, which might
    help improve performance, depending on the situation and the content of the files
    we're importing. In each case, we'll explore the changes that need to be made
    and the overall effect they have, whether this results in a positive or negative
    impact on memory or CPU, an increase or decrease in the texture quality, and under
    what conditions we can expect to make use of these techniques.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨一下我们可以对我们的纹理文件进行的更改，这些更改可能会根据情况以及我们导入的文件内容来提高性能。在每种情况下，我们将探讨需要进行的更改以及它们产生的总体影响，无论是正面还是负面对内存或
    CPU 的影响，纹理质量的增加或减少，以及我们可以在什么条件下使用这些技术。
- en: Reducing texture file size
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少纹理文件大小
- en: The larger a given texture file, the more GPU memory bandwidth will be consumed,
    pushing the texture when it is needed. If the total memory pushed per second exceeds
    the graphics card's total memory bandwidth, then we will have a bottleneck, as
    the GPU must wait for all textures to be uploaded before the next rendering pass
    can begin. Smaller textures are naturally easier to push through the pipeline
    than larger textures, so we will need to find a good middle ground between high
    quality and performance.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 给定纹理文件越大，将消耗更多的 GPU 内存带宽，在需要时推动纹理。如果每秒推送到内存中的总量超过显卡的总内存带宽，那么我们将遇到瓶颈，因为 GPU 必须等待所有纹理上传完毕，才能开始下一个渲染过程。较小的纹理比较大的纹理更容易通过管道，因此我们需要在高质量和性能之间找到一个良好的平衡点。
- en: A simple test to find out whether we're bottlenecked in memory bandwidth is
    to reduce the resolution of our game's largest and most abundant texture files
    and relaunch the scene. If the frame rate suddenly improves, then the application
    was most likely bound by texture throughput. If the frame rate does not improve
    or improves very little, then either we still have some memory bandwidth to make
    use of or there are bottlenecks elsewhere in the rendering pipeline, preventing
    us from seeing any further improvement.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的测试来确定我们是否在内存带宽上受到瓶颈的方法是降低我们游戏最大和最丰富的纹理文件分辨率并重新启动场景。如果帧率突然提高，那么应用程序很可能是受纹理吞吐量限制。如果帧率没有提高或提高很少，那么我们可能还有一些内存带宽可以利用，或者渲染管道中的其他地方存在瓶颈，阻止我们看到任何进一步的改进。
- en: Using mipmaps wisely
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能使用mipmap
- en: There would be no point rendering small, distant objects, such as rocks and
    trees, with a high-detail texture if there's no way the player would ever be able
    to see that detail. Of course, they may see some slight improvement, but the performance
    cost may not be worth the minor detail increase. Mipmaps were invented as a way
    to solve this problem (as well as to help eliminate aliasing problems that were
    plaguing video games at around the same time) by pregenerating lower-resolution
    alternatives of the same texture and keeping them together in the same memory
    space. At runtime, the GPU picks the appropriate mipmap level based on how large
    the surface appears within the perspective view (essentially based on the texel-to-pixel
    ratio when the object is rendered).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家永远无法看到这些细节，那么就没有必要用高细节纹理渲染小而远的物体，如岩石和树木。当然，他们可能会看到一些轻微的改进，但性能成本可能不值得细节的微小增加。mipmap的发明是为了解决这个问题（以及帮助消除大约在同一时间困扰视频游戏的走样问题），通过预先生成相同纹理的较低分辨率的替代品，并将它们保存在相同的内存空间中。在运行时，GPU根据表面在透视视图中的大小选择适当的mipmap级别（基本上是基于当对象被渲染时的texel到像素的比率）。
- en: By enabling the Generate Mip Maps setting, Unity automatically handles the generation
    of these lower-resolution copies of the texture. These alternatives are generated
    using high-quality resampling and filtering methods within the editor rather than
    during runtime. There are several other options available for mipmap generation
    that can affect the quality of the generated levels, so some tweaking may be required
    to get a high-quality set of mipmaps. We will need to decide whether the time
    spent tweaking these values is worth it since the whole purpose of mipmaps is
    to intentionally reduce quality to save performance in the first place.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启用生成Mipmap设置，Unity自动处理这些纹理的较低分辨率副本的生成。这些替代品是在编辑器中使用高质量的重采样和过滤方法生成的，而不是在运行时。还有其他几种可用于mipmap生成的选项，这些选项会影响生成的级别质量，因此可能需要一些调整才能获得高质量的mipmap集。我们需要决定花费在这些值上的时间是否值得，因为mipmap的整个目的就是有意降低质量，首先是为了节省性能。
- en: 'The following image shows how a 1024 x 1024 image that has been mipmapped into
    multiple lower-resolution images duplicates:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了如何将1024 x 1024的图像mipmap到多个较低分辨率的图像的重复：
- en: '![](img/436083f8-d2a6-418c-88d0-90545e3bfd0b.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/436083f8-d2a6-418c-88d0-90545e3bfd0b.png)'
- en: These images will be packed together to save space, essentially creating a final
    texture file that will be about 33 percent larger than the original image. This
    will cost some disk space and GPU memory bandwidth to upload.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图像将被打包在一起以节省空间，本质上创建了一个最终纹理文件，该文件将比原始图像大33%。这将消耗一些磁盘空间和GPU内存带宽来上传。
- en: 'Since Unity 2018.2, there is another way to load mipmaps: streaming. As in
    the audio case, mipmap streaming is used to reduce the memory needed to keep in
    memory the multiple textures of a mipmap without sacrificing the quality. In fact,
    if we enable mipmap streaming, then Unity will try to load on the fly from disk
    only the correct resolution of a texture on the basis of the camera position in
    the scene. This can save up to 30% of texture memory depending on the scene (and
    the player''s position).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Unity 2018.2以来，还有另一种加载mipmap的方法：流式传输。正如音频案例中一样，mipmap流式传输用于减少内存需求，以保持内存中多个mipmap纹理，同时不牺牲质量。实际上，如果我们启用mipmap流式传输，那么Unity将尝试根据场景中摄像机的位置动态地从磁盘加载纹理的正确分辨率。这可以根据场景（以及玩家的位置）节省高达30%的纹理内存。
- en: However, this comes at a price. First of all, streaming a mipmap is slower than
    generation; therefore, if you have instantaneous camera cuts or you move quickly,
    you can start noticing the texture quality change as the mipmaps are loaded. This
    can be mitigated by using the mipmap streaming API in order to preload the mipmaps
    in the destination location.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也有代价。首先，米级贴图的流式传输比生成慢；因此，如果你有瞬间的相机切换或者快速移动，你可能会开始注意到纹理质量的变化，因为米级贴图正在加载。这可以通过使用米级贴图流式传输API来缓解，以便在目标位置预加载米级贴图。
- en: Second, mipmap streaming may not be supported on all platforms at the moment.
    If you want to be sure that mipmap streaming is supported on your platform, you
    can check the `SystemInfo.supportsMipStreaming` property.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，目前可能并非所有平台都支持米级贴图流式传输。如果你想确保你的平台支持米级贴图流式传输，你可以检查`SystemInfo.supportsMipStreaming`属性。
- en: If you want more information on texture streaming, you can check the detailed
    page in the manual at [https://docs.unity3d.com/Manual/TextureStreaming-API.html](https://docs.unity3d.com/Manual/TextureStreaming-API.html).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于纹理流的信息，你可以查看手册中的详细页面[https://docs.unity3d.com/Manual/TextureStreaming-API.html](https://docs.unity3d.com/Manual/TextureStreaming-API.html)。
- en: It's possible to see which mipmap levels are being used by our application at
    certain points by changing the Draw Mode setting of the Scene window to Mipmaps.
    This will highlight textures in red if they are larger than they should be, given
    the player's current view (the extra detail is wasted), whereas being highlighted
    blue means that they are too small (the player is observing a low-quality texture
    with a poor texel-to-pixel ratio).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将场景窗口的绘制模式设置为米级贴图，在某些点上看到应用程序正在使用哪些米级贴图级别。如果纹理比根据玩家当前视图应该的大小更大（额外的细节被浪费了），则会用红色突出显示纹理；而用蓝色突出显示则意味着它们太小（玩家正在观察一个低质量的纹理，具有较差的像素比）。
- en: Remember that mipmapping is only useful if we have textures that need to be
    rendered at varying distances from the camera. If we have textures that always
    render at a common distance from the main camera in such a way that the mipmapped
    alternatives are never used, then enabling mipmaps is just a waste of space. Similarly,
    if we happen to have a texture that always resolves to the same mipmap level because
    the player's camera never gets too close/far away to switch levels, then it would
    be wiser to simply downscale the original texture.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，只有当我们有需要在相机不同距离处渲染的纹理时，米级贴图才有用。如果我们有始终在主相机以相同距离渲染的纹理，这样米级贴图的替代品永远不会被使用，那么启用米级贴图只是浪费空间。同样，如果我们恰好有一个始终解析到相同的米级贴图级别，因为玩家的相机永远不会太近或太远以切换级别，那么简单地降低原始纹理的分辨率会更明智。
- en: Good examples of this would be any texture file used in a 2D game, textures
    used by UI systems, or those used in a Skybox or distant background, since, by
    design, these textures will always be about the same distance from the camera,
    so mipmapping would be essentially pointless. Other good examples include objects
    that only appear near the player, such as player-centric particle effects, characters,
    objects that only appear near the player, and objects that only the player can
    hold/carry.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的良好例子包括任何用于2D游戏的纹理文件，UI系统使用的纹理，或者用于Skybox或远背景的纹理，因为这些纹理在设计上总是与相机保持相同的距离，所以米级贴图基本上是没有意义的。其他好的例子包括仅出现在玩家附近的物体，如以玩家为中心的粒子效果、角色、仅出现在玩家附近的物体，以及只有玩家可以持有/携带的物体。
- en: Managing resolution downscaling externally
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部管理分辨率降低
- en: Unity puts a lot of effort into making things as easy to use as possible and
    provides us with the ability to place the project files from external tools to
    our project workspace, such as `.PSD` and `.TIFF` files, which are often large
    and split into multiple layered images. Unity automatically generates a texture
    file from the file's contents for the rest of the engine to make use of, which
    can be very convenient, as we only need to maintain a single copy of the file
    through source control, and the Unity copy is automatically updated when an artist
    makes changes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Unity致力于使事物尽可能易于使用，并为我们提供了将来自外部工具的项目文件放置到我们的项目工作空间的能力，例如`.PSD`和`.TIFF`文件，这些文件通常很大，并且被分割成多个层级的图像。Unity会自动从文件内容生成一个纹理文件，以便其余的引擎可以使用，这可以非常方便，因为我们只需要通过源控制维护文件的单一副本，当艺术家进行更改时，Unity的副本会自动更新。
- en: The problem is that the aliasing introduced by Unity's autotexture generation
    and compression techniques from these files may not be as good as what the texture-editing
    tools we use could generate for us. Unity is very feature-rich and, first and
    foremost, focuses on being a game-development platform, which means that it can
    have difficulty competing in areas that other software developers work on full
    time. Unity may be introducing artifacts through aliasing as a result of downscaling
    the image for us, and so we might find ourselves working around it by importing
    image files with a higher resolution than necessary just to keep the intended
    quality level; however, had we downscaled the image through the external application
    first, we might have suffered much less aliasing. In these cases, we may achieve
    an acceptable level of quality with a lower resolution, while consuming less overall
    disk and memory space.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，Unity从这些文件自动生成和压缩纹理引入的锯齿可能不如我们使用的纹理编辑工具为我们生成的效果。Unity功能丰富，首先和最重要的是作为一个游戏开发平台，这意味着它在与其他软件开发人员全职工作的领域可能难以竞争。Unity可能通过缩小图像为我们引入了锯齿伪影，因此我们可能发现自己通过导入比必要的更高分辨率的图像文件来绕过它，只是为了保持预期的质量水平；然而，如果我们首先通过外部应用程序缩小图像，我们可能遭受的锯齿伪影会少得多。在这些情况下，我们可能以较低的分辨率达到可接受的质量水平，同时消耗更少的总磁盘和内存空间。
- en: We can either avoid using `.PSD` and `.TIFF` files within our Unity project
    as a matter of habit (storing them elsewhere and importing the downscaled version
    into Unity) or just perform some occasional testing to ensure that we're not wasting
    file size, memory, and GPU memory bandwidth using larger resolution files than
    necessary. This costs us some convenience in project file management, but can
    provide some significant savings for some textures if we're willing to spend the
    time comparing the different downscaled versions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以养成在Unity项目中避免使用`.PSD`和`.TIFF`文件的习惯（将它们存储在其他地方并将缩放后的版本导入Unity），或者只是偶尔进行一些测试以确保我们没有使用比必要的更高分辨率的文件浪费文件大小、内存和GPU内存带宽。这可能会在项目文件管理上给我们带来一些不便，但如果我们愿意花时间比较不同的缩放版本，这可能会为某些纹理节省一些显著的存储空间。
- en: Adjusting anisotropic filtering levels
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整各向异性过滤级别
- en: 'Anisotropic filtering is a feature that improves the image quality of textures
    when they are viewed at very oblique (shallow) angles. The following screenshot
    shows the classic example of painted lines on a road with and without anisotropic
    filtering applied:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 各向异性过滤是一种在纹理以非常斜角（浅角度）查看时提高纹理图像质量的功能。以下截图显示了应用和不应用各向异性过滤的绘制道路线条的经典示例：
- en: '![](img/6be0a82d-eefa-46a4-a0f1-cf73ecf345a8.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6be0a82d-eefa-46a4-a0f1-cf73ecf345a8.png)'
- en: In either case, the painted lines close to the camera appear fairly clear, but
    things change as they get further away from the camera. Without anisotropic filtering,
    the distant painted lines get more and more blurry and distorted, whereas these
    lines remain crisp and clear with anisotropic filtering applied.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，靠近摄像机的绘制线条看起来相当清晰，但随着它们远离摄像机，情况会发生变化。没有各向异性过滤，远处的绘制线条会越来越模糊和扭曲，而应用了各向异性过滤的线条则保持清晰和清晰。
- en: The strength of anisotropic filtering applied to the texture can be hand modified
    on a per-texture basis with the Aniso Level setting, as well as globally enabled/disabled
    using the Anisotropic Textures option within the Edit | Project | Quality settings.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过Aniso Level设置在每个纹理的基础上手动修改应用于纹理的各向异性过滤强度，以及通过Edit | Project | Quality设置中的Anisotropic
    Textures选项全局启用/禁用。
- en: Much like mipmapping, this effect can be costly and, sometimes, unnecessary.
    If there are textures in our scene that we are certain will never be viewed at
    an oblique angle (such as distant background objects, UI elements, and billboard
    particle effect textures), then we can safely disable anisotropic filtering for
    them to save runtime overhead. We can also consider adjusting the strength of
    the anisotropic filtering effect on a per-texture basis to find the magic spot
    between quality and performance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与mipmap类似，这种效果可能会很昂贵，有时甚至是不必要的。如果我们确定场景中的某些纹理永远不会以斜角（例如远处的背景对象、UI元素和横幅粒子效果纹理）被查看，那么我们可以安全地禁用这些纹理的各向异性过滤以节省运行时开销。我们还可以考虑根据每个纹理调整各向异性过滤效果的强度，以找到质量和性能之间的最佳平衡点。
- en: Consider atlasing
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑使用纹理集
- en: Atlasing is the technique of combining lots of smaller, isolated textures together
    into a single, large texture file in order to minimize the number of materials,
    and therefore draw calls, we need to use. This is effectively a means to exploit
    dynamic batching. Conceptually, this technique is very similar to the approaches
    of minimizing material usage that you learned in Chapter 3, *The Benefits of Batching*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Atlasing是将许多较小的、孤立的纹理组合成一个单独的大纹理文件的技术，以最小化所需的材质数量和绘制调用次数。这实际上是一种利用动态批处理的方法。从概念上讲，这种技术与你在第3章“批处理的好处”中学到的最小化材质使用的方法非常相似。
- en: 'Each unique material will require an additional draw call, but each material only
    supports a single primary texture. Of course, they can also support multiple secondary
    textures, such as normal maps and emission maps. However, by combining multiple
    primary textures into a single large texture file, we can minimize the number
    of draw calls used to render objects that share this texture:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每种独特的材质都需要额外的绘制调用，但每种材质仅支持一个主纹理。当然，它们也可以支持多个次级纹理，例如法线贴图和发射贴图。然而，通过将多个主纹理组合成一个单独的大纹理文件，我们可以最小化渲染共享此纹理的对象所需的绘制调用次数：
- en: '![](img/26f35ace-e607-4955-94a9-15fd539ae6e8.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26f35ace-e607-4955-94a9-15fd539ae6e8.png)'
- en: 'Extra work is required to modify the UV coordinates used by the mesh or sprite
    object to only sample the portion of the larger texture file that it needs, but
    the benefits are clear: reducing draw calls results in the reduction of CPU workload
    and improvement in the frame rate if our application is bottlenecked on the CPU.
    Assuming that the merged texture file''s resolution is equivalent to that of all
    of the combined images, there will be no loss of quality, and memory consumption
    will be essentially identical. Note that atlasing does not result in reduced memory
    bandwidth consumption since the amount of data being pushed to the GPU would also
    be identical. It just happens to be bundled together in one bigger texture file.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 需要额外的工作来修改网格或精灵对象使用的UV坐标，以便仅采样它所需的大纹理文件的部分，但好处是显而易见的：减少绘制调用会导致CPU工作负载的减少，如果我们的应用程序在CPU上成为瓶颈，则帧率会提高。假设合并的纹理文件分辨率等同于所有组合图像的分辨率，将不会损失质量，内存消耗也将基本相同。请注意，图集化不会减少内存带宽消耗，因为推送到GPU的数据量也将是相同的。它只是恰好被捆绑在一个更大的纹理文件中。
- en: Atlasing is only an option when all of the given textures require the same shader.
    If some of the textures need unique graphical effects applied through shaders,
    then they must be isolated into their own materials and atlased in separate groups.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当所有给定的纹理都需要相同的着色器时，Atlasing才是一个选项。如果某些纹理需要通过着色器应用独特的图形效果，那么它们必须被隔离到它们自己的材质中，并在单独的组中进行图集化。
- en: Atlasing is a common tactic applied to UI elements and in games that feature
    a lot of 2D graphics. Atlasing becomes practically essential when developing mobile
    games with Unity since draw calls tend to be the most common bottleneck on those
    platforms. However, we would not want to generate these atlas files manually.
    Life would be much simpler if we could continue to edit our textures individually
    and automate the task of combining them into a larger file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中开发移动游戏时，Atlasing成为了一种常见的策略，尤其是在包含大量2D图形的游戏中。当在Unity中开发移动游戏时，由于绘制调用通常是这些平台上的最常见瓶颈，Atlasing变得实际上至关重要。然而，我们并不希望手动生成这些图集文件。如果我们能够继续单独编辑我们的纹理并自动化将它们组合成更大文件的任务，生活将会简单得多。
- en: Many GUI-related tools in the Unity Asset Store provide an automated texture-atlasing
    feature. There are some standalone programs scattered across the internet that
    can handle this work, and Unity can generate atlases for sprites in the form of
    assets. These can be created by going to Asset | Create | Sprite Atlas.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Unity Asset Store中的许多与GUI相关的工具都提供了自动纹理图集功能。互联网上散布着一些可以处理这项工作的独立程序，Unity还可以以资产的形式生成精灵图集。这些可以通过访问“资产”|“创建”|“精灵图集”来创建。
- en: Check out the Unity documentation to discover more about this useful feature
    at [https://docs.unity3d.com/Manual/class-SpriteAtlas.html](https://docs.unity3d.com/Manual/class-SpriteAtlas.html).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Unity文档以了解更多关于这个有用功能的信息，请访问[https://docs.unity3d.com/Manual/class-SpriteAtlas.html](https://docs.unity3d.com/Manual/class-SpriteAtlas.html)。
- en: Note that the sprite atlas feature effectively supplants the sprite packer tool
    from older versions of Unity.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，精灵图集功能实际上取代了Unity旧版本中的精灵打包工具。
- en: Atlasing does not need to be applied to 2D graphics and UI elements either.
    We can apply this technique to 3D meshes if we happen to be creating a lot of
    low-resolution textures. 3D games that feature simple texture resolutions or a
    flat-shaded, low-poly art style are ideal candidates for atlasing in this way.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 地图纹理化也不必应用于2D图形和UI元素。如果我们碰巧在创建大量低分辨率纹理，我们可以将这项技术应用于3D网格。具有简单纹理分辨率或平面着色、低多边形艺术风格的3D游戏是这种方式进行地图纹理化的理想候选者。
- en: However, because dynamic batching affects only nonanimated meshes (that is,
    `MeshRenderer`, but not `SkinnedMeshRenderer`), there is no reason to combine
    texture files for animated characters into an atlas. Since they are animated,
    the GPU needs to multiply each object's bones by the transform of the current
    animation state. This means that a unique calculation is needed for each character,
    and they will result in an extra draw call regardless of any attempts we make
    to have them share materials.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于动态分批处理仅影响非动画网格（即`MeshRenderer`，但不包括`SkinnedMeshRenderer`），将动画角色的纹理文件组合到图集中是没有必要的。由于它们是动画的，GPU需要将每个对象的骨骼乘以当前动画状态的变化。这意味着每个角色都需要进行独特的计算，并且无论我们尝试让它们共享材质，它们都会导致额外的绘制调用。
- en: As a result, combining textures for animated characters should be done only
    as a matter of convenience and space-saving; for example, in a flat-shaded, low-poly
    art style game, where everything happens to use a common color palette, we can
    make some space savings using a single texture for the entire game world, objects,
    and characters.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将纹理组合用于动画角色应该仅作为方便和节省空间的措施；例如，在平面着色、低多边形艺术风格的游戏中，如果一切使用的是公共调色板，我们可以通过使用单个纹理来为整个游戏世界、物体和角色节省空间。
- en: The disadvantages of atlasing are mostly in terms of development time and workflow
    costs. It requires a lot of effort to overhaul an existing project to make use
    of atlasing, which can be a lot of work just to figure out whether it is worth
    the effort or not. In addition, we need to be aware of generating texture files
    that are too large for the target platform.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 地图纹理化的缺点主要在于开发时间和工作流程成本。为了利用地图纹理化，需要对现有项目进行大量努力进行彻底的改造，这仅仅是为了确定是否值得付出这些努力，就可能是一项繁重的工作。此外，我们还需要注意生成对于目标平台来说过大的纹理文件。
- en: Some devices (specifically mobile devices) have a relatively low limit on the
    size of the textures that can be pulled into the lowest memory cache of the GPU.
    If the atlased texture file is too large, then it must be broken up into smaller
    textures in order to fit the target memory space. If the device's GPU happens
    to need textures from different pieces of the atlas every other draw call, then
    not only will we inflict a lot of cache misses, but we also might find that we
    choke the memory bandwidth, as textures are constantly pulled from VRAM and the
    lower-level cache.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一些设备（特别是移动设备）对可以拉入GPU最低内存缓存的纹理大小有相对较低的限制。如果图集纹理文件过大，则必须将其拆分为较小的纹理，以便适应目标内存空间。如果设备的GPU在每次绘制调用时都需要来自图集不同部分的纹理，那么我们不仅会引发大量的缓存未命中，还可能发现我们阻塞了内存带宽，因为纹理不断地从VRAM和低级缓存中拉取。
- en: We would probably not have this problem if the atlas was left as individual
    textures. The same texture swapping will occur, but will result in much smaller
    files being swapped at the cost of additional draw calls. Our best options at
    this stage would be to lower the Atlas resolution or generate multiple smaller
    atlases to have better control over how they will be dynamically batched.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将图集保留为单独的纹理，我们可能就不会遇到这个问题。相同的纹理交换将会发生，但代价是额外的绘制调用，将导致交换的文件更小。在这个阶段，我们最好的选择可能是降低图集的分辨率或生成多个较小的图集，以便更好地控制它们如何动态分批处理。
- en: Atlasing is clearly not a perfect solution, and if it is not clear whether it
    would result in a performance benefit, then we should be careful not to waste
    too much time on its implementation. Speaking very generally, mobile games with
    a very simplistic 2D art style probably won't need to make use of atlasing; however,
    mobile games attempting to compete with high-quality assets or use any kind of
    3D graphics should probably start integrating atlasing from the very beginning
    of development, since it is likely that the project will reach texture throughput
    limits very quickly. They may even need to apply many per-platform and per-device
    optimizations in order to reach a wide audience.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理合成显然不是完美的解决方案，如果我们不确定它是否会带来性能上的好处，那么我们应该小心不要在其实施上浪费太多时间。非常一般地说，具有非常简单的2D艺术风格的移动游戏可能不需要使用纹理合成；然而，试图与高质量资产竞争或使用任何类型的3D图形的移动游戏可能应该从开发初期就开始整合纹理合成，因为项目很可能很快就会达到纹理吞吐量限制。他们甚至可能需要针对每个平台和每个设备进行许多优化，以便达到广泛的受众。
- en: Meanwhile, we should consider applying atlasing to high-quality desktop games
    only if our draw call count exceeds reasonable hardware expectations, since we will
    want many of our textures to maintain high resolutions for maximum quality. Low-quality
    desktop games can probably afford to avoid atlasing since draw calls are unlikely
    to be the biggest bottleneck.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们应该考虑只有在我们的绘制调用次数超过合理的硬件预期时才将纹理合成应用于高质量桌面游戏，因为我们希望许多纹理保持高分辨率以获得最佳质量。低质量桌面游戏可能可以承担避免纹理合成的费用，因为绘制调用不太可能是最大的瓶颈。
- en: Of course, no matter what the product is, if we're ever limited in CPU by too
    many draw calls and have already exhausted many of the alternative techniques,
    then atlasing is a very effective performance enhancement in most cases.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，无论产品是什么，如果我们因为过多的绘制调用而受到CPU的限制，并且已经用尽了多种替代技术，那么在大多数情况下，纹理合成是一种非常有效的性能提升方法。
- en: Adjusting compression rates for nonsquare textures
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整非方形纹理的压缩率
- en: Texture files are normally stored in a square, power-of-two format, meaning
    that their height and width are equal in length, and its size is a power of two—for
    example, some typical sizes are 256 x 256 pixels, 512 x 512, and 1024 x 1024,
    and so on.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理文件通常以平方、2的幂格式存储，这意味着它们的高度和宽度长度相等，其大小是2的幂——例如，一些典型的尺寸是256 x 256像素、512 x 512和1024
    x 1024，等等。
- en: It is possible to provide rectangular power-of-two textures (such as 256 x 512)
    or those with a non-power-of-two format (such as 192 x 192), but creating textures
    such as these is not recommended. Some GPUs require square texture formats, so
    Unity will compensate by automatically expanding the texture to include additional
    empty space in order to fit the form factor that the GPU expects, which will result
    in additional memory bandwidth costs, pushing what is essentially unused and useless
    data to the GPU. Other GPUs may support non-power-of-two textures, but this is
    likely to result in slower sampling than a square texture.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 提供矩形2的幂纹理（如256 x 512）或非2的幂格式（如192 x 192）是可能的，但创建这样的纹理是不推荐的。一些GPU需要平方纹理格式，因此Unity将通过自动扩展纹理以包括额外的空空间来适应GPU期望的格式，这将导致额外的内存带宽成本，将实际上未使用且无用的数据推送到GPU。其他GPU可能支持非2的幂纹理，但这可能比平方纹理的采样速度慢。
- en: So the first recommendation is to avoid nonsquare and/or non-power-of-two textures
    altogether. If the image can be placed within a square, power-of-two texture and
    does not result in too much quality degradation due to squeezing/stretching, then
    we should apply those changes just to keep the CPU and GPU happy. As a second
    option, we can customize this scaling behavior in Unity through the texture file's
    `Non Power of 2` import setting, though because this is an automated process,
    it might not give us the graphical quality we expect.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一个建议是完全避免非方形和/或非2的幂纹理。如果图像可以放置在平方、2的幂纹理中，并且不会因为挤压/拉伸而导致太多质量下降，那么我们应该只应用这些更改，以保持CPU和GPU的满意。作为第二个选项，我们可以通过Unity中的纹理文件`非2的幂`导入设置来定制这种缩放行为，尽管这是一个自动化的过程，它可能不会给我们带来预期的图形质量。
- en: Sparse textures
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 稀疏纹理
- en: Sparse textures, also known as **mega-textures** or **tiled-textures**, provide
    a way of effectively streaming texture data from disk at runtime. Relatively speaking,
    if the CPU performs operations in the order of seconds, then the disk would operate
    in the order of days. So the common advice is that hard-disk access during gameplay
    should be avoided as much as possible since any such technique risks inflicting
    more disk access than available, causing our application to grind to a halt.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏纹理，也称为**大纹理**或**瓦片纹理**，提供了一种在运行时从磁盘有效流式传输纹理数据的方法。相对而言，如果CPU的操作速度以秒为单位，那么磁盘的操作速度将以天为单位。因此，常见的建议是在游戏过程中应尽可能避免硬盘访问，因为任何此类技术都可能造成比可用更多的硬盘访问，导致我们的应用程序陷入停滞。
- en: However, sparse texturing offers some interesting performance-saving techniques
    if we're smart about starting data transfer for portions of the texture before
    we need them. Sparse texturing is prepared by combining many textures into an
    enormous texture file that would be far too large to load into graphics memory
    as a single texture file. This is similar to the concept of atlasing, except the
    file containing the textures is incredibly large—for example,  32,768 x 32,768
    pixels—and would contain considerable color detail, such as 32 bits per pixel
    (this would result in a texture file that consumes 4 GBs of disk space). The idea
    is to save large amounts of runtime memory and memory bandwidth by hand-picking
    small subsections of the texture to load from the disk dynamically, pulling them
    from the disk moments before they are needed in the game. The main cost of this
    technique is the file size requirement and the potentially continuous disk access.
    Other costs for this technique can be overcome, but normally take a great deal
    of scene preparation work.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们聪明地提前开始传输纹理部分的数据，稀疏纹理提供了一些有趣的性能节省技术。稀疏纹理是通过将许多纹理组合成一个巨大的纹理文件来准备的，这个文件如果作为一个单独的纹理文件加载到图形内存中将会太大。这与图集的概念类似，但包含纹理的文件非常大——例如，32,768
    x 32,768像素——并且会包含相当多的颜色细节，如每像素32位（这将导致一个消耗4 GB磁盘空间的纹理文件）。想法是通过手动选择纹理的小部分来动态地从磁盘加载，在游戏需要它们之前的一瞬间从磁盘拉取它们，从而节省大量的运行时内存和内存带宽。这种技术的成本主要是文件大小要求以及可能持续的磁盘访问。这种技术的其他成本可以克服，但通常需要大量的场景准备工作。
- en: The game world needs to be created in such a way that it minimizes the amount
    of texture swapping taking place. In order to avoid very noticeable *texture popping* problems,
    texture subsections must be pulled from a disk into RAM with just enough time
    to spare that the GPU does not need to wait before the transfer to VRAM can begin
    (in much the same way that it normally doesn't need to wait for ordinary texture
    files that are preloaded into RAM). This takes place in the design of the texture
    file itself by keeping common elements for a given scene in the same general area
    of the texture, and the design of the scene, by triggering new texture subsection
    loading at key moments during gameplay and making sure that disk access of the
    new tile is quickly located by the disk without extreme cache misses. If it is
    handled with care, then sparse texturing can result in impressive benefits in
    both scene quality and memory savings.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏世界需要以这种方式创建，以最大限度地减少纹理交换的数量。为了避免非常明显的**纹理闪烁**问题，纹理子部分必须从磁盘拉入RAM，留出足够的时间，这样GPU不需要等待就可以开始传输到VRAM（与它通常不需要等待预先加载到RAM中的普通纹理文件的方式非常相似）。这通过在纹理文件的设计中保持给定场景的常见元素在纹理的相同区域，以及通过在游戏过程中的关键时刻触发新的纹理子部分加载，并确保新瓦片的磁盘访问可以快速定位，而不会出现极端的缓存缺失来实现。如果处理得当，稀疏纹理可以在场景质量和内存节省方面带来令人印象深刻的效益。
- en: It is a highly specialized technique in the gaming industry and has not yet
    been widely adopted, partly because it requires specialized hardware and platform
    support and partly because it is difficult to pull it off well. The Unity documentation
    on sparse texturing has improved somewhat over time and provides an example scene
    showing the effect at work, which can be found at [http://docs.unity3d.com/Manual/SparseTextures.html](http://docs.unity3d.com/Manual/SparseTextures.html).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在游戏行业中的一个高度专业化的技术，尚未得到广泛应用，部分原因是因为它需要专门的硬件和平台支持，部分原因是因为很难做得很好。Unity关于稀疏纹理的文档随着时间的推移有所改进，并提供了一个示例场景，展示了其效果，可以在[http://docs.unity3d.com/Manual/SparseTextures.html](http://docs.unity3d.com/Manual/SparseTextures.html)找到。
- en: For Unity developers who consider themselves advanced enough to experiment with
    sparse texturing, it might be worth taking the time to perform some research to
    check whether sparse texturing is right for their project since it promises some
    significant performance savings.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于认为自己足够高级可以尝试稀疏纹理的Unity开发者来说，花时间进行一些研究以检查稀疏纹理是否适合他们的项目可能是值得的，因为它承诺可以节省一些显著的性能。
- en: Procedural materials
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序材质
- en: Procedural materials, also known as **substances**, are a means of procedurally
    generating textures at runtime by combining small, high-quality texture samples
    with custom mathematical formulas. The goal of procedural materials is to greatly
    minimize the application disk footprint at the cost of additional runtime memory
    and CPU processing during initialization to generate the texture via mathematical
    operations rather than static color data.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 程序材质，也称为**材质**，是一种在运行时通过结合小而高质量的纹理样本和自定义数学公式来程序生成纹理的方法。程序材质的目标是在初始化期间通过数学运算而不是静态颜色数据生成纹理，以牺牲额外的运行时内存和CPU处理能力，从而大大减少应用程序的磁盘占用。
- en: Texture files are, sometimes, the biggest disk space consumer of a game project,
    and it's fairly common knowledge that download times have a tremendous negative
    impact on the completed download rate and getting people to try our game (even
    if it's free). Procedural materials offer us the ability to sacrifice some initialization
    and runtime processing power for much faster downloads. This is very important
    for mobile games that are trying to compete via graphical fidelity.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理文件有时是游戏项目最大的磁盘空间消费者，而且下载时间对完成下载速度和让人们尝试我们的游戏（即使它是免费的）有巨大的负面影响是众所周知的事实。程序材质允许我们牺牲一些初始化和运行时处理能力以换取更快的下载速度。这对于试图通过图形保真度竞争的移动游戏来说非常重要。
- en: As for Unity 2019, procedural materials are no longer part of Unity. Instead,
    they are offered as a separate plugin. You can check more about substances on
    the official page at [https://www.substance3d.com/integrations/substance-in-unity](https://www.substance3d.com/integrations/substance-in-unity).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Unity 2019来说，程序材质不再是Unity的一部分。相反，它们作为单独的插件提供。您可以在官方页面了解更多关于材质的信息：[https://www.substance3d.com/integrations/substance-in-unity](https://www.substance3d.com/integrations/substance-in-unity)。
- en: Asynchronous texture uploading
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步纹理上传
- en: 'The last texture import option we haven''t covered is the read/write enabled
    option. By default, this option is disabled, which is good, because this allows
    textures to make use of the asynchronous texture uploading feature, which has
    two benefits: the texture will be uploaded asynchronously from disk to RAM, and
    when the texture data is needed by the GPU, the transfer happens on the render
    thread, not the main thread. Textures will be pushed into a circular buffer, which
    pushes data to the GPU continuously so long as the buffer contains new data. If
    not, then it early-exits the process and waits until new texture data is requested.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未介绍的最后一种纹理导入选项是读写启用选项。默认情况下，此选项是禁用的，这是好事，因为它允许纹理利用异步纹理上传功能，该功能有两个好处：纹理将从磁盘异步上传到RAM，并且当GPU需要纹理数据时，传输发生在渲染线程上，而不是主线程上。只要缓冲区包含新数据，纹理就会被推送到循环缓冲区，持续不断地将数据推送到GPU。如果没有新数据，则它将提前退出进程并等待新的纹理数据请求。
- en: Ultimately, this reduces the time spent preparing the render states for each
    frame and allows more CPU resources to be spent on gameplay logic, the physics
    engine, and so on. Of course, some time is still spent on the main thread preparing
    the render state, but moving the texture uploading task to a separate thread saves
    a significant chunk of CPU time on the main thread.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这减少了为每一帧准备渲染状态所花费的时间，并允许将更多的CPU资源用于游戏逻辑、物理引擎等。当然，仍然会在主线程上花费一些时间来准备渲染状态，但将纹理上传任务移动到单独的线程可以为主线程节省大量的CPU时间。
- en: However, enabling read/write access to the texture essentially tells Unity that
    we might be reading and editing this texture at any time. This implies that the
    GPU will need fresh access to it every time, so it will disable asynchronous texture
    uploading for that texture; all uploading must occur on the main thread. We might
    want to enable this option for things such as simulating painting colors onto
    a canvas or writing image data from the internet into a premade texture, but the
    downside is that the GPU must always wait for any changes to be made to the texture
    before it can be uploaded since it cannot predict when those changes will happen.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，启用对纹理的读写访问实际上是在告诉Unity我们可能在任何时间读取和编辑此纹理。这意味着GPU每次都需要新鲜访问它，因此它将禁用该纹理的异步纹理上传；所有上传都必须在主线程上执行。我们可能希望为诸如在画布上模拟绘画颜色或将来自互联网的图像数据写入预制的纹理等操作启用此选项，但缺点是GPU必须始终等待对纹理的任何更改被应用后才能上传，因为它无法预测这些更改何时发生。
- en: In addition, asynchronous texture uploading only works for textures we explicitly
    imported into the project and that were present during build time since the feature
    only works if the texture was packed together into special streamable assets.
    Therefore, any textures generated via `LoadImage(byte[])`, texture assets imported/downloaded
    from external locations, or loaded from a *resources* folder via `Resources.Load()` (which
    all implicitly call `LoadImage(byte[])`  themselves) will not be converted into
    streamable content, and therefore will be unable to make use of asynchronous texture
    uploading.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，异步纹理上传仅适用于我们明确导入到项目中且在构建时存在的纹理，因为该功能仅在纹理被打包到特殊的可流式传输资源中时才有效。因此，通过`LoadImage(byte[])`生成的任何纹理、从外部位置导入/下载的纹理资产，或通过`Resources.Load()`从*资源*文件夹中加载的纹理（它们都隐式调用`LoadImage(byte[])`）将不会被转换为可流式传输内容，因此将无法使用异步纹理上传。
- en: It is possible to tweak both the upper limit of the maximum allowed time so
    that it can be spent on asynchronous texture uploads, and the total circular buffer
    size Unity should use to push the textures we want to upload. These settings can
    be tweaked under Edit | Project Settings | Quality | Other and are named Async
    Upload Time Slice and Async Upload Buffer Size, respectively. We should set the
    Async Upload Time Slice value to the maximum number of milliseconds we want Unity
    to spend on asynchronous texture uploads on the render thread. It might be wise
    to set the Async Upload Buffer Size value to the largest texture file we might
    need to use, plus a little extra buffer if multiple fresh textures are needed
    in the same frame. The circular buffer that texture data is copied into will expand
    as needed, but this is often costly. Since we probably already know ahead of time
    how large we need that circular buffer to be, we might as well set it to the maximum
    expected size to avoid potential frame drops when it needs to resize the buffer.
    We now move on to our next topic— the mesh and animation file types.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 可以调整最大允许时间的上限，以便将其用于异步纹理上传，以及Unity应使用的总循环缓冲区大小，以推送我们想要上传的纹理。这些设置可以在“编辑”|“项目设置”|“质量”|“其他”中进行调整，分别命名为异步上传时间片和异步上传缓冲区大小。我们应该将异步上传时间片值设置为Unity在渲染线程上花费在异步纹理上传上的最大毫秒数。将异步上传缓冲区大小值设置为可能需要的最大纹理文件大小，如果同一帧需要多个新纹理，则额外添加一些缓冲区。纹理数据被复制的循环缓冲区将根据需要扩展，但这通常成本较高。由于我们可能已经提前知道需要循环缓冲区的大小，我们可以将其设置为最大预期大小，以避免在需要调整缓冲区大小时出现潜在的帧率下降。我们现在继续讨论下一个主题——网格和动画文件类型。
- en: Mesh and animation files
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网格和动画文件
- en: The mesh and animation file types are essentially large arrays of vertex and
    skinned bone data, and there are a variety of techniques we can apply to minimize
    file size while keeping similar, if not identical, appearances. There are also
    ways to lower the cost of rendering large groups of these objects through batching
    techniques. Let's take a look at a series of performance-enhancing techniques
    that we can apply to such files.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 网格和动画文件类型基本上是顶点和骨骼蒙皮数据的大型数组，我们可以应用各种技术来最小化文件大小，同时保持相似，如果不是完全相同的外观。还有方法可以通过批处理技术降低渲染大量此类对象的成本。让我们看看我们可以应用于此类文件的一系列性能提升技术。
- en: Reducing the polygon count
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少多边形数量
- en: Reducing the polygon count is the most obvious way to gain performance and should
    always be considered. In fact, since we cannot batch objects using skinned mesh
    renderers, it's one of the good ways of reducing CPU and GPU runtime overhead
    for animated objects.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 减少多边形数量是获得性能的最明显方法，应始终考虑。事实上，由于我们不能使用皮肤网格渲染器批量处理对象，这是减少动画对象CPU和GPU运行时开销的好方法之一。
- en: Reducing the polygon count is simple, straightforward, and provides both CPU
    and memory cost savings for the time required for artists to clean up the mesh.
    In this day and age, much of an object's detail is almost entirely based on detailed
    texturing and complex shading, so we can often get away with stripping away a
    lot of vertices on modern meshes, and most users would be unable to tell the difference.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 减少多边形数量简单直接，并且为艺术家清理网格所需的时间提供了CPU和内存成本节约。在这个时代，物体的许多细节几乎完全基于详细的纹理和复杂的着色，因此我们通常可以在现代网格上移除大量顶点，而大多数用户都无法察觉到差异。
- en: Tweaking mesh compression
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整网格压缩
- en: 'Unity offers four different Mesh Compression settings for imported mesh files:
    Off, Low, Medium, and High. Increasing this setting will convert floating-point
    data into fixed values, reducing the accuracy in the vertex position/normal direction,
    simplifying vertex color information, and so on. This can have a noticeable effect
    on meshes that contain lots of small parts near one another, such as a fence or
    grate. If we''re generating meshes procedurally, we can achieve the same type
    of compression by calling the `Optimize()` method of a `MeshRenderer` component
    (of course, this will take some time to complete).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Unity为导入的网格文件提供了四种不同的网格压缩设置：关闭、低、中、高。提高此设置会将浮点数据转换为固定值，降低顶点位置/法线方向精度，简化顶点颜色信息等。这将对包含许多相邻小部件的网格产生明显影响，例如栅栏或格栅。如果我们是生成网格的，可以通过调用`MeshRenderer`组件的`Optimize()`方法（当然，这需要一些时间来完成）来实现相同类型的压缩。
- en: 'There are also two global settings found in Edit | Project Settings | Player
    | Other Settings that can affect how mesh data is imported. They are as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在“编辑 | 项目设置 | 玩家 | 其他设置”中还可以找到两个全局设置，它们会影响网格数据的导入方式。具体如下：
- en: Vertex Compression: We can use this option to configure the type of data that
    will be optimized when we import a mesh file with Mesh Compression enabled, so
    if we want accurate normal data (for lighting), but are less worried about positional
    data, then we can configure it here. Unfortunately, this is a global setting,
    and will affect all imported meshes (although it can be configured on a per-platform
    basis since it is a Player setting).
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点压缩：我们可以使用此选项配置在启用网格压缩时导入网格文件将优化的数据类型，如果我们想要精确的法线数据（用于照明），但不太关心位置数据，则可以在此配置。不幸的是，这是一个全局设置，将影响所有导入的网格（尽管由于它是玩家设置，因此可以按平台进行配置）。
- en: Optimize Mesh Data: Enabling Optimize Mesh Data will strip away any data from
    the mesh that isn't required by the material(s) assigned to it. So, if the mesh
    contains tangent information, but the shader never requires it, then Unity will
    ignore it during build time.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化网格数据：启用“优化网格数据”将移除网格中不需要的任何数据。所以，如果网格包含切线信息，但着色器从不要求它，那么Unity在构建时将忽略它。
- en: In each case, the benefits reduce the application's disk footprint at the cost
    of extra time loading the mesh, since extra time must be spent decompressing the
    data before it's needed.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，这些好处都是以增加加载网格所需额外时间为代价来减少应用程序的磁盘占用，因为必须在需要之前花费额外时间解压缩数据。
- en: The 3D mesh-building/animation tools often provide their own built-in ways of
    automated mesh optimization in the form of estimating the overall shape and stripping
    the mesh down to fewer total polygons. This can cause a significant loss of quality
    and should be tested vigorously if used.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 3D网格构建/动画工具通常提供自己的内置自动化网格优化方式，形式为估计整体形状并将网格简化为更少的多边形。这可能导致质量显著下降，如果使用，应进行彻底测试。
- en: Using Read-Write Enabled appropriately
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确使用读写权限
- en: The Read-Write Enabled flag allows changes to be made to the mesh at runtime
    either via scripting or automatically by Unity during runtime, similar to how
    it is used for texture files. Internally, this means that it will keep the original
    mesh data in memory until we want to duplicate it and make changes dynamically.
    Disabling this option will allow Unity to discard the original mesh data from
    memory once it has determined the final mesh to use, since it knows it will never
    change.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 读写启用标志允许在运行时通过脚本或由Unity自动进行更改，类似于它用于纹理文件的方式。内部来说，这意味着它将保留原始网格数据在内存中，直到我们想要复制它并动态地对其进行更改。禁用此选项将允许Unity在确定要使用的最终网格后从内存中丢弃原始网格数据，因为它知道它将不会更改。
- en: If we use only a uniformly scaled version of a mesh throughout the entire game,
    then disabling this option will save runtime memory since we will no longer need
    the original mesh data to make further rescaled duplicates of the mesh (incidentally,
    this is how Unity organizes objects by scale factor when it comes to dynamic batching).
    Unity can, therefore, discard this unwanted data early since we won't need it
    again until the next time the application is launched.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在整个游戏中只使用网格的均匀缩放版本，那么禁用此选项将节省运行时内存，因为我们不再需要原始网格数据来制作网格的进一步缩放副本（顺便说一句，这就是Unity在动态批处理时按比例因子组织对象的方式）。因此，Unity可以提前丢弃这些不需要的数据，因为我们不会在下次应用程序启动之前再次需要它。
- en: However, if the mesh often reappears at runtime with different scales, then
    Unity needs to keep this data in memory so that it can recalculate a new mesh
    more quickly; therefore, it would be wise to enable the Read-Write Enabled flag.
    Disabling it will require Unity to not only reload the mesh data each time the
    mesh is reintroduced, but also make the rescaled duplicate at the same time, causing
    a potential performance hiccup.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果网格在运行时经常以不同的比例重新出现，那么Unity需要将此数据保留在内存中，以便它可以更快地重新计算新的网格；因此，启用读写启用标志将是明智的。禁用它将要求Unity每次网格重新引入时不仅要重新加载网格数据，还要同时创建缩放后的副本，这可能导致性能中断。
- en: Unity tries to detect the correct behavior for this setting at initialization
    time, but when meshes are instantiated and scaled in a dynamic fashion at runtime,
    we must force the issue by enabling this setting. This will improve the instantiation
    speed of the objects, but cost some memory overhead since the original mesh data
    is kept around until it's needed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Unity试图在初始化时检测此设置的正确行为，但当网格在运行时以动态方式实例化和缩放时，我们必须通过启用此设置来强制处理。这将提高对象的实例化速度，但会消耗一些内存开销，因为原始网格数据会保留直到需要时。
- en: Note that this potential overhead cost also applies when using the Generate
    Colliders option.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种潜在的开销成本也适用于使用生成碰撞器选项时。
- en: Considering baked animations
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑烘焙动画
- en: Using baked animations will require changes in the asset by using the 3D rigging
    and animation tool that we are using, since Unity does not provide such tools
    itself. Animations are normally stored as keyframe information, which it uses
    to keep track of specific mesh positions and interpolate between them at runtime
    using skinning data (bone shapes, assignments, animation curves, and so on). Baking
    animations means effectively sampling and hardcoding each position of each vertex
    into the mesh/animation file per frame without the need for interpolation and
    skinning data.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用烘焙动画需要通过我们使用的3D绑定和动画工具对资产进行更改，因为Unity本身不提供此类工具。动画通常以关键帧信息的形式存储，它使用这些信息来跟踪特定的网格位置，并在运行时使用皮肤数据（骨骼形状、分配、动画曲线等）在它们之间进行插值。烘焙动画意味着有效地在每个帧中采样并将每个顶点的每个位置硬编码到网格/动画文件中，无需插值和皮肤数据。
- en: Using baked animations can sometimes result in much smaller file sizes and memory
    overhead than blended/skinned animations for some objects since skinning data
    can take up a surprisingly large amount of space to store. This is most likely
    to be the case for relatively simple objects or objects with short animations
    since we would effectively be replacing procedural data with a hardcoded series
    of vertex positions. So if the mesh's polygon count is low enough where storing
    lots of vertex information is cheaper than skinning data, then we may see some
    significant savings through this simple change.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用烘焙动画有时可以比混合/蒙皮动画为某些对象带来更小的文件大小和内存开销，因为蒙皮数据可能需要占用出人意料大的空间来存储。这最有可能发生在相对简单的对象或具有简短动画的对象上，因为我们实际上会用硬编码的顶点位置序列替换程序数据。因此，如果网格的多边形数量足够低，以至于存储大量顶点信息比蒙皮数据更便宜，那么我们可能会通过这种简单的更改看到一些显著的节省。
- en: In addition, how often the baked sample is taken can usually be customized by
    the exporting application. Different sample rates should be tested to find a good
    value where the key moments of the animation still shine through what is essentially
    a simplified estimate.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，烘焙样本的频率通常可以通过导出应用程序进行自定义。应该测试不同的采样率，以找到动画的关键时刻仍然能够通过简化估计凸显出来的良好值。
- en: Combining meshes
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并网格
- en: Forcefully combining meshes into a large, single mesh can be a convenient option
    to reduce draw calls, particularly if the meshes are too large for dynamic batching
    and don't play well with other statically batched groups. This is essentially
    the equivalent of static batching, but it is performed manually, so sometimes
    it's a wasted effort if static batching could take care of the process for us.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 强制将网格合并成一个大型的单个网格可以是一个方便的选项，以减少绘制调用，尤其是如果网格太大而无法进行动态批处理，并且与其他静态批处理组配合不佳时。这本质上等同于静态批处理，但它是由人工执行的，因此如果静态批处理可以为我们处理这个过程，有时这会是一种浪费的努力。
- en: Be aware that if any single vertex of the mesh is visible in the scene, then
    the entire object will be rendered together as one whole. This can lead to a lot
    of wasted processing if the mesh is only partially visible most of the time. This
    technique also comes with the drawback that it generates a whole new mesh asset
    file that we must deposit into our scene, which means that any changes we make
    to the original meshes will not be reflected in the combined one. This results
    in a lot of tedious workflow effort every time changes need to be made, so if
    static batching is an option, it should be used instead.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果网格的任何单个顶点在场景中可见，则整个对象将作为一个整体一起渲染。如果网格大部分时间只部分可见，这可能会导致大量的处理浪费。这种技术还带来一个缺点，即它会生成一个新的整个网格资产文件，我们必须将其存入我们的场景中，这意味着我们对原始网格所做的任何更改都不会反映在合并后的网格中。这导致每次需要更改时都需要大量的繁琐工作流程，因此如果静态批处理是一个选项，应该使用它而不是这种方法。
- en: There are several tools available online that can combine mesh files together
    for us in Unity. They are only an Asset Store or Google search away.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在线有一些工具可以将网格文件合并在一起，用于Unity。它们只需通过资产商店或Google搜索即可获得。
- en: Asset bundles and resources
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资产包和资源
- en: We touched upon the topic of resources and serialization in Chapter 2, *Scripting
    Strategies*, and it should be fairly clear that the resource system can be a great
    benefit during prototyping, as well as during the early stages of our project,
    and can be used relatively effectively in games of limited scope.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章“脚本策略”中，我们提到了资源和序列化的话题，应该相当清楚，资源系统在原型设计和项目早期阶段都可以带来很大的好处，并且可以在范围有限的游戏中相对有效地使用。
- en: However, professional Unity projects should instead favor the asset bundle system. There
    are a number of reasons for this. Firstly, the resource system is not very scalable
    when it comes to builds. All resources are merged together into a single massive
    serialized file binary data blob with an index list of where various assets can
    be found within it. This can be hard to manage, and take a long time to build
    as we add more data to the list.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，专业的Unity项目应该更倾向于使用资产包系统。这有几个原因。首先，在构建方面，资源系统并不非常可扩展。所有资源都合并成一个单一的巨大序列化文件二进制数据块，其中包含一个索引列表，指示各种资产在该文件中的位置。这可能会很难管理，并且随着我们向列表中添加更多数据，构建时间可能会很长。
- en: Secondly, the resource system's ability to acquire data from the serialized
    file scales in an *Nlog(N)* fashion, which should make us very wary of increasing
    the value of *N*. Thirdly, the resource system makes it unwieldy for our application
    to provide different asset data on a per-device basis, whereas asset bundles tend
    to make this matter trivial. Finally, asset bundles can be used to provide small,
    periodic custom content updates to the application, while the resource system
    would require updates that completely replace the entire application to achieve
    the same effect.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，资源系统从序列化文件获取数据的能力以*Nlog(N)*的方式扩展，这应该让我们对增加*N*的值非常谨慎。第三，资源系统使得我们的应用程序按设备提供不同的资产数据变得难以操作，而资产包通常使这个问题变得微不足道。最后，资产包可以用来为应用程序提供小型的、定期的自定义内容更新，而资源系统则需要更新以完全替换整个应用程序才能达到相同的效果。
- en: Asset bundles share a lot of common functionality with resources, such as loading
    from files, loading data asynchronously, and unloading data we no longer need.
    However, they also offer much more functionality, such as content streaming, content
    updates, and content generation and sharing. These can all be used to improve
    the performance of our application to great effect. We can deliver applications
    with much smaller disk footprints and have the user download additional content
    before or during gameplay, stream assets at runtime to minimize the initial loading
    time of the application, and provide more optimized assets to the application
    on a per-platform basis without the need to push a complete application to overwrite
    to the user.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 资产包与资源共享了许多共同的功能，例如从文件中加载、异步加载数据以及卸载不再需要的我们不再需要的数据。然而，它们还提供了更多的功能，如内容流、内容更新、内容生成和共享。所有这些都可以极大地提高我们应用程序的性能。我们可以提供具有更小磁盘足迹的应用程序，让用户在游戏前或游戏中下载额外的内容，在运行时流式传输资产以最小化应用程序的初始加载时间，并且可以在每个平台上为应用程序提供更优化的资产，而无需推送完整的应用程序以覆盖用户。
- en: Of course, there are downsides to asset bundles. They are much more complicated
    to set up and maintain than resources, they're more complicated to understand
    since they use a much more sophisticated system for accessing asset data than
    the resources system, and making full use of their functionality (such as streaming
    and content updates) would require a lot of additional QA testing to make sure
    that the server is delivering content properly, and that the game is reading and
    updating its content to match. Ergo, asset bundles are best used only when our
    team size is able to support the extra workload they require.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，资产包也有其缺点。它们比资源更复杂，设置和维护起来更复杂，理解起来也更复杂，因为它们使用了一个比资源系统更复杂的系统来访问资产数据。充分利用其功能（如流式传输和内容更新）需要大量的额外QA测试，以确保服务器正确地提供内容，并且游戏能够读取和更新其内容以匹配。因此，只有在我们的团队能够支持它们所需的额外工作量时，才最好使用资产包。
- en: A tutorial on the asset bundle system is beyond the scope of this book, but
    there are dozens of useful guides online and in the Unity documentation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中不涉及资产包系统的教程，但网上和Unity文档中有很多有用的指南。
- en: Check out the Unity tutorial at [https://learn.unity.com/tutorial/assets-resources-and-assetbundles](https://learn.unity.com/tutorial/assets-resources-and-assetbundles) to
    find out more about the asset bundle system.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Unity教程[https://learn.unity.com/tutorial/assets-resources-and-assetbundles](https://learn.unity.com/tutorial/assets-resources-and-assetbundles)，了解更多关于资产包系统信息。
- en: If you require further convincing, then a Unity blog post from April 2017 should
    help reveal how the asset bundle system can use memory more efficiently during
    runtime in ways that the resources system cannot provide through memory pooling.
    You can find this blog at [https://blogs.unity3d.com/2017/04/12/asset-bundles-vs-resources-a-memory-showdown/](https://blogs.unity3d.com/2017/04/12/asset-bundles-vs-resources-a-memory-showdown/).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要进一步的说服，那么2017年4月的一篇Unity博客文章应该有助于揭示资产包系统如何在运行时更有效地使用内存，这是资源系统无法通过内存池提供的。您可以在[https://blogs.unity3d.com/2017/04/12/asset-bundles-vs-resources-a-memory-showdown/](https://blogs.unity3d.com/2017/04/12/asset-bundles-vs-resources-a-memory-showdown/)找到这篇博客。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: There are many different opportunities that we can explore to achieve performance
    gains for our application just by tinkering with our imported assets. Alternatively,
    from another perspective, there are plenty of ways to ruin our application's performance
    through asset mismanagement. Almost every single import configuration opportunity
    is a trade-off between one performance metric or workflow task and another. Typically,
    this means saving the disk footprint via compression at the expense of CPU at
    runtime to decompress the data, or faster access while reducing the quality level
    of the final presentation. So we must remain vigilant and only pick the right
    techniques for the right assets for the right reasons.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调整导入的资产来探索许多不同的机会，从而提高我们应用程序的性能。从另一个角度来看，也有许多方法可以通过资产管理不善来破坏我们应用程序的性能。几乎每一个导入配置的机会都是在一项性能指标或工作流程任务与另一项之间的权衡。通常这意味着通过压缩来节省磁盘占用空间，但运行时需要CPU来解压缩数据，或者更快地访问数据，同时降低最终展示的质量水平。因此，我们必须保持警惕，只为合适的资产选择合适的技巧，出于合适的原因。
- en: This concludes our exploration of improving performance through art asset manipulation.
    In the next chapter, we will be investigating how to improve our usage of Unity's
    physics engine.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们通过艺术资产操作来提高性能的探索。在下一章中，我们将探讨如何提高我们对Unity物理引擎的使用。
