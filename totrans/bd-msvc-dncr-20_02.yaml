- en: Implementing Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现微服务
- en: 'In the previous chapter, we discussed the problems of a layered monolith architecture.
    In this chapter, we will discuss how we can refactor them from the existing system
    and build separate microservices for products and orders. In this chapter, we
    will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了分层单体架构的问题。在本章中，我们将讨论如何从现有系统中重构它们，并为产品和订单构建独立的微服务。在本章中，我们将涵盖以下主题：
- en: Introduction to C# 7.0, Entity Framework Core, Visual Studio 2017, and Microsoft
    SQLServer
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 7.0、Entity Framework Core、Visual Studio 2017 和 Microsoft SQLServer 简介
- en: Size of microservices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的大小
- en: What makes a good service?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么使一个好的服务？
- en: Domain-driven design (DDD) and its importance for microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域驱动设计（DDD）及其对微服务的重要性
- en: The concept of Seam
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Seam 的概念
- en: Communication between microservices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务之间的通信
- en: Revisiting the Flix One case study
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重温 Flix One 案例研究
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Before we proceed with the concepts to implement microservices, it is worth
    mentioning the core concepts, languages, and tools that we're using to implement
    these microservices. In this chapter, we will get an overview of these topics.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论实现微服务概念之前，值得提及的是我们用来实现这些微服务的核心概念、语言和工具。在本章中，我们将对这些主题进行概述。
- en: C# 7.0
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 7.0
- en: C# is a programming language developed by Microsoft. The current release at
    the time of writing this book is C# 7.0\. The language appeared in 2002\. This
    language is an object-oriented language and component-oriented. The current version
    has various new features such as ValueTuple, Deconstructors, pattern matching,
    the switch statement local function, and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: C# 是微软开发的一种编程语言。本书撰写时的当前版本是 C# 7.0。该语言于 2002 年出现。这是一种面向对象和面向组件的语言。当前版本具有各种新功能，如
    ValueTuple、析构函数、模式匹配、switch 语句局部函数等。
- en: We are not going into details of these features as it's beyond the scope of
    this book. Refer to [https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/) for
    more details.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨这些功能，因为它们超出了本书的范围。更多详细信息，请参考：[https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/)。
- en: Entity Framework Core
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Entity Framework Core
- en: '**Entity Framework Core** (**EF Core**) is a cross-platform version of Microsoft
    Entity Framework that is one of the most popular **object-relational mappers**
    (**ORMs**).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**Entity Framework Core**（**EF Core**）是微软 Entity Framework 的跨平台版本，它是最受欢迎的 **对象关系映射器**（**ORM**）之一。'
- en: ORM is a technique that helps you to query and manipulate data as per required
    business output. Refer to the discussion at [https://stackoverflow.com/questions/1279613/what-is-an-orm-and-where-can-i-learn-more-about-it](https://stackoverflow.com/questions/1279613/what-is-an-orm-and-where-can-i-learn-more-about-it)
    for more details.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 是一种帮助您根据所需业务输出查询和操作数据的技术。有关更多详细信息，请参阅[https://stackoverflow.com/questions/1279613/what-is-an-orm-and-where-can-i-learn-more-about-it](https://stackoverflow.com/questions/1279613/what-is-an-orm-and-where-can-i-learn-more-about-it)。
- en: EF Core supports various databases. A complete list of databases is available
    here: [https://docs.microsoft.com/en-us/ef/core/providers/index](https://docs.microsoft.com/en-us/ef/core/providers/index).
    The current version of EF Core is 2.0\. To get familiar with EF Core, I suggest
    you read this: [https://docs.microsoft.com/en-us/ef/core/get-started/index](https://docs.microsoft.com/en-us/ef/core/get-started/index)
    in detail.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 支持多种数据库。数据库的完整列表可在以下链接找到：[https://docs.microsoft.com/en-us/ef/core/providers/index](https://docs.microsoft.com/en-us/ef/core/providers/index)。当前
    EF Core 的版本是 2.0。为了熟悉 EF Core，我建议您详细阅读以下内容：[https://docs.microsoft.com/en-us/ef/core/get-started/index](https://docs.microsoft.com/en-us/ef/core/get-started/index)。
- en: Visual Studio 2017
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio 2017
- en: Visual Studio is one of the best **Integrated Development Environments** (**IDE**)
    created by Microsoft. It enables developers to work in various ways using famous
    languages(for example, C#, VB.NET F#, and so on). The current release of Visual
    Studio 2017 is update 3 (VS15.3).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 是微软创建的最好的 **集成开发环境**（**IDE**）之一。它使开发者能够使用著名的语言（例如，C#、VB.NET、F#
    等）以各种方式工作。Visual Studio 2017 的当前发布版本是更新 3（VS15.3）。
- en: An IDE is a software application that provides a facility for programmers to
    write programs using programming languages. For more information, visit [https://en.wikipedia.org/wiki/Integrated_development_environment.](https://en.wikipedia.org/wiki/Integrated_development_environment)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 集成开发环境（IDE）是一种软件应用程序，它为程序员提供了一个使用编程语言编写程序的平台。更多信息，请访问：[https://en.wikipedia.org/wiki/Integrated_development_environment](https://en.wikipedia.org/wiki/Integrated_development_environment)。
- en: Microsoft also released Visual Studio for macOS, and the new avatar of Visual
    Studio has many tremendous features. For more information please refer to [https://www.visualstudio.com/vs/whatsnew/](https://www.visualstudio.com/vs/whatsnew/).
    In this book, all examples are written using Visual Studio 2017 update 3\. You
    can also download a community edition that is free: [https://www.visualstudio.com/.](https://www.visualstudio.com/)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 微软还发布了适用于macOS的Visual Studio，Visual Studio的新版本拥有许多惊人的功能。更多信息请参阅[https://www.visualstudio.com/vs/whatsnew/](https://www.visualstudio.com/vs/whatsnew/)。本书中的所有示例都是使用Visual
    Studio 2017更新3编写的。您还可以下载免费的社区版：[https://www.visualstudio.com/](https://www.visualstudio.com/)。
- en: Microsoft SQLServer
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Microsoft SQLServer
- en: '**Microsoft SQLServer** (**MSSQL**) is a software application that is a relational
    database management system. It''s mainly used as  database software to store and
    retrieve data. This is built on top of SQL, that is, Structured Query Language: [http://searchsqlserver.techtarget.com/definition/SQL](http://searchsqlserver.techtarget.com/definition/SQL).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Microsoft SQLServer**（**MSSQL**）是一个关系型数据库管理系统软件应用。它主要用于作为数据库软件来存储和检索数据。这是建立在SQL之上的，即结构化查询语言：[http://searchsqlserver.techtarget.com/definition/SQL](http://searchsqlserver.techtarget.com/definition/SQL)。'
- en: The current release, that is, SQL Server 2017, is more robust and can be used
    on Windows and Linux. You can get SQL Server 2017 from here: [https://www.microsoft.com/en-IN/sql-server/sql-server-2017](https://www.microsoft.com/en-IN/sql-server/sql-server-2017).
    Please note that we will use SQL Server 2008 R2 or later in this book.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本，即SQL Server 2017，更加健壮，可以在Windows和Linux上使用。您可以从这里获取SQL Server 2017：[https://www.microsoft.com/en-IN/sql-server/sql-server-2017](https://www.microsoft.com/en-IN/sql-server/sql-server-2017)。请注意，本书中将使用SQL
    Server 2008 R2或更高版本。
- en: Size of microservices
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的大小
- en: Before we start building our microservices, we should be clear about a few of
    their basic aspects, such as what factors to consider while sizing our microservices
    and how to ensure their isolation from the rest of the system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建微服务之前，我们应该清楚它们的一些基本方面，例如在确定微服务大小时要考虑哪些因素，以及如何确保它们与系统其他部分的隔离。
- en: 'As the name suggests, microservices should be micro. A question arises: what
    is micro? Microservices are all about size and granularity. To understand this
    better, let''s consider the application discussed in [Chapter 1](274437a4-3708-4913-96b3-539e376c71fb.xhtml),
    *An Introduction to Microservices*.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，微服务应该是微型的。一个问题随之而来：什么是微型？微服务全部关乎大小和粒度。为了更好地理解这一点，让我们考虑在[第1章](274437a4-3708-4913-96b3-539e376c71fb.xhtml)中讨论的应用，*微服务简介*。
- en: 'We wanted the teams working on this project to stay synchronized at all times
    with respect to their code. Staying synchronized is even more important when we
    release the complete project. We needed to first decompose our application/specific
    parts into smaller functionalities/segments of the main service. Let''s discuss
    the factors that need to be considered for the high-level isolation of microservices:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望参与此项目的团队始终保持其代码的一致性。在发布完整项目时，保持一致性尤为重要。我们需要首先将我们的应用/特定部分分解成更小的功能/主服务段的片段。让我们讨论需要考虑的因素，以确保微服务的高级隔离：
- en: 'Risks due to requirement changes: Changes in the requirements of one microservice
    should be independent of other microservices. In such a case, we will isolate/split
    our software into smaller services in such a way that if there are any requirement
    changes in one service, they will be independent of another microservice.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于需求变更而产生的风险：一个微服务的需求变更应独立于其他微服务。在这种情况下，我们将我们的软件隔离/分割成更小的服务，以便如果某个服务有任何需求变更，它们将独立于另一个微服务。
- en: 'Functionality changes: We will isolate the functionalities that are rarely
    changed from the dependent functionalities that can be frequently modified. For
    example, in our application, the customer module notification functionality will
    rarely change. But its related modules, such as `Order`, are more likely to have
    frequent business changes as part of their life cycle.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能性变更：我们将隔离那些很少变更的功能性，以及那些可能频繁修改的依赖功能性。例如，在我们的应用中，客户模块通知功能很少变更。但与其相关的模块，如`订单`，在其生命周期中更有可能频繁发生业务变更。
- en: 'Team changes: We should also consider isolating modules in such a way that
    one team can work independently of all the other teams. If the process of making
    a new developer productive—regarding the tasks in such modules—is not dependent
    on people outside the team, it means we are well placed.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队变更：我们还应考虑以这种方式隔离模块，使得一个团队能够独立于所有其他团队工作。如果使新开发者能够高效完成这些模块中的任务的过程不依赖于团队外的人，这意味着我们处于有利的位置。
- en: 'Technology changes: Technology use needs to be isolated vertically within each
    module. A module should not be dependent on a technology or component from another
    module. We should strictly isolate the modules developed in different technologies
    or stacks, or look at moving them to a common platform as a last resort.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术变更：技术使用需要在每个模块内垂直隔离。一个模块不应依赖于来自另一个模块的技术或组件。我们应该严格隔离使用不同技术或堆栈开发的模块，或者将它们迁移到公共平台作为最后的手段。
- en: Our primary goal should not be to make services as small as possible; instead,
    our goal should be to isolate the identified bounded context and keep it small.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要目标不应该是使服务尽可能小；相反，我们的目标应该是隔离已识别的边界上下文并保持其小。
- en: What makes a good service?
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么使良好的服务变得出色？
- en: Before microservices were conceptualized, whenever we thought of enterprise
    application integration, middleware looked like the most feasible option. Software
    vendors offered **Enterprise Service Bus** (**ESB**), and it was one of the best options for
    middleware.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务概念化之前，每当考虑到企业应用集成时，中间件看起来是最可行的选项。软件供应商提供了**企业服务总线**（**ESB**），它是中间件的最佳选项之一。
- en: Besides considering these solutions, our main priority should be inclined toward
    the architectural features. When microservices arrived, middleware was no longer
    a consideration. Rather, the focus shifted to contemplation of business problems
    and how to tackle those problems with the help of the architecture.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了考虑这些解决方案外，我们的主要优先级应倾向于架构特性。当微服务出现时，中间件不再是考虑的重点。相反，焦点转向了对业务问题的思考以及如何借助架构来解决这些问题。
- en: 'In order to make a service that can be used and maintained easily by developers
    and users, the service must have the following features (we can also consider
    these as characteristics of good services):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使服务能够被开发者和用户轻松使用和维护，该服务必须具备以下特性（我们也可以将这些视为良好服务的特征）：
- en: 'Standard data formats: Good services should follow standardized data formats
    while exchanging services or systems with other components. The most popular data
    formats used in the .NET stack are XML and JSON.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准数据格式：良好的服务在与其他组件交换服务或系统时应遵循标准数据格式。在.NET堆栈中最常用的数据格式是XML和JSON。
- en: 'Standard communication protocol: Good services should obey standard communication
    formats, such as SOAP and REST.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准通信协议：良好的服务应遵守标准通信格式，如SOAP和REST。
- en: 'Loose coupling: One of the most important characteristics of a good service
    is that it follows loose coupling. When services are loosely coupled, we don''t
    have to worry about changes. Changes in one service will not impact other services.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松散耦合：良好服务的一个重要特征是它遵循松散耦合。当服务松散耦合时，我们不必担心变化。一个服务的变更不会影响其他服务。
- en: DDD and its importance for microservices
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DDD及其对微服务的重要性
- en: '**Domain-Driven Design** (**DDD**) is a methodology and a process of designing
    complex systems. In these sections, we will briefly discuss DDD and how it is
    important in the context of microservices.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域驱动设计**（**DDD**）是一种设计和复杂系统的方法论和过程。在这些部分中，我们将简要讨论DDD及其在微服务环境中的重要性。'
- en: Domain model design
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域模型设计
- en: The main objective of domain design is to understand the exact domain problems
    and then draft a model that can be written in any language or set of technologies.
    For example, in our Flix One bookstore application, we need to understand *Order
    Management* and *Stock Management*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 领域设计的首要目标是理解确切的领域问题，然后制定一个可以用任何语言或技术集编写的模型。例如，在我们的Flix One书店应用程序中，我们需要理解*订单管理*和*库存管理*。
- en: 'Here are a few characteristics of the domain-driven model:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是领域驱动模型的一些特征：
- en: A domain model should focus on a specific business model and not multiple business
    models
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域模型应专注于特定的商业模式，而不是多个商业模式
- en: It should be reusable
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是可重用的
- en: It should be designed so that it can be called in a loosely coupled way, unlike
    the rest of the system
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该设计成可以以松散耦合的方式调用，而不同于系统的其余部分
- en: It should be designed independently of persistence implementations
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该独立于持久化实现进行设计
- en: It should be pulled out from a project to another location, so it should not
    be based on any infrastructure framework
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该从一个项目被拉取到另一个位置，因此它不应该基于任何基础设施框架
- en: Importance for microservices
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的重要性
- en: DDD is the blueprint and can be implemented by microservices. In other words,
    once DDD is done, we can implement it using microservices. This is just like how,
    in our application, we can easily implement *Order services*, *Inventory services*,
    *Tracking services*, and so on.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: DDD 是蓝图，可以通过微服务实现。换句话说，一旦完成 DDD，我们就可以使用微服务来实现它。这就像在我们的应用程序中，我们可以轻松实现 *订单服务*、*库存服务*、*跟踪服务*
    等等。
- en: Once you have dealt with the transition process to your satisfaction, a simple
    exercise should be performed. This will help you verify that the size of the microservice
    is small enough. Every system is unique and has its own complexity level. Considering
    these levels of your domain, you need to have a baseline for the maximum number
    of domain objects that can talk to each other. If any service fails this evaluation
    criterion, then you have a possible candidate to evaluate your transition once
    again. However, don't get into this exercise with a specific number in mind; you
    can always go easy. As long as you have followed all the steps correctly, the
    system should be fine for you.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对过渡过程感到满意，应该进行一个简单的练习。这将帮助你验证微服务的大小是否足够小。每个系统都是独特的，并且具有自己的复杂度级别。考虑到你领域的这些级别，你需要有一个基准，以确定可以相互通信的最大域对象数量。如果任何服务未能通过这个评估标准，那么你可能有一个候选者来再次评估你的过渡。然而，不要带着一个特定的数字来进行这个练习；你总是可以轻松一些。只要正确遵循所有步骤，系统对你来说应该就没有问题。
- en: If you feel that this baseline process is difficult for you to achieve, you
    can take another route. Go through all the interfaces and classes in each microservice.
    Considering all the steps we have followed, and the industry standard coding guidelines,
    anybody new to the system should be able to make sense of its purpose.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得这个基准过程对你来说很难实现，你可以选择另一条路。遍历每个微服务中的所有接口和类。考虑到我们遵循的所有步骤和行业标准编码指南，任何新加入系统的人都应该能够理解其目的。
- en: You can also perform another simple test to check whether the correct vertical
    isolation of the services was achieved. You can deploy each one of them and make
    them live with the rest of the services, which are still unavailable. If your
    service goes live and continues listening for incoming requests, you can pat yourself
    on the back.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以进行另一个简单的测试，以检查是否实现了服务的正确垂直隔离。你可以部署每一个，并让它们与仍然不可用的其他服务一起运行。如果你的服务上线并继续监听传入的请求，你可以给自己鼓掌。
- en: There are many benefits that you can derive from the isolated deployment capability.
    The capability to just deploy them independently allows the host in them to enter
    its own independent processes. It allows you to harness the power of the cloud
    and other hybrid models of hosting that you can think of. You are free to independently
    pick different technologies for each one of them as well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从隔离部署能力中获得许多好处。仅仅独立部署它们的能力，就允许它们中的主机进入自己的独立进程。它允许你利用云和其他混合托管模型的力量，这些模型是你能想到的。你也可以自由地为每一个选择不同的技术。
- en: The concept of seam
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接缝的概念
- en: At the very core of microservices lies the capability to work on a specific
    functionality in isolation from the rest of the system. This translates into all
    the advantages discussed earlier, such as reduced module dependency, code reusability,
    easier code maintenance, and better deployment.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的核心能力在于能够在与其他系统隔离的情况下处理特定的功能。这转化为之前讨论的所有优势，例如减少模块依赖、代码重用性、更容易的代码维护和更好的部署。
- en: In my opinion, the same attributes that were attained with the implementation
    of microservices should be maintained during the process of implementation. Why
    should the whole process of moving monoliths to microservices be painful and not
    be as rewarding as using the microservices themselves? Just remember that the
    transition can't be done overnight and will need meticulous planning. Many capable
    solution architects have differed in their approaches while presenting their highly
    capable teams. The answer lies not just in the points already mentioned, but in
    the risk to the business itself.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，在实施微服务的过程中获得相同的属性应该在实施过程中保持。为什么将单体迁移到微服务的过程会痛苦，而不是像使用微服务本身那样有回报？只需记住，过渡不可能一蹴而就，需要细致的计划。许多有能力的解决方案架构师在展示他们高度有能力的团队时，他们的方法各不相同。答案不仅在于已经提到的点，还在于对业务本身的潜在风险。
- en: This is very well attainable. However, we must identify our method correctly
    in order to achieve it. Otherwise, there is a possibility that the whole process
    of transitioning a monolithic application to microservices could be a dreadful
    one.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常容易实现的。然而，我们必须正确地识别我们的方法才能实现它。否则，整个将单体应用过渡到微服务的过程可能会变得非常糟糕。
- en: Module interdependency
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块间依赖
- en: This should always be the starting point when trying to transition a monolithic
    application to microservice-style architecture. Identify and pick up those parts
    of the application that are least dependent on other modules and have the least
    dependency on them, as well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试将单体应用过渡到微服务风格的架构时，这始终应该是起点。识别并挑选出那些对其他模块依赖最少且依赖程度最低的应用部分。
- en: It is very important to understand that by identifying such parts of the application,
    you are not just trying to pick up the least challenging parts to deal with. However,
    at the same time, you have identified seams, which are the most easily visible
    ones. These are parts of the application where we will perform the necessary changes
    first. This allows us to completely isolate this part of the code from the rest
    of the system. It should be ready to become a part of the microservice or deployed
    in the final stage of this exercise.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点非常重要，通过识别应用中的这些部分，你并不是仅仅试图挑选出最不具挑战性的部分来处理。然而，与此同时，你已经识别出了缝隙，这些是最容易看到的。这些是应用中我们将首先进行必要更改的部分。这使我们能够完全将这部分代码与系统其他部分隔离。它应该准备好成为微服务的一部分或在这次练习的最后阶段部署。
- en: Even though such seams have been identified, the capability to achieve microservice-style
    development is still a little further away. This is a good start, though.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管已经识别出这些缝隙，但实现微服务风格开发的能力仍然还有一段距离。这是一个好的开始。
- en: Technology
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术
- en: A two-pronged approach is required here. First, you must identify what different
    features of the application's base framework are being utilized. The differentiation
    could be, for example, implemented on the basis of heavy dependency on certain
    data structures, interprocess communication being performed, or the activity of
    report generation. This is the easier part.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要采取双管齐下的方法。首先，你必须确定应用基础框架中正在利用的不同功能。这种区分可以基于对某些数据结构的重依赖、执行进程间通信或报告生成活动。这是比较容易的部分。
- en: However, as the second step, I recommend that you become more confident and
    pick up pieces that use a type of technology that is different from what is being
    used currently. For example, there could be a piece of code relying on simple
    data structures or XML-based persistence. Identify such baggage in the system
    and mark it for a transition. A lot of prudence is required in this twin-pronged
    approach. Making a selection that is too ambitious could set you on a path similar
    to what we have been trying to avoid altogether.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，作为第二步，我建议你变得更加自信，并挑选出使用与当前使用的技术类型不同的部分。例如，可能有一段代码依赖于简单的数据结构或基于XML的持久化。识别系统中的这种负担并将其标记为过渡。在这种双管齐下的方法中需要非常谨慎。选择过于雄心勃勃可能会让你走上我们试图完全避免的道路。
- en: Some of these parts might not look like very promising candidates for the final
    microservice-style architecture application. They should still be dealt with now.
    In the end, they will allow you to easily perform the transition.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些部分可能看起来并不是最终微服务风格架构应用的很有希望的候选者。但它们现在仍然需要处理。最终，它们将使你能够轻松地进行过渡。
- en: Team structure
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队结构
- en: With every iteration of this identification process being executed, this factor
    becomes more and more important. There could be teams that are differentiated
    on various grounds, such as their technical skill set, geographical location,
    or security requirements (employees versus outsourced).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这个识别过程的每一次迭代执行，这个因素变得越来越重要。可能会有基于各种理由区分的团队，例如他们的技术技能集、地理位置或安全要求（员工与外包）。
- en: If there is a part of the functionality that requires a specific skill set,
    then you could be looking at another probable Seam candidate. Teams can be composed
    of varying degrees of these differentiation factors. As part of the transition
    to microservices, the clear differentiation that could enable them to work independently
    could further optimize their productivity.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果功能的一部分需要特定的技能集，那么你可能正在寻找另一个可能的 Seam 候选。团队可以由不同程度的不同化因素组成。作为向微服务过渡的一部分，能够使他们独立工作的清晰区分可以进一步优化他们的生产力。
- en: This can also provide a benefit in the form of safeguarding the intellectual
    property of the company—outsourcing to consultants for specific parts of the application
    is not uncommon. The capability to allow consultants or partners to help you only
    on a specific module makes the process simpler and more secure.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以提供一种形式的利益，即保护公司的知识产权——将应用程序的特定部分外包给顾问并不少见。允许顾问或合作伙伴仅在一个特定模块上帮助你的能力使得这个过程更加简单和安全。
- en: Database
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库
- en: The heart and soul of any enterprise system is its database. It is the biggest
    asset of the system on any given day. It is also the most vulnerable part of the
    whole system in such an exercise. No wonder database architects can sound mean
    and intruding whenever you ask them to make even the smallest change. Their domain
    is defined by database tables and stored procedures.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 任何企业系统的核心和灵魂是其数据库。它是系统在任何给定日期的最大资产。它也是在这种练习中最脆弱的部分。难怪数据库架构师在你要求他们进行哪怕是最小的更改时，听起来会显得有些刻薄和侵扰。他们的领域由数据库表和存储过程定义。
- en: The health of their domain is judged by the referential integrity and the time
    it takes to perform various transactions. I don't hold them guilty for overdoing
    it anymore. They have a reason for this—their past experiences. It's time to change
    that. Let me tell you, this won't be easy, as we will have to utilize a completely
    different approach to handle data integrity once we embark on this path.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 他们领域的健康状况是通过参照完整性和执行各种事务所需的时间来评判的。我不再认为他们过度行事是有罪的。他们有理由这样做——他们的过去经验。是时候改变了。让我告诉你，这不会容易，因为一旦我们踏上这条路，我们就必须利用一种完全不同的方法来处理数据完整性。
- en: You might think that the easiest approach is to divide the whole database in
    one go, but this is not the case. It can lead us to the situation we have been
    trying to avoid all along. Let's look at how to go about doing this in a more
    efficient manner.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为最简单的方法是一次性将整个数据库分割开来，但这并非如此。这可能会让我们陷入我们一直试图避免的情况。让我们看看如何以更有效的方式来进行这项工作。
- en: As you move along, picking up pieces after the module dependency analysis, identify
    the database structures that are being used to interact with the database. There
    are two steps that you need to perform here. First, check whether you can isolate
    the database structures in your code to be broken down, and align this with the
    newly defined vertical boundaries. Second, identify what it would take to break
    down the underlying database structure as well.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你继续前进，在模块依赖分析之后收集碎片，确定正在用于与数据库交互的数据库结构。在这里你需要执行两个步骤。首先，检查你是否可以将代码中的数据库结构隔离出来进行分解，并将其与新定义的垂直边界对齐。其次，确定分解底层数据库结构需要什么。
- en: Don't worry yet if breaking down the underlying data structure seems difficult.
    If it appears that it is involving other modules that you haven't started to move
    to microservices, it is a good sign. Don't let the database changes define the
    modules that you would pick and migrate to microservice-style architecture. Keep
    it the other way round. This ensures that when a database change is picked up,
    the code that depends on the change is already ready to absorb the change.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分解底层数据结构看起来很困难，请不要担心。如果它似乎涉及到你尚未开始迁移到微服务的其他模块，这是一个好兆头。不要让数据库更改定义你将选择并迁移到微服务架构的模块。相反，保持另一种方式。这确保了当数据库更改被采纳时，依赖于该更改的代码已经准备好吸收这些更改。
- en: 'This ensures that you don''t pick up the battle of data integrity while you
    are already occupied with modifying the code that would rely on this part of the
    database. Nevertheless, such database structures should draw your attention so
    that the modules that depend on them are picked next. This will allow you to easily
    complete the move to microservices for all the associated modules in one go. Refer
    to the following diagram:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了你在忙于修改依赖于这部分数据库的代码时，不会陷入数据完整性的战斗。尽管如此，这种数据库结构应该引起你的注意，以便于选择依赖于它们的模块。这将允许你一次性轻松完成所有相关模块的微服务迁移。参考以下图表：
- en: '![](img/041baa4c-439d-4fd5-97ec-6d6b82f20456.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/041baa4c-439d-4fd5-97ec-6d6b82f20456.png)'
- en: Here, we have not broken the database yet. Instead, we have simply separated
    our database access part into layers as part of the first step.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还没有破坏数据库。相反，我们只是将数据库访问部分在第一步中分离成层。
- en: What we have simply done is map the code data structure the database, and they
    no longer depend on each other. Let's see how this step would work out when we
    remove foreign key relationships.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是简单地将代码数据结构映射到数据库中，它们不再相互依赖。让我们看看当我们移除外键关系时这一步会如何运作。
- en: If we can transition the code structures being used to access the database along
    with the database structure, we will save time. This approach might differ from
    system to system and can be affected by our personal bias. If your database structure
    changes seem to be impacting modules that are yet to be marked for transition,
    move on for now.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够将用于访问数据库的代码结构和数据库结构一起过渡，我们将节省时间。这种方法可能因系统而异，并可能受到我们个人偏见的影响。如果你的数据库结构变化似乎影响了尚未标记为过渡的模块，那么现在可以继续前进。
- en: 'Another important point to understand here is what kind of changes are acceptable
    when you break down this database table or merge it with another partial structure?
    The most important thing is not to shy away from breaking those foreign key relationships
    apart. This might sound like a big difference from our traditional approach to
    maintaining data integrity. However, removing your foreign key relationships is
    the most fundamental challenge when restructuring your database to suit the microservice
    architecture. Remember that a microservice is meant to be independent of other
    services. If there are foreign key relationships with other parts of the system,
    it makes it dependent on the services owning that part of the database. Refer
    to the following diagram:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要理解的一个重要点是，当你分解这个数据库表或将其与另一个部分结构合并时，哪些变化是可以接受的？最重要的是不要回避打破那些外键关系。这听起来可能与我们传统维护数据完整性的方法有很大的不同。然而，移除外键关系是在将数据库重构以适应微服务架构时最根本的挑战。记住，微服务应该是独立于其他服务的。如果有与其他系统部分的外键关系，它会使它依赖于拥有该数据库部分的服务。参考以下图表：
- en: '![](img/d192da44-e0e3-4344-b40a-29bb63c009b4.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d192da44-e0e3-4344-b40a-29bb63c009b4.png)'
- en: 'As part of step two, we have kept the foreign key fields in the database tables
    but have removed the foreign key constraint. So the **ORDER** table is still holding
    information about **ProductID**, but the foreign key relation is broken now. Refer
    to the following diagram:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二步的一部分，我们在数据库表中保留了外键字段，但移除了外键约束。因此，**ORDER** 表仍然持有关于 **ProductID** 的信息，但现在外键关系已经断裂。参考以下图表：
- en: '![](img/cfefb0b7-e7e8-439e-87e1-34f2f8a05e41.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cfefb0b7-e7e8-439e-87e1-34f2f8a05e41.png)'
- en: This is what our microservice-style architecture would finally look like. The
    central database would be moved away in favor of each service having their own
    database. So, separating the data structures in the code and removing foreign
    key relationships is our preparation to finally make the change. The connected
    boundaries of microservices in the preceding figure signify the interservice communication.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们最终会看到的微服务风格架构。中央数据库将被移除，以支持每个服务拥有自己的数据库。因此，分离代码中的数据结构和移除外键关系是我们最终做出改变的准备。前一个图表中微服务之间的连接边界表示了服务间的通信。
- en: With the two steps performed, your code is now ready to split **ORDER** and
    **PRODUCT** into separate services, with each having their own database.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这两个步骤后，你的代码现在可以准备好将 **ORDER** 和 **PRODUCT** 分割成独立的服务，每个服务都有自己的数据库。
- en: If all of the discussion here has left you bewildered about all those transactions
    that have been safely performed up to now, you are not alone. This outcome of
    the challenge with the transactions is not a small one by any means, and deserves
    focused attention. We'll talk about this in detail a bit later. Before that, there
    is another part that becomes a no man's land in the database. It is master data
    or static data, as some may call it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这里的所有讨论都让你对至今为止安全执行的所有那些事务感到困惑，那么你并不孤单。这个关于事务的挑战的结果绝不是小事，值得集中关注。我们稍后会详细讨论这个问题。在此之前，还有一个部分在数据库中变成了无人之地。它就是主数据或静态数据，就像有些人可能会称呼它那样。
- en: Master data
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主数据
- en: Handling master data is more about your personal choice and system-specific
    requirements. If you see that the master data is not going to change for ages
    and occupies an insignificant amount of records, you are better off with the configuration
    files or even code enumerations.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 处理主数据更多的是关于你的个人选择和系统特定的需求。如果你发现主数据在很长时间内都不会改变，并且只占据很少量的记录，那么使用配置文件甚至代码枚举会更合适。
- en: This requires someone to push out the configuration files once in a while when
    the changes do happen. However, this still leaves a gap for the future. As the
    rest of the system would depend on this one module, it will be responsible for
    these updates. If this module does not behave correctly, other parts of the system
    relying on it could also be impacted negatively.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要有人在变化发生时偶尔推出配置文件。然而，这仍然为未来留下了缺口。由于系统的其他部分将依赖于这个模块，它将负责这些更新。如果这个模块表现不正确，那么依赖于它的系统其他部分也可能受到负面影响。
- en: Another option could be to wrap up the master data in a separate service altogether.
    Having the master data delivered through a service would provide the advantage
    of the services knowing the change instantly and understanding the capability
    to consume it as well.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择可能是将主数据完全封装在一个独立的服务中。通过服务提供主数据将提供服务的优势，即服务能够立即了解变化并理解其消费能力。
- en: The process of requesting this service might not be much different from the
    process of reading configuration files when required. It might be slower, but
    then it is to be done only as many times as necessary.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请求这个服务的过程可能和读取配置文件的过程没有太大区别。它可能更慢，但只需要在必要时执行这么多次。
- en: Moreover, you could also support different sets of master data. It would be
    fairly easy to maintain product sets that differ every year. With the microservice
    architecture style, it is always a good idea to be independent of any kind of
    outside reliance in future.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以支持不同的主数据集。维护每年都不同的产品集相对容易。采用微服务架构风格，始终独立于任何未来的外部依赖是一个好主意。
- en: Transaction
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务
- en: With our foreign keys gone and the database split into smaller parts, we need
    to devise our own mechanisms for handling data integrity. Here, we need to factor
    in the possibility that not all services would successfully go through a transaction
    in the scope of their respective data stores.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的外键消失，数据库被分割成更小的部分，我们需要制定自己的机制来处理数据完整性。在这里，我们需要考虑并非所有服务都能在其各自的数据存储范围内成功完成事务的可能性。
- en: A good example is a user ordering a specific product. At the time the order
    is being accepted, there is a sufficient quantity available to be ordered. However,
    by the time the order is logged, the Product service cannot log the orders for
    some reason. We don't know yet whether is was due to insufficient quantity or
    some other communication fault within the system. There are two possible options
    here. Let's discuss them one by one.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的例子是用户订购特定产品。在订单被接受的时候，有足够的库存可供订购。然而，当订单被记录下来时，由于某种原因，产品服务无法记录订单。我们还不知道这是否是由于库存不足或其他系统内的通信故障。这里有两种可能的选择。让我们逐一讨论。
- en: The first option is to try again and perform the remaining part of the transaction
    sometime later. This would require us to orchestrate the whole transaction in
    a way that tracks individual transactions across services. So every transaction
    that leads to transactions being performed for more than one service must be tracked.
    In case one of them does not go through, it deserves a retry. This might work
    for long-lived operations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是再次尝试，并在稍后时间执行事务的剩余部分。这要求我们以跟踪跨服务单个事务的方式编排整个事务。因此，任何导致对多个服务执行事务的事务都必须被跟踪。如果其中之一没有成功，它值得重试。这可能适用于长期操作。
- en: However, for other operations, this could cause a real problem. If the operation
    is not long-lived and you still decide to retry, the outcome will result in either
    locking out other transactions or making the transaction wait—meaning it is impossible
    to complete it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于其他操作，这可能会造成真正的问题。如果操作不是长期存在的，你仍然决定重试，结果将导致锁定其他事务或使事务等待——这意味着无法完成它。
- en: Another option that we can contemplate here is to cancel the entire set of transactions
    spread across various services. This means that a single failure at any stage
    of the entire set of transactions would result in the reversal of all the previous
    transactions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里可以考虑的另一个选项是取消跨越各种服务的整个事务集。这意味着整个事务集中的任何阶段的单个故障都会导致所有先前事务的回滚。
- en: This is one area where maximum prudence would be required, and it would be time
    well invested. A stable outcome is only guaranteed when the transactions are planned
    out well in any microservice-style architecture application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一需要最大谨慎的领域，这将是一个明智的投资。只有在任何微服务风格的架构应用中妥善规划事务时，才能保证稳定的输出。
- en: Communication between microservices
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务之间的通信
- en: In the preceding section, we separated our *Order module* into **Order services** and
    discussed how we can break down the foreign key relationship between **ORDER**
    and **PRODUCT** tables.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们将我们的**Order模块**分离成**Order服务**，并讨论了如何分解**ORDER**和**PRODUCT**表之间的外键关系。
- en: In a monolithic application, we have a single repository that queries the database
    to fetch the records from both **ORDER** and **PRODUCT** tables. However, in our
    upcoming microservice application, we will segregate repositories between **Order
    service** and **Product service**. With each service having its respective database,
    each one would access its own database only. **Order service** would only be able
    to access order **Database**, whereas **Product service** would be able to access
    product **Database** only. **Order service** should not be allowed to access product **Database**
    and vice versa.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体应用中，我们有一个单一的仓库，它查询数据库以从**ORDER**和**PRODUCT**表中获取记录。然而，在我们的即将推出的微服务应用中，我们将**Order服务**和**Product服务**之间的仓库进行分离。每个服务都有自己的数据库，每个服务只会访问自己的数据库。**Order服务**只能访问订单**数据库**，而**Product服务**只能访问产品**数据库**。**Order服务**不应被允许访问产品**数据库**，反之亦然。
- en: We will discuss communication between microservices in Chapter 3, *Integration
    Techniques and Microservices*, in detail.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第3章“集成技术和微服务”中详细讨论微服务之间的通信。
- en: 'Refer to the following diagram:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下图表：
- en: '![](img/357146ab-c997-4a2c-8a36-26bae14d8155.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/357146ab-c997-4a2c-8a36-26bae14d8155.png)'
- en: In the preceding figure, we can see that our UI is interacting with **Order
    Service** and **Product service** via **API gateway**. Both the services are physically
    separated from each other and there is no direct interaction between these services.
    Communication performed in this manner is also referred to as communication that
    is based on the *API Gateway Pattern*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们可以看到我们的UI通过**API网关**与**Order服务**和**Product服务**进行交互。这两个服务在物理上是分离的，并且这些服务之间没有直接交互。以这种方式进行的通信也被称为基于**API网关模式**的通信。
- en: The API gateway is nothing but a middle tier via which the UI can interact with
    the microservices. It also provides a simpler interface and makes the process
    of consuming these services simpler. It provides a different level of granularity
    to different clients as required (browser and desktop).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: API网关实际上是一个中间层，通过它UI可以与微服务进行交互。它还提供了一个更简单的接口，简化了消费这些服务的流程。它根据需要为不同的客户端提供不同级别的粒度（浏览器和桌面）。
- en: We can say that it provides coarse-grained APIs to mobile clients and fine-grained
    APIs to desktop clients, and it can use a high-performance network underneath
    its hood to provide some serious throughput.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，它为移动客户端提供粗粒度API，为桌面客户端提供细粒度API，并且它可以在其内部使用高性能网络来提供一些严重的吞吐量。
- en: 'The definition of granularity from Wikipedia is as follows ([https://en.wikipedia.org/wiki/Granularity](https://en.wikipedia.org/wiki/Granularity)):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科对粒度的定义如下([https://en.wikipedia.org/wiki/Granularity](https://en.wikipedia.org/wiki/Granularity))：
- en: '"**Granularity** is the extent to which a system is broken down into small
    parts, either the system itself or its description or observation. It is the extent
    to which a larger entity is subdivided. For example, a yard broken into inches
    has a finer granularity than a yard broken into feet.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: “**粒度**是指系统分解成小部分的程度，无论是系统本身、其描述还是观察。它是更大实体细分到何种程度。例如，将码分成英寸的粒度比将码分成英尺的粒度更细。”
- en: Coarse-grained systems consist of fewer, larger components than fine-grained
    systems; a coarse-grained description of a system regards large subcomponents
    while a fine-grained description regards smaller components of which the larger
    ones are composed."
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 粗粒度系统由比细粒度系统更少、更大的组件组成；一个系统的粗粒度描述关注大子组件，而细粒度描述关注由较大组件组成的较小组件。
- en: Benefits of the API gateway for microservices
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API网关对微服务的益处
- en: 'There is no doubt that the API gateway is beneficial for microservices. With
    its use, you can do the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，API网关对微服务是有益的。使用它，你可以做以下事情：
- en: Invoke services through the API gateway
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过API网关调用服务
- en: Reduce round trips between the client and the application
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少客户端与应用程序之间的往返次数
- en: The client has the ability to access different APIs in one place, as segregated
    by the gateway
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端能够在一个地方访问不同的API，这些API由网关进行隔离
- en: It provides flexibility to clients in such a manner that they are able to interact
    with different services as and when they need to. This way, there is no need to
    expose complete/all services at all. API gateway is a component of complete API
    management. In our solution, we will use Azure API management, and we will explain
    it further in Chapter 3, *Integration Techniques and Microservices*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它以这种方式为客户端提供灵活性，使他们能够根据需要与不同的服务进行交互。这样，就无需完全或全部公开服务。API网关是完整API管理的一个组件。在我们的解决方案中，我们将使用Azure
    API管理，并在第3章“集成技术和微服务”中进一步解释。
- en: API gateway versus API management
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API网关与API管理的比较
- en: 'In the preceding section, we discussed how the API gateway hides the actual
    APIs from its client and then simply redirects the calls to the actual API from
    these clients. The API management solution provides a complete management system
    to manage all the APIs of its external consumers. All API management solutions,
    such as Azure API management ([https://docs.microsoft.com/en-us/azure/api-management/](https://docs.microsoft.com/en-us/azure/api-management/)),
    provide various capabilities and functionalities, such as:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了API网关如何隐藏实际API以防止其客户端直接访问，然后仅将这些客户端的调用重定向到实际API。API管理解决方案提供了一个完整的系统来管理其外部消费者的所有API。所有API管理解决方案，例如Azure
    API管理([https://docs.microsoft.com/en-us/azure/api-management/](https://docs.microsoft.com/en-us/azure/api-management/))，都提供了各种功能和能力，例如：
- en: Design
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计
- en: Development
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发
- en: Security
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Publishing
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布
- en: Scalability
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可伸缩性
- en: Monitoring
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控
- en: Analysis
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析
- en: Monetization
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赚钱
- en: Revisiting the Flix One case study
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾Flix One案例研究
- en: 'In the preceding chapter, we looked at an example of an imaginary company,
    Flix One Inc., operating in the e-commerce domain and having its own .NET monolithic
    application: the Flix One bookstore. We have already discussed the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们查看了一个虚构公司Flix One Inc.的例子，该公司在电子商务领域运营，并拥有自己的.NET单体应用：Flix One书店。我们已经讨论了以下内容：
- en: How to segregate the code
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何隔离代码
- en: How to segregate the database
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何隔离数据库
- en: How to denormalize the database
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何对数据库进行反规范化
- en: How to begin transitioning
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何开始过渡
- en: The available refactoring approaches
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的重构方法
- en: In the next sections, we will start writing/transitioning .NET monolith to a microservice
    application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始编写/过渡.NET单体应用到一个微服务应用。
- en: Prerequisites
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前提条件
- en: 'We will use the following tools and technologies while transitioning our monolithic
    application to microservice-style architecture:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在将我们的单体应用过渡到微服务架构风格时，我们将使用以下工具和技术：
- en: Visual Studio 2017 update 3 or later
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2017更新3或更高版本
- en: C# 7.0
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 7.0
- en: ASP.NET Core MVC/Web API
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC/Web API
- en: Entity Framework Core
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Entity Framework Core
- en: SQL Server 2008R2 or later
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server 2008R2 或更高版本
- en: Transitioning to our product service
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转向我们的产品服务
- en: 'We already have our product module in place. We are going to pull back this
    module now and start with a new ASP.NET Core MVC project. To do this, follow all
    the steps we discussed in the preceding sections and in [Chapter 1](6126f4b5-7098-4bb4-891d-02065b4b5930.xhtml), *An
    Introduction to Microservices*, Let''s examine the technology and database we
    will use:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经建立了我们的产品模块。我们现在将撤回这个模块，并开始一个新的 ASP.NET Core MVC 项目。为此，请遵循我们在前几节和[第1章](6126f4b5-7098-4bb4-891d-02065b4b5930.xhtml)，*微服务简介*中讨论的所有步骤，让我们来检查我们将使用的技术和数据库：
- en: 'Technology stack: We have already selected this for our product service; we
    will go with ASP.NET Core, C#, **Entity framework **(**EF**), and so on. Microservices
    can be written using different technology stacks and can be consumed by clients
    created by different technologies. For our product service, we will go with ASP.NET
    Core.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术栈：我们已经为我们的产品服务选择了这项技术；我们将使用 ASP.NET Core、C#、**Entity framework **(**EF**)
    等技术。微服务可以使用不同的技术栈编写，并且可以被由不同技术创建的客户端消费。对于我们的产品服务，我们将选择 ASP.NET Core。
- en: 'Database: We have already discussed this in [Chapter 1](6126f4b5-7098-4bb4-891d-02065b4b5930.xhtml),
    *An Introduction to Microservices*, when talking about a monolithic application
    and segregating its database. Here, we will go with SQL Server, and the database
    schema will be `Product` instead of `dbo`.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库：我们在[第1章](6126f4b5-7098-4bb4-891d-02065b4b5930.xhtml)，*微服务简介*中讨论单体应用程序及其数据库隔离时已经讨论过这个问题。在这里，我们将使用
    SQL Server，数据库模式将是 `Product` 而不是 `dbo`。
- en: 'Our product database is segregated. We will use this database in our product
    service, as shown in the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的产品数据库是隔离的。我们将在产品服务中使用这个数据库，如下截图所示：
- en: '![](img/2b8f6813-6396-4dec-989e-9aeeaeffd95b.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b8f6813-6396-4dec-989e-9aeeaeffd95b.png)'
- en: We have created a separated product database for our product service. We did
    not migrate the entire data. In the following sections, we will discuss product
    database migration as well. Migration is important as we have numerous existing
    records of FlixOne bookstore customers. We can't ignore these records, and they
    need to be migrated to our modified structure. Let's get started.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的产品服务创建了一个分离的产品数据库。我们没有迁移所有数据。在接下来的章节中，我们将讨论产品数据库迁移。迁移很重要，因为我们有大量的 FlixOne
    书店客户现有记录。我们不能忽略这些记录，并且它们需要迁移到我们修改后的结构中。让我们开始吧。
- en: Migrations
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移
- en: In the preceding section, we separated our product database to ensure that it
    would only be used by our product service. We also selected a technology stack
    of our choice to build our microservice (product service). In this section, we
    will discuss how we can migrate both our existing code and database to ensure
    that they fit right in with our new architectural style.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个章节中，我们将产品数据库分离，以确保它只被我们的产品服务使用。我们还选择了我们选择的技术栈来构建我们的微服务（产品服务）。在本节中，我们将讨论如何迁移我们现有的代码和数据库，以确保它们与我们的新架构风格完美匹配。
- en: Code migration
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码迁移
- en: 'Code migration does not involve just pulling out a few layers of code from
    the existing monolithic application and then bundling it with our newly created
    **Product service**. In order to achieve this, you''ll need to implement all that
    you have learned up until now. In the existing monolithic application, we have
    a single repository, which is common to all modules, whereas, for microservices,
    we will create repositories for each module separately and keep them isolated
    from each other:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 代码迁移不仅仅是将现有单体应用程序中的一层或多层代码提取出来，然后与我们的新创建的 **Product 服务**捆绑在一起。为了实现这一点，你需要实施到目前为止所学的所有内容。在现有的单体应用程序中，我们有一个单一的资源库，它是所有模块共有的，而对于微服务，我们将为每个模块单独创建资源库，并将它们彼此隔离：
- en: '![](img/5e671df5-24e4-49e7-8c3b-70ae5507352d.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e671df5-24e4-49e7-8c3b-70ae5507352d.png)'
- en: In the preceding image, **Product service** has a **Product repository**, which
    further interacts with its designated data store, named **Product database**.
    We will now discuss microcomponents a bit more. They are nothing but isolated parts
    of the application (microservice), namely common classes and business functionalities.
    It is worthwhile to note here that the **Product repository** itself is a microcomponent
    in the world of microservices.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，**Product service** 有一个 **Product repository**，它进一步与其指定的数据存储（**Product
    database**）交互。现在我们将更详细地讨论微组件。它们不过是应用程序的独立部分（微服务），即常见的类和业务功能。值得注意的是，**Product repository**
    本身就是微服务世界中的一个微组件。
- en: 'In our final product service, which is to be done in ASP.NET Core 2.0, we will
    work with a model and controller to create our REST API. Let''s talk about both
    of these briefly:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最终产品服务中，我们将使用 ASP.NET Core 2.0 来完成，我们将使用模型和控制器来创建我们的 REST API。让我们简要地谈谈这两者：
- en: 'Model: This is an object that represents the data in the product service. In
    our case, the identified models are stacked into product and category fields.
    In our code, models are nothing but a set of simple C# classes. When we talk in
    terms of EF Core, they are commonly referred to as **plain old CLR objects** (**POCOs**).
    POCOs are nothing but simple entities without any data access functionality.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型：这是一个代表产品服务中数据的对象。在我们的案例中，已识别的模型堆叠在产品和类别字段中。在我们的代码中，模型不过是一系列简单的 C# 类。当我们谈论
    EF Core 时，它们通常被称为 **Plain Old CLR Objects**（**POCOs**）。POCOs 不过是没有任何数据访问功能的简单实体。
- en: Controller: This is a simple C# class that inherits an abstract class controller
    of the `Microsoft.AspNetCore.Mvc `namespace. It handles HTTP requests and is responsible
    for the creation of the HTTP response to be sent back. In our **Product** service,
    we have a product controller that handles everything.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器：这是一个简单的 C# 类，继承自 `Microsoft.AspNetCore.Mvc` 命名空间中的抽象控制器类。它处理 HTTP 请求，并负责创建要发送回的
    HTTP 响应。在我们的 **Product** 服务中，我们有一个处理所有事务的产品控制器。
- en: Let's follow a step-by-step approach to create our product service.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遵循逐步方法来创建我们的产品服务。
- en: Creating our project
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的项目
- en: 'As already decided in the previous sections, we will create our `ProductService`
    in ASP.NET Core 2.0 or C# 7.0, using Visual Studio. Let''s look at what steps
    are required to do this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节已决定，我们将使用 Visual Studio 在 ASP.NET Core 2.0 或 C# 7.0 中创建我们的 `ProductService`。让我们看看完成此操作所需的步骤：
- en: Start Visual Studio.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio。
- en: Create a new project by navigating to File | New | Project.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到文件 | 新建 | 项目来创建一个新的项目。
- en: From the template options available, select ASP.NET Core Web Application.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用的模板选项中选择 ASP.NET Core Web Application。
- en: Enter the project name as `FlixOne.BookStore.ProductService`, and click on ok.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目名称输入为 `FlixOne.BookStore.ProductService`，然后点击确定。
- en: 'From the template screen, select Web Application (Model-View-Controller) and
    make sure you have selected .NET Core and ASP.NET Core 2.0 from the options, as
    shown in the following screenshot:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从模板屏幕，选择 Web Application (Model-View-Controller)，并确保您已从选项中选择 .NET Core 和 ASP.NET
    Core 2.0，如以下截图所示：
- en: '![](img/02d9049b-d80a-4141-8e6c-f6924ca39bac.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![属性设置](img/02d9049b-d80a-4141-8e6c-f6924ca39bac.png)'
- en: 6\. Leave rest options as the default and click on ok.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 将其余选项保留为默认值并点击确定。
- en: 'The new solution should look like the following screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 新解决方案应该看起来像以下截图：
- en: '![](img/ffc4e6f9-bc82-4013-a5a3-1d1ff156a5cd.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/ffc4e6f9-bc82-4013-a5a3-1d1ff156a5cd.png)'
- en: From the solution explorer, right-click (or press *Alt* + *Enter*) on the project
    and click on Properties.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器，右键单击（或按 *Alt* + *Enter*）项目，然后点击属性：
- en: 'From the Properties window, click on Build and click on Advance. The Language
    version should be C#7.0, as shown in the following screenshot:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从属性窗口，点击构建并点击高级。语言版本应该是 C#7.0，如以下截图所示：
- en: '![](img/fa3860db-5a10-4058-9e42-ce6490740072.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/fa3860db-5a10-4058-9e42-ce6490740072.png)'
- en: Adding the model
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加模型
- en: In our monolithic application, we do not have any model classes yet. So let's
    go ahead and add a new model as required.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的单体应用程序中，我们还没有任何模型类。因此，让我们继续添加一个所需的新模型。
- en: 'To add the new model, add a new folder and name it `Models`. In the Solution
    Explorer, right-click on the project and then click on options from Add | New
    Folder:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加新模型，添加一个新文件夹并将其命名为 `Models`。在解决方案资源管理器中，右键单击项目，然后从添加 | 新文件夹中点击选项：
- en: '![](img/062c2d4c-7372-4fbb-ad95-7d72e74618e2.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![添加模型](img/062c2d4c-7372-4fbb-ad95-7d72e74618e2.png)'
- en: There is no hard and fast rule for putting all the model classes in a folder
    named `Models`. As a matter of fact, we can put our model classes anywhere in
    the project in our application. We follow this practice as it becomes self-explanatory
    from folder names. At the same time, it easily identifies that this folder is
    for the model classes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有模型类放入名为 `Models` 的文件夹中并没有硬性规定。实际上，我们可以在应用程序项目的任何地方放置我们的模型类。我们遵循这种做法，因为它使得文件夹名称变得自解释。同时，它也容易识别这个文件夹是用于模型类的。
- en: 'To add new Product and Category classes (these classes will represent our POCOs),
    do as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加新的产品类别类（这些类将代表我们的 POCOs），请按照以下步骤操作：
- en: Right-click on the `Models` folder and chose Option.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `Models` 文件夹并选择选项。
- en: Add New Item|Class. We will name them `Product` and `Category`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新项|类。我们将它们命名为 `Product` 和 `Category`。
- en: Now add the properties that depict our product database column name to the tables `Product`
    and `Category`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将描述我们产品数据库列名的属性添加到 `Product` 和 `Category` 表中。
- en: There is no restriction regarding having the property name match the table column
    name. It is just general practice.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 关于属性名与表列名匹配没有限制。这只是一种常规做法。
- en: 'The following code snippet depicts what our `Product.cs` model class will look
    like:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段描述了我们的 `Product.cs` 模型类将看起来像什么：
- en: '[PRE0]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following code snippet shows what our `Category.cs` model class will look
    like:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了我们的 `Category.cs` 模型类将看起来像什么：
- en: '[PRE1]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Adding a repository
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加仓库
- en: In our monolithic application, we have a common repository throughout the project.
    In `ProductService`, by virtue of following all the principals learned up until
    now, we will create microcomponents, which means separate repositories encapsulating
    the data layer.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的单体应用程序中，整个项目中有一个通用的仓库。在 `ProductService` 中，通过遵循到目前为止学到的所有原则，我们将创建微组件，这意味着包含数据层的独立仓库。
- en: A repository is nothing but a simple C# class that contains the logic to retrieve
    data from the database and maps it to the model.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库不过是一个简单的 C# 类，它包含从数据库检索数据的逻辑并将其映射到模型。
- en: 'Adding a repository is as simple as following these steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 添加仓库就像遵循以下步骤一样简单：
- en: Create a new folder and name it `Persistence`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并将其命名为 `Persistence`。
- en: Add the `IProductRepository` interface and a `ProductRepository` class that
    will implement the `IProductRepository` interface.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `IProductRepository` 接口和一个实现 `IProductRepository` 接口的 `ProductRepository`
    类。
- en: Again, we name the folder `Persistence` in an effort to follow the general principal
    for easy identification.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们命名文件夹为 `Persistence`，以遵循易于识别的一般原则。
- en: 'The following code snippet provides an overview of the `IProductRepository`
    interface:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段提供了 `IProductRepository` 接口的一个概述：
- en: '[PRE2]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following code snippet provides an overview of the `ProductRepository` class
    (it is still without any implementation and it does not have any interaction with
    the database yet):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段提供了 `ProductRepository` 类的一个概述（它还没有任何实现，并且还没有与数据库进行任何交互）：
- en: '[PRE3]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Registering the repositories
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册仓库
- en: 'For `ProductService`, we will use built-in dependency injection support with
    ASP.NET Core. To do so, follow these simple steps:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `ProductService`，我们将使用 ASP.NET Core 内置的依赖注入支持。为此，请按照以下简单步骤操作：
- en: Open `Startup.cs`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Startup.cs`。
- en: 'Add the repository to the `ConfigureServices` method. It should look like this:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将仓库添加到 `ConfigureServices` 方法中。它应该看起来像这样：
- en: '[PRE4]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Adding a product controller
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加产品控制器
- en: Finally, we have reached the stage where we can proceed to add our controller
    class. This controller will actually be responsible for responding to the incoming
    HTTP requests with the applicable HTTP response. In case you are wondering what
    is to be done with that, you can see the `HomeController` class, as it is a default
    class provided by the ASP.NET core template.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经到达了可以继续添加我们的控制器类的阶段。这个控制器实际上将负责对传入的 HTTP 请求做出相应的 HTTP 响应。如果你想知道该怎么做，你可以查看
    `HomeController` 类，因为它是由 ASP.NET core 模板提供的默认类。
- en: 'Right-click on the `controllers` folder, chose the Add | New Item option, and
    select Web API Controller Class. Name it `ProductController`. Here we are going
    to utilize whatever code/functionality we can from the monolithic application.
    Go back to the legacy code and look at the operations you''re performing there;
    they can be borrowed for our `ProductController` class. Refer to the following
    screenshot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击 `controllers` 文件夹，选择 Add | New Item 选项，然后选择 Web API Controller Class。将其命名为
    `ProductController`。在这里，我们将利用来自单体应用的任何代码/功能。回到旧代码，查看你正在执行的操作；它们可以被借用到我们的 `ProductController`
    类中。参考以下截图：
- en: '![](img/13d111e8-9d32-4c0e-8c50-7305312f1990.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13d111e8-9d32-4c0e-8c50-7305312f1990.png)'
- en: 'After we have made the required modifications to `ProductController`, it should
    look something similar to this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对 `ProductController` 进行了必要的修改后，它应该看起来类似于以下内容：
- en: '[PRE5]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The ProductService API
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ProductService API
- en: 'In our monolithic application, for the `Product` module, we are doing the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的单体应用中，对于 `Product` 模块，我们正在执行以下操作：
- en: Adding a new `Product` module
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个新的 `Product` 模块
- en: Updating an existing `Product` module
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新现有的 `Product` 模块
- en: Deleting an existing `Product` module
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除现有的 `Product` 模块
- en: Retrieving a `Product` module
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 `Product` 模块
- en: 'Now we will create `ProductService`; we require the following APIs:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建 `ProductService`；我们需要以下 API：
- en: '| **API Resource** | **Description** |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| **API 资源** | **描述** |'
- en: '| `GET` /`api`/`Product` | Gets a list of products |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `GET` /`api`/`Product` | 获取产品列表 |'
- en: '| `GET` /`api`/`Product{id}` | Gets a product |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `GET` /`api`/`Product{id}` | 获取一个产品 |'
- en: '| `PUT` /`api`/`Product{id}` | Updates an existing product |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` /`api`/`Product{id}` | 更新现有的产品 |'
- en: '| `DELETE` /`api`/`Product{id}` | Deletes an existing product |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` /`api`/`Product{id}` | 删除现有的产品 |'
- en: '| `POST` /`api`/`Product` | Adds a new product |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `POST` /`api`/`Product` | 添加一个新的产品 |'
- en: Adding EF core support
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 EF core 支持
- en: Before going further, we need to add EF so that our service can interact with
    the actual product database. Until now, we did not add any method to our repository
    that could interact with the database.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要添加 EF 以便我们的服务可以与实际的产品数据库交互。到目前为止，我们没有向我们的存储库添加任何可以与数据库交互的方法。
- en: To add EF core support, we need to add EF's core `sqlserver` package (we are
    adding the `sqlserver` package because we are using SQL Server as our DB server).
    Open the NuGet Package Manager (Tools | NuGet Package Manager | Manage NuGet Package).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加 EF core 支持，我们需要添加 EF 的核心 `sqlserver` 包（我们添加 `sqlserver` 包是因为我们正在使用 SQL Server
    作为我们的数据库服务器）。打开 NuGet 包管理器（工具 | NuGet 包管理器 | 管理NuGet包）。
- en: 'Open the NuGet Package and search for `Microsoft.EntityFrameworkCore.SqlServer`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 NuGet 包管理器并搜索 `Microsoft.EntityFrameworkCore.SqlServer`：
- en: '![](img/b9de49b9-e010-4ae5-b66d-2035e6473095.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9de49b9-e010-4ae5-b66d-2035e6473095.png)'
- en: EF Core DbContext
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EF Core DbContext
- en: 'In the preceding section, we added the EF Core 2.0 package for SQL Server support;
    now we need to create a context so our models can interact with our product database.
    We have the Product and Category models, refer to this list:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们为 SQL Server 支持添加了 EF Core 2.0 包；现在我们需要创建一个上下文，以便我们的模型可以与我们的产品数据库交互。我们有产品和分类模型，参考以下列表：
- en: Add a new folder and name it `Contexts`—it is not compulsory to add a new folder.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的文件夹并将其命名为 `Contexts`—添加新文件夹不是强制性的。
- en: In the `context` folder, add a new C# class and name it `ProductContext`. We
    are creating `DbContext` for `ProductDatabase`, so to make it similar here, we
    are creating `ProductContext`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `context` 文件夹中，添加一个新的 C# 类并将其命名为 `ProductContext`。我们正在为 `ProductDatabase`
    创建 `DbContext`，为了使其在这里相似，我们创建 `ProductContext`。
- en: Make sure the `ProductContext` class inherits the `DbContext` class.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将 `ProductContext` 类继承自 `DbContext` 类。
- en: 'Make the changes, and our `ProductContext` class will look like this:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行更改，我们的 `ProductContext` 类将看起来像这样：
- en: '[PRE6]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have created our context, but this context is independent of the product
    database. We need to add a provider and connection string so that `ProductContext` can
    talk with our database.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了上下文，但这个上下文与产品数据库是独立的。我们需要添加一个提供者和连接字符串，以便 `ProductContext` 可以与我们的数据库通信。
- en: 'Once again, open the `Startup.cs` file and add the `SQL Server db` provider
    for our EF Core support, under the `ConfigureServcies` method. Once you add the
    provider''s `ConfigureServcies` method, our `Startup.cs` file will look like this:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开 `Startup.cs` 文件，并在 `ConfigureServices` 方法下添加 `SQL Server db` 提供器以支持我们的
    EF Core。一旦添加了提供器的 `ConfigureServices` 方法，我们的 `Startup.cs` 文件将看起来像这样：
- en: '[PRE7]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Open the `appsettings.json` file and add the required database connection string.
    In our provider, we have already set the connection key as `ProductsConnection.`
    So now, add the following line to set the connection string with the same key
    (change Data Source to your data source):'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`appsettings.json`文件并添加所需的数据库连接字符串。在我们的提供者中，我们已经将连接密钥设置为`ProductsConnection`。因此，现在添加以下行以使用相同的密钥设置连接字符串（将数据源更改为您的数据源）：
- en: '[PRE8]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: EF Core migrations
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EF Core迁移
- en: 'Although we have already created our product database, it is not time to underestimate
    the power of EF Core migrations. EF Core migrations will be helpful for us to
    perform any future modifications to the database. This modification could be in
    the form of a simple field addition or any other update to the database structure.
    We can simply rely on these EF Core migration commands every time to do the necessary
    changes for us. In order to utilize this capability, follow these simple steps:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经创建了产品数据库，但不应低估EF Core迁移的力量。EF Core迁移将帮助我们执行对数据库的任何未来修改。这种修改可能是简单字段添加或对数据库结构的任何其他更新。我们可以简单地依赖这些EF
    Core迁移命令来为我们进行必要的更改。为了利用这一功能，请按照以下简单步骤操作：
- en: Go to Tools | NuGet Package Manager | Package Manager Console.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往工具 | NuGet包管理器 | 包管理器控制台。
- en: 'Run the following commands from Package Manager Console:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从包管理器控制台运行以下命令：
- en: '[PRE9]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To initiate the migration, run this command:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启动迁移，运行以下命令：
- en: '[PRE10]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is important to note that this is to be done only the first time (when we
    do not yet have a database created by this command).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，这应该只在进行一次（当我们还没有通过此命令创建数据库时）。
- en: 'Now, whenever there are any changes in your model, simply execute the following
    command:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，每当您的模型有任何更改时，只需执行以下命令：
- en: '[PRE11]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Database migration
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库迁移
- en: At this point, we are done with our `ProductDatabase` creation. Now it's time
    to migrate our existing database. There are many different ways to do this. Our
    monolithic application, which presently has a huge database, contains a large
    number of records as well. It is not possible to migrate them by simply using
    a database SQL script.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经完成了`ProductDatabase`的创建。现在，是时候迁移我们现有的数据库了。有许许多多的方法可以做到这一点。我们目前拥有一个庞大的数据库的单体应用程序，其中包含大量的记录。仅使用数据库SQL脚本是无法迁移它们的。
- en: We need to explicitly create a script to migrate the database with all of its
    data. Another option is to go ahead and create a DB package as required. Depending
    on the complexity of your data and the records, you might need to create more
    than one data package to ensure that the data is migrated correctly to our newly
    created database, `ProductDB`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要显式地创建一个脚本以迁移包含所有数据的数据库。另一个选择是继续创建所需的DB包。根据您数据复杂性和记录的数量，您可能需要创建多个数据包以确保数据正确迁移到我们新创建的数据库`ProductDB`。
- en: Revisiting repositories and the controller
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视仓储和控制器
- en: 'We are now ready to facilitate interaction between our model and database via our
    newly created repositories. After making the appropriate changes to `ProductRepository`,
    it will look like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好通过我们新创建的仓储来促进模型和数据库之间的交互。在适当修改`ProductRepository`后，它将如下所示：
- en: '[PRE12]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Introducing ViewModel
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍ViewModel
- en: 'Add a new class to the `models` folder and name it `ProductViewModel`. We do
    this because, in our monolithic application, whenever we search for a product,
    it should be displayed in its product category. In order to support this, we need
    to incorporate the necessary fields into our view model. Our `ProductViewModel` class
    will look like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在`models`文件夹中添加一个新的类，命名为`ProductViewModel`。我们这样做是因为，在我们的单体应用程序中，每次我们搜索产品时，它应该显示在其产品类别中。为了支持这一点，我们需要将必要的字段纳入我们的视图模型。我们的`ProductViewModel`类将如下所示：
- en: '[PRE13]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Revisiting the product controller
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视产品控制器
- en: 'Finally, we are ready to create a REST API for `ProductService`. After the
    changes are made, here is what `ProductController` will look like:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备好为`ProductService`创建REST API。在做出更改后，`ProductController`将如下所示：
- en: '[PRE14]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have completed our all the tasks that are required for web API creation.
    Now, we need to tweaks few things so that client can get information about our
    web APIs. So, in the upcoming sections, we will add Swagger to our web API documentation.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了创建Web API所需的所有任务。现在，我们需要调整一些设置，以便客户端可以获取有关我们的Web API的信息。因此，在接下来的章节中，我们将向Web
    API文档中添加Swagger。
- en: Adding Swagger support
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Swagger支持
- en: We are using Swagger in our API documentation. We will not dive into the details
    of Swagger here (for more information, refer to [https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger)).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的API文档中使用Swagger。在这里，我们不会深入Swagger的细节（更多信息，请参阅[https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger))。
- en: Swagger is an open source and famous library that provides documentation for
    Web APIs. Refer to the official link, [https://swagger.io/](https://swagger.io/),
    for more information.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger是一个开源且著名的库，为Web API提供文档。有关更多信息，请参阅官方链接，[https://swagger.io/](https://swagger.io/)。
- en: 'It is very easy to add documentation using Swagger. Follow these steps:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Swagger添加文档非常简单。按照以下步骤操作：
- en: Open NuGet Package Manager.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开NuGet包管理器。
- en: Search for the `Swashbuckle.AspNetCore` package.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索`Swashbuckle.AspNetCore`包。
- en: 'Select the package and then install the package:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择包然后安装包：
- en: '![](img/f71fad12-faa2-4147-833b-53ac1361df19.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f71fad12-faa2-4147-833b-53ac1361df19.png)'
- en: 'It will install the following:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将安装以下内容：
- en: Swashbuckle.AspNetCore
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swashbuckle.AspNetCore
- en: Swashbuckle.AspNetCore.Swagger
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swashbuckle.AspNetCore.Swagger
- en: Swashbuckle.AspNetCore.SwaggerGen
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swashbuckle.AspNetCore.SwaggerGen
- en: Swashbuckle.AspNetCore.SwaggerUI
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swashbuckle.AspNetCore.SwaggerUI
- en: 'This is shown in the following screenshot:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下面的屏幕截图中显示：
- en: '![](img/20ceaa41-dd98-46f8-ace6-39f8a46fc3c5.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20ceaa41-dd98-46f8-ace6-39f8a46fc3c5.png)'
- en: 'Open the `Startup.cs` file, move to the ConfigureServices method, and add the
    following lines to register the Swagger generator:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Startup.cs`文件，移动到`ConfigureServices`方法，并添加以下行以注册Swagger生成器：
- en: '[PRE15]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, in the Configure method, add the following code:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Configure`方法中添加以下代码：
- en: '[PRE16]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Press *F5* and run the application; you'll get a default page.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*F5*运行应用程序；您将获得一个默认页面。
- en: 'Open the Swagger documentation by adding swagger in the URL. So, the URL would
    be `http://localhost:43552/swagger/`:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在URL中添加swagger来打开Swagger文档。因此，URL将是`http://localhost:43552/swagger/`：
- en: '![](img/64e5272f-fc8a-4a65-be37-8a765d25ae75.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64e5272f-fc8a-4a65-be37-8a765d25ae75.png)'
- en: The preceding image shows the Product API resources, and you can try these APIs
    from within the Swagger documentation page.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图像显示了产品API资源，您可以在Swagger文档页面中尝试这些API。
- en: 'Finally, we have completed the transition of our monolith .NET application
    to microservices and discussed the step-by-step transition of `ProductService`.
    There are more steps to come for this application:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经完成了我们的单体.NET应用程序向微服务的过渡，并讨论了`ProductService`的逐步过渡。对于此应用程序还有更多步骤要来：
- en: 'How microservices communicate: This will be discussed in *Chapter 3, Integration
    Techniques and Microservices*'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务如何通信：这将在*第3章，集成技术和微服务*中讨论。
- en: 'How to test a microservice: This will be discussed in **Chapter 4, Testing
    Microservices**'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何测试微服务：这将在**第4章，测试微服务**中讨论。
- en: 'Deploying microservices: This will be discussed in *[Chapter 5](6843b0a1-0287-4d15-9e72-fdf228e52604.xhtml),
    Deploying Microservices*'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署微服务：这将在*[第5章](6843b0a1-0287-4d15-9e72-fdf228e52604.xhtml)，部署微服务*中讨论。
- en: 'How can we make sure our microservices are secure, and monitoring our microservices:
    This will be discussed in *Chapter 6, Securing Microservices*, and *Chapter 7,
    Monitoring Microservices*'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保我们的微服务安全，以及监控微服务：这将在*第6章，确保微服务安全*和*第7章，监控微服务*中讨论。
- en: 'How microservices are scaled: This will be discussed in *Chapter 8, Scaling
    Microservices*'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务如何扩展：这将在*第8章，扩展微服务*中讨论。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the different factors that can be used to identify
    and isolate microservices at a high level. We also discussed the various characteristics
    of a good service. When talking about DDD, we learned its importance in the context
    of microservices.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了可以用于在高级别识别和隔离微服务的不同因素。我们还讨论了良好服务的各种特征。在谈论领域驱动设计（DDD）时，我们学习了它在微服务环境中的重要性。
- en: Furthermore, we analyzed how we can correctly achieve the vertical isolation
    of microservices through various parameters in detail. We tried to draw on our
    previous understanding of the challenges posed by a monolithic application and
    its solution in microservices, and we learned that we can use factors such as
    module interdependency, technology utilization, and team structure to identify
    seams and perform the transition from a monolithic architecture to microservices
    in an organized manner.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们详细分析了如何通过各种参数正确实现微服务的垂直隔离。我们试图借鉴我们对单体应用带来的挑战及其在微服务中的解决方案的先前理解，并了解到我们可以利用模块间的依赖性、技术利用率和团队结构来识别接口，并有序地将单体架构过渡到微服务架构。
- en: It became apparent that the database can pose a clear challenge in this process.
    However, we identified how we can still perform the process using a simple strategy
    and the possible approaches to do this. We then established that, with the foreign
    keys reduced/removed, the transactions can be handled in a completely different
    manner.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，数据库在这个过程中可能构成一个明显的挑战。然而，我们确定了如何使用简单策略和可能的实施方法来执行此过程。然后我们确定，通过减少/移除外键，事务可以以完全不同的方式处理。
- en: Moving on from a monolith to bounded contexts, we further applied our knowledge
    to transition the FlixOne application to a microservice architecture.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 从单体过渡到边界上下文，我们进一步将我们的知识应用于将 FlixOne 应用程序过渡到微服务架构。
