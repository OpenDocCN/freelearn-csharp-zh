<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">RPG Character Design</h1>
                
            
            <article>
                
<div class="title-page-name">
<p class="calibre3">We are now at an interesting point in our development. In this chapter, we will discuss the design of our RPG characters and look at some of the attributes and characteristics that we need to design and implement.</p>
</div>
<p class="calibre3">Here is a breakdown of the topics covered in this chapter:</p>
<ul class="calibre11">
<li class="calibre12">Character definitions</li>
<li class="calibre12">Base character class attributes</li>
<li class="calibre12">Character states</li>
<li class="calibre12">Character model:
<ul class="calibre32">
<li class="calibre12">Rigging your model</li>
<li class="calibre12">Character motion</li>
<li class="calibre12">Animator controller</li>
<li class="calibre12">Animation states</li>
<li class="calibre12">Character controller</li>
<li class="calibre12">Modification to animations</li>
</ul>
</li>
<li class="calibre12">Inverse kinematics</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Character definitions</h1>
                
            
            <article>
                
<p class="calibre3">To have a meaningful and interesting RPG, the game should usually have more than one character class. In <a target="_blank" href="part0021.html#K0RQ0-7a1ef7ae3ef249cdb149f8344d2e8e79" class="calibre10">Chapter 1</a>, <em class="calibre14"><span class="calibre6">What is an RPG?</span></em> We defined the following class types:</p>
<ul class="calibre11">
<li class="calibre12">Barbarians</li>
<li class="calibre12">Orcs</li>
<li class="calibre12">Villagers</li>
</ul>
<p class="calibre3">We won't be able to implement all of the character types, due to time. The demonstration of the implementation of one or two character types should give you a good foundation to develop your own character classes. After all, that is the overall objective of this book.</p>
<p class="calibre3">One of the main characters is, of course, the <strong class="calibre5">Player Character</strong> (<strong class="calibre5">PC</strong>). Let's go ahead and concentrate on the implementation of the PC, and then we can start defining and designing the <kbd class="calibre13">Barbarian</kbd> class, the <kbd class="calibre13">Villager</kbd> class, and perhaps the <kbd class="calibre13">Orc</kbd> class.</p>
<div class="packt_infobox">My character models will be from the Asset Store. You may either download the same characters or design your own. You can also use different types of character models. The point is to implement the character based on the specifications, which will be defined in this chapter and beyond.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Character assets</h1>
                
            
            <article>
                
<p class="calibre3">I will be using the following assets from the Asset Store for my character models:</p>
<ul class="calibre11">
<li class="calibre12">Fantasy Horde Barbarians</li>
<li class="calibre12">Fantasy Horde - Villagers</li>
<li class="calibre12">Fantasy Horde - Orc</li>
</ul>
<p class="calibre3">Let's take a look at some of the attributes that our player will have in general.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Base character class attributes</h1>
                
            
            <article>
                
<p class="calibre3">Let's start laying down the foundation we will need for the implementation of our character classes. The following is a list of attributes that will be part of the Base Character class:</p>
<ul class="calibre11">
<li class="calibre12">Character class name</li>
<li class="calibre12">Character class description</li>
<li class="calibre12">List of attributes:
<ul class="calibre32">
<li class="calibre12">Strength</li>
<li class="calibre12">Dexterity</li>
<li class="calibre12">Endurance</li>
<li class="calibre12">Intelligence</li>
<li class="calibre12">Social standing</li>
<li class="calibre12">Agility</li>
<li class="calibre12">Alertness</li>
<li class="calibre12">Vitality</li>
<li class="calibre12">Willpower</li>
</ul>
</li>
</ul>
<p class="calibre3">The attributes you define for your characters depend on the character type, but there will be some similarities between all character attributes. We would like to implement these similarities in a base class that will be shared with all character classes.</p>
<div class="packt_infobox">
<p class="calibre66">The list provided is just a sample, and you can add or subtract as you see fit.</p>
</div>
<div class="title-page-name">
<p class="calibre3">Let's keep things simple. We will use only the five primary statistics for now, as follows:</p>
</div>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Strength:</strong> Strength is a measure of how physically solid a character is. Quality controls the most extreme weight the character can convey, skirmish assault as well as harm, and some of the time hit focuses. Protective layer and weapons may likewise have a strength prerequisite.</li>
<li class="calibre12"><strong class="calibre1">Defense:</strong> Defense is a measure of how flexible a character is. Protection more often than not diminishes harm taken by either a rate or a settled sum for each hit.</li>
<li class="calibre12"><strong class="calibre1">Dexterity:</strong> Dexterity is a measure of how deft a character is. Skill controls assault, development speed, and precision, and also dodging an adversary's assault.</li>
<li class="calibre12"><strong class="calibre1">Intelligence:</strong> Intelligence is a measure of a character's critical thinking capacity. Knowledge regularly controls a character's capacity to understand remote dialects and their aptitude in enchantment. Now and again, insight controls what number of aptitude focuses the character gets at level up. In a few recreations, it controls the rate at which encounter focuses are earned, or the sum expected to level up. This is once in a while joined with shrewdness, and additionally self control.</li>
<li class="calibre12"><strong class="calibre1">Health:</strong> Health decides whether the character is alive or dead.</li>
</ul>
<p class="calibre3">The attributes listed are attributes that will be inherited by all character classes. Now let's put this into code. Create a new C# script and name it <kbd class="calibre13">BaseCharacter.cs</kbd>. Open the script and place the following code in the file:</p>
<pre class="calibre18">namespace com.noorcon.rpg2e 
{ 
   public class BaseCharacter 
   { 
      public string Name; 
      public string Description; 
 
      public float Strength; 
      public float Defense; 
      public float Dexterity; 
      public float Intelligence; 
      public float Health; 
   } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Character states     </h1>
                
            
            <article>
                
<p class="calibre3">States are an important part of the character design. They will also drive the kind of actions and movement you will need to create for each state. For instance, at a minimum our character will need to have the following states implemented:</p>
<ul class="calibre11">
<li class="calibre12">Idle</li>
<li class="calibre12">Walking</li>
<li class="calibre12">Running</li>
<li class="calibre12">Jumping</li>
<li class="calibre12">Attacking</li>
<li class="calibre12">Die</li>
</ul>
<p class="calibre3">You character may have more states defined; this is something that you, as the designer of the game, will need to identify and eventually implement. Each one of the states identified will need to be implemented as an animation. The person creating the character models will usually also develop the animations for the character.</p>
<p class="calibre3">For instance, the Orc model has the following states/animations defined:</p>
<div class="mce-root1"><img src="../images/00052.gif" class="calibre67"/></div>
<p class="calibre3">You may consider implementing all of the states or some of the states. The theory and practice are the same either way.</p>
<p class="calibre3">I can also use RawMocap data to animate the models, since the models I am using are Mecanim-ready, including Face Rigs. In fact, we will use some RawMocap data to animate the models.</p>
<p class="calibre3">With the release of Unity 5, the <em class="calibre14">Mecanim Animation System</em> was introduced, which is used to create easy workflow and setup of animations on humanoid characters, retargeting animation from one character to the next, previewing the animation clips, managing complex interactions between animations with a visual tool, and animating different body parts with different logic.</p>
<p class="calibre3">In fact, let's go ahead and download the asset from the <span class="calibre6">Asset Store</span> right now. Do a search on <em class="calibre14">Raw Mocap Data for Mecanim</em> in the <span class="calibre6">Asset Store</span>.</p>
<div class="mce-root1"><img src="../images/00053.jpeg" class="calibre68"/></div>
<div class="packt_infobox">The package contains several raw motion capture data files for your use. Be aware that you might have to make some adjustments on your own.</div>
<p class="calibre3">When creating your character models, it is a good idea to follow the proper bone structure set up for your characters. This will help make controlling the states and the animations of your character easier, as well as re-using your Animation Controller on multiple characters. This is also true if you are going to use a character from the Asset Store.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Character model</h1>
                
            
            <article>
                
<p class="calibre3">You should now consider how your player character is going to look. There are several approaches that can be taken. An easy way would be to have a predefined hero where the player does not have many options or much choice when it comes to customization of the character. The other way would be to provide the player the ability to change and modify their character to an extent or fully. This all really depends on your budget!</p>
<p class="calibre3">Here, we are going to do something in-between, to get the benefit of both worlds.</p>
<div class="packt_infobox">You may use the Asset Store to download predefined characters that can be used as placeholders for your game while you create your own. You can even use some of the characters that are freely available through the Asset Store and modify them for your needs.</div>
<p class="calibre3">Once you have determined your character model, the next step is to configure it and customize it for your game. The character model I have can be visually modified to represent several unique characters.</p>
<p class="calibre3">For instance, let's take a look at the default character models we will be working with, as detailed in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Default character models</h1>
                
            
            <article>
                
<p class="calibre3">Here is a set of character models that have been purchased from the Asset Store. I like this set of models as they are simple and straightforward to work with.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Barbarian</h1>
                
            
            <article>
                
<p class="calibre3">This model contains several body types—fat, regular, and skinny—which are set up by blendshapes on the body and cloth. It comes with 15 different body and accessories textures, one weapons texture, and two shield textures. This gives us a good range of unique character definitions and customization to enhance the range of different NPCs for the RPG.</p>
<p class="calibre3">We will take a look at how to utilize them when doing character customization. See the following screenshot for an example of a barbarian:</p>
<div class="mce-root1"><img src="../images/00054.jpeg" class="calibre45"/></div>
<div class="mce-root2">The Barbarian model</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Villager</h1>
                
            
            <article>
                
<p class="calibre3">The<span class="calibre6"> </span>Villager<span class="calibre6"> </span>models give us two groups of models: child and adult. In the adult group, we have the male, female, and monk types. There are 16 male, three monk, eight female, four child, and two equipment textures provided. For the female type, there are two types of texture: standard hair, used for loose hair, and hat, used with head accessories such as a hat.</p>
<p class="calibre3">There are two different sets of animations: one for the <kbd class="calibre13">Adult</kbd> mesh type and one for the <kbd class="calibre13">Child</kbd> mesh type. The child type has fewer states compared to the adult. See the following screenshot, depicting a male, female, and child villager:</p>
<div class="mce-root1"><img src="../images/00055.jpeg" class="calibre45"/></div>
<div class="mce-root2">The Villager models</div>
<p class="calibre3"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Orc</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6">The Orc model will be a bit different in its structure. All body-type meshes will be part of the main structure; there are three main models: Fat, Average, and Athletic. There might also be some legacy animations, which we will need to take care of when we start the configuration and programming or the </span><kbd class="calibre13">Orc</kbd><span class="calibre6"> class. See the following screenshot of an orc:</span></p>
<div class="mce-root1"><img src="../images/00056.jpeg" class="calibre45"/></div>
<div class="mce-root2">The Orc model</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Let's get started</h1>
                
            
            <article>
                
<p class="calibre3">Drag and drop the Barbarian model from your project into the scene. You will need to study your character model carefully, and understand how it is built so that you can modify it during design time, as well as during runtime if necessary.</p>
<p class="calibre3">This particular model has several visual elements attached for weapons, clothing, and so on. Your model may have been configured differently; if so, you will need to create your own attachment points and instantiate the weapons and/or other character related assets accordingly. See the following screenshot:</p>
<div class="mce-root1"><img src="../images/00057.jpeg" class="calibre45"/></div>
<div class="mce-root2">Model hierarchy</div>
<p class="calibre3">Select your character model and investigate the structure of the model. You will notice that there is a certain pattern and naming convention to the model hierarchy, as shown in the preceding screenshot. Some models might have animations attached. To check them, you will need to select the model from the <span class="calibre6">Project</span> window and select the <span class="calibre6">Animation</span> tab in the <span class="calibre6">Inspector</span> window to get a list of the embedded animations for the model, as shown in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00058.jpeg" class="calibre69"/></div>
<p class="calibre3">In the <span class="calibre6">Inspector</span> window, select the <span class="calibre6">Animations</span> tab shown in the preceding screenshot, and notice the <span class="calibre6">Clips</span> section for all animations developed for your character model, as indicated in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00059.gif" class="calibre70"/></div>
<p class="calibre3">Notice that the animation clips have a start time and an end time. The actual character model is visually displayed at the bottom of the <span class="calibre6">Inspector</span> window.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Rigging your model</h1>
                
            
            <article>
                
<p class="calibre3">There might be times that you will need to <span class="calibre6">Rig</span> your model to make it suitable for your game. This can be achieved by selecting your model source, and from the <span class="calibre6">Inspector</span> window selecting the <span class="calibre6">Rig</span> tab, as shown in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00060.jpeg" class="calibre71"/></div>
<p class="calibre3">In the <span class="calibre6">Rig</span> tab, there are several options that you can apply to your model. Assuming that your character is of <span class="calibre6">Humanoid</span> type, you will need to select the <span class="calibre6">Humanoid Animation Type</span> if not already selected. The <span class="calibre6">Avatar Definition</span> can also be either created from the model or assigned if you have an avatar defined. Finally, you can click on the <span class="calibre6">Configure...</span> button to see the configuration of the rigged model. See the following screenshot:</p>
<div class="mce-root1"><img src="../images/00061.jpeg" class="calibre45"/></div>
<div class="mce-root2">Humanoid bone structure</div>
<p class="calibre3">Notice from the preceding screenshot that your model has a mapping defined for its skeleton. If your model is of <span class="calibre6">Humanoid</span> type, and if your model structure has been named properly, the system will automatically assign the correct bones and joints. If your naming is not per Unity specification, you can navigate your model structure and manually assign each point in the <span class="calibre6">Body</span>, <span class="calibre6">Head</span>, <span class="calibre6">Left</span> <span class="calibre6">Hand</span>, and <span class="calibre6">Right Hand</span>.</p>
<p class="calibre3">The <span class="calibre6">Muscles</span> and <span class="calibre6">Settings</span> tabs will enable you to define and restrict the movement of the joints for your model. These can be very useful and practical for creating more realistic movements for your characters. You can study these topics further on your own, as they would require a whole chapter or two to cover them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Character motion</h1>
                
            
            <article>
                
<p class="calibre3">Traditionally, the motion and movement of the characters were done separately through code. With the introduction of <em class="calibre14">Mecanim</em>, you are now able to apply what is called <em class="calibre14">Root Motion</em>. This modifies the character's in-game transform based on the data in root motion.</p>
<p class="calibre3">We are going to use root motion for our characters. Root motion works with the <span class="calibre6">Animator Controller</span> and the Animation State Machine. The Body Transform and Orientation are stored in the Animation Clip. This makes it easier to create a state machine that plays the appropriate animation clip through the <span class="calibre6">Animator Controller</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Animator Controller</h1>
                
            
            <article>
                
<p class="calibre3">In this section, we will use the new <span class="calibre6">Animator Controller</span> to create our character states and determine the criteria for a change of states. Let's make a new folder in the <span class="calibre6">Project</span> window and name it <kbd class="calibre13">Animator</kbd>. Select the newly created folder.</p>
<p class="calibre3">To create an <span class="calibre6">Animator Controller</span>, in the <span class="calibre6">Project</span> window, right-click and select <em class="calibre14"><span class="calibre6">Create | Animator Controller</span></em>. Give it a name. I have called mine <kbd class="calibre13">BaseAnimatorController</kbd>. Double-click the controller to open the <span class="calibre6">Animator</span> window.</p>
<p class="calibre3">The <span class="calibre6">Animator Controller</span> is a very complex tool, and it will take you some time to study the different aspects and features that are available to you through it. The following screenshot is a snapshot of an empty controller. I have marked the main sections of the <span class="calibre6">Animator</span> window. There are two visible tabs, the <span class="calibre6">Layers</span> tab and the <em class="calibre14"><span class="calibre6">Parameters</span></em> tab. In the <em class="calibre14"><span class="calibre6">Layers</span></em>, tab you will be able to create different layers that hold your animation states and the relevant <kbd class="calibre13">Transitions</kbd> from one state to the next. The <em class="calibre14"><span class="calibre6">Parameters</span></em> tab is where you define your parameters that will be accessed and modified by the <span class="calibre6">Animator Controller</span>, as well as through your code.</p>
<p class="calibre3">There is a wide range of topics that you will need to know to fully appreciate the Mecanim system. We won't be going through all of the aspects in this book, but we will touch on some of the key aspects that are needed for our game. See the following screenshot:</p>
<div class="mce-root1"><img src="../images/00062.jpeg" class="calibre72"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Animation states</h1>
                
            
            <article>
                
<p class="calibre3">To create a new state, you can simply drag and drop an animation from your <span class="calibre6">Project</span> window. This will name and assign the relevant animation to the state in the layer. You can also create an empty state by right-clicking in the layer and selecting <em class="calibre14"><span class="calibre6">Create State</span></em> | <em class="calibre14"><span class="calibre6">Empty</span></em>. When a state is created, you can click on the state and observe its properties in the <span class="calibre6">Inspector</span> window, as shown in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00063.jpeg" class="calibre73"/></div>
<div class="packt_infobox">Your model may or may not have animations attached to it. The whole idea of the Mecanim system is to enable character modelers to work on their models, while animators can use the skeleton of a humanoid avatar to animate the character. This in turn makes it easier and better to have a set of animations applied to different types of character models!</div>
<p class="calibre3">To identify the state, it is best to provide it with a unique name that can be easily recognized in the state diagram. You will need to assign a Motion to it; this is the animation clip that will be playing when the state is active. The next important property would be the <em class="calibre14"><span class="calibre6">Transitions</span></em> property. A transition will determine the condition for which state will be moving to another state, if there is such a requirement.</p>
<p class="calibre3">For instance, when the character is in an idle state, what condition is for the character to change its state to a walking state, to a running state and so forth, as shown in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00064.jpeg" class="calibre74"/></div>
<p class="calibre3">In the preceding screenshot, you will see I have defined three different states: <span class="calibre6">Idle</span>, <span class="calibre6">Walking</span>, and <span class="calibre6">Running</span>. You will also notice that, in the <em class="calibre14"><span class="calibre6">Parameters</span></em> tab, I have defined some parameters. These parameters are used to determine when to move from idle to walking, to running, and back. The parameters are there to help you create the conditions for your state machine.</p>
<p class="calibre3">To create a <span class="calibre6">Transition</span> from one state to the next, right-click your state, and select <em class="calibre14"><span class="calibre6">Make Transition</span></em>, then select the state it will transition to. This will create the visual arrow from the start state to the end state. Select the <em class="calibre14">Transition</em> arrow to get its properties, and set the conditions in the <span class="calibre6">Inspector</span> window.</p>
<p class="calibre3">The <span class="calibre6">Walking</span> and <span class="calibre6">Running</span> states are actually a Blend Tree in this instance. A Blend Tree is used to make the transition from one animation state to the next more natural. In order for the blended motion to make sense, the motions that are blended must be of similar nature and timing.</p>
<div class="packt_infobox">Blend Trees are used to allow multiple animations to be blended smoothly by incorporating parts of them all to a varying degree. The amount that each of the motions contributes to the final effect is controlled using a blending parameter, which is just one of the numeric animation parameters associates with the <span class="packt_screen">Animator Controller</span>.</div>
<p class="calibre3">For instance, the walking state could look something like the following screenshot:</p>
<div class="mce-root1"><img src="../images/00065.jpeg" class="calibre45"/></div>
<div class="mce-root2">Blend Tree example</div>
<p class="calibre3">In our first <em class="calibre14"><span class="calibre6">Blend Tree</span></em> node, we have five outputs: <kbd class="calibre13">HumanoidWalkLeftSharp</kbd>, <kbd class="calibre13">HumanoidWalkLeft</kbd>, <kbd class="calibre13">WalkFWD</kbd>, <kbd class="calibre13">HumanoidWalkRight</kbd>, and <kbd class="calibre13">HumanoidWalkRightSharp</kbd>. These are the animation clips that will be playing based on the value of the parameter called <em class="calibre14"><span class="calibre6">Horizontal</span></em>.</p>
<div class="packt_infobox">These animations are from <em class="calibre30">Raw Mocap Data for Mecanim.</em></div>
<p class="calibre3">In the behavior region, you will notice a few thresholds that have been set up for the parameter; these thresholds are what determines the animation to be played. The value of the <span class="calibre6">Horizontal</span> parameter is set through our C# code by passing in the value of the <span class="calibre6">Horizontal</span> <span class="calibre6">Axis</span>, which is defined in the <span class="calibre6">Input Manager</span>. See the following screenshot:</p>
<div class="mce-root1"><img src="../images/00066.jpeg" class="calibre75"/></div>
<p class="calibre3">When you select a <em class="calibre14">Blend Tree</em> node, your <span class="calibre6">Inspector</span> window will give you the ability to add or remove the different animation states, as well as the parameter and the threshold of the parameter that will determine which animation will be rendered.</p>
<div class="packt_infobox">The key to have a smooth looking blending in your animation is to pay attention to your animation data.</div>
<p class="calibre3"/>
<p class="calibre3">Let's take a look at our final state diagram:</p>
<div class="mce-root1"><img src="../images/00067.jpeg" class="calibre45"/></div>
<div class="mce-root2">State diagram</div>
<p class="calibre3">At this stage, I have gone ahead and implemented the state diagram for <em class="calibre14"><span class="calibre6">Idle</span></em>, <em class="calibre14"><span class="calibre6">Walking</span></em>, <em class="calibre14"><span class="calibre6">Running</span></em>, <em class="calibre14"><span class="calibre6">Idle Jump</span></em>, <em class="calibre14"><span class="calibre6">Running Jump</span>, <span class="calibre6">Attack1/2/3</span></em>, <em class="calibre14"><span class="calibre6">Punch</span></em>, and <em class="calibre14"><span class="calibre6">Die</span></em>.</p>
<p class="calibre3">The parameter that defines the transition from the <span class="calibre6">Idle</span> state to the <span class="calibre6">Walking</span> and <span class="calibre6">Running s</span>tates is the <span class="calibre6">Speed</span> parameter. If the <span class="calibre6">Speed</span> value is greater than 0.1, it will transition from <span class="calibre6">Idle</span> to <span class="calibre6">Walking;</span> if it is greater than 0.6, it will transition from <span class="calibre6">Walking</span> to <span class="calibre6">Running</span>. The opposite is true for going from <span class="calibre6">Running</span> to <span class="calibre6">Walking</span>, and from <span class="calibre6">Walking</span> to <span class="calibre6">Running</span>.</p>
<p class="calibre3">Notice, however, that the character can only enter the <span class="calibre6">Jump</span> state from either the <span class="calibre6">Idle</span> state or from the <span class="calibre6">Running</span> state. The parameter that controls this transition is the <kbd class="calibre13">Jump</kbd> parameter, which is a Boolean value set by pressing the Space bar button on the keyboard.</p>
<p class="calibre3"/>
<p class="calibre3">There are also three attack states that can be triggered from the <span class="calibre6">Any</span> state, as well as a <span class="calibre6">Die</span> state that can be entered from the <span class="calibre6">Any</span> state. Well, this is because your character can die at any given time if you are not careful!</p>
<p class="calibre3">Let's take a look at how we can control these parameters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Character controller</h1>
                
            
            <article>
                
<p class="calibre3">It is time to enable our character to move around the scene. This is generally handled by the character controller. The character controller will be used to handle most of the interactions the player will have with the character in the game.</p>
<p class="calibre3">Create a new C# script and call it <kbd class="calibre13">BarbarianCharacterController.cs</kbd>. Enter the following code in the <kbd class="calibre13">BarbarianCharacterController</kbd> class. At the moment the code is very basic. Let's get a listing of the code and we can start discussing the different parts of the code after the listing:</p>
<pre class="calibre76">using UnityEngine; 
 
namespace com.noorcon.rpg2e 
{ 
   public class BarbarianCharacterController : MonoBehaviour 
   { 
 
      public Animator animator; 
      public float directionDampTime; 
 
      public float speed = 6.0f; 
      public float h = 0.0f; 
      public float v = 0.0f; 
 
      bool attack = false; 
      bool punch = false; 
      bool run = false; 
 
      bool jump = false; 
      bool die = false; 
      bool dead = false; 
 
      // Use this for initialization 
      void Start() 
      { 
         this.animator = GetComponent&lt;Animator&gt;() as Animator; 
      } 
 
      // Update is called once per frame 
      private Vector3 moveDirection = Vector3.zero; 
 
      void Update() 
      { 
 <br class="title-page-name"/>         if (dead) 
         { 
            if (die) 
            { 
               die = !die; 
               animator.SetBool("Die", die); 
            } 
         return; 
      } 
 
         if (Input.GetKeyDown(KeyCode.C)) 
         { 
            attack = true; 
         } 
         if (Input.GetKeyUp(KeyCode.C)) 
         { 
            attack = false; 
         } 
         animator.SetBool("Attack", attack); 
 
         if (Input.GetKeyDown(KeyCode.P)) 
         { 
            punch = true; 
         } 
         if (Input.GetKeyUp(KeyCode.P)) 
         { 
            punch = false; 
         } 
         animator.SetBool("Punch", punch); 
 
         if (Input.GetKeyDown(KeyCode.LeftShift)) 
         { 
            this.run = true; 
         } 
         if (Input.GetKeyUp(KeyCode.LeftShift)) 
         { 
            this.run = false; 
         } 
         animator.SetBool("Run", run); 
 
         if (Input.GetKeyDown(KeyCode.Space)) 
         { 
            jump = true; 
         } 
         if (Input.GetKeyUp(KeyCode.Space)) 
         { 
            jump = false; 
         } 
         animator.SetBool("Jump", jump); 
 
         if (Input.GetKeyDown(KeyCode.I)) 
         { 
            die = true; 
            dead = true; 
         } 
 
         animator.SetBool("Die", die); 
      } 
 </pre>
<p class="calibre3">In the <kbd class="calibre13">Start()</kbd> function, we will get a reference to the <span class="calibre6">Animator Controller</span>. We will be using the <kbd class="calibre13">FixedUpdate()</kbd> function to perform our updates for the character movement, as shown in the following code:</p>
<pre class="calibre76">      void FixedUpdate() 
      { 
         // The Inputs are defined in the Input Manager 
         // get value for horizontal axis 
         h = Input.GetAxis("Horizontal"); 
         // get value for vertical axis 
         v = Input.GetAxis("Vertical"); 
 
         speed = new Vector2(h, v).sqrMagnitude; 
 
         // Used to get values on console 
         Debug.Log(string.Format("H:{0} - V:{1} - Speed:{2}", h, v,    <br class="title-page-name"/>         speed)); 
 
         animator.SetFloat("Speed", speed); 
         animator.SetFloat("Horizontal", h); 
         animator.SetFloat("Vertical", v); 
      } 
   } 
} </pre>
<p class="calibre3"/>
<p class="calibre3">What is the difference between the <kbd class="calibre13">Update()</kbd> function and the <kbd class="calibre13">FixedUpdate()</kbd>? The <kbd class="calibre13">Update()</kbd> function is called every frame, and is used regularly to update the moving of non-physics objects, simple timers, and input processing. The update interval time varies for the <kbd class="calibre13">Update()</kbd> function. <kbd class="calibre13">FixedUpdate()</kbd> is called every physics step. The interval is consistent and used for adjusting physics on Rigidbody.</p>
<p class="calibre3">In the <kbd class="calibre13">FixedUpdate()</kbd> function, we get the inputs for our Horizontal and Vertical axes, we calculate the <em class="calibre14">speed</em> value, and set the parameters defined in the <span class="calibre6">Animator Controller</span> using the <kbd class="calibre13">animator.SetFloat()</kbd> function. These parameters are then used by the animator controller to decide which state the character is at.</p>
<p class="calibre3">For instance, to go from an idle state to the walking state, the <em class="calibre14">speed</em> parameter needs to be greater than 0.1, and from walking to running, the <em class="calibre14">speed</em> parameter will need to be greater than 0.6, and the <em class="calibre14">run</em> parameter needs to be true. The opposite is true when you want to go back from the running state to the walking state and from the walking state to the idle state. The Horizontal and Vertical parameters control the movement for turning left or turning right. All these three parameters combined control what state and what animation the character is rendering.</p>
<p class="calibre3">The next step is for us to enable the <em class="calibre14"><span class="calibre6">Jump</span></em>, <span class="calibre6">Die</span> and <em class="calibre14"><span class="calibre6">Attack</span></em> states. The <span class="calibre6">Jump</span> state can be entered while the character is idle or running and the Jump Boolean variable is set to true. The jump condition is set in the <kbd class="calibre13">Update()</kbd> function when the space bar is pressed by the player. This sets the variable to true and passes the variable to the animator controller.</p>
<p class="calibre3">The same mechanism is used for the attack and punch state. This is mapped to the following keys on the keyboard: <em class="calibre14">C</em> and <em class="calibre14">P</em>. Each one will set its Boolean value to true and pass it into the animator controller. The player can only enter these states from the <span class="calibre6">Any</span> state. We will leave it as is for now.</p>
<p class="calibre3">Finally, the <span class="calibre6">Die</span> state is implemented, and for now we are using the keyboard input I to test it out. The main difference between the <span class="calibre6">Die</span> state and the other states so far is that the <span class="calibre6">Die</span> state can be entered from any state.</p>
<div class="packt_infobox">We are not using Blend Trees for these states as there is only one type of animation for the state. You will also notice that the states can only be transitioned to from the <span class="packt_screen">Idle</span> state. This is due to how the animations and model were set up initially. Yours could be different.</div>
<p class="calibre3"/>
<p class="calibre3">Take a look at the following screenshot:</p>
<div class="mce-root1"><img src="../images/00068.jpeg" class="calibre45"/></div>
<div class="mce-root2">Animator parameters</div>
<p class="calibre3">The character can get into the <span class="calibre6">Die</span> and <span class="calibre6">Attack</span> states from any state. That is, your character player can die at any time in the game, whatever state he or she is in at the time. The jump states can be triggered from two states, idle and the running. You can improve these transitions and states based on the level of your animation complexity, but for now, this should do.</p>
<p class="calibre3"/>
<p class="calibre3"/>
<p class="calibre3"/>
<p class="calibre3"/>
<p class="calibre3"/>
<p class="calibre3"/>
<p class="calibre3"/>
<p class="calibre3"/>
<p class="calibre3">Take a look at the following screenshot:</p>
<div class="mce-root1"><img src="../images/00069.jpeg" class="calibre77"/></div>
<p class="calibre3">These states are controlled through Boolean parameters defined in the animator. At this stage, you should be able to use your model to test the scene, as well as your character animations and states.</p>
<p class="calibre3"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Modification to animations</h1>
                
            
            <article>
                
<p class="calibre3">There might be times that you will need to make some changes and/or modifications to the existing modification that will make it work properly with your game and the state machine.</p>
<p class="calibre3">The attack animations prepared for my character model need to be adjusted to make them loop while the character is still in that particular state. For instance, if I use the existing animation and the character state goes into attack mode, the animation will play only once. This is not what I intend to do; I am building the attack input to perform the attack while the attack key is pressed down. Changing the animation loop setting is easy. To do so, select the animation from your <span class="calibre6">Project</span> window and select the <em class="calibre14"><span class="calibre6">Edit...</span></em> button from the <span class="calibre6">Inspector</span> window, as shown in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00070.jpeg" class="calibre78"/></div>
<p class="calibre3">You will now be in the <span class="calibre6">Edit</span> mode of the animation, as displayed in the following screenshot. I have placed the <span class="calibre6">Inspector</span> window next to it, to illustrate the <span class="calibre6">Animation</span> tab, selecting each animation we want to modify, one at a time, and setting the <span class="calibre6">Loop Time</span> property to <span class="calibre6">True</span>.</p>
<p class="calibre3">In this particular screenshot, you will also notice several other important properties for the animation, such as <em class="calibre14"><span class="calibre6">Root Transform Rotation</span></em>, <em class="calibre14"><span class="calibre6">Mirror</span></em>, <em class="calibre14"><span class="calibre6">Curves</span></em>, <em class="calibre14"><span class="calibre6">Events</span></em>, <em class="calibre14"><span class="calibre6">Mask</span></em>, and <em class="calibre14"><span class="calibre6">Motion</span></em>. We will use the <span class="calibre6">Curves</span> property when we set out Inverse Kinematics for some of our animations regarding our character. This basically sets the values of predefined parameters that can be used to set or get them through <em class="calibre14">Mecanim</em>. Take a look at the following screenshot:</p>
<div class="mce-root1"><img src="../images/00071.jpeg" class="calibre79"/></div>
<p class="calibre3">If your animations are attached to your model and your animations and models are older, you will most likely need to make some modifications to them.</p>
<p class="calibre3">For instance, one of the main properties that you might have to set for a particular animation clip would be the <em class="calibre14"><span class="calibre6">Loop Time</span></em> property, as shown in the preceding screenshot. This will make sure that the animation will loop as long as you are in the state which is running the animation. If looping is not enabled, the animation will run once and stop, even if you are still in the state representing the animation.</p>
<p class="calibre3">Make sure the <em class="calibre14"><span class="calibre6">Loop Time</span></em> property is set for the idle, walking, running and attacking animations. At the same time, not all animation clips need to be looped, for instance, the jump and die animations just need to be played once. You will need to do your diligence and check all of these properties.</p>
<p class="calibre3">Other animation will need to be modified to enable baking the transform into the model. For instance, the die and jump animations have the following properties checked: <em class="calibre14"><span class="calibre6">Root Transform Rotation</span></em> and <em class="calibre14"><span class="calibre6">Root Transform Position (Y)</span></em>; make sure that the <em class="calibre14"><span class="calibre6">Bake Into Pose</span></em> property is checked. This is important, to make sure the animation and the skeletal movement of the character are harmonized at the root transform position.</p>
<div class="packt_infobox">Your animation might seem funky if these properties are not set properly. If there is something weird going on, make sure to double-check these properties.</div>
<p class="calibre3">If you have not done so by now, you should attach your <kbd class="calibre13">BarbarianharacterController.cs</kbd> script to your player character.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Inverse Kinematics</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Inverse Kinematics</strong> (<strong class="calibre5">IK</strong>) is important in game programming. It is typically used to make the character's movement more realistic. One of the main uses of IK is the calculation of the player's feet and how they relate to the ground they are standing on.</p>
<p class="calibre3">In short, IK is used to determine the position and rotation of the joints of a character based on a given position in space. For instance, to make sure the foot of a player lands properly on the terrain it is walking on.</p>
<p class="calibre3">Unity has a built-in IK system that can be used to do some basic calculations in this regard. Let's go ahead and implement the foot IK for our character. There are a few things that you will need to set up before we can enable IK for our humanoid character.</p>
<p class="calibre3">The first thing to do is check your layer in the <span class="calibre6">Animator Controller</span> and use the <span class="calibre6">Engine</span> icon to enter the <span class="calibre6">Settings</span> window. Make sure that <em class="calibre14"><span class="calibre6">IK Pass</span></em> is checked, as shown in the following screenshot. You will also need to provide a Mask if you have not done so already. The mask is used to dictate which parts of the skeleton are affected by the IK. Take a look at the following screenshot:</p>
<div class="mce-root1"><img src="../images/00072.jpeg" class="calibre45"/></div>
<div class="mce-root2">Mask for Inverse Kinematics</div>
<p class="calibre3">Once you have set this up, the fun begins. We need to create a C# script that will handle our IK. Create a C# script and call it <kbd class="calibre13">IKHandle.cs</kbd>. Type the following code into the script:</p>
<pre class="calibre18">using UnityEngine; 
 
namespace com.noorcon.rpg2e 
{ 
   public class IKHandle : MonoBehaviour 
   { 
      Animator anim; 
 
      #region USED FOR MANUAL TESTING 
      Transform leftIKTarget; 
      Transform rightIKTarget; 
 
      Transform hintLeft; 
      Transform hintRight; 
 
      float ikWeight = 1f; 
      #endregion 
 
      // to make it dynamic 
      [Header("Dynamic IK Values")] 
      Vector3 LeftFootPosition; 
      Vector3 RightFootPosition; 
 
      Quaternion LeftFootRotation; 
      Quaternion RightFootRotation; 
 
      float LeftFootWeight; 
      float RightFootWeight; 
 
      public Transform LeftFoot; 
      public Transform RightFoot; 
 
      [Header("Adjustment Properties for IK")] 
      public float OffsetY; 
 
      public float LookIkWeight = 1.0f; 
      public float BodyWeight = 0.7f; 
      public float HeadWeight = 0.9f; 
      public float EyesWeight = 1.0f; 
      public float ClampWeight = 1.0f; 
 
      public Transform LookPosition; 
 
      // Use this for initialization 
      void Start() 
      { 
         anim = GetComponent&lt;Animator&gt;(); 
 
         LeftFoot = anim.GetBoneTransform(HumanBodyBones.LeftFoot); 
         RightFoot = anim.GetBoneTransform(HumanBodyBones.RightFoot); 
 
         LeftFootRotation = LeftFoot.rotation; 
         RightFootRotation = RightFoot.rotation; 
 
      } </pre>
<p class="calibre3"/>
<p class="calibre3"/>
<p class="calibre3"><span class="calibre6">This script is a bit involved. In order for the Inverse Kinematic, that is, IK, to work properly, we need to identify a couple of important points in space. One of these points is the position of the target in space that we want our foot to move to, and the second point in space is the hint. These two points in space are used to control the movement and translations of the skeleton for a particular joint to be made, in order to successfully complete the IK for the target position. Take a look at the following code:</span></p>
<pre class="calibre18">      // Update is called once per frame 
      void Update() 
      { 
         // we can set the look position here somewhere 
         Ray ray = new Ray(Camera.main.transform.position, <br class="title-page-name"/>         Camera.main.transform.forward); 
 
         Debug.DrawRay(Camera.main.transform.position, <br class="title-page-name"/>         Camera.main.transform.forward * 15, Color.cyan); 
 
         //lookPosition.position = ray.GetPoint(15); 
 
         RaycastHit leftHit; 
         RaycastHit rightHit; 
 
         Vector3 lpos = LeftFoot.TransformPoint(Vector3.zero); 
         Vector3 rpos = RightFoot.TransformPoint(Vector3.zero); 
 
         if (Physics.Raycast(lpos, -Vector3.up, out leftHit, 1)) 
         { 
            LeftFootPosition = leftHit.point; 
            LeftFootRotation = Quaternion.FromToRotation(transform.up, <br class="title-page-name"/>            leftHit.normal) * transform.rotation; 
         } 
 
         if (Physics.Raycast(rpos, -Vector3.up, out rightHit, 1)) 
         { 
            RightFootPosition = rightHit.point; 
            RightFootRotation = Quaternion.FromToRotation(transform.up,    <br class="title-page-name"/>            rightHit.normal) * transform.rotation; 
         } 
      } 
 
      void OnAnimatorIK() 
      { 
         LeftFootWeight = anim.GetFloat("MyLeftFoot"); 
         RightFootWeight = anim.GetFloat("MyRightFoot"); 
 
         anim.SetIKPositionWeight(AvatarIKGoal.LeftFoot, <br class="title-page-name"/>         LeftFootWeight); 
         anim.SetIKPositionWeight(AvatarIKGoal.RightFoot, <br class="title-page-name"/>         RightFootWeight); 
         anim.SetIKPosition(AvatarIKGoal.LeftFoot, LeftFootPosition + <br class="title-page-name"/>         new Vector3(0f, OffsetY, 0f)); 
         anim.SetIKPosition(AvatarIKGoal.RightFoot, RightFootPosition + <br class="title-page-name"/>         new Vector3(0f, OffsetY, 0f)); 
 
         anim.SetIKRotationWeight(AvatarIKGoal.LeftFoot, <br class="title-page-name"/>         LeftFootWeight); 
         anim.SetIKRotationWeight(AvatarIKGoal.RightFoot, <br class="title-page-name"/>         RightFootWeight); 
         anim.SetIKRotation(AvatarIKGoal.LeftFoot, LeftFootRotation); 
         anim.SetIKRotation(AvatarIKGoal.RightFoot, RightFootRotation); 
 
      } 
   } 
} </pre>
<p class="calibre3">The <kbd class="calibre13">LeftFootPosition</kbd> and <kbd class="calibre13">RightFootPosition</kbd> <span class="calibre6">variables </span>are used to represent the target position for the left and right foot during runtime. <kbd class="calibre13">LeftFootRotation</kbd> and <kbd class="calibre13">RightFootRotation</kbd> are used to store the rotation of the left and right foot.</p>
<p class="calibre3">We also need two variables to actually reference our left and right foot in the model. This is done by the <kbd class="calibre13">LeftFoot</kbd> and <kbd class="calibre13">RightFoot</kbd> variables.</p>
<p class="calibre3">Some of these variables are initialized in the <kbd class="calibre13">Start()</kbd> function. Specifically, we get a reference to the left and right foot from the <span class="calibre6">Animator Controller</span> bone structure defined for humanoids.</p>
<p class="calibre3">In the <kbd class="calibre13">Update()</kbd> function, we use <kbd class="calibre13">Physics.Raycast()</kbd> to perform some raycasting, to determine the position of our left and right foot. This data is then used and stored in the <kbd class="calibre13">LeftFootPosition</kbd> and <kbd class="calibre13">RightFootPosition</kbd> variables, with their equivalent rotation data in the <kbd class="calibre13">LeftFootRotation</kbd> and <kbd class="calibre13">RightFootRotation</kbd> variables. Take a look at the following screenshot:</p>
<div class="mce-root1"><img src="../images/00073.jpeg" class="calibre45"/></div>
<div class="mce-root2">Animation curves</div>
<p class="calibre3">The actual IK animation is applied in the <kbd class="calibre13">OnAnimatorIK()</kbd> function. The <kbd class="calibre13">LeftFootWeight</kbd> and <kbd class="calibre13">RightFootWeight</kbd> variables are used to get the parameter values set for <kbd class="calibre13">MyLeftFoot</kbd> and <kbd class="calibre13">MyRightFoot</kbd> in the <span class="calibre6">Animator Controller</span>, through the animation clip <kbd class="calibre13">Curve</kbd> function.</p>
<div class="packt_infobox">The key here is to properly define the curve of the animation clip that will be used to drive the weight of the IK. The preceding screenshot only shows the curve of the idle state. Both feet are on the ground, therefore the value is set to 1. For your walking and running clips, your curve will be different.</div>
<p class="calibre3">Finally, the <kbd class="calibre13">SetIKPositionWeight()</kbd> and <kbd class="calibre13">SetIKPosition()</kbd> functions are used to properly adjust the position and rotation of the feet relative to the ground! Notice that this is performed for each foot separately.</p>
<p class="calibre3">Attach the <kbd class="calibre13">IKHandle.cs</kbd> script to your character and do a test run. Notice the difference in your character and the way it is interacting with the floor or the terrain you have set up.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting the animation curve</h1>
                
            
            <article>
                
<p class="calibre3">This step is very important for the IK to work. I am going to use the <span class="calibre6">Idle</span> animation to demonstrate what needs to be configured, to make sure the parameters in the animator controller are set properly. Take a look at the following screenshot:</p>
<div class="mce-root1"><img src="../images/00074.jpeg" class="calibre45"/></div>
<div class="mce-root2">Animation curve modification</div>
<p class="calibre3">For the IK to work properly and look nice, you will need to set the curve for each animation that has to do with the motion of the feet. Since we have five sets of animations for walking and running, you will need to perform the same for each animation curve to properly set the weight value that will be passed to the IK script.</p>
<p class="calibre3"/>
<p class="calibre3"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">We covered a lot of content in this chapter. We discussed the different character definitions we will be using for our game, looked at the base character class attributes that will be shared by all of our characters, and created the <kbd class="calibre13">BaseCharacter</kbd> class to be used later in the game. We also discussed the primary states our character will have in the game, and how to implement them using the <span class="calibre6">Animator Controller</span>.</p>
<p class="calibre3">We looked at how to rig our character model to be prepared for the Mecanim system, as well as how to use the Mecanim system to create animation and state diagrams that will determine how the character behaves during game play. Then we implemented our initial character controller script that handles the state of our character. This gave us the opportunity to look at the Blend Trees and transition from one state to the next using parameters. We then looked at how to modify animation clips if there is a need for it.</p>
<p class="calibre3">Finally, we learned about Inverse Kinematics, which will help our character to behave more realistically in the game environment.</p>
<p class="calibre3">Having reached the end of the chapter, you should have a good grasp of all of the different components that work together to make your character look, behave, and move in the game environment.</p>
<p class="calibre3">In the next chapter, we will be introducing non-character behaviors.</p>


            </article>

            
        </section>
    </body></html>