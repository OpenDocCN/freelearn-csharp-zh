- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Interfaces and Inheriting Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about deriving new types from existing ones using **object-oriented
    programming** (**OOP**). You will learn how to use operators as an alternative
    method to implement simple functionality, and you will learn how to use generics
    to make your code safer and more performant. You will learn about delegates and
    events to exchange messages between types. You will implement interfaces for common
    functionality. You will create a derived class to inherit from a base class to
    reuse functionality, override an inherited type member, and use polymorphism.
    Finally, you will learn how to create extension methods and cast between classes
    in an inheritance hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: In an online-only section, you will see the differences between reference and
    value types and how they are stored in memory. You will find links to online materials
    at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a class library and console application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static methods and overloading operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making types safely reusable with generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raising and handling events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with `null` values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting from classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting within inheritance hierarchies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting and extending .NET types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summarizing custom type choices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a class library and console application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by defining a solution with two projects, like the one created
    in *Chapter 5*, *Building Your Own Types with Object-Oriented Programming*. Even
    if you completed all the exercises in that chapter, follow the instructions below
    so that you start this chapter with fresh working projects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Class Library** / `classlib`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `PacktLibrary`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter06`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Framework: .NET 9.0 (Standard-Term Support)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add a new project, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console App** / `console`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `PeopleApp`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter06`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Framework: .NET 9.0 (Standard-Term Support)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Do not use top-level statements: Cleared'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enable native AOT publish: Cleared'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, both projects target .NET 9 and, therefore, use the C# 13 compiler
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, rename the file named `Class1.cs` to `Person.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In both projects, add `<ItemGroup>` to globally and statically import the `System.Console`
    class, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Person.cs`, delete any existing statements and define a `Person` class,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `PeopleApp` project, add a project reference to `PacktLibrary`, as shown
    in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, delete the existing statements, write statements to create
    an instance of `Person`, and then write information about it to the console, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you use Visual Studio, configure the startup project for the solution as
    the current selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `PeopleApp` project and note the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Static methods and overloading operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is specifically about methods that apply to two instances of the
    same type. It is not about the more general case of methods that apply to zero,
    one, or more than two instances. Remember that static methods do not require an
    object instance. They are called directly using the class name.
  prefs: []
  type: TYPE_NORMAL
- en: I wanted to think of some methods that would apply to two `Person` instances
    that could also become binary operators, like `+` and `*`. What would adding two
    people together represent? What would multiplying two people represent? The obvious
    answers are getting married and having babies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will design our methods to enable us to model the story of Lamech and his
    two wives and their children, as described at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.kingjamesbibleonline.org/Genesis-4-19/](https://www.kingjamesbibleonline.org/Genesis-4-19/)'
  prefs: []
  type: TYPE_NORMAL
- en: We might want two instances of `Person` to be able to marry and procreate. We
    can implement this by writing methods and overriding operators. Instance methods
    are actions that an object does to itself; static methods are actions the type
    does.
  prefs: []
  type: TYPE_NORMAL
- en: Which you choose depends on what makes the most sense for the action.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Having both static and instance methods to perform similar
    actions often makes sense. For example, `string` has both a `Compare` static method
    and a `CompareTo` instance method. This puts the choice of how to use the functionality
    in the hands of the programmers using your type, giving them more flexibility.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing functionality using methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by implementing some functionality by using both static and instance
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add properties with private backing storage fields to indicate
    if that person is married and to whom, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Person.cs`, add one instance method and one static method that will allow
    two `Person` objects to marry, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `static` method, the `Person` objects are passed as parameters named
    `p1` and `p2`, and guard clauses are used to check for `null` values. If either
    is already married to the other, an exception is thrown; otherwise, they are each
    added to each other’s list of spouses. You can model this differently if you want
    to allow two people to have multiple marriage ceremonies. In that case, you might
    choose to not throw an exception and instead do nothing. Their state of marriage
    would remain the same. Additional calls to `Marry` would not change if they are
    married or not. In this scenario, I want you to see that the code recognizes that
    they are already married by throwing an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the instance method, a call is made to the `static` method, passing the current
    person (`this`) and the `partner` they want to marry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning!** Although instance methods can call static methods, the opposite
    is not true. A static method cannot call an instance method because there isn’t
    an object instance to call it on.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add an instance method to the `Person` class that will output
    the spouses of a person if they are married, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Person.cs`, add one instance method and one static method to the `Person`
    class that will allow two `Person` objects to procreate if they are married to
    each other, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `static` method named `Procreate`, the `Person` objects that will procreate
    are passed as parameters named `p1` and `p2`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new `Person` class named `baby` is created with a name composed of a combination
    of the two people who have procreated. This could be changed later by setting
    the returned `baby` variable’s `Name` property. Although we could add a third
    parameter to the `Procreate` method for the baby name, we will define a binary
    operator later, and they cannot have third parameters. So, for consistency, we
    will just return the baby reference and let the calling code set the name of it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `baby` object is added to the `Children` collection of both parents and
    then returned. Classes are reference types, meaning a reference to the `baby`
    object stored in memory is added, not a clone of the `baby` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the instance method named `ProcreateWith`, the `Person` object to procreate
    with is passed as a parameter named `partner`, and that, along with `this`, which
    represents the current object, is passed to the static `Procreate` method to reuse
    the method implementation. `this` is a keyword that references the current instance
    of the class. It is a convention to use different method names for related static
    and instance methods, but not to the extent that you would fail to match standard
    English meaning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, that could mean naming both methods the same, as in the example of `Marry(x,
    y)` for the static method name and `x.Marry(y)` for the instance method name.
    More commonly, it would mean using a different method name, for example, `Procreate(x,
    y)` for the static method name and `x.ProcreateWith(y)` for the instance method
    name, or `Compare(x, y)` for the static method name and `x.CompareTo(y)` for the
    instance method name.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: A method that creates a new object, or modifies an existing
    object, should return a reference to that object so that the caller can access
    the results.'
  prefs: []
  type: TYPE_NORMAL
- en: '5\. In `Program.cs`, create three people and have them marry and then procreate
    with each other, noting that to add a double-quote character into a `string`,
    you must prefix it with a backslash character like this, `\"`, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: I used a `for` instead of a `foreach` statement so that I could use the `i`
    variable with the indexer to access each child.
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you have just seen, for functionality that applies to two instances of an
    object type, it is easy to provide both static and instance methods to implement
    the same functionality. Neither static nor instance methods are best in all scenarios,
    and you cannot predict how your type might be used. It is best to provide both
    to allow a developer to use your types in the way that best fits their needs.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see how we can add a third way to provide the same functionality for
    two instances of a type.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing functionality using operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `System.String` class has a `static` method named `Concat` that concatenates
    two `string` values and returns the result, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling a method like `Concat` works, but it might be more natural for a programmer
    to use the `+` symbol operator to “add” two `string` values together, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A well-known biblical phrase is *Go forth and multiply*, meaning to procreate.
    Let’s write code so that the `*` (multiply) symbol will allow two `Person` objects
    to procreate. And we will use the `+` operator to marry two people.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do this by defining a `static` operator for the `*` symbol. The syntax is
    rather like a method, because in effect, an operator *is* a method, but it uses
    a symbol instead of a method name, which makes the syntax more concise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, create a `static` operator for the `+` symbol, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The return type for an operator does not need to match the types passed as parameters
    to the operator, but the return type cannot be `void`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, create a `static` operator for the `*` symbol, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Unlike methods, operators do not appear in IntelliSense
    lists for a type or a type instance when you enter a dot (`.`). For every operator
    that you define, make a method as well, because it may not be obvious to a programmer
    that the operator is available. The implementation of the operator can then call
    the method, reusing the code you have written. A second reason to provide a method
    is that operators are not supported by every language compiler; for example, although
    arithmetic operators like `*` are supported by Visual Basic and F#, there is no
    requirement that other languages support all operators supported by C#. You have
    to read the type definition or the documentation to discover whether operators
    are implemented.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, comment out the statement that calls the static `Marry` method
    to marry Zillah and Lamech, and replace it with an `if` statement that uses the
    `+` operator to marry them, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, after calling the `Procreate` method and before the statements
    that write the children to the console, use the `*` operator for Lamech to have
    two more babies with his wives, Adah and Zillah, as highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**More Information**: To learn more about operator overloading, you can read
    the documentation at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading)'
  prefs: []
  type: TYPE_NORMAL
- en: Making types safely reusable with generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2005, with C# 2 and .NET Framework 2, Microsoft introduced a feature named
    **generics**, which enables your types to be more safely reusable and efficient.
    It does this by allowing a programmer to pass types as parameters, like how you
    can pass objects as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: This topic is only about types that need to provide flexibility for the types
    they work with. For example, collection types need to be able to store multiple
    instances of any type. That flexibility can be provided either by using the `System.Object`
    type or generics. For other scenarios that do not need type flexibility, the use
    of non-generic types is good practice.
  prefs: []
  type: TYPE_NORMAL
- en: Working with non-generic types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let’s look at an example of working with a non-generic type so that you
    can understand the problems that generics are designed to solve, such as weakly
    typed parameters and values, and performance problems caused by using `System.Object`.
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Collections.Hashtable` can be used to store multiple key-value pairs,
    each with a unique key that can later be used to quickly look up its value. Both
    the key and value can be any object because they are declared as `System.Object`.
    Although this provides flexibility, it is slow, and bugs are easier to introduce
    because no type checks are made when adding items.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write some code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, create an instance of the non-generic collection, `System.Collections.Hashtable`,
    and then add four items to it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that three items have a unique integer key to look them up. The last item
    has a `Person` object as its key to look it up. This is valid in a non-generic
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to define a `key` with the value of `2` and use it to look up
    its value in the *hash* table, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to use the `harry` object to look up its value, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and note that it works, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although the code works, there is potential for mistakes because literally any
    type can be used for the key or value. If another developer used your variable
    named `lookupObject` and expected all the items to be a certain type, they might
    cast them to that type and get exceptions because some values might be a different
    type. A lookup object with lots of items would also give poor performance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Avoid types in the `System.Collections` namespace. Use types
    in the `System.Collections.Generics` and related namespaces instead. If you need
    to use a library that uses non-generic types, then of course you will have to
    use non-generic types. This is an example of what is commonly referred to as technical
    debt.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with generic types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`System.Collections.Generic.Dictionary<TKey, TValue>` can be used to store
    multiple values, each with a unique key that can later be used to quickly look
    up its value. Both the key and value can be any object, but you must tell the
    compiler what the types of the key and value will be when you first instantiate
    the collection. You do this by specifying types for the **generic parameters**
    in angle brackets `<>`, `TKey`, and `TValue`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: When a generic type has one definable type, it should be
    named `T`, for example, `List<T>`, where `T` is the type stored in the list. When
    a generic type has multiple definable types, it should use `T` as a name prefix
    and have a sensible name, for example, `Dictionary<TKey, TValue>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Generics provides flexibility, is faster, and makes bugs easier to avoid because
    type checks are made when adding items at compile time. We will not need to explicitly
    specify the `System.Collections.Generic` namespace that contains `Dictionary<TKey,
    TValue>` because it is implicitly and globally imported by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write some code to solve the problem by using generics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, create an instance of the generic lookup collection `Dictionary<TKey,
    TValue>` and then add four items to it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the compile error when using `harry` as a key, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace `harry` with `4`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements to set the `key` to `3`, and use it to look up its value in
    the dictionary, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and note that it works, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have now seen the difference between non-generic and generic types that
    need the flexibility to store any type. You know to always use generic collection
    types if possible. Unless you are unlucky enough to be forced to use a legacy
    non-generic library, you never need to write code that uses non-generic types
    that can store any type again.
  prefs: []
  type: TYPE_NORMAL
- en: Just because it is good practice to use generic collection types in preference
    to non-generic collection types does not mean the more general case is also true.
    Non-generic non-collection types and other types that do not need the flexibility
    to work with any type are used all the time. Collection types just happen to be
    the most common type that benefits from generics.
  prefs: []
  type: TYPE_NORMAL
- en: Raising and handling events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Methods are often described as *actions that an object can perform, either on
    itself or on related objects*. For example, `List<T>` can add an item to itself
    or clear itself, and `File` can create or delete a file in the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Events are often described as *actions that happen to an object*. For example,
    in a user interface, `Button` has a `Click` event, a click being something that
    happens to a button. Also, `FileSystemWatcher` listens to the filesystem for change
    notifications and raises events like `Created` and `Deleted`, which are triggered
    when a directory or file changes.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to think of events is that they provide a way of exchanging messages
    between objects.
  prefs: []
  type: TYPE_NORMAL
- en: Events are built on **delegates**, so let’s start by having a look at what delegates
    are and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Calling methods using delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have already seen the most common way to call or execute a method: using
    the `.` operator to access the method using its name. For example, `Console.WriteLine`
    tells the `Console` type to call its `WriteLine` method.'
  prefs: []
  type: TYPE_NORMAL
- en: The other way to call or execute a method is to use a delegate. If you have
    used languages that support **function pointers**, then think of a delegate as
    being a **type-safe method pointer**.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, a delegate contains the memory address of a method that must
    match the same signature as the delegate, enabling it to be called safely with
    the correct parameter types.
  prefs: []
  type: TYPE_NORMAL
- en: The code in this section is illustrative and not meant to be typed into a project.
    You will explore code like this in the next section, so for now, just read the
    code and try to understand its meaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine there is a method in the `Person` class that must have
    a `string` type passed as its only parameter, and it returns an `int` type, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'I can call this method on an instance of `Person` named `p1` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, I can define a delegate with a matching signature to call the
    method indirectly. Note that the names of the parameters do not have to match.
    Only the types of parameters and return values must match, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: A `delegate` is a reference type like a `class`, so if you
    define one in `Program.cs`, then it must be at the bottom of the file. It would
    be best to define it in its own class file, for example, `Program.Delegates.cs`.
    If you defined a delegate in the middle of `Program.cs`, then you would see the
    following compiler error: `CS8803: Top-level statements must precede namespace
    and type declarations`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I can create an instance of the delegate, point it at the method, and
    finally, call the delegate (which calls the method), as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Examples of delegate use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are probably thinking, *“What’s the point of that?”*
  prefs: []
  type: TYPE_NORMAL
- en: It provides flexibility. For example, we could use delegates to create a queue
    of methods that need to be called in order. Queuing actions that need to be performed
    is common in services to provide improved scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is to allow multiple actions to execute in parallel. Delegates
    have built-in support for asynchronous operations that run on a different thread,
    which can provide improved responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: The most important example is that delegates allow us to implement events to
    send messages between different objects that do not need to know about each other.
    Events are an example of loose coupling between components because they do not
    need to know about each other; they just need to know the event signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Status: It’s complicated'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Delegates and events are two of the most confusing features of C# and can take
    a few attempts to understand, so don’t worry if you feel lost as we walk through
    how they work! Move on to other topics and come back again another day when your
    brain has had the opportunity to process the concepts while you sleep.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and handling delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Microsoft has two predefined delegates for use as events. They both have two
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`object? sender`: This parameter is a reference to the object raising the event
    or sending the message. The `?` indicates that this reference could be `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventArgs e` or `TEventArgs e`: This parameter contains additional relevant
    information about the event. For example, in a GUI app, you might define `MouseMoveEventArgs`,
    which has properties for the `X` and `Y` coordinates for the mouse pointer. A
    bank account might have a `WithdrawEventArgs` with a property for the `Amount`
    to withdraw.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Their signatures are simple, yet flexible, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: When you want to define an event in your own type, you should
    use one of these two predefined delegates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some types provide “empty” values for when you need an instance, but it doesn’t
    need to have any particular value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`string.Empty` is an empty string value `""`. It is better to use `string.Empty`
    than `""` because every time you use `""` the compiler must instantiate a new
    empty string instance. You can think of `string.Empty` as a global single instance
    of an empty string. Sharing it is more efficient than creating your own new instances
    every time you need to reference an empty string value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventArgs.Empty` is an empty `EventArgs` value. Use it when you must conform
    to the built-in event delegates that require an `EventArgs` instance to be passed
    as a parameter, but it doesn’t need any particular value because it won’t be read
    or used in the method anyway.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might have a delegate defined, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In that case, there are multiple ways to call the delegate, as shown in the
    following code examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use its variable name, `Shout`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use its `Invoke` method to call it synchronously:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use its `BeginInvoke` method to call it asynchronously, without a callback
    function or any state:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `BeginInvoke` method is beyond the scope of this book, but I have included
    it so that you know it exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delegates and their method handlers have a potentially many-to-many relationship.
    One delegate can have one method handler. But one delegate can also have many
    method handlers (you will do this when you hook up `Shout` to both `Harry_Shout`
    and `Harry_Shout_2`). And many delegates can reference one method handler, or
    any combination of these. Let’s explore delegates and events:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to the `Person` class and note the following points, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It defines an `EventHandler` delegate field named `Shout`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines an `int` field to store `AngerLevel`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines a method named `Poke`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each time a person is poked, their `AngerLevel` increments. Once their `AngerLevel`
    reaches three, they raise the `Shout` event, but only if there is at least one
    event delegate pointing at a method defined somewhere else in the code; that is,
    it is not `null`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Checking whether an object is not `null` before calling one of its methods
    is very common. C# 6 and later allow `null` checks to be simplified inline using
    a `?` symbol before the `.` operator, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Shout?.Invoke(this, EventArgs.Empty);`'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PeopleApp` project, add a new class file named `Program.EventHandlers.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.EventHandlers.cs`, delete any existing statements, and then add
    a method with a matching signature that gets a reference to the `Person` object
    from the `sender` parameter and outputs some information about them, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Microsoft’s convention for method names that handle events
    is `ObjectName_EventName`. In this project, `sender` will always be a `Person`
    instance, so the `null` checks are not necessary, and the event handler could
    be much simpler with just the `WriteLine` statement. However, it is important
    to know that these types of `null` checks make your code more robust in cases
    of event misuse.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can have as many methods as you like to be event handlers, named whatever
    you like, as long as the method signature matches the delegate signature. This
    means you could have 50 `Person` instances, each with their own method, or have
    one method that they all share. The methods can be declared at any level that
    makes sense for the scenario and matches the access levels set (like `protected`,
    `private`, `public`, and so on). One of the key benefits of delegates and events
    is loose binding between components so maximum flexibility is desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add a statement to assign the method to the delegate field,
    and then add statements to call the `Poke` method four times, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result. Note that Harry says nothing
    the first two times he is poked, and only gets angry enough to shout once he’s
    been poked at least three times, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In Step 3, note that the `sender` is checked to make sure it is a `Person`
    instance, and if it is, then it is assigned to a local variable named `p`, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The first statement does two things at once, which needs more explanation. The
    parameter named `sender` is declared to be of type `object`. This means we cannot
    just say `sender.Name` or `sender.AngerLevel`. We need to cast `sender` to a local
    variable that is explicitly defined as `Person`. We also need to check that `sender`
    actually is a `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do both things at once in a single expression: `sender is not Person
    p`. This expression will return `true` if `sender` is not a `Person`, and hence
    the statement executes `return` so the method immediately returns. Or the expression
    returns `false` if `sender` is a `Person`, and sender will be stored in the local
    variable named `p`, which is of type `Person`. After that, we can use expressions
    like `p.Name` and `p.AngerLevel`.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining and handling events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ve now seen how delegates implement the most important functionality of
    events: the ability to define a signature for a method that can be implemented
    by a completely different piece of code, calling that method and any others that
    are hooked up to the delegate field.'
  prefs: []
  type: TYPE_NORMAL
- en: But what about events? There is less to them than you might think.
  prefs: []
  type: TYPE_NORMAL
- en: When assigning a method to a delegate field, you should not use the simple assignment
    operator as we did in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates are multicast, meaning that you can assign multiple delegates to a
    single delegate field. Instead of the `=` assignment, we could have used the `+=`
    operator so that we could add more methods to the same delegate field. When the
    delegate is called, all the assigned methods are called, although you have no
    control over the order in which they are called. Do not use events to implement
    a queuing system to buy concert tickets; otherwise, the wrath of millions of Swifties
    will fall upon you.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `Shout` delegate field already referenced one or more methods, by assigning
    another method, that method would replace all the others. With delegates that
    are used for events, we usually want to make sure that a programmer only ever
    uses either the `+=` operator or the `-=` operator to assign and remove methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To enforce this, in `Person.cs`, add the `event` keyword to the delegate field
    declaration, as highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the `PeopleApp` project and note the compiler error message, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is (almost) all that the `event` keyword does! If you will never have more
    than one method assigned to a delegate field, then technically you do not need
    events, but it is still good practice to indicate your meaning and that you expect
    a delegate field to be used as an event.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, modify the comment and the method assignment to use `+=` instead
    of just `=`, as highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the `PeopleApp` project and note that it has the same behavior as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.EventHandlers.cs`, create a second event handler for Harry’s `Shout`
    event, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, after the statement that assigns the `Harry_Shout` method
    to the `Shout` event, add a statement to attach the new event handler to the `Shout`
    event too, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project, view the result. Note that both event handlers
    execute whenever an event is raised, which only happens once the anger level is
    three or more, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In Windows desktop development, imagine that you have three buttons: `AddButton`,
    `SaveButton`, and `DeleteButton`. Each button has very different functionality.
    Good practice would be to create three methods to handle their `Click` events,
    named `AddButton_Click`, `SaveButton_Click`, and `DeleteButton_Click`. Each would
    have a different implementation code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But now, imagine you have 26 buttons: `AButton`, `BButton`, `CButton`, and
    so on, up to `ZButton`. Each button has the same functionality: to filter a list
    of people by the first letter of their name. Good practice would be to create
    one method to handle their `Click` events, perhaps named `AtoZButtons_Click`.
    This method would have an implementation code that would use the `sender` parameter
    to know which button was clicked, and therefore how to apply the filtering, but
    otherwise be the same for all the buttons.'
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for events. Now, let’s look at interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces are a way to implement standard functionality and connect different
    types to make new things. Think of them like the studs on top of LEGO™ bricks,
    which allow them to “stick” together, or electrical standards for plugs and sockets.
  prefs: []
  type: TYPE_NORMAL
- en: If a type implements an interface, then it makes a promise to the rest of .NET
    that it supports specific functionality. Therefore, they are sometimes described
    as contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Common interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Table 6.1* shows some common interfaces that your types might implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interface** | **Method(s)** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `IComparable` | `CompareTo(other)` | This defines a comparison method that
    a type implements to order or sort its instances. |'
  prefs: []
  type: TYPE_TB
- en: '| `IComparer` | `Compare(first, second)` | This defines a comparison method
    that a secondary type implements to order or sort instances of a primary type.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `IDisposable` | `Dispose()` | This defines a disposal method to release unmanaged
    resources more efficiently than waiting for a finalizer. See the *Releasing unmanaged
    resources* section later in this chapter for more details. |'
  prefs: []
  type: TYPE_TB
- en: '| `IFormattable` | `ToString(format, culture)` | This defines a culture-aware
    method to format the value of an object into a string representation. |'
  prefs: []
  type: TYPE_TB
- en: '| `IFormatter` | `Serialize(stream, object)``Deserialize(stream)` | This defines
    methods to convert an object to and from a stream of bytes for storage or transfer.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `IFormatProvider` | `GetFormat(type)` | This defines a method to format inputs
    based on a language and region. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.1: Some common interfaces that your types might implement'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing objects when sorting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common interfaces that you will want to implement in your types
    that represent data is `IComparable`. If a type implements one of the `IComparable`
    interfaces, then arrays and collections containing instances of that type can
    be sorted.
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of an abstraction for the concept of sorting. To sort any
    type, the minimum functionality would be the ability to compare two items and
    decide which goes before the other. If a type implements that minimum functionality,
    then a sorting algorithm can use it to sort instances of that type in any way
    the sorting algorithm wants.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IComparable` interface has one method named `CompareTo`. This has two
    variations, one that works with a nullable `object` type and one that works with
    a nullable generic type `T`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `in` keyword specifies that the type parameter `T` is contravariant, which
    means that you can use a less derived type than that specified. For example, if
    `Employee` derives from `Person`, then both can be compared to each other.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `string` type implements `IComparable` by returning `-1` if
    the `string` should be sorted before the `string` is compared to, `1` if it should
    be sorted after, and `0` if they are equal. The `int` type implements `IComparable`
    by returning `-1` if the `int` is less than the `int` being compared to, `1` if
    it is greater, and `0` if they are equal.
  prefs: []
  type: TYPE_NORMAL
- en: '`CompareTo` return values can be summarized as shown in *Table 6.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **this before other** | **this is equal to other** | **this after other**
    |'
  prefs: []
  type: TYPE_TB
- en: '| -1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.2: Summary of the CompareTo return values'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we implement the `IComparable` interface and its `CompareTo` method
    for the `Person` class, let’s see what happens when we try to sort an array of
    `Person` instances without implementing this interface, including some that are
    `null` or have a `null` value for their `Name` property:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PeopleApp` project, add a new class file named `Program.Helpers.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Helpers.cs`, delete any existing statements. Then define a method
    for the `partial` `Program` class that will output all the names of a collection
    of people passed as a parameter, with a title beforehand, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements that create an array of `Person` instances,
    call the `OutputPeopleNames` method to write the items to the console, and then
    attempt to sort the array and write the items to the console again, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and an exception will be thrown. As the message
    explains, to fix the problem, our type must implement `IComparable`, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Person.cs`, after inheriting from `object`, add a comma and enter `IComparable<Person?>`,
    as highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your code editor will draw a red squiggle under the new code to warn you that
    you have not yet implemented the method you promised to. Your code editor can
    write the skeleton implementation for you.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the light bulb and then click **Implement interface**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scroll down to the bottom of the `Person` class to find the method that was
    written for you, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Delete the statement that throws the `NotImplementedException` error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements to handle variations of input values, including `null`. Call
    the `CompareTo` method of the `Name` field, which uses the `string` type’s implementation
    of `CompareTo`. Return the result, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have chosen to compare two `Person` instances by comparing their `Name` fields.
    `Person` instances will, therefore, be sorted alphabetically by their name. `null`
    values will be sorted to the bottom of the collection. Storing the calculated
    `position` before returning it is useful when debugging. I’ve also used more round
    brackets than the compiler needs to make the code easier for me to read. If you
    prefer fewer brackets, then feel free to remove them.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the final `else` statement will never execute because the logic
    of the `if` and `else` `if` clauses means it will only execute when `this` (the
    current object instance) is `null`. In that scenario, the method could not execute
    anyway since the object wouldn’t exist! I wrote the `if` statement to exhaustively
    cover all combinations of `null` and not `null` for `other` and `this`, but the
    last of those combinations could, in practice, never happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `PeopleApp` project. Note that this time it works as it should, sorted
    alphabetically by name, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: If you want to sort an array or collection of instances
    of your type, then implement the `IComparable` interface.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Comparing objects using a separate class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you won’t have access to the source code for a type, and it might
    not implement the `IComparable` interface. Luckily, there is another way to sort
    instances of a type. You can create a separate type that implements a slightly
    different interface, named `IComparer`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PacktLibrary` project, add a new class file named `PersonComparer.cs`,
    containing a class implementing the `IComparer` interface that will compare two
    people, that is, two `Person` instances. Implement it by comparing the length
    of their `Name` fields, or if the names are the same length, then compare the
    names alphabetically, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to sort the array using an alternative implementation,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project, and view the result of sorting the people by the
    length of their names and then alphabetically, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This time, when we sort the `people` array, we explicitly ask the sorting algorithm
    to use the `PersonComparer` type instead so that the people are sorted with the
    shortest names first, like `Adam`, and the longest names last, like `Richard`.
    When the lengths of two or more names are equal, they are sorted alphabetically,
    like `Jenny` and `Simon`.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit and explicit interface implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interfaces can be implemented implicitly and explicitly. Implicit implementations
    are simpler and more common. Explicit implementations are only necessary if a
    type must have multiple methods with the same name and signature. Personally,
    the only time I can remember ever having to explicitly implement an interface
    is when writing the code example for this book.
  prefs: []
  type: TYPE_NORMAL
- en: For example, both `IGamePlayer` and `IKeyHolder` might have a method called
    `Lose` with the same parameters because both a game and a key can be lost. The
    members of an interface are always and automatically `public` because they have
    to be accessible for another type to implement them!
  prefs: []
  type: TYPE_NORMAL
- en: 'In a type that must implement both interfaces, only one implementation of `Lose`
    can be the implicit method. If both interfaces can share the same implementation,
    there is no problem, but if not, then the other `Lose` method will have to be
    implemented differently and called explicitly, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Although the implementation of `IGamePlayer.Lose` in `Human` is `private`, the
    `IGamePlayer.Lose` member itself has an access modifier of `public`, so if we
    cast the `Human` instance into the interface type, then that `Lose` implementation
    is accessible.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** Method access modifiers in an implementation type must match the
    method definition in the interface. For example, the `Lose` method in the interface
    is `public`, so the method implementation in the class must also be `public`.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining interfaces with default implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A language feature introduced in C# 8 is the **default implementation** for
    an interface. This allows an interface to contain implementation. This breaks
    the clean separation between interfaces that define a contract and classes and
    other types that implement them. It is considered by some .NET developers to be
    a perversion of the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PacktLibrary` project, add a new file named `IPlayable.cs`, and modify
    the statements to define a public `IPlayable` interface with two methods to `Play`
    and `Pause`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `PacktLibrary` project, add a new class file named `DvdPlayer.cs`, and
    modify the statements in the file to implement the `IPlayable` interface, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is useful, but what if we decide to add a third method named `Stop`? Before
    C# 8, this would be impossible once at least one type is implemented in the original
    interface. One of the main traits of an interface is that it is a fixed contract.
  prefs: []
  type: TYPE_NORMAL
- en: C# 8 allows you to add new members to an interface after release if those new
    members have a default implementation. C# purists do not like the idea, but for
    practical reasons, such as avoiding breaking changes or having to define a whole
    new interface, it is useful, and other languages such as Java and Swift enable
    similar techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Support for default interface implementations requires some fundamental changes
    to the underlying platform, so they are only supported with C# if the target framework
    is .NET 5 or later, .NET Core 3 or later, or .NET Standard 2.1\. They are, therefore,
    not supported by .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a default implementation to the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `IPlayable` interface to add a `Stop` method with a default implementation,
    as highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the `PeopleApp` project, and note that the projects compile successfully
    despite the `DvdPlayer` class not implementing `Stop`. In the future, we could
    override the default implementation of `Stop` by implementing it in the `DvdPlayer`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although controversial, default implementations in interfaces might be useful
    in scenarios where the most common implementation is known at the time of defining
    the interface. Therefore, it is best if the interface defines that implementation
    once, and then most types that implement that interface can inherit it without
    needing to implement their own. However, if the interface definer does not know
    how the member should or even could be implemented, then it is a waste of effort
    to add a default implementation because it will always be replaced.
  prefs: []
  type: TYPE_NORMAL
- en: Think about the `IComparable` interface that you saw earlier in this chapter.
    It defines a `CompareTo` method. What might a default implementation of that method
    be? Personally, I think it’s obvious that there is no default implementation that
    would make any practical sense. The least-worst implementation that I can think
    of would be to compare the `string` values returned from calling `ToString` on
    the two objects. However, every type really should implement its own `CompareTo`
    method. You are likely to find the same with 99.9% of the interfaces you use.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at how to work with null values.
  prefs: []
  type: TYPE_NORMAL
- en: Working with null values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if a variable does not yet have a value? How can we indicate that? C# has
    the concept of a `null` value, which can be used to indicate that a variable has
    not been set.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are unsure of the difference between reference types and value types
    in .NET, then I recommend that you read the following online-only section before
    you continue with this section: [https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Making a value type nullable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, **value types** like `int` and `DateTime` must always have a *value*,
    hence their name. Sometimes, for example, when reading values stored in a database
    that allows empty, missing, or `null` values, it is convenient to allow a value
    type to be `null`. We call this a **nullable value type**.
  prefs: []
  type: TYPE_NORMAL
- en: You can enable this by adding a question mark as a suffix to the type when declaring
    a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example. We will create a new project because some of the null
    handling options are set at the project level:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App**/`console` project
    named `NullHandling` to the `Chapter06` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `NullHandling.csproj`, add an `<ItemGroup>` to globally and statically import
    the `System.Console` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements, and then add statements to
    declare and assign values, including `null`, two `int` variables, one suffixed
    with `?` and one not, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the project and note the compile error, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Comment out the statement that gives the compile error, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the project and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The second line is blank because it outputs the `null` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to use alternative syntax, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on `Nullable<int>` and press *F12*, or right-click and choose **Go To
    Definition**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that the generic value type, `Nullable<T>`, must have a type `T`, which
    is a `struct`, or a value type. It has useful members like `HasValue`, `Value`,
    and `GetValueOrDefault`, as shown in *Figure 6.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Revealing Nullable<T> members'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: When you append a `?` after a `struct` type, you change
    it to a different type. For example, `DateTime?` becomes `Nullable<DateTime>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding null-related initialisms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we see some code, let’s review some commonly used initialisms in *Table
    6.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Initialism** | **Meaning** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| NRT | Nullable Reference Type | This is a compiler feature introduced with
    C# 8 and enabled by default in new projects with C# 10, which performs static
    analysis of your code at design time and shows warnings of potential misuse of
    `null` values for reference types. |'
  prefs: []
  type: TYPE_TB
- en: '| NRE | `NullReferenceException` | This is an exception thrown at runtime when
    **dereferencing** a `null` value, also known as accessing a variable or member
    on an object that is `null`. |'
  prefs: []
  type: TYPE_TB
- en: '| ANE | `ArgumentNullException` | This is an exception thrown at runtime by
    a method, property, or indexer invocation when an argument or value is `null`,
    and when the business logic determines that it is not valid. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.3: Commonly used initialisms'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding nullable reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of the `null` value is so common, in so many languages, that many experienced
    programmers never question the need for its existence. However, there are many
    scenarios where we could write better, simpler code if a variable is not allowed
    to have a `null` value.
  prefs: []
  type: TYPE_NORMAL
- en: The most significant change to the C# 8 language compiler was the introduction
    of checks and warnings for nullable and non-nullable reference types. *“But wait!”*,
    you are probably thinking. *“Reference types are already nullable!”*
  prefs: []
  type: TYPE_NORMAL
- en: And you would be right, but in C# 8 and later, reference types can be configured
    to warn you about `null` values by setting a file- or project-level option, enabling
    this useful new feature. Since this is a big change for C#, Microsoft decided
    to make the feature an opt-in.
  prefs: []
  type: TYPE_NORMAL
- en: It will take several years for this new C# language compiler feature to make
    an impact, since thousands of existing library packages and apps will expect the
    old behavior. Even Microsoft did not have time to fully implement this new feature
    in all the main .NET packages until .NET 6\. Important libraries like `Microsoft.Extensions`
    for logging, dependency injections, and configuration were not annotated until
    .NET 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the transition, you can choose between several approaches for your own
    projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Default**: For projects created using .NET 5 or earlier, no changes are needed.
    Non-nullable reference types are not checked. For projects created using .NET
    6 or later, nullability checks are enabled by default, but this can be disabled
    by either deleting the `<Nullable>` entry in the project file or setting it to
    `disable`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Opt-in project and opt-out files**: Enable the feature at the project level,
    and for any files that need to remain compatible with old behavior, opt out. This
    was the approach Microsoft used internally while it updated its own packages to
    use this new feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Opt-in files**: Only enable the NRT feature for individual files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning!** This NRT feature does not *prevent* `null` values – it just *warns*
    you about them, and the warnings can be disabled, so you still need to be careful!
    For example, using the `?` character to declare a variable as nullable does not
    allow `null` values, it just disables the warning, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Controlling the nullability warning check feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable the nullability warning check feature at the project level, have
    the `<Nullable>` element set to `enable` in your project file, as highlighted
    in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'To disable the nullability warning check feature at the project level, have
    the `<Nullable>` element set to `disable` in your project file, as highlighted
    in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: You could also remove the `<Nullable>` element completely because the default,
    if not explicitly set, is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable the feature at the file level, add the following at the top of a
    code file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable the feature at the file level, add the following at the top of a
    code file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Disabling null and other compiler warnings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You could decide to enable the nullability feature at the project or file level
    but then disable some of the 50+ warnings related to it. Some common nullability
    warnings are shown in *Table 6.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `CS8600` | Converting a null literal or a possible null value to a non-nullable
    type |'
  prefs: []
  type: TYPE_TB
- en: '| `CS8601` | A possible null reference assignment |'
  prefs: []
  type: TYPE_TB
- en: '| `CS8602` | A dereference of a possibly null reference |'
  prefs: []
  type: TYPE_TB
- en: '| `CS8603` | A possible null reference return |'
  prefs: []
  type: TYPE_TB
- en: '| `CS8604` | A possible null reference argument for a parameter |'
  prefs: []
  type: TYPE_TB
- en: '| `CS8618` | A non-nullable field `<field_name>` must contain a non-null value
    when exiting a constructor. Consider declaring the field as nullable |'
  prefs: []
  type: TYPE_TB
- en: '| `CS8625` | Cannot convert a null literal to a non-nullable reference type
    |'
  prefs: []
  type: TYPE_TB
- en: '| `CS8655` | The switch expression does not handle some null inputs (it is
    not exhaustive) |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.4: Common nullability warnings'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can disable compiler warnings for a whole project. To do so, add a `NoWarn`
    element with a semicolon-separated list of compiler warning codes, as shown in
    the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To disable compiler warnings at the statement level, you can disable and then
    restore a specified compiler warning to temporarily suppress it for a block of
    statements, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: These techniques can be used for any compiler warnings, not just those related
    to nullability.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring non-nullable variables and parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you enable NRTs and you want a reference type to be assigned the `null` value,
    then you will have to use the same syntax to make a value type nullable, that
    is, adding a `?` symbol after the type declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do NRTs work? Let’s look at an example. When storing information about
    an address, you might want to force a value for the street, city, and region,
    but the building can be left blank, that is, `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `NullHandling` project, add a class file named `Address.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Address.cs`, delete any existing statements and then add statements to
    declare an `Address` class with four fields, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After a few seconds, note the warnings about non-nullable fields, like `Street`
    not being initialized, as shown in *Figure 6.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Warning messages about non-nullable fields in the Error List window'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign the empty `string` value to the `Street` field, and define constructors
    to set the other fields that are non-nullable, as highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, import the namespace to use `Address`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to instantiate an `Address` and set its properties,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the `Warning` `CS8625` on setting the `Street` but not the `Building`,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append an exclamation mark to `null` when setting `Street`, as highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the warning disappears.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements that will dereference the `Building` and `Street` properties,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the `Warning CS8602` on setting the `Building` but not the `Street`, as
    shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At runtime it is still possible for an exception to be thrown when working with
    `Street`, but the compiler should continue to warn you of potential exceptions
    when working with `Building` so that you can change your code to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the null-conditional operator to return `null` instead of accessing the
    `Length`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app, and note that the statement that accesses the `Length`
    of the `Building` outputs a `null` value (blank line), but a runtime exception
    occurs when we access the `Length` of the `Street`, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wrap the statement that accesses the `Street` length in a null check, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is worth reminding yourself that an NRT is only about asking the compiler
    to provide warnings about potential `null` values that might cause problems. It
    does not actually change the behavior of your code. It performs a static analysis
    of your code at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: This explains why the new language feature is named **nullable reference types**
    (**NRTs**). Starting with C# 8, unadorned reference types can become non-nullable,
    and the same syntax is used to make a reference type nullable, as it is used for
    value types.
  prefs: []
  type: TYPE_NORMAL
- en: Suffixing a reference type with `?` does not change the type. This is different
    from suffixing a value type with `?`, which changes its type to `Nullable<T>`.
    Reference types can already have `null` values. All you do with **NRTs** is tell
    the compiler that you expect it to be `null`, so the compiler does not need to
    warn you. However, this does not remove the need to perform `null` checks throughout
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at language features to work with `null` values that change the
    behavior of your code and work well as a complement to NRTs.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for null
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Checking whether a nullable reference type or value type variable currently
    contains `null` is important because if you do not, a `NullReferenceException`
    can be thrown, which results in an error. You should check for a `null` value
    before using a nullable variable, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'C# 7 introduced `is` combined with the `!` (`not`) operator as an alternative
    to `!=`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'C# 9 introduced `is not` as an even clearer alternative, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: Although you would traditionally use the expression `(thisCouldBeNull
    != null)`, this is no longer considered good practice because the developer could
    have overloaded the `!=` operator to change how it works. Using pattern matching
    with `is null` and `is not null` is the only guaranteed way to check for `null`.
    For many developers, it is still instinctual to use `!=`, so I apologize in advance
    if you catch me still using it!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `is` operator cannot be overloaded by a developer, its behavior is
    guaranteed. Both the `==` and `!=` operators could be overloaded by a developer
    so their behavior could change. The .NET team has now consistently implemented
    their null checks using `is`, so I recommend that you do the same, as you can
    see at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://twitter.com/Dave_DotNet/status/1764995927868076428](https://twitter.com/Dave_DotNet/status/1764995927868076428)'
  prefs: []
  type: TYPE_NORMAL
- en: The term *overriding* is about altering or extending the behavior of an inherited
    method in the context of object-oriented inheritance. *Overloading* occurs when
    you provide a new implementation for an existing operator or method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to use a member of a variable that might be `null`, use the **null-conditional
    operator**, `?.`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, you want to either assign a variable to a result or use an alternative
    value, such as `3`, if the variable is `null`. You do this using the **null-coalescing
    operator**, `??`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Checking for null in method parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even if you enable NRTs, when defining methods with parameters, it is good practice
    to check for `null` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In earlier versions of C#, you would have to write `if` statements to check
    for `null` parameter values and then throw an `ArgumentNullException` for any
    parameter that is `null`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'C# 10 introduced a convenience method to throw an exception if an argument
    is `null`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'C# 11 previews proposed and introduced a new `!!` operator that does this for
    you, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement and throwing of the exception would be done for you. The
    code is injected and executed before any statements that you write.
  prefs: []
  type: TYPE_NORMAL
- en: This proposal was controversial within the C# developer community. Some would
    prefer the use of attributes to decorate parameters instead of a pair of characters.
    The .NET product team said they reduced the .NET libraries by more than 10,000
    lines of code by using this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'That sounds like a good reason to use it to me! And no one must use it if they
    choose not to. Unfortunately, the team eventually decided to remove the feature,
    so now we all have to write the null checks manually. If you’re interested in
    this story, then you can read more about it at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/dotnet/csharp-11-preview-updates/#remove-parameter-null-checking-from-c-11](https://devblogs.microsoft.com/dotnet/csharp-11-preview-updates/#remove-parameter-null-checking-from-c-11)'
  prefs: []
  type: TYPE_NORMAL
- en: I include this story in this book because I think it’s an interesting example
    of Microsoft being transparent, by developing .NET in the open and listening to
    and responding to feedback from the community.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Always remember that nullable is a warning check, not an
    enforcement. You can read more about the compiler warnings relating to `null`
    at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/nullable-warnings](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/nullable-warnings)'
  prefs: []
  type: TYPE_NORMAL
- en: That’s more than enough talk about “nothing”! Let’s look at the meat of this
    chapter, inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting from classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Person` type we created earlier derived (inherited) from `System.Object`.
    Now, we will create a subclass that inherits from `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, add a new class file named `Employee.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify its contents to define a class named `Employee` that derives from `Person`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `PeopleApp` project, in `Program.cs`, add statements to create an instance
    of the `Employee` class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `Employee` class has inherited all the members of `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: Extending classes to add functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will add some employee-specific members to extend the class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Employee.cs`, add statements to define two properties, for an employee
    code and the date they were hired (we do not need to know a start time, so we
    can use the `DateOnly` type), as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to set John’s employee code and hire date,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hiding members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, the `WriteToConsole` method is inherited from `Person`, and it only
    outputs the employee’s name and date and time of birth. We might want to change
    what this method does for an employee:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Employee.cs`, add statements to redefine the `WriteToConsole` method, as
    highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project, view the result, and note that the first line
    of output is before the employees were hired; hence, it has a default date, as
    shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your code editor warns you that your method now hides the method from `Person`
    by drawing a squiggle under the method name, the **PROBLEMS**/**Error List** window
    includes more details, and the compiler will output a warning when you build and
    run the console application, as shown in *Figure 6.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_06_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Hidden method warning'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the warning describes, you should hide this message by applying the `new`
    keyword to the method, indicating that you are deliberately replacing the old
    method, as highlighted in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Make this fix now.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the this and base keywords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two special C# keywords that can be used to refer to the current
    object instance or the base class that it inherits from:'
  prefs: []
  type: TYPE_NORMAL
- en: '`this`: It represents the current object instance. For example, in the `Person`
    class instance members (but not in static members), you could use the expression
    `this.Born` to access the `Born` field of the current object instance. You rarely
    need to use it, since the expression `Born` would also work. It is only when there
    is a local variable also named `Born` that you would need to use `this.Born` to
    explicitly say you are referring to the field, not the local variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`base`: It represents the base class that the current object inherits from.
    For example, anywhere in the `Person` class, you could use the expression `base.ToString()`
    to call the base class implementation of that method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will (hopefully) remember from *Chapter 5*, *Building Your Own Types with
    Object-Oriented Programming*, that to access static members, you must use the
    type name.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rather than hiding a method, it is usually better to **override** it. You can
    only override it if the base class chooses to allow overriding, by applying the
    `virtual` keyword to any methods that should allow overriding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add a statement to write the value of the `john` variable
    to the console using its `string` representation, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and note that the `ToString` method is inherited
    from `System.Object`, so the implementation returns the namespace and type name,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Person.cs` (not in the `Employee` class!), override this behavior by adding
    a `ToString` method to output the name of the person as well as the type name,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `base` keyword allows a subclass to access members of its superclass, that
    is, the **base class** that it inherits or derives from.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Good Practice**: Some code editors like Visual Studio will automatically
    add a call to the base class member when you override a member. To decide if you
    need to keep the call or not, view the tooltip or definition of the member. For
    example, in *Chapter 10*, *Working with Data Using Entity Framework Core*, you
    will override a method of the `DbContext` class named `OnConfiguring`. If you
    hover over the method name, its tooltip tells you “The base implementation does
    nothing.” If you **Go To Definition** (*F12*) of the method, you will see that
    it does nothing, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The method only exists in the base class so that subclasses can override it
    and then EF Core can call your code when it needs to configure the data context.
    It would be a waste for your overridden method implementation to call the base
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `PeopleApp` project and view the result. Now, when the `ToString` method
    is called, it outputs the person’s name, as well as returning the base class’s
    implementation of `ToString`, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Many real-world APIs, for example, Microsoft’s Entity Framework
    Core, Castle’s DynamicProxy, and Optimizely CMS’s content models, require the
    properties that you define in your classes to be marked as `virtual` so that they
    can be overridden. Carefully decide which of your methods and property members
    should be marked as `virtual`.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting from abstract classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, you learned about interfaces that can define a set
    of members that a type must have to meet a basic level of functionality. These
    are very useful, but their main limitation is that until C# 8 they could not provide
    any implementation of their own.
  prefs: []
  type: TYPE_NORMAL
- en: This is a particular problem if you still need to create class libraries that
    will work with .NET Framework and other platforms that do not support .NET Standard
    2.1.
  prefs: []
  type: TYPE_NORMAL
- en: In those earlier platforms, you could use an **abstract class** as a sort of
    halfway house between a pure interface and a fully implemented class.
  prefs: []
  type: TYPE_NORMAL
- en: When a class is marked as `abstract`, this means that it cannot be instantiated
    because you have indicated that the class is not complete. It needs more implementation
    before it can be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `System.IO.Stream` class is `abstract` because it implements
    common functionality that all streams would need but is not complete. Therefore,
    it is useless without more implementation that is specific to the type of stream,
    so you cannot instantiate it using `new Stream()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compare the two types of interface and the two types of class, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Choosing between an interface and an abstract class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have now seen examples of implementing the concept of abstraction using
    either an interface or an `abstract` class. Which should you pick? Now that an
    interface can have default implementations for its members, is the `abstract`
    keyword for a class obsolete?
  prefs: []
  type: TYPE_NORMAL
- en: Well, let’s think about a real example. `Stream` is an `abstract` class. Would
    or could the .NET team use an interface for that today?
  prefs: []
  type: TYPE_NORMAL
- en: Every member of an interface must be `public` (or at least match the interface’s
    access level, which could be `internal` if it should only be used in the class
    library that it’s defined in). An `abstract` class has more flexibility in its
    members’ access modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of an `abstract` class over an interface is that serialization
    often does not work for an interface. So, no, we still need to be able to define
    abstract classes.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing inheritance and overriding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can prevent another developer from inheriting from your class by applying
    the `sealed` keyword to its definition. For example, no one can inherit from Scrooge
    McDuck, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: An example of `sealed` in .NET is the `string` class. Microsoft has implemented
    some extreme optimizations inside the `string` class that could be negatively
    affected by your inheritance, so Microsoft prevents that.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can prevent someone from further overriding a `virtual` method in your
    class by applying the `sealed` keyword to the method. For example, no one can
    change the way Lady Gaga sings, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: You can only seal an overridden method.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have now seen two ways to change the behavior of an inherited method. We
    can *hide* it using the `new` keyword (known as **non-polymorphic inheritance**),
    or we can *override* it (known as **polymorphic inheritance**).
  prefs: []
  type: TYPE_NORMAL
- en: Both ways can access members of the base or superclass by using the `base` keyword,
    so what is the difference?
  prefs: []
  type: TYPE_NORMAL
- en: It all depends on the type of variable holding a reference to the object. For
    example, a variable of the `Person` type can hold a reference to a `Person` class,
    or any type that derives from `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this could affect your code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Employee.cs`, add statements to override the `ToString` method so that
    it writes the employee’s name and code to the console, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, write statements to create a new employee named Alice stored
    in a variable of type `Employee`. Also, store Alice in a second variable of type
    `Person`, and then call both variables’ `WriteToConsole` and `ToString` methods,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When a method is hidden with `new`, the compiler is not smart enough to know
    that the object is an `Employee`, so it calls the `WriteToConsole` method in `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: When a method is overridden with `virtual` and `override`, the compiler is smart
    enough to know that although the variable is declared as a `Person` class and
    the object itself is an `Employee` class, and therefore, the `Employee` implementation
    of `ToString` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The member modifiers and the effect they have are summarized in *Table 6.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Variable type** | **Member modifier** | **Method executed** | **In class**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Person` |  | `WriteToConsole` | `Person` |'
  prefs: []
  type: TYPE_TB
- en: '| `Employee` | `new` | `WriteToConsole` | `Employee` |'
  prefs: []
  type: TYPE_TB
- en: '| `Person` | `virtual` | `ToString` | `Employee` |'
  prefs: []
  type: TYPE_TB
- en: '| `Employee` | `override` | `ToString` | `Employee` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.5: Member modifiers and the effect they have'
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, polymorphism is academic to most programmers. If you get the
    concept, that’s cool; but if not, I suggest that you don’t worry about it. Some
    people like to make others feel inferior by saying understanding polymorphism
    is important for all C# programmers, but in my opinion, it’s not. There are thousands
    of other topics that your time and effort will be better spent on.
  prefs: []
  type: TYPE_NORMAL
- en: You can have a successful career with C# and never need to be able to explain
    polymorphism, just as a racing car driver doesn’t need to explain the engineering
    behind fuel injection.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: You should use `virtual` and `override` rather than `new`
    to change the implementation of an inherited method whenever possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Casting within inheritance hierarchies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Casting** between types is subtly different from converting between types.
    Casting is between similar types, like between a 16-bit integer and a 32-bit integer,
    or between a superclass and one of its subclasses. **Converting** is between dissimilar
    types, such as between text and a number.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you need to work with multiple types of `stream`, then instead
    of declaring specific types of stream like `MemoryStream` or `FileStream`, you
    could declare an array of `Stream`, the supertype of `MemoryStream`, and `FileStream`.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit casting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, you saw how an instance of a derived type can be stored
    in a variable of its base type (or its base’s base type, and so on). When we do
    this, it is called **implicit casting**.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit casting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The opposite of implicit casting is explicit casting, and you must use parentheses
    around the type you want to cast into as a prefix to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add a statement to assign the `aliceInPerson` variable to
    a new `Employee` variable, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your code editor displays a red squiggle and a compile error, as shown in *Figure
    6.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_06_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: A missing explicit cast compile error'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the statement to prefix the assigned variable name with a cast to the
    `Employee` type, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Avoiding casting exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compiler is now happy; however, because `aliceInPerson` might be a different
    derived type, like `Student` instead of `Employee`, we need to be careful. In
    a real application with more complex code, the current value of this variable
    could have been set to a `Student` instance, and then this statement would throw
    an `InvalidCastException` error at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Using is to check a type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can handle this by writing a `try` statement, but there is a better way.
    We can check the type of an object using the `is` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap the explicit cast statement in an `if` statement, as highlighted in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: You could simplify the code further using a declaration
    pattern, and this will avoid the need to perform an explicit cast, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: This technique of both checking and casting was covered in *Chapter 3*, *Controlling
    Flow, Converting Types, and Handling Exceptions*.
  prefs: []
  type: TYPE_NORMAL
- en: What if you want to execute a block of statements when Alice is *not* an employee?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the past, you would have had to use the `!` (not) operator, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'With C# 9 and later, you can use the `not` keyword, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Using as to cast a type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternatively, you can use the `as` keyword to cast a type. Instead of throwing
    an exception, the `as` keyword returns `null` if the type cannot be cast:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to cast Alice using the `as` keyword, and then
    check whether the return value is not null, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since accessing a member of a `null` variable will throw a `NullReferenceException`
    error, you should always check for `null` before using the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Use the `is` and `as` keywords to prevent throwing exceptions
    when casting between derived types. If you don’t do this, you must write `try`-`catch`
    statements for `InvalidCastException`.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting and extending .NET types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET has pre-built class libraries containing hundreds of thousands of types.
    Rather than creating your own completely new types, you can often get a head start
    by deriving from one of Microsoft’s types to inherit some or all its behavior,
    and then overriding or extending it.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example of inheritance, we will derive a new type of exception:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, add a new class file named `PersonException.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the contents of the file to define a class named `PersonException` with
    three constructors, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unlike ordinary methods, constructors are not inherited, so we must explicitly
    declare and explicitly call the `base` constructor implementations in `System.Exception`
    (or whichever exception class you derived from) to make them available to programmers
    who might want to use those constructors with our custom exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define a method that throws an exception
    if a date/time parameter is earlier than a person’s date and time of birth, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to test what happens when employee John Jones
    tries to time-travel too far back, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: When defining your own exceptions, give them the same three
    constructors that explicitly call the built-in ones in `System.Exception`. Other
    exceptions that you might inherit from may have more.'
  prefs: []
  type: TYPE_NORMAL
- en: Extending types when you can’t inherit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, we saw how the `sealed` modifier can be used to prevent inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft has applied the `sealed` keyword to the `System.String` class so that
    no one can inherit and potentially break the behavior of strings.
  prefs: []
  type: TYPE_NORMAL
- en: Can we still add new methods to strings? Yes, if we use a language feature named
    **extension methods**, which was introduced with C# 3.0\. To properly understand
    extension methods, we need to review static methods first.
  prefs: []
  type: TYPE_NORMAL
- en: Using static methods to reuse functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the first version of C#, we’ve been able to create `static` methods to
    reuse functionality, such as the ability to validate that a `string` contains
    an email address. The implementation will use a regular expression that you will
    learn more about in *Chapter 8*, *Working with Common .NET Types*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write some code:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, add a new class file named `StringExtensions.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify `StringExtensions.cs`, as shown in the following code, and note the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class imports a namespace to handle regular expressions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `IsValidEmail` method is `static`, and it uses the `Regex` type to check
    for matches against a simple email pattern that looks for valid characters before
    and after the `@` symbol:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to validate two examples of email addresses,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This works, but extension methods can reduce the amount of code we must type
    and simplify the usage of this function.
  prefs: []
  type: TYPE_NORMAL
- en: Using extension methods to reuse functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is easy to turn `static` methods into extension methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `StringExtensions.cs`, add the `static` modifier before the class, and then
    add the `this` modifier before the `string` type, as highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: These two changes tell the compiler that it should treat
    the method as one that extends the `string` type.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to use the extension method for `string` values
    that need to be checked for valid email addresses, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the subtle simplification in the syntax to call the `IsValidEmail` method.
    The older, longer syntax still works too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IsValidEmail` extension method now appears to be a method just like all
    the actual instance methods of the `string` type, such as `IsNormalized`, except
    with a small down arrow on the method icon to indicate an extension method, as
    shown in *Figure 6.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_06_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Extension methods appear in IntelliSense alongside instance methods'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `PeopleApp` project and view the result, which will be the same as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice**: Extension methods cannot replace or override existing instance
    methods. You cannot, for example, redefine the `Insert` method. The extension
    method will appear as an overload in IntelliSense, but an instance method will
    be called in preference to an extension method with the same name and signature.'
  prefs: []
  type: TYPE_NORMAL
- en: Although extension methods might not seem to give a big benefit, in *Chapter
    11*, *Querying and Manipulating Data Using LINQ*, you will see some extremely
    powerful uses of extension methods.
  prefs: []
  type: TYPE_NORMAL
- en: Method chaining or fluent style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Method chaining, also known as fluent style, is a programming technique where
    multiple method calls are chained together in a single statement. This is achieved
    by having each method return an instance of the same object (often the object
    the method was called on), enabling a sequence of method calls on the same object.
    This style is popular in C# for creating readable and concise code, especially
    for configuring objects or building complex queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider this `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'To construct a `Person` instance, you can chain method calls, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Extension methods allow adding new methods to existing types without modifying
    their source code or creating a new derived type. When combined with method chaining,
    this can enhance the readability and functionality of existing classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have a `Car` class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create extension methods to enable method chaining for the `Car` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use these extension methods to chain method calls on a Car object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The benefits of method chaining include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Readability**: The code is more readable and resembles natural language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conciseness**: Reduces the need for repetitive code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configurability**: Allows the flexible and easy configuration of objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But the potential drawbacks of method chaining include debugging difficulty
    because long chains can be harder to debug, and misleading code because if not
    used carefully, it can lead to less intuitive code, especially when dealing with
    nullable objects or complex logic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good practice**: When method chaining, use clear method names to ensure they
    clearly indicate their purpose, return `this` or the object itself to maintain
    the chain, and carefully consider how to handle potential errors or exceptions
    within chained methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Method chaining and the fluent style, especially when combined with extension
    methods in C#, provide clean, readable, and maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing custom type choices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have covered OOP and the C# features that enable you to define your
    own types, let’s summarize what you’ve learned.
  prefs: []
  type: TYPE_NORMAL
- en: Categories of custom types and their capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Categories of custom types and their capabilities are summarized in *Table
    6.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Instantiation** | **Inheritance** | **Equality** | **Memory**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `class` | Yes | Single | Reference | Heap |'
  prefs: []
  type: TYPE_TB
- en: '| `sealed` `class` | Yes | None | Reference | Heap |'
  prefs: []
  type: TYPE_TB
- en: '| `abstract` `class` | No | Single | Reference | Heap |'
  prefs: []
  type: TYPE_TB
- en: '| `record` or `record` `class` | Yes | Single | Value | Heap |'
  prefs: []
  type: TYPE_TB
- en: '| `struct` or `record` `struct` | Yes | None | Value | Stack |'
  prefs: []
  type: TYPE_TB
- en: '| `interface` | No | Multiple | Reference | Heap |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.6: Categories of custom types and their capabilities'
  prefs: []
  type: TYPE_NORMAL
- en: It is best to think about these differences by starting with the “normal” case
    and then spotting the differences in other cases. For example, a “normal” `class`
    can be instantiated with `new`, it supports single inheritance, it uses memory
    reference equality, and its state is stored in heap memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s highlight what is different about the more specialized types of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: A `sealed` class does not support inheritance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `abstract` class does not allow instantiation with `new`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `record` class uses value equality instead of reference equality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can do the same for other types compared to a “normal” class:'
  prefs: []
  type: TYPE_NORMAL
- en: A `struct` or `record struct` does not support inheritance, it uses value equality
    instead of reference equality, and its state is stored in stack memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `interface` does not allow instantiation with `new` and supports multiple
    inheritance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutability and records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common misconception is that `record` types are immutable, meaning their
    instance property and field values cannot be changed after initialization. However,
    the mutability of a `record` type actually depends on how the `record` is defined.
    Let’s explore mutability:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, add a new class file named `Mutability.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify `Mutability.cs`, as shown in the following code, and note the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `PeopleApp` project, in `Program.cs`, create an instance of each type,
    setting the initial `Name` value to `Bob`, and then modify the `Name` property
    to `Bill`. You will see the two types that are immutable after initialization
    because they will give the compiler error `CS8852`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that record `C1` is mutable and `C2` is immutable. Note that `S1` and `S2`
    are mutable and `S3` is immutable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comment out the two statements that cause compiler errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Microsoft made some interesting design choices with records. Make sure you remember
    the subtle differences in behavior when combining record, class, and struct, and
    use different types of declaration of each.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Comparing inheritance and implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For me, the terms *inherit* and *implement* are different, and in the early
    days of C# and .NET you could strictly apply them to classes and interfaces, respectively.
    For example, the `FileStream` class inherits from the `Stream` class, and the
    `Int32` `struct` implements the `IComparable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: '*Inherit* implies some functionality that a subclass gets “for free” by inheriting
    from its **base**, or **superclass**. *Implement* implies some functionality that
    is NOT inherited but instead MUST be provided by the subclass. This is why I chose
    to title this chapter *Implementing Interfaces and Inheriting Classes*.'
  prefs: []
  type: TYPE_NORMAL
- en: Before C# 8, interfaces were always purely contracts. There was no functionality
    in an interface that you could inherit. In those days, you could strictly use
    the term *implement* for interfaces that represent a list of members that your
    type must implement, and *inherit* for classes with functionality that your type
    can inherit and potentially override.
  prefs: []
  type: TYPE_NORMAL
- en: With C# 8, interfaces can now include default implementations, making them more
    like abstract classes, and the term *inherit* for an interface that has default
    implementations does make sense. But I feel uncomfortable with this capability,
    as do many other .NET developers, because it messes up what used to be a clean
    language design. Default interfaces also require changes to the underlying .NET
    runtime, so they cannot be used with legacy platforms like .NET Standard 2.0 class
    libraries and .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Classes can also have abstract members, for example, methods or properties without
    any implementation, just like an interface could have. When a subclass inherits
    from this class, it MUST provide an implementation of those abstract members,
    and the base class must be decorated with the `abstract` keyword to prevent it
    from being instantiated using `new` because it is missing some functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing illustrative code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s review some example code that illustrates some of the important differences
    between types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the code, I have left out access modifiers like `private` and `public`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of normal brace formatting, to save vertical space I have put all the
    method implementations in one statement, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using “I” as a prefix for interfaces is a convention, not a requirement. It
    is useful to highlight interfaces using this prefix, since only interfaces support
    multiple inheritance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with more in-depth research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.1 – Online material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Online material can be extra content written by me for this book, or it can
    be references to content created by Microsoft or third parties.
  prefs: []
  type: TYPE_NORMAL
- en: Managing memory with reference and value types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Read the following online-only section to learn how to manage memory with reference
    and value types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Writing better code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Read the following online-only section to learn how to use analyzers to write
    better code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch06-writing-better-code.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch06-writing-better-code.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.2 – Practice creating an inheritance hierarchy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Explore inheritance hierarchies by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new console app named `Exercise_Inheritance` to your `Chapter06` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class named `Shape` with properties named `Height`, `Width`, and `Area`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three classes that derive from it—`Rectangle`, `Square`, and `Circle`—with
    any additional members you feel are appropriate and that override and implement
    the `Area` property correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to create one instance of each shape, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app and ensure that the result looks like the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Exercise 6.3 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a delegate?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an event?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are a base class and a derived class related, and how can the derived class
    access the base class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `is` and `as` operators?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which keyword is used to prevent a class from being derived from or a method
    from being further overridden?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which keyword is used to prevent a class from being instantiated with the `new`
    keyword?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which keyword is used to allow a member to be overridden?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the difference between a destructor and a deconstruct method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the signatures of the constructors that all exceptions should have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an extension method, and how do you define one?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 6.4 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about:'
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegates and events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory usage differences between reference and value types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with null values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deriving and casting types using inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base and derived classes, how to override a type member, and using polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how .NET is packaged and deployed, and in
    subsequent chapters, the types that it provides you with to implement common functionality,
    such as file handling and database access.
  prefs: []
  type: TYPE_NORMAL
