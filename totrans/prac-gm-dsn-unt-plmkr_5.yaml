- en: Chapter 5. Scripting and Custom Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous chapters, you learned how to make a game using Playmaker''s in-built
    actions. Unfortunately, their capabilities are limited, and sooner or later you
    will find yourself in need of something that Playmaker does not know how to do
    out-of-the-box. In this case, you can try and find a ready-made solution on the
    Internet, but to make sure that there is an answer to every one of your questions,
    you will certainly have to learn how to write scripts. These are the topics that
    we will discuss in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Programming in Unity JavaScript (sometimes also called UnityScript) and C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common Unity classes, variables, and functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a script and using it as component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming a script into a Playmaker action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a Unity Script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Explaining how programming works in general is beyond the scope of this book,
    so I am going to assume that you already know what variables, functions, classes,
    and operators are. If, however, you do not know these things, it should not take
    you too long to pick up the basics using either Code Academy ([http://www.codecademy.com/tracks/javascript](http://www.codecademy.com/tracks/javascript))
    or Unity's own starting level tutorials ([http://unity3d.com/learn/tutorials/modules/beginner/scripting](http://unity3d.com/learn/tutorials/modules/beginner/scripting)).
  prefs: []
  type: TYPE_NORMAL
- en: We are going to start with **JavaScript** (**JS**) in this section, because
    it is much simpler to use and does not require any understanding of object-oriented
    programming beyond the component-based approach to development that we already
    discussed in [Chapter 3](ch03.html "Chapter 3. Components and State Machines"),
    *Components and State Machines*. Besides, you will end up writing significantly
    less code.
  prefs: []
  type: TYPE_NORMAL
- en: Both JS and C# use the same Unity classes and functions, and the difference
    in syntax is not very significant at all. However, for more complex things it
    is generally a good idea to use C# (for one thing, it is currently impossible
    to write a Playmaker action in JavaScript). We will start with a JS script and
    then translate it into C#, explaining the differences. You can later choose whichever
    language works better for you.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a script that replaces all the Playmaker actions in the
    **Push Puck** state of both mallets' FSMs. When you see that you have to make
    a chain of five or more actions, it is generally easier to combine them in a single
    custom action, especially if you are planning to use this compound action on multiple
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start by creating a new script. First of all, create a new folder named
    `Scripts` using the **Project** panel. Then, right-click on the newly created
    folder and navigate to **Create** | **Javascript**. Name the file `PushPuck`.
    Double-click on the file. The standard Unity programming environment, MonoDevelop,
    should open. Select everything there is in that script and replace it with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt Publishing books you have
    purchased from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Press *command* + *S* (*Ctrl* + *S* in Windows) in MonoDevelop to save the changes
    to the script.
  prefs: []
  type: TYPE_NORMAL
- en: Let us examine this code line-by-line. The first line is `#pragma strict`. This
    is a preprocessor directive. If you have some previous programming experience,
    you have probably seen something similar before. It does not participate in script
    logic; what it does is make JavaScript more explicit by imposing more strict error
    handling in the compiler. What it means for you is that you have to explicitly
    define the types of your variables, which is something you would not normally
    do in standard JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another common preprocessor directive for JS is `#pragma downcast`, which lets
    you get rid of warnings of implicit downcast if you do not care about them.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that there are two lines of variable declaration: `pushMag` and `collisionTag`
    are declared as `float` and `String`. Once you attach this script to an object,
    these variables will be displayed in the Inspector, because they are both public
    and serialized. Since a script in Unity is treated as a component, variables appear
    as parameters in the Inspector once you attach the script to a game object.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to declare a variable that does not appear in the Inspector, but
    want other scripts to still have access to it, you should put `[System.NonSerialized]`
    before it. If you want to both hide it and close all access to it, you just need
    to put `private` before the `var` keyword. Finally, if you want to expose a private
    variable in Inspector, you should put `[System.SerializableAttribute]` before
    its declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next goes the function declaration: `function` `OnControllerColliderHit` `(hit
    : ControllerColliderHit)`. `OnControllerColliderHit` is one of the standard Unity
    functions that are responsible for detecting collisions. Other such functions
    are `OnCollisionEnter`, `OnCollisionStay`, `OnCollisionExit`, `OnTriggerEnter`,
    `OnTriggerStay`, and `OnTriggerExit`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `OnControllerColliderHit` function gets called automatically if the object
    that the script is attached to has a Character Controller component and that Character
    Controller collides with a collider. The `hit` variable of type `ControllerColliderHit`
    gets assigned and can be used inside the function. By typing `hit` and a dot,
    one can access all kinds of information about the collision.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, inside the function there is an `if` condition: `if (hit.gameObject.tag
    == collisionTag)`. We access the `gameObject` that our Character Controller has
    collided with, using the dot operator, and then we use it again to access that
    tag in `gameObject`. Then we compare that tag with the `collisionTag` string variable
    that is assigned in the Inspector. If the tag matches the string we specified,
    the code inside the curly brackets is executed.'
  prefs: []
  type: TYPE_NORMAL
- en: In this script, we reproduced the exact sequence of actions in the **Push Puck**
    state of the mallets' FSMs. You can consult it for reference. First, we get the
    position of the puck and store it in a `Vector3` variable called `hitObjectPos`.
    Then we get the point of the hit and store it in another `Vector3` variable called
    `hitPointPos`. We then calculate the force of the push in one step instead of
    three that we used in Playmaker. Finally, the force is applied to the puck's rigidbody.
  prefs: []
  type: TYPE_NORMAL
- en: After that there is a line with `Debug.Log` that prints information about every
    hit in the Console. You can comment this line out by typing `//` in front of it.
    Keep it uncommented for now to make sure that the script works.
  prefs: []
  type: TYPE_NORMAL
- en: The very last line of the script is `@script RequireComponent (CharacterController)`.
    It is there to make sure that there is a Character Controller component attached
    to the game object that this script is attached to. If you attach this script
    to a game object that does not have a Character Controller, it will be attached
    automatically. If you try to remove the Character Controller without removing
    `PushPuck` first, Unity will display a warning dialog window and not allow you
    to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Now it is time to see if our newly created script works. Go back to Unity and
    open the **Console** panel. If there are no red errors, this means that the script
    was compiled correctly and is ready to be used. If there is some kind of error
    in a script, double-clicking on it in the Console will open the script in MonoDevelop
    and direct you to the line where the error has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything is okay, select **MalletLeft**, open the **playMaker** panel
    and in the **Move** state disable the **Collision** **Event** action by unchecking
    the box next to its name. If you start the game now, colliding with the puck will
    not push it. Now it is time to use our brand-new `PushPuck` script. Drag and drop
    the `PushPuck` file from the **Project** panel to the **Inspector** panel while
    having **MalletLeft** selected. It will attach to it as a component. Set its parameters
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a Unity Script](img/8108OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Open the **Console** panel and launch the game. Note how messages appear in
    the Console every time you hit the puck with your mallet. If you stop the game
    and double-click on one of the `Debug.Logs`, MonoDevelop will open and point you
    to the `Debug.Log` line of the `PushPuck` script. Now that you know the script
    works, you can comment that line out in order to prevent it from spamming the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: Also, now you can apply it to the AI opponent as well. Remember to deactivate
    the **Collision Event** action first.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of standard Unity classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While I am not going to copy the whole Unity Script Reference into this chapter
    of the book, I would like to list a few important classes and functions that you
    are going to use quite often.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most obvious and frequently used standard functions are `Awake`, `Start`,
    `OnEnable`, `OnDisable`, `Update`, and `FixedUpdate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Awake` is the first function that is called when a scene is loaded. The `Awake`
    function can happen only once per scene load. It is generally a good idea to put
    all initialization code into the `Awake` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Start` happens after `Awake` and also runs once. Sometimes it is a good idea
    to put some code into `Awake` and some other code into `Start` in order to make
    sure that one is executed after the other. When you have an `Awake` function in
    one script and another `Awake` function in another script, you cannot be sure
    which one will be executed first. If the order matters, put one of the pieces
    of code into the `Start` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There''s another way to ensure a correct script execution order. You can decide
    which script is executed before or after by navigating to **Edit** | **Project
    Settings** | **Script Execution Order** from the main menu and then pressing the
    plus button in the Inspector, selecting the script whose execution order you would
    like to define, and then dragging it up or down in the interface. You will notice
    that the number on the right changes as you drag the script: this number is the
    script''s execution order. You give the script its default execution order by
    removing it from this list. You can do this by pressing the minus button on the
    right from its name in the list.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `OnEnable` function is a lot like `Start`, except it is called every time
    the object to which the script is attached is activated, as well as every time
    the component itself is enabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnDisable` is the opposite of `OnEnable`. It is called when the object or
    the component gets disabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Update` is called every frame. Most of the games'' logic usually happens here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FixedUpdate` is called on physics update, which is generally significantly
    more frequent than `Update`. All the code that cannot be frame rate dependent
    (such as, for instance, movement) should be in the `FixedUpdate` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apart from the functions, there are whole classes with their methods and variables
    that you should absolutely know about when programming in Unity. It is hard to
    emphasize something in particular, and you really should just go through all the
    major classes listed in the Scripting Reference ([http://docs.unity3d.com/Documentation/ScriptReference/](http://docs.unity3d.com/Documentation/ScriptReference/)).
    There are really a lot of classes, and there is hardly anyone who knows what all
    of them do, but we are going to go through a few that you should look at first
    thing: `Mathf`, `Vector3`, `Color`, `Input`, `GameObject`, `Transform`, `Renderer`,
    `Material`, `Collision`, `Collider`, and of course `Object`, `Behaviour`, `Component`,
    and `MonoBehaviour`.'
  prefs: []
  type: TYPE_NORMAL
- en: The last four classes are especially important, since they include things that
    you are going to use every time you write a script in Unity, including functions
    like `Update`, `Destroy`, `GetComponent`, and `Start`, as well as variables such
    as `enabled`, `name`, `layer`, and `tag`. Try to read descriptions of these classes
    and their functions and variables very carefully, and look at the basic examples
    the documentation offers with them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Playmaker action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time to translate our script to C#. Create a new C# script the same way
    you created the JS one. Call it `PushPuckAction`. Open the script and find the
    line starting with the `public class` keywords. Make sure that the name of the
    class is the same as the name of the script, then press *command* + *S* (*Ctrl*
    + *S* in Windows) to save your changes if you made any.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the default template for a C# script looks different from that
    of JS. This is because more things are shown to you. For instance, in JS it is
    implied that everything inside a script is, in fact, in a class with the same
    name, but you do not see the class declaration anywhere. Component classes in
    Unity have to inherit from MonoBehaviour, and it is shown in C#, while JS hides
    it from you. Then you have the two lines with the `using` keyword. All JS scripts
    use these namespaces, but JS hides it from you as well. The following script is
    the same one that we had before, but this time translated to C#. Replace the template
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Press *command* + *S* (*Ctrl* + *S* in Windows), and let us look at what has
    changed apart from the things already mentioned. The syntax of the component requirement
    is different in C#. On top of that, the `RequireComponent` attribute has to be
    placed before the class declaration.
  prefs: []
  type: TYPE_NORMAL
- en: The `#pragma strict` directive is gone. C# is explicit by nature and requires
    that you specify types of everything, so it is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In C#, the following are quite useful: `#region [Name]`/`#endregion`, which
    is a good way of dividing your code into regions that you can fold. For example,
    writing `#region Variables` will create a region called `Variables`. Then you
    will be able to press a minus in a rectangle on the left of the MonoDevelop window
    to fold the code region, the end of which you have to mark with `#endregion`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `function` keyword is not used. Instead, function declarations are preceded
    by return types. You can specify a return type in JS as well, but this is done
    with the `:` operator after the brackets, for example, `function Update() : void`.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, all variable declarations are preceded with types of variables instead
    of the `var` keyword. There are more differences in syntax that we cannot see
    in this example because of the relative simplicity of our script, but these are
    the main ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you replace your JS script with the C# one on the Mallets, they will
    act exactly the same way as before. Try doing this, then remove the **Push Puck
    Action** component from the mallets. It is time to modify the script and transform
    `PushPuckAction.cs` into an actual Playmaker action. Replace the contents of `PushPuckAction.cs`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Press *command* + *S* (*Ctrl* + *S* in Windows) to save the script. As you can
    see, this time more things have changed, although you can still see the same structure.
    Let us go through the code line-by-line and examine it.
  prefs: []
  type: TYPE_NORMAL
- en: The `using` directives are the same, but the difference begins right after them.
    The line `namespace` `HutongGames.PlayMaker.Actions` is obligatory for all Playmaker
    actions. Without it Playmaker will not know that the script that you are writing
    is, in fact, an action.
  prefs: []
  type: TYPE_NORMAL
- en: The `[ActionCategory(ActionCategory.Character)]` line puts your new action into
    a category. In this case, we are putting it into the `Character` category, because
    the action is about things colliding with the Character Controller. It could also
    go into the `Physics` category. To move it there, the line would have to be `[ActionCategory(ActionCategory.Physics)]`.
  prefs: []
  type: TYPE_NORMAL
- en: After that there is `[Tooltip("...")]`, which is quite self-explanatory. It
    shows a short description when you select the action from the list in the **Actions**
    panel.
  prefs: []
  type: TYPE_NORMAL
- en: The `PushPuckAction` class now inherits from `FsmStateAction` instead of `MonoBehavior`.
    You still have access to all the standard Unity classes, but Playmaker-specific
    ones are added now.
  prefs: []
  type: TYPE_NORMAL
- en: Then there is another `Tooltip`, this time for a variable rather that a whole
    action. The text within this tooltip will appear when you hover your mouse pointer
    over the variable in the **State** tab of the **playMaker** panel or in the **Actions**
    panel.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the type of the `pushMag` variable has changed from `float` to `FsmFloat`,
    and the same goes for the `string` variable `collisionTag`—it is `FsmString` now.
    These are Playmaker types of variables. The same operations can be performed on
    them as before, but to access their value you now have to use the dot operator
    with the word `Value`, so, for example, `pushMag.Value` will return a float, the
    value of the Playmaker variable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do not want to be able to assign a value directly in the **State** tab
    of the **playMaker** panel and force choosing from existing variables, you can
    write `[UIHint(UIHint.Variable)]` in the line before the variable declaration,
    the same way we did for the tooltips.
  prefs: []
  type: TYPE_NORMAL
- en: A `Reset` function was added. This is what happens when a new action is added
    to a state or when you right-click on the header of the action and press **Reset**.
    In it, we reinitialize the variables.
  prefs: []
  type: TYPE_NORMAL
- en: Then there is the `DoControllerColliderHit` function. Its name has changed from
    the standard Unity `OnControllerColliderHit`. Inside the function everything has
    stayed more or less the same with the only difference that types of `Vector3`
    variables have changed to `FsmVector3`, so to access their values `.Value` is
    used. Also, instead of `Vector3.Normalize`, we used `.nomalized`, which does exactly
    the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it is clear that in order to find examples and standard Unity classes'
    API one has to go to Unity Script Reference, it may be less clear about Playmaker-specific
    things. The easiest way to find examples is opening the script files of existing
    Playmaker actions that are located under the `PlayMaker/Actions` path, in your
    project. For example, if you are not quite sure how to detect mouse input and
    you want to do it via a Playmaker custom action, you can open `PlayMaker/Actions/MousePick.cs`
    and look at how the creators of Playmaker solved this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Note that both `Reset` and `DoControllerColliderHit` have `override` preceding
    their types. This means that we are replacing a base function defined in the Playmaker
    with our own function. As a general rule, you will need to override all of the
    Playmaker standard functions using this keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are done writing a custom Playmaker action, we can try using it.
    Remove the **Push Puck** and/or **Push** **Puck** **Action** components from **MalletLeft**
    and **MalletRight**. In their **Move** state, remove the **Collision Event** action.
    Then locate the newly created **Push Puck Action** in the **Actions** panel and
    add it to the state. Set the properties as shown in the following screenshot.
    Finally, delete the **Push Puck** state from the FSM as well as the **Push** event
    and transition. To delete a transition, you just need to right-click on the event
    in the FSM view and press **Delete Transition**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Playmaker action](img/8108OT_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to scripting in Unity, both JavaScript
    and C#, and learned how to create custom Playmaker actions. You should try repeating
    the process described in this chapter with another set of actions on your own.
    Set yourself a gameplay goal, for instance, you could take one of the exercises
    offered at the end of [Chapter 4](ch04.html "Chapter 4. Creating Your First Game"),
    *Creating Your First Game*, write a JS or C# script that accomplishes the goal;
    and then translate it into a Playmaker action. You will feel much more comfortable
    with scripting by the time you are done, as it is all about practice, and no amount
    of reading and theory can replace a hands-on experience with a text editor and
    a search engine.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapters continue talking about advanced subjects, such as networking
    and external APIs, and we are going to do some more scripting in [Chapter 7](ch07.html
    "Chapter 7. Working with External APIs"), *Working with External APIs*.
  prefs: []
  type: TYPE_NORMAL
