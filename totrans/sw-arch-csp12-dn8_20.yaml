- en: '20'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '20'
- en: Kubernetes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes
- en: This chapter is dedicated to describing the Kubernetes container orchestrator
    and its implementation in Azure, called **Azure Kubernetes Service** (**AKS**).
    We discussed the importance and the tasks handled by orchestrators in the *Which
    tools are needed to manage microservices?* section of *Chapter 11, Applying a
    Microservice Architecture to Your Enterprise Application*. Here, it is worth recalling
    just that Kubernetes is the de facto standard for orchestrators.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于描述 Kubernetes 容器编排器及其在 Azure 中的实现，称为 **Azure Kubernetes 服务**（**AKS**）。我们在第
    11 章“将微服务架构应用于您的企业应用”的“*哪些工具需要用于管理微服务？*”部分讨论了编排器的重要性和处理任务。在这里，值得回顾的是 Kubernetes
    是编排器的既定标准。
- en: We will show also how to install and use minikube on your local machine, which
    is a one-node Kubernetes simulator you can use to try out all of the examples
    in this chapter, and also to test your own applications. Simulators are useful
    both to avoid wasting too much money on an actual cloud-based Kubernetes cluster,
    and to provide a different Kubernetes cluster to each developer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将展示如何在你的本地机器上安装和使用 minikube，这是一个单节点 Kubernetes 模拟器，你可以用它来尝试本章中的所有示例，也可以测试你自己的应用程序。模拟器在避免在实际基于云的
    Kubernetes 集群上浪费太多钱，并为每个开发者提供不同的 Kubernetes 集群方面都很有用。
- en: This chapter explains the fundamental Kubernetes concepts and then focuses on
    how to interact with a Kubernetes cluster and how to deploy a Kubernetes application.
    All concepts are put into practice with simple examples. We recommend reading
    *Chapter 11*, *Applying a Microservice Architecture to Your Enterprise Application*,
    before reading this chapter, since we will use concepts explained in previous
    chapters.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了 Kubernetes 的基本概念，然后重点介绍如何与 Kubernetes 集群交互以及如何部署 Kubernetes 应用程序。所有概念都通过简单的示例进行实践。我们建议在阅读本章之前先阅读第
    11 章“将微服务架构应用于您的企业应用”，因为我们将在本章中使用前面章节中解释的概念。
- en: 'More specifically, in this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，在本章中，我们将涵盖以下主题：
- en: Kubernetes basics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 基础
- en: Interacting with Azure Kubernetes clusters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Azure Kubernetes 集群交互
- en: Advanced Kubernetes concepts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级 Kubernetes 概念
- en: By the end of this chapter, you will have learned how to implement and deploy
    a complete solution using Azure Kubernetes Service.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何使用 Azure Kubernetes 服务（AKS）实现和部署一个完整的解决方案。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, you will require the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你需要以下内容：
- en: Visual Studio 2022 free Community Edition or better, with all the database tools
    installed, or any other `.yaml` file editor, such as Visual Studio Code.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022 免费社区版或更高版本，已安装所有数据库工具，或任何其他 `.yaml` 文件编辑器，例如 Visual Studio
    Code。
- en: A free Azure account. The *Creating an Azure account* section in *Chapter 1*,
    *Understanding the Importance of Software Architecture*, explains how to create
    one.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个免费的 Azure 账户。第 1 章“理解软件架构的重要性”中的“*创建 Azure 账户*”部分解释了如何创建一个。
- en: An optional minikube installation. Installation instructions will be given in
    the *Using minikube* section of this chapter.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的 minikube 安装。安装说明将在本章的“使用 minikube”部分提供。
- en: The code for this chapter is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在 [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)
    找到。
- en: Kubernetes basics
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 基础
- en: Kubernetes is an advanced open source software for managing distributed applications
    running on a computer network. Kubernetes can be used on your private machine’s
    cluster, or you can use hardware-scalable Kubernetes offerings from all main cloud
    providers. This kind of software is called an **orchestrator** since it dynamically
    allocates microservices to the available hardware resources in order to maximize
    performance. Moreover, orchestrators like Kubernetes provide stable virtual addresses
    to microservices that they move around from one machine to another, thus changing
    their physical addresses. At the time of writing, Kubernetes is the most widespread
    orchestrator and the *de facto* standard for cluster orchestration that can be
    used with a wide ecosystem of tools and applications. While not being tied to
    specific languages or frameworks, Kubernetes is a fundamental tool for managing
    hardware resources and communications in .NET distributed applications based on
    microservices. This section introduces the basic Kubernetes concepts and entities.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一种用于管理在计算机网络上运行的分布式应用程序的高级开源软件。Kubernetes 可以用于您的私有机器的集群，或者您可以使用所有主要云提供商的硬件可扩展
    Kubernetes 产品。这种软件被称为**编排器**，因为它动态地将微服务分配给可用的硬件资源，以最大化性能。此外，像 Kubernetes 这样的编排器为它们在机器之间移动的微服务提供稳定的虚拟地址，从而改变它们的物理地址。在撰写本文时，Kubernetes
    是最广泛使用的编排器，是集群编排的*事实标准*，可以与广泛的工具和应用程序生态系统一起使用。虽然 Kubernetes 不绑定到特定的语言或框架，但它是在基于微服务的
    .NET 分布式应用程序中管理硬件资源和通信的基本工具。本节介绍了 Kubernetes 的基本概念和实体。
- en: A Kubernetes cluster is a cluster of virtual machines running the Kubernetes
    orchestrator.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 集群是运行 Kubernetes 编排器的虚拟机集群。
- en: '![](img/B19820_20_01.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_20_01.png)'
- en: 'Figure 20.1: Computer network equipped with Kubernetes'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.1：配备 Kubernetes 的计算机网络
- en: Generally, Kubernetes is installed on specific machines referred to as **master
    nodes**, while all other computers simply run an interface software that connects
    with the software running on the master nodes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Kubernetes 安装在称为**主节点**的特定机器上，而所有其他计算机仅运行一个连接到主节点上运行的软件的接口软件。
- en: The virtual machines composing the cluster are called **nodes**. The smallest
    software unit we can deploy on Kubernetes is not a single application, but an
    aggregate of containerized applications called **Pod**. While Kubernetes supports
    various types of containers, the most commonly used container type is Docker,
    which we analyzed in *Chapter 11*, *Applying a Microservice Architecture to Your
    Enterprise Application*, so we will confine our discussion here to Docker. Pods
    are aggregates of Docker images, each containing one of your .NET microservices
    or microservices implemented with other technologies.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 组成集群的虚拟机被称为**节点**。我们可以在 Kubernetes 上部署的最小软件单元不是一个单独的应用程序，而是一组容器化应用程序的集合，称为**Pod**。虽然
    Kubernetes 支持各种类型的容器，但最常用的容器类型是 Docker，这在我们的第 11 章*将微服务架构应用于您的企业应用程序*中进行了分析，因此我们将在这里仅限于讨论
    Docker。Pod 是 Docker 图像的集合，每个图像都包含您的 .NET 微服务或使用其他技术实现的微服务。
- en: More specifically, Pods are sets of Docker images constrained to be placed together
    on the same node during the overall life of the application. They can be moved
    to other nodes, but they must be moved together. This means that they can easily
    communicate through localhost ports. Communication between different Pods, however,
    is more complex since the IP addresses of Pods are ephemeral resources because
    Pods have no fixed node where they run, but rather are moved from one node to
    another by the orchestrator. Moreover, Pods may be replicated to increase performance,
    so, in general, it makes no sense to address a message to a specific Pod; instead,
    we address it to any of the identical replicas of the same Pod.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，Pod 是在应用程序的整体生命周期中必须放置在同一节点上的 Docker 图像集合。它们可以被移动到其他节点，但必须一起移动。这意味着它们可以通过
    localhost 端口轻松通信。然而，不同 Pod 之间的通信更为复杂，因为 Pod 的 IP 地址是短暂的资源，因为 Pod 没有固定的运行节点，而是由编排器从一个节点移动到另一个节点。此外，Pod
    可能会被复制以提高性能，因此，通常将消息发送到特定的 Pod 没有意义；相反，我们将它发送到同一 Pod 的任何相同副本。
- en: 'Cluster nodes and Pods are managed by master nodes that communicate with cluster
    administrators through an API server, as shown in the following diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 集群节点和 Pod 由主节点管理，主节点通过 API 服务器与集群管理员通信，如下所示：
- en: '![](img/B19820_20_02.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_20_02.png)'
- en: 'Figure 20.2: Kubernetes cluster'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.2：Kubernetes 集群
- en: The scheduler allocates Pods to nodes according to the administrator constraints,
    while the controller manager groups several daemons that monitor the cluster’s
    actual state and try to move it toward the desired state declared through the
    API server. There are controllers for several Kubernetes resources, from Pod replicas
    to communication facilities. In fact, each resource has some target objectives
    to be maintained while the application runs, and the controller verifies these
    objectives are actually achieved, possibly triggering corrective actions if not,
    such as moving some Pods running too slowly to less crowded nodes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器根据管理员的约束将Pod分配到节点，同时控制器管理器将多个守护进程分组，这些守护进程监控集群的实际状态并尝试将其移动到通过API服务器声明的期望状态。有几个控制器用于Kubernetes资源，从Pod副本到通信设施。实际上，每个资源在应用程序运行期间都有一些需要保持的目标目标，控制器会验证这些目标是否真正实现，如果没有实现，可能会触发纠正措施，例如将运行速度过慢的一些Pod移动到更少拥挤的节点。
- en: The kubelet manages the interaction of each non-master node with the master
    nodes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: kubelet管理每个非主节点与主节点之间的交互。
- en: In Kubernetes, communication between Pods is handled by resources called **Services**
    that are assigned virtual addresses by the Kubernetes infrastructure and that
    forward their communications to sets of identical Pods. In short, Services are
    Kubernetes’ way of assigning consistent virtual addresses to sets of Pod replicas.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，Pod之间的通信由称为**服务**的资源处理，这些服务由Kubernetes基础设施分配虚拟地址，并将它们的通信转发到一组相同的Pod。简而言之，服务是Kubernetes为Pod副本集分配一致虚拟地址的方式。
- en: All Kubernetes entities may be assigned name-value pairs called **labels** that
    are used to reference them through a pattern-matching mechanism. More specifically,
    Selectors select Kubernetes entities by listing labels they must have.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的所有实体都可以分配名为**标签**的键值对，这些标签通过模式匹配机制来引用。更具体地说，选择器通过列出它们必须具有的标签来选择Kubernetes实体。
- en: Thus, for instance, all Pods that receive traffic from the same Service are
    selected by specifying labels that they must have in the Service definition.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，所有从同一服务接收流量的Pod都会通过指定它们在服务定义中必须具有的标签来选择。
- en: The way a Service routes its traffic to all connected Pods depends on the way
    Pods are organized. Stateless Pods are organized in so-called `ReplicaSets`. `ReplicaSets`
    have a unique virtual address assigned to the whole group and traffic is split
    equally among all Pods of the group.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 服务路由其流量到所有连接Pod的方式取决于Pod的组织方式。无状态Pod组织在所谓的`ReplicaSets`中。`ReplicaSets`为整个组分配一个唯一的虚拟地址，流量在组中的所有Pod之间平均分配。
- en: 'Stateful Kubernetes Pod replicas are organized into so-called `StatefulSets`.
    `StatefulSets` use sharding to split the traffic between all their Pods. For this
    reason, Kubernetes Services assign a different name to each Pod of the `StatefulSet`
    they are connected to. These names look like the following: `basename-0.<base
    URL>`, `basename-1.<base URL>`, ..., `basename-n.<base URL>`. This way, message
    sharding is easily accomplished as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 状态化Kubernetes Pod副本组织成所谓的`StatefulSets`。`StatefulSets`使用分片来分割所有Pod之间的流量。因此，Kubernetes服务为它们连接到的`StatefulSet`中的每个Pod分配不同的名称。这些名称看起来如下：`basename-0.<base
    URL>`，`basename-1.<base URL>`，...，`basename-n.<base URL>`。这样，消息分片就可以轻松完成如下：
- en: Each time a message must be sent to a `StatefulSet` composed of *N* replicas,
    you compute a hash between `0` and `N-1`, say `X`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次必须向由*N*个副本组成的`StatefulSet`发送消息时，你会在`0`和`N-1`之间计算一个哈希值，比如说`X`。
- en: Add the postfix `X` to a base name to get a cluster address, such as `basename-x.<base
    URL>`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基础名称后添加后缀`X`以获取集群地址，例如`basename-x.<base URL>`。
- en: Send the message to the `basename-x.<base URL> cluster address`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将消息发送到`basename-x.<base URL>`集群地址。
- en: Kubernetes has no predefined storing facilities, and you can’t use node disk
    storage since Pods are moved between the available nodes, so long-term storage
    must be provided with sharded cloud databases or with other kinds of cloud storage.
    While each Pod in a StatefulSet can access a sharded cloud database with the usual
    connection string technique, Kubernetes offers a technique to abstract disk-like
    cloud storage provided by the external Kubernetes cluster environment. We will
    describe this storage in the *Advanced Kubernetes concepts* section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes没有预定义的存储设施，你不能使用节点磁盘存储，因为Pod会在可用节点之间移动，所以必须使用分片云数据库或其他类型的云存储来提供长期存储。虽然每个StatefulSet中的Pod都可以使用常规连接字符串技术访问分片云数据库，但Kubernetes提供了一种技术来抽象外部Kubernetes集群环境提供的类似磁盘的云存储。我们将在*高级Kubernetes概念*部分描述这种存储。
- en: All Kubernetes entities mentioned in this short introduction can be defined
    in a `.yaml` file, which, once deployed to a Kubernetes cluster, causes the creation
    of all entities defined in the file. The subsection that follows describes `.yaml`
    files, while the other subsections thereafter describe in detail all the basic
    Kubernetes objects mentioned so far, and explain how to define them in a `.yaml`
    file. Other Kubernetes objects will be described throughout the chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的介绍中提到的所有 Kubernetes 实体都可以在 `.yaml` 文件中定义，一旦部署到 Kubernetes 集群，就会在文件中定义的所有实体被创建。接下来的子节描述
    `.yaml` 文件，而之后的子节将详细描述迄今为止提到的所有基本 Kubernetes 对象，并解释如何在 `.yaml` 文件中定义它们。其他 Kubernetes
    对象将在本章的其余部分进行描述。
- en: .yaml files
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .yaml 文件
- en: The desired configuration of a cluster and the structure of Kubernetes objects
    are described by the developer with a language called YAML, and are packaged in
    files with a `.yaml` extension.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者使用一种名为 YAML 的语言来描述集群的期望配置和 Kubernetes 对象的结构，并将它们打包在具有 `.yaml` 扩展名的文件中。
- en: '`.yaml` files, like JSON files, can be used to describe nested objects and
    collections in a human-readable way, but they do it with a different syntax. You
    have objects and lists, but object properties are not surrounded by `{}`, and
    lists are not surrounded by `[]`. Instead, nested objects are declared by simply
    indenting their content with spaces. The number of spaces can be freely chosen,
    but once they’ve been chosen, they must be used consistently.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`.yaml` 文件，类似于 JSON 文件，可以用一种易于阅读的方式描述嵌套对象和集合，但它们使用的是不同的语法。您有对象和列表，但对象的属性不是用
    `{}` 包围，列表也不是用 `[]` 包围。相反，通过简单地使用空格缩进来声明嵌套对象。空格的数量可以自由选择，但一旦选择，就必须始终如一地使用。'
- en: List items can be distinguished from object properties by preceding them with
    a hyphen (`-`).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表项可以通过在它们前面加上破折号 (`-`) 来与对象属性区分开来。
- en: 'Here is an example involving nested objects and collections:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个涉及嵌套对象和集合的示例：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding `Person` object has a `Spouse` nested object and a nested collection
    of addresses.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `Person` 对象有一个嵌套的 `Spouse` 对象和一个嵌套的地址集合。
- en: 'The same example in JSON would be:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSON 中的相同示例将是：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the syntax is more readable, since it avoids the overhead of
    parentheses.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，语法更易于阅读，因为它避免了括号的冗余。
- en: '`.yaml` files can contain several sections, each defining a different entity,
    that are separated by a line containing the `---` string. Comments are preceded
    by a `#` symbol, which must be repeated on each comment line.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`.yaml` 文件可以包含多个部分，每个部分定义不同的实体，它们之间由包含 `---` 字符串的行分隔。注释前有一个 `#` 符号，必须在每行注释中重复。'
- en: 'Each section starts with the declaration of the Kubernetes API group and version.
    In fact, not all objects belong to the same API group. For objects that belong
    to the `core` API group, we can specify just the API version, as in the following
    example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分都以 Kubernetes API 组和版本的声明开始。实际上，并非所有对象都属于同一个 API 组。对于属于 `core` API 组的对象，我们只需指定
    API 版本即可，如下例所示：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'While objects belonging to different API groups must also specify the API name,
    as in the following example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 而属于不同 API 组的对象也必须指定 API 名称，如下例所示：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the next subsection, we analyze ReplicaSets and the Deployments that are
    built on top of them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，我们将分析建立在它们之上的 ReplicaSets 和 Deployments。
- en: ReplicaSets and Deployments
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReplicaSets 和 Deployments
- en: The most important building block of Kubernetes applications is the ReplicaSet,
    that is, a Pod replicated *N* times. Usually, however, you use a more complex
    object that is built on top of the ReplicaSet – the Deployment. Deployments not
    only create a ReplicaSet, but also monitor them to ensure that the number of replicas
    is kept constant regardless of hardware faults and other events that might involve
    the ReplicaSets. In other words, they are a declarative way of defining ReplicaSets
    and Pods.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 应用程序最重要的构建块是 ReplicaSet，即 Pod 被复制 *N* 次。然而，通常您会使用一个更复杂的对象，它是建立在 ReplicaSet
    之上的——Deployment。Deployment 不仅创建 ReplicaSet，还监控它们以确保副本数量在硬件故障和其他可能涉及 ReplicaSet
    的事件发生时保持恒定。换句话说，它们是定义 ReplicaSet 和 Pod 的声明性方式。
- en: 'Replicating the same functionalities, and thus the same Pods, is the simplest
    operation to optimize for performance: the more replicas we create of the same
    Pod, the more hardware resources and threads must be made available for the functionality
    encoded by that Pod. Thus, when we discover that a functionality becomes a bottleneck
    in the system, we may just increase the number of replicas of the Pod that encodes
    that functionality.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 复制相同的函数，从而复制相同的Pod，是优化性能的最简单操作：我们为相同的Pod创建的副本越多，就必须为该Pod编码的功能提供更多的硬件资源和线程。因此，当我们发现某个功能成为系统中的瓶颈时，我们可能只需增加编码该功能的Pod副本的数量。
- en: 'Each Deployment has a name (`metadata->name`), an attribute that specifies
    the desired number of replicas (`spec->replicas`), a key-value pair (`spec ->
    selector-> matchLabels`) that selects the Pods to monitor, and a template (`spec->template`)
    that specifies how to build the Pod replicas:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部署都有一个名称（`metadata->name`），一个指定所需副本数的属性（`spec->replicas`），一个键值对（`spec -> selector->
    matchLabels`），它选择要监控的Pod，以及一个模板（`spec->template`），它指定如何构建Pod副本：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`namespace` is optional and, if not provided, a namespace called `default`
    is assumed. Namespaces are a way of keeping separate the objects of a Kubernetes
    cluster. For instance, a cluster can host the objects of two completely independent
    applications, each placed in a separate `namespace` in order to prevent possible
    name collisions. In a few words, Kubernetes namespaces have the same purpose as
    .NET namespaces: preventing name collisions.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`namespace`是可选的，如果没有提供，则假定一个名为`default`的命名空间。命名空间是保持Kubernetes集群中对象分离的一种方式。例如，一个集群可以托管两个完全独立的应用程序的对象，每个应用程序都放置在单独的`namespace`中，以防止可能的重名冲突。简而言之，Kubernetes命名空间与.NET命名空间具有相同的目的：防止重名冲突。'
- en: Indented inside the template is the definition of the Pod to replicate. Complex
    objects such as Deployments can also contain other kinds of templates, for instance,
    a template of disk-like memory required by the external environment. We will discuss
    this in more detail in the *Advanced Kubernetes concepts* section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板内部缩进的是要复制的Pod的定义。复杂的对象，如部署，也可以包含其他类型的模板，例如，外部环境所需的类似磁盘的内存模板。我们将在*高级Kubernetes概念*部分详细讨论这一点。
- en: 'In turn, the Pod template contains a `metadata` section with the labels used
    to select the Pods, and a `spec` section with a list of all of the containers:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，Pod模板包含一个`metadata`部分，其中包含用于选择Pod的标签，以及一个`spec`部分，其中包含所有容器的列表：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Each container has a name and must specify the name of the Docker image to use
    to create the containers. If the Docker image is not contained in the public Docker
    registry, the name must be a URI that also includes the repository’s location.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器都有一个名称，并且必须指定用于创建容器的Docker镜像的名称。如果Docker镜像不在公共Docker注册表中，名称必须是一个URI，它还包括存储库的位置。
- en: Then, containers must specify the memory and CPU resources that they need to
    be created in the `resources->requests` object. A Pod replica is created only
    if these resources are currently available. The `resources->limits` object, instead,
    specifies the maximum resources a container replica can use. If, during the container
    execution, these limits are exceeded, action is taken to limit them. More specifically,
    if the CPU limit is exceeded, the container is throttled (its execution is stopped
    to restore its CPU consumption), while, if the memory limits are exceeded, the
    container is restarted. `containerPort` must be the port exposed by the container.
    Here, we can also specify further information, such as the protocol used.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，容器必须指定它们在`resources->requests`对象中需要的内存和CPU资源才能被创建。只有当这些资源当前可用时，才会创建Pod副本。相反，`resources->limits`对象指定了容器副本可以使用的最大资源。如果在容器执行期间超过了这些限制，将采取行动来限制它们。更具体地说，如果CPU限制被超过，容器将被节流（其执行停止以恢复其CPU消耗），而如果内存限制被超过，容器将被重启。`containerPort`必须是容器暴露的端口。在这里，我们还可以指定其他信息，例如使用的协议。
- en: CPU time is expressed in millicores; `1,000` millicores means `100%` of the
    CPU time, while memory is expressed in mebibytes (`1Mi` `=` `1,024*1,024 bytes`),
    or other units. `env` lists all the operating system environment variables to
    pass to the containers with their values.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: CPU时间以毫芯为单位表示；`1,000`毫芯表示`100%`的CPU时间，而内存以兆字节（`1Mi` `=` `1,024*1,024 bytes`）或其他单位表示。`env`列出所有传递给容器的操作系统环境变量及其值。
- en: Both containers and Pod templates can contain other fields, such as properties
    that define virtual files, and properties that define commands that return the
    readiness and the health state of the container. We will analyze these fields
    in the *Advanced Kubernetes concepts* section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和Pod模板都可以包含其他字段，例如定义虚拟文件属性和定义返回容器就绪状态和健康状态的命令的属性。我们将在*高级Kubernetes概念*部分中分析这些字段。
- en: The following subsection describes Pod sets conceived to store state information.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下子部分描述了旨在存储状态信息的Pod集。
- en: StatefulSets
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: StatefulSets
- en: StatefulSets are very similar to ReplicaSets, but while the Pods of a ReplicaSet
    are indistinguishable processors that contribute in parallel to the same workload
    through load-balancing strategies, Pods in a StatefulSet have a unique identity
    and can contribute to the same workload only through sharding. This is because
    StatefulSets were conceived to store information, and information cannot be stored
    in parallel, merely split among several stores through sharding.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSet与ReplicaSet非常相似，但ReplicaSet中的Pod是不可区分的处理器，它们通过负载均衡策略并行贡献相同的工作负载，而StatefulSet中的Pod具有唯一的标识，只能通过分片来贡献相同的工作负载。这是因为StatefulSet是为了存储信息而设计的，信息不能并行存储，只能通过分片在几个存储之间分割。
- en: For the same reason, each Pod instance is always kept tied to any virtual disk
    space it requires (see the *Advanced Kubernetes concepts* section) so that each
    Pod instance is responsible for writing to a specific store.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同样的原因，每个Pod实例始终与其所需的任何虚拟磁盘空间保持关联（参见*高级Kubernetes概念*部分），这样每个Pod实例就负责写入特定的存储。
- en: Moreover, StatefulSets’ Pod instances have ordinal numbers attached to them.
    They are started in sequence according to these numbers, and they are stopped
    in reverse order. If the StatefulSet contains *N* replicas, these numbers go from
    `0` to `N-1`. Moreover, a unique name for each instance is obtained by chaining
    the Pod name specified in the template with the instance ordinal, in the following
    way – `<pod name>-<instance ordinal>`. Thus, instance names will be something
    like `mypodname-0`, `mypodname-1`, and so on. As we will see in the *Services*
    subsection, instance names are used to build unique cluster network URIs for all
    instances, so that other Pods can communicate with a specific instance of a StateFulSet
    Pod.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，StatefulSets的Pod实例还附加了序号。它们根据这些序号按顺序启动，并按相反的顺序停止。如果StatefulSet包含*N*个副本，这些数字从`0`到`N-1`。此外，每个实例都有一个独特的名称，通过将模板中指定的Pod名称与实例序号链接在一起获得，如下所示
    – `<pod name>-<instance ordinal>`。因此，实例名称将类似于`mypodname-0`、`mypodname-1`等。正如我们将在*服务*子部分中看到的那样，实例名称用于为所有实例构建唯一的集群网络URI，以便其他Pod可以与StateFulSet
    Pod的特定实例通信。
- en: Since Pods in a StateFulSet have memory, each of them can only serve the requests
    that can be processed with the data contained in them. Therefore, in order to
    take advantage of several Pods in a StatefulSets, we must share the whole data
    space in easy-to-compute subsets. This technique is called sharding. For instance,
    Pods of a StatefulSet that handle customers could each be assigned a different
    set of customer names according to their first letters. One could handle all customers
    whose names start with letters in the interval A-C, another the names in the interval
    D-F, and so on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于StatefulSet中的Pod具有内存，每个Pod只能处理包含在其内的数据可以处理的需求。因此，为了利用StatefulSet中的多个Pod，我们必须在易于计算的子集中共享整个数据空间。这种技术称为分片。例如，处理客户的StatefulSet的Pod可以根据其首字母分配不同的客户名称集。一个可以处理所有以A-C字母开头的客户，另一个可以处理以D-F字母开头的名称，依此类推。
- en: 'Here is a typical StatefulSet definition:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个典型的StatefulSet定义：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The template part is the same as that of Deployments. The main difference between
    StatefulSets and Deployments is the `serviceName` field. This specifies the name
    of a service that must be connected with the StatefulSet to provide unique network
    addresses for all Pod instances. We will discuss this subject in more detail in
    the *Services* subsection. Moreover, usually, StatefulSets use some form of storage.
    We will discuss this in detail in the *Advanced Kubernetes concepts* section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 模板部分与Deployments相同。StatefulSets与Deployments之间的主要区别是`serviceName`字段。它指定了必须与StatefulSet连接的服务名称，以为所有Pod实例提供唯一的网络地址。我们将在*服务*子部分中更详细地讨论这个问题。此外，通常StatefulSets使用某种形式的存储。我们将在*高级Kubernetes概念*部分中详细讨论这一点。
- en: It is also worth pointing out that the default order of the creation and stop
    strategy of StatefulSets can be changed by specifying an explicit `Parallel` value
    for the `spec->podManagementPolicy` property (the default value is `OrderedReady`).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是，可以通过指定`spec->podManagementPolicy`属性的显式`Parallel`值来更改StatefulSets创建和停止策略的默认顺序（默认值是`OrderedReady`）。
- en: 'The following table summarizes the differences between StatefulSets and ReplicaSets:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了StatefulSets和ReplicaSets之间的差异：
- en: '| **Features** | **StatefulSets** | **ReplicaSets** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **StatefulSets** | **ReplicaSets** |'
- en: '| Unique address for the whole set | No. Each Pod in the set has a different
    address and takes care of a different kind of requests. | Yes. Pods in ReplicaSets
    are indistinguishable so each request can be served by any of them. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 整个集合的唯一地址 | No. 集合中的每个Pod都有一个不同的地址，并负责处理不同类型的请求。 | Yes. ReplicaSet中的Pod是不可区分的，因此每个请求可以由其中的任何一个Pod处理。
    |'
- en: '| Number of replicas can be increased during application lifetime | No. Since
    each Pod is in charge of a specific kind of requests and has a unique address,
    we can''t add more Pods. | Yes. Since Pods are indistinguishable, more Pods can''t
    cause problems, but just improve the performance of the whole set. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 应用生命周期内可以增加副本数量 | No. 由于每个Pod负责特定类型的请求并具有唯一的地址，因此我们无法添加更多的Pod。 | Yes. 由于Pod是不可区分的，更多的Pod不会引起问题，但只会提高整个集合的性能。
    |'
- en: '| Pods can store permanent data inside of them | Yes, they are designed for
    this. Requests are issued to Pods with the sharding technique. | No, because they
    are designed to be undistinguishable, and storing a specific datum in a specific
    Pod would make a Pod different from the others in the set. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| Pods可以在其中存储永久数据 | Yes, they are designed for this. Requests are issued to
    Pods with the sharding technique. | No, because they are designed to be indistinguishable,
    and storing a specific datum in a specific Pod would make a Pod different from
    the others in the set. |'
- en: 'Table 20.1: StataefulSets versus ReplicaSets'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表20.1：StatefulSets与ReplicaSets对比
- en: The following subsection describes how to provide stable network addresses to
    both ReplicaSets and StatefulSets.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将描述如何为ReplicaSets和StatefulSets提供稳定的网络地址。
- en: Services
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: Since Pod instances can be moved between nodes, they have no stable IP address
    attached to them. Services take care of assigning a unique and stable virtual
    address to a whole ReplicaSet and of load balancing the traffic to all its instances.
    Services are not software objects created in the cluster, but just an abstraction
    of the various settings and activities needed to implement their functionalities.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Pod实例可以在节点之间移动，它们没有附加到它们上的稳定IP地址。服务负责为整个ReplicaSet分配一个唯一且稳定的虚拟地址，并对所有实例的流量进行负载均衡。服务不是在集群中创建的软件对象，而只是实现其功能所需的各种设置和活动的抽象。
- en: Services work at level 4 of the protocol stack, so they understand protocols
    such as TCP, but they aren’t able to perform, for instance, HTTP-specific actions/transformations,
    such as ensuring a secure HTTPS connection. Therefore, if you need to install
    HTTPS certificates on the Kubernetes cluster, you need a more complex object that
    is capable of interacting at level 7 of the protocol stack. The `Ingress` object
    was conceived for this. We will discuss this in the next subsection.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 服务在协议栈的第4层工作，因此它们理解TCP等协议，但它们无法执行HTTP特定的操作/转换，例如确保安全的HTTPS连接。因此，如果您需要在Kubernetes集群上安装HTTPS证书，则需要一个能够与协议栈第7层交互的更复杂对象。`Ingress`对象就是为了这个目的而设计的。我们将在下一个子节中讨论这一点。
- en: Services also handle assigning a unique virtual address to each instance of
    a StatefulSet. In fact, there are various kinds of Services; some were conceived
    for ReplicaSets and others for StatefulSets.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 服务还负责为StatefulSet的每个实例分配一个唯一的虚拟地址。实际上，存在各种类型的服务；一些是为ReplicaSets设计的，而另一些是为StatefulSets设计的。
- en: A `ClusterIP` service type is assigned a unique cluster internal IP address.
    It specifies the ReplicaSets or Deployments it is connected to through label pattern
    matching. It uses tables maintained by the Kubernetes infrastructure to load balance
    the traffic it receives between all the Pod instances to which it is connected.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 被分配了唯一集群内部IP地址的`ClusterIP`服务类型。它通过标签模式匹配指定它连接到的ReplicaSets或Deployments。它使用Kubernetes基础设施维护的表来在它连接的所有Pod实例之间负载均衡它接收到的流量。
- en: Therefore, other Pods can communicate with the Pods connected to a Service by
    interacting with this Service that is assigned the stable network name `<service
    name>.<service namespace>.svc.cluster.local`. Since they are just assigned local
    IP addresses, a `ClusterIP` service can’t be accessed from outside the Kubernetes
    cluster.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，其他 Pods 可以通过与此服务交互来与连接到服务的 Pods 进行通信，该服务被分配了稳定的网络名称 `<service name>.<service
    namespace>.svc.cluster.local`。由于它们只是分配了本地 IP 地址，因此 `ClusterIP` 服务无法从 Kubernetes
    集群外部访问。
- en: A ClusterIP is the usual communication choice for Deployments and ReplicaSets
    that do not communicate with anything outside of their Kubernetes cluster.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不与 Kubernetes 集群外部进行通信的 Deployments 和 ReplicaSets，ClusterIP 是通常的通信选择。
- en: 'Here is the definition of a typical `ClusterIP` service:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是典型 `ClusterIP` 服务的定义：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each Service can work on several ports and can route any port (`port`) to the
    ports exposed by the containers (`targetPort`). However, it is very often the
    case that `port = targetPort`. Ports can be given names, but these names are optional.
    Also, the specification of the protocol is optional; when not explicitly specified,
    all supported level 4 protocols are allowed. The `spec->selector` property specifies
    all the name/value pairs that select the Pods for the Service to which to route
    the communications it receives.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务可以在多个端口上工作，并将任何端口 (`port`) 路由到容器暴露的端口 (`targetPort`)。然而，`port = targetPort`
    的情况非常常见。端口可以命名，但这些名称是可选的。此外，协议的指定也是可选的；当未明确指定时，允许所有受支持的四层协议。`spec->selector` 属性指定了所有用于选择要路由通信的服务的
    Pods 的名称/值对。
- en: Since a `ClusterIP` service can’t be accessed from outside the Kubernetes cluster,
    we need other Service types to expose a Kubernetes application on a public IP
    address.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ClusterIP` 服务无法从 Kubernetes 集群外部访问，我们需要其他服务类型来在公共 IP 地址上暴露 Kubernetes 应用程序。
- en: '`NodePort`-type Services are the simplest way to expose Pods to the outside
    world. In order to implement a `NodePort` service, the same port `x` is opened
    on all nodes of the Kubernetes cluster and each node routes the traffic it receives
    on this port to a newly created `ClusterIP` service.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`NodePort` 类型服务是将 Pods 暴露给外部世界的最简单方式。为了实现 `NodePort` 服务，在 Kubernetes 集群的每个节点上打开相同的端口
    `x`，并且每个节点将接收到的此端口上的流量路由到一个新创建的 `ClusterIP` 服务。'
- en: 'In turn, the `ClusterIP` service routes its traffic to all Pods selected by
    the service:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，`ClusterIP` 服务将其流量路由到服务所选的所有 Pods：
- en: '![Diagram  Description automatically generated](img/B19820_20_03.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 描述自动生成](img/B19820_20_03.png)'
- en: 'Figure 20.3: NodePort service'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.3：NodePort 服务
- en: Therefore, you can simply communicate with port `x` through a public IP of any
    cluster node in order to access the Pods connected to the `NodePort` service.
    Of course, the whole process is completely automatic and hidden from the developer,
    whose only preoccupation is getting the port number `x` so they know where to
    forward the external traffic.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以通过任何集群节点的公共 IP 地址上的端口 `x` 进行通信，以访问连接到 `NodePort` 服务的 Pods。当然，整个过程是完全自动的，并且对开发者隐藏，开发者的唯一关注点是获取端口号
    `x`，以便知道如何转发外部流量。
- en: 'The definition of a `NodePort` service is similar to the definition of a `ClusterIP`
    service, the only difference being that they specify a value of `NodePort` for
    the `spec->type` property:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`NodePort` 服务的定义与 `ClusterIP` 服务的定义类似，唯一的区别是它们为 `spec->type` 属性指定了 `NodePort`
    的值：'
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As a default, a node port `x` in the range 30000-32767 is automatically chosen
    for each `targetPort` specified by the `Service`. The `port` property associated
    with each `targetPort` is meaningless for `NodePort` Services since all traffic
    passes through the selected node port `x`, and, by convention, is set to the same
    value as the `targetPort`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，为每个由 `Service` 指定的 `targetPort` 自动选择范围在 30000-32767 之间的节点端口 `x`。对于 `NodePort`
    服务，与每个 `targetPort` 相关的 `port` 属性是无效的，因为所有流量都通过选定的节点端口 `x` 传递，并且按照惯例，将其设置为与 `targetPort`
    相同的值。
- en: 'The developer can also set the NodePort `x` directly through a `nodePort` property:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者还可以通过 `nodePort` 属性直接设置 NodePort `x`：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When the Kubernetes cluster is hosted on a cloud, the more convenient way to
    expose some Pods to the outside world is through a `LoadBalancer` service, in
    which case the Kubernetes cluster is exposed to the outside world through a level
    4 load balancer of the selected cloud provider.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Kubernetes 集群托管在云上时，将一些 Pods 暴露给外部世界的更方便的方式是通过 `LoadBalancer` 服务，在这种情况下，Kubernetes
    集群通过所选云提供商的第四层负载均衡器暴露给外部世界。
- en: A LoadBalancer is the usual communication choice for Deployments and ReplicaSets
    that do communicate outside of their Kubernetes cluster but don’t need advanced
    HTTP features.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器（LoadBalancer）通常是用于部署（Deployments）和副本集（ReplicaSets）的通信选择，这些部署和副本集在其 Kubernetes
    集群外部进行通信，但不需要高级 HTTP 功能。
- en: 'The definition of a `LoadBalancer` service is similar to that of a `ClusterIp`
    service, the only difference being that the `spec->type` property must be set
    to `LoadBalancer`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadBalancer` 服务的定义与 `ClusterIp` 服务的定义类似，唯一的区别是必须将 `spec->type` 属性设置为 `LoadBalancer`：'
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If no further specification is added, a dynamic public IP is randomly assigned.
    However, if a specific public IP address is required, it can be set as a public
    IP address for the cluster load balancer by specifying it in the `spec->loadBalancerIP`
    property:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有添加进一步的指定，将随机分配一个动态公共 IP。然而，如果需要特定的公共 IP 地址，可以通过在 `spec->loadBalancerIP`
    属性中指定它来将其设置为集群负载均衡器的公共 IP 地址：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In **Azure Kubernetes Service** (**AKS**), you must also specify the resource
    group where the IP address was allocated in an annotation:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Azure Kubernetes 服务**（**AKS**）中，你还必须在注释中指定分配 IP 地址的资源组：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In AKS, you can remain with a dynamic IP address, but you can get a public
    static domain name of the type `<my-service-label>.<location>.cloudapp.azure.com`,
    where `<location>` is the geographic label you have chosen for your resources.
    `<my-service-label>` is a label that you have verified that makes the previous
    domain name unique. The chosen label must be declared in an annotation of your
    service, as shown here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AKS 中，你可以保持使用动态 IP 地址，但你也可以获得一个公共静态域名，类型为 `<my-service-label>.<location>.cloudapp.azure.com`，其中
    `<location>` 是你为资源选择的地理位置标签。《my-service-label》是一个你验证过的标签，使得上述域名唯一。《my-service-label》必须在你的服务注释中声明，如下所示：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'StatefulSets don’t need any load balancing since each Pod instance has its
    own identity, but do require a unique URL address for each Pod instance. This
    unique URL is provided by the so-called **headless Services**. Headless Services
    are defined like `ClusterIP` services, the only difference being that they have
    their `spec->clusterIP` property set to `none`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`StatefulSets` 不需要任何负载均衡，因为每个 Pod 实例都有自己的标识，但确实需要为每个 Pod 实例提供一个唯一的 URL 地址。这个唯一的
    URL 由所谓的 **无头服务** 提供。无头服务的定义与 `ClusterIP` 服务类似，唯一的区别是它们将 `spec->clusterIP` 属性设置为
    `none`：'
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All StatefulSets handled by a headless Service must place the Service name in
    their `spec-> serviceName` property, as already stated in the *StatefulSets* subsection.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所有由无头服务处理的 `StatefulSets` 必须在其 `spec->serviceName` 属性中放置服务名称，正如在 *StatefulSets*
    子节中已经说明的那样。
- en: The unique name provided by a headless Service to all `StatefulSets` Pod instances
    it handles is `<unique pod name>.<service name>.<namespace>.svc.cluster.local`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 无头服务为它所处理的每个 `StatefulSets` Pod 实例提供的唯一名称是 `<unique pod name>.<service name>.<namespace>.svc.cluster.local`。
- en: Services only understand low-level protocols, such as TCP/IP, but most web applications
    are situated on the more sophisticated HTTP protocol. That’s why Kubernetes offers
    higher-level entities called I**ngresses** that are built on top of services.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 服务只理解低级协议，如 TCP/IP，但大多数 Web 应用程序都位于更复杂的 HTTP 协议上。这就是为什么 Kubernetes 提供了在服务之上构建的更高层次的实体，称为
    **Ingress**。
- en: Ingresses are fundamental in the implementation of all web-based applications
    that need support for HTTP. Moreover, since at the moment, a substantial amount
    of applications are web applications, ingresses are a **must** for all microservices
    applications. In particular, they are needed by all microservices based on ASP.NET
    Core, which we will discuss in the remainder of the book.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 入口对于所有需要 HTTP 支持的基于 Web 的应用程序的实施至关重要。此外，由于目前大量应用程序都是 Web 应用程序，入口对于所有微服务应用程序来说都是
    **必需的**。特别是，所有基于 ASP.NET Core 的微服务都需要它们，我们将在本书的剩余部分讨论这一点。
- en: The following subsection describes these and explains how to expose a set of
    Pods through a level 7 protocol load balancer, which can be used to get access
    to typical HTTP services, instead of through a `LoadBalancer` Service.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节描述了这些内容，并解释了如何通过第 7 层协议负载均衡器公开一组 Pod，这可以用来访问典型的 HTTP 服务，而不是通过 `LoadBalancer`
    服务。
- en: Ingresses
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入口（Ingresses）
- en: Ingresses were conceived to enable each application running in a Kubernetes
    cluster to expose an HTTP-based interface. This is a fundamental requirement for
    any orchestrator, since nowadays all microservices applications are web applications
    that interact with their clients through HTTP-based protocols. Moreover, Ingresses
    must be very efficient since all communications with the Kubernetes cluster will
    pass through them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 入口（Ingresses）的概念是为了使运行在 Kubernetes 集群中的每个应用程序都能够暴露基于 HTTP 的接口。这对于任何编排器来说都是一个基本要求，因为如今所有微服务应用程序都是
    Web 应用程序，它们通过基于 HTTP 的协议与客户端进行交互。此外，入口必须非常高效，因为所有与 Kubernetes 集群的通信都将通过它们进行。
- en: 'Accordingly, ingresses offer all of the typical services offered by an advanced
    and efficient web server. They provide the following services:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，入口提供了由高级和高效的 Web 服务器提供的所有典型服务。它们提供以下服务：
- en: HTTPS termination. They accept HTTPS connections and route them in HTTP format
    to any service in the cluster.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTPS 终结。它们接受 HTTPS 连接，并以 HTTP 格式将它们路由到集群中的任何服务。
- en: Name-based virtual hosting. They associate several domain names with the same
    IP address and route each domain, or `<domain>/<path prefix>`, to a different
    cluster Service.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于名称的虚拟主机。它们将多个域名与同一 IP 地址关联，并将每个域名或 `<domain>/<path prefix>` 路由到不同的集群服务。
- en: Load balancing.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡。
- en: An ingress is the usual communication choice for Deployments and ReplicaSets
    that do communicate outside of their Kubernetes cluster and need advanced HTTP
    features.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 入口是部署（Deployments）和副本集（ReplicaSets）的常规通信选择，这些部署和副本集需要与 Kubernetes 集群外部进行通信，并且需要高级
    HTTP 功能。
- en: Since rewriting all functionalities of an advanced web server from scratch would
    be substantially impossible, Ingresses rely on existing web servers to offer their
    services. More specifically, Kubernetes offers the possibility to add an interface
    module called Ingress Controllers to connect each Kubernetes cluster with an existing
    web server, such as NGINX and Apache.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从头开始重写高级 Web 服务器的所有功能基本上是不可能的，入口依赖于现有的 Web 服务器来提供服务。更具体地说，Kubernetes 提供了添加一个名为入口控制器（Ingress
    Controllers）的接口模块的可能性，以将每个 Kubernetes 集群与现有的 Web 服务器（如 NGINX 和 Apache）连接起来。
- en: Ingress Controllers are custom Kubernetes objects that must be installed in
    the cluster. They handle the interface between Kubernetes and the pre-existing
    web server software, which can be either an external web server or a web server
    that is part of the Ingress Controller installation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 入口控制器是自定义的 Kubernetes 对象，必须在集群中安装。它们处理 Kubernetes 与现有的 Web 服务器软件之间的接口，这可以是外部
    Web 服务器，也可以是 Ingress 控制器安装的一部分 Web 服务器。
- en: We will describe the installation of an Ingress Controller based on the NGINX
    web server software in the *Advanced Kubernetes concepts* section, as an example
    of the use of Helm. However, there are Ingress Controllers for all main web servers.
    The *Further reading* section contains information on how to install also an Ingress
    Controller that interfaces an external Azure Application Gateway.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *高级 Kubernetes 概念* 部分中描述基于 NGINX Web 服务器软件的入口控制器的安装，作为 Helm 使用的示例。然而，所有主要的
    Web 服务器都有入口控制器。*进一步阅读* 部分包含有关如何安装一个与外部 Azure 应用程序网关接口的入口控制器的信息。
- en: HTTPS termination and name-based virtual hosting (see the explanation of these
    terms at the beginning of this subsection) can be configured in the Ingress definition
    in a way that is independent of the chosen Ingress Controller, while the way load
    balancing is achieved depends on the specific Ingress Controller chosen and on
    its configuration. Some Ingress Controller configuration data can be passed in
    the `metadata-> annotations` field of the Ingress definition.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS 终结和基于名称的虚拟主机（有关这些术语的解释请参阅本小节开头）可以在入口定义中配置，方式独立于所选的入口控制器，而负载均衡的实现方式则取决于所选的具体入口控制器及其配置。一些入口控制器配置数据可以通过入口定义的
    `metadata-> annotations` 字段传递。
- en: 'Name-based virtual hosting is defined in the `spec-> rules` section of the
    Ingress definition:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 基于名称的虚拟主机在入口定义的 `spec-> rules` 部分中定义：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each rule specifies an optional hostname that can contain the `*` wildcard.
    If no hostname is provided, the rule matches all hostnames. For each rule, we
    can specify several paths, each redirected to a different service/port pair, where
    the service is referenced through its name. The way the match with each `path`
    is carried out depends on the value of `pathType`; if this value is `Prefix`,
    the specified `path` must be a prefix of any matching path. Otherwise, if this
    value is `Exact`, the match must be exact. Matches are case-sensitive.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个规则指定一个可选的主机名，它可以包含 `*` 通配符。如果没有提供主机名，则规则匹配所有主机名。对于每个规则，我们可以指定几个路径，每个路径都重定向到不同的服务/端口对，其中服务通过其名称引用。匹配每个
    `path` 的方式取决于 `pathType` 的值；如果此值为 `Prefix`，则指定的 `path` 必须是任何匹配路径的前缀。否则，如果此值为 `Exact`，则匹配必须是精确的。匹配区分大小写。
- en: 'HTTPS termination on a specific hostname is specified by associating it with
    a certificate encoded in a Kubernetes secret:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定主机名上指定 HTTPS 终止是通过将其与一个编码在 Kubernetes 机密中的证书相关联来实现的：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: HTTPS certificates can be obtained free of charge at [https://letsencrypt.org/](https://letsencrypt.org/).
    The procedure is explained on the website, but basically, as with all certificate
    authorities, you provide a key and they return the certificate based on that key.
    It is also possible to install a **certificate manager** that takes care of automatically
    installing and renewing the certificate. The way a key/certificate pair is encoded
    in a Kubernetes secret string is detailed in the *Advanced Kubernetes concepts*
    section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS 证书可以在 [https://letsencrypt.org/](https://letsencrypt.org/) 免费获得。该流程在网站上有所解释，但基本上，与所有证书颁发机构一样，您提供一个密钥，他们根据该密钥返回证书。还可以安装一个
    **证书管理器**，它会自动安装和续订证书。密钥/证书对如何在 Kubernetes 机密字符串中编码在 *高级 Kubernetes 概念* 部分中详细说明。
- en: 'The whole Ingress definition is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 Ingress 定义如下：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the `namespace` is optional, and if not specified, is assumed to be `default`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`namespace` 是可选的，如果没有指定，则默认为 `default`。
- en: In the next section, we will put into practice some of the concepts explained
    here by defining an Azure Kubernetes cluster and deploying a simple application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过定义一个 Azure Kubernetes 集群并部署一个简单的应用程序来实践这里解释的一些概念。
- en: Interacting with Kubernetes clusters
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Kubernetes 集群交互
- en: In this section, we will explain both how to create an Azure Kubernetes cluster,
    and how to install minikube, a Kubernetes simulator, on your local machine. All
    examples can be run on both Azure Kubernetes and your local minikube instance.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释如何创建一个 Azure Kubernetes 集群，以及如何在您的本地机器上安装 minikube，一个 Kubernetes 模拟器。所有示例都可以在
    Azure Kubernetes 和您的本地 minikube 实例上运行。
- en: Creating an Azure Kubernetes cluster
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Azure Kubernetes 集群
- en: 'To create an AKS cluster, do the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 AKS 集群，请执行以下操作：
- en: Type `AKS` into the Azure search box.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Azure 搜索框中输入 `AKS`。
- en: Select **Kubernetes services**.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Kubernetes 服务**。
- en: Then click the **Create** button.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击 **创建** 按钮。
- en: 'After that, the following form will appear:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将出现以下表单：
- en: '![](img/B19820_20_04.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![img/B19820_20_04.png](img/B19820_20_04.png)'
- en: 'Figure 20.4: Creating a Kubernetes cluster'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.4：创建 Kubernetes 集群
- en: It is worth mentioning that you can get help simply by hovering over any ![](img/B19820_20_001.png)
    with the mouse.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，您只需将鼠标悬停在任何 ![img/B19820_20_001.png](img/B19820_20_001.png) 上即可获得帮助。
- en: As usual, you are required to specify a subscription, resource group, and region.
    Then, you can choose a unique name (**Kubernetes cluster name**) and the version
    of Kubernetes you would like to use. For computational power, you are asked to
    select a machine template for each node (**Node size**) and the number of nodes.
    While for an actual application, it is recommended to select at least three nodes,
    let’s select just two nodes for our exercise in order to save our free Azure credit.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，您需要指定一个订阅、资源组和区域。然后，您可以选择一个独特的名称（**Kubernetes 集群名称**）以及您希望使用的 Kubernetes
    版本。对于计算能力，您需要为每个节点选择一个机器模板（**节点大小**）和节点数量。而对于实际应用，建议至少选择三个节点，但为了节省我们的免费 Azure
    信用额度，我们这次只选择两个节点。
- en: Moreover, the default virtual machine should also be set to a cheap one, so
    click **Change size** and select **DS2 v2**. Finally, set **Scale method** to
    **Manual** to prevent the number of nodes from being automatically changed, which
    might quickly burn through your free Azure credit.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，默认的虚拟机也应设置为便宜的型号，因此点击 **更改大小** 并选择 **DS2 v2**。最后，将 **缩放方法** 设置为 **手动** 以防止节点数量自动更改，这可能会快速消耗您的免费
    Azure 信用额度。
- en: The **Availability zones** setting allows you to spread your nodes across several
    geographic zones for better fault tolerance. The default is three zones. Please
    change it to two zones since we have just two nodes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**可用区域**设置允许你将你的节点分散在几个地理区域，以提高容错能力。默认为三个区域。请将其更改为两个区域，因为我们只有两个节点。'
- en: 'After implementing the preceding changes, you should see the following settings:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 实施上述更改后，你应该看到以下设置：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B19820_20_05.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件  自动生成的描述](img/B19820_20_05.png)'
- en: 'Figure 20.5: Chosen settings'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.5：选择的设置
- en: Now you can create your cluster by clicking the **Review + create** button.
    A review page should appear. Confirm and create the cluster.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过点击**审查 + 创建**按钮来创建你的集群。应该会出现一个审查页面。确认并创建集群。
- en: If you click **Next** instead of **Review + create**, you can also define other
    node types, and then you can provide security information, namely, a *service
    principal*, and specify whether you wish to enable role-based access control.
    In Azure, service principals are accounts that are associated with services you
    may use to define resource access policies. You may also change the default network
    settings and other settings.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**下一步**而不是**审查 + 创建**，你也可以定义其他节点类型，然后你可以提供安全信息，即*服务主体*，并指定你是否希望启用基于角色的访问控制。在Azure中，服务主体是与你可能使用的服务关联的账户，你可以使用它来定义资源访问策略。你还可以更改默认的网络设置和其他设置。
- en: Deployment may take a little while (10-20 minutes). After that time, you will
    have your first Kubernetes cluster! At the end of the chapter, when the cluster
    is no longer required, please don’t forget to delete it in order to avoid wasting
    your free Azure credit.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 部署可能需要一点时间（10-20分钟）。在这段时间之后，你将拥有你的第一个Kubernetes集群！在章节结束时，当集群不再需要时，请务必删除它，以避免浪费你的免费Azure信用额度。
- en: In the next subsection, you will learn how to install and use minikube, a single-node
    Kubernetes simulator, on your local machine.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，你将学习如何在你的本地机器上安装和使用minikube，这是一个单节点Kubernetes模拟器。
- en: Using minikube
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用minikube
- en: 'The easiest way to install minikube is the usage of the Windows installer you
    can find in the official installation page: [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 安装minikube最简单的方法是使用官方安装页面中可找到的Windows安装程序：[https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)。
- en: During the installation you will be prompted on the kind of virtualization tool
    to use. If you already installed Docker Desktop and WSL, please specify Docker.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中，你将提示选择要使用的虚拟化工具。如果你已经安装了Docker Desktop和WSL，请指定Docker。
- en: If you have a different operating system, please follow the default choices,
    instead.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是不同的操作系统，请遵循默认选项。
- en: The installation of Docker Desktop is explained in the technical requirements
    of *Chapter 11, Applying a Microservice Architecture to Your Enterprise Application*.
    Please note that both WSL and Docker Desktop must be installed and Docker must
    be configured to use Linux containers by default.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 'Docker Desktop的安装说明在*第11章，将微服务架构应用于你的企业应用程序*的技术要求中解释。请注意，WSL和Docker Desktop都必须安装，并且Docker必须配置为默认使用Linux容器。 '
- en: 'Once you have minikube installed, you must add its binary to your computer
    `PATH`. The easiest way to do it is to open a PowerShell console and run the following
    command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了minikube，你必须将其二进制文件添加到你的计算机`PATH`中。最简单的方法是打开PowerShell控制台并运行以下命令：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once installed, your cluster can be run with:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，你可以使用以下命令运行你的集群：
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you have finished working with the cluster, it can be stopped with:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成与集群的工作后，可以使用以下命令停止它：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the next subsection, you will learn how to interact with your minikube instance
    or Azure cluster through Kubernetes’ official client, kubectl.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，你将学习如何通过Kubernetes的官方客户端kubectl与你的minikube实例或Azure集群进行交互。
- en: Using kubectl
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用kubectl
- en: 'Once you have created your Azure Kubernetes cluster, you can interact with
    it via the Azure Cloud Shell. Click on the console icon in the top right of your
    Azure portal page. The following screenshot shows the Azure Shell icon:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了你的Azure Kubernetes集群，你就可以通过Azure Cloud Shell与之交互。点击Azure门户页面右上角的控制台图标。以下截图显示了Azure
    Shell图标：
- en: '![](img/B19820_20_06.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_20_06.png)'
- en: 'Figure 20.6: Azure Shell icon'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.6：Azure Shell图标
- en: When prompted, select the **Bash Shell**. Then you will be prompted to create
    a storage account, so confirm and create it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示时，选择**Bash Shell**。然后你将被提示创建一个存储账户，因此请确认并创建它。
- en: 'We will use this shell to interact with our cluster. At the top of the shell
    there is a file icon that we will use to upload our `.yaml` files:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个shell来与我们的集群交互。在shell的顶部有一个文件图标，我们将用它来上传我们的`.yaml`文件：
- en: '![Graphical user interface, application  Description automatically generated](img/B19820_20_07.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，自动生成的描述](img/B19820_20_07.png)'
- en: 'Figure 20.7: How to upload files in Azure Cloud Shell'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.7：如何在Azure Cloud Shell中上传文件
- en: It is also possible to download a client called Azure CLI and to install it
    on your local machine (see [https://docs.microsoft.com/en-US/cli/azure/install-azure-cli](https://docs.microsoft.com/en-US/cli/azure/install-azure-cli)),
    but, in this case, you also need to install all the tools needed to interact with
    the Kubernetes cluster (kubectl and Helm) that are pre-installed in Azure Cloud
    Shell.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以下载一个名为Azure CLI的客户端并将其安装到你的本地机器上（见[https://docs.microsoft.com/en-US/cli/azure/install-azure-cli](https://docs.microsoft.com/en-US/cli/azure/install-azure-cli)），但在此情况下，你还需要安装所有与Kubernetes集群交互所需的工具（kubectl和Helm），这些工具在Azure
    Cloud Shell中预先安装。
- en: 'Once you’ve created a Kubernetes cluster, you can interact with it through
    the `kubectl` command-line tool. `kubectl` is integrated into Azure Cloud Shell,
    so you just need to activate your cluster credentials to use it. You can do this
    with the following Azure Cloud Shell command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个Kubernetes集群，你就可以通过`kubectl`命令行工具与之交互。`kubectl`集成到Azure Cloud Shell中，所以你只需要激活你的集群凭据来使用它。你可以使用以下Azure
    Cloud Shell命令来完成此操作：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding command stores the credentials that were automatically created
    to enable your interaction with the cluster in a `/.kube/config` configuration
    file. From now on, you can issue your `kubectl` commands with no further authentication.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将自动创建的凭据存储在`/.kube/config`配置文件中，以启用你与集群的交互。从现在开始，你可以无需进一步认证即可输入你的`kubectl`命令。
- en: If, instead, you need to interact with your local minikube cluster, you need
    a local installation of `kubectl`, but minikube installs it automatically for
    you.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要与你的本地minikube集群交互，你需要本地安装`kubectl`，但minikube会自动为你安装。
- en: 'In order to use the automatically-installed `kubectl`, all `kubectl` commands
    must be preceded by the `minikube` command and `kubectl` must be followed by --.
    Thus, for instance, if you wanted to run the following command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用自动安装的`kubectl`，所有`kubectl`命令都必须以`minikube`命令开头，并且`kubectl`后面必须跟有--。例如，如果你想运行以下命令：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then you would have to write the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要编写以下内容：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the remainder of the chapter, we will write commands that work on actual
    Kubernetes clusters such as Azure Kubernetes. Therefore, when using minikube,
    remember to replace `kubectl` with `minikube kubectl` -- in your commands.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将编写在真实的Kubernetes集群（如Azure Kubernetes）上工作的命令。因此，当使用minikube时，请记住在你的命令中将`kubectl`替换为`minikube
    kubectl` --。
- en: 'If you issue the `kubectl get nodes` command, you get a list of all your Kubernetes
    nodes. In general, `kubectl get <object type>` lists all objects of a given type.
    You can use it with `nodes`, `pods`, `statefulset`, and so on. `kubectl get all`
    shows a list of all the objects created in your cluster. If you also add the name
    of a specific object, you will get information on just that specific object, as
    shown here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入`kubectl get nodes`命令，你会得到所有Kubernetes节点的列表。通常，`kubectl get <对象类型>`会列出给定类型的所有对象。你可以用它来与`nodes`、`pods`、`statefulset`等一起使用。`kubectl
    get all`会显示你集群中创建的所有对象的列表。如果你还添加了特定对象的名称，你将只得到关于该特定对象的信息，如下所示：
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you add the `--watch` option, the object list will be continuously updated,
    so you can see the state of all the selected objects changing over time. You can
    leave this watch state by hitting *Ctrl* + *C*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加了`--watch`选项，对象列表将不断更新，因此你可以看到所有选定对象的状态随时间变化。你可以通过按*Ctrl* + *C*来离开监视状态。
- en: 'The following command shows a detailed report on a specific object:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示特定对象的详细报告：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'All objects described in a `.yaml` file, say `myClusterConfiguration.yaml`,
    can be created with the following command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`.yaml`文件中描述的所有对象，例如`myClusterConfiguration.yaml`，都可以使用以下命令创建：'
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, if you modify the `.yaml` file, you can reflect all the modifications
    in your cluster with the `apply` command, as shown here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果你修改了`.yaml`文件，你可以使用`apply`命令将所有修改反映到你的集群中，如下所示：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`apply` does the same job as `create` but, if the resource already exists,
    `apply` overrides it, while `create` exits with an error message.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply` 与 `create` 执行相同的任务，但如果资源已存在，`apply` 将覆盖它，而 `create` 将以错误消息退出。'
- en: 'You can destroy all objects that were created with a `.yaml` file by passing
    the same file to the `delete` command, as shown here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将相同的文件传递给 `delete` 命令来销毁使用 `.yaml` 文件创建的所有对象，如下所示：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `delete` command can also be passed an object type and a list of names
    of objects of that type to destroy, as shown in the following example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete` 命令也可以传递一个对象类型和该类型对象名称的列表，以销毁这些对象，如下面的示例所示：'
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding `kubectl` commands should suffice for most of your practical needs.
    For more details, the *Further reading* section contains a link to the official
    documentation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `kubectl` 命令应该足以满足大多数实际需求。对于更多详细信息，*进一步阅读* 部分包含了对官方文档的链接。
- en: In the next subsection, we will use `kubectl create` to install a simple demo
    application.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，我们将使用 `kubectl create` 来安装一个简单的演示应用程序。
- en: Deploying the demo Guestbook application
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署演示 Guestbook 应用程序
- en: The Guestbook application is a demo application used in the examples in the
    official Kubernetes documentation. We will use it as an example of a Kubernetes
    application since its Docker images are available in the public Docker repository,
    so we don’t need to write software.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Guestbook 应用程序是官方 Kubernetes 文档中使用的演示应用程序。我们将使用它作为 Kubernetes 应用程序的示例，因为其 Docker
    镜像可在公共 Docker 仓库中找到，因此我们不需要编写软件。
- en: The Guestbook application stores the opinions of customers who visit a hotel
    or a restaurant.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Guestbook 应用程序存储访问酒店或餐厅的客户意见。
- en: It is composed of a UI, and an in-memory database, based on Redis. Moreover,
    updates are sent to the master copy of the Redis database, which is automatically
    replicated in *N* read-only Redis replicas.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 它由一个用户界面和一个基于 Redis 的内存数据库组成。此外，更新被发送到 Redis 数据库的主副本，该主副本自动复制为 *N* 个只读 Redis
    副本。
- en: '![](img/B19820_20_08.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_20_08.png)'
- en: 'Figure 20.8: Architecture of the Guestbook application'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20.8：Guestbook 应用程序的架构
- en: The UI application can be deployed in Kubernetes as a Deployment, since it is
    memoryless.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: UI 应用程序可以作为 Deployment 在 Kubernetes 中部署，因为它是无状态的。
- en: The Redis master store is deployed as a single pod `Deployment`. We can’t implement
    it with an *N*-pods `Deployment` since we need sharding for parallelizing updates.
    However, we might have used a `StatefulSet` assigning a different data shard to
    each different master Pod. However, since this is your first Kubernetes exercise
    and since write operations should not be predominant, a single master database
    should suffice in the practical case of a single restaurant/hotel.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 主存储以单个 pod `Deployment` 的形式部署。我们不能使用 *N* 个 pod 的 `Deployment` 来实现它，因为我们需要分片以并行化更新。然而，我们可能已经使用了一个
    `StatefulSet`，为每个不同的主 Pod 分配不同的数据分片。但是，由于这是你的第一个 Kubernetes 练习，并且由于写入操作不应占主导地位，在单个餐厅/酒店的实际情况中，单个主数据库应该足够了。
- en: Since all slave copies contain the same data and consequently are undistinguishable,
    they can be implemented with a `Deployment`, too.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有从副本都包含相同的数据，因此它们是不可区分的，也可以使用 `Deployment` 来实现。
- en: The whole application is composed of three `.yaml` files that you can find in
    the GitHub repository associated with this book ([https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 整个应用程序由三个 `.yaml` 文件组成，您可以在与本书相关的 GitHub 仓库中找到这些文件（[https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)）。
- en: 'Here is the code for the master storage based on Redis that is contained in
    the `redis-master.yaml` file:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是包含在 `redis-master.yaml` 文件中的基于 Redis 的主存储代码：
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The file is composed of two object definitions separated by a line containing
    just `---`, that is, the object definition separator of `.yaml` files. It is common
    to group related objects, such as a Deployment with its associated Service, in
    the same file separated by the `---` objects separator symbol in order to increase
    code readability.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件由两个对象定义组成，由仅包含 `---` 的行分隔，即 `.yaml` 文件的对象定义分隔符。通常，将相关的对象，如与其关联的服务一起的 Deployment，放在同一个文件中，通过
    `---` 对象分隔符号来分隔，以提高代码可读性。
- en: The first object is a `Deployment` with a single replica, and the second object
    is a `ClusterIP` Service that exposes the `Deployment` on the `6379` port at the
    internal `redis-leader.default.svc.cluster.local` network address. The Deployment
    pod template defines the three `app`, `role`, and `tier` labels with values that
    are used in the `selector` definition of the Service to connect the Service with
    the unique Pod defined in the `Deployment`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个对象是一个具有单个副本的`Deployment`，第二个对象是一个`ClusterIP`服务，它将`Deployment`在内部`redis-leader.default.svc.cluster.local`网络地址的`6379`端口上暴露。部署Pod模板定义了三个`app`、`role`和`tier`标签及其值，这些值用于服务`selector`定义中，以将服务与`Deployment`中定义的唯一Pod连接。
- en: 'Let’s upload the `redis-master.yaml` file to Azure Cloud Shell, and then deploy
    it in the cluster with the following command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`redis-master.yaml`文件上传到Azure Cloud Shell，然后使用以下命令在集群中部署它：
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once the operation is complete, you can inspect the contents of the cluster
    with `kubectl get all`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦操作完成，你可以使用`kubectl get all`来检查集群的内容。
- en: The slave storage is defined in the `redis-slave.yaml` file and is created in
    the same way, the only difference being that this time we have two replicas, and
    a different Docker image. The full code is in the GitHub repository associated
    with this book.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 从机存储在`redis-slave.yaml`文件中定义，并且以相同的方式创建，唯一的区别是这次我们有两个副本，以及不同的Docker镜像。完整的代码在本书相关的GitHub仓库中。
- en: 'Let’s upload this file as well and deploy it with the following command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也上传此文件，并使用以下命令部署它：
- en: '[PRE32]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The code for the UI tier is contained in the `frontend.yaml` file. `Deployment`
    has three replicas and a different Service type. Let’s upload and deploy this
    file with the following command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: UI层的代码包含在`frontend.yaml`文件中。`Deployment`有三个副本和不同的服务类型。让我们使用以下命令上传并部署此文件：
- en: '[PRE33]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It is worthwhile analyzing the Service code in the `frontend.yaml` file:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 分析`frontend.yaml`文件中的服务代码是值得的：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Again, the full code is in the GitHub repository associated with the book.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，完整的代码在本书相关的GitHub仓库中。
- en: This Service is of the `LoadBalancer` type. Since this Pod is the application
    interface with the world outside of the Kubernetes cluster, its service must have
    a fixed IP and must be load balanced. Therefore, we must use a `LoadBalancer`
    service since this is the unique service type that satisfies those requirements.
    (See the *Services* section of this chapter for more information.)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务为`LoadBalancer`类型。由于此Pod是应用程序与Kubernetes集群外部的接口，其服务必须有一个固定的IP，并且必须进行负载均衡。因此，我们必须使用`LoadBalancer`服务，因为这是唯一满足这些要求的服务类型。（有关更多信息，请参阅本章的*服务*部分。）
- en: 'If you are in Azure Kubernetes or any other cloud Kubernetes service, in order
    to get the public IP address assigned to the service, and then to the application,
    use the following command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Azure Kubernetes或任何其他云Kubernetes服务，为了获取分配给服务的公网IP地址，然后到应用程序，请使用以下命令：
- en: '[PRE35]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding command should display information on all the installed services.
    You should find the public IP in the `EXTERNAL-IP` column of the list. If you
    see only `<none>` values, please repeat the command until the public IP address
    is assigned to the load balancer.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令应显示所有已安装服务的详细信息。你应该在列表的`EXTERNAL-IP`列中找到公网IP。如果你只看到`<none>`值，请重复此命令，直到公网IP地址分配给负载均衡器。
- en: 'If no IP is assigned after a few minutes, please verify whether there is some
    error or warning in any of the service descriptions. If not, please check whether
    all deployments are actually running using the following command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果几分钟内没有分配IP，请检查任何服务描述中是否有错误或警告。如果没有，请使用以下命令检查所有部署是否实际上正在运行：
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If, instead, you are on minikube, `LoadBalancer` services can be accessed by
    issuing this command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在minikube上，可以通过以下命令访问`LoadBalancer`服务：
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Thus, in our case:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的情况下：
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The command should automatically open the browser.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应自动打开浏览器。
- en: Once you get the IP address, navigate with the browser to this address. The
    application’s home page should now appear!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取到IP地址，使用浏览器导航到该地址。现在应该会显示应用程序的主页！
- en: 'If the page doesn’t appear, verify whether any service has an error by issuing
    the following command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果页面没有出现，请通过以下命令检查是否有任何服务出现错误：
- en: '[PRE39]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If not, also verify that all deployments are in the running state with the
    following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是这样，也请使用以下命令验证所有部署是否处于运行状态：
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you find problems, please look for errors in the `.yaml` files, correct
    them, and then update the object defined in the file with:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现问题，请检查 `.yaml` 文件中的错误，更正它们，然后使用以下命令更新文件中定义的对象：
- en: '[PRE41]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once you have finished experimenting with the application, make sure to remove
    the application from the cluster to avoid wasting your free Azure credit (public
    IP addresses cost money) with the following commands:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成对应用程序的实验，请确保使用以下命令将应用程序从集群中移除，以避免浪费您的免费 Azure 信用额度（公共 IP 地址需要付费）：
- en: '`kubectl delete deployment frontend redis-master redis-slave`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl delete deployment frontend redis-master redis-slave`'
- en: '`kubectl delete service frontend redis-leader redis-follower`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl delete service frontend redis-leader redis-follower`'
- en: In the next section, we will analyze other important Kubernetes features.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将分析其他重要的 Kubernetes 功能。
- en: Advanced Kubernetes concepts
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 Kubernetes 概念
- en: In this section, we will discuss other important Kubernetes features, including
    how to assign permanent storage to StatefulSets; how to store secrets such as
    passwords, connection strings, or certificates; how a container can inform Kubernetes
    about its health state; and how to handle complex Kubernetes packages with Helm.
    All of these subjects are organized into dedicated subsections. We will start
    with the problem of permanent storage.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论其他重要的 Kubernetes 功能，包括如何将永久存储分配给 StatefulSets；如何存储密码、连接字符串或证书等机密信息；容器如何通知
    Kubernetes 其健康状态；以及如何使用 Helm 处理复杂的 Kubernetes 包。所有这些主题都组织在专门的子节中。我们将从永久存储的问题开始。
- en: Requiring permanent storage
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要永久存储
- en: 'Since Pods are moved between nodes, they can’t store data on the disk storage
    offered by the current node where they are running, or they would lose that storage
    as soon as they are moved to a different node. This leaves us with two options:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Pod 会在节点之间移动，因此它们不能存储在它们运行的当前节点提供的磁盘存储上，否则一旦它们被移动到不同的节点，就会丢失该存储。这给我们留下了两个选择：
- en: '**Using external databases**: With the help of databases, ReplicaSets can also
    store information. However, if we need better performance in terms of write/update
    operations, we should use distributed sharded databases based on non-SQL engines
    such as Cosmos DB or MongoDB (see *Chapter 12*, *Choosing Your Data Storage in
    the Cloud*). In this case, in order to take maximum advantage of table sharding,
    we need StatefulSets, where each Pod instance takes care of a different table
    shard.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用外部数据库**：借助数据库，ReplicaSets 也可以存储信息。然而，如果我们需要在写入/更新操作方面获得更好的性能，我们应该使用基于非
    SQL 引擎的分布式分片数据库，例如 Cosmos DB 或 MongoDB（见 *第 12 章*，*在云中选择您的数据存储*）。在这种情况下，为了最大限度地利用表分片，我们需要
    StatefulSets，其中每个 Pod 实例负责不同的表分片。'
- en: '**Using cloud storage**: Not being tied to a physical cluster node, cloud storage
    can be associated permanently with specific Pod instances of StatefulSets. Cloud
    storage is discussed in the *Redis* and *Azure storage accounts* sections of *Chapter
    12*.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用云存储**：由于不受物理集群节点的限制，云存储可以永久关联到 StatefulSets 的特定 Pod 实例。云存储在 *第 12 章* 的
    *Redis* 和 *Azure 存储帐户* 部分中讨论。'
- en: Since access to external databases doesn’t require any Kubernetes-specific techniques
    but can be done with the usual connection strings, we will concentrate on cloud
    storage.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于访问外部数据库不需要任何特定的 Kubernetes 技巧，只需使用常规的连接字符串即可完成，因此我们将专注于云存储。
- en: Kubernetes offers an abstraction of storage called **PersistentVolumeClaim**
    (**PVC**) that is independent of the underlying storage provider. More specifically,
    PVCs are allocation requests that are either matched to predefined resources or
    allocated dynamically. When the Kubernetes cluster is in the cloud, typically,
    you use dynamic allocation carried out by dynamic providers installed by the cloud
    provider. For more information on cloud storage, please refer to *Chapter 12*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了一个称为 **PersistentVolumeClaim** （**PVC**）的存储抽象，它与底层存储提供商无关。更具体地说，PVC
    是请求分配，这些请求要么与预定义的资源匹配，要么动态分配。当 Kubernetes 集群位于云中时，通常，您使用由云提供商安装的动态提供者执行的动态分配。有关云存储的更多信息，请参阅
    *第 12 章*。
- en: 'Cloud providers such as Azure offer different storage classes with different
    performance and different costs. Moreover, the PVC can also specify the `accessMode`,
    which can be:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 云提供商，如 Azure，提供具有不同性能和不同成本的不同的存储类别。此外，PVC 还可以指定 `accessMode`，可以是：
- en: '`ReadWriteOnce`: The volume can be mounted as read-write by a single Pod.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadWriteOnce`：卷可以被单个 Pod 以读写方式挂载。'
- en: '`ReadOnlyMany`: The volume can be mounted as read-only by many Pods.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadOnlyMany`：卷可以被多个Pod以只读方式挂载。'
- en: '`ReadWriteMany`: The volume can be mounted as read-write by many Pods.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadWriteMany`：卷可以被多个Pod以读写方式挂载。'
- en: 'Volume claims can be added to StatefulSets in a specific `spec->volumeClaimTemplates`
    object:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在StatefulSets中添加到特定的`spec->volumeClaimTemplates`对象中：
- en: '[PRE42]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `storage` property contains the storage requirements. `volumeMode` set to
    `Filesystem` is a standard setting that means the storage will be available as
    a file path. The other possible value is `Block`, which allocates the memory as
    `unformatted`. `storageClassName` must be set to an existing storage class offered
    by the cloud provider. If it’s omitted, the default storage class will be assumed.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`storage`属性包含存储需求。`volumeMode`设置为`Filesystem`是标准设置，意味着存储将以文件路径的形式可用。另一个可能的值是`Block`，它将内存分配为`未格式化`。`storageClassName`必须设置为云提供商提供的现有存储类。如果省略，则假定默认存储类。'
- en: 'All available storage classes can be listed with the following command:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令列出所有可用的存储类：
- en: '[PRE43]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once `volumeClaimTemplates` has defined how to create permanent storage, then
    each container must specify which file path to attach that permanent storage to
    in the `spec->containers->volumeMounts` property:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`volumeClaimTemplates`定义了如何创建持久存储，那么每个容器必须指定在`spec->containers->volumeMounts`属性中将该持久存储附加到哪个文件路径：
- en: '[PRE44]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, `name` must correspond to the name given to the PVC.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`name`必须与PVC给出的名称相匹配。
- en: The following subsection shows how to use Kubernetes secrets.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将展示如何使用Kubernetes密钥。
- en: Kubernetes secrets
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes密钥
- en: 'Some data, such as passwords and connection strings, cannot be exposed but
    need to be protected by some kind of encryption. Kubernetes handles private sensitive
    data that need encryption through specific objects called **secrets**. **Secrets**
    are sets of key-value pairs that are encrypted to protect them. They can be created
    by putting each value in a file, and then invoking the following `kubectl` command:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据，如密码和连接字符串，不能公开，需要通过某种加密来保护。Kubernetes通过称为**密钥**的特定对象处理需要加密的私有敏感数据。**密钥**是一组加密以保护它们的键值对。可以通过将每个值放入一个文件中，然后调用以下`kubectl`命令来创建：
- en: '[PRE45]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this case, the filenames become the keys and the files’ contents are the
    values.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，文件名成为键，文件的内容成为值。
- en: 'When the values are strings, they can be specified directly in the `kubectl`
    command, as shown here:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当值是字符串时，可以在`kubectl`命令中直接指定，如下所示：
- en: '[PRE46]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this case, keys and values are listed one after the other, separated by the
    `=` character. In the previous example, the actual password is enclosed between
    single quotes to escape special characters like `$` that are usually required
    to build strong passwords.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，键和值依次列出，由`=`字符分隔。在先前的例子中，实际密码被单引号包围以转义通常用于构建强密码的特殊字符，如`$`。
- en: 'Once defined, secrets can be referred to in the `spec->volume` property of
    a Pod (Deployment or StatefulSet template), as shown here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义，密钥就可以在Pod（Deployment或StatefulSet模板）的`spec->volume`属性中引用，如下所示：
- en: '[PRE47]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After that, each container can specify on which path to mount them in the `spec->containers->volumeMounts`
    property:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，每个容器可以指定在`spec->containers->volumeMounts`属性中挂载它们的路径：
- en: '[PRE48]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding example, each key is seen as a file with the same name as the
    key. The content of the file is the secret value, base64-encoded. Therefore, the
    code that reads each file must decode its content (in .NET, `Convert.FromBase64`
    will do the job).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，每个密钥被视为一个与密钥同名文件。文件的内容是加密的密值，使用base64编码。因此，读取每个文件的代码必须解码其内容（在.NET中，`Convert.FromBase64`将完成这项工作）。
- en: 'When secrets contain strings, they can also be passed as environment variables
    in the `spec->containers->env` object:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当密钥包含字符串时，也可以在`spec->containers->env`对象中作为环境变量传递：
- en: '[PRE49]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, the `name` property must match the secret’s name. Passing secrets as environment
    variables is very convenient when containers host ASP.NET Core applications, since,
    in this case, environment variables are all immediately available in the configuration
    object (see the *Loading configuration data and using it with the options framework*
    section of *Chapter 17*, *Presenting ASP.NET Core*).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`name`属性必须与密钥的名称匹配。当容器托管ASP.NET Core应用程序时，将密钥作为环境变量传递非常方便，在这种情况下，环境变量都立即在配置对象中可用（参见第17章“展示ASP.NET
    Core”中的*加载配置数据和使用选项框架*部分）。
- en: 'Secrets can also encode the key/certificate pair of an HTTPS certificate with
    the following `kubectl` command:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密也可以使用以下 `kubectl` 命令来编码 HTTPS 证书的密钥/证书对：
- en: '[PRE50]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Secrets defined in this way can be used to enable HTTPS termination in Ingresses.
    You can do this by placing the secret names in the `spec->tls->hosts->secretName`
    properties of an Ingress.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式定义的秘密可以用来在 Ingress 中启用 HTTPS 终止。您可以通过将秘密名称放置在 Ingress 的 `spec->tls->hosts->secretName`
    属性中来做到这一点。
- en: Liveness and readiness checks
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活跃性和就绪性检查
- en: Kubernetes automatically monitors all containers to ensure they are still alive
    and that they keep their resource consumption within the limits declared in the
    `spec->containers->resources->limits` object. When some conditions are violated,
    the container is either throttled, or restarted, or the whole Pod instance is
    restarted on a different node. How does Kubernetes know that a container is in
    a healthy state? While it can use the operating system to check the healthy state
    of nodes, it has no universal check that works with all containers.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 自动监控所有容器以确保它们仍然存活，并且它们保持其资源消耗在 `spec->containers->resources->limits`
    对象中声明的限制内。当某些条件被违反时，容器可能会被节流、重启，或者整个 Pod 实例在不同的节点上重启。Kubernetes 如何知道容器处于健康状态？虽然它可以使用操作系统来检查节点的健康状态，但它没有适用于所有容器的通用检查。
- en: 'Therefore, the containers themselves must inform Kubernetes of their health,
    otherwise Kubernetes cannot verify them. Containers can inform Kubernetes of their
    health in two ways: either by declaring a console command that returns their health,
    or by declaring an endpoint that provides the same information.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，容器本身必须通知 Kubernetes 它们的健康状况，否则 Kubernetes 无法验证它们。容器可以通过两种方式通知 Kubernetes
    它们的健康状况：要么声明一个返回其健康状况的控制台命令，要么声明一个提供相同信息的端点。
- en: 'Both declarations are provided in the `spec-> containers-> livenessProb` object.
    The console command check is declared as shown here:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个声明都包含在 `spec-> containers-> livenessProbe` 对象中。控制台命令检查声明如下：
- en: '[PRE51]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If `command` returns `0`, the container is considered healthy. In the preceding
    example, the software running in the container records its state of health in
    the `/tmp/healthy` file, so the `cat/tmp/healthy` command returns it. `PeriodSeconds`
    is the time between checks, while `initialDelaySeconds` is the initial delay before
    performing the first check. An initial delay is always necessary so as to give
    the container time to start.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `command` 返回 `0`，则容器被认为是健康的。在先前的例子中，容器中运行的软件将它的健康状况记录在 `/tmp/healthy` 文件中，因此
    `cat /tmp/healthy` 命令返回它。`PeriodSeconds` 是检查之间的时间，而 `initialDelaySeconds` 是在执行第一次检查之前的初始延迟。初始延迟总是必要的，以便给容器启动留出时间。
- en: 'The endpoint check is quite similar:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 端点检查相当类似：
- en: '[PRE52]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The test is successful if the HTTP response contains the declared header with
    the declared value. You may also use a pure TCP check, as shown here:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 HTTP 响应包含声明的带有声明的值的头，则测试成功。您也可以使用纯 TCP 检查，如下所示：
- en: '[PRE53]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this case, the check succeeds if Kubernetes is able to open a TCP socket
    to the container on the declared port.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果 Kubernetes 能够在声明的端口上打开到容器的 TCP 套接字，则检查成功。
- en: Similarly, the readiness of containers once they are installed is monitored
    with a readiness check. The readiness check is defined in a similar way as the
    liveness check, the only difference being that `livenessProbe` is replaced with
    `readinessProbe`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，一旦容器安装完成，其就绪性通过就绪性检查进行监控。就绪性检查的定义方式与活跃性检查类似，唯一的区别是 `livenessProbe` 被替换为
    `readinessProbe`。
- en: The following subsection explains how to autoscale Deployments.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将解释如何自动扩展 Deployment。
- en: Autoscaling
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动扩展
- en: Instead of manually modifying the number of replicas in a Deployment to adapt
    it to a decrease or increase in load, we can let Kubernetes decide for itself
    the number of replicas needed to keep a declared resource’s consumption constant.
    Thus, for instance, if we declare a target of 10% CPU consumption, then when the
    average resource consumption of each replica exceeds this limit, a new replica
    will be created. If the average CPU consumption falls below this limit, a replica
    is destroyed. The typical resource used to monitor replicas is CPU consumption,
    but we can also use memory consumption.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必手动修改 Deployment 中的副本数量以适应负载的减少或增加，我们可以让 Kubernetes 自己决定保持声明的资源消耗恒定所需的副本数量。因此，例如，如果我们声明目标为
    10% 的 CPU 消耗，那么当每个副本的平均资源消耗超过此限制时，将创建一个新的副本。如果平均 CPU 消耗低于此限制，则销毁一个副本。用于监控副本的典型资源是
    CPU 消耗，但我们也可以使用内存消耗。
- en: In actual high-traffic production systems, autoscaling is a **must**, because
    it is the only way to adapt quickly the system to changes in the load.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的高流量生产系统中，自动扩展是**必须的**，因为它是快速适应负载变化系统的唯一方式。
- en: 'Autoscaling is achieved by defining a `HorizontalPodAutoscaler` object. Here
    is an example of the `HorizontalPodAutoscaler` definition:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义`HorizontalPodAutoscaler`对象来实现自动扩展。以下是一个`HorizontalPodAutoscaler`定义的示例：
- en: '[PRE54]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`spec-> scaleTargetRef->name` specifies the name of the Deployment to autoscale,
    while `targetAverageUtilization` specifies the target resource (in our case, `cpu`)
    percentage usage (in our case, 25%).'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec-> scaleTargetRef->name`指定了要自动扩展的Deployment的名称，而`targetAverageUtilization`指定了目标资源（在我们的情况下，`cpu`）的百分比使用率（在我们的情况下，25%）。'
- en: The following subsection gives a short introduction to the Helm package manager
    and Helm charts and explains how to install Helm charts on a Kubernetes cluster.
    An example of how to install an Ingress Controller is given as well.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节简要介绍了Helm包管理器和Helm图表，并解释了如何在Kubernetes集群上安装Helm图表。还提供了一个如何安装Ingress Controller的示例。
- en: Helm – installing an Ingress Controller
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helm – 安装Ingress Controller
- en: 'Helm charts are a way to organize the installation of complex Kubernetes applications
    that contain several `.yaml` files. A Helm chart is a set of `.yaml` files organized
    into folders and subfolders. Here is a typical folder structure of a Helm chart
    taken from the official documentation:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表是组织复杂Kubernetes应用程序安装的方式，这些应用程序包含多个`.yaml`文件。Helm图表是一组组织成文件夹和子文件夹的`.yaml`文件。以下是从官方文档中摘取的典型Helm图表文件夹结构：
- en: '![Text  Description automatically generated](img/B19820_20_09.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19820_20_09.png)'
- en: 'Figure 20.9: Folder structure of a Helm chart'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图20.9：Helm图表的文件夹结构
- en: 'The `.yaml` files specific to the application are placed in the top `templates`
    directory, while the `charts` directory may contain other Helm charts used as
    helper libraries. The top-level `Chart.yaml` file contains general information
    on the package (name and description), together with both the application version
    and the Helm chart version. The following is a typical example:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 特定于应用程序的`.yaml`文件放置在顶层的`templates`目录中，而`charts`目录可能包含其他用作辅助库的Helm图表。顶层`Chart.yaml`文件包含有关包（名称和描述）的一般信息，以及应用程序版本和Helm图表版本。以下是一个典型的示例：
- en: '[PRE55]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, `type` can be either `application` or `library`. Only `application` charts
    can be deployed, while `library` charts are utilities for developing other charts.
    `library` charts are placed in the `charts` folder of other Helm charts.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`type`可以是`application`或`library`。只有`application`图表可以被部署，而`library`图表是用于开发其他图表的工具。`library`图表放置在其他Helm图表的`charts`文件夹中。
- en: In order to configure each specific application installation, Helm chart `.yaml`
    files contain variables that are specified when Helm charts are installed. Moreover,
    Helm charts also provide a simple templating language that allows some declarations
    to be included only if some conditions depending on the input variables are satisfied.
    The top-level `values.yaml` file declares default values for the input variables,
    meaning that the developer needs to specify just the few variables for which they
    require values different from the defaults. We will not describe the Helm chart
    template language because it would be too extensive, but you can find it in the
    official Helm documentation referred to in the *Further reading* section.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置每个特定的应用程序安装，Helm图表`.yaml`文件包含在安装Helm图表时指定的变量。此外，Helm图表还提供了一种简单的模板语言，允许在某些条件满足的情况下仅包含一些声明，这些条件依赖于输入变量。顶层`values.yaml`文件声明了输入变量的默认值，这意味着开发者只需指定那些需要与默认值不同的变量即可。我们不会描述Helm图表模板语言，因为它过于广泛，但您可以在*进一步阅读*部分中提到的官方Helm文档中找到它。
- en: Helm charts are usually organized in public or private repositories in a way
    that is similar to Docker images. There is a Helm client that you can use to download
    packages from a remote repository and to install charts in Kubernetes clusters.
    The Helm client is immediately available in Azure Cloud Shell, so you can start
    using Helm for your Azure Kubernetes cluster without needing to install it.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表通常以类似于Docker镜像的方式组织在公共或私有存储库中。有一个Helm客户端，您可以使用它从远程存储库下载包并在Kubernetes集群中安装图表。Helm客户端在Azure
    Cloud Shell中立即可用，因此您可以在不安装它的情况下开始使用Helm为您的Azure Kubernetes集群。
- en: 'A remote repository must be added before using its packages, as shown in the
    following example:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用其软件包之前，必须先添加远程仓库，如下例所示：
- en: '[PRE56]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The preceding command makes the packages of a remote repository available and
    gives a local name to that remote repository. After that, any package from the
    remote repository can be installed with a command such as the following:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令使远程仓库的软件包可用，并为该远程仓库指定一个本地名称。之后，可以使用如下命令安装远程仓库中的任何软件包：
- en: '[PRE57]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here, `<namespace>` is the namespace in which to install the application. As
    usual, if it’s not provided, the `default` namespace is assumed. `<instance name>`
    is the name that you give to the installed application. You need this name to
    get information about the installed application with the following command:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<namespace>` 是安装应用程序的命名空间。像往常一样，如果没有提供，则假定使用 `default` 命名空间。`<instance
    name>` 是你为安装的应用程序指定的名称。你需要这个名称来使用以下命令获取安装应用程序的信息：
- en: '[PRE58]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can get also information about all applications installed with Helm with
    the help of the following command:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下命令获取使用 Helm 安装的所有应用程序的信息：
- en: '[PRE59]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The application name is also needed to delete the application from the cluster
    by means of the following command:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 删除集群中的应用程序也需要应用程序名称，如下述命令所示：
- en: '[PRE60]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When we install an application, we may also provide a `.yaml` file with all
    the variable values we want to override. We can also specify a specific version
    of the Helm chart, otherwise the most recent version is used. Here is an example
    with both the version and values overridden:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们安装应用程序时，我们还可以提供一个包含所有要覆盖的变量值的 `.yaml` 文件。我们还可以指定 Helm 图表的特定版本，否则将使用最新版本。以下是一个同时覆盖版本和值的示例：
- en: '[PRE61]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, value overrides can also be provided in-line with the `--set` option,
    as shown here:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以使用 `--set` 选项直接提供值覆盖，如下所示：
- en: '[PRE62]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can also upgrade an existing installation with the `upgrade` command, as
    shown here:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `upgrade` 命令升级现有的安装，如下所示：
- en: '[PRE63]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `upgrade` command may be used to specify new value overrides with the `–f`
    option or with the `--set` option, and a new version with `--version`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `upgrade` 命令通过 `--f` 选项或 `--set` 选项指定新的值覆盖，并通过 `--version` 指定新版本。
- en: 'Let’s use Helm to provide an Ingress for the Guestbook demo application. More
    specifically, we will use Helm to install an Ingress Controller based on Nginx.
    The detailed procedure to be observed is as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Helm 为 Guestbook 演示应用程序提供 Ingress。更具体地说，我们将使用 Helm 安装基于 Nginx 的 Ingress
    控制器。需要遵循的详细步骤如下：
- en: 'Add the remote repository:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加远程仓库：
- en: '[PRE64]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Install the Ingress Controller:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Ingress 控制器：
- en: '[PRE65]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: When the installation is complete, you should see an entry for the installed
    Ingress Controller among the installed services if you type `kubectl get service`.
    The entry should contain a public IP. Please make a note of this IP since it will
    be the public IP of the application.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，如果你输入 `kubectl get service`，应该能在已安装的服务中看到已安装的 Ingress 控制器的条目。该条目应包含一个公网
    IP。请记下此 IP，因为这将作为应用程序的公网 IP。
- en: 'Open the `frontend.yaml` file and remove the `type: LoadBalancer` line. Save
    and upload this to Azure Cloud Shell. We changed the service type of the frontend
    application from `LoadBalancer` to `ClusterIP` (the default). This service will
    be connected to the new Ingress you are going to define.'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开 `frontend.yaml` 文件，删除 `type: LoadBalancer` 行。保存并上传到 Azure Cloud Shell。我们将前端应用程序的服务类型从
    `LoadBalancer` 改为 `ClusterIP`（默认）。此服务将连接到你即将定义的新 Ingress。'
- en: 'Deploy `redis-master.yaml`, `redis-slave.yaml`, and `frontend.yaml` with `kubectl`,
    as detailed in the *Deploying the demo Guestbook application* subsection. Create
    a `frontend-ingress.yaml` file and place the following code in it:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据 *部署演示 Guestbook 应用程序* 子节中的详细说明，使用 `kubectl` 部署 `redis-master.yaml`、`redis-slave.yaml`
    和 `frontend.yaml`。创建一个 `frontend-ingress.yaml` 文件，并将以下代码放入其中：
- en: '[PRE66]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Upload `frontend-ingress.yaml` to Azure Cloud Shell and deploy it with the
    following command:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `frontend-ingress.yaml` 文件上传到 Azure Cloud Shell，并使用以下命令部署它：
- en: '[PRE67]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Open the browser and navigate to the public IP you made a note of in *step 3*.
    There, you should see the application running.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器，导航到你在 *步骤 3* 中记下的公网 IP。在那里，你应该能看到应用程序正在运行。
- en: The public IP allocated to the `Ingress-Controller` at *Step 3* is listed also
    in the **Azure Public IP Addresses** section of Azure. You can find it by searching
    for this section in the Azure search box. Once in this section, you should see
    this IP address listed. There you can also assign it a hostname of the type `<a
    name you can choose>.<your Azure region>.cloudeapp.com`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 3* 分配给 `Ingress-Controller` 的公共 IP 地址也列在 Azure 的 **Azure 公共 IP 地址** 部分。你可以在
    Azure 搜索框中搜索此部分来找到它。一旦进入此部分，你应该能看到列出的此 IP 地址。在那里，你还可以将其分配为类型为 `<你选择的名字>.<你的 Azure
    区域>.cloudeapp.com` 的主机名。
- en: 'We recommend studying the [https://letsencrypt.org/](https://letsencrypt.org/)
    documentation on how to require a certificate, assign a hostname to the application’s
    public IP, and then use this hostname to get a free HTTPS certificate from [https://letsencrypt.org/](https://letsencrypt.org/).
    Unfortunately, we can’t give more details since the procedure to require a certificate
    is too extensive. Once you get a certificate, you can generate a secret from it
    with the following command:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议学习 [https://letsencrypt.org/](https://letsencrypt.org/) 上的文档，了解如何要求证书、为应用程序的公共
    IP 分配主机名，然后使用此主机名从 [https://letsencrypt.org/](https://letsencrypt.org/) 获取免费的
    HTTPS 证书。不幸的是，我们无法提供更多细节，因为要求证书的流程过于复杂。一旦你获得证书，你可以使用以下命令从它生成一个密钥：
- en: '[PRE68]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then you can add the preceding secret to your `frontend-ingress.yaml Ingress`
    by adding the following `spec->tls` section to it:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过添加以下 `spec->tls` 部分到 `frontend-ingress.yaml Ingress` 中，将前面的密钥添加到你的 `frontend-ingress.yaml
    Ingress`：
- en: '[PRE69]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Following the correction, upload the file to your Azure Cloud Shell instance
    and update the previous Ingress definition with the following:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在更正后，将文件上传到你的 Azure Cloud Shell 实例，并使用以下内容更新之前的 Ingress 定义：
- en: '[PRE70]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: At this point, you should be able to access the Guestbook application with HTTPS.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该能够使用 HTTPS 访问 Guestbook 应用程序。
- en: 'When you are done experimenting, please don’t forget to delete everything from
    your cluster to avoid wasting your free Azure credit. You can do this by means
    of the following commands:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成实验后，请不要忘记从你的集群中删除所有内容，以避免浪费你的免费 Azure 信用额度。你可以通过以下命令来完成此操作：
- en: '[PRE71]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we described Kubernetes’ basic concepts and objects, and then
    we explained how to create an AKS cluster. We also showed how to deploy applications
    and how to monitor and inspect the state of your cluster with a simple demo application.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了 Kubernetes 的基本概念和对象，然后解释了如何创建 AKS 集群。我们还展示了如何部署应用程序，以及如何使用简单的演示应用程序监控和检查集群的状态。
- en: The chapter also described more advanced Kubernetes features that have fundamental
    roles in practical applications, including how to provide persistent storage to
    the containers running on Kubernetes, how to inform Kubernetes of the health state
    of your containers, and how to offer advanced HTTP services, such as HTTPS and
    name-based virtual hosting.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还描述了更多在实用应用程序中具有基本角色的 Kubernetes 高级功能，包括如何为在 Kubernetes 上运行的容器提供持久存储，如何通知
    Kubernetes 容器的健康状态，以及如何提供高级 HTTP 服务，例如 HTTPS 和基于名称的虚拟主机。
- en: Finally, we reviewed how to install complex applications with Helm, and gave
    a short description of Helm and Helm commands.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们回顾了如何使用 Helm 安装复杂的应用程序，并对 Helm 及 Helm 命令进行了简要介绍。
- en: Up next, we have the book’s case study.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍本书的案例研究。
- en: Questions
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why are Services needed?
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么需要服务？
- en: Why is an Ingress needed?
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么需要 Ingress？
- en: Why is Helm needed?
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么需要 Helm？
- en: Is it possible to define several Kubernetes objects in the same `.yaml` file?
    If yes, how?
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个 `.yaml` 文件中定义多个 Kubernetes 对象是否可能？如果是，该如何操作？
- en: How does Kubernetes detect container faults?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes 如何检测容器故障？
- en: Why are persistent volume claims needed?
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么需要持久卷声明？
- en: What is the difference between a ReplicaSet and a StatefulSet?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ReplicaSet 和 StatefulSet 之间有什么区别？
- en: Further reading
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'A good book for extending the knowledge acquired in this chapter is the following:
    [https://www.packtpub.com/product/hands-on-kubernetes-on-azure-second-edition/9781800209671](https://www.packtpub.com/product/hands-on-kubernetes-on-azure-second-edition/9781800209671).'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展本章所学知识的好书如下：[https://www.packtpub.com/product/hands-on-kubernetes-on-azure-second-edition/9781800209671](https://www.packtpub.com/product/hands-on-kubernetes-on-azure-second-edition/9781800209671)。
- en: 'The official documentation for Kubernetes and `.yaml` files can be found here:
    [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/).'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 和 `.yaml` 文件的官方文档可以在这里找到：[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)。
- en: 'More information on Helm and Helm charts can be found in the official documentation.
    This is extremely well written and contains some good tutorials: [https://helm.sh/](https://helm.sh/).'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Helm 和 Helm 图表的更多信息可以在官方文档中找到。这是一份非常优秀的文档，包含了一些很好的教程：[https://helm.sh/](https://helm.sh/).
- en: 'The official documentation for Azure Kubernetes can be found here: [https://docs.microsoft.com/en-US/azure/aks/](https://docs.microsoft.com/en-US/azure/aks/).'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Kubernetes 的官方文档可以在此处找到：[https://docs.microsoft.com/en-US/azure/aks/](https://docs.microsoft.com/en-US/azure/aks/).
- en: 'The official documentation on the Azure Application Gateway-based Ingress Controller
    is available here: [https://github.com/Azure/application-gateway-kubernetes-ingress](https://github.com/Azure/application-gateway-kubernetes-ingress).'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 Azure Application Gateway 的入口控制器的官方文档可在以下链接找到：[https://github.com/Azure/application-gateway-kubernetes-ingress](https://github.com/Azure/application-gateway-kubernetes-ingress).
- en: 'Ingress certificate release and renewal can be automated as explained here:
    [https://docs.microsoft.com/azure/application-gateway/ingress-controller-letsencrypt-certificate-application-gateway](https://docs.microsoft.com/azure/application-gateway/ingress-controller-letsencrypt-certificate-application-gateway).
    While the procedure specifies an Azure Application Gateway-based ingress controller,
    it is adequate for any Ingress Controller.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入口证书的发布和续订可以自动化，具体说明请参阅此处：[https://docs.microsoft.com/azure/application-gateway/ingress-controller-letsencrypt-certificate-application-gateway](https://docs.microsoft.com/azure/application-gateway/ingress-controller-letsencrypt-certificate-application-gateway)。虽然该流程指定了基于
    Azure Application Gateway 的入口控制器，但它适用于任何入口控制器。
- en: Leave a review!
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下您的评价！
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below for a 20% discount code.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢这本书吗？通过留下亚马逊评价来帮助像您这样的读者。扫描下面的二维码以获取 20% 的折扣码。
- en: '![](img/Leave_a_review_QR.png)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Leave_a_review_QR.png)'
- en: '**Limited Offer*'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**限时优惠*'
