- en: Chapter 5. Producing Tabular Reports
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：生成表格报告
- en: 'In this chapter, we will create a library that will help application developers
    to create tabular reports using a custom **Document Object Model** (**DOM**),
    created for this purpose. The tree-structured document object model will be traversed
    to produce output in the Adobe® **Portable Document Format** (**PDF**) and HTML
    format. Support for new target formats would be seamless, with developers writing
    handlers for those. For PDF output, we plan to use the open source **iTextSharp**
    library. During the course of this chapter, as a reader, you will learn the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个库，帮助应用开发者使用为此目的创建的定制**文档对象模型**（**DOM**）来创建表格报告。我们将遍历树状结构的文档对象模型，以生成Adobe®
    **便携式文档格式**（**PDF**）和HTML格式的输出。对新目标格式的支持将无缝进行，开发者只需编写相应的处理器。对于PDF输出，我们计划使用开源的**iTextSharp**库。在本章的阅读过程中，作为读者，你将学习以下内容：
- en: Defining an object model for documents
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义文档的对象模型
- en: The composite pattern for modeling part/whole relationship
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于建模部分/整体关系的组合模式
- en: Producing PDF documents by leveraging the iTextSharp library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过利用iTextSharp库生成PDF文档
- en: The visitor pattern and composite object traversal
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者模式和组合对象遍历
- en: Requirements for the library
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库的需求
- en: 'Before we embark on writing the library, let us scribble down a preliminary
    requirements statement as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们着手编写库之前，让我们先草拟一个初步的需求声明如下：
- en: For a large class of business applications, we require tabular reports in various
    formats. The popular choice for output formats are PDF, HTML, SVG, and so on.
    We should create a library to produce tabular output in these formats. The library
    should define a unified programming model, and serve as an API for the developers.
    The contents of the documents and its tables should be separated from the processing
    layer to incorporate future output drivers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大量商业应用，我们需要各种格式的表格报告。流行的输出格式选择包括PDF、HTML、SVG等。我们应该创建一个库来生成这些格式的表格输出。该库应定义一个统一的编程模型，并作为开发者的API。文档内容和其表格的内容应与处理层分离，以便纳入未来的输出驱动程序。
- en: Solutions approach
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案方法
- en: 'Before writing the code, let us step back a bit to enumerate the details of
    the requirements. The library which we are planning to write should have the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码之前，让我们稍微退后一步，列举一下需求细节。我们计划编写的库应该具备以下特点：
- en: Support for various output formats like HTML, PDF, and so on
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持各种输出格式，如HTML、PDF等
- en: An object model for storing the contents of the table
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储表格内容的对象模型
- en: A unified programming model and API for developers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为开发者提供的统一编程模型和API
- en: Separate content and it's processing
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离内容和其处理
- en: The ability to write new pluggable output processors (drivers)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写新的可插拔输出处理器（驱动程序）的能力
- en: 'We will start by creating a hierarchy of elements for storing document contents.
    A simple hierarchy which has been conceived is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个用于存储文档内容的元素层次结构。一个简单的设计如下：
- en: '![Solutions approach](img/B05691_05_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![解决方案方法](img/B05691_05_02.jpg)'
- en: We will encode our content in a tree-structured document model. For the sake
    of simplicity, we have reduced the number of document elements. In an industrial
    strength implementation of this library, we will have many more elements. We can
    create tables within tables in this scheme, as we allow nested tables. Before
    we get into the implementation of the aforementioned hierarchy, we will look into
    the specifics of the creation of a PDF document using an open source library.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在树状文档模型中编码我们的内容。为了简化，我们减少了文档元素的数量。在库的工业强度实现中，我们将有更多的元素。我们可以在这种方案中创建表格内的表格，因为我们允许嵌套表格。在我们开始实现上述层次结构之前，我们将探讨使用开源库创建PDF文档的具体细节。
- en: iTextSharp for the PDF output
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于PDF输出的iTextSharp
- en: To produce the output of a document in the PDF format, we plan to use the .NET
    version of the open source iText library.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成PDF格式的文档输出，我们计划使用开源iText库的.NET版本。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The library can be downloaded from the iTextSharp website at the following address: [https://www.nuget.org/packages/iTextSharp/](https://www.nuget.org/packages/iTextSharp/).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 该库可以从以下地址的iTextSharp网站上下载：[https://www.nuget.org/packages/iTextSharp/](https://www.nuget.org/packages/iTextSharp/)。
- en: 'A simple program, which produces a PDF document using the library, is given
    next to make the reader understand the programming model of this library:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的程序，它使用库生成一个PDF文档，紧随其后，以便让读者理解这个库的编程模型：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code will produce a PDF document with the contents given to the
    iTextsharp library through the iTextSharp API. Now we will focus on the creation
    of a DOM for storing our contents.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将生成一个PDF文档，该文档包含通过iTextSharp API传递给iTextsharp库的内容。现在我们将专注于创建一个DOM来存储我们的内容。
- en: Composite and visitor pattern - A quick primer
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合和访问者模式 - 快速入门
- en: 'Whenever we deal with hierarchies like W3C DOM, document formats, graphics
    database or **abstract syntax tree** (**AST**) of a compiler, we create part/whole
    relationship. The GoF composite pattern is natural choice for creating hierarchies.
    Building hierarchies and its processing can be separated using GoF visitor pattern.
    The visitor pattern visits each node in the hierarchy and perform some action
    on the node. In a compiler, the tree representation of a program will be processed
    for type checking, code generation, trans compilation (source to source transformation)
    and so on. Sometimes people would like to perform additional activities on the
    tree. It is not feasible to add methods for processing the nodes within a node.
    Whenever a programmer wants a new method, we are forced to change every node in
    the hierarchy. A mechanism is necessary for processing to be decoupled from the
    nodes in a hierarchy. When we use visitor pattern, the nodes within the hierarchy
    becomes a container for data alone. We will write an expression composite to model
    a four function calculator to demonstrate the composite and visitor:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理像W3C DOM、文档格式、图形数据库或编译器的**抽象语法树**（**AST**）这样的层次结构时，我们创建部分/整体关系。GoF组合模式是创建层次结构的一个自然选择。使用GoF访问者模式可以将层次结构的构建和处理分离。访问者模式遍历层次结构中的每个节点并在节点上执行某些操作。在一个编译器中，程序的树表示将被用于类型检查、代码生成、跨编译（源到源转换）等。有时人们希望在树上执行额外的活动。在节点内部添加处理节点的方法是不可行的。每当程序员想要一个新方法时，我们就被迫更改层次结构中的每个节点。需要一个机制来解耦层次结构中的节点处理。当我们使用访问者模式时，层次结构内的节点仅成为数据的容器。我们将编写一个表达式组合来模拟一个四功能计算器，以展示组合和访问者模式：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The hierarchy for an expression is
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的层次结构是
- en: '`Expr`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Expr`'
- en: '`Number`'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number`'
- en: '`BinaryExpr`'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BinaryExpr`'
- en: '`UnaryExpr`'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnaryExpr`'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following class will store an IEEE 754 double precision floating point
    value. Our evaluator will handle only constants, as an expression evaluator which
    supports variables will take additional effort and won''t serve our primary purpose
    of demonstrating the composite and visitor pattern:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的类将存储一个IEEE 754双精度浮点值。我们的评估器将只处理常量，因为支持变量的表达式评估器将需要额外的努力，而且不会服务于我们演示组合和访问者模式的初衷：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have created the `Number` node, we should create a node to compose
    values through a binary operator. The binary operators supported are `+`, `-`,
    `/`, `*` and the class has been named `BinaryExpr`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`Number`节点，我们应该创建一个节点来通过二元运算符组合值。支持的二元运算符有`+`、`-`、`/`、`*`，并且这个类被命名为`BinaryExpr`：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following class implements unary expression node. We support unary operators
    `+` and `-`, in our evaluator:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的类实现了单元表达式节点。在我们的评估器中，我们支持单元运算符`+`和`-`：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have defined a expression hierarchy which can be composed to form arithmetical
    expressions of arbitrary complexity. Our nodes store only data and references
    to child nodes. The processing of nodes are decoupled from the node proper, using
    visitor pattern. Let us see couple of examples which we can use to compose arithmetical
    expression. As an example, let us see how we can store the expression *1+2* using
    our composites:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个表达式层次结构，它可以组合成任意复杂性的算术表达式。我们的节点只存储数据和子节点的引用。节点的处理与节点本身解耦，使用访问者模式。让我们看看几个例子，我们可以用它们来组合算术表达式。作为一个例子，让我们看看我们如何使用我们的组合来存储表达式
    *1+2*：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The expression *2+3*4* can be encoded as:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 *2+3*4* 可以编码为：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can compose expressions of arbitrary complexity using this method. Now, we
    will see how we can process these composites using the visitor pattern. As an
    example, we will write a visitor which generates **Reverse Polish Notation** (**RPN**)
    from our expression tree. RPN is also called postfix notation and are used in
    some calculators and Forth programming language. Read more about RPN from the
    Internet.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种方法构建任意复杂性的表达式。现在，我们将看看我们如何使用访问者模式处理这些组合。作为一个例子，我们将编写一个生成 **逆波兰表示法**（**RPN**）的访问者。RPN
    也称为后缀表示法，在一些计算器和 Forth 编程语言中使用。从互联网上了解更多关于 RPN 的信息。
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The above class can be invoked as follows. We will show how one can convert
    the expression *2+3*4* to *2 3 4 * +*. Let us encode the expression using our
    expression hierarchy as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类可以按如下方式调用。我们将展示如何将表达式 *2+3*4* 转换为 *2 3 4 * +*。让我们使用我们的表达式层次结构来编码表达式如下：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The expression hierarchy composed above can be traversed by `ReversePolishEvaluator`
    to produce *2 3 4 * +* as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上述构建的表达式层次结构可以通过 `ReversePolishEvaluator` 进行遍历，从而产生 *2 3 4 * +* 如下所示：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The whole purpose of creating an expression tree to evaluate it. We will write
    a stack based expression evaluator to demonstrate the use of visitor pattern:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表达式树并对其进行评估的整个目的。我们将编写一个基于栈的表达式评估器来演示访问者模式的用法：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The above stack evaluator can be invoked as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上述栈评估器可以按如下方式调用：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have finished our discussion on visitor and composite pattern. In the above
    example, we defined a small hierarchy to compose mathematical expressions and
    processed it using visitor classes which traversed the composite to produce RPN
    expression and evaluate it using a stack. This technique is widely used wherever
    one is supposed to process a hierarchy. Let us focus on how to create a document
    hierarchy and process it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了对访问者和组合模式的讨论。在上面的例子中，我们定义了一个小的层次结构来构建数学表达式，并使用遍历组合的访问者类来处理它，从而生成 RPN
    表达式并使用栈进行评估。这种技术在需要处理层次结构的地方被广泛使用。让我们关注如何创建文档层次结构并处理它。
- en: The composite pattern and document composition
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合模式和文档组合
- en: 'While representing part-whole hierarchies (tree-structured), the composite
    design pattern describes a group of objects to be treated in a uniform manner,
    as if the leaf node and interior nodes are instances of the same object. A document
    object can contain multiple tables, and we can nest tables as well. This is an
    instance of a part-whole hierarchy, and composite design pattern is a natural
    choice here. To create a composite, we need to declare a base class, and all objects
    should be derived from this base class:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在表示部分-整体层次结构（树状结构）时，组合设计模式描述了一组应以统一方式处理的对象，就像叶节点和内部节点是同一对象的实例一样。文档对象可以包含多个表格，我们也可以嵌套表格。这是一个部分-整体层次结构的实例，组合设计模式在这里是一个自然的选择。要创建组合，我们需要声明一个基类，并且所有对象都应该从这个基类派生：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `TDocumentElement` class acts as a base class for all the classes in the
    object model. Please note the following two important things about the `TDocumentElement`
    class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`TDocumentElement` 类作为对象模型中所有类的基类。请注意关于 `TDocumentElement` 类的以下两个重要事项：'
- en: The first one is the `DocumentElements` property. Every `TDocumentElement` has
    a list of `TDocumentElement` to store its child objects. This means, we can insert
    a list of concrete objects which implements `TDcoumentElement` as a child. Using
    this technique, we can compose a document hierarchy of arbitrary complexity.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一项是 `DocumentElements` 属性。每个 `TDocumentElement` 都有一个 `TDocumentElement` 列表来存储其子对象。这意味着，我们可以插入一个实现
    `TDcoumentElement` 的具体对象列表作为子对象。使用这种技术，我们可以构建任意复杂性的文档层次结构。
- en: The second thing is the presence of an abstract method called `accept`. The
    `accept` method is a mechanism by which we will be able to separate the operations
    on node and the node data structure. We will learn more about the semantics of
    the `accept` method in a later section.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二点是存在一个名为 `accept` 的抽象方法。`accept` 方法是一种机制，通过它我们可以将节点操作和节点数据结构分开。我们将在后面的章节中了解更多关于
    `accept` 方法的语义。
- en: The topmost class in the hierarchy is `TDocument`, which acts as a container
    for a hierarchical collection of the `TDocumentElement` derived class. The class
    will store all the child contents (concrete classes of base type `TDocumentElement`)
    to be embedded inside the document.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构中最顶层的类是 `TDocument`，它作为 `TDocumentElement` 派生类的分层集合的容器。该类将存储要嵌入文档中的所有子内容（基类型为
    `TDocumentElement` 的具体类）。
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Application developers can leverage the `addObject` method available in the
    `TDocumentElement` class to add contents to `TDocument`. In our canned example,
    the most obvious choice is a list of tables. The `accept` method makes a call
    to the visitor's visit method with the `TDocument` instance (this) as a parameter.
    This will hit the `visit(TDocument)` method implemented in a class, which implements
    the `IDocumentVisitor` interface. More on visitor pattern and its implementation
    is available in a later section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发者可以利用`TDocumentElement`类中可用的`addObject`方法向`TDocument`添加内容。在我们的示例中，最明显的选择是表格列表。`accept`方法调用访问者的`visit`方法，并将`TDocument`实例（this）作为参数。这将调用实现`IDocumentVisitor`接口的类中实现的`visit(TDocument)`方法。有关访问者模式和其实现的更多内容将在后面的章节中介绍。
- en: The `TDocumentTable` models a table object, which can be embedded inside a document.
    Since the `TDocumentTable` object inherits from `TDocumentElement`, we can add
    any `TDocumentElement` derived class as a child. With this technique, we can embed
    objects of arbitrary complexity. But, for our library, an Instance of `TDocumentTable`
    is the natural choice as the first child of the `TDocument` object.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`TDocumentTable`模型了一个可以嵌入文档中的表格对象。由于`TDocumentTable`对象继承自`TDocumentElement`，我们可以将任何`TDocumentElement`派生类作为子项添加。使用这种技术，我们可以嵌入任意复杂性的对象。但是，对于我们的库，`TDocumentTable`实例是作为`TDocument`对象第一个子项的自然选择。'
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Inside a table, we store data as a series of rows, and the class for storing
    information is appropriately named `TDocumentTableRow`. We can insert another
    table as a child as well. One can embed a table within a table. For the sake of
    brevity, we have not included that feature in the current implementation. If we
    need to support nested tables, we need to incorporate a data structure called
    scope tree. The listing of such an implementation cannot be conveniently included
    in a book.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在表格内部，我们以一系列行的方式存储数据，用于存储信息的类被适当地命名为`TDocumentTableRow`。我们也可以将另一个表格作为子项插入。可以在表格内嵌套表格。为了简洁起见，我们尚未在当前实现中包含该功能。如果我们需要支持嵌套表格，我们需要合并一个称为作用域树的数据结构。此类实现的列表无法方便地包含在书中。
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A row is a collection of cells, and inside each cell, we can store arbitrary
    text. It is possible to store an image as well, but, for the sake of brevity,
    we have limited the cell contents to text. The image or another content type can
    be incorporated very easily following the schema used for text.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 行是一系列单元格的集合，在每一个单元格中，我们可以存储任意文本。也可以存储图像，但为了简洁起见，我们已将单元格内容限制为文本。根据用于文本的方案，可以非常容易地合并图像或其他内容类型。
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Every cell in the table contains a text item for our implementation. We model
    the text using the `TDocumentText` class. In this class, the `Text` property is
    used to store and load text.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中的每个单元格都包含一个用于我们的实现的文本项。我们使用`TDocumentText`类来模拟文本。在这个类中，`Text`属性用于存储和加载文本。
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Thus, we have defined our DOM. You can see the UML representation of the composite
    pattern in action in the following diagram:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了我们的DOM。您可以在以下图中看到组合模式的作用的UML表示：
- en: '![The composite pattern and document composition](img/B05691_05_01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![组合模式和文档组合](img/B05691_05_01.jpg)'
- en: Now we need to create a mechanism to traverse the hierarchy to produce the output
    of our choice.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个机制来遍历层次结构以生成我们选择的输出。
- en: Visitor pattern for document traversal
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档遍历的访问者模式
- en: The tree-structured DOM created by us needs to be traversed to produce the content
    in an output format like HTML, PDF, or SVG.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的树形DOM需要遍历以生成类似HTML、PDF或SVG的输出格式的内容。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The composite tree created by us can be traversed using the GoF visitor pattern.
    Wherever composite pattern is used for composing an hierarchy of objects, the
    visitor pattern is a natural choice for the traversal of the tree.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的复合树可以使用GoF访问者模式进行遍历。无论何时使用组合模式来组合对象层次结构，访问者模式都是遍历树的天然选择。
- en: 'In a visitor pattern implementation, every node in the composite tree will
    support a method called `accept`, which takes a visitor concrete class as a parameter.
    The job of the `accept` routine is to reflect the call to the appropriate visit
    method in the visitor concrete class. We declare an interface named `IDocumentVisitor`
    with methods for visiting each of the elements in our hierarchy as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问者模式实现中，复合树中的每个节点都将支持一个名为`accept`的方法，该方法接受一个访问者具体类作为参数。`accept`例程的职责是将对访问者具体类中适当访问方法的调用反射出来。我们声明一个名为`IDocumentVisitor`的接口，其中包含用于访问我们层次结构中每个元素的方法，如下所示：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The traversal of the tree should start from the top node of the tree. In our
    case, we start the traversal from the `TDocument` node. For each node in the hierarchy,
    we will add an `accept` method, which takes an instance of `IDocumentVisitor`.
    The signature of this function is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 树的遍历应从树的顶层节点开始。在我们的情况下，我们从 `TDocument` 节点开始遍历。对于层次结构中的每个节点，我们将添加一个 `accept`
    方法，它接受 `IDocumentVisitor` 的一个实例。此函数的签名如下：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Each element of the document node which derives from `TDocumentElement` needs
    to have an implementation of this method. For example, the body of the `TDocument`
    class is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `TDocumentElement` 派生的文档节点元素需要实现此方法。例如，`TDocument` 类的体如下所示：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the `TDocument` class, the `accept` method will reflect the call to the `IDocumentVisitor
    visit(TDocument)` method implemented by the `Visitor` class. In the `Visitor`
    class, for each node inserted as a child, a call to the `accept` method of the
    respective nodes will be triggered. Each time the call gets reflected back to
    the appropriate visit method of the `Visitor` class. In this manner, the accept/visit
    pair processes the whole hierarchy.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TDocument` 类中，`accept` 方法将反映 `Visitor` 类实现的 `IDocumentVisitor visit(TDocument)`
    方法的调用。在 `Visitor` 类中，对于每个作为子节点插入的节点，将触发对该节点 `accept` 方法的调用。每次调用都会反射回 `Visitor`
    类的相应访问方法。以这种方式，accept/visit 对处理整个层次结构。
- en: 'The traversal starts with the `TDocument accept` method, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历从 `TDocument accept` 方法开始，如下所示：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `ds` object is of type `TDocument`, and the `accept` method takes an instance
    of the `IDocumentVisitor` interface. In the document object, the call gets reflected
    to the `IDocumentVisitor visit(TDocument)` method.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`ds` 对象是 `TDocument` 类型，`accept` 方法接受 `IDocumentVisitor` 接口的一个实例。在文档对象中，调用会反射到
    `IDocumentVisitor visit(TDocument)` 方法。'
- en: PDFVisitor for PDF generation
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PDFVisitor 用于 PDF 生成
- en: 'We have defined our object hierarchy and an interface to traverse the hierarchy.
    Now we need to implement routines to traverse the tree. The `PDFVisitor` class
    implements the `IDocumentVisitor` interface, as shown in the following code snippet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了我们的对象层次结构和遍历层次结构的接口。现在我们需要实现遍历树的例程。`PDFVisitor` 类实现了 `IDocumentVisitor`
    接口，如下代码片段所示：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `visit` method, which takes `TDocument` as a parameter, adds some metadata
    to the PDF document being created. After this operation, the method inspects all
    the child elements of `TDocument`, and issues an `accept` method call with the
    current visitor instance. This invokes the `accept` method of the concrete class
    of `TDocumentElement` embedded as a child object:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`visit` 方法，它以 `TDocument` 作为参数，向正在创建的 PDF 文档添加一些元数据。在此操作之后，该方法检查 `TDocument`
    的所有子元素，并使用当前访问实例发出 `accept` 方法调用。这调用了嵌入作为子对象的 `TDocumentElement` 具体类的 `accept`
    方法：'
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `TDocumentTable` object will be handled by the `visit` method in a similar
    fashion. Once we have worked with the node, all the children stored in `DocumentElements`
    will be processed by invoking the `accept` method of each of the node element
    embedded inside the table:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`TDocumentTable` 对象将以类似的方式由 `visit` 方法处理。一旦我们处理了节点，存储在 `DocumentElements` 中的所有子节点将通过调用嵌入表中的每个节点元素的
    `accept` 方法进行处理：'
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Mostly, an instance of `TDocumentTableRow` is included as a child of `TDocumentTable`.
    For our implementation, we will navigate to all the children of a row object,
    issuing accept calls to the respective nodes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`TDocumentTableRow` 的实例被包含为 `TDocumentTable` 的子节点。对于我们的实现，我们将遍历行对象的全部子节点，对相应的节点发出
    `accept` 调用：
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A table is a collection of rows, and a row is a collection of cells. Each of
    the cells contains some text. We can add a collection of text inside a cell as
    well. Our implementation assumes that we will store only one text.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 表是行的集合，行是单元格的集合。每个单元格包含一些文本。我们还可以在单元格内添加文本集合。我们的实现假设我们只存储一个文本。
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To process `TDocumentTableCell`, we iterate through all the child elements
    of a cell, and these elements are instances `TDocumentText`. For the sake of brevity,
    we have included an attribute called `Text` to store the contents of a cell there:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理 `TDocumentTableCell`，我们遍历单元格的所有子元素，这些元素是 `TDocumentText` 的实例。为了简洁起见，我们包含了一个名为
    `Text` 的属性来存储单元格的内容：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `TDocumentText` class has a property by the name of `Text`, where an application
    developer can store some text. That will be added to the table:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`TDocumentText` 类有一个名为 `Text` 的属性，其中应用程序开发者可以存储一些文本。这将添加到表中：'
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: HTMLVisitor for HTML generation
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTMLVisitor 用于 HTML 生成
- en: 'The `HTMLVisitor` class produces HTML output by traversing the DOM. The skeleton
    implementation of `HTMLVisitor` is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTMLVisitor`类通过遍历DOM来生成HTML输出。`HTMLVisitor`的骨架实现如下：'
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `HTMLVisitor` class can be leveraged as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可以如下使用`HTMLVisitor`类：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The client program
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端程序
- en: 'A simple program which leverages the DOM is given next. We create a `TDocument`
    object as a top-level node, and add the rest of the document contents as child
    nodes to the respective classes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的简单程序展示了如何利用DOM。我们创建一个`TDocument`对象作为顶级节点，并将文档的其他内容作为子节点添加到相应的类中：
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a library for producing tabular reports in various
    formats. In the process, we learned about creating arbitrary hierarchies of objects
    in a tree-structured manner. We leveraged the composite pattern to implement our
    hierarchy. The composites were processed using the visitor pattern. We dealt with
    PDF and HTML output by writing `PDFVisitor` and `HTMLVisitor` classes. Incorporating
    a new output format is just a matter of writing a new visitor (say, `SVGVisitor`),
    where one needs to map the contents of the document to the appropriate SVG tags.
    In the next chapter, we will learn about the interpreter pattern and the observer
    pattern by implementing a library that will help us plot arbitrary expressions
    as graphs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个用于生成各种格式的表格报告的库。在这个过程中，我们学习了以树状结构创建任意对象层次的方法。我们利用组合模式来实现我们的层次结构。复合对象通过访问者模式进行处理。我们通过编写`PDFVisitor`和`HTMLVisitor`类来处理PDF和HTML输出。引入新的输出格式只需编写一个新的访问者（例如，`SVGVisitor`），其中需要将文档内容映射到适当的SVG标签。在下一章中，我们将通过实现一个帮助我们将任意表达式作为图表绘制的库来学习解释器模式和观察者模式。
