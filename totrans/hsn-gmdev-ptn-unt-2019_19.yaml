- en: Decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Decorator is one of those rare patterns where the name represents its purpose
    perfectly. As its name implies, the Decorator pattern permits us to decorate an
    object; this is, of course, a very vague explanation. So, a more concrete but
    simple explanation of its core purpose is that it offers us a way to decorate
    old code with new code, by dynamically adding functionality to an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We will review the basics of the Decorator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will build a system to add attachments to a rifle dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is hands-on, so you will need to have a basic understanding of
    Unity and C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following specific Unity engine and C# language concept:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are unfamiliar with this concept, please review it before starting this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2U0MT6x](http://bit.ly/2U0MT6x)'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of the Decorator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Decorator pattern is the type of pattern that you would need to implement
    in code in order to fully understand, so we are going to keep the theory section
    brief. In its most basic form, the Decorator pattern offers us a mechanism that
    permits us to add behaviors to objects at runtime without altering the objects
    in the process.
  prefs: []
  type: TYPE_NORMAL
- en: As its name implies, it decorates objects; but it does so by chaining references
    of decorator objects through the constructor of a base class. It might sound abstract,
    but in practice it works, because of the way objects refer to each other in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following diagram in order to visualize the relationship
    structure between classes in the Decorator pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3d39cef-7c29-4fb1-8c3b-c7fe649bc279.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there's an interface, `IRifle`, which is offering an implementation
    contract to all classes that want to be rifles. But, the most important class
    in the diagram is the `RifleDecorator`. It's the class that will permit us to
    attach the `WithScope` and `WithStabilizer` decorators to any rifle object that
    implements `IRifle`.
  prefs: []
  type: TYPE_NORMAL
- en: But, before writing this in code, let's review some of the core benefits and
    possible drawbacks when using the Decorator pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Decorator pattern has an excellent reputation; it''s even a significant
    part of the Python language. So, its benefits often outweigh its drawbacks, as
    we can see in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative to subclassing**: The Decorator pattern focuses on injecting
    functionality into an object, instead of inheriting and then extending.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manageable permutations**: Features and requirements change all the time
    during production; the Decorator pattern offers a way to add functionality by
    distributing it through self-contained components, without modifying core implementations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime dynamics**: The Decorator pattern permits us to add functionality
    to an object at runtime without modifying it directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code complexity**: Like most advanced patterns, implementing the Decorator
    pattern can result in a more complex code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relationship complexity**: Keeping track of the chain of initialization and
    the relationships between decorators can become very complicated if there are
    multiple layers of decorators around an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The drawbacks of specific patterns are often related to the complexity and verbosity
    they add to a code base. It's mostly an issue when working in a team of members
    with various levels of experience, because junior programmers might not have the
    skills to recognize specific patterns just by reading the code.
  prefs: []
  type: TYPE_NORMAL
- en: Use case example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Weapons are an essential element of video games, especially in the first-person
    shooter (FPS) genre. A very cool and profitable feature to have in an FPS is weapon
    customization. The ability to upgrade a basic rifle by attaching new components
    to it, such as a scope or silencer, is very engaging. But, as a game programmer,
    having to write all these variations and configurations in code, in a structured
    and modular manner, can be very complicated.
  prefs: []
  type: TYPE_NORMAL
- en: But, with the Decorator pattern, we can reproduce the real-life concept of attaching
    components to a configurable weapon in code. This is what we are going to do in
    the following code example.
  prefs: []
  type: TYPE_NORMAL
- en: The Adapter and Decorator patterns are similar, but Adapter is used to adapt
    an object's interface, while Decorator enhances an object’s responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A particular thing to keep in mind in the following code example is that we
    are going to use constructors. It''s often recommended not to use them in Unity,
    because if you are working with `Monobehaviours` or `ScritableObjects` derived
    classes and you attach them to `GameObjects` included in a scene, the engine will
    automatically initialize them. But, in this example, we are going to break this
    rule; mainly because the Decorator is dependent on the internal mechanisms of
    the constructor, as we are going to see in the following code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin the implementation of our weapon customization system by writing
    an interface that will be used as an *implementation* *contract* for all our derived
    rifle types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, it's a simple interface with one function that returns the accuracy
    value of a rifle as a float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a standard interface for all our rifle objects, let''s write
    a concrete rifle class that will represent a basic configuration of a rifle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `BasicRifle` class is doing nothing special; it just implements the `IRifle`
    interface; but we are going to use it as a foundation object that we are going
    to decorate with attachments that will upgrade its default accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need a class that will take the responsibility of attaching the decorators
    to our `BasicRifle` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are implementing the core of the Decorator pattern in the `RifleDecorator`
    class. We can see that the `RifleDecorator` class is implementing the `IRifle`
    interface, but there's a small detail that's very important to notice. The `GetAccuracy()`
    function is virtual, which means that any derived class of `RifleDecorator` will
    be able to override it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our Decorator class, let''s see how an actual decorator object
    will attach itself to our `BasicRifle` object during runtime:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to notice is the constructor; it takes an `IRifle` type object
    as an argument, and then calls its base constructor. This approach might seem
    very tangled at first view, but it's going to become clear once we implement the
    client side of this example. Another detail to note is that we are overriding
    the `GetAccuracy()` function, but also changing the overall accuracy of the rifle
    by adding `m_ScopeAccurancy` to the base value in the return path.
  prefs: []
  type: TYPE_NORMAL
- en: 'To showcase the flexibility of the Decorator pattern, let''s add another decorator
    to our example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`WithStabilizer` has the same implementation as the `WithScope`, except for
    the final accuracy value that it returns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to implement the client; this is where we are going to trigger
    the decoration feature of the Decorator pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important element to notice in this class is the chaining of the constructor
    calls in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With this line of code, we are basically attaching the `WithScope` and `WithStabilizer`
    decorators to a `BasicRifle` instance by chaining them with the base constructor.
  prefs: []
  type: TYPE_NORMAL
- en: So, we can now get different accuracy outputs depending on how many attachments
    we attach to the `BasicRifle` instance, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code returns accuracy of `5.0f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code returns accuracy of `25.0f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code returns accuracy of `35.0f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, by using the Decorator pattern, we now have an underlying implementation
    of a dynamic weapon customization system that we can extend to build a collection
    of runtime attachments for our game's weaponry.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we reviewed a pattern that offers a game programmer a flexible
    way to implement an often requested feature – weapon customization. It appears
    that the Decorator pattern was perfectly designed to accomplish this type of task.
    But, as you can imagine, the Decorator can be used to implement all kinds of customizable
    systems and features, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Vehicle upgrades
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Armour and clothing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will transition out of Behavioral patterns and will
    instead focus on Decouplers, starting with the Event Bus.
  prefs: []
  type: TYPE_NORMAL
- en: Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we decided to use native C# constructors, which is proper because
    we were not using `MonoBehaviours` or `ScritableObjects`. But this not always
    the case, so, as an exercise, you should try to refactor the code example we just
    completed, but without any constructors and primarily using native Unity `MonoBehaviours`
    and `ScriptableObjects`.
  prefs: []
  type: TYPE_NORMAL
- en: You can find hints on how to accomplish this in the official Unity API documentation
    on `ScriptableObjects`; please check the *Further reading* section for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Unity – Scripting API: ScriptableObject* [https://docs.unity3d.com/ScriptReference/ScriptableObject.html](https://docs.unity3d.com/ScriptReference/ScriptableObject.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erich Gamma,
    John Vlissides, Ralph Johnson, and Richard Helm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610](http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
