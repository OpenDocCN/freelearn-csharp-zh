- en: Chapter 5.  Algebraic Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, I turn to the F# features that are (almost) missing among
    mainstream programming languages, such as C#, that are collectively referred to
    in computer science as **algebraic data types** ([https://en.wikipedia.org/wiki/Algebraic_data_type](https://en.wikipedia.org/wiki/Algebraic_data_type)
    ). They advance primitive data types to the higher type level with the help of
    the composition of other types (primitive or in-turn composite) which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tuples** and **records** that represent *product algebraic data types*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Discriminated unions** that represent *sum algebraic types*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I''ll cover the same facets for each of these composite types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Type composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type equality and comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type decomposition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type augmentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I will revisit the pattern matching as a type decomposition facility that can
    often be applied outside of the `match` construction.
  prefs: []
  type: TYPE_NORMAL
- en: Combining data with algebraic data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually a conventional programmer considers the matter of data composition through
    the prism of the object-oriented paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everyone usually intuitively understands that **primitive data types** are
    basic, built-in types supported by a compiler or library: `int64` , `string` ,
    `bigint` (although if viewed with a rigor, `string` may be considered as `char`
    array, and `bigint` as a **record** ).'
  prefs: []
  type: TYPE_NORMAL
- en: The next thing programmers learn is that instances of primitive types can be
    aggregated into collections such as **arrays** or **lists** . However, these collections
    are monomorphic. That is, the type of all collection members must be the same.
    Pretty limiting, huh?
  prefs: []
  type: TYPE_NORMAL
- en: The object-oriented paradigm extends primitive types with **classes** . The
    class just represents a custom type that hides the details of the data composition
    with the help of encapsulation and offers visibility to just the public properties.
    Typically, .NET libraries offer plenty of such composite types, for example, `System.DateTime`
    .
  prefs: []
  type: TYPE_NORMAL
- en: F# certainly supports this way of constructing composite data types as well.
    However, following the cumbersome and error-prone venue of **Plain ** **Old **
    **C ** **Objects** ( **POCO** ) each time when a composite type is required is
    not in line with the F# promise of succinct and error-free code. What would be
    the way out? Welcome to algebraic data types!
  prefs: []
  type: TYPE_NORMAL
- en: Product algebraic data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the simplest case, consider that I use the analogy of *set product* to combine
    types `A` and `B` ; the result would be a set of data pairs where the first pair
    constituent is of type `A` , the second constituent is of type `B` , and the whole
    combination is a Cartesian product of A and B.
  prefs: []
  type: TYPE_NORMAL
- en: F# offers two product algebraic data types, that is, **tuples** and **records**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have already touched tuples in previous chapters; now I'll go deeper into
    this subject.
  prefs: []
  type: TYPE_NORMAL
- en: Tuple composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A tuple is a combination of two or more values of any type. The tuple value
    element type can be of anything: primitive types, other tuples, custom classes,
    and functions. For example, take a look at the following code line (`Ch5_1.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This represents a tuple assembled from three elements of type `int* string *
    (unit -> int)` .
  prefs: []
  type: TYPE_NORMAL
- en: In order to belong to the same type of tuple, two tuple values must have the
    same number of elements with the similar types in the order of occurrence.
  prefs: []
  type: TYPE_NORMAL
- en: Tuple equality and comparison
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'F# automatically implements the structural equality for tuples if each element
    type supports the equality constraint. Tuples are equal if all their elements
    are equal pairwise as shown in the following code (`Ch5_1.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding equality expression value is `true` . However, for the value
    of `tuple` bound above the following expression does not compile (`Ch5_1.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The compiler complains that the `(unit -> int)` type, which is the function
    forming the third element of the tuple, does not support the `'equality'` constraint.
    The equality relationship is not defined for the F# function values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Structural comparison for tuples is similarly provided by F# out of the box
    and is based on pairwise comparisons of elements in a lexicographical order from
    left to right given that all element types fulfill the `''comparison''` constraint
    as shown in the following code (`Ch5_1.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding expression value is `true` .
  prefs: []
  type: TYPE_NORMAL
- en: Tuple decomposition with pattern matching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter is the perfect place to keep the promise I made in [Chapter 4](text00039.html#page
    "Chapter 4.  Basic Pattern Matching") , *Basic Pattern Matching* regarding pattern
    matching in the capacity of the data structure disassembling tool. The following
    code snippet demonstrates how value binding can carry the functionality of pattern
    matching outside of the `match` construction (`Ch5_1.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, `elem1` and `elem2` effectively acquire values of the first and second
    elements of tuple `a` , which is reflected by the `(1,car)` output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Elements of a tuple that are of no interest within a particular tuple disassemble
    pattern may be omitted using the familiar match-all `_` template, as shown in
    the following code (`Ch5_1.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This snippet highlights how to obtain and invoke a function extracted from the
    third element of the tuple value; the first two tuple elements are simply ignored
    with the help of the `_` template.
  prefs: []
  type: TYPE_NORMAL
- en: Tuple augmentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tuple type does not have an explicit name. This fact effectively makes normal
    F# type augmentation impossible. Nevertheless, there is still some space left
    for a good hack. This one exploits the need to have interop with other .NET languages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Documentation** ([https://msdn.microsoft.com/en-us/library/dd233200.aspx](https://msdn.microsoft.com/en-us/library/dd233200.aspx)
    ) states that the compiled form of a tuple represents the corresponding overload
    of class **Tuple** ([https://msdn.microsoft.com/en-us/library/system.tuple.aspx](https://msdn.microsoft.com/en-us/library/system.tuple.aspx)
    ). Given this fact, I can augment the compiled presentation and apply the augmented
    method using the cast, as shown in the following code (`Ch5_1.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, I have augmented a tuple of two generic elements that have type `System.Tuple<'T1,'T2>
    with` the `AsString` instance method, which allows a very distinctive presentation
    of the tuple value. Then, given the instance of the `int*string` tuple, I have
    upcasted it to `obj` type with the `box` function and then immediately downcasted
    it with `:?>` operator to `System.Tuple<int,string>` type, followed by calling
    the `AsString` augmented method on the deceivingly constructed `System.Tuple<int,string>`
    class instance, getting the expected result, that is, `[[1]:["car"]]` .
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping it up, I can conclude that tuples represent a simple algebraic data
    type that fits simple designs well. Using tuples instead of custom types for data
    composition is archetypal for idiomatic F# usage.
  prefs: []
  type: TYPE_NORMAL
- en: Records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Records represent the other F# native product algebraic data type. It addresses
    the matter that exceptional simplicity of tuples causing some deficiencies. The
    most unfavorable feature of tuples is the lack of binding of a tuple to a concrete
    kind of otherwise structurally similar tuple type. For the F# compiler, there
    is no difference between `(1,"car")` and `(10,"whiskey")` , which puts the burden
    of distinguishing the instance type upon the programmer. Would it be nice to supply
    structurally similar but semantically different types with explicit names? Also
    it would be helpful to label tuple constituents with unique names in order to
    stop relying just on the element position? Sure, welcome to F# **records** !
  prefs: []
  type: TYPE_NORMAL
- en: Record composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'F# records may be considered as the tuples of explicitly named types with labeled
    elements. Referring to the tuple sample given in the preceding script `Ch5_1.fsx`
    , it can be rewritten as follows (`Ch5_2.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After placing the preceding snippet into FSI, you get the result shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Record composition](img/Image00021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Defining the F# record type and instance
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot visually demonstrates the benefits of records over
    tuples when it comes to the unambiguous labeling of the whole and its parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, the naming of record fields makes it unnecessary to stick to
    a certain order of field listing as shown in the following code (`Ch5_2.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Without any problems, value `b` is recognized as a binding of type `transport`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'After being constructed, F# records are genuinely immutable, similar to tuples.
    The language provides just another form of record construction off the existing
    instance using the `with` modifier as shown in the following code (`Ch5_2.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This translates into an instance of `transport { code = 2; name = "plane" }`
    . Note the use of the "fully qualified" field name, `transport.name` . I put it
    this way in order to highlight how it can be possible to resolve ambiguity as
    different record types may have similarly named fields.
  prefs: []
  type: TYPE_NORMAL
- en: Record equality and comparison
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No surprises here. F#, by default, provides structural equality and comparison
    for records in a manner similar to tuples. However, having an explicit type declaration
    allows more flexibility in this matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if structural equality is not desired and reference equality is
    required for any reason, it is not a problem for records, which type definition
    may be decorated with `[<ReferenceEquality>]` attribute as shown in the following
    code snippet (`Ch5_2.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot illustrates what happens if running this code in FSI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Record equality and comparison](img/Image00021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Referential equality for F# records
  prefs: []
  type: TYPE_NORMAL
- en: Note that after decorating the `Transport` type with the `ReferenceEquality`
    attribute, two structurally equal records, `x` and `y` , are not considered equal
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is worth noting that decorating a record type with the `[<CLIMutable>]` attribute
    makes the underlying record a standard mutable .NET CLI type for interoperability
    scenarios; in particular providing additionally a default parameterless constructor
    and elements mutability. See **Core.CLIMutableAttribute Class (F#)** ([https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.climutableattribute-class-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.climutableattribute-class-%5Bfsharp%5D)
    ) for further details.
  prefs: []
  type: TYPE_NORMAL
- en: Record decomposition with pattern matching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Disassembling records with pattern matching is similar to the disassembling
    tuples and may work with or without the `match` construction. The latter case
    is preferable from the standpoint of succinctness as shown in the following code
    (`Ch5_2.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This discards the `code` field of `a` as not interesting and binds its `name`
    field with the `aName` value. The same effect can be achieved with even shorter
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If a single field value is required, then simple `let` `aName' = a.name` works
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Record augmentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Having an explicit type declaration for F# records allows a great deal of augmenting
    around. A nice example of augmenting a record type in order to implement a thread
    safe mutable **singleton** property can be found in the **SqlClient Type provider
    code** ([https://github.com/fsprojects/FSharp.Data.SqlClient/blob/c0de3afd43d1f2fc6c99f0adc605d4fa73f2eb9f/src/SqlClient/Configuration.fs#L87](https://github.com/fsprojects/FSharp.Data.SqlClient/blob/c0de3afd43d1f2fc6c99f0adc605d4fa73f2eb9f/src/SqlClient/Configuration.fs#L87)
    ). A distilled snippet is represented as follows (`Ch5_3.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Database` and `RetryCount` are kept as fields of the F# record that is
    placed as a thread safe static property backed by the `singleton` private reference.
    The beauty of the pattern is that at any moment, configuration can be changed
    programmatically at the same time keeping the singleton thread safe.
  prefs: []
  type: TYPE_NORMAL
- en: Sum algebraic data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In contrast to the product algebraic data types covered earlier, sum algebraic
    data types use the *set sum* operation for the composition of new types. The easiest
    case for this type is an *enumeration* composed of just a bunch of individual
    values. A more generic case is a type that groups a bunch of different types called
    *variants* . Each variant contributes a set of its possible values, which are
    created with the help of the *variant constructor* . All possible values of all
    variants combined with a set sum (union) constitute the sum type.
  prefs: []
  type: TYPE_NORMAL
- en: Another contrast with product types is that of all possible variants, only a
    *single* one can be a value for an instance of the sum type, while *all* fields
    constitute the value of a product type.
  prefs: []
  type: TYPE_NORMAL
- en: This may sound complicated, but the concept is quite simple. Let's dive in.
  prefs: []
  type: TYPE_NORMAL
- en: Discriminated unions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sum algebraic data types were introduced in F# by the native data type named
    *discriminated union* ( **DU** ). The utter flexibility of discriminated unions
    makes them handy to represent pretty much anything in the world. For this particular
    reason, F# programmers use discriminated unions to build the domain-specific languages
    they come up with when approaching solutions for miscellaneous problems. The ability
    of discriminated unions to provide meaningful naming to entities of arbitrary
    complexity, along with the benefits of static typing, is indispensable for clarity
    in representing problems of any scale.
  prefs: []
  type: TYPE_NORMAL
- en: Discriminated union composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The manner of discriminated union composition follows its most natural presentation:
    it is a list of variant cases called *constructors* , separated from each other
    by the OR sign (`|` ). Each case reflects the single variant (case). For example,
    take a look at the following definition (`Ch5_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This can serve as a natural reflection of the payment processing domain part
    that is concerned with the performing charge of a credit card. `ChargeAttempt`
    can be represented by a discriminated union that has two cases: `Original` , reflecting
    that the credit card was successfully charged on the first attempt, and `Retry`
    , reflecting that the charge had some unsuccessful attempts first and then eventually
    passed through. `Retry` reflects the overall amount of charge attempts, for example,
    `Retry 4` as shown in the following code (`Ch5_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, `cco` is a value of type `ChargeAttempt` that has
    the `Original` case value; `ccr` is a value of type `ChargeAttempt` too, but it
    has the case value of `Retry 4` .
  prefs: []
  type: TYPE_NORMAL
- en: The empty constructor case
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *empty constructor* case variant represents the simplest case form. It is
    just a pure label without any kind of associated extra type. We already have used
    this case variant in the preceding code, it stands behind the solitary label `Original`
    .
  prefs: []
  type: TYPE_NORMAL
- en: The single constructor case
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *single constructor* case represents a discriminated union that has only
    one case. This is a very useful ubiquitous pattern that structures the underlying
    problem''s domain and promotes type safety. For example, I need to represent an
    electric bulb that has characteristics such as electric voltage and optical brightness.
    Using single constructor cases, this can be achieved as follows (`Ch5_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A person reading the preceding code instantaneously gets introduced to the key
    entities to operate with. Also, having the preceding numeric values wrapped into
    a discriminated union single constructor case creates an extra layer of type safety.
    That is, number `2500` wrapped into constructor `Brightness(2500)` can be used
    only for the `brightness` field of the `Brightness` type.
  prefs: []
  type: TYPE_NORMAL
- en: Discriminated union equality and comparison
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Discriminated unions provide structural equality and comparison out of the
    box as shown in the following code (`Ch5_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Discriminated union decomposition with pattern matching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Discriminated unions are aligned exceptionally well with pattern matching,
    so decomposing discriminated unions with the help of pattern matching is a breeze
    as shown in the following code (`Ch5_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Discriminated union augmentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similarly to F# records, discriminated unions can be seriously augmented. Let''s
    consider the following real-life augmentation example. In the electronic payments
    world, the payment amount may be discounted depending upon the chosen payment
    instrument. The quantity of the discount may be preset as follows (the whole setup
    and concrete numbers below are fictitious):'
  prefs: []
  type: TYPE_NORMAL
- en: For a credit card, the discount is zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a debit card, the discount is $0.35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For ACH, the discount is $0.75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discounts are a part of the payment service configuration and may change from
    one marketing campaign to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Discount application depending upon the payment instrument can be achieved
    via the discriminated union augmentation as follows (`Ch5_5.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the particular discount amount is tied to each payment instrument case
    via the discriminated union case constructor: `CreditCard` , `DebitCard` , or
    `ACH` . Along with the distinct cases, the type shares the `ApplyDiscount` single
    instance method, which calculates the discounted amount for an original payment
    amount based on the current discount for the selected payment instrument. The
    results of running the preceding script in FSI are shown in the following figure,
    where discounted payment amounts are shown for a payment of $20.23 for each of
    the covered payment instruments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Discriminated union augmentation](img/Image00022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Augmenting F# discriminated union
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter you get familiar with extremely important F# features that represent
    algebraic data types. For each of the types, the topics of composition, decomposition,
    standard and custom equality and comparison, and augmentation are covered. In
    the end, you are expected to understand the reasons behind the superiority of
    F# data composition with native algebraic data types over custom POCOs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I'll turn to the exciting subject of F# sequences that
    represent data and calculation dualism.
  prefs: []
  type: TYPE_NORMAL
