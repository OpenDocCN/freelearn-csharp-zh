- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Files, Streams, and Serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about reading and writing to files and streams, text encoding,
    and serialization. Applications that do not interact with a filesystem are extraordinarily
    rare. As a .NET developer, almost every application that you build will need to
    manage the filesystem and create, open, read, and write to and from files. Most
    of those files will contain text, so it is important to understand how text is
    encoded. And finally, after working with objects in memory, you will need to store
    them somewhere permanently for later reuse. You do that using a technique called
    serialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing a filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing with streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding and decoding text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing object graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing a filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your applications will often need to perform input and output operations with
    files and directories in different environments. The `System` and `System.IO`
    namespaces contain classes for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Handling cross-platform environments and filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore how to handle cross-platform environments and the differences
    between Windows, Linux, and macOS. Paths are different for Windows, macOS, and
    Linux, so we will start by exploring how .NET handles this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console App** / `console`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `WorkingWithFileSystems`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter09`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the project file, add a package reference for `Spectre.Console`, and then
    add elements to import the following classes statically and globally, `System.Console`,
    `System.IO.Directory`, `System.IO.Path`, and `System.Environment`, as shown in
    the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the `WorkingWithFileSystems` project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class file named `Program.Helpers.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Helpers.cs`, add a partial `Program` class with a `SectionTitle`
    method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to use a `Spectre.Console` table to do the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the path and directory separation characters.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Output the path of the current directory.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Output some special paths for system files, temporary files, and documents:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Environment` type has many other useful members that we did not use in
    this code, including the `OSVersion` and `ProcessorCount` properties.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown using Visual Studio on Windows in
    *Figure 9.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_09_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Showing filesystem information with Visual Studio on Windows'
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: You can learn more about using `Spectre Console` tables
    at the following link: [https://spectreconsole.net/widgets/table](https://spectreconsole.net/widgets/table).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When running the console app using `dotnet run` on a Mac, the path and directory
    separator characters are different, and the `CurrentDirectory` will be the project
    folder, not a folder inside `bin`, as shown in *Figure 9.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_09_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Showing filesystem information with the CLI on macOS'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Windows uses a backslash (`\`) for the directory separator
    character. macOS and Linux use a forward slash (`/`) for the directory separator
    character. Do not assume which character is used in your code when combining paths;
    use `Path.DirectorySeparatorChar`.'
  prefs: []
  type: TYPE_NORMAL
- en: In future sections of this chapter, we will create directories and files in
    the `Personal` special folder, so make a note of where that is for your operating
    system. For example, if you’re using Linux, it should be `$USER/Documents`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing drives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To manage drives, use the `DriveInfo` type, which has a static method that returns
    information about all the drives connected to your computer. Each drive has a
    drive type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore drives:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, write statements to get all the drives and output their name,
    type, size, available free space, and format, but only if the drive is ready,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Check that a drive is ready before reading properties such
    as `TotalSize`, or you will see an exception thrown with removable drives.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux, by default, your console app will only have permission to read the
    `Name` and `DriveType` properties when run as a normal user. An `UnauthorizedAccessException`
    is thrown for `DriveFormat`, `TotalSize`, and `AvailableFreeSpace`. Run the console
    app as a superuser to avoid this issue, as shown in the following command: `sudo
    dotnet run`. Using `sudo` is fine in a development environment, but in a production
    environment, it’s recommended to edit your permissions to avoid running with elevated
    permissions. On Linux, the name and drive format columns might also need to be
    wider, for example, 55 and 12 characters wide, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in *Figure 9.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_09_03.png)Figure 9.3: Showing drive information on Windows and
    macOS'
  prefs: []
  type: TYPE_NORMAL
- en: Managing directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To manage directories, use the `Directory`, `Path`, and `Environment` static
    classes. These types include many members to work with the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'When constructing custom paths, you must be careful to write your code so that
    it makes no assumptions about the platform, for example, what to use for the directory
    separator character:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, write statements to do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a custom path under the user’s home directory by creating an array of
    strings for the directory names, and then properly combine them with the `Path`
    type’s `Combine` method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Check for the existence of the custom directory path using the `Exists` method
    of the `Directory` class.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create and then delete the directory, including the files and subdirectories
    within it, using the `CreateDirectory` and `Delete` methods of the `Directory`
    class:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: In .NET 6 and earlier, only the `Directory` class had an `Exists` method. In
    .NET 7 or later, the `Path` class also has an `Exists` method. Both can be used
    to check for the existence of a path.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code, view the result, and use your favorite file management tool to
    confirm that the directory has been created before pressing *Enter* to delete
    it, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Managing files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with files, you can statically import the file type, just as we
    did for the directory type. However, for the next example, we will not do so because
    it has some of the same methods as the directory type, and they would conflict.
    The file type has a short enough name not to matter in this case. The steps are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, write statements to do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check for the existence of a file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a text file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a line of text to the file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the file to release system resources and file locks (this would normally
    be done inside a `try`-`finally` statement block to ensure that the file is closed,
    even if an exception occurs when writing to it).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the file to a backup.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the original file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Read the backup file’s contents and then close it:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Managing paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to work with parts of a path; for example, you might want
    to extract just the folder name, the filename, or the extension. Sometimes, you
    need to generate temporary folders and filenames. You can do this with static
    methods of the `Path` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add the following statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`GetTempFileName` creates a zero-byte file and returns its name, ready for
    you to use. `GetRandomFileName` just returns a filename; it doesn’t create the
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting file information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get more information about a file or directory, for example, its size or
    when it was last accessed, you can create an instance of the `FileInfo` or `DirectoryInfo`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '`FileInfo` and `DirectoryInfo` both inherit from `FileSystemInfo`, so they
    both have members such as `LastAccessTime` and `Delete`, as well as extra members
    specific to themselves, as shown in *Table 9.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class** | **Members** |'
  prefs: []
  type: TYPE_TB
- en: '| `FileSystemInfo` | Fields: `FullPath` and `OriginalPath`Properties: `Attributes`,
    `CreationTime`, `CreationTimeUtc`, `Exists`, `Extension`, `FullName`, `LastAccessTime`,
    `LastAccessTimeUtc`, `LastWriteTime`, `LastWriteTimeUtc`, and `Name`Methods: `Delete`,
    `GetObjectData`, and `Refresh` |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryInfo` | Properties: `Parent` and `Root`Methods: `Create`, `CreateSubdirectory`,
    `EnumerateDirectories`, `EnumerateFiles`, `EnumerateFileSystemInfos`, `GetAccessControl`,
    `GetDirectories`, `GetFiles`, `GetFileSystemInfos`, `MoveTo`, and `SetAccessControl`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FileInfo` | Properties: `Directory`, `DirectoryName`, `IsReadOnly`, and
    `Length`Methods: `AppendText`, `CopyTo`, `Create`, `CreateText`, `Decrypt`, `Encrypt`,
    `GetAccessControl`, `MoveTo`, `Open`, `OpenRead`, `OpenText`, `OpenWrite`, `Replace`,
    and `SetAccessControl` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.1: Classes to get information about files and directories'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write some code that uses a `FileInfo` instance to efficiently perform
    multiple actions on a file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to create an instance of `FileInfo` for the
    backup file, and write information about it to the console, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The number of bytes might be different on your operating system because operating
    systems can use different line endings.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling how you work with files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with files, you often need to control how they are opened. The
    `File.Open` method has overloads to specify additional options using `enum` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `enum` types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileMode`: This controls what you want to do with a file, like `CreateNew`,
    `OpenOrCreate`, or `Truncate`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileAccess`: This controls what level of access you need, like `ReadWrite`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileShare`: This controls locks on a file to allow other processes the specified
    level of access, like `Read`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might want to open a file and read from it, allowing other processes to
    read it too, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also an `enum` for attributes of a file, `FileAttributes`, that checks
    a `FileSystemInfo`-derived type’s `Attributes` property for values like `Archive`
    and `Encrypted`. For example, you could check a file or directory’s attributes,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'All the methods of the `File` class that manage a file have a parameter to
    specify the path to the file as a `string` value. Additional parameters of the
    `File` class, its methods, and what the methods return are shown in *Table 9.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Special parameters** | **Returns** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `Open` | `FileMode`, `FileAccess`, `FileShare` | `FileStream` | Byte-level
    access to a file. |'
  prefs: []
  type: TYPE_TB
- en: '| `OpenWrite` |  | `FileStream` | Overwrites from the start but does not truncate.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Create` | `FileOptions` | `FileStream` | Overwrites and truncates. |'
  prefs: []
  type: TYPE_TB
- en: '| `OpenText` |  | `StreamReader` | For reading a text file. |'
  prefs: []
  type: TYPE_TB
- en: '| `CreateText` |  | `StreamWriter` | Overwrites and truncates. |'
  prefs: []
  type: TYPE_TB
- en: '| `AppendText` |  | `StreamWriter` | Creates the file if it does not exist.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadAllLines` | `Encoding` | `string[]` | Warning! This uses a lot of memory
    for large files. |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadAllText` | `Encoding` | `string` | Warning! This uses a lot of memory
    for large files. |'
  prefs: []
  type: TYPE_TB
- en: '| `WriteAllText` | `string`, `Encoding` | `void` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `AppendAllText` | `string`, `Encoding` | `void` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `WriteAllLines` | `string[]`, `IEnumerable<string>`, `Encoding` | `void`
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| `AppendAllLines` | `string[]`, `IEnumerable<string>`, `Encoding` | `void`
    |  |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.2: File class and its methods'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve learned some common ways to work with the directories and files
    in a filesystem, we next need to learn how to read and write data stored in a
    file, that is, how to work with streams.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing with streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 10*, *Working with Data Using Entity Framework Core*, you will use
    a file named `Northwind.db`, but you will not work with the file directly. Instead,
    you will interact with the SQLite database engine, which, in turn, will read and
    write to the file. In scenarios where there is no other system that “owns” the
    file and does the reading and writing for you, you will use a file stream to work
    directly with the file.
  prefs: []
  type: TYPE_NORMAL
- en: A **stream** is a sequence of bytes that can be read from and written to. Although
    files can be processed rather like arrays, with random access provided by knowing
    the position of a byte within the file, it is more efficient to process a file
    as a stream in which the bytes can be accessed in sequential order. When a human
    does the processing, they tend to need random access so that they can jump around
    the data, make changes, and then return to the data they worked on earlier. When
    an automated system does the processing, it tends to be able to work sequentially
    and only needs to “touch” the data once.
  prefs: []
  type: TYPE_NORMAL
- en: Streams can also be used to process terminal input and output and networking
    resources, such as sockets and ports, that do not provide random access and cannot
    seek (that is, move) to a position. You can write code to process some arbitrary
    bytes without knowing or caring where they come from. Your code simply reads or
    writes to a stream, and another piece of code handles where the bytes are stored.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding abstract and concrete streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is an `abstract` class named `Stream` that represents any type of stream.
    Remember that an `abstract` class cannot be instantiated using `new`; it can only
    be inherited. This is because it is only partially implemented.
  prefs: []
  type: TYPE_NORMAL
- en: There are many concrete classes that inherit from this base class, including
    `FileStream`, `MemoryStream`, `BufferedStream`, `GZipStream`, and `SslStream`.
    They all work the same way. All streams implement `IDisposable`, so they have
    a `Dispose` method to release unmanaged resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the common members of the `Stream` class are described in *Table 9.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Member** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `CanRead` and `CanWrite` | These properties determine if you can read from
    and write to the stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `Length` and `Position` | These properties determine the total number of
    bytes and the current position within the stream. These properties may throw a
    `NotSupportedException` for some types of streams, for example, if `CanSeek` returns
    `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Close` and `Dispose` | This method closes the stream and releases its resources.
    You can call either method, since the implementation of `Dispose` calls `Close`!
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Flush` | If the stream has a buffer, then this method writes the bytes in
    the buffer to the stream, and the buffer is cleared. |'
  prefs: []
  type: TYPE_TB
- en: '| `CanSeek` | This property determines if the `Seek` method can be used. |'
  prefs: []
  type: TYPE_TB
- en: '| `Seek` | This method moves the current position to the one specified in its
    parameter. |'
  prefs: []
  type: TYPE_TB
- en: '| `Read` and `ReadAsync` | These methods read a specified number of bytes from
    the stream into a byte array and advance the position. |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadByte` | This method reads the next byte from the stream and advances
    the position. |'
  prefs: []
  type: TYPE_TB
- en: '| `Write` and `WriteAsync` | These methods write the contents of a byte array
    into the stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `WriteByte` | This method writes a byte to the stream. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.3: Common members of the Stream class'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding storage streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some storage streams that represent a location where bytes will be stored are
    described in *Table 9.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Namespace** | **Class** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO` | `FileStream` | Bytes stored in the filesystem |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO` | `MemoryStream` | Bytes stored in memory in the current process
    |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Net.Sockets` | `NetworkStream` | Bytes stored at a network location
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.4: Storage stream classes'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileStream` has been rewritten in .NET 6 to have much higher performance and
    reliability on Windows. You can read more about this at the following link: [https://devblogs.microsoft.com/dotnet/file-io-improvements-in-dotnet-6/](https://devblogs.microsoft.com/dotnet/file-io-improvements-in-dotnet-6/).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding function streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Function streams cannot exist on their own and can only be “plugged into” other
    streams to add functionality. Some are described in *Table 9.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Namespace** | **Class** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Security.Cryptography` | `CryptoStream` | This encrypts and decrypts
    the stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO.Compression` | `GZipStream`, `DeflateStream` | These compress
    and decompress the stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Net.Security` | `AuthenticatedStream` | This sends credentials across
    the stream. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.5: Function stream classes'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding stream helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although there will be occasions where you need to work with streams at a low
    level, most often, you can plug helper classes into the chain to make things easier.
    All the helper types for streams implement `IDisposable`, so they have a `Dispose`
    method to release unmanaged resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some helper classes to handle common scenarios are described in *Table 9.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Namespace** | **Class** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO` | `StreamReader` | This reads from the underlying stream as plain
    text. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO` | `StreamWriter` | This writes to the underlying stream as plain
    text. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO` | `BinaryReader` | This reads from streams as .NET types. For
    example, the `ReadDecimal` method reads the next 16 bytes from the underlying
    stream as a `decimal` value, and the `ReadInt32` method reads the next 4 bytes
    as an `int` value. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO` | `BinaryWriter` | This writes to streams as .NET types. For
    example, the `Write` method with a `decimal` parameter writes 16 bytes to the
    underlying stream, and the `Write` method with an `int` parameter writes 4 bytes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Xml` | `XmlReader` | This reads from the underlying stream using
    the XML format. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Xml` | `XmlWriter` | This writes to the underlying stream using the
    XML format. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.6: Stream helper classes'
  prefs: []
  type: TYPE_NORMAL
- en: Building a stream pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is very common to combine a helper, like `StreamWriter`, and multiple function
    streams, like `GZipStream` and `CryptoStream`, with a storage stream, like `FileStream`,
    into a pipeline, as shown in *Figure 9.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_09_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Writing plain text, and then encrypting and compressing it into
    a file stream'
  prefs: []
  type: TYPE_NORMAL
- en: Your code would just call a simple helper method, like `WriteLine`, to send
    a `string` value, like `"Hello"`, through the pipeline until it arrives at its
    final destination, having been compressed and then encrypted so that it gets written
    to the file as `"``G7x"` (or whatever it would be).
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: “*Good encryption will generate relatively uncompressible
    data. If you switch the order of the operations so that you first compress and
    then encrypt, not only should you end up with a smaller file, but the encryption
    will most likely take less time as it’ll be operating on less data*.” From an
    article by Stephen Toub: [https://learn.microsoft.com/en-us/archive/msdn-magazine/2008/february/net-matters-stream-pipeline](https://learn.microsoft.com/en-us/archive/msdn-magazine/2008/february/net-matters-stream-pipeline).'
  prefs: []
  type: TYPE_NORMAL
- en: Writing to text streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you open a file to read or write to it, you use resources outside of .NET.
    These are called **unmanaged resources** and must be disposed of when you are
    done working with them.
  prefs: []
  type: TYPE_NORMAL
- en: To deterministically control when these resources are disposed of, we can call
    the `Dispose` method. When the `Stream` class was first designed, all cleanup
    code was expected to go in the `Close` method. But later, the concept of `IDisposable`
    was added to .NET, and `Stream` had to implement a `Dispose` method. Later, the
    `using` statement was added to .NET, which can automatically call `Dispose`. So
    today, you can call either `Close` or `Dispose`, which actually do the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s type some code to write text to a stream:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to add a new **Console App** / `console` project,
    named `WorkingWithStreams`, to the `Chapter09` solution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the project file, add an element to import the `System.Console`, `System.Environment`,
    and `System.IO.Path` classes, statically and globally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class file named `Program.Helpers.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Helpers.cs`, add a partial `Program` class with a `SectionTitle`
    and an `OutputFileInfo` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a new class file named `Viper.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Viper.cs`, define a static class named `Viper` with a static array of `string`
    values, named `Callsigns`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, delete the existing statements, and then import the namespace
    to work with the `Viper` class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to enumerate the `Viper` call signs, writing
    each one on its own line in a single text file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Calling `Close` on the stream writer helper will call `Close` on the underlying
    stream. This in turn calls `Dispose` to release unmanaged file resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the file that was created, and confirm that it contains the list of call
    signs as well as a blank line, as we are effectively calling `WriteLine` twice:
    once when we write the last call sign to the file, and again when we read the
    whole file and write it out to the console.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that if you run the project at the command prompt using `dotnet run`,
    then the path will be the project folder. It will not include `bin\Debug\net9.0`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to XML streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to write an XML element, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WriteStartElement` and `WriteEndElement`: Use this pair when an element might
    have child elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WriteElementString`: Use this when an element does not have children.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s try storing the Viper pilot call signs array of `string` values
    in an XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, import the `System.Xml` namespace, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom of `Program.cs`, add statements that enumerate the call signs,
    writing each one as an element in a single XML file, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Optionally, right-click in the `Close` method of `xmlFileStream`, select **Go
    To Implementation**, and note the implementations of the `Dispose`, `Close`, and
    `Dispose(bool)` methods, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Close` and `Dispose(bool)` methods are `virtual` in the `Stream` class
    because they are designed to be overridden in a derived class, like `FileStream`,
    to do the work of releasing unmanaged resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Before calling the `Dispose` method, check that the object
    is not `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying disposal by using the using statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can simplify the code that needs to check for a `null` object and then call
    its `Dispose` method by using the `using` statement. Unless you need a greater
    level of control, I would generally recommend using `using` rather than manually
    calling `Dispose`, as it’s less code to write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Confusingly, there are two uses for the `using` keyword: importing a namespace
    and generating a `finally` statement that calls `Dispose` on an object implementing
    `IDisposable`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler changes a `using` statement block into a `try`-`finally` statement
    without a `catch` statement. You can use nested `try` statements, so if you do
    want to catch any exceptions, you can, as shown in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even simplify the code further by not explicitly specifying the braces
    and indentation for the `using` statements, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this clearer, let’s review a simpler example. You can use a `using`
    block to ensure that the `Dispose` method is called at the end of the scope, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**More Information**: You can learn how the preceding code is lowered into
    a `try-catch` block at the following link: [https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md#ensuring-that-dispose-is-called](https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md#ensuring-that-dispose-is-called).
    If you haven’t already, you should also read the following online section: [https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md#releasing-unmanaged-resources](https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md#releasing-unmanaged-resources).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use a simplified syntax without braces, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, there is no explicit block defined by braces,
    so an implicit block is defined that ends at the end of the containing scope.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: You can learn more about this at the following links:
    [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/using](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/using)
    and [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/statements#1314-the-using-statement](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/statements#1314-the-using-statement).'
  prefs: []
  type: TYPE_NORMAL
- en: Compressing streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: XML is relatively verbose, so it takes up more space in bytes than plain text.
    Let’s see how we can squeeze the XML using a common compression algorithm, known
    as GZIP.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET Core 2.1, Microsoft introduced an implementation of the Brotli compression
    algorithm. In performance, Brotli is like the algorithm used in DEFLATE and GZIP,
    but the output is about 20% denser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compare the two compression algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new class file named `Program.Compress.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Compress.cs`, write statements to use instances of `GZipStream`
    or `BrotliStream` to create a compressed file that contains the same XML elements
    as before, and then decompress it while reading it and outputting to the console,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The code that uses the `decompressor` object does not use the simplified `using`
    syntax. Instead, it uses the fact that `using` blocks can omit their braces for
    a single “statement,” just like `if` statements. Remember that `if` statements
    can have explicit braces even if only one statement is executed within a block,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `using (XmlReader reader = XmlReader.Create(decompressor))`
    and the entire `while (reader.Read()) { ... }` block are equivalent to single
    statements, so we can remove the braces and the code works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add calls to `Compress` with parameters to use the `gzip`
    and `brotli` algorithms, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and compare the sizes of the XML file and the compressed XML
    file using the `gzip` and `brotli` algorithms, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To summarize the file sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Uncompressed: 320 bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GZIP-compressed: 151 bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Brotli-compressed: 117 bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As well as choosing a compression mode, you can also choose a compression level.
    You can learn more about this at the following link: [https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.compressionlevel](https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.compressionlevel).'
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing with random access handles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the first 20 years of .NET’s life, the only API to work directly with files
    was the one for stream classes. These work great for automated tasks that only
    need to process data sequentially. But when a human interacts with the data, they
    often want to jump around and return multiple times to the same location.
  prefs: []
  type: TYPE_NORMAL
- en: 'With .NET 6 and later, there is a new API for working with files without needing
    a file stream and in a random access way. Let’s see a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to add a new **Console App** / `console` project
    named `WorkingWithRandomAccess` to the `Chapter09` solution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the project file, add an element to import the `System.Console` class statically
    and globally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements, and then get a handle to a
    file named `coffee.txt`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write some text encoded as a byte array, and then store it in a read-only memory
    buffer to the file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To read from the file, get the length of the file, allocate a memory buffer
    for the contents using that length, and then read the file, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and note the content of the file, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Encoding and decoding text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Text characters can be represented in different ways. For example, the alphabet
    can be encoded using Morse code into a series of dots and dashes for transmission
    over a telegraph line.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way, text inside a computer is stored as bits (ones and zeros)
    representing a code point within a code space. Most code points represent a single
    character, but they can also have other meanings, like formatting.
  prefs: []
  type: TYPE_NORMAL
- en: For example, ASCII has a code space with 128 code points. .NET uses a standard
    called **Unicode** to encode text internally. Unicode has more than 1 million
    code points.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you will need to move text outside .NET for use by systems that do
    not use Unicode or a variation of it, so it is important to learn how to convert
    between encodings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common text encodings used by computers are shown in *Table 9.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Encoding** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| ASCII | This encodes a limited range of characters using the lower 7 bits
    of a byte. |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-8 | This represents each Unicode code point as a sequence of 1 to 4 bytes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-7 | This is designed to be more efficient over 7-bit channels than UTF-8,
    but it has security and robustness issues, so UTF-8 is recommended over UTF-7.
    |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-16 | This represents each Unicode code point as a sequence of one or
    two 16-bit integers. |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-32 | This represents each Unicode code point as a 32-bit integer and
    is, therefore, a fixed-length encoding, unlike the other Unicode encodings, which
    are all variable-length encodings. |'
  prefs: []
  type: TYPE_TB
- en: '| ANSI/ISO encodings | This provides support for a variety of code pages that
    are used to support a specific language or group of languages. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 9.7: Common text encodings'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: In most cases today, UTF-8 is a good default, which is why
    it is literally the default encoding, that is, `Encoding.Default`. You should
    avoid using `Encoding.UTF7` because it is not secure. Due to this, the C# compiler
    will warn you when you try to use UTF-7\. Of course, you might need to generate
    text using that encoding for compatibility with another system, so it needs to
    remain an option in .NET.'
  prefs: []
  type: TYPE_NORMAL
- en: Encoding strings as byte arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore text encodings:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project,
    named `WorkingWithEncodings`, to the `Chapter09` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the project file, add an element to statically and globally import the `System.Console`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements, import the `System.Text` namespace,
    add statements to encode a `string` using an encoding chosen by the user, loop
    through each byte, and then decode the encoded value back into a `string` and
    output it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, press *1* to choose ASCII, and note that when outputting the
    bytes, the pound sign (`£`) and accented e (`é`) cannot be represented in ASCII,
    so it uses a question mark instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rerun the code and press *3* to choose UTF-8\. Note that UTF-8 requires 2 extra
    bytes for the two characters that need 2 bytes each (12 bytes instead of 10 bytes
    in total), but it can encode and decode the `é` and `£` characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rerun the code and press *4* to choose Unicode (UTF-16). Note that UTF-16 requires
    2 bytes for every character, so 20 bytes in total, and it can encode and decode
    the `é` and `£` characters. This encoding is used internally by .NET to store
    `char` and `string` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encoding and decoding text in files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using stream helper classes, such as `StreamReader` and `StreamWriter`,
    you can specify the encoding you want to use. As you write to the helper, the
    text will be automatically encoded, and as you read from the helper, the bytes
    will be automatically decoded.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify an encoding, pass the encoding as a second parameter to the helper
    type’s constructor, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: Often, you won’t have the choice of which encoding to use
    because you will generate a file for use by another system. However, if you do,
    pick one that uses the least number of bytes but can store every character you
    need.'
  prefs: []
  type: TYPE_NORMAL
- en: Serializing object graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **object graph** is a structure of multiple objects that are related to each
    other, either through a direct reference or indirectly through a chain of references.
  prefs: []
  type: TYPE_NORMAL
- en: '**Serialization** is the process of converting a live object graph into a sequence
    of bytes using a specified format. **Deserialization** is the reverse process.'
  prefs: []
  type: TYPE_NORMAL
- en: You would use serialization to save the current state of a live object so that
    you can recreate it in the future, for example, saving the current state of a
    game so that you can continue at the same place tomorrow. The stream produced
    from a serialized object is usually stored in a file or database.
  prefs: []
  type: TYPE_NORMAL
- en: There are dozens of formats you can choose for serialization, but the two most
    common text-based human-readable formats are **eXtensible Markup Language** (**XML**)
    and **JavaScript Object Notation** (**JSON**). There are also more efficient binary
    formats like Protobuf, used by gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: JSON is more compact and is best for web and mobile applications.
    XML is more verbose but is better supported in more legacy systems. Use JSON to
    minimize the size of serialized object graphs. JSON is also a good choice when
    sending object graphs to web applications and mobile applications, as it is the
    native serialization format for JavaScript, and mobile apps often make calls over
    limited bandwidth, so the number of bytes is important.'
  prefs: []
  type: TYPE_NORMAL
- en: .NET has multiple classes that will serialize to and from XML and JSON. We will
    start by looking at `XmlSerializer` and `JsonSerializer`.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing as XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by looking at XML, probably the world’s most used serialization
    format (for now). To show a typical example, we will define a custom class to
    store information about a person and then create an object graph, using a list
    of `Person` instances with nesting:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project
    named `WorkingWithSerialization` to the `Chapter09` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the project file, add elements to statically and globally import the following
    classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: System.Console to use ForegroundColor and WriteLine
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: System.Environment to use CurrentDirectory
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: System.IO.Path to use Combine, GetFileName, and GetDirectoryName
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new class file named `Program.Helpers.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Helpers.cs`, add a partial `Program` class with a `SectionTitle`
    and an `OutputFileInfo` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new class file, named `Person.cs`, to define a `Person` class with a
    `Salary` property that is `protected`, meaning it is only accessible to itself
    and derived classes. To populate the salary, the class has a constructor with
    a single parameter to set the initial salary, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, delete the existing statements, and then import namespaces
    to work with XML serialization and the `Person` class, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to create an object graph of `Person` instances,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, view the result, and note that an exception is thrown, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Person.cs`, add a statement to define a parameterless constructor, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The constructor does not need to do anything, but it must exist so that the
    `XmlSerializer` can call it to instantiate new `Person` instances during the deserialization
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, and note that the object graph is serialized
    as XML elements, like `<FirstName>Bob</FirstName>`, and that the `Salary` property
    is not included because it is not a `public` property, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Generating compact XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We could make the XML more compact using attributes instead of elements for
    some fields:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Person.cs`, import the `System.Xml.Serialization` namespace
    so that you can decorate some properties with the `[XmlAttribute]` attribute,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Person.cs`, decorate the first name, last name, and date of birth properties
    with the `[XmlAttribute]` attribute, and set a short name for each property, as
    highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and note that the size of the file has reduced from 793 to 488
    bytes, a space-saving of more than a third. This reduction was achieved by outputting
    property values as XML attributes, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Deserializing XML files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s try deserializing the XML file back into live objects in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to open the XML file, and then deserialize
    it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and note that the people are loaded successfully from the XML
    file and then enumerated, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**More Information**: There are many other attributes defined in the `System.Xml.Serialization`
    namespace that can be used to control the XML generated. A good place to start
    is the official documentation for the `XmlAttributeAttribute` class found here:
    [https://learn.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlattributeattribute](https://learn.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlattributeattribute).
    Do not get this class confused with the `XmlAttribute` class in the `System.Xml`
    namespace. That is used to represent an XML attribute when reading and writing
    XML, using `XmlReader` and `XmlWriter`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t use any annotations, `XmlSerializer` performs a case-insensitive
    match using the property name when deserializing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: When using `XmlSerializer`, remember that only the public
    fields and properties are included, and the type must have a parameterless constructor.
    You can customize the output with attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: Serializing with JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most popular .NET libraries to work with the JSON serialization format
    is **Newtonsoft.Json**, known as **Json.NET**. It is mature and powerful.
  prefs: []
  type: TYPE_NORMAL
- en: '`Newtonsoft.Json` is so popular that it overflowed the bounds of the 32-bit
    integer used for the download count in the NuGet package manager, as shown in
    the following post in *Figure 9.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_09_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Negative 2 billion downloads for Newtonsoft.Json in August 2022'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `WorkingWithSerialization` project, add a package reference for the
    latest version of `Newtonsoft.Json`, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the `WorkingWithSerialization` project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to create a text file, and then serialize the
    people into the file as JSON, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and note that JSON requires fewer than half the number of bytes
    compared to XML with elements. It’s even smaller than the XML file, which uses
    attributes (366 compared to 488), as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: High-performance JSON processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET Core 3 introduced a new namespace to work with JSON, `System.Text.Json`,
    which is optimized for performance by leveraging APIs like `Span<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, older libraries like `Json.NET` are implemented by reading UTF-16\. It
    would be more performant to read and write JSON documents using UTF-8 because
    most network protocols, including HTTP, use UTF-8, and you can avoid transcoding
    UTF-8 to and from Json.NET’s Unicode `string` values.
  prefs: []
  type: TYPE_NORMAL
- en: With the new API, Microsoft achieved between 1.3x and 5x improvement, depending
    on the scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original author of Json.NET, James Newton-King, joined Microsoft and is
    working with them to develop their new JSON types. As he says in a comment discussing
    the new JSON APIs, “*Json.NET isn’t going away*,” as shown in *Figure 9.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_09_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: A comment by the original author of Json.NET'
  prefs: []
  type: TYPE_NORMAL
- en: Deserializing JSON files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see how to use the modern JSON APIs to deserialize a JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `WorkingWithSerialization` project, at the top of `Program.cs`, import
    the new JSON class to perform serialization, using an alias to avoid conflicting
    names with the Json.NET one we used before, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to open the JSON file, deserialize it, and
    output the names and counts of the children of the people, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Choose Json.NET for developer productivity and a large feature
    set, or `System.Text.Json` for performance. You can review a list of the differences
    at the following link: [https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to#table-of-differences-between-newtonsoftjson-and-systemtextjson](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to#table-of-differences-between-newtonsoftjson-and-systemtextjson).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: JSON schema exporter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET 9 introduced a class to make it easy to generate JSON schemas for .NET
    types. As a result, serialization is simplified and data conforms to expected
    formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see a working example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `WorkingWithSerialization` project, at the top of `Program.cs`, import
    the namespaces to perform JSON serialization and work with JSON schemas, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to export the JSON schema for the `Person`
    class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Controlling JSON processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many options to take control of how JSON is processed, as shown in
    the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Including and excluding fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a casing policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a case-sensitivity policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing between compact and prettified whitespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see some in action:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project,
    named `ControllingJson`, to the `Chapter09` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the project file, add elements to statically and globally import the `System.Console`,
    `System.Environment`, and `System.IO.Path` classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `ControllingJson` project, add a new class file named `Book.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Book.cs`, define a class named `Book`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, delete the existing statements, and then import the namespaces
    to work with high-performance JSON and `Book`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to create an instance of the `Book` class and
    serialize it to JSON, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The JSON file is 221 bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The member names use camelCasing, for example, `publishDate`. This is best for
    subsequent processing in a browser with JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All fields are included due to the options set, including `pages`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON is prettified for easier human legibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DateTime` and `DateTimeOffset` values are stored as a single standard `string`
    format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `Program.cs`, when setting the `JsonSerializerOptions`, comment out the setting
    of a casing policy, write with an indent, and include fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The JSON file has about a 20% reduction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The member names use normal casing, for example, `PublishDate`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Pages` field is missing. The other fields are included due to the `[JsonInclude]`
    attribute on the `PublishDate` and `Created` fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning about binary serialization using BinaryFormatter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `BinaryFormatter` class is a serialization class that can convert a live
    object, or a graph of connected objects, into a binary format that can be stored
    or transmitted and later reconstructed. This class has been part of .NET since
    its early versions and is in the `System.Runtime.Serialization.Formatters.Binary`
    namespace. But `BinaryFormatter` is problematic for several reasons, primarily
    related to security and robustness.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `BinaryFormatter` is vulnerable to deserialization attacks, where
    malicious input can execute arbitrary code during the deserialization process.
    This makes any application using `BinaryFormatter` susceptible to **remote code
    execution** (**RCE**) if an attacker can control the serialized data. `BinaryFormatter`
    does not perform any validation or checks on the data it deserializes, making
    it inherently insecure when handling untrusted data.
  prefs: []
  type: TYPE_NORMAL
- en: '`BinaryFormatter` does not support many modern serialization features, like
    JSON or XML serialization capabilities, which are more secure and flexible.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Microsoft recommends using serialization libraries like
    `System.Text.Json`, `System.Xml.Serialization`, or `Google.Protobuf`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first version of .NET Core, the Microsoft team removed `BinaryFormatter`
    entirely due to its known risks, but without a clear path to using something safer,
    customers demanded that it be brought back, which the team did with .NET Core
    1.1\. Since then, the team has disabled it by default but allowed developers to
    explicitly re-enable it, by setting flags if they accept the risks.
  prefs: []
  type: TYPE_NORMAL
- en: With .NET 9, the flags to enable `BinaryFormatter` have been removed, and any
    use of it will throw an exception. But there is still a way to re-enable it, by
    referencing a NuGet package marked as being permanently vulnerable and setting
    some configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: You can learn more about why and how the `BinaryFormatter`
    class is being removed in .NET 9 at the following link: `https://devblogs.microsoft.com/dotnet/binaryformatter-removed-from-dotnet-9/`.'
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with more in-depth research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 9.1 – Online material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Online material can be extra content written by me for this book, or it can
    be references to content created by Microsoft or third parties.
  prefs: []
  type: TYPE_NORMAL
- en: Working with tar archives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you use Linux, then you will be interested in how to programmatically work
    with tar archives. I have written an online-only section to introduce you to them
    that can be found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch09-tar-archives.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch09-tar-archives.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Migrating from Newtonsoft to new JSON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have existing code that uses the Newtonsoft `Json.NET` library and you
    want to migrate to the new `System.Text.Json` namespace, then Microsoft has specific
    documentation for that, which you can find at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 9.2 – Practice exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Practice exercises go deeper into the topics for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing as XML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `Chapter09` solution, create a console app named `Exercise_SerializingShapes`
    that creates a list of shapes, uses serialization to save it to the filesystem
    with XML, and then deserializes it back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Shapes should have a read-only property named `Area` so that when you deserialize,
    you can output a list of shapes, including their areas, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what your output should look like when you run your console application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 9.3 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between using the `File` class and the `FileInfo` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `ReadByte` method and the `Read` method of
    a stream?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When would you use the `StringReader`, `TextReader`, and `StreamReader` classes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `DeflateStream` type do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many bytes per character does UTF-8 encoding use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an object graph?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best serialization format to choose to minimize space requirements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best serialization format to choose for cross-platform compatibility?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it bad to use a `string` value like `"\Code\Chapter01"` to represent
    a path, and what should you do instead?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where can you find information about NuGet packages and their dependencies?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 9.4 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-9---working-with-files-streams-and-serialization](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-9---working-with-files-streams-and-serialization)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Read from and write to text files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read from and write to XML files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compress and decompress files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encode and decode text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialize an object graph into JSON and XML.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deserialize an object graph from JSON and XML.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to work with databases using Entity
    Framework Core.
  prefs: []
  type: TYPE_NORMAL
