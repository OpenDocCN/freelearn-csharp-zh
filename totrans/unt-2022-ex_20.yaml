- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finishing Games with Commercial Viability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 14*](B18347_14.xhtml#_idTextAnchor272), we wrapped up the development
    process that started with us creating the 3D **first-person shooter** (**FPS**)
    game and ended with us designing a truly immersive boss room encounter – in our
    own room – using **mixed reality** (**MR**). To achieve this, we took advantage
    of the power and flexibility of the **Unity XR Interaction Toolkit** (**XRI**)
    and combined 3D assets with our reusable components and systems from our previous
    work.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored additional Unity-specific MR technologies such as AR Foundation,
    which we used to create immersive experiences using detected planes from the player’s
    physical surroundings. We used walls, floors, and tables to spawn virtual objects
    and create a virtual game environment. We also designed the boss room, set up
    Quest devices, and customized Unity’s Mixed Reality Template. Additionally, we
    crafted the interactive module Prefab Variants, along with puzzle and shooting
    mechanics, to deepen the player experience.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore **Games as a Service** (**GaaS**), Unity DevOps
    and LiveOps resources, and source code management via a **version control system**
    (**VCS**). We’ll also discuss in-game economies for commercialization and finish
    by exploring different storefront platforms for distributing our games, including
    an example of implementing **Unity Gaming Services** (**UGS**) and publishing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing GaaS – UGS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safeguarding your investment! Source code management with Unity Version Control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engaging players with an in-game economy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting your game out there! Platform distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing UGS and publishing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have gained confidence in your ability to
    manage and secure your project development life cycle during both the production
    and release phases. You’ll also know how to distribute a commercially viable finished
    game effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along in this chapter, you must have Unity Hub and a 2022 version
    of Unity Editor installed. You’ll also need to be able to sign in to Unity Cloud
    using your Unity ID account.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the complete project from GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing GaaS – UGS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important lesson is to finish your games. You have no potential to
    graduate as a hobbyist or have a self-sustaining career as an indie game developer
    unless you finish your games. A finished game also serves as proof of finely-tuned
    skills as a game developer and a showcase for studios, should you be looking to
    get hired by one.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, finishing games boils down to treating the game-making process more
    like a business. This is **GaaS**, blending development and operating strategies
    to create dynamic, remarkable, commercial, and continuously evolving game experiences
    for players in your *business* of making games.
  prefs: []
  type: TYPE_NORMAL
- en: When developing a game using a GaaS model, the focus shifts more toward long-term
    engagement and monetization strategies in the later stages of production. If we
    aim to maximize commercial viability with our game’s release – for a sustained
    revenue stream – we’ll need to employ continuous content delivery, social interaction,
    and data analysis to guide our decision-making processes.
  prefs: []
  type: TYPE_NORMAL
- en: Unity not only provides a game engine for the foundation of your game’s development
    but also cloud services you should leverage to increase your chance for success.
    Namely, **Unity Cloud** provides a group of efficient and time-saving tools and
    workflows that substantially assist in securing your projects and releasing commercially
    viable games.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity Cloud
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity Cloud: [https://cloud.unity.com/](https://cloud.unity.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: Unity Cloud provides access to **UGS**, which they describe as “*a complete
    service ecosystem for live games*.” Considering the breadth of service offerings
    and ease of integration into our game projects, it should be no surprise why we
    would benefit from adopting one or more services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a quick rundown of what UGS provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Foundational game systems**: Systems such as authentication and player accounts
    enable cloud saves and platform crossplay, and content management enables deployment
    and dynamic updating of game content. Meanwhile, multiplayer game hosting can
    scale your game to millions of players (as games such as **Among Us** and **Apex
    Legends** did). Rounding things out are version control and build automation,
    which comprise Unity’s **DevOps** features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player engagement**: Features such as analytics enable data-driven decisions
    to maximize the player experience. Engagement tools with A/B testing allow features
    with the most player enjoyment to surface, while communications such as voice
    and text chat build communities. And don’t forget the ever-so-important crash
    reporting to know where your game crashes so that you can respond quickly with
    fixes. This grouping of services is Unity’s **LiveOps** features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game growth**: Grow your game with user acquisition and drive monetization
    revenue with in-game ads, ad mediation, and in-app purchase features to establish
    your game’s economy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional reading | UGS
  prefs: []
  type: TYPE_NORMAL
- en: 'From DevOps to LiveOps in one platform: [https://unity.com/solutions/gaming-services](https://unity.com/solutions/gaming-services)'
  prefs: []
  type: TYPE_NORMAL
- en: The aforementioned UGS topics can fill a whole book, so we’ll focus on just
    the core services that are crucial for game development production and are intended
    for commercial release in this chapter. That means we’ll focus on **Unity DevOps**
    and **Unity LiveOps** in this section, as well as the basics of a game economy
    and publishing in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The success of GaaS depends on the complementary roles played by DevOps and
    LiveOps. DevOps is responsible for updating the game efficiently. At the same
    time, LiveOps decides which updates to include and how to engage players (determining
    what to buff or nerf in the game based on player engagement is a fun challenge!).
    Both tools work together to create a cycle of continuous improvement (that is,
    **Kaizen**) that sustains and improves the game with updates over time.
  prefs: []
  type: TYPE_NORMAL
- en: Kaizen (改善)
  prefs: []
  type: TYPE_NORMAL
- en: '**Kaizen** is the Sino-Japanese word for “improvement.” It’s all about continuous
    improvement. In game development, this could mean making small changes weekly
    or even daily to mechanics, balance, storylines, or even coding practices. It
    can help identify issues so that we can make adjustments early before they become
    more significant problems.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore these core services in more detail, starting with DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Unity DevOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**DevOps**, derived from the fusion of **development** (**Dev**) and **operations**
    (**Ops**) practices, plays a vital role in software development and is particularly
    valuable in game development, especially in the application of GaaS. Unity DevOps
    tools facilitate accelerated development and deployment cycles – throughout the
    entire production life cycle – and help ensure reliable game releases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examining the problems that can be solved using Unity DevOps tools can help
    us better understand the benefits. The service offerings tackle essential challenges
    in game development by addressing critical aspects such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Managing assets (complex and/or large)**: You can trust that your assets
    will be maintained and archived in your project repository, no matter the size
    or the complexity of their structure. This applies to working solo or in collaboration
    with a team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Managing code base changes**: In addition to managing assets, tracking changes
    via version history will ensure quality is maintained and progress on work is
    never lost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Streamlining build and deployment**: Automating the build process and deployment
    for your game’s executables significantly accelerates the distribution of updates
    – getting updates in the hands of your players quicker, whether that’s to squash
    bugs or improve player engagement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional reading | Unity DevOps
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity DevOps: [https://unity.com/products/unity-devops](https://unity.com/products/unity-devops)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two specific services Unity DevOps offers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unity Version Control**: Game development teams and solo developers can overcome
    project continuance challenges by using a specialized VCS that’s also tightly
    integrated with Unity Editor. Unity Version Control offers local and private cloud
    code repositories that provide a scalable collaboration platform for programmers,
    artists, and creators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be wondering why I suggest using Unity Version Control for our game
    development projects even though this book’s projects are shared with you through
    a link to GitHub at the beginning of each chapter. Well, the reason is straightforward:
    GitHub offers public repositories, which are commonly used for open source projects,
    while Unity Version Control does not provide this feature.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unity Build Automation**: A customizable build pipeline that seamlessly integrates
    with Unity Version Control or third-party repositories (for example, **GitHub**,
    **GitLab**, and **Bitbucket**). It provides robust platform build (for example,
    on Windows, Mac, Linux, Android, and iOS) and testing capabilities that streamline
    the process of building and deploying game builds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Unity DevOps services are much more than the brief introductions provided
    here, so let’s explore each in more detail. We’ll start with Unity Version Control.
  prefs: []
  type: TYPE_NORMAL
- en: Unity Version Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Unity Version Control** (formerly **Plastic SCM**) is a modern VCS that can
    be used seamlessly with Unity. It provides Unity-tailored version control capabilities
    and mitigates many of the risks associated with game development. For the record,
    you can use Unity Version Control with software platforms and projects other than
    Unity.'
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity Version Control
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity Version Control: [https://unity.com/solutions/version-control](https://unity.com/solutions/version-control)'
  prefs: []
  type: TYPE_NORMAL
- en: So, what is version control? Version control is a system that tracks file changes
    over time. It enables multiple people to collaborate on the same set of files
    and tracks the different file versions. It also allows you to revert to previous
    file versions if needed.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned repeatedly, due to its importance, it’s crucial to use a VCS to
    avoid losing work while working on game development projects. Version control,
    a central pillar of DevOps, also enables team collaboration while more easily
    resolving conflicts that can occur with multiple people working on the same code
    base and assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, Unity Version Control offers the following essential VCS features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Efficient management of large assets**: The Unity Version Control workspace
    optimizes handling large binary files in your projects (such as texture images
    and 3D model assets). Unlike other VCS offerings, which rely on problematic large
    file support add-ons, Unity Version Control ensures efficient storage and retrieval
    of large assets without any decrease in performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced collaboration with branching and merging**: Unity Version Control
    provides robust capabilities for branching implemented features into isolated
    environments and merging changes when two people have worked on the same file.
    This makes for a smoother collaboration experience across the project and teams
    by managing parallel or asynchronous work effectively to mitigate conflicts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud archiving for project continuance**: Most VCSs offer cloud archiving,
    as does Unity Version Control, which prevents losses from local system failures
    – which can and do occur! If your project source doesn’t exist in more than one
    location, it doesn’t exist. Yikes!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration with DevOps pipelines**: Unity Version Control works with any
    game engine or software development environment, not just Unity. There are integrations
    into DevOps toolchains, issue-tracking applications, team communication platforms,
    IDEs, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s explore Unity Build Automation, which picks up where Unity Version
    Control leaves off and is the second half of Unity DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Unity Build Automation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using **Unity Build Automation** tools, you can automate the process of creating
    and deploying builds across platforms, where frequent and reliable game updates
    are essential for GaaS in a DevOps environment – players can be brutal with developer
    expectations for rapid responses and high quality. As competitive as the games
    market can sometimes be, you generally get only one chance to hit a player’s expectations;
    otherwise, they’ll bail hard on your game.
  prefs: []
  type: TYPE_NORMAL
- en: Build automation complements version control by addressing developer challenges
    related to an individual and manual build creation process, as well as consistency
    and efficiency across build distributions. A winning combination of version control
    and build automation achieves a comprehensive solution for managing game development
    workflows, from code management to build distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity Build Automation
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity Build Automation: [https://unity.com/solutions/ci-cd](https://unity.com/solutions/ci-cd)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, Unity Build Automation offers the following essential build features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Streamlined central build process**: Building projects is a time-consuming
    endeavor, and keeping a developer’s system pegged at 100% CPU utilization during
    a build on their development machine crashes their productivity. Offloading the
    build and deployment processes from the local system to a cloud-based pipeline
    eliminates bottlenecks and provides a standardized process, especially when targeting
    multiple platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Streamlined build deployment process**: Automating the deployment process
    significantly saves time and eliminates the – error-prone – manual process of
    copying and uploading game builds to distribution servers across multiple platforms,
    ensuring your game binaries are always ready for release to your testing team
    (for solo Indie devs, this is your friends and family) or players.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time integration and feedback**: Since your QA testers and players have
    already expeditiously received the latest game update, there should be no delay
    in receiving feedback and bug reports. This is vital to promptly address your
    players’ needs and efficiently close the loop on iterating changes, maintaining
    the quality of the game in the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional reading | CI/CD
  prefs: []
  type: TYPE_NORMAL
- en: '**CI/CD** stands for **continuous integration** and **continuous deployment**
    (or **delivery**). It encompasses best practices for development teams using automated
    code integration and delivery.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What is CI/CD?: [https://www.infoworld.com/article/3271126/what-is-cicd-continuous-integration-and-continuous-delivery-explained.xhtml](https://www.infoworld.com/article/3271126/what-is-cicd-continuous-integration-and-continuous-delivery-explained.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging Unity DevOps, game developers can streamline their workflows,
    accelerate development cycles, and deliver higher-quality gaming experiences to
    their players. DevOps takes care of the production phase of your game development
    journey. Now, let’s review Unity LiveOps, which takes care of the release phase.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Unity LiveOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**LiveOps**, derived from the fusion of, well, **live** (**Live**) and **operations**
    (**Ops**) practices, also plays an important role in game development, especially
    in applying GaaS during the post-release phase. Unity LiveOps focuses on the activities
    required to run live games, such as content updates, community management, and
    analytics, all of which help keep your game relevant and engaging for players.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examining the problems Unity LiveOps tools can solve will help us better understand
    the benefits. The service offerings tackle essential challenges for operating
    a live game by addressing critical aspects such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optimizing player engagement**: To enhance player engagement and retention,
    we can employ LiveOps strategies that allow us to update game content dynamically,
    offer personalized player experiences, and respond to real-time analytics data
    to identify and reduce churn rate (that is, the number of players who leave the
    game and never return)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficient game management**: You can streamline game operations with automated
    event management, enable direct player communication, and rapidly iterate with
    A/B testing to align better with player expectations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monetization strategies**: Unity LiveOps provides tools to analyze in-app
    purchases and manage in-game ads, allowing us to optimize revenue with promotions
    and pricing while keeping our players happy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional reading | Unity LiveOps
  prefs: []
  type: TYPE_NORMAL
- en: 'Use LiveOps to get the insights you need for a better player experience: [https://unity.com/solutions/gaming-services/player-insights](https://unity.com/solutions/gaming-services/player-insights).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Power up your LiveOps strategy for better player retention: [https://unity.com/solutions/gaming-services/continuous-game-improvements](https://unity.com/solutions/gaming-services/continuous-game-improvements).'
  prefs: []
  type: TYPE_NORMAL
- en: Many services are included under the Unity LiveOps umbrella. These services
    collectively empower game developers to extend the life cycle of their games,
    so I encourage you to review the Unity LiveOps links in the preceding callout.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, a few services stand out as particularly crucial for the
    success and longevity of a live published game. So, we’ll only look at a few essential
    services for maintaining engagement and ensuring a high-quality player experience.
    These services can be found on Unity Cloud under the **Products** section, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – Unity Cloud products list](img/B18347_15_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 – Unity Cloud products list
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll list the services in the same categories Unity displays in the Unity Cloud
    dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GAMING SERVICES** | **ACCOUNTS**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player Authentication**: Enables secure and consistent player authentication,
    including anonymous, platform-specific, or custom options, and offers cross-device
    support and **Cloud Save**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GAMING SERVICES** | **ENGAGEMENT** **AND ANALYTICS**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analytics**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analyze**: A comprehensive set of analytics features, including **Game performance**,
    **Retention**, **Revenue**, and **User acquisition**, to make focused data-driven
    decisions. Custom dashboards and data explorers are available for your deep dives
    into player metrics, and they use funnels to identify your player journeys.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manage**: You can both manage and analyze in-game events (predefined and
    custom) with the **Event Manager** and **Event Browser** features. Well-placed
    events allow you to adjust gameplay strategies based on your players’ engagement.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game Overrides**: Utilizing **Remote Config** and **A/B Testing** allows
    for dynamic content and game-logic adjustments to target your player’s preferences
    (without the need to deploy a new game build), resulting in more engagement and
    more fun!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GAMING SERVICES** | **CRASH REPORTING**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud Diagnostics**: Utilize crash reporting tools to promptly detect and
    resolve issues that impact game stability and performance, resulting in a seamless
    and bug-free gaming experience for players'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity Cloud pricing
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity DevOps and LiveOps consist of a pay-as-you-go consumption model. All
    developers start with a generous free plan: [https://unity.com/solutions/gaming-services/pricing](https://unity.com/solutions/gaming-services/pricing).'
  prefs: []
  type: TYPE_NORMAL
- en: Note that **Authentication** and **Game Overrides** are 100% free.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing these essential LiveOps services into our games, we can strive
    for increased player engagement and satisfaction, both of which contribute to
    our game’s longevity. Completing our first published commercial game is only the
    start of our journey as career game developers. We want to enable our next game,
    so we should leverage all the tools at our disposal to help us get there.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how combining Unity DevOps and Unity LiveOps technologies,
    such as Unity Version Control and Analytics, equips game developers with the tools
    required to form the backbone of a successful GaaS project. Next, we’ll learn
    how to configure Unity Version Control to secure our game project code and assets.
  prefs: []
  type: TYPE_NORMAL
- en: Safeguarding your investment! Source code management with Unity Version Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity Version Control provides a customized version control solution for Unity
    projects with tight editor integration. This ensures our work is protected and
    that for team environments, a smooth collaboration experience is provided for
    team members. As previously stated, in software development, including game development,
    version control is essential to prevent data loss and effectively resolve conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll explore the steps to implement Unity Version Control
    for our projects. First, we’ll break down Unity Version Control’s approach to
    catering the VCS experience that’s specific to programmers and artists. We’ll
    start with programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Catering VCS for programmers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity Version Control provides customized workflows for artists and programmers
    in one repository. It offers developers the flexibility to work in centralized
    or distributed environments with comprehensive branching and merging capabilities.
    Artists and designers can use a simpler, user-friendly workspace interface called
    **Gluon** to take advantage of intuitive file-based asset workflows that enhance
    their creativity.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15**.2* shows the developer-centric workspace interface, which provides
    programmers with every feature on offer, such as **Pending Changes**, **Changesets**,
    **Branches**, and **Branch Explorer**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 – Unity Version Control workspace](img/B18347_15_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.2 – Unity Version Control workspace
  prefs: []
  type: TYPE_NORMAL
- en: Compare this to the simpler, more straightforward, artist-centric workspace
    interface in *Figure 15**.3* in the *Catering VCS for* *artists* section.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll delve into each interface’s features as we walk through setting
    up a new Unity project using Unity Version Control. But before that, we’ll look
    at the artist-centric workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Catering VCS for artists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gluon is recommended for artists who are using Unity Version Control to streamline
    art production workflows. Gluon provides an easy-to-use file management interface
    that allows you to select specific files to work on without the need to download
    and manage the entire project. Additionally, Gluon enables users to lock files
    (across branches), ensuring exclusive access to art assets so that no one else
    can modify the same file simultaneously and then seamlessly submit changes back
    to the repository. The ability to lock and unlock assets as needed during work
    enables smoother collaboration within a game production team.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15**.3* shows the simplified artist-centric Gluon workspace interface,
    which provides artists and designers with the **Workspace Explorer**, **Checkin
    Changes**, **Incoming Changes**, and **Changesets** features:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3 – Unity Version Control Gluon workspace](img/B18347_15_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.3 – Unity Version Control Gluon workspace
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Gluon
  prefs: []
  type: TYPE_NORMAL
- en: 'Version control for artists: [https://unity.com/solutions/version-control-artists](https://unity.com/solutions/version-control-artists)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Gluon also offers a unique feature that benefits artists directly: it has a
    built-in image viewer diff tool! With it, you can compare two versions of the
    same file from the change history so that there’s never a question of what changes
    were made, when, and by whom to the art assets in our projects. A Gluon workspace
    alone can be used as a robust asset management platform. Gluon works well with
    standard image formats such as PNG and JPG but can support additional formats
    with preview generators (for example, by adding **ImageMagick** as an external
    preview tool to add support for over 100 additional formats).'
  prefs: []
  type: TYPE_NORMAL
- en: Gluon’s image diff tool
  prefs: []
  type: TYPE_NORMAL
- en: With Gluon’s image diff tool, you can view images side by side, use an “onion
    skin” preview, calculate differences, do a “swipe,” and even compare image properties
    in text format.
  prefs: []
  type: TYPE_NORMAL
- en: Not only does Unity Version Control provide all the VCS tooling for daily operations
    such as checking in changes (that is, committing and pushing) and uploading to
    a cloud repository, handling incoming changes (that is, pulling), and merging
    and resolving file change conflicts within its workspace, it’s also fully compatible
    with the popular Git **distributed version control system** (**DVCS**). Let’s
    quickly look at how Unity Version Control operates as a Git client.
  prefs: []
  type: TYPE_NORMAL
- en: Catering VCS for Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For Git users, yes, Unity Version Control also has you covered – it also speaks
    the Git network protocol. It can push and pull changes directly with any remote
    Git server (such as **GitHub**, **GitLab**, or **Bitbucket**). The **Git Sync**
    feature, which is implemented in **Branch Explorer** (seen in *Figure 15**.7*)
    with a simple right-click menu, where you can choose **Push/Pull** | **Sync with
    Git…**, immediately turns Unity Version Control into a VCS that’s fully compatible
    with Git bidirectional synchronization. The advantage is that you can use Unity
    Version Control for all your DVCS client needs, either with a Unity Version Control
    workspace or a Git project.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Git
  prefs: []
  type: TYPE_NORMAL
- en: 'Git is a popular free and open source DVCS: [https://git-scm.com/](https://git-scm.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: However, Unity Version Control is designed to manage game-specific assets quickly
    and efficiently, even when dealing with huge files and binaries. This makes it
    an effective alternative to Git, especially Git **large file support** (**LFS**),
    which is known for its tendency to have issues. Whether your game assets are large
    or small, Unity Version Control offers a fast and efficient way to manage them
    all in your game projects.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, enough on practices and workflows – let’s set up our first Unity Version
    Control cloud workspace for a new Unity project.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Unity Version Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity has made adding version control to your projects as frictionless as possible
    by adding an option directly in the **Unity Hub** interface when creating a new
    project. You simply need to select a checkbox, as seen in *Figure 15**.4*. Use
    Unity Version Control? Check – yes, please!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 – Unity Hub showing a new version-controlled project](img/B18347_15_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.4 – Unity Hub showing a new version-controlled project
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating a project in Unity Hub, referring to *Figure 15**.4*, we must
    create and link a version control workspace by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Unity Hub** and click the **New Project** button (top-right of the window).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a template on which to base your new project (download the template if
    required).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, under the **PROJECT SETTINGS** section (right-hand side of the window),
    fill out the required fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Project name**: The name you’ll assign this project (something like “my awesome
    game” – no special characters).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Location**: Where you’ll store the project files on your local system drive
    (use a short path and no special characters).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unity Cloud Organization**: You must select an organization for your project.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connect to Unity Cloud**: Optional; enable this option if you intend to use
    UGS with this project (considering we already discussed all the benefits of UGS,
    we’d be doing ourselves a disservice if we don’t enable it).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Unity Version Control**: Finally, here we are. This is optional, but
    we should surely enable this option for our “my awesome game” project so that
    we don’t lose any of our development work!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click **Create project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let Unity do its thing, creating the project and Unity Version Control workspace
    locally and in Unity Cloud. When Unity Editor opens, we’ll be greeted by the **Unity
    Version Control** window. As we can see, we already have some pending file changes
    to check in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5 – Unity Editor’s Unity Version Control window](img/B18347_15_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.5 – Unity Editor’s Unity Version Control window
  prefs: []
  type: TYPE_NORMAL
- en: At any time, if you need the **Unity Version Control** window because it’s not
    currently showing, go to **Window** | **Unity Version Control** or click the button
    to the right of the *Manage services* (cloud icon) button (top left, directly
    under the file menu).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can also quickly use the standalone Unity Version Control desktop application,
    shown in *Figure 15**.5*, by clicking the gear icon and selecting **Open in**
    **Desktop App**.
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Figure 15**.5*, these files are the default assets Unity adds to
    a new project. They only exist locally in our project folder, so we need to inform
    the Unity Version Control workspace that we have these changes to track. We can
    do that by using the **Pending Changes** tab, confirming the files we want selected,
    and checking in the changes (or, in Git terms, **commit**).
  prefs: []
  type: TYPE_NORMAL
- en: '**Initial commit** is a common first commit message for a changeset, meaning
    this is the beginning of our workspace, or repository, history, so enter that
    in the text box provided at the bottom. Check the check box next to **Added and
    private** because we want all these files, too, then click **Check in Changes**.
    This will create a changeset and a file version history for all the files in the
    changeset. Yay! You’ve just made your first VCS commit!'
  prefs: []
  type: TYPE_NORMAL
- en: Committing best practices
  prefs: []
  type: TYPE_NORMAL
- en: Commit small, commit often. Or, at the very least, commit at the end of your
    workday to ensure no work progress is lost. It’s also good to test your work before
    committing and use a clear and concise commit message (for example, include why
    the change was made, not just what was changed).
  prefs: []
  type: TYPE_NORMAL
- en: The Unity Cloud dashboard also provides a browser-based interface for managing
    Unity Version Control repositories. It allows users to visualize and interface
    with their project’s version history, branches, changesets, code reviews, and
    file locks. Seats and user groups are also available for team management, and
    usage reporting is available for tracking billing.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view your game project’s cloud repository by opening Unity Cloud in
    your browser ([http://cloud.unity.com](http://cloud.unity.com)) and going to **DevOps**
    | **Repositories**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6 – Unity Cloud repositories dashboard](img/B18347_15_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.6 – Unity Cloud repositories dashboard
  prefs: []
  type: TYPE_NORMAL
- en: The VCS workflow is very simple and straightforward for a solo developer. You
    are the only person making changes, and you’ll rarely, if ever, conflict with
    yourself while performing daily work in your solo-member workspace.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling best practices
  prefs: []
  type: TYPE_NORMAL
- en: A common best practice for project teams is to regularly update their working
    copy by pulling the latest changes from the cloud repository to work from before
    starting new work or making further changes. That way, the team always builds
    upon moving the project code base forward.
  prefs: []
  type: TYPE_NORMAL
- en: You may, however, want to revert some changes to an earlier version. So, for
    those situations and if you’re working with a team of developers in the same workspace,
    we must consider some best practices for setting up a Unity project for collaboration
    to minimize file merge conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a collaborative project structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When setting up a Unity project for version control, adopting a project architecture
    designed for better collaboration is essential to help prevent workflow conflicts
    between team members. A well-organized project structure and clear guidelines
    for scene organization and prefab workflows can significantly reduce the likelihood
    of conflicts and problematic merge issues that are often encountered with Unity
    scene and Prefabs assets and any binary files that cannot merge.
  prefs: []
  type: TYPE_NORMAL
- en: Project organization and VCS best practices eBook (Unity)
  prefs: []
  type: TYPE_NORMAL
- en: 'Version control and project organization best practices for game developers:
    [https://unity.com/resources/version-control-project-organization-best-practices-ebook](https://unity.com/resources/version-control-project-organization-best-practices-ebook)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two aspects for better project structure that we touched on previously,
    namely Prefabs and scenes, deserve a bit more context, so let’s have a quick look
    at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prefab workflow**: Prefab workflows are crucial for efficient collaboration
    in Unity projects. Prefabs allow for modular game design, where game objects are
    pre-made objects that form the Scene Hierarchy and are put together to create
    all the necessary functionality. Prefab changes are carefully managed and communicated
    to minimize conflicts and ensure consistency. Still, they are updated separately
    from scene changes to prevent unintentional simultaneous scene updates by multiple
    team members.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additive scene workflow**: When it comes to managing scenes in Unity, it’s
    important to have collaborative workflows and organization strategies in place.
    Using an additive scene approach allows multiple developers to work on different
    aspects of the same level simultaneously by sectioning a level into main scenes
    and additive scenes (such as lighting, gameplay elements, or UI components); teams
    can work on different scenes in parallel and bring them together at runtime without
    conflicts. Additionally, ensure that Unity’s scene serialization is used in text
    mode (the default for version control) to make it easier for VCS to track changes
    and use merge tools such as **UnityYAMLMerge**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these Unity project-specific collaborative workflows, we can
    also use VCS team workflows, such as *branch per feature* or even *branch* *per
    task*.
  prefs: []
  type: TYPE_NORMAL
- en: When developing new features or working on specific project tasks, it’s often
    helpful for teams to work in isolated branches rather than use a single main (or
    master) branch. This approach facilitates collaboration by allowing each feature
    to progress on its own timeline, reducing conflicts and enabling parallel development
    among the team. As a result, team workflow is smoother, and project management
    becomes more organized.
  prefs: []
  type: TYPE_NORMAL
- en: Git Flow
  prefs: []
  type: TYPE_NORMAL
- en: In Git, **Git Flow** is a workflow that employs different branches for features,
    bug fixes, and releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 15**.7*, we can see how Unity Version Control visualizes the workspace
    branches. Additional branches will show up as forked from the changeset of the
    source branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7 – Unity Version Control branch explorer with changesets](img/B18347_15_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.7 – Unity Version Control branch explorer with changesets
  prefs: []
  type: TYPE_NORMAL
- en: Pull request (PR) | code review
  prefs: []
  type: TYPE_NORMAL
- en: After completing work on a feature branch, it’s a good practice to create a
    **pull request** (**PR**) to merge the changes into the dev/develop branch (before
    merging into the main branch for distribution). The team leader or a designated
    senior developer on the DevOps team should review the changes before accepting
    and merging the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unity Version Control, we don’t have PRs per se (it’s a Git concept). Instead,
    we have a whole code review system: [https://docs.plasticscm.com/code-review](https://docs.plasticscm.com/code-review).'
  prefs: []
  type: TYPE_NORMAL
- en: Once work has been completed on a features branch, using a PR or code review
    process is good practice to merge the work into the Dev (develop) branch. It’s
    the responsibility of the team leader or designated senior developer on the DevOps
    team to review before accepting and merging the request.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the day, what matters most is that you – or your development team
    – feel at ease with the VCS workflow. However, it’s not always possible to avoid
    merge conflicts, no matter how strictly we adhere to the best workflow practices
    and collaboration strategies. So, when faced with the inevitable task of resolving
    merge conflicts, we rely on merge tools to help us through.
  prefs: []
  type: TYPE_NORMAL
- en: Merging conflicting file changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unity Version Control comes with a powerful merge tool and merge configuration
    settings designed specifically for handling merges in Unity projects. The merge
    configuration allows us to specify asset-specific merge tools such as **UnityYAMLMerge**
    for Unity scene files and **Semantic Merge** for most other text-based file assets:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UnityYAMLMerge**: A merge tool that’s specific for merging scene and prefab
    files in YAML format. It understands the structure of Unity-specific assets, making
    it more intelligent than text-based merge tools. It is an invaluable asset for
    teams working on Unity projects, and Unity Version Control’s default configuration
    includes it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Semantic Merge**: An intelligent C# language-dependent merge tool that can
    resolve code conflicts efficiently, mostly automatically, because it understands
    code structure beyond simple text differences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing file history and differences
  prefs: []
  type: TYPE_NORMAL
- en: You can right-click on any script or asset at any time in the Unity Editor’s
    **Project** window and select **Unity Version Control** | **View** **file history**.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can select **Unity Version Control** | **Diff with previous
    revision** to see file-specific changes between the two.
  prefs: []
  type: TYPE_NORMAL
- en: I hope I have convinced you of the value of using the Unity version control
    system in your game project – or any VCS. We learned how to set up Unity Version
    Control for a new Unity project, the basics of checking in our work, and some
    best practices for organizing our project for team collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: Unity Version Control pricing
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity Version Control enables you, or your team, to safely and securely store
    and work with your game project assets and data in parallel: [https://unity.com/products/unity-devops#pricing](https://unity.com/products/unity-devops#pricing).'
  prefs: []
  type: TYPE_NORMAL
- en: Unity provides 1 to 3 seats and 5 GB of storage for free. You only pay for additional
    seats (per seat per month for additional team members) and anything above 5 GB
    of storage (per GB per month).
  prefs: []
  type: TYPE_NORMAL
- en: I relied on Unity Version Control throughout the entire process of creating
    the projects for this book. You didn’t think I would want to risk losing my work
    at any point during the project’s progress, did you?
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll continue our discussion for preparing our games for
    commercial release with an overview of an in-game economy.
  prefs: []
  type: TYPE_NORMAL
- en: Engaging players with an in-game economy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In-game economies are critical for commercial success and warrant our attention
    when designing our games. Different monetization mechanisms, when designing our
    game mechanics, play a significant role in our ability to generate revenue within
    the game, which is distinct from commercialization efforts such as marketing and
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Economy mechanisms can cover a wide range of strategies and differ, sometimes
    drastically, between game platforms and genres. These strategies can include microtransactions,
    ads, virtual currencies, subscription models, or premium game purchases. By understanding
    a few basic nuances between these mechanisms, game producers and developers can
    gain an understanding of effective commercial strategies for their games.
  prefs: []
  type: TYPE_NORMAL
- en: Commercialization versus monetization
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between commercialization and monetization lies in their respective
    focuses. Commercialization is primarily concerned with bringing a game to market
    and making it available to players, while monetization deals with how the game
    generates revenue once it’s in players’ hands.
  prefs: []
  type: TYPE_NORMAL
- en: Producers have two primary platforms to choose from when launching commercial
    games, and how game economies are structured varies significantly between them.
    These are **mobile** and **PC** – we could even say “free” and premium.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s quickly look at what each platform’s economic strategy is designed
    to do, starting with mobile.
  prefs: []
  type: TYPE_NORMAL
- en: Economies for mobile games
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mobile games often follow a “freemium” or **free-to-play** (**F2P**) model,
    which means they are available for players to download and play without any up-front
    payment. However, the monetization strategy includes buying virtual currency for
    in-game items, watching ads, or paying microtransactions to obtain different gameplay
    advantages. Unsurprisingly, this model is designed to attract a wide range of
    players to download and play the game, meaning your game has to be remarkable
    and fun to be successful since most mobile games only earn from a small fraction
    of their players (churn is real – players need to find the fun fast!).
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the most out of a commercial game release on mobile, here are some key
    strategies you can focus on in your game design:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encourage regular player engagement**: Mobile game developers commonly use
    daily login rewards, quests, events, timers, speed-ups, and even weekly or monthly
    challenges to encourage players to return to the game regularly with the ultimate
    goal of getting players to buy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rewarded ad watch**: One way of generating ad revenue is by offering rewards
    to players in exchange for watching the entire ad. Rewards can speed up gameplay
    progress, double virtual currency rewards, or even save the player’s progress.
    You get the ad revenue but also lead the player down a path to buying later on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In-game purchase offers**: Cosmetic items to gameplay advantages are on offer
    here. However, it’s crucial to balance gameplay advantages to avoid “pay-to-win”
    scenarios, which can tend to drive players away.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscriptions and season passes**: Providing unique content for a limited
    time – evoking a sense of urgency and excitement – can motivate players to keep
    coming back and engage them to keep spending on your game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s not an extensive list by any means, and implementing these strategies in
    your games’ monetization mechanics requires a lot of subtlety. Still, it would
    be best to have a general sense of what’s needed to introduce an in-game economy
    for your mobile game’s commercial potential.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll examine similar strategies for premium games.
  prefs: []
  type: TYPE_NORMAL
- en: Economies for premium games
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Premium games, which are purchased upfront and only offer a *free* play experience
    if the publisher provides a demo, focus more on the player’s initial investment
    but may include additional incentives for revenue longevity. To contradict a bit
    of what I just said, though, some titles are F2P but monetize purely through in-game
    purchases and expansion packs. As such, the premium game economy differs significantly
    from mobile games.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key strategies you can focus on in your game design to get the
    most out of a commercial game release on PC:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expansion packs and downloadable content (DLC)**: To extend the life cycle
    and longevity of premium games, new stories and content can be purchased by players
    after their initial release to generate additional revenue. It’s best to account
    for DLC during the development phase because the game architecture must support
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In-game purchase offers**: This one crosses over from mobile since we also
    include cosmetic items and gameplay advantages here. You don’t need to look any
    further than the free-to-play **Fortnite** to know how much revenue can be generated
    from cosmetic items! Again, here, it’s important to balance gameplay advantages
    to avoid “pay-to-win” scenarios – I believe the PC crowd is more inclined to be
    driven away here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The game’s initial quality and depth = player trust**: Premium games should
    offer gameplay experiences that justify the price tag to the player (that is,
    the feeling that what they paid for the game is worthwhile). So, in this case,
    the game’s economy should focus on enriching the player experience and not so
    much on encouraging more player spending, which is a difficult balance to strike
    when we try to ensure our investment in making the game is positive from a revenue
    perspective.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is also not an extensive list, with the obvious subtleties required to
    implement these strategies being left to your creative mind while we wear our
    economist hat. However, it’s still a good sense of what’s needed to bring in-game
    economies for a premium game’s commercial potential.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s finish our introduction to the in-game economy by examining the contrasting
    strategies and mechanisms of the mobile and PC platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Contrasting economic strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The platforms we’ve discussed regarding the in-game economy each have distinct
    approaches to engaging players and generating the resulting revenue (hopefully).
    To better understand the differences in the strategies laid out for each one,
    we can simply and clearly compare the key strategies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following matrix table shows the primary differences between each platform’s
    in-game economy strategy and associated player engagement:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Strategy** | **Mobile Games** | **PC (****Premium) Games** |'
  prefs: []
  type: TYPE_TB
- en: '| Engagement versus investment | Focus on constant player engagement and frequent
    but small incentivized transactions | Focus on the initial player investment and
    later offer expanded content with DLCs |'
  prefs: []
  type: TYPE_TB
- en: '| Accessibility versus depth | Games must be easy to pick up and play, be addictively
    fun, and attract a broad audience of players | Games must offer deeper and more
    complex gameplay experiences to hook long-term players |'
  prefs: []
  type: TYPE_TB
- en: '| Monetization frequency | Relies on continuous monetization opportunities
    employing several strategies for player spending | Relies on monetizing through
    fewer but more significant player spending, if any, beyond the initial game purchase
    |'
  prefs: []
  type: TYPE_TB
- en: Table 15.1 – In-game economy contrast between mobile and PC games
  prefs: []
  type: TYPE_NORMAL
- en: Creating an in-game economy is a delicate task that requires many disciplines,
    including a mashup of gameplay design and fair monetization strategies. For mobile
    games, the challenge lies in attracting and then engaging a small percentage of
    players to convince them to spend real money on an otherwise free experience.
    And for premium PC games, the challenge lies initially in offering enough upfront
    value to players that they’ll gladly justify purchasing your game. Then, it’s
    up to you to engage them to want to spend more for additional content. Both economies
    require a thorough understanding of your target player demographic and your ability
    to avoid introducing undesirable monetization approaches.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned the basics of an in-game economy for mobile and
    PC platforms. Of course, a lot more can be learned here, so I encourage you to
    do additional reading on the topics that appeal most to your game’s design. As
    it would happen, Unity provides best practices and guides on the subject too!
  prefs: []
  type: TYPE_NORMAL
- en: What is an in-game economy | Unity
  prefs: []
  type: TYPE_NORMAL
- en: 'The first guide in a series about the in-game economy: [https://unity.com/how-to/what-is-in-game-economy-guide-part-1](https://unity.com/how-to/what-is-in-game-economy-guide-part-1).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll explore the platform distribution aspect of a game
    production’s life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Getting your game out there! Platform distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we talked about the mobile and PC platforms concerning
    the in-game economies. However, we did not go into detail about distributing to
    these platforms. Well, now’s the time.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll examine the options available for distributing our games
    on mobile and PC platforms. This will be a high-level review of the processes,
    with a focus geared more toward commercial releases. I’ll also provide links for
    each platform for the – in most cases – step-by-step details of preparing our
    game for distribution on that platform.
  prefs: []
  type: TYPE_NORMAL
- en: Console distribution
  prefs: []
  type: TYPE_NORMAL
- en: For console distribution platforms such as **PlayStation**, **Xbox**, and **Nintendo
    Switch**, a game developer – who is not associated with a large AAA studio – will
    face additional challenges regarding these platforms. The additional set of requirements
    for getting our games on consoles generally involves such things as a rigorous
    approval process, purchase of a costly developer’s kit, a lengthy and complicated
    code porting process, and conforming to specific standards and performance requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with mobile, let’s discover what’s available to get our game into players’
    hands.
  prefs: []
  type: TYPE_NORMAL
- en: Distributing on mobile platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the world of mobile game distribution, there are two key players to be aware
    of – let’s face it, most people old enough to buy a smartphone or tablet device
    know what they are – the **Google Play Store** and the **Apple** **App Store**.
  prefs: []
  type: TYPE_NORMAL
- en: These mobile-centric platforms, or storefronts, offer developers access to a
    vast global audience without much friction in accessing the platform and building
    our games – especially when using Unity. However, developers are challenged with
    standing out in a crowded marketplace and competing with large studios (and large
    marketing budgets!), so it’s critical to optimize for discoverability with not
    only a remarkable game but also learning the ins and outs of **app store** **optimization**
    (**ASO**).
  prefs: []
  type: TYPE_NORMAL
- en: The free-to-play model is king on mobile storefronts since it’s what the storefronts
    provide significant support for and is generally what players still expect. As
    mentioned in the previous section, *Engaging players with an in-game economy*,
    and aligning with player expectations, we’ll want to consider the platform’s built-in
    payment systems for in-app purchases and ads for revenue.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with an overview of the publishing requirements for the Google Play
    Store.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing on the Google Play Store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Developers looking to publish their games on the Google Play Store must understand
    both the technical and financial aspects of the platform – this is true not only
    for the Google Play Store but also for any of the distribution platforms available
    to us.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the technical aspects, publishing to the Google Play Store means
    building our games for the **Android** platform. Unity offers great support building
    for Android and provides many settings for customizing the game builds (such as
    a graphics API, texture compression, quality settings, and a scripting backend).
    In addition, Unity provides scripting API access to mobile-specific device features
    such as touch input, camera, vibration, gyroscope and accelerometer, location
    services, notifications, and AR support (**ARCore**).
  prefs: []
  type: TYPE_NORMAL
- en: Android screen resolutions
  prefs: []
  type: TYPE_NORMAL
- en: Adapting games for Android devices poses a significant challenge to mobile developers
    because of the eye-widening number of screen resolutions, aspect ratios, display
    notches and cutouts, and now foldables out in the wild west of device manufacturers.
    This requires the game developer to put on their UI designer hat and implement
    responsive and flexible UI design strategies to ensure an optimal viewing experience
    within the screens’ safe areas across devices.
  prefs: []
  type: TYPE_NORMAL
- en: Each distribution platform generally offers a unique set of value-added services
    specific to its platform that developers can incorporate into their game designs.
    Google offers its **Google Play Games Services**, which include sign-in, saved
    games, achievements, leaderboards, friends, player stats, and events.
  prefs: []
  type: TYPE_NORMAL
- en: Google Play Store | distribution information
  prefs: []
  type: TYPE_NORMAL
- en: 'Release with confidence: [https://play.google.com/console/about/guides/releasewithconfidence/](https://play.google.com/console/about/guides/releasewithconfidence/)'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s review the publishing requirements for the Apple App Store.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing on the Apple App Store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Developers looking to publish their games on the Apple App Store must understand
    that it has its own technical and financial aspects for distributing games on
    the platform. Again, this is something true for all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: When looking to publish games to the Apple App Store, the technical aspects
    involve building our games for the **iOS** platform. Unity has us covered here,
    too, and offers excellent support for building iOS **Xcode** projects. Correct
    – I didn’t say game build. Unity generates an Xcode project to build iOS apps
    and games, so if you want to build a game locally, you must have Xcode installed
    – it’s only available on **macOS** systems. However, Unity Build Automation, which
    we already know from the *Introducing Unity DevOps* section, can build and deploy
    iOS games for you, making it possible to develop an iOS application on non-macOS
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Build for iOS: [https://docs.unity3d.com/2022.3/Documentation/Manual/iphone-BuildProcess.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/iphone-BuildProcess.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Unsurprisingly, Unity also provides scripting API access for iOS device-specific
    features such as touch input, camera, vibration, gyroscope and accelerometer,
    location services, notifications, and AR support (**ARKit**).
  prefs: []
  type: TYPE_NORMAL
- en: iOS screen resolutions
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to Android, the iOS device ecosystem offers a more consistent range
    of screen resolutions, aspect ratios, and “notched” safe areas to display game
    content and UI within. Apple’s well-controlled hardware designs also mean there
    are fewer device models, each with its well-documented screen specifications.
    This uniformity simplifies game development as we wear our UI-designer hats to
    ensure our games are presented more seamlessly across Apple’s mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apple also offers a range of value-added services specific to its platforms
    that developers can incorporate into their game designs. Apple offers **Game Center**,
    which can be utilized for games targeting **Apple Arcade**. The following services
    are available: player identity, saved games, leaderboards, achievements, and turn-based
    and multiplayer games.'
  prefs: []
  type: TYPE_NORMAL
- en: Apple App Store | distribution information
  prefs: []
  type: TYPE_NORMAL
- en: 'Submit your iOS apps to the App Store: [https://developer.apple.com/ios/submit/](https://developer.apple.com/ios/submit/).'
  prefs: []
  type: TYPE_NORMAL
- en: Additional third-party app stores are available for Android and target smaller
    but more direct markets, such as **Amazon Appstore**, **Samsung Galaxy Store**,
    **Huawei AppGallery**, and **APPTUTTi**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unity Distribution Portal** ([https://api-udp.unity.com/](https://api-udp.unity.com/))
    attempts to simplify the process of releasing and managing our Android game releases
    to multiple global app stores, so that may be of interest. But there are (currently)
    no such third-party app store markets for iOS.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s finish up the mobile distribution platforms with a quick breakdown of
    the financial considerations.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing financials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the financial aspect, I’ve compiled the essential publishing information
    for developers interested in the Google Play Store and Apple App Store platforms
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Registration Fee** | **Revenue Cut** | **Platform** |'
  prefs: []
  type: TYPE_TB
- en: '| **Google** **Play Store** | $25 one-time | 70/30% split*30% to Google | Wide
    audience reach, rich games market |'
  prefs: []
  type: TYPE_TB
- en: '| **Apple** **App Store** | $99 annual | 70/30% split*30% to Apple | Apple
    device users only, Apple Arcade |'
  prefs: []
  type: TYPE_TB
- en: Table 15.2 – Mobile store publishing details
  prefs: []
  type: TYPE_NORMAL
- en: Note regarding Table 15.2
  prefs: []
  type: TYPE_NORMAL
- en: '*I’ve greatly simplified this statement because it’s constantly evolving; please
    consult the platform documentation for current information. In some situations,
    the revenue fee is lowered to 15%.'
  prefs: []
  type: TYPE_NORMAL
- en: That covers mobile-specific distribution platforms, so let’s move on to PC-based
    platforms and explore some of their specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Distributing on PC platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PC games have a wider range of distribution options for both commercial sale
    of and non-commercial sharing of our games. For mobile games, the distribution
    is purely digital delivery, whereas PC games can have physical distribution channels,
    too, but we’ll focus only on digital storefronts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steam** and **Epic Games Store** are the two primary parties involved in
    the PC-based game digital storefronts. The primary commercialization strategy
    for these storefronts is premium. Generally speaking, PC-based players usually
    seek more immersive gameplay experiences than mobile offers, which aligns more
    with the premium model’s focus on upfront purchases or subscriptions.'
  prefs: []
  type: TYPE_NORMAL
- en: However, just as much as with mobile storefronts, developers launching on PC
    game distribution platforms must maximize visibility, navigate channels, and leverage
    platform-specific features to entice players, enhance their engagement, and, of
    course, drive sales.
  prefs: []
  type: TYPE_NORMAL
- en: Direct sales
  prefs: []
  type: TYPE_NORMAL
- en: Game developers can offer their games directly to players from their websites
    as an alternative to PC game storefronts. This approach provides higher revenue
    per sale and complete control over the sales process but does require significant
    effort and investment in marketing, customer service, and infrastructure. Do you
    want to make games and get them in players’ hands or manage an eCommerce website?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into each of these primary PC game storefronts now, with similar
    coverage to the mobile storefronts, and finish with **Itch.io**, which caters
    more to smaller independent game developers for both premium, donation-based,
    or completely free game distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing on Steam
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It should be no surprise that developers looking to publish their PC games on
    Steam must also navigate and understand this platform’s technical and financial
    aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the technical aspects, publishing to Steam means building our games
    for standalone PC platforms, but primarily Windows (Mac and Linux are also supported).
    Before being able to publish our Unity games on Steam, we first need to integrate
    the **Steamworks software developer kit** (**SDK**). The SDK provides all the
    necessary tools and resources to ensure compatibility with the Steam distribution
    platform (including such essential things as setting our Steam **App ID**). Games
    must also meet specific technical requirements set by the platform. These requirements
    include such things as minimum system specifications, controller support, and
    game performance.
  prefs: []
  type: TYPE_NORMAL
- en: Like what mobile platforms provide, PC platforms also have unique services that
    add value to our games! For Steam, we have a full breadth of services available
    to integrate into our games, including achievements, game statistics, leaderboards,
    OpenID, game notifications, voice chat and commands, input, player-created content,
    inventory, microtransactions, game servers, and matchmaking and lobbies for multiplayer.
  prefs: []
  type: TYPE_NORMAL
- en: Steam | distribution information
  prefs: []
  type: TYPE_NORMAL
- en: 'See what Steamworks has to offer: [https://partner.steamgames.com/](https://partner.steamgames.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the other side of the coin for PC game distribution platforms,
    the Epic Games Store.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing on the Epic Games Store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Developers who want to distribute their PC games on the **Epic Games Store**
    (**Epic**) face the same familiar platform technical and financial aspects. Let’s
    review them.
  prefs: []
  type: TYPE_NORMAL
- en: The technical aspects are up first; publishing to Epic means building our games
    for standalone PC platforms, which Epic supports for Windows and Mac. Unlike Steam,
    Epic does not require us to integrate any specific platform SDKs, but games still
    must meet the particular technical requirements set by the platform. The requirements
    are designed to provide the best gameplay experiences and, surprisingly, not lock
    players into a single storefront. The requirements include supporting crossplay
    for multiplayer games across any PC storefront, implementing achievements for
    Epic if implemented in other stores’ distributions, and ensuring games download,
    install, launch, and function consistently – while also being of sufficient quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s not to say that Epic doesn’t offer gaming services similar to Steam
    – they provide a dizzying array of online services. **Epic Online Services** (**EOS**)
    has built-in support for all kinds of platforms: Windows, Mac, Linux, PlayStation,
    Xbox, Nintendo Switch, Android, and iOS. The services on offer for both account
    and game services include achievements, gameplay stats, leaderboards, login, player
    accounts and data storage, title storage, player management, friends, presence,
    game invites, voice chat, analytics, anti-cheat, and multiplayer services with
    crossplay, peer-to-peer, matchmaking, and lobbies. Whew! Mind you, they all are
    entirely free to use.'
  prefs: []
  type: TYPE_NORMAL
- en: Why is Epic providing free online game services?
  prefs: []
  type: TYPE_NORMAL
- en: Scaling a game and strengthening player communities requires various backend
    services and infrastructure; finishing our games is only half the battle. Epic
    offers help for game developers to succeed with their games by providing services
    – initially made for Fortnite and currently operating the Epic Games Store – for
    free for all developers. The sentiment from Epic is that they succeed when, through
    widespread adoption of their services, the participating developers succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Epic has also recently started allowing indie game developers to self-publish
    on their store through the **Epic Developer Portal**, stating that the store is
    open to all developers and game publishers, so long as their games meet the store’s
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Epic Games | distribution information
  prefs: []
  type: TYPE_NORMAL
- en: 'Start distributing PC games on the Epic Games Store: [https://store.epicgames.com/en-US/distribution](https://store.epicgames.com/en-US/distribution).'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to self-publishing as a differentiating factor, Epic Games Store
    is also known for exclusivity deals, regular free game giveaways, grant awards,
    and support for blockchain-based games (wading into a more controversial side
    of game development).
  prefs: []
  type: TYPE_NORMAL
- en: Web3 (blockchain) games
  prefs: []
  type: TYPE_NORMAL
- en: 'The Epic Games Store is one of the only leading storefronts to embrace blockchain
    technology games. Blockchain, NFT, and cryptocurrency products can be published
    but only if they follow specific policies: [https://dev.epicgames.com/docs/epic-games-store/requirements-guidelines/distribution-requirements/blockchain](https://dev.epicgames.com/docs/epic-games-store/requirements-guidelines/distribution-requirements/blockchain).'
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning from the leading PC distribution platform storefronts to a more
    indie-friendly distribution platform is a pivot away from purely commercial revenue
    generation aspirations. Let’s have a look at how more indie-friendly platforms,
    such as Itch.io and **Game Jolt**, prioritize creative freedom and a more experimental
    space for game developers to share their game creations with the world.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing on Itch.io
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the landscape of digital distribution platform storefronts, Itch.io stands
    apart. The platform distinctly caters to indie game developers and creatives.
    That’s not to say it’s not home to some well-known and popular titles such as
    *Celeste*, *Night in the Woods*, and *Doki Doki Literature Club!* (for you visual
    novel fans). The platform offers a unique opportunity for game publishers to start
    small and scale up as their games grow.
  prefs: []
  type: TYPE_NORMAL
- en: The technical aspects of the platform are pretty open because the type of platforms
    supported varies, depending on the kind of game being distributed via Unity or
    literally any other game engine or coding framework. The platform supports playing
    `*.zip` and `*.rar` files), as well as media files (that is, image, audio, and
    video files).
  prefs: []
  type: TYPE_NORMAL
- en: Itch.io | Distribution information
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a custom page to instantly distribute or sell your indie games: [https://itch.io/developers](https://itch.io/developers).'
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the financial aspect, Itch.io allows sellers to determine the revenue
    percentage share to Itch.io, ranging from 0% to 100%, with a default rate of 10%
    if you don’t make any changes to it. Yay!
  prefs: []
  type: TYPE_NORMAL
- en: Itch.io revenue sharing
  prefs: []
  type: TYPE_NORMAL
- en: 'Introducing open revenue sharing: [https://itch.io/updates/introducing-open-revenue-sharing](https://itch.io/updates/introducing-open-revenue-sharing).'
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, for Unity developers just looking to quickly share their games
    (usually early prototypes or development in progress for testing), the **SIMMER.io**
    website provides drag-and-drop simplicity for quickly sharing WebGL game builds.
    I believe a “tip jar” is in the works.
  prefs: []
  type: TYPE_NORMAL
- en: SIMMER.io
  prefs: []
  type: TYPE_NORMAL
- en: 'A place for Unity developers to share WebGL games fast and easy (and free):
    [https://simmer.io/](https://simmer.io/).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s finish up the PC distribution platforms with a quick breakdown of the
    financial considerations.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing financials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the financial aspect, the essential publishing information for developers
    interested in releasing on Steam, Epic Games Store, or Itch.io is shown in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Registration Fee** | **Revenue Cut** | **Platform** |'
  prefs: []
  type: TYPE_TB
- en: '| **Steam** | $100 fee for each gameReimbursed with $1,000 earned revenue |
    70/30% split*30% to Steam | Massive community, **Steamworks** tools for developers
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Epic Games** **Store** | $100 fee for each game (self-publish) | 88/12%
    split*12% to Epic | Exclusivity deals, game funding, free gaming services (EOS),
    makers of Unreal Engine, home of *Fortnite* |'
  prefs: []
  type: TYPE_TB
- en: '| **Itch.io** | None | Open revenue sharing0% to 100% to Itch.io* | Large indie
    game dev community, creative freedom, flexible pricing, donations |'
  prefs: []
  type: TYPE_TB
- en: Table 15.3 – Steam publishing details
  prefs: []
  type: TYPE_NORMAL
- en: Note regarding Table 15.3
  prefs: []
  type: TYPE_NORMAL
- en: '*I’ve greatly simplified this statement because it’s constantly evolving; please
    consult the platform documentation for current information.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the larger game distribution platforms for
    mobile and PC. We explored the technical and financial aspects of publishing games
    on these storefronts and looked at what distinct services they offer for integrating
    into our game’s design.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll walk through an example implementation of UGS and publish the game
    to a PC-based store platform.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing UGS and publishing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a foundational knowledge of Unity’s cloud services for DevOps
    and LiveOps, let’s walk through an example of adding base LiveOps analytics and
    crash reporting to a project and implementing a basic player engagement strategy
    by updating game content dynamically. We’ll finish up by automating our build
    process with DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by adding the LiveOps services to our game project. For this example,
    and as seen in this chapter’s screenshots, I’ll use the 2D collection game we
    started with in [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041). To follow along,
    you’ll either need to have made a game based on that project, or you can download
    the Unity project from this book’s GitHub repository here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch2/Unity%20Project](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch2/Unity%20Project).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding LiveOps services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two services we’ll be adding to our game project are **Analytics** and **Cloud
    Diagnostics**. These services are the most basic activities required to run live
    games successfully, and I wouldn’t publish a game without them! We can easily
    understand how our game is performing with our players, and Unity’s providing
    these services out-of-the-box is a definite plus.
  prefs: []
  type: TYPE_NORMAL
- en: Both services are available to add and enable directly within the Unity Editor.
    Let’s start by adding the Analytics service.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Analytics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Unity Analytics service collects essential data about your game and players.
    Core game events and user properties are automatically collected when a player
    opens and runs your game. Additionally, you can define and track your custom in-game
    events. All the data that’s collected from the player activity is aggregated and
    displayed in the Unity Cloud dashboard, which allows you, or any team member,
    to analyze the data and gain insights related to player engagement. Analytics
    is invaluable in determining how to optimize your game for increased player retention
    and satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Deep data insights about your game: [https://unity.com/products/unity-analytics](https://unity.com/products/unity-analytics).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get started with Analytics: [https://docs.unity.com/ugs/en-us/manual/analytics/manual/get-started](https://docs.unity.com/ugs/en-us/manual/analytics/manual/get-started).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, it’s easy to quickly add to our games by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Window** | **Package Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Packages** dropdown, change the context to **Unity Registry**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `analytics`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Analytics** and click the **Install** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once installed, click the **Configure** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Go to Dashboard** link to open the Unity Cloud dashboard (in your
    default web browser) to configure and monitor events and get an overview of your
    game’s activity in **Game performance**, drill down into critical metrics with
    **Data Explorer**, and see how events change over time with **Event Browser.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initializing the Analytics service
  prefs: []
  type: TYPE_NORMAL
- en: To start collecting player data to be shown and analyzed in the Unity Cloud
    dashboard, we’ll have to do two things for the Analytics service. First, we need
    to call **UnityServices.InitializeAsync()** when the game starts. More importantly,
    due to data privacy regulations (such as GDPR, CCPA, or PIPL), we’ll also need
    to have the player opt into having data collected so that we can call **StartDataCollection()**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find detailed information on how to perform this initial setup here:
    [https://docs.unity.com/ugs/en-us/manual/analytics/manual/sdk-guide](https://docs.unity.com/ugs/en-us/manual/analytics/manual/sdk-guide).'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve provided a basic analytics initialization script example for you to get
    started with here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch15/Game-Assets/AnalyticsInitialization.zip](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch15/Game-Assets/AnalyticsInitialization.zip).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make opting in a positive experience for your players by using a statement
    like the following: “*Help us create a better game experience for you! Opting
    into analytics lets us learn how you play the game and what we can improve. We
    take your privacy seriously; all data is collected anonymously and used solely
    to enhance gameplay and features. Thank you for your support!*” (Disclaimer: I
    am not a lawyer; you should consult accordingly when it comes to regulations.)'
  prefs: []
  type: TYPE_NORMAL
- en: Adding our next LiveOps service will be even easier.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Cloud Diagnostics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most essential service that’s included under Cloud Diagnostics is, by far,
    **Crash and Exception Reporting**. When your game is out in the wild with players
    banging on it, it is incredibly challenging to know what’s going on with its operational
    stability. You can get real-time data on crashes and exceptions in your games
    by simply adding and enabling the service in your project from Unity Editor. Then,
    you can periodically view any occurrences with their crash and exception details
    (including stack trace) to take action on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add Cloud Diagnostics to your project, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Window** | **Package Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Packages** dropdown, change the context to **Unity Registry**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `diagnostics`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Cloud Diagnostics** and click the **Install** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once installed, click the **Configure** button (or, at any time, go to **Services**
    | **Cloud Diagnostics** | **Configure**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the slider in the top-right corner of the **Project Settings** window
    to enable Cloud Diagnostics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Go to Dashboard** link to open the Unity Cloud dashboard (in your
    default web browser) to monitor and review any crash occurrences in Crash and
    Exception Reporting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up Cloud Diagnostics: [https://unity.com/products/cloud-diagnostics](https://unity.com/products/cloud-diagnostics)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up Crash and Exception Reporting: [https://docs.unity.com/ugs/manual/cloud-diagnostics/manual/CrashandExceptionReporting/SettingupCrashandExceptionReporting](https://docs.unity.com/ugs/manual/cloud-diagnostics/manual/CrashandExceptionReporting/SettingupCrashandExceptionReporting)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our configuration of the Cloud Diagnostics service, we can use a `Debug.LogException()`
    statement to view an exception message within the Console window in the `Start()`
    method of any script added to a GameObject in your scene and enter **Play Mode**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To finish our LiveOps example, let’s see how we can dynamically change game
    content by adding a seasonal holiday theme to our ladybug player character for
    Halloween.
  prefs: []
  type: TYPE_NORMAL
- en: Updating game content dynamically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The autumn season in the Northeastern part of the United States has always
    been my favorite time of the year, both as an adult and while growing up. I particularly
    enjoy the Halloween season during this time. With that being said, let’s begin
    the dynamic content update by taking inspiration from this season and seeing how
    I’ve added to the artwork for our ladybug player character from the 2D collection
    game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8 – Halloween-themed player character](img/B18347_15_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.8 – Halloween-themed player character
  prefs: []
  type: TYPE_NORMAL
- en: Scary, right? As seen in the `Player` Prefab root named `Graphics_Halloween`.
    In the `GameObject` array with a header of `Theme Graphics`, where I’ve assigned
    both the original graphics, renamed to `Graphics_Default`, and the new holiday
    graphics.
  prefs: []
  type: TYPE_NORMAL
- en: To follow along…
  prefs: []
  type: TYPE_NORMAL
- en: 'You can either update your ladybug player character with holiday graphics and
    add the **_graphics** array to the **PlayerController** script yourself (refer
    to the *Updating the player controller script* section that follows) or find the
    updated player character with both of these already completed in this book’s GitHub
    repository: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch15/Game-Assets/SeasonalPlayer.zip](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch15/Game-Assets/SeasonalPlayer.zip).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how we’ll dynamically switch to the Halloween graphics by setting
    up and coding a **Remote** **Config** integration.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Remote Config
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With Remote Config, we can fine-tune game adjustments for difficulty or time
    values, make personalization changes, or run timed events without having to distribute
    a new game build – providing we account for these features during our design and
    development phases, that is.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, we’ll use a simple Boolean value for our configuration key
    value to turn on or off the display of the Halloween graphics. First things first,
    however, we need to install and configure Remote Config by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Window** | **Package Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Packages** dropdown, change the context to **Unity Registry**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `remote`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **Remote Config** and click the **Install** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that Remote Config requires **Authentication** and will also install it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once installed, go to **Window** | **Remote Config** (no, I don’t know why
    it’s not also under **Services**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.9 – Remote Config key value settings in the Editor area](img/B18347_15_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.9 – Remote Config key value settings in the Editor area
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Figure 15**.9*, by default, our environment will be **production**,
    but just know that you have the option of creating any number of additional environments
    for your needs – the first logical one would be **development** for working within
    the **Editor** area and testing before pushing to production (that is, your live
    players).
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 15**.9*, you can quickly access the Unity Cloud dashboard
    using the **View in Dashboard** button. The web dashboard allows you to add and
    change key values without firing up Unity Editor and is available from any computer
    or mobile device with a web browser; just go to [https://cloud.unity.com/](https://cloud.unity.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the config key for controlling the visibility of our holiday graphics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the **Remote Config** window open, click the **View in Dashboard** button
    to open the Unity Cloud dashboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, we can simply add a new key-value pair directly in the **Remote Config**
    window right within Unity Editor, and you can certainly do that now by clicking
    the **Add Setting** button. Still, we’re going to leverage the dashboard to cheat
    – ah, I mean, generate some starter code for this first setting.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the first screen you see does not say **Setup Guide**, you can find the link
    in the column to the left of the main window titled **GAMING SERVICES Remote Config**.
    There are a few options at the bottom, and one is **Setup guide** – click it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the options for checking your environments and installing the package
    by confirming or simply clicking the defaults for **Next** and **Finish** since
    we won’t need to change anything here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click `Theme_Holiday`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Type**: **Boolean**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Next**, set **Value** to **true**, and click **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we want to click the `RemoteConfigSettings` in a new `Assets/Scripts/Services`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the script in your IDE, delete all the existing template code, and paste
    the copied code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the public class declaration from `ExampleSample` to `RemoteConfigSettings`
    and save (*Ctrl*/*Cmd* + *S*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Okay; we have started the first phase of our integration, but we’ll want to
    make two minor additions to make it compatible with our other scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll go ahead and make it a singleton instance so that we can access
    it from our `PlayerController` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, we’ll add an event to listen for when the remote configuration has completed
    being fetched from the server so that we can update our graphics based on the
    current published value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating dynamic content | UGS use cases
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that for this example, we’ll manually toggle the value for displaying
    the holiday theme graphics at the time we decide to. Still, Unity provides another
    way to automate this on a calendar schedule, which is by using **Game Overrides**.
    This use case can be found in the Unity documentation here: [https://docs.unity.com/ugs/en-us/manual/game-overrides/manual/use-cases](https://docs.unity.com/ugs/en-us/manual/game-overrides/manual/use-cases).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many additional use cases for implementing UGS can be found here: [https://docs.unity.com/ugs/en-us/solutions/manual/Welcome](https://docs.unity.com/ugs/en-us/solutions/manual/Welcome).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `RemoteConfigSettings` script with the following singleton pattern
    and `OnSettingsChanged` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to be able to invoke the event when the server configuration values have
    been retrieved, add the following `OnSettingsChanged` invocation to the `ApplyRemoteSettings()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we’re passing in the `RemoteConfigService` class’s `appConfig`
    object so that the event listeners can get their required config settings. With
    that, we can now add the Remote Config service to our game. Create a new GameObject
    in the scene named `RemoteConfig` and add the `RemoteConfigSettings` script. With
    that, we’re done – easy-peasy.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture tip
  prefs: []
  type: TYPE_NORMAL
- en: For brevity and to keep things simple for this dynamic content example, I’ve
    decided to add the graphics changing directly to the **PlayerController** script.
    However, you may want to consider making it a separate component for a more robust
    and reusable *dynamic graphics swapping* *system* component.
  prefs: []
  type: TYPE_NORMAL
- en: Now, all that’s left to do is add to the capability of our `PlayerController`
    component so that we can get the configuration setting value to determine whether
    to show the holiday graphic.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the player controller script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open the `PlayerController` script for editing and add the following declarations
    for holding `GameObject` references for the graphics (both the default and holiday
    versions) and a constant for the Remote Config settings key we previously defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So that we can respond to the completion of the remote settings being fetched,
    let’s add a listener to the `OnSettingsChanged` event on the `RemoteConfigSettings`
    singleton instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We’ve also made sure we add a removal for the listener, like the good programmers
    we are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can handle the `OnSettingsChanged` event being triggered by adding
    the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, let’s do this one last time. A breakdown of the methods looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ConfigSettingsChanged()`: This method is the `OnSettingsChanged` event handler.
    Using the `RuntimeConfig` object passed in the event, we use its `GetBool()` method
    with the string constant for the key name, `THEME_HOLIDAY`, to retrieve the current
    value. `false` is used as the default value that’s returned should the key not
    be found:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`If (!isThemeEnabled)`: If the value that’s returned from `GetBool()` is `false`,
    we’ll short-circuit the method with `return`, leaving the default graphics as
    the currently visible graphics on the player character:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Otherwise, `ShowThemeGraphics(1)` is called and passed in an index value of
    `1`, meaning the second item that’s assigned in the `_graphics` array – where
    we assigned the Halloween graphics in the `0`, item #2 is index `1`, and so on.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ShowThemeGraphics()`: Here, we simply iterate through all the GameObjects
    in the `_graphics` array using a `foreach` statement, setting each object’s active
    state to `false`. We immediately follow up by setting the object with the passed-in
    index value active, ensuring the graphics that are assigned to that index will
    be the graphics displayed with `_graphics[value].SetActive(true)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save the script and try it out! After entering **Play Mode**, you should see
    the graphics on your ladybug player character change to the holiday graphics created
    for the theme. Nice!
  prefs: []
  type: TYPE_NORMAL
- en: Bonus activity
  prefs: []
  type: TYPE_NORMAL
- en: Update the **OnSettingsChanged** event architecture so that it uses an implementation
    of the global event system we created in [*Chapter 9*](B18347_09.xhtml#_idTextAnchor169).
  prefs: []
  type: TYPE_NORMAL
- en: After you build and publish your game, you can use the Unity Cloud dashboard
    to change the value of `Theme_Holiday` at any time to show/hide the holiday graphics
    without having to rebuild and redistribute a new game build.
  prefs: []
  type: TYPE_NORMAL
- en: Complete project code
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the completed 2D collection game project code for this chapter
    from this book’s GitHub repository: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch15/Unity-Project](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch15/Unity-Project).'
  prefs: []
  type: TYPE_NORMAL
- en: And speaking of building and distributing your game build, that’s something
    you’re going to have to do lots and lots of times throughout its life cycle. If
    only there were a way to simplify and automate that process… oh wait, there is!
  prefs: []
  type: TYPE_NORMAL
- en: Publishing with Unity Build Automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Moving the build process of our local system to dedicated build servers – cloud-based
    systems, in this case – in our game development workflow offers several benefits
    but primarily improved productivity because our machines won’t be locked up during
    the build time. Builds generated on dedicated servers can also help to ensure
    consistency and reliability across all our game versions – significantly reducing
    the “*but it works on my* *machine*” problem.
  prefs: []
  type: TYPE_NORMAL
- en: To help identify issues and catch bugs for our players early on, we can also
    integrate automated testing and **quality assurance** (**QA**) into our automated
    build process. Additionally, we can automate the distribution of completed builds
    to various teams for further testing and, if required, publishing.
  prefs: []
  type: TYPE_NORMAL
- en: It all starts with understanding the build process, so let’s have a look at
    building locally.
  prefs: []
  type: TYPE_NORMAL
- en: Building your game
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [*Chapter 14*](B18347_14.xhtml#_idTextAnchor272), we saw how we can use
    **Build Settings** to set the build target platform to **Android** and build to
    our head-mounted device for testing our MR game. Here, we can do the same thing
    but build our 2D collection game for standalone platforms, such as Windows and
    Mac PCs, by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Build Settings** from **File** | **Build Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that **Platform** is set to **Windows, Mac, Linux** (also known as *standalone*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the desired platform in the **Target** dropdown (for example, Windows).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Build**, or **Build And Run**, to automatically launch the game when
    the build finishes, and select a folder on your system to store the build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait until the build finishes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You don’t have any choice; you have to sit there and wait… staring at the progress
    indicator minute by minute until it finishes. Luckily, with our small 2D game,
    this doesn’t take long at all, but that won’t always be the case as our games
    grow in size and complexity. Prepare to get up from your desk, go make a cup of
    coffee, and come back only to see that the progress bar has barely moved!
  prefs: []
  type: TYPE_NORMAL
- en: When the build finishes, you’ll have the files necessary to run your game in
    the folder you selected for the build. Open the folder in your system’s file explorer
    and run the EXE file to play the game. To distribute your game – share it with
    your team, friends, and family – zip up the contents of the folder (minus any
    folders ending in `DoNotShip`) and share it via an online cloud storage service
    (such as Google Drive, Dropbox, OneDrive, or Box).
  prefs: []
  type: TYPE_NORMAL
- en: Still, we can do better. Let’s offload the build process to Unity Build Automation.
  prefs: []
  type: TYPE_NORMAL
- en: Automating the build pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve already seen how to add Unity Version Control to our projects’ DevOps
    strategy. Well, automating a build is the second half of this DevOps story – specifically
    **CI/CD** – since we’ll use our project’s cloud workspace as the source for the
    cloud build configuration. This is how the cloud service gains access to our project
    files to perform the build.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s add **Build Automation** to our project by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Window** | **Package Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Packages** dropdown, change the context to **Unity Registry**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `build`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Build Automation** and click the **Install** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once installed, click the **Configure** button (or, at any time, go to **Services**
    | **Build Automation** | **Configure**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the top-right corner of the **Project Settings** window, click the slider
    to enable Build Automation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Manage Build Targets** button to open the Unity Cloud dashboard
    (in your default web browser). This is where we’ll add our first build target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.10 – Unity Cloud Build Automation configurations](img/B18347_15_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.10 – Unity Cloud Build Automation configurations
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, click the **Get Started** button to connect the source control provider
    and repository (that is, the workspace):'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Unity Version Control** in the **Source control provider / SCM** **type**
    dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your Unity organization in the **UVCS organization Server** **URL** dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave **Authenticate with Unity** **ID** selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Save** (at the top).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the source control settings have been saved, proceed to **Build Automation**
    | **Configurations** and follow these steps to add our build target:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Quick target** **setup** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Windows desktop 64-bit** in the **Select a platform to build** **for:**
    dialogue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Confirm that the **Repo** field has been populated with your game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have more than one branch in your workspace, select the branch for building
    in the **Branch** dropdown.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Versioning**, select **Always Use Latest 2022.3** in the **Unity** **version**
    dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Windows 11** in the **Builder Operating System and** **Version** dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Builder configuration** screen, ensure **STANDARD** is selected and
    click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Scheduling** screen, for this example, we’re going to manually kick
    off the build process from within Unity Editor, so I prefer to enable **Auto-cancel**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important tip
  prefs: []
  type: TYPE_NORMAL
- en: You can change the scheduling of your builds at any time. The most popular strategy
    is to dedicate a branch in your workspace to automatically start a build when
    the branch has been updated.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Save** **configuration** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, return to Unity Editor and reopen the Build Automation settings. When
    it refreshes, you’ll see we now have a build target that’s been added: **Default
    Windows** **desktop 64-bit**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, ensure your Unity Version Control workspace is up to date by checking
    in any pending changes for your project, and then click the **Build** button.
    A console entry will be created with a status of **Build #1 Default Windows desktop
    64-bit added to queue** to notify you that the build has been queued.'
  prefs: []
  type: TYPE_NORMAL
- en: You can check the status of your cloud builds by clicking the **Build History**
    button or opening a web browser on any device in the Unity Cloud dashboard under
    **Build Automation** | **Build History**.
  prefs: []
  type: TYPE_NORMAL
- en: Build Automation pricing
  prefs: []
  type: TYPE_NORMAL
- en: 'You can build faster for multiple platforms, including Windows, Mac, Linux,
    Android, and WebGL, and on multiple machines simultaneously: [https://unity.com/products/unity-devops#pricing](https://unity.com/products/unity-devops#pricing).'
  prefs: []
  type: TYPE_NORMAL
- en: Windows build includes 200 minutes for free per month. You pay for additional
    build minutes, Mac build minutes, additional concurrent build machines, and storage
    above 5 GB (per GB per month).
  prefs: []
  type: TYPE_NORMAL
- en: 'When the build finishes, if you’re still within Unity Editor, you’ll see a
    console message appear: **Build #1 Default Windows desktop** **64-bit success**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll also receive an email with the subject **Built ‘2D Collection Game’
    for Windows x86_64**, and the message **‘2D Collection Game’ (Default Windows
    desktop 64-bit) #1 has been built for Windows x86_64!** The email will also list
    any warnings or errors encountered during the build process and links to the cloud
    dashboard configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, an **INSTALL** link will be provided to download the build
    artifact (that is, files your team uses to deploy or test your application). Clicking
    the link will bring you to the Unity Cloud dashboard’s **Build Details** page
    for this build. You can download the game build by clicking the **Download .ZIP
    file** button. You can also easily share this build with anyone by clicking the
    **Share** button – you’ll be provided a share link and QR code that will remain
    valid for 14 days.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic build sharing
  prefs: []
  type: TYPE_NORMAL
- en: You can enable automatically creating the build share link on the **Build Automation
    Settings** page. When enabled, the share link will be included in the email notification
    you receive when the build succeeds (preventing a trip to the Unity Cloud dashboard
    to grab it).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to enabling automatic build sharing, Unity allows integrations with
    popular developer tools such as Discord, Slack, Jira, and Trello to create automated
    notifications in these spaces for both Build Automation and Cloud Diagnostics.
    You can configure your integrations in the Unity Cloud dashboard under **Administration**
    | **Project** **integrations** ([https://docs.unity3d.com/Manual/UnityIntegrations.xhtml](https://docs.unity3d.com/Manual/UnityIntegrations.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have built our first standalone PC game, let’s publish it on **Itch.io**
    and share it with the world!
  prefs: []
  type: TYPE_NORMAL
- en: Publishing your game
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this publishing example, we’ll publish our game to **Itch.io**. It’s the
    perfect platform for our little 2D collection game to start getting our indie
    title into players’ hands for some valuable playtesting, feedback, and bug squashing
    (Ack! But not our ladybug!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Itch.io and register on the site; ensure you check off **I’m interested
    in distributing content on** **itch.io**: [https://itch.io/register](https://itch.io/register).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once registered, go to the **Creator Dashboard** area (that is, **Dashboard**)
    and click the **Create new project** button. This will bring you to the following
    screen, where you can start filling out all the required details and upload a
    screenshot for a cover image to display your game listing on the storefront:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11 – Creating a new project on Itch.io](img/B18347_15_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.11 – Creating a new project on Itch.io
  prefs: []
  type: TYPE_NORMAL
- en: The field we need to pay attention to when uploading our game build to the site
    is **Kind of project**. Ensure it’s set to **Downloadable**. Then, in the **Uploads**
    section below, click the **Upload files** button and select the ZIP file we created
    to distribute our game build in the *Building your game* section or from the build
    automation process.
  prefs: []
  type: TYPE_NORMAL
- en: Building for WebGL | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: Note that for Itch.io, you have the option of publishing a WebGL build of the
    game that will run directly within the player’s web browser instead of having
    to be downloaded. Before committing to a WebGL version of your game, you must
    ensure your game is playable and performant in a web browser to provide a good
    player experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build your WebGL application: [https://docs.unity3d.com/2022.3/Documentation/Manual/webgl-building.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/webgl-building.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Fill out the remainder of the fields, including all the fields under the **Details**
    section, which includes **Description**, **Genre**, **Community interaction**,
    and **Visibility & access**. Also, don’t forget to add **Screenshots** and a **Gameplay
    video or trailer** to excite and encourage visitors to your page to download and
    play your game.
  prefs: []
  type: TYPE_NORMAL
- en: Itch.io Devlogs
  prefs: []
  type: TYPE_NORMAL
- en: Have you heard of a Devlog? It’s a forum post where game developers share updates
    on their ongoing projects. Anyone can leave comments and thoughts, which is an
    excellent way for players to stay informed about the latest developments in games
    they are interested in. Additionally, developers can use the forum to generate
    excitement and increase project engagement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Itch.io Community Devlogs: [https://itch.io/devlogs](https://itch.io/devlogs).'
  prefs: []
  type: TYPE_NORMAL
- en: When you’re happy with what you’ve entered, click **Save & view page** to finish
    publishing your game on Itch.io. Yay!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to add Unity LiveOps services to our 2D collection
    game, including core services such as Analytics and Cloud Diagnostics, and updating
    in-game content dynamically without requiring distributing a new game build with
    Remote Config. We also learned how to set up Unity DevOps to automate our game
    build process while offloading it from our local machine. We finished with a quick
    game publishing example.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced and explored the concepts and strategies for
    operating and publishing GaaS to help achieve our commercial viability goals and,
    ultimately, success. By adopting GaaS and implementing the tools and technologies
    of both DevOps and LiveOps, we can build a solid foundation to support the ongoing
    release of games and content updates. This helps keep our players engaged and
    can provide longer lifetime value for our game releases.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we learned how to safeguard all the hard work we put into our
    game projects by introducing source code management with Unity Version Control.
    We also learned how to set up and use version control within Unity Editor for
    a cloud-based DVCS solution and better structure our projects to minimize conflicts
    for team collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: We gained a fundamental understanding of game economies and distribution channels
    while discussing how to better leverage player engagement to convert mobile free-to-play
    games into revenue through in-game purchases, ads, subscriptions, and premium
    purchases for PC games. Then, we provided a technical and financial feature breakdown
    of the top game distribution platforms for both free and premium games.
  prefs: []
  type: TYPE_NORMAL
- en: We concluded this chapter with examples of implementations of Unity LiveOps
    and DevOps. We achieved this by adding core cloud services, dynamically updating
    in-game content, building and automating the build process, and finally publishing
    our game.
  prefs: []
  type: TYPE_NORMAL
- en: Final words!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout these chapters, from the creative processes of designing games and
    working with art assets to the detailed implementations of programming mechanics
    and systems, we explored fundamental principles, solved problems, and celebrated
    overcoming challenges together. Whether you’re a seasoned professional, an indie
    dev, a student, or an aspiring hobbyist, I hope you’ve been provided with inspiration,
    insights, moments of revelation, and the occasional laugh.
  prefs: []
  type: TYPE_NORMAL
- en: As this chapter comes to a close, I want to express my heartfelt appreciation
    to each of you who has embarked on this adventure with me. Thank you. I am honored
    to have the opportunity to share my knowledge and experiences with such an incredible
    developer community.
  prefs: []
  type: TYPE_NORMAL
- en: All stories have an ending, and as such, this one has come to an end now, too.
    Still, it’s just one of many phases in our journey as game developers as we continue
    to work toward finishing and releasing our remarkable games.
  prefs: []
  type: TYPE_NORMAL
- en: Until next time… I have a game to finish now (and you do, too). Have fun!
  prefs: []
  type: TYPE_NORMAL
