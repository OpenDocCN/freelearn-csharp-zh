- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MVVM and Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B19723_03.xhtml#_idTextAnchor036), we examined the fundamentals
    of .NET MAUI, but our code was in the code-behind files associated with XAML files.
    It is time, though, to turn our attention to the consensus architecture for .NET
    MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: '**Model-View-ViewModel** (**MVVM**) is not a tool or a platform but an architecture.
    Simply put, it is a way of organizing your code and thinking to optimize the creation
    of .NET MAUI applications and to facilitate unit testing (see [*Chapter 9*](B19723_09.xhtml#_idTextAnchor160)).'
  prefs: []
  type: TYPE_NORMAL
- en: At its simplest, MVVM consists of three sets of files, that is three namespaces,
    which essentially means three folders (with subfolders as needed). Taken in turn,
    `Model` is the set of classes that define the *shape* of your data. This just
    means that the classes that represent data are held in the model.
  prefs: []
  type: TYPE_NORMAL
- en: '`View` is, in simple words, the page that the user sees.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewModel` is where all the action happens. It is the set of classes that
    manage the logic of your program and that contain the *properties* that are presented
    in `View`. We’ll get into **ViewModel** (**VM**) properties as we go.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up MVMM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XAML versus C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Popups and dialogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brushes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need the latest version of Visual Studio (any edition).
  prefs: []
  type: TYPE_NORMAL
- en: Each chapter in this book is saved as a branch. The code shown in this chapter
    and the next is in the branch at [https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/MVVMAndControls](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/MVVMAndControls).
    If you check out the branch you’ll see where we ended up, but if you want some
    of the intermediate steps, just examine the commits that contributed to the branch.
    To follow along, however, check out the branch at [https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/Navigation/tree/XAMLAndCSharp](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/Navigation/tree/XAMLAndCSharp)
    as the starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up for MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MVVM is as much a way to organize your files and folders as it is an architectural
    approach. To get started using MVVM we’ll do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the folders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the associated Community Toolkits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating folders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be creating three folders. Before I tell you the names of these folders,
    I should say there is some disagreement about what exactly to name them. *Table
    4.1* shows the folder names and their alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** **we’ll use** | **Alternative 1** | **Alternative 2** |'
  prefs: []
  type: TYPE_TB
- en: '| `Model` | `Models` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `View` | `Views` | `Pages` |'
  prefs: []
  type: TYPE_TB
- en: '| `ViewModel` | `ViewModels` |  |'
  prefs: []
  type: TYPE_TB
- en: Table 4.1 – Naming the folders
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the key difference is whether or not the name of the folder
    should use the plural, reflecting the fact that there will be more than one file
    in each folder, or the singular (as we will do), reflecting the name Model-View-ViewModel.
    I can’t think of a less important controversy, and it clearly doesn’t matter what
    you choose as long as you are consistent. Arbitrarily, we’ll use the first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, create three folders in your project: `Model`, `View`, and `ViewModel`,
    as shown in *Figure 4**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – MVVM Folders'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.1_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – MVVM Folders
  prefs: []
  type: TYPE_NORMAL
- en: '`MainPage` is now in the wrong place. Drag `MainPage.xaml` to the `View` folder
    (it will bring its code-behind with it). You need to fix the namespace in the
    XAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the code behind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Microsoft provides libraries that are not part of .NET MAUI as they were created
    by the .NET community, but which, nonetheless, Microsoft endorses and supports.
    Much of the functionality of these community toolkits will probably migrate into
    .NET MAUI itself.
  prefs: []
  type: TYPE_NORMAL
- en: The MVVM Community Toolkit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open `CommunityToolkit-MVVM` and click on **CommunityToolkit.MVVM**. This wonderful
    toolkit will make programming with MVVM infinitely easier than it otherwise would
    be. See *Figure 4**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Getting the NuGet package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.2_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Getting the NuGet package
  prefs: []
  type: TYPE_NORMAL
- en: We’ll come back to how to use this toolkit when we talk about *source code generators*.
    Next, let’s take a look at some of the views.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET MAUI Controls is a generic term for pages, layouts, and views. In this
    chapter, we will look at views, while pages and layouts will be reviewed in the
    next chapter. In [*Chapter 7*](B19723_07.xhtml#_idTextAnchor129), we’ll look at
    navigating between pages.
  prefs: []
  type: TYPE_NORMAL
- en: Views versus pages
  prefs: []
  type: TYPE_NORMAL
- en: From the perspective of MVVM, a view is a page. From the perspective of .NET
    MAUI, `View` is a control. So, just to keep you totally confused, a View consists
    of Views and layouts. To avoid this absurdity, we’ll refer to the latter as controls.
    Some frameworks call these widgets. From time to time I’ll forget and refer to
    these controls as Views, but the context will make clear what I mean.
  prefs: []
  type: TYPE_NORMAL
- en: A .NET MAUI Control is an object that maps to native controls on each target
    platform. Thus, a .NET MAUI Button maps to an iOS, Android, Macintosh, and Windows
    native Button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The principal way to display text is with `Label`. The inheritance tree for
    `Label` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object` > `BindableObject` > `Element` > `NavigableElement` >'
  prefs: []
  type: TYPE_NORMAL
- en: '`VisualElement` > `View` > `Label`'
  prefs: []
  type: TYPE_NORMAL
- en: An object is, of course, the base for every class in C#. We’ll skip over `BindableObject`
    for now, and we’ll group `Element`, `NavigableElement`, and `VisualElement` together
    as things you can see on your page. This brings us to `View` as described previously,
    and then `Label` itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common property to use on `Label` is `Text`. `Text` is what `Label`
    displays, thus you can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This creates a Label that displays the iconic greeting. But there is more you
    can do with `Label`, as we saw in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Forget Me Not labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at Labels in the context of Forget Me Not. We already have the application,
    but it is just what we get out of the box. Let’s revise this first page to create
    the initial page for Forget Me Not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please click on the `VerticalStackLayout` on `MainPage.xaml` That will collapse
    `VerticalStackLayout` and allow you to delete it all at once, as shown in *Figure
    4**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Collapsed VerticalStackLayout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.3_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Collapsed VerticalStackLayout
  prefs: []
  type: TYPE_NORMAL
- en: Next, go to the code-behind file (`MainPage.xaml.cs`) and remove the counter
    and the `OnCounterClicked` event handler.
  prefs: []
  type: TYPE_NORMAL
- en: Having cleaned all that out, we are ready to put in new code. We need a layout
    we can put labels into, so let’s create an empty `VerticalStackLayout`, and add
    a Label Control to it that says `Welcome to Forget` `Me Not`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re ready to build on that. Let’s add some of the more common properties
    for making `Label` look good:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll examine each of these properties in turn, but first, *Figure 4**.4* shows
    what the page looks like right now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Label'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.4_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Label
  prefs: []
  type: TYPE_NORMAL
- en: Note that the title (**Home**) is an artifact of the page. What we care about
    is the Label shown below it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see if we can’t make that look a bit nicer before we examine the properties
    of `Label` by adding just a bit of padding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That gives us the page, as shown in *Figure 4**.5*.
  prefs: []
  type: TYPE_NORMAL
- en: XAML Styler
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the properties are laid out nicely and in alphabetical order. This
    is due to a (free) tool named XAML Styler which you can get from the Visual Studio
    Marketplace ([https://bit.ly/XAMLstyler](https://bit.ly/XAMLstyler)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure  4.5 – Label with Padding'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.5_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Label with Padding
  prefs: []
  type: TYPE_NORMAL
- en: Much better. Let’s examine the preceding code with the padding line by line.
  prefs: []
  type: TYPE_NORMAL
- en: Most of these properties are self-explanatory. The `BackgroundColor` property
    controls the entire label. In our case, we’ve set the `Padding` property (as described
    in [*Chapter 3*](B19723_03.xhtml#_idTextAnchor036)) to `10`; thus, the red shows
    with a padding of `10` all around the text.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we set the text to `Bold` using the `FontAttributes` property.
    The possible attributes are `Bold`, `Italic`, and `None`, with `None` being the
    default.
  prefs: []
  type: TYPE_NORMAL
- en: '`FontSize` can be entered in device-independent units (for example, `FontSize
    = "20")` or in one of the enumerated constants such as `Micro`, `Small`, `Large`,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '`HorizontalOptions` and `VerticalOptions` place the label on the page relative
    to the edges of the page. We touched on this in the previous chapter. In the case
    of `HorizontalOptions`, the choices are `Start` (far left), `Center` (middle),
    or `End` (far right).'
  prefs: []
  type: TYPE_NORMAL
- en: The next property is `LineBreakMode`, which goes with the `MaxLines` property.
    Together they determine how many lines of text the label can support and where
    the lines will be wrapped. To see this, modify the text to say “*Welcome to Forget
    Me Not, so glad you are here, we couldn’t do this without you and we appreciate
    your patience.*” As you can see in *Figure 4**.6*, the text is now centered on
    multiple lines, and each line breaks at a word boundary.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Multi-line Label'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.6_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – Multi-line Label
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, `Label` has dozens of properties, and while we’ve covered
    the most important ones, you can always look up the others on Microsoft Learn.
    In this case, the page you’ll need is [https://bit.ly/MicrosoftLabel](https://bit.ly/MicrosoftLabel).
  prefs: []
  type: TYPE_NORMAL
- en: The key to displaying data in the MVVM model is data binding, which allows us
    to associate a view and a property and then allows .NET MAUI to keep the view
    up to date as the value of the property changes. Let’s explore this next.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most powerful aspects of .NET MAUI is **data binding** and data binding
    works extremely well with MVVM. The idea is to *bind* data (values) to controls.
    For example, we might have a class with the text we want to display on this label
    held on a public property (you can only bind to public properties). Rather than
    having to copy that text from the class to the label, we just tell the label the
    name of the property.
  prefs: []
  type: TYPE_NORMAL
- en: The public property will be kept in a class in `ViewModel`. But we have to answer
    the question how does `View` know where to look for the property? That is handled
    by setting `BindingContext`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a simple example. In `ViewModel`, create a new file named `MainViewModel.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: Naming ViewModel
  prefs: []
  type: TYPE_NORMAL
- en: The most common naming convention is to name the page with the word page, such
    as `MainPage` or `LoginPage` but to drop the word page in the `ViewModel` name,
    such as `MainViewModel` and `LoginViewModel`. So, that is what we’ll do in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Note that other programmers will use the `MainPageViewModel` name. On the other
    hand, some do not use the word *page* but rather *view*, as in `MainView` and
    `LoginView`. What is most important is for you (and your team) to be consistent
    so that it is easy to guess and find the associated pages and view models.
  prefs: []
  type: TYPE_NORMAL
- en: Before going ahead, notice that Visual Studio has put your class into the `ForgetMeNotDemo.ViewModel`
    namespace (if you named your project `ForgetMeNot`, the namespace will be `ForgetMeNot.ViewModel`).
    This is based on the folder the `.cs` file is in.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the class is public and that it is marked `partial`. All binding in
    .NET MAUI is done with partial classes, allowing the rest of the class to be handled
    internally and by generated partial classes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a public property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now want to create a property named `FullName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original way to do this looked something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the absolute best approach is to take advantage of the code generators
    in the `NuGet` package we just added. These work by using attributes. Add an attribute
    above the `[ObservableObject]` class declaration like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'That attribute will allow you to generate properties. Above each property,
    use the `ObservableProperty` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will cause the `NuGet` package to (invisibly) generate the uppercase public
    property and its `OnPropertyChanged()` method call as if you had entered them
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at how to set the `FullName` value, we need to set up `BindingContext`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up BindingContext
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`BindingContext` tells your `View` where to get its bound data. You can set
    this in a number of ways; the most common is to set it in the code-behind file
    for the `View` class (in this case, `MainPage.xaml.cs`). First, we declare an
    instance of `ViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code behind the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll see how to assign values to the `ViewModel` class properties.
  prefs: []
  type: TYPE_NORMAL
- en: Names
  prefs: []
  type: TYPE_NORMAL
- en: I don’t usually like abbreviations for names. There are rare exceptions, and
    using `vm` for `ViewModel` is such a strong convention that I yield to peer-group
    pressure.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning values to the View Model class properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can assign your string in `ViewModel`, in the `ViewModel` constructor,
    or in the override for the `OnAppearing` method. `OnAppearing` is called before
    `View` is displayed and looks like this (you put this in the code-behind file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We will return to `OnAppearing` and its sibling `OnDisappearing` method, in
    [*Chapter 7*](B19723_07.xhtml#_idTextAnchor129).
  prefs: []
  type: TYPE_NORMAL
- en: InitializeComponent
  prefs: []
  type: TYPE_NORMAL
- en: '`InitializeComponent` must be in the constructor of every code-behind file.
    It is the responsibility of `InitializeComponent` to initialize all the controls
    on the page.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You are now ready to bind the `FullName` property to `Label`. In the XAML,
    change the `Label` text property to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Naming properties and fields
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using the binding keyword tells `Label` to get its value from the `FullName`
    property found in the `ViewModel` set by `BindingContext`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will want to pay attention to the syntax. It is always as shown here: open
    quotes, open braces, the `Binding` keyword, property name, closing brace, and
    closing quotes. Okay, I lied. It is sometimes more complex, but these elements
    are always there.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this construct is that the value of `FullName` is placed inside
    the `Text` property of the label, as shown in *Figure 4**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – A label with data-bound text'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.7_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – A label with data-bound text
  prefs: []
  type: TYPE_NORMAL
- en: One of the distinguishing characteristics of an MVVM program is that the logic
    is in `ViewModel` rather than in the code-behind file, which we will explore next.
  prefs: []
  type: TYPE_NORMAL
- en: ViewModel versus code-behind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The more you can put into `ViewModel` (rather than the code-behind file) the
    easier it will be to test your program (see [*Chapter 9*](B19723_09.xhtml#_idTextAnchor160)
    on unit testing). Some MVVM fans think *nothing* should be in the code-behind
    file besides the required call to `InitializeComponent`. They argue that even
    setting `ViewModel` should be done in the XAML to keep the code-behind file as
    empty as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'I take a more moderate view of this. I often set `BindingContext` in the code-behind
    file. I do move all my *event handling* out of the code-behind file as you’ll
    see when we talk about commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `BindingContext` here is set before calling `InitializeComponent`.
    While either can come first in most cases, setting up all your bindings before
    initializing the page is generally good practice. Thus, we’ll stick with the approach
    shown here.
  prefs: []
  type: TYPE_NORMAL
- en: Renegade code-behind
  prefs: []
  type: TYPE_NORMAL
- en: There are times when it is just much easier to put a method in the code-behind
    file. Be careful with this, however. 99% of the time, when it seems really important
    to put something in the code-behind file, you actually can make it work in `ViewModel`,
    and that is much better (again, for testing). But if you do have to put something
    in the code-behind file, do not feel bad, and do not let other .NET MAUI programmers
    push you around.
  prefs: []
  type: TYPE_NORMAL
- en: The center of developing most apps, the part that people respond to, is the
    **user interface** (**UI**). In .NET MAUI, the UI consists of views in layouts.
    Let’s turn our attention to the most important views.
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many controls for displaying and obtaining data from the user. The
    following sections will cover the most common and useful ones, including those
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ImageButtons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entering text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You *can* write a .NET MAUI program without images, but it is likely to look
    pretty boring. Managing images is much easier in .NET MAUI than it was in `Xamarin.Forms`.
    Now, instead of having to have one image for each resolution in iOS and Android,
    you place one image in the resources folder, and .NET MAUI takes care of the rest
    for all the platforms!
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we’ll use an image named `flower.png`, which you can download
    from our GitHub repository. If you prefer, though, you can use any image you like.
    We’ll place the image in the `Resources` > `Images` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are ready to display it, we’ll use an **Image View**. Here is a simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: I’ve only set three properties, but they accomplish quite a bit. `HeightRequest`
    sets, as you might guess, the height of the image on the page in device-independent
    units (in this case, `200`). I’ve set it to be centered. Most importantly, I’ve
    identified the source—that is the name of the image. But rather than lock in the
    name of the image in `View`, I’ve bound it to a property in `MainPageViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is that `MainPage` now looks like *Figure 4**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Binding the source to a property in ViewModel'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.8_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – Binding the source to a property in ViewModel
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there are a number of additional properties you can set. A set of
    favorites for me are the `Rotation` properties, which can rotate on the *x*, *y*,
    and *z* axes. If I add the `RotationX` property like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The image rotates, as shown in *Figure 4**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – RotationX=”45”'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.9_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – RotationX=”45”
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful trick is to make the image semi-transparent by setting `Opacity`
    to a value between `0` and `1`. *Figure 4**.10* shows the same image with an opacity
    of `.25`. I removed `StackLayout` and substituted a `Grid`. More about grids in
    the next chapter, but if you just declare one and put `Label` and `Image` into
    it with no other `Grid` properties, they lay one on top of the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 4**.10* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Overlay and semi-transparent effect'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.10_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10 – Overlay and semi-transparent effect
  prefs: []
  type: TYPE_NORMAL
- en: There is endless room for creativity.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on an image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the key things that many people want to do with an image is click on
    it. There are two solutions to this problem. The easiest is to use a button.
  prefs: []
  type: TYPE_NORMAL
- en: Buttons can have text and a number of other properties, but the most important
    is the command. The command tells `ViewModel` what to do when the button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: To show how this works, I’m going to put a new property on our image, `IsVisible`,
    and set it to `true`. As long as that is `true`, the image is visible. But, as
    you can imagine, setting it false makes the big flower invisible. Not only is
    it invisible, but it also takes up no space on the page, so the button will be
    directly under the label.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for `Button`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is the simplest button I can make (we’ll look at making it nicer in just
    a bit). The key here is the `Command` parameter. You can tell by the `Binding`
    keyword that `ToggleFlowerVisibility` will be in `ViewModel`. Sure enough, it
    is, but rather than declaring a command and pointing it at a method, we can use
    the code generator to do the heavy lifting for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the modified `MainViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is an example of *convention over configuration* – the `Command` property
    in `Button` is `ToggleFlowerVisibilityCommand`, but when you implement it in `RelayCommand`
    [2], you name it `ToggleFlowerVisibility` [3] leaving off `Command`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we created `FlowerIsVisible` [1] as an `ObservableProperty`, we simply
    toggle it from `true` to `false` and back on each click.
  prefs: []
  type: TYPE_NORMAL
- en: Button properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As it is now, the button will be displayed as it would appear natively on each
    platform. But these buttons can be pretty ugly. We can make them much nicer by
    taking over more of their appearance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is my XAML for `Button`, which while not beautiful, will illustrate some
    of the properties you can use to take control of the button’s appearance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three new properties that we’ve not seen before. The first is `BorderColor`,
    which goes along with `BorderWidth`. This provides a border around the button.
    Since we’ve set `BackgroundColor` to `Red`, the border will stand out. The final
    new property is `CornerRadius`, which gives us a nice rounding of the corners
    of the otherwise square button. Put that all together, and you get a button that
    looks like *Figure 4**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – A nicer-looking button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.11_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – A nicer-looking button
  prefs: []
  type: TYPE_NORMAL
- en: Why is this button still ugly?
  prefs: []
  type: TYPE_NORMAL
- en: I am certainly not a UI person, and so my pages tend to be fairly ugly until
    fixed by someone who knows what they are doing. The screen images in this book
    will reflect that inability.
  prefs: []
  type: TYPE_NORMAL
- en: ImageButton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At times, rather than having text, we’d rather have an image on the button.
    There is an `ImageButton` control that combines many of the properties of the
    `Image` control and the `Button` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see how similar it is to the `Button` control. In fact, I’ve preserved
    the command binding and the source binding, so we end up with a small image of
    the flower under the big image, but clicking on the small one (`ImageButton`)
    causes the big one (`Image`) to become invisible and then visible, and so on.
    I’ll show both visible in *Figure 4**.12* because it is hard to toggle an image
    on paper:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – ImageButton'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.12_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.12 – ImageButton
  prefs: []
  type: TYPE_NORMAL
- en: TapGestureRecognizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second way to handle tapping on an image is to assign a gesture recognizer.
    The type of `GestureRecognizer` we’re going to assign is `TapGestureRecognizer`,
    which will recognize when the image itself has been tapped. To be safe, we’ll
    set it so that the image has to be double-tapped. When that happens, the image
    will “poof!” disappear.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll remove `ImageButton`, and just have `Image` (and `Label`). Here is our
    new XAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We see at [1] that the image starts as visible. Between the opening and closing
    brackets for `Image` we add `GestureRecognizer` [2]. Within `GestureRecognizer`
    we add `TapGestureRecognizer` [3], and we define `ImageTappedCommand` [4] just
    as we did with other commands. Finally, we declare that for the command to fire,
    the user must tap twice [5].
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of `RelayCommand` from `ViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this handler is nearly identical to the previous one. However,
    this one won’t work as intended. Before reading further, try to figure out what
    will happen when we double-click on the image (to make it invisible) and then
    try to do so again (to make it visible). Take your time. I’ll wait here.
  prefs: []
  type: TYPE_NORMAL
- en: You can solve this by going back to `Button`, or perhaps putting a `GestureRcognizer`
    on the Label.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you double-tap on the image, it does, in fact, disappear because `IsVisible`
    is set to false. However, once it disappears, it is gone, and there is nothing
    there to tap on to bring it back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: What’s interesting here is that the `TapGestureRecognizer` command points to
    the same `RelayCommand`; it will be invoked either by double-tapping on the image
    or single-tapping on the label.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are two takeaway points from this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TapGestureRecognizer` allows you to make any control tappable, which can be
    pretty powerful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once `View` is invisible, it is no longer on the page. You can make it visible
    again from the code behind, but only if you do so by way of a different control
    (as we did with `ButtonImage`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After displaying text, the most important aspect of an app is the ability to
    obtain text from the user. For that, the principal views are `Entry` and `Editor`.
    Let’s have a look at them next.
  prefs: []
  type: TYPE_NORMAL
- en: Entering text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve looked at displaying text, let’s turn our attention to entering text.
    There are two controls that are principally responsible for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Entry`: Used for entering a line of text'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Editor`: Used for entering multiple lines of text'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These two controls are obviously related, but they have different properties.
    `Entry` is designed to take a single line of text and `Editor` handles multi-line
    entry.
  prefs: []
  type: TYPE_NORMAL
- en: To see these views at work, let’s create a login page for Forget Me Not.
  prefs: []
  type: TYPE_NORMAL
- en: Forget Me Not login page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ve been playing with the `MainPage`, but in truth, the actual application
    has a very simple `MainPage`: just the image. Things get more interesting with
    the login page. We will make a first approximation of the login page as it will
    allow us to use the `Entry` and `Editor` controls, though we will evolve this
    page as we go.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the login page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first task is to create the login page. To do so, right-click on the `LoginPage.xaml`,
    as shown in *Figure 4**.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Add Item dialog box'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.13_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13 – Add Item dialog box
  prefs: []
  type: TYPE_NORMAL
- en: XAML versus C#
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you wish to create the UI for the login page using C# rather than XAML, choose
    **ContentPage (C#)** instead. We’ll look at both in this section, but let’s start
    with the XAML version.
  prefs: []
  type: TYPE_NORMAL
- en: Examine the XAML page out of the box. The class is set to `ForgetMeNotDemo.View.LoginPage`,
    reflecting the namespace (when we created the file under `View` that became the
    namespace automatically). The XAML also has `VerticalStackLayout` and inside that,
    `Label`.
  prefs: []
  type: TYPE_NORMAL
- en: Take a very quick look at the code-behind file. Note that `namespace` has been
    created for you and that the page derives from `ContentPage` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the XAML page and delete `Label` in `VerticalScrollView`. When the
    application is complete, it should look like *Figure 4**.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Login.XAML (top portion)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.14_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.14 – Login.XAML (top portion)
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have two labels. To the right of each label is an entry,
    and the entry has placeholder text. As soon as you start typing in the entry,
    the placeholder text will disappear.
  prefs: []
  type: TYPE_NORMAL
- en: There are also three buttons. To lay this out properly, we’d like to use `Grid`,
    but we’re not covering grids until [*Chapter 6*](B19723_06.xhtml#_idTextAnchor115),
    *Layouts*. That’s not a problem, though, because it gives us the opportunity to
    look at nesting `StackLayouts` and using `HorizontalStackLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, we’ll just create the top line. We’d like flexibility for the
    text in the label, and we’d like to capture the *User name* entry in a property
    of `ViewModel` that we haven’t created yet. Let’s do that now. Right-click on
    the `LoginViewModel` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `LoginViewModel` add `ObservableProperty` for the user name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When the user types a name into the Entry control it will be saved in this property.
  prefs: []
  type: TYPE_NORMAL
- en: OneWay and TwoWay binding
  prefs: []
  type: TYPE_NORMAL
- en: Controls can be `OneWay`, in which case the control gets its value from the
    data source (in this case, the property) but can’t send it back, or `TwoWay`,
    in which case the control gets its data from the data source but can also write
    a value back. `Entry` defaults to `TwoWay`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re ready to create the top line in `LoginPage` in XAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re using three properties on `Entry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HorizontalOptions`: Here we are setting it to `End` so that `Entry` will be
    to the far right of the line'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PlaceHolder`: This is the text that will be displayed until the user starts
    to enter text'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Text`: We have bound this to the `Name` property in `ViewModel`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is one problem looking at this page: there is no way to get there (yet).
    For now, rather than having the program open at `MainPage`, we’ll have it open
    to our new `LoginPage`. To do so, go to `AppShell.xaml` and change `ShellContent`
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We’ll be discussing the Shell and routing in [*Chapter 7*](B19723_07.xhtml#_idTextAnchor129),
    but this will work for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the program. If you run it on an Android device or emulator, it should
    look more or less like *Figure 4**.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – LoginPage, the first iteration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.15_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.15 – LoginPage, the first iteration
  prefs: []
  type: TYPE_NORMAL
- en: Even for me, it’s not very attractive, but it does demonstrate the controls
    and the layout. Try typing in the **User Name** entry. Notice that the placeholder
    text disappears instantly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a way to tell whether the value you entered is really binding to the
    `Name` property. To do this, let’s add a label and bind it to the `Name` property.
    That way, when we enter text into the entry it will be reflected in `Label`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'However, before we can make that work, we have to set up `BindingContext`,
    as we did on `MainPage`. Open the code-behind file for the XAML page and set up
    `LoginViewModel` as the binding context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this and type into the entry the text is saved in the `Name` property
    in `ViewModel`. Since the label is bound to the same property, the text is immediately
    shown there as well, as seen in *Figure 4**.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Proving that the entry is binding to the Name property'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.16_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.16 – Proving that the entry is binding to the Name property
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know it is working, delete the label. Let’s do the same thing for
    the password that we did for the name, except that we don’t want anyone to see
    the password we’re entering. No problem, `Entry` has a `boolean` property, `IsPassword`,
    which we’ll set to `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Before continuing, notice that we have `VerticalStackLayout` that contains two
    `HorizontalStackLayouts`. This is a not uncommon layout, but again we’ll get more
    control over the appearance when we move on to `Grid`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this XAML is shown in *Figure 4**.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Using the password Boolean on Entry'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.17_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.17 – Using the password Boolean on Entry
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s complete this first iteration of the page by adding the three buttons.
    We’ll only give one (**Submit**) a command for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in *Figure 4**.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18 – Adding the buttons'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.18_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.18 – Adding the buttons
  prefs: []
  type: TYPE_NORMAL
- en: When you run this, you may notice that it works fine, except that clicking on
    **Submit** doesn’t do anything. That is because we named the command but never
    implemented it. We’re going to save doing so for a while. Actually, for a long
    while. We’ll tackle the real implementation when we get to [*Chapter 11*](B19723_11.xhtml#_idTextAnchor216),
    *Working with* *the API*.
  prefs: []
  type: TYPE_NORMAL
- en: The Title
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that the page has a **LoginPage** title. The good news
    is that we got that for free (.NET MAUI created it when we created the page).
    However, it would be nice to have a space between **Login** and **Page**.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the XAML page is the declaration of `ContentPage`, and the first
    property set there is `Title`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Just insert the missing space, and all will be right with the world.
  prefs: []
  type: TYPE_NORMAL
- en: Editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second primary way of entering text into your application is with the `Editor`
    control. The principal difference from the `Entry` class is that `Editor` is designed
    for multi-line data entry. You have a lot of control over the text, as you’ll
    see in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add an editor to the login page. We’ll set it so that it is only visible
    if the user clicks on **Forgot Password**. The user will be encouraged to explain
    exactly where the password was the last time they saw it and why they were so
    careless when we told them to keep the password secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reopen `LoginPage.xaml` and add an `Editor` inside `VerticalStackLayout`, at
    the very bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: I’ve used a number of properties on the editor, and a few of them are new.
  prefs: []
  type: TYPE_NORMAL
- en: '[1] `IsTextPredictionEnabled` allows your editor to offer the user text to
    complete their sentence. You’ve seen this, no doubt, when working with Gmail and
    other applications. This is actually `True` by default; you might want to set
    it to `False` when asking for a user’s name or other conditions in which the prediction
    might be annoying.'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] `MaxLength` manages how many characters the user may enter into the editor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] `PlaceHolderColor` allows you to set the color of the placeholder text.'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] Similarly, `TextColor` sets the color of the text the user enters.'
  prefs: []
  type: TYPE_NORMAL
- en: '[5] `VerticalTextAlignment` sets where, within the editor, the text will lie.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.19* shows what **Login Page** looks like before the user enters
    anything into the editor, and *Figure 4**.20* shows what it looks like after the
    user has entered a few lines of text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Before the user enters text into the editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.19_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.19 – Before the user enters text into the editor
  prefs: []
  type: TYPE_NORMAL
- en: You can enter as much text as you want into the editor, up to whatever maximum
    you’ve set in the declaration of the control.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20 – After the user enters text into the editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.20_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.20 – After the user enters text into the editor
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the margin is only set to `10`, there is a huge space between the
    buttons and the text. That is because we set `VerticalTextAlignment` to `Center`.
    If we change it to `Start`, the text will move to the top of the editor, as shown
    in *Figure 4**.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21 – Moving the text in the editor to the top (start) position'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.21_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.21 – Moving the text in the editor to the top (start) position
  prefs: []
  type: TYPE_NORMAL
- en: Buttons inherently rely on events, but events are handled in the code-behind
    file, and we’d like to keep all our logic in `ViewModel`. The answer to that is
    the `EventToCommand` behavior, which we will consider next.
  prefs: []
  type: TYPE_NORMAL
- en: Behaviors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Editor` control has a number of events. These can be handled by event handlers
    in the code-behind file, but for the reasons already explained (and explained)
    we’d rather not do that. So, here enters behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Behaviors let you add functionality to your controls without having to create
    subclasses. They *tack on* the behavior. What we want to do now is tack on the
    ability to manage commands in a control (`Editor`) that doesn’t have commands.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET MAUI Community Toolkit comes with a plethora of behaviors, including
    `EventToCommandBehavior`. This wonderful behavior allows you to transform an event
    (which would be handled in the code-behind file) into a command, which can be
    handled in `ViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The event we want to change in `Editor` is `OnEditorCompleted`, which is raised
    when the user hits the *Enter* key (or, on Windows, the *Tab* key):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The syntax is reminiscent of `GestureRecognizers`, and that is not a coincidence.
    The idea is to enable a control to have various collections and to be able to
    declare those collections in the XAML.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, of course, declare the same thing in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As noted earlier, anything you can do in XAML, you can also do in C#.
  prefs: []
  type: TYPE_NORMAL
- en: You manage the command (however you create it) in `ViewModel`, just as you would
    any other command. For fun, let’s add a label below the editor and bind it to
    `LostPasswordExcuse`, but only show it until the user presses *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: '`Login.xaml` now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The Community Toolkit provides us with a much easier way to handle commands
    in `ViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Popups and dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is not uncommon to want to alert the user to a condition or change or to
    get back a bit of data from the user with an alert, as shown in *Figure 4**.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22 – The Alert dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.22_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.22 – The Alert dialog
  prefs: []
  type: TYPE_NORMAL
- en: To keep things clean, remove the Editor and its associated Label from `LoginPage.xaml`
    and remove the constructor and `ICommand` from `ViewModel`. We won’t need them
    in the final version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DisplayAlert` object can only be called from a page. Later, you’ll see
    how to handle `SubmitCommand` on the Button in `ViewModel` and send a message
    to the page to show the alert. For now, let’s keep things simple, and change the
    Button’s `SubmitCommand` to an event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The event handler is placed in the code-behind file. Notice the signature of
    the event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The dialog in *Figure 4**.22* displayed data but did not interact with the user
    (except to say to press **OK** to close the dialog). However, we can allow the
    user to make a choice and then record which button they press.
  prefs: []
  type: TYPE_NORMAL
- en: Event handler signature
  prefs: []
  type: TYPE_NORMAL
- en: '`OnSubmit` wants to be `async` because you want to call `DisplayAlert` with
    `await`. With events (and only events) `async` is not an async Task but rather
    an async void. The parameters are always an `Object` type and `EventArgs` or a
    type derived from `EventArgs`. The first is typically named `sender` as this is
    the `View` that raised the event. `EventArgs` is empty and serves as the base
    class for specific types of arguments that some events pass into the event handler.
    Since we won’t be using event handlers in the final code, you don’t have to worry
    too much about this.'
  prefs: []
  type: TYPE_NORMAL
- en: Here we’ve considered only one of the three types of alerts. Let’s look at the
    other two next.
  prefs: []
  type: TYPE_NORMAL
- en: Presenting the user with a choice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we’re at it, let’s look at the other two types of alerts. One asks the
    user to select one of two choices. We’ll add that to the `CreateAccount` button
    just for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a `clicked` event to the `OnCreate` button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And, to have a place to show the result, let’s add a label after the closing
    `HorizontalStackLayout` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The code-behind file has the event handler, which will update our label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'DisplayA`lert` returns a Boolean, so we call `ToString()` to place it in the
    text field of the `CreateAccount` label. The dialog is shown in *Figure 4**.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.23 – Using dialog to prompt a choice'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.23_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.23 – Using dialog to prompt a choice
  prefs: []
  type: TYPE_NORMAL
- en: We can go further and offer the user a series of choices. This is often referred
    to as a *wizard*, as it can be used to walk the user through a series of actions.
  prefs: []
  type: TYPE_NORMAL
- en: ActionSheet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The third variant of dialog is `ActionSheet`. Here we can put forward a number
    of choices and allow the user to select one. We’ll attach this to an event handler
    for the **Forgot** **Password** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[1] The first parameter is the title.'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] The second parameter is the text for the **Cancel** button.'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] The third parameter is the text for the `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is followed by a list of choices. *Figure 4**.24* shows what this looks
    like when it runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24 – ActionSheet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.24_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.24 – ActionSheet
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there are times when we want to allow the user to enter free-form data.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a prompt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final variant of dialog provides a prompt to the user who can fill in a
    value. We’ll need to modify the event handler for `OnCreate` to illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In this variant, it is common to use named parameters, as there are many options.
    *Figure 4**.25* shows what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.25 – Display prompt'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.25_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.25 – Display prompt
  prefs: []
  type: TYPE_NORMAL
- en: Toast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A very popular alternative to dialog boxes is the *Toast* view. This is a popup
    that comes up from the bottom of the page (much like toast coming up out of a
    toaster), which displays its message and then disappears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the handler for `OnCreate` again, this time to display a toast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When creating a Toast, you’ll need `cancellationToken`. Fortunately, you can
    instantiate one from the static `Token` object from the `CancellationTokenSource`
    object [1] and [3].
  prefs: []
  type: TYPE_NORMAL
- en: You set the duration of how long the toast will be shown with the `ToastDuration`
    enumeration [2]. The choices are `Long` and `Short`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.26* shows the Toast:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.26 – Toast popup'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.26_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.26 – Toast popup
  prefs: []
  type: TYPE_NORMAL
- en: Snackbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need more control over the appearance of your Toast, you can use the
    closely related `Snackbar`. `Snackbar` not only has a plethora of options, it
    but it also has two steps. First is the display of the toast, and second is an
    (optional) action – that is, what do you want to do when the toast is dismissed?
    In this example, we’ll display a dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cornucopia of options means that the event handler is a bit more extensive
    than usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[1] We start by creating `CancellationTokenSource` as we did previously.'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] Create a message to be displayed in the toast.'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] Add a message that can be clicked on to dismiss the toast.'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] Define how long you want the toast to be displayed. You can use any unit
    of time that `TimeSpan` supports (you could have the toast display for days!).'
  prefs: []
  type: TYPE_NORMAL
- en: '[5] The action is what will happen when the toast is dismissed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[6] Here is where we set the characteristics of the toast.'
  prefs: []
  type: TYPE_NORMAL
- en: '[7] You can set the text color for the toast and for the dismissal text independently
    of each other.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.27* shows what `Snackbar` looks like before we click on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.27 – Snackbar'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.27_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.27 – Snackbar
  prefs: []
  type: TYPE_NORMAL
- en: 'After the user clicks on the `SnackBar` disappears, and the action is fired;
    in this case, the dialog box appears, as shown in *Figure 4**.28*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.28 – The action after the snackbar is dismissed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.28_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.28 – The action after the snackbar is dismissed
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI does not have a horizontal line control, but we can put the `BoxView`
    control to work as an excellent substitute.
  prefs: []
  type: TYPE_NORMAL
- en: BoxView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the simplest controls is `BoxView`, which simply draws a box on the
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 4**.29* shows the `BoxView` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.29 – A simple BoxView control'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.29_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.29 – A simple BoxView control
  prefs: []
  type: TYPE_NORMAL
- en: 'What good is this you ask? If you make the box height very small and the width
    very large, you get a nice line to divide your page. If we put the following after
    the **Password** entry, but before the buttons, we can neatly divide the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 4**.30* shows what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.30 – Using the BoxView control to draw a line'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.30_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.30 – Using the BoxView control to draw a line
  prefs: []
  type: TYPE_NORMAL
- en: Many UI experts like to frame controls with a border, potentially with a *drop
    shadow*. To do this you’ll want to use a `Frame` control.
  prefs: []
  type: TYPE_NORMAL
- en: Frame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you wish to create a border around another control, you’ll want to use a
    `Frame` control. `Frame` lets you define the color of the border, `CornerRadius`,
    and whether or not the frame has a shadow. Let’s create a frame around the `Password`
    entry field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 4**.31* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.31 – Putting a frame around the Password entry'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.31_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.31 – Putting a frame around the Password entry
  prefs: []
  type: TYPE_NORMAL
- en: You control the color of the `BoxView` control and a number of other controls
    by painting the color using Brushes.
  prefs: []
  type: TYPE_NORMAL
- en: Brushes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can fill in the color of any number of controls using a brush. The easiest
    place to see this in action is with a `BoxView` control, or with `Frame`.
  prefs: []
  type: TYPE_NORMAL
- en: There are three types of brushes, **Solid**, **Linear Gradient**, and **Radial
    Gradient**. Let’s explore them in a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The Solid brush
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Solid Brush is used when you want to fill a control with a single color.
    Typically, the solid brush is implicit in the `BackgroundColor` property of the
    control, as we saw above when drawing the `BoxView` control.
  prefs: []
  type: TYPE_NORMAL
- en: LinearGradientBrush
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`LinearGradientBrush` paints an area with a blend of two or more colors along
    a line called the gradient axis. You specify a start point and an endpoint, and
    then you specify stop points (where the colors switch) along the way.'
  prefs: []
  type: TYPE_NORMAL
- en: The start and endpoints are relative to the borders of the painted area, with
    `0,0` being the upper left corner (and the default start) and `1,1` being the
    lower right (and the default stop).
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, I’ll move the frame from around the password to a space
    of its own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[1] Here we create a `Background` property on `Frame`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] Within that, create `LinearGradientBrush`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we specify `EndPoint` but not `StartPoint`, as we’re using the default
    `StartPoint` of `0,0`. By going from `0,0` to `1,0`, we create a horizontal gradient.
  prefs: []
  type: TYPE_NORMAL
- en: '[3] We have set the first `GradientStop` at `0.2`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] We set the second `GradientStop` at `0.1`, giving us about twice as much
    yellow as red.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.32* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.32 – LinearGradientBrush'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.32_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.32 – LinearGradientBrush
  prefs: []
  type: TYPE_NORMAL
- en: Gradient stops
  prefs: []
  type: TYPE_NORMAL
- en: Gradient stops indicate the position along the gradient vector, ranging from
    `0` to `1`. In short, the first gradient shown here is two-tenths of the way,
    and the second is one-tenth of the way along the gradient vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gradients come in two flavors: linear, as shown in the previous example, and
    radial, as explained next.'
  prefs: []
  type: TYPE_NORMAL
- en: RadialGradientBrush
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we do the same thing with `RadialGradientBrush`, our coordinates start at
    the center, which defaults to `0.5,0.5`, and we supply the radius as a double.
    The default value is `0.5`. Let’s reproduce `LinearGradient` shown previously
    using `RadialGradientBrush`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we did not specify the center or the radius, so we are using the
    default values. *Figure 4**.33* illustrates the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.33 – RadialGradientBrush'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.33_B19723.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.33 – RadialGradientBrush
  prefs: []
  type: TYPE_NORMAL
- en: With this, we’ve come to the end of a very important chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This has been a long chapter, and we’ve covered many things, but if you break
    it down, the real topics were as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: MVVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataBinding`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, controls are a pretty big topic, and we’re not done. In the next
    chapter, we’ll talk about layouts, but we’ll also discuss how you style controls,
    animate controls, and more.
  prefs: []
  type: TYPE_NORMAL
- en: The 90% you use 90% of the time
  prefs: []
  type: TYPE_NORMAL
- en: I did not try to cover every control, nor did I cover all the properties of
    the controls we did see. That would have turned this book into an encyclopedia,
    and my goal is to show you the 90% of .NET MAUI that you use day in and day out.
    If you find you need a different property or a different control, well, that’s
    what the (excellent) documentation is for. Just go to [https://bit.ly/Liberty-Maui](https://bit.ly/Liberty-Maui),
    or ask Google or your local AI agent, and you’ll be able to find every nook and
    cranny.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main takeaways from this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: MVVM is the essential architecture for .NET MAUI. In MVVM, `Model` is the data
    (we’ve not seen this at work yet), `View` is the UI, and `ViewModel` is where
    all the logic is (or should be). We broke MVVM for much of this chapter and put
    the logic in the code-behind file, but that was only as a convenience and because
    we haven’t, yet, talked about getting data into and out of pages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataBinding` is how you connect `ViewModel` to `View`. Rather than copying
    data from a property in `ViewModel` to a field in `View`, you bind that control
    to the property, and when the property’s value changes, the control is automagically
    updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a boatload of controls available to you and each is displayed as a
    native control on all of the supported platforms: iOS, Android, Windows, and macOS.
    The fact that they are emitted as native controls is tremendously important. Not
    only will they look right, but they will also be wicked fast.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything you can declare in XAML you can declare in C#.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can take control over the appearance of each control so that they look the
    same on every platform – anything from having the same color all the way to looking
    identical. That is entirely up to you. It only depends on how many properties
    you set on each control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the advantages of MVVM?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you create the connection between the `View` class and `ViewModel` so
    that data binding will work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are two controls for entering data into a form?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the most common control for displaying data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a `SnackBar`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You try it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Build a page that acts like a form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give it some prompts, entry fields, and buttons to accept the entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user fills in the field and clicks on the button, display a confirmation
    toast and show their entry in a label
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add in an image, and for extra credit, enable that image to be clicked on and,
    when clicked on, display a congratulatory dialog box and/or toast (or if you are
    ambitious, use `SnackBar`!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feel free to mix in additional controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
