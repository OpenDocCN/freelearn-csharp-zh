# 评估

# 第一章

1.  软件架构师需要了解任何可以帮助他们更快解决问题并确保他们有更好质量的技术的技术。

1.  Azure 提供了，并且不断演进，许多软件架构师可以在解决方案中实现的功能组件。

1.  流程模型可以帮助你了解你的团队，你将提供的解决方案类型，以及可用的预算。

1.  软件架构师会关注任何可能影响性能、安全性、可用性等方面的用户或系统需求。

1.  所有这些，但非功能性需求需要更多的关注。

1.  设计思维是一种帮助软件架构师精确定义用户需求的工具。

1.  当我们想要定义功能性需求时，用户故事是好的。

1.  缓存、异步编程和正确的对象分配。

1.  为了检查实现是否正确，软件架构师将其与已经设计和验证过的模型和原型进行比较。

# 第二章

1.  垂直和水平。

1.  是的，你可以自动部署到已定义的 Web 应用程序，或者直接使用 Visual Studio 创建一个新的。

1.  通过最小化它们闲置的时间来利用可用的硬件资源。

1.  代码行为是确定的，因此易于调试。不可能出现死锁，执行流程模仿顺序代码的流程，这意味着更容易设计和理解。

1.  因为正确的顺序可以最小化填写表格所需的动作数量。

1.  因为它允许以独立于操作系统的方式操作路径文件。

1.  它可以与多个 .NET Core 版本以及多个经典 .NET 框架版本一起使用。

1.  控制台、.NET Core 和 .NET 标准类库；ASP.NET Core、测试和微服务。

# 第三章

1.  不，它适用于多个平台。

1.  是的，开发/部署过程中的每一步都可以自动化，包括部署到生产环境。

1.  自动、手动和负载测试计划。

1.  是的，他们可以通过 Azure DevOps 源来做到这一点。

1.  为了管理需求和组织整个开发过程。

1.  史诗级工作项代表由多个功能组成的高级系统子部分。

1.  一种父子关系。

# 第四章

1.  当你从本地解决方案迁移或拥有基础设施团队时，IaaS 是一个好的选择。

1.  PaaS 是在团队专注于软件开发时，快速且安全交付软件的最佳选择。

1.  如果你打算交付的解决方案由知名玩家提供，例如 SaaS，你应该考虑使用它。

1.  当你构建一个新系统，没有专门从事基础设施的人员，并且不想担心可伸缩性时，无服务器绝对是一个选项。

1.  Azure SQL Server 数据库可以在几分钟内启动，之后你将拥有 Microsoft SQL Server 的全部功能。

1.  Azure 提供了一组称为 Azure 认知服务的服务。这些服务提供视觉、语音、语言、搜索和知识方面的解决方案。

1.  在混合场景中，你有灵活性来决定系统每个部分的最佳解决方案，同时尊重解决方案的路径并将其推向未来。

1.  为了允许更新/写入并行性。

1.  传递给 `Create` 方法的第三个参数，它创建代理实例，允许我们指定通信的允许目标。通常，`ServiceReplicaListener` 构造函数的第三个参数指定是否在辅助副本上创建监听器。

# 第五章

1.  代码模块化和部署模块化。

1.  不，其他重要优势包括很好地处理开发团队和整个 CI/CD 循环，以及轻松有效地混合异构技术的可能性。

1.  一个帮助我们实现弹性通信的库。

1.  在 `HostBuilder` 方法中可以声明依赖注入和托管服务。

1.  一旦你在开发机器上安装了 Docker，你就可以开发、调试和部署 Docker 化的 .NET Core 应用程序。你还可以将 Docker 镜像添加到由 Visual Studio 处理的服务 Fabric 应用程序中。

1.  基于 Kubernetes `.yaml` 文件的那个。

1.  面向集群外部的流量，并通过集群的 URI 访问的那个。

# 第六章

1.  在数据库依赖提供者的帮助下。

1.  要么通过调用它们 `Id`，要么通过使用 `Key` 属性装饰它们。

1.  使用 `MaxLength` 和 `MinLength` 属性。

1.  类似于：`builder.Entity<Package>().HasIndex(m => m.Name);`.

1.  类似于 `builder.Entity<Destination>()`：

    `.HasMany(m => m.Packages)`

    `.WithOne(m => m.MyDestination)`

    `.HasForeignKey(m => m.DestinationId)`

    `.OnDelete(DeleteBehavior.Cascade);`

1.  Add-Migration 和 Update-Database.

1.  不，但你可以使用 `Include` LINQ 子句强制包含它们。

1.  是的，它是，多亏了 `Select` LINQ 子句。

1.  通过调用 `context.Database.Migrate()`。

# 第七章

1.  不，它是一个内存中的字典，可以用作缓存或满足其他内存存储需求。

1.  是的，它们是。本章的大部分内容都是致力于解释为什么。

1.  写操作。

1.  NoSQL 数据库的主要弱点是其一致性和事务，而其主要优势是性能，尤其是在处理分布式写入时。

1.  最终一致性、一致性前缀、会话、有界不一致性、强一致性。

1.  不，它们在分布式环境中效率不高。基于 GUID 的字符串表现更好，因为它们的唯一性是自动的，不需要同步操作。

1.  `OwnsMany` 和 `OwnsOne`.

1.  是的，它们可以。一旦你使用了 `SelectMany`，索引就可以用来搜索嵌套对象。

# 第八章

1.  Azure Functions 是一个 Azure PaaS 组件，允许你实现 FaaS 解决方案。

1.  你可以使用不同的语言编写Azure Functions，例如C#、F#和Node。你还可以使用Azure Portal和Visual Studio VS Code创建函数。

1.  Azure Functions有两种计划选项。第一种计划是消费计划，你将根据使用的数量付费。第二种计划是App Service计划，你将与函数的需求共享App Service资源。

1.  在Visual Studio中部署函数的过程与Web应用部署相同。

1.  我们可以触发Azure Functions的方式有很多，例如使用Blob存储、Cosmos DB、Event Grid、Event Hubs、HTTP、Microsoft Graph事件、队列存储、服务总线、定时器和Webhooks。

1.  Azure Functions v1需要.NET Framework引擎，而v2需要.NET Core。

1.  每个Azure Function的执行都可以通过Application Insights进行监控。在这里，你可以检查处理所需的时间、资源使用情况、每个函数调用中发生的错误和异常。

# 第9章

1.  设计模式是解决软件开发中常见问题的良好解决方案。

1.  虽然设计模式为你提供了我们在开发中面临的典型问题的代码实现，但设计原则有助于你在实现软件架构时选择最佳选项。

1.  建造者模式将帮助你生成复杂的对象，而无需在你要使用它们的类中定义它们。

1.  工厂模式在有多种来自同一抽象的对象且不知道在开始编码时需要创建哪个对象的情况下非常有用。

1.  当你需要一个在软件执行期间只有一个实例的类时，单例模式非常有用。

1.  当你需要提供一个控制对另一个对象访问的对象时，使用代理模式。

1.  当你需要执行将影响对象行为的*命令*时，使用命令模式。

1.  当你需要向一组其他对象提供有关对象的信息时，发布/订阅模式非常有用。

1.  如果你想实现依赖倒置原则，DI模式非常有用。

# 第10章

1.  专家使用的语言变化以及词语含义的变化。

1.  领域映射。

1.  不；整个通信都通过实体进行，即聚合根。

1.  因为聚合体代表部分-部分层次结构。

1.  只有一个，因为仓库是聚合中心。

1.  应用层操作仓库接口。仓库实现注册在依赖注入引擎中。

1.  为了在多个聚合体上协调单事务操作。

1.  更新和查询的规范通常相当不同，尤其是在简单的CRUD系统中。其最强形式的原因主要是查询响应时间的优化。

1.  依赖注入。

1.  不；必须进行严重的影响分析，以便我们可以采用它。

# 第11章

1.  不，因为这种方法会有很多重复代码，这会在维护时造成困难。

1.  代码重用的最佳方法是创建库。

1.  是的。你可以在你之前创建的库中找到已经创建的组件，然后通过创建可以在未来重用的新组件来增加这些库。

1.  .NET标准是一个规范，它允许.NET的不同框架之间实现兼容性，从.NET Framework到Unity。.NET Core是.NET的一种实现，并且是开源的。

1.  通过创建.NET标准库，你将能够在不同的.NET实现中使用它，例如.NET Core、.NET Framework和Xamarin。

1.  你可以使用面向对象的原则（继承、封装、抽象和多态）来启用代码重用。

1.  泛型是一种复杂的实现，通过定义一个占位符来简化具有相同特性的对象在编译时被替换为特定类型的方式。

# 第12章

1.  不，因为这会违反服务对请求的反应必须依赖于请求本身，而不是之前与客户端交换的其他消息/请求的原则。

1.  不，因为这会违反互操作性约束。

1.  是的，它可以。POST的主要操作必须是创建，但删除可以作为副作用执行。

1.  三，即头和体的Base64编码加上签名。

1.  从请求体中。

1.  使用`ApiController`属性。

1.  `ProducesResponseType`属性。

1.  使用`Route`和`Http<verb>`属性。

1.  类似于`services.AddHttpClient<MyProxy>()`。

# 第13章

1.  开发者错误页面和开发者数据库错误页面、生产错误页面、主机、HTTPS重定向、路由、身份验证和授权以及端点调用者。

1.  不。

1.  错误。同一个标签上可以调用多个标签助手。

1.  `ModelState.IsValid`。

1.  `@RenderBody()`。

1.  我们可以使用`@RenderSection("Scripts", required: false)`。

1.  我们可以使用`return View("viewname", ViewModel)`。

1.  三。

1.  不；还有`ViewState`字典。

# 第14章

1.  可维护性为你提供了快速交付你设计的软件的机会。它还允许你轻松修复错误。

1.  圈复杂度是一个检测方法节点数量的指标。数字越高，影响越差。

1.  版本控制系统将保证源代码的完整性，并为你提供分析每个修改历史的机会。

1.  Try-catch是控制由你编写的代码引发的异常的一种方式。Try-finally是一种保证即使在try块内部有异常，finally块也会执行其过程的方式。当你想在同一块代码中解决这两种情况时，可以使用try-catch-finally。

1.  垃圾回收器是 .NET Core/.NET Framework 系统的一种，它监视你的应用程序并检测你不再使用的对象。它清理这些对象以释放内存。

1.  `IDisposable` 接口对于需要程序员进行清理的对象实例化的类来说很重要，因为垃圾回收器无法清理它们。

1.  .NET Core 以一种可以保证更安全代码的方式封装了一些设计模式，例如依赖注入和 Builder。

# 第 15 章

1.  因为大多数测试在软件发生任何更改后都必须重新进行。

1.  因为在单元测试及其相关应用程序代码中发生完全相同错误的概率非常低。

1.  当测试方法定义了多个测试时使用 `[Theory]`，而当测试方法只定义了一个测试时使用 `[Fact]`。

1.  `Assert`。

1.  `Setup`、`Returns` 和 `ReturnsAsync`。

1.  是的；使用 `ReturnAsync`。

# 第 16 章

1.  编写良好的代码是任何熟练掌握该编程语言的人都可以处理、修改和发展的代码。

1.  Roslyn 是用于在 Visual Studio 内部进行代码分析的 .NET 编译器。

1.  代码分析是一种在编译前检测不良实践的实践，它考虑了代码的编写方式。

1.  代码分析可以发现即使在表面上看起来很好的软件中也会发生的问题，例如内存泄漏和不良编程实践。

1.  Roslyn 可以用于代码分析。

1.  Visual Studio 扩展是在 Visual Studio 内部运行的编程工具。这些工具可以在某些情况下帮助你，在这些情况下 Visual Studio IDE 没有为你提供适当的功能。

1.  微软代码分析、SonarLint 和 Code Cracker。

# 第 17 章

1.  为了最大化软件为目标组织提供的价值。

1.  不；它需要获取所有能够最大化软件增值所需的能力。

1.  因为当新用户订阅时，其租户必须自动创建，并且因为新的软件更新必须分发到所有客户的基础设施中。

1.  是的；Terraform 是一个例子。

1.  Azure 管道。

1.  你的业务依赖于 SaaS 供应商，因此其可靠性是基本的。

1.  不；可扩展性同容错性和自动故障恢复一样重要。

# 第 18 章

1.  DevOps 是一种持续向最终用户提供价值的途径。为了成功做到这一点，必须进行持续集成、持续交付和持续反馈。

1.  持续集成允许你在每次提交更改时检查你交付的软件的质量。你可以通过在 Azure DevOps 中启用此功能来完成此操作。

1.  持续交付允许你在确信所有质量检查都通过了你设计的测试后部署解决方案。Azure DevOps 通过提供相关工具来帮助你完成此操作。

1.  持续反馈是采用 DevOps 生命周期中的工具，以便在性能、可用性以及你正在开发的应用的其他方面快速获得反馈。

1.  构建管道将允许你运行构建和测试应用程序的任务，而发布管道将为你提供定义应用程序在每个场景中如何部署的机会。

1.  应用洞察（Application Insights）是监控你已部署的系统健康状况的有用工具，这使得它成为一款出色的持续反馈工具。

1.  测试与反馈（Test & Feedback）是一个工具，允许利益相关者分析你正在开发的软件，并能够与 Azure DevOps 连接以打开任务甚至错误。

# 第19章

1.  这是一种确保每次提交到代码仓库的代码都经过构建和测试的方法。

1.  是的，你可以先独立设置 DevOps，然后稍后启用持续交付。你的团队和流程需要准备好并关注这一变化的发生。

1.  所有这些风险都可能对你的生产环境造成损害。例如，你可能有一个尚未准备好的功能却已经部署了，你可能在客户不利的时刻造成服务中断，或者你可能因为错误的修复而遭受不良的副作用。

1.  多阶段环境可以保护生产环境免受不良发布的影响。

1.  自动化测试可以预测预览场景中的错误和不良行为。

1.  拉取请求允许在主分支提交之前进行代码审查。

1.  不；拉取请求（pull requests）可以帮助你在任何有 Git 作为源控制的发展方法中。

# 第20章

1.  不；这取决于用户界面的复杂性和变化频率。

1.  ASP.NET Core 管道不会执行，但输入会直接传递到控制器。

1.  使用 `Microsoft.AspNetCore.Mvc.Testing` NuGet 包。

1.  使用 `AngleSharp` NuGet 包。
