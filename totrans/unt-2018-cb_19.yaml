- en: Automated Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating and running a default test script class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing a simple unit test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameterizing tests with a data provider method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing a simple health script class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and executing a unit test in PlayMode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PlayMode testing a door animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PlayMode and unit testing a player health bar with events, logging, and exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a very simple computer program, we can write code, then run it, entering
    a variety of valid and invalid data, and see whether the program behaves as we
    expect it to. This is known as a code-then-test approach. However, this approach
    has several significant weaknesses:'
  prefs: []
  type: TYPE_NORMAL
- en: Each time we change the code, as well as running new tests relating to the code
    we are improving, we have to run all the old tests to ensure that no unexpected
    modified behaviors have been introduced (in other words, our new code has not
    **broken** another part of our program)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tests manually is time consuming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are relying on a human to rerun the test each time, and this test may be
    run using different data, or some data may be omitted, or different team members
    may take a different approach to running tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, even for simple programs (and most are not simple), some kind of
    fast, automated testing system makes a lot of sense.
  prefs: []
  type: TYPE_NORMAL
- en: The big picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an approach to software development called **Test-Driven Development**
    (**TDD**), whereby code is **only** written until all tests pass. So, if we want
    to add or improve the behavior of our game program, we must specify what we want
    in terms of tests, and then the programmers write code to pass the tests. This
    avoids a situation whereby programmers write code and features that are not needed,
    or spend time over-optimizing things that would have been fine, and so on. It
    means that the game development team directs its work toward agreed goals understood
    by all, since they have been specified as tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates basic TDD in that we only write code until
    all tests pass. Then it''s time to write more tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9ca918d-641c-4ed7-adae-842e174b6676.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another way that TDD is often summarized is as red-green-refactor:'
  prefs: []
  type: TYPE_NORMAL
- en: '**red:** We write code that fails the test (in other words, for the new feature/improved
    behavior we wish to add to our system)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**green:** We write code that passes the new test (and all the existing ones)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**refactor:** We (may) choose to improve the code (and ensure that the improved
    code passes all the tests)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two kinds of software test are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration tests**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Unit Test** tests a "unit" of code, which can be a single method, but which
    may include some other computer work being executed between the method being tested
    and the end result(s) being checked.
  prefs: []
  type: TYPE_NORMAL
- en: '*"A unit test is a piece of code that invokes a unit of work and checks one
    specific end result of that unit of work. If the assumptions on the end result
    turn out to be wrong, the unit test has failed*."'
  prefs: []
  type: TYPE_NORMAL
- en: —Roy Oshergrove (p. 5, *The Art of Unit Testing* (Second edition).
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit tests should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: automated (runnable at the "push of a button")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: easy to implement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: easy to read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: executed in isolation (tests should be independent from one another)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: assessed as either having being passed or failed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: relevant tomorrow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: consistent (the same results each time!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: able to easily pinpoint what was at fault for each test that fails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most computer languages have an xUnit unit testing system available, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'C#: NUnit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java: JUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PHP: PHPUnit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity offers an easy way to write and execute NUnit tests in its editor (and
    at the command line).
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, each unit test will be written in three sections, a sequence of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange**: Set any initial values needed (sometimes, we are just giving a
    value to a variable in order to improve code readability)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Act**: Invoke some code (and, if appropriate, store the results)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assert**: Make assertions for what should be true about the code invoked
    (and any stored results)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observe that the naming of a unit test method (by convention) is quite verbose—it
    is made up of lots of words that describe what it does. For example, you might
    have a unit test method named `TestHealthNotGoAboveOne()`. The idea is that if
    a test fails, the name of the test should give a programmer a very good idea of
    what behavior is being tested and, therefore, how to quickly establish whether
    the test is correct and, if so, where to look in your program code for what was
    being tested. Another part of the convention of naming unit tests is that numerals
    are not used—ust words—so we write "one", "two", and so on, in the name of the
    test method.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests (PlayMode tests in Unity)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **Integration Test** involves checking the behavior of interacting software
    components, for example, ones that use real time, or a real filesystem, or that
    communicate with the web or other applications running on the computer. Integration
    tests are usually not as fast as unit tests, and may not produce consistent results
    (since the components may interact in different ways at different times).
  prefs: []
  type: TYPE_NORMAL
- en: Both **Unit** and **Integration Test** are important, but they are different
    and should be treated differently.
  prefs: []
  type: TYPE_NORMAL
- en: Unity offers **Play Mode** testing, allowing integration testing as Unity scenes
    execute with testing code in them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Places where you can learn more about Unity Testing include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity Test Runner and PlayMode documentation pages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Manual/testing-editortestsrunner.html](https://docs.unity3d.com/Manual/testing-editortestsrunner.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Manual/PlaymodeTestFramework.html](https://docs.unity3d.com/Manual/PlaymodeTestFramework.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A website for the book "The Art of Unit Testing" (and lots of other learning
    resources associated with testing): [http://artofunittesting.com/](http://artofunittesting.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A great dual article tutorial about Unity testing by Tomek Paszek of Unity
    (talking about the old Unity test tools, but most of the content is still very
    relevant): [https://blogs.unity3d.com/2014/06/03/unit-testing-part-2-unit-testing-monobehaviours/](https://blogs.unity3d.com/2014/06/03/unit-testing-part-2-unit-testing-monobehaviours/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'YouTube, where you can learn lots about Unity testing (and other topics) from
    Infalliblecode: [https://www.youtube.com/infalliblecode](https://www.youtube.com/infalliblecode)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CodeProject.com''s introduction to TDD and NUnit: [https://www.codeproject.com/Articles/162041/Introduction-to-NUnit-and-TDD](https://www.codeproject.com/Articles/162041/Introduction-to-NUnit-and-TDD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a default test script class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unity can create a default C# test script for you, thereby enabling you to
    quickly start creating and executing tests on your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae577c7a-a58a-4000-9eda-6f93e1110c47.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To generate a default test script class, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Project panel, create a folder called Editor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Display the Test Runner panel by choosing the following menu: Window | General
    | Test Runner'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the EditMode button is selected in the Test Runner panel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that your new Editor folder is selected in the Project panel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Test Runner panel, click the Create Test Script in the current folder button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now have a new C# script added to your Editor folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run the tests in your script class, click the Run All button in the Test
    Running panel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now see all green ticks (check marks) in the panel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unity checks that you have a folder named Editor selected in the Project panel,
    and then creates a C# NewTestScript script class for you containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Test Runner panel, you should see the script class and its two methods
    listed. Note that the first line in the Test Runner panel is the Unity project
    name, the second line will say `Assembly-CSharp-Editor.dll`, followed by your
    script class name, and then each of the test methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7fcf6a3-c7ad-4c50-849a-b3f16d5e0203.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are three symbols to indicate the status of each test/class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Empty circle**: Test not executed since the script class was last changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Green tick** (check mark): The test was passed successfully'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Red cross**: The test was failed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some details that you won't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Create a default test script from the Project panel's Create menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way of creating a default Unit Test script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Project panel, chose the following menu: Create | Testing | C# Test
    Script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit mode minimum skeleton unit test script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Be aware that if you are only going to use this script class for testing in
    EditMode, you can delete the second method and some of the using statements as
    follows, so as to give you a minimal skeleton to work from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A simple unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the same way as printing "hello world" is most programmers first program
    statement, asserting that 1 + 1 = 2 is perhaps the most common first test executed
    for those learning unit testing. That''s what we''ll create in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6ba1b96-51a1-42fc-9439-6619d61ecd02.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create and execute a simple unit test, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Project panel, create a folder called Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside your Editor folder, create a new C# `SimpleTester.cs` script class containing
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Display the Test Runner panel by choosing the following menu: Window | General
    | Test Runner.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the `EditMode` button is selected in the Test Runner panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Run All.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see the results of your Unit Test being executed – if the test was
    concluded successfully, it should have a green 'tick' next to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have declared that the `TestOnePlusOneEqualsTwo()` method in the C# `SimpleTester.cs`
    script class is a test method. When executing this test method, the Unity Test
    Runner executes each statement in sequence, so variables `n1`, `n2`, and `expectedResult`
    are set, then the calculation of 1 + 1 is stored in the variable result, and finally
    (the most important bit), we make an assertion of what should be true after executing
    that code. Our assertion states that the value of the `expectedResult` variable should
    be equal to the value of the variable result.
  prefs: []
  type: TYPE_NORMAL
- en: If the assertion is true, the test is passed, otherwise it is failed. Generally,
    as programmers, we expect our code to pass, so we inspect each fail very carefully,
    first to see whether we have an obvious error, then perhaps to check whether the
    test itself is correct (especially if it's a new test), and then to begin to debug
    and understand why our code behaved in such a way that it did not yield the anticipated
    result.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some details that you won't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Shorter tests with values in the assertion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For simple calculations, some programmers prefer to write less test code by
    putting the values directly into the assertion. So, as shown below, our 1 + 1
    = 2 test could be expressed in a single assertion, where the expected value of
    2, and the expression 1 + 1, are entered directly into an `AreEqual(...)` method
    invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, if you are new to testing, you may prefer the previous approach, whereby
    the preparation, code execution, and storage of results, and the assertion of
    properties about those results, are structured clearly in a sequence of **Arrange/Act/Assert**.
  prefs: []
  type: TYPE_NORMAL
- en: Expected value followed by the actual value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When comparing values with assertions, it is customary for the expected (correct)
    value to be given first, followed by the actual value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'While it makes no difference to the true or false nature of equality, and so
    on, it can make a difference to messages when tests fail with some testing frameworks
    (for example, "got 2 but expected 3" has a very different meaning to "got 3 but
    expected 2"). Hence, the following assertion would output a message that would
    be confusing, since 2 was our expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69dd1664-2b61-4de9-b131-5c3bf8b392de.png)'
  prefs: []
  type: TYPE_IMG
- en: Parameterizing tests with a data provider method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we are testing our code using a range of test data, then sometimes there
    is little difference between each test apart from the the values. Rather than
    duplicating our Arrange/Act/Assert statements, we can re-use a single method,
    and the Unity Test Runner will loop through a collection of test data, running
    the test method for each set of test data. The special method that provides multiple
    sets of test data to a test method is known as a DataProvider, and we''ll create
    one in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23878553-e5bf-44f1-9f9d-fb3714659e72.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To parameterize tests with a data provider method, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Project panel, create a folder called Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside your Editor folder, create a new C# `DataProviderTester.cs` script class containing
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Display the Test Runner panel by choosing the following menu: Window | General
    | Test Runner.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the EditMode button is selected in the Test Runner panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Run All.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see the results of your Unit Test being executed. You should see
    four sets of results for the `TestAdd(...)` test method, one for each of the datasets
    provided by the `AdditionProvider` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have indicated that the `TestAdd(...)` method is a test method with a compiler
    attribute [Test]. However, in this case, we have added additional information
    to state that the data source for this method is the `AdditionProvider` method.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the Unity Test Runner will retrieve the data objects from the
    additional provider, and create multiple tests for the `TestAdd(...)` method,
    one for each set of data from the `AdditionProvider()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Test Runner panel, we can see a line for each of these tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Unit testing a simple health script class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create something that might be used in a game, and that can easily be
    unit tested. Classes that do **not** subclass from Monobehavior are much easier
    to unit test, since instance objects can be created using the keyword new. If
    the class is carefully designed with private data and public methods with clearly
    declared dependencies as parameters, it becomes easy to write a set of tests to
    make us confident that objects of this class will behave as expected in terms
    of default values, as well as valid and invalid data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will create a health script class, and a set of tests for
    this class. This kind of class can be reused for both the health of human players,
    and also Artificial Intelligence (AI)-controlled enemies in a game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1db24c0c-d5e6-4c17-a24c-153834a86a78.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To unit test a health script class, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Project panel, create a _Scripts folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside your `_Scripts` folder, create a new C# `Health.cs` script class containing
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Inside your _Scripts folder, create a new folder named Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside your Editor folder, create a new C# `TestHealth.cs` script class containing
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Display the Test Runner panel by choosing the following menu: Window | Debug
    | Test Runner.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the EditMode button is selected in the Test Runner panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Run All.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see the results of your unit tests being executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each of the C# script-classes is described below.
  prefs: []
  type: TYPE_NORMAL
- en: Script-class Health.cs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This script class has one private property; as it is private, it can only be
    changed by methods. Its initial value is 1.0, in other words, 100% health:'
  prefs: []
  type: TYPE_NORMAL
- en: '`health` (float): The valid range is from 0 (dead!) to 1.0 (100% health)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are 3 public methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetHealth()`: This returns the current value of the health float number (which
    should be between 0 and 1.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddHealth(float)`: This takes as input a float (the amount to add to the health),
    and returns a Boolean true/false, as to whether the value was valid. Note the
    logic of this method is that it accepts values of 0 or more (and will return true),
    but it will ensure that the value of health is never more than 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KillCharacter()`: This method sets health to zero, and returns true, since
    it is always successful in this action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script-class TestHealth.cs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This script class has five methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TestReturnsOneWhenCreated()`: This tests that the initial value of health
    is 1, when a new Health object is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestPointTwoAfterAddPointOneTwiceAfterKill()`: This tests that after a kill
    (health set to zero), and then adding 0.1 on two occasions, the health should
    be 0.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestReturnsZeroWhenKilled()`: This tests that the health value is set to zero
    immediately after the `KillCharacter()` method has been called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestNoChangeAndReturnsFalseWhenAddNegativeValue()`: This tests that attempting
    to add a negative value to health should return false and that the value of health
    should not have changed. This method is an example of a test with more than one
    assertion (but both are related to the actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestHealthNotGoAboveOne()`: This test verifies that even when lots of values
    are added to health, totaling more than 1.0, the value returned from `GetHealth()`
    is one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hopefully, all the tests pass when you run them, giving some confidence that
    the logic implementation in the `Health.cs` script class does behave as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and executing a unit test in Play mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's a good idea to write as much of the logic for a game as isolated, non-Monobehavior
    classes, that are easy to unit test in Edit mode. However, some of the logic in
    a game relates to things that happen when the game is running. Examples include
    physics, collisions, and timing-based events. We test these parts of our games
    in Play Mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll create one very simple Play Mode test, to check that
    physics affects a RigidBody (based on an example from the Unity documentation):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d7fe717-66e1-4c2b-bbdb-6b312ea5e15f.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create and execute a unit test in **Play** mode, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Display the Test Runner panel by choosing the following menu: Window | General
    | Test Runner'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enable PlayMode tests for all assemblies. Do this by displaying the drop-down
    menu in the top-right corner of the Test Runner panel, and then selecting Enable
    playmode tests for all assemblies (click OK to any message concerned with restarting
    the editor):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6abcb454-93c1-4ec8-be54-22864a5f354f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, restart the Unity Editor (just close the application and then reopen it
    with your project).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is very important that you restart the Unity Editor application after enabling
    PlayMode. If you fail to do this, then you may not be able to locate your PlayMode
    test script classes where they can see (and refer to) your Monobehavior classes.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the PlayMode button is selected in the Test Runner panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Test Runner panel, click the Create PlayMode Test Assembly Folder button.
    A new folder, named Tests, should have been created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, open the `Tests` folder. It should contain an assembly
    definition file Tests.asmdef.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Test Runner panel, click the Create Test Script in the current folder
    button – you may wish to rename this script from the default name, `NewTestScript`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit your new test script, replacing the content with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Click Run All.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Hierarchy, you'll see that a temporary scene is created (named something
    along the lines of InitTestScene6623462364), and that a GameObject named Code
    Based Test Runner is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Game panel, you will briefly see the message Display 1 No Cameras Rendering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see the results of your unit test being executed – if the test is
    concluded successfully, it should have a green tick next to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Methods marked with the `[UnityTest]` attribute are run as coroutines. A coroutine
    has the ability to pause execution (when it meets a yield statement) and return
    control to Unity, but then to continue where it left off when called again (for
    example, the next frame, second, or whatever). The yield statement indicates the
    statement after which, and for how long, execution of the method is to be paused.
    Examples of different types of yield include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Waiting until until the next frame: `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Waiting for a given length of time: `WaitForSeconds(<seconds>)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Waiting until the next fixed-update time period (physics is not applied each
    frame (since the framerate varies), but after a fixed period of time): `WaitForFixedUpdate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method `GameObject_WithRigidBody_WillBeAffectedByPhysics()` creates a new GameObject
    and attaches to it a RigidBody. It also stores the original Y position. The yield
    statement makes the PlayMode Test Runner wait until physics has begun at the next
    fixed update period. Finally, an assertion is made that the original Y position
    is not equal to the new Y position (after the physics fixed update). Since the
    defaults for a RigidBody are that gravity will be applied, this is a good test
    that physics is being applied to the new object (in other words, it should have
    started falling down once physics had been applied).
  prefs: []
  type: TYPE_NORMAL
- en: PlayMode testing a door animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having learned the basics of PlayMode testing in the previous recipe, now let's
    test something non-trivial that we might find in a game. In this recipe, we'll
    create a PlayMode test to ensure that a door opening animation plays when the
    player's sphere object enters a collider.
  prefs: []
  type: TYPE_NORMAL
- en: 'A scene has been provided with the player''s sphere initialized to roll toward
    a red door. When the sphere hits the collider (`OnTriggerEnter` event), some code
    sets the door''s Animator Controller Opening variable to true, which transitions
    the door from its closed state to its open state, as can be seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27a33dc2-b393-4ed7-aa36-9cb6807b6c2b.png)'
  prefs: []
  type: TYPE_IMG
- en: Thanks should go to the creator of the ground texture; it was designed by Starline,
    and published at [Freepik.com](http://Freepik.com).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, a Unity Package has been provided `(doorScene.unitypackage)`
    in the `19_06` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To PlayMode test a door animation, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity project, and delete the default folder Scenes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the Unity package provided (doorScene.unitypackage).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following scenes – doorScene and menuScene – to the project Build (the
    sequence doesn't matter).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the scene currently open is menuScene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Display the Test Runner panel by choosing the following menu: Window | General
    | Test Runner'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable playmode tests for all assemblies. Do this by displaying the drop-down
    menu in the top-right corner of the Test Runner panel, and selecting Enable playmode
    tests for all assemblies (click OK to any message concerned with restarting the
    editor).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now restart the Unity Editor (just close the application and then reopen it
    with your project).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the PlayMode button is selected in the Test Runner panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, select the top-level folder Assets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Test Runner panel, click the "Create PlayMode Test Assembly Folder" button.
    A new folder, named Tests, should have been created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, open the `Tests` folder. It should contain an assembly
    definition file `Tests.asmdef`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Test Runner panel, click the "Create Test Script in the current folder"
    button. Rename this script class `DoorTest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `DoorTest.cs` script class, replacing the content with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following test method to `DoorTest.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following test method to `DoorTest.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following test method to `DoorTest.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Click Run All.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the tests run, you will see first in the Hierarchy, Game and Scene panels
    that a temporary scene is created, then the doorScene running, with the sphere
    rolling toward the red door.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see the results of your unit test being executed – if all tests are
    concluded successfully, there should be green ticks (check marks) next to each
    test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You added two scenes to the build, so they can be selected in our scripts using
    the SceneManager during PlayMode testing.
  prefs: []
  type: TYPE_NORMAL
- en: We opened the menuScene so that we can clearly see when Unity runs different
    scenes during our PlayMode testing – and we'll see the menu scene reopened after
    testing takes place.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a `SetUp()` method that is executed before each test. SetUp and TearDown
    methods are very useful for preparing things before each test, and resetting things
    back to how they were before the test took place. Unfortunately, aspects such
    as loading our door scene before running each test, and then reloading the menu
    after each test, involve waiting until the scene load process has completed. We
    can''t place yield statements in our `SetUp()` and `TearDown()` methods, so you''ll
    see each test has repeated scene loading at the beginning and end of each test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For each test, we wait, either for a single frame (yield `null`), or for a few
    seconds (yield `return new WaitForSeconds(...)`). This ensures that all objects
    have been created and physics is started before our test starts running. The first
    two tests check the initial conditions, in other words, that the door begins in
    the DoorClosed animation state, and that the Animation Controller's `isOpening`
    variable is false.
  prefs: []
  type: TYPE_NORMAL
- en: The final test waits for a few seconds (which is enough time for the sphere
    to roll up to the door and trigger the opening animation), and tests that the
    door is entering/has entered the DoorOpen animation state, and that the Animation
    Controller's `isOpening` variable is true.
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen, there is quite a bit more to PlayMode testing than Unit Testing,
    but it means that we have a way to test actual GameObject interactions when features
    such as timers and physics are running. As this recipe demonstrates, we can also
    load our own scenes for PlayMode testing, be they special scenes created just
    to test interactions, or actual scenes that are to be included in our final game
    build.
  prefs: []
  type: TYPE_NORMAL
- en: PlayMode and Unit Testing a player health bar with events, logging, and exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we combine many different kinds of tests on a feature of many
    games – a visual health bar representing the player's numeric health value (in
    this case, a float number from 0.0 - 1.0). Although far from comprehensively testing
    all aspects of the health bar, this recipe gives a good sample of how we can go
    about testing many different parts of a game using the Unity Testing tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Unity Package is provided that contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Player.cs`: a player script class, managing values for player health, and
    using delegates-and-events to publish health changes to any listening **View**
    classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two **View** classes that register to listen for player health change events:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HealthBarDisplay.cs`: this updates the fillAmount for a UI image for each
    new player health value received'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HealthChangeLogger.cs`: this prints messages about the new player health value
    received to the Debug.Log file'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlayerManager.cs`: a manager script, which initializes player and HealthChangeLogger
    objects, and also allows the user to change the health of the player by pressing
    the Up and Down arrow keys (simulating healing/damage during a game)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A scene that has 2 UI images – one is a health bar outline (red heart and a
    black outline), the second is the filler image – showing dark blue to light blue
    to green, for weak to strong health values)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This recipe allows several different kinds of testing to be demonstrated:'
  prefs: []
  type: TYPE_NORMAL
- en: PlayMode testing, to check that the actual `fillAmount` of the UI image displayed matches
    the 0.0 ... 1.0 range of the player's health
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit Testing, to check that player health starts with the correct default value,
    and correctly increases and decreases after calls to the `AddHealth(...)` and `ReduceHealth(...)`
    methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing, to check that health change events are published by the player
    object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing, to check that expected messages are logged in the `Debug.Log`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unit testing, to check that argument out-of-range exceptions are thrown if
    negative values are passed to the player''s `AddHealth(...)` or `ReduceHealth(...)`
    methods. This is demonstrated in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/f66aebf7-313f-4a0a-88bd-41d1a7b04dae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Thanks to Pixel Art Maker for the health bar image: [http://pixelartmaker.com/art/49e2498a414f221](http://pixelartmaker.com/art/49e2498a414f221)'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, a Unity Package has been provided (`healthBarScene.unitypackage`)
    in the `19_07` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To PlayMode and Unit Test a player health bar, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Unity project, create a new empty scene, and delete the default
    folder Scenes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the Unity package provided (`healthBarScene.unitypackage`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the HealthBarScene scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add HealthBarScene to the project Build (menu: File | Build Settings ...).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Display the Test Runner panel by choosing the following menu: Window | General
    | Test Runner.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable PlayMode tests for all assemblies. Do this by displaying the drop-down
    menu in the top-right corner of the Test Runner panel, and selecting Enable playmode
    tests for all assemblies (click OK to any message concerned with restarting the
    editor).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now restart the Unity Editor (just close the application and then reopen it
    with your project).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the PlayMode button is selected in the Test Runner panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, select the top-level folder Assets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Test Runner panel, click the "Create PlayMode Test Assembly Folder" button.
    A new folder, named Tests, should have been created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the Assets folder is selected in the Project panel. Create a new
    folder named PlayModeTests (this should now appear in the Assets folder).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the PlayModeTests folder is selected in the Project panel. In the
    Test Runner panel, click the "Create Test Script in the current folder" button.
    Rename this script class `HealthBarPlayModeTests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `HealthBarPlayModeTests.cs` script class, replacing the content with
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following test in `HealthBarPlayModeTests.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Click Run All.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the tests run, you will see first in the Hierarchy, Game and Scene panels
    that a temporary scene is created, then the HealthBarScene running, with the visual
    health bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see the results of your PlayMode Test being executed – if the test
    is concluded successfully, there should be a green tick (check mark).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the Assets folder is selected in the Project panel. Create a new
    folder named Editor (this should now appear in the Assets folder).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the Editor folder is selected in the Project panel. In the Test
    Runner panel, click the "Create Test Script in the current folder" button. Rename
    this script class `EditModeUnitTests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `EditModeUnitTests.cs` script class, replacing the content with the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following class and basic tests inside the `EditModeUnitTests` class
    in `EditModeUnitTests.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following class and limit test inside the `EditModeUnitTests` class
    in `EditModeUnitTests.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following class and event tests inside the `EditModeUnitTests` class
    in `EditModeUnitTests.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following class and exception tests inside the `EditModeUnitTests`
    class in `EditModeUnitTests.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following class and logging tests inside the `EditModeUnitTests` class
    in `EditModeUnitTests.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the inner classes allow grouping of the unit tests visually
    in the Test Runner panel
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/640546ed-4ddc-44c9-9a49-5638af8a756c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at how it works in detail.
  prefs: []
  type: TYPE_NORMAL
- en: PlayMode testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PlayMode test `TestHealthBarImageMatchesPlayerHealth()` loads the `HealthBar`
    scene, gets a reference to the instance-object of PlayerManager, which is a component
    of the GameObject tagged PlayerManager, and invokes the `ReduceHealth()` method.
    This method reduces the player's health by 0.1, so from its starting value of
    1.0, it becomes 0.9.
  prefs: []
  type: TYPE_NORMAL
- en: The PlayerManager GameObject also has as a component an instance object of the
    C# `HealthBarDisplay` script class. This object registers to listen to published
    events from the player class. It also has a public UI Image variable that has
    been linked to the UI Image of the health bar filler image in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: When the player's health is reduced to 0.9, it publishes the `OnChangeHealth(0.9)`
    event. This event is received by the `HealthBarDisplay` object instance, which
    then sets the fillAmount property of the linked health bar filler image in the
    scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TestHealthBarImageMatchesPlayerHealth(`) PlayMode test gets a reference
    to the object instance named image-health-bar-filler, storing this reference in
    the `healthBarFiller` variable. The test assertion made is that the expectedResult
    value of 0.9 matches that actual fillAmount property of the UI Image in the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several unit tests, grouped by placing them inside their own classes,
    inside the `EditModeUnitTests` script class.
  prefs: []
  type: TYPE_NORMAL
- en: '`TestCorrectValues` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DefaultHealthOne()`: this tests that the default (initial value) of the player''s
    health is 1'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HealthCorrectAfterReducedByPointOne()`: this tests that when the player''s
    health is reduced by 0.1, it becomes 0.9'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HealthCorrectAfterReducedByHalf()`: this tests that when the player''s health
    is reduced by 0.5 it becomes 0.5'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'class `TestLimitNotExceeded`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HealthNotExceedMaximumOfOne()`: this tests that the value of the player''s
    health does not exceed 1, even after attempts to add 1, 0.5, and 0.1 to its initial
    value of 1'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'class `TestEvents`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CheckEventFiredWhenAddHealth()`: this tests that an OnChangeHealth() event
    is published when the player''s health is increased'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CheckEventFiredWhenReduceHealth()`: this tests that an OnChangeHealth() event
    is published when the player''s health is decreased'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'class `TestLogging`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CorrectDebugLogMessageAfterHealthReduced()`: this tests that a Debug.Log message
    is correctly logged after the player''s heath is reduced by 0.1 to 0.9'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'class `TestExceptions`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Throws_Exception_When_Add_Health_Passed_Less_Than_Zero()`: this tests that
    an ArgumentOutOfRangeException is thrown when a negative value is passed to the
    AddHealth(...) player method'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Throws_Exception_When_Reduce_Health_Passed_Less_Than_Zero()`: this tests that
    an ArgumentOutOfRangeException is thrown when a negative value is passed to the
    ReduceHealth(...) player method'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These two tests illustrate one convention of naming tests that adds an underscore
    _ character between each word in the method name in order to improve readability.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Learn more about the LogAssert Unity Script reference in the Unity documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/ScriptReference/TestTools.LogAssert.html](https://docs.unity3d.com/ScriptReference/TestTools.LogAssert.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The method for unit testing C# events is adapted from a post on philosophicalgeek.com:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.philosophicalgeek.com/2007/12/27/easily-unit-testing-event-handlers/](http://www.philosophicalgeek.com/2007/12/27/easily-unit-testing-event-handlers/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The delegate-event publishing of health change events in this health bar feature
    is an example of the Publisher-Subscriber design pattern. Learn more about design
    patterns and their implementations for Unity games in `Chapter 17`, Extra Features
    and Design Patterns.
  prefs: []
  type: TYPE_NORMAL
