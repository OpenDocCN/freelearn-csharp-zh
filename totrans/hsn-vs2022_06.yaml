- en: 'Chapter 5: Debugging and Compiling Your Projects'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As software developers, one skill that should be learned as early as possible
    is program debugging. This applies to .NET projects but also any other software
    development technology.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to get the most out of Visual Studio 2022, you must be familiar
    with its different windows that can help you observe information to fix bugs and
    know how to use as many of the debugging tools it offers, including **breakpoints**.
    A breakpoint offers the functionality to stop the execution of an application,
    allowing you to see the state of each of the objects and corroborate its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: That is why, in this chapter, we will talk about debugging in Visual Studio
    2022, the different breakpoints available, the state inspection tools, and which
    are the best scenarios for each one of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will discuss in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging projects in Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring breakpoints in Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspection tools for debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's learn about debugging in Visual Studio 2022 to detect possible errors
    in our programs.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples shown in this chapter, Visual Studio 2022 must be installed
    with the web development workload, as shown in [*Chapter 1*](B17873_01_ePub.xhtml#_idTextAnchor013),
    *Getting Started with Visual Studio 2022*.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, the code implementation will be performed on the project created in
    [*Chapter 4*](B17873_04_ePub.xhtml#_idTextAnchor052), *Creating Projects and Templates*,
    specifically in the `Program.cs` file, for easier testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the `Program.cs` file with the changes made throughout this chapter
    at the following link: [https://github.com/PacktPublishing/Hands-On-Visual-Studio-2022/blob/main/Chapter05/Program.cs](https://github.com/PacktPublishing/Hands-On-Visual-Studio-2022/blob/main/Chapter05/Program.cs).'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging projects in Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before discussing the breakpoint topic in depth in the *Exploring breakpoints
    in Visual Studio 2022* section, it is important that you know some technical aspects
    used in the debugging world, as well as in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the technical aspects of debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important that you know the difference between the terms debugger and
    debugging so that you know what I mean when I mention any of these terms during
    the chapter and the book.
  prefs: []
  type: TYPE_NORMAL
- en: First, the term debugging refers to the action of looking for errors in the
    code. This does not necessarily include the use of a tool such as an IDE. You
    could, for example, search for errors in code written on a piece of paper, and
    you would still be debugging.
  prefs: []
  type: TYPE_NORMAL
- en: This is usually not feasible, and a tool called a debugger is often used. This
    tool is attached to the application process you are going to run, allowing you
    to analyze your code while the application is running.
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating between debug mode and run mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is essential to differentiate between debug mode and run mode in Visual Studio,
    as they can be confusing to those who touch the IDE for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first analyze debug mode. This option is activated by selecting the
    **Debug** configuration (which is preselected by default) and clicking on the
    green button located in the same space as the project name, as shown in *Figure
    5.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Visual Studio''s debug mode option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.01_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Visual Studio's debug mode option
  prefs: []
  type: TYPE_NORMAL
- en: When this option is pressed, the debugger will be attached to the execution
    of the application, which will allow us to use functions, such as stopping at
    a certain breakpoint in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we can also choose a second configuration in the drop-down
    list, as shown in *Figure 5.2*, called **Release**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Visual Studio''s release mode option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.02_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Visual Studio's release mode option
  prefs: []
  type: TYPE_NORMAL
- en: When this option is selected and we proceed to start the execution of the application,
    the debugger will not be attached, which will give you a better idea of how your
    application will behave toward the end user. This implies that you will not be
    able to perform code debugging or see where exceptions have occurred, but you
    will gain a performance improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Project debugging initialization options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As part of the debugging and execution options of an application, we must know
    that we have a set of options available to perform our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you drop down the options next to the green button with the name of your
    project, as shown in *Figure 5.3*, you will be able to see a set of configurations
    for the deployment of your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The server configuration options for debugging'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.03_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – The server configuration options for debugging
  prefs: []
  type: TYPE_NORMAL
- en: For example, the first three options are used to choose which server you want
    to use for testing. By default, a server called **Kestrel** is used. But it is
    also possible to use **IIS Express**, or even **WSL**, if your application is
    more oriented to Linux-based environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 5.4*, we can observe the following options to change the browser,
    enable script debugging, and view the debugging properties of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Additional options for debugging'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.04_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – Additional options for debugging
  prefs: []
  type: TYPE_NORMAL
- en: These options are useful if, for example, you want to use a particular browser
    to use some of its own tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the application has been configured in debug mode, you will see the buttons
    that allow you to control the execution of the application in the upper part of
    the IDE, as shown in *Figure 5.5*. These buttons, from left to right, are used
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Pause the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restart the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Buttons to control the flow of the application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.5_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – Buttons to control the flow of the application
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the existing debugging concepts in Visual Studio, let's analyze
    breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring breakpoints in Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Breakpoints are a fundamental part of software development. They allow you to
    stop the flow of your application at any point you want to inspect the state of
    your objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To place a breakpoint in Visual Studio, it is enough that we position ourselves
    right next to the numbering of the lines. This will start showing a gray circle
    that will appear and disappear as we move the cursor over the line numbers, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – The location for placing breakpoints in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.06_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – The location for placing breakpoints in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we find the line we want to debug, we just need to left-click once, which
    will cause the circle to turn red, as shown in *Figure 5.7*. Once you have done
    this, if you move the cursor away from the circle, you will be able to see how
    it remains as it is, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Placing a breakpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.07_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – Placing a breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'If we proceed to execute the application with the breakpoint set, we will see
    how the application flow stops immediately after starting the application, as
    shown in *Figure 5.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Debugging a breakpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.08_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – Debugging a breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the application has stopped at the breakpoint, we have different tools
    available that we can use to view the status of the application – for example,
    if we position over a variable that is before the debug line, we will be able
    to see its current status. If it is primitive data, you will see its value immediately,
    while if it is an object, you will be able to go inside its properties to examine
    each one of them, as shown in *Figure 5.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Examining the properties of an object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.09_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.9 – Examining the properties of an object
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more options to place breakpoints – for example, if you place yourself
    on one of the gray circles and click on it with the right button, a series of
    breakpoints will appear, which we will analyze in the *Conditional breakpoints*,
    *Temporary breakpoints*, and *Dependent breakpoints* sections so that you can
    insert them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – The options for inserting a breakpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.10_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.10 – The options for inserting a breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, if you right-click on any breakpoint already placed, you will see
    options to add functionalities to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – The menu for modifying breakpoints'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.11_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.11 – The menu for modifying breakpoints
  prefs: []
  type: TYPE_NORMAL
- en: This is the easiest way to add breakpoints to your project. However, you will
    often need special breakpoints that are activated under certain circumstances,
    so we will proceed to review them in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio has keyboard shortcuts created for almost all the operations we
    are going to be performing. So, I will mention them for you as *notes*, as we
    move forward throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to enter a breakpoint quickly by placing yourself on the line
    you want to debug and pressing the *F9* key.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating between breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we know how to place breakpoints in the source code, we can continue the
    execution of the application in different ways through the buttons located in
    the upper part of the menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – The debugging options for application execution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.12_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.12 – The debugging options for application execution
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of them will execute the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step into**: This allows us to execute all the source code line by line.
    If, as part of the flow, we invoke methods to which we have access through the
    source code, we will navigate to it automatically following the line-by-line debugging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step over**: This allows us to only walk through lines of code in the current
    method and not step into any methods invoked by the current method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step out**: This button is used in case we are inside a method. It will allow
    us to step out of the execution of the method to return just to the line after
    the invocation of the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Each of these options has a shortcut assigned to it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Step into: the *F11* key'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Step over: the *F10* key'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Step out: *Shift* + *F11* keys'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we wish to examine all the breakpoints we have in our project, we can do
    it by activating the breakpoints window. This is done from the **Debug** | **Windows**
    | **Breakpoints** menu, as seen in *Figure 5.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – The option to display the breakpoint window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.13_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.13 – The option to display the breakpoint window
  prefs: []
  type: TYPE_NORMAL
- en: This will display a new window that shows a list of all breakpoints placed in
    our project.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are times when you will need your breakpoint to stop when certain conditions
    are met. In this case, using conditional breakpoints is the best option. To insert
    a breakpoint of this type, just right-click on the sidebar, which will show you
    the different types of breakpoints available, as shown in the *Navigating between
    breakpoints* section. Select the **Conditional Breakpoint** type, which will open
    a window with preselected options, as shown in *Figure 5.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – The options for conditional breakpoints'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.14_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.14 – The options for conditional breakpoints
  prefs: []
  type: TYPE_NORMAL
- en: Within a conditional breakpoint, we can configure either a **Conditional Expression**
    condition, a **Hit Count** condition, or a **Filter** condition, which we will
    discuss in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: To insert a conditional expression, you can use the *Alt* + *F9* keys, followed
    by the *C* key.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Expression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Conditional Expression** option, as shown in *Figure 5.15*, will allow
    us to stop the application when a true condition that we have previously specified
    is fulfilled, or when the value of an object changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – The types of expression that can be evaluated with conditional
    expressions](img/Figure_5.15_B17873.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – The types of expression that can be evaluated with conditional
    expressions
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, we can specify a Boolean expression, ranging from the comparison
    of a pair of values to the comparison of complex objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 5.17*, a `for` loop has been created that prints the numbers from
    `1` to `10` to have a better appreciation of the example. Also, I have placed
    a pin on the `i` variable, which you can place by simply hovering over any variable
    while the application is running and clicking on the pin symbol, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – The types of expressions that can be evaluated with conditional
    expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.16_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.16 – The types of expressions that can be evaluated with conditional
    expressions
  prefs: []
  type: TYPE_NORMAL
- en: 'As a condition, we have indicated that we only want to stop the application
    when the value of `i` is greater than the number `5`. After starting the application,
    the breakpoint has stopped, just when `i` has a value of `6`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Debugging a conditional expression'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.17_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.17 – Debugging a conditional expression
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second case, we can monitor an object, property, or field so that the
    breakpoint stops only when it changes. This can be seen in a practical way in
    *Figure 5.18*, in which the `i` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – Evaluating a conditional expression with the When changed parameter'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.18_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.18 – Evaluating a conditional expression with the When changed parameter
  prefs: []
  type: TYPE_NORMAL
- en: As a result, when the breakpoint is executed for the first time, the value of
    `i` is equal to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Hit Count
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `25`, as we can see in *Figure 5.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Evaluating a Hit Count expression'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.19_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.19 – Evaluating a Hit Count expression
  prefs: []
  type: TYPE_NORMAL
- en: This will cause the application to stop when `i` has a value of exactly `25`.
  prefs: []
  type: TYPE_NORMAL
- en: Filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last type of conditional breakpoint is the **Filter** condition. This will
    allow us to trigger a breakpoint according to a series of predefined expressions.
    These expressions can be found in the **Filter** box, as shown in *Figure 5.20*,
    and range from the machine name, through processes, to thread properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – The options for a Filter condition'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.20_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.20 – The options for a Filter condition
  prefs: []
  type: TYPE_NORMAL
- en: These are the types of conditional breakpoints, which are very useful for performing
    value comparisons. Now, let's look at function breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Function breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Function Breakpoint** type, as its name indicates, will allow us to debug
    a method when it is executed, even if we have not set a breakpoint as we did in
    the *Conditional breakpoints* section. This is very useful if you have hundreds
    of lines of code and know the name of the function that you want to debug.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the breakpoints we saw in the *Conditional breakpoints* section, this
    breakpoint is placed in a different way. First, as seen in *Figure 5.21*, you
    can go to the **Debug** | **New Breakpoint** | **Function Breakpoint** menu and
    insert in the window the name of the function in which we want to set the breakpoint,
    instead of placing the red dot in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21 – Adding a function breakpoint from the Debug menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.21_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.21 – Adding a function breakpoint from the Debug menu
  prefs: []
  type: TYPE_NORMAL
- en: 'The next way is to add a breakpoint function from the **Breakpoints** window,
    as shown in *Figure 5.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22 – Adding a function breakpoint from the Debug menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.22_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.22 – Adding a function breakpoint from the Debug menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we click on the `Program.cs` file, which has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we know the name of the function to be evaluated, we can enter it in the
    **Function Name** box. We can do this in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Typing the name of the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the function name with a specific overload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the `dll` name if we have the source code for it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our example, we will place only the name of the `StopHere` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23 – Filling in the name of the function we are interested in debugging'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.23_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.23 – Filling in the name of the function we are interested in debugging
  prefs: []
  type: TYPE_NORMAL
- en: 'With the data established, we will proceed to execute the application, having
    previously called this new method. This will cause the application to stop at
    the start of the method (which we specified in *Figure 5.23*), as seen in *Figure
    5.24*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24 – A demonstration of the breakpoint being executed through a
    function breakpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.24_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.24 – A demonstration of the breakpoint being executed through a function
    breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to add a function breakpoint by pressing the *Ctrl* + *K* keys,
    followed by the *B* key.
  prefs: []
  type: TYPE_NORMAL
- en: Undoubtedly, this type of breakpoint will make our life easier when we want
    to debug methods quickly. In case you want to trigger breakpoints based on the
    data of an object, you can use the data breakpoints, which we will see next.
  prefs: []
  type: TYPE_NORMAL
- en: Data breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to be able to place breakpoints when the properties of an object
    change, then data breakpoints are your best option. If you try to add one of these
    breakpoints from the **Breakpoints** window, you will see that the option is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because we first need to place a breakpoint at a point before we want
    to start monitoring the property. Once this is done, start the application until
    the breakpoint is activated, and in one of the windows called `EnvironmentName`
    property of the `app` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25 – Adding a data breakpoint to break when the EnvironmentName
    property changes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.25_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.25 – Adding a data breakpoint to break when the EnvironmentName property
    changes
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we select the option, we will see how a new breakpoint is created automatically,
    which will detect when the property we have specified changes, as shown in *Figure
    5.26*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.26 – The data breakpoint being created in the Breakpoints window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.26_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.26 – The data breakpoint being created in the Breakpoints window
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say, subsequently, we proceed to modify the property data – for example,
    through the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run the application, we will see how the breakpoint previously
    placed is reached, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.27 – A demonstration of a break when the property has been changed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.27_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.27 – A demonstration of a break when the property has been changed
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will see that when you restart the application or stop it, the
    breakpoint will disappear from the window. This is because the object reference
    is lost.
  prefs: []
  type: TYPE_NORMAL
- en: Dependent breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This type of breakpoint is a special breakpoint that will only be executed if
    another breakpoint is reached first. Perhaps in a simple scenario, it is not very
    useful, but in complex scenarios, where hundreds of functionalities come into
    play, it can be of great help.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine that you have a method that is invoked in several places
    in your application, and you are testing a new functionality that invokes it.
    If you were to place a normal breakpoint on the method, it would stop every time
    it is invoked. With a dependent breakpoint, you can specify that you only want
    to stop execution if the breakpoint of your new functionality is reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this functionality, I have added a couple of methods to the
    `Program.cs` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea of the `CommonMethod` function is that we can see the content of a
    string passed as a parameter and know at what point the breakpoint has stopped.
    With this in mind, let''s add some additional lines in which we will first call
    `CommonMethod`, then `NewMethod`, and finally, `CommonMethod` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To place a dependent breakpoint, we will first place a normal breakpoint in
    the line of code on which we want to depend – that is, the one that first must
    be executed for the dependent breakpoint to be executed. In our example, we will
    place it in the `NewMethod` functionality, since it is the method we want to test,
    as shown in *Figure 5.28*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.28 – The placement of the breakpoint on which a dependent breakpoint
    will depend'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.28_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.28 – The placement of the breakpoint on which a dependent breakpoint
    will depend
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you must right-click on the line where you want to create the dependent
    breakpoint, as shown in *Figure 5.29*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.29 – Inserting a dependent breakpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.29_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.29 – Inserting a dependent breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'This option will display the **Breakpoint Settings** window, where you will
    be asked which breakpoint you want to depend on to launch the dependent breakpoint.
    In our example, we will select the only breakpoint that is part of our project,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.30 – A list of breakpoints on which we can depend for dependent
    breakpoint execution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.30_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.30 – A list of breakpoints on which we can depend for dependent breakpoint
    execution
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this window is closed, you will see how a special breakpoint is created
    that (if you hover over it) will tell you on which other breakpoint it depends,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.31 – A view of a dependent breakpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.31_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.31 – A view of a dependent breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, when running the application, you will see how it stops first on the
    `NewMethod` call and not on `CommonMethod`, even though it has been invoked first.
    If you continue the execution, the dependent breakpoint will stop, showing the
    **After invocation of NewMethod()** message, as shown in *Figure 5.32*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.32 – The execution of a dependent breakpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.32_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.32 – The execution of a dependent breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this type of breakpoint can be very helpful to avoid constant
    method invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Temporary breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Temporary breakpoints, as their name indicates, are breakpoints that are automatically
    deleted once they are executed. To place one of these, you must right-click on
    the breakpoint line and select the **Insert Temporary Breakpoint** option, as
    shown in *Figure 5.33*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.33 – The menu to insert a temporary breakpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.33_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.33 – The menu to insert a temporary breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: If you run the application, you will see that once the application has stopped
    at the breakpoint, it will be automatically deleted. This type of breakpoint can
    be used when we want to evaluate, for example, the first iteration of a cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: To insert a temporary breakpoint quickly, use the *F9* + *Shift* + *Alt* keys,
    followed by the *T* key.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have examined the different types of breakpoints available in Visual
    Studio, let's see how we can take advantage of them using different inspection
    tools, which we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Inspection tools for debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with breakpoints, it is important that we know where to find the
    information we want to visualize and to know whether it is correct or not. For
    this, within Visual Studio, we have a series of windows that will allow us to
    visualize different types of information. So, let's look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Watch window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Watch** window will allow us to keep track of the values of variables
    or properties while we execute our code step by step. It is especially useful
    when we have pieces of code that are repeated several times, such as cycles or
    common methods. To access this window, we must first place a breakpoint in the
    code and execute the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the application stops at the breakpoint, we will be able to deploy the
    **Debug** | **Windows** menu. This will show us a set of new debugging windows
    that we can only access while running the application. Let''s select the **Watch**
    option to choose a window, as shown in *Figure 5.34*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.34 – The menu to reach the Watch windows'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.34_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.34 – The menu to reach the Watch windows
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the window has been opened, we can add the name of different variables
    and properties that we want to monitor. As long as we have entered a valid variable
    name for the scope we are in, we will be shown its corresponding value in the
    **Value** column, as shown in *Figure 5.35*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.35 – The monitoring of variable values and properties through the
    Watch window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.35_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.35 – The monitoring of variable values and properties through the Watch
    window
  prefs: []
  type: TYPE_NORMAL
- en: Another very simple way to add variables to a **Watch** window is to right-click
    on the variable you want to monitor when the application is running and select
    the **Add Watch** option.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: To access any **Watch** window quickly, you can use the *Ctrl* + *Alt* + *W*
    shortcut, followed by the window number (from *1* to *4*).
  prefs: []
  type: TYPE_NORMAL
- en: QuickWatch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `for` loop (seen in the *Hit Count* section), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.36 – The QuickWatch option from the Debug menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.36_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.36 – The QuickWatch option from the Debug menu
  prefs: []
  type: TYPE_NORMAL
- en: This option will activate a modal window, which means that we will not be able
    to continue running the application until we close it. In this window, we will
    be able to see data such as the name of the expression, the value, and the type
    of data we are evaluating.
  prefs: []
  type: TYPE_NORMAL
- en: 'Something very useful in this window is that we will be able to modify the
    expression. This means that we will be able to evaluate other variables and can
    even execute some operations that we want to test. In *Figure 5.37*, we see this
    in action, having entered a new expression to evaluate whether its result is `true`
    or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.37 – Modifying expressions in the QuickWatch window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.37_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.37 – Modifying expressions in the QuickWatch window
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, this offers a huge advantage, since we can test variables and
    properties that are quickly available in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: You can use the *Shift* + *F9* shortcut to access the **QuickWatch** window
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The Autos and Locals windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Autos** and **Locals** windows allow us to view information about variables
    and properties without the need to add them somewhere as with the **Watch** window.
  prefs: []
  type: TYPE_NORMAL
- en: However, these have a specific scope. While the **Autos** window shows the value
    of the variables around the breakpoint we have placed, the **Locals** window will
    show values only for the current scope – that is, usually the function or method
    in which the breakpoint is located.
  prefs: []
  type: TYPE_NORMAL
- en: Another important point about these windows is that they will only be shown
    when we run the application and after we have placed a breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the demonstration of this window pair, I have added a new method to our
    `Program.cs` file and placed a breakpoint, as shown in *Figure 5.38*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.38 – The TestLocalsAndAutos method, with a breakpoint placed to
    demonstrate the Locals and Autos windows](img/Figure_5.38_B17873.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.38 – The TestLocalsAndAutos method, with a breakpoint placed to demonstrate
    the Locals and Autos windows
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we invoke the method and only when the application is running, we will
    be able to display the windows through the **Debug** | **Windows** | **Autos**
    menu and the **Debug** | **Windows** | **Locals** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.39 – Accessing the Autos and Locals windows from the Debug menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.39_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.39 – Accessing the Autos and Locals windows from the Debug menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first examine the `i` and `currentString` variables, which belong to
    the `TestLocalsAndAutos` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.40 – The Locals window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.40_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.40 – The Locals window
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if we look at the `i` variable, since it is the information
    that is in the scope of the breakpoint, which means the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.41 – The Autos window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.41_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.41 – The Autos window
  prefs: []
  type: TYPE_NORMAL
- en: This pair of windows is tremendously useful to see all the available information
    on our variables at a glance.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to display these windows through the following shortcuts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Autos**: *Ctrl* + *D*, followed by the *A* key'
  prefs: []
  type: TYPE_NORMAL
- en: '**Locals**: *Ctrl* + *D*, followed by the *L* key'
  prefs: []
  type: TYPE_NORMAL
- en: Call stacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the use of windows that we saw in the *Watch window*, *QuickWatch*,
    and *The Autos and Locals windows* sections is the most-used method of error correction,
    we also have some others to keep track of the invocation flow between our methods.
  prefs: []
  type: TYPE_NORMAL
- en: One of such window is called **Call Stack**, which when we place a breakpoint,
    will show the stack of calls that have been made until arriving at the same one.
    To show the window, we must select the option from **Debug** | **Windows** | **Call
    Stack**. This menu item will only be available while the application is running,
    but if you want the window to show up for each debug session, you can use the
    thumbtack/pin icon to dock it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 5.42*, we have executed the same code as that in the *The Autos
    and Locals windows* section, stopping at the same breakpoint. As we can see in
    the following figure, the **Call Stack** window shows the line of code where we
    are once the application has stopped due to the breakpoint, as well as the set
    of calls between methods that have been made to reach the breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.42 – The Call Stack window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.42_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.42 – The Call Stack window
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 5.42*, we can also see the state of the application in each one of
    the calls if we double-click on any of them. This will allow us to see the values
    of properties and variables at some specific point in the flow of the application.
  prefs: []
  type: TYPE_NORMAL
- en: This will take us to the code section from where we invoke the method, and it
    will be highlighted with a different color so that we don't get confused with
    the colors of the breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: To display the **Call Stack** window, you can also press the *Ctrl* + *Alt*
    + *C* keys.
  prefs: []
  type: TYPE_NORMAL
- en: Immediate window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another window of great interest is the **Immediate** window. This window, which
    we can open from the **Debug** | **Windows** | **Immediate** menu, will allow
    us to make evaluations of expressions, execute statements, and print values of
    variables and properties.
  prefs: []
  type: TYPE_NORMAL
- en: When you open this window, you will surely be surprised to see nothing inside
    it. This is because this window will allow you to write on it, to enter the name
    of a variable or property, and even invoke methods (if they are within the scope),
    added to the fact that you will have available all the potential of IntelliSense
    while you write your expressions. IntelliSense is Visual Studio's auto-completion
    help enhanced with artificial intelligence, and we will talk more about it in
    [*Chapter 7*](B17873_07_ePub.xhtml#_idTextAnchor088), *Coding Efficiently with
    AI and Code Views*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 5.43*, the invocation of the `TestLocalsAndAutos` method has been
    executed again, and we have obtained a substring of the main `currentString` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.43 – The Immediate Window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.43_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.43 – The Immediate Window
  prefs: []
  type: TYPE_NORMAL
- en: A great advantage of this window is that we can execute as many expressions
    as we want, keeping all the list of results we obtain, as well as the expressions
    entered.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: You can display the **Immediate** window if you press the *Ctrl* + *Alt* + *I*
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio has many options for debugging source code. In this chapter, we
    have learned what breakpoints are, the different types of breakpoints, and the
    associated windows that we can activate to keep track of data in variables and
    properties. This information has been of utmost importance, since it will help
    you to solve problems in your code when you face them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [*Chapter 6*](B17873_06_ePub.xhtml#_idTextAnchor081)*,
    Adding Code Snippets*, you will learn about the concept of code snippets, which
    allow you to reuse common pieces of code across different projects, quickly adjusting
    them to your needs.
  prefs: []
  type: TYPE_NORMAL
