<html><head></head><body>
<div><h1 class="chapterNumber">15</h1>
<h1 class="chapterTitle" id="_idParaDest-302">Applying Service-Oriented Architectures with .NET</h1>
<p class="normal">The term <strong class="keyWord">Service-Oriented Architecture</strong> (<strong class="keyWord">SOA</strong>) refers to a modular architecture where interaction between system components is<a id="_idIndexMarker1061"/> achieved through communication. This approach has evolved for years and is now the basis of all communication between systems over the Internet. SOA allows applications from different organizations to exchange data and transactions automatically. Besides that, it allows organizations to offer services on the Internet. For instance, in a banking application, SOA can allow separate services for account management, transaction processing, and customer support to communicate seamlessly. More than that, it can enable suppliers to access customer support directly.</p>
<p class="normal">Moreover, as we discussed in <em class="italic">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>, communication-based interaction solves the binary compatibility and version mismatch problems that inevitably appear in complex systems made up of modules that share the same address space. Moreover, with SOA and its pattern of communication, you do not need to deploy different copies of the same component in the various systems/subsystems that use it – each component only needs to be deployed in one place, even if they<a id="_idIndexMarker1062"/> are written in different programming languages, simplifying the overall cycle of <strong class="keyWord">Continuous Integration/Continuous Delivery</strong> (<strong class="keyWord">CI/CD</strong>).</p>
<p class="normal">If a newer version conforms to the communication interface that is declared to the clients, no incompatibilities can occur. For instance, if you have a backend service that calculates tax based on a specific rule and the entry of selling data, if the specific rule changes, but the selling data doesn’t, you will be able to update the service without changing the application in the clients. On the other hand, with DLLs/packages, when the same interface is maintained, incompatibilities may arise because of possible version mismatches in terms of the dependencies of other DLLs/packages that the library module might have in common with its clients.</p>
<p class="normal">Organizing clusters/networks of cooperating services was discussed in <em class="italic">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>. In this chapter, we will focus on the two main communication interfaces used all over the world. More specifically, we will discuss the following topics:</p>
<ul>
<li class="bulletList">Understanding the principles of the SOA approach</li>
<li class="bulletList">SOAP and REST web services</li>
<li class="bulletList">How does .NET 8 deal with SOA?</li>
</ul>
<p class="normal">By the end of this chapter, you will know how to publicly expose data from an application through an ASP.NET Core service.</p>
<h1 class="heading-1" id="_idParaDest-303">Technical requirements</h1>
<p class="normal">This chapter requires the Visual Studio 2022 free Community edition or better with all the database tools installed.</p>
<p class="normal">All the concepts in this chapter will be clarified with practical examples based on the WWTravelClub book use case, located in <em class="italic">Chapter 21, Case Study</em>. You will find the code for this chapter at <a href="https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E">https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E</a>.</p>
<h1 class="heading-1" id="_idParaDest-304">Understanding the principles of the SOA approach</h1>
<p class="normal">Like classes in an object-oriented architecture, services are implementations of interfaces that, in turn, come from a system’s functional specifications. Therefore, the first step in <em class="italic">service</em> design is the definition of its <em class="italic">abstract interface</em>. During this initial stage, you might have two<a id="_idIndexMarker1063"/> approaches:</p>
<ul>
<li class="bulletList">Define all the service operations as interface methods that operate on the types of your favorite language (C#, Java, C++, JavaScript, and so on) and decide which operations to implement with synchronous communication and which ones to implement with asynchronous communication.</li>
<li class="bulletList">Create the contract first in an interoperable format. In this approach, you can use definition files using patterns like OpenAPI, Protobuf, WSDL, and AsyncAPI without touching the programming language with which the services will be developed, using some tools to help.</li>
</ul>
<p class="normal">The interfaces that are defined in this initial stage will not necessarily be used in the actual service implementation and are just useful design tools. Once we have decided on the architecture of the services, these interfaces are usually redefined so that we can adapt them to the peculiarity of the architecture.</p>
<p class="normal">It is worth pointing out that<a id="_idIndexMarker1064"/> SOA messages must keep the same kind of semantics as method calls/answers. Besides, SOA follows stateless development; that is, the reaction to a message must not depend on any previously received messages because the server does not save information from prior requests, which means the messages must be independent of each other.</p>
<p class="normal">For instance, if the purpose of messages is to create a new database entry, this semantic must not change with the context of other messages, and the way the database entry is created must depend on the content of the current message and not on other previously received messages. Consequently, a client cannot create sessions and cannot log in to a service, perform some operations, and then log out. An authentication token must be repeated in each message.</p>
<p class="normal">The reasons for this constraint are modularity, testability, and maintainability. In fact, a session-based service would be very hard to test and modify due to the interactions that are <em class="italic">hidden</em> in the session data.</p>
<p class="normal">Once you have decided on the interface that is going to be implemented by a service, you must decide which communication stack/SOA to adopt. The communication stack must be part of some official or <em class="italic">de facto</em> standard to ensure the interoperability of the service.</p>
<div><p class="normal">Interoperability is the main constraint prescribed by SOA: services must offer a communication interface that does not depend on a specific library used, implementation language, or deployment platform.</p>
</div>
<p class="normal">Considering you have decided on the communication stack/architecture, you need to adapt your previous interfaces to the peculiarities of the architecture (see the <em class="italic">REST web services</em> subsection of this chapter for more details). Then, you must translate these interfaces into the chosen communication language. This means that you must map all the programming language types into types that are available in the chosen communication language.</p>
<p class="normal">The actual translation of data is usually performed automatically by the SOA libraries that are used by your development environment. However, some configuration might be needed, and, in any case, we must be aware of how our programming language types are transformed before each communication. For instance, some numeric types might be transformed into types with less precision or with different ranges of values. In .NET 8, for instance, you should be <a id="_idIndexMarker1065"/>aware that floating-point numeric types vary between <strong class="keyWord">float</strong> (~6-9 digits), <strong class="keyWord">double</strong> (~15-17 digits), and <strong class="keyWord">decimal</strong> (~28-29 digits). You may consider the alternative of using string variables to reduce the risk of imprecision while transferring numeric types.</p>
<p class="normal">The interoperability constraint can be interpreted in a lighter form in the case of microservices that are not accessible outside of their clusters since they need to communicate with other microservices that belong to the same cluster. In this case, this means that the communication stack might be platform-specific so that it can increase performance, but it must be standard to avoid compatibility problems with other microservices that might be added to the cluster as the application evolves.</p>
<p class="normal">We have spoken of the <em class="italic">communication stack</em> and not of the <em class="italic">communication protocol</em> because SOA communication standards usually define the format of the message’s content and provide different possibilities for the specific protocol that is used to embed those messages. For instance, REST services usually run over HTTP/HTTPS based on JSON messages, while the SOAP protocol just defines an XML-based format for the various kinds of messages, but SOAP messages can be conveyed by various protocols. Usually, the most common protocol that is used for SOAP is also HTTP, but you may decide to jump to the HTTP level and send SOAP messages directly over TCP/IP for better performance.</p>
<p class="normal">The choice of communication stack you should adopt depends on several factors, as described below. When it comes to accessing data, maybe the communication stack will be mandatory and decided by the provider, but you should also be concerned about these factors when providing a service:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Compatibility constraints</strong>: If your service must be publicly available on the Internet to business clients, then you must conform to the most common choices, which means using SOAP over either HTTP or REST services. The most common choices are different if your clients are not business clients but <strong class="keyWord">Internet of Things</strong> (<strong class="keyWord">IoT</strong>) clients. Also, within IoT, the protocols that are used in different application areas <a id="_idIndexMarker1066"/>can be different. For instance, marine vehicle status data is typically exchanged with <em class="italic">Signal K</em>. Although this protocol is too specific and is presented here just as an example, as a software architect, you must understand that you may face this kind of standard in a specific area.</li>
<li class="bulletList"><strong class="keyWord">Development/deployment platform</strong>: Not all communication stacks are available on all development <a id="_idIndexMarker1067"/>frameworks and on all deployment platforms, but luckily, all the most common communication stacks that are used in public business services, such as SOAP- and JSON-based REST communication, are available on all the main development/deployment platforms.</li>
<li class="bulletList"><strong class="keyWord">Performance</strong>: If your system is not exposed to the outside world and is a private part of your microservice cluster, performance considerations have a higher priority. In this scenario, gRPC, which we will discuss soon in this chapter, can be noted as a good option.</li>
<li class="bulletList"><strong class="keyWord">Availability of tools and knowledge in your team</strong>: Knowing about the availability of tools in your team/organization is important when it comes to choosing between acceptable communication stacks.
    <p class="normal">However, this kind of constraint always has less priority than compatibility constraints since it makes no sense to conceive a system that is easy to implement for your team but that almost nobody can use.</p></li>
</ul>
<ul>
<li class="bulletList"><strong class="keyWord">Flexibility versus available features</strong>: Some communication solutions, while less complete, offer a higher degree of flexibility, while other solutions, though more complete, offer less flexibility. The need for flexibility started a movement from SOAP-based services to more flexible REST services in the last few years. This point will be discussed in more detail when we describe SOAP and REST services in the remainder of this section.</li>
<li class="bulletList"><strong class="keyWord">Service description</strong>: When services must be exposed on the Internet, client applications need a publicly available description of the service specifications to design their communication clients. Some communication stacks include languages and conventions to describe service specifications. Formal service specifications that are exposed this way can be processed so that they automatically create communication clients. SOAP goes further and allows service discoverability by means of a public XML-based directory containing information about the tasks each web service can carry out.</li>
</ul>
<p class="normal">Once you have chosen the communication stack you wish to use, you must use the tools that are available in your development environment to implement the service in a way that conforms to the chosen communication stack. Sometimes, communication stack compliance is automatically ensured by the development tools, but sometimes, it may require some development effort. For instance, in the .NET world, the compliance of SOAP services is automatically ensured by development tools if you use WCF, while the compliance of REST services falls under the developer’s responsibility, although you have, since .NET 5, automatic<a id="_idIndexMarker1068"/> support for the OpenAPI standard using Swagger. Some of the fundamental features of SOA solutions are as follows:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Authentication</strong>: Allows the client to authenticate to access service operations.</li>
<li class="bulletList"><strong class="keyWord">Authorization</strong>: Handles the client’s permissions.</li>
<li class="bulletList"><strong class="keyWord">Security</strong>: This is how communication is kept safe, that is, how to prevent unauthorized systems from reading and/or modifying the content of the communication. Typically, encryption prevents both unauthorized modifications and reading, while electronic signature algorithms prevent just modifications.</li>
<li class="bulletList"><strong class="keyWord">Exceptions</strong>: Returns exceptions to the client.</li>
<li class="bulletList"><strong class="keyWord">Message reliability</strong>: Ensures that messages reliably reach their destination in case of possible infrastructure faults.</li>
</ul>
<p class="normal">Though sometimes desirable, the following features are not always necessary:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Distributed transactions</strong>: The capability to handle distributed transactions, thus undoing all the changes you have made whenever the distributed transactions fail or are aborted.</li>
<li class="bulletList"><strong class="keyWord">Support for the Publisher/Subscriber pattern</strong>: If and how events and notifications are supported.</li>
<li class="bulletList"><strong class="keyWord">Addressing</strong>: If and how references to other services and/or methods are supported.</li>
<li class="bulletList"><strong class="keyWord">Routing</strong>: If and how messages can be routed through a network of services.</li>
</ul>
<p class="normal">The remainder of this section will describe SOAP services a bit. However, the focus will be REST services since today they are the <em class="italic">de facto</em> standard for business services that are exposed outside of their clusters/servers. For performance reasons, microservices use other protocols, discussed in <em class="italic">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>, <em class="italic">Chapter 14</em>, <em class="italic">Implementing Microservices with .NET</em>. For inter-cluster communication, <strong class="keyWord">Advanced Message Queuing Protocol</strong> (<strong class="keyWord">AMQP</strong>) is used, and<a id="_idIndexMarker1069"/> links are given in the <em class="italic">Further reading</em> section.</p>
<h1 class="heading-1" id="_idParaDest-305">SOAP web services</h1>
<p class="normal">The <strong class="keyWord">Simple Object Access Protocol</strong> (<strong class="keyWord">SOAP</strong>) allows both <a id="_idIndexMarker1070"/>one-way messages and request/reply messages. Communication can be both synchronous and asynchronous, as explained in <em class="italic">Chapter 1, Understanding the Importance of Software Architecture</em>, and <em class="italic">Chapter 2, Non-Functional Requirements</em>, but if the underlying protocol is synchronous, such as in the case of HTTP, the sender receives an acknowledgment <a id="_idIndexMarker1071"/>saying that the message was received (but not necessarily processed). When asynchronous communication is used, the sender must listen for incoming communications. Often, asynchronous communication is implemented with the Publisher/Subscriber pattern, which we described in <em class="italic">Chapter 6</em>, <em class="italic">Design Patterns and .NET 8 Implementation</em>.</p>
<p class="normal">Messages are represented as XML documents called <strong class="keyWord">envelopes</strong>. Each envelope contains <code class="inlineCode">header</code>, <code class="inlineCode">body</code>, and <code class="inlineCode">fault</code> elements. The <code class="inlineCode">body</code> is <a id="_idIndexMarker1072"/>where the actual content of the message is placed. The <code class="inlineCode">fault</code> element contains possible errors, so it is the way exceptions are exchanged when communication occurs. Finally, the <code class="inlineCode">header</code> contains any auxiliary information that enriches the protocol but does not contain domain data. For example, the <code class="inlineCode">header</code> may contain an authentication token and/or a signature if the message is signed.</p>
<div><p class="normal">You can find the default namespace for<a id="_idIndexMarker1073"/> the SOAP envelope at <a href="https://www.w3.org/2003/05/soap-envelope/">https://www.w3.org/2003/05/soap-envelope/</a>.</p>
</div>
<p class="normal">The underlying protocol that is used to send the XML envelopes is usually HTTP, since this is the protocol of the Internet, but the SOAP specification allows any protocol, so we can use TCP/IP or SMTP directly. As a matter of fact, the more diffused underlying protocol is HTTP, so if you do not have a good reason to choose another protocol, you should use HTTP to maximize the interoperability of the service.</p>
<h2 class="heading-2" id="_idParaDest-306">SOAP specifications</h2>
<p class="normal">SOAP specifications contain the <a id="_idIndexMarker1074"/>basics of message exchange, while other auxiliary features are described in separate specification documents called <code class="inlineCode">WS-</code> <code class="inlineCode">*</code> and are usually handled by adding extra information in the SOAP header. <code class="inlineCode">WS-*</code> specifications handle all the fundamental and desirable features of SOA we listed previously. We have some of them below:</p>
<table class="table-container" id="table001-4">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">WS-*</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Main objective</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">WS-Security </code></p>
</td>
<td class="table-cell">
<p class="normal">Takes care of security, including authentication, authorization, and encryption/signatures</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">WS-Eventing</code> / <code class="inlineCode">WS-Notification</code> </p>
</td>
<td class="table-cell">
<p class="normal">Two alternative ways of implementing the Publisher/Subscriber pattern</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">WS-ReliableMessaging </code></p>
</td>
<td class="table-cell">
<p class="normal">Concerned with the reliable delivery of messages in case of possible faults</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">WS-Transaction </code></p>
</td>
<td class="table-cell">
<p class="normal">Concerned with distributed transactions</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 15.1: Summary of Key WS-* Specifications and Their Main Objectives in SOAP-Based SOA</p>
<p class="normal">The preceding <code class="inlineCode">WS- *</code> specifications are in no way exhaustive but are the more relevant and supported features. In fact, actual implementations in various environments (such as Java and .NET) furnish the more relevant <code class="inlineCode">WS- *</code> services, but no implementation supports all the <code class="inlineCode">WS- *</code> specifications.</p>
<p class="normal">All the XML documents/document parts involved in the SOAP protocol are formally defined in XSD documents, like in the example below, which are special XML documents whose content provides a description of XML structures.</p>
<pre class="programlisting code"><code class="hljs-code">&lt;?xml version="1.0"?&gt;
&lt;xs:schema id="sample" targetNamespace="http://tempuri.org/sample.xsd" elementFormDefault="qualified" xmlns="http://tempuri.org/sample.xsd" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
&lt;xs:element name='mySample'&gt;
&lt;xs:complexType&gt;
&lt;xs:simpleContent&gt;
&lt;xs:extension base='xs:decimal'&gt;
&lt;xs:attribute name='sizing' type='xs:string' /&gt;
&lt;/xs:extension&gt;
&lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;
&lt;/xs:element&gt;
&lt;/xs:schema&gt;
</code></pre>
<p class="normal">Also, all your custom data structures (classes and interfaces in an object-oriented language) must be translated into XSD if they are going to be part of a SOAP envelope.</p>
<p class="normal">Each XSD specification has an associated <code class="inlineCode">namespace</code> that identifies the specification and a physical location where it can be found. Both the namespace and the physical location are URIs. The location URI does not need to be publicly accessible if the web service is accessible just from within an intranet.</p>
<p class="normal">The whole definition of a service is an XSD specification that may contain references to other namespaces, that is, to other XSD documents. Simply put, all the messages via SOAP communication must be defined in an XSD specification. Then, a server and a client can communicate if they<a id="_idIndexMarker1075"/> refer to the same XSD specifications. This means, for instance, that you need to create a new XSD specification each time you add another field to a message. After that, you need to update all the XSD files that reference the old message definition to the new message definition by creating a new version of them. In turn, these modifications require the creation of other versions for other XSD files, and so on. Therefore, simple modifications that maintain compatibility with the previous behavior (clients could simply ignore the field that was added) may cause an exponential chain of version changes.</p>
<h2 class="heading-2" id="_idParaDest-307">Difficulties associated with the standard</h2>
<p class="normal">In the last few years, the difficulty in handling modifications, along with the complexity of handling the configuration of all the <code class="inlineCode">WS- *</code> specifications and performance problems, caused a gradual move<a id="_idIndexMarker1076"/> toward the simpler REST services that we will describe in the upcoming sections. This move started with services that were called from JavaScript due to the difficulty of implementing complete SOAP clients that were able to run efficiently in a web browser. Moreover, the complex SOAP machinery was oversized for the simple needs of the typical clients running in a browser and may have caused a complete waste of development time.</p>
<p class="normal">For this reason, services aimed at non-JavaScript clients started a massive move toward REST services, and nowadays, the preferred choice is REST services, with SOAP being used either for compatibility with legacy systems or when features that are not supported by REST services are needed.</p>
<p class="normal">Today, we can consider REST services that transfer data with JSON, the most-used approach all over the world. Security aspects, design patterns for enabling transactional support, performance, and even documentation have improved all over the years, so this is certainly the best alternative<a id="_idIndexMarker1077"/> for applying SOAs nowadays. Let’s have a look at REST web services in the next topic. </p>
<h1 class="heading-1" id="_idParaDest-308">REST web services</h1>
<p class="normal">REST services were initially conceived to avoid the complex machinery of SOAP in simple cases, such as calls to a service from the JavaScript code of a web page. Then, they gradually became the preferred choice for <a id="_idIndexMarker1078"/>complex systems. REST services use HTTP to exchange data in JSON or, less commonly, in XML format. Simply put, they replace the SOAP body with the HTTP body, the SOAP header with the HTTP header, and the HTTP response code replaces the fault element and furnishes further auxiliary information on the operation that was performed.</p>
<p class="normal">The main reason for the success of REST services is that HTTP already offers most of the SOAP features natively, which means we can avoid building a SOAP level on top of HTTP. Moreover, the whole HTTP machinery is simpler than SOAP: simpler to program, simpler to configure, and simpler to implement efficiently.</p>
<p class="normal">Moreover, REST services impose fewer constraints on the clients. Type compatibility between servers and clients conforms to the more flexible JavaScript type compatibility model because JSON is a subset of JavaScript. Moreover, when XML is used in place of JSON, it maintains the same JavaScript type compatibility rules. No XML namespaces need to be specified.</p>
<p class="normal">When using JSON and XML, if the server adds some more fields to the response while keeping the same semantics of all the other fields compatible with the previous client, they can simply ignore the new fields. Accordingly, changes that are made to a REST service definition only need to be propagated to previous clients in the case of breaking changes that cause actual incompatible behavior in the server.</p>
<p class="normal">Moreover, it is likely that changes will be self-limited and won’t result in an exponential chain of changes because type compatibility does not require the reference to a specific type to be defined in a unique shared place and simply requires that the shape of types is compatible.</p>
<h2 class="heading-2" id="_idParaDest-309">Service type compatibility rules</h2>
<p class="normal">Let’s clarify the REST service type compatibility rules with an example. Imagine that several services use a <code class="inlineCode">Person</code> object that <a id="_idIndexMarker1079"/>contains <code class="inlineCode">Name</code>, <code class="inlineCode">Surname</code>, and <code class="inlineCode">Address</code> string fields. This object is served by <strong class="keyWord">S1</strong>:</p>
<pre class="programlisting code"><code class="hljs-code">{
    Name: string,
    Surname: string,
    Address: string
}
</code></pre>
<p class="normal">Type compatibility is ensured if the service and client refer to different copies of the preceding definition. It is also acceptable for the client to use a definition with fewer fields since it can simply ignore all the other fields:</p>
<pre class="programlisting code"><code class="hljs-code">{
    Name: string,
    Surname: string,
}
</code></pre>
<p class="normal">You can only use a definition with fewer fields within your “own” code. Attempting to send information back to the server without the expected fields may cause problems.</p>
<p class="normal">Now, imagine the scenario where you have an <strong class="keyWord">S2</strong> service that takes <code class="inlineCode">Person</code> objects from <strong class="keyWord">S1</strong> and adds them to the responses it returns on some of its methods. Suppose the <strong class="keyWord">S1</strong> service that handles the <code class="inlineCode">Person</code> object replaces the <code class="inlineCode">Address</code> string with a complex object:</p>
<pre class="programlisting code"><code class="hljs-code">{
    Name: string,
    Surname: string,
    Address:
        {
            Country: string,
            Town: string,
            Location: string
        }
}
</code></pre>
<p class="normal">After the breaking change, the <strong class="keyWord">S2</strong> service will have to adapt its communication client that calls the <strong class="keyWord">S1</strong> service to the new format. Then, it can convert the new <code class="inlineCode">Person</code> format into the older one before using <code class="inlineCode">Person</code> objects in its responses. This way, the <strong class="keyWord">S2</strong> service avoids propagating the breaking change of <strong class="keyWord">S1</strong>.</p>
<p class="normal">In general, basing type compatibility on the object shape (tree of nested properties) instead of a reference to the same formal type definition increases flexibility and modifiability. The price we pay for this increased flexibility is that type compatibility cannot be computed automatically by comparing the formal definition of server and client interfaces. In fact, in the absence of a univocal specification, each time a new version of the service is released, the developer must verify that the semantics of all the fields that the client and <a id="_idIndexMarker1080"/>server have in common remain unchanged from the previous version.</p>
<p class="normal">The basic idea behind REST services is to give up the severity checks and complex protocols for greater flexibility and simplicity, while SOAP does exactly the opposite.</p>
<h2 class="heading-2" id="_idParaDest-310">REST and native HTTP features</h2>
<p class="normal">The REST services manifesto states<a id="_idIndexMarker1081"/> that REST uses native HTTP features to implement all the required service features. So, for instance, authentication will be performed directly with the HTTP <code class="inlineCode">Authorization</code> field, encryption will be achieved with HTTPS, exceptions will be handled with an HTTP error status code, and routing and reliable messaging will be handled by the machinery the HTTP protocol relies on. Addressing is achieved by using URLs to refer to services, their methods, and other resources.</p>
<p class="normal">There is no native support for asynchronous communication since HTTP is a synchronous protocol. There is also no native support for the Publisher/Subscriber pattern, but two services can interact with the Publisher/Subscriber pattern by each exposing an endpoint to the other. More specifically, the first service exposes a subscription endpoint, while the second one exposes an endpoint where it receives its notifications, which are authorized through a common secret that is exchanged during the subscription. This pattern is quite common. GitHub also allows us to send repository events to our REST services.</p>
<p class="normal">REST services offer no easy options when it comes to implementing distributed transactions, since HTTP is stateless. However, approaches like the SAGA pattern, described in <em class="italic">Chapter 14, Implementing Microservices with .NET</em>, and event sourcing, described in <em class="italic">Chapter 7, Understanding the Different Domains in Software Solutions</em>, helped a lot in the last years to solve this difficulty. Besides, luckily, most application areas do not need the strong form of consistency that is ensured by distributed transactions. For them, lighter forms of consistency, such as <em class="italic">eventual consistency</em>, are enough and are preferred for performance reasons. Please refer to <em class="italic">Chapter 12</em>, <em class="italic">Choosing Your Data Storage in the Cloud</em>, for a discussion on the various types of consistencies.</p>
<p class="normal">The REST manifesto not only prescribes the usage of the predefined solutions that are already available in HTTP but<a id="_idIndexMarker1082"/> also the usage of a web-like semantic. In general, service operations can be conceived as CRUD operations, but not limited to them on resources that are identified by URLs (the same resource may be identified by several URLs). In fact, REST is an acronym for <strong class="keyWord">Representational State Transfer</strong>, meaning<a id="_idIndexMarker1083"/> that each URL is the representation of some sort of entity. As a best practice, each kind of service request needs to adopt the appropriate HTTP verb and return the status code as follows:</p>
<ul>
<li class="bulletList"><code class="inlineCode">GET</code> (read operation): The URL represents the resource that is returned by the read operation. Thus, <code class="inlineCode">GET</code> operations mimic pointer dereferencing. In the case of a successful operation, a 200 (OK) status code is returned.</li>
<li class="bulletList"><code class="inlineCode">POST</code> (creation operation): The JSON/XML object that is contained in the request body is added as a new resource to the object represented by the operation URL. If the new resource is successfully created immediately, a 201 (created) status code is returned, along with a response object that depends on the operation and an indication as to where the created resource can be retrieved from. The response object should contain the most specific URL that identifies the created resource. If creation is deferred to a later time, a 202 (accepted) status code is returned.</li>
<li class="bulletList"><code class="inlineCode">PUT</code> (edit operation): The JSON/XML object contained in the request body replaces the object referenced by the request URL. In the case of a successful operation, a 200 (OK) status code is returned. This operation is idempotent, meaning that repeating the same request twice causes the same modification. 204 (No Content) is also a possible return value.</li>
<li class="bulletList"><code class="inlineCode">PATCH</code>: The JSON/XML object contained in the request body contains instructions on how to modify the object referenced by the request URL. This operation is not idempotent since the modification may be an increment of a numeric field. In the case of a successful operation, a 200 (OK) status code is returned.</li>
<li class="bulletList"><code class="inlineCode">DELETE</code>: The resource referenced by the request URL is removed. In the case of a successful operation, a 200 (OK) status code is returned.</li>
</ul>
<p class="normal">If the resource has been moved from the request URL to another URL, a redirect code is returned:</p>
<ul>
<li class="bulletList"><code class="inlineCode">301</code> (moved permanently), plus the new URL where we can find the resource</li>
<li class="bulletList"><code class="inlineCode">307</code> (moved temporarily), plus the new URL where we can find the resource</li>
</ul>
<p class="normal">If the operation fails, a status code that<a id="_idIndexMarker1084"/> depends on the kind of failure is returned. Some examples of failure codes are as follows:</p>
<ul>
<li class="bulletList"><code class="inlineCode">400</code> (bad request): The request that was sent to the server is ill formed.</li>
<li class="bulletList"><code class="inlineCode">404</code> (not found): When the request URL does not refer to any known object.</li>
<li class="bulletList"><code class="inlineCode">405</code> (method not allowed): When the request verb is not supported by the resource referenced by the URL.</li>
<li class="bulletList"><code class="inlineCode">401</code> (unauthorized): The operation requires authentication, but the client has not furnished any valid authorization header.</li>
<li class="bulletList"><code class="inlineCode">403</code> (forbidden): The client is correctly authenticated but has no right to perform the operation.</li>
<li class="bulletList"><code class="inlineCode">409</code> (conflict): The operation failed due to some conflict with the current state of the server.</li>
<li class="bulletList"><code class="inlineCode">412</code> (precondition failed): The operation failed due to some precondition desired.</li>
<li class="bulletList"><code class="inlineCode">422</code> (unprocessable content): The request was well formatted, but there are semantic errors in it.</li>
</ul>
<p class="normal">The preceding list of status codes is not exhaustive. A reference to an exhaustive list will be provided in the <em class="italic">Further reading</em> section.</p>
<p class="normal">It is fundamental to point out that <code class="inlineCode">POST</code>/<code class="inlineCode">PUT</code>/<code class="inlineCode">PATCH</code>/<code class="inlineCode">DELETE</code> operations may have – and usually have – side effects on other resources. Otherwise, it would be impossible to code operations that act simultaneously on several resources.</p>
<p class="normal">In other words, the HTTP verb must conform with the operation that is performed on the resource and referenced by the request URL, but the operation might affect other resources. The same operation might be performed with a different HTTP verb on one of the other involved resources. It is the developer’s responsibility to choose which way to perform the same operation to implement it in the service interface.</p>
<p class="normal">Thanks to the side effects of HTTP verbs, REST services can encode all these operations as CRUD operations on resources represented by URLs.</p>
<p class="normal">Often, moving an existing service to REST requires us to split the various inputs between the request URL and the request body. More specifically, we extract the input fields that univocally define one of the objects involved in the method’s execution and use them to create a URL that univocally identifies that object. Then, we decide on which HTTP verb to use based on the operation that is <a id="_idIndexMarker1085"/>performed on the selected object. Finally, we place the remainder of the input in the request body.</p>
<p class="normal">If our services were designed with an object-oriented architecture focused on the business domain objects (such as DDD, as described in <em class="italic">Chapter 7, Understanding the Different Domains in Software Solutions</em>), the REST translation of all the service methods should be quite immediate since services should already be organized around domain resources. Otherwise, moving to REST might require some service interface redefinitions.</p>
<p class="normal">The adoption of full REST semantics has the advantage that services can be extended with or without small modifications being made to the preexisting operation definitions. In fact, extensions should mainly manifest as additional properties of some objects and as additional resource URLs with some associated operations. Therefore, preexisting clients can simply ignore them.</p>
<h2 class="heading-2" id="_idParaDest-311">Example of methods in the REST language</h2>
<p class="normal">Now, let us learn how methods can be <a id="_idIndexMarker1086"/>expressed in the REST language with a simple example of an intra-bank money transfer. We will present here two approaches.</p>
<p class="normal">In the first one, a bank account can be represented by a URL as follows:</p>
<p class="normal"><code class="inlineCode">https://mybank.com/accounts/{bank account number}</code></p>
<p class="normal">If we imagine a bank transfer we may represent it as a <code class="inlineCode">PATCH</code> request, whose body contains an object with properties representing the amount of money, time of transfer, description, and the account receiving the money.</p>
<p class="normal">The operation modifies the account mentioned in the URL but also the receiving account as a <em class="italic">side effect</em>. If the account doesn’t have enough money, a <code class="inlineCode">409</code> (conflict) status code is returned, along with an object with all the error details (an error description, the available funds, and so on).</p>
<p class="normal">However, since all the bank operations are recorded in the account statement, the creation and addition of a new transfer object for a <em class="italic">bank account operations</em> collection associated with the bank account is a better way to represent the transfer. In this second approach, the URL might be something like the following:</p>
<p class="normal"><code class="inlineCode">https://mybank.com/accounts/{bank account number}/transactions</code></p>
<p class="normal">Here, the HTTP verb is <code class="inlineCode">POST</code> since we are creating a new object. The body content is the same, and a <code class="inlineCode">422</code> status code is returned if there is a lack of funds.</p>
<p class="normal">Both representations of<a id="_idIndexMarker1087"/> the transfer cause the same changes in the database. Moreover, once the inputs are extracted from the different URLs and from the possibly different request bodies, the subsequent processing is the same. In both cases, we have the same inputs and the same processing – it is just the exterior appearance of the two requests that are different.</p>
<p class="normal">However, the introduction of the virtual <em class="italic">transactions</em> collection allows us to extend the service with several more <em class="italic">transaction</em> collection-specific methods. It is worth pointing out that the <em class="italic">transaction </em>collection does not need to relate to a database table or any physical object: it lives in the world of URLs and creates a convenient way for us to model the transfer.</p>
<p class="normal">The increased usage of REST services leads to a description of REST service interfaces to be created like the ones developed for SOAP. This<a id="_idIndexMarker1088"/> standard is called <strong class="keyWord">OpenAPI</strong>. We will talk about this in the following subsection.</p>
<h2 class="heading-2" id="_idParaDest-312">The OpenAPI standard</h2>
<p class="normal">OpenAPI is a specification that is used <a id="_idIndexMarker1089"/>worldwide for describing the REST APIs. The OpenAPI Initiative was founded in November 2015, as an open-source project under the Linux Foundation, with the help of companies like SmartBear, Google, IBM, and Microsoft. The specification is currently versioned as 3.1. The whole service is described by a JSON or YAML endpoint, that is, an endpoint that describes the service with a JSON object. This JSON object has a general section that applies to the whole service and contains the general features of the service, such as its version and description, as well as shared definitions.</p>
<div><p class="normal">You can find OpenAPI Specification examples at <a href="https://github.com/OAI/OpenAPI-Specification/">https://github.com/OAI/OpenAPI-Specification/</a>.</p>
</div>
<p class="normal">Then, each service endpoint has a specific section that describes the endpoint URL or URL format (in case some inputs are included in the URL), all its inputs, all the possible output types and status codes, and all the authorization protocols. Each endpoint-specific section can reference the <a id="_idIndexMarker1090"/>definitions contained in the general section.</p>
<p class="normal">A complete description of the OpenAPI syntax is out of the scope of this book, but you will find visual editors on the Internet that can help you clarify the specification mentioned before. A great example is provided by SmartBear, one of the companies that founded the initiative, and it is called Swagger <a id="_idIndexMarker1091"/>Editor. In the beta version of the online tool, you can load an example using OpenAPI version 3.1.0. This helps companies to create API contracts even before deciding the programming language of the API.</p>
<p class="normal">Various development frameworks automatically generate OpenAPI documentation by processing the REST API code, and further information is provided by the developer, so your team does not need to have in-depth knowledge of OpenAPI syntax. An example of this is the <code class="inlineCode">Swashbuckle.AspNetCore</code> NuGet package that we will present in this chapter.</p>
<p class="normal">The <em class="italic">How does .NET 8 deal with SOA?</em> section explains how we can automatically generate OpenAPI documentation in ASP.NET Core REST API projects, while the use case presented in <em class="italic">Chapter 21, Case Study, </em>will provide a practical example of its usage.</p>
<p class="normal">We will end this subsection by talking about how to handle authentication and authorization in REST services.</p>
<h2 class="heading-2" id="_idParaDest-313">REST service authorization and authentication</h2>
<p class="normal">Since REST services are stateless, when<a id="_idIndexMarker1092"/> authentication is required, the client must send an authentication token in every single request. That token is usually placed in the HTTP authorization header, but this depends on the type of authentication protocol you are using. The simplest way to authenticate is through the explicit transmission of a shared secret. This can be done with the following code:</p>
<pre class="programlisting code"><code class="hljs-code">Authorization: Api-Key &lt;string known by both server and client&gt;
</code></pre>
<p class="normal">The shared secret is called an API key. Since, at the time of writing, there is no standard on how to send it, API keys can also be sent in other headers, as shown in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">X-API-Key: &lt;string known by both server and client&gt;
</code></pre>
<p class="normal">It is worth mentioning that API-key-based authentication needs HTTPS to stop shared secrets from being stolen. API keys are very simple to use, but they do not convey information about user authorizations, so they can be adopted when the operations allowed by the client are quite standard, and there are no complex authorization patterns. Moreover, when exchanged in requests, API keys are susceptible to being attacked on the server or client side. A common pattern to mitigate this is to create a “service account” user and <a id="_idIndexMarker1093"/>restrict their authorizations to just those needed and use the API keys from that specific account when interacting with the API.</p>
<div><p class="normal">If you need a more sophisticated authentication service, you may consider using the OAuth 2.0 protocol. For instance, when you implement “Sign in with [Some specific social media],” you are probably using this protocol. Of course, to use it, you have to define an authentication service provider.</p>
</div>
<p class="normal">Safer techniques use shared secrets that are valid for a long period of time, just by the user logging in. Then, the login returns a short-life token that is used as a shared secret in all the subsequent requests. When the short-lived secret is going to expire, it can be renewed with a call to a renew endpoint.</p>
<p class="normal">The whole logic is completely decoupled from the short-life token-based authorization logic. The login is usually based on login endpoints that receive long-term credentials and return short-life tokens. Login credentials are either usual username-password pairs that are passed as input to the login method or other kinds of authorization tokens that are converted into short-life tokens that are served by the login endpoint. Login can also be achieved with various authentication protocols based on X.509 certificates.</p>
<p class="normal">The most widespread <a id="_idIndexMarker1094"/>short-life token type is the so-called bearer token. Each bearer token encodes information about how long it lasts and a list of assertions, called claims, that can be used for authorization purposes. Bearer tokens are returned by either login operations or renewal operations. Their characteristic feature is that they are not tied to the client that receives them or to any other specific client, but they identify the client, which can simply use them in its invocations.</p>
<p class="normal">No matter how a client gets a bearer token, this is all a client needs to be granted, including all the rights implied by its claims. It is enough to transfer a bearer token to another client to empower that client with all the rights implied by all the bearer token claims since no proof of identity is required by bearer-token-based authorization.</p>
<p class="normal">Therefore, once a client gets a bearer token, it can delegate some operations to third parties by transferring its bearer token to them. Typically, when a bearer token must be used for delegation, during the login phase, the client specifies the claims to include to restrict what operations can be <a id="_idIndexMarker1095"/>authorized by the token.</p>
<p class="normal">Compared to API key authentication, bearer-token-based authentication is disciplined by standards. They must use the following <code class="inlineCode">Authorization</code> header:</p>
<pre class="programlisting code"><code class="hljs-code">Authorization: Bearer &lt;bearer token string&gt;
</code></pre>
<p class="normal">Bearer tokens can be implemented in several ways. REST services typically use JWTs that are strings with a Base64 URL encoding of JSON objects. More specifically, JWT creation starts with a JSON header, as well as a JSON payload. The JSON header specifies the kind of token and how it is signed, while the payload consists of a JSON object that contains all the claims as property/value pairs. The following is an example header:</p>
<pre class="programlisting code"><code class="hljs-code">{
  "alg": "RS256",
  "typ": "JWT"
}
</code></pre>
<p class="normal">The following is an example payload:</p>
<pre class="programlisting code"><code class="hljs-code">{
  "iss": "wwtravelclub.com"
"sub": "example",
  "aud": ["S1", "S2"],
  "roles": [
    "ADMIN",
    "USER"
  ],
  "exp": 1512975450,
  "iat": 1512968250230
}
</code></pre>
<p class="normal">Then, the header and payload are Base64 URL-encoded, and the corresponding string is concatenated as follows:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;header BASE64 string&gt;.&lt;payload base64 string&gt;
</code></pre>
<p class="normal">The preceding string is then signed with the algorithm specified in the header, which, in our example, is <code class="inlineCode">RSA +SHA256</code>, and the signature string is concatenated with the original string as follows:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;header BASE64 string&gt;.&lt;payload base64 string&gt;.&lt;signature string&gt;
</code></pre>
<p class="normal">The preceding code is the final bearer token string. A symmetric signature can be used instead of RSA, but, in this case, both<a id="_idIndexMarker1096"/> the JWT issuer and all the services using it for authorization must share a common secret, while, with RSA, the private key of the JWT issuer does not need to be shared with anyone, since the signature can be verified with just the issuer public key.</p>
<p class="normal">Some payload properties are standard, such as the following:</p>
<ul>
<li class="bulletList"><code class="inlineCode">iss</code>: Issuer of the JWT.</li>
<li class="bulletList"><code class="inlineCode">aud</code>: The audience, that is, the services and/or operations that can use the token for authorization. If a service does not see its identifier within this list, it should reject the token.</li>
<li class="bulletList"><code class="inlineCode">sub</code>: A string that identifies the <em class="italic">principal</em> (that is, the user) to which the JWT was issued.</li>
<li class="bulletList"><code class="inlineCode">iat</code>, <code class="inlineCode">exp</code>, and <code class="inlineCode">nbf</code>: These are for the time the JWT was issued, its expiration time, and, if set, the time after which the token is valid, respectively. All the times are expressed as seconds from midnight UTC on January 1, 1970. Here, all the days are considered as having exactly 86,400 seconds in them.</li>
</ul>
<p class="normal">Other claims may be defined as public if we represent them with a unique URI; otherwise, they are considered private to the issuer and to the services known to the issuer.</p>
<h2 class="heading-2" id="_idParaDest-314">API versioning</h2>
<p class="normal">Considering a natural scenario where<a id="_idIndexMarker1097"/> the number of APIs will increase in your application, and, more than that, the business logic will obviously evolve, as a software architect, you must decide how you are going to version the APIs, guaranteeing the compatibility between your services and the clients that consume these services.</p>
<p class="normal">It is important to mention that there are several versioning options for doing so:</p>
<ul>
<li class="bulletList"><strong class="keyWord">URI</strong>: It consists of defining the version of the API in its URI, for example, <code class="inlineCode">https://wwtravelclub.com/v1/trips</code>.</li>
<li class="bulletList"><strong class="keyWord">Parameter</strong>: You can define a parameter in the request that defines the version, for instance, <code class="inlineCode">https://wwtravelclub.com/trips?version=2</code>.</li>
<li class="bulletList"><strong class="keyWord">Media type</strong>: In this case, the desired version of the API will be presented in the HTTP <code class="inlineCode">Accept</code> header.</li>
<li class="bulletList"><strong class="keyWord">Custom request header</strong>: Like the media type versioning technique, but in this case the HTTP header will be customized by you.</li>
</ul>
<p class="normal">The first two alternatives are the most<a id="_idIndexMarker1098"/> commonly used, but the important point here is that you must consider crucial the implementation of a versioning technique.</p>
<h1 class="heading-1" id="_idParaDest-315">How does .NET 8 deal with SOA?</h1>
<p class="normal">WCF technology has not been<a id="_idIndexMarker1099"/> ported to .NET 5+ and there are no plans to perform a complete port of it. Part of the source code was donated, and an open-source project started out of it. You can find information about this project at <a href="https://github.com/CoreWCF/CoreWCF">https://github.com/CoreWCF/CoreWCF</a>. Instead, Microsoft is investing in gRPC, Google’s open-source technology. Besides, .NET 8 has excellent support for REST services through ASP.NET Core.</p>
<div><p class="normal">There is a tool developed by Microsoft to help you with the migration of WCF applications to the latest .NET. You can find it at <a href="https://devblogs.microsoft.com/dotnet/migration-wcf-to-corewcf-upgrade-assistant/">https://devblogs.microsoft.com/dotnet/migration-wcf-to-corewcf-upgrade-assistant/</a>.</p>
</div>
<p class="normal">The main reasons behind the decision to abandon WCF are as follows:</p>
<ul>
<li class="bulletList">As we have already discussed, SOAP technology has been overtaken by REST technology in most application areas.</li>
<li class="bulletList">WCF technology is strictly tied to Windows, so it would be very expensive to reimplement all its features from scratch in .NET 5+. Since support for full .NET will continue, users who need WCF can still rely on it.</li>
<li class="bulletList">As a general strategy, with .NET 5+, Microsoft prefers investing in open-source technologies that can be shared with other competitors. That is why, instead of investing in WCF, Microsoft provided a gRPC implementation starting from .NET Core 3.0.</li>
</ul>
<p class="normal">The next subsections <a id="_idIndexMarker1100"/>will cover the support provided inside Visual Studio for each technology we have mentioned.</p>
<h2 class="heading-2" id="_idParaDest-316">SOAP client support</h2>
<p class="normal">In WCF, service specifications are <a id="_idIndexMarker1101"/>defined through .NET interfaces, and the actual service code is supplied in classes that implement those interfaces. Endpoints, underlying protocols (HTTP and TCP/IP), and any other features are defined in a configuration file. In turn, the configuration file can be edited with an easy-to-use configuration tool. Therefore, the developer is responsible for providing just the service behavior as a standard .NET class and for configuring all the service features in a declarative way. This way, the service configuration is completely decoupled from the actual service behavior, and each service can be reconfigured so that it can be adapted to a different environment without the need to modify its code.</p>
<p class="normal">While .NET 8 does not support SOAP technology for creating new services, it does support the usage of SOAP clients when there are many SOAP services as legacy. More specifically, it is quite easy to create a SOAP service proxy for an existing SOAP service in Visual Studio (please refer to <em class="italic">Chapter 6</em>, <em class="italic">Design Patterns and .NET 8 Implementation</em>, for a discussion of what a proxy is and of the Proxy pattern).</p>
<p class="normal">In the case of services, a proxy is a class that implements the service interface and whose methods perform their jobs by calling the analogous methods of the remote service.</p>
<p class="normal">To create a service proxy, right-click <strong class="keyWord">Dependencies</strong> in your project in <strong class="keyWord">Solution Explorer</strong>, and then select <strong class="keyWord">Add connected service</strong>. Then, in the form that appears, select <strong class="keyWord">Microsoft WCF Service Reference Provider</strong>. There, you can specify the URL of the service (where the WSDL service description is contained), the namespace where you wish to add the proxy class, and much more. At the end of the wizard, Visual Studio automatically adds all the necessary NuGet packages and scaffolds the proxy class. This is enough to create an instance of this class and to call its methods so that we can interact with the remote SOAP service.</p>
<p class="normal">There are also third parties, such as NuGet packages, that provide limited support for SOAP services, but currently, they aren’t very useful since such limited support does not include features that aren’t available in <a id="_idIndexMarker1102"/>REST services.</p>
<h2 class="heading-2" id="_idParaDest-317">gRPC support</h2>
<p class="normal">The .NET SDK supports the gRPC <a id="_idIndexMarker1103"/>project template, which scaffolds both a gRPC server and a gRPC client. gRPC implements a remote procedure call pattern that offers both synchronous and asynchronous calls, reducing the traffic of messages between the client and server.</p>
<p class="normal">Using gRPC is super easy since Visual Studio’s gRPC project template scaffolds everything so that the gRPC service and its clients are working. The developer just needs to define the application-specific C# service interface and a class that implements it.</p>
<p class="normal">For configuring it, services are defined through interfaces written in a Protobuf file, and their code is provided in C# classes that implement those interfaces, while clients interact with those services through proxies that implement the same service interfaces.</p>
<p class="normal">gRPC is a good option for internal communications within a microservices cluster. Since there are gRPC libraries for all the main languages and development frameworks, it can be used in Kubernetes-based clusters. Besides, gRPC is more efficient than the REST services protocol due to its more compact representation of data and its being easier to use since everything to do with the protocol is taken care of by the development framework.</p>
<p class="normal">For this reason, we have added a brand-new chapter dedicated to discussing this implementation, <em class="italic">Chapter 14</em>, <em class="italic">Implementing Microservices with .NET</em>, and you can check details about the technology at <a href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-8.0">https://docs.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-8.0</a>.</p>
<p class="normal">The remainder of the section is dedicated to .NET support for REST services from both the server and client sides.</p>
<h2 class="heading-2" id="_idParaDest-318">A short introduction to ASP.NET Core</h2>
<p class="normal">ASP.NET Core applications are .NET <a id="_idIndexMarker1104"/>applications based on the <em class="italic">Host</em> concept we described in the <em class="italic">Using generic hosts</em> subsection of <em class="italic">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>.</p>
<p class="normal">Using C# 12 and .NET 8, the template for creating ASP.NET Core apps has changed a bit. The main purpose is to simplify how we set it up. The <code class="inlineCode">Program.cs</code> file of each ASP.NET application now creates a host, builds it, and runs it without needing the <code class="inlineCode">Startup</code> class anymore, as we can see in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">var builder = WebApplication.CreateBuilder(args);
// Add services to the container.
builder.Services.AddControllers();
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
var app = builder.Build();
// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();
app.Run();
</code></pre>
<p class="normal"><code class="inlineCode">Environment</code> is taken from the <code class="inlineCode">ASPNETCORE_ENVIRONMENT</code> environment variable. In turn, it is defined in the <code class="inlineCode">Properties\launchSettings.json</code> file when the application runs in Visual Studio over <strong class="keyWord">Solution Explorer</strong>. In this file, you can define several environments that can be selected with the dropdown next to Visual Studio’s run button, <strong class="keyWord">IIS Express</strong>. By default, the <strong class="keyWord">IIS Express</strong> setting sets <code class="inlineCode">ASPNETCORE_ENVIRONMENT</code> to <code class="inlineCode">Development</code>. The following is a typical <code class="inlineCode">launchSettings.json</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">{
"iisSettings": {
"windowsAuthentication": false,
"anonymousAuthentication": true,
"iisExpress": {
"applicationUrl": "http://localhost:48638",
"sslPort": 44367
}
},
"profiles": {
"http": {
"commandName": "Project",
"dotnetRunMessages": true,
"launchBrowser": true,
"launchUrl": "swagger",
"applicationUrl": "http://localhost:5085",
"environmentVariables": {
"ASPNETCORE_ENVIRONMENT": "Development"
}
},
"https": {
"commandName": "Project",
"dotnetRunMessages": true,
"launchBrowser": true,
"launchUrl": "swagger",
"applicationUrl": "https://localhost:7214;http://localhost:5085",
"environmentVariables": {
"ASPNETCORE_ENVIRONMENT": "Development"
}
},
"IIS Express": {
"commandName": "IISExpress",
"launchBrowser": true,
"launchUrl": "swagger",
"environmentVariables": {
"ASPNETCORE_ENVIRONMENT": "Development"
}
}
}
}
</code></pre>
<p class="normal">The value to use for <code class="inlineCode">ASPNETCORE_ENVIRONMENT</code> when the application is published can be added to the published XML file after<a id="_idIndexMarker1105"/> it has been created by Visual Studio. This value is <code class="inlineCode">&lt;EnvironmentName&gt;Staging&lt;/EnvironmentName&gt;</code>. It can also be specified in your Visual Studio ASP.NET Core project file (<code class="inlineCode">.csproj</code>):</p>
<pre class="programlisting code"><code class="hljs-code">&lt;PropertyGroup&gt;
&lt;EnvironmentName&gt;Staging&lt;/EnvironmentName&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p class="normal">Each middleware in the pipeline is defined by an <code class="inlineCode">app.Use&lt;something&gt;</code> method, which often accepts some options. Each of them processes the requests and then either forwards the modified request to the next one in the pipeline or returns an HTTP response. When an HTTP response is returned, it is processed by all the previous ones in reverse order.</p>
<p class="normal">Modules are inserted in the pipeline<a id="_idIndexMarker1106"/> in the order they are defined by the <code class="inlineCode">app.Use&lt;something&gt;</code> method calls. The preceding code adds an error page if <code class="inlineCode">ASPNETCORE_ENVIRONMENT</code> is <code class="inlineCode">Development</code>. A complete description of the ASP.NET Core pipeline will be given in the <em class="italic">Understanding the presentation layers of web applications</em> section of <em class="italic">Chapter 17</em>, <em class="italic">Presenting ASP.NET Core</em>.</p>
<p class="normal">In the next subsection, we will explain how the MVC framework lets you implement REST services.</p>
<h2 class="heading-2" id="_idParaDest-319">Implementing REST services with ASP.NET Core</h2>
<p class="normal">Today, we can guarantee that the use of MVC and a web API is consolidated. In the MVC framework, HTTP requests are processed by classes called controllers. Each request is mapped to the call of a controller <a id="_idIndexMarker1107"/>public method. The selected controller <a id="_idIndexMarker1108"/>and controller methods depend on the shape of the request path, and they are defined by routing rules, which, for the REST API, are usually provided through attributes associated with both the <code class="inlineCode">Controller</code> class and its methods.</p>
<div><p class="normal">ASP.NET Core 6 has introduced minimal APIs to simplify the mechanism of implementing APIs with C#. You can find a good explanation of it at <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis</a>.</p>
</div>
<p class="normal"><code class="inlineCode">Controller</code> methods that process HTTP requests are called action methods. When the controller and action methods are selected, the MVC framework creates a controller instance to serve the request. All the parameters of the controller constructors are resolved with dependency injection.</p>
<div><p class="normal">Please refer to the <em class="italic">Using generic hosts</em> subsection of <em class="italic">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>, for a description of how to use dependency injection with a .NET host and to the <em class="italic">Dependency injection pattern</em> subsection of <em class="italic">Chapter 6</em>, <em class="italic">Design Patterns and .NET 8 Implementation</em>, for a general discussion of dependency injection.</p>
</div>
<p class="normal">The following is a typical REST<a id="_idIndexMarker1109"/> API controller and its controller method definitions:</p>
<pre class="programlisting code"><code class="hljs-code">[Route("api/[controller]")]
[ApiController]
public class ValuesController : ControllerBase
{
    // GET api/values/5
    [HttpGet("{id}")]
    public ActionResult&lt;string&gt; Get(int id)
    {
        ...
</code></pre>
<p class="normal">The <code class="inlineCode">[ApiController]</code> attribute <a id="_idIndexMarker1110"/>declares that the controller is a REST API controller. <code class="inlineCode">[Route("api/[controller]")]</code> declares that the controller must be selected on paths that start with <code class="inlineCode">api/&lt;controller name&gt;</code>. The controller’s name is the name of the controller class without the <code class="inlineCode">Controller</code> postfix. This is preferred over hardcoding a controller name to save time on refactoring. Thus, in this case, we have <code class="inlineCode">api/values</code>.</p>
<p class="normal"><code class="inlineCode">[HttpGet("{id}")]</code> declares that the method must be invoked on GET requests of the <code class="inlineCode">api/values/&lt;id&gt;</code> type, where <code class="inlineCode">id</code> must be a number that’s passed as an argument to the method invocation. This can be done with <code class="inlineCode">Get(int id)</code>. There is also an <code class="inlineCode">Http&lt;verb&gt;</code> attribute for each HTTP verb: <code class="inlineCode">HttpPost</code> and <code class="inlineCode">HttpPatch</code>.</p>
<p class="normal">We may also have another method defined like so:</p>
<pre class="programlisting code"><code class="hljs-code">[HttpGet]
public ... Get()
</code></pre>
<p class="normal">This method is invoked on <code class="inlineCode">GET</code> requests of the <code class="inlineCode">api/values</code> type, that is, on <code class="inlineCode">GET</code> requests without <code class="inlineCode">id</code> after the controller’s name.</p>
<p class="normal">Several action methods can have the same name, but only one should be compatible with each request path; otherwise, an exception is thrown. In other words, routing rules and <code class="inlineCode">Http&lt;verb&gt;</code> attributes must univocally define which controller and which of its action methods to select for each request.</p>
<p class="normal">By default, parameters are passed to the action methods of API controllers according to the following rules.</p>
<p class="normal">Simple types (<code class="inlineCode">integers</code>, <code class="inlineCode">floats</code>, and <code class="inlineCode">DateTimes</code>) are taken from the request path if routing rules specify them as parameters, as in the case of the previous example’s <code class="inlineCode">[HttpGet("{id}")]</code> attribute. If they are not found in the routing rules, the ASP.NET Core framework looks for <a id="_idIndexMarker1111"/>query string parameters with the same name. Thus, for instance, if we replace <code class="inlineCode">[HttpGet("{id}")]</code> with <code class="inlineCode">[HttpGet]</code>, the ASP.NET Core framework will look for something like <code class="inlineCode">api/values?id=&lt;id type&gt;</code> or <code class="inlineCode">api/values/{id}</code>.</p>
<p class="normal">Complex types are extracted from the request body by formatters. The right formatter is chosen according to the value of the<a id="_idIndexMarker1112"/> request’s <code class="inlineCode">Content-Type</code> header. If no <code class="inlineCode">Content-Type</code> header is specified, the JSON formatter is taken. The JSON formatter tries to parse the request body as a JSON object and then tries to transform this JSON object into an instance of the .NET complex type. If either the JSON extraction or the subsequent conversion fails, an exception is thrown. As described in <em class="italic">Chapter 2, Non-Functional Requirements</em>, be careful with exceptions since their computational costs are much higher than a normal code flow. </p>
<p class="normal">If an exception is inevitable, consider using the recommendations for logging described in <em class="italic">Chapter 4, Best Practices in Coding C# 12</em>. By default, just the JSON input formatter is supported, but you can also add an XML formatter that can be used when <code class="inlineCode">Content-Type</code> specifies XML content.</p>
<p class="normal">You can customize the source that is used to fill an action method parameter by prefixing the parameter with an adequate attribute. The following code shows some examples of this:</p>
<pre class="programlisting code"><code class="hljs-code">...MyActionMethod(....[FromHeader] string myHeader....)
// x is taken from a request header named myHeader
...MyActionMethod(....[FromServices] MyType x....)
// x is filled with an instance of MyType through dependency injection
</code></pre>
<p class="normal">The return type of an action method can be an <code class="inlineCode">IActionResult</code> interface, a type that implements that interface, or a DTO directly. In turn, <code class="inlineCode">IActionResult</code> has just the following method:</p>
<pre class="programlisting code"><code class="hljs-code">Task ExecuteResultAsync(ActionContext context);
</code></pre>
<p class="normal">This method is called by the MVC framework at the right time to create the actual response and response headers. The <code class="inlineCode">ActionContext</code> object, when passed to the method, contains the whole context of the HTTP request, which includes a request object with all the necessary information about the original HTTP requests (headers, body, and cookies), as <a id="_idIndexMarker1113"/>well as a response object that collects all the pieces of the response that is being built.</p>
<p class="normal">You do not have to create an<a id="_idIndexMarker1114"/> implementation of <code class="inlineCode">IActionResult</code> manually since <code class="inlineCode">ControllerBase</code> already has methods to create <code class="inlineCode">IActionResult</code> implementations so that all the necessary HTTP responses are generated. Some of these methods are as follows:</p>
<ul>
<li class="bulletList"><code class="inlineCode">OK</code>: This returns a 200 status code, as well as an optional result object. It is used as either <code class="inlineCode">return OK()</code> or <code class="inlineCode">return OK(myResult)</code>.</li>
<li class="bulletList"><code class="inlineCode">BadRequest</code>: This returns a 400 status code, as well as an optional response object.</li>
<li class="bulletList"><code class="inlineCode">Created(string uri, object o)</code>: This returns a 201 status code, as well as a result object and the URI of the created resource.</li>
<li class="bulletList"><code class="inlineCode">Accepted</code>: This returns a 202 status result, as well as an optional result object and resource URI.</li>
<li class="bulletList"><code class="inlineCode">Unauthorized</code>: This returns a 401 status result, as well as an optional result object.</li>
<li class="bulletList"><code class="inlineCode">Forbid</code>: This returns a 403 status result, as well as an optional list of failed permissions.</li>
<li class="bulletList"><code class="inlineCode">StatusCode(int statusCode, object o = null)</code>: This returns a custom status code, as well as an optional result object.</li>
</ul>
<p class="normal">An action method can return a result object directly with <code class="inlineCode">return myObject</code>. This is equivalent to returning <code class="inlineCode">OK(myObject)</code>.</p>
<p class="normal">When all the result paths return a result object of the same type, say, <code class="inlineCode">MyType</code>, the action method can be declared as returning <code class="inlineCode">ActionResult&lt;MyType&gt;</code>. You may also return responses like <code class="inlineCode">NotFound</code>, but for sure, you will get a better type of check with this approach.</p>
<p class="normal">By default, result objects are serialized in JSON in the response body. However, if an XML formatter has been added to the ASP.NET Core framework processing pipeline, as shown previously, the way the result is serialized depends on the <code class="inlineCode">Accept</code> header of the HTTP request. More specifically, if the client explicitly requires XML format with the <code class="inlineCode">Accept</code> header, the object will be serialized in XML; otherwise, it will be serialized in JSON.</p>
<p class="normal">Complex objects that are passed<a id="_idIndexMarker1115"/> as input to action methods can be validated with validation attributes as follows:</p>
<pre class="programlisting code"><code class="hljs-code">public record MyType
{
   [Required]
    public string Name{get; set;}
    ...
    [MaxLength(64)]
    public string Description{get; set;}
}
</code></pre>
<p class="normal">If the controller has been <a id="_idIndexMarker1116"/>decorated with the <code class="inlineCode">[ApiController]</code> attribute and if validation fails, the ASP.NET Core framework automatically creates a <code class="inlineCode">BadRequest</code> response containing a dictionary with all the validation errors detected, without executing the action method. Therefore, you do not need to add further code to handle validation errors.</p>
<p class="normal">Action methods can also be declared as <code class="inlineCode">async</code> methods, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">public async Task&lt;IActionResult&gt;MyMethod(......)
{
    await MyBusinessObject.MyBusinessMethod();
    ...
}
public async Task&lt;ActionResult&lt;MyType&gt;&gt;MyMethod(......)
{
    ...
</code></pre>
<p class="normal">Practical examples of controllers/action methods will be shown in <em class="italic">Use case – exposing WWTravelClub packages, </em>presented in <em class="italic">Chapter 21, Case Study</em>. In the next subsection, we will explain how to handle authorization and authentication with JWTs.</p>
<h3 class="heading-3" id="_idParaDest-320">ASP.NET Core service authorization</h3>
<p class="normal">When using a JWT, authorizations are based on the claims contained in the JWT. All the token claims in any action method can<a id="_idIndexMarker1117"/> be accessed through the <code class="inlineCode">User.Claims</code> controller property. Since <code class="inlineCode">User.Claims</code> is an <code class="inlineCode">IEnumerable&lt;Claim&gt;</code>, it can be processed with LINQ to verify complex conditions on claims.</p>
<p class="normal">If authorization is based on <em class="italic">role</em> claims, you can simply use the <code class="inlineCode">User.IsInRole</code> function, as shown in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">If(User.IsInRole("Administrators") || User.IsInRole("SuperUsers"))
{
    ...
}
else return Forbid();
</code></pre>
<p class="normal">However, permissions are not usually checked from within action methods and are automatically checked by the MVC framework according to authorization attributes that decorate either the whole controller or a single action method. If an action method or the whole controller is decorated with <code class="inlineCode">[Authorize]</code>, then access to the action method is possible only if the request has a valid <a id="_idIndexMarker1118"/>authentication token, which means we don’t have to perform a check on the token claims. It is also possible to check whether the token contains a set of roles using the following code:</p>
<pre class="programlisting code"><code class="hljs-code">[Authorize(Roles = "Administrators,SuperUsers")]
</code></pre>
<p class="normal">More complex conditions on claims require that authorization policies be defined while building the app in <code class="inlineCode">Program.cs</code>, as shown in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">var builder = WebApplication.CreateBuilder(args);
// Add services to the container.
builder.Services.AddControllers();
...
builder.Services.AddAuthorization(options =&gt;
{
    options.AddPolicy("CanDrive", policy =&gt;
       policy.RequireAssertion(context =&gt;
       context.User.HasClaim(c =&gt; c.Type == "HasDrivingLicense")));
});
</code></pre>
<p class="normal">After that, you can decorate the action methods or controllers with <code class="inlineCode">[Authorize(Policy = "Father")]</code>.</p>
<p class="normal">Before using JWT-based authorization, you must configure it in <code class="inlineCode">Program.cs</code>. First, you must add the middleware that processes authentication tokens in ASP.NET Core, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">var app = builder.Build();
...
app.UseAuthorization();
app.MapControllers();
app.Run();
</code></pre>
<p class="normal">Then, you must configure the authentication services. There, you define the authentication options that will be<a id="_idIndexMarker1119"/> injected through dependency injection into the authentication middleware:</p>
<pre class="programlisting code"><code class="hljs-code">var builder = WebApplication.CreateBuilder(args);
// Add services to the container.
builder.Services.AddControllers();
...
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =&gt; {
        options.TokenValidationParameters =
          new TokenValidationParameters
          {
              ValidateIssuer = true,
              ValidateAudience = true,
              ValidateLifetime = true,
              ValidateIssuerSigningKey = true,
              ValidIssuer = "My.Issuer",
              ValidAudience = "This.Website.Audience",
              IssuerSigningKey = new
                  SymmetricSecurityKey(Encoding.ASCII.GetBytes("MySecret"))
          };
    });
</code></pre>
<p class="normal">The preceding code provides a name to the authentication scheme, that is, a default name. Then, it specifies JWT authentication options. Usually, we require that the authentication middleware verifies that the JWT is not expired (<code class="inlineCode">ValidateLifetime = true</code>), that it has the right issuer and audience (see the <em class="italic">REST service authorization and authentication</em> section of this chapter), and that its signature is valid.</p>
<p class="normal">The preceding example uses a symmetric signing key generated from a string. This means that the same key is used to sign and verify the signature. This is an acceptable choice if JWTs are created by the same website that uses them, but it is not an acceptable choice if there is a unique JWT issuer that controls access to several web API sites.</p>
<p class="normal">Here, we should use an asymmetric key (typically, an <code class="inlineCode">RsaSecurityKey</code>), so JWT verification requires just the knowledge of the public key associated with the actual private signing key. IdentityServer 4 can be used to quickly create a website that works as an authentication server. It emits a JWT with the usual username/password credentials or converts other authentication tokens. If you use an authentication server such as IdentityServer 4, you do not need to specify the <code class="inlineCode">IssuerSigningKey</code> option since the authorization middleware is able to retrieve the required public key from the authorization server automatically.</p>
<p class="normal">It is enough to provide the authentication server URL, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">.AddJwtBearer(options =&gt; {
options.Authority = "https://www.MyAuthorizationserver.com";
options.TokenValidationParameters =...
        ...
</code></pre>
<p class="normal">On the other hand, if you decide to emit a JWT in your web API’s site, you can define a <code class="inlineCode">Login</code> action method that accepts an<a id="_idIndexMarker1120"/> object with a username and password and that, while relying on database information, builds the JWT with code similar to the following:</p>
<pre class="programlisting code"><code class="hljs-code">var claims = new List&lt;Claim&gt;
{
   new Claim(...),
   new Claim(...) ,
   ...
};
var token = new JwtSecurityToken(
          issuer: "MyIssuer",
          audience: ...,
          claims: claims,
          expires: DateTime.UtcNow.AddMinutes(expiryInMinutes),
          signingCredentials:
          new SymmetricSecurityKey(Encoding.ASCII.GetBytes("MySecret"));
          return OK(new JwtSecurityTokenHandler().WriteToken(token));
</code></pre>
<p class="normal">Here, <code class="inlineCode">JwtSecurityTokenHandler().WriteToken(token)</code> generates the actual token string from the token properties contained in the <code class="inlineCode">JwtSecurityToken</code> instance.</p>
<p class="normal">In the next subsection, we will learn how to empower our web API with an OpenAPI documentation endpoint so that proxy classes for communicating with our services can be generated automatically.</p>
<h3 class="heading-3" id="_idParaDest-321">ASP.NET Core support for OpenAPI</h3>
<p class="normal">Most of the information that is needed to fill in an OpenAPI JSON document can be extracted from web API controllers <a id="_idIndexMarker1121"/>through reflection, that is, input types and sources (path, request body, and header) and endpoint paths (these can be extracted from routing rules). Returned output types and status codes, in general, cannot be easily computed since they can be generated dynamically.</p>
<p class="normal">Therefore, the MVC framework provides the <code class="inlineCode">ProducesResponseType </code>attribute so that we can declare a possible return type – a status code pair. It is enough to decorate each action method with as many <code class="inlineCode">ProducesResponseType</code> attributes as there are possible types, that is, possible status code pairs, as shown in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">[HttpGet("{id}")]
[ProducesResponseType(typeof(MyReturnType), StatusCodes.Status200OK)]
[ProducesResponseType(typeof(MyErrorReturnType), StatusCodes.Status404NotFound)]
public IActionResult GetById(int id)...
</code></pre>
<p class="normal">If no object is returned along a path, we can just declare the status code as follows:</p>
<pre class="programlisting code"><code class="hljs-code"> [ProducesResponseType(StatusCodes.Status403Forbidden)]
</code></pre>
<p class="normal">We can also specify just the status code when all the paths return the same type and when that type is specified in the action method return type as <code class="inlineCode">ActionResult&lt;CommonReturnType&gt;</code>.</p>
<p class="normal">Once all the action methods have been documented, to generate any actual documentation for the JSON endpoints, we must install the <code class="inlineCode">Swashbuckle.AspNetCore</code> NuGet package and place some code in the <code class="inlineCode">Program.cs</code> file:</p>
<div><p class="normal">In .NET 5+, you can automatically include it by leaving <strong class="keyWord">OpenAPI support</strong> checked when creating a project.</p>
</div>
<pre class="programlisting code"><code class="hljs-code">var builder = WebApplication.CreateBuilder(args);
...
//open api middleware
builder.Services.AddSwaggerGen(c =&gt;
{
    c.SwaggerDoc("v1", new() { Title = "WWTravelClubREST60", Version = "v1" });
});
var app = builder.Build();
...
app.UseSwagger();
app.UseSwaggerUI(c =&gt; c.SwaggerEndpoint("/swagger/v1/swagger.json", "WWTravelClubREST60 v1"));
...
app.Run();
</code></pre>
<p class="normal">The first argument of the <code class="inlineCode">SwaggerDoc</code> method is the documentation endpoint name. By default, the documentation endpoint is <a id="_idIndexMarker1122"/>accessible through the <code class="inlineCode">&lt;webroot&gt;//swagger/&lt;endpoint name&gt;/swagger.json</code> path, but this can be changed in several ways. The rest of the information contained in the <code class="inlineCode">Info</code> class is self-explanatory.</p>
<p class="normal">We can add several <code class="inlineCode">SwaggerDoc</code> calls to define several documentation endpoints. However, by default, all the documentation endpoints will contain the same documentation, which includes a description of all the REST services included in the project. This default can be changed by calling the <code class="inlineCode">c.DocInclusionPredicate(Func&lt;string, ApiDescription&gt; predicate)</code> method from within <code class="inlineCode">services.AddSwaggerGen(c =&gt; {...})</code>.</p>
<p class="normal"><code class="inlineCode">DocInclusionPredicate</code> must be passed a function that receives a JSON document name and an action method description and must return <code class="inlineCode">true</code> if the documentation of the action must be included in that JSON document.</p>
<p class="normal">To declare that your REST APIs need a JWT, you must add the following code within <code class="inlineCode">services.AddSwaggerGen(c =&gt; {...})</code>:</p>
<pre class="programlisting code"><code class="hljs-code">var security = new Dictionary&lt;string, IEnumerable&lt;string&gt;&gt;
{
    {"Bearer", new string[] { }},
};
c.AddSecurityDefinition("Bearer", new ApiKeyScheme
{
    Description = "JWT Authorization header using the Bearer scheme.
    Example: \"Authorization: Bearer {token}\"",
    Name = "Authorization",
    In = "header",
    Type = "apiKey"
});
c.AddSecurityRequirement(security);
</code></pre>
<p class="normal">You can enrich the JSON documentation endpoint with information that has been extracted from triple-slash comments, which are usually added to generate automatic code documentation. The following code shows some examples of this. The following snippet shows how we can add a method description and parameter information:</p>
<pre class="programlisting code"><code class="hljs-code">/// &lt;summary&gt;
/// Deletes a specific TodoItem.
/// &lt;/summary&gt;
/// &lt;param name="id"&gt;id to delete&lt;/param&gt;
[HttpDelete("{id}")]
public IActionResultDelete(long id)
</code>
 we can add an example of usage:</pre>
<pre class="programlisting code"><code class="hljs-code">/// &lt;summary&gt;
/// Creates an item.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Sample request:
///
/// POST /MyItem
/// {
/// "id": 1,
/// "name": "Item1"
/// }
///
/// &lt;/remarks&gt;
</code></pre>
<p class="normal">The following snippet shows how we can add parameter descriptions and return type descriptions for each HTTP status code:</p>
<pre class="programlisting code"><code class="hljs-code">/// &lt;param name="item"&gt;item to be created&lt;/param&gt;
/// &lt;returns&gt;A newly created TodoItem&lt;/returns&gt;
/// &lt;response code="201"&gt;Returns the newly created item&lt;/response&gt;
/// &lt;response code="400"&gt;If the item is null&lt;/response&gt;
</code></pre>
<p class="normal">To enable extraction from triple-slash comments, we must enable code documentation creation by adding the following code to our project file (<code class="inlineCode">.csproj</code>):</p>
<pre class="programlisting code"><code class="hljs-code">&lt;PropertyGroup&gt;
&lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;
&lt;NoWarn&gt;$(NoWarn);1591&lt;/NoWarn&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p class="normal">Then, we must enable code <a id="_idIndexMarker1124"/>documentation processing from within <code class="inlineCode">services.AddSwaggerGen(c =&gt; {...})</code> by adding the following code:</p>
<pre class="programlisting code"><code class="hljs-code">var xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
c.IncludeXmlComments(xmlPath);
</code></pre>
<p class="normal">Once our documentation endpoints are ready, we can add some more middleware that is contained in the same <code class="inlineCode">Swashbuckle.AspNetCore</code> NuGet package to generate a friendly user interface that we can test our REST API on:</p>
<pre class="programlisting code"><code class="hljs-code">app.UseSwaggerUI(c =&gt;
{
    c.SwaggerEndpoint("/swagger/&lt;documentation name&gt;/swagger.json", "
    &lt;api name that appears in dropdown&gt;");
});
</code></pre>
<p class="normal">If you have several documentation endpoints, you need to add a <code class="inlineCode">SwaggerEndpoint</code> call for each of them. We will use this interface to test the REST API defined in the book use case, presented in <em class="chapterRef">Chapter 21, Case Study</em>. There you will also find out how to use Postman, an API platform for building and using APIs.</p>
<p class="normal">Once you have a working JSON documentation endpoint, you can automatically generate the C# or TypeScript code of a proxy class, presented in <em class="chapterRef">Chapter 6, Design Patterns and .NET 8 Implementation</em>, with one of the following methods:</p>
<ul>
<li class="bulletList">The NSwagStudio Windows program, which is available at <a href="https://github.com/RicoSuter/NSwag/wiki/NSwagStudio">https://github.com/RicoSuter/NSwag/wiki/NSwagStudio</a>.</li>
<li class="bulletList">The <code class="inlineCode">NSwag.CodeGeneration.CSharp</code> or <code class="inlineCode">NSwag.CodeGeneration.TypeScript</code>NuGet packages if you want to customize code generation.</li>
<li class="bulletList">The <code class="inlineCode">NSwag.MSBuild</code> NuGet package if you want to tie code generation to Visual Studio build operations. The documentation for this can be found at <a href="https://github.com/RicoSuter/NSwag/wiki/NSwag.MSBuild">https://github.com/RicoSuter/NSwag/wiki/NSwag.MSBuild</a>.</li>
</ul>
<p class="normal">In the next subsection, you will learn how to invoke a REST API from another REST API or from a .NET client.</p>
<h3 class="heading-3" id="_idParaDest-322">.NET HTTP clients</h3>
<p class="normal">The <code class="inlineCode">HttpClient</code> class in the <code class="inlineCode">System.Net.Http</code> namespace is a .NET Standard 2.0 built-in HTTP client class. While it could be used directly whenever we need to interact with a REST service, there are some problems<a id="_idIndexMarker1125"/> in creating and releasing <code class="inlineCode">HttpClient</code> instances repeatedly, as follows:</p>
<ul>
<li class="bulletList">Their creation is expensive.</li>
<li class="bulletList">When an <code class="inlineCode">HttpClient</code> is released, for instance, in a using statement, the underlying connection is not closed immediately but at the first garbage collection session. Therefore, repeated creation and release operations quickly exhaust the maximum number of connections the operating system can handle.</li>
</ul>
<p class="normal">Therefore, either a single <code class="inlineCode">HttpClient</code> instance is reused, such as a Singleton, or <code class="inlineCode">HttpClient</code> instances are somehow pooled. Starting from the 2.1 version of .NET Core, the <code class="inlineCode">HttpClientFactory</code> class was introduced to pool HTTP clients. More specifically, whenever a new <code class="inlineCode">HttpClient</code> instance is required for an <code class="inlineCode">HttpClientFactory</code> object, a new <code class="inlineCode">HttpClient</code> is created. However, the underlying <code class="inlineCode">HttpClientMessageHandler</code> instances, which are expensive to create, are pooled until their maximum lifetime expires.</p>
<p class="normal"><code class="inlineCode">HttpClientMessageHandler</code> instances must have a finite duration since they cache DNS resolution information that may change over time. The default lifetime of <code class="inlineCode">HttpClientMessageHandler</code> is 2 minutes, but it can be redefined by the developer.</p>
<p class="normal">Using <code class="inlineCode">HttpClientFactory</code> allows us to automatically pipeline all the HTTP operations with other operations. For instance, we can add a Polly retry strategy to handle all the failures of all our HTTP operations automatically. For an introduction to Polly, please refer to the <em class="italic">Resilient task execution</em> subsection of <em class="italic">Chapter 5</em>, <em class="italic">Implementing Code Reusability in C# 12</em>.</p>
<p class="normal">The simplest way to exploit the advantages offered by the <code class="inlineCode">HttpClientFactory</code> class is to add the <code class="inlineCode">Microsoft.Extensions.Http</code> NuGet package and then follow these steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Define a proxy class, say, <code class="inlineCode">MyProxy</code>, to interact with the desired REST service.</li>
<li class="numberedList">Let <code class="inlineCode">MyProxy</code> accept an <code class="inlineCode">HttpClient</code> instance in its constructor.</li>
<li class="numberedList">Use the <code class="inlineCode">HttpClient</code> that was injected into the constructor to implement all the necessary operations.</li>
<li class="numberedList">Declare your proxy in the services configuration method of your host, which, in the case of an ASP.NET Core application, is in the <code class="inlineCode">Program.cs</code> class. In the simplest case, the declaration is something similar to <code class="inlineCode">builder.Services.AddHttpClient&lt;MyProxy&gt;()</code>.</li>
</ol>
<p class="normal">This will automatically add <code class="inlineCode">MyProxy</code> to the services that are available for dependency injection, so you can easily inject it, for instance, in your controller’s constructors. Moreover, each time an instance of <code class="inlineCode">MyProxy</code> is created, an <code class="inlineCode">HttpClient</code> is returned by an <code class="inlineCode">HttpClientFactory</code> and is automatically<a id="_idIndexMarker1126"/> injected into its constructor.</p>
<p class="normal">In the constructors of the classes that need to interact with a REST service, we may also need an interface instead of a specific proxy implementation with a declaration of the type:</p>
<pre class="programlisting code"><code class="hljs-code">builder.Services.AddHttpClient&lt;IMyProxy, MyProxy&gt;()
</code></pre>
<p class="normal">This way, each client that is passed to the proxy is preconfigured so that it requires a JSON response and must work with a specific service. Once the base address has been defined, each HTTP request needs to specify the relative path of the service method to call.</p>
<p class="normal">The following code shows how to perform a <code class="inlineCode">POST</code> to a service. This requires an extra package, <code class="inlineCode">System.Net.Http.Json</code>, because of the usage of <code class="inlineCode">PostAsJsonAsync</code>. Here, we are stating that the <code class="inlineCode">HttpClient</code> that was injected into the proxy constructor has been stored in the <code class="inlineCode">webClient</code> private field:</p>
<pre class="programlisting code"><code class="hljs-code">//Add a bearer token to authenticate the call
webClient.DefaultRequestHeaders.Add("Authorization", "Bearer " + token);
...
//Call service method with a POST verb and get response
var response = await webClient.PostAsJsonAsync&lt;MyPostModel&gt;("my/method/relative/path",
    new MyPostModel
    {
        //fill model here
        ...
    });
//extract response status code
var status = response.StatusCode;
...
//extract body content from response
string stringResult = await response.Content.ReadAsStringAsync();
</code></pre>
<p class="normal">If you use Polly, you do not need to intercept and handle communication errors since this job is performed by Polly. First, you need to verify the status code to decide what to do next. Then, you can parse the JSON string contained in the response body to get a .NET instance of a type that, in general, depends on the status code. The code to perform the parsing is based <a id="_idIndexMarker1127"/>on the <code class="inlineCode">System.Text.Json</code> NuGet package’s <code class="inlineCode">JsonSerializer</code> class and is as follows:</p>
<pre class="programlisting code"><code class="hljs-code">var result =
  JsonSerializer.Deserialize&lt;MyResultClass&gt;(stringResult);
</code></pre>
<p class="normal">Performing a <code class="inlineCode">GET</code> request is similar, but instead of calling <code class="inlineCode">PostAsJsonAsync</code>, you need to call <code class="inlineCode">GetAsync</code>, as shown here. The use of other HTTP verbs is completely analogous:</p>
<pre class="programlisting code"><code class="hljs-code">var response =
  await webClient.GetAsync("my/getmethod/relative/path");
</code></pre>
<p class="normal">As you can see from this section, accessing HTTP APIs is quite simple and requires the implementation of some .NET 6 libraries. Since the beginning of .NET Core, Microsoft has been working a lot on improving the performance and simplicity of this part of the framework. It is up to you to keep yourself updated on the documentation and facilities they keep implementing.</p>
<h1 class="heading-1" id="_idParaDest-323">Summary</h1>
<p class="normal">In this chapter, we introduced SOA, its design principles, and its constraints. Among them, interoperability is worth remembering.</p>
<p class="normal">Then, we focused on well-established standards for business applications that achieve the interoperability that is needed for publicly exposed services. Therefore, SOAP and REST services were discussed in detail, along with the transition from SOAP services to REST services that has taken place in most application areas in the last few years. Then, REST service principles, authentication/authorization, and documentation were described in greater detail.</p>
<p class="normal">Finally, we looked at the tools that are available in .NET 8 that we can use to implement and interact with services. We looked at a variety of frameworks for intra-cluster communication, such as .NET remoting and gRPC, and tools for SOAP- and REST-based public services.</p>
<p class="normal">Here, we mainly focused on REST services. Their ASP.NET Core implementations were described in detail, along with the techniques we can use to authenticate/authorize them and their documentation. We also focused on how to implement efficient .NET proxies so that we can interact with REST services.</p>
<p class="normal">In the next chapter, we will learn how to use .NET 8 to implement microservices with ASP.NET Core.</p>
<h1 class="heading-1" id="_idParaDest-324">Questions</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Can services use cookie-based sessions?</li>
<li class="numberedList">Is it good practice to implement a service with a custom communication protocol? Why or why not?</li>
<li class="numberedList">Can a <code class="inlineCode">POST</code> request to a REST service cause a deletion?</li>
<li class="numberedList">How many dot-separated parts are contained in a JWT bearer token?</li>
<li class="numberedList">By default, where are the complex type parameters of a REST service’s action methods taken from?</li>
<li class="numberedList">How is a controller declared as a REST service?</li>
<li class="numberedList">What are the main documentation attributes of ASP.NET Core services?</li>
<li class="numberedList">How are ASP.NET Core REST service routing rules declared?</li>
<li class="numberedList">How should a proxy be declared so that we can take advantage of .NET <code class="inlineCode">HttpClientFactory</code> class features?</li>
</ol>
<h1 class="heading-1" id="_idParaDest-325">Further reading</h1>
<ul>
<li class="bulletList">This chapter mainly focused on the more commonly used REST service. If you are interested in SOAP services, a good place to start is the Wikipedia page regarding SOAP specifications: <a href="https://en.wikipedia.org/wiki/List_of_web_service_specifications">https://en.wikipedia.org/wiki/List_of_web_service_specifications</a>. On the other hand, if you are interested in the Microsoft .NET WCF technology for implementing SOAP services, you can refer to WCF’s official documentation here: <a href="https://docs.microsoft.com/en-us/dotnet/framework/wcf/">https://docs.microsoft.com/en-us/dotnet/framework/wcf/</a>.</li>
<li class="bulletList">This chapter mentioned the AMQP protocol as an option for intra-cluster communication without describing it. Detailed information on this protocol is available on AMQP’s official site: <a href="https://www.amqp.org/">https://www.amqp.org/</a>.</li>
<li class="bulletList">More information on gRPC is available on Google gRPC’s official site: <a href="https://grpc.io/">https://grpc.io/</a>. More information on the Visual Studio gRPC project template can be found here: <a href="https://docs.microsoft.com/en-US/aspnet/core/grpc/">https://docs.microsoft.com/en-US/aspnet/core/grpc/</a>. You may also want to check out gRPC-Web at <a href="https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/">https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/</a>.</li>
<li class="bulletList">More details on ASP.NET Core services are available in the official documentation: <a href="https://docs.microsoft.com/en-US/aspnet/core/web-api/">https://docs.microsoft.com/en-US/aspnet/core/web-api/</a>. More information on the .NET HTTP client is available here: <a href="https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests">https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests</a>.</li>
<li class="bulletList">Minimal APIs are described at <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis</a>.</li>
<li class="bulletList">More information on JWT authentication is available here: <a href="https://jwt.io/">https://jwt.io/</a>. If you would like to generate JWTs with IdentityServer, you may refer to its official documentation page: <a href="https://docs.duendesoftware.com/identityserver/v7">https://docs.duendesoftware.com/identityserver/v7</a>.</li>
<li class="bulletList">More information on OpenAPI is available at <a href="https://swagger.io/docs/specification/about/">https://swagger.io/docs/specification/about/</a>, while more information on Swashbuckle can be found on its GitHub repository page: <a href="https://github.com/domaindrivendev/Swashbuckle">https://github.com/domaindrivendev/Swashbuckle</a>.</li>
</ul>
<h1 class="heading-1">Leave a review!</h1>
<p class="normal">Enjoying this book? Help readers like you by leaving an Amazon review. Scan the QR code below for a 20% discount code.</p>
<p class="normal"><img alt="" role="presentation" src="img/Leave_a_review_QR.png"/></p>
<p class="normal"><em class="italic">*Limited Offer</em></p>
</div>
</body></html>