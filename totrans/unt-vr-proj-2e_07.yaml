- en: Locomotion and Comfort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point in this book, the player's point-of-view camera has been stationary.
    In this chapter, we'll start to move around as we consider various techniques
    for locomotion and teleportation. First, we'll dig deeper into the Unity standard
    character components, and then we move ourselves into a controllable first-person
    character and explore techniques to move around in the virtual world. We'll also
    discuss practices for managing motion sickness and sense of self within VR.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Unity's character objects and components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Glide locomotion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comfort mode locomotion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teleportation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issues around VR motion sickness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the projects in this chapter are separate and not directly required
    by the other chapters in this book. If you decide to skip any of it or not save
    your work, that's OK.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Unity characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A first-person character is such a key asset in a VR project that we really
    should understand its components inside out. So, before we go about building one
    for our project, it would be a good idea to take a close look at the built-in
    components and standard assets that Unity provides.
  prefs: []
  type: TYPE_NORMAL
- en: Unity components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you probably know, each Unity game object contains a set of associated **components**.
    Unity includes many types of built-in components, which you can see by browsing
    the Component menu in the main menu bar. Each component adds properties and behaviors
    to the object that it belongs to. A component's properties are accessible via
    the Unity editor's Inspector panel and scripts. A script attached to a game object
    is also a type of a component and may have properties that you can set in the
    Inspector panel.
  prefs: []
  type: TYPE_NORMAL
- en: The component types used to implement first-person characters include the **Camera**,
    **Character Controller**, and/or **Rigidbody**, and various scripts. Let's review
    each of these standard components.
  prefs: []
  type: TYPE_NORMAL
- en: The Camera component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Camera component specifies the viewing parameters that are used to render
    the scene on each frame update. Any object with a Camera component is considered
    a `camera` object. Naturally, we've been using a camera in our scenes since we
    started, and we've been accessing it in the scripts that we've written.
  prefs: []
  type: TYPE_NORMAL
- en: A stereographic VR camera object renders two views, one for each eye. In VR,
    the camera controller scripts read data from the headset's motion sensors and
    positional tracking to determine the current head pose (position, direction, and
    rotation) and set the camera's transform appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: The Rigidbody component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you add a Rigidbody component to any Unity game object, it will benefit
    from the calculations that are performed by the **physics engine**. Rigidbody
    components have parameters for gravity, mass, and drag, among others. During gameplay,
    the physics engine calculates each rigid object's *momentum* (mass, speed, and
    direction).
  prefs: []
  type: TYPE_NORMAL
- en: Rigid objects interact with other rigid objects. For example, if they collide,
    they'll bounce off each other and the parameters of the interaction can be controlled
    with a **physic material** with properties such as friction and bounciness factors.
  prefs: []
  type: TYPE_NORMAL
- en: Rigidbodies can be flagged as *kinematic*, which is usually only used when the
    object is driven by animation or scripts. Collisions will not affect kinematic
    objects, but they will still affect the motion of other rigidbodies. It's mostly
    used when objects are chained together with *joints*, like the ones connecting
    a humanoid's bones or a swinging pendulum.
  prefs: []
  type: TYPE_NORMAL
- en: Any rigid object, given a child camera object, becomes a rigid first-person
    character. Then, you can add scripts to handle user input to move, jump, look
    around, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The Character Controller component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like a Rigidbody, the **Character Controller** (**CC**) is used for *collision
    detection* and c*haracter movement*. It needs scripts to handle the user input
    to move, jump, and look around, too. However, it doesn't automatically have the
    physics built in.
  prefs: []
  type: TYPE_NORMAL
- en: The CC component is specifically designed for character objects because characters
    in a game often are not really expected to behave the same as other physics-based
    objects. It can be used instead of, or in addition to, a Rigidbody.
  prefs: []
  type: TYPE_NORMAL
- en: The CC component has a built-in **Capsule Collider** behavior to detect collisions.
    However, it doesn't automatically use the physics engine to *respond* to the collision.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a CC object hits a rigid object such as a wall, it will just
    stop. It won't bounce. If a rigid object, such as a flying brick, hits a CC object,
    the brick will get deflected (bounce) based on its own properties, but the CC
    object will not be affected. Of course, if you want to include behavior like this
    on the CC object, you can program that in your own scripts.
  prefs: []
  type: TYPE_NORMAL
- en: The CC component does have an especially good support for one force in its scripting
    API-*gravity*. Built-in parameters are specifically related to keeping the object's
    feet on the ground. For example, the Step Offset parameter defines how tall a
    step the character can hop onto rather than being an obstacle that blocks his
    way. Similarly, the Slope Limit parameter says how big an incline is too steep
    and whether it should be treated like a wall. In your scripts, you can use the
    `Move()` method and the `IsGrounded` variable to implement character behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Unless you script it, a CC object has no momentum and can stop on a dime. It
    feels very precise, but this could also lead to a jerky movement. The opposite
    is true for Rigidbody objects, which feel more fluid because they have momentum,
    acceleration/deceleration, and obey the laws of physics. In VR, we'd ideally like
    some combination of the two, if we use it at all.
  prefs: []
  type: TYPE_NORMAL
- en: Using physics to move yourself through a VR scene is not always best. As we'll
    see, alternative locomotion techniques may not use physics at all, such as *teleportation*.
  prefs: []
  type: TYPE_NORMAL
- en: Unity Standard Assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Characters package in Unity Standard Assets comes with a number of third-
    and first-person character prefab objects. These prefab objects are compared in
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Prefab | Components |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/d0940b8a-38a4-4b13-969a-4b1b5cac138b.png) | ![](img/a8740890-7967-42fd-af07-5609c393eac4.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/490989ab-841b-495a-9204-5646b413ac21.png) | ![](img/1032403f-6ec8-4c8b-b24f-aa129728c7a5.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/bfab0187-3824-4c3b-a5f7-a48911127869.png) | ![](img/85e9a57d-f56a-445a-889c-a68517db4061.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/44832510-485f-43ea-a8e5-6752cd33d34f.png) | ![](img/569cf22a-f936-4118-aa06-9b2b11755af7.png)
    |'
  prefs: []
  type: TYPE_TB
- en: Let's discuss this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: ThirdPersonController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already used both of the third-person prefabs, `ThirdPersonController`
    and `AIThirdPersonController`, in [Chapter 2](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml),
    *Content, Objects, and Scale*, and [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml),
    *Gaze-Based Control*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `ThirdPersonController` prefab has child objects that define the character's
    body, namely our friend Ethan. He is a rigged avatar (from the `.fbx` file), which
    means that humanoid animations can be applied to make him walk, run, jump, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: The `ThirdPersonController` prefab uses a Rigidbody for physics and Capsule
    Collider for collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: It has two scripts. A `ThirdPersonUserControl` script takes user input, such
    as thumbstick presses, and tells the character to move, jump, and so on. A `ThirdPersonCharacter`
    script implements physics movements and calls the animations that are needed for
    running, crouching, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: AIThirdPersonController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `AIThirdPersonController` prefab is identical to the `ThirdPersonController`
    prefab, but the former adds a `NavMeshAgent` and an `AICharacterControl` script,
    which constrains where and how the character can move around the scene. If you
    recall, in [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml), *Gaze-Based
    Control*, we used the `AICharacterController` to make Ethan walk around the scene
    and avoid bumping into objects.
  prefs: []
  type: TYPE_NORMAL
- en: First-person FPSController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FPSController` prefab is a first-person controller that uses both a CC
    component and a Rigidbody. It has a child camera attached to it. When the character
    moves, the camera moves with it.
  prefs: []
  type: TYPE_NORMAL
- en: The core distinction between third-person controller prefabs and first-person
    controller prefabs is the **child object**. Third-person controller prefabs have
    a rigged humanoid child object, while first-person controller prefabs have a camera
    child object.
  prefs: []
  type: TYPE_NORMAL
- en: Its body mass is set to a low value (`1`) and `IsKinematic` is enabled. This
    means that it will have limited momentum and does not react to other rigid objects,
    but it can be driven by animations.
  prefs: []
  type: TYPE_NORMAL
- en: Its `FirstPersonController` script offers a plethora of parameters for running,
    jumping, audio footsteps, and more. The script also includes parameters and animations
    for a *head bob*, which bounces the camera in a natural way when the character
    is moving. If you use the `FPSController` script in your VR project, *be sure
    to disable any head bob features* or you might need to clean the puke off your
    keyboard!
  prefs: []
  type: TYPE_NORMAL
- en: RigidBodyFPSController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `RigidBodyFPSController` prefab is a first-person controller with a Rigidbody
    but no CC component. Like `FPSController`, it has a child camera object. When
    the character moves, the camera moves with it.
  prefs: []
  type: TYPE_NORMAL
- en: A `RigidBodyFPSController` prefab's body mass is more substantial, set to 10,
    and is not kinematic. That is, it *can* get bounced around when it collides with
    other objects. It has a separate Capsule Collider component with the `ZeroFriction`
    physic material. The `RigidBodyFirstPersonController` script is different from
    the `FPSController` one, but the former has a lot of similar parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why am I going through all of this detail here?** If you''ve built any non-VR
    projects in Unity, then you''ve most likely used these prefabs. However, you might
    not have paid much attention to how they''re assembled. Virtual reality is experienced
    from the first-person perspective. Our implementation toolbox is Unity. It is
    important to understand Unity''s tools that manage and control this first-person
    experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Using glide locomotion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our locomotion features in this chapter, let's take an *agile* approach
    to development. This means (in part) that we'll start by defining our new feature,
    or story, with a set of requirements. Then, we'll incrementally build and test
    this feature, one requirement at a time, by iterating and refining our work as
    we go along. Experimentation is not only allowed, it's encouraged.
  prefs: []
  type: TYPE_NORMAL
- en: '**Agile software development** is a broad term for methodologies that encourage
    small incremental and iterative development in a fashion that''s easy to respond
    to changing and refined requirements. See the Agile Manifesto at [http://agilemanifesto.org/](http://agilemanifesto.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The feature we want to implement is this: as a first-person character, when
    I start walking, I will move through the scene in the direction I am looking until
    I indicate to stop walking. Here are the requirements to achieve this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: Move in the direction you're looking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep your feet on the ground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't pass through solid objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't fall off the edge of the world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step over small objects and handle uneven terrain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start and stop moving by clicking an input button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This sounds reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, if you have a saved version of the scene from [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml),
    *Gaze-Based Control*, you can start with that. Or, build a similar simple new
    scene containing a ground plane, some 3D objects as obstacles, and a copy of your
    `MeMyselfEye` prefab.
  prefs: []
  type: TYPE_NORMAL
- en: Move in the direction you're looking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already have a `MeMyselfEye` object containing the camera rig. We''re going
    to turn it into a first-person controller. Our first requirement is to move about
    the scene in the direction you''re looking. Add a script named `GlideLocomotion`.
    Keeping it simple, let''s start by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `MeMyselfEye` object in the Hierarchy panel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, select Add Component | New Script and name it `GlideLocomotion`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, open the script and code it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The normal walking speed for humans is about 1.4 meters per second. In VR, that
    could make you feel sick. Let's travel a lot slower than that, at 0.4 m/s. During
    `Update()`, we check the current direction in which the player is looking (`camera.transform.forward`)
    and move the `MeMyselfEye` transform position in this direction at the current
    velocity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the coding shortcuts for the self-modification of a variable (`*=` and
    `+=`). The last two lines of the preceding code could have been written out like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, I used the `*=` and `+=` operators instead. Save the script and the scene
    and try it in VR.
  prefs: []
  type: TYPE_NORMAL
- en: When you look forward, you move forward. Look left, move left. Look right, move
    right. It works!
  prefs: []
  type: TYPE_NORMAL
- en: Look up... *Whoa!! Did you expect that?! We're freakin' flying!* You can move
    up, down, and all around as if you're Superman or piloting a drone. Presently,
    `MeMyselfEye` has no mass and physics and does not respond to gravity. Nonetheless,
    it meets our requirement to move in the direction you're looking. So, let's continue.
  prefs: []
  type: TYPE_NORMAL
- en: Keep your feet on the ground
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next requirement wants you to keep your feet on the ground. We know that
    `GroundPlane` is flat and positioned at Y = `0`. So, let''s just add this simple
    constraint to the `GlideLocomotion` script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Save the script and try it in VR.
  prefs: []
  type: TYPE_NORMAL
- en: Not bad. Now, we can move around the Y = `0` plane.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, you're like a ghost, readily passing through the cube, sphere,
    and the other objects.
  prefs: []
  type: TYPE_NORMAL
- en: Don't pass through solid objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The third requirement states *don''t pass through solid objects*. Here''s an
    idea. Give it a Rigidbody component, a collider, and let the physics engine take
    care of it. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `MeMyselfEye` object in the Hierarchy panel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, navigate to Add Component | Physics | Rigidbody
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then Add Component | Physics | Capsule Collider
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Capsule Collider Height to 2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your Character Controller's capsule collider (green mesh in the Scene window)
    extends through the ground plane, adjusts its Center Y to `1`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try it in VR.
  prefs: []
  type: TYPE_NORMAL
- en: '*Whoa!! What the...?* It was going fine there for a second, but as soon as
    you knock into the cube, you go spinning out of control in wild directions, like
    a spacewalk gone bad in the movie *Gravity*. Well, that''s a Rigidbody for you.
    Forces are being applied in all directions and axes. Let''s add some constraints
    as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Inspector panel''s Rigidbody pane, check off the checkboxes for Freeze
    Position: Y and Freeze Rotation: X and Z.'
  prefs: []
  type: TYPE_NORMAL
- en: Try it in VR.
  prefs: []
  type: TYPE_NORMAL
- en: Now that's pretty nice! You're able to move by looking in a direction, you're
    not flying (Y position constrained), and you don't pass through solid objects.
    Instead, you slide past them since only the Y rotation is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: If your `KillTarget` script is still running (from [Chapter 2](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml),
    *Content, Objects, and Scale*), you should be able to stare at Ethan until he
    explodes. Do it, make Ethan explode... *Whoa!* We just got blown out of here by
    the explosion, spinning out of control in wild directions again. Maybe we're just
    not ready for this powerful physics engine yet. We can probably address this in
    the scripting, but for the time being, let's abandon the Rigidbody idea. We'll
    come back to it in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may recall that CC includes a Capsule Collider and supports movement that
    is constrained by collisions. We''ll try that instead, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Inspector panel, click on the Rigidbody pane's *gear* icon and select
    Remove Component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, remove its Capsule Collider component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector panel, navigate to Add Component | Physics | Character Controller
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your Character Controller's capsule collider (green mesh in the Scene window)
    extends through the ground plane, adjusts its Center Y to `1`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `GlideLocomotion` script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Instead of updating `transform.position` directly, we called the built-in `CharacterController.Move()`
    function and let it do it for us. It knows that the characters should behave with
    certain constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script and try it in VR.
  prefs: []
  type: TYPE_NORMAL
- en: This time, when we bump into objects (a cube or sphere), we kind of go over
    it and then remain in the air. The `Move()` function does not apply gravity to
    the scene for us. We need to add that to the script, which isn't so hard (see
    the Unity API docs at [http://docs.unity3d.com/ScriptReference/CharacterController.Move.html](http://docs.unity3d.com/ScriptReference/CharacterController.Move.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a simpler way. The `CharacterController.SimpleMove()` function
    applies gravity to the move for us. Just replace the whole `Update()` function
    with the following one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `SimpleMove()` function takes care of gravity and also handles `Time.deltaTime`.
    So, all that we need to give it is the movement direction vector. Also, since
    it's introducing gravity, we don't need the Y = `0` constraint either. Much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script and try it in VR.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! I think we've met all the requirements so far. *Just don't go walking
    off the edge...*
  prefs: []
  type: TYPE_NORMAL
- en: The exercises in this section assume you're using VR in seated or standing mode,
    not room-scale. We're modifying the whole MyMyselfEye rig as we move the player.
    In room-scale, that's moving the play area bounds as well. Since we're attaching
    the collider to the MyMyselfEye position, if you physically step away from the
    center of the play area, the collider will not be aligned with your actual body
    position. Later on, we will address issues of locomotion with room-scale VR.
  prefs: []
  type: TYPE_NORMAL
- en: Don't fall off the edge of the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have gravity, if we walk off the edge of the ground plane, you'll
    fall into oblivion. Fixing this isn't a first-person character thing. Just add
    some railings to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use cubes, scaling them to the desired thickness and length and moving them
    into position. Go ahead and do it. I won''t give you the step-by-step instructions
    for it. For example, I used these transforms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scale: `0.1`, `0.1`, `10.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Railing 1: Position: `-5`, `1`, `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Railing 2: Position: `5`, `1`, `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Railing 3: Position: `0`, `1`, `-5`; Rotation: `0`, `90`, `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Railing 4: Position: `0`, `1`, `5`; Rotation: `0`, `90`, `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try it in VR. Try to walk through the railings. Whew! This is safer.
  prefs: []
  type: TYPE_NORMAL
- en: Stepping over small objects and handling uneven terrain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we''re at it, add a few things to walk on and over, such as a ramp and
    other obstacles. The result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/216d0ee2-2f12-4c85-8a59-38ca4a4ea4ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Try it in VR. Walk up the ramp and step off the cube. Hey, this is fun!
  prefs: []
  type: TYPE_NORMAL
- en: The CC component is taking care of the requirement to step over small objects
    and handle uneven terrain. You might want to tinker with its Slope Limit and Step
    Offset settings.
  prefs: []
  type: TYPE_NORMAL
- en: '**Caution**: Glide locomotion can cause motion sickness, especially for players
    who are susceptible. Please use it with caution in your apps. This may become
    especially noticeable as you glide up the ramp and then jump off the block onto
    the ground plane. On the other hand, some people love rollercoaster VR! Also,
    giving the player control of the locomotion through a mechanic as simple as a
    button press can go a long way in helping reduce queasiness and motion sickness,
    which we''ll add next.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting and stopping movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next requirement is *to start and stop moving by clicking an input button*.
    We'll look for a button press using the logical `"Fire1"` button. If you want
    to use a different button, or if you're targeting a platform that does not have
    a mapping to `"Fire1"` please refer to [Chapter 5](21722631-9544-4b1e-a888-877d34b0fff7.xhtml),
    *Handy Interactables*, under the topic *Basic button input*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `GlideLocomotion` script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: On Daydream, you may call `GvrControllerInput.ClickButtonDown` and `ClickButtonUp` instead.
  prefs: []
  type: TYPE_NORMAL
- en: By adding a Boolean `isWalking` flag, we can switch the forward movement on
    and off, which can be signaled by a key press.
  prefs: []
  type: TYPE_NORMAL
- en: Adding comfort mode locomotion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have mentioned the potential of motion sickness several times already in
    this chapter, and earlier in this book. In general, the more control you give
    the player in moving around within VR the better off she'll be and reduce the
    risk of feeling queasy. Offering a button to start/stop motion is one step, as
    we just saw. Another is what's commonly referred to as *comfort mode*.
  prefs: []
  type: TYPE_NORMAL
- en: It's been discovered that using glide locomotion around curves is worse that
    simply going in a straight line. So, one technique for getting around in a VR
    scene is only allow forward motion, regardless of which direction the player is
    looking, and then use the thumbstick to change direction. Also, rather than allow
    the thumbstick to change the direction angle continuously, we limit it to fixed
    angle steps of 30 degrees, for example. We'll add this to our `GlideLocomotion`
    script as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the class, add the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in `Update()`, add the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the `"Fire1"` button is pressed and `isWalking` is true, we move the
    `MeMyselfEye` forward in the direction indicated in its transform, rather than
    the `Camera` look directions, changing the line to `character.SimpleMove(transform.forward
    * velocity)`.
  prefs: []
  type: TYPE_NORMAL
- en: When the user pushes the thumbstick to the right, that is, the logical `"Horizontal"`
    axis is positive, we will rotate the rig clockwise by 30 degrees (`comfortAngle`).
    When the thumbstick is pressed left, we rotate counter-clockwise. We check for
    greater than 0.5 rather than exactly 1.0 so the player does not need to jam the
    stick all the way to the edge.
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to keep rotating, again and again, each update while the joystick
    is pressed, so we set a flag, `hasRotated`, and then ignore the axis until it
    comes to rest at the zero position. Then, we'll allow the player to press it again.
  prefs: []
  type: TYPE_NORMAL
- en: The result is a comfortable navigation mechanic where one button moves you forward
    and another lets you change direction in large increments.
  prefs: []
  type: TYPE_NORMAL
- en: 'For your reference, some button mappings used in this mechanic are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In OpenVR on HTC VIVE, `"Fire1"` is the menu button on one controller, `"Horizontal"`
    is touching the touchpad on the other controller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In OpenVR on Oculus, `"Fire1"` is the right controller's B button, `"Horizontal"`
    is the left controller thumbstick.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On Daydream, you should modify the code to use `GvrControllerInput`. To detect
    horizontal clicks on the touchpad, call `GvrControllerInput.TouchPosCentered`,
    which returns a `Vector2`, and check `x` for values between `-1` and `1`. For
    example, replace the call to GetAxis with the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You're encouraged to extend the `ButtonTest()` function used in the beginning
    of [Chapter 5](21722631-9544-4b1e-a888-877d34b0fff7.xhtml), *Handy Interactables*,
    to determine which button mappings, axes, and SDK functions work best for your
    target VR device.
  prefs: []
  type: TYPE_NORMAL
- en: We just implemented glide locomotion, where you move forward smoothly in the
    direction you're looking, or with comfort mode, in the direction your body is
    facing, while your head can look around. Comfort mode reduces the chance of motion
    sickness by having you change the direction you're facing in jumps of 30-degree
    angles. But even that may not be comfortable enough, and some developers (and
    players) prefer no gliding at all, and instead let you just *teleport* from one
    location to another.
  prefs: []
  type: TYPE_NORMAL
- en: Other locomotion considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to offer your players a VR ride, you can define a predefined *track* to
    glide along, like a guided tour of a building or art gallery. Tracks can be 3D,
    moving you up and down too, with gravity, such as VR roller coasters, or without
    gravity, such as a space tour. We do not recommend this mechanic except for the
    most hardcore thrill seekers as it has a good chance of causing motion sickness.
  prefs: []
  type: TYPE_NORMAL
- en: Another technique for comfort during locomotion is **Tunneling**. During the
    movement, the camera is cropped with a vignette and simple background, like a
    grid, is displayed in the player's peripheral vision, so the user only sees what
    is directly before them. Eliminating peripheral vision while moving can reduce
    the chance of motion sickness.
  prefs: []
  type: TYPE_NORMAL
- en: For vertical locomotion, apps have implemented a climbing mechanic, using your
    hands to reach, grab, and pull yourself up. Mountain climbing simulation games
    such as The Climb ([http://www.theclimbgame.com/](http://www.theclimbgame.com/))
    takes this idea to the next level (literally!), providing a number of different
    reach mechanics and grip types to grab onto.
  prefs: []
  type: TYPE_NORMAL
- en: Other apps have also tried using your hands, not for climbing, but for walking.
    For example, reaching and pulling like a rope, or swinging your arms like a runner,
    or even a circular pulling motion like you're operating a wheelchair.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there are hardware devices, such as that implement locomotion mechanisms
    using your feet to walk and run. Examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: VR treadmills such as Virtuix Omni ([http://www.virtuix.com/](http://www.virtuix.com/))
    and VR Virtualizer ([https://www.cyberith.com/](https://www.cyberith.com/)), where
    you walk in place with your feet and legs to walk and run in VR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise bikes such as VirZoom ([https://www.virzoom.com/](https://www.virzoom.com/))
    where you can bike and even hang glide in VR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Body tracking sensors can be used not just for player locomotion but also motion
    capture for creating character animations. Devices include Optitrack ([http://optitrack.com/motion-capture-virtual-reality/](http://optitrack.com/motion-capture-virtual-reality/)),
    Perception Neuron ([https://neuronmocap.com/](https://neuronmocap.com/)), ProVR
    ([http://www.vrs.org.uk/virtual-reality-gear/motion-tracking/priovr.html](http://www.vrs.org.uk/virtual-reality-gear/motion-tracking/priovr.html)),
    and others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You probably need to write your app specifically for that device as there are
    no standards for these body tracking devices, but they're certainly a lot of fun.
  prefs: []
  type: TYPE_NORMAL
- en: Techniques for teleportation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Pointer teleportation** is a mechanic where you point to a location you want
    to go to, and you jump there. No gliding. You just teleport to the new location.
    A laser beam or arc may be drawn, along with a teleport location receptacle to
    indicate where you may go.'
  prefs: []
  type: TYPE_NORMAL
- en: As we've seen in previous chapters, we can make our own scripts. But since this
    is a core feature of VR applications, teleportation components are often included
    with device SDK toolkits. We'll write our own and consider some provided ones
    afterward.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, if you have a saved version of the scene from [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml), *Gaze-Based
    Control*, you can start with that. You may disable a few objects that we do not
    need, including `Ethan` and `WalkTarget`. Or, build a similar simple new scene
    containing a ground plane, some 3D objects as obstacles, and a copy of your `MeMyselfEye`
    prefab.
  prefs: []
  type: TYPE_NORMAL
- en: Looking to teleport
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mechanic we'll implement for our homegrown teleportation will work on any
    VR platform, using gaze-based pointing. Similar to how we controlled Ethan the
    zombie in [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml), *Gaze-Based
    Control*, we'll cast a ray from the player's camera view to the ground plane to
    choose a move-to location.
  prefs: []
  type: TYPE_NORMAL
- en: In our script, we'll use button press to initiate the teleport and release to
    jump there if you've selected a valid location. Alternatively, you could consider
    other input such as a forward push of the thumbstick using `Input.GetAxis`(v*ertical*)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a teleport marker (similar to the WalkTarget one), as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an empty game object to the Hierarchy panel, and rename it `TeleportMarker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset its Transform values to position (`0`,`0`,`0`) (using the gear icon in
    the upper-right of the Transform pane).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the mouse and navigate to 3D Object | Cylinder. This will create
    a cylindrical object parented by `TeleportMarker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset its transform and change the Scale to (`0.4`, `0.05`, `0.4`). This will
    create a flat disk with a diameter of `0.4`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable or remove its Capsule Collider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For now, we'll use the default material. Or, you could decorate your marker
    with another material. (For example, if you have Steam `InteractionSystem` installed,
    try the `TeleportPointVisible` material. If you have Daydream Elements installed,
    try the `TeleportGlow` material.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write the script:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `MeMyselfEye` object in the Hierarchy panel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable or remove the `GlideLocomotion` component, if present
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Add Component | New Script and name it `LookTeleport`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The script works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When the player clicks, targeting begins, and the target marker is made visible
    (`SetActive(true)`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While targeting, we identify what the player is looking at (`Raycast`). And
    if it's the ground, we position the target there (`hit.point`). Otherwise, the
    target is reset to the player's position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the player stops pressing the button, the target is hidden. And we position
    the player to the target's current position, thus completing the teleportation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that we are using the `TeleportMarker` target to store the state of our
    teleport mechanic while in targeting mode. When the target is active, we're targeting.
    When we exit targeting, we use the target's position as the new player position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the script and in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the `GroundPlane` object onto the Ground slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `TeleportMarker` object onto the Target slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Play. Pressing the input button will activate the target marker, which
    moves as you look. On releasing the button, you teleport to that position. You
    can cancel the teleport by looking at something other than the ground and releasing
    the button.
  prefs: []
  type: TYPE_NORMAL
- en: Teleporting between surfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous script, we're using a plain Raycast to determine where to place
    the `TeleportMarker`. This really only works on Plane objects. For any other 3D
    object, the hit point might be any surface, not just the topside walkable one.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach is to use NavMesh to identify surfaces you can teleport
    to within the scene. Back in [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml),
    *Gaze-Based Control*, we generated a NavMesh for Ethan's `AIThirdPersonController`
    to control where he's allowed to roam. This time, we also use the NavMesh to determine
    where we (`MeMyselfEye`) can go. Feel free to go back and review our conversations
    about NavMesh.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this approach is the available teleportation locations can
    be a subset of the ground plane. There can be can be multiple other object surfaces
    and even complex terrains. The teleportation locations will be limited to valid
    flat or slightly sloped surfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you skipped that section, or if you''ve rearranged objects in your
    scene since then, we will regenerate the NavMesh now:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Navigation panel. If it's not already a tab in your editor, open
    the Navigation window from the main menu by navigating to Window | Navigation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select its Object tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Ground Plane in Hierarchy, then in the Navigation window's Object
    pane, check the Navigation Static checkbox. (Alternatively, you can use the object's
    Inspector window Static drop-down list.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat step 3 for each of the objects that should block your possible teleportation
    locations: the cubes, sphere, and so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For demonstration, we will now also add a second story platform:'
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, create a new 3D Cube and name it Overlook
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Scale to (`2.5`, `0.1`, `5`) and its Position to (`4`, `2.5`, `0.5`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Navigation window, select the Object tab and check Navigation Static
    for the overlook, then
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Bake tab and click on the Bake button at the bottom of the panel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that its height (Y Scale) of the platform is greater than Agent Height
    (2) in the Navigation Bake settings. This will ensure the player can go both beneath
    the platform and on top of it. In the Scene window, you can see the areas in blue
    defined by the NavMesh, shown next, including a nice lookout area on the second
    story platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6f1877b-cbad-4ccd-8ef3-1a22c5c9ce4e.png)'
  prefs: []
  type: TYPE_IMG
- en: We can now modify the script to find our teleport target position on the NavMesh
    rather than the ground plane. Unfortunately, Unity does not provide a `Raycast`
    function for directly finding a hit point on the NavMesh. Instead, we find a hit
    point, as usual, using Physics colliders (which may be on the side or bottom of
    an object, not just the walkable surface), and then call `NavMesh.SamplePosition`
    to find the hit point position on the NavMesh. Modify the `LookTeleport` script
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line at the top of your script to access the NavMesh API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, modify `Update()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The call to `NavMesh.SamplePosition` takes the `hit.point` and finds the closest
    point on the NavMesh, within a given radius (we gave 1.0).
  prefs: []
  type: TYPE_NORMAL
- en: Press Play. Now, you can set the `TeleportMarker` not only on the walkable surface
    of the `GroundPlane` but also on top of the Overlook!
  prefs: []
  type: TYPE_NORMAL
- en: 'One more thing. Doing a `Physics.Raycast` can get quite expensive, especially
    in scenes with a lot of objects. You can limit the Raycast search by providing
    a layer mask. For example, create a layer named `Teleport` and set this layer
    for both `GroundPlane` and Overlook game objects. Then, modify the Raycast call
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will limit our Raycast to just the surfaces overlaid by the NavMesh, namely
    the ground plane and overlook.
  prefs: []
  type: TYPE_NORMAL
- en: The next scenario we'll consider is not permitting free roaming at all, but
    setting up a limited set of teleportation locations.
  prefs: []
  type: TYPE_NORMAL
- en: Teleport spawn points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is very common in VR applications to limit teleportation to only specific
    predefined locations within the scene. In that case, you would not need any free-roaming
    glide locomotion or arbitrary teleportation targets. Instead, you can define the
    specific teleportation spawn points. Let's see how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a `TeleportSpawn` prefab to mark our locations:'
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, create a 3D Sphere and name it `TeleportSpawn`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset its transform (gear icon | Reset)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Scale to `0.4`, `0.4`, `0.4`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Position to something like (`2`, `0`, `3`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new layer named `TeleportSpawn` from Inspector | Layers | Add Layer
    and fill in the name in an empty slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `TeleportSpawn` object in Hierarchy again, and now set its layer
    (Layers | TeleportSpawn) to the one we just defined
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s quickly make a material:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Materials folder, right-click to Create a new Material and name it `Teleport
    Material`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Rendering Mode to Transparent
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Albedo color and give it a low alpha (such as 30) so it's translucent,
    such as our pale green (`70`, `230`, `70`, `30`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the material onto the `TeleportSpawn` object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For this exercise, we''ll replace the `LookTeleport` component on `MeMyselfEye`
    with a new `LookSpawnTeleport` one:'
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, select `MeMyselfEye`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable the `LookTeleport` component, if present
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Component | New Script and name it `LookSpawnTeleport`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the new script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `Update()` function does a Raycast to see if any of the spawn point objects
    is selected. If so, the object is highlighted (unhighlighting any previous ones).
    Then, if the `Fire1` button is pressed, it teleports the player to that location.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add a couple of private helper functions, `Highlight()` and `Unhighlight()`.
    The first highlights an object by modifying its material color, making it more
    opaque (alpha 0.8). Unhighlight restores the original color when you look away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, now let''s place a few of the markers around the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the `TeleportSpawn` object from Hierarchy to your `Prefabs` folder in the
    Project Assets
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate `TeleportSpawn` three times
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position one of them at (`0`, `0`, `-1.5`) (the default `MeMyselfEye` position)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the others to suitable locations, such as (`2`, `0`, `3`), (`-4`, `0`,
    `1`), and if you have the Overlook, (`3.5`, `2.5`, `0`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alright! Press Play. When you look at a spawn point, it highlights. When you
    press the `Fire1` button, you teleport to the location.
  prefs: []
  type: TYPE_NORMAL
- en: It may be useful to add a reticle (small cursor) at the center of your camera
    view to help focus the player's attention on the teleport objects, as we did in
    [Chapter 6](36d3f24b-8acf-42df-92cc-abb5147d4a1f.xhtml), *World Space UI,* under
    the topic *The reticle cursor*.
  prefs: []
  type: TYPE_NORMAL
- en: Although the teleport works, it may be nice if it also sets your view direction.
    One way to do this is to carefully place the `TeleportSpawn` objects facing the
    direction we want the player to face, and setting the player's transform rotation,
    in addition to position.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give a visual clue for the direction the spawn point is facing, we''ll add
    a graphic. We have included an image file, `flip-flops.png`, with this book. Otherwise,
    use anything that indicates a forward direction. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `flip-flops.png` texture by dragging it into your `Project Textures`
    folder (or navigating to Import New Asset...).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new material in the Material folder and name it `FlipFlops`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `flip-flops` texture onto the `FlipFlops` material's Albedo map and
    choose Rendering Mode as Cutout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `TeleportSpawn` object in Hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a child Quad object (right-click Create | 3D Object | Quad).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `FlipFlops` material onto the `Quad`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Quad's Transform Position to (`0`, `.01`, `0`) and its Rotation to (`90`, `0`, `0`)
    so that it lies flat on the ground plane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the parent `TeleportSpawn` object and in Inspector, press Apply to save
    these changes to the prefab. Now all the spawns will have feet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that for the one up on the Overlook, you can adjust its Quad so it's visible
    from below, such as Position (`0`, `-0.2`, `0`) and Rotation (`-90`, `0`, `180`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The modification to our script to apply the rotation is trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There it is, a gaze-based teleportation system with predefined spawn points,
    as shown here in the Scene window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e2f7fd4-7437-410a-9f78-5d726a596fe5.png)'
  prefs: []
  type: TYPE_IMG
- en: Other teleport considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's a lot more that can be said and done with teleportation. You may prefer
    to select the location using hand controllers rather than gaze. It is common to
    show the teleport pointer using an arced laser beam (using a Bezier curve). The
    teleport spawn point is often rendered using a glow or fiery effect. Many of these
    features have already been built and provided using higher-level VR toolkits (see
    next topic).
  prefs: []
  type: TYPE_NORMAL
- en: Blink teleport is a technique that does a fade-out fade-in between the change
    in player position. It is said to provide an additional degree of comfort. We
    won't show the code here, but there are several techniques for implementing fades
    for VR, such as creating a screen-space canvas that covers the entire camera with
    a black panel, and lerping its alpha channel as it fades (see [https://docs.unity3d.com/ScriptReference/Mathf.Lerp.html](https://docs.unity3d.com/ScriptReference/Mathf.Lerp.html)).
    Some have even found fading with a literal blink effect is quite natural, where
    you rapidly fade out from top to bottom, and fade in bottom to top, like an eyelid
    closing and opening.
  prefs: []
  type: TYPE_NORMAL
- en: Another technique is to provide a third-person view of the scene from above,
    sometimes called a **mini-map**, **god view***,* or **dollhouse view**. From this
    perspective, the player could point to a new location to teleport. This mini version
    of the scene could be an object the player uses as a tool in the main scene, or
    you transition to this view mode during the teleportation selection process.
  prefs: []
  type: TYPE_NORMAL
- en: You can also teleport to a different scene. Combined with the blink fade in/out,
    you call `SceneManager.LoadScene("OtherSceneName")` rather than simply changing
    the transform position. Note, you must add the other scene to the Build Settings
    Scenes to Build list (see [https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadScene.html](https://github.com/thestonefox/VRTK)).
  prefs: []
  type: TYPE_NORMAL
- en: Clever use of teleportation and the player's direction can lead to efficient
    use of limited play space and give the perception of the VR space being much larger
    than actually in real life. For example, in room-scale VR, if you have the player
    walk toward the edge of the play space and enter an elevator (teleport), she could
    be facing the back of the elevator going in and must turn around when the doors
    open on the new level and can now physically walk forward. In fact, infinite corridors
    and connected rooms could be implemented this way while maintaining player immersion.
  prefs: []
  type: TYPE_NORMAL
- en: Teleportation toolkits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have explored several different locomotion and teleportation mechanics. All
    of them use your gaze direction for selection. This is sometimes the best choice.
    Sometimes it's not. It certainly is the lowest common denominator between various
    VR devices, from high-end HTC VIVE and Oculus Rift to the low-end Google Cardboard,
    gaze-based selection with a simple click will always be available.
  prefs: []
  type: TYPE_NORMAL
- en: It is likely you will prefer to use the hand controller for selection. High-end
    systems include two positionally tracked controllers, one for each hand. Lower-end
    devices, such as Google Daydream, include a single 3DOF "laser pointer" controller. Another
    reason we avoided implementing with controllers so far is the coding varies greatly
    from one device to the next. Also, the device-specific toolkits often come with
    components and prefabs that implement this mechanic, optimized for their particular
    platform, including high-performance shaders for rendering arced laser beams and
    teleportation markers.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will show how to implement teleportation using these higher-level
    components, using SteamVR Interaction System and Google Daydream Elements. If
    you're not using one of these, please see the toolkits project with your target
    device, or consider a generalized toolkit such as the open source VRTK ([https://github.com/thestonefox/VRTK](https://github.com/thestonefox/VRTK)).
  prefs: []
  type: TYPE_NORMAL
- en: Teleporting with SteamVR Interaction System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SteamVR Interaction System we first introduced in [Chapter 5](21722631-9544-4b1e-a888-877d34b0fff7.xhtml),
    *Handy Interactables* includes easy to use teleport components. If you are using
    SteamVR SDK, it can be found in the `Assets/SteamVR/InteractionSystem/Teleport/` folder.
    The teleport tools include a lot of extras we didn't get a chance to implement
    ourselves, including materials, models, prefabs, scripts, shaders, sounds, textures,
    haptics, oh my!
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, the teleport toolkit includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Teleporting` prefab: Teleportation controller, add one per scene'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TeleportPoint` prefab:Locations you want to teleport to, add one for each
    location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TeleportArea` component: Add to a game object, such as a Plane, to allow teleporting
    anywhere on that area'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interaction System includes its own `Player` camera rig which replaces the
    default `[CameraRig]` we have been using, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the `Player` prefab in `SteamVR/InteractionSystem/Core/Prefabs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag it as a child of `MeMyselfEye` in your scene Hierarchy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete or disable the `[CameraRig]` object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a copy of `Teleporting` prefab from Project `Assets/SteamVR/InteractionSystem/Teleport/Prefabs` as
    a child of `MeMyselfEye` (this controller can actually go anywhere in the scene)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Player in Hierarchy, and drag its parent `MeMyselfEye` onto its Tracking
    Origin Transform slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This last step is important. The toolkit's teleportation components change the
    position of the `Player` object by default. We want to teleport the Player parent,
    `MeMyselfEye`, when we teleport. This might also be used if in your game, for
    example, the player is sitting in the cockpit of vehicle and you intend to teleport
    the whole vehicle, not just the Player itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you followed the projects earlier in this chapter, disable the things we
    won''t be using here:'
  prefs: []
  type: TYPE_NORMAL
- en: On `MyMyselfEye`, disable or remove the Look Teleport and Look Spawn Teleport
    components
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable or delete each of the `TeleportSpawn` objects
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, for each teleport location:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag a copy of the `TeleportPoint` prefab from Project `Assets/SteamVR/InteractionSystem/Teleport/Prefabs`
    into the Hierarchy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place one where you want in the scene. As previously, we used (`0`, `0`, `-1.5`),
    (`2`, `0`, `3`), (`-4`, `0`, `1`), and on the Overlook (`3.5`, `2.5`, `0`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s it! Press Play. The teleport points do not show until you press the
    button on your controller, then they glow, a dashed laser arc lets you choose
    one, and you go there. In the Game window shown here, I am teleporting to the
    Overlook location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a63a4c3-8a3a-4468-9af3-d3737417b404.png)'
  prefs: []
  type: TYPE_IMG
- en: Please review the many options on the Teleport component. You can modify or
    replace materials used for highlighting teleport points, sounds, and other effects.
    The Teleport Arc component has options for rendering the laser arc, and the `TeleportPoints`
    themselves can each be modified separately.
  prefs: []
  type: TYPE_NORMAL
- en: Teleporting with Daydream Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Google Daydream Elements package we first introduced in [Chapter 5](21722631-9544-4b1e-a888-877d34b0fff7.xhtml), *Handy
    Interactables* includes some teleport components. If you are targeting Google
    Daydream, you can install the separate Daydream Elements download from GitHub
    ([https://github.com/googlevr/daydream-elements/releases](https://github.com/googlevr/daydream-elements/releases)).
    And documentation can be found on the Elements site ([https://developers.google.com/vr/elements/teleportation](https://developers.google.com/vr/elements/teleportation)).
  prefs: []
  type: TYPE_NORMAL
- en: Once imported into your project, it can be found in the `Assets/DaydreamElements/Elements/Teleport/` folder.
    There is a demo scene, Teleport, and associated materials, models, prefabs, scripts,
    shaders, and textures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Out of the box, the tools are pretty generic and very customizable. The primary
    prefab is `TeleportController`, which does all the work. The user input used to
    trigger teleport behavior can be configured in the Unity Editor by filling the
    component slots, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0b48a82-4c23-4594-a210-38c2abd5ffa7.png)'
  prefs: []
  type: TYPE_IMG
- en: You can extend the teleporter by changing its *detector*, *visualizer*, and
    *transition* classes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Detector**: Such as the `ArcTeleportDetector` does a curved arc Raycast to
    find objects in the scene and limits the hit to horizontal surfaces with adequate
    space to "fit" the player, so you do not teleport into walls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visualizer**: Such as the `ArcTeleportVisualizer`, renders the arc when teleport
    is triggered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transition**: Such as `LinearTeleportTransition`, animates the player to
    the new location. This could be modified to implement a blink effect, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To add it to your scene:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the `TeleportController` prefab into your Hierarchy as child of Player
    (for us that `MeMyselfEye` | GVRCameraRig | Player)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset its Transform, if necessary
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `MeMyselfEye` object onto the `TeleportController` component's Player
    transform slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag `GvrControllerPointer` (or whichever controller game object you're using)
    onto the Controller transform slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Play and you can teleport all around your scene. There is no need to place
    specific teleport targets.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `TeleportController` will work by letting you land on any object
    in the scene that has a collider. You can limit the objects considered by the
    detector's Raycast by specifying the layer(s). Also, if you want arbitrarily shaped
    target areas that are not necessarily game objects in your scene, you can add
    sets of objects with just colliders, no renderers. This is how the teleport areas
    on the islands are implemented in the Daydream Elements teleport demo.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting center and position
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes in VR, the view presented in the headset is not quite in sync with
    your body's orientation. Device SDKs provide functions to reset the orientation
    of the headset with respect to the real-world space. This is often referred to
    as the **recentering** of the view.
  prefs: []
  type: TYPE_NORMAL
- en: Unity provides an API call that maps to the underlying device SDK to recenter
    the device, `UnityEngine.VR.InputTracking.Recenter()`. This function will center
    tracking to the current position and orientation of the HMD. It only works with
    seated and standing experiences. Room scale experiences are not affected.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of this writing, Recenter does not work in SteamVR, even for seated
    configuration. The solution is to call the following code instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The Daydream controller has reset built into the underlying system (press and
    hold the system button). This is because unwanted drift is so common on mobile
    VR devices. Also, for Cardboard (and Daydream users without a controller), there
    is a standard floor canvas menu you should include in your player rig (as we did
    in [Chapter 3](5f03c1ec-a1bc-4ec8-bf4b-dc7a4492aba4.xhtml), *VR Build and Run*),
    that includes a reset and recenter buttons.
  prefs: []
  type: TYPE_NORMAL
- en: On other systems, you can choose a button that triggers a call to `Recenter` as
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting room scale teleportation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned, the Unity Recenter function does not have any affect on room scale
    setups. We assume that room scale players are standing and mobilized, so they
    can just turn themselves to face "forward" within the VR scene.
  prefs: []
  type: TYPE_NORMAL
- en: When teleporting, however, we are moving the player to a new location, and possibly
    to an entirely different scene. When we reposition MyMyselfEye or any parent of
    the positionally tracked camera, the player is not necessary located at origin
    of that rig. If the player teleports to a new location, his whole play space should
    be ported and the player should end up standing on the virtual location he specifically
    chose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function will compensate the teleport transform to the player''s
    relative pose within the playspace. As written, it assumes it is a component on
    the MeMyselfEye player root object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To use it in our previous teleport script examples, replace the `transform.position
    = target.transform.position;` line with a call to `TeleportRoomscale( target.transform.position
    )` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Managing VR motion sickness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: VR motion sickness, or simulator sickness, is a real symptom and a concern for
    virtual reality. Researchers, psychologists, and technologists with a wide array
    of specializations and PhDs are studying the problem to better understand the
    underlying causes and find solutions.
  prefs: []
  type: TYPE_NORMAL
- en: A cause of VR motion sickness is a lag in screen updates, or latency, when you're
    moving your head. Your brain expects the world around you to change exactly in
    sync. Any perceptible delay can make you feel uncomfortable, to say the least.
  prefs: []
  type: TYPE_NORMAL
- en: Latency can be reduced by faster rendering of each frame, keeping to the recommended
    frames per second. Device manufacturers see this as their problem to solve, in
    both hardware and device driver software. GPU and chip manufacturers see it as
    a processor performance and throughput problem. We will undoubtedly see leaps
    and bounds of improvements over the coming years.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, as VR developers, we need to be aware of latency and other
    causes of VR motion sickness. Developers need to look at it like it's our problem
    too because ultimately, it comes down to performance and ergonomics. With an ongoing
    dichotomy of mobile VR versus desktop VR, there will always be upper bounds on
    the performance of devices that our players will be using. In [Chapter 13](c938e975-93f3-4435-9d99-9f76bbbd0a98.xhtml),
    *Optimizing for Performance and Comfort*, we dive into the technical details of
    the rendering pipeline and performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'But it''s not just technology. I can get nauseous riding a real-world roller
    coaster. So, why wouldn''t a VR one have a similar effect? Things to consider
    that help improve your players'' comfort and safety include game mechanics and
    user experience design such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Don''t move fast**: When moving or animating a first-person character, don''t
    move too fast. High-speed first-person shooter games that work on gaming consoles
    and desktop PCs may not work out so well in VR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Look forward**: When moving through a scene, if you''re looking to the side
    rather than straight ahead, you''re more likely to feel nauseous.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Don''t turn your head too fast**: Discourage users from turning their head
    quickly with the VR headset on. The latency in updating the HMD screen is aggravated
    by larger changes in the viewport in small time slices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Offer comfort mode**: When a scene requires you to quickly turn yourself
    a lot of times, provide a ratcheted rotation mechanism, also known as comfort
    mode, which lets you change the direction in which you look in larger increments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use fade or blink** cuts during teleportation and scene changes. When fading,
    go to a dark color, as white can be startling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use tunneling** or other techniques during locomotion. Reduce what is visible
    in the peripheral vision by masking the camera except what is just in front of
    you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use a third-person camera**: If you have high-speed action but you don''t
    necessarily intend to give the user a thrill ride, use a third-person camera view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stay grounded**: Provide visual cues that help the user stay grounded, such
    as horizon lines, nearby objects in your field of view, and relative fixed-position
    objects, such as dashboards and body parts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provide an option to recenter the view**: Mobile VR devices, in particular,
    are subject to drift and the need to be recentered on occasion. With wired VR
    devices, it helps you avoid getting tangled in HMD wires. As a safety issue, recentering
    your view relative to the real world may help you avoid hitting furniture and
    walls in the physical space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Don''t use cut scenes**: In traditional games (and movies), a technique that
    can be used to transition between levels is to show a 2D cutscene movie. This
    does not work in VR if the head motion detection is disabled. It breaks the immersion
    and can cause nausea. An alternative is to simply fade to black and then open
    the new scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimize rendering performance**: It behooves all VR developers to understand
    the underlying causes of latency-specifically rendering performance-and what you
    can do to optimize it, such as lowering the poly count and choosing lighting models
    carefully. Learn to use performance monitoring tools in order to keep the frames
    per second within the expected and acceptable limits. More on this will be discussed
    in [Chapter 10](df997d92-d63c-4701-9786-da7ba54082b6.xhtml), *Using All 360 Degrees*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encourage users to take breaks**: Alternatively, you can maybe just provide
    a puke-bag with your game! Or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored many different ways of moving around within your
    virtual environments. We started by examining Unity's components that support
    conventional third-person and first-person characters and quickly realized most
    of those capabilities are not too useful in VR. For instance, we don't want the
    app to bob our head up and down as we walk, and we don't necessarily want to go
    jumping off buildings either. Moving around is important, but player comfort is
    more so. You don't want to induce motion sickness.
  prefs: []
  type: TYPE_NORMAL
- en: Locomotion is moving smoothly and linearly across the scene, akin to walking.
    Using gaze-based mechanics, we implemented moving in the direction you're looking
    and used input buttons to start and stop. Then, we separated the locomotion from
    head direction, always moving "forward" and using a separate input (thumbpad)
    to change the angle our body is facing. With this *comfort mode*, you can locomote
    and still look around.
  prefs: []
  type: TYPE_NORMAL
- en: Jumping to a new location is called teleportation. We started again with a gaze-based
    mechanic, letting you select a teleport location where you're looking. We implemented
    a couple ways of constraining where you are allowed to teleport, using NavMesh
    and using teleport spawn points. Then, we looked at some teleportation toolkits,
    from SteamVR and Google Daydream, which provide a rich set of capabilities, as
    well as a juicy user experience that is not trivial to implement from scratch.
    If you're targeting a different platform, such as Oculus, there are similar tools.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter,we'll explore the Unity physics engine more and implement
    some interactive games.
  prefs: []
  type: TYPE_NORMAL
